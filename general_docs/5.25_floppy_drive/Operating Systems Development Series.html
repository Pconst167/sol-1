<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0049)http://www.brokenthorn.com/Resources/OSDev20.html -->
<html class=" udlssposk idc0_350 tmdsnjok"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><title>Operating Systems Development Series</title> 
<link href="./Operating Systems Development Series_files/reference.css" type="text/css" rel="stylesheet"> 
<meta content="MSHTML 6.00.6000.16441" name="GENERATOR"><meta http-equiv="origin-trial" content="AlK2UR5SkAlj8jjdEc9p3F3xuFYlF6LYjAML3EOqw1g26eCwWPjdmecULvBH5MVPoqKYrOfPhYVL71xAXI1IBQoAAAB8eyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiV2ViVmlld1hSZXF1ZXN0ZWRXaXRoRGVwcmVjYXRpb24iLCJleHBpcnkiOjE3NTgwNjcxOTksImlzU3ViZG9tYWluIjp0cnVlfQ=="><meta http-equiv="origin-trial" content="Amm8/NmvvQfhwCib6I7ZsmUxiSCfOxWxHayJwyU1r3gRIItzr7bNQid6O8ZYaE1GSQTa69WwhPC9flq/oYkRBwsAAACCeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiV2ViVmlld1hSZXF1ZXN0ZWRXaXRoRGVwcmVjYXRpb24iLCJleHBpcnkiOjE3NTgwNjcxOTksImlzU3ViZG9tYWluIjp0cnVlfQ=="><meta http-equiv="origin-trial" content="A9uiHDzQFAhqALUhTgTYJcz9XrGH2y0/9AORwCSapUO/f7Uh7ysIzyszNkuWDLqNYg8446Uj48XIstBW1qv/wAQAAACNeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiRmxlZGdlQmlkZGluZ0FuZEF1Y3Rpb25TZXJ2ZXIiLCJleHBpcnkiOjE3Mjc4MjcxOTksImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"><meta http-equiv="origin-trial" content="A9R+gkZL3TWq+Z7RJ2L0c7ZN7FZD5z4mHmVvjrPitg/EMz9P3j5d3W7Vw5ZR9jtJGmWKltM4BO3smNzpCgwYuwwAAACTeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiRmxlZGdlQmlkZGluZ0FuZEF1Y3Rpb25TZXJ2ZXIiLCJleHBpcnkiOjE3Mjc4MjcxOTksImlzU3ViZG9tYWluIjp0cnVlLCJpc1RoaXJkUGFydHkiOnRydWV9"></head> 
<body text="#000000" vlink="#666699" alink="#000000" link="#666699" bgcolor="#ffffff" leftmargin="0" background="./Operating Systems Development Series_files/watermark.gif" topmargin="0" marginheight="0" marginwidth="0"> 


<table border="0" cellpadding="0" cellspacing="0" width="100%"> 
<tbody><tr> 
     <td width="60%"> 
	<a href="http://www.brokenthorn.com/"><img src="./Operating Systems Development Series_files/5.png" border="0"></a> 
     </td> 
     <td width="40%"> 
 
        <div id="ad_main"> 
 
<script src="./Operating Systems Development Series_files/f.txt"></script><script src="./Operating Systems Development Series_files/f(1).txt"></script><script type="text/javascript"><!--
google_ad_client = "pub-9243579471203558";
google_ad_width = 468;
google_ad_height = 60;
google_ad_format = "468x60_as";
google_ad_type = "image";
google_ad_channel = "";
google_ui_features = "rc:6";
//-->
</script> 
<script type="text/javascript" src="./Operating Systems Development Series_files/f(2).txt"> 
</script><ins class="adsbygoogle adsbygoogle-noablate" data-ad-channel="" data-ad-client="pub-9243579471203558" data-ad-format="468x60_as" data-ad-height="60" data-ad-type="image" data-ad-width="468" data-adsbygoogle-status="done" style="display: inline-block; width: 468px; height: 60px;" data-ad-status="unfilled"><div id="aswift_0_host" style="border: none; height: 60px; width: 468px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;"><iframe id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;border:0;width:468px;height:60px;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" width="468" height="60" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allow="attribution-reporting; run-ad-auction" src="./Operating Systems Development Series_files/ads.html" data-google-container-id="a!1" tabindex="0" title="Advertisement" aria-label="Advertisement" data-load-complete="true"></iframe></div></ins> 
        </div> 
 
     </td> 
  </tr> 
</tbody></table> 

<table cellspacing="0" cellpadding="3" width="100%" border="0"> 
  <tbody> 
  <tr> 
    <td class="tblhdr">Operating Systems Development Series</td> 
</tr> 
  <tr> 
 
    <td align="middle" colspan="2"></td></tr></tbody></table> 
<table cellspacing="0" cellpadding="5" width="100%" border="0"> 
  <tbody> 
  <tr> 
    <td> 
 
<!-- Title --> 
 
      <center><span class="title">Operating Systems Development - FDC Programming</span> 
 
<br><span class="author">by Mike, 2009</span></center> 
 
 
      <p>This series is intended to demonstrate and teach operating system development from
	the ground up.</p> 
 
	<center><img src="./Operating Systems Development Series_files/Intel-D8272A.jpg" width="350px" height="200px"><br><i>8272A Floppy Disk Controller</i></center> 
 
	<h1>Introduction</h1> 
 
	Yey! Its finally time to work with the floppy drive! This chapter covers almost everything there
	is to know about the floppy drive and programming the floppy disk!
	<p> 
	Here is what is on the menu for this chapter:
 
	</p><ul> 
		<li>FDC and FDD History</li> 
		<li>Disk Layout</li> 
		<li>CHS, LBA</li> 
		<li>FDD Structure</li> 
		<li>FDC Hardware</li> 
		<li>Interfacing with the FDC</li> 
		<li>FDC registers and commands</li> 
	</ul> 
 
	<h1>History</h1> 
 
	The <b>Floppy Disk Controller (FDC)</b> is the controller that interfaces with the <b>Floppy Disk Drive (FDD)</b>.
	The PC useually uses a form of the <b>NEC ?PD765 FDC</b>. PS/2 useally uses a form of the <b>Intel 82077A</b> while
	the AT useally uses a form of the <b>Intel 82072A</b> microcontroller.
	<p> 
	The <b>Floppy disk drive (FDD)</b> is a device that is capable of reading and writing data to a <b>floppy disk</b>.
	</p><p> 
	In 1971, David L. Noble, hired by Alan Shugart, who was the IBM Direct Access Storage Product Manager, tried to develop
	a new storage tape format for their System/370 mainframes. IBM was looking to create something that is smaller and faster
	then tape drives when reloading the microcode for their <b>Initial Control Program Load (ICPL)</b>. Nobles team worked on
	a product under the code name "Minnow" called a "memory disk". It was a read only, 8 inch diskette, having the capacity
	of 80 kilobytes. It was commercially released in 1971 and shipped with all System/370 mainframes.
	</p><p> 
	When Alan Shugart left IBM and moved to Memorex, his team shipped the Memorex 650 in 1972, the first read/write floppy disk drive.
 
	</p><p> 
	Floppy disks were invented by IBM in 8 inch, 5 and 1/4 inch and 3 1/2 inch formats. 
 
	</p><h1>Disk Structure</h1> 
 
	<h2>Physical Layout</h2> 
 
	Understanding the disk structure is important. Here is the layout of a floppy disk:
 
	<p> 
	</p><center><img src="./Operating Systems Development Series_files/flpy.png"></center> 
	<p> 
	This is the physical layout of a generic 3-1/2" floppy disk. Here, we are looking at
	Head 1 (The front side), and the Sector represents 512 bytes. A Track is a collection of sectors.
 
	</p><p> 
	<b>Note: Remember that 1 sector is 512 bytes, and there are 18 sectors per track on floppy disks.</b> 
	</p><p> 
 Looking at the above picture, remember:
 
</p><ul> 
    <li>Each Track is useually divided into 512 byte sectors. On floppies, there are 18 sectors per track.</li> 
    <li>A Cylinder is a group of tracks with the same radius (The Red tracks in the picture above are one cylinder)</li> 
    <li>Floppy Disks have two heads (Displayed in the picture)</li> 
    <li>There is 2880 Sectors total.</li> 
</ul> 
	To better understand everything, we should have a look at <b>CHS</b>. Lets take a look at that next!
 
	<h2>Cylinder / Head / Sector (CHS)</h2> 
 
	<h3>Sectors</h3> 
 
A "Sector" simply represents a goupe of 512 bytes. So, Sector 1 represents the first 512 bytes of a disk. 
 
	<h3>Head</h3> 
 
A "Head" (or Face) represents the side of the disk. Head 0 is the front side, Head 1 is the back side. Most disks only have 1 side, hence only 1 head ("Head 1") 
 
	<h3>Track</h3> 
 
	A track is one ring around the disk. In the case of floppy disks, 18 sectors span a single track.
 
 
<p> 
The <b>Cylinder number represents a track number on a single disk</b>. In the case of a floppy disk, It represents the Track to read from.
 
</p><p> 
<b>There is 18 sectors per track. 80 tracks per side.</b> 
 
	</p><h3>Understanding CHS</h3> 
 
	The floppy disk addresses using CHS format. In order to read or write from any location on disk,
	we must tell the FDC to move the <b>Read/Write Head</b> to the exact track, cylinder, and sector
	on the disk to read or write to.
 
	<h3>Linear Block Addressing (LBA)</h3> 
 
 We can also provide a more abstract way of reading and writing
	to disks using <b>Linear Block Addressing (LBA)</b> instead. LBA allows us to be able to read or
	write to any sector on disk from sector 0-2880.
 
	<h1>Floppy Interfacing</h1> 
 
	Software interfaces with the floppy disk drive by controlling it through a floppy disk controller.
	Do to differences in floppy disk controllers, I would like to focus on the original 8272A Floppy
	Disk Controller. The image at the beginning of this chapter shows a typical 8272A Integrated Circuit (IC)
	controller. This is the IC that we will look at here.
 
	<h2>Detail: 82072A Floppy Microcontroller</h2> 
 
	The 8272A IC has 40 pins. Lets take a look at it here. While we will take a brief look at all 40 pins,
	we will not look at it in full detail here as that is when we cross into the electronics field.
 
	<p> 
	</p><center><img src="./Operating Systems Development Series_files/8272a.jpg"></center> 
	<p> 
	Most of these pins are not very useful for programming the controller. Other pins are more important
	to understand, however. Lets take a look. For completness sake, we will look at all of the pins brefily.
	You will see that the FDC indirectly communicates with both the <b>Programmable Interrupt Controller (PIC)</b>,
	the system bus, as well as the <b>Direct Memory Access</b> controller.
	</p><p> 
	</p><ul> 
	<li><b>RESET Pin</b> - places the FDC in an idle state. It drives all output lines low. The <b>Vcc</b> pin
	is a +5 V power input.</li> 
	<li><b>GND Pin</b> - is the ground pin.</li> 
	<li><b>CLK Pin</b> - typical Single Phase 8 MHz Squarewave clock signal.</li> 
	<li><b>RD Pin</b> - tells the FDC that the current operating is a read operation.</li> 
	<li><b>WR Pin</b> - is simular, but for a write operation.</li> 
	<ul> 
		<li> These are set by the <b>Control Bus</b> in an <b>I/O read/write</b> operation by software. </li> 
	</ul> 
	<li><b>CS Pin</b> - Chip Select</li> 
	<li><b>DB0 - DB7 Pins</b> - bidirectional 8 bit data bus. It connects indirectly to the systems primary <b>Data Bus</b>.</li> 
	<li><b>A0 Pin</b> - <b>Data/Status Register Select</b> pin. If it is high (1), it tells the FDC to place the contents
	in its <b>Data Register</b> to the data bus. If the line is low (0), it copies the contents of the <b>Status Register</b> 
	to the data bus. This is done through the output data bus pins DB0 - DB7, which in turn is through the systems data bus
	which can be read by software.
	</li><li><b>DRQ Pin</b> - <b>Data Direct Memory Access (DMA) Request</b> pin. <b>If this line is high (1), the FDC is making a DMA request.</b></li> 
	<li><b>DACK Pin</b> - <b>DMA Acknowledge</b> pin. When the controller is performing a DMA transfer, this line will
	be low (0).</li> 
	<li><b>TC Pin</b> - When the DMA transfer is completed, the FDC sets the <b>Terminal Count</b> pin, <n>TC to high (1).</n></li> 
	<li><b>IDX Pin</b> - high when the FDC is at the beginning of a disk track. </li> 
	<li><b>INT Pin</b> - is high (1) when the FDC sends an <b>Interrupt Request (IR)</b>. This line is indirecty connected to the <b>IR6</b> on the <b>Programmable
	Interrupt Controller (PIC)</b>.</li> 
	<li><b>RW/Seek Pin</b> - Sets seek mode of read/write mode. 1: Seek mode, 0: Read/Write mode.</li> 
	<li><b>LCT/DIR Pin</b> - <b>Low current/Direction</b> pin.</li> 
	<li><b>FR/STP Pin</b> - <b>Fault reset/Step</b> pin.</li> 
	<li><b>HDL Pin</b> - <b>Head Load</b> pin.Command causes the Read/Write head in the FDD to contact the diskette</li> 
	<li><b>RDY Pin</b> - <b>Ready</b> pin. Indicates that the FDD is ready to send or recieve data</li> 
	<li><b>WP/TS Pin</b> - <b>Write protect/Two side</b> pin. In Read/Write mode, set high if media is write protected.
	If seek mode, set high if media is two sided.</li> 
	<li><b>FLT/TRK0 Pin</b> - <b>Fault/Track 0</b> pin. In Read/Write mode, set high on a detected FDD fault.</li> 
	<li><b>PS0 - PS2 Pins</b> - <b>Precompensation (Pre-shift)</b> pins. Write precompensation status during <b>MFM</b> mode.</li> 
	<li><b>WR DATA Pin</b> - Write data pin</li> 
	<li><b>RD DATA Pin</b> - Read data pin</li> 
	<li><b>DS0 - DS1 Pins</b> - Drive select pins</li> 
	<li><b>HDSEL Pin</b> - <b>Head Select Pin.</b> When high (1), the FDC sets the FDD to access Head 1. When low, it is head 0.</li> 
	<li><b>MFM Pin</b> - When high, FDC is in <b>MFM</b> mode. If low (0), it operates in <b>FM</b> mode.</li> 
	<li><b>WE Pin</b> - <b>Write enable pin.</b></li> 
	<li><b>VCO Pin</b> - <b>VCO Sync pin.</b> When 0, inhibits <b>VCO</b> in <b>PLL</b>. When 1, enables <b>VCO</b>.</li> 
	<li><b>DW Pin</b> - Data Window pin. Generated by PLL, used for sample data from the FDD.</li> 
	<li><b>WR CLK Pin</b> - Write Clock</li> 
	</ul> 
	The FDC can operate with or without a <b>Direct Memory Access (DMA) controller</b>. If it is operating in a non DMA mode,
	it will generate <b>IRQ 6</b> for every transfer of a data byte between the processor and the FDC. In DMA
	mode, the processor will load a command into the FDC and all data transfers will occur under control
	of the FDC and DMA controllers.
 
	<p> 
	This is important! You do not need to know all of the FDC pins. Rather, just remember that the <b>FDC
	communicates with three primary controllers.</b> The first is one of possibly four <b>Floppy Disk Drives (FDD)</b> 
	internal controllers, the <b>programmable interrupt controller (PIC)</b>, and the <b>Direct Memory Access (DMA) controller</b>.
	Software communicates with the FDC by the processors standard <b>IN/OUT</b> port i/o instructions.
 
	</p><p>Several registers in the
	FDC are mapped into the processors i/o address space. As with standard I/O port reads, during an in and out operation,
	the processor sets the READ or WRITE line on the control bus, and the port address on the address bus. This is done on
	the <b>system bus</b> or the <b>Industry Standard Architecture (ISA)</b> bus.
	</p><p> 
	On newer hardware, the FDC is not directly connected to the ISA bus, but is rather integrated as a Super I/O IC
	and communicates with the processor through the Super I/O's <b>Low Pin Count</b> bus.
	</p><p> 
	Okay! We know how the software can communicate with the FDC. Where does the PIC and DMA come into play?
	</p><p> 
	Looking at the pin listing above, we can see that the FDC has a pin called <b>INT</b>. This line is indirectly
	connected to the <b>Programmable Interrupt Controller IR 6</b> line. The FDC will pull this line high (1)
	whenever a byte of data is ready to be read or written. This also pulls the PIC IR 6 line high. From here,
	the PIC takes control. It masks out the other lines and determins if it can be services. It notifies the processor
	of an interrupt by activating the processors <b>Interrupt Acknowledge (INTA)</b> pin. After the processor verifies
	that it is safe to service the interrupt, it resets the INTA line to ackowledge the PIC to proceed. The PIC places
	the interrupt vector that this IRQ is mapped to use (set up during initializing the PIC). The processor takes
	the IRQ, gets its address from the idtr, and voila - our interrupt is called.
	</p><p> 
	The FDC can also be programmed to operate in DMA mode. The DMA is a controller that we have not looked at yet.
	Because of this, I do not want to get too involved with it. However we may go over it in the next chapter for
	completness. <b>The FDC is connected to DMA channel 2</b>.
 
	</p><p> 
	</p><center><img src="./Operating Systems Development Series_files/Fdcinpc.jpg"></center> 
	<p> 
	Thats all there is to it for the FDC hardware. <b>Their can be multiple FDCs inside of a computer system.
	Each FDC can connect up to 4 Floppy Disk Drives (FDDs). This is important!</b> Alot of times when communicating
	with a FDC, you have to select which FDD that the request is for.
 
	</p><h2>Floppy Interface Cable</h2> 
 
	The FDC communicates with a FDD through a <b>Floppy Interface Cable</b>, which is a form of a
	<b>Parallel ATA (PATA)</b> cable also known as an <b>Integrated Drive Electronics (IDE)</b> cable
	which evolved from <b>Western Digital</b>.
 
	<p> 
	</p><center><img src="./Operating Systems Development Series_files/fddcable.jpg"></center> 
	<p> 
 
	You should notice a twist in the above cable. That will be described a little shortley. This cable
	has 40 pins. Through these 40 pins, the FDC can talk to different FDD's that are connected to the
	cable.
	</p><p> 
	Some registers that are used to communicate with the FDC allow you to detect the input pins of
	the controller and the cable. Because of this, we should probably at least take a small glance
	at the 40 lines of the cable.
 
	</p><p> 
	</p><center> 
	<table border="1"> 
	<tbody><tr><th bgcolor="#aaaaaa" colspan="4">Floppy Interface Cable Pins</th> 
	</tr><tr bgcolor="#cccccc"><td>Pin</td><td>Description</td><td>Pin</td><td>Descripton</td></tr> 
	<tr><td bgcolor="#cccccc">0</td><td>Reset</td><td bgcolor="#cccccc">20</td><td>DDRQ</td></tr> 
	<tr><td bgcolor="#cccccc">1</td><td>Ground</td><td bgcolor="#cccccc">21</td><td>Ground</td></tr> 
	<tr><td bgcolor="#cccccc">2</td><td>Data pin 7</td><td bgcolor="#cccccc">22</td><td>I/O Write</td></tr> 
	<tr><td bgcolor="#cccccc">3</td><td>Data pin 8</td><td bgcolor="#cccccc">23</td><td>Ground</td></tr> 
	<tr><td bgcolor="#cccccc">4</td><td>Data pin 6</td><td bgcolor="#cccccc">24</td><td>I/O Read</td></tr> 
	<tr><td bgcolor="#cccccc">5</td><td>Data pin 9</td><td bgcolor="#cccccc">25</td><td>Ground</td></tr> 
	<tr><td bgcolor="#cccccc">6</td><td>Data pin 5</td><td bgcolor="#cccccc">26</td><td>IOCHRDY</td></tr> 
	<tr><td bgcolor="#cccccc">7</td><td>Data pin 10</td><td bgcolor="#cccccc">27</td><td>Cable Select (CS)</td></tr> 
	<tr><td bgcolor="#cccccc">8</td><td>Data pin 4</td><td bgcolor="#cccccc">28</td><td>DDACK</td></tr> 
	<tr><td bgcolor="#cccccc">9</td><td>Data pin 11</td><td bgcolor="#cccccc">29</td><td>Ground</td></tr> 
	<tr><td bgcolor="#cccccc">10</td><td>Data pin 3</td><td bgcolor="#cccccc">30</td><td>Interrupt</td></tr> 
	<tr><td bgcolor="#cccccc">11</td><td>Data pin 12</td><td bgcolor="#cccccc">31</td><td>(No connection)</td></tr> 
	<tr><td bgcolor="#cccccc">12</td><td>Data pin 2</td><td bgcolor="#cccccc">32</td><td>Address 1</td></tr> 
	<tr><td bgcolor="#cccccc">13</td><td>Data pin 13</td><td bgcolor="#cccccc">33</td><td>GPIO_DMA66_Detect</td></tr> 
	<tr><td bgcolor="#cccccc">14</td><td>Data pin 1</td><td bgcolor="#cccccc">34</td><td>Address 0</td></tr> 
	<tr><td bgcolor="#cccccc">15</td><td>Data pin 14</td><td bgcolor="#cccccc">35</td><td>Address 2</td></tr> 
	<tr><td bgcolor="#cccccc">16</td><td>Data pin 0</td><td bgcolor="#cccccc">36</td><td>Chip Select 1</td></tr> 
	<tr><td bgcolor="#cccccc">17</td><td>Data pin 15</td><td bgcolor="#cccccc">37</td><td>Chip Select 3</td></tr> 
	<tr><td bgcolor="#cccccc">18</td><td>Ground</td><td bgcolor="#cccccc">38</td><td>Activity</td></tr> 
	<tr><td bgcolor="#cccccc">19</td><td>Key or Vcc_in</td><td bgcolor="#cccccc">39</td><td>Ground</td></tr> 
	</tbody></table> 
	</center><p> 
 
	- More to be added later -
 
	</p><h1>FDC Programming</h1> 
 
	<h2>FDC Operating Modes</h2> 
 
	Most FDC's these days are more advanced then the original 8272 microcontroller. To acheive backward
	compatability, newer FDC's add additional pins to the controller and allow different registers to
	be communicated with when operating in a specific mode. For example, the <b>Status Register A</b> 
	mode is only accesable when the controller is running in <b>PC-AT</b> mode. Upon controller reset,
	the controller operates in the default <b>82077A</b> mode.
 
	<h2>Waiting for an IRQ</h2> 
 
	Remember that the FDC uses IRQ 6? The FDC will send a byte after the completion of a read or write
	command, or, depending on its mode, for every byte transferred. It will also send an IRQ when
	the controller is reset during initialization.
	<p> 
	For our purposes, we will be operating the FDC in a DMA mode. Basically what this means is that
	we will only be getting an interrupt whenever a read, write, seek, or calibrate command completes
	as well as during initialization.
	</p><p> 
	In all cases, however, this means that we will need to wait for an IRQ to fire so we know the
	command completes. A way for us to do this is to have the IRQ set a global when it fires, and
	provide an irq_wait like function that waits for the IRQ, and resets the global when it fires.
	</p><p> 
	Lets do that now. First the IRQ:
 
</p><blockquote><pre><div class="code">const int FLOPPY_IRQ = 6;
 
//! set when IRQ fires
static volatile uint8_t _FloppyDiskIRQ = 0;
 
void _cdecl i86_flpy_irq () {
 
	_asm add esp, 12
	_asm pushad
	_asm cli
 
	//! irq fired
	_FloppyDiskIRQ = 1;
 
	//! tell hal we are done
	interruptdone( FLOPPY_IRQ );
 
	_asm sti
	_asm popad
	_asm iretd
}</div></pre></blockquote> 
 
	This looks as simple as the IRQ in the PIT, doesnt it? :) Oh, right, and now we wait:
 
<blockquote><pre><div class="code">//! wait for irq to fire
inline void flpydsk_wait_irq () {
 
	//! wait for irq to fire
	while ( _FloppyDiskIRQ == 0)
		;
	_FloppyDiskIRQ = 0;
}</div></pre></blockquote> 
 
	Simple enough. So, assuming we send a command, like a read or write command, just call <b>flpydsk_wait_irq()</b>.
	When it completes, you know the command finished and its safe to continue. Cool, huh? ;)
 
	<h2>DMA?</h2> 
 
	What? We are programming the FDC in DMA mode? But we have not covered the DMA yet! Yes, yes indeed
	this poses a problem.
	<p> 
	I was originally going to program the FDC in Non-DMA mode. However, while this might work in some cases,
	alot of emulators and even some hardware do not support it anymore. Because of this, to retain portability,
	I decided that the best bet is to stick with using the DMA (<b>Direct Memory Access Controller [DMAC])</b>.
	</p><p> 
	However, because we have not covered the DMA yet in detail, we run into a problem. I figure, rather then
	throwing a whole DMA interface to you without explination, we can just hack together three basic DMA
	routines and rewrite them more throughley later ;)
	</p><p> 
	<b>flpydsk_initialize_dma</b> basically creates a buffer for the DMA to use at physical address 0x1000 - 0x10000 (64k).
	When we read a sector from disk, the DMA will put the sector data to this location so please be sure that nothing
	is there as it will be overwritten. You can choose another location if you like, however there are some rules:
 
	</p><ul> 
		<li>The buffer cannot cross 64k boundaries. It should stay at a 64k boundery for best performance</li> 
		<li>The area of memory it writes to must be idenitity mapped or its frame address mapped to a page. The DMA <b>always</b> works with physical memory</li> 
	</ul> 
 
	The demo uses 0x1000 + 64k for the buffer so you should keep it there if you dont feel confortable changing it.
 
	<p> 
	<b>dma_read</b> and <b>dma_write</b> just tells the DMA to start reading or writing the data that the FDC
	sends it. This will be the sector that we tell the FDC to read or write. For example, if we tell the FDC
	to read a sector, it will give the sector data to the DMA to be placed in the buffer that we set it to (which
	is at 0x1000). Cool, huh?
 
</p><blockquote><pre><div class="code">//! initialize DMA to use phys addr 1k-64k
void flpydsk_initialize_dma () {
 
	outportb (0x0a,0x06);	//mask dma channel 2
	outportb (0xd8,0xff);	//reset master flip-flop
	outportb (0x04, 0);     //address=0x1000 
	outportb (0x04, 0x10);
	outportb (0xd8, 0xff);  //reset master flip-flop
	outportb (0x05, 0xff);  //count to 0x23ff (number of bytes in a 3.5" floppy disk track)
	outportb (0x05, 0x23);
	outportb (0x80, 0);     //external page register = 0
	outportb (0x0a, 0x02);  //unmask dma channel 2
}
 
//! prepare the DMA for read transfer
void flpydsk_dma_read () {
 
	outportb (0x0a, 0x06); //mask dma channel 2
	outportb (0x0b, 0x56); //single transfer, address increment, autoinit, read, channel 2
	outportb (0x0a, 0x02); //unmask dma channel 2
}
 
//! prepare the DMA for write transfer
void flpydsk_dma_write () {
 
	outportb (0x0a, 0x06); //mask dma channel 2
	outportb (0x0b, 0x5a); //single transfer, address increment, autoinit, write, channel 2
	outportb (0x0a, 0x02); //unmask dma channel 2
}</div></pre></blockquote> 
 
	If you dont understand the above code, dont worry. Everything reguarding the DMA will be
	rewritten and explained in the next tutorial when we cover the DMA in more detail.
 
	<h2>FDC Port mapping</h2> 
 
	The FDC has four external registers that are mapped into the i86 I/O address space. These can be
	accessed by software through standard I/O instructions. I <b>bolded</b> these registers.
	<p> 
	Some systems may provide more external registers to their FDC's then the primary four.
	</p><p> 
	The second FDC is typically mapped to I/O ports 0x370 - 0x377.
	</p><p> 
	Because there are two sets of ports for two different FDC's, this table will include both
	port sets.
 
	</p><p> 
	</p><center> 
	<table border="1"> 
	<tbody><tr><th bgcolor="#aaaaaa" colspan="4">Floppy Disk Controller Ports</th> 
	</tr><tr bgcolor="#cccccc"><td>Port (FDC 0)</td><td>Port (FDC 1)</td><td>Read/Write</td><td>Descripton</td></tr> 
	<tr><td bgcolor="#aaaaaa" colspan="4"><center>Primary FDC Registers</center></td></tr> 
	<tr><td bgcolor="#cccccc">0x3F2</td><td bgcolor="#cccccc">0x372</td><td>Write Only</td><td>Digital Output Register (DOR)</td></tr> 
	<tr><td bgcolor="#cccccc">0x3F4</td><td bgcolor="#cccccc">0x374</td><td>Read Only</td><td>Main Status Register (MSR)</td></tr> 
	<tr><td bgcolor="#cccccc">0x3F5</td><td bgcolor="#cccccc">0x375</td><td>Read / Write</td><td>Data Register</td></tr> 
	<tr><td bgcolor="#cccccc">0x3F7</td><td bgcolor="#cccccc">0x377</td><td>Read Only</td><td>AT only. Configuation Control Register (CCR)</td></tr> 
	<tr><td bgcolor="#cccccc">0x3F7</td><td bgcolor="#cccccc">0x377</td><td>Write Only</td><td>AT only. Digital Input Register (DIR)</td></tr> 
	<tr><td bgcolor="#aaaaaa" colspan="4"><center>Other FDC Registers</center></td></tr> 
	<tr><td bgcolor="#cccccc">0x3F0</td><td bgcolor="#cccccc">0x370</td><td>Read Only</td><td>PS/2 only. Status Register A (SRA)</td></tr> 
	<tr><td bgcolor="#cccccc">0x3F1</td><td bgcolor="#cccccc">0x371</td><td>Read Only</td><td>PS/2 only. Status Register B (SRB)</td></tr> 
	<tr><td bgcolor="#cccccc">0x3F4</td><td bgcolor="#cccccc">0x374</td><td>Write Only</td><td>PS/2 only. Data Rate Select Register (DSR)</td></tr> 
 
	</tbody></table> 
	</center><p> 
 
	We will take a look at the registers closer - bit by bit - in the next section. Well, the important ones anyways.
	I may decide to update this chapter covering the other registers for completness purposes, though. For now, we
	will only focus on the first four registers shown above.
	</p><p> 
	<b>Remember that all of this code is in the demo at the end of this chapter</b>.
 
     </p><blockquote><pre><div class="code">enum FLPYDSK_IO {
 
	FLPYDSK_DOR		=	0x3f2,
	FLPYDSK_MSR		=	0x3f4,
	FLPYDSK_FIFO		=	0x3f5,	//data register
	FLPYDSK_CTRL		=	0x3f7
};</div></pre></blockquote> 
 
	<h2>Registers</h2> 
 
	<h3>Status Register A (SRA) (PS2 Mode Only)</h3> 
 
	<b>You do not need to know this register. It is here for completness only.</b> 
	<p> 
	This is a read only register that monitors the state of several interface pins on the controller.
	It is not accessable when the controller is in PC-AT Mode. This is a read only register.
	</p><p> 
	The exact format of this register may depend on the model of the controller.
 
	</p><ul> 
		<li><b>Bit 0</b> DIR</li> 
		<li><b>Bit 1</b> WP</li> 
		<li><b>Bit 2</b> INDX</li> 
		<li><b>Bit 3</b> HDSEL</li> 
		<li><b>Bit 4</b> TRKO</li> 
		<li><b>Bit 5</b> STEP Flip/Flop</li> 
		<li><b>Bit 6</b> DRV2</li> 
		<li><b>Bit 7</b> INTERRUPT line state (interrupt pending)</li> 
	</ul> 
	<b>Warning: These bits can change between controller models.</b> 
	<p> 
	Do not worry if this register seems complex; it can be without experience in electronics. It is here
	for completeness only and will not be used in the series.
 
	</p><h3>Status Register B (SRB) (PS/2 Mode Only)</h3> 
 
	<b>You do not need to know this register. It is here for completness only.</b> 
	<p> 
 
	Simular to the above register, this allows us to monitor the state of several lines of the FDC.
	It is not accessable when the FDC is in PC-AT Mode. This is a read only register.
 
	</p><ul> 
		<li><b>Bit 0</b> MOT EN0 (Motor Enable 0)</li> 
		<li><b>Bit 1</b> MOT EN1 (Motor Enable 1)</li> 
		<li><b>Bit 2</b> WE Flip/Flop</li> 
		<li><b>Bit 3</b> Read Data (RDDATA) Flip/Flop</li> 
		<li><b>Bit 4</b> Write Data (WRDATA) Flip/Flop</li> 
		<li><b>Bit 5</b> Drive Select 0</li> 
		<li><b>Bit 6</b> Undefined; Always 1</li> 
		<li><b>Bit 7</b> Undefined; Always 1</li> 
	</ul> 
	<b>Warning: These bits can change between controller models.</b> 
	<p> 
	Do not worry if this register seems complex; it can be without experience in electronics. It is here
	for completeness only and will not be used in the series.
 
	</p><h3>Data Rate Select Register (DSR)</h3> 
 
	<b>You do not need to know this register. It is here for completness only.</b> 
	<p> 
	This is a write only register that allow you to change the timings of the drive control signals. It is used
	by writing to I/O port 0x3f4 (FDC 0) or 0x374 (FDC 1).
	</p><p> 
	This is an 8 bit register. It has the following format:
 
	</p><ul> 
		<li><b>Bit 0</b> DRATE SEL0</li> 
		<li><b>Bit 1</b> DRATE SEL1</li> 
		<li><b>Bit 2</b> PRE-COMP 0</li> 
		<li><b>Bit 3</b> PRE-COMP 1</li> 
		<li><b>Bit 4</b> PRE-COMP 2</li> 
		<li><b>Bit 5</b> Must be 0</li> 
		<li><b>Bit 6</b> POWER DOWN: Deactivates internal clocks and shuts off the internal oscillator</li> 
		<li><b>Bit 7</b> S/W RESET: Reset the internal oscillator</li> 
	</ul> 
	<p> 
	<b>PRE-COMP 0 - PRE-COMP 2</b> are a little complex. These adjusts the <b>WRDATA</b> output pins
	for the <b>bit shifting</b> that can occur on magnetic media, such as floppy drives. To adjust the
	precompensation delay, we can set these bits to one of the following:
 
	</p><ul> 
		<li><b>000</b> Default (250-500 Kbps, 125 ns. 1 Mbps, 41.67 ns)</li> 
		<li><b>110</b> 250 ns</li> 
		<li><b>101</b> 208.33 ns</li> 
		<li><b>100</b> 166.67 ns</li> 
		<li><b>011</b> 125 ns</li> 
		<li><b>010</b> 83.34 ns</li> 
		<li><b>001</b> 41.67 ns</li> 
		<li><b>111</b> Disabled</li> 
	</ul> 
 
	<p> 
	<b>DRATE SEL0 - DERATE SEL 1</b> are used to set the data rate. Valid values are shown below.
 
	</p><ul> 
		<li><b>00</b> 500 Kbps</li> 
		<li><b>10</b> 250 Kbps</li> 
		<li><b>01</b> 300 Kbps</li> 
		<li><b>11</b> 1 Mbps</li> 
	</ul> 
	<b>Warning: Setting Data Rates greater then drive can handle may cause errors.</b> 
 
	<h3>Digital Output Register (DOR)</h3> 
 
	Yey! The first useful register! <b>This one is important to know</b>.
	<p> 
	This is a <b>write only</b> register that allows you to control different functions of the FDC,
	such as the FDD motor control, operation mode (DMA and IRQ), reset, and drive. It has the format:
 
	</p><ul> 
		<li><b>Bits 0-1</b> DR1, DR2</li> 
		<ul> 
			<li>00 - Drive 0</li> 
			<li>01 - Drive 1</li> 
			<li>10 - Drive 2</li> 
			<li>11 - Drive 3</li> 
		</ul> 
		<li><b>Bit 2</b> REST</li> 
		<ul> 
			<li>0 - Reset controller</li> 
			<li>1 - Controller enabled</li> 
		</ul> 
		<li><b>Bit 3</b> Mode</li> 
		<ul> 
			<li>0 - IRQ channel</li> 
			<li>1 - DMA mode</li> 
		</ul> 
		<li><b>Bits 4 - 7</b> Motor Control (Drives 0 - 3)</li> 
		<ul> 
			<li>0 - Stop Motor for drive</li> 
			<li>1 - Start Motor for drive</li> 
		</ul> 
	</ul> 
 
	This is an easy one! Basically when sending a command to control the functionality of the FDC,
	just build up a bit pattern to select what drive this is for (Remember that a single FDC can communicate
	with four FDD's!), the controller reset status, mode of operation (Remeber that the FDC can operate
	in both DMA and IRQ modes?) and the status of that particular FDD internal motor.
	<p> 
	Here is an example. Lets say we want to start up the motor for the first floppy drive (FDD 0). <b>Starting
	the motor for the FDD is needed before performing any read or write operations to it!</b> To start it,
	just set the bit (4-7) that corrosponds to the drive you want to start or stop the motor. Keeping
	all other bits at 0 will be a normal operation (IRQ mode, reset controller.) Knowing that the DOR is mapped
	to the processors i/o address space at port 0x3f2, this becomes very simple.
 
	First, we will create bit masks for the register to increase readability. Rememeber that all of this code
	is also in the demo at the end of this tutorial.
 
     </p><blockquote><pre><div class="code">enum FLPYDSK_DOR_MASK {
 
	FLPYDSK_DOR_MASK_DRIVE0			=	0,	//00000000	= here for completeness sake
	FLPYDSK_DOR_MASK_DRIVE1			=	1,	//00000001
	FLPYDSK_DOR_MASK_DRIVE2			=	2,	//00000010
	FLPYDSK_DOR_MASK_DRIVE3			=	3,	//00000011
	FLPYDSK_DOR_MASK_RESET			=	4,	//00000100
	FLPYDSK_DOR_MASK_DMA			=	8,	//00001000
	FLPYDSK_DOR_MASK_DRIVE0_MOTOR		=	16,	//00010000
	FLPYDSK_DOR_MASK_DRIVE1_MOTOR		=	32,	//00100000
	FLPYDSK_DOR_MASK_DRIVE2_MOTOR		=	64,	//01000000
	FLPYDSK_DOR_MASK_DRIVE3_MOTOR		=	128	//10000000
};</div></pre></blockquote> 
 
	Using the above bit masks, we can just bitwise OR the different bits that we would like to set. So,
	to start the motor for floppy drive 0:
 
 <blockquote><pre><div class="code">outportb (FLPYDSK_DOR, FLPYDSK_DOR_MASK_DRIVE0_MOTOR | FLPYDSK_DOR_MASK_RESET);</div></pre></blockquote> 
 
	Remember that FLPYDSK_DOR was defined ealier as 0x3f2, which is the i/o address of the DOR FDC register. The above also resets
	the controller.
 
	<p> 
	To turn this same motor off, just send the same command but without the motor bit set:
 
 </p><blockquote><pre><div class="code">outportb (FLPYDSK_DOR, FLPYDSK_DOR_MASK_RESET);</div></pre></blockquote> 
 
	<p> 
	<b>Warning: Give the motor some time to start up!</b> Remember that the internal FDD motor is mechanical.
	Like all mechanical devices, they tend to be slower then the speed of the running software. Because of this,
	whenever starting up a FDD motor, always give it a little time to spin up before attempting to read or write to it.
 
	</p><p> 
	The DOR is a write only register. To inforce this, lets create a routine for it:
 
 </p><blockquote><pre><div class="code">void flpydsk_write_dor (uint8_t val ) {
 
	//! write the digital output register
	outportb (FLPYDSK_DOR, val);
}</div></pre></blockquote> 
 
	Lets move on to the next important register!
 
	<h3>Main Status Register (MSR)</h3> 
 
	The <b>Main Status Register (MSR)</b> follows a *gasp!* specific bit format! Bet you did not see that one coming! Okay, okay,
	lets get back on track here (pun intended). Here is the format of the MSR:
 
	<ul> 
		<li><b>Bit 0</b> - FDD 0: 1 if FDD is busy in seek mode</li> 
		<li><b>Bit 1</b> - FDD 1: 1 if FDD is busy in seek mode</li> 
		<li><b>Bit 2</b> - FDD 2: 1 if FDD is busy in seek mode</li> 
		<li><b>Bit 3</b> - FDD 3: 1 if FDD is busy in seek mode</li> 
		<ul> 
			<li>0: The selected FDD is not busy</li> 
			<li>1: The selected FDD is busy</li> 
		</ul> 
		<li><b>Bit 4</b> - FDC Busy; Read or Write command in progress</li> 
		<ul> 
			<li>0: Not busy</li> 
			<li>1: Busy</li> 
		</ul> 
		<li><b>Bit 5</b> - FDC in Non DMA mode</li> 
		<ul> 
			<li>0: FDC in DMA mode</li> 
			<li>1: FDC not in DMA mode</li> 
		</ul> 
		<li><b>Bit 6</b> - DIO: direction of data transfer between the FDC IC and the CPU</li> 
		<ul> 
			<li>0: FDC expecting data from CPU</li> 
			<li>1: FDC has data for CPU</li> 
		</ul> 
		<li><b>Bit 7</b> - RQM: Data register is ready for data transfer</li> 
		<ul> 
			<li>0: Data register not ready</li> 
			<li>1: Data register ready</li> 
		</ul> 
	</ul> 
	This MSR is a simple one. It containes the current status information for the FDC and disk drives.
	Before sending a command or reading from the FDD, we will need to always check the current status
	of the FDC to insure it is ready.
	<p> 
	Here is an example of reading from this MSR to see if its busy. We first define the bit masks
	that will be used in the code. Notice how it follows the format shown above.
 
 </p><blockquote><pre><div class="code">enum FLPYDSK_MSR_MASK {
 
	FLPYDSK_MSR_MASK_DRIVE1_POS_MODE	=	1,	//00000001
	FLPYDSK_MSR_MASK_DRIVE2_POS_MODE	=	2,	//00000010
	FLPYDSK_MSR_MASK_DRIVE3_POS_MODE	=	4,	//00000100
	FLPYDSK_MSR_MASK_DRIVE4_POS_MODE	=	8,	//00001000
	FLPYDSK_MSR_MASK_BUSY			=	16,	//00010000
	FLPYDSK_MSR_MASK_DMA			=	32,	//00100000
	FLPYDSK_MSR_MASK_DATAIO			=	64, 	//01000000
	FLPYDSK_MSR_MASK_DATAREG		=	128	//10000000
};</div></pre></blockquote> 
 
Easy, huh? So lets test if the FDC is busy (BUSY flag is set.) Knowing that FLPYDSR_MSR is 0x3f4, the i/o port
address for the MSR, all we need to do is this:
 
<blockquote><pre><div class="code">if ( inportb (FLPYDSK_MSR) &amp; FLPYDSK_MSR_MASK_BUSY )
	//! FDC is busy</div></pre></blockquote> 
 
When sending a read or write command, all we need to do is wait until this bit is 0. Cool, huh?
<p> 
To make readability easier, I decided to hide this in a routine so here it is. This routine just returns
the status of the FDC.
 
</p><blockquote><pre><div class="code">uint8_t flpydsk_read_status () {
 
	//! just return main status register
	return inportb (FLPYDSK_MSR);
}</div></pre></blockquote> 
 
	<h3>Tape Drive Register (TDR)</h3> 
 
	<b>You do not need to know this register. It is here for completness only.</b> 
	<p> 
 
	This register allows us to assign tape drive support to a specific drive during initialization
	of that drive. This is a read/write register and is 8 bits in size.
	However only the first two bits are defined. They both are used to select between drive 0 - 3.
	Selecting Drive 0 is not allowed as that is reserved for the floppy boot device. Because of this,
	it is not in the bit list shown below.
 
	</p><ul> 
		<li>00: None.</li> 
		<li>01: Drive 1</li> 
		<li>10: Drive 2</li> 
		<li>11: Drive 3</li> 
	</ul> 
 
	Only a hardware reset will reset this register. A software reset has no effect. Do not worry if you
	dont know much about tape drives - this register does not apply to us and will not be used in the series.
	It is here only for completeness. :)
 
	<h3>Data Register</h3> 
 
	This is a 8 or 16 bit read/write register. The actual size of the register is specific on the type
	of controller. <b>All command paramaters and disk data transfers are read to and
	written from the data register.</b> This register does not follow a specific bit format and is used
	for generic data. It is accessed through I/O port 0x3f5 (FDC 0) or 0x375 (FDC 1).
	<p> 
	<b>Note: Before reading or writing this register, you should always insure it is valid by first
	reading its status in the Master Status Register (MSR)</b>.
	</p><p> 
	<b>Remember: All command bytes and command paramaters are sent to the FDC through this register!</b> 
	You will see examples of this in the command section below, so dont worry to much about it yet.
	</p><p> 
	<b>If an invalid command was issued, the value returned from the data register is 0x80</b>.
	</p><p> 
	The following routines read from this register and are use in the demo. It attemps to wait
	until the data register is safe to read or write to, then it either reads it (read_data function)
	or write it (send_command function).
 
</p><blockquote><pre><div class="code">void flpydsk_send_command (uint8_t cmd) {
 
	//! wait until data register is ready. We send commands to the data register
	for (int i = 0; i &lt; 500; i++ )
		if ( flpydsk_read_status () &amp; FLPYDSK_MSR_MASK_DATAREG )
			return outportb (FLPYDSK_FIFO, cmd);
}
 
uint8_t flpydsk_read_data () {
 
	//! same as above function but returns data register for reading
	for (int i = 0; i &lt; 500; i++ )
		if ( flpydsk_read_status () &amp; FLPYDSK_MSR_MASK_DATAREG )
			return inportb (FLPYDSK_FIFO);
}</div></pre></blockquote> 
 
	<h3>Digital Input Register (DIR)</h3> 
 
	<b>You do not need to know this register. It is here for completness only.</b> 
	<p> 
 
	Okay, there was a digital output register (DOR) so I am sure you seen this one coming :) This is
	a read only register in all operation modes of the controller. Only bit 7 is defined when running
	in PC-AT Mode, all other bits are undefined and should not be used. In other operation modes, Bit
	7 is undefined.
	</p><p> 
	Bit 7 (DSK CHG) monitors the DSK CHG pin of the FDC. Looking at our pin layout at the beginning of
	this chapter, you will see that there is no DSK CHG pin. This has to do with the differences between
	the newer FDC models and the original model. Newer models added and changed different bits in this
	register to monitor newer pins on the FDC, such as DMA GATE, DRATE SEL0/1, etc. The values of this
	register is specific to the operation mode of the FDC.
 
	</p><p> 
	<b>Note that the bits in this register can change between models</b>.
 
	</p><h3>Configuation Control Register (CCR)</h3> 
 
	In PC/AT Mode, this register is known as the <b>Data Rate Select Register (DSR)</b> and only
	has the first two bits set (Bit 0=DRATE SEL0, Bit 1=DRATE SEL1.) This was listed in a table
	in the DSR register section. Lets take another look...
 
	<ul> 
		<li><b>00</b> 500 Kbps</li> 
		<li><b>10</b> 250 Kbps</li> 
		<li><b>01</b> 300 Kbps</li> 
		<li><b>11</b> 1 Mbps</li> 
	</ul> 
 
	<p> 
	Bit 2 is NOPREC in Model 30/CCR modes and has no function. Other bits are undefined and may change
	depending on controller.
	</p><p> 
	Like the other registers, I created a routine so we can write to this register.
 
</p><blockquote><pre><div class="code">void flpydsk_write_ccr (uint8_t val) {
 
	//! write the configuation control
	outportb (FLPYDSK_CTRL, val);
}</div></pre></blockquote> 
 
	<h2>Commands</h2> 
 
	<h3>Abstract</h3> 
 
	Commands are used to control a FDD connected to the FDC for different operations, like reading and
	writing. They are written to the data register over the data bus (D0-D7) pins during a write operation
	(IO and WRITE control lines are set on the control bus.) In other words, a OUT assembly language instruction
	to the data register at port 0x3f5 (FDC 0) or 0x375 (FDC 1.)
	<p> 
	<b>Warning: Before sending a command or paramamter byte, insure the data register is ready to recieve
	data by testing bit 7 of the Main Status Register (MSR) first.</b> 
	</p><p> 
	There are <b>thirteen</b> (or more depending on controller) commands. Each command can be 1 to 9
	bytes in size. The FDC knows how many bytes to expect from the first command byte. That is,
	the first byte is the actual command that tells the FDC what we want it to do. The FDC knows
	how many more bytes to expect from this command (The command paramaters.)
	</p><p> 
	<b>Commands will only operate on a single head of the track.</b> If you want to operate on both heads,
	you need to set the <b>Multiple Track Bit</b>. Alot of these commands follow bit formats (Will be shown
	below). This is where things get complicated.
	</p><p> 
	A command byte only uses the low 4 bits of the byte for the actual command (can be more.) The high
	bits of these command bytes are for optional settings for the command. I call these <b>extended command
	bits</b> but it does not have an official name. There is a couple of these bits that are common for
	alot of the commands that we will need to use. We will look at these bits in the command byte later.
 
	</p><p> 
	Okay, first lets take a look the command listing. We will then look at each one separately. Notice how
	they all only use the first 4 bits of the command byte.
 
</p><blockquote><pre><div class="code">enum FLPYDSK_CMD {
	
	FDC_CMD_READ_TRACK	=	2,
	FDC_CMD_SPECIFY		=	3,
	FDC_CMD_CHECK_STAT	=	4,
	FDC_CMD_WRITE_SECT	=	5,
	FDC_CMD_READ_SECT	=	6,
	FDC_CMD_CALIBRATE	=	7,
	FDC_CMD_CHECK_INT	=	8,
	FDC_CMD_WRITE_DEL_S	=	9,
	FDC_CMD_READ_ID_S	=	0xa,
	FDC_CMD_READ_DEL_S	=	0xc,
	FDC_CMD_FORMAT_TRACK	=	0xd,
	FDC_CMD_SEEK		=	0xf
};</div></pre></blockquote> 
 
To send a command to the FDC, remember that we have to write it to the data register, aka the FIFO.
To do this, we first need to wait until the data register is ready by checking the bit in the MSR.
Assuming <b>flpydsk_read_status ()</b> just returns the value from the MSR, lets hide all of this
inside of a simpler method:
 
<blockquote><pre><div class="code">void flpydsk_send_command (uint8_t cmd) {
 
	//! wait until data register is ready. We send commands to the data register
	for (int i = 0; i &lt; 500; i++ )
		if ( flpydsk_read_status () &amp; FLPYDSK_MSR_MASK_DATAREG )
			return outportb (FLPYDSK_FIFO, cmd);
}</div></pre></blockquote> 
 
	<h3>Extended Command Bits</h3> 
 
	Some of these commands require you to pass several bytes before the command is executed.
	Others return several bytes. To make things easier to read, I have listed all of the
	commands, formats, and paramater bytes in tables. Each command comes with an explination
	and an example routine.
	<p> 
	Okay, now remember when we mentioned exteneded command bits and how the commands above are only
	four bits? The upper four bits can be used for different things and purposes.
	</p><p> 
	When describing the format of a command, we represent an extended bit with a character (like M or F.)
	For example, the Write Sector command has the format M F 0 0 0 1 1 0, where the first four bits (0 1 1 0)
	are the command byte and the top four bits, M F 0 0 represent different settings. M is set for multitrack,
	F to select what density mode to operate in for the command.
	</p><p> 
	Here is a list of common bits:
	</p><ul> 
	<li>M - MultiTrack Operation</li> 
		<ul> 
			<li>0: Operate on one track of the cylinder</li> 
			<li>1: Operate on both tracks of the cylinder</li> 
		</ul> 
	<li>F - FM/MFM Mode Setting</li> 
		<ul> 
			<li>0: Operate in FM (Single Density) mode</li> 
			<li>1: Operate in MFM (Double Density) mode</li> 
		</ul> 
	<li>S - Skip Mode Setting</li> 
		<ul> 
			<li>0: Do not skip deleted data address marks</li> 
			<li>1: Skip deleted data address marks</li> 
		</ul> 
	<li>HD - Head Number</li> 
	<li>DR0 - DR1 - Drive Number Bits (2 bits for up to 4 drives)</li> 
	</ul> 
 
	The M, F, and S bits are very common to alot of the commands, so I
	decided to stick them in a nice enumeration. To set them, just bitwise
	OR these settings with the command that you would like to use.
 
<blockquote><pre><div class="code">enum FLPYDSK_CMD_EXT {
 
	FDC_CMD_EXT_SKIP	=	0x20,	//00100000
	FDC_CMD_EXT_DENSITY	=	0x40,	//01000000
	FDC_CMD_EXT_MULTITRACK	=	0x80	//10000000
};</div></pre></blockquote> 
 
	<h3>GAP 3</h3> 
 
	<b>GAP 3</b> referrs to the space between sectors on the physical disk. It is
	a type of <b>GPL (Gap Length)</b>.
 
<blockquote><pre><div class="code">enum FLPYDSK_GAP3_LENGTH {
 
	FLPYDSK_GAP3_LENGTH_STD = 42,
	FLPYDSK_GAP3_LENGTH_5_14= 32,
	FLPYDSK_GAP3_LENGTH_3_5= 27
};</div></pre></blockquote> 
 
	Some commands require us to pass the GAP 3 code, so there it is :)
 
	<h3>Bytes Per Sector</h3> 
 
	Some commands require us to pass in the bytes per sector. These cannot be any size, however,
	and always follows a formula:
 
<blockquote><pre><div class="code">2^n * 128, where ^ denotes "to the power of"</div></pre></blockquote> 
 
	<i>n</i> is a number from 0-7. It cannot go higher then 7, as 2^7 * 128 = 16384 (16 kbytes).
	It is possible to select up to 16 Kbytes per sector on the FDC. Most drives may not support it, however.
	<p> 
	Our list has the most common:
 
</p><blockquote><pre><div class="code">enum FLPYDSK_SECTOR_DTL {
 
	FLPYDSK_SECTOR_DTL_128	=	0,
	FLPYDSK_SECTOR_DTL_256	=	1,
	FLPYDSK_SECTOR_DTL_512	=	2,
	FLPYDSK_SECTOR_DTL_1024	=	4
};</div></pre></blockquote> 
 
	...So, if a command requires us to pass the number of bytes per sector, dont put 512! rather, put
	FLPYDSK_SECTOR_DTL_512, which is 2.
 
	<h3>How to pass paramaters to commands</h3> 
 
	If you recall, alot of commands require us to pass paramaters to it. To pass the paramaters, simply
	send them the same way the command was sent. For example, the specify command requires us to pass two
	paramaters to it. The command wont start without it so...
 
	<blockquote><pre><div class="code">flpydsk_send_command (FDC_CMD_SPECIFY);
flpydsk_send_command (data);
flpydsk_send_command (data2);</div></pre></blockquote> 
 
	Thats all there is to it ;)
 
<h3>How to get return values from commands</h3> 
 
	Unlike functions in programming in which you can ignore return values, the FDC requires for them to
	be processed in some way. Granted, you can still ignore them, but you must get them from the FDC. The
	FDC wont allow any more commands until it is done.
	<p> 
	If the command returns data, it will be returned -- one at a time -- in the FIFO (Data register).
	So, to read them, you must continually read the FIFO to get all of the returned data.
	</p><p> 
	<b>Note: If a command returns data, it will send an interrupt that you must wait for. This is how
	you will know when the command is done and that it is safe to read the return values from the FIFO.</b> 
	</p><p> 
	A good example of return values is the read sectors command. It requires us to wait for an IRQ
	so we know it completes, and returns 7 bytes. So to read all of the returned data bytes, we have to
	read from the data register one at a time:
 
	</p><blockquote><pre><div class="code">for (int j=0; j&lt;7; j++)
	flpydsk_read_data ();</div></pre></blockquote> 
 
	Of course, for error checking purposes you should actually check some of the return values.
 
	<h3>Write Sector</h3> 
 
	<ul> 
		<li>Format: M F 0 0 0 1 1 0</li> 
		<li>Paramaters:</li> 
		<ul> 
			<li>x x x x x HD DR DR0</li> 
			<li>Cylinder</li> 
			<li>Head</li> 
			<li>Sector Number</li> 
			<li>Sector Size</li> 
			<li>Track Length</li> 
			<li>Length of GAP3</li> 
			<li>Data Length</li> 
		</ul> 
		<li>Return:</li> 
		<ul> 
			<li>Return byte 0: ST0</li> 
			<li>Return byte 1: ST1</li> 
			<li>Return byte 2: ST2</li> 
			<li>Return byte 3: Current cylinder</li> 
			<li>Return byte 4: Current head</li> 
			<li>Return byte 5: Sector number</li> 
			<li>Return byte 6: Sector size</li> 
		</ul> 
	</ul> 
	<p> 
	This command reads a sector from a FDD. For every byte in the sector, the FDC issues interrupt 6
	and places the byte read from the disk into the data register so that we can read it in.
 
 
	</p><h3>Read Sector</h3> 
 
	<ul> 
		<li>Format: M F S 0 0 1 1 0</li> 
		<li>Paramaters:</li> 
		<ul> 
			<li>x x x x x HD DR1 DR0 = HD=head DR0/DR1=Disk</li> 
			<li>Cylinder</li> 
			<li>Head</li> 
			<li>Sector Number</li> 
			<li>Sector Size</li> 
			<li>Track Length</li> 
			<li>Length of GAP3</li> 
			<li>Data Length</li> 
		</ul> 
		<li>Return:</li> 
		<ul> 
			<li>Return byte 0: ST0</li> 
			<li>Return byte 1: ST1</li> 
			<li>Return byte 2: ST2</li> 
			<li>Return byte 3: Current cylinder</li> 
			<li>Return byte 4: Current head</li> 
			<li>Return byte 5: Sector number</li> 
			<li>Return byte 6: Sector size</li> 
		</ul> 
	</ul> 
	<p> 
 
	This command reads a sector from a FDD. For every byte in the sector, the FDC issues interrupt 6
	and places the byte read from the disk into the data register so that we can read it in.
	</p><p> 
	The following is the routine used in the demo. It first sets up the DMA to prepare for a read
	operation. It then executes the read sector command (FDC_CMD_READ_SECT) setting the commands M, F, and
	S bits with it (Multitrack read, double density, skip deleted address marks. Please see above for a list
	of all of these.)
	</p><p> 
	Afterwords, it passes all of the commands paramaters to it to begin the read command. The sector size
	paramater is FLPYDSK_SECTOR_DTL_512 (bytes per sector), which, if you recall, is the value 2 (Please
	see the above <b>Bytes per sector</b> section for details.) Next paramater is the sectors per track (18).
	The next paramater is the GAP 3 length. We pass the value of the standard 3-1/2" floppy disk GAP 3 length
	(FLPYDSK_GAP3_LENGTH_3_5, which is 27).
	</p><p> 
	The <b>Data Length</b> paramater byte is only valid if the sector size is 0. Else, it should be 0xff.
	</p><p> 
	Because this command sends an IRQ after completion, we need to wait for the IRQ.
 
 
</p><blockquote><pre><div class="code">void flpydsk_read_sector_imp (uint8_t head, uint8_t track, uint8_t sector) {
 
	uint32_t st0, cyl;
 
	//! set the DMA for read transfer
	flpydsk_dma_read ();
 
	//! read in a sector
	flpydsk_send_command (
		FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK |
		FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
	flpydsk_send_command ( head &lt;&lt; 2 | _CurrentDrive );
	flpydsk_send_command ( track);
	flpydsk_send_command ( head);
	flpydsk_send_command ( sector);
	flpydsk_send_command ( FLPYDSK_SECTOR_DTL_512 );
	flpydsk_send_command (
		( ( sector + 1 ) &gt;= FLPY_SECTORS_PER_TRACK )
			? FLPY_SECTORS_PER_TRACK : sector + 1 );
	flpydsk_send_command ( FLPYDSK_GAP3_LENGTH_3_5 );
	flpydsk_send_command ( 0xff );
 
	//! wait for irq
	flpydsk_wait_irq ();
 
	//! read status info
	for (int j=0; j&lt;7; j++)
		flpydsk_read_data ();
 
	//! let FDC know we handled interrupt
	flpydsk_check_int (&amp;st0,&amp;cyl);
}</div></pre></blockquote> 
 
	...After the IRQ fires, we read in all 7 return bytes. Then we send a SENSE_INTERRUPT command with
	flpydsk_check_int () which tells the FDC that we have handled the interrupt. (Please see the <b>Check Interrupt Status</b> 
	section below.)
	<p> 
	Wait... Where is the data at? Looking at the above command, we dont tell the FDC will to put the data at.
	This poses an interesting problem, dont you think?
	</p><p> 
	Depending on the FDCs mode of operation, in Non-DMA mode, it will fire IRQ 6 for every byte. The byte of
	data read from disk is in the FIFO. In DMA mode (where we are in), it will give the data to the DMA, which
	will put the data into a buffer (wherever location we told the DMA to put it at.)
	</p><p> 
	So, in our case, we set up the DMA buffer to 0x1000, remember? After calling the above routine, the sector
	data will be at 0x1000! Cool, huh? We can change its location by giving the DMA a different address.
 
	</p><h3>Fix Drive Data / Specify</h3> 
	<ul> 
		<li>Format: 0 0 0 0 0 0 1 1</li> 
		<li>Paramaters:</li> 
		<ul> 
			<li>S S S S H H H H - S=Step Rate H=Head Unload Time</li> 
			<li>H H H H H H H NDM - H=Head Load Time NDM=0 (DMA Mode) or 1 (DMA Mode)</li> 
		</ul> 
		<li>Return: None</li> 
	</ul> 
	<p> 
	This command is used to pass controlling information to the FDC about the mechanical drive connected to
	it. To make working with this command easier, lets write a routine for it:
 
 
</p><blockquote><pre><div class="code">void flpydsk_drive_data (uint32_t stepr, uint32_t loadt, uint32_t unloadt, bool dma ) {
 
	uint32_t data = 0;
 
	flpydsk_send_command (FDC_CMD_SPECIFY);
 
	data = ( (stepr &amp; 0xf) &lt;&lt; 4) | (unloadt &amp; 0xf);
	flpydsk_send_command (data);
 
	data = (loadt) &lt;&lt; 1 | (dma==true) ? 1 : 0;
	flpydsk_send_command (data);
}</div></pre></blockquote> 
 
	<h3>Check Status</h3> 
 
	<ul> 
		<li>Format: 0 0 0 0 0 1 0 0</li> 
		<li>Paramaters:</li> 
		<ul> 
			<li>x x x x x HD DR1 DR0</li> 
		</ul> 
		<li>Return:</li> 
		<ul> 
			<li>Byte 0: Status Register 3 (ST3)</li> 
		</ul> 
	</ul> 
	<p> 
	This command returns the drive status.
 
	</p><h3>Calibrate Drive</h3> 
 
	<ul> 
		<li>Format: 0 0 0 0 0 1 1 1</li> 
		<li>Paramaters:</li> 
		<ul> 
			<li>x x x x x 0 DR1 DR0
		</li></ul> 
		<li>Return: None</li> 
	</ul> 
	<p> 
	This command is used to position the read/write head to cylinder 0. After completion, the FDC
	issues an interrupt. If the disk has more then 80 tracks, you may need to issue this command several
	times. After issuing this command, always check to insure it is on the right track (<b>Check Interrupt
	Status</b> command.)
	</p><p> 
	If, after the command, we are not on cylinder 0 yet, we issue the command again. When we find cylinder 0,
	we turn the motor off and return success. If we dont fine it after 10 tries we bail.
	</p><p> 
	Note that we have to insure that the motor is running during this command. Also notice how we use the SENSE_INTERRUPT
	command (the flpydsk_check_int () call) to abtain the current cylinder.
 
</p><blockquote><pre><div class="code">int flpydsk_calibrate (uint32_t drive) {
 
	uint32_t st0, cyl;
 
	if (drive &gt;= 4)
		return -2;
 
	//! turn on the motor
	flpydsk_control_motor (true);
 
	for (int i = 0; i &lt; 10; i++) {
 
		//! send command
		flpydsk_send_command ( FDC_CMD_CALIBRATE );
		flpydsk_send_command ( drive );
		flpydsk_wait_irq ();
		flpydsk_check_int ( &amp;st0, &amp;cyl);
 
		//! did we fine cylinder 0? if so, we are done
		if (!cyl) {
 
			flpydsk_control_motor (false);
			return 0;
		}
	}
 
	flpydsk_control_motor (false);
	return -1;
}</div></pre></blockquote> 
 
	<h3>Check Interrupt Status</h3> 
 
	<ul> 
		<li>Format: 0 0 0 0 1 0 0 0</li> 
		<li>Paramaters: None</li> 
		<li>Return:</li> 
		<ul> 
			<li>Byte 0: Status Register 0 (ST0)</li> 
			<li>Byte 1: Current Cylinder</li> 
		</ul> 
	</ul> 
	<p> 
 
	This command is used to check information on the state of the FDC when an interrupt returnes.
 
</p><blockquote><pre><div class="code">void flpydsk_check_int (uint32_t* st0, uint32_t* cyl) {
 
	flpydsk_send_command (FDC_CMD_CHECK_INT);
 
	*st0 = flpydsk_read_data ();
	*cyl = flpydsk_read_data ();
}</div></pre></blockquote> 
 
	<h3>Seek / Park Head</h3> 
	<ul> 
		<li>Format: 0 0 0 0 1 1 1 1</li> 
		<li>Paramaters:</li> 
		<ul> 
			<li>x x x x x HD DR1 DR0 - HD=Head DR1/DR0 = drive</li> 
			<li>Cylinder</li> 
		</ul> 
		<li>Return: None</li> 
	</ul> 
	<p> 
	This command is used to move the read/write head to a specific cylinder. Simular to the
	calibrate command, we may need to send the command multiple times. Notice the call to
	check_int () to get the current cylinder after every attempt. We then test if the current cylinder
	is the cylinder we are looking for. If it is not, we try again. If it is, we return success.
 
</p><blockquote><pre><div class="code">int flpydsk_seek ( uint32_t cyl, uint32_t head ) {
 
	uint32_t st0, cyl0;
 
	if (_CurrentDrive &gt;= 4)
		return -1;
 
	for (int i = 0; i &lt; 10; i++ ) {
 
		//! send the command
		flpydsk_send_command (FDC_CMD_SEEK);
		flpydsk_send_command ( (head) &lt;&lt; 2 | _CurrentDrive);
		flpydsk_send_command (cyl);
 
		//! wait for the results phase IRQ
		flpydsk_wait_irq ();
		flpydsk_check_int (&amp;st0,&amp;cyl0);
 
		//! found the cylinder?
		if ( cyl0 == cyl)
			return 0;
	}
 
	return -1;
}</div></pre></blockquote> 
 
	<h3>Invalid Commands</h3> 
 
	If an invalid command is sent to the FDC, the FDC ignores it and goes into standy mode.
 
	<h2>Resetting the FDC</h2> 
 
	<h3>Disabling the Controller</h3> 
 
	If the DOR RESET line is low, the controller will be in a disabled state. In other words,
	just write 0 to the DOR register to disable the controller:
 
<blockquote><pre><div class="code">void flpydsk_disable_controller () {
 
	flpydsk_write_dor (0);
}</div></pre></blockquote> 
 
	<h3>Enabling the Controller</h3> 
 
	To enable the controller, set the RESET line high in DOR. Also, because we want the FDC to operate
	in DMA mode, you must also set that bit in DOR:
 
<blockquote><pre><div class="code">void flpydsk_enable_controller () {
 
	flpydsk_write_dor ( FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA);
}</div></pre></blockquote> 
 
	When the controller is enabled after being disabled, it will issue an interrupt. During
	this time, you must reinitialize the controller and drive configuation.
 
	<h3>Initializing the FDC</h3> 
 
	During a controller reset, you need to reinitialize the controller. After resetting the controller,
	it will fire IRQ 6. After it has been fired, you must send a SENSE_INTERRUPT command to all drives
	connected to the FDC (by calling <b>flpydsk_check_int</b> 4 times.)
	<p> 
	Afterwords its time to reconfigure the controller. Remember that the <b>CCR (Configuation Control Register)</b> 
	only has 2 bits for the data rate. By setting both to 0, we set the data rate to 500 Kbps, which is a nice default
	value.
	</p><p> 
	Then we call flpydsk_drive_data which sends a <b>Fix Drive Data / Specify</b> command to the controller
	to set the drives mechanical information, including: Step rate, head load and unload time, and if it
	supports DMA mode or not.
	</p><p> 
	Then we recalibrate the drive so it is on cylinder 0.
 
</p><blockquote><pre><div class="code">void flpydsk_reset () {
 
	uint32_t st0, cyl;
 
	//! reset the controller
	flpydsk_disable_controller ();
	flpydsk_enable_controller ();
	flpydsk_wait_irq ();
 
	//! send CHECK_INT/SENSE INTERRUPT command to all drives
	for (int i=0; i&lt;4; i++)
		flpydsk_check_int (&amp;st0,&amp;cyl);
 
	//! transfer speed 500kb/s
	flpydsk_write_ccr (0);
 
	//! pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
	flpydsk_drive_data (3,16,240,true);
 
	//! calibrate the disk
	flpydsk_calibrate ( _CurrentDrive );
}</div></pre></blockquote> 
 
	After a reset, the drive is ready to be used by us.
 
	<h1>Demo</h1> 
 
	<center><img src="./Operating Systems Development Series_files/fdc.jpg"><p><i>FDC Demo in action</i><br><a href="http://www.brokenthorn.com/Resources/Demos/Demo15a.zip">Demo Download</a></p></center> 
 
	<b>Note: There is a known bug in the demo that causes VPC to only read the first sector read.
	This will be resolved as soon as possible.</b> No known issues when running in Bochs.
 
	<h2>Updates and Changes</h2> 
 
	<h3>String to int convertion - stdio.h/stdio.cpp</h3> 
 
	In order to make this demo more interactive, I included three functions in the standard library
	that are used for converting strings into integers. This includes <b>strtol</b>, <b>strtoul</b> and <b>atoi</b>.
	The demo uses <b>atoi</b> to convert a string entered from the user into a useable integer.
 
	<h3>Installing the floppy driver - flpydsk.cpp</h3> 
 
	The floppy driver comes with a nice install routine that allows the demo to easily set it up. All it
	does is install our interrupt handler using our HAL's setvect () routine, initializes the DMA for
	transfers, and resets the controller so it is ready for use.
 
<blockquote><pre><div class="code">void flpydsk_install (int irq) {
 
	//! install irq handler
	setvect (irq, i86_flpy_irq);
 
	//! initialize the DMA for FDC
	flpydsk_initialize_dma ();
 
	//! reset the fdc
	flpydsk_reset ();
 
	//! set drive information
	flpydsk_drive_data (13, 1, 0xf, true);
}</div></pre></blockquote> 
 
	The demo calls this function during initialization to set up the driver before attempting to read from
	it.
 
	<h3>Reading any sector - LBA and CHS - flpydsk.cpp</h3> 
 
	The driver hides the details of CHS behind two nice functions. Knowing that the drive works in
	CHS (Cylinder/Head/Sector) and does not know anything about LBA (Linear Block Addressing), we
	should provide a routine to convert between these two. This way we can just pass in a sector number
	to read or write to/from without worry of what physical CHS it is at.
	<p> 
	Remember the formula to convert LBA to CHS? Lets apply it here:
 
</p><blockquote><pre><div class="code">void flpydsk_lba_to_chs (int lba,int *head,int *track,int *sector) {
 
   *head = ( lba % ( FLPY_SECTORS_PER_TRACK * 2 ) ) / ( FLPY_SECTORS_PER_TRACK );
   *track = lba / ( FLPY_SECTORS_PER_TRACK * 2 );
   *sector = lba % FLPY_SECTORS_PER_TRACK + 1;
}</div></pre></blockquote> 
 
FLPY_SECTORS_PER_TRACK is 18. Great! So now we can just call this function to convert any linear sector
number into a CHS location! Cool, huh?
<p> 
Because we are wanting to be able to read any sector from disk, we can provide a routine for just that.
And because we already have <b>flpydsk_read_sector_imp</b>, which containes the code to send the read command
to the controller, this routine is very simple.
 
</p><blockquote><pre><div class="code">uint8_t* flpydsk_read_sector (int sectorLBA) {
 
	if (_CurrentDrive &gt;= 4)
		return 0;
 
	//! convert LBA sector to CHS
	int head=0, track=0, sector=1;
	flpydsk_lba_to_chs (sectorLBA, &amp;head, &amp;track, or);
 
	//! turn motor on and seek to track
	flpydsk_control_motor (true);
	if (flpydsk_seek (track, head) != 0)
		return 0;
 
	//! read sector and turn motor off
	flpydsk_read_sector_imp (head, track, sector);
	flpydsk_control_motor (false);
 
	//! warning: this is a bit hackish
	return (uint8_t*) DMA_BUFFER;
}</div></pre></blockquote> 
 
	Whenever the demo wants to read a sector, it calls this routine. This routine converts the
	sector into a physical location on disk (CHS). It turns the motor on and seeks to the cylinder
	that this sector is on. After words, it calls <b>flpydsk_read_sector_imp</b> to perform the magic
	of actually reading the sector and turns the motor off afterwords.
	<p> 
	After the flpydsk_read_sector_imp call, the data for the sector should be in the DMA buffer.
	We return a pointer to this buffer, which now containes the sector data just read. Cool, huh?
	</p><p> 
	This is the magical routine that ties everything together :)
 
	</p><h3>New Read Command - main.cpp</h3> 
 
	This demo builds on the last demo. Because of this, it keeps the command line interface (CLI) that was
	built in the previous demo. This also makes this demo the most complex demo yet.
	<p> 
	I have added a new command to our list of commands in the CLI - <b>read</b> - that allows us to read
	any sector off disk. It uses out floppy driver built in this tutorial to do it.
	</p><p> 
	The command is inside of a function and is executed in the demo by typing <b>read</b>. It dumps the
	512 bytes into 4 128-byte blocks for readability. After each block, you will be prompted to press a key
	to continue with the next chunk. It uses the new <b>atoi</b> function to convert the sector number entered
	(which is an LBA sector number) into an int, and reads it in. This, dear readers, is the function that makes
	the magic happen:
 
</p><blockquote><pre><div class="code">void cmd_read_sect () {
 
	uint32_t sectornum = 0;
	char sectornumbuf [4];
	uint8_t* sector = 0;
 
	DebugPrintf ("\n\rPlease type in the sector number [0 is default] &gt;");
	get_cmd (sectornumbuf, 3);
	sectornum = atoi (sectornumbuf);
 
	DebugPrintf ("\n\rSector %i contents:\n\n\r", sectornum);
 
	//! read sector from disk
	sector = flpydsk_read_sector ( sectornum );
 
	//! display sector
	if (sector!=0) {
 
		int i = 0;
		for ( int c = 0; c &lt; 4; c++ ) {
 
			for (int j = 0; j &lt; 128; j++)
				DebugPrintf ("0x%x ", sector[ i + j ]);
			i += 128;
 
			DebugPrintf("\n\rPress any key to continue\n\r");
			getch ();
		}
	}
	else
		DebugPrintf ("\n\r*** Error reading sector from disk");
 
	DebugPrintf ("\n\rDone.");
}</div></pre></blockquote> 
 
	<h1>Conclusion</h1> 
 
	Yeesh, this is a long tutorial. I might be making some changes to help improve it and make it
	better and more complete. :)
	<p> 
	In the next tutorial, we will be looking at the DMA. We will create an interface for programming
	the DMA and better use it in the FDC driver. After all of this...I suppose its filesystems again
	(ugh). Dont worry - After that it is Multitasking!
 
	</p><p> 
	Until next time,
	</p><p>
	~Mike<br>
	<i>BrokenThorn Entertainment. Currently developing DoE and the <a href="http://www.brokenthorn.com/mos/site2/">Neptune Operating System</a></i>

	<br><br>
	<i>Questions or comments? Feel free to <a href="mailto:neon6000@aol.com">Contact me</a>.</i>

	<br><br>
	Would you like to contribute and help improve the articles? If so, please <a href="mailto:neon6000@aol.com">let me know!</a>

<br><br> 
<table width="100%" border="0"> 
<tbody><tr> 
<td><p align="left"> 
<a class="anchor" href="http://www.brokenthorn.com/Resources/OSDev19.html"> 
<img src="./Operating Systems Development Series_files/left.jpg" border="0"></a> 
&nbsp;&nbsp;
<a class="anchor" href="http://www.brokenthorn.com/Resources/OSDev19.html"> 
<font size="4">Chapter 19</font> 
</a> 
 
</p></td> 
<td> 
<p align="center"> 
<font size="4"><a class="anchor" href="http://www.brokenthorn.com/Resources/OSDevIndex.html">Home</a></font> 
</p> 
</td> 
<td><p align="right"> 
<!--<a class="anchor" href="OSDev9.html"><font size=4>Chapter 9</font></a>--> 
&nbsp;&nbsp;
<!--<a class="anchor" href="OSDev9.html"><img src="images/right.jpg" border=0></a>--> 
</p></td> 
</tr> 
</tbody></table> 
 
 
 
 </p></td></tr></tbody></table><ins class="adsbygoogle adsbygoogle-noablate" data-adsbygoogle-status="done" style="display: none !important;" data-ad-status="unfilled"><div id="aswift_1_host" style="border: none; height: 0px; width: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; background-color: transparent; display: inline-block;"><iframe id="aswift_1" name="aswift_1" style="left:0;position:absolute;top:0;border:0;width:undefinedpx;height:undefinedpx;" sandbox="allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts allow-top-navigation-by-user-activation" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allow="attribution-reporting; run-ad-auction" src="./Operating Systems Development Series_files/ads(1).html" data-google-container-id="a!2" tabindex="0" title="Advertisement" aria-label="Advertisement" data-load-complete="true"></iframe></div></ins></body><iframe id="google_esf" name="google_esf" src="./Operating Systems Development Series_files/zrt_lookup_fy2021.html" style="display: none;"></iframe></html>