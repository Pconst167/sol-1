<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-CA" lang="en-CA"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Ian! D. Allen – idallen@idallen.ca – www.idallen.com">
  <title>Unix/Linux File System – directories, inodes, hard links</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/ianstyles003.css">
  <link rel="stylesheet" href="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/ianstyles004.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
     <meta name="author" content="Ian! D. Allen - idallen@idallen.ca - www.idallen.com"> 
     <link rel="shortcut icon" href="http://teaching.idallen.org/cst8207/19w/notes/common/favicon.png" type="image/x-icon"> 
     
</head>
<body class="pandoc-html ">
<header id="title-block-header">
<h1 class="title">Unix/Linux File System – directories, inodes, hard links</h1>
<p class="author">Ian! D. Allen – <a href="mailto:idallen@idallen.ca" class="email">idallen@idallen.ca</a> – <a href="http://www.idallen.com/">www.idallen.com</a></p>
<p class="date">Winter 2019 - January to April 2019 - Updated 2019-03-01 04:02 EST</p>
</header>
<ul>
<li><a href="http://teaching.idallen.org/cst8207/19w/">Course Home Page</a></li>
<li><a href="http://teaching.idallen.org/cst8207/19w/notes/course_outline.pdf">Course Outline</a></li>
<li><a href="http://teaching.idallen.org/cst8207/19w/notes/indexcgi.cgi">All Weeks</a></li>
<li><a href="http://teaching.idallen.org/cst8207/19w/notes/450_file_system.txt">Plain Text</a></li>
</ul>
<!--navbar1-->

<nav id="TOC" role="doc-toc">
	  <p class="updated"> 
	     Updated: 
	      
	     2019-03-01 04:02 EST 
	  </p>
<ul>
<li><a href="#file-systems-contain-names-of-directories-and-files"><span class="toc-section-number">1</span> File systems contain names of directories and files</a>
<ul>
<li><a href="#files-are-a-list-of-bytes"><span class="toc-section-number">1.1</span> Files are a list of bytes</a></li>
<li><a href="#even-hardware-devices-have-file-names"><span class="toc-section-number">1.2</span> Even hardware devices have file names</a></li>
</ul></li>
<li><a href="#things-are-stored-in-index-nodes-inodes"><span class="toc-section-number">2</span> Things are stored in Index Nodes = Inodes</a>
<ul>
<li><a href="#directories-map-names-to-inode-numbers"><span class="toc-section-number">2.1</span> Directories map names to inode numbers</a></li>
<li><a href="#one-inode-many-names"><span class="toc-section-number">2.2</span> One inode, many names</a></li>
<li><a href="#inodes-contain-pointers-to-disk-blocks"><span class="toc-section-number">2.3</span> Inodes contain pointers to disk blocks</a></li>
<li><a href="#inodes-contain-attributes-owners-permissions-times-etc."><span class="toc-section-number">2.4</span> Inodes contain attributes (owners, permissions, times, etc.)</a></li>
<li><a href="#inodes-are-unique-inside-a-file-system"><span class="toc-section-number">2.5</span> Inodes are unique inside a file system</a></li>
<li><a href="#inodes-are-a-fixed-resource"><span class="toc-section-number">2.6</span> Inodes are a fixed resource</a></li>
</ul></li>
<li><a href="#file-system-diagrams-are-wrong"><span class="toc-section-number">3</span> File System Diagrams are Wrong</a></li>
<li><a href="#directories-hold-only-names-and-inode-numbers"><span class="toc-section-number">4</span> Directories hold only names and inode numbers</a>
<ul>
<li><a href="#attributes-are-stored-with-the-inode-not-the-name"><span class="toc-section-number">4.1</span> Attributes are stored with the inode, not the name</a></li>
<li><a href="#damaged-directories-create-orphans"><span class="toc-section-number">4.2</span> Damaged directories create orphans</a></li>
</ul></li>
<li><a href="#multiple-names-hard-links"><span class="toc-section-number">5</span> Multiple names – hard links</a>
<ul>
<li><a href="#link-counts-count-names-ln-creates-rm-removes-only-a-name"><span class="toc-section-number">5.1</span> Link counts count names; <code>ln</code> creates, <code>rm</code> removes only a name</a></li>
</ul></li>
<li><a href="#tracing-inodes-in-pathnames-ascii-art"><span class="toc-section-number">6</span> Tracing Inodes in Pathnames – ASCII Art</a>
<ul>
<li><a href="#slashes-separate-names-in-pathnames"><span class="toc-section-number">6.1</span> Slashes separate names in pathnames</a></li>
<li><a href="#names-reside-above-the-things-they-name"><span class="toc-section-number">6.2</span> Names reside above the things they name</a></li>
<li><a href="#tracing-pathname-1-homealexfoobar"><span class="toc-section-number">6.3</span> Tracing Pathname 1: <code>/home/alex/foobar</code></a></li>
<li><a href="#tracing-pathname-2-homealexliteraturebarfoo"><span class="toc-section-number">6.4</span> Tracing Pathname 2: <code>/home/alex/literature/barfoo</code></a></li>
<li><a href="#summary-tracing-pathname-2-homealexliteraturebarfoo"><span class="toc-section-number">6.5</span> Summary Tracing Pathname 2: <code>/home/alex/literature/barfoo</code></a></li>
<li><a href="#every-inode-has-a-link-count-a-count-of-names"><span class="toc-section-number">6.6</span> Every inode has a link count: a count of names</a></li>
<li><a href="#permissions-on-data-vs.-permissions-on-directories"><span class="toc-section-number">6.7</span> Permissions on data vs.&nbsp;permissions on directories</a></li>
</ul></li>
<li><a href="#exercise-questions-on-hard-links-and-directories"><span class="toc-section-number">7</span> Exercise Questions on Hard Links and Directories</a></li>
</ul>
</nav>
<section id="file-systems-contain-names-of-directories-and-files" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> File systems contain names of directories and files<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<p>Unix/Linux has hierarchical file systems consisting of directories, 
sub-directories, and data files. Each thing has a name in the file 
system tree.</p>
<section id="files-are-a-list-of-bytes" class="level2" data-number="1.1">
<h2 data-number="1.1"><span class="header-section-number">1.1</span> Files are a list of bytes<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>In Unix, a <strong>file</strong> is a sequence of bytes without 
structure. Any necessary structure (e.g.&nbsp;for a database) is added 
by the programs that manipulate the data in the file. Linux itself 
doesn’t know about the internal structure of a database file – all it 
does is return bytes.</p>
<blockquote>
<p>Most Unix books say “everything is a file”, and they loosely use the 
word “file” to refer to anything in the file system, including 
directories, symbolic links, devices, etc. The manual page for the <code>find</code> command says that it can <code>search for files</code>, but it really means that it can search for any kind of thing, not just strictly a “file”.</p>
</blockquote>
</section>
<section id="even-hardware-devices-have-file-names" class="level2" data-number="1.2">
<h2 data-number="1.2"><span class="header-section-number">1.2</span> Even hardware devices have file names<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Unix tries its best to treat every device attached to it as if it 
were a list of bytes. Therefore, everything, including network cards, 
hard drives, partitions, keyboards, printers, and plain files are 
treated as file-like objects and each has a name in the file system:</p>
<ul>
<li>Your computer memory is <code>/dev/mem</code>.</li>
<li>Your first hard disk is <code>/dev/sda</code>.</li>
<li>A terminal (keyboard and screen) is <code>/dev/tty1</code>.</li>
<li>Etc.</li>
</ul>
<!-- -->
<pre><code>$ ls -li /dev/mem /dev/sda /dev/tty1
5792 crw-r----- 1 root kmem 1, 1 Oct 13 02:30 /dev/mem
 888 brw-rw---- 1 root disk 8, 0 Oct 13 02:30 /dev/sda
5808 crw-rw---- 1 root tty  4, 1 Oct 13 02:31 /dev/tty1</code></pre>
<p>Most input and output devices and directories are treated as files in
 Linux. If you have sufficient permissions, you can directly read all 
these devices using their file system names. Recent versions of Unix 
have evolved directories into non-readable (non-file) objects.</p>
</section>
</section>
<section id="things-are-stored-in-index-nodes-inodes" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Things are stored in Index Nodes = Inodes<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<p>As with most things computer-related, things in the file system are 
not stored on disk by name, they are stored using a numbered data 
structure called an index number or <strong>inode</strong>.</p>
<p>Everything in a Unix file system has a unique inode number that 
manages the storage and attributes for that thing: every file, 
directory, special file, etc. Files and directories are both managed 
with inodes.</p>
<section id="directories-map-names-to-inode-numbers" class="level2" data-number="2.1">
<h2 data-number="2.1"><span class="header-section-number">2.1</span> Directories map names to inode numbers<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Directories map file system names to inode numbers for you. Each 
inode is identified by a unique inode number that can be shown using the
 <code>-i</code> option to the <code>ls</code> command:</p>
<pre><code>$ ls -l -i /usr/bin/perl*
266327 -rwxr-xr-x 2 root root 10376 Mar 18  2013 /usr/bin/perl
266327 -rwxr-xr-x 2 root root 10376 Mar 18  2013 /usr/bin/perl5.14.2
266331 -rwxr-xr-x 2 root root 45183 Mar 18  2013 /usr/bin/perlbug
266328 -rwxr-xr-x 1 root root   224 Mar 18  2013 /usr/bin/perldoc
266329 -rwxr-xr-x 1 root root   125 Mar 18  2013 /usr/bin/perldoc.stub
266330 -rwxr-xr-x 1 root root 12318 Mar 18  2013 /usr/bin/perlivp
266331 -rwxr-xr-x 2 root root 45183 Mar 18  2013 /usr/bin/perlthanks</code></pre>
<p>The program <code>/usr/bin/perl</code>, above, is not stored on disk in the same place as its name <code>perl</code>; it is stored in an inode somewhere else, under inode number <code>266327</code>.</p>
<p>Unix <strong>directories</strong> are what map file system names (e.g.&nbsp;<code>perl</code>) to inode numbers (e.g.&nbsp;<code>266327</code>) that contain the actual data.</p>
<p>In the example above, you can see that file name <code>/usr/bin/perl</code> really leads to inode number <code>266327</code> and that another name <code>perl5.14.2</code> leads to the same inode number. The names are separate from the things they name.</p>
<p>When you access the <code>perl</code> program by name, the system finds the <code>perl</code> name in a directory, paired with the inode number <code>266327</code> that holds the actual data, and then the system has to go elsewhere on disk to that inode number <code>266327</code> to access the data for the <code>perl</code> program.</p>
<p>File and directory data is actually stored under inode numbers, not 
under names. Directories map the names to the inode numbers for you.</p>
</section>
<section id="one-inode-many-names" class="level2" data-number="2.2">
<h2 data-number="2.2"><span class="header-section-number">2.2</span> One inode, many names<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>As you can see above, a name <code>perl</code> in a directory leads to a single inode number <code>266327</code>, but the inode <code>266327</code> may have several names that lead to it, e.g.&nbsp;both <code>perl</code> and <code>perl5.14.2</code>.</p>
<p>Each file name is mapped to only one single inode number, but one file inode number may have many names that map to it.</p>
</section>
<section id="inodes-contain-pointers-to-disk-blocks" class="level2" data-number="2.3">
<h2 data-number="2.3"><span class="header-section-number">2.3</span> Inodes contain pointers to disk blocks<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>A Unix inode manages the disk storage space for a file or a 
directory. The inode contains a list of pointers to the disk blocks that
 belong to that file or directory.</p>
<p>The disk blocks store the data for the inode. The larger the file or 
directory, the more disk block pointers it needs in the inode.</p>
</section>
<section id="inodes-contain-attributes-owners-permissions-times-etc." class="level2" data-number="2.4">
<h2 data-number="2.4"><span class="header-section-number">2.4</span> Inodes contain attributes (owners, permissions, times, etc.)<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Also stored in the inode are the attributes of the file or directory: permissions, owner, group, size, access/modify times, etc.</p>
<p>The attributes of a file are stored in the inode for the file. They 
attributes not stored with the name of the file, which is up in some 
directory.</p>
<p>The attributes of a directory are also stored in the inode for the directory. The attributes of the things named <em>in</em> the directory – names of files or sub-directories – are <em>not</em> stored in the directory; they are stored in the individual inodes of those things.</p>
<p>The attributes of a directory inode apply only to that directory itself, not to the things named <em>in</em> the directory, which have their own inodes.</p>
<p>The name of the file or directory is <em>not</em> stored in its own 
inode. Inodes have only numbers, attributes, and disk blocks – an inode 
does not contain its own name. The names are kept separately, in 
directories.</p>
</section>
<section id="inodes-are-unique-inside-a-file-system" class="level2" data-number="2.5">
<h2 data-number="2.5"><span class="header-section-number">2.5</span> Inodes are unique inside a file system<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Inode numbers are specific to a <strong>file system</strong> inside a <strong>disk partition</strong>. Each file system has its own set of inode numbers.</p>
<p>Numbering is done separately for each file system, so different disk 
partitions may have file system objects with the same inode numbers.</p>
</section>
<section id="inodes-are-a-fixed-resource" class="level2" data-number="2.6">
<h2 data-number="2.6"><span class="header-section-number">2.6</span> Inodes are a fixed resource<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Every Linux file system is created new with a large set of available inodes. You can list the free inodes using <code class="pre">df -i</code>.
 Some types of Unix file systems can never make more inodes, even if 
there is lots of disk space available; when all the inodes are used up, 
the file system can create no more files until some files are deleted to
 free some inodes.</p>
</section>
</section>
<section id="file-system-diagrams-are-wrong" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> File System Diagrams are Wrong<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<p>Most diagrams showing file systems and links in Unix texts are wrong 
and range from confusing to seriously misleading. Here’s the truth, 
complete with an ASCII-art file system diagram below.</p>
<p>The names for inodes (names for files, directories, devices, etc.) are stored on disk in directories. Only the <em>names</em> and the associated <em>inode numbers</em> are stored in the directory; the actual <em>disk space</em>
 for whatever data is being named is stored in the numbered inode, not 
in the directory. The names and numbers are kept in the directory; the 
names are <em>not</em> kept with the data, which is in the inode.</p>
<p>In the directory, beside each name, is the index number (inode 
number) indicating where to find the disk space used to actually store 
the thing being named. You can see this name-inode pairing using <code>ls -i</code>:</p>
<pre><code>$ ls -i /usr/bin/perl*
266327 /usr/bin/perl        266329 /usr/bin/perldoc.stub
266327 /usr/bin/perl5.14.2  266330 /usr/bin/perlivp
266331 /usr/bin/perlbug     266331 /usr/bin/perlthanks
266328 /usr/bin/perldoc</code></pre>
<p>The crucial thing to know is that the names and the actual storage for the things being named are in <em>separate places</em>. Most texts make the error of writing Unix file system diagrams that put the names right <em>on</em> the things that are being named. That is misleading and the cause of many misunderstandings about Unix files and directories.</p>
<p>Names exist one level <em>above</em> (separate from) the items that they name:</p>
<pre><code>WRONG - names on things      RIGHT - names above things
=======================      ==========================
                                                      
    R O O T            ---&gt;         [etc,bin,home]   &lt;-- ROOT directory
   /   |   \                         /    |      \
etc   bin   home       ---&gt;  [passwd]  [ls,rm]  [abcd0001]
 |   /   \    \                 |      /    \       |
 |  ls   rm  abcd0001  ---&gt;     |  &lt;data&gt;  &lt;data&gt;  [.bashrc]
 |               |              |                   |
passwd       .bashrc   ---&gt;  &lt;data&gt;                &lt;data&gt;</code></pre>
<p>Directories are lists of names and inode numbers, as shown by the 
square-bracketed lists in the diagram on the right, above. (The actual 
inode numbers are omitted from this small diagram.)</p>
<p>The name of each thing (file, directory, special file, etc.) is kept 
in a directory, separate from the storage space for the thing it names. 
This allows inodes to have multiple names and to have names in multiple 
directories; all the names can refer to the same storage space by simply
 using the same inode number.</p>
<p>In the correct diagram on the right, the directories are lists of 
names in square brackets. Directories give names to the objects below 
them in the tree. The top directory on the right is the ROOT directory 
inode, containing the list of names under it: <code>etc</code>, <code>bin</code>, <code>home</code>, and others.</p>
<p>The line leading downwards from the name <code>bin</code> in the ROOT directory indicates that the name <code>bin</code> is paired with an inode number that is another directory inode containing the list of names in the <code>bin</code> directory, including names <code>ls</code> and <code>rm</code> and others. The line leading down from <code>ls</code> in the <code>bin</code> directory inode leads to the data inode for the file <code>/bin/ls</code>. There is no name kept with the data inode – the name is up in the directory above it.</p>
<p>The ROOT directory inode has no name because there is no directory 
above it to give it one! Every other directory except ROOT has a name 
because there is a directory inode above it that contains its name.</p>
</section>
<section id="directories-hold-only-names-and-inode-numbers" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Directories hold only names and inode numbers<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<p>To make a hierarchical file system, file system names are stored in directories.</p>
<p>Each Unix directory is itself an inode. Like all inodes, directory 
inodes contain pointers to disk blocks and attribute information about 
the inode (permissions, owner, etc.), but what is stored in the disk 
blocks of a directory inode is not file data but directory data. That 
directly data is simply a list of names and inode numbers.</p>
<p>The directory inode contains attribute information about the <em>directory</em>, itself, not about the things named <em>in</em> the directory. (Use <code class="pre">ls -ld</code> to see the attributes of the directory inode itself.)</p>
<p>On Unix, for each thing in the file system, only the name and the 
inode number of the thing is kept in the directory. No data or 
attributes about the thing are kept in the directory, only the name of 
the thing and its inode number.</p>
<p>The <em>name</em> of a file is kept in a directory, paired with its 
inode number. The file’s actual attributes and pointers to disk blocks 
are kept elsewhere, in the inode for the file.</p>
<p>This means that names are not kept in the same inodes with the things that they name.</p>
<p>Directories are what give names to inodes on Unix. Directories can be
 thought of as “files containing lists of names and inode numbers”. 
Files have disk blocks containing file data; directories also have disk 
blocks; but, the blocks contain lists of names and inode numbers.</p>
<p>If a directory is damaged in Unix, only the names are lost, not any of the file data blocks or the file attributes.</p>
<section id="attributes-are-stored-with-the-inode-not-the-name" class="level2" data-number="4.1">
<h2 data-number="4.1"><span class="header-section-number">4.1</span> Attributes are stored with the inode, not the name<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>A Unix directory is only a list of pairs of names and associated inode numbers. The attribute information about an item named <em>in</em>
 a directory – the type, permissions, owner, etc. of the thing – is kept
 with the inode associated with the thing, not in the directory.</p>
<p>Reading a Unix directory tells you only some names and inode numbers;
 you know nothing about the types, sizes, owners, or modify times of 
those inodes unless you actually go out to each separate inode on disk 
and access it to read its attributes. Without actually accessing the 
inode, you can’t know the attributes of the inode; you can’t even know 
if the inode is a file inode or a directory inode. (Some modern Unix 
file systems also cache a second copy of the inode type in the directory
 to speed up common file system browsing operations.)</p>
<p>To find out attribute information of some file system object, that 
information is stored in the inode of the object, not in the directory. 
You must first use the inode number associated with the object to find 
the inode of the item and look at the item’s attributes. This is why <code>ls</code> or <code class="pre">ls -i</code> are much faster than <code class="pre">ls -l</code> on a huge directory:</p>
<ol type="a">
<li><code>ls</code> or <code class="pre">ls -i</code> only need to read 
the names and inode numbers from the directory – no additional inode 
access is needed because no other attributes are being queried. Reading 
the one directory inode is sufficient.</li>
<li><code class="pre">ls -l</code> has to display attribute information 
for every object named in the directory, so it has to do a separate 
inode lookup to find out the inode attribute information for every inode
 in the directory. A directory with 1000 names in it requires 1000 
separate inode lookups to fetch the attributes!</li>
</ol>
<p>No attribute information about the things named in the directory is 
kept in the directory (except on those modern file systems where caching
 of inode type is enabled). The directory only contains pairs of names 
and inode numbers.</p>
<p>To find a thing by name, the system goes to a directory inode, looks 
up the name in the disk space allocated to that directory, finds the 
inode number associated with the name, then goes out to the disk a 
second time and finds that inode on the disk. If that inode is another 
directory, the process repeats from left-to-right along the pathname 
until the inode of the last pathname component (on the far right in the 
pathname) is found. Then the disk block pointers of that last inode can 
be used to find the data contents of the last pathname component.</p>
</section>
<section id="damaged-directories-create-orphans" class="level2" data-number="4.2">
<h2 data-number="4.2"><span class="header-section-number">4.2</span> Damaged directories create orphans<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>The name and inode number pairing in a Unix directory is the only 
connection between a name and the thing it names on disk. The name is 
kept separate from the data belonging to the thing it names (the actual 
inode on disk).</p>
<p>If a disk error damages a directory inode or the directory disk 
blocks, file data is not usually lost; since, the actual data for the 
things named in the directory are stored in inodes separate from the 
directory itself.</p>
<p>If a directory is damaged, only the names of the things are lost and 
the inodes become “orphan” inodes without names. The storage used for 
the things themselves is elsewhere on disk and may be undamaged. You can
 run a file system recovery program such as <code>fsck</code> to recover the data (but not the names).</p>
<p>The name of an item (file, directory, etc.) and its inode number are 
the only things kept in a directory. The directory storage for that name
 and number is managed by its own inode that is separate from the inode 
of each thing in the directory. The name and number are stored in the 
directory inode; the data for the item named is stored in its own inode 
somewhere else.</p>
</section>
</section>
<section id="multiple-names-hard-links" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Multiple names – hard links<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<p>Because (1) data in a file is managed by an inode with a unique 
number, (2) the name of the file is not kept in that inode, and (3) 
directories pair names with inode numbers, a Unix file (inode) can be 
given multiple names by having multiple name-and-inode pairs in one or 
more directories.</p>
<p>Inode <code>123</code> may be paired with the name <code>cat</code> in one directory and the same <code>123</code> may be paired with the name <code>dog</code> in the same or a different directory. Either name leads to the same <code>123</code> file inode and the same data and attributes. Though there appear to be two different files <code>cat</code> and <code>dog</code>
 in the directory, the only thing different between the two is the name –
 both names lead to the same inode and therefore to the same data and 
attributes (permissions, owner, etc.).</p>
<blockquote>
<p>You can use <code class="pre">ls -i</code> to see the inode numbers paired with each name, and the <code>find</code> command has a useful <code>-inum</code> expression operator.</p>
</blockquote>
<section id="link-counts-count-names-ln-creates-rm-removes-only-a-name" class="level2" data-number="5.1">
<h2 data-number="5.1"><span class="header-section-number">5.1</span> Link counts count names; <code>ln</code> creates, <code>rm</code> removes only a name<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Multiple names for the same inode are called “hard links”. The system
 keeps a “link count” in each inode that counts the number of names each
 inode has been given. The <code>ln</code> command can create a new name
 (a new hard link) in a directory for an existing file inode, increasing
 the file’s inode link count. The <code>rm</code> command removes a name (a hard link) from a directory, decreasing the file’s inode link count.</p>
<p>When the link count for an inode goes to zero, the inode has no names
 and the inode is freed and recycled and all the storage and data used 
by the item is released.</p>
<p>The <code>rm</code> command does not remove <em>files</em>; it removes <em>names</em>
 for files. When all the names for a file inode are removed, the system 
removes the inode itself and releases all the disk space.</p>
<p>As long as an inode has at least one name is some directory (a non-zero link count), it cannot be freed up and released.</p>
</section>
</section>
<section id="tracing-inodes-in-pathnames-ascii-art" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Tracing Inodes in Pathnames – ASCII Art<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<p>Below is an ASCII Art diagram of some directories and a hard-linked file with two names.</p>
<section id="slashes-separate-names-in-pathnames" class="level2" data-number="6.1">
<h2 data-number="6.1"><span class="header-section-number">6.1</span> Slashes separate names in pathnames<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>When you look at a Unix pathname, remember that that the slashes 
separate the names of the pathname components. All the components to the
 left of the rightmost slash must be directories, including the “empty” 
ROOT directory name to the left of the leftmost slash. For example:</p>
<pre><code>/home/alex/foobar</code></pre>
<p>In the above example, there are three slashes and therefore four pathname components:</p>
<ol type="1">
<li>The nameless ROOT directory is the start of this absolute pathname.</li>
<li>Inside the above ROOT directory is the name of the <code>home</code> directory.</li>
<li>Inside the above <code>home</code> directory is the name of the <code>alex</code> directory.</li>
<li>Inside the above <code>alex</code> directory is the name of the <code>foobar</code> file.</li>
</ol>
<blockquote>
<p>The “empty” name in front of the first slash is the name of the ROOT 
directory. The ROOT directory doesn’t have a name. (Some books get 
around this by calling the ROOT directory “slash” or <code>/</code>. That is wrong. ROOT doesn’t have a name – slashes <em>separate</em> names.)</p>
</blockquote>
<p>The last (rightmost) component of a pathname can be a file or a 
directory (or any other thing, such as a symbolic link); for this 
example, let’s assume <code>foobar</code> is a name for a file inode.</p>
</section>
<section id="names-reside-above-the-things-they-name" class="level2" data-number="6.2">
<h2 data-number="6.2"><span class="header-section-number">6.2</span> Names reside above the things they name<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Below is a file system diagram written correctly, with the names for things shown in the directory one level <em>above</em>
 the things to which the names actually refer. Each box represents an 
inode; the inode numbers for the box are given beside the box, on the 
left.</p>
<p>Inside the directory inodes you can see the pairing of names and 
inode numbers. (These inode numbers are made up – see your actual Unix 
system for some real inode numbers.)</p>
<p>One of the inodes below, <code>#12</code>, is not a directory; it is an inode for a file and the inode contains the file data.</p>
<p>The downward arrows in the diagram trace two paths (hard links) to the same <code>#12</code> file data, <code>/home/alex/foobar</code> and <code>/home/alex/literature/barfoo</code>.</p>
<p>We will trace the inodes for two pathnames in the diagram below:</p>
<ol type="1">
<li><code>/home/alex/foobar</code></li>
<li><code>/home/alex/literature/barfoo</code></li>
</ol>
<p>Follow the downward-pointing arrows:</p>
<pre><code>    +----+-----+-----------------------------------------+
#2  |. 2 |.. 2 | home 5 | usr 9 | tmp 11 | etc 23 | ...  |
    +----+-----+--v--------------------------------------+
                  |  The inode #2 above is the ROOT directory. It has the
                  |  name "home" in it. The *directory* "home" is not
                  |  here; only the *name* is here. The ROOT directory
                  |  itself does not have a name, because there is no
                  V  directory above it to give it a name!
    +----+-----+---------------------------------------------------+
#5  |. 5 |.. 2 | alex 31 | leslie 36 | pat 39 | abcd0001 21 | ...  |
    +----+-----+--v------------------------------------------------+
                  |  The inode #5 above is the "home" directory. The name
                  |  "home" isn't here; it's up in the ROOT directory,
                  |  above. This directory has the name "alex" in it.
                  V
    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+--v-----------------------------v------------------+
                  |  The inode #31 above is     |
                  |  the "alex" directory. The  |
                  |  name "alex" isn't here;    |
                  |  it's up in the "home"      |
                  |  directory, above.  This    |
                  |  directory has the names    |
                  |  "foobar" and "literature"  |
                  |  in it.                     |
                  |                             V
    +----+-----+--|-------------------------------------------+
#7  |. 7 |.. 31|  |  barfoo 12 | morestuf 123 | junk 99 | ... |
    +----+-----+--|-------v-----------------------------------+
                  |       |  The inode #7 above is the "literature" directory.
                  |       |  The name "literature" isn't here; it's up
                  |       |  in the "alex" directory.  This directory has
                  |       |  the name "barfoo" in it.
                  |       |
                  V       V
                 *-----------*  This inode #12 on the left is a file inode.
                 | file data |  It contains pointers to the data blocks for the file.
             #12 | file data |  This file inode has two names, "foobar" and "barfoo",
                 | file data |  but those names are not here.  Those two names are up
                 *-----------*  up in the two directories that point to this file, above.
                                Because this inode has two names, it has a link count of two.</code></pre>
<p>The absolute pathname <code>/home/alex/foobar</code> starts at the nameless ROOT directory, inode <code>#2</code>. It travels through two more directory inodes and stops at file inode <code>#12</code>. Using all four inode numbers, <code>/home/alex/foobar</code> could be written as <code>#2-&gt;#5-&gt;#31-&gt;#12</code>.</p>
<p>The absolute pathname <code>/home/alex/literature/barfoo</code> starts at the ROOT inode and travels through three more directory inodes. It stops at the same <code>#12</code> file inode as <code>/home/alex/foobar</code>. Using all five inode numbers, <code>/home/alex/literature/barfoo</code> could be written as <code>#2-&gt;#5-&gt;#31-&gt;#7-&gt;#12</code>.</p>
<p>Thus, <code>/home/alex/foobar</code> and <code>/home/alex/literature/barfoo</code> are two absolute pathnames leading to the same inode <code>#12</code> file data. The names <code>foobar</code> and <code>barfoo</code> are two names for the same file and are called “hard links”. Because the file inode <code>#12</code> has two names, it has a “link count” of two.</p>
<p>Let’s examine each of the two pathnames and their inodes in more detail.</p>
</section>
<section id="tracing-pathname-1-homealexfoobar" class="level2" data-number="6.3">
<h2 data-number="6.3"><span class="header-section-number">6.3</span> Tracing Pathname 1: <code>/home/alex/foobar</code><span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<blockquote>
<p>Remember: Directories are chunks of storage that pair names with 
inode numbers. That is all that is in a directory: names and inode 
numbers.</p>
</blockquote>
<p>The box below represents the layout of names and inode numbers inside
 the actual disk space given to the nameless ROOT directory, inode <code>#2</code>:</p>
<pre><code>    +----+-----+-----------------------------------------+
#2  |. 2 |.. 2 | home 5 | usr 9 | tmp 11 | etc 23 | ...  |
    +----+-----+-----------------------------------------+</code></pre>
<p>If you look at the ROOT directory above, you will see that both the name <code>.</code> and the name <code>..</code> in this ROOT directory are paired with inode <code>#2</code>, the inode number of the ROOT directory itself.</p>
<p>Following either name <code>.</code> or <code>..</code> will lead to inode <code>#2</code> and right back to this same ROOT inode. The ROOT directory is the only directory that is its own parent.</p>
<p>The above ROOT directory has the name <code>home</code> in it, paired with inode <code>#5</code>. The actual disk <em>space</em> of the directory <code>home</code> is not here; only the <em>name</em> <code>home</code> is here, along with its own inode number <code>#5</code>. To read the actual contents of the <code>home</code> directory, find the disk space managed by inode <code>#5</code> somewhere else on disk and look there. (In fact, until we look up inode <code>#5</code> and find out that it is a directory inode, we have no way of even knowing that the name <code>home</code> is a name of a directory!)</p>
<p>The above ROOT directory pairing of <code>home</code> with inode <code>#5</code> is what gives the <code>home</code> directory inode its name. The name <code>home</code> is separate from the disk space for <code>home</code>. The ROOT directory itself does not have a name; because, it has no parent directory to give it a name!</p>
<p>Let us move to the storage space for the <code>home</code> directory at inode <code>#5</code>.</p>
<p>The box below represents the layout of names and inode numbers inside the actual disk space given to the <code>home</code> directory, inode <code>#5</code>:</p>
<pre><code>    +----+-----+---------------------------------------------------+
#5  |. 5 |.. 2 | alex 31 | leslie 36 | pat 39 | abcd0001 21 | ...  |
    +----+-----+---------------------------------------------------+</code></pre>
<p>The name <code>home</code> for this inode <code>#5</code>isn’t found in this inode; the name <code>home</code> is given to inode <code>#5</code> up in the ROOT directory. Names are separate from the things they name.</p>
<p>We see that the name <code>.</code> above leads back to this same <code>#5</code> inode, which is why <code>/home</code> and <code>/home/.</code> lead to the same <code>#5</code> inode.</p>
<p>We see that the name <code>..</code> above leads up to the parent <code>#2</code> inode (the ROOT inode), which is why <code>/home/..</code> leads us to <code>/</code> the ROOT.</p>
<p>The above <code>home</code> directory has the name <code>alex</code> in it, paired with inode <code>#31</code>. The actual disk <em>space</em> of the directory <code>alex</code> is not here; only the <em>name</em> <code>alex</code> is here, along with its own inode number <code>#31</code>. To read the actual contents of the <code>alex</code> directory, find the disk space manged by inode <code>#31</code> somewhere on disk and look there. (In fact, until we look up inode <code>#31</code> and find out that it is a directory inode, we have no way of even knowing that the name <code>alex</code> is a name of a directory!)</p>
<p>The above <code>home</code> directory pairing of <code>alex</code> with inode <code>#31</code> is what gives the <code>alex</code> directory inode its name. The name <code>alex</code> is separate from the disk space for <code>alex</code>.</p>
<p>Let us move to the storage space for the <code>alex</code> directory at inode <code>#31</code>.</p>
<p>The box below represents the layout of names and inode numbers inside the actual disk space given to the <code>alex</code> directory, inode <code>#31</code>:</p>
<pre><code>    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+---------------------------------------------------+</code></pre>
<p>The name <code>alex</code> for this inode isn’t in this inode; the name <code>alex</code> is given to inode <code>#31</code> up in the <code>home</code> directory. Names are separate from the things they name.</p>
<p>We see that the name <code>.</code> above leads back to this same <code>#31</code> inode, which is why <code>/home/alex</code> and <code>/home/alex/.</code> lead to the same <code>#31</code> inode.</p>
<p>We see that the name <code>..</code> above leads up to the parent <code>#5</code> inode (the <code>/home</code> inode), which is why <code>/home/alex/..</code> leads us to <code>/home</code>.</p>
<p>The above <code>alex</code> directory has the name <code>foobar</code> in it, paired with inode <code>#12</code>. The actual disk <em>space</em> of the file <code>foobar</code> is not here; only the <em>name</em> <code>foobar</code> is here, along with its own inode number <code>#12</code>. To read the actual data of the file <code>foobar</code>, find the disk space managed by inode <code>#12</code> somewhere on disk and look there. (In fact, until we look up inode <code>#12</code> and find out that it is a plain file inode, we no way of even knowing that the name <code>foobar</code> is a name of a plain file!)</p>
<p>The above <code>alex</code> directory pairing of <code>foobar</code> with inode <code>#12</code> is what gives the <code>foobar</code> file inode one of its two names. The name <code>foobar</code> is separate from the disk space for <code>foobar</code>.</p>
<p>Let us move to the storage space for the <code>foobar</code> file at inode <code>#12</code>.</p>
<p>The box below represents the actual disk space given to the <code>foobar</code> file, inode <code>#12</code>:</p>
<pre><code>    *-----------*
#12 | file data |
    *-----------*</code></pre>
<p>The name <code>foobar</code> for this inode isn’t in this inode; the name <code>foobar</code> is up in the <code>alex</code> directory. Names are separate from the things they name.</p>
<blockquote>
<p>This <code>foobar</code> inode is a file inode, not a directory 
inode, and the attributes of this inode will indicate that. All the 
attributes of an inode – type, permissions, owner, group, modify date, 
etc. – are stored in the inode itself. The only thing <em>not</em> stored in the inode is the <em>name</em> of the inode, which is always stored in the directory above the inode (the parent directory of the inode).</p>
</blockquote>
<p>The inode for a file contains pointers to disk blocks that contain 
file data, not directory data. There are no special directory names <code>.</code> and <code>..</code>
 in files. There are no names here at all; the disk block pointers in 
this inode point to just file data (whatever is in the file).</p>
<p>This completes the inode trace for <code>/home/alex/foobar</code>: <code>#2-&gt;#5-&gt;#31-&gt;#12</code></p>
<p>But <code>foobar</code> is just one of the names for inode <code>#12</code>; it has another name, too.</p>
</section>
<section id="tracing-pathname-2-homealexliteraturebarfoo" class="level2" data-number="6.4">
<h2 data-number="6.4"><span class="header-section-number">6.4</span> Tracing Pathname 2: <code>/home/alex/literature/barfoo</code><span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<blockquote>
<p>Remember: Directories are chunks of storage that pair names with 
inode numbers. That is all that is in a directory: names and inode 
numbers.</p>
</blockquote>
<p>Let’s now trace the inode path for the name <code>/home/alex/literature/barfoo</code>. This pathname is a “hard link” to <code>/home/alex/foobar</code>; both the <code>foobar</code> and <code>barfoo</code> names point to the same inode number. Let’s see how this is possible.</p>
<p>The trace from ROOT through <code>/home/alex</code> is the same as before. Things change in our second trace because of <code>/home/alex/literature</code>.</p>
<p>If we look at the <code>alex</code> directory inode <code>#31</code> again, we see that the name <code>literature</code> is paired with inode <code>#7</code>:</p>
<pre><code>    +----+-----+---------------------------------------------------+
#31 |. 31|.. 5 | foobar 12 | temp 15 | literature 7 | demo 6 | ... |
    +----+-----+---------------------------------------------------+</code></pre>
<p>The above <code>alex</code> directory has the name <code>literature</code> in it, paired with inode <code>#7</code>. The actual disk <em>space</em> of the directory <code>literature</code> is not here; only the <em>name</em> <code>literature</code> is here, along with its own inode number <code>#7</code>. To read the actual contents of the directory <code>literature</code>, find the disk space managed by inode <code>#7</code> somewhere else on disk and look there. (In fact, until we look up inode <code>#7</code> and find out that it is a directory inode, we no way of even knowing that the name <code>literature</code> is a name of a directory!)</p>
<p>Let us move to the storage space for the <code>literature</code> directory at inode <code>#7</code>.</p>
<p>The box below represents the layout of names and inode numbers inside the actual disk space given to the <code>literature</code> directory, inode <code>#7</code>:</p>
<pre><code>    +----+-----+---------------------------------------------+
#7  |. 7 |.. 31|    barfoo 12 | morestuf 123 | junk 99 | ... |
    +----+-----+---------------------------------------------+</code></pre>
<p>The name <code>literature</code> for this inode isn’t in this inode; the name <code>literature</code> is given to inode <code>#7</code> up in the <code>alex</code> directory. Names are separate from the things they name.</p>
<p>We see that the name <code>.</code> above leads back to this same <code>#7</code> inode, which is why <code>/home/alex/literature</code> and <code>/home/alex/literature/.</code> lead to the same <code>#7</code> inode.</p>
<p>We see that the name <code>..</code> above leads up to the parent <code>#31</code> inode (the <code>/home/alex</code> inode), which is why <code>/home/alex/literature/..</code> leads us to <code>/home/alex</code>.</p>
<p>The above <code>literature</code> directory has the name <code>barfoo</code> in it, paired with inode <code>#12</code>. The actual disk <em>space</em> of the file <code>barfoo</code> is not here; only the <em>name</em> <code>barfoo</code> is here, along with its own inode number <code>#12</code>. To read the actual data of the file <code>barfoo</code>, find the disk space managed by inode <code>#12</code> somewhere on disk and look there. (In fact, until we look up inode <code>#12</code> and find out that it is a plain file inode, we no way of even knowing that the name <code>barfoo</code> is a name of a plain file!)</p>
<p>The above <code>literature</code> directory pairing of <code>barfoo</code> with inode <code>#12</code> is what gives the <code>barfoo</code> file inode the other one of its two names. The name <code>barfoo</code> is separate from the disk space for <code>barfoo</code>.</p>
<p>You will recall that we have seen inode <code>#12</code> in the previous trace. Above, in the <code>alex</code> directory (inode <code>#31</code>), inode <code>#12</code> was also paired with the name <code>foobar</code>. In the <code>literature</code> directory (inode <code>#7</code>), inode <code>#12</code> is paired with the name <code>barfoo</code>. Inode <code>#12</code> therefore has two different names; both names <code>foobar</code> and <code>barfoo</code> are both hard links to the same inode <code>#12</code>, and the <code>ls</code> command can prove this:</p>
<pre><code>$ ls -i /home/alex/foobar /home/alex/literature/barfoo
12 /home/alex/foobar   12 /home/alex/literature/barfoo</code></pre>
<p>Having two names means the “link count” of inode <code>#12</code> is set to “<code>2</code>”. Both names lead to the same <code>#12</code> inode and thus to the same data and same attributes. This is <em>one</em> single file with <em>two</em> names. A change to the file data using the name <code>foobar</code> changes the data in inode <code>#12</code>. That changes file data for the name <code>barfoo</code> too; because, <code>foobar</code> and <code>barfoo</code> are two names for the same <code>#12</code> inode storage – they are two names that point to the same storage inode.</p>
<p>All the inode attributes – everything about data inode <code>#12</code> except its name – is kept with the inode. The only thing different in a long listing of <code>foobar</code> and <code>barfoo</code>
 will be the names; everything else (file type, permissions, owner, 
group, link count, size, modification times, etc.) is part of inode <code>#12</code>
 and must therefore be identical for the two names. Neither name is more
 “original” than the other; both names have equal status. To release the
 <code>#12</code> inode storage, you have to delete both names so that the link count of inode <code>#12</code> drops to zero.</p>
</section>
<section id="summary-tracing-pathname-2-homealexliteraturebarfoo" class="level2" data-number="6.5">
<h2 data-number="6.5"><span class="header-section-number">6.5</span> Summary Tracing Pathname 2: <code>/home/alex/literature/barfoo</code><span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Let’s summarize the inodes used in this pathname:</p>
<pre><code>/home/alex/literature/barfoo</code></pre>
<p>Start on the left and walk the tree of names and inodes left to 
right. To be a valid Unix path, everything to the left of the rightmost 
slash must be a directory. (Thus, ROOT, <code>home</code>, <code>alex</code>, and <code>literature</code> must be directories, if this is a valid pathname.)</p>
<p>Start with the nameless ROOT directory in front of the first slash 
(ROOT doesn’t have a name, since it does not appear in any parent 
directory) and look for the first pathname component (<code>home</code>) inside that ROOT directory (inside inode <code>#2</code>).</p>
<p>Let’s trace the pathname:</p>
<p>Look in the ROOT directory (located in inode <code>#2</code>) for the name of the first pathname component: <code>home</code>. We find the name <code>home</code> inside the ROOT directory, paired with inode <code>#5</code>. Go back out to the disk to find inode <code>#5</code> that is the actual <code>home</code> directory.</p>
<blockquote>
<p>Note how the names are separate from the things they name. The actual directory inode <code>#5</code> of the <code>home</code> directory is not the same as the inode <code>#2</code> of the ROOT directory that contains the directory name <code>home</code>. The name is stored in a different place (<code>#2</code>) than the thing it names (<code>#5</code>).</p>
</blockquote>
<p>In inode <code>#5</code>, the directory inode that has the name <code>home</code>, look for the name <code>alex</code>. We find <code>alex</code> paired with inode <code>#31</code>. Go back out to the disk to find inode <code>#31</code> that is the actual <code>alex</code> directory inode. Again, the name <code>alex</code> is contained in directory inode <code>#5</code> (<code>home</code>) and that name is stored separately from inode <code>#31</code> that is the actual <code>alex</code> directory itself.</p>
<p>In inode <code>#31</code>, the directory inode that has the name <code>alex</code>, look for the name <code>literature</code>. We find <code>literature</code> paired with inode <code>#7</code>. Go back out to the disk to find inode <code>#7</code> that is the actual <code>literature</code> directory inode. Again, the name <code>literature</code> is contained in directory inode <code>#31</code> (<code>alex</code>) and that name is stored separately from the inode <code>#7</code> that is the actual <code>literature</code> directory itself.</p>
<p>In inode <code>#7</code>, the directory inode that has the name <code>literature</code>, look for the name <code>barfoo</code>. We find <code>barfoo</code> paired with inode <code>#12</code>. Go back out to the disk to find inode <code>#12</code> that is the actual data of the file <code>barfoo</code>. Again, the name <code>barfoo</code> is contained in directory inode <code>#7</code> (<code>literature</code>) and that name is stored separately from the inode <code>#12</code> that is the actual data of the file. The name of a file is not part of the inode that makes up the actual file data.</p>
<p>We have found the inode that is the file data: inode <code>#12</code>. The name of this file, <code>barfoo</code>, is stored up in inode <code>#7</code> that is the <code>literature</code> directory. The name is separate from the data it names.</p>
</section>
<section id="every-inode-has-a-link-count-a-count-of-names" class="level2" data-number="6.6">
<h2 data-number="6.6"><span class="header-section-number">6.6</span> Every inode has a link count: a count of names<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Every <strong>directory inode</strong> contains a name <code>..</code>
 (dot dot) paired with the number of the inode that is the unique parent
 directory of the inode. That unique parent directory is the only one 
containing the name of this inode. Because a directory can have only one
 parent, hard links are not permitted for directories. (The name <code>..</code> can only link to one parent directory.)</p>
<p>Directory inode <code>#5</code> above contains the name <code>..</code> paired with inode <code>#2</code> (the ROOT directory), and it is in that <code>#2</code> inode directory that we see that inode <code>#5</code> is paired with the name <code>home</code>. The parent directory of inode <code>#5</code> is the directory that contains the name <code>home</code>.</p>
<p>Unlike directory inodes, <strong>file inodes</strong> contain no 
record of which parent directories give it its names. The only thing 
that is recorded in the file inode is the number of names the inode has:
 the link count. File inode <code>#12</code> has two names, so it has a 
link count of two. The inode has no information about in which 
directories the two names are located.</p>
<p>There is no easy way to know which directories give a file inode its one or more names. In a file inode, there is no name <code>..</code>
 to point to a parent directory, because a file inode might have 
hundreds or thousands of parent directories (thousands of names).</p>
<p>If you have a file inode with multiple names (a link count larger 
than one) and you want to find the other names for the inode, you have 
to do a brute-force search in every directory on the file system to see 
which directories might have names paired with this inode number.</p>
<p>Usually, the multiple names for an inode are in the same directory or
 in directories that are closely related to each other (parent 
directories, sub-directories, or sibling directories), but that isn’t 
always the case. In the worst case, finding all the names for a file 
inode may require searching for that inode number in <em>every</em> directory in the whole file system, something that could take hours on a very large file system.</p>
<p>A file is deleted from disk only when its link count goes to zero, 
i.e.&nbsp;when all the names for the inode are removed. Then the disk 
blocks for the inode are returned to the system for use by other files, 
and the inode (with a zero link count) is returned to the pool of free 
and available inodes.</p>
</section>
<section id="permissions-on-data-vs.-permissions-on-directories" class="level2" data-number="6.7">
<h2 data-number="6.7"><span class="header-section-number">6.7</span> Permissions on data vs.&nbsp;permissions on directories<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h2>
<p>Each Unix inode has a set of permissions that govern what a process 
can do to that inode. Since names are stored in directory inodes, 
separate from the inodes of things they name, a process may have 
permissions to change the name of a thing in a directory inode without 
having permissions to change the data in the inode that is the thing 
itself, or vice-versa.</p>
<ul>
<li><p>If a process has permission to change a directory inode, it can 
change the names of things in that directory inode, including adding 
names (e.g.&nbsp;<code>ln</code>), removing names (e.g.&nbsp;<code>rm</code>), or renaming names (e.g.&nbsp;<code>mv</code>). These are operations on directory inodes.</p></li>
<li><p>If a process has permission to change a file inode, it can erase,
 append to, or change the content of the file itself. The file inode is 
different from the inode containing the name of the file.</p></li>
</ul>
<p>Names are stored in directory inodes, separate from the things they 
name, so a process may have permissions to change the content of a file 
(the file inode) without having permissions to change the name of the 
file (the directory inode containing the name), or vice-versa.</p>
<p>If file data inode <code>#12</code> above has appropriate permission 
attributes, a process could read or write the data in that file inode. 
It is the permission attributes on the inode <code>#12</code> containing the file <em>data</em> that govern what a process can do with the <em>data</em> in the file.</p>
<p>The two names of the file, either <code>foobar</code> or <code>barfoo</code>, are stored up in directory inodes separate from the inode <code>#12</code>. The permissions on the inodes of those two parent directories containing the <em>names</em> of the file do not control whether a process can modify the inode containing the <em>data</em> of the file. It is the inode that contains the data (<code>#12</code>) that controls whether a process can read or write the data in that inode.</p>
<p>Directory inodes have permissions that control whether a process is 
allowed to pass through the directory to access the things named in the 
directory. This is called <em>access</em> or <em>search</em> permission (<code>x</code>).</p>
<p>If the any of the inodes of the directories containing the names leading down to the file at inode <code>#12</code> don’t give the process <em>search</em>
 permission, the process won’t be able to reach the file’s data inode 
that way and won’t be able to access the file’s data using those 
directories; but, perhaps some other directories may lead the process to
 the same inode <code>#12</code>, if the file has another name.</p>
<p>To access and read the data in a file path such as:</p>
<pre><code>/home/alex/literature/barfoo</code></pre>
<p>you need appropriate <em>search</em> permissions on the ROOT directory inode, the <code>home</code> directory inode, the <code>alex</code> directory inode, the <code>literature</code> directory inode, and finally <em>read</em> permissions on the <code>barfoo</code> file data inode <code>#12</code>.</p>
<p>It is the file data inode <code>#12</code> permissions that determine whether or not you can read or change the <em>data</em> of the file. Reading or changing the data in the file requires permissions on the inode <code>#12</code> that contains the data blocks of the file itself.</p>
<p>It is the <code>literature</code> directory inode permissions (inode <code>#7</code>) that determine what you can do with the <em>name</em> <code>barfoo</code> of the file, because the <code>literature</code> directory (inode <code>#7</code>) is where the name <code>barfoo</code> is kept. Changing, linking to, or removing the name of a file operates on the inode of the <em>directory</em>
 in which the file name appears; altering the name has nothing to do 
with reading or changing the inode that contains the data blocks of the 
file itself.</p>
<p>You can have no permissions on the inode that contains the data 
blocks of the file itself (it may even be owned by some other user) and 
still you may be able to rename or remove one of the names of the file 
from a directory on whose inode you do have permissions. The name(s) of a
 file is(are) stored in separate inodes from the data blocks of the 
file.</p>
<p>Names are separate from the things that they name. The permissions of
 the names are also separate from the permissions of the data.</p>
<ul>
<li><p>Changing a <em>name</em> in a directory inode requires write and execute permissions on the <em>directory</em> inode containing the name. No permissions are needed on the inode containing the <em>data</em> of the thing being renamed. (Some recent Linux kernels have added security that changes this.)</p></li>
<li><p>Changing the <em>content</em> of a file only requires write permissions on the data inode of the <em>file</em> itself, not on the inode of any parent directory that holds one of the names of the file.</p></li>
</ul>
<p>Names are separate from the things they name, so two sets of 
permissions (two inodes) are always involved when a process tries to 
access a thing.</p>
</section>
</section>
<section id="exercise-questions-on-hard-links-and-directories" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Exercise Questions on Hard Links and Directories<span class="uptoTOC"><a href="#TOC">Index<img src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/toparrow.gif" alt="up to index" width="44" height="17"></a></span></h1>
<ul>
<li><p>Normally when you do <code class="pre">ls -l dir</code> you see the permissions of the <em>contents</em>
 of the directory, not the directory itself. What command and options 
are needed to see the access permissions and link count of the directory
 inode itself, instead of the <em>contents</em> of a directory? (See the Worksheets and also RTFM.)</p></li>
<li><p>When you are inside a directory, what is the name you use to 
refer to the directory itself? (This name works inside any directory.) 
What name always refers to the unique parent directory?</p></li>
<li><p>How many links (names) does a brand new, empty directory have? 
Why isn’t it just one link, as it is for a new file? (In other words, 
why does a new file have one link and a new directory have more than 
that?)</p></li>
<li><p>Why does creating a sub-directory in a directory cause the 
directory’s link (name) count to increase by one for every sub-directory
 created? (Recall that a link count is a count of names.)</p></li>
<li><p>Why doesn’t the link (name) count of the directory increase when you create files in the directory?</p></li>
<li><p>Give the Unix command and its output that shows the inode number 
and owners of the following directories. Only show the given directory; 
do not show any other directories:</p>
<ol type="a">
<li>your current directory</li>
<li>your parent directory</li>
<li>your HOME directory</li>
<li>the directory named <code>/home</code></li>
<li>the ROOT directory</li>
<li>the directory named <code>/root</code></li>
</ol>
<p>Note: Show only one line of output for each single directory; do not 
show the contents of the directory. Use a command (and options) that 
will show only the directory itself, not its contents. (RTFM)</p></li>
</ul>
<!-- References -->

	<div id="signature-block" class="slide section level1">
	<pre id="signature"><code><b>Author:</b> 
| Ian! D. Allen, BA, MMath  -  idallen@idallen.ca  -  Ottawa, Ontario, Canada
| Home Page: http://idallen.com/   Contact Improv: http://contactimprov.ca/
| College professor (Free/Libre GNU+Linux) at: http://teaching.idallen.com/
| Defend digital freedom:  http://eff.org/  and have fun:  http://fools.ca/</code></pre>
<p><a href="http://teaching.idallen.org/cst8207/19w/notes/450_file_system.txt">Plain Text</a> - plain text version of this page in <a href="http://johnmacfarlane.net/pandoc/">Pandoc Markdown</a> format <!-- vim:set softtabstop=4 expandtab: --></p>
</div></section>
	<div id="logo-block" class="slide section level1"> 
	<p> 
	    <a href="http://www.anybrowser.org/campaign/"> 
		<img style="border:0;width:88px;height:31px" src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/anybrowser3.gif" alt="Campaign for non-browser-specific HTML"></a> 
	    &nbsp; 
	    <a href="http://validator.w3.org/check?uri=referer"> 
		<img style="border:0;width:88px;height:31px" src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/valid-xhtml10.png" alt="Valid XHTML 1.0 Transitional"></a> 
	    &nbsp; 
	    <a href="http://jigsaw.w3.org/css-validator/check/referer"> 
		<img style="border:0;width:88px;height:31px" src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/vcss.gif" alt="Valid CSS!"></a> 
	    &nbsp; 
	    
	<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/"> 
	    <img style="border:0;width:88px;height:31px" src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/somerights.gif" alt="Creative Commons by nc sa 3.0"></a> 
	&nbsp; 
	<a href="http://www.catb.org/hacker-emblem/"> 
	    <img style="border:0;width:35px;height:31px" src="Unix_Linux%20File%20System%20%E2%80%93%20directories,%20inodes,%20hard%20links_files/glider-small.png" alt="Hacker Ideals Emblem"></a> 
	 
	    &nbsp; 
	    <span style="vertical-align: 50%"> 
	    Author <a href="http://idallen.com/">Ian! D. Allen</a> 
	    </span> 
	</p> 
	</div>


</body></html>