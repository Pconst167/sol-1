0001   0000             ; --- FILENAME: ../solarium/usr/bin/ansitest.c
0002   0000             ; --- DATE:     25-10-2025 at 01:19:04
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; unsigned int fg, bg, color; 
0012   0408 52 02 00      sub sp, 2
0013   040B 52 02 00      sub sp, 2
0014   040E 52 02 00      sub sp, 2
0015   0411             ; printf("\033[2J\033[H"); 
0016   0411             ; --- START FUNCTION CALL
0017   0411 26 18 0F      mov b, _s0 ; "\033[2J\033[H"
0018   0414 FD AB         swp b
0019   0416 D8            push b
0020   0417 07 C0 05      call printf
0021   041A 51 02 00      add sp, 2
0022   041D             ; --- END FUNCTION CALL
0023   041D             ; printf("\033[1mBold Text\033[0m\n"); 
0024   041D             ; --- START FUNCTION CALL
0025   041D 26 20 0F      mov b, _s1 ; "\033[1mBold Text\033[0m\n"
0026   0420 FD AB         swp b
0027   0422 D8            push b
0028   0423 07 C0 05      call printf
0029   0426 51 02 00      add sp, 2
0030   0429             ; --- END FUNCTION CALL
0031   0429             ; printf("\033[4mUnderlined Text\033[0m\n"); 
0032   0429             ; --- START FUNCTION CALL
0033   0429 26 33 0F      mov b, _s2 ; "\033[4mUnderlined Text\033[0m\n"
0034   042C FD AB         swp b
0035   042E D8            push b
0036   042F 07 C0 05      call printf
0037   0432 51 02 00      add sp, 2
0038   0435             ; --- END FUNCTION CALL
0039   0435             ; printf("\033[5mBlinking Text\033[0m\n"); 
0040   0435             ; --- START FUNCTION CALL
0041   0435 26 4C 0F      mov b, _s3 ; "\033[5mBlinking Text\033[0m\n"
0042   0438 FD AB         swp b
0043   043A D8            push b
0044   043B 07 C0 05      call printf
0045   043E 51 02 00      add sp, 2
0046   0441             ; --- END FUNCTION CALL
0047   0441             ; printf("\033[7mInverted Colors\033[0m\n"); 
0048   0441             ; --- START FUNCTION CALL
0049   0441 26 63 0F      mov b, _s4 ; "\033[7mInverted Colors\033[0m\n"
0050   0444 FD AB         swp b
0051   0446 D8            push b
0052   0447 07 C0 05      call printf
0053   044A 51 02 00      add sp, 2
0054   044D             ; --- END FUNCTION CALL
0055   044D             ; printf("Reset All\n\n"); 
0056   044D             ; --- START FUNCTION CALL
0057   044D 26 7C 0F      mov b, _s5 ; "Reset All\n\n"
0058   0450 FD AB         swp b
0059   0452 D8            push b
0060   0453 07 C0 05      call printf
0061   0456 51 02 00      add sp, 2
0062   0459             ; --- END FUNCTION CALL
0063   0459             ; for (bg = 40; bg <= 47; ++bg) { 
0064   0459             _for1_init:
0065   0459 FA FD FF      lea d, [bp + -3] ; $bg
0066   045C DA            push d
0067   045D FD 2E 28 00   mov32 cb, $00000028
0067   0461 00 00 
0068   0463 E7            pop d
0069   0464 FD 43         mov [d], b
0070   0466             _for1_cond:
0071   0466 FA FD FF      lea d, [bp + -3] ; $bg
0072   0469 2A            mov b, [d]
0073   046A 38 00 00      mov c, 0
0074   046D             ; --- START RELATIONAL
0075   046D D7            push a
0076   046E 11            mov a, b
0077   046F FD 2E 2F 00   mov32 cb, $0000002f
0077   0473 00 00 
0078   0475 B0            cmp a, b
0079   0476 FD 76         sleu ; <= (unsigned)
0080   0478 E4            pop a
0081   0479             ; --- END RELATIONAL
0082   0479 C0 00 00      cmp b, 0
0083   047C C6 01 05      je _for1_exit
0084   047F             _for1_block:
0085   047F             ; for (fg = 30; fg <= 37; ++fg) { 
0086   047F             _for2_init:
0087   047F FA FF FF      lea d, [bp + -1] ; $fg
0088   0482 DA            push d
0089   0483 FD 2E 1E 00   mov32 cb, $0000001e
0089   0487 00 00 
0090   0489 E7            pop d
0091   048A FD 43         mov [d], b
0092   048C             _for2_cond:
0093   048C FA FF FF      lea d, [bp + -1] ; $fg
0094   048F 2A            mov b, [d]
0095   0490 38 00 00      mov c, 0
0096   0493             ; --- START RELATIONAL
0097   0493 D7            push a
0098   0494 11            mov a, b
0099   0495 FD 2E 25 00   mov32 cb, $00000025
0099   0499 00 00 
0100   049B B0            cmp a, b
0101   049C FD 76         sleu ; <= (unsigned)
0102   049E E4            pop a
0103   049F             ; --- END RELATIONAL
0104   049F C0 00 00      cmp b, 0
0105   04A2 C6 E7 04      je _for2_exit
0106   04A5             _for2_block:
0107   04A5             ; printf("\033[%d;%dm %d/%d ", fg, bg, fg, bg); 
0108   04A5             ; --- START FUNCTION CALL
0109   04A5 FA FD FF      lea d, [bp + -3] ; $bg
0110   04A8 2A            mov b, [d]
0111   04A9 38 00 00      mov c, 0
0112   04AC FD AB         swp b
0113   04AE D8            push b
0114   04AF FA FF FF      lea d, [bp + -1] ; $fg
0115   04B2 2A            mov b, [d]
0116   04B3 38 00 00      mov c, 0
0117   04B6 FD AB         swp b
0118   04B8 D8            push b
0119   04B9 FA FD FF      lea d, [bp + -3] ; $bg
0120   04BC 2A            mov b, [d]
0121   04BD 38 00 00      mov c, 0
0122   04C0 FD AB         swp b
0123   04C2 D8            push b
0124   04C3 FA FF FF      lea d, [bp + -1] ; $fg
0125   04C6 2A            mov b, [d]
0126   04C7 38 00 00      mov c, 0
0127   04CA FD AB         swp b
0128   04CC D8            push b
0129   04CD 26 88 0F      mov b, _s6 ; "\033[%d;%dm %d/%d "
0130   04D0 FD AB         swp b
0131   04D2 D8            push b
0132   04D3 07 C0 05      call printf
0133   04D6 51 0A 00      add sp, 10
0134   04D9             ; --- END FUNCTION CALL
0135   04D9             _for2_update:
0136   04D9 FA FF FF      lea d, [bp + -1] ; $fg
0137   04DC 2A            mov b, [d]
0138   04DD FD 77         inc b
0139   04DF FA FF FF      lea d, [bp + -1] ; $fg
0140   04E2 FD 43         mov [d], b
0141   04E4 0A 8C 04      jmp _for2_cond
0142   04E7             _for2_exit:
0143   04E7             ; printf("\033[0m\n"); 
0144   04E7             ; --- START FUNCTION CALL
0145   04E7 26 98 0F      mov b, _s7 ; "\033[0m\n"
0146   04EA FD AB         swp b
0147   04EC D8            push b
0148   04ED 07 C0 05      call printf
0149   04F0 51 02 00      add sp, 2
0150   04F3             ; --- END FUNCTION CALL
0151   04F3             _for1_update:
0152   04F3 FA FD FF      lea d, [bp + -3] ; $bg
0153   04F6 2A            mov b, [d]
0154   04F7 FD 77         inc b
0155   04F9 FA FD FF      lea d, [bp + -3] ; $bg
0156   04FC FD 43         mov [d], b
0157   04FE 0A 66 04      jmp _for1_cond
0158   0501             _for1_exit:
0159   0501             ; printf("\n256-Color Chart:\n"); 
0160   0501             ; --- START FUNCTION CALL
0161   0501 26 9E 0F      mov b, _s8 ; "\n256-Color Chart:\n"
0162   0504 FD AB         swp b
0163   0506 D8            push b
0164   0507 07 C0 05      call printf
0165   050A 51 02 00      add sp, 2
0166   050D             ; --- END FUNCTION CALL
0167   050D             ; for (color = 0; color < 256; ++color) { 
0168   050D             _for3_init:
0169   050D FA FB FF      lea d, [bp + -5] ; $color
0170   0510 DA            push d
0171   0511 FD 2E 00 00   mov32 cb, $00000000
0171   0515 00 00 
0172   0517 E7            pop d
0173   0518 FD 43         mov [d], b
0174   051A             _for3_cond:
0175   051A FA FB FF      lea d, [bp + -5] ; $color
0176   051D 2A            mov b, [d]
0177   051E 38 00 00      mov c, 0
0178   0521             ; --- START RELATIONAL
0179   0521 D7            push a
0180   0522 11            mov a, b
0181   0523 FD 2E 00 01   mov32 cb, $00000100
0181   0527 00 00 
0182   0529 B0            cmp a, b
0183   052A FD 75         slu ; < (unsigned)
0184   052C E4            pop a
0185   052D             ; --- END RELATIONAL
0186   052D C0 00 00      cmp b, 0
0187   0530 C6 AB 05      je _for3_exit
0188   0533             _for3_block:
0189   0533             ; printf("\033[48;5;%dm %3d \033[0m", color, color); 
0190   0533             ; --- START FUNCTION CALL
0191   0533 FA FB FF      lea d, [bp + -5] ; $color
0192   0536 2A            mov b, [d]
0193   0537 38 00 00      mov c, 0
0194   053A FD AB         swp b
0195   053C D8            push b
0196   053D FA FB FF      lea d, [bp + -5] ; $color
0197   0540 2A            mov b, [d]
0198   0541 38 00 00      mov c, 0
0199   0544 FD AB         swp b
0200   0546 D8            push b
0201   0547 26 B1 0F      mov b, _s9 ; "\033[48;5;%dm %3d \033[0m"
0202   054A FD AB         swp b
0203   054C D8            push b
0204   054D 07 C0 05      call printf
0205   0550 51 06 00      add sp, 6
0206   0553             ; --- END FUNCTION CALL
0207   0553             ; if ((color + 1) % 16 == 0) 
0208   0553             _if4_cond:
0209   0553 FA FB FF      lea d, [bp + -5] ; $color
0210   0556 2A            mov b, [d]
0211   0557 38 00 00      mov c, 0
0212   055A             ; --- START TERMS
0213   055A D7            push a
0214   055B 11            mov a, b
0215   055C FD 2E 01 00   mov32 cb, $00000001
0215   0560 00 00 
0216   0562 56            add b, a
0217   0563 E4            pop a
0218   0564             ; --- END TERMS
0219   0564             ; --- START FACTORS
0220   0564 D7            push a
0221   0565 FD D8         push g
0222   0567 11            mov a, b
0223   0568 FD 7A         mov g, c
0224   056A FD 2E 10 00   mov32 cb, $00000010
0224   056E 00 00 
0225   0570 FD D8         push g ; save 'g' as the div instruction uses it
0226   0572 AE            div a, b ; %, a: quotient, b: remainder
0227   0573 11            mov a, b
0228   0574 FD F1         pop g
0229   0576 FD 38         mov c, g
0230   0578 27            mov b, a
0231   0579 FD F1         pop g
0232   057B E4            pop a
0233   057C             ; --- END FACTORS
0234   057C             ; --- START RELATIONAL
0235   057C D7            push a
0236   057D 11            mov a, b
0237   057E FD 2E 00 00   mov32 cb, $00000000
0237   0582 00 00 
0238   0584 B0            cmp a, b
0239   0585 FD 71         seq ; ==
0240   0587 E4            pop a
0241   0588             ; --- END RELATIONAL
0242   0588 C0 00 00      cmp b, 0
0243   058B C6 9D 05      je _if4_exit
0244   058E             _if4_TRUE:
0245   058E             ; printf("\n"); 
0246   058E             ; --- START FUNCTION CALL
0247   058E 26 C5 0F      mov b, _s10 ; "\n"
0248   0591 FD AB         swp b
0249   0593 D8            push b
0250   0594 07 C0 05      call printf
0251   0597 51 02 00      add sp, 2
0252   059A             ; --- END FUNCTION CALL
0253   059A 0A 9D 05      jmp _if4_exit
0254   059D             _if4_exit:
0255   059D             _for3_update:
0256   059D FA FB FF      lea d, [bp + -5] ; $color
0257   05A0 2A            mov b, [d]
0258   05A1 FD 77         inc b
0259   05A3 FA FB FF      lea d, [bp + -5] ; $color
0260   05A6 FD 43         mov [d], b
0261   05A8 0A 1A 05      jmp _for3_cond
0262   05AB             _for3_exit:
0263   05AB             ; printf("\n"); 
0264   05AB             ; --- START FUNCTION CALL
0265   05AB 26 C5 0F      mov b, _s10 ; "\n"
0266   05AE FD AB         swp b
0267   05B0 D8            push b
0268   05B1 07 C0 05      call printf
0269   05B4 51 02 00      add sp, 2
0270   05B7             ; --- END FUNCTION CALL
0271   05B7             ; return 0; 
0272   05B7 FD 2E 00 00   mov32 cb, $00000000
0272   05BB 00 00 
0273   05BD F9            leave
0274   05BE 05 0B         syscall sys_terminate_proc
0275   05C0             
0276   05C0             printf:
0277   05C0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0278   05C3             ; char *p, *format_p; 
0279   05C3 52 01 00      sub sp, 1
0280   05C6 52 02 00      sub sp, 2
0281   05C9             ; format_p = format; 
0282   05C9 FA FE FF      lea d, [bp + -2] ; $format_p
0283   05CC DA            push d
0284   05CD FA 05 00      lea d, [bp + 5] ; $format
0285   05D0 2A            mov b, [d]
0286   05D1 38 00 00      mov c, 0
0287   05D4 E7            pop d
0288   05D5 FD 43         mov [d], b
0289   05D7             ; p = &format + 2; 
0290   05D7 FA 00 00      lea d, [bp + 0] ; $p
0291   05DA DA            push d
0292   05DB FA 05 00      lea d, [bp + 5] ; $format
0293   05DE 2D            mov b, d
0294   05DF             ; --- START TERMS
0295   05DF D7            push a
0296   05E0 11            mov a, b
0297   05E1 FD 2E 02 00   mov32 cb, $00000002
0297   05E5 00 00 
0298   05E7 56            add b, a
0299   05E8 E4            pop a
0300   05E9             ; --- END TERMS
0301   05E9 E7            pop d
0302   05EA FD 3E         mov [d], bl
0303   05EC             ; for(;;){ 
0304   05EC             _for7_init:
0305   05EC             _for7_cond:
0306   05EC             _for7_block:
0307   05EC             ; if(!*format_p) break; 
0308   05EC             _if8_cond:
0309   05EC FA FE FF      lea d, [bp + -2] ; $format_p
0310   05EF 2A            mov b, [d]
0311   05F0 38 00 00      mov c, 0
0312   05F3 74            mov d, b
0313   05F4 32            mov bl, [d]
0314   05F5 A7 00         mov bh, 0
0315   05F7 38 00 00      mov c, 0
0316   05FA C0 00 00      cmp b, 0
0317   05FD FD 71         seq ; !
0318   05FF C0 00 00      cmp b, 0
0319   0602 C6 0B 06      je _if8_else
0320   0605             _if8_TRUE:
0321   0605             ; break; 
0322   0605 0A CC 08      jmp _for7_exit ; for break
0323   0608 0A B9 08      jmp _if8_exit
0324   060B             _if8_else:
0325   060B             ; if(*format_p == '%'){ 
0326   060B             _if9_cond:
0327   060B FA FE FF      lea d, [bp + -2] ; $format_p
0328   060E 2A            mov b, [d]
0329   060F 38 00 00      mov c, 0
0330   0612 74            mov d, b
0331   0613 32            mov bl, [d]
0332   0614 A7 00         mov bh, 0
0333   0616 38 00 00      mov c, 0
0334   0619             ; --- START RELATIONAL
0335   0619 D7            push a
0336   061A 11            mov a, b
0337   061B FD 2E 25 00   mov32 cb, $00000025
0337   061F 00 00 
0338   0621 B0            cmp a, b
0339   0622 FD 71         seq ; ==
0340   0624 E4            pop a
0341   0625             ; --- END RELATIONAL
0342   0625 C0 00 00      cmp b, 0
0343   0628 C6 A4 08      je _if9_else
0344   062B             _if9_TRUE:
0345   062B             ; format_p++; 
0346   062B FA FE FF      lea d, [bp + -2] ; $format_p
0347   062E 2A            mov b, [d]
0348   062F 38 00 00      mov c, 0
0349   0632 FD 77         inc b
0350   0634 FA FE FF      lea d, [bp + -2] ; $format_p
0351   0637 FD 43         mov [d], b
0352   0639 FD 7D         dec b
0353   063B             ; switch(*format_p){ 
0354   063B             _switch10_expr:
0355   063B FA FE FF      lea d, [bp + -2] ; $format_p
0356   063E 2A            mov b, [d]
0357   063F 38 00 00      mov c, 0
0358   0642 74            mov d, b
0359   0643 32            mov bl, [d]
0360   0644 A7 00         mov bh, 0
0361   0646 38 00 00      mov c, 0
0362   0649             _switch10_comparisons:
0363   0649 C1 6C         cmp bl, $6c
0364   064B C6 7C 06      je _switch10_case0
0365   064E C1 4C         cmp bl, $4c
0366   0650 C6 7C 06      je _switch10_case1
0367   0653 C1 64         cmp bl, $64
0368   0655 C6 94 07      je _switch10_case2
0369   0658 C1 69         cmp bl, $69
0370   065A C6 94 07      je _switch10_case3
0371   065D C1 75         cmp bl, $75
0372   065F C6 C8 07      je _switch10_case4
0373   0662 C1 78         cmp bl, $78
0374   0664 C6 FC 07      je _switch10_case5
0375   0667 C1 70         cmp bl, $70
0376   0669 C6 FC 07      je _switch10_case6
0377   066C C1 63         cmp bl, $63
0378   066E C6 30 08      je _switch10_case7
0379   0671 C1 73         cmp bl, $73
0380   0673 C6 64 08      je _switch10_case8
0381   0676 0A 95 08      jmp _switch10_default
0382   0679 0A A1 08      jmp _switch10_exit
0383   067C             _switch10_case0:
0384   067C             _switch10_case1:
0385   067C             ; format_p++; 
0386   067C FA FE FF      lea d, [bp + -2] ; $format_p
0387   067F 2A            mov b, [d]
0388   0680 38 00 00      mov c, 0
0389   0683 FD 77         inc b
0390   0685 FA FE FF      lea d, [bp + -2] ; $format_p
0391   0688 FD 43         mov [d], b
0392   068A FD 7D         dec b
0393   068C             ; if(*format_p == 'd' || *format_p == 'i') 
0394   068C             _if11_cond:
0395   068C FA FE FF      lea d, [bp + -2] ; $format_p
0396   068F 2A            mov b, [d]
0397   0690 38 00 00      mov c, 0
0398   0693 74            mov d, b
0399   0694 32            mov bl, [d]
0400   0695 A7 00         mov bh, 0
0401   0697 38 00 00      mov c, 0
0402   069A             ; --- START RELATIONAL
0403   069A D7            push a
0404   069B 11            mov a, b
0405   069C FD 2E 64 00   mov32 cb, $00000064
0405   06A0 00 00 
0406   06A2 B0            cmp a, b
0407   06A3 FD 71         seq ; ==
0408   06A5 E4            pop a
0409   06A6             ; --- END RELATIONAL
0410   06A6             ; --- START LOGICAL OR
0411   06A6 D7            push a
0412   06A7 11            mov a, b
0413   06A8 FA FE FF      lea d, [bp + -2] ; $format_p
0414   06AB 2A            mov b, [d]
0415   06AC 38 00 00      mov c, 0
0416   06AF 74            mov d, b
0417   06B0 32            mov bl, [d]
0418   06B1 A7 00         mov bh, 0
0419   06B3 38 00 00      mov c, 0
0420   06B6             ; --- START RELATIONAL
0421   06B6 D7            push a
0422   06B7 11            mov a, b
0423   06B8 FD 2E 69 00   mov32 cb, $00000069
0423   06BC 00 00 
0424   06BE B0            cmp a, b
0425   06BF FD 71         seq ; ==
0426   06C1 E4            pop a
0427   06C2             ; --- END RELATIONAL
0428   06C2 FD A8         sor a, b ; ||
0429   06C4 E4            pop a
0430   06C5             ; --- END LOGICAL OR
0431   06C5 C0 00 00      cmp b, 0
0432   06C8 C6 EB 06      je _if11_else
0433   06CB             _if11_TRUE:
0434   06CB             ; print_signed_long(*(long int*)p); 
0435   06CB             ; --- START FUNCTION CALL
0436   06CB FA 00 00      lea d, [bp + 0] ; $p
0437   06CE 32            mov bl, [d]
0438   06CF A7 00         mov bh, 0
0439   06D1 38 00 00      mov c, 0
0440   06D4 74            mov d, b
0441   06D5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0442   06D8 FD 39         mov c, b ; And place it into C
0443   06DA 2A            mov b, [d] ; Lower Word in B
0444   06DB 12            mov a, c
0445   06DC FD AA         swp a
0446   06DE D7            push a
0447   06DF FD AB         swp b
0448   06E1 D8            push b
0449   06E2 07 CE 08      call print_signed_long
0450   06E5 51 04 00      add sp, 4
0451   06E8             ; --- END FUNCTION CALL
0452   06E8 0A 77 07      jmp _if11_exit
0453   06EB             _if11_else:
0454   06EB             ; if(*format_p == 'u') 
0455   06EB             _if12_cond:
0456   06EB FA FE FF      lea d, [bp + -2] ; $format_p
0457   06EE 2A            mov b, [d]
0458   06EF 38 00 00      mov c, 0
0459   06F2 74            mov d, b
0460   06F3 32            mov bl, [d]
0461   06F4 A7 00         mov bh, 0
0462   06F6 38 00 00      mov c, 0
0463   06F9             ; --- START RELATIONAL
0464   06F9 D7            push a
0465   06FA 11            mov a, b
0466   06FB FD 2E 75 00   mov32 cb, $00000075
0466   06FF 00 00 
0467   0701 B0            cmp a, b
0468   0702 FD 71         seq ; ==
0469   0704 E4            pop a
0470   0705             ; --- END RELATIONAL
0471   0705 C0 00 00      cmp b, 0
0472   0708 C6 2B 07      je _if12_else
0473   070B             _if12_TRUE:
0474   070B             ; print_unsigned_long(*(unsigned long int*)p); 
0475   070B             ; --- START FUNCTION CALL
0476   070B FA 00 00      lea d, [bp + 0] ; $p
0477   070E 32            mov bl, [d]
0478   070F A7 00         mov bh, 0
0479   0711 38 00 00      mov c, 0
0480   0714 74            mov d, b
0481   0715 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0482   0718 FD 39         mov c, b ; And place it into C
0483   071A 2A            mov b, [d] ; Lower Word in B
0484   071B 12            mov a, c
0485   071C FD AA         swp a
0486   071E D7            push a
0487   071F FD AB         swp b
0488   0721 D8            push b
0489   0722 07 A5 0A      call print_unsigned_long
0490   0725 51 04 00      add sp, 4
0491   0728             ; --- END FUNCTION CALL
0492   0728 0A 77 07      jmp _if12_exit
0493   072B             _if12_else:
0494   072B             ; if(*format_p == 'x') 
0495   072B             _if13_cond:
0496   072B FA FE FF      lea d, [bp + -2] ; $format_p
0497   072E 2A            mov b, [d]
0498   072F 38 00 00      mov c, 0
0499   0732 74            mov d, b
0500   0733 32            mov bl, [d]
0501   0734 A7 00         mov bh, 0
0502   0736 38 00 00      mov c, 0
0503   0739             ; --- START RELATIONAL
0504   0739 D7            push a
0505   073A 11            mov a, b
0506   073B FD 2E 78 00   mov32 cb, $00000078
0506   073F 00 00 
0507   0741 B0            cmp a, b
0508   0742 FD 71         seq ; ==
0509   0744 E4            pop a
0510   0745             ; --- END RELATIONAL
0511   0745 C0 00 00      cmp b, 0
0512   0748 C6 6B 07      je _if13_else
0513   074B             _if13_TRUE:
0514   074B             ; printx32(*(long int *)p); 
0515   074B             ; --- START FUNCTION CALL
0516   074B FA 00 00      lea d, [bp + 0] ; $p
0517   074E 32            mov bl, [d]
0518   074F A7 00         mov bh, 0
0519   0751 38 00 00      mov c, 0
0520   0754 74            mov d, b
0521   0755 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0522   0758 FD 39         mov c, b ; And place it into C
0523   075A 2A            mov b, [d] ; Lower Word in B
0524   075B 12            mov a, c
0525   075C FD AA         swp a
0526   075E D7            push a
0527   075F FD AB         swp b
0528   0761 D8            push b
0529   0762 07 D0 0B      call printx32
0530   0765 51 04 00      add sp, 4
0531   0768             ; --- END FUNCTION CALL
0532   0768 0A 77 07      jmp _if13_exit
0533   076B             _if13_else:
0534   076B             ; err("Unexpected format in printf."); 
0535   076B             ; --- START FUNCTION CALL
0536   076B 26 C7 0F      mov b, _s11 ; "Unexpected format in printf."
0537   076E FD AB         swp b
0538   0770 D8            push b
0539   0771 07 30 0C      call err
0540   0774 51 02 00      add sp, 2
0541   0777             ; --- END FUNCTION CALL
0542   0777             _if13_exit:
0543   0777             _if12_exit:
0544   0777             _if11_exit:
0545   0777             ; p = p + 4; 
0546   0777 FA 00 00      lea d, [bp + 0] ; $p
0547   077A DA            push d
0548   077B FA 00 00      lea d, [bp + 0] ; $p
0549   077E 32            mov bl, [d]
0550   077F A7 00         mov bh, 0
0551   0781 38 00 00      mov c, 0
0552   0784             ; --- START TERMS
0553   0784 D7            push a
0554   0785 11            mov a, b
0555   0786 FD 2E 04 00   mov32 cb, $00000004
0555   078A 00 00 
0556   078C 56            add b, a
0557   078D E4            pop a
0558   078E             ; --- END TERMS
0559   078E E7            pop d
0560   078F FD 3E         mov [d], bl
0561   0791             ; break; 
0562   0791 0A A1 08      jmp _switch10_exit ; case break
0563   0794             _switch10_case2:
0564   0794             _switch10_case3:
0565   0794             ; print_signed(*(int*)p); 
0566   0794             ; --- START FUNCTION CALL
0567   0794 FA 00 00      lea d, [bp + 0] ; $p
0568   0797 32            mov bl, [d]
0569   0798 A7 00         mov bh, 0
0570   079A 38 00 00      mov c, 0
0571   079D 74            mov d, b
0572   079E 2A            mov b, [d]
0573   079F 38 00 00      mov c, 0
0574   07A2 FD AB         swp b
0575   07A4 D8            push b
0576   07A5 07 5E 0C      call print_signed
0577   07A8 51 02 00      add sp, 2
0578   07AB             ; --- END FUNCTION CALL
0579   07AB             ; p = p + 2; 
0580   07AB FA 00 00      lea d, [bp + 0] ; $p
0581   07AE DA            push d
0582   07AF FA 00 00      lea d, [bp + 0] ; $p
0583   07B2 32            mov bl, [d]
0584   07B3 A7 00         mov bh, 0
0585   07B5 38 00 00      mov c, 0
0586   07B8             ; --- START TERMS
0587   07B8 D7            push a
0588   07B9 11            mov a, b
0589   07BA FD 2E 02 00   mov32 cb, $00000002
0589   07BE 00 00 
0590   07C0 56            add b, a
0591   07C1 E4            pop a
0592   07C2             ; --- END TERMS
0593   07C2 E7            pop d
0594   07C3 FD 3E         mov [d], bl
0595   07C5             ; break; 
0596   07C5 0A A1 08      jmp _switch10_exit ; case break
0597   07C8             _switch10_case4:
0598   07C8             ; print_unsigned(*(unsigned int*)p); 
0599   07C8             ; --- START FUNCTION CALL
0600   07C8 FA 00 00      lea d, [bp + 0] ; $p
0601   07CB 32            mov bl, [d]
0602   07CC A7 00         mov bh, 0
0603   07CE 38 00 00      mov c, 0
0604   07D1 74            mov d, b
0605   07D2 2A            mov b, [d]
0606   07D3 38 00 00      mov c, 0
0607   07D6 FD AB         swp b
0608   07D8 D8            push b
0609   07D9 07 C1 0D      call print_unsigned
0610   07DC 51 02 00      add sp, 2
0611   07DF             ; --- END FUNCTION CALL
0612   07DF             ; p = p + 2; 
0613   07DF FA 00 00      lea d, [bp + 0] ; $p
0614   07E2 DA            push d
0615   07E3 FA 00 00      lea d, [bp + 0] ; $p
0616   07E6 32            mov bl, [d]
0617   07E7 A7 00         mov bh, 0
0618   07E9 38 00 00      mov c, 0
0619   07EC             ; --- START TERMS
0620   07EC D7            push a
0621   07ED 11            mov a, b
0622   07EE FD 2E 02 00   mov32 cb, $00000002
0622   07F2 00 00 
0623   07F4 56            add b, a
0624   07F5 E4            pop a
0625   07F6             ; --- END TERMS
0626   07F6 E7            pop d
0627   07F7 FD 3E         mov [d], bl
0628   07F9             ; break; 
0629   07F9 0A A1 08      jmp _switch10_exit ; case break
0630   07FC             _switch10_case5:
0631   07FC             _switch10_case6:
0632   07FC             ; printx16(*(int*)p); 
0633   07FC             ; --- START FUNCTION CALL
0634   07FC FA 00 00      lea d, [bp + 0] ; $p
0635   07FF 32            mov bl, [d]
0636   0800 A7 00         mov bh, 0
0637   0802 38 00 00      mov c, 0
0638   0805 74            mov d, b
0639   0806 2A            mov b, [d]
0640   0807 38 00 00      mov c, 0
0641   080A FD AB         swp b
0642   080C D8            push b
0643   080D 07 C6 0E      call printx16
0644   0810 51 02 00      add sp, 2
0645   0813             ; --- END FUNCTION CALL
0646   0813             ; p = p + 2; 
0647   0813 FA 00 00      lea d, [bp + 0] ; $p
0648   0816 DA            push d
0649   0817 FA 00 00      lea d, [bp + 0] ; $p
0650   081A 32            mov bl, [d]
0651   081B A7 00         mov bh, 0
0652   081D 38 00 00      mov c, 0
0653   0820             ; --- START TERMS
0654   0820 D7            push a
0655   0821 11            mov a, b
0656   0822 FD 2E 02 00   mov32 cb, $00000002
0656   0826 00 00 
0657   0828 56            add b, a
0658   0829 E4            pop a
0659   082A             ; --- END TERMS
0660   082A E7            pop d
0661   082B FD 3E         mov [d], bl
0662   082D             ; break; 
0663   082D 0A A1 08      jmp _switch10_exit ; case break
0664   0830             _switch10_case7:
0665   0830             ; putchar(*(char*)p); 
0666   0830             ; --- START FUNCTION CALL
0667   0830 FA 00 00      lea d, [bp + 0] ; $p
0668   0833 32            mov bl, [d]
0669   0834 A7 00         mov bh, 0
0670   0836 38 00 00      mov c, 0
0671   0839 74            mov d, b
0672   083A 32            mov bl, [d]
0673   083B A7 00         mov bh, 0
0674   083D 38 00 00      mov c, 0
0675   0840 DD            push bl
0676   0841 07 97 0A      call putchar
0677   0844 51 01 00      add sp, 1
0678   0847             ; --- END FUNCTION CALL
0679   0847             ; p = p + 2; 
0680   0847 FA 00 00      lea d, [bp + 0] ; $p
0681   084A DA            push d
0682   084B FA 00 00      lea d, [bp + 0] ; $p
0683   084E 32            mov bl, [d]
0684   084F A7 00         mov bh, 0
0685   0851 38 00 00      mov c, 0
0686   0854             ; --- START TERMS
0687   0854 D7            push a
0688   0855 11            mov a, b
0689   0856 FD 2E 02 00   mov32 cb, $00000002
0689   085A 00 00 
0690   085C 56            add b, a
0691   085D E4            pop a
0692   085E             ; --- END TERMS
0693   085E E7            pop d
0694   085F FD 3E         mov [d], bl
0695   0861             ; break; 
0696   0861 0A A1 08      jmp _switch10_exit ; case break
0697   0864             _switch10_case8:
0698   0864             ; print(*(char**)p); 
0699   0864             ; --- START FUNCTION CALL
0700   0864 FA 00 00      lea d, [bp + 0] ; $p
0701   0867 32            mov bl, [d]
0702   0868 A7 00         mov bh, 0
0703   086A 38 00 00      mov c, 0
0704   086D 74            mov d, b
0705   086E 2A            mov b, [d]
0706   086F FD AB         swp b
0707   0871 D8            push b
0708   0872 07 45 0C      call print
0709   0875 51 02 00      add sp, 2
0710   0878             ; --- END FUNCTION CALL
0711   0878             ; p = p + 2; 
0712   0878 FA 00 00      lea d, [bp + 0] ; $p
0713   087B DA            push d
0714   087C FA 00 00      lea d, [bp + 0] ; $p
0715   087F 32            mov bl, [d]
0716   0880 A7 00         mov bh, 0
0717   0882 38 00 00      mov c, 0
0718   0885             ; --- START TERMS
0719   0885 D7            push a
0720   0886 11            mov a, b
0721   0887 FD 2E 02 00   mov32 cb, $00000002
0721   088B 00 00 
0722   088D 56            add b, a
0723   088E E4            pop a
0724   088F             ; --- END TERMS
0725   088F E7            pop d
0726   0890 FD 3E         mov [d], bl
0727   0892             ; break; 
0728   0892 0A A1 08      jmp _switch10_exit ; case break
0729   0895             _switch10_default:
0730   0895             ; print("Error: Unknown argument type.\n"); 
0731   0895             ; --- START FUNCTION CALL
0732   0895 26 E4 0F      mov b, _s12 ; "Error: Unknown argument type.\n"
0733   0898 FD AB         swp b
0734   089A D8            push b
0735   089B 07 45 0C      call print
0736   089E 51 02 00      add sp, 2
0737   08A1             ; --- END FUNCTION CALL
0738   08A1             _switch10_exit:
0739   08A1 0A B9 08      jmp _if9_exit
0740   08A4             _if9_else:
0741   08A4             ; putchar(*format_p); 
0742   08A4             ; --- START FUNCTION CALL
0743   08A4 FA FE FF      lea d, [bp + -2] ; $format_p
0744   08A7 2A            mov b, [d]
0745   08A8 38 00 00      mov c, 0
0746   08AB 74            mov d, b
0747   08AC 32            mov bl, [d]
0748   08AD A7 00         mov bh, 0
0749   08AF 38 00 00      mov c, 0
0750   08B2 DD            push bl
0751   08B3 07 97 0A      call putchar
0752   08B6 51 01 00      add sp, 1
0753   08B9             ; --- END FUNCTION CALL
0754   08B9             _if9_exit:
0755   08B9             _if8_exit:
0756   08B9             ; format_p++; 
0757   08B9 FA FE FF      lea d, [bp + -2] ; $format_p
0758   08BC 2A            mov b, [d]
0759   08BD 38 00 00      mov c, 0
0760   08C0 FD 77         inc b
0761   08C2 FA FE FF      lea d, [bp + -2] ; $format_p
0762   08C5 FD 43         mov [d], b
0763   08C7 FD 7D         dec b
0764   08C9             _for7_update:
0765   08C9 0A EC 05      jmp _for7_cond
0766   08CC             _for7_exit:
0767   08CC F9            leave
0768   08CD 09            ret
0769   08CE             
0770   08CE             print_signed_long:
0771   08CE F8 00 00      enter 0 ; (push bp; mov bp, sp)
0772   08D1             ; char digits[10];  // fits 2,147,483,647 
0773   08D1 52 0A 00      sub sp, 10
0774   08D4             ; int i = 0; 
0775   08D4 52 02 00      sub sp, 2
0776   08D7             ; --- START LOCAL VAR INITIALIZATION
0777   08D7 FA F5 FF      lea d, [bp + -11] ; $i
0778   08DA DA            push d
0779   08DB FD 2E 00 00   mov32 cb, $00000000
0779   08DF 00 00 
0780   08E1 E7            pop d
0781   08E2 FD 43         mov [d], b
0782   08E4             ; --- END LOCAL VAR INITIALIZATION
0783   08E4             ; unsigned long int absval; 
0784   08E4 52 04 00      sub sp, 4
0785   08E7             ; if (num < 0) { 
0786   08E7             _if14_cond:
0787   08E7 FA 05 00      lea d, [bp + 5] ; $num
0788   08EA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0789   08ED FD 39         mov c, b ; And place it into C
0790   08EF 2A            mov b, [d] ; Lower Word in B
0791   08F0             ; --- START RELATIONAL
0792   08F0 D7            push a
0793   08F1 FD D8         push g
0794   08F3 11            mov a, b
0795   08F4 FD 7A         mov g, c
0796   08F6 FD 2E 00 00   mov32 cb, $00000000
0796   08FA 00 00 
0797   08FC 38 00 00      mov c, 0
0798   08FF FD AF         cmp32 ga, cb
0799   0901 FD 73         slt ; <
0800   0903 FD F1         pop g
0801   0905 E4            pop a
0802   0906             ; --- END RELATIONAL
0803   0906 C0 00 00      cmp b, 0
0804   0909 C6 68 09      je _if14_else
0805   090C             _if14_TRUE:
0806   090C             ; putchar('-'); 
0807   090C             ; --- START FUNCTION CALL
0808   090C FD 2E 2D 00   mov32 cb, $0000002d
0808   0910 00 00 
0809   0912 DD            push bl
0810   0913 07 97 0A      call putchar
0811   0916 51 01 00      add sp, 1
0812   0919             ; --- END FUNCTION CALL
0813   0919             ; absval = (unsigned long int)(-(num + 1)) + 1; 
0814   0919 FA F1 FF      lea d, [bp + -15] ; $absval
0815   091C DA            push d
0816   091D FA 05 00      lea d, [bp + 5] ; $num
0817   0920 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0818   0923 FD 39         mov c, b ; And place it into C
0819   0925 2A            mov b, [d] ; Lower Word in B
0820   0926             ; --- START TERMS
0821   0926 D7            push a
0822   0927 FD D8         push g
0823   0929 11            mov a, b
0824   092A FD 7A         mov g, c
0825   092C FD 2E 01 00   mov32 cb, $00000001
0825   0930 00 00 
0826   0932 38 00 00      mov c, 0
0827   0935 FD 15         add32 cb, ga
0828   0937 FD F1         pop g
0829   0939 E4            pop a
0830   093A             ; --- END TERMS
0831   093A 12            mov a, c
0832   093B 95            not a
0833   093C 97            not b
0834   093D 55 01 00      add b, 1
0835   0940 5B 00 00      adc a, 0
0836   0943 39            mov c, a
0837   0944 A7 00         mov bh, 0
0838   0946 38 00 00      mov c, 0
0839   0949             ; --- START TERMS
0840   0949 D7            push a
0841   094A FD D8         push g
0842   094C 11            mov a, b
0843   094D FD 7A         mov g, c
0844   094F FD 2E 01 00   mov32 cb, $00000001
0844   0953 00 00 
0845   0955 38 00 00      mov c, 0
0846   0958 FD 15         add32 cb, ga
0847   095A FD F1         pop g
0848   095C E4            pop a
0849   095D             ; --- END TERMS
0850   095D E7            pop d
0851   095E FD 43         mov [d], b
0852   0960 28            mov b, c
0853   0961 FD 44 02 00   mov [d + 2], b
0854   0965 0A 82 09      jmp _if14_exit
0855   0968             _if14_else:
0856   0968             ; absval = (unsigned long int)num; 
0857   0968 FA F1 FF      lea d, [bp + -15] ; $absval
0858   096B DA            push d
0859   096C FA 05 00      lea d, [bp + 5] ; $num
0860   096F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0861   0972 FD 39         mov c, b ; And place it into C
0862   0974 2A            mov b, [d] ; Lower Word in B
0863   0975 A7 00         mov bh, 0
0864   0977 38 00 00      mov c, 0
0865   097A E7            pop d
0866   097B FD 43         mov [d], b
0867   097D 28            mov b, c
0868   097E FD 44 02 00   mov [d + 2], b
0869   0982             _if14_exit:
0870   0982             ; if (absval == 0) { 
0871   0982             _if15_cond:
0872   0982 FA F1 FF      lea d, [bp + -15] ; $absval
0873   0985 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0874   0988 FD 39         mov c, b ; And place it into C
0875   098A 2A            mov b, [d] ; Lower Word in B
0876   098B             ; --- START RELATIONAL
0877   098B D7            push a
0878   098C FD D8         push g
0879   098E 11            mov a, b
0880   098F FD 7A         mov g, c
0881   0991 FD 2E 00 00   mov32 cb, $00000000
0881   0995 00 00 
0882   0997 38 00 00      mov c, 0
0883   099A FD AF         cmp32 ga, cb
0884   099C FD 71         seq ; ==
0885   099E FD F1         pop g
0886   09A0 E4            pop a
0887   09A1             ; --- END RELATIONAL
0888   09A1 C0 00 00      cmp b, 0
0889   09A4 C6 B9 09      je _if15_exit
0890   09A7             _if15_TRUE:
0891   09A7             ; putchar('0'); 
0892   09A7             ; --- START FUNCTION CALL
0893   09A7 FD 2E 30 00   mov32 cb, $00000030
0893   09AB 00 00 
0894   09AD DD            push bl
0895   09AE 07 97 0A      call putchar
0896   09B1 51 01 00      add sp, 1
0897   09B4             ; --- END FUNCTION CALL
0898   09B4             ; return; 
0899   09B4 F9            leave
0900   09B5 09            ret
0901   09B6 0A B9 09      jmp _if15_exit
0902   09B9             _if15_exit:
0903   09B9             ; while (absval > 0) { 
0904   09B9             _while16_cond:
0905   09B9 FA F1 FF      lea d, [bp + -15] ; $absval
0906   09BC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0907   09BF FD 39         mov c, b ; And place it into C
0908   09C1 2A            mov b, [d] ; Lower Word in B
0909   09C2             ; --- START RELATIONAL
0910   09C2 D7            push a
0911   09C3 FD D8         push g
0912   09C5 11            mov a, b
0913   09C6 FD 7A         mov g, c
0914   09C8 FD 2E 00 00   mov32 cb, $00000000
0914   09CC 00 00 
0915   09CE 38 00 00      mov c, 0
0916   09D1 FD AF         cmp32 ga, cb
0917   09D3 FD 81         sgu
0918   09D5 FD F1         pop g
0919   09D7 E4            pop a
0920   09D8             ; --- END RELATIONAL
0921   09D8 C0 00 00      cmp b, 0
0922   09DB C6 59 0A      je _while16_exit
0923   09DE             _while16_block:
0924   09DE             ; digits[i++] = '0' + (absval % 10); 
0925   09DE FA F7 FF      lea d, [bp + -9] ; $digits
0926   09E1 D7            push a
0927   09E2 DA            push d
0928   09E3 FA F5 FF      lea d, [bp + -11] ; $i
0929   09E6 2A            mov b, [d]
0930   09E7 38 00 00      mov c, 0
0931   09EA 11            mov a, b
0932   09EB FD 77         inc b
0933   09ED FA F5 FF      lea d, [bp + -11] ; $i
0934   09F0 FD 43         mov [d], b
0935   09F2 27            mov b, a
0936   09F3 E7            pop d
0937   09F4 5A            add d, b
0938   09F5 E4            pop a
0939   09F6 DA            push d
0940   09F7 FD 2E 30 00   mov32 cb, $00000030
0940   09FB 00 00 
0941   09FD             ; --- START TERMS
0942   09FD D7            push a
0943   09FE 11            mov a, b
0944   09FF FA F1 FF      lea d, [bp + -15] ; $absval
0945   0A02 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0946   0A05 FD 39         mov c, b ; And place it into C
0947   0A07 2A            mov b, [d] ; Lower Word in B
0948   0A08             ; --- START FACTORS
0949   0A08 D7            push a
0950   0A09 FD D8         push g
0951   0A0B 11            mov a, b
0952   0A0C FD 7A         mov g, c
0953   0A0E FD 2E 0A 00   mov32 cb, $0000000a
0953   0A12 00 00 
0954   0A14 FD D8         push g ; save 'g' as the div instruction uses it
0955   0A16 AE            div a, b ; %, a: quotient, b: remainder
0956   0A17 11            mov a, b
0957   0A18 FD F1         pop g
0958   0A1A FD 38         mov c, g
0959   0A1C 27            mov b, a
0960   0A1D FD F1         pop g
0961   0A1F E4            pop a
0962   0A20             ; --- END FACTORS
0963   0A20 FD 22 00 00   mov g, 0
0964   0A24 FD 15         add32 cb, ga
0965   0A26 E4            pop a
0966   0A27             ; --- END TERMS
0967   0A27 E7            pop d
0968   0A28 FD 3E         mov [d], bl
0969   0A2A             ; absval = absval / 10; 
0970   0A2A FA F1 FF      lea d, [bp + -15] ; $absval
0971   0A2D DA            push d
0972   0A2E FA F1 FF      lea d, [bp + -15] ; $absval
0973   0A31 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0974   0A34 FD 39         mov c, b ; And place it into C
0975   0A36 2A            mov b, [d] ; Lower Word in B
0976   0A37             ; --- START FACTORS
0977   0A37 D7            push a
0978   0A38 FD D8         push g
0979   0A3A 11            mov a, b
0980   0A3B FD 7A         mov g, c
0981   0A3D FD 2E 0A 00   mov32 cb, $0000000a
0981   0A41 00 00 
0982   0A43 FD D8         push g ; save 'g' as the div instruction uses it
0983   0A45 AE            div a, b ; /, a: quotient, b: remainder
0984   0A46 FD F1         pop g
0985   0A48 FD 38         mov c, g
0986   0A4A 27            mov b, a
0987   0A4B FD F1         pop g
0988   0A4D E4            pop a
0989   0A4E             ; --- END FACTORS
0990   0A4E E7            pop d
0991   0A4F FD 43         mov [d], b
0992   0A51 28            mov b, c
0993   0A52 FD 44 02 00   mov [d + 2], b
0994   0A56 0A B9 09      jmp _while16_cond
0995   0A59             _while16_exit:
0996   0A59             ; while (i > 0) { 
0997   0A59             _while23_cond:
0998   0A59 FA F5 FF      lea d, [bp + -11] ; $i
0999   0A5C 2A            mov b, [d]
1000   0A5D 38 00 00      mov c, 0
1001   0A60             ; --- START RELATIONAL
1002   0A60 D7            push a
1003   0A61 11            mov a, b
1004   0A62 FD 2E 00 00   mov32 cb, $00000000
1004   0A66 00 00 
1005   0A68 B0            cmp a, b
1006   0A69 FD 7F         sgt ; >
1007   0A6B E4            pop a
1008   0A6C             ; --- END RELATIONAL
1009   0A6C C0 00 00      cmp b, 0
1010   0A6F C6 95 0A      je _while23_exit
1011   0A72             _while23_block:
1012   0A72             ; putchar(digits[--i]); 
1013   0A72             ; --- START FUNCTION CALL
1014   0A72 FA F7 FF      lea d, [bp + -9] ; $digits
1015   0A75 D7            push a
1016   0A76 DA            push d
1017   0A77 FA F5 FF      lea d, [bp + -11] ; $i
1018   0A7A 2A            mov b, [d]
1019   0A7B FD 7D         dec b
1020   0A7D FA F5 FF      lea d, [bp + -11] ; $i
1021   0A80 FD 43         mov [d], b
1022   0A82 E7            pop d
1023   0A83 5A            add d, b
1024   0A84 E4            pop a
1025   0A85 32            mov bl, [d]
1026   0A86 A7 00         mov bh, 0
1027   0A88 38 00 00      mov c, 0
1028   0A8B DD            push bl
1029   0A8C 07 97 0A      call putchar
1030   0A8F 51 01 00      add sp, 1
1031   0A92             ; --- END FUNCTION CALL
1032   0A92 0A 59 0A      jmp _while23_cond
1033   0A95             _while23_exit:
1034   0A95 F9            leave
1035   0A96 09            ret
1036   0A97             
1037   0A97             putchar:
1038   0A97 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1039   0A9A             ; --- BEGIN INLINE ASM SEGMENT
1040   0A9A FA 05 00      lea d, [bp + 5] ; $c
1041   0A9D 1E            mov al, [d]
1042   0A9E 23            mov ah, al
1043   0A9F 19 00         mov al, 0
1044   0AA1 05 03         syscall sys_io      ; char in AH
1045   0AA3             ; --- END INLINE ASM SEGMENT
1046   0AA3 F9            leave
1047   0AA4 09            ret
1048   0AA5             
1049   0AA5             print_unsigned_long:
1050   0AA5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1051   0AA8             ; char digits[10]; 
1052   0AA8 52 0A 00      sub sp, 10
1053   0AAB             ; int i = 0; 
1054   0AAB 52 02 00      sub sp, 2
1055   0AAE             ; --- START LOCAL VAR INITIALIZATION
1056   0AAE FA F5 FF      lea d, [bp + -11] ; $i
1057   0AB1 DA            push d
1058   0AB2 FD 2E 00 00   mov32 cb, $00000000
1058   0AB6 00 00 
1059   0AB8 E7            pop d
1060   0AB9 FD 43         mov [d], b
1061   0ABB             ; --- END LOCAL VAR INITIALIZATION
1062   0ABB             ; if(num == 0){ 
1063   0ABB             _if24_cond:
1064   0ABB FA 05 00      lea d, [bp + 5] ; $num
1065   0ABE 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1066   0AC1 FD 39         mov c, b ; And place it into C
1067   0AC3 2A            mov b, [d] ; Lower Word in B
1068   0AC4             ; --- START RELATIONAL
1069   0AC4 D7            push a
1070   0AC5 FD D8         push g
1071   0AC7 11            mov a, b
1072   0AC8 FD 7A         mov g, c
1073   0ACA FD 2E 00 00   mov32 cb, $00000000
1073   0ACE 00 00 
1074   0AD0 38 00 00      mov c, 0
1075   0AD3 FD AF         cmp32 ga, cb
1076   0AD5 FD 71         seq ; ==
1077   0AD7 FD F1         pop g
1078   0AD9 E4            pop a
1079   0ADA             ; --- END RELATIONAL
1080   0ADA C0 00 00      cmp b, 0
1081   0ADD C6 F2 0A      je _if24_exit
1082   0AE0             _if24_TRUE:
1083   0AE0             ; putchar('0'); 
1084   0AE0             ; --- START FUNCTION CALL
1085   0AE0 FD 2E 30 00   mov32 cb, $00000030
1085   0AE4 00 00 
1086   0AE6 DD            push bl
1087   0AE7 07 97 0A      call putchar
1088   0AEA 51 01 00      add sp, 1
1089   0AED             ; --- END FUNCTION CALL
1090   0AED             ; return; 
1091   0AED F9            leave
1092   0AEE 09            ret
1093   0AEF 0A F2 0A      jmp _if24_exit
1094   0AF2             _if24_exit:
1095   0AF2             ; while (num > 0) { 
1096   0AF2             _while25_cond:
1097   0AF2 FA 05 00      lea d, [bp + 5] ; $num
1098   0AF5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1099   0AF8 FD 39         mov c, b ; And place it into C
1100   0AFA 2A            mov b, [d] ; Lower Word in B
1101   0AFB             ; --- START RELATIONAL
1102   0AFB D7            push a
1103   0AFC FD D8         push g
1104   0AFE 11            mov a, b
1105   0AFF FD 7A         mov g, c
1106   0B01 FD 2E 00 00   mov32 cb, $00000000
1106   0B05 00 00 
1107   0B07 38 00 00      mov c, 0
1108   0B0A FD AF         cmp32 ga, cb
1109   0B0C FD 81         sgu
1110   0B0E FD F1         pop g
1111   0B10 E4            pop a
1112   0B11             ; --- END RELATIONAL
1113   0B11 C0 00 00      cmp b, 0
1114   0B14 C6 92 0B      je _while25_exit
1115   0B17             _while25_block:
1116   0B17             ; digits[i++] = '0' + (num % 10); 
1117   0B17 FA F7 FF      lea d, [bp + -9] ; $digits
1118   0B1A D7            push a
1119   0B1B DA            push d
1120   0B1C FA F5 FF      lea d, [bp + -11] ; $i
1121   0B1F 2A            mov b, [d]
1122   0B20 38 00 00      mov c, 0
1123   0B23 11            mov a, b
1124   0B24 FD 77         inc b
1125   0B26 FA F5 FF      lea d, [bp + -11] ; $i
1126   0B29 FD 43         mov [d], b
1127   0B2B 27            mov b, a
1128   0B2C E7            pop d
1129   0B2D 5A            add d, b
1130   0B2E E4            pop a
1131   0B2F DA            push d
1132   0B30 FD 2E 30 00   mov32 cb, $00000030
1132   0B34 00 00 
1133   0B36             ; --- START TERMS
1134   0B36 D7            push a
1135   0B37 11            mov a, b
1136   0B38 FA 05 00      lea d, [bp + 5] ; $num
1137   0B3B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1138   0B3E FD 39         mov c, b ; And place it into C
1139   0B40 2A            mov b, [d] ; Lower Word in B
1140   0B41             ; --- START FACTORS
1141   0B41 D7            push a
1142   0B42 FD D8         push g
1143   0B44 11            mov a, b
1144   0B45 FD 7A         mov g, c
1145   0B47 FD 2E 0A 00   mov32 cb, $0000000a
1145   0B4B 00 00 
1146   0B4D FD D8         push g ; save 'g' as the div instruction uses it
1147   0B4F AE            div a, b ; %, a: quotient, b: remainder
1148   0B50 11            mov a, b
1149   0B51 FD F1         pop g
1150   0B53 FD 38         mov c, g
1151   0B55 27            mov b, a
1152   0B56 FD F1         pop g
1153   0B58 E4            pop a
1154   0B59             ; --- END FACTORS
1155   0B59 FD 22 00 00   mov g, 0
1156   0B5D FD 15         add32 cb, ga
1157   0B5F E4            pop a
1158   0B60             ; --- END TERMS
1159   0B60 E7            pop d
1160   0B61 FD 3E         mov [d], bl
1161   0B63             ; num = num / 10; 
1162   0B63 FA 05 00      lea d, [bp + 5] ; $num
1163   0B66 DA            push d
1164   0B67 FA 05 00      lea d, [bp + 5] ; $num
1165   0B6A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1166   0B6D FD 39         mov c, b ; And place it into C
1167   0B6F 2A            mov b, [d] ; Lower Word in B
1168   0B70             ; --- START FACTORS
1169   0B70 D7            push a
1170   0B71 FD D8         push g
1171   0B73 11            mov a, b
1172   0B74 FD 7A         mov g, c
1173   0B76 FD 2E 0A 00   mov32 cb, $0000000a
1173   0B7A 00 00 
1174   0B7C FD D8         push g ; save 'g' as the div instruction uses it
1175   0B7E AE            div a, b ; /, a: quotient, b: remainder
1176   0B7F FD F1         pop g
1177   0B81 FD 38         mov c, g
1178   0B83 27            mov b, a
1179   0B84 FD F1         pop g
1180   0B86 E4            pop a
1181   0B87             ; --- END FACTORS
1182   0B87 E7            pop d
1183   0B88 FD 43         mov [d], b
1184   0B8A 28            mov b, c
1185   0B8B FD 44 02 00   mov [d + 2], b
1186   0B8F 0A F2 0A      jmp _while25_cond
1187   0B92             _while25_exit:
1188   0B92             ; while (i > 0) { 
1189   0B92             _while32_cond:
1190   0B92 FA F5 FF      lea d, [bp + -11] ; $i
1191   0B95 2A            mov b, [d]
1192   0B96 38 00 00      mov c, 0
1193   0B99             ; --- START RELATIONAL
1194   0B99 D7            push a
1195   0B9A 11            mov a, b
1196   0B9B FD 2E 00 00   mov32 cb, $00000000
1196   0B9F 00 00 
1197   0BA1 B0            cmp a, b
1198   0BA2 FD 7F         sgt ; >
1199   0BA4 E4            pop a
1200   0BA5             ; --- END RELATIONAL
1201   0BA5 C0 00 00      cmp b, 0
1202   0BA8 C6 CE 0B      je _while32_exit
1203   0BAB             _while32_block:
1204   0BAB             ; putchar(digits[--i]); 
1205   0BAB             ; --- START FUNCTION CALL
1206   0BAB FA F7 FF      lea d, [bp + -9] ; $digits
1207   0BAE D7            push a
1208   0BAF DA            push d
1209   0BB0 FA F5 FF      lea d, [bp + -11] ; $i
1210   0BB3 2A            mov b, [d]
1211   0BB4 FD 7D         dec b
1212   0BB6 FA F5 FF      lea d, [bp + -11] ; $i
1213   0BB9 FD 43         mov [d], b
1214   0BBB E7            pop d
1215   0BBC 5A            add d, b
1216   0BBD E4            pop a
1217   0BBE 32            mov bl, [d]
1218   0BBF A7 00         mov bh, 0
1219   0BC1 38 00 00      mov c, 0
1220   0BC4 DD            push bl
1221   0BC5 07 97 0A      call putchar
1222   0BC8 51 01 00      add sp, 1
1223   0BCB             ; --- END FUNCTION CALL
1224   0BCB 0A 92 0B      jmp _while32_cond
1225   0BCE             _while32_exit:
1226   0BCE F9            leave
1227   0BCF 09            ret
1228   0BD0             
1229   0BD0             printx32:
1230   0BD0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1231   0BD3             ; --- BEGIN INLINE ASM SEGMENT
1232   0BD3 FA 05 00      lea d, [bp + 5] ; $hex
1233   0BD6 2B 02 00      mov b, [d+2]
1234   0BD9 07 E2 0B      call print_u16x_printx32
1235   0BDC 2A            mov b, [d]
1236   0BDD 07 E2 0B      call print_u16x_printx32
1237   0BE0             ; --- END INLINE ASM SEGMENT
1238   0BE0             ; return; 
1239   0BE0 F9            leave
1240   0BE1 09            ret
1241   0BE2             ; --- BEGIN INLINE ASM SEGMENT
1242   0BE2             print_u16x_printx32:
1243   0BE2 D7            push a
1244   0BE3 D8            push b
1245   0BE4 DD            push bl
1246   0BE5 30            mov bl, bh
1247   0BE6 07 04 0C      call _itoa_printx32        ; convert bh to char in A
1248   0BE9 2F            mov bl, al        ; save al
1249   0BEA 19 00         mov al, 0
1250   0BEC 05 03         syscall sys_io        ; display AH
1251   0BEE 24            mov ah, bl        ; retrieve al
1252   0BEF 19 00         mov al, 0
1253   0BF1 05 03         syscall sys_io        ; display AL
1254   0BF3 EA            pop bl
1255   0BF4 07 04 0C      call _itoa_printx32        ; convert bh to char in A
1256   0BF7 2F            mov bl, al        ; save al
1257   0BF8 19 00         mov al, 0
1258   0BFA 05 03         syscall sys_io        ; display AH
1259   0BFC 24            mov ah, bl        ; retrieve al
1260   0BFD 19 00         mov al, 0
1261   0BFF 05 03         syscall sys_io        ; display AL
1262   0C01 E5            pop b
1263   0C02 E4            pop a
1264   0C03 09            ret
1265   0C04             _itoa_printx32:
1266   0C04 DA            push d
1267   0C05 D8            push b
1268   0C06 A7 00         mov bh, 0
1269   0C08 FD A4 04      shr bl, 4  
1270   0C0B 74            mov d, b
1271   0C0C 1F 1E 0C      mov al, [d + s_hex_digits_printx32]
1272   0C0F 23            mov ah, al
1273   0C10 E5            pop b
1274   0C11 D8            push b
1275   0C12 A7 00         mov bh, 0
1276   0C14 FD 87 0F      and bl, $0F
1277   0C17 74            mov d, b
1278   0C18 1F 1E 0C      mov al, [d + s_hex_digits_printx32]
1279   0C1B E5            pop b
1280   0C1C E7            pop d
1281   0C1D 09            ret
1282   0C1E 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1282   0C22 34 35 36 37 
1282   0C26 38 39 41 42 
1282   0C2A 43 44 45 46 
1283   0C2E             ; --- END INLINE ASM SEGMENT
1284   0C2E F9            leave
1285   0C2F 09            ret
1286   0C30             
1287   0C30             err:
1288   0C30 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1289   0C33             ; print(e); 
1290   0C33             ; --- START FUNCTION CALL
1291   0C33 FA 05 00      lea d, [bp + 5] ; $e
1292   0C36 2A            mov b, [d]
1293   0C37 38 00 00      mov c, 0
1294   0C3A FD AB         swp b
1295   0C3C D8            push b
1296   0C3D 07 45 0C      call print
1297   0C40 51 02 00      add sp, 2
1298   0C43             ; --- END FUNCTION CALL
1299   0C43 F9            leave
1300   0C44 09            ret
1301   0C45             
1302   0C45             print:
1303   0C45 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1304   0C48             ; --- BEGIN INLINE ASM SEGMENT
1305   0C48 FA 05 00      lea d, [bp + 5] ; $s
1306   0C4B FD 2A         mov d, [d]
1307   0C4D             _puts_L1_print:
1308   0C4D 1E            mov al, [d]
1309   0C4E B9 00         cmp al, 0
1310   0C50 C6 5C 0C      jz _puts_END_print
1311   0C53 23            mov ah, al
1312   0C54 19 00         mov al, 0
1313   0C56 05 03         syscall sys_io
1314   0C58 79            inc d
1315   0C59 0A 4D 0C      jmp _puts_L1_print
1316   0C5C             _puts_END_print:
1317   0C5C             ; --- END INLINE ASM SEGMENT
1318   0C5C F9            leave
1319   0C5D 09            ret
1320   0C5E             
1321   0C5E             print_signed:
1322   0C5E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1323   0C61             ; char digits[5];  // enough for "-32768" 
1324   0C61 52 05 00      sub sp, 5
1325   0C64             ; int i = 0; 
1326   0C64 52 02 00      sub sp, 2
1327   0C67             ; --- START LOCAL VAR INITIALIZATION
1328   0C67 FA FA FF      lea d, [bp + -6] ; $i
1329   0C6A DA            push d
1330   0C6B FD 2E 00 00   mov32 cb, $00000000
1330   0C6F 00 00 
1331   0C71 E7            pop d
1332   0C72 FD 43         mov [d], b
1333   0C74             ; --- END LOCAL VAR INITIALIZATION
1334   0C74             ; unsigned int absval; 
1335   0C74 52 02 00      sub sp, 2
1336   0C77             ; if (num < 0) { 
1337   0C77             _if33_cond:
1338   0C77 FA 05 00      lea d, [bp + 5] ; $num
1339   0C7A 2A            mov b, [d]
1340   0C7B 38 00 00      mov c, 0
1341   0C7E             ; --- START RELATIONAL
1342   0C7E D7            push a
1343   0C7F 11            mov a, b
1344   0C80 FD 2E 00 00   mov32 cb, $00000000
1344   0C84 00 00 
1345   0C86 B0            cmp a, b
1346   0C87 FD 73         slt ; < (signed)
1347   0C89 E4            pop a
1348   0C8A             ; --- END RELATIONAL
1349   0C8A C0 00 00      cmp b, 0
1350   0C8D C6 C4 0C      je _if33_else
1351   0C90             _if33_TRUE:
1352   0C90             ; putchar('-'); 
1353   0C90             ; --- START FUNCTION CALL
1354   0C90 FD 2E 2D 00   mov32 cb, $0000002d
1354   0C94 00 00 
1355   0C96 DD            push bl
1356   0C97 07 97 0A      call putchar
1357   0C9A 51 01 00      add sp, 1
1358   0C9D             ; --- END FUNCTION CALL
1359   0C9D             ; absval = (unsigned int)(-(num + 1)) + 1;  // safe for -32768 
1360   0C9D FA F8 FF      lea d, [bp + -8] ; $absval
1361   0CA0 DA            push d
1362   0CA1 FA 05 00      lea d, [bp + 5] ; $num
1363   0CA4 2A            mov b, [d]
1364   0CA5 38 00 00      mov c, 0
1365   0CA8             ; --- START TERMS
1366   0CA8 D7            push a
1367   0CA9 11            mov a, b
1368   0CAA FD 2E 01 00   mov32 cb, $00000001
1368   0CAE 00 00 
1369   0CB0 56            add b, a
1370   0CB1 E4            pop a
1371   0CB2             ; --- END TERMS
1372   0CB2 FD 97         neg b
1373   0CB4             ; --- START TERMS
1374   0CB4 D7            push a
1375   0CB5 11            mov a, b
1376   0CB6 FD 2E 01 00   mov32 cb, $00000001
1376   0CBA 00 00 
1377   0CBC 56            add b, a
1378   0CBD E4            pop a
1379   0CBE             ; --- END TERMS
1380   0CBE E7            pop d
1381   0CBF FD 43         mov [d], b
1382   0CC1 0A D2 0C      jmp _if33_exit
1383   0CC4             _if33_else:
1384   0CC4             ; absval = (unsigned int)num; 
1385   0CC4 FA F8 FF      lea d, [bp + -8] ; $absval
1386   0CC7 DA            push d
1387   0CC8 FA 05 00      lea d, [bp + 5] ; $num
1388   0CCB 2A            mov b, [d]
1389   0CCC 38 00 00      mov c, 0
1390   0CCF E7            pop d
1391   0CD0 FD 43         mov [d], b
1392   0CD2             _if33_exit:
1393   0CD2             ; if (absval == 0) { 
1394   0CD2             _if34_cond:
1395   0CD2 FA F8 FF      lea d, [bp + -8] ; $absval
1396   0CD5 2A            mov b, [d]
1397   0CD6 38 00 00      mov c, 0
1398   0CD9             ; --- START RELATIONAL
1399   0CD9 D7            push a
1400   0CDA 11            mov a, b
1401   0CDB FD 2E 00 00   mov32 cb, $00000000
1401   0CDF 00 00 
1402   0CE1 B0            cmp a, b
1403   0CE2 FD 71         seq ; ==
1404   0CE4 E4            pop a
1405   0CE5             ; --- END RELATIONAL
1406   0CE5 C0 00 00      cmp b, 0
1407   0CE8 C6 FD 0C      je _if34_exit
1408   0CEB             _if34_TRUE:
1409   0CEB             ; putchar('0'); 
1410   0CEB             ; --- START FUNCTION CALL
1411   0CEB FD 2E 30 00   mov32 cb, $00000030
1411   0CEF 00 00 
1412   0CF1 DD            push bl
1413   0CF2 07 97 0A      call putchar
1414   0CF5 51 01 00      add sp, 1
1415   0CF8             ; --- END FUNCTION CALL
1416   0CF8             ; return; 
1417   0CF8 F9            leave
1418   0CF9 09            ret
1419   0CFA 0A FD 0C      jmp _if34_exit
1420   0CFD             _if34_exit:
1421   0CFD             ; while (absval > 0) { 
1422   0CFD             _while35_cond:
1423   0CFD FA F8 FF      lea d, [bp + -8] ; $absval
1424   0D00 2A            mov b, [d]
1425   0D01 38 00 00      mov c, 0
1426   0D04             ; --- START RELATIONAL
1427   0D04 D7            push a
1428   0D05 11            mov a, b
1429   0D06 FD 2E 00 00   mov32 cb, $00000000
1429   0D0A 00 00 
1430   0D0C B0            cmp a, b
1431   0D0D FD 81         sgu ; > (unsigned)
1432   0D0F E4            pop a
1433   0D10             ; --- END RELATIONAL
1434   0D10 C0 00 00      cmp b, 0
1435   0D13 C6 83 0D      je _while35_exit
1436   0D16             _while35_block:
1437   0D16             ; digits[i++] = '0' + (absval % 10); 
1438   0D16 FA FC FF      lea d, [bp + -4] ; $digits
1439   0D19 D7            push a
1440   0D1A DA            push d
1441   0D1B FA FA FF      lea d, [bp + -6] ; $i
1442   0D1E 2A            mov b, [d]
1443   0D1F 38 00 00      mov c, 0
1444   0D22 11            mov a, b
1445   0D23 FD 77         inc b
1446   0D25 FA FA FF      lea d, [bp + -6] ; $i
1447   0D28 FD 43         mov [d], b
1448   0D2A 27            mov b, a
1449   0D2B E7            pop d
1450   0D2C 5A            add d, b
1451   0D2D E4            pop a
1452   0D2E DA            push d
1453   0D2F FD 2E 30 00   mov32 cb, $00000030
1453   0D33 00 00 
1454   0D35             ; --- START TERMS
1455   0D35 D7            push a
1456   0D36 11            mov a, b
1457   0D37 FA F8 FF      lea d, [bp + -8] ; $absval
1458   0D3A 2A            mov b, [d]
1459   0D3B 38 00 00      mov c, 0
1460   0D3E             ; --- START FACTORS
1461   0D3E D7            push a
1462   0D3F FD D8         push g
1463   0D41 11            mov a, b
1464   0D42 FD 7A         mov g, c
1465   0D44 FD 2E 0A 00   mov32 cb, $0000000a
1465   0D48 00 00 
1466   0D4A FD D8         push g ; save 'g' as the div instruction uses it
1467   0D4C AE            div a, b ; %, a: quotient, b: remainder
1468   0D4D 11            mov a, b
1469   0D4E FD F1         pop g
1470   0D50 FD 38         mov c, g
1471   0D52 27            mov b, a
1472   0D53 FD F1         pop g
1473   0D55 E4            pop a
1474   0D56             ; --- END FACTORS
1475   0D56 56            add b, a
1476   0D57 E4            pop a
1477   0D58             ; --- END TERMS
1478   0D58 E7            pop d
1479   0D59 FD 3E         mov [d], bl
1480   0D5B             ; absval = absval / 10; 
1481   0D5B FA F8 FF      lea d, [bp + -8] ; $absval
1482   0D5E DA            push d
1483   0D5F FA F8 FF      lea d, [bp + -8] ; $absval
1484   0D62 2A            mov b, [d]
1485   0D63 38 00 00      mov c, 0
1486   0D66             ; --- START FACTORS
1487   0D66 D7            push a
1488   0D67 FD D8         push g
1489   0D69 11            mov a, b
1490   0D6A FD 7A         mov g, c
1491   0D6C FD 2E 0A 00   mov32 cb, $0000000a
1491   0D70 00 00 
1492   0D72 FD D8         push g ; save 'g' as the div instruction uses it
1493   0D74 AE            div a, b ; /, a: quotient, b: remainder
1494   0D75 FD F1         pop g
1495   0D77 FD 38         mov c, g
1496   0D79 27            mov b, a
1497   0D7A FD F1         pop g
1498   0D7C E4            pop a
1499   0D7D             ; --- END FACTORS
1500   0D7D E7            pop d
1501   0D7E FD 43         mov [d], b
1502   0D80 0A FD 0C      jmp _while35_cond
1503   0D83             _while35_exit:
1504   0D83             ; while (i > 0) { 
1505   0D83             _while42_cond:
1506   0D83 FA FA FF      lea d, [bp + -6] ; $i
1507   0D86 2A            mov b, [d]
1508   0D87 38 00 00      mov c, 0
1509   0D8A             ; --- START RELATIONAL
1510   0D8A D7            push a
1511   0D8B 11            mov a, b
1512   0D8C FD 2E 00 00   mov32 cb, $00000000
1512   0D90 00 00 
1513   0D92 B0            cmp a, b
1514   0D93 FD 7F         sgt ; >
1515   0D95 E4            pop a
1516   0D96             ; --- END RELATIONAL
1517   0D96 C0 00 00      cmp b, 0
1518   0D99 C6 BF 0D      je _while42_exit
1519   0D9C             _while42_block:
1520   0D9C             ; putchar(digits[--i]); 
1521   0D9C             ; --- START FUNCTION CALL
1522   0D9C FA FC FF      lea d, [bp + -4] ; $digits
1523   0D9F D7            push a
1524   0DA0 DA            push d
1525   0DA1 FA FA FF      lea d, [bp + -6] ; $i
1526   0DA4 2A            mov b, [d]
1527   0DA5 FD 7D         dec b
1528   0DA7 FA FA FF      lea d, [bp + -6] ; $i
1529   0DAA FD 43         mov [d], b
1530   0DAC E7            pop d
1531   0DAD 5A            add d, b
1532   0DAE E4            pop a
1533   0DAF 32            mov bl, [d]
1534   0DB0 A7 00         mov bh, 0
1535   0DB2 38 00 00      mov c, 0
1536   0DB5 DD            push bl
1537   0DB6 07 97 0A      call putchar
1538   0DB9 51 01 00      add sp, 1
1539   0DBC             ; --- END FUNCTION CALL
1540   0DBC 0A 83 0D      jmp _while42_cond
1541   0DBF             _while42_exit:
1542   0DBF F9            leave
1543   0DC0 09            ret
1544   0DC1             
1545   0DC1             print_unsigned:
1546   0DC1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1547   0DC4             ; char digits[5]; 
1548   0DC4 52 05 00      sub sp, 5
1549   0DC7             ; int i = 0; 
1550   0DC7 52 02 00      sub sp, 2
1551   0DCA             ; --- START LOCAL VAR INITIALIZATION
1552   0DCA FA FA FF      lea d, [bp + -6] ; $i
1553   0DCD DA            push d
1554   0DCE FD 2E 00 00   mov32 cb, $00000000
1554   0DD2 00 00 
1555   0DD4 E7            pop d
1556   0DD5 FD 43         mov [d], b
1557   0DD7             ; --- END LOCAL VAR INITIALIZATION
1558   0DD7             ; if(num == 0){ 
1559   0DD7             _if43_cond:
1560   0DD7 FA 05 00      lea d, [bp + 5] ; $num
1561   0DDA 2A            mov b, [d]
1562   0DDB 38 00 00      mov c, 0
1563   0DDE             ; --- START RELATIONAL
1564   0DDE D7            push a
1565   0DDF 11            mov a, b
1566   0DE0 FD 2E 00 00   mov32 cb, $00000000
1566   0DE4 00 00 
1567   0DE6 B0            cmp a, b
1568   0DE7 FD 71         seq ; ==
1569   0DE9 E4            pop a
1570   0DEA             ; --- END RELATIONAL
1571   0DEA C0 00 00      cmp b, 0
1572   0DED C6 02 0E      je _if43_exit
1573   0DF0             _if43_TRUE:
1574   0DF0             ; putchar('0'); 
1575   0DF0             ; --- START FUNCTION CALL
1576   0DF0 FD 2E 30 00   mov32 cb, $00000030
1576   0DF4 00 00 
1577   0DF6 DD            push bl
1578   0DF7 07 97 0A      call putchar
1579   0DFA 51 01 00      add sp, 1
1580   0DFD             ; --- END FUNCTION CALL
1581   0DFD             ; return; 
1582   0DFD F9            leave
1583   0DFE 09            ret
1584   0DFF 0A 02 0E      jmp _if43_exit
1585   0E02             _if43_exit:
1586   0E02             ; while (num > 0) { 
1587   0E02             _while44_cond:
1588   0E02 FA 05 00      lea d, [bp + 5] ; $num
1589   0E05 2A            mov b, [d]
1590   0E06 38 00 00      mov c, 0
1591   0E09             ; --- START RELATIONAL
1592   0E09 D7            push a
1593   0E0A 11            mov a, b
1594   0E0B FD 2E 00 00   mov32 cb, $00000000
1594   0E0F 00 00 
1595   0E11 B0            cmp a, b
1596   0E12 FD 81         sgu ; > (unsigned)
1597   0E14 E4            pop a
1598   0E15             ; --- END RELATIONAL
1599   0E15 C0 00 00      cmp b, 0
1600   0E18 C6 88 0E      je _while44_exit
1601   0E1B             _while44_block:
1602   0E1B             ; digits[i++] = '0' + (num % 10); 
1603   0E1B FA FC FF      lea d, [bp + -4] ; $digits
1604   0E1E D7            push a
1605   0E1F DA            push d
1606   0E20 FA FA FF      lea d, [bp + -6] ; $i
1607   0E23 2A            mov b, [d]
1608   0E24 38 00 00      mov c, 0
1609   0E27 11            mov a, b
1610   0E28 FD 77         inc b
1611   0E2A FA FA FF      lea d, [bp + -6] ; $i
1612   0E2D FD 43         mov [d], b
1613   0E2F 27            mov b, a
1614   0E30 E7            pop d
1615   0E31 5A            add d, b
1616   0E32 E4            pop a
1617   0E33 DA            push d
1618   0E34 FD 2E 30 00   mov32 cb, $00000030
1618   0E38 00 00 
1619   0E3A             ; --- START TERMS
1620   0E3A D7            push a
1621   0E3B 11            mov a, b
1622   0E3C FA 05 00      lea d, [bp + 5] ; $num
1623   0E3F 2A            mov b, [d]
1624   0E40 38 00 00      mov c, 0
1625   0E43             ; --- START FACTORS
1626   0E43 D7            push a
1627   0E44 FD D8         push g
1628   0E46 11            mov a, b
1629   0E47 FD 7A         mov g, c
1630   0E49 FD 2E 0A 00   mov32 cb, $0000000a
1630   0E4D 00 00 
1631   0E4F FD D8         push g ; save 'g' as the div instruction uses it
1632   0E51 AE            div a, b ; %, a: quotient, b: remainder
1633   0E52 11            mov a, b
1634   0E53 FD F1         pop g
1635   0E55 FD 38         mov c, g
1636   0E57 27            mov b, a
1637   0E58 FD F1         pop g
1638   0E5A E4            pop a
1639   0E5B             ; --- END FACTORS
1640   0E5B 56            add b, a
1641   0E5C E4            pop a
1642   0E5D             ; --- END TERMS
1643   0E5D E7            pop d
1644   0E5E FD 3E         mov [d], bl
1645   0E60             ; num = num / 10; 
1646   0E60 FA 05 00      lea d, [bp + 5] ; $num
1647   0E63 DA            push d
1648   0E64 FA 05 00      lea d, [bp + 5] ; $num
1649   0E67 2A            mov b, [d]
1650   0E68 38 00 00      mov c, 0
1651   0E6B             ; --- START FACTORS
1652   0E6B D7            push a
1653   0E6C FD D8         push g
1654   0E6E 11            mov a, b
1655   0E6F FD 7A         mov g, c
1656   0E71 FD 2E 0A 00   mov32 cb, $0000000a
1656   0E75 00 00 
1657   0E77 FD D8         push g ; save 'g' as the div instruction uses it
1658   0E79 AE            div a, b ; /, a: quotient, b: remainder
1659   0E7A FD F1         pop g
1660   0E7C FD 38         mov c, g
1661   0E7E 27            mov b, a
1662   0E7F FD F1         pop g
1663   0E81 E4            pop a
1664   0E82             ; --- END FACTORS
1665   0E82 E7            pop d
1666   0E83 FD 43         mov [d], b
1667   0E85 0A 02 0E      jmp _while44_cond
1668   0E88             _while44_exit:
1669   0E88             ; while (i > 0) { 
1670   0E88             _while51_cond:
1671   0E88 FA FA FF      lea d, [bp + -6] ; $i
1672   0E8B 2A            mov b, [d]
1673   0E8C 38 00 00      mov c, 0
1674   0E8F             ; --- START RELATIONAL
1675   0E8F D7            push a
1676   0E90 11            mov a, b
1677   0E91 FD 2E 00 00   mov32 cb, $00000000
1677   0E95 00 00 
1678   0E97 B0            cmp a, b
1679   0E98 FD 7F         sgt ; >
1680   0E9A E4            pop a
1681   0E9B             ; --- END RELATIONAL
1682   0E9B C0 00 00      cmp b, 0
1683   0E9E C6 C4 0E      je _while51_exit
1684   0EA1             _while51_block:
1685   0EA1             ; putchar(digits[--i]); 
1686   0EA1             ; --- START FUNCTION CALL
1687   0EA1 FA FC FF      lea d, [bp + -4] ; $digits
1688   0EA4 D7            push a
1689   0EA5 DA            push d
1690   0EA6 FA FA FF      lea d, [bp + -6] ; $i
1691   0EA9 2A            mov b, [d]
1692   0EAA FD 7D         dec b
1693   0EAC FA FA FF      lea d, [bp + -6] ; $i
1694   0EAF FD 43         mov [d], b
1695   0EB1 E7            pop d
1696   0EB2 5A            add d, b
1697   0EB3 E4            pop a
1698   0EB4 32            mov bl, [d]
1699   0EB5 A7 00         mov bh, 0
1700   0EB7 38 00 00      mov c, 0
1701   0EBA DD            push bl
1702   0EBB 07 97 0A      call putchar
1703   0EBE 51 01 00      add sp, 1
1704   0EC1             ; --- END FUNCTION CALL
1705   0EC1 0A 88 0E      jmp _while51_cond
1706   0EC4             _while51_exit:
1707   0EC4 F9            leave
1708   0EC5 09            ret
1709   0EC6             
1710   0EC6             printx16:
1711   0EC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1712   0EC9             ; --- BEGIN INLINE ASM SEGMENT
1713   0EC9 FA 05 00      lea d, [bp + 5] ; $hex
1714   0ECC 2A            mov b, [d]
1715   0ECD             print_u16x_printx16:
1716   0ECD DD            push bl
1717   0ECE 30            mov bl, bh
1718   0ECF 07 EC 0E      call _itoa_printx16        ; convert bh to char in A
1719   0ED2 2F            mov bl, al        ; save al
1720   0ED3 19 00         mov al, 0
1721   0ED5 05 03         syscall sys_io        ; display AH
1722   0ED7 24            mov ah, bl        ; retrieve al
1723   0ED8 19 00         mov al, 0
1724   0EDA 05 03         syscall sys_io        ; display AL
1725   0EDC EA            pop bl
1726   0EDD 07 EC 0E      call _itoa_printx16        ; convert bh to char in A
1727   0EE0 2F            mov bl, al        ; save al
1728   0EE1 19 00         mov al, 0
1729   0EE3 05 03         syscall sys_io        ; display AH
1730   0EE5 24            mov ah, bl        ; retrieve al
1731   0EE6 19 00         mov al, 0
1732   0EE8 05 03         syscall sys_io        ; display AL
1733   0EEA             ; --- END INLINE ASM SEGMENT
1734   0EEA             ; return; 
1735   0EEA F9            leave
1736   0EEB 09            ret
1737   0EEC             ; --- BEGIN INLINE ASM SEGMENT
1738   0EEC             _itoa_printx16:
1739   0EEC DA            push d
1740   0EED D8            push b
1741   0EEE A7 00         mov bh, 0
1742   0EF0 FD A4 04      shr bl, 4  
1743   0EF3 74            mov d, b
1744   0EF4 1F 06 0F      mov al, [d + s_hex_digits_printx16]
1745   0EF7 23            mov ah, al
1746   0EF8 E5            pop b
1747   0EF9 D8            push b
1748   0EFA A7 00         mov bh, 0
1749   0EFC FD 87 0F      and bl, $0F
1750   0EFF 74            mov d, b
1751   0F00 1F 06 0F      mov al, [d + s_hex_digits_printx16]
1752   0F03 E5            pop b
1753   0F04 E7            pop d
1754   0F05 09            ret
1755   0F06 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1755   0F0A 34 35 36 37 
1755   0F0E 38 39 41 42 
1755   0F12 43 44 45 46 
1756   0F16             ; --- END INLINE ASM SEGMENT
1757   0F16 F9            leave
1758   0F17 09            ret
1759   0F18             ; --- END TEXT SEGMENT
1760   0F18             
1761   0F18             ; --- BEGIN DATA SEGMENT
1762   0F18 1B 5B 32 4A _s0: .db "\033[2J\033[H", 0
1762   0F1C 1B 5B 48 00 
1763   0F20 1B 5B 31 6D _s1: .db "\033[1mBold Text\033[0m\n", 0
1763   0F24 42 6F 6C 64 
1763   0F28 20 54 65 78 
1763   0F2C 74 1B 5B 30 
1763   0F30 6D 0A 00 
1764   0F33 1B 5B 34 6D _s2: .db "\033[4mUnderlined Text\033[0m\n", 0
1764   0F37 55 6E 64 65 
1764   0F3B 72 6C 69 6E 
1764   0F3F 65 64 20 54 
1764   0F43 65 78 74 1B 
1764   0F47 5B 30 6D 0A 
1764   0F4B 00 
1765   0F4C 1B 5B 35 6D _s3: .db "\033[5mBlinking Text\033[0m\n", 0
1765   0F50 42 6C 69 6E 
1765   0F54 6B 69 6E 67 
1765   0F58 20 54 65 78 
1765   0F5C 74 1B 5B 30 
1765   0F60 6D 0A 00 
1766   0F63 1B 5B 37 6D _s4: .db "\033[7mInverted Colors\033[0m\n", 0
1766   0F67 49 6E 76 65 
1766   0F6B 72 74 65 64 
1766   0F6F 20 43 6F 6C 
1766   0F73 6F 72 73 1B 
1766   0F77 5B 30 6D 0A 
1766   0F7B 00 
1767   0F7C 52 65 73 65 _s5: .db "Reset All\n\n", 0
1767   0F80 74 20 41 6C 
1767   0F84 6C 0A 0A 00 
1768   0F88 1B 5B 25 64 _s6: .db "\033[%d;%dm %d/%d ", 0
1768   0F8C 3B 25 64 6D 
1768   0F90 20 25 64 2F 
1768   0F94 25 64 20 00 
1769   0F98 1B 5B 30 6D _s7: .db "\033[0m\n", 0
1769   0F9C 0A 00 
1770   0F9E 0A 32 35 36 _s8: .db "\n256-Color Chart:\n", 0
1770   0FA2 2D 43 6F 6C 
1770   0FA6 6F 72 20 43 
1770   0FAA 68 61 72 74 
1770   0FAE 3A 0A 00 
1771   0FB1 1B 5B 34 38 _s9: .db "\033[48;5;%dm %3d \033[0m", 0
1771   0FB5 3B 35 3B 25 
1771   0FB9 64 6D 20 25 
1771   0FBD 33 64 20 1B 
1771   0FC1 5B 30 6D 00 
1772   0FC5 0A 00       _s10: .db "\n", 0
1773   0FC7 55 6E 65 78 _s11: .db "Unexpected format in printf.", 0
1773   0FCB 70 65 63 74 
1773   0FCF 65 64 20 66 
1773   0FD3 6F 72 6D 61 
1773   0FD7 74 20 69 6E 
1773   0FDB 20 70 72 69 
1773   0FDF 6E 74 66 2E 
1773   0FE3 00 
1774   0FE4 45 72 72 6F _s12: .db "Error: Unknown argument type.\n", 0
1774   0FE8 72 3A 20 55 
1774   0FEC 6E 6B 6E 6F 
1774   0FF0 77 6E 20 61 
1774   0FF4 72 67 75 6D 
1774   0FF8 65 6E 74 20 
1774   0FFC 74 79 70 65 
1774   1000 2E 0A 00 
1775   1003             
1776   1003 05 10       _heap_top: .dw _heap
1777   1005 00          _heap: .db 0
1778   1006             ; --- END DATA SEGMENT
1779   1006             
1780   1006             .end
tasm: Number of errors = 0
