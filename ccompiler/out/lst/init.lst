0001   0000             ; --- FILENAME: ../solarium/sbin/init.c
0002   0000             ; --- DATE:     16-06-2025 at 19:16:57
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; printf("init process started.\n\r"); 
0012   0408             ; --- START FUNCTION CALL
0013   0408 26 4F 0D      mov b, _s0 ; "init process started.\n\r"
0014   040B FD AB         swp b
0015   040D D8            push b
0016   040E 07 29 04      call printf
0017   0411 51 02 00      add sp, 2
0018   0414             ; --- END FUNCTION CALL
0019   0414             ; printf("starting shell...\n\r"); 
0020   0414             ; --- START FUNCTION CALL
0021   0414 26 67 0D      mov b, _s1 ; "starting shell...\n\r"
0022   0417 FD AB         swp b
0023   0419 D8            push b
0024   041A 07 29 04      call printf
0025   041D 51 02 00      add sp, 2
0026   0420             ; --- END FUNCTION CALL
0027   0420             ; --- BEGIN INLINE ASM SEGMENT
0028   0420 3B 4D 0D      mov d, _shell_path ; $shell_path
0029   0423 FD 2A         mov d, [d]
out/init.asm line 0030: Label not found: (sys_spawn_proc)
out/init.asm line 0030: Unused data in MS byte of argument. (200)
0030   0425 05 00         syscall sys_spawn_proc
0031   0427             ; --- END INLINE ASM SEGMENT
0032   0427 05 0B         syscall sys_terminate_proc
0033   0429             
0034   0429             printf:
0035   0429 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0036   042C             ; char *p, *format_p; 
0037   042C 52 02 00      sub sp, 2
0038   042F 52 02 00      sub sp, 2
0039   0432             ; format_p = format; 
0040   0432 FA FD FF      lea d, [bp + -3] ; $format_p
0041   0435 DA            push d
0042   0436 FA 05 00      lea d, [bp + 5] ; $format
0043   0439 2A            mov b, [d]
0044   043A 38 00 00      mov c, 0
0045   043D E7            pop d
0046   043E FD 43         mov [d], b
0047   0440             ; p = &format + 2; 
0048   0440 FA FF FF      lea d, [bp + -1] ; $p
0049   0443 DA            push d
0050   0444 FA 05 00      lea d, [bp + 5] ; $format
0051   0447 2D            mov b, d
0052   0448             ; --- START TERMS
0053   0448 D7            push a
0054   0449 11            mov a, b
0055   044A FD 2E 02 00   mov32 cb, $00000002
0055   044E 00 00 
0056   0450 56            add b, a
0057   0451 E4            pop a
0058   0452             ; --- END TERMS
0059   0452 E7            pop d
0060   0453 FD 43         mov [d], b
0061   0455             ; for(;;){ 
0062   0455             _for1_init:
0063   0455             _for1_cond:
0064   0455             _for1_block:
0065   0455             ; if(!*format_p) break; 
0066   0455             _if2_cond:
0067   0455 FA FD FF      lea d, [bp + -3] ; $format_p
0068   0458 2A            mov b, [d]
0069   0459 38 00 00      mov c, 0
0070   045C 74            mov d, b
0071   045D 32            mov bl, [d]
0072   045E A7 00         mov bh, 0
0073   0460 38 00 00      mov c, 0
0074   0463 C0 00 00      cmp b, 0
0075   0466 FD 71         seq ; !
0076   0468 C0 00 00      cmp b, 0
0077   046B C6 74 04      je _if2_else
0078   046E             _if2_TRUE:
0079   046E             ; break; 
0080   046E 0A 14 07      jmp _for1_exit ; for break
0081   0471 0A 01 07      jmp _if2_exit
0082   0474             _if2_else:
0083   0474             ; if(*format_p == '%'){ 
0084   0474             _if3_cond:
0085   0474 FA FD FF      lea d, [bp + -3] ; $format_p
0086   0477 2A            mov b, [d]
0087   0478 38 00 00      mov c, 0
0088   047B 74            mov d, b
0089   047C 32            mov bl, [d]
0090   047D A7 00         mov bh, 0
0091   047F 38 00 00      mov c, 0
0092   0482             ; --- START RELATIONAL
0093   0482 D7            push a
0094   0483 11            mov a, b
0095   0484 FD 2E 25 00   mov32 cb, $00000025
0095   0488 00 00 
0096   048A B0            cmp a, b
0097   048B FD 71         seq ; ==
0098   048D E4            pop a
0099   048E             ; --- END RELATIONAL
0100   048E C0 00 00      cmp b, 0
0101   0491 C6 EC 06      je _if3_else
0102   0494             _if3_TRUE:
0103   0494             ; format_p++; 
0104   0494 FA FD FF      lea d, [bp + -3] ; $format_p
0105   0497 2A            mov b, [d]
0106   0498 38 00 00      mov c, 0
0107   049B FD 77         inc b
0108   049D FA FD FF      lea d, [bp + -3] ; $format_p
0109   04A0 FD 43         mov [d], b
0110   04A2 FD 7D         dec b
0111   04A4             ; switch(*format_p){ 
0112   04A4             _switch4_expr:
0113   04A4 FA FD FF      lea d, [bp + -3] ; $format_p
0114   04A7 2A            mov b, [d]
0115   04A8 38 00 00      mov c, 0
0116   04AB 74            mov d, b
0117   04AC 32            mov bl, [d]
0118   04AD A7 00         mov bh, 0
0119   04AF 38 00 00      mov c, 0
0120   04B2             _switch4_comparisons:
0121   04B2 C1 6C         cmp bl, $6c
0122   04B4 C6 E0 04      je _switch4_case0
0123   04B7 C1 4C         cmp bl, $4c
0124   04B9 C6 E0 04      je _switch4_case1
0125   04BC C1 64         cmp bl, $64
0126   04BE C6 F0 05      je _switch4_case2
0127   04C1 C1 69         cmp bl, $69
0128   04C3 C6 F0 05      je _switch4_case3
0129   04C6 C1 75         cmp bl, $75
0130   04C8 C6 20 06      je _switch4_case4
0131   04CB C1 78         cmp bl, $78
0132   04CD C6 50 06      je _switch4_case5
0133   04D0 C1 63         cmp bl, $63
0134   04D2 C6 80 06      je _switch4_case6
0135   04D5 C1 73         cmp bl, $73
0136   04D7 C6 B0 06      je _switch4_case7
0137   04DA 0A DD 06      jmp _switch4_default
0138   04DD 0A E9 06      jmp _switch4_exit
0139   04E0             _switch4_case0:
0140   04E0             _switch4_case1:
0141   04E0             ; format_p++; 
0142   04E0 FA FD FF      lea d, [bp + -3] ; $format_p
0143   04E3 2A            mov b, [d]
0144   04E4 38 00 00      mov c, 0
0145   04E7 FD 77         inc b
0146   04E9 FA FD FF      lea d, [bp + -3] ; $format_p
0147   04EC FD 43         mov [d], b
0148   04EE FD 7D         dec b
0149   04F0             ; if(*format_p == 'd' || *format_p == 'i') 
0150   04F0             _if5_cond:
0151   04F0 FA FD FF      lea d, [bp + -3] ; $format_p
0152   04F3 2A            mov b, [d]
0153   04F4 38 00 00      mov c, 0
0154   04F7 74            mov d, b
0155   04F8 32            mov bl, [d]
0156   04F9 A7 00         mov bh, 0
0157   04FB 38 00 00      mov c, 0
0158   04FE             ; --- START RELATIONAL
0159   04FE D7            push a
0160   04FF 11            mov a, b
0161   0500 FD 2E 64 00   mov32 cb, $00000064
0161   0504 00 00 
0162   0506 B0            cmp a, b
0163   0507 FD 71         seq ; ==
0164   0509 E4            pop a
0165   050A             ; --- END RELATIONAL
0166   050A             ; --- START LOGICAL OR
0167   050A D7            push a
0168   050B 11            mov a, b
0169   050C FA FD FF      lea d, [bp + -3] ; $format_p
0170   050F 2A            mov b, [d]
0171   0510 38 00 00      mov c, 0
0172   0513 74            mov d, b
0173   0514 32            mov bl, [d]
0174   0515 A7 00         mov bh, 0
0175   0517 38 00 00      mov c, 0
0176   051A             ; --- START RELATIONAL
0177   051A D7            push a
0178   051B 11            mov a, b
0179   051C FD 2E 69 00   mov32 cb, $00000069
0179   0520 00 00 
0180   0522 B0            cmp a, b
0181   0523 FD 71         seq ; ==
0182   0525 E4            pop a
0183   0526             ; --- END RELATIONAL
0184   0526 FD A8         sor a, b ; ||
0185   0528 E4            pop a
0186   0529             ; --- END LOGICAL OR
0187   0529 C0 00 00      cmp b, 0
0188   052C C6 4D 05      je _if5_else
0189   052F             _if5_TRUE:
0190   052F             ; print_signed_long(*(long *)p); 
0191   052F             ; --- START FUNCTION CALL
0192   052F FA FF FF      lea d, [bp + -1] ; $p
0193   0532 2A            mov b, [d]
0194   0533 38 00 00      mov c, 0
0195   0536 74            mov d, b
0196   0537 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0197   053A FD 39         mov c, b ; And place it into C
0198   053C 2A            mov b, [d] ; Lower Word in B
0199   053D 12            mov a, c
0200   053E FD AA         swp a
0201   0540 D7            push a
0202   0541 FD AB         swp b
0203   0543 D8            push b
0204   0544 07 16 07      call print_signed_long
0205   0547 51 04 00      add sp, 4
0206   054A             ; --- END FUNCTION CALL
0207   054A 0A D5 05      jmp _if5_exit
0208   054D             _if5_else:
0209   054D             ; if(*format_p == 'u') 
0210   054D             _if6_cond:
0211   054D FA FD FF      lea d, [bp + -3] ; $format_p
0212   0550 2A            mov b, [d]
0213   0551 38 00 00      mov c, 0
0214   0554 74            mov d, b
0215   0555 32            mov bl, [d]
0216   0556 A7 00         mov bh, 0
0217   0558 38 00 00      mov c, 0
0218   055B             ; --- START RELATIONAL
0219   055B D7            push a
0220   055C 11            mov a, b
0221   055D FD 2E 75 00   mov32 cb, $00000075
0221   0561 00 00 
0222   0563 B0            cmp a, b
0223   0564 FD 71         seq ; ==
0224   0566 E4            pop a
0225   0567             ; --- END RELATIONAL
0226   0567 C0 00 00      cmp b, 0
0227   056A C6 8B 05      je _if6_else
0228   056D             _if6_TRUE:
0229   056D             ; print_unsigned_long(*(unsigned long *)p); 
0230   056D             ; --- START FUNCTION CALL
0231   056D FA FF FF      lea d, [bp + -1] ; $p
0232   0570 2A            mov b, [d]
0233   0571 38 00 00      mov c, 0
0234   0574 74            mov d, b
0235   0575 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0236   0578 FD 39         mov c, b ; And place it into C
0237   057A 2A            mov b, [d] ; Lower Word in B
0238   057B 12            mov a, c
0239   057C FD AA         swp a
0240   057E D7            push a
0241   057F FD AB         swp b
0242   0581 D8            push b
0243   0582 07 B6 08      call print_unsigned_long
0244   0585 51 04 00      add sp, 4
0245   0588             ; --- END FUNCTION CALL
0246   0588 0A D5 05      jmp _if6_exit
0247   058B             _if6_else:
0248   058B             ; if(*format_p == 'x') 
0249   058B             _if7_cond:
0250   058B FA FD FF      lea d, [bp + -3] ; $format_p
0251   058E 2A            mov b, [d]
0252   058F 38 00 00      mov c, 0
0253   0592 74            mov d, b
0254   0593 32            mov bl, [d]
0255   0594 A7 00         mov bh, 0
0256   0596 38 00 00      mov c, 0
0257   0599             ; --- START RELATIONAL
0258   0599 D7            push a
0259   059A 11            mov a, b
0260   059B FD 2E 78 00   mov32 cb, $00000078
0260   059F 00 00 
0261   05A1 B0            cmp a, b
0262   05A2 FD 71         seq ; ==
0263   05A4 E4            pop a
0264   05A5             ; --- END RELATIONAL
0265   05A5 C0 00 00      cmp b, 0
0266   05A8 C6 C9 05      je _if7_else
0267   05AB             _if7_TRUE:
0268   05AB             ; printx32(*(long int *)p); 
0269   05AB             ; --- START FUNCTION CALL
0270   05AB FA FF FF      lea d, [bp + -1] ; $p
0271   05AE 2A            mov b, [d]
0272   05AF 38 00 00      mov c, 0
0273   05B2 74            mov d, b
0274   05B3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0275   05B6 FD 39         mov c, b ; And place it into C
0276   05B8 2A            mov b, [d] ; Lower Word in B
0277   05B9 12            mov a, c
0278   05BA FD AA         swp a
0279   05BC D7            push a
0280   05BD FD AB         swp b
0281   05BF D8            push b
0282   05C0 07 F4 09      call printx32
0283   05C3 51 04 00      add sp, 4
0284   05C6             ; --- END FUNCTION CALL
0285   05C6 0A D5 05      jmp _if7_exit
0286   05C9             _if7_else:
0287   05C9             ; err("Unexpected format in printf."); 
0288   05C9             ; --- START FUNCTION CALL
0289   05C9 26 7B 0D      mov b, _s2 ; "Unexpected format in printf."
0290   05CC FD AB         swp b
0291   05CE D8            push b
0292   05CF 07 54 0A      call err
0293   05D2 51 02 00      add sp, 2
0294   05D5             ; --- END FUNCTION CALL
0295   05D5             _if7_exit:
0296   05D5             _if6_exit:
0297   05D5             _if5_exit:
0298   05D5             ; p = p + 4; 
0299   05D5 FA FF FF      lea d, [bp + -1] ; $p
0300   05D8 DA            push d
0301   05D9 FA FF FF      lea d, [bp + -1] ; $p
0302   05DC 2A            mov b, [d]
0303   05DD 38 00 00      mov c, 0
0304   05E0             ; --- START TERMS
0305   05E0 D7            push a
0306   05E1 11            mov a, b
0307   05E2 FD 2E 04 00   mov32 cb, $00000004
0307   05E6 00 00 
0308   05E8 56            add b, a
0309   05E9 E4            pop a
0310   05EA             ; --- END TERMS
0311   05EA E7            pop d
0312   05EB FD 43         mov [d], b
0313   05ED             ; break; 
0314   05ED 0A E9 06      jmp _switch4_exit ; case break
0315   05F0             _switch4_case2:
0316   05F0             _switch4_case3:
0317   05F0             ; print_signed(*(int*)p); 
0318   05F0             ; --- START FUNCTION CALL
0319   05F0 FA FF FF      lea d, [bp + -1] ; $p
0320   05F3 2A            mov b, [d]
0321   05F4 38 00 00      mov c, 0
0322   05F7 74            mov d, b
0323   05F8 2A            mov b, [d]
0324   05F9 38 00 00      mov c, 0
0325   05FC FD AB         swp b
0326   05FE D8            push b
0327   05FF 07 82 0A      call print_signed
0328   0602 51 02 00      add sp, 2
0329   0605             ; --- END FUNCTION CALL
0330   0605             ; p = p + 2; 
0331   0605 FA FF FF      lea d, [bp + -1] ; $p
0332   0608 DA            push d
0333   0609 FA FF FF      lea d, [bp + -1] ; $p
0334   060C 2A            mov b, [d]
0335   060D 38 00 00      mov c, 0
0336   0610             ; --- START TERMS
0337   0610 D7            push a
0338   0611 11            mov a, b
0339   0612 FD 2E 02 00   mov32 cb, $00000002
0339   0616 00 00 
0340   0618 56            add b, a
0341   0619 E4            pop a
0342   061A             ; --- END TERMS
0343   061A E7            pop d
0344   061B FD 43         mov [d], b
0345   061D             ; break; 
0346   061D 0A E9 06      jmp _switch4_exit ; case break
0347   0620             _switch4_case4:
0348   0620             ; print_unsigned(*(unsigned int*)p); 
0349   0620             ; --- START FUNCTION CALL
0350   0620 FA FF FF      lea d, [bp + -1] ; $p
0351   0623 2A            mov b, [d]
0352   0624 38 00 00      mov c, 0
0353   0627 74            mov d, b
0354   0628 2A            mov b, [d]
0355   0629 38 00 00      mov c, 0
0356   062C FD AB         swp b
0357   062E D8            push b
0358   062F 07 D3 0B      call print_unsigned
0359   0632 51 02 00      add sp, 2
0360   0635             ; --- END FUNCTION CALL
0361   0635             ; p = p + 2; 
0362   0635 FA FF FF      lea d, [bp + -1] ; $p
0363   0638 DA            push d
0364   0639 FA FF FF      lea d, [bp + -1] ; $p
0365   063C 2A            mov b, [d]
0366   063D 38 00 00      mov c, 0
0367   0640             ; --- START TERMS
0368   0640 D7            push a
0369   0641 11            mov a, b
0370   0642 FD 2E 02 00   mov32 cb, $00000002
0370   0646 00 00 
0371   0648 56            add b, a
0372   0649 E4            pop a
0373   064A             ; --- END TERMS
0374   064A E7            pop d
0375   064B FD 43         mov [d], b
0376   064D             ; break; 
0377   064D 0A E9 06      jmp _switch4_exit ; case break
0378   0650             _switch4_case5:
0379   0650             ; printx16(*(int*)p); 
0380   0650             ; --- START FUNCTION CALL
0381   0650 FA FF FF      lea d, [bp + -1] ; $p
0382   0653 2A            mov b, [d]
0383   0654 38 00 00      mov c, 0
0384   0657 74            mov d, b
0385   0658 2A            mov b, [d]
0386   0659 38 00 00      mov c, 0
0387   065C FD AB         swp b
0388   065E D8            push b
0389   065F 07 EB 0C      call printx16
0390   0662 51 02 00      add sp, 2
0391   0665             ; --- END FUNCTION CALL
0392   0665             ; p = p + 2; 
0393   0665 FA FF FF      lea d, [bp + -1] ; $p
0394   0668 DA            push d
0395   0669 FA FF FF      lea d, [bp + -1] ; $p
0396   066C 2A            mov b, [d]
0397   066D 38 00 00      mov c, 0
0398   0670             ; --- START TERMS
0399   0670 D7            push a
0400   0671 11            mov a, b
0401   0672 FD 2E 02 00   mov32 cb, $00000002
0401   0676 00 00 
0402   0678 56            add b, a
0403   0679 E4            pop a
0404   067A             ; --- END TERMS
0405   067A E7            pop d
0406   067B FD 43         mov [d], b
0407   067D             ; break; 
0408   067D 0A E9 06      jmp _switch4_exit ; case break
0409   0680             _switch4_case6:
0410   0680             ; putchar(*(char*)p); 
0411   0680             ; --- START FUNCTION CALL
0412   0680 FA FF FF      lea d, [bp + -1] ; $p
0413   0683 2A            mov b, [d]
0414   0684 38 00 00      mov c, 0
0415   0687 74            mov d, b
0416   0688 32            mov bl, [d]
0417   0689 A7 00         mov bh, 0
0418   068B 38 00 00      mov c, 0
0419   068E DD            push bl
0420   068F 07 A8 08      call putchar
0421   0692 51 01 00      add sp, 1
0422   0695             ; --- END FUNCTION CALL
0423   0695             ; p = p + 2; 
0424   0695 FA FF FF      lea d, [bp + -1] ; $p
0425   0698 DA            push d
0426   0699 FA FF FF      lea d, [bp + -1] ; $p
0427   069C 2A            mov b, [d]
0428   069D 38 00 00      mov c, 0
0429   06A0             ; --- START TERMS
0430   06A0 D7            push a
0431   06A1 11            mov a, b
0432   06A2 FD 2E 02 00   mov32 cb, $00000002
0432   06A6 00 00 
0433   06A8 56            add b, a
0434   06A9 E4            pop a
0435   06AA             ; --- END TERMS
0436   06AA E7            pop d
0437   06AB FD 43         mov [d], b
0438   06AD             ; break; 
0439   06AD 0A E9 06      jmp _switch4_exit ; case break
0440   06B0             _switch4_case7:
0441   06B0             ; print(*(char**)p); 
0442   06B0             ; --- START FUNCTION CALL
0443   06B0 FA FF FF      lea d, [bp + -1] ; $p
0444   06B3 2A            mov b, [d]
0445   06B4 38 00 00      mov c, 0
0446   06B7 74            mov d, b
0447   06B8 2A            mov b, [d]
0448   06B9 FD AB         swp b
0449   06BB D8            push b
0450   06BC 07 69 0A      call print
0451   06BF 51 02 00      add sp, 2
0452   06C2             ; --- END FUNCTION CALL
0453   06C2             ; p = p + 2; 
0454   06C2 FA FF FF      lea d, [bp + -1] ; $p
0455   06C5 DA            push d
0456   06C6 FA FF FF      lea d, [bp + -1] ; $p
0457   06C9 2A            mov b, [d]
0458   06CA 38 00 00      mov c, 0
0459   06CD             ; --- START TERMS
0460   06CD D7            push a
0461   06CE 11            mov a, b
0462   06CF FD 2E 02 00   mov32 cb, $00000002
0462   06D3 00 00 
0463   06D5 56            add b, a
0464   06D6 E4            pop a
0465   06D7             ; --- END TERMS
0466   06D7 E7            pop d
0467   06D8 FD 43         mov [d], b
0468   06DA             ; break; 
0469   06DA 0A E9 06      jmp _switch4_exit ; case break
0470   06DD             _switch4_default:
0471   06DD             ; print("Error: Unknown argument type.\n"); 
0472   06DD             ; --- START FUNCTION CALL
0473   06DD 26 98 0D      mov b, _s3 ; "Error: Unknown argument type.\n"
0474   06E0 FD AB         swp b
0475   06E2 D8            push b
0476   06E3 07 69 0A      call print
0477   06E6 51 02 00      add sp, 2
0478   06E9             ; --- END FUNCTION CALL
0479   06E9             _switch4_exit:
0480   06E9 0A 01 07      jmp _if3_exit
0481   06EC             _if3_else:
0482   06EC             ; putchar(*format_p); 
0483   06EC             ; --- START FUNCTION CALL
0484   06EC FA FD FF      lea d, [bp + -3] ; $format_p
0485   06EF 2A            mov b, [d]
0486   06F0 38 00 00      mov c, 0
0487   06F3 74            mov d, b
0488   06F4 32            mov bl, [d]
0489   06F5 A7 00         mov bh, 0
0490   06F7 38 00 00      mov c, 0
0491   06FA DD            push bl
0492   06FB 07 A8 08      call putchar
0493   06FE 51 01 00      add sp, 1
0494   0701             ; --- END FUNCTION CALL
0495   0701             _if3_exit:
0496   0701             _if2_exit:
0497   0701             ; format_p++; 
0498   0701 FA FD FF      lea d, [bp + -3] ; $format_p
0499   0704 2A            mov b, [d]
0500   0705 38 00 00      mov c, 0
0501   0708 FD 77         inc b
0502   070A FA FD FF      lea d, [bp + -3] ; $format_p
0503   070D FD 43         mov [d], b
0504   070F FD 7D         dec b
0505   0711             _for1_update:
0506   0711 0A 55 04      jmp _for1_cond
0507   0714             _for1_exit:
0508   0714 F9            leave
0509   0715 09            ret
0510   0716             
0511   0716             print_signed_long:
0512   0716 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0513   0719             ; char digits[10]; 
0514   0719 52 0A 00      sub sp, 10
0515   071C             ; int i = 0; 
0516   071C 52 02 00      sub sp, 2
0517   071F             ; --- START LOCAL VAR INITIALIZATION
0518   071F FA F5 FF      lea d, [bp + -11] ; $i
0519   0722 DA            push d
0520   0723 FD 2E 00 00   mov32 cb, $00000000
0520   0727 00 00 
0521   0729 E7            pop d
0522   072A FD 43         mov [d], b
0523   072C             ; --- END LOCAL VAR INITIALIZATION
0524   072C             ; if (num < 0) { 
0525   072C             _if8_cond:
0526   072C FA 05 00      lea d, [bp + 5] ; $num
0527   072F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0528   0732 FD 39         mov c, b ; And place it into C
0529   0734 2A            mov b, [d] ; Lower Word in B
0530   0735             ; --- START RELATIONAL
0531   0735 D7            push a
0532   0736 FD D8         push g
0533   0738 11            mov a, b
0534   0739 FD 7A         mov g, c
0535   073B FD 2E 00 00   mov32 cb, $00000000
0535   073F 00 00 
0536   0741 38 00 00      mov c, 0
0537   0744 FD AF         cmp32 ga, cb
0538   0746 FD 73         slt ; <
0539   0748 FD F1         pop g
0540   074A E4            pop a
0541   074B             ; --- END RELATIONAL
0542   074B C0 00 00      cmp b, 0
0543   074E C6 80 07      je _if8_else
0544   0751             _if8_TRUE:
0545   0751             ; putchar('-'); 
0546   0751             ; --- START FUNCTION CALL
0547   0751 FD 2E 2D 00   mov32 cb, $0000002d
0547   0755 00 00 
0548   0757 DD            push bl
0549   0758 07 A8 08      call putchar
0550   075B 51 01 00      add sp, 1
0551   075E             ; --- END FUNCTION CALL
0552   075E             ; num = -num; 
0553   075E FA 05 00      lea d, [bp + 5] ; $num
0554   0761 DA            push d
0555   0762 FA 05 00      lea d, [bp + 5] ; $num
0556   0765 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0557   0768 FD 39         mov c, b ; And place it into C
0558   076A 2A            mov b, [d] ; Lower Word in B
0559   076B 12            mov a, c
0560   076C 95            not a
0561   076D 97            not b
0562   076E 55 01 00      add b, 1
0563   0771 5B 00 00      adc a, 0
0564   0774 39            mov c, a
0565   0775 E7            pop d
0566   0776 FD 43         mov [d], b
0567   0778 28            mov b, c
0568   0779 FD 44 02 00   mov [d + 2], b
0569   077D 0A B7 07      jmp _if8_exit
0570   0780             _if8_else:
0571   0780             ; if (num == 0) { 
0572   0780             _if9_cond:
0573   0780 FA 05 00      lea d, [bp + 5] ; $num
0574   0783 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0575   0786 FD 39         mov c, b ; And place it into C
0576   0788 2A            mov b, [d] ; Lower Word in B
0577   0789             ; --- START RELATIONAL
0578   0789 D7            push a
0579   078A FD D8         push g
0580   078C 11            mov a, b
0581   078D FD 7A         mov g, c
0582   078F FD 2E 00 00   mov32 cb, $00000000
0582   0793 00 00 
0583   0795 38 00 00      mov c, 0
0584   0798 FD AF         cmp32 ga, cb
0585   079A FD 71         seq ; ==
0586   079C FD F1         pop g
0587   079E E4            pop a
0588   079F             ; --- END RELATIONAL
0589   079F C0 00 00      cmp b, 0
0590   07A2 C6 B7 07      je _if9_exit
0591   07A5             _if9_TRUE:
0592   07A5             ; putchar('0'); 
0593   07A5             ; --- START FUNCTION CALL
0594   07A5 FD 2E 30 00   mov32 cb, $00000030
0594   07A9 00 00 
0595   07AB DD            push bl
0596   07AC 07 A8 08      call putchar
0597   07AF 51 01 00      add sp, 1
0598   07B2             ; --- END FUNCTION CALL
0599   07B2             ; return; 
0600   07B2 F9            leave
0601   07B3 09            ret
0602   07B4 0A B7 07      jmp _if9_exit
0603   07B7             _if9_exit:
0604   07B7             _if8_exit:
0605   07B7             ; while (num > 0) { 
0606   07B7             _while10_cond:
0607   07B7 FA 05 00      lea d, [bp + 5] ; $num
0608   07BA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0609   07BD FD 39         mov c, b ; And place it into C
0610   07BF 2A            mov b, [d] ; Lower Word in B
0611   07C0             ; --- START RELATIONAL
0612   07C0 D7            push a
0613   07C1 FD D8         push g
0614   07C3 11            mov a, b
0615   07C4 FD 7A         mov g, c
0616   07C6 FD 2E 00 00   mov32 cb, $00000000
0616   07CA 00 00 
0617   07CC 38 00 00      mov c, 0
0618   07CF FD AF         cmp32 ga, cb
0619   07D1 FD 7F         sgt
0620   07D3 FD F1         pop g
0621   07D5 E4            pop a
0622   07D6             ; --- END RELATIONAL
0623   07D6 C0 00 00      cmp b, 0
0624   07D9 C6 5E 08      je _while10_exit
0625   07DC             _while10_block:
0626   07DC             ; digits[i] = '0' + (num % 10); 
0627   07DC FA F7 FF      lea d, [bp + -9] ; $digits
0628   07DF D7            push a
0629   07E0 DA            push d
0630   07E1 FA F5 FF      lea d, [bp + -11] ; $i
0631   07E4 2A            mov b, [d]
0632   07E5 38 00 00      mov c, 0
0633   07E8 E7            pop d
0634   07E9 5A            add d, b
0635   07EA E4            pop a
0636   07EB DA            push d
0637   07EC FD 2E 30 00   mov32 cb, $00000030
0637   07F0 00 00 
0638   07F2             ; --- START TERMS
0639   07F2 D7            push a
0640   07F3 11            mov a, b
0641   07F4 FA 05 00      lea d, [bp + 5] ; $num
0642   07F7 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0643   07FA FD 39         mov c, b ; And place it into C
0644   07FC 2A            mov b, [d] ; Lower Word in B
0645   07FD             ; --- START FACTORS
0646   07FD D7            push a
0647   07FE FD D8         push g
0648   0800 11            mov a, b
0649   0801 FD 7A         mov g, c
0650   0803 FD 2E 0A 00   mov32 cb, $0000000a
0650   0807 00 00 
0651   0809 FD D8         push g ; save 'g' as the div instruction uses it
0652   080B AE            div a, b ; %, a: quotient, b: remainder
0653   080C 11            mov a, b
0654   080D FD F1         pop g
0655   080F FD 38         mov c, g
0656   0811 27            mov b, a
0657   0812 FD F1         pop g
0658   0814 E4            pop a
0659   0815             ; --- END FACTORS
0660   0815 FD 22 00 00   mov g, 0
0661   0819 FD 15         add32 cb, ga
0662   081B E4            pop a
0663   081C             ; --- END TERMS
0664   081C E7            pop d
0665   081D FD 3E         mov [d], bl
0666   081F             ; num = num / 10; 
0667   081F FA 05 00      lea d, [bp + 5] ; $num
0668   0822 DA            push d
0669   0823 FA 05 00      lea d, [bp + 5] ; $num
0670   0826 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0671   0829 FD 39         mov c, b ; And place it into C
0672   082B 2A            mov b, [d] ; Lower Word in B
0673   082C             ; --- START FACTORS
0674   082C D7            push a
0675   082D FD D8         push g
0676   082F 11            mov a, b
0677   0830 FD 7A         mov g, c
0678   0832 FD 2E 0A 00   mov32 cb, $0000000a
0678   0836 00 00 
0679   0838 FD D8         push g ; save 'g' as the div instruction uses it
0680   083A AE            div a, b ; /, a: quotient, b: remainder
0681   083B FD F1         pop g
0682   083D FD 38         mov c, g
0683   083F 27            mov b, a
0684   0840 FD F1         pop g
0685   0842 E4            pop a
0686   0843             ; --- END FACTORS
0687   0843 E7            pop d
0688   0844 FD 43         mov [d], b
0689   0846 28            mov b, c
0690   0847 FD 44 02 00   mov [d + 2], b
0691   084B             ; i++; 
0692   084B FA F5 FF      lea d, [bp + -11] ; $i
0693   084E 2A            mov b, [d]
0694   084F 38 00 00      mov c, 0
0695   0852 11            mov a, b
0696   0853 FD 77         inc b
0697   0855 FA F5 FF      lea d, [bp + -11] ; $i
0698   0858 FD 43         mov [d], b
0699   085A 27            mov b, a
0700   085B 0A B7 07      jmp _while10_cond
0701   085E             _while10_exit:
0702   085E             ; while (i > 0) { 
0703   085E             _while17_cond:
0704   085E FA F5 FF      lea d, [bp + -11] ; $i
0705   0861 2A            mov b, [d]
0706   0862 38 00 00      mov c, 0
0707   0865             ; --- START RELATIONAL
0708   0865 D7            push a
0709   0866 11            mov a, b
0710   0867 FD 2E 00 00   mov32 cb, $00000000
0710   086B 00 00 
0711   086D B0            cmp a, b
0712   086E FD 7F         sgt ; >
0713   0870 E4            pop a
0714   0871             ; --- END RELATIONAL
0715   0871 C0 00 00      cmp b, 0
0716   0874 C6 A6 08      je _while17_exit
0717   0877             _while17_block:
0718   0877             ; i--; 
0719   0877 FA F5 FF      lea d, [bp + -11] ; $i
0720   087A 2A            mov b, [d]
0721   087B 38 00 00      mov c, 0
0722   087E 11            mov a, b
0723   087F FD 7D         dec b
0724   0881 FA F5 FF      lea d, [bp + -11] ; $i
0725   0884 FD 43         mov [d], b
0726   0886 27            mov b, a
0727   0887             ; putchar(digits[i]); 
0728   0887             ; --- START FUNCTION CALL
0729   0887 FA F7 FF      lea d, [bp + -9] ; $digits
0730   088A D7            push a
0731   088B DA            push d
0732   088C FA F5 FF      lea d, [bp + -11] ; $i
0733   088F 2A            mov b, [d]
0734   0890 38 00 00      mov c, 0
0735   0893 E7            pop d
0736   0894 5A            add d, b
0737   0895 E4            pop a
0738   0896 32            mov bl, [d]
0739   0897 A7 00         mov bh, 0
0740   0899 38 00 00      mov c, 0
0741   089C DD            push bl
0742   089D 07 A8 08      call putchar
0743   08A0 51 01 00      add sp, 1
0744   08A3             ; --- END FUNCTION CALL
0745   08A3 0A 5E 08      jmp _while17_cond
0746   08A6             _while17_exit:
0747   08A6 F9            leave
0748   08A7 09            ret
0749   08A8             
0750   08A8             putchar:
0751   08A8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0752   08AB             ; --- BEGIN INLINE ASM SEGMENT
0753   08AB FA 05 00      lea d, [bp + 5] ; $c
0754   08AE 1E            mov al, [d]
0755   08AF 23            mov ah, al
0756   08B0 19 00         mov al, 0
0757   08B2 05 03         syscall sys_io      ; char in AH
0758   08B4             ; --- END INLINE ASM SEGMENT
0759   08B4 F9            leave
0760   08B5 09            ret
0761   08B6             
0762   08B6             print_unsigned_long:
0763   08B6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0764   08B9             ; char digits[10]; 
0765   08B9 52 0A 00      sub sp, 10
0766   08BC             ; int i; 
0767   08BC 52 02 00      sub sp, 2
0768   08BF             ; i = 0; 
0769   08BF FA F5 FF      lea d, [bp + -11] ; $i
0770   08C2 DA            push d
0771   08C3 FD 2E 00 00   mov32 cb, $00000000
0771   08C7 00 00 
0772   08C9 E7            pop d
0773   08CA FD 43         mov [d], b
0774   08CC             ; if(num == 0){ 
0775   08CC             _if18_cond:
0776   08CC FA 05 00      lea d, [bp + 5] ; $num
0777   08CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0778   08D2 FD 39         mov c, b ; And place it into C
0779   08D4 2A            mov b, [d] ; Lower Word in B
0780   08D5             ; --- START RELATIONAL
0781   08D5 D7            push a
0782   08D6 FD D8         push g
0783   08D8 11            mov a, b
0784   08D9 FD 7A         mov g, c
0785   08DB FD 2E 00 00   mov32 cb, $00000000
0785   08DF 00 00 
0786   08E1 38 00 00      mov c, 0
0787   08E4 FD AF         cmp32 ga, cb
0788   08E6 FD 71         seq ; ==
0789   08E8 FD F1         pop g
0790   08EA E4            pop a
0791   08EB             ; --- END RELATIONAL
0792   08EB C0 00 00      cmp b, 0
0793   08EE C6 03 09      je _if18_exit
0794   08F1             _if18_TRUE:
0795   08F1             ; putchar('0'); 
0796   08F1             ; --- START FUNCTION CALL
0797   08F1 FD 2E 30 00   mov32 cb, $00000030
0797   08F5 00 00 
0798   08F7 DD            push bl
0799   08F8 07 A8 08      call putchar
0800   08FB 51 01 00      add sp, 1
0801   08FE             ; --- END FUNCTION CALL
0802   08FE             ; return; 
0803   08FE F9            leave
0804   08FF 09            ret
0805   0900 0A 03 09      jmp _if18_exit
0806   0903             _if18_exit:
0807   0903             ; while (num > 0) { 
0808   0903             _while19_cond:
0809   0903 FA 05 00      lea d, [bp + 5] ; $num
0810   0906 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0811   0909 FD 39         mov c, b ; And place it into C
0812   090B 2A            mov b, [d] ; Lower Word in B
0813   090C             ; --- START RELATIONAL
0814   090C D7            push a
0815   090D FD D8         push g
0816   090F 11            mov a, b
0817   0910 FD 7A         mov g, c
0818   0912 FD 2E 00 00   mov32 cb, $00000000
0818   0916 00 00 
0819   0918 38 00 00      mov c, 0
0820   091B FD AF         cmp32 ga, cb
0821   091D FD 81         sgu
0822   091F FD F1         pop g
0823   0921 E4            pop a
0824   0922             ; --- END RELATIONAL
0825   0922 C0 00 00      cmp b, 0
0826   0925 C6 AA 09      je _while19_exit
0827   0928             _while19_block:
0828   0928             ; digits[i] = '0' + (num % 10); 
0829   0928 FA F7 FF      lea d, [bp + -9] ; $digits
0830   092B D7            push a
0831   092C DA            push d
0832   092D FA F5 FF      lea d, [bp + -11] ; $i
0833   0930 2A            mov b, [d]
0834   0931 38 00 00      mov c, 0
0835   0934 E7            pop d
0836   0935 5A            add d, b
0837   0936 E4            pop a
0838   0937 DA            push d
0839   0938 FD 2E 30 00   mov32 cb, $00000030
0839   093C 00 00 
0840   093E             ; --- START TERMS
0841   093E D7            push a
0842   093F 11            mov a, b
0843   0940 FA 05 00      lea d, [bp + 5] ; $num
0844   0943 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0845   0946 FD 39         mov c, b ; And place it into C
0846   0948 2A            mov b, [d] ; Lower Word in B
0847   0949             ; --- START FACTORS
0848   0949 D7            push a
0849   094A FD D8         push g
0850   094C 11            mov a, b
0851   094D FD 7A         mov g, c
0852   094F FD 2E 0A 00   mov32 cb, $0000000a
0852   0953 00 00 
0853   0955 FD D8         push g ; save 'g' as the div instruction uses it
0854   0957 AE            div a, b ; %, a: quotient, b: remainder
0855   0958 11            mov a, b
0856   0959 FD F1         pop g
0857   095B FD 38         mov c, g
0858   095D 27            mov b, a
0859   095E FD F1         pop g
0860   0960 E4            pop a
0861   0961             ; --- END FACTORS
0862   0961 FD 22 00 00   mov g, 0
0863   0965 FD 15         add32 cb, ga
0864   0967 E4            pop a
0865   0968             ; --- END TERMS
0866   0968 E7            pop d
0867   0969 FD 3E         mov [d], bl
0868   096B             ; num = num / 10; 
0869   096B FA 05 00      lea d, [bp + 5] ; $num
0870   096E DA            push d
0871   096F FA 05 00      lea d, [bp + 5] ; $num
0872   0972 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0873   0975 FD 39         mov c, b ; And place it into C
0874   0977 2A            mov b, [d] ; Lower Word in B
0875   0978             ; --- START FACTORS
0876   0978 D7            push a
0877   0979 FD D8         push g
0878   097B 11            mov a, b
0879   097C FD 7A         mov g, c
0880   097E FD 2E 0A 00   mov32 cb, $0000000a
0880   0982 00 00 
0881   0984 FD D8         push g ; save 'g' as the div instruction uses it
0882   0986 AE            div a, b ; /, a: quotient, b: remainder
0883   0987 FD F1         pop g
0884   0989 FD 38         mov c, g
0885   098B 27            mov b, a
0886   098C FD F1         pop g
0887   098E E4            pop a
0888   098F             ; --- END FACTORS
0889   098F E7            pop d
0890   0990 FD 43         mov [d], b
0891   0992 28            mov b, c
0892   0993 FD 44 02 00   mov [d + 2], b
0893   0997             ; i++; 
0894   0997 FA F5 FF      lea d, [bp + -11] ; $i
0895   099A 2A            mov b, [d]
0896   099B 38 00 00      mov c, 0
0897   099E 11            mov a, b
0898   099F FD 77         inc b
0899   09A1 FA F5 FF      lea d, [bp + -11] ; $i
0900   09A4 FD 43         mov [d], b
0901   09A6 27            mov b, a
0902   09A7 0A 03 09      jmp _while19_cond
0903   09AA             _while19_exit:
0904   09AA             ; while (i > 0) { 
0905   09AA             _while26_cond:
0906   09AA FA F5 FF      lea d, [bp + -11] ; $i
0907   09AD 2A            mov b, [d]
0908   09AE 38 00 00      mov c, 0
0909   09B1             ; --- START RELATIONAL
0910   09B1 D7            push a
0911   09B2 11            mov a, b
0912   09B3 FD 2E 00 00   mov32 cb, $00000000
0912   09B7 00 00 
0913   09B9 B0            cmp a, b
0914   09BA FD 7F         sgt ; >
0915   09BC E4            pop a
0916   09BD             ; --- END RELATIONAL
0917   09BD C0 00 00      cmp b, 0
0918   09C0 C6 F2 09      je _while26_exit
0919   09C3             _while26_block:
0920   09C3             ; i--; 
0921   09C3 FA F5 FF      lea d, [bp + -11] ; $i
0922   09C6 2A            mov b, [d]
0923   09C7 38 00 00      mov c, 0
0924   09CA 11            mov a, b
0925   09CB FD 7D         dec b
0926   09CD FA F5 FF      lea d, [bp + -11] ; $i
0927   09D0 FD 43         mov [d], b
0928   09D2 27            mov b, a
0929   09D3             ; putchar(digits[i]); 
0930   09D3             ; --- START FUNCTION CALL
0931   09D3 FA F7 FF      lea d, [bp + -9] ; $digits
0932   09D6 D7            push a
0933   09D7 DA            push d
0934   09D8 FA F5 FF      lea d, [bp + -11] ; $i
0935   09DB 2A            mov b, [d]
0936   09DC 38 00 00      mov c, 0
0937   09DF E7            pop d
0938   09E0 5A            add d, b
0939   09E1 E4            pop a
0940   09E2 32            mov bl, [d]
0941   09E3 A7 00         mov bh, 0
0942   09E5 38 00 00      mov c, 0
0943   09E8 DD            push bl
0944   09E9 07 A8 08      call putchar
0945   09EC 51 01 00      add sp, 1
0946   09EF             ; --- END FUNCTION CALL
0947   09EF 0A AA 09      jmp _while26_cond
0948   09F2             _while26_exit:
0949   09F2 F9            leave
0950   09F3 09            ret
0951   09F4             
0952   09F4             printx32:
0953   09F4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0954   09F7             ; --- BEGIN INLINE ASM SEGMENT
0955   09F7 FA 05 00      lea d, [bp + 5] ; $hex
0956   09FA 2B 02 00      mov b, [d+2]
0957   09FD 07 06 0A      call print_u16x_printx32
0958   0A00 2A            mov b, [d]
0959   0A01 07 06 0A      call print_u16x_printx32
0960   0A04             ; --- END INLINE ASM SEGMENT
0961   0A04             ; return; 
0962   0A04 F9            leave
0963   0A05 09            ret
0964   0A06             ; --- BEGIN INLINE ASM SEGMENT
0965   0A06             print_u16x_printx32:
0966   0A06 D7            push a
0967   0A07 D8            push b
0968   0A08 DD            push bl
0969   0A09 30            mov bl, bh
0970   0A0A 07 28 0A      call _itoa_printx32        ; convert bh to char in A
0971   0A0D 2F            mov bl, al        ; save al
0972   0A0E 19 00         mov al, 0
0973   0A10 05 03         syscall sys_io        ; display AH
0974   0A12 24            mov ah, bl        ; retrieve al
0975   0A13 19 00         mov al, 0
0976   0A15 05 03         syscall sys_io        ; display AL
0977   0A17 EA            pop bl
0978   0A18 07 28 0A      call _itoa_printx32        ; convert bh to char in A
0979   0A1B 2F            mov bl, al        ; save al
0980   0A1C 19 00         mov al, 0
0981   0A1E 05 03         syscall sys_io        ; display AH
0982   0A20 24            mov ah, bl        ; retrieve al
0983   0A21 19 00         mov al, 0
0984   0A23 05 03         syscall sys_io        ; display AL
0985   0A25 E5            pop b
0986   0A26 E4            pop a
0987   0A27 09            ret
0988   0A28             _itoa_printx32:
0989   0A28 DA            push d
0990   0A29 D8            push b
0991   0A2A A7 00         mov bh, 0
0992   0A2C FD A4 04      shr bl, 4  
0993   0A2F 74            mov d, b
0994   0A30 1F 42 0A      mov al, [d + s_hex_digits_printx32]
0995   0A33 23            mov ah, al
0996   0A34 E5            pop b
0997   0A35 D8            push b
0998   0A36 A7 00         mov bh, 0
0999   0A38 FD 87 0F      and bl, $0F
1000   0A3B 74            mov d, b
1001   0A3C 1F 42 0A      mov al, [d + s_hex_digits_printx32]
1002   0A3F E5            pop b
1003   0A40 E7            pop d
1004   0A41 09            ret
1005   0A42 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1005   0A46 34 35 36 37 
1005   0A4A 38 39 41 42 
1005   0A4E 43 44 45 46 
1006   0A52             ; --- END INLINE ASM SEGMENT
1007   0A52 F9            leave
1008   0A53 09            ret
1009   0A54             
1010   0A54             err:
1011   0A54 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1012   0A57             ; print(e); 
1013   0A57             ; --- START FUNCTION CALL
1014   0A57 FA 05 00      lea d, [bp + 5] ; $e
1015   0A5A 2A            mov b, [d]
1016   0A5B 38 00 00      mov c, 0
1017   0A5E FD AB         swp b
1018   0A60 D8            push b
1019   0A61 07 69 0A      call print
1020   0A64 51 02 00      add sp, 2
1021   0A67             ; --- END FUNCTION CALL
1022   0A67 F9            leave
1023   0A68 09            ret
1024   0A69             
1025   0A69             print:
1026   0A69 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1027   0A6C             ; --- BEGIN INLINE ASM SEGMENT
1028   0A6C FA 05 00      lea d, [bp + 5] ; $s
1029   0A6F FD 2A         mov d, [d]
1030   0A71             _puts_L1_print:
1031   0A71 1E            mov al, [d]
1032   0A72 B9 00         cmp al, 0
1033   0A74 C6 80 0A      jz _puts_END_print
1034   0A77 23            mov ah, al
1035   0A78 19 00         mov al, 0
1036   0A7A 05 03         syscall sys_io
1037   0A7C 79            inc d
1038   0A7D 0A 71 0A      jmp _puts_L1_print
1039   0A80             _puts_END_print:
1040   0A80             ; --- END INLINE ASM SEGMENT
1041   0A80 F9            leave
1042   0A81 09            ret
1043   0A82             
1044   0A82             print_signed:
1045   0A82 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1046   0A85             ; char digits[5]; 
1047   0A85 52 05 00      sub sp, 5
1048   0A88             ; int i = 0; 
1049   0A88 52 02 00      sub sp, 2
1050   0A8B             ; --- START LOCAL VAR INITIALIZATION
1051   0A8B FA FA FF      lea d, [bp + -6] ; $i
1052   0A8E DA            push d
1053   0A8F FD 2E 00 00   mov32 cb, $00000000
1053   0A93 00 00 
1054   0A95 E7            pop d
1055   0A96 FD 43         mov [d], b
1056   0A98             ; --- END LOCAL VAR INITIALIZATION
1057   0A98             ; if (num < 0) { 
1058   0A98             _if27_cond:
1059   0A98 FA 05 00      lea d, [bp + 5] ; $num
1060   0A9B 2A            mov b, [d]
1061   0A9C 38 00 00      mov c, 0
1062   0A9F             ; --- START RELATIONAL
1063   0A9F D7            push a
1064   0AA0 11            mov a, b
1065   0AA1 FD 2E 00 00   mov32 cb, $00000000
1065   0AA5 00 00 
1066   0AA7 B0            cmp a, b
1067   0AA8 FD 73         slt ; < (signed)
1068   0AAA E4            pop a
1069   0AAB             ; --- END RELATIONAL
1070   0AAB C0 00 00      cmp b, 0
1071   0AAE C6 D1 0A      je _if27_else
1072   0AB1             _if27_TRUE:
1073   0AB1             ; putchar('-'); 
1074   0AB1             ; --- START FUNCTION CALL
1075   0AB1 FD 2E 2D 00   mov32 cb, $0000002d
1075   0AB5 00 00 
1076   0AB7 DD            push bl
1077   0AB8 07 A8 08      call putchar
1078   0ABB 51 01 00      add sp, 1
1079   0ABE             ; --- END FUNCTION CALL
1080   0ABE             ; num = -num; 
1081   0ABE FA 05 00      lea d, [bp + 5] ; $num
1082   0AC1 DA            push d
1083   0AC2 FA 05 00      lea d, [bp + 5] ; $num
1084   0AC5 2A            mov b, [d]
1085   0AC6 38 00 00      mov c, 0
1086   0AC9 FD 97         neg b
1087   0ACB E7            pop d
1088   0ACC FD 43         mov [d], b
1089   0ACE 0A FC 0A      jmp _if27_exit
1090   0AD1             _if27_else:
1091   0AD1             ; if (num == 0) { 
1092   0AD1             _if28_cond:
1093   0AD1 FA 05 00      lea d, [bp + 5] ; $num
1094   0AD4 2A            mov b, [d]
1095   0AD5 38 00 00      mov c, 0
1096   0AD8             ; --- START RELATIONAL
1097   0AD8 D7            push a
1098   0AD9 11            mov a, b
1099   0ADA FD 2E 00 00   mov32 cb, $00000000
1099   0ADE 00 00 
1100   0AE0 B0            cmp a, b
1101   0AE1 FD 71         seq ; ==
1102   0AE3 E4            pop a
1103   0AE4             ; --- END RELATIONAL
1104   0AE4 C0 00 00      cmp b, 0
1105   0AE7 C6 FC 0A      je _if28_exit
1106   0AEA             _if28_TRUE:
1107   0AEA             ; putchar('0'); 
1108   0AEA             ; --- START FUNCTION CALL
1109   0AEA FD 2E 30 00   mov32 cb, $00000030
1109   0AEE 00 00 
1110   0AF0 DD            push bl
1111   0AF1 07 A8 08      call putchar
1112   0AF4 51 01 00      add sp, 1
1113   0AF7             ; --- END FUNCTION CALL
1114   0AF7             ; return; 
1115   0AF7 F9            leave
1116   0AF8 09            ret
1117   0AF9 0A FC 0A      jmp _if28_exit
1118   0AFC             _if28_exit:
1119   0AFC             _if27_exit:
1120   0AFC             ; while (num > 0) { 
1121   0AFC             _while29_cond:
1122   0AFC FA 05 00      lea d, [bp + 5] ; $num
1123   0AFF 2A            mov b, [d]
1124   0B00 38 00 00      mov c, 0
1125   0B03             ; --- START RELATIONAL
1126   0B03 D7            push a
1127   0B04 11            mov a, b
1128   0B05 FD 2E 00 00   mov32 cb, $00000000
1128   0B09 00 00 
1129   0B0B B0            cmp a, b
1130   0B0C FD 7F         sgt ; >
1131   0B0E E4            pop a
1132   0B0F             ; --- END RELATIONAL
1133   0B0F C0 00 00      cmp b, 0
1134   0B12 C6 89 0B      je _while29_exit
1135   0B15             _while29_block:
1136   0B15             ; digits[i] = '0' + (num % 10); 
1137   0B15 FA FC FF      lea d, [bp + -4] ; $digits
1138   0B18 D7            push a
1139   0B19 DA            push d
1140   0B1A FA FA FF      lea d, [bp + -6] ; $i
1141   0B1D 2A            mov b, [d]
1142   0B1E 38 00 00      mov c, 0
1143   0B21 E7            pop d
1144   0B22 5A            add d, b
1145   0B23 E4            pop a
1146   0B24 DA            push d
1147   0B25 FD 2E 30 00   mov32 cb, $00000030
1147   0B29 00 00 
1148   0B2B             ; --- START TERMS
1149   0B2B D7            push a
1150   0B2C 11            mov a, b
1151   0B2D FA 05 00      lea d, [bp + 5] ; $num
1152   0B30 2A            mov b, [d]
1153   0B31 38 00 00      mov c, 0
1154   0B34             ; --- START FACTORS
1155   0B34 D7            push a
1156   0B35 FD D8         push g
1157   0B37 11            mov a, b
1158   0B38 FD 7A         mov g, c
1159   0B3A FD 2E 0A 00   mov32 cb, $0000000a
1159   0B3E 00 00 
1160   0B40 FD D8         push g ; save 'g' as the div instruction uses it
1161   0B42 AE            div a, b ; %, a: quotient, b: remainder
1162   0B43 11            mov a, b
1163   0B44 FD F1         pop g
1164   0B46 FD 38         mov c, g
1165   0B48 27            mov b, a
1166   0B49 FD F1         pop g
1167   0B4B E4            pop a
1168   0B4C             ; --- END FACTORS
1169   0B4C 56            add b, a
1170   0B4D E4            pop a
1171   0B4E             ; --- END TERMS
1172   0B4E E7            pop d
1173   0B4F FD 3E         mov [d], bl
1174   0B51             ; num = num / 10; 
1175   0B51 FA 05 00      lea d, [bp + 5] ; $num
1176   0B54 DA            push d
1177   0B55 FA 05 00      lea d, [bp + 5] ; $num
1178   0B58 2A            mov b, [d]
1179   0B59 38 00 00      mov c, 0
1180   0B5C             ; --- START FACTORS
1181   0B5C D7            push a
1182   0B5D FD D8         push g
1183   0B5F 11            mov a, b
1184   0B60 FD 7A         mov g, c
1185   0B62 FD 2E 0A 00   mov32 cb, $0000000a
1185   0B66 00 00 
1186   0B68 FD D8         push g ; save 'g' as the div instruction uses it
1187   0B6A AE            div a, b ; /, a: quotient, b: remainder
1188   0B6B FD F1         pop g
1189   0B6D FD 38         mov c, g
1190   0B6F 27            mov b, a
1191   0B70 FD F1         pop g
1192   0B72 E4            pop a
1193   0B73             ; --- END FACTORS
1194   0B73 E7            pop d
1195   0B74 FD 43         mov [d], b
1196   0B76             ; i++; 
1197   0B76 FA FA FF      lea d, [bp + -6] ; $i
1198   0B79 2A            mov b, [d]
1199   0B7A 38 00 00      mov c, 0
1200   0B7D 11            mov a, b
1201   0B7E FD 77         inc b
1202   0B80 FA FA FF      lea d, [bp + -6] ; $i
1203   0B83 FD 43         mov [d], b
1204   0B85 27            mov b, a
1205   0B86 0A FC 0A      jmp _while29_cond
1206   0B89             _while29_exit:
1207   0B89             ; while (i > 0) { 
1208   0B89             _while36_cond:
1209   0B89 FA FA FF      lea d, [bp + -6] ; $i
1210   0B8C 2A            mov b, [d]
1211   0B8D 38 00 00      mov c, 0
1212   0B90             ; --- START RELATIONAL
1213   0B90 D7            push a
1214   0B91 11            mov a, b
1215   0B92 FD 2E 00 00   mov32 cb, $00000000
1215   0B96 00 00 
1216   0B98 B0            cmp a, b
1217   0B99 FD 7F         sgt ; >
1218   0B9B E4            pop a
1219   0B9C             ; --- END RELATIONAL
1220   0B9C C0 00 00      cmp b, 0
1221   0B9F C6 D1 0B      je _while36_exit
1222   0BA2             _while36_block:
1223   0BA2             ; i--; 
1224   0BA2 FA FA FF      lea d, [bp + -6] ; $i
1225   0BA5 2A            mov b, [d]
1226   0BA6 38 00 00      mov c, 0
1227   0BA9 11            mov a, b
1228   0BAA FD 7D         dec b
1229   0BAC FA FA FF      lea d, [bp + -6] ; $i
1230   0BAF FD 43         mov [d], b
1231   0BB1 27            mov b, a
1232   0BB2             ; putchar(digits[i]); 
1233   0BB2             ; --- START FUNCTION CALL
1234   0BB2 FA FC FF      lea d, [bp + -4] ; $digits
1235   0BB5 D7            push a
1236   0BB6 DA            push d
1237   0BB7 FA FA FF      lea d, [bp + -6] ; $i
1238   0BBA 2A            mov b, [d]
1239   0BBB 38 00 00      mov c, 0
1240   0BBE E7            pop d
1241   0BBF 5A            add d, b
1242   0BC0 E4            pop a
1243   0BC1 32            mov bl, [d]
1244   0BC2 A7 00         mov bh, 0
1245   0BC4 38 00 00      mov c, 0
1246   0BC7 DD            push bl
1247   0BC8 07 A8 08      call putchar
1248   0BCB 51 01 00      add sp, 1
1249   0BCE             ; --- END FUNCTION CALL
1250   0BCE 0A 89 0B      jmp _while36_cond
1251   0BD1             _while36_exit:
1252   0BD1 F9            leave
1253   0BD2 09            ret
1254   0BD3             
1255   0BD3             print_unsigned:
1256   0BD3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1257   0BD6             ; char digits[5]; 
1258   0BD6 52 05 00      sub sp, 5
1259   0BD9             ; int i; 
1260   0BD9 52 02 00      sub sp, 2
1261   0BDC             ; i = 0; 
1262   0BDC FA FA FF      lea d, [bp + -6] ; $i
1263   0BDF DA            push d
1264   0BE0 FD 2E 00 00   mov32 cb, $00000000
1264   0BE4 00 00 
1265   0BE6 E7            pop d
1266   0BE7 FD 43         mov [d], b
1267   0BE9             ; if(num == 0){ 
1268   0BE9             _if37_cond:
1269   0BE9 FA 05 00      lea d, [bp + 5] ; $num
1270   0BEC 2A            mov b, [d]
1271   0BED 38 00 00      mov c, 0
1272   0BF0             ; --- START RELATIONAL
1273   0BF0 D7            push a
1274   0BF1 11            mov a, b
1275   0BF2 FD 2E 00 00   mov32 cb, $00000000
1275   0BF6 00 00 
1276   0BF8 B0            cmp a, b
1277   0BF9 FD 71         seq ; ==
1278   0BFB E4            pop a
1279   0BFC             ; --- END RELATIONAL
1280   0BFC C0 00 00      cmp b, 0
1281   0BFF C6 14 0C      je _if37_exit
1282   0C02             _if37_TRUE:
1283   0C02             ; putchar('0'); 
1284   0C02             ; --- START FUNCTION CALL
1285   0C02 FD 2E 30 00   mov32 cb, $00000030
1285   0C06 00 00 
1286   0C08 DD            push bl
1287   0C09 07 A8 08      call putchar
1288   0C0C 51 01 00      add sp, 1
1289   0C0F             ; --- END FUNCTION CALL
1290   0C0F             ; return; 
1291   0C0F F9            leave
1292   0C10 09            ret
1293   0C11 0A 14 0C      jmp _if37_exit
1294   0C14             _if37_exit:
1295   0C14             ; while (num > 0) { 
1296   0C14             _while38_cond:
1297   0C14 FA 05 00      lea d, [bp + 5] ; $num
1298   0C17 2A            mov b, [d]
1299   0C18 38 00 00      mov c, 0
1300   0C1B             ; --- START RELATIONAL
1301   0C1B D7            push a
1302   0C1C 11            mov a, b
1303   0C1D FD 2E 00 00   mov32 cb, $00000000
1303   0C21 00 00 
1304   0C23 B0            cmp a, b
1305   0C24 FD 81         sgu ; > (unsigned)
1306   0C26 E4            pop a
1307   0C27             ; --- END RELATIONAL
1308   0C27 C0 00 00      cmp b, 0
1309   0C2A C6 A1 0C      je _while38_exit
1310   0C2D             _while38_block:
1311   0C2D             ; digits[i] = '0' + (num % 10); 
1312   0C2D FA FC FF      lea d, [bp + -4] ; $digits
1313   0C30 D7            push a
1314   0C31 DA            push d
1315   0C32 FA FA FF      lea d, [bp + -6] ; $i
1316   0C35 2A            mov b, [d]
1317   0C36 38 00 00      mov c, 0
1318   0C39 E7            pop d
1319   0C3A 5A            add d, b
1320   0C3B E4            pop a
1321   0C3C DA            push d
1322   0C3D FD 2E 30 00   mov32 cb, $00000030
1322   0C41 00 00 
1323   0C43             ; --- START TERMS
1324   0C43 D7            push a
1325   0C44 11            mov a, b
1326   0C45 FA 05 00      lea d, [bp + 5] ; $num
1327   0C48 2A            mov b, [d]
1328   0C49 38 00 00      mov c, 0
1329   0C4C             ; --- START FACTORS
1330   0C4C D7            push a
1331   0C4D FD D8         push g
1332   0C4F 11            mov a, b
1333   0C50 FD 7A         mov g, c
1334   0C52 FD 2E 0A 00   mov32 cb, $0000000a
1334   0C56 00 00 
1335   0C58 FD D8         push g ; save 'g' as the div instruction uses it
1336   0C5A AE            div a, b ; %, a: quotient, b: remainder
1337   0C5B 11            mov a, b
1338   0C5C FD F1         pop g
1339   0C5E FD 38         mov c, g
1340   0C60 27            mov b, a
1341   0C61 FD F1         pop g
1342   0C63 E4            pop a
1343   0C64             ; --- END FACTORS
1344   0C64 56            add b, a
1345   0C65 E4            pop a
1346   0C66             ; --- END TERMS
1347   0C66 E7            pop d
1348   0C67 FD 3E         mov [d], bl
1349   0C69             ; num = num / 10; 
1350   0C69 FA 05 00      lea d, [bp + 5] ; $num
1351   0C6C DA            push d
1352   0C6D FA 05 00      lea d, [bp + 5] ; $num
1353   0C70 2A            mov b, [d]
1354   0C71 38 00 00      mov c, 0
1355   0C74             ; --- START FACTORS
1356   0C74 D7            push a
1357   0C75 FD D8         push g
1358   0C77 11            mov a, b
1359   0C78 FD 7A         mov g, c
1360   0C7A FD 2E 0A 00   mov32 cb, $0000000a
1360   0C7E 00 00 
1361   0C80 FD D8         push g ; save 'g' as the div instruction uses it
1362   0C82 AE            div a, b ; /, a: quotient, b: remainder
1363   0C83 FD F1         pop g
1364   0C85 FD 38         mov c, g
1365   0C87 27            mov b, a
1366   0C88 FD F1         pop g
1367   0C8A E4            pop a
1368   0C8B             ; --- END FACTORS
1369   0C8B E7            pop d
1370   0C8C FD 43         mov [d], b
1371   0C8E             ; i++; 
1372   0C8E FA FA FF      lea d, [bp + -6] ; $i
1373   0C91 2A            mov b, [d]
1374   0C92 38 00 00      mov c, 0
1375   0C95 11            mov a, b
1376   0C96 FD 77         inc b
1377   0C98 FA FA FF      lea d, [bp + -6] ; $i
1378   0C9B FD 43         mov [d], b
1379   0C9D 27            mov b, a
1380   0C9E 0A 14 0C      jmp _while38_cond
1381   0CA1             _while38_exit:
1382   0CA1             ; while (i > 0) { 
1383   0CA1             _while45_cond:
1384   0CA1 FA FA FF      lea d, [bp + -6] ; $i
1385   0CA4 2A            mov b, [d]
1386   0CA5 38 00 00      mov c, 0
1387   0CA8             ; --- START RELATIONAL
1388   0CA8 D7            push a
1389   0CA9 11            mov a, b
1390   0CAA FD 2E 00 00   mov32 cb, $00000000
1390   0CAE 00 00 
1391   0CB0 B0            cmp a, b
1392   0CB1 FD 7F         sgt ; >
1393   0CB3 E4            pop a
1394   0CB4             ; --- END RELATIONAL
1395   0CB4 C0 00 00      cmp b, 0
1396   0CB7 C6 E9 0C      je _while45_exit
1397   0CBA             _while45_block:
1398   0CBA             ; i--; 
1399   0CBA FA FA FF      lea d, [bp + -6] ; $i
1400   0CBD 2A            mov b, [d]
1401   0CBE 38 00 00      mov c, 0
1402   0CC1 11            mov a, b
1403   0CC2 FD 7D         dec b
1404   0CC4 FA FA FF      lea d, [bp + -6] ; $i
1405   0CC7 FD 43         mov [d], b
1406   0CC9 27            mov b, a
1407   0CCA             ; putchar(digits[i]); 
1408   0CCA             ; --- START FUNCTION CALL
1409   0CCA FA FC FF      lea d, [bp + -4] ; $digits
1410   0CCD D7            push a
1411   0CCE DA            push d
1412   0CCF FA FA FF      lea d, [bp + -6] ; $i
1413   0CD2 2A            mov b, [d]
1414   0CD3 38 00 00      mov c, 0
1415   0CD6 E7            pop d
1416   0CD7 5A            add d, b
1417   0CD8 E4            pop a
1418   0CD9 32            mov bl, [d]
1419   0CDA A7 00         mov bh, 0
1420   0CDC 38 00 00      mov c, 0
1421   0CDF DD            push bl
1422   0CE0 07 A8 08      call putchar
1423   0CE3 51 01 00      add sp, 1
1424   0CE6             ; --- END FUNCTION CALL
1425   0CE6 0A A1 0C      jmp _while45_cond
1426   0CE9             _while45_exit:
1427   0CE9 F9            leave
1428   0CEA 09            ret
1429   0CEB             
1430   0CEB             printx16:
1431   0CEB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1432   0CEE             ; --- BEGIN INLINE ASM SEGMENT
1433   0CEE FA 05 00      lea d, [bp + 5] ; $hex
1434   0CF1 2A            mov b, [d]
1435   0CF2             print_u16x_printx16:
1436   0CF2 DD            push bl
1437   0CF3 30            mov bl, bh
1438   0CF4 07 11 0D      call _itoa_printx16        ; convert bh to char in A
1439   0CF7 2F            mov bl, al        ; save al
1440   0CF8 19 00         mov al, 0
1441   0CFA 05 03         syscall sys_io        ; display AH
1442   0CFC 24            mov ah, bl        ; retrieve al
1443   0CFD 19 00         mov al, 0
1444   0CFF 05 03         syscall sys_io        ; display AL
1445   0D01 EA            pop bl
1446   0D02 07 11 0D      call _itoa_printx16        ; convert bh to char in A
1447   0D05 2F            mov bl, al        ; save al
1448   0D06 19 00         mov al, 0
1449   0D08 05 03         syscall sys_io        ; display AH
1450   0D0A 24            mov ah, bl        ; retrieve al
1451   0D0B 19 00         mov al, 0
1452   0D0D 05 03         syscall sys_io        ; display AL
1453   0D0F             ; --- END INLINE ASM SEGMENT
1454   0D0F             ; return; 
1455   0D0F F9            leave
1456   0D10 09            ret
1457   0D11             ; --- BEGIN INLINE ASM SEGMENT
1458   0D11             _itoa_printx16:
1459   0D11 DA            push d
1460   0D12 D8            push b
1461   0D13 A7 00         mov bh, 0
1462   0D15 FD A4 04      shr bl, 4  
1463   0D18 74            mov d, b
1464   0D19 1F 2B 0D      mov al, [d + s_hex_digits_printx16]
1465   0D1C 23            mov ah, al
1466   0D1D E5            pop b
1467   0D1E D8            push b
1468   0D1F A7 00         mov bh, 0
1469   0D21 FD 87 0F      and bl, $0F
1470   0D24 74            mov d, b
1471   0D25 1F 2B 0D      mov al, [d + s_hex_digits_printx16]
1472   0D28 E5            pop b
1473   0D29 E7            pop d
1474   0D2A 09            ret
1475   0D2B 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1475   0D2F 34 35 36 37 
1475   0D33 38 39 41 42 
1475   0D37 43 44 45 46 
1476   0D3B             ; --- END INLINE ASM SEGMENT
1477   0D3B F9            leave
1478   0D3C 09            ret
1479   0D3D             ; --- END TEXT SEGMENT
1480   0D3D             
1481   0D3D             ; --- BEGIN DATA SEGMENT
1482   0D3D 2F 75 73 72 _shell_path_data: .db "/usr/bin0/shell", 0
1482   0D41 2F 62 69 6E 
1482   0D45 30 2F 73 68 
1482   0D49 65 6C 6C 00 
1483   0D4D 3D 0D       _shell_path: .dw _shell_path_data
1484   0D4F 69 6E 69 74 _s0: .db "init process started.\n\r", 0
1484   0D53 20 70 72 6F 
1484   0D57 63 65 73 73 
1484   0D5B 20 73 74 61 
1484   0D5F 72 74 65 64 
1484   0D63 2E 0A 0D 00 
1485   0D67 73 74 61 72 _s1: .db "starting shell...\n\r", 0
1485   0D6B 74 69 6E 67 
1485   0D6F 20 73 68 65 
1485   0D73 6C 6C 2E 2E 
1485   0D77 2E 0A 0D 00 
1486   0D7B 55 6E 65 78 _s2: .db "Unexpected format in printf.", 0
1486   0D7F 70 65 63 74 
1486   0D83 65 64 20 66 
1486   0D87 6F 72 6D 61 
1486   0D8B 74 20 69 6E 
1486   0D8F 20 70 72 69 
1486   0D93 6E 74 66 2E 
1486   0D97 00 
1487   0D98 45 72 72 6F _s3: .db "Error: Unknown argument type.\n", 0
1487   0D9C 72 3A 20 55 
1487   0DA0 6E 6B 6E 6F 
1487   0DA4 77 6E 20 61 
1487   0DA8 72 67 75 6D 
1487   0DAC 65 6E 74 20 
1487   0DB0 74 79 70 65 
1487   0DB4 2E 0A 00 
1488   0DB7             
1489   0DB7 B9 0D       _heap_top: .dw _heap
1490   0DB9 00          _heap: .db 0
1491   0DBA             ; --- END DATA SEGMENT
1492   0DBA             
1493   0DBA             .end
tasm: Number of errors = 2
