0001   0000             ; --- FILENAME: ../solarium/usr/bin/mkbin.c
0002   0000             ; --- DATE:     16-06-2025 at 19:16:57
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0000             IDE_buffer       .EQU  $8204
0003+  0000             boot_origin      .EQU  $8004
0004+  0000             bios_uart        .EQU  $0002
0005+  0000             bios_ide         .EQU  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; char *s; 
0012   0408 52 02 00      sub sp, 2
0013   040B             ; prog = 0x0000; // Beginning of arguments buffer 
0014   040B 3B F4 0F      mov d, _prog ; $prog
0015   040E DA            push d
0016   040F FD 2E 00 00   mov32 cb, $00000000
0016   0413 00 00 
0017   0415 E7            pop d
0018   0416 FD 43         mov [d], b
0019   0418             ; s = arg; 
0020   0418 FA FF FF      lea d, [bp + -1] ; $s
0021   041B DA            push d
0022   041C 3B F0 0D      mov d, _arg_data ; $arg
0023   041F 2D            mov b, d
0024   0420 38 00 00      mov c, 0
0025   0423 E7            pop d
0026   0424 FD 43         mov [d], b
0027   0426             ; for(;;){ 
0028   0426             _for1_init:
0029   0426             _for1_cond:
0030   0426             _for1_block:
0031   0426             ; if(*prog == '\0' || *prog == ';' || *prog == ' '){ 
0032   0426             _if2_cond:
0033   0426 3B F4 0F      mov d, _prog ; $prog
0034   0429 2A            mov b, [d]
0035   042A 38 00 00      mov c, 0
0036   042D 74            mov d, b
0037   042E 32            mov bl, [d]
0038   042F A7 00         mov bh, 0
0039   0431 38 00 00      mov c, 0
0040   0434             ; --- START RELATIONAL
0041   0434 D7            push a
0042   0435 11            mov a, b
0043   0436 FD 2E 00 00   mov32 cb, $00000000
0043   043A 00 00 
0044   043C B0            cmp a, b
0045   043D FD 71         seq ; ==
0046   043F E4            pop a
0047   0440             ; --- END RELATIONAL
0048   0440             ; --- START LOGICAL OR
0049   0440 D7            push a
0050   0441 11            mov a, b
0051   0442 3B F4 0F      mov d, _prog ; $prog
0052   0445 2A            mov b, [d]
0053   0446 38 00 00      mov c, 0
0054   0449 74            mov d, b
0055   044A 32            mov bl, [d]
0056   044B A7 00         mov bh, 0
0057   044D 38 00 00      mov c, 0
0058   0450             ; --- START RELATIONAL
0059   0450 D7            push a
0060   0451 11            mov a, b
0061   0452 FD 2E 3B 00   mov32 cb, $0000003b
0061   0456 00 00 
0062   0458 B0            cmp a, b
0063   0459 FD 71         seq ; ==
0064   045B E4            pop a
0065   045C             ; --- END RELATIONAL
0066   045C FD A8         sor a, b ; ||
0067   045E 11            mov a, b
0068   045F 3B F4 0F      mov d, _prog ; $prog
0069   0462 2A            mov b, [d]
0070   0463 38 00 00      mov c, 0
0071   0466 74            mov d, b
0072   0467 32            mov bl, [d]
0073   0468 A7 00         mov bh, 0
0074   046A 38 00 00      mov c, 0
0075   046D             ; --- START RELATIONAL
0076   046D D7            push a
0077   046E 11            mov a, b
0078   046F FD 2E 20 00   mov32 cb, $00000020
0078   0473 00 00 
0079   0475 B0            cmp a, b
0080   0476 FD 71         seq ; ==
0081   0478 E4            pop a
0082   0479             ; --- END RELATIONAL
0083   0479 FD A8         sor a, b ; ||
0084   047B E4            pop a
0085   047C             ; --- END LOGICAL OR
0086   047C C0 00 00      cmp b, 0
0087   047F C6 99 04      je _if2_else
0088   0482             _if2_TRUE:
0089   0482             ; *s = '\0'; 
0090   0482 FA FF FF      lea d, [bp + -1] ; $s
0091   0485 2A            mov b, [d]
0092   0486 38 00 00      mov c, 0
0093   0489 D8            push b
0094   048A FD 2E 00 00   mov32 cb, $00000000
0094   048E 00 00 
0095   0490 E7            pop d
0096   0491 FD 3E         mov [d], bl
0097   0493             ; break; 
0098   0493 0A C7 04      jmp _for1_exit ; for break
0099   0496 0A C4 04      jmp _if2_exit
0100   0499             _if2_else:
0101   0499             ; *s++ = *prog++; 
0102   0499 FA FF FF      lea d, [bp + -1] ; $s
0103   049C 2A            mov b, [d]
0104   049D 38 00 00      mov c, 0
0105   04A0 FD 77         inc b
0106   04A2 FA FF FF      lea d, [bp + -1] ; $s
0107   04A5 FD 43         mov [d], b
0108   04A7 FD 7D         dec b
0109   04A9 D8            push b
0110   04AA 3B F4 0F      mov d, _prog ; $prog
0111   04AD 2A            mov b, [d]
0112   04AE 38 00 00      mov c, 0
0113   04B1 FD 77         inc b
0114   04B3 3B F4 0F      mov d, _prog ; $prog
0115   04B6 FD 43         mov [d], b
0116   04B8 FD 7D         dec b
0117   04BA 74            mov d, b
0118   04BB 32            mov bl, [d]
0119   04BC A7 00         mov bh, 0
0120   04BE 38 00 00      mov c, 0
0121   04C1 E7            pop d
0122   04C2 FD 3E         mov [d], bl
0123   04C4             _if2_exit:
0124   04C4             _for1_update:
0125   04C4 0A 26 04      jmp _for1_cond
0126   04C7             _for1_exit:
0127   04C7             ; printf("> "); 
0128   04C7             ; --- START FUNCTION CALL
0129   04C7 26 F6 11      mov b, _s0 ; "> "
0130   04CA FD AB         swp b
0131   04CC D8            push b
0132   04CD 07 DC 04      call printf
0133   04D0 51 02 00      add sp, 2
0134   04D3             ; --- END FUNCTION CALL
0135   04D3             ; --- BEGIN INLINE ASM SEGMENT
0136   04D3 3B F0 0D      mov d, _arg_data ; $arg
0137   04D6 19 06         mov al, 6
0138   04D8 05 04         syscall sys_filesystem
0139   04DA             ; --- END INLINE ASM SEGMENT
0140   04DA 05 0B         syscall sys_terminate_proc
0141   04DC             
0142   04DC             printf:
0143   04DC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0144   04DF             ; char *p, *format_p; 
0145   04DF 52 02 00      sub sp, 2
0146   04E2 52 02 00      sub sp, 2
0147   04E5             ; format_p = format; 
0148   04E5 FA FD FF      lea d, [bp + -3] ; $format_p
0149   04E8 DA            push d
0150   04E9 FA 05 00      lea d, [bp + 5] ; $format
0151   04EC 2A            mov b, [d]
0152   04ED 38 00 00      mov c, 0
0153   04F0 E7            pop d
0154   04F1 FD 43         mov [d], b
0155   04F3             ; p = &format + 2; 
0156   04F3 FA FF FF      lea d, [bp + -1] ; $p
0157   04F6 DA            push d
0158   04F7 FA 05 00      lea d, [bp + 5] ; $format
0159   04FA 2D            mov b, d
0160   04FB             ; --- START TERMS
0161   04FB D7            push a
0162   04FC 11            mov a, b
0163   04FD FD 2E 02 00   mov32 cb, $00000002
0163   0501 00 00 
0164   0503 56            add b, a
0165   0504 E4            pop a
0166   0505             ; --- END TERMS
0167   0505 E7            pop d
0168   0506 FD 43         mov [d], b
0169   0508             ; for(;;){ 
0170   0508             _for3_init:
0171   0508             _for3_cond:
0172   0508             _for3_block:
0173   0508             ; if(!*format_p) break; 
0174   0508             _if4_cond:
0175   0508 FA FD FF      lea d, [bp + -3] ; $format_p
0176   050B 2A            mov b, [d]
0177   050C 38 00 00      mov c, 0
0178   050F 74            mov d, b
0179   0510 32            mov bl, [d]
0180   0511 A7 00         mov bh, 0
0181   0513 38 00 00      mov c, 0
0182   0516 C0 00 00      cmp b, 0
0183   0519 FD 71         seq ; !
0184   051B C0 00 00      cmp b, 0
0185   051E C6 27 05      je _if4_else
0186   0521             _if4_TRUE:
0187   0521             ; break; 
0188   0521 0A C7 07      jmp _for3_exit ; for break
0189   0524 0A B4 07      jmp _if4_exit
0190   0527             _if4_else:
0191   0527             ; if(*format_p == '%'){ 
0192   0527             _if5_cond:
0193   0527 FA FD FF      lea d, [bp + -3] ; $format_p
0194   052A 2A            mov b, [d]
0195   052B 38 00 00      mov c, 0
0196   052E 74            mov d, b
0197   052F 32            mov bl, [d]
0198   0530 A7 00         mov bh, 0
0199   0532 38 00 00      mov c, 0
0200   0535             ; --- START RELATIONAL
0201   0535 D7            push a
0202   0536 11            mov a, b
0203   0537 FD 2E 25 00   mov32 cb, $00000025
0203   053B 00 00 
0204   053D B0            cmp a, b
0205   053E FD 71         seq ; ==
0206   0540 E4            pop a
0207   0541             ; --- END RELATIONAL
0208   0541 C0 00 00      cmp b, 0
0209   0544 C6 9F 07      je _if5_else
0210   0547             _if5_TRUE:
0211   0547             ; format_p++; 
0212   0547 FA FD FF      lea d, [bp + -3] ; $format_p
0213   054A 2A            mov b, [d]
0214   054B 38 00 00      mov c, 0
0215   054E FD 77         inc b
0216   0550 FA FD FF      lea d, [bp + -3] ; $format_p
0217   0553 FD 43         mov [d], b
0218   0555 FD 7D         dec b
0219   0557             ; switch(*format_p){ 
0220   0557             _switch6_expr:
0221   0557 FA FD FF      lea d, [bp + -3] ; $format_p
0222   055A 2A            mov b, [d]
0223   055B 38 00 00      mov c, 0
0224   055E 74            mov d, b
0225   055F 32            mov bl, [d]
0226   0560 A7 00         mov bh, 0
0227   0562 38 00 00      mov c, 0
0228   0565             _switch6_comparisons:
0229   0565 C1 6C         cmp bl, $6c
0230   0567 C6 93 05      je _switch6_case0
0231   056A C1 4C         cmp bl, $4c
0232   056C C6 93 05      je _switch6_case1
0233   056F C1 64         cmp bl, $64
0234   0571 C6 A3 06      je _switch6_case2
0235   0574 C1 69         cmp bl, $69
0236   0576 C6 A3 06      je _switch6_case3
0237   0579 C1 75         cmp bl, $75
0238   057B C6 D3 06      je _switch6_case4
0239   057E C1 78         cmp bl, $78
0240   0580 C6 03 07      je _switch6_case5
0241   0583 C1 63         cmp bl, $63
0242   0585 C6 33 07      je _switch6_case6
0243   0588 C1 73         cmp bl, $73
0244   058A C6 63 07      je _switch6_case7
0245   058D 0A 90 07      jmp _switch6_default
0246   0590 0A 9C 07      jmp _switch6_exit
0247   0593             _switch6_case0:
0248   0593             _switch6_case1:
0249   0593             ; format_p++; 
0250   0593 FA FD FF      lea d, [bp + -3] ; $format_p
0251   0596 2A            mov b, [d]
0252   0597 38 00 00      mov c, 0
0253   059A FD 77         inc b
0254   059C FA FD FF      lea d, [bp + -3] ; $format_p
0255   059F FD 43         mov [d], b
0256   05A1 FD 7D         dec b
0257   05A3             ; if(*format_p == 'd' || *format_p == 'i') 
0258   05A3             _if7_cond:
0259   05A3 FA FD FF      lea d, [bp + -3] ; $format_p
0260   05A6 2A            mov b, [d]
0261   05A7 38 00 00      mov c, 0
0262   05AA 74            mov d, b
0263   05AB 32            mov bl, [d]
0264   05AC A7 00         mov bh, 0
0265   05AE 38 00 00      mov c, 0
0266   05B1             ; --- START RELATIONAL
0267   05B1 D7            push a
0268   05B2 11            mov a, b
0269   05B3 FD 2E 64 00   mov32 cb, $00000064
0269   05B7 00 00 
0270   05B9 B0            cmp a, b
0271   05BA FD 71         seq ; ==
0272   05BC E4            pop a
0273   05BD             ; --- END RELATIONAL
0274   05BD             ; --- START LOGICAL OR
0275   05BD D7            push a
0276   05BE 11            mov a, b
0277   05BF FA FD FF      lea d, [bp + -3] ; $format_p
0278   05C2 2A            mov b, [d]
0279   05C3 38 00 00      mov c, 0
0280   05C6 74            mov d, b
0281   05C7 32            mov bl, [d]
0282   05C8 A7 00         mov bh, 0
0283   05CA 38 00 00      mov c, 0
0284   05CD             ; --- START RELATIONAL
0285   05CD D7            push a
0286   05CE 11            mov a, b
0287   05CF FD 2E 69 00   mov32 cb, $00000069
0287   05D3 00 00 
0288   05D5 B0            cmp a, b
0289   05D6 FD 71         seq ; ==
0290   05D8 E4            pop a
0291   05D9             ; --- END RELATIONAL
0292   05D9 FD A8         sor a, b ; ||
0293   05DB E4            pop a
0294   05DC             ; --- END LOGICAL OR
0295   05DC C0 00 00      cmp b, 0
0296   05DF C6 00 06      je _if7_else
0297   05E2             _if7_TRUE:
0298   05E2             ; print_signed_long(*(long *)p); 
0299   05E2             ; --- START FUNCTION CALL
0300   05E2 FA FF FF      lea d, [bp + -1] ; $p
0301   05E5 2A            mov b, [d]
0302   05E6 38 00 00      mov c, 0
0303   05E9 74            mov d, b
0304   05EA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0305   05ED FD 39         mov c, b ; And place it into C
0306   05EF 2A            mov b, [d] ; Lower Word in B
0307   05F0 12            mov a, c
0308   05F1 FD AA         swp a
0309   05F3 D7            push a
0310   05F4 FD AB         swp b
0311   05F6 D8            push b
0312   05F7 07 C9 07      call print_signed_long
0313   05FA 51 04 00      add sp, 4
0314   05FD             ; --- END FUNCTION CALL
0315   05FD 0A 88 06      jmp _if7_exit
0316   0600             _if7_else:
0317   0600             ; if(*format_p == 'u') 
0318   0600             _if8_cond:
0319   0600 FA FD FF      lea d, [bp + -3] ; $format_p
0320   0603 2A            mov b, [d]
0321   0604 38 00 00      mov c, 0
0322   0607 74            mov d, b
0323   0608 32            mov bl, [d]
0324   0609 A7 00         mov bh, 0
0325   060B 38 00 00      mov c, 0
0326   060E             ; --- START RELATIONAL
0327   060E D7            push a
0328   060F 11            mov a, b
0329   0610 FD 2E 75 00   mov32 cb, $00000075
0329   0614 00 00 
0330   0616 B0            cmp a, b
0331   0617 FD 71         seq ; ==
0332   0619 E4            pop a
0333   061A             ; --- END RELATIONAL
0334   061A C0 00 00      cmp b, 0
0335   061D C6 3E 06      je _if8_else
0336   0620             _if8_TRUE:
0337   0620             ; print_unsigned_long(*(unsigned long *)p); 
0338   0620             ; --- START FUNCTION CALL
0339   0620 FA FF FF      lea d, [bp + -1] ; $p
0340   0623 2A            mov b, [d]
0341   0624 38 00 00      mov c, 0
0342   0627 74            mov d, b
0343   0628 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0344   062B FD 39         mov c, b ; And place it into C
0345   062D 2A            mov b, [d] ; Lower Word in B
0346   062E 12            mov a, c
0347   062F FD AA         swp a
0348   0631 D7            push a
0349   0632 FD AB         swp b
0350   0634 D8            push b
0351   0635 07 69 09      call print_unsigned_long
0352   0638 51 04 00      add sp, 4
0353   063B             ; --- END FUNCTION CALL
0354   063B 0A 88 06      jmp _if8_exit
0355   063E             _if8_else:
0356   063E             ; if(*format_p == 'x') 
0357   063E             _if9_cond:
0358   063E FA FD FF      lea d, [bp + -3] ; $format_p
0359   0641 2A            mov b, [d]
0360   0642 38 00 00      mov c, 0
0361   0645 74            mov d, b
0362   0646 32            mov bl, [d]
0363   0647 A7 00         mov bh, 0
0364   0649 38 00 00      mov c, 0
0365   064C             ; --- START RELATIONAL
0366   064C D7            push a
0367   064D 11            mov a, b
0368   064E FD 2E 78 00   mov32 cb, $00000078
0368   0652 00 00 
0369   0654 B0            cmp a, b
0370   0655 FD 71         seq ; ==
0371   0657 E4            pop a
0372   0658             ; --- END RELATIONAL
0373   0658 C0 00 00      cmp b, 0
0374   065B C6 7C 06      je _if9_else
0375   065E             _if9_TRUE:
0376   065E             ; printx32(*(long int *)p); 
0377   065E             ; --- START FUNCTION CALL
0378   065E FA FF FF      lea d, [bp + -1] ; $p
0379   0661 2A            mov b, [d]
0380   0662 38 00 00      mov c, 0
0381   0665 74            mov d, b
0382   0666 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0383   0669 FD 39         mov c, b ; And place it into C
0384   066B 2A            mov b, [d] ; Lower Word in B
0385   066C 12            mov a, c
0386   066D FD AA         swp a
0387   066F D7            push a
0388   0670 FD AB         swp b
0389   0672 D8            push b
0390   0673 07 A7 0A      call printx32
0391   0676 51 04 00      add sp, 4
0392   0679             ; --- END FUNCTION CALL
0393   0679 0A 88 06      jmp _if9_exit
0394   067C             _if9_else:
0395   067C             ; err("Unexpected format in printf."); 
0396   067C             ; --- START FUNCTION CALL
0397   067C 26 F9 11      mov b, _s1 ; "Unexpected format in printf."
0398   067F FD AB         swp b
0399   0681 D8            push b
0400   0682 07 07 0B      call err
0401   0685 51 02 00      add sp, 2
0402   0688             ; --- END FUNCTION CALL
0403   0688             _if9_exit:
0404   0688             _if8_exit:
0405   0688             _if7_exit:
0406   0688             ; p = p + 4; 
0407   0688 FA FF FF      lea d, [bp + -1] ; $p
0408   068B DA            push d
0409   068C FA FF FF      lea d, [bp + -1] ; $p
0410   068F 2A            mov b, [d]
0411   0690 38 00 00      mov c, 0
0412   0693             ; --- START TERMS
0413   0693 D7            push a
0414   0694 11            mov a, b
0415   0695 FD 2E 04 00   mov32 cb, $00000004
0415   0699 00 00 
0416   069B 56            add b, a
0417   069C E4            pop a
0418   069D             ; --- END TERMS
0419   069D E7            pop d
0420   069E FD 43         mov [d], b
0421   06A0             ; break; 
0422   06A0 0A 9C 07      jmp _switch6_exit ; case break
0423   06A3             _switch6_case2:
0424   06A3             _switch6_case3:
0425   06A3             ; print_signed(*(int*)p); 
0426   06A3             ; --- START FUNCTION CALL
0427   06A3 FA FF FF      lea d, [bp + -1] ; $p
0428   06A6 2A            mov b, [d]
0429   06A7 38 00 00      mov c, 0
0430   06AA 74            mov d, b
0431   06AB 2A            mov b, [d]
0432   06AC 38 00 00      mov c, 0
0433   06AF FD AB         swp b
0434   06B1 D8            push b
0435   06B2 07 35 0B      call print_signed
0436   06B5 51 02 00      add sp, 2
0437   06B8             ; --- END FUNCTION CALL
0438   06B8             ; p = p + 2; 
0439   06B8 FA FF FF      lea d, [bp + -1] ; $p
0440   06BB DA            push d
0441   06BC FA FF FF      lea d, [bp + -1] ; $p
0442   06BF 2A            mov b, [d]
0443   06C0 38 00 00      mov c, 0
0444   06C3             ; --- START TERMS
0445   06C3 D7            push a
0446   06C4 11            mov a, b
0447   06C5 FD 2E 02 00   mov32 cb, $00000002
0447   06C9 00 00 
0448   06CB 56            add b, a
0449   06CC E4            pop a
0450   06CD             ; --- END TERMS
0451   06CD E7            pop d
0452   06CE FD 43         mov [d], b
0453   06D0             ; break; 
0454   06D0 0A 9C 07      jmp _switch6_exit ; case break
0455   06D3             _switch6_case4:
0456   06D3             ; print_unsigned(*(unsigned int*)p); 
0457   06D3             ; --- START FUNCTION CALL
0458   06D3 FA FF FF      lea d, [bp + -1] ; $p
0459   06D6 2A            mov b, [d]
0460   06D7 38 00 00      mov c, 0
0461   06DA 74            mov d, b
0462   06DB 2A            mov b, [d]
0463   06DC 38 00 00      mov c, 0
0464   06DF FD AB         swp b
0465   06E1 D8            push b
0466   06E2 07 86 0C      call print_unsigned
0467   06E5 51 02 00      add sp, 2
0468   06E8             ; --- END FUNCTION CALL
0469   06E8             ; p = p + 2; 
0470   06E8 FA FF FF      lea d, [bp + -1] ; $p
0471   06EB DA            push d
0472   06EC FA FF FF      lea d, [bp + -1] ; $p
0473   06EF 2A            mov b, [d]
0474   06F0 38 00 00      mov c, 0
0475   06F3             ; --- START TERMS
0476   06F3 D7            push a
0477   06F4 11            mov a, b
0478   06F5 FD 2E 02 00   mov32 cb, $00000002
0478   06F9 00 00 
0479   06FB 56            add b, a
0480   06FC E4            pop a
0481   06FD             ; --- END TERMS
0482   06FD E7            pop d
0483   06FE FD 43         mov [d], b
0484   0700             ; break; 
0485   0700 0A 9C 07      jmp _switch6_exit ; case break
0486   0703             _switch6_case5:
0487   0703             ; printx16(*(int*)p); 
0488   0703             ; --- START FUNCTION CALL
0489   0703 FA FF FF      lea d, [bp + -1] ; $p
0490   0706 2A            mov b, [d]
0491   0707 38 00 00      mov c, 0
0492   070A 74            mov d, b
0493   070B 2A            mov b, [d]
0494   070C 38 00 00      mov c, 0
0495   070F FD AB         swp b
0496   0711 D8            push b
0497   0712 07 9E 0D      call printx16
0498   0715 51 02 00      add sp, 2
0499   0718             ; --- END FUNCTION CALL
0500   0718             ; p = p + 2; 
0501   0718 FA FF FF      lea d, [bp + -1] ; $p
0502   071B DA            push d
0503   071C FA FF FF      lea d, [bp + -1] ; $p
0504   071F 2A            mov b, [d]
0505   0720 38 00 00      mov c, 0
0506   0723             ; --- START TERMS
0507   0723 D7            push a
0508   0724 11            mov a, b
0509   0725 FD 2E 02 00   mov32 cb, $00000002
0509   0729 00 00 
0510   072B 56            add b, a
0511   072C E4            pop a
0512   072D             ; --- END TERMS
0513   072D E7            pop d
0514   072E FD 43         mov [d], b
0515   0730             ; break; 
0516   0730 0A 9C 07      jmp _switch6_exit ; case break
0517   0733             _switch6_case6:
0518   0733             ; putchar(*(char*)p); 
0519   0733             ; --- START FUNCTION CALL
0520   0733 FA FF FF      lea d, [bp + -1] ; $p
0521   0736 2A            mov b, [d]
0522   0737 38 00 00      mov c, 0
0523   073A 74            mov d, b
0524   073B 32            mov bl, [d]
0525   073C A7 00         mov bh, 0
0526   073E 38 00 00      mov c, 0
0527   0741 DD            push bl
0528   0742 07 5B 09      call putchar
0529   0745 51 01 00      add sp, 1
0530   0748             ; --- END FUNCTION CALL
0531   0748             ; p = p + 2; 
0532   0748 FA FF FF      lea d, [bp + -1] ; $p
0533   074B DA            push d
0534   074C FA FF FF      lea d, [bp + -1] ; $p
0535   074F 2A            mov b, [d]
0536   0750 38 00 00      mov c, 0
0537   0753             ; --- START TERMS
0538   0753 D7            push a
0539   0754 11            mov a, b
0540   0755 FD 2E 02 00   mov32 cb, $00000002
0540   0759 00 00 
0541   075B 56            add b, a
0542   075C E4            pop a
0543   075D             ; --- END TERMS
0544   075D E7            pop d
0545   075E FD 43         mov [d], b
0546   0760             ; break; 
0547   0760 0A 9C 07      jmp _switch6_exit ; case break
0548   0763             _switch6_case7:
0549   0763             ; print(*(char**)p); 
0550   0763             ; --- START FUNCTION CALL
0551   0763 FA FF FF      lea d, [bp + -1] ; $p
0552   0766 2A            mov b, [d]
0553   0767 38 00 00      mov c, 0
0554   076A 74            mov d, b
0555   076B 2A            mov b, [d]
0556   076C FD AB         swp b
0557   076E D8            push b
0558   076F 07 1C 0B      call print
0559   0772 51 02 00      add sp, 2
0560   0775             ; --- END FUNCTION CALL
0561   0775             ; p = p + 2; 
0562   0775 FA FF FF      lea d, [bp + -1] ; $p
0563   0778 DA            push d
0564   0779 FA FF FF      lea d, [bp + -1] ; $p
0565   077C 2A            mov b, [d]
0566   077D 38 00 00      mov c, 0
0567   0780             ; --- START TERMS
0568   0780 D7            push a
0569   0781 11            mov a, b
0570   0782 FD 2E 02 00   mov32 cb, $00000002
0570   0786 00 00 
0571   0788 56            add b, a
0572   0789 E4            pop a
0573   078A             ; --- END TERMS
0574   078A E7            pop d
0575   078B FD 43         mov [d], b
0576   078D             ; break; 
0577   078D 0A 9C 07      jmp _switch6_exit ; case break
0578   0790             _switch6_default:
0579   0790             ; print("Error: Unknown argument type.\n"); 
0580   0790             ; --- START FUNCTION CALL
0581   0790 26 16 12      mov b, _s2 ; "Error: Unknown argument type.\n"
0582   0793 FD AB         swp b
0583   0795 D8            push b
0584   0796 07 1C 0B      call print
0585   0799 51 02 00      add sp, 2
0586   079C             ; --- END FUNCTION CALL
0587   079C             _switch6_exit:
0588   079C 0A B4 07      jmp _if5_exit
0589   079F             _if5_else:
0590   079F             ; putchar(*format_p); 
0591   079F             ; --- START FUNCTION CALL
0592   079F FA FD FF      lea d, [bp + -3] ; $format_p
0593   07A2 2A            mov b, [d]
0594   07A3 38 00 00      mov c, 0
0595   07A6 74            mov d, b
0596   07A7 32            mov bl, [d]
0597   07A8 A7 00         mov bh, 0
0598   07AA 38 00 00      mov c, 0
0599   07AD DD            push bl
0600   07AE 07 5B 09      call putchar
0601   07B1 51 01 00      add sp, 1
0602   07B4             ; --- END FUNCTION CALL
0603   07B4             _if5_exit:
0604   07B4             _if4_exit:
0605   07B4             ; format_p++; 
0606   07B4 FA FD FF      lea d, [bp + -3] ; $format_p
0607   07B7 2A            mov b, [d]
0608   07B8 38 00 00      mov c, 0
0609   07BB FD 77         inc b
0610   07BD FA FD FF      lea d, [bp + -3] ; $format_p
0611   07C0 FD 43         mov [d], b
0612   07C2 FD 7D         dec b
0613   07C4             _for3_update:
0614   07C4 0A 08 05      jmp _for3_cond
0615   07C7             _for3_exit:
0616   07C7 F9            leave
0617   07C8 09            ret
0618   07C9             
0619   07C9             print_signed_long:
0620   07C9 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0621   07CC             ; char digits[10]; 
0622   07CC 52 0A 00      sub sp, 10
0623   07CF             ; int i = 0; 
0624   07CF 52 02 00      sub sp, 2
0625   07D2             ; --- START LOCAL VAR INITIALIZATION
0626   07D2 FA F5 FF      lea d, [bp + -11] ; $i
0627   07D5 DA            push d
0628   07D6 FD 2E 00 00   mov32 cb, $00000000
0628   07DA 00 00 
0629   07DC E7            pop d
0630   07DD FD 43         mov [d], b
0631   07DF             ; --- END LOCAL VAR INITIALIZATION
0632   07DF             ; if (num < 0) { 
0633   07DF             _if10_cond:
0634   07DF FA 05 00      lea d, [bp + 5] ; $num
0635   07E2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0636   07E5 FD 39         mov c, b ; And place it into C
0637   07E7 2A            mov b, [d] ; Lower Word in B
0638   07E8             ; --- START RELATIONAL
0639   07E8 D7            push a
0640   07E9 FD D8         push g
0641   07EB 11            mov a, b
0642   07EC FD 7A         mov g, c
0643   07EE FD 2E 00 00   mov32 cb, $00000000
0643   07F2 00 00 
0644   07F4 38 00 00      mov c, 0
0645   07F7 FD AF         cmp32 ga, cb
0646   07F9 FD 73         slt ; <
0647   07FB FD F1         pop g
0648   07FD E4            pop a
0649   07FE             ; --- END RELATIONAL
0650   07FE C0 00 00      cmp b, 0
0651   0801 C6 33 08      je _if10_else
0652   0804             _if10_TRUE:
0653   0804             ; putchar('-'); 
0654   0804             ; --- START FUNCTION CALL
0655   0804 FD 2E 2D 00   mov32 cb, $0000002d
0655   0808 00 00 
0656   080A DD            push bl
0657   080B 07 5B 09      call putchar
0658   080E 51 01 00      add sp, 1
0659   0811             ; --- END FUNCTION CALL
0660   0811             ; num = -num; 
0661   0811 FA 05 00      lea d, [bp + 5] ; $num
0662   0814 DA            push d
0663   0815 FA 05 00      lea d, [bp + 5] ; $num
0664   0818 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0665   081B FD 39         mov c, b ; And place it into C
0666   081D 2A            mov b, [d] ; Lower Word in B
0667   081E 12            mov a, c
0668   081F 95            not a
0669   0820 97            not b
0670   0821 55 01 00      add b, 1
0671   0824 5B 00 00      adc a, 0
0672   0827 39            mov c, a
0673   0828 E7            pop d
0674   0829 FD 43         mov [d], b
0675   082B 28            mov b, c
0676   082C FD 44 02 00   mov [d + 2], b
0677   0830 0A 6A 08      jmp _if10_exit
0678   0833             _if10_else:
0679   0833             ; if (num == 0) { 
0680   0833             _if11_cond:
0681   0833 FA 05 00      lea d, [bp + 5] ; $num
0682   0836 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0683   0839 FD 39         mov c, b ; And place it into C
0684   083B 2A            mov b, [d] ; Lower Word in B
0685   083C             ; --- START RELATIONAL
0686   083C D7            push a
0687   083D FD D8         push g
0688   083F 11            mov a, b
0689   0840 FD 7A         mov g, c
0690   0842 FD 2E 00 00   mov32 cb, $00000000
0690   0846 00 00 
0691   0848 38 00 00      mov c, 0
0692   084B FD AF         cmp32 ga, cb
0693   084D FD 71         seq ; ==
0694   084F FD F1         pop g
0695   0851 E4            pop a
0696   0852             ; --- END RELATIONAL
0697   0852 C0 00 00      cmp b, 0
0698   0855 C6 6A 08      je _if11_exit
0699   0858             _if11_TRUE:
0700   0858             ; putchar('0'); 
0701   0858             ; --- START FUNCTION CALL
0702   0858 FD 2E 30 00   mov32 cb, $00000030
0702   085C 00 00 
0703   085E DD            push bl
0704   085F 07 5B 09      call putchar
0705   0862 51 01 00      add sp, 1
0706   0865             ; --- END FUNCTION CALL
0707   0865             ; return; 
0708   0865 F9            leave
0709   0866 09            ret
0710   0867 0A 6A 08      jmp _if11_exit
0711   086A             _if11_exit:
0712   086A             _if10_exit:
0713   086A             ; while (num > 0) { 
0714   086A             _while12_cond:
0715   086A FA 05 00      lea d, [bp + 5] ; $num
0716   086D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0717   0870 FD 39         mov c, b ; And place it into C
0718   0872 2A            mov b, [d] ; Lower Word in B
0719   0873             ; --- START RELATIONAL
0720   0873 D7            push a
0721   0874 FD D8         push g
0722   0876 11            mov a, b
0723   0877 FD 7A         mov g, c
0724   0879 FD 2E 00 00   mov32 cb, $00000000
0724   087D 00 00 
0725   087F 38 00 00      mov c, 0
0726   0882 FD AF         cmp32 ga, cb
0727   0884 FD 7F         sgt
0728   0886 FD F1         pop g
0729   0888 E4            pop a
0730   0889             ; --- END RELATIONAL
0731   0889 C0 00 00      cmp b, 0
0732   088C C6 11 09      je _while12_exit
0733   088F             _while12_block:
0734   088F             ; digits[i] = '0' + (num % 10); 
0735   088F FA F7 FF      lea d, [bp + -9] ; $digits
0736   0892 D7            push a
0737   0893 DA            push d
0738   0894 FA F5 FF      lea d, [bp + -11] ; $i
0739   0897 2A            mov b, [d]
0740   0898 38 00 00      mov c, 0
0741   089B E7            pop d
0742   089C 5A            add d, b
0743   089D E4            pop a
0744   089E DA            push d
0745   089F FD 2E 30 00   mov32 cb, $00000030
0745   08A3 00 00 
0746   08A5             ; --- START TERMS
0747   08A5 D7            push a
0748   08A6 11            mov a, b
0749   08A7 FA 05 00      lea d, [bp + 5] ; $num
0750   08AA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0751   08AD FD 39         mov c, b ; And place it into C
0752   08AF 2A            mov b, [d] ; Lower Word in B
0753   08B0             ; --- START FACTORS
0754   08B0 D7            push a
0755   08B1 FD D8         push g
0756   08B3 11            mov a, b
0757   08B4 FD 7A         mov g, c
0758   08B6 FD 2E 0A 00   mov32 cb, $0000000a
0758   08BA 00 00 
0759   08BC FD D8         push g ; save 'g' as the div instruction uses it
0760   08BE AE            div a, b ; %, a: quotient, b: remainder
0761   08BF 11            mov a, b
0762   08C0 FD F1         pop g
0763   08C2 FD 38         mov c, g
0764   08C4 27            mov b, a
0765   08C5 FD F1         pop g
0766   08C7 E4            pop a
0767   08C8             ; --- END FACTORS
0768   08C8 FD 22 00 00   mov g, 0
0769   08CC FD 15         add32 cb, ga
0770   08CE E4            pop a
0771   08CF             ; --- END TERMS
0772   08CF E7            pop d
0773   08D0 FD 3E         mov [d], bl
0774   08D2             ; num = num / 10; 
0775   08D2 FA 05 00      lea d, [bp + 5] ; $num
0776   08D5 DA            push d
0777   08D6 FA 05 00      lea d, [bp + 5] ; $num
0778   08D9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0779   08DC FD 39         mov c, b ; And place it into C
0780   08DE 2A            mov b, [d] ; Lower Word in B
0781   08DF             ; --- START FACTORS
0782   08DF D7            push a
0783   08E0 FD D8         push g
0784   08E2 11            mov a, b
0785   08E3 FD 7A         mov g, c
0786   08E5 FD 2E 0A 00   mov32 cb, $0000000a
0786   08E9 00 00 
0787   08EB FD D8         push g ; save 'g' as the div instruction uses it
0788   08ED AE            div a, b ; /, a: quotient, b: remainder
0789   08EE FD F1         pop g
0790   08F0 FD 38         mov c, g
0791   08F2 27            mov b, a
0792   08F3 FD F1         pop g
0793   08F5 E4            pop a
0794   08F6             ; --- END FACTORS
0795   08F6 E7            pop d
0796   08F7 FD 43         mov [d], b
0797   08F9 28            mov b, c
0798   08FA FD 44 02 00   mov [d + 2], b
0799   08FE             ; i++; 
0800   08FE FA F5 FF      lea d, [bp + -11] ; $i
0801   0901 2A            mov b, [d]
0802   0902 38 00 00      mov c, 0
0803   0905 11            mov a, b
0804   0906 FD 77         inc b
0805   0908 FA F5 FF      lea d, [bp + -11] ; $i
0806   090B FD 43         mov [d], b
0807   090D 27            mov b, a
0808   090E 0A 6A 08      jmp _while12_cond
0809   0911             _while12_exit:
0810   0911             ; while (i > 0) { 
0811   0911             _while19_cond:
0812   0911 FA F5 FF      lea d, [bp + -11] ; $i
0813   0914 2A            mov b, [d]
0814   0915 38 00 00      mov c, 0
0815   0918             ; --- START RELATIONAL
0816   0918 D7            push a
0817   0919 11            mov a, b
0818   091A FD 2E 00 00   mov32 cb, $00000000
0818   091E 00 00 
0819   0920 B0            cmp a, b
0820   0921 FD 7F         sgt ; >
0821   0923 E4            pop a
0822   0924             ; --- END RELATIONAL
0823   0924 C0 00 00      cmp b, 0
0824   0927 C6 59 09      je _while19_exit
0825   092A             _while19_block:
0826   092A             ; i--; 
0827   092A FA F5 FF      lea d, [bp + -11] ; $i
0828   092D 2A            mov b, [d]
0829   092E 38 00 00      mov c, 0
0830   0931 11            mov a, b
0831   0932 FD 7D         dec b
0832   0934 FA F5 FF      lea d, [bp + -11] ; $i
0833   0937 FD 43         mov [d], b
0834   0939 27            mov b, a
0835   093A             ; putchar(digits[i]); 
0836   093A             ; --- START FUNCTION CALL
0837   093A FA F7 FF      lea d, [bp + -9] ; $digits
0838   093D D7            push a
0839   093E DA            push d
0840   093F FA F5 FF      lea d, [bp + -11] ; $i
0841   0942 2A            mov b, [d]
0842   0943 38 00 00      mov c, 0
0843   0946 E7            pop d
0844   0947 5A            add d, b
0845   0948 E4            pop a
0846   0949 32            mov bl, [d]
0847   094A A7 00         mov bh, 0
0848   094C 38 00 00      mov c, 0
0849   094F DD            push bl
0850   0950 07 5B 09      call putchar
0851   0953 51 01 00      add sp, 1
0852   0956             ; --- END FUNCTION CALL
0853   0956 0A 11 09      jmp _while19_cond
0854   0959             _while19_exit:
0855   0959 F9            leave
0856   095A 09            ret
0857   095B             
0858   095B             putchar:
0859   095B F8 00 00      enter 0 ; (push bp; mov bp, sp)
0860   095E             ; --- BEGIN INLINE ASM SEGMENT
0861   095E FA 05 00      lea d, [bp + 5] ; $c
0862   0961 1E            mov al, [d]
0863   0962 23            mov ah, al
0864   0963 19 00         mov al, 0
0865   0965 05 03         syscall sys_io      ; char in AH
0866   0967             ; --- END INLINE ASM SEGMENT
0867   0967 F9            leave
0868   0968 09            ret
0869   0969             
0870   0969             print_unsigned_long:
0871   0969 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0872   096C             ; char digits[10]; 
0873   096C 52 0A 00      sub sp, 10
0874   096F             ; int i; 
0875   096F 52 02 00      sub sp, 2
0876   0972             ; i = 0; 
0877   0972 FA F5 FF      lea d, [bp + -11] ; $i
0878   0975 DA            push d
0879   0976 FD 2E 00 00   mov32 cb, $00000000
0879   097A 00 00 
0880   097C E7            pop d
0881   097D FD 43         mov [d], b
0882   097F             ; if(num == 0){ 
0883   097F             _if20_cond:
0884   097F FA 05 00      lea d, [bp + 5] ; $num
0885   0982 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0886   0985 FD 39         mov c, b ; And place it into C
0887   0987 2A            mov b, [d] ; Lower Word in B
0888   0988             ; --- START RELATIONAL
0889   0988 D7            push a
0890   0989 FD D8         push g
0891   098B 11            mov a, b
0892   098C FD 7A         mov g, c
0893   098E FD 2E 00 00   mov32 cb, $00000000
0893   0992 00 00 
0894   0994 38 00 00      mov c, 0
0895   0997 FD AF         cmp32 ga, cb
0896   0999 FD 71         seq ; ==
0897   099B FD F1         pop g
0898   099D E4            pop a
0899   099E             ; --- END RELATIONAL
0900   099E C0 00 00      cmp b, 0
0901   09A1 C6 B6 09      je _if20_exit
0902   09A4             _if20_TRUE:
0903   09A4             ; putchar('0'); 
0904   09A4             ; --- START FUNCTION CALL
0905   09A4 FD 2E 30 00   mov32 cb, $00000030
0905   09A8 00 00 
0906   09AA DD            push bl
0907   09AB 07 5B 09      call putchar
0908   09AE 51 01 00      add sp, 1
0909   09B1             ; --- END FUNCTION CALL
0910   09B1             ; return; 
0911   09B1 F9            leave
0912   09B2 09            ret
0913   09B3 0A B6 09      jmp _if20_exit
0914   09B6             _if20_exit:
0915   09B6             ; while (num > 0) { 
0916   09B6             _while21_cond:
0917   09B6 FA 05 00      lea d, [bp + 5] ; $num
0918   09B9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0919   09BC FD 39         mov c, b ; And place it into C
0920   09BE 2A            mov b, [d] ; Lower Word in B
0921   09BF             ; --- START RELATIONAL
0922   09BF D7            push a
0923   09C0 FD D8         push g
0924   09C2 11            mov a, b
0925   09C3 FD 7A         mov g, c
0926   09C5 FD 2E 00 00   mov32 cb, $00000000
0926   09C9 00 00 
0927   09CB 38 00 00      mov c, 0
0928   09CE FD AF         cmp32 ga, cb
0929   09D0 FD 81         sgu
0930   09D2 FD F1         pop g
0931   09D4 E4            pop a
0932   09D5             ; --- END RELATIONAL
0933   09D5 C0 00 00      cmp b, 0
0934   09D8 C6 5D 0A      je _while21_exit
0935   09DB             _while21_block:
0936   09DB             ; digits[i] = '0' + (num % 10); 
0937   09DB FA F7 FF      lea d, [bp + -9] ; $digits
0938   09DE D7            push a
0939   09DF DA            push d
0940   09E0 FA F5 FF      lea d, [bp + -11] ; $i
0941   09E3 2A            mov b, [d]
0942   09E4 38 00 00      mov c, 0
0943   09E7 E7            pop d
0944   09E8 5A            add d, b
0945   09E9 E4            pop a
0946   09EA DA            push d
0947   09EB FD 2E 30 00   mov32 cb, $00000030
0947   09EF 00 00 
0948   09F1             ; --- START TERMS
0949   09F1 D7            push a
0950   09F2 11            mov a, b
0951   09F3 FA 05 00      lea d, [bp + 5] ; $num
0952   09F6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0953   09F9 FD 39         mov c, b ; And place it into C
0954   09FB 2A            mov b, [d] ; Lower Word in B
0955   09FC             ; --- START FACTORS
0956   09FC D7            push a
0957   09FD FD D8         push g
0958   09FF 11            mov a, b
0959   0A00 FD 7A         mov g, c
0960   0A02 FD 2E 0A 00   mov32 cb, $0000000a
0960   0A06 00 00 
0961   0A08 FD D8         push g ; save 'g' as the div instruction uses it
0962   0A0A AE            div a, b ; %, a: quotient, b: remainder
0963   0A0B 11            mov a, b
0964   0A0C FD F1         pop g
0965   0A0E FD 38         mov c, g
0966   0A10 27            mov b, a
0967   0A11 FD F1         pop g
0968   0A13 E4            pop a
0969   0A14             ; --- END FACTORS
0970   0A14 FD 22 00 00   mov g, 0
0971   0A18 FD 15         add32 cb, ga
0972   0A1A E4            pop a
0973   0A1B             ; --- END TERMS
0974   0A1B E7            pop d
0975   0A1C FD 3E         mov [d], bl
0976   0A1E             ; num = num / 10; 
0977   0A1E FA 05 00      lea d, [bp + 5] ; $num
0978   0A21 DA            push d
0979   0A22 FA 05 00      lea d, [bp + 5] ; $num
0980   0A25 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0981   0A28 FD 39         mov c, b ; And place it into C
0982   0A2A 2A            mov b, [d] ; Lower Word in B
0983   0A2B             ; --- START FACTORS
0984   0A2B D7            push a
0985   0A2C FD D8         push g
0986   0A2E 11            mov a, b
0987   0A2F FD 7A         mov g, c
0988   0A31 FD 2E 0A 00   mov32 cb, $0000000a
0988   0A35 00 00 
0989   0A37 FD D8         push g ; save 'g' as the div instruction uses it
0990   0A39 AE            div a, b ; /, a: quotient, b: remainder
0991   0A3A FD F1         pop g
0992   0A3C FD 38         mov c, g
0993   0A3E 27            mov b, a
0994   0A3F FD F1         pop g
0995   0A41 E4            pop a
0996   0A42             ; --- END FACTORS
0997   0A42 E7            pop d
0998   0A43 FD 43         mov [d], b
0999   0A45 28            mov b, c
1000   0A46 FD 44 02 00   mov [d + 2], b
1001   0A4A             ; i++; 
1002   0A4A FA F5 FF      lea d, [bp + -11] ; $i
1003   0A4D 2A            mov b, [d]
1004   0A4E 38 00 00      mov c, 0
1005   0A51 11            mov a, b
1006   0A52 FD 77         inc b
1007   0A54 FA F5 FF      lea d, [bp + -11] ; $i
1008   0A57 FD 43         mov [d], b
1009   0A59 27            mov b, a
1010   0A5A 0A B6 09      jmp _while21_cond
1011   0A5D             _while21_exit:
1012   0A5D             ; while (i > 0) { 
1013   0A5D             _while28_cond:
1014   0A5D FA F5 FF      lea d, [bp + -11] ; $i
1015   0A60 2A            mov b, [d]
1016   0A61 38 00 00      mov c, 0
1017   0A64             ; --- START RELATIONAL
1018   0A64 D7            push a
1019   0A65 11            mov a, b
1020   0A66 FD 2E 00 00   mov32 cb, $00000000
1020   0A6A 00 00 
1021   0A6C B0            cmp a, b
1022   0A6D FD 7F         sgt ; >
1023   0A6F E4            pop a
1024   0A70             ; --- END RELATIONAL
1025   0A70 C0 00 00      cmp b, 0
1026   0A73 C6 A5 0A      je _while28_exit
1027   0A76             _while28_block:
1028   0A76             ; i--; 
1029   0A76 FA F5 FF      lea d, [bp + -11] ; $i
1030   0A79 2A            mov b, [d]
1031   0A7A 38 00 00      mov c, 0
1032   0A7D 11            mov a, b
1033   0A7E FD 7D         dec b
1034   0A80 FA F5 FF      lea d, [bp + -11] ; $i
1035   0A83 FD 43         mov [d], b
1036   0A85 27            mov b, a
1037   0A86             ; putchar(digits[i]); 
1038   0A86             ; --- START FUNCTION CALL
1039   0A86 FA F7 FF      lea d, [bp + -9] ; $digits
1040   0A89 D7            push a
1041   0A8A DA            push d
1042   0A8B FA F5 FF      lea d, [bp + -11] ; $i
1043   0A8E 2A            mov b, [d]
1044   0A8F 38 00 00      mov c, 0
1045   0A92 E7            pop d
1046   0A93 5A            add d, b
1047   0A94 E4            pop a
1048   0A95 32            mov bl, [d]
1049   0A96 A7 00         mov bh, 0
1050   0A98 38 00 00      mov c, 0
1051   0A9B DD            push bl
1052   0A9C 07 5B 09      call putchar
1053   0A9F 51 01 00      add sp, 1
1054   0AA2             ; --- END FUNCTION CALL
1055   0AA2 0A 5D 0A      jmp _while28_cond
1056   0AA5             _while28_exit:
1057   0AA5 F9            leave
1058   0AA6 09            ret
1059   0AA7             
1060   0AA7             printx32:
1061   0AA7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1062   0AAA             ; --- BEGIN INLINE ASM SEGMENT
1063   0AAA FA 05 00      lea d, [bp + 5] ; $hex
1064   0AAD 2B 02 00      mov b, [d+2]
1065   0AB0 07 B9 0A      call print_u16x_printx32
1066   0AB3 2A            mov b, [d]
1067   0AB4 07 B9 0A      call print_u16x_printx32
1068   0AB7             ; --- END INLINE ASM SEGMENT
1069   0AB7             ; return; 
1070   0AB7 F9            leave
1071   0AB8 09            ret
1072   0AB9             ; --- BEGIN INLINE ASM SEGMENT
1073   0AB9             print_u16x_printx32:
1074   0AB9 D7            push a
1075   0ABA D8            push b
1076   0ABB DD            push bl
1077   0ABC 30            mov bl, bh
1078   0ABD 07 DB 0A      call _itoa_printx32        ; convert bh to char in A
1079   0AC0 2F            mov bl, al        ; save al
1080   0AC1 19 00         mov al, 0
1081   0AC3 05 03         syscall sys_io        ; display AH
1082   0AC5 24            mov ah, bl        ; retrieve al
1083   0AC6 19 00         mov al, 0
1084   0AC8 05 03         syscall sys_io        ; display AL
1085   0ACA EA            pop bl
1086   0ACB 07 DB 0A      call _itoa_printx32        ; convert bh to char in A
1087   0ACE 2F            mov bl, al        ; save al
1088   0ACF 19 00         mov al, 0
1089   0AD1 05 03         syscall sys_io        ; display AH
1090   0AD3 24            mov ah, bl        ; retrieve al
1091   0AD4 19 00         mov al, 0
1092   0AD6 05 03         syscall sys_io        ; display AL
1093   0AD8 E5            pop b
1094   0AD9 E4            pop a
1095   0ADA 09            ret
1096   0ADB             _itoa_printx32:
1097   0ADB DA            push d
1098   0ADC D8            push b
1099   0ADD A7 00         mov bh, 0
1100   0ADF FD A4 04      shr bl, 4  
1101   0AE2 74            mov d, b
1102   0AE3 1F F5 0A      mov al, [d + s_hex_digits_printx32]
1103   0AE6 23            mov ah, al
1104   0AE7 E5            pop b
1105   0AE8 D8            push b
1106   0AE9 A7 00         mov bh, 0
1107   0AEB FD 87 0F      and bl, $0F
1108   0AEE 74            mov d, b
1109   0AEF 1F F5 0A      mov al, [d + s_hex_digits_printx32]
1110   0AF2 E5            pop b
1111   0AF3 E7            pop d
1112   0AF4 09            ret
1113   0AF5 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1113   0AF9 34 35 36 37 
1113   0AFD 38 39 41 42 
1113   0B01 43 44 45 46 
1114   0B05             ; --- END INLINE ASM SEGMENT
1115   0B05 F9            leave
1116   0B06 09            ret
1117   0B07             
1118   0B07             err:
1119   0B07 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1120   0B0A             ; print(e); 
1121   0B0A             ; --- START FUNCTION CALL
1122   0B0A FA 05 00      lea d, [bp + 5] ; $e
1123   0B0D 2A            mov b, [d]
1124   0B0E 38 00 00      mov c, 0
1125   0B11 FD AB         swp b
1126   0B13 D8            push b
1127   0B14 07 1C 0B      call print
1128   0B17 51 02 00      add sp, 2
1129   0B1A             ; --- END FUNCTION CALL
1130   0B1A F9            leave
1131   0B1B 09            ret
1132   0B1C             
1133   0B1C             print:
1134   0B1C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1135   0B1F             ; --- BEGIN INLINE ASM SEGMENT
1136   0B1F FA 05 00      lea d, [bp + 5] ; $s
1137   0B22 FD 2A         mov d, [d]
1138   0B24             _puts_L1_print:
1139   0B24 1E            mov al, [d]
1140   0B25 B9 00         cmp al, 0
1141   0B27 C6 33 0B      jz _puts_END_print
1142   0B2A 23            mov ah, al
1143   0B2B 19 00         mov al, 0
1144   0B2D 05 03         syscall sys_io
1145   0B2F 79            inc d
1146   0B30 0A 24 0B      jmp _puts_L1_print
1147   0B33             _puts_END_print:
1148   0B33             ; --- END INLINE ASM SEGMENT
1149   0B33 F9            leave
1150   0B34 09            ret
1151   0B35             
1152   0B35             print_signed:
1153   0B35 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1154   0B38             ; char digits[5]; 
1155   0B38 52 05 00      sub sp, 5
1156   0B3B             ; int i = 0; 
1157   0B3B 52 02 00      sub sp, 2
1158   0B3E             ; --- START LOCAL VAR INITIALIZATION
1159   0B3E FA FA FF      lea d, [bp + -6] ; $i
1160   0B41 DA            push d
1161   0B42 FD 2E 00 00   mov32 cb, $00000000
1161   0B46 00 00 
1162   0B48 E7            pop d
1163   0B49 FD 43         mov [d], b
1164   0B4B             ; --- END LOCAL VAR INITIALIZATION
1165   0B4B             ; if (num < 0) { 
1166   0B4B             _if29_cond:
1167   0B4B FA 05 00      lea d, [bp + 5] ; $num
1168   0B4E 2A            mov b, [d]
1169   0B4F 38 00 00      mov c, 0
1170   0B52             ; --- START RELATIONAL
1171   0B52 D7            push a
1172   0B53 11            mov a, b
1173   0B54 FD 2E 00 00   mov32 cb, $00000000
1173   0B58 00 00 
1174   0B5A B0            cmp a, b
1175   0B5B FD 73         slt ; < (signed)
1176   0B5D E4            pop a
1177   0B5E             ; --- END RELATIONAL
1178   0B5E C0 00 00      cmp b, 0
1179   0B61 C6 84 0B      je _if29_else
1180   0B64             _if29_TRUE:
1181   0B64             ; putchar('-'); 
1182   0B64             ; --- START FUNCTION CALL
1183   0B64 FD 2E 2D 00   mov32 cb, $0000002d
1183   0B68 00 00 
1184   0B6A DD            push bl
1185   0B6B 07 5B 09      call putchar
1186   0B6E 51 01 00      add sp, 1
1187   0B71             ; --- END FUNCTION CALL
1188   0B71             ; num = -num; 
1189   0B71 FA 05 00      lea d, [bp + 5] ; $num
1190   0B74 DA            push d
1191   0B75 FA 05 00      lea d, [bp + 5] ; $num
1192   0B78 2A            mov b, [d]
1193   0B79 38 00 00      mov c, 0
1194   0B7C FD 97         neg b
1195   0B7E E7            pop d
1196   0B7F FD 43         mov [d], b
1197   0B81 0A AF 0B      jmp _if29_exit
1198   0B84             _if29_else:
1199   0B84             ; if (num == 0) { 
1200   0B84             _if30_cond:
1201   0B84 FA 05 00      lea d, [bp + 5] ; $num
1202   0B87 2A            mov b, [d]
1203   0B88 38 00 00      mov c, 0
1204   0B8B             ; --- START RELATIONAL
1205   0B8B D7            push a
1206   0B8C 11            mov a, b
1207   0B8D FD 2E 00 00   mov32 cb, $00000000
1207   0B91 00 00 
1208   0B93 B0            cmp a, b
1209   0B94 FD 71         seq ; ==
1210   0B96 E4            pop a
1211   0B97             ; --- END RELATIONAL
1212   0B97 C0 00 00      cmp b, 0
1213   0B9A C6 AF 0B      je _if30_exit
1214   0B9D             _if30_TRUE:
1215   0B9D             ; putchar('0'); 
1216   0B9D             ; --- START FUNCTION CALL
1217   0B9D FD 2E 30 00   mov32 cb, $00000030
1217   0BA1 00 00 
1218   0BA3 DD            push bl
1219   0BA4 07 5B 09      call putchar
1220   0BA7 51 01 00      add sp, 1
1221   0BAA             ; --- END FUNCTION CALL
1222   0BAA             ; return; 
1223   0BAA F9            leave
1224   0BAB 09            ret
1225   0BAC 0A AF 0B      jmp _if30_exit
1226   0BAF             _if30_exit:
1227   0BAF             _if29_exit:
1228   0BAF             ; while (num > 0) { 
1229   0BAF             _while31_cond:
1230   0BAF FA 05 00      lea d, [bp + 5] ; $num
1231   0BB2 2A            mov b, [d]
1232   0BB3 38 00 00      mov c, 0
1233   0BB6             ; --- START RELATIONAL
1234   0BB6 D7            push a
1235   0BB7 11            mov a, b
1236   0BB8 FD 2E 00 00   mov32 cb, $00000000
1236   0BBC 00 00 
1237   0BBE B0            cmp a, b
1238   0BBF FD 7F         sgt ; >
1239   0BC1 E4            pop a
1240   0BC2             ; --- END RELATIONAL
1241   0BC2 C0 00 00      cmp b, 0
1242   0BC5 C6 3C 0C      je _while31_exit
1243   0BC8             _while31_block:
1244   0BC8             ; digits[i] = '0' + (num % 10); 
1245   0BC8 FA FC FF      lea d, [bp + -4] ; $digits
1246   0BCB D7            push a
1247   0BCC DA            push d
1248   0BCD FA FA FF      lea d, [bp + -6] ; $i
1249   0BD0 2A            mov b, [d]
1250   0BD1 38 00 00      mov c, 0
1251   0BD4 E7            pop d
1252   0BD5 5A            add d, b
1253   0BD6 E4            pop a
1254   0BD7 DA            push d
1255   0BD8 FD 2E 30 00   mov32 cb, $00000030
1255   0BDC 00 00 
1256   0BDE             ; --- START TERMS
1257   0BDE D7            push a
1258   0BDF 11            mov a, b
1259   0BE0 FA 05 00      lea d, [bp + 5] ; $num
1260   0BE3 2A            mov b, [d]
1261   0BE4 38 00 00      mov c, 0
1262   0BE7             ; --- START FACTORS
1263   0BE7 D7            push a
1264   0BE8 FD D8         push g
1265   0BEA 11            mov a, b
1266   0BEB FD 7A         mov g, c
1267   0BED FD 2E 0A 00   mov32 cb, $0000000a
1267   0BF1 00 00 
1268   0BF3 FD D8         push g ; save 'g' as the div instruction uses it
1269   0BF5 AE            div a, b ; %, a: quotient, b: remainder
1270   0BF6 11            mov a, b
1271   0BF7 FD F1         pop g
1272   0BF9 FD 38         mov c, g
1273   0BFB 27            mov b, a
1274   0BFC FD F1         pop g
1275   0BFE E4            pop a
1276   0BFF             ; --- END FACTORS
1277   0BFF 56            add b, a
1278   0C00 E4            pop a
1279   0C01             ; --- END TERMS
1280   0C01 E7            pop d
1281   0C02 FD 3E         mov [d], bl
1282   0C04             ; num = num / 10; 
1283   0C04 FA 05 00      lea d, [bp + 5] ; $num
1284   0C07 DA            push d
1285   0C08 FA 05 00      lea d, [bp + 5] ; $num
1286   0C0B 2A            mov b, [d]
1287   0C0C 38 00 00      mov c, 0
1288   0C0F             ; --- START FACTORS
1289   0C0F D7            push a
1290   0C10 FD D8         push g
1291   0C12 11            mov a, b
1292   0C13 FD 7A         mov g, c
1293   0C15 FD 2E 0A 00   mov32 cb, $0000000a
1293   0C19 00 00 
1294   0C1B FD D8         push g ; save 'g' as the div instruction uses it
1295   0C1D AE            div a, b ; /, a: quotient, b: remainder
1296   0C1E FD F1         pop g
1297   0C20 FD 38         mov c, g
1298   0C22 27            mov b, a
1299   0C23 FD F1         pop g
1300   0C25 E4            pop a
1301   0C26             ; --- END FACTORS
1302   0C26 E7            pop d
1303   0C27 FD 43         mov [d], b
1304   0C29             ; i++; 
1305   0C29 FA FA FF      lea d, [bp + -6] ; $i
1306   0C2C 2A            mov b, [d]
1307   0C2D 38 00 00      mov c, 0
1308   0C30 11            mov a, b
1309   0C31 FD 77         inc b
1310   0C33 FA FA FF      lea d, [bp + -6] ; $i
1311   0C36 FD 43         mov [d], b
1312   0C38 27            mov b, a
1313   0C39 0A AF 0B      jmp _while31_cond
1314   0C3C             _while31_exit:
1315   0C3C             ; while (i > 0) { 
1316   0C3C             _while38_cond:
1317   0C3C FA FA FF      lea d, [bp + -6] ; $i
1318   0C3F 2A            mov b, [d]
1319   0C40 38 00 00      mov c, 0
1320   0C43             ; --- START RELATIONAL
1321   0C43 D7            push a
1322   0C44 11            mov a, b
1323   0C45 FD 2E 00 00   mov32 cb, $00000000
1323   0C49 00 00 
1324   0C4B B0            cmp a, b
1325   0C4C FD 7F         sgt ; >
1326   0C4E E4            pop a
1327   0C4F             ; --- END RELATIONAL
1328   0C4F C0 00 00      cmp b, 0
1329   0C52 C6 84 0C      je _while38_exit
1330   0C55             _while38_block:
1331   0C55             ; i--; 
1332   0C55 FA FA FF      lea d, [bp + -6] ; $i
1333   0C58 2A            mov b, [d]
1334   0C59 38 00 00      mov c, 0
1335   0C5C 11            mov a, b
1336   0C5D FD 7D         dec b
1337   0C5F FA FA FF      lea d, [bp + -6] ; $i
1338   0C62 FD 43         mov [d], b
1339   0C64 27            mov b, a
1340   0C65             ; putchar(digits[i]); 
1341   0C65             ; --- START FUNCTION CALL
1342   0C65 FA FC FF      lea d, [bp + -4] ; $digits
1343   0C68 D7            push a
1344   0C69 DA            push d
1345   0C6A FA FA FF      lea d, [bp + -6] ; $i
1346   0C6D 2A            mov b, [d]
1347   0C6E 38 00 00      mov c, 0
1348   0C71 E7            pop d
1349   0C72 5A            add d, b
1350   0C73 E4            pop a
1351   0C74 32            mov bl, [d]
1352   0C75 A7 00         mov bh, 0
1353   0C77 38 00 00      mov c, 0
1354   0C7A DD            push bl
1355   0C7B 07 5B 09      call putchar
1356   0C7E 51 01 00      add sp, 1
1357   0C81             ; --- END FUNCTION CALL
1358   0C81 0A 3C 0C      jmp _while38_cond
1359   0C84             _while38_exit:
1360   0C84 F9            leave
1361   0C85 09            ret
1362   0C86             
1363   0C86             print_unsigned:
1364   0C86 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1365   0C89             ; char digits[5]; 
1366   0C89 52 05 00      sub sp, 5
1367   0C8C             ; int i; 
1368   0C8C 52 02 00      sub sp, 2
1369   0C8F             ; i = 0; 
1370   0C8F FA FA FF      lea d, [bp + -6] ; $i
1371   0C92 DA            push d
1372   0C93 FD 2E 00 00   mov32 cb, $00000000
1372   0C97 00 00 
1373   0C99 E7            pop d
1374   0C9A FD 43         mov [d], b
1375   0C9C             ; if(num == 0){ 
1376   0C9C             _if39_cond:
1377   0C9C FA 05 00      lea d, [bp + 5] ; $num
1378   0C9F 2A            mov b, [d]
1379   0CA0 38 00 00      mov c, 0
1380   0CA3             ; --- START RELATIONAL
1381   0CA3 D7            push a
1382   0CA4 11            mov a, b
1383   0CA5 FD 2E 00 00   mov32 cb, $00000000
1383   0CA9 00 00 
1384   0CAB B0            cmp a, b
1385   0CAC FD 71         seq ; ==
1386   0CAE E4            pop a
1387   0CAF             ; --- END RELATIONAL
1388   0CAF C0 00 00      cmp b, 0
1389   0CB2 C6 C7 0C      je _if39_exit
1390   0CB5             _if39_TRUE:
1391   0CB5             ; putchar('0'); 
1392   0CB5             ; --- START FUNCTION CALL
1393   0CB5 FD 2E 30 00   mov32 cb, $00000030
1393   0CB9 00 00 
1394   0CBB DD            push bl
1395   0CBC 07 5B 09      call putchar
1396   0CBF 51 01 00      add sp, 1
1397   0CC2             ; --- END FUNCTION CALL
1398   0CC2             ; return; 
1399   0CC2 F9            leave
1400   0CC3 09            ret
1401   0CC4 0A C7 0C      jmp _if39_exit
1402   0CC7             _if39_exit:
1403   0CC7             ; while (num > 0) { 
1404   0CC7             _while40_cond:
1405   0CC7 FA 05 00      lea d, [bp + 5] ; $num
1406   0CCA 2A            mov b, [d]
1407   0CCB 38 00 00      mov c, 0
1408   0CCE             ; --- START RELATIONAL
1409   0CCE D7            push a
1410   0CCF 11            mov a, b
1411   0CD0 FD 2E 00 00   mov32 cb, $00000000
1411   0CD4 00 00 
1412   0CD6 B0            cmp a, b
1413   0CD7 FD 81         sgu ; > (unsigned)
1414   0CD9 E4            pop a
1415   0CDA             ; --- END RELATIONAL
1416   0CDA C0 00 00      cmp b, 0
1417   0CDD C6 54 0D      je _while40_exit
1418   0CE0             _while40_block:
1419   0CE0             ; digits[i] = '0' + (num % 10); 
1420   0CE0 FA FC FF      lea d, [bp + -4] ; $digits
1421   0CE3 D7            push a
1422   0CE4 DA            push d
1423   0CE5 FA FA FF      lea d, [bp + -6] ; $i
1424   0CE8 2A            mov b, [d]
1425   0CE9 38 00 00      mov c, 0
1426   0CEC E7            pop d
1427   0CED 5A            add d, b
1428   0CEE E4            pop a
1429   0CEF DA            push d
1430   0CF0 FD 2E 30 00   mov32 cb, $00000030
1430   0CF4 00 00 
1431   0CF6             ; --- START TERMS
1432   0CF6 D7            push a
1433   0CF7 11            mov a, b
1434   0CF8 FA 05 00      lea d, [bp + 5] ; $num
1435   0CFB 2A            mov b, [d]
1436   0CFC 38 00 00      mov c, 0
1437   0CFF             ; --- START FACTORS
1438   0CFF D7            push a
1439   0D00 FD D8         push g
1440   0D02 11            mov a, b
1441   0D03 FD 7A         mov g, c
1442   0D05 FD 2E 0A 00   mov32 cb, $0000000a
1442   0D09 00 00 
1443   0D0B FD D8         push g ; save 'g' as the div instruction uses it
1444   0D0D AE            div a, b ; %, a: quotient, b: remainder
1445   0D0E 11            mov a, b
1446   0D0F FD F1         pop g
1447   0D11 FD 38         mov c, g
1448   0D13 27            mov b, a
1449   0D14 FD F1         pop g
1450   0D16 E4            pop a
1451   0D17             ; --- END FACTORS
1452   0D17 56            add b, a
1453   0D18 E4            pop a
1454   0D19             ; --- END TERMS
1455   0D19 E7            pop d
1456   0D1A FD 3E         mov [d], bl
1457   0D1C             ; num = num / 10; 
1458   0D1C FA 05 00      lea d, [bp + 5] ; $num
1459   0D1F DA            push d
1460   0D20 FA 05 00      lea d, [bp + 5] ; $num
1461   0D23 2A            mov b, [d]
1462   0D24 38 00 00      mov c, 0
1463   0D27             ; --- START FACTORS
1464   0D27 D7            push a
1465   0D28 FD D8         push g
1466   0D2A 11            mov a, b
1467   0D2B FD 7A         mov g, c
1468   0D2D FD 2E 0A 00   mov32 cb, $0000000a
1468   0D31 00 00 
1469   0D33 FD D8         push g ; save 'g' as the div instruction uses it
1470   0D35 AE            div a, b ; /, a: quotient, b: remainder
1471   0D36 FD F1         pop g
1472   0D38 FD 38         mov c, g
1473   0D3A 27            mov b, a
1474   0D3B FD F1         pop g
1475   0D3D E4            pop a
1476   0D3E             ; --- END FACTORS
1477   0D3E E7            pop d
1478   0D3F FD 43         mov [d], b
1479   0D41             ; i++; 
1480   0D41 FA FA FF      lea d, [bp + -6] ; $i
1481   0D44 2A            mov b, [d]
1482   0D45 38 00 00      mov c, 0
1483   0D48 11            mov a, b
1484   0D49 FD 77         inc b
1485   0D4B FA FA FF      lea d, [bp + -6] ; $i
1486   0D4E FD 43         mov [d], b
1487   0D50 27            mov b, a
1488   0D51 0A C7 0C      jmp _while40_cond
1489   0D54             _while40_exit:
1490   0D54             ; while (i > 0) { 
1491   0D54             _while47_cond:
1492   0D54 FA FA FF      lea d, [bp + -6] ; $i
1493   0D57 2A            mov b, [d]
1494   0D58 38 00 00      mov c, 0
1495   0D5B             ; --- START RELATIONAL
1496   0D5B D7            push a
1497   0D5C 11            mov a, b
1498   0D5D FD 2E 00 00   mov32 cb, $00000000
1498   0D61 00 00 
1499   0D63 B0            cmp a, b
1500   0D64 FD 7F         sgt ; >
1501   0D66 E4            pop a
1502   0D67             ; --- END RELATIONAL
1503   0D67 C0 00 00      cmp b, 0
1504   0D6A C6 9C 0D      je _while47_exit
1505   0D6D             _while47_block:
1506   0D6D             ; i--; 
1507   0D6D FA FA FF      lea d, [bp + -6] ; $i
1508   0D70 2A            mov b, [d]
1509   0D71 38 00 00      mov c, 0
1510   0D74 11            mov a, b
1511   0D75 FD 7D         dec b
1512   0D77 FA FA FF      lea d, [bp + -6] ; $i
1513   0D7A FD 43         mov [d], b
1514   0D7C 27            mov b, a
1515   0D7D             ; putchar(digits[i]); 
1516   0D7D             ; --- START FUNCTION CALL
1517   0D7D FA FC FF      lea d, [bp + -4] ; $digits
1518   0D80 D7            push a
1519   0D81 DA            push d
1520   0D82 FA FA FF      lea d, [bp + -6] ; $i
1521   0D85 2A            mov b, [d]
1522   0D86 38 00 00      mov c, 0
1523   0D89 E7            pop d
1524   0D8A 5A            add d, b
1525   0D8B E4            pop a
1526   0D8C 32            mov bl, [d]
1527   0D8D A7 00         mov bh, 0
1528   0D8F 38 00 00      mov c, 0
1529   0D92 DD            push bl
1530   0D93 07 5B 09      call putchar
1531   0D96 51 01 00      add sp, 1
1532   0D99             ; --- END FUNCTION CALL
1533   0D99 0A 54 0D      jmp _while47_cond
1534   0D9C             _while47_exit:
1535   0D9C F9            leave
1536   0D9D 09            ret
1537   0D9E             
1538   0D9E             printx16:
1539   0D9E F8 00 00      enter 0 ; (push bp; mov bp, sp)
1540   0DA1             ; --- BEGIN INLINE ASM SEGMENT
1541   0DA1 FA 05 00      lea d, [bp + 5] ; $hex
1542   0DA4 2A            mov b, [d]
1543   0DA5             print_u16x_printx16:
1544   0DA5 DD            push bl
1545   0DA6 30            mov bl, bh
1546   0DA7 07 C4 0D      call _itoa_printx16        ; convert bh to char in A
1547   0DAA 2F            mov bl, al        ; save al
1548   0DAB 19 00         mov al, 0
1549   0DAD 05 03         syscall sys_io        ; display AH
1550   0DAF 24            mov ah, bl        ; retrieve al
1551   0DB0 19 00         mov al, 0
1552   0DB2 05 03         syscall sys_io        ; display AL
1553   0DB4 EA            pop bl
1554   0DB5 07 C4 0D      call _itoa_printx16        ; convert bh to char in A
1555   0DB8 2F            mov bl, al        ; save al
1556   0DB9 19 00         mov al, 0
1557   0DBB 05 03         syscall sys_io        ; display AH
1558   0DBD 24            mov ah, bl        ; retrieve al
1559   0DBE 19 00         mov al, 0
1560   0DC0 05 03         syscall sys_io        ; display AL
1561   0DC2             ; --- END INLINE ASM SEGMENT
1562   0DC2             ; return; 
1563   0DC2 F9            leave
1564   0DC3 09            ret
1565   0DC4             ; --- BEGIN INLINE ASM SEGMENT
1566   0DC4             _itoa_printx16:
1567   0DC4 DA            push d
1568   0DC5 D8            push b
1569   0DC6 A7 00         mov bh, 0
1570   0DC8 FD A4 04      shr bl, 4  
1571   0DCB 74            mov d, b
1572   0DCC 1F DE 0D      mov al, [d + s_hex_digits_printx16]
1573   0DCF 23            mov ah, al
1574   0DD0 E5            pop b
1575   0DD1 D8            push b
1576   0DD2 A7 00         mov bh, 0
1577   0DD4 FD 87 0F      and bl, $0F
1578   0DD7 74            mov d, b
1579   0DD8 1F DE 0D      mov al, [d + s_hex_digits_printx16]
1580   0DDB E5            pop b
1581   0DDC E7            pop d
1582   0DDD 09            ret
1583   0DDE 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1583   0DE2 34 35 36 37 
1583   0DE6 38 39 41 42 
1583   0DEA 43 44 45 46 
1584   0DEE             ; --- END INLINE ASM SEGMENT
1585   0DEE F9            leave
1586   0DEF 09            ret
1587   0DF0             ; --- END TEXT SEGMENT
1588   0DF0             
1589   0DF0             ; --- BEGIN DATA SEGMENT
1590   0DF0 00 00 00 00 _arg_data: .fill 512, 0
1590   0DF4 00 00 00 00 
1590   0DF8 00 00 00 00 
1590   0DFC 00 00 00 00 
1590   0E00 00 00 00 00 
1590   0E04 00 00 00 00 
1590   0E08 00 00 00 00 
1590   0E0C 00 00 00 00 
1590   0E10 00 00 00 00 
1590   0E14 00 00 00 00 
1590   0E18 00 00 00 00 
1590   0E1C 00 00 00 00 
1590   0E20 00 00 00 00 
1590   0E24 00 00 00 00 
1590   0E28 00 00 00 00 
1590   0E2C 00 00 00 00 
1590   0E30 00 00 00 00 
1590   0E34 00 00 00 00 
1590   0E38 00 00 00 00 
1590   0E3C 00 00 00 00 
1590   0E40 00 00 00 00 
1590   0E44 00 00 00 00 
1590   0E48 00 00 00 00 
1590   0E4C 00 00 00 00 
1590   0E50 00 00 00 00 
1590   0E54 00 00 00 00 
1590   0E58 00 00 00 00 
1590   0E5C 00 00 00 00 
1590   0E60 00 00 00 00 
1590   0E64 00 00 00 00 
1590   0E68 00 00 00 00 
1590   0E6C 00 00 00 00 
1590   0E70 00 00 00 00 
1590   0E74 00 00 00 00 
1590   0E78 00 00 00 00 
1590   0E7C 00 00 00 00 
1590   0E80 00 00 00 00 
1590   0E84 00 00 00 00 
1590   0E88 00 00 00 00 
1590   0E8C 00 00 00 00 
1590   0E90 00 00 00 00 
1590   0E94 00 00 00 00 
1590   0E98 00 00 00 00 
1590   0E9C 00 00 00 00 
1590   0EA0 00 00 00 00 
1590   0EA4 00 00 00 00 
1590   0EA8 00 00 00 00 
1590   0EAC 00 00 00 00 
1590   0EB0 00 00 00 00 
1590   0EB4 00 00 00 00 
1590   0EB8 00 00 00 00 
1590   0EBC 00 00 00 00 
1590   0EC0 00 00 00 00 
1590   0EC4 00 00 00 00 
1590   0EC8 00 00 00 00 
1590   0ECC 00 00 00 00 
1590   0ED0 00 00 00 00 
1590   0ED4 00 00 00 00 
1590   0ED8 00 00 00 00 
1590   0EDC 00 00 00 00 
1590   0EE0 00 00 00 00 
1590   0EE4 00 00 00 00 
1590   0EE8 00 00 00 00 
1590   0EEC 00 00 00 00 
1590   0EF0 00 00 00 00 
1590   0EF4 00 00 00 00 
1590   0EF8 00 00 00 00 
1590   0EFC 00 00 00 00 
1590   0F00 00 00 00 00 
1590   0F04 00 00 00 00 
1590   0F08 00 00 00 00 
1590   0F0C 00 00 00 00 
1590   0F10 00 00 00 00 
1590   0F14 00 00 00 00 
1590   0F18 00 00 00 00 
1590   0F1C 00 00 00 00 
1590   0F20 00 00 00 00 
1590   0F24 00 00 00 00 
1590   0F28 00 00 00 00 
1590   0F2C 00 00 00 00 
1590   0F30 00 00 00 00 
1590   0F34 00 00 00 00 
1590   0F38 00 00 00 00 
1590   0F3C 00 00 00 00 
1590   0F40 00 00 00 00 
1590   0F44 00 00 00 00 
1590   0F48 00 00 00 00 
1590   0F4C 00 00 00 00 
1590   0F50 00 00 00 00 
1590   0F54 00 00 00 00 
1590   0F58 00 00 00 00 
1590   0F5C 00 00 00 00 
1590   0F60 00 00 00 00 
1590   0F64 00 00 00 00 
1590   0F68 00 00 00 00 
1590   0F6C 00 00 00 00 
1590   0F70 00 00 00 00 
1590   0F74 00 00 00 00 
1590   0F78 00 00 00 00 
1590   0F7C 00 00 00 00 
1590   0F80 00 00 00 00 
1590   0F84 00 00 00 00 
1590   0F88 00 00 00 00 
1590   0F8C 00 00 00 00 
1590   0F90 00 00 00 00 
1590   0F94 00 00 00 00 
1590   0F98 00 00 00 00 
1590   0F9C 00 00 00 00 
1590   0FA0 00 00 00 00 
1590   0FA4 00 00 00 00 
1590   0FA8 00 00 00 00 
1590   0FAC 00 00 00 00 
1590   0FB0 00 00 00 00 
1590   0FB4 00 00 00 00 
1590   0FB8 00 00 00 00 
1590   0FBC 00 00 00 00 
1590   0FC0 00 00 00 00 
1590   0FC4 00 00 00 00 
1590   0FC8 00 00 00 00 
1590   0FCC 00 00 00 00 
1590   0FD0 00 00 00 00 
1590   0FD4 00 00 00 00 
1590   0FD8 00 00 00 00 
1590   0FDC 00 00 00 00 
1590   0FE0 00 00 00 00 
1590   0FE4 00 00 00 00 
1590   0FE8 00 00 00 00 
1590   0FEC 00 00 00 00 
1591   0FF0 00 00       _tok: .fill 2, 0
1592   0FF2 00 00       _toktype: .fill 2, 0
1593   0FF4 00 00       _prog: .fill 2, 0
1594   0FF6 00 00 00 00 _token_data: .fill 256, 0
1594   0FFA 00 00 00 00 
1594   0FFE 00 00 00 00 
1594   1002 00 00 00 00 
1594   1006 00 00 00 00 
1594   100A 00 00 00 00 
1594   100E 00 00 00 00 
1594   1012 00 00 00 00 
1594   1016 00 00 00 00 
1594   101A 00 00 00 00 
1594   101E 00 00 00 00 
1594   1022 00 00 00 00 
1594   1026 00 00 00 00 
1594   102A 00 00 00 00 
1594   102E 00 00 00 00 
1594   1032 00 00 00 00 
1594   1036 00 00 00 00 
1594   103A 00 00 00 00 
1594   103E 00 00 00 00 
1594   1042 00 00 00 00 
1594   1046 00 00 00 00 
1594   104A 00 00 00 00 
1594   104E 00 00 00 00 
1594   1052 00 00 00 00 
1594   1056 00 00 00 00 
1594   105A 00 00 00 00 
1594   105E 00 00 00 00 
1594   1062 00 00 00 00 
1594   1066 00 00 00 00 
1594   106A 00 00 00 00 
1594   106E 00 00 00 00 
1594   1072 00 00 00 00 
1594   1076 00 00 00 00 
1594   107A 00 00 00 00 
1594   107E 00 00 00 00 
1594   1082 00 00 00 00 
1594   1086 00 00 00 00 
1594   108A 00 00 00 00 
1594   108E 00 00 00 00 
1594   1092 00 00 00 00 
1594   1096 00 00 00 00 
1594   109A 00 00 00 00 
1594   109E 00 00 00 00 
1594   10A2 00 00 00 00 
1594   10A6 00 00 00 00 
1594   10AA 00 00 00 00 
1594   10AE 00 00 00 00 
1594   10B2 00 00 00 00 
1594   10B6 00 00 00 00 
1594   10BA 00 00 00 00 
1594   10BE 00 00 00 00 
1594   10C2 00 00 00 00 
1594   10C6 00 00 00 00 
1594   10CA 00 00 00 00 
1594   10CE 00 00 00 00 
1594   10D2 00 00 00 00 
1594   10D6 00 00 00 00 
1594   10DA 00 00 00 00 
1594   10DE 00 00 00 00 
1594   10E2 00 00 00 00 
1594   10E6 00 00 00 00 
1594   10EA 00 00 00 00 
1594   10EE 00 00 00 00 
1594   10F2 00 00 00 00 
1595   10F6 00 00 00 00 _string_const_data: .fill 256, 0
1595   10FA 00 00 00 00 
1595   10FE 00 00 00 00 
1595   1102 00 00 00 00 
1595   1106 00 00 00 00 
1595   110A 00 00 00 00 
1595   110E 00 00 00 00 
1595   1112 00 00 00 00 
1595   1116 00 00 00 00 
1595   111A 00 00 00 00 
1595   111E 00 00 00 00 
1595   1122 00 00 00 00 
1595   1126 00 00 00 00 
1595   112A 00 00 00 00 
1595   112E 00 00 00 00 
1595   1132 00 00 00 00 
1595   1136 00 00 00 00 
1595   113A 00 00 00 00 
1595   113E 00 00 00 00 
1595   1142 00 00 00 00 
1595   1146 00 00 00 00 
1595   114A 00 00 00 00 
1595   114E 00 00 00 00 
1595   1152 00 00 00 00 
1595   1156 00 00 00 00 
1595   115A 00 00 00 00 
1595   115E 00 00 00 00 
1595   1162 00 00 00 00 
1595   1166 00 00 00 00 
1595   116A 00 00 00 00 
1595   116E 00 00 00 00 
1595   1172 00 00 00 00 
1595   1176 00 00 00 00 
1595   117A 00 00 00 00 
1595   117E 00 00 00 00 
1595   1182 00 00 00 00 
1595   1186 00 00 00 00 
1595   118A 00 00 00 00 
1595   118E 00 00 00 00 
1595   1192 00 00 00 00 
1595   1196 00 00 00 00 
1595   119A 00 00 00 00 
1595   119E 00 00 00 00 
1595   11A2 00 00 00 00 
1595   11A6 00 00 00 00 
1595   11AA 00 00 00 00 
1595   11AE 00 00 00 00 
1595   11B2 00 00 00 00 
1595   11B6 00 00 00 00 
1595   11BA 00 00 00 00 
1595   11BE 00 00 00 00 
1595   11C2 00 00 00 00 
1595   11C6 00 00 00 00 
1595   11CA 00 00 00 00 
1595   11CE 00 00 00 00 
1595   11D2 00 00 00 00 
1595   11D6 00 00 00 00 
1595   11DA 00 00 00 00 
1595   11DE 00 00 00 00 
1595   11E2 00 00 00 00 
1595   11E6 00 00 00 00 
1595   11EA 00 00 00 00 
1595   11EE 00 00 00 00 
1595   11F2 00 00 00 00 
1596   11F6 3E 20 00    _s0: .db "> ", 0
1597   11F9 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1597   11FD 70 65 63 74 
1597   1201 65 64 20 66 
1597   1205 6F 72 6D 61 
1597   1209 74 20 69 6E 
1597   120D 20 70 72 69 
1597   1211 6E 74 66 2E 
1597   1215 00 
1598   1216 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1598   121A 72 3A 20 55 
1598   121E 6E 6B 6E 6F 
1598   1222 77 6E 20 61 
1598   1226 72 67 75 6D 
1598   122A 65 6E 74 20 
1598   122E 74 79 70 65 
1598   1232 2E 0A 00 
1599   1235             
1600   1235 37 12       _heap_top: .dw _heap
1601   1237 00          _heap: .db 0
1602   1238             ; --- END DATA SEGMENT
1603   1238             
1604   1238             .end
tasm: Number of errors = 0
