0001   0000             ; --- FILENAME: ctestsuite/testsuite4.c
0002   0000             ; --- DATE:     24-10-2025 at 20:26:42
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; int pass[10]; 
0012   0408 52 14 00      sub sp, 20
0013   040B             ; int i; 
0014   040B 52 02 00      sub sp, 2
0015   040E             ; int nbr_tests = 10; 
0016   040E 52 02 00      sub sp, 2
0017   0411             ; --- START LOCAL VAR INITIALIZATION
0018   0411 FA E9 FF      lea d, [bp + -23] ; $nbr_tests
0019   0414 DA            push d
0020   0415 FD 2E 0A 00   mov32 cb, $0000000a
0020   0419 00 00 
0021   041B E7            pop d
0022   041C FD 43         mov [d], b
0023   041E             ; --- END LOCAL VAR INITIALIZATION
0024   041E             ; for(i = 0; i < nbr_tests; i++){ 
0025   041E             _for1_init:
0026   041E FA EB FF      lea d, [bp + -21] ; $i
0027   0421 DA            push d
0028   0422 FD 2E 00 00   mov32 cb, $00000000
0028   0426 00 00 
0029   0428 E7            pop d
0030   0429 FD 43         mov [d], b
0031   042B             _for1_cond:
0032   042B FA EB FF      lea d, [bp + -21] ; $i
0033   042E 2A            mov b, [d]
0034   042F 38 00 00      mov c, 0
0035   0432             ; --- START RELATIONAL
0036   0432 D7            push a
0037   0433 11            mov a, b
0038   0434 FA E9 FF      lea d, [bp + -23] ; $nbr_tests
0039   0437 2A            mov b, [d]
0040   0438 38 00 00      mov c, 0
0041   043B B0            cmp a, b
0042   043C FD 73         slt ; < (signed)
0043   043E E4            pop a
0044   043F             ; --- END RELATIONAL
0045   043F C0 00 00      cmp b, 0
0046   0442 C6 74 04      je _for1_exit
0047   0445             _for1_block:
0048   0445             ; pass[i] = -1; 
0049   0445 FA ED FF      lea d, [bp + -19] ; $pass
0050   0448 D7            push a
0051   0449 DA            push d
0052   044A FA EB FF      lea d, [bp + -21] ; $i
0053   044D 2A            mov b, [d]
0054   044E 38 00 00      mov c, 0
0055   0451 E7            pop d
0056   0452 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0057   0456 E4            pop a
0058   0457 DA            push d
0059   0458 FD 2E FF FF   mov32 cb, $ffffffff
0059   045C FF FF 
0060   045E E7            pop d
0061   045F FD 43         mov [d], b
0062   0461             _for1_update:
0063   0461 FA EB FF      lea d, [bp + -21] ; $i
0064   0464 2A            mov b, [d]
0065   0465 38 00 00      mov c, 0
0066   0468 11            mov a, b
0067   0469 FD 77         inc b
0068   046B FA EB FF      lea d, [bp + -21] ; $i
0069   046E FD 43         mov [d], b
0070   0470 27            mov b, a
0071   0471 0A 2B 04      jmp _for1_cond
0072   0474             _for1_exit:
0073   0474             ; pass[0] = test0(); 
0074   0474 FA ED FF      lea d, [bp + -19] ; $pass
0075   0477 D7            push a
0076   0478 DA            push d
0077   0479 FD 2E 00 00   mov32 cb, $00000000
0077   047D 00 00 
0078   047F E7            pop d
0079   0480 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0080   0484 E4            pop a
0081   0485 DA            push d
0082   0486             ; --- START FUNCTION CALL
0083   0486 07 F7 04      call test0
0084   0489 E7            pop d
0085   048A FD 43         mov [d], b
0086   048C             ; for(i = 0; i < nbr_tests; i++) 
0087   048C             _for2_init:
0088   048C FA EB FF      lea d, [bp + -21] ; $i
0089   048F DA            push d
0090   0490 FD 2E 00 00   mov32 cb, $00000000
0090   0494 00 00 
0091   0496 E7            pop d
0092   0497 FD 43         mov [d], b
0093   0499             _for2_cond:
0094   0499 FA EB FF      lea d, [bp + -21] ; $i
0095   049C 2A            mov b, [d]
0096   049D 38 00 00      mov c, 0
0097   04A0             ; --- START RELATIONAL
0098   04A0 D7            push a
0099   04A1 11            mov a, b
0100   04A2 FA E9 FF      lea d, [bp + -23] ; $nbr_tests
0101   04A5 2A            mov b, [d]
0102   04A6 38 00 00      mov c, 0
0103   04A9 B0            cmp a, b
0104   04AA FD 73         slt ; < (signed)
0105   04AC E4            pop a
0106   04AD             ; --- END RELATIONAL
0107   04AD C0 00 00      cmp b, 0
0108   04B0 C6 F5 04      je _for2_exit
0109   04B3             _for2_block:
0110   04B3             ; printf("Test %d, Result: %d\n", i, pass[i]); 
0111   04B3             ; --- START FUNCTION CALL
0112   04B3 FA ED FF      lea d, [bp + -19] ; $pass
0113   04B6 D7            push a
0114   04B7 DA            push d
0115   04B8 FA EB FF      lea d, [bp + -21] ; $i
0116   04BB 2A            mov b, [d]
0117   04BC 38 00 00      mov c, 0
0118   04BF E7            pop d
0119   04C0 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0120   04C4 E4            pop a
0121   04C5 2A            mov b, [d]
0122   04C6 38 00 00      mov c, 0
0123   04C9 FD AB         swp b
0124   04CB D8            push b
0125   04CC FA EB FF      lea d, [bp + -21] ; $i
0126   04CF 2A            mov b, [d]
0127   04D0 38 00 00      mov c, 0
0128   04D3 FD AB         swp b
0129   04D5 D8            push b
0130   04D6 26 1D 0F      mov b, _s0 ; "Test %d, Result: %d\n"
0131   04D9 FD AB         swp b
0132   04DB D8            push b
0133   04DC 07 C5 05      call printf
0134   04DF 51 06 00      add sp, 6
0135   04E2             ; --- END FUNCTION CALL
0136   04E2             _for2_update:
0137   04E2 FA EB FF      lea d, [bp + -21] ; $i
0138   04E5 2A            mov b, [d]
0139   04E6 38 00 00      mov c, 0
0140   04E9 11            mov a, b
0141   04EA FD 77         inc b
0142   04EC FA EB FF      lea d, [bp + -21] ; $i
0143   04EF FD 43         mov [d], b
0144   04F1 27            mov b, a
0145   04F2 0A 99 04      jmp _for2_cond
0146   04F5             _for2_exit:
0147   04F5 05 0B         syscall sys_terminate_proc
0148   04F7             
0149   04F7             test0:
0150   04F7 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0151   04FA             ; int result = 1; 
0152   04FA 52 02 00      sub sp, 2
0153   04FD             ; --- START LOCAL VAR INITIALIZATION
0154   04FD FA FF FF      lea d, [bp + -1] ; $result
0155   0500 DA            push d
0156   0501 FD 2E 01 00   mov32 cb, $00000001
0156   0505 00 00 
0157   0507 E7            pop d
0158   0508 FD 43         mov [d], b
0159   050A             ; --- END LOCAL VAR INITIALIZATION
0160   050A             ; result = result && sizeof(char) == 1; 
0161   050A FA FF FF      lea d, [bp + -1] ; $result
0162   050D DA            push d
0163   050E FA FF FF      lea d, [bp + -1] ; $result
0164   0511 2A            mov b, [d]
0165   0512 38 00 00      mov c, 0
0166   0515             ; --- START LOGICAL AND
0167   0515 D7            push a
0168   0516 11            mov a, b
0169   0517 FD 2E 01 00   mov32 cb, 1
0169   051B 00 00 
0170   051D             ; --- START RELATIONAL
0171   051D D7            push a
0172   051E 11            mov a, b
0173   051F FD 2E 01 00   mov32 cb, $00000001
0173   0523 00 00 
0174   0525 B0            cmp a, b
0175   0526 FD 71         seq ; ==
0176   0528 E4            pop a
0177   0529             ; --- END RELATIONAL
0178   0529 FD A7         sand a, b
0179   052B E4            pop a
0180   052C             ; --- END LOGICAL AND
0181   052C E7            pop d
0182   052D FD 43         mov [d], b
0183   052F             ; result = result && sizeof(int) == 2; 
0184   052F FA FF FF      lea d, [bp + -1] ; $result
0185   0532 DA            push d
0186   0533 FA FF FF      lea d, [bp + -1] ; $result
0187   0536 2A            mov b, [d]
0188   0537 38 00 00      mov c, 0
0189   053A             ; --- START LOGICAL AND
0190   053A D7            push a
0191   053B 11            mov a, b
0192   053C FD 2E 02 00   mov32 cb, 2
0192   0540 00 00 
0193   0542             ; --- START RELATIONAL
0194   0542 D7            push a
0195   0543 11            mov a, b
0196   0544 FD 2E 02 00   mov32 cb, $00000002
0196   0548 00 00 
0197   054A B0            cmp a, b
0198   054B FD 71         seq ; ==
0199   054D E4            pop a
0200   054E             ; --- END RELATIONAL
0201   054E FD A7         sand a, b
0202   0550 E4            pop a
0203   0551             ; --- END LOGICAL AND
0204   0551 E7            pop d
0205   0552 FD 43         mov [d], b
0206   0554             ; result = result && sizeof(long int) == 4; 
0207   0554 FA FF FF      lea d, [bp + -1] ; $result
0208   0557 DA            push d
0209   0558 FA FF FF      lea d, [bp + -1] ; $result
0210   055B 2A            mov b, [d]
0211   055C 38 00 00      mov c, 0
0212   055F             ; --- START LOGICAL AND
0213   055F D7            push a
0214   0560 11            mov a, b
0215   0561 FD 2E 04 00   mov32 cb, 4
0215   0565 00 00 
0216   0567             ; --- START RELATIONAL
0217   0567 D7            push a
0218   0568 11            mov a, b
0219   0569 FD 2E 04 00   mov32 cb, $00000004
0219   056D 00 00 
0220   056F B0            cmp a, b
0221   0570 FD 71         seq ; ==
0222   0572 E4            pop a
0223   0573             ; --- END RELATIONAL
0224   0573 FD A7         sand a, b
0225   0575 E4            pop a
0226   0576             ; --- END LOGICAL AND
0227   0576 E7            pop d
0228   0577 FD 43         mov [d], b
0229   0579             ; result = result && sizeof(char**) == 2; 
0230   0579 FA FF FF      lea d, [bp + -1] ; $result
0231   057C DA            push d
0232   057D FA FF FF      lea d, [bp + -1] ; $result
0233   0580 2A            mov b, [d]
0234   0581 38 00 00      mov c, 0
0235   0584             ; --- START LOGICAL AND
0236   0584 D7            push a
0237   0585 11            mov a, b
0238   0586 FD 2E 02 00   mov32 cb, 2
0238   058A 00 00 
0239   058C             ; --- START RELATIONAL
0240   058C D7            push a
0241   058D 11            mov a, b
0242   058E FD 2E 02 00   mov32 cb, $00000002
0242   0592 00 00 
0243   0594 B0            cmp a, b
0244   0595 FD 71         seq ; ==
0245   0597 E4            pop a
0246   0598             ; --- END RELATIONAL
0247   0598 FD A7         sand a, b
0248   059A E4            pop a
0249   059B             ; --- END LOGICAL AND
0250   059B E7            pop d
0251   059C FD 43         mov [d], b
0252   059E             ; result = result && sizeof(int**) == 2; 
0253   059E FA FF FF      lea d, [bp + -1] ; $result
0254   05A1 DA            push d
0255   05A2 FA FF FF      lea d, [bp + -1] ; $result
0256   05A5 2A            mov b, [d]
0257   05A6 38 00 00      mov c, 0
0258   05A9             ; --- START LOGICAL AND
0259   05A9 D7            push a
0260   05AA 11            mov a, b
0261   05AB FD 2E 02 00   mov32 cb, 2
0261   05AF 00 00 
0262   05B1             ; --- START RELATIONAL
0263   05B1 D7            push a
0264   05B2 11            mov a, b
0265   05B3 FD 2E 02 00   mov32 cb, $00000002
0265   05B7 00 00 
0266   05B9 B0            cmp a, b
0267   05BA FD 71         seq ; ==
0268   05BC E4            pop a
0269   05BD             ; --- END RELATIONAL
0270   05BD FD A7         sand a, b
0271   05BF E4            pop a
0272   05C0             ; --- END LOGICAL AND
0273   05C0 E7            pop d
0274   05C1 FD 43         mov [d], b
0275   05C3 F9            leave
0276   05C4 09            ret
0277   05C5             
0278   05C5             printf:
0279   05C5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0280   05C8             ; char *p, *format_p; 
0281   05C8 52 01 00      sub sp, 1
0282   05CB 52 02 00      sub sp, 2
0283   05CE             ; format_p = format; 
0284   05CE FA FE FF      lea d, [bp + -2] ; $format_p
0285   05D1 DA            push d
0286   05D2 FA 05 00      lea d, [bp + 5] ; $format
0287   05D5 2A            mov b, [d]
0288   05D6 38 00 00      mov c, 0
0289   05D9 E7            pop d
0290   05DA FD 43         mov [d], b
0291   05DC             ; p = &format + 2; 
0292   05DC FA 00 00      lea d, [bp + 0] ; $p
0293   05DF DA            push d
0294   05E0 FA 05 00      lea d, [bp + 5] ; $format
0295   05E3 2D            mov b, d
0296   05E4             ; --- START TERMS
0297   05E4 D7            push a
0298   05E5 11            mov a, b
0299   05E6 FD 2E 02 00   mov32 cb, $00000002
0299   05EA 00 00 
0300   05EC 56            add b, a
0301   05ED E4            pop a
0302   05EE             ; --- END TERMS
0303   05EE E7            pop d
0304   05EF FD 3E         mov [d], bl
0305   05F1             ; for(;;){ 
0306   05F1             _for3_init:
0307   05F1             _for3_cond:
0308   05F1             _for3_block:
0309   05F1             ; if(!*format_p) break; 
0310   05F1             _if4_cond:
0311   05F1 FA FE FF      lea d, [bp + -2] ; $format_p
0312   05F4 2A            mov b, [d]
0313   05F5 38 00 00      mov c, 0
0314   05F8 74            mov d, b
0315   05F9 32            mov bl, [d]
0316   05FA A7 00         mov bh, 0
0317   05FC 38 00 00      mov c, 0
0318   05FF C0 00 00      cmp b, 0
0319   0602 FD 71         seq ; !
0320   0604 C0 00 00      cmp b, 0
0321   0607 C6 10 06      je _if4_else
0322   060A             _if4_TRUE:
0323   060A             ; break; 
0324   060A 0A D1 08      jmp _for3_exit ; for break
0325   060D 0A BE 08      jmp _if4_exit
0326   0610             _if4_else:
0327   0610             ; if(*format_p == '%'){ 
0328   0610             _if5_cond:
0329   0610 FA FE FF      lea d, [bp + -2] ; $format_p
0330   0613 2A            mov b, [d]
0331   0614 38 00 00      mov c, 0
0332   0617 74            mov d, b
0333   0618 32            mov bl, [d]
0334   0619 A7 00         mov bh, 0
0335   061B 38 00 00      mov c, 0
0336   061E             ; --- START RELATIONAL
0337   061E D7            push a
0338   061F 11            mov a, b
0339   0620 FD 2E 25 00   mov32 cb, $00000025
0339   0624 00 00 
0340   0626 B0            cmp a, b
0341   0627 FD 71         seq ; ==
0342   0629 E4            pop a
0343   062A             ; --- END RELATIONAL
0344   062A C0 00 00      cmp b, 0
0345   062D C6 A9 08      je _if5_else
0346   0630             _if5_TRUE:
0347   0630             ; format_p++; 
0348   0630 FA FE FF      lea d, [bp + -2] ; $format_p
0349   0633 2A            mov b, [d]
0350   0634 38 00 00      mov c, 0
0351   0637 FD 77         inc b
0352   0639 FA FE FF      lea d, [bp + -2] ; $format_p
0353   063C FD 43         mov [d], b
0354   063E FD 7D         dec b
0355   0640             ; switch(*format_p){ 
0356   0640             _switch6_expr:
0357   0640 FA FE FF      lea d, [bp + -2] ; $format_p
0358   0643 2A            mov b, [d]
0359   0644 38 00 00      mov c, 0
0360   0647 74            mov d, b
0361   0648 32            mov bl, [d]
0362   0649 A7 00         mov bh, 0
0363   064B 38 00 00      mov c, 0
0364   064E             _switch6_comparisons:
0365   064E C1 6C         cmp bl, $6c
0366   0650 C6 81 06      je _switch6_case0
0367   0653 C1 4C         cmp bl, $4c
0368   0655 C6 81 06      je _switch6_case1
0369   0658 C1 64         cmp bl, $64
0370   065A C6 99 07      je _switch6_case2
0371   065D C1 69         cmp bl, $69
0372   065F C6 99 07      je _switch6_case3
0373   0662 C1 75         cmp bl, $75
0374   0664 C6 CD 07      je _switch6_case4
0375   0667 C1 78         cmp bl, $78
0376   0669 C6 01 08      je _switch6_case5
0377   066C C1 70         cmp bl, $70
0378   066E C6 01 08      je _switch6_case6
0379   0671 C1 63         cmp bl, $63
0380   0673 C6 35 08      je _switch6_case7
0381   0676 C1 73         cmp bl, $73
0382   0678 C6 69 08      je _switch6_case8
0383   067B 0A 9A 08      jmp _switch6_default
0384   067E 0A A6 08      jmp _switch6_exit
0385   0681             _switch6_case0:
0386   0681             _switch6_case1:
0387   0681             ; format_p++; 
0388   0681 FA FE FF      lea d, [bp + -2] ; $format_p
0389   0684 2A            mov b, [d]
0390   0685 38 00 00      mov c, 0
0391   0688 FD 77         inc b
0392   068A FA FE FF      lea d, [bp + -2] ; $format_p
0393   068D FD 43         mov [d], b
0394   068F FD 7D         dec b
0395   0691             ; if(*format_p == 'd' || *format_p == 'i') 
0396   0691             _if7_cond:
0397   0691 FA FE FF      lea d, [bp + -2] ; $format_p
0398   0694 2A            mov b, [d]
0399   0695 38 00 00      mov c, 0
0400   0698 74            mov d, b
0401   0699 32            mov bl, [d]
0402   069A A7 00         mov bh, 0
0403   069C 38 00 00      mov c, 0
0404   069F             ; --- START RELATIONAL
0405   069F D7            push a
0406   06A0 11            mov a, b
0407   06A1 FD 2E 64 00   mov32 cb, $00000064
0407   06A5 00 00 
0408   06A7 B0            cmp a, b
0409   06A8 FD 71         seq ; ==
0410   06AA E4            pop a
0411   06AB             ; --- END RELATIONAL
0412   06AB             ; --- START LOGICAL OR
0413   06AB D7            push a
0414   06AC 11            mov a, b
0415   06AD FA FE FF      lea d, [bp + -2] ; $format_p
0416   06B0 2A            mov b, [d]
0417   06B1 38 00 00      mov c, 0
0418   06B4 74            mov d, b
0419   06B5 32            mov bl, [d]
0420   06B6 A7 00         mov bh, 0
0421   06B8 38 00 00      mov c, 0
0422   06BB             ; --- START RELATIONAL
0423   06BB D7            push a
0424   06BC 11            mov a, b
0425   06BD FD 2E 69 00   mov32 cb, $00000069
0425   06C1 00 00 
0426   06C3 B0            cmp a, b
0427   06C4 FD 71         seq ; ==
0428   06C6 E4            pop a
0429   06C7             ; --- END RELATIONAL
0430   06C7 FD A8         sor a, b ; ||
0431   06C9 E4            pop a
0432   06CA             ; --- END LOGICAL OR
0433   06CA C0 00 00      cmp b, 0
0434   06CD C6 F0 06      je _if7_else
0435   06D0             _if7_TRUE:
0436   06D0             ; print_signed_long(*(long int*)p); 
0437   06D0             ; --- START FUNCTION CALL
0438   06D0 FA 00 00      lea d, [bp + 0] ; $p
0439   06D3 32            mov bl, [d]
0440   06D4 A7 00         mov bh, 0
0441   06D6 38 00 00      mov c, 0
0442   06D9 74            mov d, b
0443   06DA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0444   06DD FD 39         mov c, b ; And place it into C
0445   06DF 2A            mov b, [d] ; Lower Word in B
0446   06E0 12            mov a, c
0447   06E1 FD AA         swp a
0448   06E3 D7            push a
0449   06E4 FD AB         swp b
0450   06E6 D8            push b
0451   06E7 07 D3 08      call print_signed_long
0452   06EA 51 04 00      add sp, 4
0453   06ED             ; --- END FUNCTION CALL
0454   06ED 0A 7C 07      jmp _if7_exit
0455   06F0             _if7_else:
0456   06F0             ; if(*format_p == 'u') 
0457   06F0             _if8_cond:
0458   06F0 FA FE FF      lea d, [bp + -2] ; $format_p
0459   06F3 2A            mov b, [d]
0460   06F4 38 00 00      mov c, 0
0461   06F7 74            mov d, b
0462   06F8 32            mov bl, [d]
0463   06F9 A7 00         mov bh, 0
0464   06FB 38 00 00      mov c, 0
0465   06FE             ; --- START RELATIONAL
0466   06FE D7            push a
0467   06FF 11            mov a, b
0468   0700 FD 2E 75 00   mov32 cb, $00000075
0468   0704 00 00 
0469   0706 B0            cmp a, b
0470   0707 FD 71         seq ; ==
0471   0709 E4            pop a
0472   070A             ; --- END RELATIONAL
0473   070A C0 00 00      cmp b, 0
0474   070D C6 30 07      je _if8_else
0475   0710             _if8_TRUE:
0476   0710             ; print_unsigned_long(*(unsigned long int*)p); 
0477   0710             ; --- START FUNCTION CALL
0478   0710 FA 00 00      lea d, [bp + 0] ; $p
0479   0713 32            mov bl, [d]
0480   0714 A7 00         mov bh, 0
0481   0716 38 00 00      mov c, 0
0482   0719 74            mov d, b
0483   071A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0484   071D FD 39         mov c, b ; And place it into C
0485   071F 2A            mov b, [d] ; Lower Word in B
0486   0720 12            mov a, c
0487   0721 FD AA         swp a
0488   0723 D7            push a
0489   0724 FD AB         swp b
0490   0726 D8            push b
0491   0727 07 AA 0A      call print_unsigned_long
0492   072A 51 04 00      add sp, 4
0493   072D             ; --- END FUNCTION CALL
0494   072D 0A 7C 07      jmp _if8_exit
0495   0730             _if8_else:
0496   0730             ; if(*format_p == 'x') 
0497   0730             _if9_cond:
0498   0730 FA FE FF      lea d, [bp + -2] ; $format_p
0499   0733 2A            mov b, [d]
0500   0734 38 00 00      mov c, 0
0501   0737 74            mov d, b
0502   0738 32            mov bl, [d]
0503   0739 A7 00         mov bh, 0
0504   073B 38 00 00      mov c, 0
0505   073E             ; --- START RELATIONAL
0506   073E D7            push a
0507   073F 11            mov a, b
0508   0740 FD 2E 78 00   mov32 cb, $00000078
0508   0744 00 00 
0509   0746 B0            cmp a, b
0510   0747 FD 71         seq ; ==
0511   0749 E4            pop a
0512   074A             ; --- END RELATIONAL
0513   074A C0 00 00      cmp b, 0
0514   074D C6 70 07      je _if9_else
0515   0750             _if9_TRUE:
0516   0750             ; printx32(*(long int *)p); 
0517   0750             ; --- START FUNCTION CALL
0518   0750 FA 00 00      lea d, [bp + 0] ; $p
0519   0753 32            mov bl, [d]
0520   0754 A7 00         mov bh, 0
0521   0756 38 00 00      mov c, 0
0522   0759 74            mov d, b
0523   075A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0524   075D FD 39         mov c, b ; And place it into C
0525   075F 2A            mov b, [d] ; Lower Word in B
0526   0760 12            mov a, c
0527   0761 FD AA         swp a
0528   0763 D7            push a
0529   0764 FD AB         swp b
0530   0766 D8            push b
0531   0767 07 D5 0B      call printx32
0532   076A 51 04 00      add sp, 4
0533   076D             ; --- END FUNCTION CALL
0534   076D 0A 7C 07      jmp _if9_exit
0535   0770             _if9_else:
0536   0770             ; err("Unexpected format in printf."); 
0537   0770             ; --- START FUNCTION CALL
0538   0770 26 32 0F      mov b, _s1 ; "Unexpected format in printf."
0539   0773 FD AB         swp b
0540   0775 D8            push b
0541   0776 07 35 0C      call err
0542   0779 51 02 00      add sp, 2
0543   077C             ; --- END FUNCTION CALL
0544   077C             _if9_exit:
0545   077C             _if8_exit:
0546   077C             _if7_exit:
0547   077C             ; p = p + 4; 
0548   077C FA 00 00      lea d, [bp + 0] ; $p
0549   077F DA            push d
0550   0780 FA 00 00      lea d, [bp + 0] ; $p
0551   0783 32            mov bl, [d]
0552   0784 A7 00         mov bh, 0
0553   0786 38 00 00      mov c, 0
0554   0789             ; --- START TERMS
0555   0789 D7            push a
0556   078A 11            mov a, b
0557   078B FD 2E 04 00   mov32 cb, $00000004
0557   078F 00 00 
0558   0791 56            add b, a
0559   0792 E4            pop a
0560   0793             ; --- END TERMS
0561   0793 E7            pop d
0562   0794 FD 3E         mov [d], bl
0563   0796             ; break; 
0564   0796 0A A6 08      jmp _switch6_exit ; case break
0565   0799             _switch6_case2:
0566   0799             _switch6_case3:
0567   0799             ; print_signed(*(int*)p); 
0568   0799             ; --- START FUNCTION CALL
0569   0799 FA 00 00      lea d, [bp + 0] ; $p
0570   079C 32            mov bl, [d]
0571   079D A7 00         mov bh, 0
0572   079F 38 00 00      mov c, 0
0573   07A2 74            mov d, b
0574   07A3 2A            mov b, [d]
0575   07A4 38 00 00      mov c, 0
0576   07A7 FD AB         swp b
0577   07A9 D8            push b
0578   07AA 07 63 0C      call print_signed
0579   07AD 51 02 00      add sp, 2
0580   07B0             ; --- END FUNCTION CALL
0581   07B0             ; p = p + 2; 
0582   07B0 FA 00 00      lea d, [bp + 0] ; $p
0583   07B3 DA            push d
0584   07B4 FA 00 00      lea d, [bp + 0] ; $p
0585   07B7 32            mov bl, [d]
0586   07B8 A7 00         mov bh, 0
0587   07BA 38 00 00      mov c, 0
0588   07BD             ; --- START TERMS
0589   07BD D7            push a
0590   07BE 11            mov a, b
0591   07BF FD 2E 02 00   mov32 cb, $00000002
0591   07C3 00 00 
0592   07C5 56            add b, a
0593   07C6 E4            pop a
0594   07C7             ; --- END TERMS
0595   07C7 E7            pop d
0596   07C8 FD 3E         mov [d], bl
0597   07CA             ; break; 
0598   07CA 0A A6 08      jmp _switch6_exit ; case break
0599   07CD             _switch6_case4:
0600   07CD             ; print_unsigned(*(unsigned int*)p); 
0601   07CD             ; --- START FUNCTION CALL
0602   07CD FA 00 00      lea d, [bp + 0] ; $p
0603   07D0 32            mov bl, [d]
0604   07D1 A7 00         mov bh, 0
0605   07D3 38 00 00      mov c, 0
0606   07D6 74            mov d, b
0607   07D7 2A            mov b, [d]
0608   07D8 38 00 00      mov c, 0
0609   07DB FD AB         swp b
0610   07DD D8            push b
0611   07DE 07 C6 0D      call print_unsigned
0612   07E1 51 02 00      add sp, 2
0613   07E4             ; --- END FUNCTION CALL
0614   07E4             ; p = p + 2; 
0615   07E4 FA 00 00      lea d, [bp + 0] ; $p
0616   07E7 DA            push d
0617   07E8 FA 00 00      lea d, [bp + 0] ; $p
0618   07EB 32            mov bl, [d]
0619   07EC A7 00         mov bh, 0
0620   07EE 38 00 00      mov c, 0
0621   07F1             ; --- START TERMS
0622   07F1 D7            push a
0623   07F2 11            mov a, b
0624   07F3 FD 2E 02 00   mov32 cb, $00000002
0624   07F7 00 00 
0625   07F9 56            add b, a
0626   07FA E4            pop a
0627   07FB             ; --- END TERMS
0628   07FB E7            pop d
0629   07FC FD 3E         mov [d], bl
0630   07FE             ; break; 
0631   07FE 0A A6 08      jmp _switch6_exit ; case break
0632   0801             _switch6_case5:
0633   0801             _switch6_case6:
0634   0801             ; printx16(*(int*)p); 
0635   0801             ; --- START FUNCTION CALL
0636   0801 FA 00 00      lea d, [bp + 0] ; $p
0637   0804 32            mov bl, [d]
0638   0805 A7 00         mov bh, 0
0639   0807 38 00 00      mov c, 0
0640   080A 74            mov d, b
0641   080B 2A            mov b, [d]
0642   080C 38 00 00      mov c, 0
0643   080F FD AB         swp b
0644   0811 D8            push b
0645   0812 07 CB 0E      call printx16
0646   0815 51 02 00      add sp, 2
0647   0818             ; --- END FUNCTION CALL
0648   0818             ; p = p + 2; 
0649   0818 FA 00 00      lea d, [bp + 0] ; $p
0650   081B DA            push d
0651   081C FA 00 00      lea d, [bp + 0] ; $p
0652   081F 32            mov bl, [d]
0653   0820 A7 00         mov bh, 0
0654   0822 38 00 00      mov c, 0
0655   0825             ; --- START TERMS
0656   0825 D7            push a
0657   0826 11            mov a, b
0658   0827 FD 2E 02 00   mov32 cb, $00000002
0658   082B 00 00 
0659   082D 56            add b, a
0660   082E E4            pop a
0661   082F             ; --- END TERMS
0662   082F E7            pop d
0663   0830 FD 3E         mov [d], bl
0664   0832             ; break; 
0665   0832 0A A6 08      jmp _switch6_exit ; case break
0666   0835             _switch6_case7:
0667   0835             ; putchar(*(char*)p); 
0668   0835             ; --- START FUNCTION CALL
0669   0835 FA 00 00      lea d, [bp + 0] ; $p
0670   0838 32            mov bl, [d]
0671   0839 A7 00         mov bh, 0
0672   083B 38 00 00      mov c, 0
0673   083E 74            mov d, b
0674   083F 32            mov bl, [d]
0675   0840 A7 00         mov bh, 0
0676   0842 38 00 00      mov c, 0
0677   0845 DD            push bl
0678   0846 07 9C 0A      call putchar
0679   0849 51 01 00      add sp, 1
0680   084C             ; --- END FUNCTION CALL
0681   084C             ; p = p + 2; 
0682   084C FA 00 00      lea d, [bp + 0] ; $p
0683   084F DA            push d
0684   0850 FA 00 00      lea d, [bp + 0] ; $p
0685   0853 32            mov bl, [d]
0686   0854 A7 00         mov bh, 0
0687   0856 38 00 00      mov c, 0
0688   0859             ; --- START TERMS
0689   0859 D7            push a
0690   085A 11            mov a, b
0691   085B FD 2E 02 00   mov32 cb, $00000002
0691   085F 00 00 
0692   0861 56            add b, a
0693   0862 E4            pop a
0694   0863             ; --- END TERMS
0695   0863 E7            pop d
0696   0864 FD 3E         mov [d], bl
0697   0866             ; break; 
0698   0866 0A A6 08      jmp _switch6_exit ; case break
0699   0869             _switch6_case8:
0700   0869             ; print(*(char**)p); 
0701   0869             ; --- START FUNCTION CALL
0702   0869 FA 00 00      lea d, [bp + 0] ; $p
0703   086C 32            mov bl, [d]
0704   086D A7 00         mov bh, 0
0705   086F 38 00 00      mov c, 0
0706   0872 74            mov d, b
0707   0873 2A            mov b, [d]
0708   0874 FD AB         swp b
0709   0876 D8            push b
0710   0877 07 4A 0C      call print
0711   087A 51 02 00      add sp, 2
0712   087D             ; --- END FUNCTION CALL
0713   087D             ; p = p + 2; 
0714   087D FA 00 00      lea d, [bp + 0] ; $p
0715   0880 DA            push d
0716   0881 FA 00 00      lea d, [bp + 0] ; $p
0717   0884 32            mov bl, [d]
0718   0885 A7 00         mov bh, 0
0719   0887 38 00 00      mov c, 0
0720   088A             ; --- START TERMS
0721   088A D7            push a
0722   088B 11            mov a, b
0723   088C FD 2E 02 00   mov32 cb, $00000002
0723   0890 00 00 
0724   0892 56            add b, a
0725   0893 E4            pop a
0726   0894             ; --- END TERMS
0727   0894 E7            pop d
0728   0895 FD 3E         mov [d], bl
0729   0897             ; break; 
0730   0897 0A A6 08      jmp _switch6_exit ; case break
0731   089A             _switch6_default:
0732   089A             ; print("Error: Unknown argument type.\n"); 
0733   089A             ; --- START FUNCTION CALL
0734   089A 26 4F 0F      mov b, _s2 ; "Error: Unknown argument type.\n"
0735   089D FD AB         swp b
0736   089F D8            push b
0737   08A0 07 4A 0C      call print
0738   08A3 51 02 00      add sp, 2
0739   08A6             ; --- END FUNCTION CALL
0740   08A6             _switch6_exit:
0741   08A6 0A BE 08      jmp _if5_exit
0742   08A9             _if5_else:
0743   08A9             ; putchar(*format_p); 
0744   08A9             ; --- START FUNCTION CALL
0745   08A9 FA FE FF      lea d, [bp + -2] ; $format_p
0746   08AC 2A            mov b, [d]
0747   08AD 38 00 00      mov c, 0
0748   08B0 74            mov d, b
0749   08B1 32            mov bl, [d]
0750   08B2 A7 00         mov bh, 0
0751   08B4 38 00 00      mov c, 0
0752   08B7 DD            push bl
0753   08B8 07 9C 0A      call putchar
0754   08BB 51 01 00      add sp, 1
0755   08BE             ; --- END FUNCTION CALL
0756   08BE             _if5_exit:
0757   08BE             _if4_exit:
0758   08BE             ; format_p++; 
0759   08BE FA FE FF      lea d, [bp + -2] ; $format_p
0760   08C1 2A            mov b, [d]
0761   08C2 38 00 00      mov c, 0
0762   08C5 FD 77         inc b
0763   08C7 FA FE FF      lea d, [bp + -2] ; $format_p
0764   08CA FD 43         mov [d], b
0765   08CC FD 7D         dec b
0766   08CE             _for3_update:
0767   08CE 0A F1 05      jmp _for3_cond
0768   08D1             _for3_exit:
0769   08D1 F9            leave
0770   08D2 09            ret
0771   08D3             
0772   08D3             print_signed_long:
0773   08D3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0774   08D6             ; char digits[10];  // fits 2,147,483,647 
0775   08D6 52 0A 00      sub sp, 10
0776   08D9             ; int i = 0; 
0777   08D9 52 02 00      sub sp, 2
0778   08DC             ; --- START LOCAL VAR INITIALIZATION
0779   08DC FA F5 FF      lea d, [bp + -11] ; $i
0780   08DF DA            push d
0781   08E0 FD 2E 00 00   mov32 cb, $00000000
0781   08E4 00 00 
0782   08E6 E7            pop d
0783   08E7 FD 43         mov [d], b
0784   08E9             ; --- END LOCAL VAR INITIALIZATION
0785   08E9             ; unsigned long int absval; 
0786   08E9 52 04 00      sub sp, 4
0787   08EC             ; if (num < 0) { 
0788   08EC             _if10_cond:
0789   08EC FA 05 00      lea d, [bp + 5] ; $num
0790   08EF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0791   08F2 FD 39         mov c, b ; And place it into C
0792   08F4 2A            mov b, [d] ; Lower Word in B
0793   08F5             ; --- START RELATIONAL
0794   08F5 D7            push a
0795   08F6 FD D8         push g
0796   08F8 11            mov a, b
0797   08F9 FD 7A         mov g, c
0798   08FB FD 2E 00 00   mov32 cb, $00000000
0798   08FF 00 00 
0799   0901 38 00 00      mov c, 0
0800   0904 FD AF         cmp32 ga, cb
0801   0906 FD 73         slt ; <
0802   0908 FD F1         pop g
0803   090A E4            pop a
0804   090B             ; --- END RELATIONAL
0805   090B C0 00 00      cmp b, 0
0806   090E C6 6D 09      je _if10_else
0807   0911             _if10_TRUE:
0808   0911             ; putchar('-'); 
0809   0911             ; --- START FUNCTION CALL
0810   0911 FD 2E 2D 00   mov32 cb, $0000002d
0810   0915 00 00 
0811   0917 DD            push bl
0812   0918 07 9C 0A      call putchar
0813   091B 51 01 00      add sp, 1
0814   091E             ; --- END FUNCTION CALL
0815   091E             ; absval = (unsigned long int)(-(num + 1)) + 1; 
0816   091E FA F1 FF      lea d, [bp + -15] ; $absval
0817   0921 DA            push d
0818   0922 FA 05 00      lea d, [bp + 5] ; $num
0819   0925 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0820   0928 FD 39         mov c, b ; And place it into C
0821   092A 2A            mov b, [d] ; Lower Word in B
0822   092B             ; --- START TERMS
0823   092B D7            push a
0824   092C FD D8         push g
0825   092E 11            mov a, b
0826   092F FD 7A         mov g, c
0827   0931 FD 2E 01 00   mov32 cb, $00000001
0827   0935 00 00 
0828   0937 38 00 00      mov c, 0
0829   093A FD 15         add32 cb, ga
0830   093C FD F1         pop g
0831   093E E4            pop a
0832   093F             ; --- END TERMS
0833   093F 12            mov a, c
0834   0940 95            not a
0835   0941 97            not b
0836   0942 55 01 00      add b, 1
0837   0945 5B 00 00      adc a, 0
0838   0948 39            mov c, a
0839   0949 A7 00         mov bh, 0
0840   094B 38 00 00      mov c, 0
0841   094E             ; --- START TERMS
0842   094E D7            push a
0843   094F FD D8         push g
0844   0951 11            mov a, b
0845   0952 FD 7A         mov g, c
0846   0954 FD 2E 01 00   mov32 cb, $00000001
0846   0958 00 00 
0847   095A 38 00 00      mov c, 0
0848   095D FD 15         add32 cb, ga
0849   095F FD F1         pop g
0850   0961 E4            pop a
0851   0962             ; --- END TERMS
0852   0962 E7            pop d
0853   0963 FD 43         mov [d], b
0854   0965 28            mov b, c
0855   0966 FD 44 02 00   mov [d + 2], b
0856   096A 0A 87 09      jmp _if10_exit
0857   096D             _if10_else:
0858   096D             ; absval = (unsigned long int)num; 
0859   096D FA F1 FF      lea d, [bp + -15] ; $absval
0860   0970 DA            push d
0861   0971 FA 05 00      lea d, [bp + 5] ; $num
0862   0974 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0863   0977 FD 39         mov c, b ; And place it into C
0864   0979 2A            mov b, [d] ; Lower Word in B
0865   097A A7 00         mov bh, 0
0866   097C 38 00 00      mov c, 0
0867   097F E7            pop d
0868   0980 FD 43         mov [d], b
0869   0982 28            mov b, c
0870   0983 FD 44 02 00   mov [d + 2], b
0871   0987             _if10_exit:
0872   0987             ; if (absval == 0) { 
0873   0987             _if11_cond:
0874   0987 FA F1 FF      lea d, [bp + -15] ; $absval
0875   098A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0876   098D FD 39         mov c, b ; And place it into C
0877   098F 2A            mov b, [d] ; Lower Word in B
0878   0990             ; --- START RELATIONAL
0879   0990 D7            push a
0880   0991 FD D8         push g
0881   0993 11            mov a, b
0882   0994 FD 7A         mov g, c
0883   0996 FD 2E 00 00   mov32 cb, $00000000
0883   099A 00 00 
0884   099C 38 00 00      mov c, 0
0885   099F FD AF         cmp32 ga, cb
0886   09A1 FD 71         seq ; ==
0887   09A3 FD F1         pop g
0888   09A5 E4            pop a
0889   09A6             ; --- END RELATIONAL
0890   09A6 C0 00 00      cmp b, 0
0891   09A9 C6 BE 09      je _if11_exit
0892   09AC             _if11_TRUE:
0893   09AC             ; putchar('0'); 
0894   09AC             ; --- START FUNCTION CALL
0895   09AC FD 2E 30 00   mov32 cb, $00000030
0895   09B0 00 00 
0896   09B2 DD            push bl
0897   09B3 07 9C 0A      call putchar
0898   09B6 51 01 00      add sp, 1
0899   09B9             ; --- END FUNCTION CALL
0900   09B9             ; return; 
0901   09B9 F9            leave
0902   09BA 09            ret
0903   09BB 0A BE 09      jmp _if11_exit
0904   09BE             _if11_exit:
0905   09BE             ; while (absval > 0) { 
0906   09BE             _while12_cond:
0907   09BE FA F1 FF      lea d, [bp + -15] ; $absval
0908   09C1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0909   09C4 FD 39         mov c, b ; And place it into C
0910   09C6 2A            mov b, [d] ; Lower Word in B
0911   09C7             ; --- START RELATIONAL
0912   09C7 D7            push a
0913   09C8 FD D8         push g
0914   09CA 11            mov a, b
0915   09CB FD 7A         mov g, c
0916   09CD FD 2E 00 00   mov32 cb, $00000000
0916   09D1 00 00 
0917   09D3 38 00 00      mov c, 0
0918   09D6 FD AF         cmp32 ga, cb
0919   09D8 FD 81         sgu
0920   09DA FD F1         pop g
0921   09DC E4            pop a
0922   09DD             ; --- END RELATIONAL
0923   09DD C0 00 00      cmp b, 0
0924   09E0 C6 5E 0A      je _while12_exit
0925   09E3             _while12_block:
0926   09E3             ; digits[i++] = '0' + (absval % 10); 
0927   09E3 FA F7 FF      lea d, [bp + -9] ; $digits
0928   09E6 D7            push a
0929   09E7 DA            push d
0930   09E8 FA F5 FF      lea d, [bp + -11] ; $i
0931   09EB 2A            mov b, [d]
0932   09EC 38 00 00      mov c, 0
0933   09EF 11            mov a, b
0934   09F0 FD 77         inc b
0935   09F2 FA F5 FF      lea d, [bp + -11] ; $i
0936   09F5 FD 43         mov [d], b
0937   09F7 27            mov b, a
0938   09F8 E7            pop d
0939   09F9 5A            add d, b
0940   09FA E4            pop a
0941   09FB DA            push d
0942   09FC FD 2E 30 00   mov32 cb, $00000030
0942   0A00 00 00 
0943   0A02             ; --- START TERMS
0944   0A02 D7            push a
0945   0A03 11            mov a, b
0946   0A04 FA F1 FF      lea d, [bp + -15] ; $absval
0947   0A07 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0948   0A0A FD 39         mov c, b ; And place it into C
0949   0A0C 2A            mov b, [d] ; Lower Word in B
0950   0A0D             ; --- START FACTORS
0951   0A0D D7            push a
0952   0A0E FD D8         push g
0953   0A10 11            mov a, b
0954   0A11 FD 7A         mov g, c
0955   0A13 FD 2E 0A 00   mov32 cb, $0000000a
0955   0A17 00 00 
0956   0A19 FD D8         push g ; save 'g' as the div instruction uses it
0957   0A1B AE            div a, b ; %, a: quotient, b: remainder
0958   0A1C 11            mov a, b
0959   0A1D FD F1         pop g
0960   0A1F FD 38         mov c, g
0961   0A21 27            mov b, a
0962   0A22 FD F1         pop g
0963   0A24 E4            pop a
0964   0A25             ; --- END FACTORS
0965   0A25 FD 22 00 00   mov g, 0
0966   0A29 FD 15         add32 cb, ga
0967   0A2B E4            pop a
0968   0A2C             ; --- END TERMS
0969   0A2C E7            pop d
0970   0A2D FD 3E         mov [d], bl
0971   0A2F             ; absval = absval / 10; 
0972   0A2F FA F1 FF      lea d, [bp + -15] ; $absval
0973   0A32 DA            push d
0974   0A33 FA F1 FF      lea d, [bp + -15] ; $absval
0975   0A36 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0976   0A39 FD 39         mov c, b ; And place it into C
0977   0A3B 2A            mov b, [d] ; Lower Word in B
0978   0A3C             ; --- START FACTORS
0979   0A3C D7            push a
0980   0A3D FD D8         push g
0981   0A3F 11            mov a, b
0982   0A40 FD 7A         mov g, c
0983   0A42 FD 2E 0A 00   mov32 cb, $0000000a
0983   0A46 00 00 
0984   0A48 FD D8         push g ; save 'g' as the div instruction uses it
0985   0A4A AE            div a, b ; /, a: quotient, b: remainder
0986   0A4B FD F1         pop g
0987   0A4D FD 38         mov c, g
0988   0A4F 27            mov b, a
0989   0A50 FD F1         pop g
0990   0A52 E4            pop a
0991   0A53             ; --- END FACTORS
0992   0A53 E7            pop d
0993   0A54 FD 43         mov [d], b
0994   0A56 28            mov b, c
0995   0A57 FD 44 02 00   mov [d + 2], b
0996   0A5B 0A BE 09      jmp _while12_cond
0997   0A5E             _while12_exit:
0998   0A5E             ; while (i > 0) { 
0999   0A5E             _while19_cond:
1000   0A5E FA F5 FF      lea d, [bp + -11] ; $i
1001   0A61 2A            mov b, [d]
1002   0A62 38 00 00      mov c, 0
1003   0A65             ; --- START RELATIONAL
1004   0A65 D7            push a
1005   0A66 11            mov a, b
1006   0A67 FD 2E 00 00   mov32 cb, $00000000
1006   0A6B 00 00 
1007   0A6D B0            cmp a, b
1008   0A6E FD 7F         sgt ; >
1009   0A70 E4            pop a
1010   0A71             ; --- END RELATIONAL
1011   0A71 C0 00 00      cmp b, 0
1012   0A74 C6 9A 0A      je _while19_exit
1013   0A77             _while19_block:
1014   0A77             ; putchar(digits[--i]); 
1015   0A77             ; --- START FUNCTION CALL
1016   0A77 FA F7 FF      lea d, [bp + -9] ; $digits
1017   0A7A D7            push a
1018   0A7B DA            push d
1019   0A7C FA F5 FF      lea d, [bp + -11] ; $i
1020   0A7F 2A            mov b, [d]
1021   0A80 FD 7D         dec b
1022   0A82 FA F5 FF      lea d, [bp + -11] ; $i
1023   0A85 FD 43         mov [d], b
1024   0A87 E7            pop d
1025   0A88 5A            add d, b
1026   0A89 E4            pop a
1027   0A8A 32            mov bl, [d]
1028   0A8B A7 00         mov bh, 0
1029   0A8D 38 00 00      mov c, 0
1030   0A90 DD            push bl
1031   0A91 07 9C 0A      call putchar
1032   0A94 51 01 00      add sp, 1
1033   0A97             ; --- END FUNCTION CALL
1034   0A97 0A 5E 0A      jmp _while19_cond
1035   0A9A             _while19_exit:
1036   0A9A F9            leave
1037   0A9B 09            ret
1038   0A9C             
1039   0A9C             putchar:
1040   0A9C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1041   0A9F             ; --- BEGIN INLINE ASM SEGMENT
1042   0A9F FA 05 00      lea d, [bp + 5] ; $c
1043   0AA2 1E            mov al, [d]
1044   0AA3 23            mov ah, al
1045   0AA4 19 00         mov al, 0
1046   0AA6 05 03         syscall sys_io      ; char in AH
1047   0AA8             ; --- END INLINE ASM SEGMENT
1048   0AA8 F9            leave
1049   0AA9 09            ret
1050   0AAA             
1051   0AAA             print_unsigned_long:
1052   0AAA F8 00 00      enter 0 ; (push bp; mov bp, sp)
1053   0AAD             ; char digits[10]; 
1054   0AAD 52 0A 00      sub sp, 10
1055   0AB0             ; int i = 0; 
1056   0AB0 52 02 00      sub sp, 2
1057   0AB3             ; --- START LOCAL VAR INITIALIZATION
1058   0AB3 FA F5 FF      lea d, [bp + -11] ; $i
1059   0AB6 DA            push d
1060   0AB7 FD 2E 00 00   mov32 cb, $00000000
1060   0ABB 00 00 
1061   0ABD E7            pop d
1062   0ABE FD 43         mov [d], b
1063   0AC0             ; --- END LOCAL VAR INITIALIZATION
1064   0AC0             ; if(num == 0){ 
1065   0AC0             _if20_cond:
1066   0AC0 FA 05 00      lea d, [bp + 5] ; $num
1067   0AC3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1068   0AC6 FD 39         mov c, b ; And place it into C
1069   0AC8 2A            mov b, [d] ; Lower Word in B
1070   0AC9             ; --- START RELATIONAL
1071   0AC9 D7            push a
1072   0ACA FD D8         push g
1073   0ACC 11            mov a, b
1074   0ACD FD 7A         mov g, c
1075   0ACF FD 2E 00 00   mov32 cb, $00000000
1075   0AD3 00 00 
1076   0AD5 38 00 00      mov c, 0
1077   0AD8 FD AF         cmp32 ga, cb
1078   0ADA FD 71         seq ; ==
1079   0ADC FD F1         pop g
1080   0ADE E4            pop a
1081   0ADF             ; --- END RELATIONAL
1082   0ADF C0 00 00      cmp b, 0
1083   0AE2 C6 F7 0A      je _if20_exit
1084   0AE5             _if20_TRUE:
1085   0AE5             ; putchar('0'); 
1086   0AE5             ; --- START FUNCTION CALL
1087   0AE5 FD 2E 30 00   mov32 cb, $00000030
1087   0AE9 00 00 
1088   0AEB DD            push bl
1089   0AEC 07 9C 0A      call putchar
1090   0AEF 51 01 00      add sp, 1
1091   0AF2             ; --- END FUNCTION CALL
1092   0AF2             ; return; 
1093   0AF2 F9            leave
1094   0AF3 09            ret
1095   0AF4 0A F7 0A      jmp _if20_exit
1096   0AF7             _if20_exit:
1097   0AF7             ; while (num > 0) { 
1098   0AF7             _while21_cond:
1099   0AF7 FA 05 00      lea d, [bp + 5] ; $num
1100   0AFA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1101   0AFD FD 39         mov c, b ; And place it into C
1102   0AFF 2A            mov b, [d] ; Lower Word in B
1103   0B00             ; --- START RELATIONAL
1104   0B00 D7            push a
1105   0B01 FD D8         push g
1106   0B03 11            mov a, b
1107   0B04 FD 7A         mov g, c
1108   0B06 FD 2E 00 00   mov32 cb, $00000000
1108   0B0A 00 00 
1109   0B0C 38 00 00      mov c, 0
1110   0B0F FD AF         cmp32 ga, cb
1111   0B11 FD 81         sgu
1112   0B13 FD F1         pop g
1113   0B15 E4            pop a
1114   0B16             ; --- END RELATIONAL
1115   0B16 C0 00 00      cmp b, 0
1116   0B19 C6 97 0B      je _while21_exit
1117   0B1C             _while21_block:
1118   0B1C             ; digits[i++] = '0' + (num % 10); 
1119   0B1C FA F7 FF      lea d, [bp + -9] ; $digits
1120   0B1F D7            push a
1121   0B20 DA            push d
1122   0B21 FA F5 FF      lea d, [bp + -11] ; $i
1123   0B24 2A            mov b, [d]
1124   0B25 38 00 00      mov c, 0
1125   0B28 11            mov a, b
1126   0B29 FD 77         inc b
1127   0B2B FA F5 FF      lea d, [bp + -11] ; $i
1128   0B2E FD 43         mov [d], b
1129   0B30 27            mov b, a
1130   0B31 E7            pop d
1131   0B32 5A            add d, b
1132   0B33 E4            pop a
1133   0B34 DA            push d
1134   0B35 FD 2E 30 00   mov32 cb, $00000030
1134   0B39 00 00 
1135   0B3B             ; --- START TERMS
1136   0B3B D7            push a
1137   0B3C 11            mov a, b
1138   0B3D FA 05 00      lea d, [bp + 5] ; $num
1139   0B40 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1140   0B43 FD 39         mov c, b ; And place it into C
1141   0B45 2A            mov b, [d] ; Lower Word in B
1142   0B46             ; --- START FACTORS
1143   0B46 D7            push a
1144   0B47 FD D8         push g
1145   0B49 11            mov a, b
1146   0B4A FD 7A         mov g, c
1147   0B4C FD 2E 0A 00   mov32 cb, $0000000a
1147   0B50 00 00 
1148   0B52 FD D8         push g ; save 'g' as the div instruction uses it
1149   0B54 AE            div a, b ; %, a: quotient, b: remainder
1150   0B55 11            mov a, b
1151   0B56 FD F1         pop g
1152   0B58 FD 38         mov c, g
1153   0B5A 27            mov b, a
1154   0B5B FD F1         pop g
1155   0B5D E4            pop a
1156   0B5E             ; --- END FACTORS
1157   0B5E FD 22 00 00   mov g, 0
1158   0B62 FD 15         add32 cb, ga
1159   0B64 E4            pop a
1160   0B65             ; --- END TERMS
1161   0B65 E7            pop d
1162   0B66 FD 3E         mov [d], bl
1163   0B68             ; num = num / 10; 
1164   0B68 FA 05 00      lea d, [bp + 5] ; $num
1165   0B6B DA            push d
1166   0B6C FA 05 00      lea d, [bp + 5] ; $num
1167   0B6F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1168   0B72 FD 39         mov c, b ; And place it into C
1169   0B74 2A            mov b, [d] ; Lower Word in B
1170   0B75             ; --- START FACTORS
1171   0B75 D7            push a
1172   0B76 FD D8         push g
1173   0B78 11            mov a, b
1174   0B79 FD 7A         mov g, c
1175   0B7B FD 2E 0A 00   mov32 cb, $0000000a
1175   0B7F 00 00 
1176   0B81 FD D8         push g ; save 'g' as the div instruction uses it
1177   0B83 AE            div a, b ; /, a: quotient, b: remainder
1178   0B84 FD F1         pop g
1179   0B86 FD 38         mov c, g
1180   0B88 27            mov b, a
1181   0B89 FD F1         pop g
1182   0B8B E4            pop a
1183   0B8C             ; --- END FACTORS
1184   0B8C E7            pop d
1185   0B8D FD 43         mov [d], b
1186   0B8F 28            mov b, c
1187   0B90 FD 44 02 00   mov [d + 2], b
1188   0B94 0A F7 0A      jmp _while21_cond
1189   0B97             _while21_exit:
1190   0B97             ; while (i > 0) { 
1191   0B97             _while28_cond:
1192   0B97 FA F5 FF      lea d, [bp + -11] ; $i
1193   0B9A 2A            mov b, [d]
1194   0B9B 38 00 00      mov c, 0
1195   0B9E             ; --- START RELATIONAL
1196   0B9E D7            push a
1197   0B9F 11            mov a, b
1198   0BA0 FD 2E 00 00   mov32 cb, $00000000
1198   0BA4 00 00 
1199   0BA6 B0            cmp a, b
1200   0BA7 FD 7F         sgt ; >
1201   0BA9 E4            pop a
1202   0BAA             ; --- END RELATIONAL
1203   0BAA C0 00 00      cmp b, 0
1204   0BAD C6 D3 0B      je _while28_exit
1205   0BB0             _while28_block:
1206   0BB0             ; putchar(digits[--i]); 
1207   0BB0             ; --- START FUNCTION CALL
1208   0BB0 FA F7 FF      lea d, [bp + -9] ; $digits
1209   0BB3 D7            push a
1210   0BB4 DA            push d
1211   0BB5 FA F5 FF      lea d, [bp + -11] ; $i
1212   0BB8 2A            mov b, [d]
1213   0BB9 FD 7D         dec b
1214   0BBB FA F5 FF      lea d, [bp + -11] ; $i
1215   0BBE FD 43         mov [d], b
1216   0BC0 E7            pop d
1217   0BC1 5A            add d, b
1218   0BC2 E4            pop a
1219   0BC3 32            mov bl, [d]
1220   0BC4 A7 00         mov bh, 0
1221   0BC6 38 00 00      mov c, 0
1222   0BC9 DD            push bl
1223   0BCA 07 9C 0A      call putchar
1224   0BCD 51 01 00      add sp, 1
1225   0BD0             ; --- END FUNCTION CALL
1226   0BD0 0A 97 0B      jmp _while28_cond
1227   0BD3             _while28_exit:
1228   0BD3 F9            leave
1229   0BD4 09            ret
1230   0BD5             
1231   0BD5             printx32:
1232   0BD5 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1233   0BD8             ; --- BEGIN INLINE ASM SEGMENT
1234   0BD8 FA 05 00      lea d, [bp + 5] ; $hex
1235   0BDB 2B 02 00      mov b, [d+2]
1236   0BDE 07 E7 0B      call print_u16x_printx32
1237   0BE1 2A            mov b, [d]
1238   0BE2 07 E7 0B      call print_u16x_printx32
1239   0BE5             ; --- END INLINE ASM SEGMENT
1240   0BE5             ; return; 
1241   0BE5 F9            leave
1242   0BE6 09            ret
1243   0BE7             ; --- BEGIN INLINE ASM SEGMENT
1244   0BE7             print_u16x_printx32:
1245   0BE7 D7            push a
1246   0BE8 D8            push b
1247   0BE9 DD            push bl
1248   0BEA 30            mov bl, bh
1249   0BEB 07 09 0C      call _itoa_printx32        ; convert bh to char in A
1250   0BEE 2F            mov bl, al        ; save al
1251   0BEF 19 00         mov al, 0
1252   0BF1 05 03         syscall sys_io        ; display AH
1253   0BF3 24            mov ah, bl        ; retrieve al
1254   0BF4 19 00         mov al, 0
1255   0BF6 05 03         syscall sys_io        ; display AL
1256   0BF8 EA            pop bl
1257   0BF9 07 09 0C      call _itoa_printx32        ; convert bh to char in A
1258   0BFC 2F            mov bl, al        ; save al
1259   0BFD 19 00         mov al, 0
1260   0BFF 05 03         syscall sys_io        ; display AH
1261   0C01 24            mov ah, bl        ; retrieve al
1262   0C02 19 00         mov al, 0
1263   0C04 05 03         syscall sys_io        ; display AL
1264   0C06 E5            pop b
1265   0C07 E4            pop a
1266   0C08 09            ret
1267   0C09             _itoa_printx32:
1268   0C09 DA            push d
1269   0C0A D8            push b
1270   0C0B A7 00         mov bh, 0
1271   0C0D FD A4 04      shr bl, 4  
1272   0C10 74            mov d, b
1273   0C11 1F 23 0C      mov al, [d + s_hex_digits_printx32]
1274   0C14 23            mov ah, al
1275   0C15 E5            pop b
1276   0C16 D8            push b
1277   0C17 A7 00         mov bh, 0
1278   0C19 FD 87 0F      and bl, $0F
1279   0C1C 74            mov d, b
1280   0C1D 1F 23 0C      mov al, [d + s_hex_digits_printx32]
1281   0C20 E5            pop b
1282   0C21 E7            pop d
1283   0C22 09            ret
1284   0C23 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1284   0C27 34 35 36 37 
1284   0C2B 38 39 41 42 
1284   0C2F 43 44 45 46 
1285   0C33             ; --- END INLINE ASM SEGMENT
1286   0C33 F9            leave
1287   0C34 09            ret
1288   0C35             
1289   0C35             err:
1290   0C35 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1291   0C38             ; print(e); 
1292   0C38             ; --- START FUNCTION CALL
1293   0C38 FA 05 00      lea d, [bp + 5] ; $e
1294   0C3B 2A            mov b, [d]
1295   0C3C 38 00 00      mov c, 0
1296   0C3F FD AB         swp b
1297   0C41 D8            push b
1298   0C42 07 4A 0C      call print
1299   0C45 51 02 00      add sp, 2
1300   0C48             ; --- END FUNCTION CALL
1301   0C48 F9            leave
1302   0C49 09            ret
1303   0C4A             
1304   0C4A             print:
1305   0C4A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1306   0C4D             ; --- BEGIN INLINE ASM SEGMENT
1307   0C4D FA 05 00      lea d, [bp + 5] ; $s
1308   0C50 FD 2A         mov d, [d]
1309   0C52             _puts_L1_print:
1310   0C52 1E            mov al, [d]
1311   0C53 B9 00         cmp al, 0
1312   0C55 C6 61 0C      jz _puts_END_print
1313   0C58 23            mov ah, al
1314   0C59 19 00         mov al, 0
1315   0C5B 05 03         syscall sys_io
1316   0C5D 79            inc d
1317   0C5E 0A 52 0C      jmp _puts_L1_print
1318   0C61             _puts_END_print:
1319   0C61             ; --- END INLINE ASM SEGMENT
1320   0C61 F9            leave
1321   0C62 09            ret
1322   0C63             
1323   0C63             print_signed:
1324   0C63 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1325   0C66             ; char digits[5];  // enough for "-32768" 
1326   0C66 52 05 00      sub sp, 5
1327   0C69             ; int i = 0; 
1328   0C69 52 02 00      sub sp, 2
1329   0C6C             ; --- START LOCAL VAR INITIALIZATION
1330   0C6C FA FA FF      lea d, [bp + -6] ; $i
1331   0C6F DA            push d
1332   0C70 FD 2E 00 00   mov32 cb, $00000000
1332   0C74 00 00 
1333   0C76 E7            pop d
1334   0C77 FD 43         mov [d], b
1335   0C79             ; --- END LOCAL VAR INITIALIZATION
1336   0C79             ; unsigned int absval; 
1337   0C79 52 02 00      sub sp, 2
1338   0C7C             ; if (num < 0) { 
1339   0C7C             _if29_cond:
1340   0C7C FA 05 00      lea d, [bp + 5] ; $num
1341   0C7F 2A            mov b, [d]
1342   0C80 38 00 00      mov c, 0
1343   0C83             ; --- START RELATIONAL
1344   0C83 D7            push a
1345   0C84 11            mov a, b
1346   0C85 FD 2E 00 00   mov32 cb, $00000000
1346   0C89 00 00 
1347   0C8B B0            cmp a, b
1348   0C8C FD 73         slt ; < (signed)
1349   0C8E E4            pop a
1350   0C8F             ; --- END RELATIONAL
1351   0C8F C0 00 00      cmp b, 0
1352   0C92 C6 C9 0C      je _if29_else
1353   0C95             _if29_TRUE:
1354   0C95             ; putchar('-'); 
1355   0C95             ; --- START FUNCTION CALL
1356   0C95 FD 2E 2D 00   mov32 cb, $0000002d
1356   0C99 00 00 
1357   0C9B DD            push bl
1358   0C9C 07 9C 0A      call putchar
1359   0C9F 51 01 00      add sp, 1
1360   0CA2             ; --- END FUNCTION CALL
1361   0CA2             ; absval = (unsigned int)(-(num + 1)) + 1;  // safe for -32768 
1362   0CA2 FA F8 FF      lea d, [bp + -8] ; $absval
1363   0CA5 DA            push d
1364   0CA6 FA 05 00      lea d, [bp + 5] ; $num
1365   0CA9 2A            mov b, [d]
1366   0CAA 38 00 00      mov c, 0
1367   0CAD             ; --- START TERMS
1368   0CAD D7            push a
1369   0CAE 11            mov a, b
1370   0CAF FD 2E 01 00   mov32 cb, $00000001
1370   0CB3 00 00 
1371   0CB5 56            add b, a
1372   0CB6 E4            pop a
1373   0CB7             ; --- END TERMS
1374   0CB7 FD 97         neg b
1375   0CB9             ; --- START TERMS
1376   0CB9 D7            push a
1377   0CBA 11            mov a, b
1378   0CBB FD 2E 01 00   mov32 cb, $00000001
1378   0CBF 00 00 
1379   0CC1 56            add b, a
1380   0CC2 E4            pop a
1381   0CC3             ; --- END TERMS
1382   0CC3 E7            pop d
1383   0CC4 FD 43         mov [d], b
1384   0CC6 0A D7 0C      jmp _if29_exit
1385   0CC9             _if29_else:
1386   0CC9             ; absval = (unsigned int)num; 
1387   0CC9 FA F8 FF      lea d, [bp + -8] ; $absval
1388   0CCC DA            push d
1389   0CCD FA 05 00      lea d, [bp + 5] ; $num
1390   0CD0 2A            mov b, [d]
1391   0CD1 38 00 00      mov c, 0
1392   0CD4 E7            pop d
1393   0CD5 FD 43         mov [d], b
1394   0CD7             _if29_exit:
1395   0CD7             ; if (absval == 0) { 
1396   0CD7             _if30_cond:
1397   0CD7 FA F8 FF      lea d, [bp + -8] ; $absval
1398   0CDA 2A            mov b, [d]
1399   0CDB 38 00 00      mov c, 0
1400   0CDE             ; --- START RELATIONAL
1401   0CDE D7            push a
1402   0CDF 11            mov a, b
1403   0CE0 FD 2E 00 00   mov32 cb, $00000000
1403   0CE4 00 00 
1404   0CE6 B0            cmp a, b
1405   0CE7 FD 71         seq ; ==
1406   0CE9 E4            pop a
1407   0CEA             ; --- END RELATIONAL
1408   0CEA C0 00 00      cmp b, 0
1409   0CED C6 02 0D      je _if30_exit
1410   0CF0             _if30_TRUE:
1411   0CF0             ; putchar('0'); 
1412   0CF0             ; --- START FUNCTION CALL
1413   0CF0 FD 2E 30 00   mov32 cb, $00000030
1413   0CF4 00 00 
1414   0CF6 DD            push bl
1415   0CF7 07 9C 0A      call putchar
1416   0CFA 51 01 00      add sp, 1
1417   0CFD             ; --- END FUNCTION CALL
1418   0CFD             ; return; 
1419   0CFD F9            leave
1420   0CFE 09            ret
1421   0CFF 0A 02 0D      jmp _if30_exit
1422   0D02             _if30_exit:
1423   0D02             ; while (absval > 0) { 
1424   0D02             _while31_cond:
1425   0D02 FA F8 FF      lea d, [bp + -8] ; $absval
1426   0D05 2A            mov b, [d]
1427   0D06 38 00 00      mov c, 0
1428   0D09             ; --- START RELATIONAL
1429   0D09 D7            push a
1430   0D0A 11            mov a, b
1431   0D0B FD 2E 00 00   mov32 cb, $00000000
1431   0D0F 00 00 
1432   0D11 B0            cmp a, b
1433   0D12 FD 81         sgu ; > (unsigned)
1434   0D14 E4            pop a
1435   0D15             ; --- END RELATIONAL
1436   0D15 C0 00 00      cmp b, 0
1437   0D18 C6 88 0D      je _while31_exit
1438   0D1B             _while31_block:
1439   0D1B             ; digits[i++] = '0' + (absval % 10); 
1440   0D1B FA FC FF      lea d, [bp + -4] ; $digits
1441   0D1E D7            push a
1442   0D1F DA            push d
1443   0D20 FA FA FF      lea d, [bp + -6] ; $i
1444   0D23 2A            mov b, [d]
1445   0D24 38 00 00      mov c, 0
1446   0D27 11            mov a, b
1447   0D28 FD 77         inc b
1448   0D2A FA FA FF      lea d, [bp + -6] ; $i
1449   0D2D FD 43         mov [d], b
1450   0D2F 27            mov b, a
1451   0D30 E7            pop d
1452   0D31 5A            add d, b
1453   0D32 E4            pop a
1454   0D33 DA            push d
1455   0D34 FD 2E 30 00   mov32 cb, $00000030
1455   0D38 00 00 
1456   0D3A             ; --- START TERMS
1457   0D3A D7            push a
1458   0D3B 11            mov a, b
1459   0D3C FA F8 FF      lea d, [bp + -8] ; $absval
1460   0D3F 2A            mov b, [d]
1461   0D40 38 00 00      mov c, 0
1462   0D43             ; --- START FACTORS
1463   0D43 D7            push a
1464   0D44 FD D8         push g
1465   0D46 11            mov a, b
1466   0D47 FD 7A         mov g, c
1467   0D49 FD 2E 0A 00   mov32 cb, $0000000a
1467   0D4D 00 00 
1468   0D4F FD D8         push g ; save 'g' as the div instruction uses it
1469   0D51 AE            div a, b ; %, a: quotient, b: remainder
1470   0D52 11            mov a, b
1471   0D53 FD F1         pop g
1472   0D55 FD 38         mov c, g
1473   0D57 27            mov b, a
1474   0D58 FD F1         pop g
1475   0D5A E4            pop a
1476   0D5B             ; --- END FACTORS
1477   0D5B 56            add b, a
1478   0D5C E4            pop a
1479   0D5D             ; --- END TERMS
1480   0D5D E7            pop d
1481   0D5E FD 3E         mov [d], bl
1482   0D60             ; absval = absval / 10; 
1483   0D60 FA F8 FF      lea d, [bp + -8] ; $absval
1484   0D63 DA            push d
1485   0D64 FA F8 FF      lea d, [bp + -8] ; $absval
1486   0D67 2A            mov b, [d]
1487   0D68 38 00 00      mov c, 0
1488   0D6B             ; --- START FACTORS
1489   0D6B D7            push a
1490   0D6C FD D8         push g
1491   0D6E 11            mov a, b
1492   0D6F FD 7A         mov g, c
1493   0D71 FD 2E 0A 00   mov32 cb, $0000000a
1493   0D75 00 00 
1494   0D77 FD D8         push g ; save 'g' as the div instruction uses it
1495   0D79 AE            div a, b ; /, a: quotient, b: remainder
1496   0D7A FD F1         pop g
1497   0D7C FD 38         mov c, g
1498   0D7E 27            mov b, a
1499   0D7F FD F1         pop g
1500   0D81 E4            pop a
1501   0D82             ; --- END FACTORS
1502   0D82 E7            pop d
1503   0D83 FD 43         mov [d], b
1504   0D85 0A 02 0D      jmp _while31_cond
1505   0D88             _while31_exit:
1506   0D88             ; while (i > 0) { 
1507   0D88             _while38_cond:
1508   0D88 FA FA FF      lea d, [bp + -6] ; $i
1509   0D8B 2A            mov b, [d]
1510   0D8C 38 00 00      mov c, 0
1511   0D8F             ; --- START RELATIONAL
1512   0D8F D7            push a
1513   0D90 11            mov a, b
1514   0D91 FD 2E 00 00   mov32 cb, $00000000
1514   0D95 00 00 
1515   0D97 B0            cmp a, b
1516   0D98 FD 7F         sgt ; >
1517   0D9A E4            pop a
1518   0D9B             ; --- END RELATIONAL
1519   0D9B C0 00 00      cmp b, 0
1520   0D9E C6 C4 0D      je _while38_exit
1521   0DA1             _while38_block:
1522   0DA1             ; putchar(digits[--i]); 
1523   0DA1             ; --- START FUNCTION CALL
1524   0DA1 FA FC FF      lea d, [bp + -4] ; $digits
1525   0DA4 D7            push a
1526   0DA5 DA            push d
1527   0DA6 FA FA FF      lea d, [bp + -6] ; $i
1528   0DA9 2A            mov b, [d]
1529   0DAA FD 7D         dec b
1530   0DAC FA FA FF      lea d, [bp + -6] ; $i
1531   0DAF FD 43         mov [d], b
1532   0DB1 E7            pop d
1533   0DB2 5A            add d, b
1534   0DB3 E4            pop a
1535   0DB4 32            mov bl, [d]
1536   0DB5 A7 00         mov bh, 0
1537   0DB7 38 00 00      mov c, 0
1538   0DBA DD            push bl
1539   0DBB 07 9C 0A      call putchar
1540   0DBE 51 01 00      add sp, 1
1541   0DC1             ; --- END FUNCTION CALL
1542   0DC1 0A 88 0D      jmp _while38_cond
1543   0DC4             _while38_exit:
1544   0DC4 F9            leave
1545   0DC5 09            ret
1546   0DC6             
1547   0DC6             print_unsigned:
1548   0DC6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1549   0DC9             ; char digits[5]; 
1550   0DC9 52 05 00      sub sp, 5
1551   0DCC             ; int i = 0; 
1552   0DCC 52 02 00      sub sp, 2
1553   0DCF             ; --- START LOCAL VAR INITIALIZATION
1554   0DCF FA FA FF      lea d, [bp + -6] ; $i
1555   0DD2 DA            push d
1556   0DD3 FD 2E 00 00   mov32 cb, $00000000
1556   0DD7 00 00 
1557   0DD9 E7            pop d
1558   0DDA FD 43         mov [d], b
1559   0DDC             ; --- END LOCAL VAR INITIALIZATION
1560   0DDC             ; if(num == 0){ 
1561   0DDC             _if39_cond:
1562   0DDC FA 05 00      lea d, [bp + 5] ; $num
1563   0DDF 2A            mov b, [d]
1564   0DE0 38 00 00      mov c, 0
1565   0DE3             ; --- START RELATIONAL
1566   0DE3 D7            push a
1567   0DE4 11            mov a, b
1568   0DE5 FD 2E 00 00   mov32 cb, $00000000
1568   0DE9 00 00 
1569   0DEB B0            cmp a, b
1570   0DEC FD 71         seq ; ==
1571   0DEE E4            pop a
1572   0DEF             ; --- END RELATIONAL
1573   0DEF C0 00 00      cmp b, 0
1574   0DF2 C6 07 0E      je _if39_exit
1575   0DF5             _if39_TRUE:
1576   0DF5             ; putchar('0'); 
1577   0DF5             ; --- START FUNCTION CALL
1578   0DF5 FD 2E 30 00   mov32 cb, $00000030
1578   0DF9 00 00 
1579   0DFB DD            push bl
1580   0DFC 07 9C 0A      call putchar
1581   0DFF 51 01 00      add sp, 1
1582   0E02             ; --- END FUNCTION CALL
1583   0E02             ; return; 
1584   0E02 F9            leave
1585   0E03 09            ret
1586   0E04 0A 07 0E      jmp _if39_exit
1587   0E07             _if39_exit:
1588   0E07             ; while (num > 0) { 
1589   0E07             _while40_cond:
1590   0E07 FA 05 00      lea d, [bp + 5] ; $num
1591   0E0A 2A            mov b, [d]
1592   0E0B 38 00 00      mov c, 0
1593   0E0E             ; --- START RELATIONAL
1594   0E0E D7            push a
1595   0E0F 11            mov a, b
1596   0E10 FD 2E 00 00   mov32 cb, $00000000
1596   0E14 00 00 
1597   0E16 B0            cmp a, b
1598   0E17 FD 81         sgu ; > (unsigned)
1599   0E19 E4            pop a
1600   0E1A             ; --- END RELATIONAL
1601   0E1A C0 00 00      cmp b, 0
1602   0E1D C6 8D 0E      je _while40_exit
1603   0E20             _while40_block:
1604   0E20             ; digits[i++] = '0' + (num % 10); 
1605   0E20 FA FC FF      lea d, [bp + -4] ; $digits
1606   0E23 D7            push a
1607   0E24 DA            push d
1608   0E25 FA FA FF      lea d, [bp + -6] ; $i
1609   0E28 2A            mov b, [d]
1610   0E29 38 00 00      mov c, 0
1611   0E2C 11            mov a, b
1612   0E2D FD 77         inc b
1613   0E2F FA FA FF      lea d, [bp + -6] ; $i
1614   0E32 FD 43         mov [d], b
1615   0E34 27            mov b, a
1616   0E35 E7            pop d
1617   0E36 5A            add d, b
1618   0E37 E4            pop a
1619   0E38 DA            push d
1620   0E39 FD 2E 30 00   mov32 cb, $00000030
1620   0E3D 00 00 
1621   0E3F             ; --- START TERMS
1622   0E3F D7            push a
1623   0E40 11            mov a, b
1624   0E41 FA 05 00      lea d, [bp + 5] ; $num
1625   0E44 2A            mov b, [d]
1626   0E45 38 00 00      mov c, 0
1627   0E48             ; --- START FACTORS
1628   0E48 D7            push a
1629   0E49 FD D8         push g
1630   0E4B 11            mov a, b
1631   0E4C FD 7A         mov g, c
1632   0E4E FD 2E 0A 00   mov32 cb, $0000000a
1632   0E52 00 00 
1633   0E54 FD D8         push g ; save 'g' as the div instruction uses it
1634   0E56 AE            div a, b ; %, a: quotient, b: remainder
1635   0E57 11            mov a, b
1636   0E58 FD F1         pop g
1637   0E5A FD 38         mov c, g
1638   0E5C 27            mov b, a
1639   0E5D FD F1         pop g
1640   0E5F E4            pop a
1641   0E60             ; --- END FACTORS
1642   0E60 56            add b, a
1643   0E61 E4            pop a
1644   0E62             ; --- END TERMS
1645   0E62 E7            pop d
1646   0E63 FD 3E         mov [d], bl
1647   0E65             ; num = num / 10; 
1648   0E65 FA 05 00      lea d, [bp + 5] ; $num
1649   0E68 DA            push d
1650   0E69 FA 05 00      lea d, [bp + 5] ; $num
1651   0E6C 2A            mov b, [d]
1652   0E6D 38 00 00      mov c, 0
1653   0E70             ; --- START FACTORS
1654   0E70 D7            push a
1655   0E71 FD D8         push g
1656   0E73 11            mov a, b
1657   0E74 FD 7A         mov g, c
1658   0E76 FD 2E 0A 00   mov32 cb, $0000000a
1658   0E7A 00 00 
1659   0E7C FD D8         push g ; save 'g' as the div instruction uses it
1660   0E7E AE            div a, b ; /, a: quotient, b: remainder
1661   0E7F FD F1         pop g
1662   0E81 FD 38         mov c, g
1663   0E83 27            mov b, a
1664   0E84 FD F1         pop g
1665   0E86 E4            pop a
1666   0E87             ; --- END FACTORS
1667   0E87 E7            pop d
1668   0E88 FD 43         mov [d], b
1669   0E8A 0A 07 0E      jmp _while40_cond
1670   0E8D             _while40_exit:
1671   0E8D             ; while (i > 0) { 
1672   0E8D             _while47_cond:
1673   0E8D FA FA FF      lea d, [bp + -6] ; $i
1674   0E90 2A            mov b, [d]
1675   0E91 38 00 00      mov c, 0
1676   0E94             ; --- START RELATIONAL
1677   0E94 D7            push a
1678   0E95 11            mov a, b
1679   0E96 FD 2E 00 00   mov32 cb, $00000000
1679   0E9A 00 00 
1680   0E9C B0            cmp a, b
1681   0E9D FD 7F         sgt ; >
1682   0E9F E4            pop a
1683   0EA0             ; --- END RELATIONAL
1684   0EA0 C0 00 00      cmp b, 0
1685   0EA3 C6 C9 0E      je _while47_exit
1686   0EA6             _while47_block:
1687   0EA6             ; putchar(digits[--i]); 
1688   0EA6             ; --- START FUNCTION CALL
1689   0EA6 FA FC FF      lea d, [bp + -4] ; $digits
1690   0EA9 D7            push a
1691   0EAA DA            push d
1692   0EAB FA FA FF      lea d, [bp + -6] ; $i
1693   0EAE 2A            mov b, [d]
1694   0EAF FD 7D         dec b
1695   0EB1 FA FA FF      lea d, [bp + -6] ; $i
1696   0EB4 FD 43         mov [d], b
1697   0EB6 E7            pop d
1698   0EB7 5A            add d, b
1699   0EB8 E4            pop a
1700   0EB9 32            mov bl, [d]
1701   0EBA A7 00         mov bh, 0
1702   0EBC 38 00 00      mov c, 0
1703   0EBF DD            push bl
1704   0EC0 07 9C 0A      call putchar
1705   0EC3 51 01 00      add sp, 1
1706   0EC6             ; --- END FUNCTION CALL
1707   0EC6 0A 8D 0E      jmp _while47_cond
1708   0EC9             _while47_exit:
1709   0EC9 F9            leave
1710   0ECA 09            ret
1711   0ECB             
1712   0ECB             printx16:
1713   0ECB F8 00 00      enter 0 ; (push bp; mov bp, sp)
1714   0ECE             ; --- BEGIN INLINE ASM SEGMENT
1715   0ECE FA 05 00      lea d, [bp + 5] ; $hex
1716   0ED1 2A            mov b, [d]
1717   0ED2             print_u16x_printx16:
1718   0ED2 DD            push bl
1719   0ED3 30            mov bl, bh
1720   0ED4 07 F1 0E      call _itoa_printx16        ; convert bh to char in A
1721   0ED7 2F            mov bl, al        ; save al
1722   0ED8 19 00         mov al, 0
1723   0EDA 05 03         syscall sys_io        ; display AH
1724   0EDC 24            mov ah, bl        ; retrieve al
1725   0EDD 19 00         mov al, 0
1726   0EDF 05 03         syscall sys_io        ; display AL
1727   0EE1 EA            pop bl
1728   0EE2 07 F1 0E      call _itoa_printx16        ; convert bh to char in A
1729   0EE5 2F            mov bl, al        ; save al
1730   0EE6 19 00         mov al, 0
1731   0EE8 05 03         syscall sys_io        ; display AH
1732   0EEA 24            mov ah, bl        ; retrieve al
1733   0EEB 19 00         mov al, 0
1734   0EED 05 03         syscall sys_io        ; display AL
1735   0EEF             ; --- END INLINE ASM SEGMENT
1736   0EEF             ; return; 
1737   0EEF F9            leave
1738   0EF0 09            ret
1739   0EF1             ; --- BEGIN INLINE ASM SEGMENT
1740   0EF1             _itoa_printx16:
1741   0EF1 DA            push d
1742   0EF2 D8            push b
1743   0EF3 A7 00         mov bh, 0
1744   0EF5 FD A4 04      shr bl, 4  
1745   0EF8 74            mov d, b
1746   0EF9 1F 0B 0F      mov al, [d + s_hex_digits_printx16]
1747   0EFC 23            mov ah, al
1748   0EFD E5            pop b
1749   0EFE D8            push b
1750   0EFF A7 00         mov bh, 0
1751   0F01 FD 87 0F      and bl, $0F
1752   0F04 74            mov d, b
1753   0F05 1F 0B 0F      mov al, [d + s_hex_digits_printx16]
1754   0F08 E5            pop b
1755   0F09 E7            pop d
1756   0F0A 09            ret
1757   0F0B 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1757   0F0F 34 35 36 37 
1757   0F13 38 39 41 42 
1757   0F17 43 44 45 46 
1758   0F1B             ; --- END INLINE ASM SEGMENT
1759   0F1B F9            leave
1760   0F1C 09            ret
1761   0F1D             ; --- END TEXT SEGMENT
1762   0F1D             
1763   0F1D             ; --- BEGIN DATA SEGMENT
1764   0F1D 54 65 73 74 _s0: .db "Test %d, Result: %d\n", 0
1764   0F21 20 25 64 2C 
1764   0F25 20 52 65 73 
1764   0F29 75 6C 74 3A 
1764   0F2D 20 25 64 0A 
1764   0F31 00 
1765   0F32 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1765   0F36 70 65 63 74 
1765   0F3A 65 64 20 66 
1765   0F3E 6F 72 6D 61 
1765   0F42 74 20 69 6E 
1765   0F46 20 70 72 69 
1765   0F4A 6E 74 66 2E 
1765   0F4E 00 
1766   0F4F 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1766   0F53 72 3A 20 55 
1766   0F57 6E 6B 6E 6F 
1766   0F5B 77 6E 20 61 
1766   0F5F 72 67 75 6D 
1766   0F63 65 6E 74 20 
1766   0F67 74 79 70 65 
1766   0F6B 2E 0A 00 
1767   0F6E             
1768   0F6E 70 0F       _heap_top: .dw _heap
1769   0F70 00          _heap: .db 0
1770   0F71             ; --- END DATA SEGMENT
1771   0F71             
1772   0F71             .end
tasm: Number of errors = 0
