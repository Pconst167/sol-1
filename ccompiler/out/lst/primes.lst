0001   0000             ; --- FILENAME: programs/primes.c
0002   0000             ; --- DATE:     07-07-2025 at 11:42:44
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._7seg_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; unsigned int N, i; 
0012   0408 52 02 00      sub sp, 2
0013   040B 52 02 00      sub sp, 2
0014   040E             ; printf("Enter a number to find all prime numbers up to it: "); 
0015   040E             ; --- START FUNCTION CALL
0016   040E 26 2D 12      mov b, _s0 ; "Enter a number to find all prime numbers up to it: "
0017   0411 FD AB         swp b
0018   0413 D8            push b
0019   0414 07 06 08      call printf
0020   0417 51 02 00      add sp, 2
0021   041A             ; --- END FUNCTION CALL
0022   041A             ; N = scann(); 
0023   041A FA FF FF      lea d, [bp + -1] ; $N
0024   041D DA            push d
0025   041E             ; --- START FUNCTION CALL
0026   041E 07 1A 11      call scann
0027   0421 E7            pop d
0028   0422 FD 43         mov [d], b
0029   0424             ; printf("Prime numbers are: \n"); 
0030   0424             ; --- START FUNCTION CALL
0031   0424 26 61 12      mov b, _s1 ; "Prime numbers are: \n"
0032   0427 FD AB         swp b
0033   0429 D8            push b
0034   042A 07 06 08      call printf
0035   042D 51 02 00      add sp, 2
0036   0430             ; --- END FUNCTION CALL
0037   0430             ; for (i = 2; i <= N; i++) { 
0038   0430             _for1_init:
0039   0430 FA FD FF      lea d, [bp + -3] ; $i
0040   0433 DA            push d
0041   0434 FD 2E 02 00   mov32 cb, $00000002
0041   0438 00 00 
0042   043A E7            pop d
0043   043B FD 43         mov [d], b
0044   043D             _for1_cond:
0045   043D FA FD FF      lea d, [bp + -3] ; $i
0046   0440 2A            mov b, [d]
0047   0441 38 00 00      mov c, 0
0048   0444             ; --- START RELATIONAL
0049   0444 D7            push a
0050   0445 11            mov a, b
0051   0446 FA FF FF      lea d, [bp + -1] ; $N
0052   0449 2A            mov b, [d]
0053   044A 38 00 00      mov c, 0
0054   044D B0            cmp a, b
0055   044E FD 76         sleu ; <= (unsigned)
0056   0450 E4            pop a
0057   0451             ; --- END RELATIONAL
0058   0451 C0 00 00      cmp b, 0
0059   0454 C6 99 04      je _for1_exit
0060   0457             _for1_block:
0061   0457             ; if (isPrime(i)) { 
0062   0457             _if2_cond:
0063   0457             ; --- START FUNCTION CALL
0064   0457 FA FD FF      lea d, [bp + -3] ; $i
0065   045A 2A            mov b, [d]
0066   045B 38 00 00      mov c, 0
0067   045E FD AB         swp b
0068   0460 D8            push b
0069   0461 07 0D 07      call isPrime
0070   0464 51 02 00      add sp, 2
0071   0467             ; --- END FUNCTION CALL
0072   0467 C0 00 00      cmp b, 0
0073   046A C6 86 04      je _if2_exit
0074   046D             _if2_TRUE:
0075   046D             ; printf("%u\n", i); 
0076   046D             ; --- START FUNCTION CALL
0077   046D FA FD FF      lea d, [bp + -3] ; $i
0078   0470 2A            mov b, [d]
0079   0471 38 00 00      mov c, 0
0080   0474 FD AB         swp b
0081   0476 D8            push b
0082   0477 26 76 12      mov b, _s2 ; "%u\n"
0083   047A FD AB         swp b
0084   047C D8            push b
0085   047D 07 06 08      call printf
0086   0480 51 04 00      add sp, 4
0087   0483             ; --- END FUNCTION CALL
0088   0483 0A 86 04      jmp _if2_exit
0089   0486             _if2_exit:
0090   0486             _for1_update:
0091   0486 FA FD FF      lea d, [bp + -3] ; $i
0092   0489 2A            mov b, [d]
0093   048A 38 00 00      mov c, 0
0094   048D 11            mov a, b
0095   048E FD 77         inc b
0096   0490 FA FD FF      lea d, [bp + -3] ; $i
0097   0493 FD 43         mov [d], b
0098   0495 27            mov b, a
0099   0496 0A 3D 04      jmp _for1_cond
0100   0499             _for1_exit:
0101   0499             ; return 0; 
0102   0499 FD 2E 00 00   mov32 cb, $00000000
0102   049D 00 00 
0103   049F F9            leave
0104   04A0 05 0B         syscall sys_terminate_proc
0105   04A2             
0106   04A2             sqrt:
0107   04A2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0108   04A5             ; if (n <= 1) { 
0109   04A5             _if3_cond:
0110   04A5 FA 05 00      lea d, [bp + 5] ; $n
0111   04A8 2A            mov b, [d]
0112   04A9 38 00 00      mov c, 0
0113   04AC             ; --- START RELATIONAL
0114   04AC D7            push a
0115   04AD 11            mov a, b
0116   04AE FD 2E 01 00   mov32 cb, $00000001
0116   04B2 00 00 
0117   04B4 B0            cmp a, b
0118   04B5 FD 74         sle ; <= (signed)
0119   04B7 E4            pop a
0120   04B8             ; --- END RELATIONAL
0121   04B8 C0 00 00      cmp b, 0
0122   04BB C6 CA 04      je _if3_exit
0123   04BE             _if3_TRUE:
0124   04BE             ; return n; 
0125   04BE FA 05 00      lea d, [bp + 5] ; $n
0126   04C1 2A            mov b, [d]
0127   04C2 38 00 00      mov c, 0
0128   04C5 F9            leave
0129   04C6 09            ret
0130   04C7 0A CA 04      jmp _if3_exit
0131   04CA             _if3_exit:
0132   04CA             ; int x; 
0133   04CA 52 02 00      sub sp, 2
0134   04CD             ; int y; 
0135   04CD 52 02 00      sub sp, 2
0136   04D0             ; x = n; 
0137   04D0 FA FF FF      lea d, [bp + -1] ; $x
0138   04D3 DA            push d
0139   04D4 FA 05 00      lea d, [bp + 5] ; $n
0140   04D7 2A            mov b, [d]
0141   04D8 38 00 00      mov c, 0
0142   04DB E7            pop d
0143   04DC FD 43         mov [d], b
0144   04DE             ; y = (x + n / x) / 2; 
0145   04DE FA FD FF      lea d, [bp + -3] ; $y
0146   04E1 DA            push d
0147   04E2 FA FF FF      lea d, [bp + -1] ; $x
0148   04E5 2A            mov b, [d]
0149   04E6 38 00 00      mov c, 0
0150   04E9             ; --- START TERMS
0151   04E9 D7            push a
0152   04EA 11            mov a, b
0153   04EB FA 05 00      lea d, [bp + 5] ; $n
0154   04EE 2A            mov b, [d]
0155   04EF 38 00 00      mov c, 0
0156   04F2             ; --- START FACTORS
0157   04F2 D7            push a
0158   04F3 FD D8         push g
0159   04F5 11            mov a, b
0160   04F6 FD 7A         mov g, c
0161   04F8 FA FF FF      lea d, [bp + -1] ; $x
0162   04FB 2A            mov b, [d]
0163   04FC 38 00 00      mov c, 0
0164   04FF FD D8         push g ; save 'g' as the div instruction uses it
0165   0501 AE            div a, b ; /, a: quotient, b: remainder
0166   0502 FD F1         pop g
0167   0504 FD 38         mov c, g
0168   0506 27            mov b, a
0169   0507 FD F1         pop g
0170   0509 E4            pop a
0171   050A             ; --- END FACTORS
0172   050A 56            add b, a
0173   050B E4            pop a
0174   050C             ; --- END TERMS
0175   050C             ; --- START FACTORS
0176   050C D7            push a
0177   050D FD D8         push g
0178   050F 11            mov a, b
0179   0510 FD 7A         mov g, c
0180   0512 FD 2E 02 00   mov32 cb, $00000002
0180   0516 00 00 
0181   0518 FD D8         push g ; save 'g' as the div instruction uses it
0182   051A AE            div a, b ; /, a: quotient, b: remainder
0183   051B FD F1         pop g
0184   051D FD 38         mov c, g
0185   051F 27            mov b, a
0186   0520 FD F1         pop g
0187   0522 E4            pop a
0188   0523             ; --- END FACTORS
0189   0523 E7            pop d
0190   0524 FD 43         mov [d], b
0191   0526             ; while (y < x) { 
0192   0526             _while10_cond:
0193   0526 FA FD FF      lea d, [bp + -3] ; $y
0194   0529 2A            mov b, [d]
0195   052A 38 00 00      mov c, 0
0196   052D             ; --- START RELATIONAL
0197   052D D7            push a
0198   052E 11            mov a, b
0199   052F FA FF FF      lea d, [bp + -1] ; $x
0200   0532 2A            mov b, [d]
0201   0533 38 00 00      mov c, 0
0202   0536 B0            cmp a, b
0203   0537 FD 73         slt ; < (signed)
0204   0539 E4            pop a
0205   053A             ; --- END RELATIONAL
0206   053A C0 00 00      cmp b, 0
0207   053D C6 99 05      je _while10_exit
0208   0540             _while10_block:
0209   0540             ; x = y; 
0210   0540 FA FF FF      lea d, [bp + -1] ; $x
0211   0543 DA            push d
0212   0544 FA FD FF      lea d, [bp + -3] ; $y
0213   0547 2A            mov b, [d]
0214   0548 38 00 00      mov c, 0
0215   054B E7            pop d
0216   054C FD 43         mov [d], b
0217   054E             ; y = (x + n / x) / 2; 
0218   054E FA FD FF      lea d, [bp + -3] ; $y
0219   0551 DA            push d
0220   0552 FA FF FF      lea d, [bp + -1] ; $x
0221   0555 2A            mov b, [d]
0222   0556 38 00 00      mov c, 0
0223   0559             ; --- START TERMS
0224   0559 D7            push a
0225   055A 11            mov a, b
0226   055B FA 05 00      lea d, [bp + 5] ; $n
0227   055E 2A            mov b, [d]
0228   055F 38 00 00      mov c, 0
0229   0562             ; --- START FACTORS
0230   0562 D7            push a
0231   0563 FD D8         push g
0232   0565 11            mov a, b
0233   0566 FD 7A         mov g, c
0234   0568 FA FF FF      lea d, [bp + -1] ; $x
0235   056B 2A            mov b, [d]
0236   056C 38 00 00      mov c, 0
0237   056F FD D8         push g ; save 'g' as the div instruction uses it
0238   0571 AE            div a, b ; /, a: quotient, b: remainder
0239   0572 FD F1         pop g
0240   0574 FD 38         mov c, g
0241   0576 27            mov b, a
0242   0577 FD F1         pop g
0243   0579 E4            pop a
0244   057A             ; --- END FACTORS
0245   057A 56            add b, a
0246   057B E4            pop a
0247   057C             ; --- END TERMS
0248   057C             ; --- START FACTORS
0249   057C D7            push a
0250   057D FD D8         push g
0251   057F 11            mov a, b
0252   0580 FD 7A         mov g, c
0253   0582 FD 2E 02 00   mov32 cb, $00000002
0253   0586 00 00 
0254   0588 FD D8         push g ; save 'g' as the div instruction uses it
0255   058A AE            div a, b ; /, a: quotient, b: remainder
0256   058B FD F1         pop g
0257   058D FD 38         mov c, g
0258   058F 27            mov b, a
0259   0590 FD F1         pop g
0260   0592 E4            pop a
0261   0593             ; --- END FACTORS
0262   0593 E7            pop d
0263   0594 FD 43         mov [d], b
0264   0596 0A 26 05      jmp _while10_cond
0265   0599             _while10_exit:
0266   0599             ; return x; 
0267   0599 FA FF FF      lea d, [bp + -1] ; $x
0268   059C 2A            mov b, [d]
0269   059D 38 00 00      mov c, 0
0270   05A0 F9            leave
0271   05A1 09            ret
0272   05A2             
0273   05A2             primes1:
0274   05A2 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0275   05A5             ; unsigned int n, i, s, count, divides; 
0276   05A5 52 02 00      sub sp, 2
0277   05A8 52 02 00      sub sp, 2
0278   05AB 52 02 00      sub sp, 2
0279   05AE 52 02 00      sub sp, 2
0280   05B1 52 02 00      sub sp, 2
0281   05B4             ; n = 2; 
0282   05B4 FA FF FF      lea d, [bp + -1] ; $n
0283   05B7 DA            push d
0284   05B8 FD 2E 02 00   mov32 cb, $00000002
0284   05BC 00 00 
0285   05BE E7            pop d
0286   05BF FD 43         mov [d], b
0287   05C1             ; while(n < top){ 
0288   05C1             _while17_cond:
0289   05C1 FA FF FF      lea d, [bp + -1] ; $n
0290   05C4 2A            mov b, [d]
0291   05C5 38 00 00      mov c, 0
0292   05C8             ; --- START RELATIONAL
0293   05C8 D7            push a
0294   05C9 11            mov a, b
0295   05CA 3B 2B 12      mov d, _top ; $top
0296   05CD 2A            mov b, [d]
0297   05CE 38 00 00      mov c, 0
0298   05D1 B0            cmp a, b
0299   05D2 FD 75         slu ; < (unsigned)
0300   05D4 E4            pop a
0301   05D5             ; --- END RELATIONAL
0302   05D5 C0 00 00      cmp b, 0
0303   05D8 C6 0B 07      je _while17_exit
0304   05DB             _while17_block:
0305   05DB             ; s = sqrt(n); 
0306   05DB FA FB FF      lea d, [bp + -5] ; $s
0307   05DE DA            push d
0308   05DF             ; --- START FUNCTION CALL
0309   05DF FA FF FF      lea d, [bp + -1] ; $n
0310   05E2 2A            mov b, [d]
0311   05E3 38 00 00      mov c, 0
0312   05E6 FD AB         swp b
0313   05E8 D8            push b
0314   05E9 07 A2 04      call sqrt
0315   05EC 51 02 00      add sp, 2
0316   05EF             ; --- END FUNCTION CALL
0317   05EF E7            pop d
0318   05F0 FD 43         mov [d], b
0319   05F2             ; divides = 0; 
0320   05F2 FA F7 FF      lea d, [bp + -9] ; $divides
0321   05F5 DA            push d
0322   05F6 FD 2E 00 00   mov32 cb, $00000000
0322   05FA 00 00 
0323   05FC E7            pop d
0324   05FD FD 43         mov [d], b
0325   05FF             ; i = 2; 
0326   05FF FA FD FF      lea d, [bp + -3] ; $i
0327   0602 DA            push d
0328   0603 FD 2E 02 00   mov32 cb, $00000002
0328   0607 00 00 
0329   0609 E7            pop d
0330   060A FD 43         mov [d], b
0331   060C             ; while(i <= s){ 
0332   060C             _while18_cond:
0333   060C FA FD FF      lea d, [bp + -3] ; $i
0334   060F 2A            mov b, [d]
0335   0610 38 00 00      mov c, 0
0336   0613             ; --- START RELATIONAL
0337   0613 D7            push a
0338   0614 11            mov a, b
0339   0615 FA FB FF      lea d, [bp + -5] ; $s
0340   0618 2A            mov b, [d]
0341   0619 38 00 00      mov c, 0
0342   061C B0            cmp a, b
0343   061D FD 76         sleu ; <= (unsigned)
0344   061F E4            pop a
0345   0620             ; --- END RELATIONAL
0346   0620 C0 00 00      cmp b, 0
0347   0623 C6 A6 06      je _while18_exit
0348   0626             _while18_block:
0349   0626             ; if(n % i == 0){ 
0350   0626             _if19_cond:
0351   0626 FA FF FF      lea d, [bp + -1] ; $n
0352   0629 2A            mov b, [d]
0353   062A 38 00 00      mov c, 0
0354   062D             ; --- START FACTORS
0355   062D D7            push a
0356   062E FD D8         push g
0357   0630 11            mov a, b
0358   0631 FD 7A         mov g, c
0359   0633 FA FD FF      lea d, [bp + -3] ; $i
0360   0636 2A            mov b, [d]
0361   0637 38 00 00      mov c, 0
0362   063A FD D8         push g ; save 'g' as the div instruction uses it
0363   063C AE            div a, b ; %, a: quotient, b: remainder
0364   063D 11            mov a, b
0365   063E FD F1         pop g
0366   0640 FD 38         mov c, g
0367   0642 27            mov b, a
0368   0643 FD F1         pop g
0369   0645 E4            pop a
0370   0646             ; --- END FACTORS
0371   0646             ; --- START RELATIONAL
0372   0646 D7            push a
0373   0647 11            mov a, b
0374   0648 FD 2E 00 00   mov32 cb, $00000000
0374   064C 00 00 
0375   064E B0            cmp a, b
0376   064F FD 71         seq ; ==
0377   0651 E4            pop a
0378   0652             ; --- END RELATIONAL
0379   0652 C0 00 00      cmp b, 0
0380   0655 C6 6B 06      je _if19_exit
0381   0658             _if19_TRUE:
0382   0658             ; divides = 1; 
0383   0658 FA F7 FF      lea d, [bp + -9] ; $divides
0384   065B DA            push d
0385   065C FD 2E 01 00   mov32 cb, $00000001
0385   0660 00 00 
0386   0662 E7            pop d
0387   0663 FD 43         mov [d], b
0388   0665             ; break; 
0389   0665 0A A6 06      jmp _while18_exit ; while break
0390   0668 0A 6B 06      jmp _if19_exit
0391   066B             _if19_exit:
0392   066B             ; i = i + 1; 
0393   066B FA FD FF      lea d, [bp + -3] ; $i
0394   066E DA            push d
0395   066F FA FD FF      lea d, [bp + -3] ; $i
0396   0672 2A            mov b, [d]
0397   0673 38 00 00      mov c, 0
0398   0676             ; --- START TERMS
0399   0676 D7            push a
0400   0677 11            mov a, b
0401   0678 FD 2E 01 00   mov32 cb, $00000001
0401   067C 00 00 
0402   067E 56            add b, a
0403   067F E4            pop a
0404   0680             ; --- END TERMS
0405   0680 E7            pop d
0406   0681 FD 43         mov [d], b
0407   0683             ; if(i >= s) break; 
0408   0683             _if22_cond:
0409   0683 FA FD FF      lea d, [bp + -3] ; $i
0410   0686 2A            mov b, [d]
0411   0687 38 00 00      mov c, 0
0412   068A             ; --- START RELATIONAL
0413   068A D7            push a
0414   068B 11            mov a, b
0415   068C FA FB FF      lea d, [bp + -5] ; $s
0416   068F 2A            mov b, [d]
0417   0690 38 00 00      mov c, 0
0418   0693 B0            cmp a, b
0419   0694 FD 82         sgeu ; >= (unsigned)
0420   0696 E4            pop a
0421   0697             ; --- END RELATIONAL
0422   0697 C0 00 00      cmp b, 0
0423   069A C6 A3 06      je _if22_exit
0424   069D             _if22_TRUE:
0425   069D             ; break; 
0426   069D 0A A6 06      jmp _while18_exit ; while break
0427   06A0 0A A3 06      jmp _if22_exit
0428   06A3             _if22_exit:
0429   06A3 0A 0C 06      jmp _while18_cond
0430   06A6             _while18_exit:
0431   06A6             ; if(divides == 0){ 
0432   06A6             _if23_cond:
0433   06A6 FA F7 FF      lea d, [bp + -9] ; $divides
0434   06A9 2A            mov b, [d]
0435   06AA 38 00 00      mov c, 0
0436   06AD             ; --- START RELATIONAL
0437   06AD D7            push a
0438   06AE 11            mov a, b
0439   06AF FD 2E 00 00   mov32 cb, $00000000
0439   06B3 00 00 
0440   06B5 B0            cmp a, b
0441   06B6 FD 71         seq ; ==
0442   06B8 E4            pop a
0443   06B9             ; --- END RELATIONAL
0444   06B9 C0 00 00      cmp b, 0
0445   06BC C6 F0 06      je _if23_exit
0446   06BF             _if23_TRUE:
0447   06BF             ; count = count + 1;	 
0448   06BF FA F9 FF      lea d, [bp + -7] ; $count
0449   06C2 DA            push d
0450   06C3 FA F9 FF      lea d, [bp + -7] ; $count
0451   06C6 2A            mov b, [d]
0452   06C7 38 00 00      mov c, 0
0453   06CA             ; --- START TERMS
0454   06CA D7            push a
0455   06CB 11            mov a, b
0456   06CC FD 2E 01 00   mov32 cb, $00000001
0456   06D0 00 00 
0457   06D2 56            add b, a
0458   06D3 E4            pop a
0459   06D4             ; --- END TERMS
0460   06D4 E7            pop d
0461   06D5 FD 43         mov [d], b
0462   06D7             ; printf("%d\n", n); 
0463   06D7             ; --- START FUNCTION CALL
0464   06D7 FA FF FF      lea d, [bp + -1] ; $n
0465   06DA 2A            mov b, [d]
0466   06DB 38 00 00      mov c, 0
0467   06DE FD AB         swp b
0468   06E0 D8            push b
0469   06E1 26 7A 12      mov b, _s3 ; "%d\n"
0470   06E4 FD AB         swp b
0471   06E6 D8            push b
0472   06E7 07 06 08      call printf
0473   06EA 51 04 00      add sp, 4
0474   06ED             ; --- END FUNCTION CALL
0475   06ED 0A F0 06      jmp _if23_exit
0476   06F0             _if23_exit:
0477   06F0             ; n = n + 1; 
0478   06F0 FA FF FF      lea d, [bp + -1] ; $n
0479   06F3 DA            push d
0480   06F4 FA FF FF      lea d, [bp + -1] ; $n
0481   06F7 2A            mov b, [d]
0482   06F8 38 00 00      mov c, 0
0483   06FB             ; --- START TERMS
0484   06FB D7            push a
0485   06FC 11            mov a, b
0486   06FD FD 2E 01 00   mov32 cb, $00000001
0486   0701 00 00 
0487   0703 56            add b, a
0488   0704 E4            pop a
0489   0705             ; --- END TERMS
0490   0705 E7            pop d
0491   0706 FD 43         mov [d], b
0492   0708 0A C1 05      jmp _while17_cond
0493   070B             _while17_exit:
0494   070B             ; return; 
0495   070B F9            leave
0496   070C 09            ret
0497   070D             
0498   070D             isPrime:
0499   070D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0500   0710             ; unsigned int i; 
0501   0710 52 02 00      sub sp, 2
0502   0713             ; if (num <= 1) return 0; 
0503   0713             _if24_cond:
0504   0713 FA 05 00      lea d, [bp + 5] ; $num
0505   0716 2A            mov b, [d]
0506   0717 38 00 00      mov c, 0
0507   071A             ; --- START RELATIONAL
0508   071A D7            push a
0509   071B 11            mov a, b
0510   071C FD 2E 01 00   mov32 cb, $00000001
0510   0720 00 00 
0511   0722 B0            cmp a, b
0512   0723 FD 76         sleu ; <= (unsigned)
0513   0725 E4            pop a
0514   0726             ; --- END RELATIONAL
0515   0726 C0 00 00      cmp b, 0
0516   0729 C6 37 07      je _if24_exit
0517   072C             _if24_TRUE:
0518   072C             ; return 0; 
0519   072C FD 2E 00 00   mov32 cb, $00000000
0519   0730 00 00 
0520   0732 F9            leave
0521   0733 09            ret
0522   0734 0A 37 07      jmp _if24_exit
0523   0737             _if24_exit:
0524   0737             ; for (i = 2; i * i <= num; i++) { 
0525   0737             _for25_init:
0526   0737 FA FF FF      lea d, [bp + -1] ; $i
0527   073A DA            push d
0528   073B FD 2E 02 00   mov32 cb, $00000002
0528   073F 00 00 
0529   0741 E7            pop d
0530   0742 FD 43         mov [d], b
0531   0744             _for25_cond:
0532   0744 FA FF FF      lea d, [bp + -1] ; $i
0533   0747 2A            mov b, [d]
0534   0748 38 00 00      mov c, 0
0535   074B             ; --- START FACTORS
0536   074B D7            push a
0537   074C FD D8         push g
0538   074E 11            mov a, b
0539   074F FD 7A         mov g, c
0540   0751 FA FF FF      lea d, [bp + -1] ; $i
0541   0754 2A            mov b, [d]
0542   0755 38 00 00      mov c, 0
0543   0758 D7            push a     ; save left operand
0544   0759 8E            xor a, b   ; xor sign bits
0545   075A FD AA         swp a      ; swap bytes
0546   075C 83            mov cl, al ; save result of xor into 'dl'
0547   075D E4            pop a      ; restore left side operator
0548   075E DF            push cl    ; save result of xor above
0549   075F FD AA         swp a  
0550   0761 93 80         test al, $80  
0551   0763 FD AA         swp a  
0552   0765 C6 6A 07      jz skip_invert_a_27  
0553   0768 FD 95         neg a 
0554   076A             skip_invert_a_27:   
0555   076A FD AB         swp b
0556   076C FD 93 80      test bl, $80  
0557   076F FD AB         swp b
0558   0771 C6 76 07      jz skip_invert_b_27  
0559   0774 FD 97         neg b 
0560   0776             skip_invert_b_27:   
0561   0776 AC            mul a, b ; *
0562   0777 FD 78         mov g, a
0563   0779 11            mov a, b
0564   077A EA            pop bl
0565   077B FD 93 80      test bl, $80
0566   077E C6 8B 07      jz _same_signs_27
0567   0781 2F            mov bl, al
0568   0782 95            not a
0569   0783 FD 97         neg b
0570   0785 5B 00 00      adc a, 0
0571   0788 FD 78         mov g, a
0572   078A 11            mov a, b
0573   078B             _same_signs_27:
0574   078B FD 38         mov c, g
0575   078D 27            mov b, a
0576   078E FD F1         pop g
0577   0790 E4            pop a
0578   0791             ; --- END FACTORS
0579   0791             ; --- START RELATIONAL
0580   0791 D7            push a
0581   0792 FD D8         push g
0582   0794 11            mov a, b
0583   0795 FD 7A         mov g, c
0584   0797 FA 05 00      lea d, [bp + 5] ; $num
0585   079A 2A            mov b, [d]
0586   079B 38 00 00      mov c, 0
0587   079E 38 00 00      mov c, 0
0588   07A1 FD AF         cmp32 ga, cb
0589   07A3 FD 76         sleu
0590   07A5 FD F1         pop g
0591   07A7 E4            pop a
0592   07A8             ; --- END RELATIONAL
0593   07A8 C0 00 00      cmp b, 0
0594   07AB C6 FE 07      je _for25_exit
0595   07AE             _for25_block:
0596   07AE             ; if (num % i == 0) return 0; 
0597   07AE             _if28_cond:
0598   07AE FA 05 00      lea d, [bp + 5] ; $num
0599   07B1 2A            mov b, [d]
0600   07B2 38 00 00      mov c, 0
0601   07B5             ; --- START FACTORS
0602   07B5 D7            push a
0603   07B6 FD D8         push g
0604   07B8 11            mov a, b
0605   07B9 FD 7A         mov g, c
0606   07BB FA FF FF      lea d, [bp + -1] ; $i
0607   07BE 2A            mov b, [d]
0608   07BF 38 00 00      mov c, 0
0609   07C2 FD D8         push g ; save 'g' as the div instruction uses it
0610   07C4 AE            div a, b ; %, a: quotient, b: remainder
0611   07C5 11            mov a, b
0612   07C6 FD F1         pop g
0613   07C8 FD 38         mov c, g
0614   07CA 27            mov b, a
0615   07CB FD F1         pop g
0616   07CD E4            pop a
0617   07CE             ; --- END FACTORS
0618   07CE             ; --- START RELATIONAL
0619   07CE D7            push a
0620   07CF 11            mov a, b
0621   07D0 FD 2E 00 00   mov32 cb, $00000000
0621   07D4 00 00 
0622   07D6 B0            cmp a, b
0623   07D7 FD 71         seq ; ==
0624   07D9 E4            pop a
0625   07DA             ; --- END RELATIONAL
0626   07DA C0 00 00      cmp b, 0
0627   07DD C6 EB 07      je _if28_exit
0628   07E0             _if28_TRUE:
0629   07E0             ; return 0; 
0630   07E0 FD 2E 00 00   mov32 cb, $00000000
0630   07E4 00 00 
0631   07E6 F9            leave
0632   07E7 09            ret
0633   07E8 0A EB 07      jmp _if28_exit
0634   07EB             _if28_exit:
0635   07EB             _for25_update:
0636   07EB FA FF FF      lea d, [bp + -1] ; $i
0637   07EE 2A            mov b, [d]
0638   07EF 38 00 00      mov c, 0
0639   07F2 11            mov a, b
0640   07F3 FD 77         inc b
0641   07F5 FA FF FF      lea d, [bp + -1] ; $i
0642   07F8 FD 43         mov [d], b
0643   07FA 27            mov b, a
0644   07FB 0A 44 07      jmp _for25_cond
0645   07FE             _for25_exit:
0646   07FE             ; return 1; 
0647   07FE FD 2E 01 00   mov32 cb, $00000001
0647   0802 00 00 
0648   0804 F9            leave
0649   0805 09            ret
0650   0806             
0651   0806             printf:
0652   0806 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0653   0809             ; char *p, *format_p; 
0654   0809 52 02 00      sub sp, 2
0655   080C 52 02 00      sub sp, 2
0656   080F             ; format_p = format; 
0657   080F FA FD FF      lea d, [bp + -3] ; $format_p
0658   0812 DA            push d
0659   0813 FA 05 00      lea d, [bp + 5] ; $format
0660   0816 2A            mov b, [d]
0661   0817 38 00 00      mov c, 0
0662   081A E7            pop d
0663   081B FD 43         mov [d], b
0664   081D             ; p = &format + 2; 
0665   081D FA FF FF      lea d, [bp + -1] ; $p
0666   0820 DA            push d
0667   0821 FA 05 00      lea d, [bp + 5] ; $format
0668   0824 2D            mov b, d
0669   0825             ; --- START TERMS
0670   0825 D7            push a
0671   0826 11            mov a, b
0672   0827 FD 2E 02 00   mov32 cb, $00000002
0672   082B 00 00 
0673   082D 56            add b, a
0674   082E E4            pop a
0675   082F             ; --- END TERMS
0676   082F E7            pop d
0677   0830 FD 43         mov [d], b
0678   0832             ; for(;;){ 
0679   0832             _for31_init:
0680   0832             _for31_cond:
0681   0832             _for31_block:
0682   0832             ; if(!*format_p) break; 
0683   0832             _if32_cond:
0684   0832 FA FD FF      lea d, [bp + -3] ; $format_p
0685   0835 2A            mov b, [d]
0686   0836 38 00 00      mov c, 0
0687   0839 74            mov d, b
0688   083A 32            mov bl, [d]
0689   083B A7 00         mov bh, 0
0690   083D 38 00 00      mov c, 0
0691   0840 C0 00 00      cmp b, 0
0692   0843 FD 71         seq ; !
0693   0845 C0 00 00      cmp b, 0
0694   0848 C6 51 08      je _if32_else
0695   084B             _if32_TRUE:
0696   084B             ; break; 
0697   084B 0A F1 0A      jmp _for31_exit ; for break
0698   084E 0A DE 0A      jmp _if32_exit
0699   0851             _if32_else:
0700   0851             ; if(*format_p == '%'){ 
0701   0851             _if33_cond:
0702   0851 FA FD FF      lea d, [bp + -3] ; $format_p
0703   0854 2A            mov b, [d]
0704   0855 38 00 00      mov c, 0
0705   0858 74            mov d, b
0706   0859 32            mov bl, [d]
0707   085A A7 00         mov bh, 0
0708   085C 38 00 00      mov c, 0
0709   085F             ; --- START RELATIONAL
0710   085F D7            push a
0711   0860 11            mov a, b
0712   0861 FD 2E 25 00   mov32 cb, $00000025
0712   0865 00 00 
0713   0867 B0            cmp a, b
0714   0868 FD 71         seq ; ==
0715   086A E4            pop a
0716   086B             ; --- END RELATIONAL
0717   086B C0 00 00      cmp b, 0
0718   086E C6 C9 0A      je _if33_else
0719   0871             _if33_TRUE:
0720   0871             ; format_p++; 
0721   0871 FA FD FF      lea d, [bp + -3] ; $format_p
0722   0874 2A            mov b, [d]
0723   0875 38 00 00      mov c, 0
0724   0878 FD 77         inc b
0725   087A FA FD FF      lea d, [bp + -3] ; $format_p
0726   087D FD 43         mov [d], b
0727   087F FD 7D         dec b
0728   0881             ; switch(*format_p){ 
0729   0881             _switch34_expr:
0730   0881 FA FD FF      lea d, [bp + -3] ; $format_p
0731   0884 2A            mov b, [d]
0732   0885 38 00 00      mov c, 0
0733   0888 74            mov d, b
0734   0889 32            mov bl, [d]
0735   088A A7 00         mov bh, 0
0736   088C 38 00 00      mov c, 0
0737   088F             _switch34_comparisons:
0738   088F C1 6C         cmp bl, $6c
0739   0891 C6 BD 08      je _switch34_case0
0740   0894 C1 4C         cmp bl, $4c
0741   0896 C6 BD 08      je _switch34_case1
0742   0899 C1 64         cmp bl, $64
0743   089B C6 CD 09      je _switch34_case2
0744   089E C1 69         cmp bl, $69
0745   08A0 C6 CD 09      je _switch34_case3
0746   08A3 C1 75         cmp bl, $75
0747   08A5 C6 FD 09      je _switch34_case4
0748   08A8 C1 78         cmp bl, $78
0749   08AA C6 2D 0A      je _switch34_case5
0750   08AD C1 63         cmp bl, $63
0751   08AF C6 5D 0A      je _switch34_case6
0752   08B2 C1 73         cmp bl, $73
0753   08B4 C6 8D 0A      je _switch34_case7
0754   08B7 0A BA 0A      jmp _switch34_default
0755   08BA 0A C6 0A      jmp _switch34_exit
0756   08BD             _switch34_case0:
0757   08BD             _switch34_case1:
0758   08BD             ; format_p++; 
0759   08BD FA FD FF      lea d, [bp + -3] ; $format_p
0760   08C0 2A            mov b, [d]
0761   08C1 38 00 00      mov c, 0
0762   08C4 FD 77         inc b
0763   08C6 FA FD FF      lea d, [bp + -3] ; $format_p
0764   08C9 FD 43         mov [d], b
0765   08CB FD 7D         dec b
0766   08CD             ; if(*format_p == 'd' || *format_p == 'i') 
0767   08CD             _if35_cond:
0768   08CD FA FD FF      lea d, [bp + -3] ; $format_p
0769   08D0 2A            mov b, [d]
0770   08D1 38 00 00      mov c, 0
0771   08D4 74            mov d, b
0772   08D5 32            mov bl, [d]
0773   08D6 A7 00         mov bh, 0
0774   08D8 38 00 00      mov c, 0
0775   08DB             ; --- START RELATIONAL
0776   08DB D7            push a
0777   08DC 11            mov a, b
0778   08DD FD 2E 64 00   mov32 cb, $00000064
0778   08E1 00 00 
0779   08E3 B0            cmp a, b
0780   08E4 FD 71         seq ; ==
0781   08E6 E4            pop a
0782   08E7             ; --- END RELATIONAL
0783   08E7             ; --- START LOGICAL OR
0784   08E7 D7            push a
0785   08E8 11            mov a, b
0786   08E9 FA FD FF      lea d, [bp + -3] ; $format_p
0787   08EC 2A            mov b, [d]
0788   08ED 38 00 00      mov c, 0
0789   08F0 74            mov d, b
0790   08F1 32            mov bl, [d]
0791   08F2 A7 00         mov bh, 0
0792   08F4 38 00 00      mov c, 0
0793   08F7             ; --- START RELATIONAL
0794   08F7 D7            push a
0795   08F8 11            mov a, b
0796   08F9 FD 2E 69 00   mov32 cb, $00000069
0796   08FD 00 00 
0797   08FF B0            cmp a, b
0798   0900 FD 71         seq ; ==
0799   0902 E4            pop a
0800   0903             ; --- END RELATIONAL
0801   0903 FD A8         sor a, b ; ||
0802   0905 E4            pop a
0803   0906             ; --- END LOGICAL OR
0804   0906 C0 00 00      cmp b, 0
0805   0909 C6 2A 09      je _if35_else
0806   090C             _if35_TRUE:
0807   090C             ; print_signed_long(*(long *)p); 
0808   090C             ; --- START FUNCTION CALL
0809   090C FA FF FF      lea d, [bp + -1] ; $p
0810   090F 2A            mov b, [d]
0811   0910 38 00 00      mov c, 0
0812   0913 74            mov d, b
0813   0914 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0814   0917 FD 39         mov c, b ; And place it into C
0815   0919 2A            mov b, [d] ; Lower Word in B
0816   091A 12            mov a, c
0817   091B FD AA         swp a
0818   091D D7            push a
0819   091E FD AB         swp b
0820   0920 D8            push b
0821   0921 07 F3 0A      call print_signed_long
0822   0924 51 04 00      add sp, 4
0823   0927             ; --- END FUNCTION CALL
0824   0927 0A B2 09      jmp _if35_exit
0825   092A             _if35_else:
0826   092A             ; if(*format_p == 'u') 
0827   092A             _if36_cond:
0828   092A FA FD FF      lea d, [bp + -3] ; $format_p
0829   092D 2A            mov b, [d]
0830   092E 38 00 00      mov c, 0
0831   0931 74            mov d, b
0832   0932 32            mov bl, [d]
0833   0933 A7 00         mov bh, 0
0834   0935 38 00 00      mov c, 0
0835   0938             ; --- START RELATIONAL
0836   0938 D7            push a
0837   0939 11            mov a, b
0838   093A FD 2E 75 00   mov32 cb, $00000075
0838   093E 00 00 
0839   0940 B0            cmp a, b
0840   0941 FD 71         seq ; ==
0841   0943 E4            pop a
0842   0944             ; --- END RELATIONAL
0843   0944 C0 00 00      cmp b, 0
0844   0947 C6 68 09      je _if36_else
0845   094A             _if36_TRUE:
0846   094A             ; print_unsigned_long(*(unsigned long *)p); 
0847   094A             ; --- START FUNCTION CALL
0848   094A FA FF FF      lea d, [bp + -1] ; $p
0849   094D 2A            mov b, [d]
0850   094E 38 00 00      mov c, 0
0851   0951 74            mov d, b
0852   0952 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0853   0955 FD 39         mov c, b ; And place it into C
0854   0957 2A            mov b, [d] ; Lower Word in B
0855   0958 12            mov a, c
0856   0959 FD AA         swp a
0857   095B D7            push a
0858   095C FD AB         swp b
0859   095E D8            push b
0860   095F 07 93 0C      call print_unsigned_long
0861   0962 51 04 00      add sp, 4
0862   0965             ; --- END FUNCTION CALL
0863   0965 0A B2 09      jmp _if36_exit
0864   0968             _if36_else:
0865   0968             ; if(*format_p == 'x') 
0866   0968             _if37_cond:
0867   0968 FA FD FF      lea d, [bp + -3] ; $format_p
0868   096B 2A            mov b, [d]
0869   096C 38 00 00      mov c, 0
0870   096F 74            mov d, b
0871   0970 32            mov bl, [d]
0872   0971 A7 00         mov bh, 0
0873   0973 38 00 00      mov c, 0
0874   0976             ; --- START RELATIONAL
0875   0976 D7            push a
0876   0977 11            mov a, b
0877   0978 FD 2E 78 00   mov32 cb, $00000078
0877   097C 00 00 
0878   097E B0            cmp a, b
0879   097F FD 71         seq ; ==
0880   0981 E4            pop a
0881   0982             ; --- END RELATIONAL
0882   0982 C0 00 00      cmp b, 0
0883   0985 C6 A6 09      je _if37_else
0884   0988             _if37_TRUE:
0885   0988             ; printx32(*(long int *)p); 
0886   0988             ; --- START FUNCTION CALL
0887   0988 FA FF FF      lea d, [bp + -1] ; $p
0888   098B 2A            mov b, [d]
0889   098C 38 00 00      mov c, 0
0890   098F 74            mov d, b
0891   0990 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0892   0993 FD 39         mov c, b ; And place it into C
0893   0995 2A            mov b, [d] ; Lower Word in B
0894   0996 12            mov a, c
0895   0997 FD AA         swp a
0896   0999 D7            push a
0897   099A FD AB         swp b
0898   099C D8            push b
0899   099D 07 D1 0D      call printx32
0900   09A0 51 04 00      add sp, 4
0901   09A3             ; --- END FUNCTION CALL
0902   09A3 0A B2 09      jmp _if37_exit
0903   09A6             _if37_else:
0904   09A6             ; err("Unexpected format in printf."); 
0905   09A6             ; --- START FUNCTION CALL
0906   09A6 26 7E 12      mov b, _s4 ; "Unexpected format in printf."
0907   09A9 FD AB         swp b
0908   09AB D8            push b
0909   09AC 07 31 0E      call err
0910   09AF 51 02 00      add sp, 2
0911   09B2             ; --- END FUNCTION CALL
0912   09B2             _if37_exit:
0913   09B2             _if36_exit:
0914   09B2             _if35_exit:
0915   09B2             ; p = p + 4; 
0916   09B2 FA FF FF      lea d, [bp + -1] ; $p
0917   09B5 DA            push d
0918   09B6 FA FF FF      lea d, [bp + -1] ; $p
0919   09B9 2A            mov b, [d]
0920   09BA 38 00 00      mov c, 0
0921   09BD             ; --- START TERMS
0922   09BD D7            push a
0923   09BE 11            mov a, b
0924   09BF FD 2E 04 00   mov32 cb, $00000004
0924   09C3 00 00 
0925   09C5 56            add b, a
0926   09C6 E4            pop a
0927   09C7             ; --- END TERMS
0928   09C7 E7            pop d
0929   09C8 FD 43         mov [d], b
0930   09CA             ; break; 
0931   09CA 0A C6 0A      jmp _switch34_exit ; case break
0932   09CD             _switch34_case2:
0933   09CD             _switch34_case3:
0934   09CD             ; print_signed(*(int*)p); 
0935   09CD             ; --- START FUNCTION CALL
0936   09CD FA FF FF      lea d, [bp + -1] ; $p
0937   09D0 2A            mov b, [d]
0938   09D1 38 00 00      mov c, 0
0939   09D4 74            mov d, b
0940   09D5 2A            mov b, [d]
0941   09D6 38 00 00      mov c, 0
0942   09D9 FD AB         swp b
0943   09DB D8            push b
0944   09DC 07 5F 0E      call print_signed
0945   09DF 51 02 00      add sp, 2
0946   09E2             ; --- END FUNCTION CALL
0947   09E2             ; p = p + 2; 
0948   09E2 FA FF FF      lea d, [bp + -1] ; $p
0949   09E5 DA            push d
0950   09E6 FA FF FF      lea d, [bp + -1] ; $p
0951   09E9 2A            mov b, [d]
0952   09EA 38 00 00      mov c, 0
0953   09ED             ; --- START TERMS
0954   09ED D7            push a
0955   09EE 11            mov a, b
0956   09EF FD 2E 02 00   mov32 cb, $00000002
0956   09F3 00 00 
0957   09F5 56            add b, a
0958   09F6 E4            pop a
0959   09F7             ; --- END TERMS
0960   09F7 E7            pop d
0961   09F8 FD 43         mov [d], b
0962   09FA             ; break; 
0963   09FA 0A C6 0A      jmp _switch34_exit ; case break
0964   09FD             _switch34_case4:
0965   09FD             ; print_unsigned(*(unsigned int*)p); 
0966   09FD             ; --- START FUNCTION CALL
0967   09FD FA FF FF      lea d, [bp + -1] ; $p
0968   0A00 2A            mov b, [d]
0969   0A01 38 00 00      mov c, 0
0970   0A04 74            mov d, b
0971   0A05 2A            mov b, [d]
0972   0A06 38 00 00      mov c, 0
0973   0A09 FD AB         swp b
0974   0A0B D8            push b
0975   0A0C 07 B0 0F      call print_unsigned
0976   0A0F 51 02 00      add sp, 2
0977   0A12             ; --- END FUNCTION CALL
0978   0A12             ; p = p + 2; 
0979   0A12 FA FF FF      lea d, [bp + -1] ; $p
0980   0A15 DA            push d
0981   0A16 FA FF FF      lea d, [bp + -1] ; $p
0982   0A19 2A            mov b, [d]
0983   0A1A 38 00 00      mov c, 0
0984   0A1D             ; --- START TERMS
0985   0A1D D7            push a
0986   0A1E 11            mov a, b
0987   0A1F FD 2E 02 00   mov32 cb, $00000002
0987   0A23 00 00 
0988   0A25 56            add b, a
0989   0A26 E4            pop a
0990   0A27             ; --- END TERMS
0991   0A27 E7            pop d
0992   0A28 FD 43         mov [d], b
0993   0A2A             ; break; 
0994   0A2A 0A C6 0A      jmp _switch34_exit ; case break
0995   0A2D             _switch34_case5:
0996   0A2D             ; printx16(*(int*)p); 
0997   0A2D             ; --- START FUNCTION CALL
0998   0A2D FA FF FF      lea d, [bp + -1] ; $p
0999   0A30 2A            mov b, [d]
1000   0A31 38 00 00      mov c, 0
1001   0A34 74            mov d, b
1002   0A35 2A            mov b, [d]
1003   0A36 38 00 00      mov c, 0
1004   0A39 FD AB         swp b
1005   0A3B D8            push b
1006   0A3C 07 C8 10      call printx16
1007   0A3F 51 02 00      add sp, 2
1008   0A42             ; --- END FUNCTION CALL
1009   0A42             ; p = p + 2; 
1010   0A42 FA FF FF      lea d, [bp + -1] ; $p
1011   0A45 DA            push d
1012   0A46 FA FF FF      lea d, [bp + -1] ; $p
1013   0A49 2A            mov b, [d]
1014   0A4A 38 00 00      mov c, 0
1015   0A4D             ; --- START TERMS
1016   0A4D D7            push a
1017   0A4E 11            mov a, b
1018   0A4F FD 2E 02 00   mov32 cb, $00000002
1018   0A53 00 00 
1019   0A55 56            add b, a
1020   0A56 E4            pop a
1021   0A57             ; --- END TERMS
1022   0A57 E7            pop d
1023   0A58 FD 43         mov [d], b
1024   0A5A             ; break; 
1025   0A5A 0A C6 0A      jmp _switch34_exit ; case break
1026   0A5D             _switch34_case6:
1027   0A5D             ; putchar(*(char*)p); 
1028   0A5D             ; --- START FUNCTION CALL
1029   0A5D FA FF FF      lea d, [bp + -1] ; $p
1030   0A60 2A            mov b, [d]
1031   0A61 38 00 00      mov c, 0
1032   0A64 74            mov d, b
1033   0A65 32            mov bl, [d]
1034   0A66 A7 00         mov bh, 0
1035   0A68 38 00 00      mov c, 0
1036   0A6B DD            push bl
1037   0A6C 07 85 0C      call putchar
1038   0A6F 51 01 00      add sp, 1
1039   0A72             ; --- END FUNCTION CALL
1040   0A72             ; p = p + 2; 
1041   0A72 FA FF FF      lea d, [bp + -1] ; $p
1042   0A75 DA            push d
1043   0A76 FA FF FF      lea d, [bp + -1] ; $p
1044   0A79 2A            mov b, [d]
1045   0A7A 38 00 00      mov c, 0
1046   0A7D             ; --- START TERMS
1047   0A7D D7            push a
1048   0A7E 11            mov a, b
1049   0A7F FD 2E 02 00   mov32 cb, $00000002
1049   0A83 00 00 
1050   0A85 56            add b, a
1051   0A86 E4            pop a
1052   0A87             ; --- END TERMS
1053   0A87 E7            pop d
1054   0A88 FD 43         mov [d], b
1055   0A8A             ; break; 
1056   0A8A 0A C6 0A      jmp _switch34_exit ; case break
1057   0A8D             _switch34_case7:
1058   0A8D             ; print(*(char**)p); 
1059   0A8D             ; --- START FUNCTION CALL
1060   0A8D FA FF FF      lea d, [bp + -1] ; $p
1061   0A90 2A            mov b, [d]
1062   0A91 38 00 00      mov c, 0
1063   0A94 74            mov d, b
1064   0A95 2A            mov b, [d]
1065   0A96 FD AB         swp b
1066   0A98 D8            push b
1067   0A99 07 46 0E      call print
1068   0A9C 51 02 00      add sp, 2
1069   0A9F             ; --- END FUNCTION CALL
1070   0A9F             ; p = p + 2; 
1071   0A9F FA FF FF      lea d, [bp + -1] ; $p
1072   0AA2 DA            push d
1073   0AA3 FA FF FF      lea d, [bp + -1] ; $p
1074   0AA6 2A            mov b, [d]
1075   0AA7 38 00 00      mov c, 0
1076   0AAA             ; --- START TERMS
1077   0AAA D7            push a
1078   0AAB 11            mov a, b
1079   0AAC FD 2E 02 00   mov32 cb, $00000002
1079   0AB0 00 00 
1080   0AB2 56            add b, a
1081   0AB3 E4            pop a
1082   0AB4             ; --- END TERMS
1083   0AB4 E7            pop d
1084   0AB5 FD 43         mov [d], b
1085   0AB7             ; break; 
1086   0AB7 0A C6 0A      jmp _switch34_exit ; case break
1087   0ABA             _switch34_default:
1088   0ABA             ; print("Error: Unknown argument type.\n"); 
1089   0ABA             ; --- START FUNCTION CALL
1090   0ABA 26 9B 12      mov b, _s5 ; "Error: Unknown argument type.\n"
1091   0ABD FD AB         swp b
1092   0ABF D8            push b
1093   0AC0 07 46 0E      call print
1094   0AC3 51 02 00      add sp, 2
1095   0AC6             ; --- END FUNCTION CALL
1096   0AC6             _switch34_exit:
1097   0AC6 0A DE 0A      jmp _if33_exit
1098   0AC9             _if33_else:
1099   0AC9             ; putchar(*format_p); 
1100   0AC9             ; --- START FUNCTION CALL
1101   0AC9 FA FD FF      lea d, [bp + -3] ; $format_p
1102   0ACC 2A            mov b, [d]
1103   0ACD 38 00 00      mov c, 0
1104   0AD0 74            mov d, b
1105   0AD1 32            mov bl, [d]
1106   0AD2 A7 00         mov bh, 0
1107   0AD4 38 00 00      mov c, 0
1108   0AD7 DD            push bl
1109   0AD8 07 85 0C      call putchar
1110   0ADB 51 01 00      add sp, 1
1111   0ADE             ; --- END FUNCTION CALL
1112   0ADE             _if33_exit:
1113   0ADE             _if32_exit:
1114   0ADE             ; format_p++; 
1115   0ADE FA FD FF      lea d, [bp + -3] ; $format_p
1116   0AE1 2A            mov b, [d]
1117   0AE2 38 00 00      mov c, 0
1118   0AE5 FD 77         inc b
1119   0AE7 FA FD FF      lea d, [bp + -3] ; $format_p
1120   0AEA FD 43         mov [d], b
1121   0AEC FD 7D         dec b
1122   0AEE             _for31_update:
1123   0AEE 0A 32 08      jmp _for31_cond
1124   0AF1             _for31_exit:
1125   0AF1 F9            leave
1126   0AF2 09            ret
1127   0AF3             
1128   0AF3             print_signed_long:
1129   0AF3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1130   0AF6             ; char digits[10]; 
1131   0AF6 52 0A 00      sub sp, 10
1132   0AF9             ; int i = 0; 
1133   0AF9 52 02 00      sub sp, 2
1134   0AFC             ; --- START LOCAL VAR INITIALIZATION
1135   0AFC FA F5 FF      lea d, [bp + -11] ; $i
1136   0AFF DA            push d
1137   0B00 FD 2E 00 00   mov32 cb, $00000000
1137   0B04 00 00 
1138   0B06 E7            pop d
1139   0B07 FD 43         mov [d], b
1140   0B09             ; --- END LOCAL VAR INITIALIZATION
1141   0B09             ; if (num < 0) { 
1142   0B09             _if38_cond:
1143   0B09 FA 05 00      lea d, [bp + 5] ; $num
1144   0B0C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1145   0B0F FD 39         mov c, b ; And place it into C
1146   0B11 2A            mov b, [d] ; Lower Word in B
1147   0B12             ; --- START RELATIONAL
1148   0B12 D7            push a
1149   0B13 FD D8         push g
1150   0B15 11            mov a, b
1151   0B16 FD 7A         mov g, c
1152   0B18 FD 2E 00 00   mov32 cb, $00000000
1152   0B1C 00 00 
1153   0B1E 38 00 00      mov c, 0
1154   0B21 FD AF         cmp32 ga, cb
1155   0B23 FD 73         slt ; <
1156   0B25 FD F1         pop g
1157   0B27 E4            pop a
1158   0B28             ; --- END RELATIONAL
1159   0B28 C0 00 00      cmp b, 0
1160   0B2B C6 5D 0B      je _if38_else
1161   0B2E             _if38_TRUE:
1162   0B2E             ; putchar('-'); 
1163   0B2E             ; --- START FUNCTION CALL
1164   0B2E FD 2E 2D 00   mov32 cb, $0000002d
1164   0B32 00 00 
1165   0B34 DD            push bl
1166   0B35 07 85 0C      call putchar
1167   0B38 51 01 00      add sp, 1
1168   0B3B             ; --- END FUNCTION CALL
1169   0B3B             ; num = -num; 
1170   0B3B FA 05 00      lea d, [bp + 5] ; $num
1171   0B3E DA            push d
1172   0B3F FA 05 00      lea d, [bp + 5] ; $num
1173   0B42 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1174   0B45 FD 39         mov c, b ; And place it into C
1175   0B47 2A            mov b, [d] ; Lower Word in B
1176   0B48 12            mov a, c
1177   0B49 95            not a
1178   0B4A 97            not b
1179   0B4B 55 01 00      add b, 1
1180   0B4E 5B 00 00      adc a, 0
1181   0B51 39            mov c, a
1182   0B52 E7            pop d
1183   0B53 FD 43         mov [d], b
1184   0B55 28            mov b, c
1185   0B56 FD 44 02 00   mov [d + 2], b
1186   0B5A 0A 94 0B      jmp _if38_exit
1187   0B5D             _if38_else:
1188   0B5D             ; if (num == 0) { 
1189   0B5D             _if39_cond:
1190   0B5D FA 05 00      lea d, [bp + 5] ; $num
1191   0B60 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1192   0B63 FD 39         mov c, b ; And place it into C
1193   0B65 2A            mov b, [d] ; Lower Word in B
1194   0B66             ; --- START RELATIONAL
1195   0B66 D7            push a
1196   0B67 FD D8         push g
1197   0B69 11            mov a, b
1198   0B6A FD 7A         mov g, c
1199   0B6C FD 2E 00 00   mov32 cb, $00000000
1199   0B70 00 00 
1200   0B72 38 00 00      mov c, 0
1201   0B75 FD AF         cmp32 ga, cb
1202   0B77 FD 71         seq ; ==
1203   0B79 FD F1         pop g
1204   0B7B E4            pop a
1205   0B7C             ; --- END RELATIONAL
1206   0B7C C0 00 00      cmp b, 0
1207   0B7F C6 94 0B      je _if39_exit
1208   0B82             _if39_TRUE:
1209   0B82             ; putchar('0'); 
1210   0B82             ; --- START FUNCTION CALL
1211   0B82 FD 2E 30 00   mov32 cb, $00000030
1211   0B86 00 00 
1212   0B88 DD            push bl
1213   0B89 07 85 0C      call putchar
1214   0B8C 51 01 00      add sp, 1
1215   0B8F             ; --- END FUNCTION CALL
1216   0B8F             ; return; 
1217   0B8F F9            leave
1218   0B90 09            ret
1219   0B91 0A 94 0B      jmp _if39_exit
1220   0B94             _if39_exit:
1221   0B94             _if38_exit:
1222   0B94             ; while (num > 0) { 
1223   0B94             _while40_cond:
1224   0B94 FA 05 00      lea d, [bp + 5] ; $num
1225   0B97 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1226   0B9A FD 39         mov c, b ; And place it into C
1227   0B9C 2A            mov b, [d] ; Lower Word in B
1228   0B9D             ; --- START RELATIONAL
1229   0B9D D7            push a
1230   0B9E FD D8         push g
1231   0BA0 11            mov a, b
1232   0BA1 FD 7A         mov g, c
1233   0BA3 FD 2E 00 00   mov32 cb, $00000000
1233   0BA7 00 00 
1234   0BA9 38 00 00      mov c, 0
1235   0BAC FD AF         cmp32 ga, cb
1236   0BAE FD 7F         sgt
1237   0BB0 FD F1         pop g
1238   0BB2 E4            pop a
1239   0BB3             ; --- END RELATIONAL
1240   0BB3 C0 00 00      cmp b, 0
1241   0BB6 C6 3B 0C      je _while40_exit
1242   0BB9             _while40_block:
1243   0BB9             ; digits[i] = '0' + (num % 10); 
1244   0BB9 FA F7 FF      lea d, [bp + -9] ; $digits
1245   0BBC D7            push a
1246   0BBD DA            push d
1247   0BBE FA F5 FF      lea d, [bp + -11] ; $i
1248   0BC1 2A            mov b, [d]
1249   0BC2 38 00 00      mov c, 0
1250   0BC5 E7            pop d
1251   0BC6 5A            add d, b
1252   0BC7 E4            pop a
1253   0BC8 DA            push d
1254   0BC9 FD 2E 30 00   mov32 cb, $00000030
1254   0BCD 00 00 
1255   0BCF             ; --- START TERMS
1256   0BCF D7            push a
1257   0BD0 11            mov a, b
1258   0BD1 FA 05 00      lea d, [bp + 5] ; $num
1259   0BD4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1260   0BD7 FD 39         mov c, b ; And place it into C
1261   0BD9 2A            mov b, [d] ; Lower Word in B
1262   0BDA             ; --- START FACTORS
1263   0BDA D7            push a
1264   0BDB FD D8         push g
1265   0BDD 11            mov a, b
1266   0BDE FD 7A         mov g, c
1267   0BE0 FD 2E 0A 00   mov32 cb, $0000000a
1267   0BE4 00 00 
1268   0BE6 FD D8         push g ; save 'g' as the div instruction uses it
1269   0BE8 AE            div a, b ; %, a: quotient, b: remainder
1270   0BE9 11            mov a, b
1271   0BEA FD F1         pop g
1272   0BEC FD 38         mov c, g
1273   0BEE 27            mov b, a
1274   0BEF FD F1         pop g
1275   0BF1 E4            pop a
1276   0BF2             ; --- END FACTORS
1277   0BF2 FD 22 00 00   mov g, 0
1278   0BF6 FD 15         add32 cb, ga
1279   0BF8 E4            pop a
1280   0BF9             ; --- END TERMS
1281   0BF9 E7            pop d
1282   0BFA FD 3E         mov [d], bl
1283   0BFC             ; num = num / 10; 
1284   0BFC FA 05 00      lea d, [bp + 5] ; $num
1285   0BFF DA            push d
1286   0C00 FA 05 00      lea d, [bp + 5] ; $num
1287   0C03 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1288   0C06 FD 39         mov c, b ; And place it into C
1289   0C08 2A            mov b, [d] ; Lower Word in B
1290   0C09             ; --- START FACTORS
1291   0C09 D7            push a
1292   0C0A FD D8         push g
1293   0C0C 11            mov a, b
1294   0C0D FD 7A         mov g, c
1295   0C0F FD 2E 0A 00   mov32 cb, $0000000a
1295   0C13 00 00 
1296   0C15 FD D8         push g ; save 'g' as the div instruction uses it
1297   0C17 AE            div a, b ; /, a: quotient, b: remainder
1298   0C18 FD F1         pop g
1299   0C1A FD 38         mov c, g
1300   0C1C 27            mov b, a
1301   0C1D FD F1         pop g
1302   0C1F E4            pop a
1303   0C20             ; --- END FACTORS
1304   0C20 E7            pop d
1305   0C21 FD 43         mov [d], b
1306   0C23 28            mov b, c
1307   0C24 FD 44 02 00   mov [d + 2], b
1308   0C28             ; i++; 
1309   0C28 FA F5 FF      lea d, [bp + -11] ; $i
1310   0C2B 2A            mov b, [d]
1311   0C2C 38 00 00      mov c, 0
1312   0C2F 11            mov a, b
1313   0C30 FD 77         inc b
1314   0C32 FA F5 FF      lea d, [bp + -11] ; $i
1315   0C35 FD 43         mov [d], b
1316   0C37 27            mov b, a
1317   0C38 0A 94 0B      jmp _while40_cond
1318   0C3B             _while40_exit:
1319   0C3B             ; while (i > 0) { 
1320   0C3B             _while47_cond:
1321   0C3B FA F5 FF      lea d, [bp + -11] ; $i
1322   0C3E 2A            mov b, [d]
1323   0C3F 38 00 00      mov c, 0
1324   0C42             ; --- START RELATIONAL
1325   0C42 D7            push a
1326   0C43 11            mov a, b
1327   0C44 FD 2E 00 00   mov32 cb, $00000000
1327   0C48 00 00 
1328   0C4A B0            cmp a, b
1329   0C4B FD 7F         sgt ; >
1330   0C4D E4            pop a
1331   0C4E             ; --- END RELATIONAL
1332   0C4E C0 00 00      cmp b, 0
1333   0C51 C6 83 0C      je _while47_exit
1334   0C54             _while47_block:
1335   0C54             ; i--; 
1336   0C54 FA F5 FF      lea d, [bp + -11] ; $i
1337   0C57 2A            mov b, [d]
1338   0C58 38 00 00      mov c, 0
1339   0C5B 11            mov a, b
1340   0C5C FD 7D         dec b
1341   0C5E FA F5 FF      lea d, [bp + -11] ; $i
1342   0C61 FD 43         mov [d], b
1343   0C63 27            mov b, a
1344   0C64             ; putchar(digits[i]); 
1345   0C64             ; --- START FUNCTION CALL
1346   0C64 FA F7 FF      lea d, [bp + -9] ; $digits
1347   0C67 D7            push a
1348   0C68 DA            push d
1349   0C69 FA F5 FF      lea d, [bp + -11] ; $i
1350   0C6C 2A            mov b, [d]
1351   0C6D 38 00 00      mov c, 0
1352   0C70 E7            pop d
1353   0C71 5A            add d, b
1354   0C72 E4            pop a
1355   0C73 32            mov bl, [d]
1356   0C74 A7 00         mov bh, 0
1357   0C76 38 00 00      mov c, 0
1358   0C79 DD            push bl
1359   0C7A 07 85 0C      call putchar
1360   0C7D 51 01 00      add sp, 1
1361   0C80             ; --- END FUNCTION CALL
1362   0C80 0A 3B 0C      jmp _while47_cond
1363   0C83             _while47_exit:
1364   0C83 F9            leave
1365   0C84 09            ret
1366   0C85             
1367   0C85             putchar:
1368   0C85 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1369   0C88             ; --- BEGIN INLINE ASM SEGMENT
1370   0C88 FA 05 00      lea d, [bp + 5] ; $c
1371   0C8B 1E            mov al, [d]
1372   0C8C 23            mov ah, al
1373   0C8D 19 00         mov al, 0
1374   0C8F 05 03         syscall sys_io      ; char in AH
1375   0C91             ; --- END INLINE ASM SEGMENT
1376   0C91 F9            leave
1377   0C92 09            ret
1378   0C93             
1379   0C93             print_unsigned_long:
1380   0C93 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1381   0C96             ; char digits[10]; 
1382   0C96 52 0A 00      sub sp, 10
1383   0C99             ; int i; 
1384   0C99 52 02 00      sub sp, 2
1385   0C9C             ; i = 0; 
1386   0C9C FA F5 FF      lea d, [bp + -11] ; $i
1387   0C9F DA            push d
1388   0CA0 FD 2E 00 00   mov32 cb, $00000000
1388   0CA4 00 00 
1389   0CA6 E7            pop d
1390   0CA7 FD 43         mov [d], b
1391   0CA9             ; if(num == 0){ 
1392   0CA9             _if48_cond:
1393   0CA9 FA 05 00      lea d, [bp + 5] ; $num
1394   0CAC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1395   0CAF FD 39         mov c, b ; And place it into C
1396   0CB1 2A            mov b, [d] ; Lower Word in B
1397   0CB2             ; --- START RELATIONAL
1398   0CB2 D7            push a
1399   0CB3 FD D8         push g
1400   0CB5 11            mov a, b
1401   0CB6 FD 7A         mov g, c
1402   0CB8 FD 2E 00 00   mov32 cb, $00000000
1402   0CBC 00 00 
1403   0CBE 38 00 00      mov c, 0
1404   0CC1 FD AF         cmp32 ga, cb
1405   0CC3 FD 71         seq ; ==
1406   0CC5 FD F1         pop g
1407   0CC7 E4            pop a
1408   0CC8             ; --- END RELATIONAL
1409   0CC8 C0 00 00      cmp b, 0
1410   0CCB C6 E0 0C      je _if48_exit
1411   0CCE             _if48_TRUE:
1412   0CCE             ; putchar('0'); 
1413   0CCE             ; --- START FUNCTION CALL
1414   0CCE FD 2E 30 00   mov32 cb, $00000030
1414   0CD2 00 00 
1415   0CD4 DD            push bl
1416   0CD5 07 85 0C      call putchar
1417   0CD8 51 01 00      add sp, 1
1418   0CDB             ; --- END FUNCTION CALL
1419   0CDB             ; return; 
1420   0CDB F9            leave
1421   0CDC 09            ret
1422   0CDD 0A E0 0C      jmp _if48_exit
1423   0CE0             _if48_exit:
1424   0CE0             ; while (num > 0) { 
1425   0CE0             _while49_cond:
1426   0CE0 FA 05 00      lea d, [bp + 5] ; $num
1427   0CE3 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1428   0CE6 FD 39         mov c, b ; And place it into C
1429   0CE8 2A            mov b, [d] ; Lower Word in B
1430   0CE9             ; --- START RELATIONAL
1431   0CE9 D7            push a
1432   0CEA FD D8         push g
1433   0CEC 11            mov a, b
1434   0CED FD 7A         mov g, c
1435   0CEF FD 2E 00 00   mov32 cb, $00000000
1435   0CF3 00 00 
1436   0CF5 38 00 00      mov c, 0
1437   0CF8 FD AF         cmp32 ga, cb
1438   0CFA FD 81         sgu
1439   0CFC FD F1         pop g
1440   0CFE E4            pop a
1441   0CFF             ; --- END RELATIONAL
1442   0CFF C0 00 00      cmp b, 0
1443   0D02 C6 87 0D      je _while49_exit
1444   0D05             _while49_block:
1445   0D05             ; digits[i] = '0' + (num % 10); 
1446   0D05 FA F7 FF      lea d, [bp + -9] ; $digits
1447   0D08 D7            push a
1448   0D09 DA            push d
1449   0D0A FA F5 FF      lea d, [bp + -11] ; $i
1450   0D0D 2A            mov b, [d]
1451   0D0E 38 00 00      mov c, 0
1452   0D11 E7            pop d
1453   0D12 5A            add d, b
1454   0D13 E4            pop a
1455   0D14 DA            push d
1456   0D15 FD 2E 30 00   mov32 cb, $00000030
1456   0D19 00 00 
1457   0D1B             ; --- START TERMS
1458   0D1B D7            push a
1459   0D1C 11            mov a, b
1460   0D1D FA 05 00      lea d, [bp + 5] ; $num
1461   0D20 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1462   0D23 FD 39         mov c, b ; And place it into C
1463   0D25 2A            mov b, [d] ; Lower Word in B
1464   0D26             ; --- START FACTORS
1465   0D26 D7            push a
1466   0D27 FD D8         push g
1467   0D29 11            mov a, b
1468   0D2A FD 7A         mov g, c
1469   0D2C FD 2E 0A 00   mov32 cb, $0000000a
1469   0D30 00 00 
1470   0D32 FD D8         push g ; save 'g' as the div instruction uses it
1471   0D34 AE            div a, b ; %, a: quotient, b: remainder
1472   0D35 11            mov a, b
1473   0D36 FD F1         pop g
1474   0D38 FD 38         mov c, g
1475   0D3A 27            mov b, a
1476   0D3B FD F1         pop g
1477   0D3D E4            pop a
1478   0D3E             ; --- END FACTORS
1479   0D3E FD 22 00 00   mov g, 0
1480   0D42 FD 15         add32 cb, ga
1481   0D44 E4            pop a
1482   0D45             ; --- END TERMS
1483   0D45 E7            pop d
1484   0D46 FD 3E         mov [d], bl
1485   0D48             ; num = num / 10; 
1486   0D48 FA 05 00      lea d, [bp + 5] ; $num
1487   0D4B DA            push d
1488   0D4C FA 05 00      lea d, [bp + 5] ; $num
1489   0D4F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1490   0D52 FD 39         mov c, b ; And place it into C
1491   0D54 2A            mov b, [d] ; Lower Word in B
1492   0D55             ; --- START FACTORS
1493   0D55 D7            push a
1494   0D56 FD D8         push g
1495   0D58 11            mov a, b
1496   0D59 FD 7A         mov g, c
1497   0D5B FD 2E 0A 00   mov32 cb, $0000000a
1497   0D5F 00 00 
1498   0D61 FD D8         push g ; save 'g' as the div instruction uses it
1499   0D63 AE            div a, b ; /, a: quotient, b: remainder
1500   0D64 FD F1         pop g
1501   0D66 FD 38         mov c, g
1502   0D68 27            mov b, a
1503   0D69 FD F1         pop g
1504   0D6B E4            pop a
1505   0D6C             ; --- END FACTORS
1506   0D6C E7            pop d
1507   0D6D FD 43         mov [d], b
1508   0D6F 28            mov b, c
1509   0D70 FD 44 02 00   mov [d + 2], b
1510   0D74             ; i++; 
1511   0D74 FA F5 FF      lea d, [bp + -11] ; $i
1512   0D77 2A            mov b, [d]
1513   0D78 38 00 00      mov c, 0
1514   0D7B 11            mov a, b
1515   0D7C FD 77         inc b
1516   0D7E FA F5 FF      lea d, [bp + -11] ; $i
1517   0D81 FD 43         mov [d], b
1518   0D83 27            mov b, a
1519   0D84 0A E0 0C      jmp _while49_cond
1520   0D87             _while49_exit:
1521   0D87             ; while (i > 0) { 
1522   0D87             _while56_cond:
1523   0D87 FA F5 FF      lea d, [bp + -11] ; $i
1524   0D8A 2A            mov b, [d]
1525   0D8B 38 00 00      mov c, 0
1526   0D8E             ; --- START RELATIONAL
1527   0D8E D7            push a
1528   0D8F 11            mov a, b
1529   0D90 FD 2E 00 00   mov32 cb, $00000000
1529   0D94 00 00 
1530   0D96 B0            cmp a, b
1531   0D97 FD 7F         sgt ; >
1532   0D99 E4            pop a
1533   0D9A             ; --- END RELATIONAL
1534   0D9A C0 00 00      cmp b, 0
1535   0D9D C6 CF 0D      je _while56_exit
1536   0DA0             _while56_block:
1537   0DA0             ; i--; 
1538   0DA0 FA F5 FF      lea d, [bp + -11] ; $i
1539   0DA3 2A            mov b, [d]
1540   0DA4 38 00 00      mov c, 0
1541   0DA7 11            mov a, b
1542   0DA8 FD 7D         dec b
1543   0DAA FA F5 FF      lea d, [bp + -11] ; $i
1544   0DAD FD 43         mov [d], b
1545   0DAF 27            mov b, a
1546   0DB0             ; putchar(digits[i]); 
1547   0DB0             ; --- START FUNCTION CALL
1548   0DB0 FA F7 FF      lea d, [bp + -9] ; $digits
1549   0DB3 D7            push a
1550   0DB4 DA            push d
1551   0DB5 FA F5 FF      lea d, [bp + -11] ; $i
1552   0DB8 2A            mov b, [d]
1553   0DB9 38 00 00      mov c, 0
1554   0DBC E7            pop d
1555   0DBD 5A            add d, b
1556   0DBE E4            pop a
1557   0DBF 32            mov bl, [d]
1558   0DC0 A7 00         mov bh, 0
1559   0DC2 38 00 00      mov c, 0
1560   0DC5 DD            push bl
1561   0DC6 07 85 0C      call putchar
1562   0DC9 51 01 00      add sp, 1
1563   0DCC             ; --- END FUNCTION CALL
1564   0DCC 0A 87 0D      jmp _while56_cond
1565   0DCF             _while56_exit:
1566   0DCF F9            leave
1567   0DD0 09            ret
1568   0DD1             
1569   0DD1             printx32:
1570   0DD1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1571   0DD4             ; --- BEGIN INLINE ASM SEGMENT
1572   0DD4 FA 05 00      lea d, [bp + 5] ; $hex
1573   0DD7 2B 02 00      mov b, [d+2]
1574   0DDA 07 E3 0D      call print_u16x_printx32
1575   0DDD 2A            mov b, [d]
1576   0DDE 07 E3 0D      call print_u16x_printx32
1577   0DE1             ; --- END INLINE ASM SEGMENT
1578   0DE1             ; return; 
1579   0DE1 F9            leave
1580   0DE2 09            ret
1581   0DE3             ; --- BEGIN INLINE ASM SEGMENT
1582   0DE3             print_u16x_printx32:
1583   0DE3 D7            push a
1584   0DE4 D8            push b
1585   0DE5 DD            push bl
1586   0DE6 30            mov bl, bh
1587   0DE7 07 05 0E      call _itoa_printx32        ; convert bh to char in A
1588   0DEA 2F            mov bl, al        ; save al
1589   0DEB 19 00         mov al, 0
1590   0DED 05 03         syscall sys_io        ; display AH
1591   0DEF 24            mov ah, bl        ; retrieve al
1592   0DF0 19 00         mov al, 0
1593   0DF2 05 03         syscall sys_io        ; display AL
1594   0DF4 EA            pop bl
1595   0DF5 07 05 0E      call _itoa_printx32        ; convert bh to char in A
1596   0DF8 2F            mov bl, al        ; save al
1597   0DF9 19 00         mov al, 0
1598   0DFB 05 03         syscall sys_io        ; display AH
1599   0DFD 24            mov ah, bl        ; retrieve al
1600   0DFE 19 00         mov al, 0
1601   0E00 05 03         syscall sys_io        ; display AL
1602   0E02 E5            pop b
1603   0E03 E4            pop a
1604   0E04 09            ret
1605   0E05             _itoa_printx32:
1606   0E05 DA            push d
1607   0E06 D8            push b
1608   0E07 A7 00         mov bh, 0
1609   0E09 FD A4 04      shr bl, 4  
1610   0E0C 74            mov d, b
1611   0E0D 1F 1F 0E      mov al, [d + s_hex_digits_printx32]
1612   0E10 23            mov ah, al
1613   0E11 E5            pop b
1614   0E12 D8            push b
1615   0E13 A7 00         mov bh, 0
1616   0E15 FD 87 0F      and bl, $0F
1617   0E18 74            mov d, b
1618   0E19 1F 1F 0E      mov al, [d + s_hex_digits_printx32]
1619   0E1C E5            pop b
1620   0E1D E7            pop d
1621   0E1E 09            ret
1622   0E1F 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1622   0E23 34 35 36 37 
1622   0E27 38 39 41 42 
1622   0E2B 43 44 45 46 
1623   0E2F             ; --- END INLINE ASM SEGMENT
1624   0E2F F9            leave
1625   0E30 09            ret
1626   0E31             
1627   0E31             err:
1628   0E31 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1629   0E34             ; print(e); 
1630   0E34             ; --- START FUNCTION CALL
1631   0E34 FA 05 00      lea d, [bp + 5] ; $e
1632   0E37 2A            mov b, [d]
1633   0E38 38 00 00      mov c, 0
1634   0E3B FD AB         swp b
1635   0E3D D8            push b
1636   0E3E 07 46 0E      call print
1637   0E41 51 02 00      add sp, 2
1638   0E44             ; --- END FUNCTION CALL
1639   0E44 F9            leave
1640   0E45 09            ret
1641   0E46             
1642   0E46             print:
1643   0E46 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1644   0E49             ; --- BEGIN INLINE ASM SEGMENT
1645   0E49 FA 05 00      lea d, [bp + 5] ; $s
1646   0E4C FD 2A         mov d, [d]
1647   0E4E             _puts_L1_print:
1648   0E4E 1E            mov al, [d]
1649   0E4F B9 00         cmp al, 0
1650   0E51 C6 5D 0E      jz _puts_END_print
1651   0E54 23            mov ah, al
1652   0E55 19 00         mov al, 0
1653   0E57 05 03         syscall sys_io
1654   0E59 79            inc d
1655   0E5A 0A 4E 0E      jmp _puts_L1_print
1656   0E5D             _puts_END_print:
1657   0E5D             ; --- END INLINE ASM SEGMENT
1658   0E5D F9            leave
1659   0E5E 09            ret
1660   0E5F             
1661   0E5F             print_signed:
1662   0E5F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1663   0E62             ; char digits[5]; 
1664   0E62 52 05 00      sub sp, 5
1665   0E65             ; int i = 0; 
1666   0E65 52 02 00      sub sp, 2
1667   0E68             ; --- START LOCAL VAR INITIALIZATION
1668   0E68 FA FA FF      lea d, [bp + -6] ; $i
1669   0E6B DA            push d
1670   0E6C FD 2E 00 00   mov32 cb, $00000000
1670   0E70 00 00 
1671   0E72 E7            pop d
1672   0E73 FD 43         mov [d], b
1673   0E75             ; --- END LOCAL VAR INITIALIZATION
1674   0E75             ; if (num < 0) { 
1675   0E75             _if57_cond:
1676   0E75 FA 05 00      lea d, [bp + 5] ; $num
1677   0E78 2A            mov b, [d]
1678   0E79 38 00 00      mov c, 0
1679   0E7C             ; --- START RELATIONAL
1680   0E7C D7            push a
1681   0E7D 11            mov a, b
1682   0E7E FD 2E 00 00   mov32 cb, $00000000
1682   0E82 00 00 
1683   0E84 B0            cmp a, b
1684   0E85 FD 73         slt ; < (signed)
1685   0E87 E4            pop a
1686   0E88             ; --- END RELATIONAL
1687   0E88 C0 00 00      cmp b, 0
1688   0E8B C6 AE 0E      je _if57_else
1689   0E8E             _if57_TRUE:
1690   0E8E             ; putchar('-'); 
1691   0E8E             ; --- START FUNCTION CALL
1692   0E8E FD 2E 2D 00   mov32 cb, $0000002d
1692   0E92 00 00 
1693   0E94 DD            push bl
1694   0E95 07 85 0C      call putchar
1695   0E98 51 01 00      add sp, 1
1696   0E9B             ; --- END FUNCTION CALL
1697   0E9B             ; num = -num; 
1698   0E9B FA 05 00      lea d, [bp + 5] ; $num
1699   0E9E DA            push d
1700   0E9F FA 05 00      lea d, [bp + 5] ; $num
1701   0EA2 2A            mov b, [d]
1702   0EA3 38 00 00      mov c, 0
1703   0EA6 FD 97         neg b
1704   0EA8 E7            pop d
1705   0EA9 FD 43         mov [d], b
1706   0EAB 0A D9 0E      jmp _if57_exit
1707   0EAE             _if57_else:
1708   0EAE             ; if (num == 0) { 
1709   0EAE             _if58_cond:
1710   0EAE FA 05 00      lea d, [bp + 5] ; $num
1711   0EB1 2A            mov b, [d]
1712   0EB2 38 00 00      mov c, 0
1713   0EB5             ; --- START RELATIONAL
1714   0EB5 D7            push a
1715   0EB6 11            mov a, b
1716   0EB7 FD 2E 00 00   mov32 cb, $00000000
1716   0EBB 00 00 
1717   0EBD B0            cmp a, b
1718   0EBE FD 71         seq ; ==
1719   0EC0 E4            pop a
1720   0EC1             ; --- END RELATIONAL
1721   0EC1 C0 00 00      cmp b, 0
1722   0EC4 C6 D9 0E      je _if58_exit
1723   0EC7             _if58_TRUE:
1724   0EC7             ; putchar('0'); 
1725   0EC7             ; --- START FUNCTION CALL
1726   0EC7 FD 2E 30 00   mov32 cb, $00000030
1726   0ECB 00 00 
1727   0ECD DD            push bl
1728   0ECE 07 85 0C      call putchar
1729   0ED1 51 01 00      add sp, 1
1730   0ED4             ; --- END FUNCTION CALL
1731   0ED4             ; return; 
1732   0ED4 F9            leave
1733   0ED5 09            ret
1734   0ED6 0A D9 0E      jmp _if58_exit
1735   0ED9             _if58_exit:
1736   0ED9             _if57_exit:
1737   0ED9             ; while (num > 0) { 
1738   0ED9             _while59_cond:
1739   0ED9 FA 05 00      lea d, [bp + 5] ; $num
1740   0EDC 2A            mov b, [d]
1741   0EDD 38 00 00      mov c, 0
1742   0EE0             ; --- START RELATIONAL
1743   0EE0 D7            push a
1744   0EE1 11            mov a, b
1745   0EE2 FD 2E 00 00   mov32 cb, $00000000
1745   0EE6 00 00 
1746   0EE8 B0            cmp a, b
1747   0EE9 FD 7F         sgt ; >
1748   0EEB E4            pop a
1749   0EEC             ; --- END RELATIONAL
1750   0EEC C0 00 00      cmp b, 0
1751   0EEF C6 66 0F      je _while59_exit
1752   0EF2             _while59_block:
1753   0EF2             ; digits[i] = '0' + (num % 10); 
1754   0EF2 FA FC FF      lea d, [bp + -4] ; $digits
1755   0EF5 D7            push a
1756   0EF6 DA            push d
1757   0EF7 FA FA FF      lea d, [bp + -6] ; $i
1758   0EFA 2A            mov b, [d]
1759   0EFB 38 00 00      mov c, 0
1760   0EFE E7            pop d
1761   0EFF 5A            add d, b
1762   0F00 E4            pop a
1763   0F01 DA            push d
1764   0F02 FD 2E 30 00   mov32 cb, $00000030
1764   0F06 00 00 
1765   0F08             ; --- START TERMS
1766   0F08 D7            push a
1767   0F09 11            mov a, b
1768   0F0A FA 05 00      lea d, [bp + 5] ; $num
1769   0F0D 2A            mov b, [d]
1770   0F0E 38 00 00      mov c, 0
1771   0F11             ; --- START FACTORS
1772   0F11 D7            push a
1773   0F12 FD D8         push g
1774   0F14 11            mov a, b
1775   0F15 FD 7A         mov g, c
1776   0F17 FD 2E 0A 00   mov32 cb, $0000000a
1776   0F1B 00 00 
1777   0F1D FD D8         push g ; save 'g' as the div instruction uses it
1778   0F1F AE            div a, b ; %, a: quotient, b: remainder
1779   0F20 11            mov a, b
1780   0F21 FD F1         pop g
1781   0F23 FD 38         mov c, g
1782   0F25 27            mov b, a
1783   0F26 FD F1         pop g
1784   0F28 E4            pop a
1785   0F29             ; --- END FACTORS
1786   0F29 56            add b, a
1787   0F2A E4            pop a
1788   0F2B             ; --- END TERMS
1789   0F2B E7            pop d
1790   0F2C FD 3E         mov [d], bl
1791   0F2E             ; num = num / 10; 
1792   0F2E FA 05 00      lea d, [bp + 5] ; $num
1793   0F31 DA            push d
1794   0F32 FA 05 00      lea d, [bp + 5] ; $num
1795   0F35 2A            mov b, [d]
1796   0F36 38 00 00      mov c, 0
1797   0F39             ; --- START FACTORS
1798   0F39 D7            push a
1799   0F3A FD D8         push g
1800   0F3C 11            mov a, b
1801   0F3D FD 7A         mov g, c
1802   0F3F FD 2E 0A 00   mov32 cb, $0000000a
1802   0F43 00 00 
1803   0F45 FD D8         push g ; save 'g' as the div instruction uses it
1804   0F47 AE            div a, b ; /, a: quotient, b: remainder
1805   0F48 FD F1         pop g
1806   0F4A FD 38         mov c, g
1807   0F4C 27            mov b, a
1808   0F4D FD F1         pop g
1809   0F4F E4            pop a
1810   0F50             ; --- END FACTORS
1811   0F50 E7            pop d
1812   0F51 FD 43         mov [d], b
1813   0F53             ; i++; 
1814   0F53 FA FA FF      lea d, [bp + -6] ; $i
1815   0F56 2A            mov b, [d]
1816   0F57 38 00 00      mov c, 0
1817   0F5A 11            mov a, b
1818   0F5B FD 77         inc b
1819   0F5D FA FA FF      lea d, [bp + -6] ; $i
1820   0F60 FD 43         mov [d], b
1821   0F62 27            mov b, a
1822   0F63 0A D9 0E      jmp _while59_cond
1823   0F66             _while59_exit:
1824   0F66             ; while (i > 0) { 
1825   0F66             _while66_cond:
1826   0F66 FA FA FF      lea d, [bp + -6] ; $i
1827   0F69 2A            mov b, [d]
1828   0F6A 38 00 00      mov c, 0
1829   0F6D             ; --- START RELATIONAL
1830   0F6D D7            push a
1831   0F6E 11            mov a, b
1832   0F6F FD 2E 00 00   mov32 cb, $00000000
1832   0F73 00 00 
1833   0F75 B0            cmp a, b
1834   0F76 FD 7F         sgt ; >
1835   0F78 E4            pop a
1836   0F79             ; --- END RELATIONAL
1837   0F79 C0 00 00      cmp b, 0
1838   0F7C C6 AE 0F      je _while66_exit
1839   0F7F             _while66_block:
1840   0F7F             ; i--; 
1841   0F7F FA FA FF      lea d, [bp + -6] ; $i
1842   0F82 2A            mov b, [d]
1843   0F83 38 00 00      mov c, 0
1844   0F86 11            mov a, b
1845   0F87 FD 7D         dec b
1846   0F89 FA FA FF      lea d, [bp + -6] ; $i
1847   0F8C FD 43         mov [d], b
1848   0F8E 27            mov b, a
1849   0F8F             ; putchar(digits[i]); 
1850   0F8F             ; --- START FUNCTION CALL
1851   0F8F FA FC FF      lea d, [bp + -4] ; $digits
1852   0F92 D7            push a
1853   0F93 DA            push d
1854   0F94 FA FA FF      lea d, [bp + -6] ; $i
1855   0F97 2A            mov b, [d]
1856   0F98 38 00 00      mov c, 0
1857   0F9B E7            pop d
1858   0F9C 5A            add d, b
1859   0F9D E4            pop a
1860   0F9E 32            mov bl, [d]
1861   0F9F A7 00         mov bh, 0
1862   0FA1 38 00 00      mov c, 0
1863   0FA4 DD            push bl
1864   0FA5 07 85 0C      call putchar
1865   0FA8 51 01 00      add sp, 1
1866   0FAB             ; --- END FUNCTION CALL
1867   0FAB 0A 66 0F      jmp _while66_cond
1868   0FAE             _while66_exit:
1869   0FAE F9            leave
1870   0FAF 09            ret
1871   0FB0             
1872   0FB0             print_unsigned:
1873   0FB0 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1874   0FB3             ; char digits[5]; 
1875   0FB3 52 05 00      sub sp, 5
1876   0FB6             ; int i; 
1877   0FB6 52 02 00      sub sp, 2
1878   0FB9             ; i = 0; 
1879   0FB9 FA FA FF      lea d, [bp + -6] ; $i
1880   0FBC DA            push d
1881   0FBD FD 2E 00 00   mov32 cb, $00000000
1881   0FC1 00 00 
1882   0FC3 E7            pop d
1883   0FC4 FD 43         mov [d], b
1884   0FC6             ; if(num == 0){ 
1885   0FC6             _if67_cond:
1886   0FC6 FA 05 00      lea d, [bp + 5] ; $num
1887   0FC9 2A            mov b, [d]
1888   0FCA 38 00 00      mov c, 0
1889   0FCD             ; --- START RELATIONAL
1890   0FCD D7            push a
1891   0FCE 11            mov a, b
1892   0FCF FD 2E 00 00   mov32 cb, $00000000
1892   0FD3 00 00 
1893   0FD5 B0            cmp a, b
1894   0FD6 FD 71         seq ; ==
1895   0FD8 E4            pop a
1896   0FD9             ; --- END RELATIONAL
1897   0FD9 C0 00 00      cmp b, 0
1898   0FDC C6 F1 0F      je _if67_exit
1899   0FDF             _if67_TRUE:
1900   0FDF             ; putchar('0'); 
1901   0FDF             ; --- START FUNCTION CALL
1902   0FDF FD 2E 30 00   mov32 cb, $00000030
1902   0FE3 00 00 
1903   0FE5 DD            push bl
1904   0FE6 07 85 0C      call putchar
1905   0FE9 51 01 00      add sp, 1
1906   0FEC             ; --- END FUNCTION CALL
1907   0FEC             ; return; 
1908   0FEC F9            leave
1909   0FED 09            ret
1910   0FEE 0A F1 0F      jmp _if67_exit
1911   0FF1             _if67_exit:
1912   0FF1             ; while (num > 0) { 
1913   0FF1             _while68_cond:
1914   0FF1 FA 05 00      lea d, [bp + 5] ; $num
1915   0FF4 2A            mov b, [d]
1916   0FF5 38 00 00      mov c, 0
1917   0FF8             ; --- START RELATIONAL
1918   0FF8 D7            push a
1919   0FF9 11            mov a, b
1920   0FFA FD 2E 00 00   mov32 cb, $00000000
1920   0FFE 00 00 
1921   1000 B0            cmp a, b
1922   1001 FD 81         sgu ; > (unsigned)
1923   1003 E4            pop a
1924   1004             ; --- END RELATIONAL
1925   1004 C0 00 00      cmp b, 0
1926   1007 C6 7E 10      je _while68_exit
1927   100A             _while68_block:
1928   100A             ; digits[i] = '0' + (num % 10); 
1929   100A FA FC FF      lea d, [bp + -4] ; $digits
1930   100D D7            push a
1931   100E DA            push d
1932   100F FA FA FF      lea d, [bp + -6] ; $i
1933   1012 2A            mov b, [d]
1934   1013 38 00 00      mov c, 0
1935   1016 E7            pop d
1936   1017 5A            add d, b
1937   1018 E4            pop a
1938   1019 DA            push d
1939   101A FD 2E 30 00   mov32 cb, $00000030
1939   101E 00 00 
1940   1020             ; --- START TERMS
1941   1020 D7            push a
1942   1021 11            mov a, b
1943   1022 FA 05 00      lea d, [bp + 5] ; $num
1944   1025 2A            mov b, [d]
1945   1026 38 00 00      mov c, 0
1946   1029             ; --- START FACTORS
1947   1029 D7            push a
1948   102A FD D8         push g
1949   102C 11            mov a, b
1950   102D FD 7A         mov g, c
1951   102F FD 2E 0A 00   mov32 cb, $0000000a
1951   1033 00 00 
1952   1035 FD D8         push g ; save 'g' as the div instruction uses it
1953   1037 AE            div a, b ; %, a: quotient, b: remainder
1954   1038 11            mov a, b
1955   1039 FD F1         pop g
1956   103B FD 38         mov c, g
1957   103D 27            mov b, a
1958   103E FD F1         pop g
1959   1040 E4            pop a
1960   1041             ; --- END FACTORS
1961   1041 56            add b, a
1962   1042 E4            pop a
1963   1043             ; --- END TERMS
1964   1043 E7            pop d
1965   1044 FD 3E         mov [d], bl
1966   1046             ; num = num / 10; 
1967   1046 FA 05 00      lea d, [bp + 5] ; $num
1968   1049 DA            push d
1969   104A FA 05 00      lea d, [bp + 5] ; $num
1970   104D 2A            mov b, [d]
1971   104E 38 00 00      mov c, 0
1972   1051             ; --- START FACTORS
1973   1051 D7            push a
1974   1052 FD D8         push g
1975   1054 11            mov a, b
1976   1055 FD 7A         mov g, c
1977   1057 FD 2E 0A 00   mov32 cb, $0000000a
1977   105B 00 00 
1978   105D FD D8         push g ; save 'g' as the div instruction uses it
1979   105F AE            div a, b ; /, a: quotient, b: remainder
1980   1060 FD F1         pop g
1981   1062 FD 38         mov c, g
1982   1064 27            mov b, a
1983   1065 FD F1         pop g
1984   1067 E4            pop a
1985   1068             ; --- END FACTORS
1986   1068 E7            pop d
1987   1069 FD 43         mov [d], b
1988   106B             ; i++; 
1989   106B FA FA FF      lea d, [bp + -6] ; $i
1990   106E 2A            mov b, [d]
1991   106F 38 00 00      mov c, 0
1992   1072 11            mov a, b
1993   1073 FD 77         inc b
1994   1075 FA FA FF      lea d, [bp + -6] ; $i
1995   1078 FD 43         mov [d], b
1996   107A 27            mov b, a
1997   107B 0A F1 0F      jmp _while68_cond
1998   107E             _while68_exit:
1999   107E             ; while (i > 0) { 
2000   107E             _while75_cond:
2001   107E FA FA FF      lea d, [bp + -6] ; $i
2002   1081 2A            mov b, [d]
2003   1082 38 00 00      mov c, 0
2004   1085             ; --- START RELATIONAL
2005   1085 D7            push a
2006   1086 11            mov a, b
2007   1087 FD 2E 00 00   mov32 cb, $00000000
2007   108B 00 00 
2008   108D B0            cmp a, b
2009   108E FD 7F         sgt ; >
2010   1090 E4            pop a
2011   1091             ; --- END RELATIONAL
2012   1091 C0 00 00      cmp b, 0
2013   1094 C6 C6 10      je _while75_exit
2014   1097             _while75_block:
2015   1097             ; i--; 
2016   1097 FA FA FF      lea d, [bp + -6] ; $i
2017   109A 2A            mov b, [d]
2018   109B 38 00 00      mov c, 0
2019   109E 11            mov a, b
2020   109F FD 7D         dec b
2021   10A1 FA FA FF      lea d, [bp + -6] ; $i
2022   10A4 FD 43         mov [d], b
2023   10A6 27            mov b, a
2024   10A7             ; putchar(digits[i]); 
2025   10A7             ; --- START FUNCTION CALL
2026   10A7 FA FC FF      lea d, [bp + -4] ; $digits
2027   10AA D7            push a
2028   10AB DA            push d
2029   10AC FA FA FF      lea d, [bp + -6] ; $i
2030   10AF 2A            mov b, [d]
2031   10B0 38 00 00      mov c, 0
2032   10B3 E7            pop d
2033   10B4 5A            add d, b
2034   10B5 E4            pop a
2035   10B6 32            mov bl, [d]
2036   10B7 A7 00         mov bh, 0
2037   10B9 38 00 00      mov c, 0
2038   10BC DD            push bl
2039   10BD 07 85 0C      call putchar
2040   10C0 51 01 00      add sp, 1
2041   10C3             ; --- END FUNCTION CALL
2042   10C3 0A 7E 10      jmp _while75_cond
2043   10C6             _while75_exit:
2044   10C6 F9            leave
2045   10C7 09            ret
2046   10C8             
2047   10C8             printx16:
2048   10C8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2049   10CB             ; --- BEGIN INLINE ASM SEGMENT
2050   10CB FA 05 00      lea d, [bp + 5] ; $hex
2051   10CE 2A            mov b, [d]
2052   10CF             print_u16x_printx16:
2053   10CF DD            push bl
2054   10D0 30            mov bl, bh
2055   10D1 07 EE 10      call _itoa_printx16        ; convert bh to char in A
2056   10D4 2F            mov bl, al        ; save al
2057   10D5 19 00         mov al, 0
2058   10D7 05 03         syscall sys_io        ; display AH
2059   10D9 24            mov ah, bl        ; retrieve al
2060   10DA 19 00         mov al, 0
2061   10DC 05 03         syscall sys_io        ; display AL
2062   10DE EA            pop bl
2063   10DF 07 EE 10      call _itoa_printx16        ; convert bh to char in A
2064   10E2 2F            mov bl, al        ; save al
2065   10E3 19 00         mov al, 0
2066   10E5 05 03         syscall sys_io        ; display AH
2067   10E7 24            mov ah, bl        ; retrieve al
2068   10E8 19 00         mov al, 0
2069   10EA 05 03         syscall sys_io        ; display AL
2070   10EC             ; --- END INLINE ASM SEGMENT
2071   10EC             ; return; 
2072   10EC F9            leave
2073   10ED 09            ret
2074   10EE             ; --- BEGIN INLINE ASM SEGMENT
2075   10EE             _itoa_printx16:
2076   10EE DA            push d
2077   10EF D8            push b
2078   10F0 A7 00         mov bh, 0
2079   10F2 FD A4 04      shr bl, 4  
2080   10F5 74            mov d, b
2081   10F6 1F 08 11      mov al, [d + s_hex_digits_printx16]
2082   10F9 23            mov ah, al
2083   10FA E5            pop b
2084   10FB D8            push b
2085   10FC A7 00         mov bh, 0
2086   10FE FD 87 0F      and bl, $0F
2087   1101 74            mov d, b
2088   1102 1F 08 11      mov al, [d + s_hex_digits_printx16]
2089   1105 E5            pop b
2090   1106 E7            pop d
2091   1107 09            ret
2092   1108 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2092   110C 34 35 36 37 
2092   1110 38 39 41 42 
2092   1114 43 44 45 46 
2093   1118             ; --- END INLINE ASM SEGMENT
2094   1118 F9            leave
2095   1119 09            ret
2096   111A             
2097   111A             scann:
2098   111A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2099   111D             ; int m; 
2100   111D 52 02 00      sub sp, 2
2101   1120             ; --- BEGIN INLINE ASM SEGMENT
2102   1120 F8 08 00      enter 8
2103   1123 FA F9 FF      lea d, [bp +- 7]
2104   1126 07 6E 11      call _gets_scann
2105   1129 07 5E 11      call _strlen_scann      ; get string length in C
2106   112C 7E            dec c
2107   112D FD 4E         mov si, d
2108   112F 12            mov a, c
2109   1130 FD 99         shl a
2110   1132 3B 0B 12      mov d, table_power_scann
2111   1135 59            add d, a
2112   1136 38 00 00      mov c, 0
2113   1139             mul_loop_scann:
2114   1139 F6            lodsb      ; load ASCII to al
2115   113A B9 00         cmp al, 0
2116   113C C6 4F 11      je mul_exit_scann
2117   113F 6F 30         sub al, $30    ; make into integer
2118   1141 22 00         mov ah, 0
2119   1143 2A            mov b, [d]
2120   1144 AC            mul a, b      ; result in B since it fits in 16bits
2121   1145 11            mov a, b
2122   1146 28            mov b, c
2123   1147 54            add a, b
2124   1148 39            mov c, a
2125   1149 63 02 00      sub d, 2
2126   114C 0A 39 11      jmp mul_loop_scann
2127   114F             mul_exit_scann:
2128   114F 12            mov a, c
2129   1150 F9            leave
2130   1151 FA FF FF      lea d, [bp + -1] ; $m
2131   1154 43            mov [d], a
2132   1155             ; --- END INLINE ASM SEGMENT
2133   1155             ; return m; 
2134   1155 FA FF FF      lea d, [bp + -1] ; $m
2135   1158 2A            mov b, [d]
2136   1159 38 00 00      mov c, 0
2137   115C F9            leave
2138   115D 09            ret
2139   115E             ; --- BEGIN INLINE ASM SEGMENT
2140   115E             _strlen_scann:
2141   115E DA            push d
2142   115F 38 00 00      mov c, 0
2143   1162             _strlen_L1_scann:
2144   1162 BD 00         cmp byte [d], 0
2145   1164 C6 6C 11      je _strlen_ret_scann
2146   1167 79            inc d
2147   1168 78            inc c
2148   1169 0A 62 11      jmp _strlen_L1_scann
2149   116C             _strlen_ret_scann:
2150   116C E7            pop d
2151   116D 09            ret
2152   116E             _gets_scann:
2153   116E DA            push d
2154   116F             _gets_loop_scann:
2155   116F 19 01         mov al, 1
2156   1171 05 03         syscall sys_io      ; receive in AH
2157   1173 B9 00         cmp al, 0        ; check error code (AL)
2158   1175 C6 6F 11      je _gets_loop_scann      ; if no char received, retry
2159   1178 76 1B         cmp ah, 27
2160   117A C6 9B 11      je _gets_ansi_esc_scann
2161   117D 76 0A         cmp ah, $0A        ; LF
2162   117F C6 06 12      je _gets_end_scann
2163   1182 76 0D         cmp ah, $0D        ; CR
2164   1184 C6 06 12      je _gets_end_scann
2165   1187 76 5C         cmp ah, $5C        ; '\\'
2166   1189 C6 C7 11      je _gets_escape_scann
2167   118C 76 08         cmp ah, $08      ; check for backspace
2168   118E C6 97 11      je _gets_backspace_scann
2169   1191 1A            mov al, ah
2170   1192 3E            mov [d], al
2171   1193 79            inc d
2172   1194 0A 6F 11      jmp _gets_loop_scann
2173   1197             _gets_backspace_scann:
2174   1197 7F            dec d
2175   1198 0A 6F 11      jmp _gets_loop_scann
2176   119B             _gets_ansi_esc_scann:
2177   119B 19 01         mov al, 1
2178   119D 05 03         syscall sys_io        ; receive in AH without echo
2179   119F B9 00         cmp al, 0          ; check error code (AL)
2180   11A1 C6 9B 11      je _gets_ansi_esc_scann    ; if no char received, retry
2181   11A4 76 5B         cmp ah, '['
2182   11A6 C7 6F 11      jne _gets_loop_scann
2183   11A9             _gets_ansi_esc_2_scann:
2184   11A9 19 01         mov al, 1
2185   11AB 05 03         syscall sys_io          ; receive in AH without echo
2186   11AD B9 00         cmp al, 0            ; check error code (AL)
2187   11AF C6 A9 11      je _gets_ansi_esc_2_scann  ; if no char received, retry
2188   11B2 76 44         cmp ah, 'D'
2189   11B4 C6 BF 11      je _gets_left_arrow_scann
2190   11B7 76 43         cmp ah, 'C'
2191   11B9 C6 C3 11      je _gets_right_arrow_scann
2192   11BC 0A 6F 11      jmp _gets_loop_scann
2193   11BF             _gets_left_arrow_scann:
2194   11BF 7F            dec d
2195   11C0 0A 6F 11      jmp _gets_loop_scann
2196   11C3             _gets_right_arrow_scann:
2197   11C3 79            inc d
2198   11C4 0A 6F 11      jmp _gets_loop_scann
2199   11C7             _gets_escape_scann:
2200   11C7 19 01         mov al, 1
2201   11C9 05 03         syscall sys_io      ; receive in AH
2202   11CB B9 00         cmp al, 0        ; check error code (AL)
2203   11CD C6 C7 11      je _gets_escape_scann      ; if no char received, retry
2204   11D0 76 6E         cmp ah, 'n'
2205   11D2 C6 F1 11      je _gets_LF_scann
2206   11D5 76 72         cmp ah, 'r'
2207   11D7 C6 F8 11      je _gets_CR_scann
2208   11DA 76 30         cmp ah, '0'
2209   11DC C6 FF 11      je _gets_NULL_scann
2210   11DF 76 5C         cmp ah, $5C  
2211   11E1 C6 EA 11      je _gets_slash_scann
2212   11E4 1A            mov al, ah        ; if not a known escape, it is just a normal letter
2213   11E5 3E            mov [d], al
2214   11E6 79            inc d
2215   11E7 0A 6F 11      jmp _gets_loop_scann
2216   11EA             _gets_slash_scann:
2217   11EA 19 5C         mov al, $5C
2218   11EC 3E            mov [d], al
2219   11ED 79            inc d
2220   11EE 0A 6F 11      jmp _gets_loop_scann
2221   11F1             _gets_LF_scann:
2222   11F1 19 0A         mov al, $0A
2223   11F3 3E            mov [d], al
2224   11F4 79            inc d
2225   11F5 0A 6F 11      jmp _gets_loop_scann
2226   11F8             _gets_CR_scann:
2227   11F8 19 0D         mov al, $0D
2228   11FA 3E            mov [d], al
2229   11FB 79            inc d
2230   11FC 0A 6F 11      jmp _gets_loop_scann
2231   11FF             _gets_NULL_scann:
2232   11FF 19 00         mov al, $00
2233   1201 3E            mov [d], al
2234   1202 79            inc d
2235   1203 0A 6F 11      jmp _gets_loop_scann
2236   1206             _gets_end_scann:
2237   1206 19 00         mov al, 0
2238   1208 3E            mov [d], al        ; terminate string
2239   1209 E7            pop d
2240   120A 09            ret
2241   120B             table_power_scann:
2242   120B 01 00       .dw 1              ; 1
2243   120D 0A 00       .dw $A             ; 10
2244   120F 64 00       .dw $64            ; 100
2245   1211 E8 03       .dw $3E8           ; 1000
2246   1213 10 27       .dw $2710          ; 10000
2247   1215 A0 86 01 00 .dw $86A0, $1      ; 100000
2248   1219 40 42 0F 00 .dw $4240, $F      ; 1000000
2249   121D 80 96 98 00 .dw $9680, $98     ; 10000000
2250   1221 00 E1 F5 05 .dw $E100, $5F5    ; 100000000
2251   1225 00 CA 9A 3B .dw $CA00, $3B9A   ; 1000000000
2252   1229             ; --- END INLINE ASM SEGMENT
2253   1229 F9            leave
2254   122A 09            ret
2255   122B             ; --- END TEXT SEGMENT
2256   122B             
2257   122B             ; --- BEGIN DATA SEGMENT
2258   122B 00 00       _top: .fill 2, 0
2259   122D 45 6E 74 65 _s0: .db "Enter a number to find all prime numbers up to it: ", 0
2259   1231 72 20 61 20 
2259   1235 6E 75 6D 62 
2259   1239 65 72 20 74 
2259   123D 6F 20 66 69 
2259   1241 6E 64 20 61 
2259   1245 6C 6C 20 70 
2259   1249 72 69 6D 65 
2259   124D 20 6E 75 6D 
2259   1251 62 65 72 73 
2259   1255 20 75 70 20 
2259   1259 74 6F 20 69 
2259   125D 74 3A 20 00 
2260   1261 50 72 69 6D _s1: .db "Prime numbers are: \n", 0
2260   1265 65 20 6E 75 
2260   1269 6D 62 65 72 
2260   126D 73 20 61 72 
2260   1271 65 3A 20 0A 
2260   1275 00 
2261   1276 25 75 0A 00 _s2: .db "%u\n", 0
2262   127A 25 64 0A 00 _s3: .db "%d\n", 0
2263   127E 55 6E 65 78 _s4: .db "Unexpected format in printf.", 0
2263   1282 70 65 63 74 
2263   1286 65 64 20 66 
2263   128A 6F 72 6D 61 
2263   128E 74 20 69 6E 
2263   1292 20 70 72 69 
2263   1296 6E 74 66 2E 
2263   129A 00 
2264   129B 45 72 72 6F _s5: .db "Error: Unknown argument type.\n", 0
2264   129F 72 3A 20 55 
2264   12A3 6E 6B 6E 6F 
2264   12A7 77 6E 20 61 
2264   12AB 72 67 75 6D 
2264   12AF 65 6E 74 20 
2264   12B3 74 79 70 65 
2264   12B7 2E 0A 00 
2265   12BA             
2266   12BA BC 12       _heap_top: .dw _heap
2267   12BC 00          _heap: .db 0
2268   12BD             ; --- END DATA SEGMENT
2269   12BD             
2270   12BD             .end
tasm: Number of errors = 0
