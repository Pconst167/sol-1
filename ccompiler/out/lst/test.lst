0001   0000             ; --- FILENAME: test.c
0002   0000             ; --- DATE:     23-10-2025 at 22:08:43
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; char *p = alloc(20); 
0012   0408 52 02 00      sub sp, 2
0013   040B             ; --- START LOCAL VAR INITIALIZATION
0014   040B FA FF FF      lea d, [bp + -1] ; $p
0015   040E DA            push d
0016   040F             ; --- START FUNCTION CALL
0017   040F FD 2E 14 00   mov32 cb, $00000014
0017   0413 00 00 
0018   0415 FD AB         swp b
0019   0417 D8            push b
0020   0418 07 56 04      call alloc
0021   041B 51 02 00      add sp, 2
0022   041E             ; --- END FUNCTION CALL
0023   041E E7            pop d
0024   041F FD 43         mov [d], b
0025   0421             ; --- END LOCAL VAR INITIALIZATION
0026   0421             ; strcpy(p, "hello world"); 
0027   0421             ; --- START FUNCTION CALL
0028   0421 26 CB 0F      mov b, _s0 ; "hello world"
0029   0424 FD AB         swp b
0030   0426 D8            push b
0031   0427 FA FF FF      lea d, [bp + -1] ; $p
0032   042A 2A            mov b, [d]
0033   042B 38 00 00      mov c, 0
0034   042E FD AB         swp b
0035   0430 D8            push b
0036   0431 07 16 06      call strcpy
0037   0434 51 04 00      add sp, 4
0038   0437             ; --- END FUNCTION CALL
0039   0437             ; printf("\nstring: %s\n", p); 
0040   0437             ; --- START FUNCTION CALL
0041   0437 FA FF FF      lea d, [bp + -1] ; $p
0042   043A 2A            mov b, [d]
0043   043B 38 00 00      mov c, 0
0044   043E FD AB         swp b
0045   0440 D8            push b
0046   0441 26 D7 0F      mov b, _s1 ; "\nstring: %s\n"
0047   0444 FD AB         swp b
0048   0446 D8            push b
0049   0447 07 90 06      call printf
0050   044A 51 04 00      add sp, 4
0051   044D             ; --- END FUNCTION CALL
0052   044D             ; return 0; 
0053   044D FD 2E 00 00   mov32 cb, $00000000
0053   0451 00 00 
0054   0453 F9            leave
0055   0454 05 0B         syscall sys_terminate_proc
0056   0456             
0057   0456             alloc:
0058   0456 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0059   0459             ; struct block **b = &free_list; 
0060   0459 52 02 00      sub sp, 2
0061   045C             ; --- START LOCAL VAR INITIALIZATION
0062   045C FA FF FF      lea d, [bp + -1] ; $b
0063   045F DA            push d
0064   0460 3B C9 0F      mov d, _free_list ; $free_list
0065   0463 2D            mov b, d
0066   0464 E7            pop d
0067   0465 FD 28         mov si, b
0068   0467 FD 50         mov di, d
0069   0469 38 02 00      mov c, 2
0070   046C FD F5         rep movsb
0071   046E             ; --- END LOCAL VAR INITIALIZATION
0072   046E             ; struct block *prev = 0; 
0073   046E 52 02 00      sub sp, 2
0074   0471             ; --- START LOCAL VAR INITIALIZATION
0075   0471 FA FD FF      lea d, [bp + -3] ; $prev
0076   0474 DA            push d
0077   0475 FD 2E 00 00   mov32 cb, $00000000
0077   0479 00 00 
0078   047B E7            pop d
0079   047C FD 28         mov si, b
0080   047E FD 50         mov di, d
0081   0480 38 02 00      mov c, 2
0082   0483 FD F5         rep movsb
0083   0485             ; --- END LOCAL VAR INITIALIZATION
0084   0485             ; struct block *pp; 
0085   0485 52 02 00      sub sp, 2
0086   0488             ; struct block *blk = *b; 
0087   0488 52 02 00      sub sp, 2
0088   048B             ; --- START LOCAL VAR INITIALIZATION
0089   048B FA F9 FF      lea d, [bp + -7] ; $blk
0090   048E DA            push d
0091   048F FA FF FF      lea d, [bp + -1] ; $b
0092   0492 2A            mov b, [d]
0093   0493 38 00 00      mov c, 0
0094   0496 74            mov d, b
0095   0497 2A            mov b, [d]
0096   0498 E7            pop d
0097   0499 FD 28         mov si, b
0098   049B FD 50         mov di, d
0099   049D 38 02 00      mov c, 2
0100   04A0 FD F5         rep movsb
0101   04A2             ; --- END LOCAL VAR INITIALIZATION
0102   04A2             ; if (size & 1) size++; 
0103   04A2             _if1_cond:
0104   04A2 FA 05 00      lea d, [bp + 5] ; $size
0105   04A5 2A            mov b, [d]
0106   04A6 38 00 00      mov c, 0
0107   04A9 D7            push a
0108   04AA 11            mov a, b
0109   04AB FD 2E 01 00   mov32 cb, $00000001
0109   04AF 00 00 
0110   04B1 FD 92         and b, a ; &
0111   04B3 E4            pop a
0112   04B4 C0 00 00      cmp b, 0
0113   04B7 C6 CD 04      je _if1_exit
0114   04BA             _if1_TRUE:
0115   04BA             ; size++; 
0116   04BA FA 05 00      lea d, [bp + 5] ; $size
0117   04BD 2A            mov b, [d]
0118   04BE 38 00 00      mov c, 0
0119   04C1 11            mov a, b
0120   04C2 FD 77         inc b
0121   04C4 FA 05 00      lea d, [bp + 5] ; $size
0122   04C7 FD 43         mov [d], b
0123   04C9 27            mov b, a
0124   04CA 0A CD 04      jmp _if1_exit
0125   04CD             _if1_exit:
0126   04CD             ; while (*b) { 
0127   04CD             _while2_cond:
0128   04CD FA FF FF      lea d, [bp + -1] ; $b
0129   04D0 2A            mov b, [d]
0130   04D1 38 00 00      mov c, 0
0131   04D4 74            mov d, b
0132   04D5 2A            mov b, [d]
0133   04D6 C0 00 00      cmp b, 0
0134   04D9 C6 7F 05      je _while2_exit
0135   04DC             _while2_block:
0136   04DC             ; pp = *b; 
0137   04DC FA FB FF      lea d, [bp + -5] ; $pp
0138   04DF DA            push d
0139   04E0 FA FF FF      lea d, [bp + -1] ; $b
0140   04E3 2A            mov b, [d]
0141   04E4 38 00 00      mov c, 0
0142   04E7 74            mov d, b
0143   04E8 2A            mov b, [d]
0144   04E9 E7            pop d
0145   04EA FD 43         mov [d], b
0146   04EC             ; if (pp->size >= size) { 
0147   04EC             _if3_cond:
0148   04EC FA FB FF      lea d, [bp + -5] ; $pp
0149   04EF FD 2A         mov d, [d]
0150   04F1 58 00 00      add d, 0
0151   04F4 2A            mov b, [d]
0152   04F5 38 00 00      mov c, 0
0153   04F8             ; --- START RELATIONAL
0154   04F8 D7            push a
0155   04F9 11            mov a, b
0156   04FA FA 05 00      lea d, [bp + 5] ; $size
0157   04FD 2A            mov b, [d]
0158   04FE 38 00 00      mov c, 0
0159   0501 B0            cmp a, b
0160   0502 FD 82         sgeu ; >= (unsigned)
0161   0504 E4            pop a
0162   0505             ; --- END RELATIONAL
0163   0505 C0 00 00      cmp b, 0
0164   0508 C6 5C 05      je _if3_exit
0165   050B             _if3_TRUE:
0166   050B             ; if (prev) 
0167   050B             _if4_cond:
0168   050B FA FD FF      lea d, [bp + -3] ; $prev
0169   050E 2A            mov b, [d]
0170   050F 38 00 00      mov c, 0
0171   0512 C0 00 00      cmp b, 0
0172   0515 C6 33 05      je _if4_else
0173   0518             _if4_TRUE:
0174   0518             ; prev->next = blk->next; 
0175   0518 FA FD FF      lea d, [bp + -3] ; $prev
0176   051B FD 2A         mov d, [d]
0177   051D 58 02 00      add d, 2
0178   0520 DA            push d
0179   0521 FA F9 FF      lea d, [bp + -7] ; $blk
0180   0524 FD 2A         mov d, [d]
0181   0526 58 02 00      add d, 2
0182   0529 2A            mov b, [d]
0183   052A 38 00 00      mov c, 0
0184   052D E7            pop d
0185   052E FD 43         mov [d], b
0186   0530 0A 46 05      jmp _if4_exit
0187   0533             _if4_else:
0188   0533             ; free_list = blk->next; 
0189   0533 3B C9 0F      mov d, _free_list ; $free_list
0190   0536 DA            push d
0191   0537 FA F9 FF      lea d, [bp + -7] ; $blk
0192   053A FD 2A         mov d, [d]
0193   053C 58 02 00      add d, 2
0194   053F 2A            mov b, [d]
0195   0540 38 00 00      mov c, 0
0196   0543 E7            pop d
0197   0544 FD 43         mov [d], b
0198   0546             _if4_exit:
0199   0546             ; return (void*)(blk + 1); 
0200   0546 FA F9 FF      lea d, [bp + -7] ; $blk
0201   0549 2A            mov b, [d]
0202   054A 38 00 00      mov c, 0
0203   054D             ; --- START TERMS
0204   054D D7            push a
0205   054E 11            mov a, b
0206   054F FD 2E 01 00   mov32 cb, $00000001
0206   0553 00 00 
0207   0555 56            add b, a
0208   0556 E4            pop a
0209   0557             ; --- END TERMS
0210   0557 F9            leave
0211   0558 09            ret
0212   0559 0A 5C 05      jmp _if3_exit
0213   055C             _if3_exit:
0214   055C             ; prev = *b; 
0215   055C FA FD FF      lea d, [bp + -3] ; $prev
0216   055F DA            push d
0217   0560 FA FF FF      lea d, [bp + -1] ; $b
0218   0563 2A            mov b, [d]
0219   0564 38 00 00      mov c, 0
0220   0567 74            mov d, b
0221   0568 2A            mov b, [d]
0222   0569 E7            pop d
0223   056A FD 43         mov [d], b
0224   056C             ; b = &pp->next; 
0225   056C FA FF FF      lea d, [bp + -1] ; $b
0226   056F DA            push d
0227   0570 FA FB FF      lea d, [bp + -5] ; $pp
0228   0573 FD 2A         mov d, [d]
0229   0575 58 02 00      add d, 2
0230   0578 2D            mov b, d
0231   0579 E7            pop d
0232   057A FD 43         mov [d], b
0233   057C 0A CD 04      jmp _while2_cond
0234   057F             _while2_exit:
0235   057F             ; if (heap_top + sizeof(struct block) + size > heap +  16000         ) 
0236   057F             _if5_cond:
0237   057F 3B 20 10      mov d, _heap_top ; $heap_top
0238   0582 2A            mov b, [d]
0239   0583 38 00 00      mov c, 0
0240   0586             ; --- START TERMS
0241   0586 D7            push a
0242   0587 11            mov a, b
0243   0588 FD 2E 04 00   mov32 cb, 4
0243   058C 00 00 
0244   058E 56            add b, a
0245   058F 11            mov a, b
0246   0590 FA 05 00      lea d, [bp + 5] ; $size
0247   0593 2A            mov b, [d]
0248   0594 38 00 00      mov c, 0
0249   0597 56            add b, a
0250   0598 E4            pop a
0251   0599             ; --- END TERMS
0252   0599             ; --- START RELATIONAL
0253   0599 D7            push a
0254   059A 11            mov a, b
0255   059B 3B 22 10      mov d, _heap ; $heap
0256   059E 2A            mov b, [d]
0257   059F 38 00 00      mov c, 0
0258   05A2             ; --- START TERMS
0259   05A2 D7            push a
0260   05A3 11            mov a, b
0261   05A4 FD 2E 80 3E   mov32 cb, $00003e80
0261   05A8 00 00 
0262   05AA 56            add b, a
0263   05AB E4            pop a
0264   05AC             ; --- END TERMS
0265   05AC B0            cmp a, b
0266   05AD FD 81         sgu ; > (unsigned)
0267   05AF E4            pop a
0268   05B0             ; --- END RELATIONAL
0269   05B0 C0 00 00      cmp b, 0
0270   05B3 C6 C1 05      je _if5_exit
0271   05B6             _if5_TRUE:
0272   05B6             ; return 0; // out of memory 
0273   05B6 FD 2E 00 00   mov32 cb, $00000000
0273   05BA 00 00 
0274   05BC F9            leave
0275   05BD 09            ret
0276   05BE 0A C1 05      jmp _if5_exit
0277   05C1             _if5_exit:
0278   05C1             ; blk = heap_top; 
0279   05C1 FA F9 FF      lea d, [bp + -7] ; $blk
0280   05C4 DA            push d
0281   05C5 3B 20 10      mov d, _heap_top ; $heap_top
0282   05C8 2A            mov b, [d]
0283   05C9 38 00 00      mov c, 0
0284   05CC E7            pop d
0285   05CD FD 43         mov [d], b
0286   05CF             ; blk->size = size; 
0287   05CF FA F9 FF      lea d, [bp + -7] ; $blk
0288   05D2 FD 2A         mov d, [d]
0289   05D4 58 00 00      add d, 0
0290   05D7 DA            push d
0291   05D8 FA 05 00      lea d, [bp + 5] ; $size
0292   05DB 2A            mov b, [d]
0293   05DC 38 00 00      mov c, 0
0294   05DF E7            pop d
0295   05E0 FD 43         mov [d], b
0296   05E2             ; heap_top = heap_top + sizeof(struct block) + size; 
0297   05E2 3B 20 10      mov d, _heap_top ; $heap_top
0298   05E5 DA            push d
0299   05E6 3B 20 10      mov d, _heap_top ; $heap_top
0300   05E9 2A            mov b, [d]
0301   05EA 38 00 00      mov c, 0
0302   05ED             ; --- START TERMS
0303   05ED D7            push a
0304   05EE 11            mov a, b
0305   05EF FD 2E 04 00   mov32 cb, 4
0305   05F3 00 00 
0306   05F5 56            add b, a
0307   05F6 11            mov a, b
0308   05F7 FA 05 00      lea d, [bp + 5] ; $size
0309   05FA 2A            mov b, [d]
0310   05FB 38 00 00      mov c, 0
0311   05FE 56            add b, a
0312   05FF E4            pop a
0313   0600             ; --- END TERMS
0314   0600 E7            pop d
0315   0601 FD 43         mov [d], b
0316   0603             ; return (void*)(blk + 1); 
0317   0603 FA F9 FF      lea d, [bp + -7] ; $blk
0318   0606 2A            mov b, [d]
0319   0607 38 00 00      mov c, 0
0320   060A             ; --- START TERMS
0321   060A D7            push a
0322   060B 11            mov a, b
0323   060C FD 2E 01 00   mov32 cb, $00000001
0323   0610 00 00 
0324   0612 56            add b, a
0325   0613 E4            pop a
0326   0614             ; --- END TERMS
0327   0614 F9            leave
0328   0615 09            ret
0329   0616             
0330   0616             strcpy:
0331   0616 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0332   0619             ; char *psrc; 
0333   0619 52 02 00      sub sp, 2
0334   061C             ; char *pdest; 
0335   061C 52 02 00      sub sp, 2
0336   061F             ; psrc = src; 
0337   061F FA FF FF      lea d, [bp + -1] ; $psrc
0338   0622 DA            push d
0339   0623 FA 07 00      lea d, [bp + 7] ; $src
0340   0626 2A            mov b, [d]
0341   0627 38 00 00      mov c, 0
0342   062A E7            pop d
0343   062B FD 43         mov [d], b
0344   062D             ; pdest = dest; 
0345   062D FA FD FF      lea d, [bp + -3] ; $pdest
0346   0630 DA            push d
0347   0631 FA 05 00      lea d, [bp + 5] ; $dest
0348   0634 2A            mov b, [d]
0349   0635 38 00 00      mov c, 0
0350   0638 E7            pop d
0351   0639 FD 43         mov [d], b
0352   063B             ; while(*psrc) *pdest++ = *psrc++; 
0353   063B             _while6_cond:
0354   063B FA FF FF      lea d, [bp + -1] ; $psrc
0355   063E 2A            mov b, [d]
0356   063F 38 00 00      mov c, 0
0357   0642 74            mov d, b
0358   0643 32            mov bl, [d]
0359   0644 A7 00         mov bh, 0
0360   0646 38 00 00      mov c, 0
0361   0649 C0 00 00      cmp b, 0
0362   064C C6 7D 06      je _while6_exit
0363   064F             _while6_block:
0364   064F             ; *pdest++ = *psrc++; 
0365   064F FA FD FF      lea d, [bp + -3] ; $pdest
0366   0652 2A            mov b, [d]
0367   0653 38 00 00      mov c, 0
0368   0656 FD 77         inc b
0369   0658 FA FD FF      lea d, [bp + -3] ; $pdest
0370   065B FD 43         mov [d], b
0371   065D FD 7D         dec b
0372   065F D8            push b
0373   0660 FA FF FF      lea d, [bp + -1] ; $psrc
0374   0663 2A            mov b, [d]
0375   0664 38 00 00      mov c, 0
0376   0667 FD 77         inc b
0377   0669 FA FF FF      lea d, [bp + -1] ; $psrc
0378   066C FD 43         mov [d], b
0379   066E FD 7D         dec b
0380   0670 74            mov d, b
0381   0671 32            mov bl, [d]
0382   0672 A7 00         mov bh, 0
0383   0674 38 00 00      mov c, 0
0384   0677 E7            pop d
0385   0678 FD 3E         mov [d], bl
0386   067A 0A 3B 06      jmp _while6_cond
0387   067D             _while6_exit:
0388   067D             ; *pdest = '\0'; 
0389   067D FA FD FF      lea d, [bp + -3] ; $pdest
0390   0680 2A            mov b, [d]
0391   0681 38 00 00      mov c, 0
0392   0684 D8            push b
0393   0685 FD 2E 00 00   mov32 cb, $00000000
0393   0689 00 00 
0394   068B E7            pop d
0395   068C FD 3E         mov [d], bl
0396   068E F9            leave
0397   068F 09            ret
0398   0690             
0399   0690             printf:
0400   0690 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0401   0693             ; char *p, *format_p; 
0402   0693 52 02 00      sub sp, 2
0403   0696 52 02 00      sub sp, 2
0404   0699             ; format_p = format; 
0405   0699 FA FD FF      lea d, [bp + -3] ; $format_p
0406   069C DA            push d
0407   069D FA 05 00      lea d, [bp + 5] ; $format
0408   06A0 2A            mov b, [d]
0409   06A1 38 00 00      mov c, 0
0410   06A4 E7            pop d
0411   06A5 FD 43         mov [d], b
0412   06A7             ; p = &format + 2; 
0413   06A7 FA FF FF      lea d, [bp + -1] ; $p
0414   06AA DA            push d
0415   06AB FA 05 00      lea d, [bp + 5] ; $format
0416   06AE 2D            mov b, d
0417   06AF             ; --- START TERMS
0418   06AF D7            push a
0419   06B0 11            mov a, b
0420   06B1 FD 2E 02 00   mov32 cb, $00000002
0420   06B5 00 00 
0421   06B7 56            add b, a
0422   06B8 E4            pop a
0423   06B9             ; --- END TERMS
0424   06B9 E7            pop d
0425   06BA FD 43         mov [d], b
0426   06BC             ; for(;;){ 
0427   06BC             _for7_init:
0428   06BC             _for7_cond:
0429   06BC             _for7_block:
0430   06BC             ; if(!*format_p) break; 
0431   06BC             _if8_cond:
0432   06BC FA FD FF      lea d, [bp + -3] ; $format_p
0433   06BF 2A            mov b, [d]
0434   06C0 38 00 00      mov c, 0
0435   06C3 74            mov d, b
0436   06C4 32            mov bl, [d]
0437   06C5 A7 00         mov bh, 0
0438   06C7 38 00 00      mov c, 0
0439   06CA C0 00 00      cmp b, 0
0440   06CD FD 71         seq ; !
0441   06CF C0 00 00      cmp b, 0
0442   06D2 C6 DB 06      je _if8_else
0443   06D5             _if8_TRUE:
0444   06D5             ; break; 
0445   06D5 0A 7B 09      jmp _for7_exit ; for break
0446   06D8 0A 68 09      jmp _if8_exit
0447   06DB             _if8_else:
0448   06DB             ; if(*format_p == '%'){ 
0449   06DB             _if9_cond:
0450   06DB FA FD FF      lea d, [bp + -3] ; $format_p
0451   06DE 2A            mov b, [d]
0452   06DF 38 00 00      mov c, 0
0453   06E2 74            mov d, b
0454   06E3 32            mov bl, [d]
0455   06E4 A7 00         mov bh, 0
0456   06E6 38 00 00      mov c, 0
0457   06E9             ; --- START RELATIONAL
0458   06E9 D7            push a
0459   06EA 11            mov a, b
0460   06EB FD 2E 25 00   mov32 cb, $00000025
0460   06EF 00 00 
0461   06F1 B0            cmp a, b
0462   06F2 FD 71         seq ; ==
0463   06F4 E4            pop a
0464   06F5             ; --- END RELATIONAL
0465   06F5 C0 00 00      cmp b, 0
0466   06F8 C6 53 09      je _if9_else
0467   06FB             _if9_TRUE:
0468   06FB             ; format_p++; 
0469   06FB FA FD FF      lea d, [bp + -3] ; $format_p
0470   06FE 2A            mov b, [d]
0471   06FF 38 00 00      mov c, 0
0472   0702 FD 77         inc b
0473   0704 FA FD FF      lea d, [bp + -3] ; $format_p
0474   0707 FD 43         mov [d], b
0475   0709 FD 7D         dec b
0476   070B             ; switch(*format_p){ 
0477   070B             _switch10_expr:
0478   070B FA FD FF      lea d, [bp + -3] ; $format_p
0479   070E 2A            mov b, [d]
0480   070F 38 00 00      mov c, 0
0481   0712 74            mov d, b
0482   0713 32            mov bl, [d]
0483   0714 A7 00         mov bh, 0
0484   0716 38 00 00      mov c, 0
0485   0719             _switch10_comparisons:
0486   0719 C1 6C         cmp bl, $6c
0487   071B C6 47 07      je _switch10_case0
0488   071E C1 4C         cmp bl, $4c
0489   0720 C6 47 07      je _switch10_case1
0490   0723 C1 64         cmp bl, $64
0491   0725 C6 57 08      je _switch10_case2
0492   0728 C1 69         cmp bl, $69
0493   072A C6 57 08      je _switch10_case3
0494   072D C1 75         cmp bl, $75
0495   072F C6 87 08      je _switch10_case4
0496   0732 C1 78         cmp bl, $78
0497   0734 C6 B7 08      je _switch10_case5
0498   0737 C1 63         cmp bl, $63
0499   0739 C6 E7 08      je _switch10_case6
0500   073C C1 73         cmp bl, $73
0501   073E C6 17 09      je _switch10_case7
0502   0741 0A 44 09      jmp _switch10_default
0503   0744 0A 50 09      jmp _switch10_exit
0504   0747             _switch10_case0:
0505   0747             _switch10_case1:
0506   0747             ; format_p++; 
0507   0747 FA FD FF      lea d, [bp + -3] ; $format_p
0508   074A 2A            mov b, [d]
0509   074B 38 00 00      mov c, 0
0510   074E FD 77         inc b
0511   0750 FA FD FF      lea d, [bp + -3] ; $format_p
0512   0753 FD 43         mov [d], b
0513   0755 FD 7D         dec b
0514   0757             ; if(*format_p == 'd' || *format_p == 'i') 
0515   0757             _if11_cond:
0516   0757 FA FD FF      lea d, [bp + -3] ; $format_p
0517   075A 2A            mov b, [d]
0518   075B 38 00 00      mov c, 0
0519   075E 74            mov d, b
0520   075F 32            mov bl, [d]
0521   0760 A7 00         mov bh, 0
0522   0762 38 00 00      mov c, 0
0523   0765             ; --- START RELATIONAL
0524   0765 D7            push a
0525   0766 11            mov a, b
0526   0767 FD 2E 64 00   mov32 cb, $00000064
0526   076B 00 00 
0527   076D B0            cmp a, b
0528   076E FD 71         seq ; ==
0529   0770 E4            pop a
0530   0771             ; --- END RELATIONAL
0531   0771             ; --- START LOGICAL OR
0532   0771 D7            push a
0533   0772 11            mov a, b
0534   0773 FA FD FF      lea d, [bp + -3] ; $format_p
0535   0776 2A            mov b, [d]
0536   0777 38 00 00      mov c, 0
0537   077A 74            mov d, b
0538   077B 32            mov bl, [d]
0539   077C A7 00         mov bh, 0
0540   077E 38 00 00      mov c, 0
0541   0781             ; --- START RELATIONAL
0542   0781 D7            push a
0543   0782 11            mov a, b
0544   0783 FD 2E 69 00   mov32 cb, $00000069
0544   0787 00 00 
0545   0789 B0            cmp a, b
0546   078A FD 71         seq ; ==
0547   078C E4            pop a
0548   078D             ; --- END RELATIONAL
0549   078D FD A8         sor a, b ; ||
0550   078F E4            pop a
0551   0790             ; --- END LOGICAL OR
0552   0790 C0 00 00      cmp b, 0
0553   0793 C6 B4 07      je _if11_else
0554   0796             _if11_TRUE:
0555   0796             ; print_signed_long(*(long int*)p); 
0556   0796             ; --- START FUNCTION CALL
0557   0796 FA FF FF      lea d, [bp + -1] ; $p
0558   0799 2A            mov b, [d]
0559   079A 38 00 00      mov c, 0
0560   079D 74            mov d, b
0561   079E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0562   07A1 FD 39         mov c, b ; And place it into C
0563   07A3 2A            mov b, [d] ; Lower Word in B
0564   07A4 12            mov a, c
0565   07A5 FD AA         swp a
0566   07A7 D7            push a
0567   07A8 FD AB         swp b
0568   07AA D8            push b
0569   07AB 07 7D 09      call print_signed_long
0570   07AE 51 04 00      add sp, 4
0571   07B1             ; --- END FUNCTION CALL
0572   07B1 0A 3C 08      jmp _if11_exit
0573   07B4             _if11_else:
0574   07B4             ; if(*format_p == 'u') 
0575   07B4             _if12_cond:
0576   07B4 FA FD FF      lea d, [bp + -3] ; $format_p
0577   07B7 2A            mov b, [d]
0578   07B8 38 00 00      mov c, 0
0579   07BB 74            mov d, b
0580   07BC 32            mov bl, [d]
0581   07BD A7 00         mov bh, 0
0582   07BF 38 00 00      mov c, 0
0583   07C2             ; --- START RELATIONAL
0584   07C2 D7            push a
0585   07C3 11            mov a, b
0586   07C4 FD 2E 75 00   mov32 cb, $00000075
0586   07C8 00 00 
0587   07CA B0            cmp a, b
0588   07CB FD 71         seq ; ==
0589   07CD E4            pop a
0590   07CE             ; --- END RELATIONAL
0591   07CE C0 00 00      cmp b, 0
0592   07D1 C6 F2 07      je _if12_else
0593   07D4             _if12_TRUE:
0594   07D4             ; print_unsigned_long(*(unsigned long int*)p); 
0595   07D4             ; --- START FUNCTION CALL
0596   07D4 FA FF FF      lea d, [bp + -1] ; $p
0597   07D7 2A            mov b, [d]
0598   07D8 38 00 00      mov c, 0
0599   07DB 74            mov d, b
0600   07DC 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0601   07DF FD 39         mov c, b ; And place it into C
0602   07E1 2A            mov b, [d] ; Lower Word in B
0603   07E2 12            mov a, c
0604   07E3 FD AA         swp a
0605   07E5 D7            push a
0606   07E6 FD AB         swp b
0607   07E8 D8            push b
0608   07E9 07 54 0B      call print_unsigned_long
0609   07EC 51 04 00      add sp, 4
0610   07EF             ; --- END FUNCTION CALL
0611   07EF 0A 3C 08      jmp _if12_exit
0612   07F2             _if12_else:
0613   07F2             ; if(*format_p == 'x') 
0614   07F2             _if13_cond:
0615   07F2 FA FD FF      lea d, [bp + -3] ; $format_p
0616   07F5 2A            mov b, [d]
0617   07F6 38 00 00      mov c, 0
0618   07F9 74            mov d, b
0619   07FA 32            mov bl, [d]
0620   07FB A7 00         mov bh, 0
0621   07FD 38 00 00      mov c, 0
0622   0800             ; --- START RELATIONAL
0623   0800 D7            push a
0624   0801 11            mov a, b
0625   0802 FD 2E 78 00   mov32 cb, $00000078
0625   0806 00 00 
0626   0808 B0            cmp a, b
0627   0809 FD 71         seq ; ==
0628   080B E4            pop a
0629   080C             ; --- END RELATIONAL
0630   080C C0 00 00      cmp b, 0
0631   080F C6 30 08      je _if13_else
0632   0812             _if13_TRUE:
0633   0812             ; printx32(*(long int *)p); 
0634   0812             ; --- START FUNCTION CALL
0635   0812 FA FF FF      lea d, [bp + -1] ; $p
0636   0815 2A            mov b, [d]
0637   0816 38 00 00      mov c, 0
0638   0819 74            mov d, b
0639   081A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0640   081D FD 39         mov c, b ; And place it into C
0641   081F 2A            mov b, [d] ; Lower Word in B
0642   0820 12            mov a, c
0643   0821 FD AA         swp a
0644   0823 D7            push a
0645   0824 FD AB         swp b
0646   0826 D8            push b
0647   0827 07 7F 0C      call printx32
0648   082A 51 04 00      add sp, 4
0649   082D             ; --- END FUNCTION CALL
0650   082D 0A 3C 08      jmp _if13_exit
0651   0830             _if13_else:
0652   0830             ; err("Unexpected format in printf."); 
0653   0830             ; --- START FUNCTION CALL
0654   0830 26 E4 0F      mov b, _s2 ; "Unexpected format in printf."
0655   0833 FD AB         swp b
0656   0835 D8            push b
0657   0836 07 DF 0C      call err
0658   0839 51 02 00      add sp, 2
0659   083C             ; --- END FUNCTION CALL
0660   083C             _if13_exit:
0661   083C             _if12_exit:
0662   083C             _if11_exit:
0663   083C             ; p = p + 4; 
0664   083C FA FF FF      lea d, [bp + -1] ; $p
0665   083F DA            push d
0666   0840 FA FF FF      lea d, [bp + -1] ; $p
0667   0843 2A            mov b, [d]
0668   0844 38 00 00      mov c, 0
0669   0847             ; --- START TERMS
0670   0847 D7            push a
0671   0848 11            mov a, b
0672   0849 FD 2E 04 00   mov32 cb, $00000004
0672   084D 00 00 
0673   084F 56            add b, a
0674   0850 E4            pop a
0675   0851             ; --- END TERMS
0676   0851 E7            pop d
0677   0852 FD 43         mov [d], b
0678   0854             ; break; 
0679   0854 0A 50 09      jmp _switch10_exit ; case break
0680   0857             _switch10_case2:
0681   0857             _switch10_case3:
0682   0857             ; print_signed(*(int*)p); 
0683   0857             ; --- START FUNCTION CALL
0684   0857 FA FF FF      lea d, [bp + -1] ; $p
0685   085A 2A            mov b, [d]
0686   085B 38 00 00      mov c, 0
0687   085E 74            mov d, b
0688   085F 2A            mov b, [d]
0689   0860 38 00 00      mov c, 0
0690   0863 FD AB         swp b
0691   0865 D8            push b
0692   0866 07 0D 0D      call print_signed
0693   0869 51 02 00      add sp, 2
0694   086C             ; --- END FUNCTION CALL
0695   086C             ; p = p + 2; 
0696   086C FA FF FF      lea d, [bp + -1] ; $p
0697   086F DA            push d
0698   0870 FA FF FF      lea d, [bp + -1] ; $p
0699   0873 2A            mov b, [d]
0700   0874 38 00 00      mov c, 0
0701   0877             ; --- START TERMS
0702   0877 D7            push a
0703   0878 11            mov a, b
0704   0879 FD 2E 02 00   mov32 cb, $00000002
0704   087D 00 00 
0705   087F 56            add b, a
0706   0880 E4            pop a
0707   0881             ; --- END TERMS
0708   0881 E7            pop d
0709   0882 FD 43         mov [d], b
0710   0884             ; break; 
0711   0884 0A 50 09      jmp _switch10_exit ; case break
0712   0887             _switch10_case4:
0713   0887             ; print_unsigned(*(unsigned int*)p); 
0714   0887             ; --- START FUNCTION CALL
0715   0887 FA FF FF      lea d, [bp + -1] ; $p
0716   088A 2A            mov b, [d]
0717   088B 38 00 00      mov c, 0
0718   088E 74            mov d, b
0719   088F 2A            mov b, [d]
0720   0890 38 00 00      mov c, 0
0721   0893 FD AB         swp b
0722   0895 D8            push b
0723   0896 07 70 0E      call print_unsigned
0724   0899 51 02 00      add sp, 2
0725   089C             ; --- END FUNCTION CALL
0726   089C             ; p = p + 2; 
0727   089C FA FF FF      lea d, [bp + -1] ; $p
0728   089F DA            push d
0729   08A0 FA FF FF      lea d, [bp + -1] ; $p
0730   08A3 2A            mov b, [d]
0731   08A4 38 00 00      mov c, 0
0732   08A7             ; --- START TERMS
0733   08A7 D7            push a
0734   08A8 11            mov a, b
0735   08A9 FD 2E 02 00   mov32 cb, $00000002
0735   08AD 00 00 
0736   08AF 56            add b, a
0737   08B0 E4            pop a
0738   08B1             ; --- END TERMS
0739   08B1 E7            pop d
0740   08B2 FD 43         mov [d], b
0741   08B4             ; break; 
0742   08B4 0A 50 09      jmp _switch10_exit ; case break
0743   08B7             _switch10_case5:
0744   08B7             ; printx16(*(int*)p); 
0745   08B7             ; --- START FUNCTION CALL
0746   08B7 FA FF FF      lea d, [bp + -1] ; $p
0747   08BA 2A            mov b, [d]
0748   08BB 38 00 00      mov c, 0
0749   08BE 74            mov d, b
0750   08BF 2A            mov b, [d]
0751   08C0 38 00 00      mov c, 0
0752   08C3 FD AB         swp b
0753   08C5 D8            push b
0754   08C6 07 75 0F      call printx16
0755   08C9 51 02 00      add sp, 2
0756   08CC             ; --- END FUNCTION CALL
0757   08CC             ; p = p + 2; 
0758   08CC FA FF FF      lea d, [bp + -1] ; $p
0759   08CF DA            push d
0760   08D0 FA FF FF      lea d, [bp + -1] ; $p
0761   08D3 2A            mov b, [d]
0762   08D4 38 00 00      mov c, 0
0763   08D7             ; --- START TERMS
0764   08D7 D7            push a
0765   08D8 11            mov a, b
0766   08D9 FD 2E 02 00   mov32 cb, $00000002
0766   08DD 00 00 
0767   08DF 56            add b, a
0768   08E0 E4            pop a
0769   08E1             ; --- END TERMS
0770   08E1 E7            pop d
0771   08E2 FD 43         mov [d], b
0772   08E4             ; break; 
0773   08E4 0A 50 09      jmp _switch10_exit ; case break
0774   08E7             _switch10_case6:
0775   08E7             ; putchar(*(char*)p); 
0776   08E7             ; --- START FUNCTION CALL
0777   08E7 FA FF FF      lea d, [bp + -1] ; $p
0778   08EA 2A            mov b, [d]
0779   08EB 38 00 00      mov c, 0
0780   08EE 74            mov d, b
0781   08EF 32            mov bl, [d]
0782   08F0 A7 00         mov bh, 0
0783   08F2 38 00 00      mov c, 0
0784   08F5 DD            push bl
0785   08F6 07 46 0B      call putchar
0786   08F9 51 01 00      add sp, 1
0787   08FC             ; --- END FUNCTION CALL
0788   08FC             ; p = p + 2; 
0789   08FC FA FF FF      lea d, [bp + -1] ; $p
0790   08FF DA            push d
0791   0900 FA FF FF      lea d, [bp + -1] ; $p
0792   0903 2A            mov b, [d]
0793   0904 38 00 00      mov c, 0
0794   0907             ; --- START TERMS
0795   0907 D7            push a
0796   0908 11            mov a, b
0797   0909 FD 2E 02 00   mov32 cb, $00000002
0797   090D 00 00 
0798   090F 56            add b, a
0799   0910 E4            pop a
0800   0911             ; --- END TERMS
0801   0911 E7            pop d
0802   0912 FD 43         mov [d], b
0803   0914             ; break; 
0804   0914 0A 50 09      jmp _switch10_exit ; case break
0805   0917             _switch10_case7:
0806   0917             ; print(*(char**)p); 
0807   0917             ; --- START FUNCTION CALL
0808   0917 FA FF FF      lea d, [bp + -1] ; $p
0809   091A 2A            mov b, [d]
0810   091B 38 00 00      mov c, 0
0811   091E 74            mov d, b
0812   091F 2A            mov b, [d]
0813   0920 FD AB         swp b
0814   0922 D8            push b
0815   0923 07 F4 0C      call print
0816   0926 51 02 00      add sp, 2
0817   0929             ; --- END FUNCTION CALL
0818   0929             ; p = p + 2; 
0819   0929 FA FF FF      lea d, [bp + -1] ; $p
0820   092C DA            push d
0821   092D FA FF FF      lea d, [bp + -1] ; $p
0822   0930 2A            mov b, [d]
0823   0931 38 00 00      mov c, 0
0824   0934             ; --- START TERMS
0825   0934 D7            push a
0826   0935 11            mov a, b
0827   0936 FD 2E 02 00   mov32 cb, $00000002
0827   093A 00 00 
0828   093C 56            add b, a
0829   093D E4            pop a
0830   093E             ; --- END TERMS
0831   093E E7            pop d
0832   093F FD 43         mov [d], b
0833   0941             ; break; 
0834   0941 0A 50 09      jmp _switch10_exit ; case break
0835   0944             _switch10_default:
0836   0944             ; print("Error: Unknown argument type.\n"); 
0837   0944             ; --- START FUNCTION CALL
0838   0944 26 01 10      mov b, _s3 ; "Error: Unknown argument type.\n"
0839   0947 FD AB         swp b
0840   0949 D8            push b
0841   094A 07 F4 0C      call print
0842   094D 51 02 00      add sp, 2
0843   0950             ; --- END FUNCTION CALL
0844   0950             _switch10_exit:
0845   0950 0A 68 09      jmp _if9_exit
0846   0953             _if9_else:
0847   0953             ; putchar(*format_p); 
0848   0953             ; --- START FUNCTION CALL
0849   0953 FA FD FF      lea d, [bp + -3] ; $format_p
0850   0956 2A            mov b, [d]
0851   0957 38 00 00      mov c, 0
0852   095A 74            mov d, b
0853   095B 32            mov bl, [d]
0854   095C A7 00         mov bh, 0
0855   095E 38 00 00      mov c, 0
0856   0961 DD            push bl
0857   0962 07 46 0B      call putchar
0858   0965 51 01 00      add sp, 1
0859   0968             ; --- END FUNCTION CALL
0860   0968             _if9_exit:
0861   0968             _if8_exit:
0862   0968             ; format_p++; 
0863   0968 FA FD FF      lea d, [bp + -3] ; $format_p
0864   096B 2A            mov b, [d]
0865   096C 38 00 00      mov c, 0
0866   096F FD 77         inc b
0867   0971 FA FD FF      lea d, [bp + -3] ; $format_p
0868   0974 FD 43         mov [d], b
0869   0976 FD 7D         dec b
0870   0978             _for7_update:
0871   0978 0A BC 06      jmp _for7_cond
0872   097B             _for7_exit:
0873   097B F9            leave
0874   097C 09            ret
0875   097D             
0876   097D             print_signed_long:
0877   097D F8 00 00      enter 0 ; (push bp; mov bp, sp)
0878   0980             ; char digits[10];  // fits 2,147,483,647 
0879   0980 52 0A 00      sub sp, 10
0880   0983             ; int i = 0; 
0881   0983 52 02 00      sub sp, 2
0882   0986             ; --- START LOCAL VAR INITIALIZATION
0883   0986 FA F5 FF      lea d, [bp + -11] ; $i
0884   0989 DA            push d
0885   098A FD 2E 00 00   mov32 cb, $00000000
0885   098E 00 00 
0886   0990 E7            pop d
0887   0991 FD 43         mov [d], b
0888   0993             ; --- END LOCAL VAR INITIALIZATION
0889   0993             ; unsigned long int absval; 
0890   0993 52 04 00      sub sp, 4
0891   0996             ; if (num < 0) { 
0892   0996             _if14_cond:
0893   0996 FA 05 00      lea d, [bp + 5] ; $num
0894   0999 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0895   099C FD 39         mov c, b ; And place it into C
0896   099E 2A            mov b, [d] ; Lower Word in B
0897   099F             ; --- START RELATIONAL
0898   099F D7            push a
0899   09A0 FD D8         push g
0900   09A2 11            mov a, b
0901   09A3 FD 7A         mov g, c
0902   09A5 FD 2E 00 00   mov32 cb, $00000000
0902   09A9 00 00 
0903   09AB 38 00 00      mov c, 0
0904   09AE FD AF         cmp32 ga, cb
0905   09B0 FD 73         slt ; <
0906   09B2 FD F1         pop g
0907   09B4 E4            pop a
0908   09B5             ; --- END RELATIONAL
0909   09B5 C0 00 00      cmp b, 0
0910   09B8 C6 17 0A      je _if14_else
0911   09BB             _if14_TRUE:
0912   09BB             ; putchar('-'); 
0913   09BB             ; --- START FUNCTION CALL
0914   09BB FD 2E 2D 00   mov32 cb, $0000002d
0914   09BF 00 00 
0915   09C1 DD            push bl
0916   09C2 07 46 0B      call putchar
0917   09C5 51 01 00      add sp, 1
0918   09C8             ; --- END FUNCTION CALL
0919   09C8             ; absval = (unsigned long int)(-(num + 1)) + 1; 
0920   09C8 FA F1 FF      lea d, [bp + -15] ; $absval
0921   09CB DA            push d
0922   09CC FA 05 00      lea d, [bp + 5] ; $num
0923   09CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0924   09D2 FD 39         mov c, b ; And place it into C
0925   09D4 2A            mov b, [d] ; Lower Word in B
0926   09D5             ; --- START TERMS
0927   09D5 D7            push a
0928   09D6 FD D8         push g
0929   09D8 11            mov a, b
0930   09D9 FD 7A         mov g, c
0931   09DB FD 2E 01 00   mov32 cb, $00000001
0931   09DF 00 00 
0932   09E1 38 00 00      mov c, 0
0933   09E4 FD 15         add32 cb, ga
0934   09E6 FD F1         pop g
0935   09E8 E4            pop a
0936   09E9             ; --- END TERMS
0937   09E9 12            mov a, c
0938   09EA 95            not a
0939   09EB 97            not b
0940   09EC 55 01 00      add b, 1
0941   09EF 5B 00 00      adc a, 0
0942   09F2 39            mov c, a
0943   09F3 A7 00         mov bh, 0
0944   09F5 38 00 00      mov c, 0
0945   09F8             ; --- START TERMS
0946   09F8 D7            push a
0947   09F9 FD D8         push g
0948   09FB 11            mov a, b
0949   09FC FD 7A         mov g, c
0950   09FE FD 2E 01 00   mov32 cb, $00000001
0950   0A02 00 00 
0951   0A04 38 00 00      mov c, 0
0952   0A07 FD 15         add32 cb, ga
0953   0A09 FD F1         pop g
0954   0A0B E4            pop a
0955   0A0C             ; --- END TERMS
0956   0A0C E7            pop d
0957   0A0D FD 43         mov [d], b
0958   0A0F 28            mov b, c
0959   0A10 FD 44 02 00   mov [d + 2], b
0960   0A14 0A 31 0A      jmp _if14_exit
0961   0A17             _if14_else:
0962   0A17             ; absval = (unsigned long int)num; 
0963   0A17 FA F1 FF      lea d, [bp + -15] ; $absval
0964   0A1A DA            push d
0965   0A1B FA 05 00      lea d, [bp + 5] ; $num
0966   0A1E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0967   0A21 FD 39         mov c, b ; And place it into C
0968   0A23 2A            mov b, [d] ; Lower Word in B
0969   0A24 A7 00         mov bh, 0
0970   0A26 38 00 00      mov c, 0
0971   0A29 E7            pop d
0972   0A2A FD 43         mov [d], b
0973   0A2C 28            mov b, c
0974   0A2D FD 44 02 00   mov [d + 2], b
0975   0A31             _if14_exit:
0976   0A31             ; if (absval == 0) { 
0977   0A31             _if15_cond:
0978   0A31 FA F1 FF      lea d, [bp + -15] ; $absval
0979   0A34 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0980   0A37 FD 39         mov c, b ; And place it into C
0981   0A39 2A            mov b, [d] ; Lower Word in B
0982   0A3A             ; --- START RELATIONAL
0983   0A3A D7            push a
0984   0A3B FD D8         push g
0985   0A3D 11            mov a, b
0986   0A3E FD 7A         mov g, c
0987   0A40 FD 2E 00 00   mov32 cb, $00000000
0987   0A44 00 00 
0988   0A46 38 00 00      mov c, 0
0989   0A49 FD AF         cmp32 ga, cb
0990   0A4B FD 71         seq ; ==
0991   0A4D FD F1         pop g
0992   0A4F E4            pop a
0993   0A50             ; --- END RELATIONAL
0994   0A50 C0 00 00      cmp b, 0
0995   0A53 C6 68 0A      je _if15_exit
0996   0A56             _if15_TRUE:
0997   0A56             ; putchar('0'); 
0998   0A56             ; --- START FUNCTION CALL
0999   0A56 FD 2E 30 00   mov32 cb, $00000030
0999   0A5A 00 00 
1000   0A5C DD            push bl
1001   0A5D 07 46 0B      call putchar
1002   0A60 51 01 00      add sp, 1
1003   0A63             ; --- END FUNCTION CALL
1004   0A63             ; return; 
1005   0A63 F9            leave
1006   0A64 09            ret
1007   0A65 0A 68 0A      jmp _if15_exit
1008   0A68             _if15_exit:
1009   0A68             ; while (absval > 0) { 
1010   0A68             _while16_cond:
1011   0A68 FA F1 FF      lea d, [bp + -15] ; $absval
1012   0A6B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1013   0A6E FD 39         mov c, b ; And place it into C
1014   0A70 2A            mov b, [d] ; Lower Word in B
1015   0A71             ; --- START RELATIONAL
1016   0A71 D7            push a
1017   0A72 FD D8         push g
1018   0A74 11            mov a, b
1019   0A75 FD 7A         mov g, c
1020   0A77 FD 2E 00 00   mov32 cb, $00000000
1020   0A7B 00 00 
1021   0A7D 38 00 00      mov c, 0
1022   0A80 FD AF         cmp32 ga, cb
1023   0A82 FD 81         sgu
1024   0A84 FD F1         pop g
1025   0A86 E4            pop a
1026   0A87             ; --- END RELATIONAL
1027   0A87 C0 00 00      cmp b, 0
1028   0A8A C6 08 0B      je _while16_exit
1029   0A8D             _while16_block:
1030   0A8D             ; digits[i++] = '0' + (absval % 10); 
1031   0A8D FA F7 FF      lea d, [bp + -9] ; $digits
1032   0A90 D7            push a
1033   0A91 DA            push d
1034   0A92 FA F5 FF      lea d, [bp + -11] ; $i
1035   0A95 2A            mov b, [d]
1036   0A96 38 00 00      mov c, 0
1037   0A99 11            mov a, b
1038   0A9A FD 77         inc b
1039   0A9C FA F5 FF      lea d, [bp + -11] ; $i
1040   0A9F FD 43         mov [d], b
1041   0AA1 27            mov b, a
1042   0AA2 E7            pop d
1043   0AA3 5A            add d, b
1044   0AA4 E4            pop a
1045   0AA5 DA            push d
1046   0AA6 FD 2E 30 00   mov32 cb, $00000030
1046   0AAA 00 00 
1047   0AAC             ; --- START TERMS
1048   0AAC D7            push a
1049   0AAD 11            mov a, b
1050   0AAE FA F1 FF      lea d, [bp + -15] ; $absval
1051   0AB1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1052   0AB4 FD 39         mov c, b ; And place it into C
1053   0AB6 2A            mov b, [d] ; Lower Word in B
1054   0AB7             ; --- START FACTORS
1055   0AB7 D7            push a
1056   0AB8 FD D8         push g
1057   0ABA 11            mov a, b
1058   0ABB FD 7A         mov g, c
1059   0ABD FD 2E 0A 00   mov32 cb, $0000000a
1059   0AC1 00 00 
1060   0AC3 FD D8         push g ; save 'g' as the div instruction uses it
1061   0AC5 AE            div a, b ; %, a: quotient, b: remainder
1062   0AC6 11            mov a, b
1063   0AC7 FD F1         pop g
1064   0AC9 FD 38         mov c, g
1065   0ACB 27            mov b, a
1066   0ACC FD F1         pop g
1067   0ACE E4            pop a
1068   0ACF             ; --- END FACTORS
1069   0ACF FD 22 00 00   mov g, 0
1070   0AD3 FD 15         add32 cb, ga
1071   0AD5 E4            pop a
1072   0AD6             ; --- END TERMS
1073   0AD6 E7            pop d
1074   0AD7 FD 3E         mov [d], bl
1075   0AD9             ; absval = absval / 10; 
1076   0AD9 FA F1 FF      lea d, [bp + -15] ; $absval
1077   0ADC DA            push d
1078   0ADD FA F1 FF      lea d, [bp + -15] ; $absval
1079   0AE0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1080   0AE3 FD 39         mov c, b ; And place it into C
1081   0AE5 2A            mov b, [d] ; Lower Word in B
1082   0AE6             ; --- START FACTORS
1083   0AE6 D7            push a
1084   0AE7 FD D8         push g
1085   0AE9 11            mov a, b
1086   0AEA FD 7A         mov g, c
1087   0AEC FD 2E 0A 00   mov32 cb, $0000000a
1087   0AF0 00 00 
1088   0AF2 FD D8         push g ; save 'g' as the div instruction uses it
1089   0AF4 AE            div a, b ; /, a: quotient, b: remainder
1090   0AF5 FD F1         pop g
1091   0AF7 FD 38         mov c, g
1092   0AF9 27            mov b, a
1093   0AFA FD F1         pop g
1094   0AFC E4            pop a
1095   0AFD             ; --- END FACTORS
1096   0AFD E7            pop d
1097   0AFE FD 43         mov [d], b
1098   0B00 28            mov b, c
1099   0B01 FD 44 02 00   mov [d + 2], b
1100   0B05 0A 68 0A      jmp _while16_cond
1101   0B08             _while16_exit:
1102   0B08             ; while (i > 0) { 
1103   0B08             _while23_cond:
1104   0B08 FA F5 FF      lea d, [bp + -11] ; $i
1105   0B0B 2A            mov b, [d]
1106   0B0C 38 00 00      mov c, 0
1107   0B0F             ; --- START RELATIONAL
1108   0B0F D7            push a
1109   0B10 11            mov a, b
1110   0B11 FD 2E 00 00   mov32 cb, $00000000
1110   0B15 00 00 
1111   0B17 B0            cmp a, b
1112   0B18 FD 7F         sgt ; >
1113   0B1A E4            pop a
1114   0B1B             ; --- END RELATIONAL
1115   0B1B C0 00 00      cmp b, 0
1116   0B1E C6 44 0B      je _while23_exit
1117   0B21             _while23_block:
1118   0B21             ; putchar(digits[--i]); 
1119   0B21             ; --- START FUNCTION CALL
1120   0B21 FA F7 FF      lea d, [bp + -9] ; $digits
1121   0B24 D7            push a
1122   0B25 DA            push d
1123   0B26 FA F5 FF      lea d, [bp + -11] ; $i
1124   0B29 2A            mov b, [d]
1125   0B2A FD 7D         dec b
1126   0B2C FA F5 FF      lea d, [bp + -11] ; $i
1127   0B2F FD 43         mov [d], b
1128   0B31 E7            pop d
1129   0B32 5A            add d, b
1130   0B33 E4            pop a
1131   0B34 32            mov bl, [d]
1132   0B35 A7 00         mov bh, 0
1133   0B37 38 00 00      mov c, 0
1134   0B3A DD            push bl
1135   0B3B 07 46 0B      call putchar
1136   0B3E 51 01 00      add sp, 1
1137   0B41             ; --- END FUNCTION CALL
1138   0B41 0A 08 0B      jmp _while23_cond
1139   0B44             _while23_exit:
1140   0B44 F9            leave
1141   0B45 09            ret
1142   0B46             
1143   0B46             putchar:
1144   0B46 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1145   0B49             ; --- BEGIN INLINE ASM SEGMENT
1146   0B49 FA 05 00      lea d, [bp + 5] ; $c
1147   0B4C 1E            mov al, [d]
1148   0B4D 23            mov ah, al
1149   0B4E 19 00         mov al, 0
1150   0B50 05 03         syscall sys_io      ; char in AH
1151   0B52             ; --- END INLINE ASM SEGMENT
1152   0B52 F9            leave
1153   0B53 09            ret
1154   0B54             
1155   0B54             print_unsigned_long:
1156   0B54 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1157   0B57             ; char digits[10]; 
1158   0B57 52 0A 00      sub sp, 10
1159   0B5A             ; int i = 0; 
1160   0B5A 52 02 00      sub sp, 2
1161   0B5D             ; --- START LOCAL VAR INITIALIZATION
1162   0B5D FA F5 FF      lea d, [bp + -11] ; $i
1163   0B60 DA            push d
1164   0B61 FD 2E 00 00   mov32 cb, $00000000
1164   0B65 00 00 
1165   0B67 E7            pop d
1166   0B68 FD 43         mov [d], b
1167   0B6A             ; --- END LOCAL VAR INITIALIZATION
1168   0B6A             ; if(num == 0){ 
1169   0B6A             _if24_cond:
1170   0B6A FA 05 00      lea d, [bp + 5] ; $num
1171   0B6D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1172   0B70 FD 39         mov c, b ; And place it into C
1173   0B72 2A            mov b, [d] ; Lower Word in B
1174   0B73             ; --- START RELATIONAL
1175   0B73 D7            push a
1176   0B74 FD D8         push g
1177   0B76 11            mov a, b
1178   0B77 FD 7A         mov g, c
1179   0B79 FD 2E 00 00   mov32 cb, $00000000
1179   0B7D 00 00 
1180   0B7F 38 00 00      mov c, 0
1181   0B82 FD AF         cmp32 ga, cb
1182   0B84 FD 71         seq ; ==
1183   0B86 FD F1         pop g
1184   0B88 E4            pop a
1185   0B89             ; --- END RELATIONAL
1186   0B89 C0 00 00      cmp b, 0
1187   0B8C C6 A1 0B      je _if24_exit
1188   0B8F             _if24_TRUE:
1189   0B8F             ; putchar('0'); 
1190   0B8F             ; --- START FUNCTION CALL
1191   0B8F FD 2E 30 00   mov32 cb, $00000030
1191   0B93 00 00 
1192   0B95 DD            push bl
1193   0B96 07 46 0B      call putchar
1194   0B99 51 01 00      add sp, 1
1195   0B9C             ; --- END FUNCTION CALL
1196   0B9C             ; return; 
1197   0B9C F9            leave
1198   0B9D 09            ret
1199   0B9E 0A A1 0B      jmp _if24_exit
1200   0BA1             _if24_exit:
1201   0BA1             ; while (num > 0) { 
1202   0BA1             _while25_cond:
1203   0BA1 FA 05 00      lea d, [bp + 5] ; $num
1204   0BA4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1205   0BA7 FD 39         mov c, b ; And place it into C
1206   0BA9 2A            mov b, [d] ; Lower Word in B
1207   0BAA             ; --- START RELATIONAL
1208   0BAA D7            push a
1209   0BAB FD D8         push g
1210   0BAD 11            mov a, b
1211   0BAE FD 7A         mov g, c
1212   0BB0 FD 2E 00 00   mov32 cb, $00000000
1212   0BB4 00 00 
1213   0BB6 38 00 00      mov c, 0
1214   0BB9 FD AF         cmp32 ga, cb
1215   0BBB FD 81         sgu
1216   0BBD FD F1         pop g
1217   0BBF E4            pop a
1218   0BC0             ; --- END RELATIONAL
1219   0BC0 C0 00 00      cmp b, 0
1220   0BC3 C6 41 0C      je _while25_exit
1221   0BC6             _while25_block:
1222   0BC6             ; digits[i++] = '0' + (num % 10); 
1223   0BC6 FA F7 FF      lea d, [bp + -9] ; $digits
1224   0BC9 D7            push a
1225   0BCA DA            push d
1226   0BCB FA F5 FF      lea d, [bp + -11] ; $i
1227   0BCE 2A            mov b, [d]
1228   0BCF 38 00 00      mov c, 0
1229   0BD2 11            mov a, b
1230   0BD3 FD 77         inc b
1231   0BD5 FA F5 FF      lea d, [bp + -11] ; $i
1232   0BD8 FD 43         mov [d], b
1233   0BDA 27            mov b, a
1234   0BDB E7            pop d
1235   0BDC 5A            add d, b
1236   0BDD E4            pop a
1237   0BDE DA            push d
1238   0BDF FD 2E 30 00   mov32 cb, $00000030
1238   0BE3 00 00 
1239   0BE5             ; --- START TERMS
1240   0BE5 D7            push a
1241   0BE6 11            mov a, b
1242   0BE7 FA 05 00      lea d, [bp + 5] ; $num
1243   0BEA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1244   0BED FD 39         mov c, b ; And place it into C
1245   0BEF 2A            mov b, [d] ; Lower Word in B
1246   0BF0             ; --- START FACTORS
1247   0BF0 D7            push a
1248   0BF1 FD D8         push g
1249   0BF3 11            mov a, b
1250   0BF4 FD 7A         mov g, c
1251   0BF6 FD 2E 0A 00   mov32 cb, $0000000a
1251   0BFA 00 00 
1252   0BFC FD D8         push g ; save 'g' as the div instruction uses it
1253   0BFE AE            div a, b ; %, a: quotient, b: remainder
1254   0BFF 11            mov a, b
1255   0C00 FD F1         pop g
1256   0C02 FD 38         mov c, g
1257   0C04 27            mov b, a
1258   0C05 FD F1         pop g
1259   0C07 E4            pop a
1260   0C08             ; --- END FACTORS
1261   0C08 FD 22 00 00   mov g, 0
1262   0C0C FD 15         add32 cb, ga
1263   0C0E E4            pop a
1264   0C0F             ; --- END TERMS
1265   0C0F E7            pop d
1266   0C10 FD 3E         mov [d], bl
1267   0C12             ; num = num / 10; 
1268   0C12 FA 05 00      lea d, [bp + 5] ; $num
1269   0C15 DA            push d
1270   0C16 FA 05 00      lea d, [bp + 5] ; $num
1271   0C19 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1272   0C1C FD 39         mov c, b ; And place it into C
1273   0C1E 2A            mov b, [d] ; Lower Word in B
1274   0C1F             ; --- START FACTORS
1275   0C1F D7            push a
1276   0C20 FD D8         push g
1277   0C22 11            mov a, b
1278   0C23 FD 7A         mov g, c
1279   0C25 FD 2E 0A 00   mov32 cb, $0000000a
1279   0C29 00 00 
1280   0C2B FD D8         push g ; save 'g' as the div instruction uses it
1281   0C2D AE            div a, b ; /, a: quotient, b: remainder
1282   0C2E FD F1         pop g
1283   0C30 FD 38         mov c, g
1284   0C32 27            mov b, a
1285   0C33 FD F1         pop g
1286   0C35 E4            pop a
1287   0C36             ; --- END FACTORS
1288   0C36 E7            pop d
1289   0C37 FD 43         mov [d], b
1290   0C39 28            mov b, c
1291   0C3A FD 44 02 00   mov [d + 2], b
1292   0C3E 0A A1 0B      jmp _while25_cond
1293   0C41             _while25_exit:
1294   0C41             ; while (i > 0) { 
1295   0C41             _while32_cond:
1296   0C41 FA F5 FF      lea d, [bp + -11] ; $i
1297   0C44 2A            mov b, [d]
1298   0C45 38 00 00      mov c, 0
1299   0C48             ; --- START RELATIONAL
1300   0C48 D7            push a
1301   0C49 11            mov a, b
1302   0C4A FD 2E 00 00   mov32 cb, $00000000
1302   0C4E 00 00 
1303   0C50 B0            cmp a, b
1304   0C51 FD 7F         sgt ; >
1305   0C53 E4            pop a
1306   0C54             ; --- END RELATIONAL
1307   0C54 C0 00 00      cmp b, 0
1308   0C57 C6 7D 0C      je _while32_exit
1309   0C5A             _while32_block:
1310   0C5A             ; putchar(digits[--i]); 
1311   0C5A             ; --- START FUNCTION CALL
1312   0C5A FA F7 FF      lea d, [bp + -9] ; $digits
1313   0C5D D7            push a
1314   0C5E DA            push d
1315   0C5F FA F5 FF      lea d, [bp + -11] ; $i
1316   0C62 2A            mov b, [d]
1317   0C63 FD 7D         dec b
1318   0C65 FA F5 FF      lea d, [bp + -11] ; $i
1319   0C68 FD 43         mov [d], b
1320   0C6A E7            pop d
1321   0C6B 5A            add d, b
1322   0C6C E4            pop a
1323   0C6D 32            mov bl, [d]
1324   0C6E A7 00         mov bh, 0
1325   0C70 38 00 00      mov c, 0
1326   0C73 DD            push bl
1327   0C74 07 46 0B      call putchar
1328   0C77 51 01 00      add sp, 1
1329   0C7A             ; --- END FUNCTION CALL
1330   0C7A 0A 41 0C      jmp _while32_cond
1331   0C7D             _while32_exit:
1332   0C7D F9            leave
1333   0C7E 09            ret
1334   0C7F             
1335   0C7F             printx32:
1336   0C7F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1337   0C82             ; --- BEGIN INLINE ASM SEGMENT
1338   0C82 FA 05 00      lea d, [bp + 5] ; $hex
1339   0C85 2B 02 00      mov b, [d+2]
1340   0C88 07 91 0C      call print_u16x_printx32
1341   0C8B 2A            mov b, [d]
1342   0C8C 07 91 0C      call print_u16x_printx32
1343   0C8F             ; --- END INLINE ASM SEGMENT
1344   0C8F             ; return; 
1345   0C8F F9            leave
1346   0C90 09            ret
1347   0C91             ; --- BEGIN INLINE ASM SEGMENT
1348   0C91             print_u16x_printx32:
1349   0C91 D7            push a
1350   0C92 D8            push b
1351   0C93 DD            push bl
1352   0C94 30            mov bl, bh
1353   0C95 07 B3 0C      call _itoa_printx32        ; convert bh to char in A
1354   0C98 2F            mov bl, al        ; save al
1355   0C99 19 00         mov al, 0
1356   0C9B 05 03         syscall sys_io        ; display AH
1357   0C9D 24            mov ah, bl        ; retrieve al
1358   0C9E 19 00         mov al, 0
1359   0CA0 05 03         syscall sys_io        ; display AL
1360   0CA2 EA            pop bl
1361   0CA3 07 B3 0C      call _itoa_printx32        ; convert bh to char in A
1362   0CA6 2F            mov bl, al        ; save al
1363   0CA7 19 00         mov al, 0
1364   0CA9 05 03         syscall sys_io        ; display AH
1365   0CAB 24            mov ah, bl        ; retrieve al
1366   0CAC 19 00         mov al, 0
1367   0CAE 05 03         syscall sys_io        ; display AL
1368   0CB0 E5            pop b
1369   0CB1 E4            pop a
1370   0CB2 09            ret
1371   0CB3             _itoa_printx32:
1372   0CB3 DA            push d
1373   0CB4 D8            push b
1374   0CB5 A7 00         mov bh, 0
1375   0CB7 FD A4 04      shr bl, 4  
1376   0CBA 74            mov d, b
1377   0CBB 1F CD 0C      mov al, [d + s_hex_digits_printx32]
1378   0CBE 23            mov ah, al
1379   0CBF E5            pop b
1380   0CC0 D8            push b
1381   0CC1 A7 00         mov bh, 0
1382   0CC3 FD 87 0F      and bl, $0F
1383   0CC6 74            mov d, b
1384   0CC7 1F CD 0C      mov al, [d + s_hex_digits_printx32]
1385   0CCA E5            pop b
1386   0CCB E7            pop d
1387   0CCC 09            ret
1388   0CCD 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1388   0CD1 34 35 36 37 
1388   0CD5 38 39 41 42 
1388   0CD9 43 44 45 46 
1389   0CDD             ; --- END INLINE ASM SEGMENT
1390   0CDD F9            leave
1391   0CDE 09            ret
1392   0CDF             
1393   0CDF             err:
1394   0CDF F8 00 00      enter 0 ; (push bp; mov bp, sp)
1395   0CE2             ; print(e); 
1396   0CE2             ; --- START FUNCTION CALL
1397   0CE2 FA 05 00      lea d, [bp + 5] ; $e
1398   0CE5 2A            mov b, [d]
1399   0CE6 38 00 00      mov c, 0
1400   0CE9 FD AB         swp b
1401   0CEB D8            push b
1402   0CEC 07 F4 0C      call print
1403   0CEF 51 02 00      add sp, 2
1404   0CF2             ; --- END FUNCTION CALL
1405   0CF2 F9            leave
1406   0CF3 09            ret
1407   0CF4             
1408   0CF4             print:
1409   0CF4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1410   0CF7             ; --- BEGIN INLINE ASM SEGMENT
1411   0CF7 FA 05 00      lea d, [bp + 5] ; $s
1412   0CFA FD 2A         mov d, [d]
1413   0CFC             _puts_L1_print:
1414   0CFC 1E            mov al, [d]
1415   0CFD B9 00         cmp al, 0
1416   0CFF C6 0B 0D      jz _puts_END_print
1417   0D02 23            mov ah, al
1418   0D03 19 00         mov al, 0
1419   0D05 05 03         syscall sys_io
1420   0D07 79            inc d
1421   0D08 0A FC 0C      jmp _puts_L1_print
1422   0D0B             _puts_END_print:
1423   0D0B             ; --- END INLINE ASM SEGMENT
1424   0D0B F9            leave
1425   0D0C 09            ret
1426   0D0D             
1427   0D0D             print_signed:
1428   0D0D F8 00 00      enter 0 ; (push bp; mov bp, sp)
1429   0D10             ; char digits[5];  // enough for "-32768" 
1430   0D10 52 05 00      sub sp, 5
1431   0D13             ; int i = 0; 
1432   0D13 52 02 00      sub sp, 2
1433   0D16             ; --- START LOCAL VAR INITIALIZATION
1434   0D16 FA FA FF      lea d, [bp + -6] ; $i
1435   0D19 DA            push d
1436   0D1A FD 2E 00 00   mov32 cb, $00000000
1436   0D1E 00 00 
1437   0D20 E7            pop d
1438   0D21 FD 43         mov [d], b
1439   0D23             ; --- END LOCAL VAR INITIALIZATION
1440   0D23             ; unsigned int absval; 
1441   0D23 52 02 00      sub sp, 2
1442   0D26             ; if (num < 0) { 
1443   0D26             _if33_cond:
1444   0D26 FA 05 00      lea d, [bp + 5] ; $num
1445   0D29 2A            mov b, [d]
1446   0D2A 38 00 00      mov c, 0
1447   0D2D             ; --- START RELATIONAL
1448   0D2D D7            push a
1449   0D2E 11            mov a, b
1450   0D2F FD 2E 00 00   mov32 cb, $00000000
1450   0D33 00 00 
1451   0D35 B0            cmp a, b
1452   0D36 FD 73         slt ; < (signed)
1453   0D38 E4            pop a
1454   0D39             ; --- END RELATIONAL
1455   0D39 C0 00 00      cmp b, 0
1456   0D3C C6 73 0D      je _if33_else
1457   0D3F             _if33_TRUE:
1458   0D3F             ; putchar('-'); 
1459   0D3F             ; --- START FUNCTION CALL
1460   0D3F FD 2E 2D 00   mov32 cb, $0000002d
1460   0D43 00 00 
1461   0D45 DD            push bl
1462   0D46 07 46 0B      call putchar
1463   0D49 51 01 00      add sp, 1
1464   0D4C             ; --- END FUNCTION CALL
1465   0D4C             ; absval = (unsigned int)(-(num + 1)) + 1;  // safe for -32768 
1466   0D4C FA F8 FF      lea d, [bp + -8] ; $absval
1467   0D4F DA            push d
1468   0D50 FA 05 00      lea d, [bp + 5] ; $num
1469   0D53 2A            mov b, [d]
1470   0D54 38 00 00      mov c, 0
1471   0D57             ; --- START TERMS
1472   0D57 D7            push a
1473   0D58 11            mov a, b
1474   0D59 FD 2E 01 00   mov32 cb, $00000001
1474   0D5D 00 00 
1475   0D5F 56            add b, a
1476   0D60 E4            pop a
1477   0D61             ; --- END TERMS
1478   0D61 FD 97         neg b
1479   0D63             ; --- START TERMS
1480   0D63 D7            push a
1481   0D64 11            mov a, b
1482   0D65 FD 2E 01 00   mov32 cb, $00000001
1482   0D69 00 00 
1483   0D6B 56            add b, a
1484   0D6C E4            pop a
1485   0D6D             ; --- END TERMS
1486   0D6D E7            pop d
1487   0D6E FD 43         mov [d], b
1488   0D70 0A 81 0D      jmp _if33_exit
1489   0D73             _if33_else:
1490   0D73             ; absval = (unsigned int)num; 
1491   0D73 FA F8 FF      lea d, [bp + -8] ; $absval
1492   0D76 DA            push d
1493   0D77 FA 05 00      lea d, [bp + 5] ; $num
1494   0D7A 2A            mov b, [d]
1495   0D7B 38 00 00      mov c, 0
1496   0D7E E7            pop d
1497   0D7F FD 43         mov [d], b
1498   0D81             _if33_exit:
1499   0D81             ; if (absval == 0) { 
1500   0D81             _if34_cond:
1501   0D81 FA F8 FF      lea d, [bp + -8] ; $absval
1502   0D84 2A            mov b, [d]
1503   0D85 38 00 00      mov c, 0
1504   0D88             ; --- START RELATIONAL
1505   0D88 D7            push a
1506   0D89 11            mov a, b
1507   0D8A FD 2E 00 00   mov32 cb, $00000000
1507   0D8E 00 00 
1508   0D90 B0            cmp a, b
1509   0D91 FD 71         seq ; ==
1510   0D93 E4            pop a
1511   0D94             ; --- END RELATIONAL
1512   0D94 C0 00 00      cmp b, 0
1513   0D97 C6 AC 0D      je _if34_exit
1514   0D9A             _if34_TRUE:
1515   0D9A             ; putchar('0'); 
1516   0D9A             ; --- START FUNCTION CALL
1517   0D9A FD 2E 30 00   mov32 cb, $00000030
1517   0D9E 00 00 
1518   0DA0 DD            push bl
1519   0DA1 07 46 0B      call putchar
1520   0DA4 51 01 00      add sp, 1
1521   0DA7             ; --- END FUNCTION CALL
1522   0DA7             ; return; 
1523   0DA7 F9            leave
1524   0DA8 09            ret
1525   0DA9 0A AC 0D      jmp _if34_exit
1526   0DAC             _if34_exit:
1527   0DAC             ; while (absval > 0) { 
1528   0DAC             _while35_cond:
1529   0DAC FA F8 FF      lea d, [bp + -8] ; $absval
1530   0DAF 2A            mov b, [d]
1531   0DB0 38 00 00      mov c, 0
1532   0DB3             ; --- START RELATIONAL
1533   0DB3 D7            push a
1534   0DB4 11            mov a, b
1535   0DB5 FD 2E 00 00   mov32 cb, $00000000
1535   0DB9 00 00 
1536   0DBB B0            cmp a, b
1537   0DBC FD 81         sgu ; > (unsigned)
1538   0DBE E4            pop a
1539   0DBF             ; --- END RELATIONAL
1540   0DBF C0 00 00      cmp b, 0
1541   0DC2 C6 32 0E      je _while35_exit
1542   0DC5             _while35_block:
1543   0DC5             ; digits[i++] = '0' + (absval % 10); 
1544   0DC5 FA FC FF      lea d, [bp + -4] ; $digits
1545   0DC8 D7            push a
1546   0DC9 DA            push d
1547   0DCA FA FA FF      lea d, [bp + -6] ; $i
1548   0DCD 2A            mov b, [d]
1549   0DCE 38 00 00      mov c, 0
1550   0DD1 11            mov a, b
1551   0DD2 FD 77         inc b
1552   0DD4 FA FA FF      lea d, [bp + -6] ; $i
1553   0DD7 FD 43         mov [d], b
1554   0DD9 27            mov b, a
1555   0DDA E7            pop d
1556   0DDB 5A            add d, b
1557   0DDC E4            pop a
1558   0DDD DA            push d
1559   0DDE FD 2E 30 00   mov32 cb, $00000030
1559   0DE2 00 00 
1560   0DE4             ; --- START TERMS
1561   0DE4 D7            push a
1562   0DE5 11            mov a, b
1563   0DE6 FA F8 FF      lea d, [bp + -8] ; $absval
1564   0DE9 2A            mov b, [d]
1565   0DEA 38 00 00      mov c, 0
1566   0DED             ; --- START FACTORS
1567   0DED D7            push a
1568   0DEE FD D8         push g
1569   0DF0 11            mov a, b
1570   0DF1 FD 7A         mov g, c
1571   0DF3 FD 2E 0A 00   mov32 cb, $0000000a
1571   0DF7 00 00 
1572   0DF9 FD D8         push g ; save 'g' as the div instruction uses it
1573   0DFB AE            div a, b ; %, a: quotient, b: remainder
1574   0DFC 11            mov a, b
1575   0DFD FD F1         pop g
1576   0DFF FD 38         mov c, g
1577   0E01 27            mov b, a
1578   0E02 FD F1         pop g
1579   0E04 E4            pop a
1580   0E05             ; --- END FACTORS
1581   0E05 56            add b, a
1582   0E06 E4            pop a
1583   0E07             ; --- END TERMS
1584   0E07 E7            pop d
1585   0E08 FD 3E         mov [d], bl
1586   0E0A             ; absval = absval / 10; 
1587   0E0A FA F8 FF      lea d, [bp + -8] ; $absval
1588   0E0D DA            push d
1589   0E0E FA F8 FF      lea d, [bp + -8] ; $absval
1590   0E11 2A            mov b, [d]
1591   0E12 38 00 00      mov c, 0
1592   0E15             ; --- START FACTORS
1593   0E15 D7            push a
1594   0E16 FD D8         push g
1595   0E18 11            mov a, b
1596   0E19 FD 7A         mov g, c
1597   0E1B FD 2E 0A 00   mov32 cb, $0000000a
1597   0E1F 00 00 
1598   0E21 FD D8         push g ; save 'g' as the div instruction uses it
1599   0E23 AE            div a, b ; /, a: quotient, b: remainder
1600   0E24 FD F1         pop g
1601   0E26 FD 38         mov c, g
1602   0E28 27            mov b, a
1603   0E29 FD F1         pop g
1604   0E2B E4            pop a
1605   0E2C             ; --- END FACTORS
1606   0E2C E7            pop d
1607   0E2D FD 43         mov [d], b
1608   0E2F 0A AC 0D      jmp _while35_cond
1609   0E32             _while35_exit:
1610   0E32             ; while (i > 0) { 
1611   0E32             _while42_cond:
1612   0E32 FA FA FF      lea d, [bp + -6] ; $i
1613   0E35 2A            mov b, [d]
1614   0E36 38 00 00      mov c, 0
1615   0E39             ; --- START RELATIONAL
1616   0E39 D7            push a
1617   0E3A 11            mov a, b
1618   0E3B FD 2E 00 00   mov32 cb, $00000000
1618   0E3F 00 00 
1619   0E41 B0            cmp a, b
1620   0E42 FD 7F         sgt ; >
1621   0E44 E4            pop a
1622   0E45             ; --- END RELATIONAL
1623   0E45 C0 00 00      cmp b, 0
1624   0E48 C6 6E 0E      je _while42_exit
1625   0E4B             _while42_block:
1626   0E4B             ; putchar(digits[--i]); 
1627   0E4B             ; --- START FUNCTION CALL
1628   0E4B FA FC FF      lea d, [bp + -4] ; $digits
1629   0E4E D7            push a
1630   0E4F DA            push d
1631   0E50 FA FA FF      lea d, [bp + -6] ; $i
1632   0E53 2A            mov b, [d]
1633   0E54 FD 7D         dec b
1634   0E56 FA FA FF      lea d, [bp + -6] ; $i
1635   0E59 FD 43         mov [d], b
1636   0E5B E7            pop d
1637   0E5C 5A            add d, b
1638   0E5D E4            pop a
1639   0E5E 32            mov bl, [d]
1640   0E5F A7 00         mov bh, 0
1641   0E61 38 00 00      mov c, 0
1642   0E64 DD            push bl
1643   0E65 07 46 0B      call putchar
1644   0E68 51 01 00      add sp, 1
1645   0E6B             ; --- END FUNCTION CALL
1646   0E6B 0A 32 0E      jmp _while42_cond
1647   0E6E             _while42_exit:
1648   0E6E F9            leave
1649   0E6F 09            ret
1650   0E70             
1651   0E70             print_unsigned:
1652   0E70 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1653   0E73             ; char digits[5]; 
1654   0E73 52 05 00      sub sp, 5
1655   0E76             ; int i = 0; 
1656   0E76 52 02 00      sub sp, 2
1657   0E79             ; --- START LOCAL VAR INITIALIZATION
1658   0E79 FA FA FF      lea d, [bp + -6] ; $i
1659   0E7C DA            push d
1660   0E7D FD 2E 00 00   mov32 cb, $00000000
1660   0E81 00 00 
1661   0E83 E7            pop d
1662   0E84 FD 43         mov [d], b
1663   0E86             ; --- END LOCAL VAR INITIALIZATION
1664   0E86             ; if(num == 0){ 
1665   0E86             _if43_cond:
1666   0E86 FA 05 00      lea d, [bp + 5] ; $num
1667   0E89 2A            mov b, [d]
1668   0E8A 38 00 00      mov c, 0
1669   0E8D             ; --- START RELATIONAL
1670   0E8D D7            push a
1671   0E8E 11            mov a, b
1672   0E8F FD 2E 00 00   mov32 cb, $00000000
1672   0E93 00 00 
1673   0E95 B0            cmp a, b
1674   0E96 FD 71         seq ; ==
1675   0E98 E4            pop a
1676   0E99             ; --- END RELATIONAL
1677   0E99 C0 00 00      cmp b, 0
1678   0E9C C6 B1 0E      je _if43_exit
1679   0E9F             _if43_TRUE:
1680   0E9F             ; putchar('0'); 
1681   0E9F             ; --- START FUNCTION CALL
1682   0E9F FD 2E 30 00   mov32 cb, $00000030
1682   0EA3 00 00 
1683   0EA5 DD            push bl
1684   0EA6 07 46 0B      call putchar
1685   0EA9 51 01 00      add sp, 1
1686   0EAC             ; --- END FUNCTION CALL
1687   0EAC             ; return; 
1688   0EAC F9            leave
1689   0EAD 09            ret
1690   0EAE 0A B1 0E      jmp _if43_exit
1691   0EB1             _if43_exit:
1692   0EB1             ; while (num > 0) { 
1693   0EB1             _while44_cond:
1694   0EB1 FA 05 00      lea d, [bp + 5] ; $num
1695   0EB4 2A            mov b, [d]
1696   0EB5 38 00 00      mov c, 0
1697   0EB8             ; --- START RELATIONAL
1698   0EB8 D7            push a
1699   0EB9 11            mov a, b
1700   0EBA FD 2E 00 00   mov32 cb, $00000000
1700   0EBE 00 00 
1701   0EC0 B0            cmp a, b
1702   0EC1 FD 81         sgu ; > (unsigned)
1703   0EC3 E4            pop a
1704   0EC4             ; --- END RELATIONAL
1705   0EC4 C0 00 00      cmp b, 0
1706   0EC7 C6 37 0F      je _while44_exit
1707   0ECA             _while44_block:
1708   0ECA             ; digits[i++] = '0' + (num % 10); 
1709   0ECA FA FC FF      lea d, [bp + -4] ; $digits
1710   0ECD D7            push a
1711   0ECE DA            push d
1712   0ECF FA FA FF      lea d, [bp + -6] ; $i
1713   0ED2 2A            mov b, [d]
1714   0ED3 38 00 00      mov c, 0
1715   0ED6 11            mov a, b
1716   0ED7 FD 77         inc b
1717   0ED9 FA FA FF      lea d, [bp + -6] ; $i
1718   0EDC FD 43         mov [d], b
1719   0EDE 27            mov b, a
1720   0EDF E7            pop d
1721   0EE0 5A            add d, b
1722   0EE1 E4            pop a
1723   0EE2 DA            push d
1724   0EE3 FD 2E 30 00   mov32 cb, $00000030
1724   0EE7 00 00 
1725   0EE9             ; --- START TERMS
1726   0EE9 D7            push a
1727   0EEA 11            mov a, b
1728   0EEB FA 05 00      lea d, [bp + 5] ; $num
1729   0EEE 2A            mov b, [d]
1730   0EEF 38 00 00      mov c, 0
1731   0EF2             ; --- START FACTORS
1732   0EF2 D7            push a
1733   0EF3 FD D8         push g
1734   0EF5 11            mov a, b
1735   0EF6 FD 7A         mov g, c
1736   0EF8 FD 2E 0A 00   mov32 cb, $0000000a
1736   0EFC 00 00 
1737   0EFE FD D8         push g ; save 'g' as the div instruction uses it
1738   0F00 AE            div a, b ; %, a: quotient, b: remainder
1739   0F01 11            mov a, b
1740   0F02 FD F1         pop g
1741   0F04 FD 38         mov c, g
1742   0F06 27            mov b, a
1743   0F07 FD F1         pop g
1744   0F09 E4            pop a
1745   0F0A             ; --- END FACTORS
1746   0F0A 56            add b, a
1747   0F0B E4            pop a
1748   0F0C             ; --- END TERMS
1749   0F0C E7            pop d
1750   0F0D FD 3E         mov [d], bl
1751   0F0F             ; num = num / 10; 
1752   0F0F FA 05 00      lea d, [bp + 5] ; $num
1753   0F12 DA            push d
1754   0F13 FA 05 00      lea d, [bp + 5] ; $num
1755   0F16 2A            mov b, [d]
1756   0F17 38 00 00      mov c, 0
1757   0F1A             ; --- START FACTORS
1758   0F1A D7            push a
1759   0F1B FD D8         push g
1760   0F1D 11            mov a, b
1761   0F1E FD 7A         mov g, c
1762   0F20 FD 2E 0A 00   mov32 cb, $0000000a
1762   0F24 00 00 
1763   0F26 FD D8         push g ; save 'g' as the div instruction uses it
1764   0F28 AE            div a, b ; /, a: quotient, b: remainder
1765   0F29 FD F1         pop g
1766   0F2B FD 38         mov c, g
1767   0F2D 27            mov b, a
1768   0F2E FD F1         pop g
1769   0F30 E4            pop a
1770   0F31             ; --- END FACTORS
1771   0F31 E7            pop d
1772   0F32 FD 43         mov [d], b
1773   0F34 0A B1 0E      jmp _while44_cond
1774   0F37             _while44_exit:
1775   0F37             ; while (i > 0) { 
1776   0F37             _while51_cond:
1777   0F37 FA FA FF      lea d, [bp + -6] ; $i
1778   0F3A 2A            mov b, [d]
1779   0F3B 38 00 00      mov c, 0
1780   0F3E             ; --- START RELATIONAL
1781   0F3E D7            push a
1782   0F3F 11            mov a, b
1783   0F40 FD 2E 00 00   mov32 cb, $00000000
1783   0F44 00 00 
1784   0F46 B0            cmp a, b
1785   0F47 FD 7F         sgt ; >
1786   0F49 E4            pop a
1787   0F4A             ; --- END RELATIONAL
1788   0F4A C0 00 00      cmp b, 0
1789   0F4D C6 73 0F      je _while51_exit
1790   0F50             _while51_block:
1791   0F50             ; putchar(digits[--i]); 
1792   0F50             ; --- START FUNCTION CALL
1793   0F50 FA FC FF      lea d, [bp + -4] ; $digits
1794   0F53 D7            push a
1795   0F54 DA            push d
1796   0F55 FA FA FF      lea d, [bp + -6] ; $i
1797   0F58 2A            mov b, [d]
1798   0F59 FD 7D         dec b
1799   0F5B FA FA FF      lea d, [bp + -6] ; $i
1800   0F5E FD 43         mov [d], b
1801   0F60 E7            pop d
1802   0F61 5A            add d, b
1803   0F62 E4            pop a
1804   0F63 32            mov bl, [d]
1805   0F64 A7 00         mov bh, 0
1806   0F66 38 00 00      mov c, 0
1807   0F69 DD            push bl
1808   0F6A 07 46 0B      call putchar
1809   0F6D 51 01 00      add sp, 1
1810   0F70             ; --- END FUNCTION CALL
1811   0F70 0A 37 0F      jmp _while51_cond
1812   0F73             _while51_exit:
1813   0F73 F9            leave
1814   0F74 09            ret
1815   0F75             
1816   0F75             printx16:
1817   0F75 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1818   0F78             ; --- BEGIN INLINE ASM SEGMENT
1819   0F78 FA 05 00      lea d, [bp + 5] ; $hex
1820   0F7B 2A            mov b, [d]
1821   0F7C             print_u16x_printx16:
1822   0F7C DD            push bl
1823   0F7D 30            mov bl, bh
1824   0F7E 07 9B 0F      call _itoa_printx16        ; convert bh to char in A
1825   0F81 2F            mov bl, al        ; save al
1826   0F82 19 00         mov al, 0
1827   0F84 05 03         syscall sys_io        ; display AH
1828   0F86 24            mov ah, bl        ; retrieve al
1829   0F87 19 00         mov al, 0
1830   0F89 05 03         syscall sys_io        ; display AL
1831   0F8B EA            pop bl
1832   0F8C 07 9B 0F      call _itoa_printx16        ; convert bh to char in A
1833   0F8F 2F            mov bl, al        ; save al
1834   0F90 19 00         mov al, 0
1835   0F92 05 03         syscall sys_io        ; display AH
1836   0F94 24            mov ah, bl        ; retrieve al
1837   0F95 19 00         mov al, 0
1838   0F97 05 03         syscall sys_io        ; display AL
1839   0F99             ; --- END INLINE ASM SEGMENT
1840   0F99             ; return; 
1841   0F99 F9            leave
1842   0F9A 09            ret
1843   0F9B             ; --- BEGIN INLINE ASM SEGMENT
1844   0F9B             _itoa_printx16:
1845   0F9B DA            push d
1846   0F9C D8            push b
1847   0F9D A7 00         mov bh, 0
1848   0F9F FD A4 04      shr bl, 4  
1849   0FA2 74            mov d, b
1850   0FA3 1F B5 0F      mov al, [d + s_hex_digits_printx16]
1851   0FA6 23            mov ah, al
1852   0FA7 E5            pop b
1853   0FA8 D8            push b
1854   0FA9 A7 00         mov bh, 0
1855   0FAB FD 87 0F      and bl, $0F
1856   0FAE 74            mov d, b
1857   0FAF 1F B5 0F      mov al, [d + s_hex_digits_printx16]
1858   0FB2 E5            pop b
1859   0FB3 E7            pop d
1860   0FB4 09            ret
1861   0FB5 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1861   0FB9 34 35 36 37 
1861   0FBD 38 39 41 42 
1861   0FC1 43 44 45 46 
1862   0FC5             ; --- END INLINE ASM SEGMENT
1863   0FC5 F9            leave
1864   0FC6 09            ret
1865   0FC7             ; --- END TEXT SEGMENT
1866   0FC7             
1867   0FC7             ; --- BEGIN DATA SEGMENT
1868   0FC7 00 00       _rng_state: .dw $0000
1869   0FC9 00 00       _free_list: .dw 0
1870   0FCB 68 65 6C 6C _s0: .db "hello world", 0
1870   0FCF 6F 20 77 6F 
1870   0FD3 72 6C 64 00 
1871   0FD7 0A 73 74 72 _s1: .db "\nstring: %s\n", 0
1871   0FDB 69 6E 67 3A 
1871   0FDF 20 25 73 0A 
1871   0FE3 00 
1872   0FE4 55 6E 65 78 _s2: .db "Unexpected format in printf.", 0
1872   0FE8 70 65 63 74 
1872   0FEC 65 64 20 66 
1872   0FF0 6F 72 6D 61 
1872   0FF4 74 20 69 6E 
1872   0FF8 20 70 72 69 
1872   0FFC 6E 74 66 2E 
1872   1000 00 
1873   1001 45 72 72 6F _s3: .db "Error: Unknown argument type.\n", 0
1873   1005 72 3A 20 55 
1873   1009 6E 6B 6E 6F 
1873   100D 77 6E 20 61 
1873   1011 72 67 75 6D 
1873   1015 65 6E 74 20 
1873   1019 74 79 70 65 
1873   101D 2E 0A 00 
1874   1020             
1875   1020 22 10       _heap_top: .dw _heap
1876   1022 00          _heap: .db 0
1877   1023             ; --- END DATA SEGMENT
1878   1023             
1879   1023             .end
tasm: Number of errors = 0
