0001   0000             ; --- FILENAME: test.c
0002   0000             ; --- DATE:     25-10-2025 at 05:25:02
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; int data[10]; 
0012   0408 52 14 00      sub sp, 20
0013   040B             ; int ok = 1; 
0014   040B 52 02 00      sub sp, 2
0015   040E             ; --- START LOCAL VAR INITIALIZATION
0016   040E FA EB FF      lea d, [bp + -21] ; $ok
0017   0411 DA            push d
0018   0412 FD 2E 01 00   mov32 cb, $00000001
0018   0416 00 00 
0019   0418 E7            pop d
0020   0419 FD 43         mov [d], b
0021   041B             ; --- END LOCAL VAR INITIALIZATION
0022   041B             ; printf("=== Compiler Self-Test ===\n"); 
0023   041B             ; --- START FUNCTION CALL
0024   041B 26 81 13      mov b, _s0 ; "=== Compiler Self-Test ===\n"
0025   041E FD AB         swp b
0026   0420 D8            push b
0027   0421 07 01 0A      call printf
0028   0424 51 02 00      add sp, 2
0029   0427             ; --- END FUNCTION CALL
0030   0427             ; fill_array(data, 10); 
0031   0427             ; --- START FUNCTION CALL
0032   0427 FD 2E 0A 00   mov32 cb, $0000000a
0032   042B 00 00 
0033   042D FD AB         swp b
0034   042F D8            push b
0035   0430 FA ED FF      lea d, [bp + -19] ; $data
0036   0433 2D            mov b, d
0037   0434 38 00 00      mov c, 0
0038   0437 FD AB         swp b
0039   0439 D8            push b
0040   043A 07 98 05      call fill_array
0041   043D 51 04 00      add sp, 4
0042   0440             ; --- END FUNCTION CALL
0043   0440             ; if (!check_array(data, 10)) ok = 0; 
0044   0440             _if1_cond:
0045   0440             ; --- START FUNCTION CALL
0046   0440 FD 2E 0A 00   mov32 cb, $0000000a
0046   0444 00 00 
0047   0446 FD AB         swp b
0048   0448 D8            push b
0049   0449 FA ED FF      lea d, [bp + -19] ; $data
0050   044C 2D            mov b, d
0051   044D 38 00 00      mov c, 0
0052   0450 FD AB         swp b
0053   0452 D8            push b
0054   0453 07 BC 06      call check_array
0055   0456 51 04 00      add sp, 4
0056   0459             ; --- END FUNCTION CALL
0057   0459 C0 00 00      cmp b, 0
0058   045C C6 6F 04      je _if1_exit
0059   045F             _if1_TRUE:
0060   045F             ; ok = 0; 
0061   045F FA EB FF      lea d, [bp + -21] ; $ok
0062   0462 DA            push d
0063   0463 FD 2E 00 00   mov32 cb, $00000000
0063   0467 00 00 
0064   0469 E7            pop d
0065   046A FD 43         mov [d], b
0066   046C 0A 6F 04      jmp _if1_exit
0067   046F             _if1_exit:
0068   046F             ; if (!check_factorial()) ok = 0; 
0069   046F             _if2_cond:
0070   046F             ; --- START FUNCTION CALL
0071   046F 07 93 07      call check_factorial
0072   0472 C0 00 00      cmp b, 0
0073   0475 C6 88 04      je _if2_exit
0074   0478             _if2_TRUE:
0075   0478             ; ok = 0; 
0076   0478 FA EB FF      lea d, [bp + -21] ; $ok
0077   047B DA            push d
0078   047C FD 2E 00 00   mov32 cb, $00000000
0078   0480 00 00 
0079   0482 E7            pop d
0080   0483 FD 43         mov [d], b
0081   0485 0A 88 04      jmp _if2_exit
0082   0488             _if2_exit:
0083   0488             ; if (!check_structs()) ok = 0; 
0084   0488             _if3_cond:
0085   0488             ; --- START FUNCTION CALL
0086   0488 07 F1 07      call check_structs
0087   048B C0 00 00      cmp b, 0
0088   048E C6 A1 04      je _if3_exit
0089   0491             _if3_TRUE:
0090   0491             ; ok = 0; 
0091   0491 FA EB FF      lea d, [bp + -21] ; $ok
0092   0494 DA            push d
0093   0495 FD 2E 00 00   mov32 cb, $00000000
0093   0499 00 00 
0094   049B E7            pop d
0095   049C FD 43         mov [d], b
0096   049E 0A A1 04      jmp _if3_exit
0097   04A1             _if3_exit:
0098   04A1             ; if (!check_pointers(data)) ok = 0; 
0099   04A1             _if4_cond:
0100   04A1             ; --- START FUNCTION CALL
0101   04A1 FA ED FF      lea d, [bp + -19] ; $data
0102   04A4 2D            mov b, d
0103   04A5 38 00 00      mov c, 0
0104   04A8 FD AB         swp b
0105   04AA D8            push b
0106   04AB 07 61 09      call check_pointers
0107   04AE 51 02 00      add sp, 2
0108   04B1             ; --- END FUNCTION CALL
0109   04B1 C0 00 00      cmp b, 0
0110   04B4 C6 C7 04      je _if4_exit
0111   04B7             _if4_TRUE:
0112   04B7             ; ok = 0; 
0113   04B7 FA EB FF      lea d, [bp + -21] ; $ok
0114   04BA DA            push d
0115   04BB FD 2E 00 00   mov32 cb, $00000000
0115   04BF 00 00 
0116   04C1 E7            pop d
0117   04C2 FD 43         mov [d], b
0118   04C4 0A C7 04      jmp _if4_exit
0119   04C7             _if4_exit:
0120   04C7             ; if (ok) 
0121   04C7             _if5_cond:
0122   04C7 FA EB FF      lea d, [bp + -21] ; $ok
0123   04CA 2A            mov b, [d]
0124   04CB 38 00 00      mov c, 0
0125   04CE C0 00 00      cmp b, 0
0126   04D1 C6 E3 04      je _if5_else
0127   04D4             _if5_TRUE:
0128   04D4             ; printf("\n*** ALL TESTS PASSED ***\n"); 
0129   04D4             ; --- START FUNCTION CALL
0130   04D4 26 9D 13      mov b, _s1 ; "\n*** ALL TESTS PASSED ***\n"
0131   04D7 FD AB         swp b
0132   04D9 D8            push b
0133   04DA 07 01 0A      call printf
0134   04DD 51 02 00      add sp, 2
0135   04E0             ; --- END FUNCTION CALL
0136   04E0 0A EF 04      jmp _if5_exit
0137   04E3             _if5_else:
0138   04E3             ; printf("\n*** TEST FAILED ***\n"); 
0139   04E3             ; --- START FUNCTION CALL
0140   04E3 26 B8 13      mov b, _s2 ; "\n*** TEST FAILED ***\n"
0141   04E6 FD AB         swp b
0142   04E8 D8            push b
0143   04E9 07 01 0A      call printf
0144   04EC 51 02 00      add sp, 2
0145   04EF             ; --- END FUNCTION CALL
0146   04EF             _if5_exit:
0147   04EF             ; return ok ? 0 : 1; 
0148   04EF             _ternary6_cond:
0149   04EF FA EB FF      lea d, [bp + -21] ; $ok
0150   04F2 2A            mov b, [d]
0151   04F3 38 00 00      mov c, 0
0152   04F6 C0 00 00      cmp b, 0
0153   04F9 C6 05 05      je _ternary6_FALSE
0154   04FC             _ternary6_TRUE:
0155   04FC FD 2E 00 00   mov32 cb, $00000000
0155   0500 00 00 
0156   0502 0A 0B 05      jmp _ternary6_exit
0157   0505             _ternary6_FALSE:
0158   0505 FD 2E 01 00   mov32 cb, $00000001
0158   0509 00 00 
0159   050B             _ternary6_exit:
0160   050B F9            leave
0161   050C 05 0B         syscall sys_terminate_proc
0162   050E             
0163   050E             factorial:
0164   050E F8 00 00      enter 0 ; (push bp; mov bp, sp)
0165   0511             ; if (n <= 1) return 1; 
0166   0511             _if7_cond:
0167   0511 FA 05 00      lea d, [bp + 5] ; $n
0168   0514 2A            mov b, [d]
0169   0515 38 00 00      mov c, 0
0170   0518             ; --- START RELATIONAL
0171   0518 D7            push a
0172   0519 11            mov a, b
0173   051A FD 2E 01 00   mov32 cb, $00000001
0173   051E 00 00 
0174   0520 B0            cmp a, b
0175   0521 FD 74         sle ; <= (signed)
0176   0523 E4            pop a
0177   0524             ; --- END RELATIONAL
0178   0524 C0 00 00      cmp b, 0
0179   0527 C6 35 05      je _if7_exit
0180   052A             _if7_TRUE:
0181   052A             ; return 1; 
0182   052A FD 2E 01 00   mov32 cb, $00000001
0182   052E 00 00 
0183   0530 F9            leave
0184   0531 09            ret
0185   0532 0A 35 05      jmp _if7_exit
0186   0535             _if7_exit:
0187   0535             ; return n * factorial(n - 1); 
0188   0535 FA 05 00      lea d, [bp + 5] ; $n
0189   0538 2A            mov b, [d]
0190   0539 38 00 00      mov c, 0
0191   053C             ; --- START FACTORS
0192   053C D7            push a
0193   053D FD D8         push g
0194   053F 11            mov a, b
0195   0540 FD 7A         mov g, c
0196   0542             ; --- START FUNCTION CALL
0197   0542 FA 05 00      lea d, [bp + 5] ; $n
0198   0545 2A            mov b, [d]
0199   0546 38 00 00      mov c, 0
0200   0549             ; --- START TERMS
0201   0549 D7            push a
0202   054A 11            mov a, b
0203   054B FD 2E 01 00   mov32 cb, $00000001
0203   054F 00 00 
0204   0551 60            sub a, b
0205   0552 27            mov b, a
0206   0553 E4            pop a
0207   0554             ; --- END TERMS
0208   0554 FD AB         swp b
0209   0556 D8            push b
0210   0557 07 0E 05      call factorial
0211   055A 51 02 00      add sp, 2
0212   055D             ; --- END FUNCTION CALL
0213   055D D7            push a     ; save left operand
0214   055E 8E            xor a, b   ; xor sign bits
0215   055F FD AA         swp a      ; swap bytes
0216   0561 83            mov cl, al ; save result of xor into 'dl'
0217   0562 E4            pop a      ; restore left side operator
0218   0563 DF            push cl    ; save result of xor above
0219   0564 FD AA         swp a  
0220   0566 93 80         test al, $80  
0221   0568 FD AA         swp a  
0222   056A C6 6F 05      jz skip_invert_a_9  
0223   056D FD 95         neg a 
0224   056F             skip_invert_a_9:   
0225   056F FD AB         swp b
0226   0571 FD 93 80      test bl, $80  
0227   0574 FD AB         swp b
0228   0576 C6 7B 05      jz skip_invert_b_9  
0229   0579 FD 97         neg b 
0230   057B             skip_invert_b_9:   
0231   057B AC            mul a, b ; *
0232   057C FD 78         mov g, a
0233   057E 11            mov a, b
0234   057F EA            pop bl
0235   0580 FD 93 80      test bl, $80
0236   0583 C6 90 05      jz _same_signs_9
0237   0586 2F            mov bl, al
0238   0587 95            not a
0239   0588 FD 97         neg b
0240   058A 5B 00 00      adc a, 0
0241   058D FD 78         mov g, a
0242   058F 11            mov a, b
0243   0590             _same_signs_9:
0244   0590 FD 38         mov c, g
0245   0592 27            mov b, a
0246   0593 FD F1         pop g
0247   0595 E4            pop a
0248   0596             ; --- END FACTORS
0249   0596 F9            leave
0250   0597 09            ret
0251   0598             
0252   0598             fill_array:
0253   0598 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0254   059B             ; int i; 
0255   059B 52 02 00      sub sp, 2
0256   059E             ; for (i = 0; i < n; i++) { 
0257   059E             _for10_init:
0258   059E FA FF FF      lea d, [bp + -1] ; $i
0259   05A1 DA            push d
0260   05A2 FD 2E 00 00   mov32 cb, $00000000
0260   05A6 00 00 
0261   05A8 E7            pop d
0262   05A9 FD 43         mov [d], b
0263   05AB             _for10_cond:
0264   05AB FA FF FF      lea d, [bp + -1] ; $i
0265   05AE 2A            mov b, [d]
0266   05AF 38 00 00      mov c, 0
0267   05B2             ; --- START RELATIONAL
0268   05B2 D7            push a
0269   05B3 11            mov a, b
0270   05B4 FA 07 00      lea d, [bp + 7] ; $n
0271   05B7 2A            mov b, [d]
0272   05B8 38 00 00      mov c, 0
0273   05BB B0            cmp a, b
0274   05BC FD 73         slt ; < (signed)
0275   05BE E4            pop a
0276   05BF             ; --- END RELATIONAL
0277   05BF C0 00 00      cmp b, 0
0278   05C2 C6 BA 06      je _for10_exit
0279   05C5             _for10_block:
0280   05C5             ; arr[i] = (i * i + 3 * i + 7) % 97; 
0281   05C5 FA 05 00      lea d, [bp + 5] ; $arr
0282   05C8 FD 2A         mov d, [d]
0283   05CA D7            push a
0284   05CB DA            push d
0285   05CC FA FF FF      lea d, [bp + -1] ; $i
0286   05CF 2A            mov b, [d]
0287   05D0 38 00 00      mov c, 0
0288   05D3 E7            pop d
0289   05D4 FD 13 02 00   mma 2 ; mov a, 2; mul a b; add d, b
0290   05D8 E4            pop a
0291   05D9 DA            push d
0292   05DA FA FF FF      lea d, [bp + -1] ; $i
0293   05DD 2A            mov b, [d]
0294   05DE 38 00 00      mov c, 0
0295   05E1             ; --- START FACTORS
0296   05E1 D7            push a
0297   05E2 FD D8         push g
0298   05E4 11            mov a, b
0299   05E5 FD 7A         mov g, c
0300   05E7 FA FF FF      lea d, [bp + -1] ; $i
0301   05EA 2A            mov b, [d]
0302   05EB 38 00 00      mov c, 0
0303   05EE D7            push a     ; save left operand
0304   05EF 8E            xor a, b   ; xor sign bits
0305   05F0 FD AA         swp a      ; swap bytes
0306   05F2 83            mov cl, al ; save result of xor into 'dl'
0307   05F3 E4            pop a      ; restore left side operator
0308   05F4 DF            push cl    ; save result of xor above
0309   05F5 FD AA         swp a  
0310   05F7 93 80         test al, $80  
0311   05F9 FD AA         swp a  
0312   05FB C6 00 06      jz skip_invert_a_18  
0313   05FE FD 95         neg a 
0314   0600             skip_invert_a_18:   
0315   0600 FD AB         swp b
0316   0602 FD 93 80      test bl, $80  
0317   0605 FD AB         swp b
0318   0607 C6 0C 06      jz skip_invert_b_18  
0319   060A FD 97         neg b 
0320   060C             skip_invert_b_18:   
0321   060C AC            mul a, b ; *
0322   060D FD 78         mov g, a
0323   060F 11            mov a, b
0324   0610 EA            pop bl
0325   0611 FD 93 80      test bl, $80
0326   0614 C6 21 06      jz _same_signs_18
0327   0617 2F            mov bl, al
0328   0618 95            not a
0329   0619 FD 97         neg b
0330   061B 5B 00 00      adc a, 0
0331   061E FD 78         mov g, a
0332   0620 11            mov a, b
0333   0621             _same_signs_18:
0334   0621 FD 38         mov c, g
0335   0623 27            mov b, a
0336   0624 FD F1         pop g
0337   0626 E4            pop a
0338   0627             ; --- END FACTORS
0339   0627             ; --- START TERMS
0340   0627 D7            push a
0341   0628 FD D8         push g
0342   062A 11            mov a, b
0343   062B FD 7A         mov g, c
0344   062D FD 2E 03 00   mov32 cb, $00000003
0344   0631 00 00 
0345   0633             ; --- START FACTORS
0346   0633 D7            push a
0347   0634 FD D8         push g
0348   0636 11            mov a, b
0349   0637 FD 7A         mov g, c
0350   0639 FA FF FF      lea d, [bp + -1] ; $i
0351   063C 2A            mov b, [d]
0352   063D 38 00 00      mov c, 0
0353   0640 D7            push a     ; save left operand
0354   0641 8E            xor a, b   ; xor sign bits
0355   0642 FD AA         swp a      ; swap bytes
0356   0644 83            mov cl, al ; save result of xor into 'dl'
0357   0645 E4            pop a      ; restore left side operator
0358   0646 DF            push cl    ; save result of xor above
0359   0647 FD AA         swp a  
0360   0649 93 80         test al, $80  
0361   064B FD AA         swp a  
0362   064D C6 52 06      jz skip_invert_a_19  
0363   0650 FD 95         neg a 
0364   0652             skip_invert_a_19:   
0365   0652 FD AB         swp b
0366   0654 FD 93 80      test bl, $80  
0367   0657 FD AB         swp b
0368   0659 C6 5E 06      jz skip_invert_b_19  
0369   065C FD 97         neg b 
0370   065E             skip_invert_b_19:   
0371   065E AC            mul a, b ; *
0372   065F FD 78         mov g, a
0373   0661 11            mov a, b
0374   0662 EA            pop bl
0375   0663 FD 93 80      test bl, $80
0376   0666 C6 73 06      jz _same_signs_19
0377   0669 2F            mov bl, al
0378   066A 95            not a
0379   066B FD 97         neg b
0380   066D 5B 00 00      adc a, 0
0381   0670 FD 78         mov g, a
0382   0672 11            mov a, b
0383   0673             _same_signs_19:
0384   0673 FD 38         mov c, g
0385   0675 27            mov b, a
0386   0676 FD F1         pop g
0387   0678 E4            pop a
0388   0679             ; --- END FACTORS
0389   0679 FD 15         add32 cb, ga
0390   067B 11            mov a, b
0391   067C FD 7A         mov g, c
0392   067E FD 2E 07 00   mov32 cb, $00000007
0392   0682 00 00 
0393   0684 38 00 00      mov c, 0
0394   0687 FD 15         add32 cb, ga
0395   0689 FD F1         pop g
0396   068B E4            pop a
0397   068C             ; --- END TERMS
0398   068C             ; --- START FACTORS
0399   068C D7            push a
0400   068D FD D8         push g
0401   068F 11            mov a, b
0402   0690 FD 7A         mov g, c
0403   0692 FD 2E 61 00   mov32 cb, $00000061
0403   0696 00 00 
0404   0698 FD D8         push g ; save 'g' as the div instruction uses it
0405   069A AE            div a, b ; %, a: quotient, b: remainder
0406   069B 11            mov a, b
0407   069C FD F1         pop g
0408   069E FD 38         mov c, g
0409   06A0 27            mov b, a
0410   06A1 FD F1         pop g
0411   06A3 E4            pop a
0412   06A4             ; --- END FACTORS
0413   06A4 E7            pop d
0414   06A5 FD 43         mov [d], b
0415   06A7             _for10_update:
0416   06A7 FA FF FF      lea d, [bp + -1] ; $i
0417   06AA 2A            mov b, [d]
0418   06AB 38 00 00      mov c, 0
0419   06AE 11            mov a, b
0420   06AF FD 77         inc b
0421   06B1 FA FF FF      lea d, [bp + -1] ; $i
0422   06B4 FD 43         mov [d], b
0423   06B6 27            mov b, a
0424   06B7 0A AB 05      jmp _for10_cond
0425   06BA             _for10_exit:
0426   06BA F9            leave
0427   06BB 09            ret
0428   06BC             
0429   06BC             check_array:
0430   06BC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0431   06BF             ; int i; 
0432   06BF 52 02 00      sub sp, 2
0433   06C2             ; for (i = 0; i < n; i++) { 
0434   06C2             _for21_init:
0435   06C2 FA FF FF      lea d, [bp + -1] ; $i
0436   06C5 DA            push d
0437   06C6 FD 2E 00 00   mov32 cb, $00000000
0437   06CA 00 00 
0438   06CC E7            pop d
0439   06CD FD 43         mov [d], b
0440   06CF             _for21_cond:
0441   06CF FA FF FF      lea d, [bp + -1] ; $i
0442   06D2 2A            mov b, [d]
0443   06D3 38 00 00      mov c, 0
0444   06D6             ; --- START RELATIONAL
0445   06D6 D7            push a
0446   06D7 11            mov a, b
0447   06D8 FA 07 00      lea d, [bp + 7] ; $n
0448   06DB 2A            mov b, [d]
0449   06DC 38 00 00      mov c, 0
0450   06DF B0            cmp a, b
0451   06E0 FD 73         slt ; < (signed)
0452   06E2 E4            pop a
0453   06E3             ; --- END RELATIONAL
0454   06E3 C0 00 00      cmp b, 0
0455   06E6 C6 8B 07      je _for21_exit
0456   06E9             _for21_block:
0457   06E9             ; if (arr[i] != expected[i]) { 
0458   06E9             _if22_cond:
0459   06E9 FA 05 00      lea d, [bp + 5] ; $arr
0460   06EC FD 2A         mov d, [d]
0461   06EE D7            push a
0462   06EF DA            push d
0463   06F0 FA FF FF      lea d, [bp + -1] ; $i
0464   06F3 2A            mov b, [d]
0465   06F4 38 00 00      mov c, 0
0466   06F7 E7            pop d
0467   06F8 FD 13 02 00   mma 2 ; mov a, 2; mul a b; add d, b
0468   06FC E4            pop a
0469   06FD 2A            mov b, [d]
0470   06FE 38 00 00      mov c, 0
0471   0701             ; --- START RELATIONAL
0472   0701 D7            push a
0473   0702 11            mov a, b
0474   0703 3B 59 13      mov d, _expected_data ; $expected
0475   0706 D7            push a
0476   0707 DA            push d
0477   0708 FA FF FF      lea d, [bp + -1] ; $i
0478   070B 2A            mov b, [d]
0479   070C 38 00 00      mov c, 0
0480   070F E7            pop d
0481   0710 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0482   0714 E4            pop a
0483   0715 2A            mov b, [d]
0484   0716 38 00 00      mov c, 0
0485   0719 B0            cmp a, b
0486   071A FD 72         sneq ; !=
0487   071C E4            pop a
0488   071D             ; --- END RELATIONAL
0489   071D C0 00 00      cmp b, 0
0490   0720 C6 78 07      je _if22_exit
0491   0723             _if22_TRUE:
0492   0723             ; printf("Array mismatch at %d: got %d expected %d\n", i, arr[i], expected[i]); 
0493   0723             ; --- START FUNCTION CALL
0494   0723 3B 59 13      mov d, _expected_data ; $expected
0495   0726 D7            push a
0496   0727 DA            push d
0497   0728 FA FF FF      lea d, [bp + -1] ; $i
0498   072B 2A            mov b, [d]
0499   072C 38 00 00      mov c, 0
0500   072F E7            pop d
0501   0730 FD 13 02 00   mma 2 ; mov a, 2; mul a, b; add d, b
0502   0734 E4            pop a
0503   0735 2A            mov b, [d]
0504   0736 38 00 00      mov c, 0
0505   0739 FD AB         swp b
0506   073B D8            push b
0507   073C FA 05 00      lea d, [bp + 5] ; $arr
0508   073F FD 2A         mov d, [d]
0509   0741 D7            push a
0510   0742 DA            push d
0511   0743 FA FF FF      lea d, [bp + -1] ; $i
0512   0746 2A            mov b, [d]
0513   0747 38 00 00      mov c, 0
0514   074A E7            pop d
0515   074B FD 13 02 00   mma 2 ; mov a, 2; mul a b; add d, b
0516   074F E4            pop a
0517   0750 2A            mov b, [d]
0518   0751 38 00 00      mov c, 0
0519   0754 FD AB         swp b
0520   0756 D8            push b
0521   0757 FA FF FF      lea d, [bp + -1] ; $i
0522   075A 2A            mov b, [d]
0523   075B 38 00 00      mov c, 0
0524   075E FD AB         swp b
0525   0760 D8            push b
0526   0761 26 CE 13      mov b, _s3 ; "Array mismatch at %d: got %d expected %d\n"
0527   0764 FD AB         swp b
0528   0766 D8            push b
0529   0767 07 01 0A      call printf
0530   076A 51 08 00      add sp, 8
0531   076D             ; --- END FUNCTION CALL
0532   076D             ; return 0; 
0533   076D FD 2E 00 00   mov32 cb, $00000000
0533   0771 00 00 
0534   0773 F9            leave
0535   0774 09            ret
0536   0775 0A 78 07      jmp _if22_exit
0537   0778             _if22_exit:
0538   0778             _for21_update:
0539   0778 FA FF FF      lea d, [bp + -1] ; $i
0540   077B 2A            mov b, [d]
0541   077C 38 00 00      mov c, 0
0542   077F 11            mov a, b
0543   0780 FD 77         inc b
0544   0782 FA FF FF      lea d, [bp + -1] ; $i
0545   0785 FD 43         mov [d], b
0546   0787 27            mov b, a
0547   0788 0A CF 06      jmp _for21_cond
0548   078B             _for21_exit:
0549   078B             ; return 1; 
0550   078B FD 2E 01 00   mov32 cb, $00000001
0550   078F 00 00 
0551   0791 F9            leave
0552   0792 09            ret
0553   0793             
0554   0793             check_factorial:
0555   0793 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0556   0796             ; int f = factorial(6); 
0557   0796 52 02 00      sub sp, 2
0558   0799             ; --- START LOCAL VAR INITIALIZATION
0559   0799 FA FF FF      lea d, [bp + -1] ; $f
0560   079C DA            push d
0561   079D             ; --- START FUNCTION CALL
0562   079D FD 2E 06 00   mov32 cb, $00000006
0562   07A1 00 00 
0563   07A3 FD AB         swp b
0564   07A5 D8            push b
0565   07A6 07 0E 05      call factorial
0566   07A9 51 02 00      add sp, 2
0567   07AC             ; --- END FUNCTION CALL
0568   07AC E7            pop d
0569   07AD FD 43         mov [d], b
0570   07AF             ; --- END LOCAL VAR INITIALIZATION
0571   07AF             ; if (f != 720) { 
0572   07AF             _if23_cond:
0573   07AF FA FF FF      lea d, [bp + -1] ; $f
0574   07B2 2A            mov b, [d]
0575   07B3 38 00 00      mov c, 0
0576   07B6             ; --- START RELATIONAL
0577   07B6 D7            push a
0578   07B7 11            mov a, b
0579   07B8 FD 2E D0 02   mov32 cb, $000002d0
0579   07BC 00 00 
0580   07BE B0            cmp a, b
0581   07BF FD 72         sneq ; !=
0582   07C1 E4            pop a
0583   07C2             ; --- END RELATIONAL
0584   07C2 C0 00 00      cmp b, 0
0585   07C5 C6 E9 07      je _if23_exit
0586   07C8             _if23_TRUE:
0587   07C8             ; printf("Factorial failed: got %d expected 720\n", f); 
0588   07C8             ; --- START FUNCTION CALL
0589   07C8 FA FF FF      lea d, [bp + -1] ; $f
0590   07CB 2A            mov b, [d]
0591   07CC 38 00 00      mov c, 0
0592   07CF FD AB         swp b
0593   07D1 D8            push b
0594   07D2 26 F8 13      mov b, _s4 ; "Factorial failed: got %d expected 720\n"
0595   07D5 FD AB         swp b
0596   07D7 D8            push b
0597   07D8 07 01 0A      call printf
0598   07DB 51 04 00      add sp, 4
0599   07DE             ; --- END FUNCTION CALL
0600   07DE             ; return 0; 
0601   07DE FD 2E 00 00   mov32 cb, $00000000
0601   07E2 00 00 
0602   07E4 F9            leave
0603   07E5 09            ret
0604   07E6 0A E9 07      jmp _if23_exit
0605   07E9             _if23_exit:
0606   07E9             ; return 1; 
0607   07E9 FD 2E 01 00   mov32 cb, $00000001
0607   07ED 00 00 
0608   07EF F9            leave
0609   07F0 09            ret
0610   07F1             
0611   07F1             check_structs:
0612   07F1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0613   07F4             ; struct Point pts[3]; 
0614   07F4 52 0C 00      sub sp, 12
0615   07F7             ; int i; 
0616   07F7 52 02 00      sub sp, 2
0617   07FA             ; for (i = 0; i < 3; i++) { 
0618   07FA             _for24_init:
0619   07FA FA F3 FF      lea d, [bp + -13] ; $i
0620   07FD DA            push d
0621   07FE FD 2E 00 00   mov32 cb, $00000000
0621   0802 00 00 
0622   0804 E7            pop d
0623   0805 FD 43         mov [d], b
0624   0807             _for24_cond:
0625   0807 FA F3 FF      lea d, [bp + -13] ; $i
0626   080A 2A            mov b, [d]
0627   080B 38 00 00      mov c, 0
0628   080E             ; --- START RELATIONAL
0629   080E D7            push a
0630   080F 11            mov a, b
0631   0810 FD 2E 03 00   mov32 cb, $00000003
0631   0814 00 00 
0632   0816 B0            cmp a, b
0633   0817 FD 73         slt ; < (signed)
0634   0819 E4            pop a
0635   081A             ; --- END RELATIONAL
0636   081A C0 00 00      cmp b, 0
0637   081D C6 B9 08      je _for24_exit
0638   0820             _for24_block:
0639   0820             ; pts[i].x = i; 
0640   0820 FA F5 FF      lea d, [bp + -11] ; $pts
0641   0823 D7            push a
0642   0824 DA            push d
0643   0825 FA F3 FF      lea d, [bp + -13] ; $i
0644   0828 2A            mov b, [d]
0645   0829 38 00 00      mov c, 0
0646   082C E7            pop d
0647   082D FD 13 04 00   mma 4 ; mov a, 4; mul a, b; add d, b
0648   0831 E4            pop a
0649   0832 58 00 00      add d, 0
0650   0835 DA            push d
0651   0836 FA F3 FF      lea d, [bp + -13] ; $i
0652   0839 2A            mov b, [d]
0653   083A 38 00 00      mov c, 0
0654   083D E7            pop d
0655   083E FD 43         mov [d], b
0656   0840             ; pts[i].y = i * i; 
0657   0840 FA F5 FF      lea d, [bp + -11] ; $pts
0658   0843 D7            push a
0659   0844 DA            push d
0660   0845 FA F3 FF      lea d, [bp + -13] ; $i
0661   0848 2A            mov b, [d]
0662   0849 38 00 00      mov c, 0
0663   084C E7            pop d
0664   084D FD 13 04 00   mma 4 ; mov a, 4; mul a, b; add d, b
0665   0851 E4            pop a
0666   0852 58 02 00      add d, 2
0667   0855 DA            push d
0668   0856 FA F3 FF      lea d, [bp + -13] ; $i
0669   0859 2A            mov b, [d]
0670   085A 38 00 00      mov c, 0
0671   085D             ; --- START FACTORS
0672   085D D7            push a
0673   085E FD D8         push g
0674   0860 11            mov a, b
0675   0861 FD 7A         mov g, c
0676   0863 FA F3 FF      lea d, [bp + -13] ; $i
0677   0866 2A            mov b, [d]
0678   0867 38 00 00      mov c, 0
0679   086A D7            push a     ; save left operand
0680   086B 8E            xor a, b   ; xor sign bits
0681   086C FD AA         swp a      ; swap bytes
0682   086E 83            mov cl, al ; save result of xor into 'dl'
0683   086F E4            pop a      ; restore left side operator
0684   0870 DF            push cl    ; save result of xor above
0685   0871 FD AA         swp a  
0686   0873 93 80         test al, $80  
0687   0875 FD AA         swp a  
0688   0877 C6 7C 08      jz skip_invert_a_26  
0689   087A FD 95         neg a 
0690   087C             skip_invert_a_26:   
0691   087C FD AB         swp b
0692   087E FD 93 80      test bl, $80  
0693   0881 FD AB         swp b
0694   0883 C6 88 08      jz skip_invert_b_26  
0695   0886 FD 97         neg b 
0696   0888             skip_invert_b_26:   
0697   0888 AC            mul a, b ; *
0698   0889 FD 78         mov g, a
0699   088B 11            mov a, b
0700   088C EA            pop bl
0701   088D FD 93 80      test bl, $80
0702   0890 C6 9D 08      jz _same_signs_26
0703   0893 2F            mov bl, al
0704   0894 95            not a
0705   0895 FD 97         neg b
0706   0897 5B 00 00      adc a, 0
0707   089A FD 78         mov g, a
0708   089C 11            mov a, b
0709   089D             _same_signs_26:
0710   089D FD 38         mov c, g
0711   089F 27            mov b, a
0712   08A0 FD F1         pop g
0713   08A2 E4            pop a
0714   08A3             ; --- END FACTORS
0715   08A3 E7            pop d
0716   08A4 FD 43         mov [d], b
0717   08A6             _for24_update:
0718   08A6 FA F3 FF      lea d, [bp + -13] ; $i
0719   08A9 2A            mov b, [d]
0720   08AA 38 00 00      mov c, 0
0721   08AD 11            mov a, b
0722   08AE FD 77         inc b
0723   08B0 FA F3 FF      lea d, [bp + -13] ; $i
0724   08B3 FD 43         mov [d], b
0725   08B5 27            mov b, a
0726   08B6 0A 07 08      jmp _for24_cond
0727   08B9             _for24_exit:
0728   08B9             ; if (pts[2].x != 2 || pts[2].y != 4) { 
0729   08B9             _if27_cond:
0730   08B9 FA F5 FF      lea d, [bp + -11] ; $pts
0731   08BC D7            push a
0732   08BD DA            push d
0733   08BE FD 2E 02 00   mov32 cb, $00000002
0733   08C2 00 00 
0734   08C4 E7            pop d
0735   08C5 FD 13 04 00   mma 4 ; mov a, 4; mul a, b; add d, b
0736   08C9 E4            pop a
0737   08CA 58 00 00      add d, 0
0738   08CD 2A            mov b, [d]
0739   08CE 38 00 00      mov c, 0
0740   08D1             ; --- START RELATIONAL
0741   08D1 D7            push a
0742   08D2 11            mov a, b
0743   08D3 FD 2E 02 00   mov32 cb, $00000002
0743   08D7 00 00 
0744   08D9 B0            cmp a, b
0745   08DA FD 72         sneq ; !=
0746   08DC E4            pop a
0747   08DD             ; --- END RELATIONAL
0748   08DD             ; --- START LOGICAL OR
0749   08DD D7            push a
0750   08DE 11            mov a, b
0751   08DF FA F5 FF      lea d, [bp + -11] ; $pts
0752   08E2 D7            push a
0753   08E3 DA            push d
0754   08E4 FD 2E 02 00   mov32 cb, $00000002
0754   08E8 00 00 
0755   08EA E7            pop d
0756   08EB FD 13 04 00   mma 4 ; mov a, 4; mul a, b; add d, b
0757   08EF E4            pop a
0758   08F0 58 02 00      add d, 2
0759   08F3 2A            mov b, [d]
0760   08F4 38 00 00      mov c, 0
0761   08F7             ; --- START RELATIONAL
0762   08F7 D7            push a
0763   08F8 11            mov a, b
0764   08F9 FD 2E 04 00   mov32 cb, $00000004
0764   08FD 00 00 
0765   08FF B0            cmp a, b
0766   0900 FD 72         sneq ; !=
0767   0902 E4            pop a
0768   0903             ; --- END RELATIONAL
0769   0903 FD A8         sor a, b ; ||
0770   0905 E4            pop a
0771   0906             ; --- END LOGICAL OR
0772   0906 C0 00 00      cmp b, 0
0773   0909 C6 59 09      je _if27_exit
0774   090C             _if27_TRUE:
0775   090C             ; printf("Struct check failed: (%d,%d)\n", pts[2].x, pts[2].y); 
0776   090C             ; --- START FUNCTION CALL
0777   090C FA F5 FF      lea d, [bp + -11] ; $pts
0778   090F D7            push a
0779   0910 DA            push d
0780   0911 FD 2E 02 00   mov32 cb, $00000002
0780   0915 00 00 
0781   0917 E7            pop d
0782   0918 FD 13 04 00   mma 4 ; mov a, 4; mul a, b; add d, b
0783   091C E4            pop a
0784   091D 58 02 00      add d, 2
0785   0920 2A            mov b, [d]
0786   0921 38 00 00      mov c, 0
0787   0924 FD AB         swp b
0788   0926 D8            push b
0789   0927 FA F5 FF      lea d, [bp + -11] ; $pts
0790   092A D7            push a
0791   092B DA            push d
0792   092C FD 2E 02 00   mov32 cb, $00000002
0792   0930 00 00 
0793   0932 E7            pop d
0794   0933 FD 13 04 00   mma 4 ; mov a, 4; mul a, b; add d, b
0795   0937 E4            pop a
0796   0938 58 00 00      add d, 0
0797   093B 2A            mov b, [d]
0798   093C 38 00 00      mov c, 0
0799   093F FD AB         swp b
0800   0941 D8            push b
0801   0942 26 1F 14      mov b, _s5 ; "Struct check failed: (%d,%d)\n"
0802   0945 FD AB         swp b
0803   0947 D8            push b
0804   0948 07 01 0A      call printf
0805   094B 51 06 00      add sp, 6
0806   094E             ; --- END FUNCTION CALL
0807   094E             ; return 0; 
0808   094E FD 2E 00 00   mov32 cb, $00000000
0808   0952 00 00 
0809   0954 F9            leave
0810   0955 09            ret
0811   0956 0A 59 09      jmp _if27_exit
0812   0959             _if27_exit:
0813   0959             ; return 1; 
0814   0959 FD 2E 01 00   mov32 cb, $00000001
0814   095D 00 00 
0815   095F F9            leave
0816   0960 09            ret
0817   0961             
0818   0961             check_pointers:
0819   0961 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0820   0964             ; int *p = arr; 
0821   0964 52 02 00      sub sp, 2
0822   0967             ; --- START LOCAL VAR INITIALIZATION
0823   0967 FA FF FF      lea d, [bp + -1] ; $p
0824   096A DA            push d
0825   096B FA 05 00      lea d, [bp + 5] ; $arr
0826   096E 2A            mov b, [d]
0827   096F 38 00 00      mov c, 0
0828   0972 E7            pop d
0829   0973 FD 43         mov [d], b
0830   0975             ; --- END LOCAL VAR INITIALIZATION
0831   0975             ; if (*p != 7 || *(p + 5) != 47) { 
0832   0975             _if28_cond:
0833   0975 FA FF FF      lea d, [bp + -1] ; $p
0834   0978 2A            mov b, [d]
0835   0979 38 00 00      mov c, 0
0836   097C 74            mov d, b
0837   097D 2A            mov b, [d]
0838   097E 38 00 00      mov c, 0
0839   0981             ; --- START RELATIONAL
0840   0981 D7            push a
0841   0982 11            mov a, b
0842   0983 FD 2E 07 00   mov32 cb, $00000007
0842   0987 00 00 
0843   0989 B0            cmp a, b
0844   098A FD 72         sneq ; !=
0845   098C E4            pop a
0846   098D             ; --- END RELATIONAL
0847   098D             ; --- START LOGICAL OR
0848   098D D7            push a
0849   098E 11            mov a, b
0850   098F FA FF FF      lea d, [bp + -1] ; $p
0851   0992 2A            mov b, [d]
0852   0993 38 00 00      mov c, 0
0853   0996             ; --- START TERMS
0854   0996 D7            push a
0855   0997 11            mov a, b
0856   0998 FD 2E 05 00   mov32 cb, $00000005
0856   099C 00 00 
0857   099E 56            add b, a
0858   099F E4            pop a
0859   09A0             ; --- END TERMS
0860   09A0 74            mov d, b
0861   09A1 2A            mov b, [d]
0862   09A2 38 00 00      mov c, 0
0863   09A5             ; --- START RELATIONAL
0864   09A5 D7            push a
0865   09A6 11            mov a, b
0866   09A7 FD 2E 2F 00   mov32 cb, $0000002f
0866   09AB 00 00 
0867   09AD B0            cmp a, b
0868   09AE FD 72         sneq ; !=
0869   09B0 E4            pop a
0870   09B1             ; --- END RELATIONAL
0871   09B1 FD A8         sor a, b ; ||
0872   09B3 E4            pop a
0873   09B4             ; --- END LOGICAL OR
0874   09B4 C0 00 00      cmp b, 0
0875   09B7 C6 F9 09      je _if28_exit
0876   09BA             _if28_TRUE:
0877   09BA             ; printf("Pointer check failed: *p=%d *(p+5)=%d\n", *p, *(p + 5)); 
0878   09BA             ; --- START FUNCTION CALL
0879   09BA FA FF FF      lea d, [bp + -1] ; $p
0880   09BD 2A            mov b, [d]
0881   09BE 38 00 00      mov c, 0
0882   09C1             ; --- START TERMS
0883   09C1 D7            push a
0884   09C2 11            mov a, b
0885   09C3 FD 2E 05 00   mov32 cb, $00000005
0885   09C7 00 00 
0886   09C9 56            add b, a
0887   09CA E4            pop a
0888   09CB             ; --- END TERMS
0889   09CB 74            mov d, b
0890   09CC 2A            mov b, [d]
0891   09CD 38 00 00      mov c, 0
0892   09D0 FD AB         swp b
0893   09D2 D8            push b
0894   09D3 FA FF FF      lea d, [bp + -1] ; $p
0895   09D6 2A            mov b, [d]
0896   09D7 38 00 00      mov c, 0
0897   09DA 74            mov d, b
0898   09DB 2A            mov b, [d]
0899   09DC 38 00 00      mov c, 0
0900   09DF FD AB         swp b
0901   09E1 D8            push b
0902   09E2 26 3D 14      mov b, _s6 ; "Pointer check failed: *p=%d *(p+5)=%d\n"
0903   09E5 FD AB         swp b
0904   09E7 D8            push b
0905   09E8 07 01 0A      call printf
0906   09EB 51 06 00      add sp, 6
0907   09EE             ; --- END FUNCTION CALL
0908   09EE             ; return 0; 
0909   09EE FD 2E 00 00   mov32 cb, $00000000
0909   09F2 00 00 
0910   09F4 F9            leave
0911   09F5 09            ret
0912   09F6 0A F9 09      jmp _if28_exit
0913   09F9             _if28_exit:
0914   09F9             ; return 1; 
0915   09F9 FD 2E 01 00   mov32 cb, $00000001
0915   09FD 00 00 
0916   09FF F9            leave
0917   0A00 09            ret
0918   0A01             
0919   0A01             printf:
0920   0A01 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0921   0A04             ; char *p, *format_p; 
0922   0A04 52 01 00      sub sp, 1
0923   0A07 52 02 00      sub sp, 2
0924   0A0A             ; format_p = format; 
0925   0A0A FA FE FF      lea d, [bp + -2] ; $format_p
0926   0A0D DA            push d
0927   0A0E FA 05 00      lea d, [bp + 5] ; $format
0928   0A11 2A            mov b, [d]
0929   0A12 38 00 00      mov c, 0
0930   0A15 E7            pop d
0931   0A16 FD 43         mov [d], b
0932   0A18             ; p = &format + 2; 
0933   0A18 FA 00 00      lea d, [bp + 0] ; $p
0934   0A1B DA            push d
0935   0A1C FA 05 00      lea d, [bp + 5] ; $format
0936   0A1F 2D            mov b, d
0937   0A20             ; --- START TERMS
0938   0A20 D7            push a
0939   0A21 11            mov a, b
0940   0A22 FD 2E 02 00   mov32 cb, $00000002
0940   0A26 00 00 
0941   0A28 56            add b, a
0942   0A29 E4            pop a
0943   0A2A             ; --- END TERMS
0944   0A2A E7            pop d
0945   0A2B FD 3E         mov [d], bl
0946   0A2D             ; for(;;){ 
0947   0A2D             _for29_init:
0948   0A2D             _for29_cond:
0949   0A2D             _for29_block:
0950   0A2D             ; if(!*format_p) break; 
0951   0A2D             _if30_cond:
0952   0A2D FA FE FF      lea d, [bp + -2] ; $format_p
0953   0A30 2A            mov b, [d]
0954   0A31 38 00 00      mov c, 0
0955   0A34 74            mov d, b
0956   0A35 32            mov bl, [d]
0957   0A36 A7 00         mov bh, 0
0958   0A38 38 00 00      mov c, 0
0959   0A3B C0 00 00      cmp b, 0
0960   0A3E FD 71         seq ; !
0961   0A40 C0 00 00      cmp b, 0
0962   0A43 C6 4C 0A      je _if30_else
0963   0A46             _if30_TRUE:
0964   0A46             ; break; 
0965   0A46 0A 0D 0D      jmp _for29_exit ; for break
0966   0A49 0A FA 0C      jmp _if30_exit
0967   0A4C             _if30_else:
0968   0A4C             ; if(*format_p == '%'){ 
0969   0A4C             _if31_cond:
0970   0A4C FA FE FF      lea d, [bp + -2] ; $format_p
0971   0A4F 2A            mov b, [d]
0972   0A50 38 00 00      mov c, 0
0973   0A53 74            mov d, b
0974   0A54 32            mov bl, [d]
0975   0A55 A7 00         mov bh, 0
0976   0A57 38 00 00      mov c, 0
0977   0A5A             ; --- START RELATIONAL
0978   0A5A D7            push a
0979   0A5B 11            mov a, b
0980   0A5C FD 2E 25 00   mov32 cb, $00000025
0980   0A60 00 00 
0981   0A62 B0            cmp a, b
0982   0A63 FD 71         seq ; ==
0983   0A65 E4            pop a
0984   0A66             ; --- END RELATIONAL
0985   0A66 C0 00 00      cmp b, 0
0986   0A69 C6 E5 0C      je _if31_else
0987   0A6C             _if31_TRUE:
0988   0A6C             ; format_p++; 
0989   0A6C FA FE FF      lea d, [bp + -2] ; $format_p
0990   0A6F 2A            mov b, [d]
0991   0A70 38 00 00      mov c, 0
0992   0A73 FD 77         inc b
0993   0A75 FA FE FF      lea d, [bp + -2] ; $format_p
0994   0A78 FD 43         mov [d], b
0995   0A7A FD 7D         dec b
0996   0A7C             ; switch(*format_p){ 
0997   0A7C             _switch32_expr:
0998   0A7C FA FE FF      lea d, [bp + -2] ; $format_p
0999   0A7F 2A            mov b, [d]
1000   0A80 38 00 00      mov c, 0
1001   0A83 74            mov d, b
1002   0A84 32            mov bl, [d]
1003   0A85 A7 00         mov bh, 0
1004   0A87 38 00 00      mov c, 0
1005   0A8A             _switch32_comparisons:
1006   0A8A C1 6C         cmp bl, $6c
1007   0A8C C6 BD 0A      je _switch32_case0
1008   0A8F C1 4C         cmp bl, $4c
1009   0A91 C6 BD 0A      je _switch32_case1
1010   0A94 C1 64         cmp bl, $64
1011   0A96 C6 D5 0B      je _switch32_case2
1012   0A99 C1 69         cmp bl, $69
1013   0A9B C6 D5 0B      je _switch32_case3
1014   0A9E C1 75         cmp bl, $75
1015   0AA0 C6 09 0C      je _switch32_case4
1016   0AA3 C1 78         cmp bl, $78
1017   0AA5 C6 3D 0C      je _switch32_case5
1018   0AA8 C1 70         cmp bl, $70
1019   0AAA C6 3D 0C      je _switch32_case6
1020   0AAD C1 63         cmp bl, $63
1021   0AAF C6 71 0C      je _switch32_case7
1022   0AB2 C1 73         cmp bl, $73
1023   0AB4 C6 A5 0C      je _switch32_case8
1024   0AB7 0A D6 0C      jmp _switch32_default
1025   0ABA 0A E2 0C      jmp _switch32_exit
1026   0ABD             _switch32_case0:
1027   0ABD             _switch32_case1:
1028   0ABD             ; format_p++; 
1029   0ABD FA FE FF      lea d, [bp + -2] ; $format_p
1030   0AC0 2A            mov b, [d]
1031   0AC1 38 00 00      mov c, 0
1032   0AC4 FD 77         inc b
1033   0AC6 FA FE FF      lea d, [bp + -2] ; $format_p
1034   0AC9 FD 43         mov [d], b
1035   0ACB FD 7D         dec b
1036   0ACD             ; if(*format_p == 'd' || *format_p == 'i') 
1037   0ACD             _if33_cond:
1038   0ACD FA FE FF      lea d, [bp + -2] ; $format_p
1039   0AD0 2A            mov b, [d]
1040   0AD1 38 00 00      mov c, 0
1041   0AD4 74            mov d, b
1042   0AD5 32            mov bl, [d]
1043   0AD6 A7 00         mov bh, 0
1044   0AD8 38 00 00      mov c, 0
1045   0ADB             ; --- START RELATIONAL
1046   0ADB D7            push a
1047   0ADC 11            mov a, b
1048   0ADD FD 2E 64 00   mov32 cb, $00000064
1048   0AE1 00 00 
1049   0AE3 B0            cmp a, b
1050   0AE4 FD 71         seq ; ==
1051   0AE6 E4            pop a
1052   0AE7             ; --- END RELATIONAL
1053   0AE7             ; --- START LOGICAL OR
1054   0AE7 D7            push a
1055   0AE8 11            mov a, b
1056   0AE9 FA FE FF      lea d, [bp + -2] ; $format_p
1057   0AEC 2A            mov b, [d]
1058   0AED 38 00 00      mov c, 0
1059   0AF0 74            mov d, b
1060   0AF1 32            mov bl, [d]
1061   0AF2 A7 00         mov bh, 0
1062   0AF4 38 00 00      mov c, 0
1063   0AF7             ; --- START RELATIONAL
1064   0AF7 D7            push a
1065   0AF8 11            mov a, b
1066   0AF9 FD 2E 69 00   mov32 cb, $00000069
1066   0AFD 00 00 
1067   0AFF B0            cmp a, b
1068   0B00 FD 71         seq ; ==
1069   0B02 E4            pop a
1070   0B03             ; --- END RELATIONAL
1071   0B03 FD A8         sor a, b ; ||
1072   0B05 E4            pop a
1073   0B06             ; --- END LOGICAL OR
1074   0B06 C0 00 00      cmp b, 0
1075   0B09 C6 2C 0B      je _if33_else
1076   0B0C             _if33_TRUE:
1077   0B0C             ; print_signed_long(*(long int*)p); 
1078   0B0C             ; --- START FUNCTION CALL
1079   0B0C FA 00 00      lea d, [bp + 0] ; $p
1080   0B0F 32            mov bl, [d]
1081   0B10 A7 00         mov bh, 0
1082   0B12 38 00 00      mov c, 0
1083   0B15 74            mov d, b
1084   0B16 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1085   0B19 FD 39         mov c, b ; And place it into C
1086   0B1B 2A            mov b, [d] ; Lower Word in B
1087   0B1C 12            mov a, c
1088   0B1D FD AA         swp a
1089   0B1F D7            push a
1090   0B20 FD AB         swp b
1091   0B22 D8            push b
1092   0B23 07 0F 0D      call print_signed_long
1093   0B26 51 04 00      add sp, 4
1094   0B29             ; --- END FUNCTION CALL
1095   0B29 0A B8 0B      jmp _if33_exit
1096   0B2C             _if33_else:
1097   0B2C             ; if(*format_p == 'u') 
1098   0B2C             _if34_cond:
1099   0B2C FA FE FF      lea d, [bp + -2] ; $format_p
1100   0B2F 2A            mov b, [d]
1101   0B30 38 00 00      mov c, 0
1102   0B33 74            mov d, b
1103   0B34 32            mov bl, [d]
1104   0B35 A7 00         mov bh, 0
1105   0B37 38 00 00      mov c, 0
1106   0B3A             ; --- START RELATIONAL
1107   0B3A D7            push a
1108   0B3B 11            mov a, b
1109   0B3C FD 2E 75 00   mov32 cb, $00000075
1109   0B40 00 00 
1110   0B42 B0            cmp a, b
1111   0B43 FD 71         seq ; ==
1112   0B45 E4            pop a
1113   0B46             ; --- END RELATIONAL
1114   0B46 C0 00 00      cmp b, 0
1115   0B49 C6 6C 0B      je _if34_else
1116   0B4C             _if34_TRUE:
1117   0B4C             ; print_unsigned_long(*(unsigned long int*)p); 
1118   0B4C             ; --- START FUNCTION CALL
1119   0B4C FA 00 00      lea d, [bp + 0] ; $p
1120   0B4F 32            mov bl, [d]
1121   0B50 A7 00         mov bh, 0
1122   0B52 38 00 00      mov c, 0
1123   0B55 74            mov d, b
1124   0B56 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1125   0B59 FD 39         mov c, b ; And place it into C
1126   0B5B 2A            mov b, [d] ; Lower Word in B
1127   0B5C 12            mov a, c
1128   0B5D FD AA         swp a
1129   0B5F D7            push a
1130   0B60 FD AB         swp b
1131   0B62 D8            push b
1132   0B63 07 E6 0E      call print_unsigned_long
1133   0B66 51 04 00      add sp, 4
1134   0B69             ; --- END FUNCTION CALL
1135   0B69 0A B8 0B      jmp _if34_exit
1136   0B6C             _if34_else:
1137   0B6C             ; if(*format_p == 'x') 
1138   0B6C             _if35_cond:
1139   0B6C FA FE FF      lea d, [bp + -2] ; $format_p
1140   0B6F 2A            mov b, [d]
1141   0B70 38 00 00      mov c, 0
1142   0B73 74            mov d, b
1143   0B74 32            mov bl, [d]
1144   0B75 A7 00         mov bh, 0
1145   0B77 38 00 00      mov c, 0
1146   0B7A             ; --- START RELATIONAL
1147   0B7A D7            push a
1148   0B7B 11            mov a, b
1149   0B7C FD 2E 78 00   mov32 cb, $00000078
1149   0B80 00 00 
1150   0B82 B0            cmp a, b
1151   0B83 FD 71         seq ; ==
1152   0B85 E4            pop a
1153   0B86             ; --- END RELATIONAL
1154   0B86 C0 00 00      cmp b, 0
1155   0B89 C6 AC 0B      je _if35_else
1156   0B8C             _if35_TRUE:
1157   0B8C             ; printx32(*(long int *)p); 
1158   0B8C             ; --- START FUNCTION CALL
1159   0B8C FA 00 00      lea d, [bp + 0] ; $p
1160   0B8F 32            mov bl, [d]
1161   0B90 A7 00         mov bh, 0
1162   0B92 38 00 00      mov c, 0
1163   0B95 74            mov d, b
1164   0B96 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1165   0B99 FD 39         mov c, b ; And place it into C
1166   0B9B 2A            mov b, [d] ; Lower Word in B
1167   0B9C 12            mov a, c
1168   0B9D FD AA         swp a
1169   0B9F D7            push a
1170   0BA0 FD AB         swp b
1171   0BA2 D8            push b
1172   0BA3 07 11 10      call printx32
1173   0BA6 51 04 00      add sp, 4
1174   0BA9             ; --- END FUNCTION CALL
1175   0BA9 0A B8 0B      jmp _if35_exit
1176   0BAC             _if35_else:
1177   0BAC             ; err("Unexpected format in printf."); 
1178   0BAC             ; --- START FUNCTION CALL
1179   0BAC 26 64 14      mov b, _s7 ; "Unexpected format in printf."
1180   0BAF FD AB         swp b
1181   0BB1 D8            push b
1182   0BB2 07 71 10      call err
1183   0BB5 51 02 00      add sp, 2
1184   0BB8             ; --- END FUNCTION CALL
1185   0BB8             _if35_exit:
1186   0BB8             _if34_exit:
1187   0BB8             _if33_exit:
1188   0BB8             ; p = p + 4; 
1189   0BB8 FA 00 00      lea d, [bp + 0] ; $p
1190   0BBB DA            push d
1191   0BBC FA 00 00      lea d, [bp + 0] ; $p
1192   0BBF 32            mov bl, [d]
1193   0BC0 A7 00         mov bh, 0
1194   0BC2 38 00 00      mov c, 0
1195   0BC5             ; --- START TERMS
1196   0BC5 D7            push a
1197   0BC6 11            mov a, b
1198   0BC7 FD 2E 04 00   mov32 cb, $00000004
1198   0BCB 00 00 
1199   0BCD 56            add b, a
1200   0BCE E4            pop a
1201   0BCF             ; --- END TERMS
1202   0BCF E7            pop d
1203   0BD0 FD 3E         mov [d], bl
1204   0BD2             ; break; 
1205   0BD2 0A E2 0C      jmp _switch32_exit ; case break
1206   0BD5             _switch32_case2:
1207   0BD5             _switch32_case3:
1208   0BD5             ; print_signed(*(int*)p); 
1209   0BD5             ; --- START FUNCTION CALL
1210   0BD5 FA 00 00      lea d, [bp + 0] ; $p
1211   0BD8 32            mov bl, [d]
1212   0BD9 A7 00         mov bh, 0
1213   0BDB 38 00 00      mov c, 0
1214   0BDE 74            mov d, b
1215   0BDF 2A            mov b, [d]
1216   0BE0 38 00 00      mov c, 0
1217   0BE3 FD AB         swp b
1218   0BE5 D8            push b
1219   0BE6 07 9F 10      call print_signed
1220   0BE9 51 02 00      add sp, 2
1221   0BEC             ; --- END FUNCTION CALL
1222   0BEC             ; p = p + 2; 
1223   0BEC FA 00 00      lea d, [bp + 0] ; $p
1224   0BEF DA            push d
1225   0BF0 FA 00 00      lea d, [bp + 0] ; $p
1226   0BF3 32            mov bl, [d]
1227   0BF4 A7 00         mov bh, 0
1228   0BF6 38 00 00      mov c, 0
1229   0BF9             ; --- START TERMS
1230   0BF9 D7            push a
1231   0BFA 11            mov a, b
1232   0BFB FD 2E 02 00   mov32 cb, $00000002
1232   0BFF 00 00 
1233   0C01 56            add b, a
1234   0C02 E4            pop a
1235   0C03             ; --- END TERMS
1236   0C03 E7            pop d
1237   0C04 FD 3E         mov [d], bl
1238   0C06             ; break; 
1239   0C06 0A E2 0C      jmp _switch32_exit ; case break
1240   0C09             _switch32_case4:
1241   0C09             ; print_unsigned(*(unsigned int*)p); 
1242   0C09             ; --- START FUNCTION CALL
1243   0C09 FA 00 00      lea d, [bp + 0] ; $p
1244   0C0C 32            mov bl, [d]
1245   0C0D A7 00         mov bh, 0
1246   0C0F 38 00 00      mov c, 0
1247   0C12 74            mov d, b
1248   0C13 2A            mov b, [d]
1249   0C14 38 00 00      mov c, 0
1250   0C17 FD AB         swp b
1251   0C19 D8            push b
1252   0C1A 07 02 12      call print_unsigned
1253   0C1D 51 02 00      add sp, 2
1254   0C20             ; --- END FUNCTION CALL
1255   0C20             ; p = p + 2; 
1256   0C20 FA 00 00      lea d, [bp + 0] ; $p
1257   0C23 DA            push d
1258   0C24 FA 00 00      lea d, [bp + 0] ; $p
1259   0C27 32            mov bl, [d]
1260   0C28 A7 00         mov bh, 0
1261   0C2A 38 00 00      mov c, 0
1262   0C2D             ; --- START TERMS
1263   0C2D D7            push a
1264   0C2E 11            mov a, b
1265   0C2F FD 2E 02 00   mov32 cb, $00000002
1265   0C33 00 00 
1266   0C35 56            add b, a
1267   0C36 E4            pop a
1268   0C37             ; --- END TERMS
1269   0C37 E7            pop d
1270   0C38 FD 3E         mov [d], bl
1271   0C3A             ; break; 
1272   0C3A 0A E2 0C      jmp _switch32_exit ; case break
1273   0C3D             _switch32_case5:
1274   0C3D             _switch32_case6:
1275   0C3D             ; printx16(*(int*)p); 
1276   0C3D             ; --- START FUNCTION CALL
1277   0C3D FA 00 00      lea d, [bp + 0] ; $p
1278   0C40 32            mov bl, [d]
1279   0C41 A7 00         mov bh, 0
1280   0C43 38 00 00      mov c, 0
1281   0C46 74            mov d, b
1282   0C47 2A            mov b, [d]
1283   0C48 38 00 00      mov c, 0
1284   0C4B FD AB         swp b
1285   0C4D D8            push b
1286   0C4E 07 07 13      call printx16
1287   0C51 51 02 00      add sp, 2
1288   0C54             ; --- END FUNCTION CALL
1289   0C54             ; p = p + 2; 
1290   0C54 FA 00 00      lea d, [bp + 0] ; $p
1291   0C57 DA            push d
1292   0C58 FA 00 00      lea d, [bp + 0] ; $p
1293   0C5B 32            mov bl, [d]
1294   0C5C A7 00         mov bh, 0
1295   0C5E 38 00 00      mov c, 0
1296   0C61             ; --- START TERMS
1297   0C61 D7            push a
1298   0C62 11            mov a, b
1299   0C63 FD 2E 02 00   mov32 cb, $00000002
1299   0C67 00 00 
1300   0C69 56            add b, a
1301   0C6A E4            pop a
1302   0C6B             ; --- END TERMS
1303   0C6B E7            pop d
1304   0C6C FD 3E         mov [d], bl
1305   0C6E             ; break; 
1306   0C6E 0A E2 0C      jmp _switch32_exit ; case break
1307   0C71             _switch32_case7:
1308   0C71             ; putchar(*(char*)p); 
1309   0C71             ; --- START FUNCTION CALL
1310   0C71 FA 00 00      lea d, [bp + 0] ; $p
1311   0C74 32            mov bl, [d]
1312   0C75 A7 00         mov bh, 0
1313   0C77 38 00 00      mov c, 0
1314   0C7A 74            mov d, b
1315   0C7B 32            mov bl, [d]
1316   0C7C A7 00         mov bh, 0
1317   0C7E 38 00 00      mov c, 0
1318   0C81 DD            push bl
1319   0C82 07 D8 0E      call putchar
1320   0C85 51 01 00      add sp, 1
1321   0C88             ; --- END FUNCTION CALL
1322   0C88             ; p = p + 2; 
1323   0C88 FA 00 00      lea d, [bp + 0] ; $p
1324   0C8B DA            push d
1325   0C8C FA 00 00      lea d, [bp + 0] ; $p
1326   0C8F 32            mov bl, [d]
1327   0C90 A7 00         mov bh, 0
1328   0C92 38 00 00      mov c, 0
1329   0C95             ; --- START TERMS
1330   0C95 D7            push a
1331   0C96 11            mov a, b
1332   0C97 FD 2E 02 00   mov32 cb, $00000002
1332   0C9B 00 00 
1333   0C9D 56            add b, a
1334   0C9E E4            pop a
1335   0C9F             ; --- END TERMS
1336   0C9F E7            pop d
1337   0CA0 FD 3E         mov [d], bl
1338   0CA2             ; break; 
1339   0CA2 0A E2 0C      jmp _switch32_exit ; case break
1340   0CA5             _switch32_case8:
1341   0CA5             ; print(*(char**)p); 
1342   0CA5             ; --- START FUNCTION CALL
1343   0CA5 FA 00 00      lea d, [bp + 0] ; $p
1344   0CA8 32            mov bl, [d]
1345   0CA9 A7 00         mov bh, 0
1346   0CAB 38 00 00      mov c, 0
1347   0CAE 74            mov d, b
1348   0CAF 2A            mov b, [d]
1349   0CB0 FD AB         swp b
1350   0CB2 D8            push b
1351   0CB3 07 86 10      call print
1352   0CB6 51 02 00      add sp, 2
1353   0CB9             ; --- END FUNCTION CALL
1354   0CB9             ; p = p + 2; 
1355   0CB9 FA 00 00      lea d, [bp + 0] ; $p
1356   0CBC DA            push d
1357   0CBD FA 00 00      lea d, [bp + 0] ; $p
1358   0CC0 32            mov bl, [d]
1359   0CC1 A7 00         mov bh, 0
1360   0CC3 38 00 00      mov c, 0
1361   0CC6             ; --- START TERMS
1362   0CC6 D7            push a
1363   0CC7 11            mov a, b
1364   0CC8 FD 2E 02 00   mov32 cb, $00000002
1364   0CCC 00 00 
1365   0CCE 56            add b, a
1366   0CCF E4            pop a
1367   0CD0             ; --- END TERMS
1368   0CD0 E7            pop d
1369   0CD1 FD 3E         mov [d], bl
1370   0CD3             ; break; 
1371   0CD3 0A E2 0C      jmp _switch32_exit ; case break
1372   0CD6             _switch32_default:
1373   0CD6             ; print("Error: Unknown argument type.\n"); 
1374   0CD6             ; --- START FUNCTION CALL
1375   0CD6 26 81 14      mov b, _s8 ; "Error: Unknown argument type.\n"
1376   0CD9 FD AB         swp b
1377   0CDB D8            push b
1378   0CDC 07 86 10      call print
1379   0CDF 51 02 00      add sp, 2
1380   0CE2             ; --- END FUNCTION CALL
1381   0CE2             _switch32_exit:
1382   0CE2 0A FA 0C      jmp _if31_exit
1383   0CE5             _if31_else:
1384   0CE5             ; putchar(*format_p); 
1385   0CE5             ; --- START FUNCTION CALL
1386   0CE5 FA FE FF      lea d, [bp + -2] ; $format_p
1387   0CE8 2A            mov b, [d]
1388   0CE9 38 00 00      mov c, 0
1389   0CEC 74            mov d, b
1390   0CED 32            mov bl, [d]
1391   0CEE A7 00         mov bh, 0
1392   0CF0 38 00 00      mov c, 0
1393   0CF3 DD            push bl
1394   0CF4 07 D8 0E      call putchar
1395   0CF7 51 01 00      add sp, 1
1396   0CFA             ; --- END FUNCTION CALL
1397   0CFA             _if31_exit:
1398   0CFA             _if30_exit:
1399   0CFA             ; format_p++; 
1400   0CFA FA FE FF      lea d, [bp + -2] ; $format_p
1401   0CFD 2A            mov b, [d]
1402   0CFE 38 00 00      mov c, 0
1403   0D01 FD 77         inc b
1404   0D03 FA FE FF      lea d, [bp + -2] ; $format_p
1405   0D06 FD 43         mov [d], b
1406   0D08 FD 7D         dec b
1407   0D0A             _for29_update:
1408   0D0A 0A 2D 0A      jmp _for29_cond
1409   0D0D             _for29_exit:
1410   0D0D F9            leave
1411   0D0E 09            ret
1412   0D0F             
1413   0D0F             print_signed_long:
1414   0D0F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1415   0D12             ; char digits[10];  // fits 2,147,483,647 
1416   0D12 52 0A 00      sub sp, 10
1417   0D15             ; int i = 0; 
1418   0D15 52 02 00      sub sp, 2
1419   0D18             ; --- START LOCAL VAR INITIALIZATION
1420   0D18 FA F5 FF      lea d, [bp + -11] ; $i
1421   0D1B DA            push d
1422   0D1C FD 2E 00 00   mov32 cb, $00000000
1422   0D20 00 00 
1423   0D22 E7            pop d
1424   0D23 FD 43         mov [d], b
1425   0D25             ; --- END LOCAL VAR INITIALIZATION
1426   0D25             ; unsigned long int absval; 
1427   0D25 52 04 00      sub sp, 4
1428   0D28             ; if (num < 0) { 
1429   0D28             _if36_cond:
1430   0D28 FA 05 00      lea d, [bp + 5] ; $num
1431   0D2B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1432   0D2E FD 39         mov c, b ; And place it into C
1433   0D30 2A            mov b, [d] ; Lower Word in B
1434   0D31             ; --- START RELATIONAL
1435   0D31 D7            push a
1436   0D32 FD D8         push g
1437   0D34 11            mov a, b
1438   0D35 FD 7A         mov g, c
1439   0D37 FD 2E 00 00   mov32 cb, $00000000
1439   0D3B 00 00 
1440   0D3D 38 00 00      mov c, 0
1441   0D40 FD AF         cmp32 ga, cb
1442   0D42 FD 73         slt ; <
1443   0D44 FD F1         pop g
1444   0D46 E4            pop a
1445   0D47             ; --- END RELATIONAL
1446   0D47 C0 00 00      cmp b, 0
1447   0D4A C6 A9 0D      je _if36_else
1448   0D4D             _if36_TRUE:
1449   0D4D             ; putchar('-'); 
1450   0D4D             ; --- START FUNCTION CALL
1451   0D4D FD 2E 2D 00   mov32 cb, $0000002d
1451   0D51 00 00 
1452   0D53 DD            push bl
1453   0D54 07 D8 0E      call putchar
1454   0D57 51 01 00      add sp, 1
1455   0D5A             ; --- END FUNCTION CALL
1456   0D5A             ; absval = (unsigned long int)(-(num + 1)) + 1; 
1457   0D5A FA F1 FF      lea d, [bp + -15] ; $absval
1458   0D5D DA            push d
1459   0D5E FA 05 00      lea d, [bp + 5] ; $num
1460   0D61 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1461   0D64 FD 39         mov c, b ; And place it into C
1462   0D66 2A            mov b, [d] ; Lower Word in B
1463   0D67             ; --- START TERMS
1464   0D67 D7            push a
1465   0D68 FD D8         push g
1466   0D6A 11            mov a, b
1467   0D6B FD 7A         mov g, c
1468   0D6D FD 2E 01 00   mov32 cb, $00000001
1468   0D71 00 00 
1469   0D73 38 00 00      mov c, 0
1470   0D76 FD 15         add32 cb, ga
1471   0D78 FD F1         pop g
1472   0D7A E4            pop a
1473   0D7B             ; --- END TERMS
1474   0D7B 12            mov a, c
1475   0D7C 95            not a
1476   0D7D 97            not b
1477   0D7E 55 01 00      add b, 1
1478   0D81 5B 00 00      adc a, 0
1479   0D84 39            mov c, a
1480   0D85 A7 00         mov bh, 0
1481   0D87 38 00 00      mov c, 0
1482   0D8A             ; --- START TERMS
1483   0D8A D7            push a
1484   0D8B FD D8         push g
1485   0D8D 11            mov a, b
1486   0D8E FD 7A         mov g, c
1487   0D90 FD 2E 01 00   mov32 cb, $00000001
1487   0D94 00 00 
1488   0D96 38 00 00      mov c, 0
1489   0D99 FD 15         add32 cb, ga
1490   0D9B FD F1         pop g
1491   0D9D E4            pop a
1492   0D9E             ; --- END TERMS
1493   0D9E E7            pop d
1494   0D9F FD 43         mov [d], b
1495   0DA1 28            mov b, c
1496   0DA2 FD 44 02 00   mov [d + 2], b
1497   0DA6 0A C3 0D      jmp _if36_exit
1498   0DA9             _if36_else:
1499   0DA9             ; absval = (unsigned long int)num; 
1500   0DA9 FA F1 FF      lea d, [bp + -15] ; $absval
1501   0DAC DA            push d
1502   0DAD FA 05 00      lea d, [bp + 5] ; $num
1503   0DB0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1504   0DB3 FD 39         mov c, b ; And place it into C
1505   0DB5 2A            mov b, [d] ; Lower Word in B
1506   0DB6 A7 00         mov bh, 0
1507   0DB8 38 00 00      mov c, 0
1508   0DBB E7            pop d
1509   0DBC FD 43         mov [d], b
1510   0DBE 28            mov b, c
1511   0DBF FD 44 02 00   mov [d + 2], b
1512   0DC3             _if36_exit:
1513   0DC3             ; if (absval == 0) { 
1514   0DC3             _if37_cond:
1515   0DC3 FA F1 FF      lea d, [bp + -15] ; $absval
1516   0DC6 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1517   0DC9 FD 39         mov c, b ; And place it into C
1518   0DCB 2A            mov b, [d] ; Lower Word in B
1519   0DCC             ; --- START RELATIONAL
1520   0DCC D7            push a
1521   0DCD FD D8         push g
1522   0DCF 11            mov a, b
1523   0DD0 FD 7A         mov g, c
1524   0DD2 FD 2E 00 00   mov32 cb, $00000000
1524   0DD6 00 00 
1525   0DD8 38 00 00      mov c, 0
1526   0DDB FD AF         cmp32 ga, cb
1527   0DDD FD 71         seq ; ==
1528   0DDF FD F1         pop g
1529   0DE1 E4            pop a
1530   0DE2             ; --- END RELATIONAL
1531   0DE2 C0 00 00      cmp b, 0
1532   0DE5 C6 FA 0D      je _if37_exit
1533   0DE8             _if37_TRUE:
1534   0DE8             ; putchar('0'); 
1535   0DE8             ; --- START FUNCTION CALL
1536   0DE8 FD 2E 30 00   mov32 cb, $00000030
1536   0DEC 00 00 
1537   0DEE DD            push bl
1538   0DEF 07 D8 0E      call putchar
1539   0DF2 51 01 00      add sp, 1
1540   0DF5             ; --- END FUNCTION CALL
1541   0DF5             ; return; 
1542   0DF5 F9            leave
1543   0DF6 09            ret
1544   0DF7 0A FA 0D      jmp _if37_exit
1545   0DFA             _if37_exit:
1546   0DFA             ; while (absval > 0) { 
1547   0DFA             _while38_cond:
1548   0DFA FA F1 FF      lea d, [bp + -15] ; $absval
1549   0DFD 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1550   0E00 FD 39         mov c, b ; And place it into C
1551   0E02 2A            mov b, [d] ; Lower Word in B
1552   0E03             ; --- START RELATIONAL
1553   0E03 D7            push a
1554   0E04 FD D8         push g
1555   0E06 11            mov a, b
1556   0E07 FD 7A         mov g, c
1557   0E09 FD 2E 00 00   mov32 cb, $00000000
1557   0E0D 00 00 
1558   0E0F 38 00 00      mov c, 0
1559   0E12 FD AF         cmp32 ga, cb
1560   0E14 FD 81         sgu
1561   0E16 FD F1         pop g
1562   0E18 E4            pop a
1563   0E19             ; --- END RELATIONAL
1564   0E19 C0 00 00      cmp b, 0
1565   0E1C C6 9A 0E      je _while38_exit
1566   0E1F             _while38_block:
1567   0E1F             ; digits[i++] = '0' + (absval % 10); 
1568   0E1F FA F7 FF      lea d, [bp + -9] ; $digits
1569   0E22 D7            push a
1570   0E23 DA            push d
1571   0E24 FA F5 FF      lea d, [bp + -11] ; $i
1572   0E27 2A            mov b, [d]
1573   0E28 38 00 00      mov c, 0
1574   0E2B 11            mov a, b
1575   0E2C FD 77         inc b
1576   0E2E FA F5 FF      lea d, [bp + -11] ; $i
1577   0E31 FD 43         mov [d], b
1578   0E33 27            mov b, a
1579   0E34 E7            pop d
1580   0E35 5A            add d, b
1581   0E36 E4            pop a
1582   0E37 DA            push d
1583   0E38 FD 2E 30 00   mov32 cb, $00000030
1583   0E3C 00 00 
1584   0E3E             ; --- START TERMS
1585   0E3E D7            push a
1586   0E3F 11            mov a, b
1587   0E40 FA F1 FF      lea d, [bp + -15] ; $absval
1588   0E43 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1589   0E46 FD 39         mov c, b ; And place it into C
1590   0E48 2A            mov b, [d] ; Lower Word in B
1591   0E49             ; --- START FACTORS
1592   0E49 D7            push a
1593   0E4A FD D8         push g
1594   0E4C 11            mov a, b
1595   0E4D FD 7A         mov g, c
1596   0E4F FD 2E 0A 00   mov32 cb, $0000000a
1596   0E53 00 00 
1597   0E55 FD D8         push g ; save 'g' as the div instruction uses it
1598   0E57 AE            div a, b ; %, a: quotient, b: remainder
1599   0E58 11            mov a, b
1600   0E59 FD F1         pop g
1601   0E5B FD 38         mov c, g
1602   0E5D 27            mov b, a
1603   0E5E FD F1         pop g
1604   0E60 E4            pop a
1605   0E61             ; --- END FACTORS
1606   0E61 FD 22 00 00   mov g, 0
1607   0E65 FD 15         add32 cb, ga
1608   0E67 E4            pop a
1609   0E68             ; --- END TERMS
1610   0E68 E7            pop d
1611   0E69 FD 3E         mov [d], bl
1612   0E6B             ; absval = absval / 10; 
1613   0E6B FA F1 FF      lea d, [bp + -15] ; $absval
1614   0E6E DA            push d
1615   0E6F FA F1 FF      lea d, [bp + -15] ; $absval
1616   0E72 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1617   0E75 FD 39         mov c, b ; And place it into C
1618   0E77 2A            mov b, [d] ; Lower Word in B
1619   0E78             ; --- START FACTORS
1620   0E78 D7            push a
1621   0E79 FD D8         push g
1622   0E7B 11            mov a, b
1623   0E7C FD 7A         mov g, c
1624   0E7E FD 2E 0A 00   mov32 cb, $0000000a
1624   0E82 00 00 
1625   0E84 FD D8         push g ; save 'g' as the div instruction uses it
1626   0E86 AE            div a, b ; /, a: quotient, b: remainder
1627   0E87 FD F1         pop g
1628   0E89 FD 38         mov c, g
1629   0E8B 27            mov b, a
1630   0E8C FD F1         pop g
1631   0E8E E4            pop a
1632   0E8F             ; --- END FACTORS
1633   0E8F E7            pop d
1634   0E90 FD 43         mov [d], b
1635   0E92 28            mov b, c
1636   0E93 FD 44 02 00   mov [d + 2], b
1637   0E97 0A FA 0D      jmp _while38_cond
1638   0E9A             _while38_exit:
1639   0E9A             ; while (i > 0) { 
1640   0E9A             _while45_cond:
1641   0E9A FA F5 FF      lea d, [bp + -11] ; $i
1642   0E9D 2A            mov b, [d]
1643   0E9E 38 00 00      mov c, 0
1644   0EA1             ; --- START RELATIONAL
1645   0EA1 D7            push a
1646   0EA2 11            mov a, b
1647   0EA3 FD 2E 00 00   mov32 cb, $00000000
1647   0EA7 00 00 
1648   0EA9 B0            cmp a, b
1649   0EAA FD 7F         sgt ; >
1650   0EAC E4            pop a
1651   0EAD             ; --- END RELATIONAL
1652   0EAD C0 00 00      cmp b, 0
1653   0EB0 C6 D6 0E      je _while45_exit
1654   0EB3             _while45_block:
1655   0EB3             ; putchar(digits[--i]); 
1656   0EB3             ; --- START FUNCTION CALL
1657   0EB3 FA F7 FF      lea d, [bp + -9] ; $digits
1658   0EB6 D7            push a
1659   0EB7 DA            push d
1660   0EB8 FA F5 FF      lea d, [bp + -11] ; $i
1661   0EBB 2A            mov b, [d]
1662   0EBC FD 7D         dec b
1663   0EBE FA F5 FF      lea d, [bp + -11] ; $i
1664   0EC1 FD 43         mov [d], b
1665   0EC3 E7            pop d
1666   0EC4 5A            add d, b
1667   0EC5 E4            pop a
1668   0EC6 32            mov bl, [d]
1669   0EC7 A7 00         mov bh, 0
1670   0EC9 38 00 00      mov c, 0
1671   0ECC DD            push bl
1672   0ECD 07 D8 0E      call putchar
1673   0ED0 51 01 00      add sp, 1
1674   0ED3             ; --- END FUNCTION CALL
1675   0ED3 0A 9A 0E      jmp _while45_cond
1676   0ED6             _while45_exit:
1677   0ED6 F9            leave
1678   0ED7 09            ret
1679   0ED8             
1680   0ED8             putchar:
1681   0ED8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1682   0EDB             ; --- BEGIN INLINE ASM SEGMENT
1683   0EDB FA 05 00      lea d, [bp + 5] ; $c
1684   0EDE 1E            mov al, [d]
1685   0EDF 23            mov ah, al
1686   0EE0 19 00         mov al, 0
1687   0EE2 05 03         syscall sys_io      ; char in AH
1688   0EE4             ; --- END INLINE ASM SEGMENT
1689   0EE4 F9            leave
1690   0EE5 09            ret
1691   0EE6             
1692   0EE6             print_unsigned_long:
1693   0EE6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1694   0EE9             ; char digits[10]; 
1695   0EE9 52 0A 00      sub sp, 10
1696   0EEC             ; int i = 0; 
1697   0EEC 52 02 00      sub sp, 2
1698   0EEF             ; --- START LOCAL VAR INITIALIZATION
1699   0EEF FA F5 FF      lea d, [bp + -11] ; $i
1700   0EF2 DA            push d
1701   0EF3 FD 2E 00 00   mov32 cb, $00000000
1701   0EF7 00 00 
1702   0EF9 E7            pop d
1703   0EFA FD 43         mov [d], b
1704   0EFC             ; --- END LOCAL VAR INITIALIZATION
1705   0EFC             ; if(num == 0){ 
1706   0EFC             _if46_cond:
1707   0EFC FA 05 00      lea d, [bp + 5] ; $num
1708   0EFF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1709   0F02 FD 39         mov c, b ; And place it into C
1710   0F04 2A            mov b, [d] ; Lower Word in B
1711   0F05             ; --- START RELATIONAL
1712   0F05 D7            push a
1713   0F06 FD D8         push g
1714   0F08 11            mov a, b
1715   0F09 FD 7A         mov g, c
1716   0F0B FD 2E 00 00   mov32 cb, $00000000
1716   0F0F 00 00 
1717   0F11 38 00 00      mov c, 0
1718   0F14 FD AF         cmp32 ga, cb
1719   0F16 FD 71         seq ; ==
1720   0F18 FD F1         pop g
1721   0F1A E4            pop a
1722   0F1B             ; --- END RELATIONAL
1723   0F1B C0 00 00      cmp b, 0
1724   0F1E C6 33 0F      je _if46_exit
1725   0F21             _if46_TRUE:
1726   0F21             ; putchar('0'); 
1727   0F21             ; --- START FUNCTION CALL
1728   0F21 FD 2E 30 00   mov32 cb, $00000030
1728   0F25 00 00 
1729   0F27 DD            push bl
1730   0F28 07 D8 0E      call putchar
1731   0F2B 51 01 00      add sp, 1
1732   0F2E             ; --- END FUNCTION CALL
1733   0F2E             ; return; 
1734   0F2E F9            leave
1735   0F2F 09            ret
1736   0F30 0A 33 0F      jmp _if46_exit
1737   0F33             _if46_exit:
1738   0F33             ; while (num > 0) { 
1739   0F33             _while47_cond:
1740   0F33 FA 05 00      lea d, [bp + 5] ; $num
1741   0F36 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1742   0F39 FD 39         mov c, b ; And place it into C
1743   0F3B 2A            mov b, [d] ; Lower Word in B
1744   0F3C             ; --- START RELATIONAL
1745   0F3C D7            push a
1746   0F3D FD D8         push g
1747   0F3F 11            mov a, b
1748   0F40 FD 7A         mov g, c
1749   0F42 FD 2E 00 00   mov32 cb, $00000000
1749   0F46 00 00 
1750   0F48 38 00 00      mov c, 0
1751   0F4B FD AF         cmp32 ga, cb
1752   0F4D FD 81         sgu
1753   0F4F FD F1         pop g
1754   0F51 E4            pop a
1755   0F52             ; --- END RELATIONAL
1756   0F52 C0 00 00      cmp b, 0
1757   0F55 C6 D3 0F      je _while47_exit
1758   0F58             _while47_block:
1759   0F58             ; digits[i++] = '0' + (num % 10); 
1760   0F58 FA F7 FF      lea d, [bp + -9] ; $digits
1761   0F5B D7            push a
1762   0F5C DA            push d
1763   0F5D FA F5 FF      lea d, [bp + -11] ; $i
1764   0F60 2A            mov b, [d]
1765   0F61 38 00 00      mov c, 0
1766   0F64 11            mov a, b
1767   0F65 FD 77         inc b
1768   0F67 FA F5 FF      lea d, [bp + -11] ; $i
1769   0F6A FD 43         mov [d], b
1770   0F6C 27            mov b, a
1771   0F6D E7            pop d
1772   0F6E 5A            add d, b
1773   0F6F E4            pop a
1774   0F70 DA            push d
1775   0F71 FD 2E 30 00   mov32 cb, $00000030
1775   0F75 00 00 
1776   0F77             ; --- START TERMS
1777   0F77 D7            push a
1778   0F78 11            mov a, b
1779   0F79 FA 05 00      lea d, [bp + 5] ; $num
1780   0F7C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1781   0F7F FD 39         mov c, b ; And place it into C
1782   0F81 2A            mov b, [d] ; Lower Word in B
1783   0F82             ; --- START FACTORS
1784   0F82 D7            push a
1785   0F83 FD D8         push g
1786   0F85 11            mov a, b
1787   0F86 FD 7A         mov g, c
1788   0F88 FD 2E 0A 00   mov32 cb, $0000000a
1788   0F8C 00 00 
1789   0F8E FD D8         push g ; save 'g' as the div instruction uses it
1790   0F90 AE            div a, b ; %, a: quotient, b: remainder
1791   0F91 11            mov a, b
1792   0F92 FD F1         pop g
1793   0F94 FD 38         mov c, g
1794   0F96 27            mov b, a
1795   0F97 FD F1         pop g
1796   0F99 E4            pop a
1797   0F9A             ; --- END FACTORS
1798   0F9A FD 22 00 00   mov g, 0
1799   0F9E FD 15         add32 cb, ga
1800   0FA0 E4            pop a
1801   0FA1             ; --- END TERMS
1802   0FA1 E7            pop d
1803   0FA2 FD 3E         mov [d], bl
1804   0FA4             ; num = num / 10; 
1805   0FA4 FA 05 00      lea d, [bp + 5] ; $num
1806   0FA7 DA            push d
1807   0FA8 FA 05 00      lea d, [bp + 5] ; $num
1808   0FAB 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1809   0FAE FD 39         mov c, b ; And place it into C
1810   0FB0 2A            mov b, [d] ; Lower Word in B
1811   0FB1             ; --- START FACTORS
1812   0FB1 D7            push a
1813   0FB2 FD D8         push g
1814   0FB4 11            mov a, b
1815   0FB5 FD 7A         mov g, c
1816   0FB7 FD 2E 0A 00   mov32 cb, $0000000a
1816   0FBB 00 00 
1817   0FBD FD D8         push g ; save 'g' as the div instruction uses it
1818   0FBF AE            div a, b ; /, a: quotient, b: remainder
1819   0FC0 FD F1         pop g
1820   0FC2 FD 38         mov c, g
1821   0FC4 27            mov b, a
1822   0FC5 FD F1         pop g
1823   0FC7 E4            pop a
1824   0FC8             ; --- END FACTORS
1825   0FC8 E7            pop d
1826   0FC9 FD 43         mov [d], b
1827   0FCB 28            mov b, c
1828   0FCC FD 44 02 00   mov [d + 2], b
1829   0FD0 0A 33 0F      jmp _while47_cond
1830   0FD3             _while47_exit:
1831   0FD3             ; while (i > 0) { 
1832   0FD3             _while54_cond:
1833   0FD3 FA F5 FF      lea d, [bp + -11] ; $i
1834   0FD6 2A            mov b, [d]
1835   0FD7 38 00 00      mov c, 0
1836   0FDA             ; --- START RELATIONAL
1837   0FDA D7            push a
1838   0FDB 11            mov a, b
1839   0FDC FD 2E 00 00   mov32 cb, $00000000
1839   0FE0 00 00 
1840   0FE2 B0            cmp a, b
1841   0FE3 FD 7F         sgt ; >
1842   0FE5 E4            pop a
1843   0FE6             ; --- END RELATIONAL
1844   0FE6 C0 00 00      cmp b, 0
1845   0FE9 C6 0F 10      je _while54_exit
1846   0FEC             _while54_block:
1847   0FEC             ; putchar(digits[--i]); 
1848   0FEC             ; --- START FUNCTION CALL
1849   0FEC FA F7 FF      lea d, [bp + -9] ; $digits
1850   0FEF D7            push a
1851   0FF0 DA            push d
1852   0FF1 FA F5 FF      lea d, [bp + -11] ; $i
1853   0FF4 2A            mov b, [d]
1854   0FF5 FD 7D         dec b
1855   0FF7 FA F5 FF      lea d, [bp + -11] ; $i
1856   0FFA FD 43         mov [d], b
1857   0FFC E7            pop d
1858   0FFD 5A            add d, b
1859   0FFE E4            pop a
1860   0FFF 32            mov bl, [d]
1861   1000 A7 00         mov bh, 0
1862   1002 38 00 00      mov c, 0
1863   1005 DD            push bl
1864   1006 07 D8 0E      call putchar
1865   1009 51 01 00      add sp, 1
1866   100C             ; --- END FUNCTION CALL
1867   100C 0A D3 0F      jmp _while54_cond
1868   100F             _while54_exit:
1869   100F F9            leave
1870   1010 09            ret
1871   1011             
1872   1011             printx32:
1873   1011 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1874   1014             ; --- BEGIN INLINE ASM SEGMENT
1875   1014 FA 05 00      lea d, [bp + 5] ; $hex
1876   1017 2B 02 00      mov b, [d+2]
1877   101A 07 23 10      call print_u16x_printx32
1878   101D 2A            mov b, [d]
1879   101E 07 23 10      call print_u16x_printx32
1880   1021             ; --- END INLINE ASM SEGMENT
1881   1021             ; return; 
1882   1021 F9            leave
1883   1022 09            ret
1884   1023             ; --- BEGIN INLINE ASM SEGMENT
1885   1023             print_u16x_printx32:
1886   1023 D7            push a
1887   1024 D8            push b
1888   1025 DD            push bl
1889   1026 30            mov bl, bh
1890   1027 07 45 10      call _itoa_printx32        ; convert bh to char in A
1891   102A 2F            mov bl, al        ; save al
1892   102B 19 00         mov al, 0
1893   102D 05 03         syscall sys_io        ; display AH
1894   102F 24            mov ah, bl        ; retrieve al
1895   1030 19 00         mov al, 0
1896   1032 05 03         syscall sys_io        ; display AL
1897   1034 EA            pop bl
1898   1035 07 45 10      call _itoa_printx32        ; convert bh to char in A
1899   1038 2F            mov bl, al        ; save al
1900   1039 19 00         mov al, 0
1901   103B 05 03         syscall sys_io        ; display AH
1902   103D 24            mov ah, bl        ; retrieve al
1903   103E 19 00         mov al, 0
1904   1040 05 03         syscall sys_io        ; display AL
1905   1042 E5            pop b
1906   1043 E4            pop a
1907   1044 09            ret
1908   1045             _itoa_printx32:
1909   1045 DA            push d
1910   1046 D8            push b
1911   1047 A7 00         mov bh, 0
1912   1049 FD A4 04      shr bl, 4  
1913   104C 74            mov d, b
1914   104D 1F 5F 10      mov al, [d + s_hex_digits_printx32]
1915   1050 23            mov ah, al
1916   1051 E5            pop b
1917   1052 D8            push b
1918   1053 A7 00         mov bh, 0
1919   1055 FD 87 0F      and bl, $0F
1920   1058 74            mov d, b
1921   1059 1F 5F 10      mov al, [d + s_hex_digits_printx32]
1922   105C E5            pop b
1923   105D E7            pop d
1924   105E 09            ret
1925   105F 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1925   1063 34 35 36 37 
1925   1067 38 39 41 42 
1925   106B 43 44 45 46 
1926   106F             ; --- END INLINE ASM SEGMENT
1927   106F F9            leave
1928   1070 09            ret
1929   1071             
1930   1071             err:
1931   1071 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1932   1074             ; print(e); 
1933   1074             ; --- START FUNCTION CALL
1934   1074 FA 05 00      lea d, [bp + 5] ; $e
1935   1077 2A            mov b, [d]
1936   1078 38 00 00      mov c, 0
1937   107B FD AB         swp b
1938   107D D8            push b
1939   107E 07 86 10      call print
1940   1081 51 02 00      add sp, 2
1941   1084             ; --- END FUNCTION CALL
1942   1084 F9            leave
1943   1085 09            ret
1944   1086             
1945   1086             print:
1946   1086 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1947   1089             ; --- BEGIN INLINE ASM SEGMENT
1948   1089 FA 05 00      lea d, [bp + 5] ; $s
1949   108C FD 2A         mov d, [d]
1950   108E             _puts_L1_print:
1951   108E 1E            mov al, [d]
1952   108F B9 00         cmp al, 0
1953   1091 C6 9D 10      jz _puts_END_print
1954   1094 23            mov ah, al
1955   1095 19 00         mov al, 0
1956   1097 05 03         syscall sys_io
1957   1099 79            inc d
1958   109A 0A 8E 10      jmp _puts_L1_print
1959   109D             _puts_END_print:
1960   109D             ; --- END INLINE ASM SEGMENT
1961   109D F9            leave
1962   109E 09            ret
1963   109F             
1964   109F             print_signed:
1965   109F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1966   10A2             ; char digits[5];  // enough for "-32768" 
1967   10A2 52 05 00      sub sp, 5
1968   10A5             ; int i = 0; 
1969   10A5 52 02 00      sub sp, 2
1970   10A8             ; --- START LOCAL VAR INITIALIZATION
1971   10A8 FA FA FF      lea d, [bp + -6] ; $i
1972   10AB DA            push d
1973   10AC FD 2E 00 00   mov32 cb, $00000000
1973   10B0 00 00 
1974   10B2 E7            pop d
1975   10B3 FD 43         mov [d], b
1976   10B5             ; --- END LOCAL VAR INITIALIZATION
1977   10B5             ; unsigned int absval; 
1978   10B5 52 02 00      sub sp, 2
1979   10B8             ; if (num < 0) { 
1980   10B8             _if55_cond:
1981   10B8 FA 05 00      lea d, [bp + 5] ; $num
1982   10BB 2A            mov b, [d]
1983   10BC 38 00 00      mov c, 0
1984   10BF             ; --- START RELATIONAL
1985   10BF D7            push a
1986   10C0 11            mov a, b
1987   10C1 FD 2E 00 00   mov32 cb, $00000000
1987   10C5 00 00 
1988   10C7 B0            cmp a, b
1989   10C8 FD 73         slt ; < (signed)
1990   10CA E4            pop a
1991   10CB             ; --- END RELATIONAL
1992   10CB C0 00 00      cmp b, 0
1993   10CE C6 05 11      je _if55_else
1994   10D1             _if55_TRUE:
1995   10D1             ; putchar('-'); 
1996   10D1             ; --- START FUNCTION CALL
1997   10D1 FD 2E 2D 00   mov32 cb, $0000002d
1997   10D5 00 00 
1998   10D7 DD            push bl
1999   10D8 07 D8 0E      call putchar
2000   10DB 51 01 00      add sp, 1
2001   10DE             ; --- END FUNCTION CALL
2002   10DE             ; absval = (unsigned int)(-(num + 1)) + 1;  // safe for -32768 
2003   10DE FA F8 FF      lea d, [bp + -8] ; $absval
2004   10E1 DA            push d
2005   10E2 FA 05 00      lea d, [bp + 5] ; $num
2006   10E5 2A            mov b, [d]
2007   10E6 38 00 00      mov c, 0
2008   10E9             ; --- START TERMS
2009   10E9 D7            push a
2010   10EA 11            mov a, b
2011   10EB FD 2E 01 00   mov32 cb, $00000001
2011   10EF 00 00 
2012   10F1 56            add b, a
2013   10F2 E4            pop a
2014   10F3             ; --- END TERMS
2015   10F3 FD 97         neg b
2016   10F5             ; --- START TERMS
2017   10F5 D7            push a
2018   10F6 11            mov a, b
2019   10F7 FD 2E 01 00   mov32 cb, $00000001
2019   10FB 00 00 
2020   10FD 56            add b, a
2021   10FE E4            pop a
2022   10FF             ; --- END TERMS
2023   10FF E7            pop d
2024   1100 FD 43         mov [d], b
2025   1102 0A 13 11      jmp _if55_exit
2026   1105             _if55_else:
2027   1105             ; absval = (unsigned int)num; 
2028   1105 FA F8 FF      lea d, [bp + -8] ; $absval
2029   1108 DA            push d
2030   1109 FA 05 00      lea d, [bp + 5] ; $num
2031   110C 2A            mov b, [d]
2032   110D 38 00 00      mov c, 0
2033   1110 E7            pop d
2034   1111 FD 43         mov [d], b
2035   1113             _if55_exit:
2036   1113             ; if (absval == 0) { 
2037   1113             _if56_cond:
2038   1113 FA F8 FF      lea d, [bp + -8] ; $absval
2039   1116 2A            mov b, [d]
2040   1117 38 00 00      mov c, 0
2041   111A             ; --- START RELATIONAL
2042   111A D7            push a
2043   111B 11            mov a, b
2044   111C FD 2E 00 00   mov32 cb, $00000000
2044   1120 00 00 
2045   1122 B0            cmp a, b
2046   1123 FD 71         seq ; ==
2047   1125 E4            pop a
2048   1126             ; --- END RELATIONAL
2049   1126 C0 00 00      cmp b, 0
2050   1129 C6 3E 11      je _if56_exit
2051   112C             _if56_TRUE:
2052   112C             ; putchar('0'); 
2053   112C             ; --- START FUNCTION CALL
2054   112C FD 2E 30 00   mov32 cb, $00000030
2054   1130 00 00 
2055   1132 DD            push bl
2056   1133 07 D8 0E      call putchar
2057   1136 51 01 00      add sp, 1
2058   1139             ; --- END FUNCTION CALL
2059   1139             ; return; 
2060   1139 F9            leave
2061   113A 09            ret
2062   113B 0A 3E 11      jmp _if56_exit
2063   113E             _if56_exit:
2064   113E             ; while (absval > 0) { 
2065   113E             _while57_cond:
2066   113E FA F8 FF      lea d, [bp + -8] ; $absval
2067   1141 2A            mov b, [d]
2068   1142 38 00 00      mov c, 0
2069   1145             ; --- START RELATIONAL
2070   1145 D7            push a
2071   1146 11            mov a, b
2072   1147 FD 2E 00 00   mov32 cb, $00000000
2072   114B 00 00 
2073   114D B0            cmp a, b
2074   114E FD 81         sgu ; > (unsigned)
2075   1150 E4            pop a
2076   1151             ; --- END RELATIONAL
2077   1151 C0 00 00      cmp b, 0
2078   1154 C6 C4 11      je _while57_exit
2079   1157             _while57_block:
2080   1157             ; digits[i++] = '0' + (absval % 10); 
2081   1157 FA FC FF      lea d, [bp + -4] ; $digits
2082   115A D7            push a
2083   115B DA            push d
2084   115C FA FA FF      lea d, [bp + -6] ; $i
2085   115F 2A            mov b, [d]
2086   1160 38 00 00      mov c, 0
2087   1163 11            mov a, b
2088   1164 FD 77         inc b
2089   1166 FA FA FF      lea d, [bp + -6] ; $i
2090   1169 FD 43         mov [d], b
2091   116B 27            mov b, a
2092   116C E7            pop d
2093   116D 5A            add d, b
2094   116E E4            pop a
2095   116F DA            push d
2096   1170 FD 2E 30 00   mov32 cb, $00000030
2096   1174 00 00 
2097   1176             ; --- START TERMS
2098   1176 D7            push a
2099   1177 11            mov a, b
2100   1178 FA F8 FF      lea d, [bp + -8] ; $absval
2101   117B 2A            mov b, [d]
2102   117C 38 00 00      mov c, 0
2103   117F             ; --- START FACTORS
2104   117F D7            push a
2105   1180 FD D8         push g
2106   1182 11            mov a, b
2107   1183 FD 7A         mov g, c
2108   1185 FD 2E 0A 00   mov32 cb, $0000000a
2108   1189 00 00 
2109   118B FD D8         push g ; save 'g' as the div instruction uses it
2110   118D AE            div a, b ; %, a: quotient, b: remainder
2111   118E 11            mov a, b
2112   118F FD F1         pop g
2113   1191 FD 38         mov c, g
2114   1193 27            mov b, a
2115   1194 FD F1         pop g
2116   1196 E4            pop a
2117   1197             ; --- END FACTORS
2118   1197 56            add b, a
2119   1198 E4            pop a
2120   1199             ; --- END TERMS
2121   1199 E7            pop d
2122   119A FD 3E         mov [d], bl
2123   119C             ; absval = absval / 10; 
2124   119C FA F8 FF      lea d, [bp + -8] ; $absval
2125   119F DA            push d
2126   11A0 FA F8 FF      lea d, [bp + -8] ; $absval
2127   11A3 2A            mov b, [d]
2128   11A4 38 00 00      mov c, 0
2129   11A7             ; --- START FACTORS
2130   11A7 D7            push a
2131   11A8 FD D8         push g
2132   11AA 11            mov a, b
2133   11AB FD 7A         mov g, c
2134   11AD FD 2E 0A 00   mov32 cb, $0000000a
2134   11B1 00 00 
2135   11B3 FD D8         push g ; save 'g' as the div instruction uses it
2136   11B5 AE            div a, b ; /, a: quotient, b: remainder
2137   11B6 FD F1         pop g
2138   11B8 FD 38         mov c, g
2139   11BA 27            mov b, a
2140   11BB FD F1         pop g
2141   11BD E4            pop a
2142   11BE             ; --- END FACTORS
2143   11BE E7            pop d
2144   11BF FD 43         mov [d], b
2145   11C1 0A 3E 11      jmp _while57_cond
2146   11C4             _while57_exit:
2147   11C4             ; while (i > 0) { 
2148   11C4             _while64_cond:
2149   11C4 FA FA FF      lea d, [bp + -6] ; $i
2150   11C7 2A            mov b, [d]
2151   11C8 38 00 00      mov c, 0
2152   11CB             ; --- START RELATIONAL
2153   11CB D7            push a
2154   11CC 11            mov a, b
2155   11CD FD 2E 00 00   mov32 cb, $00000000
2155   11D1 00 00 
2156   11D3 B0            cmp a, b
2157   11D4 FD 7F         sgt ; >
2158   11D6 E4            pop a
2159   11D7             ; --- END RELATIONAL
2160   11D7 C0 00 00      cmp b, 0
2161   11DA C6 00 12      je _while64_exit
2162   11DD             _while64_block:
2163   11DD             ; putchar(digits[--i]); 
2164   11DD             ; --- START FUNCTION CALL
2165   11DD FA FC FF      lea d, [bp + -4] ; $digits
2166   11E0 D7            push a
2167   11E1 DA            push d
2168   11E2 FA FA FF      lea d, [bp + -6] ; $i
2169   11E5 2A            mov b, [d]
2170   11E6 FD 7D         dec b
2171   11E8 FA FA FF      lea d, [bp + -6] ; $i
2172   11EB FD 43         mov [d], b
2173   11ED E7            pop d
2174   11EE 5A            add d, b
2175   11EF E4            pop a
2176   11F0 32            mov bl, [d]
2177   11F1 A7 00         mov bh, 0
2178   11F3 38 00 00      mov c, 0
2179   11F6 DD            push bl
2180   11F7 07 D8 0E      call putchar
2181   11FA 51 01 00      add sp, 1
2182   11FD             ; --- END FUNCTION CALL
2183   11FD 0A C4 11      jmp _while64_cond
2184   1200             _while64_exit:
2185   1200 F9            leave
2186   1201 09            ret
2187   1202             
2188   1202             print_unsigned:
2189   1202 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2190   1205             ; char digits[5]; 
2191   1205 52 05 00      sub sp, 5
2192   1208             ; int i = 0; 
2193   1208 52 02 00      sub sp, 2
2194   120B             ; --- START LOCAL VAR INITIALIZATION
2195   120B FA FA FF      lea d, [bp + -6] ; $i
2196   120E DA            push d
2197   120F FD 2E 00 00   mov32 cb, $00000000
2197   1213 00 00 
2198   1215 E7            pop d
2199   1216 FD 43         mov [d], b
2200   1218             ; --- END LOCAL VAR INITIALIZATION
2201   1218             ; if(num == 0){ 
2202   1218             _if65_cond:
2203   1218 FA 05 00      lea d, [bp + 5] ; $num
2204   121B 2A            mov b, [d]
2205   121C 38 00 00      mov c, 0
2206   121F             ; --- START RELATIONAL
2207   121F D7            push a
2208   1220 11            mov a, b
2209   1221 FD 2E 00 00   mov32 cb, $00000000
2209   1225 00 00 
2210   1227 B0            cmp a, b
2211   1228 FD 71         seq ; ==
2212   122A E4            pop a
2213   122B             ; --- END RELATIONAL
2214   122B C0 00 00      cmp b, 0
2215   122E C6 43 12      je _if65_exit
2216   1231             _if65_TRUE:
2217   1231             ; putchar('0'); 
2218   1231             ; --- START FUNCTION CALL
2219   1231 FD 2E 30 00   mov32 cb, $00000030
2219   1235 00 00 
2220   1237 DD            push bl
2221   1238 07 D8 0E      call putchar
2222   123B 51 01 00      add sp, 1
2223   123E             ; --- END FUNCTION CALL
2224   123E             ; return; 
2225   123E F9            leave
2226   123F 09            ret
2227   1240 0A 43 12      jmp _if65_exit
2228   1243             _if65_exit:
2229   1243             ; while (num > 0) { 
2230   1243             _while66_cond:
2231   1243 FA 05 00      lea d, [bp + 5] ; $num
2232   1246 2A            mov b, [d]
2233   1247 38 00 00      mov c, 0
2234   124A             ; --- START RELATIONAL
2235   124A D7            push a
2236   124B 11            mov a, b
2237   124C FD 2E 00 00   mov32 cb, $00000000
2237   1250 00 00 
2238   1252 B0            cmp a, b
2239   1253 FD 81         sgu ; > (unsigned)
2240   1255 E4            pop a
2241   1256             ; --- END RELATIONAL
2242   1256 C0 00 00      cmp b, 0
2243   1259 C6 C9 12      je _while66_exit
2244   125C             _while66_block:
2245   125C             ; digits[i++] = '0' + (num % 10); 
2246   125C FA FC FF      lea d, [bp + -4] ; $digits
2247   125F D7            push a
2248   1260 DA            push d
2249   1261 FA FA FF      lea d, [bp + -6] ; $i
2250   1264 2A            mov b, [d]
2251   1265 38 00 00      mov c, 0
2252   1268 11            mov a, b
2253   1269 FD 77         inc b
2254   126B FA FA FF      lea d, [bp + -6] ; $i
2255   126E FD 43         mov [d], b
2256   1270 27            mov b, a
2257   1271 E7            pop d
2258   1272 5A            add d, b
2259   1273 E4            pop a
2260   1274 DA            push d
2261   1275 FD 2E 30 00   mov32 cb, $00000030
2261   1279 00 00 
2262   127B             ; --- START TERMS
2263   127B D7            push a
2264   127C 11            mov a, b
2265   127D FA 05 00      lea d, [bp + 5] ; $num
2266   1280 2A            mov b, [d]
2267   1281 38 00 00      mov c, 0
2268   1284             ; --- START FACTORS
2269   1284 D7            push a
2270   1285 FD D8         push g
2271   1287 11            mov a, b
2272   1288 FD 7A         mov g, c
2273   128A FD 2E 0A 00   mov32 cb, $0000000a
2273   128E 00 00 
2274   1290 FD D8         push g ; save 'g' as the div instruction uses it
2275   1292 AE            div a, b ; %, a: quotient, b: remainder
2276   1293 11            mov a, b
2277   1294 FD F1         pop g
2278   1296 FD 38         mov c, g
2279   1298 27            mov b, a
2280   1299 FD F1         pop g
2281   129B E4            pop a
2282   129C             ; --- END FACTORS
2283   129C 56            add b, a
2284   129D E4            pop a
2285   129E             ; --- END TERMS
2286   129E E7            pop d
2287   129F FD 3E         mov [d], bl
2288   12A1             ; num = num / 10; 
2289   12A1 FA 05 00      lea d, [bp + 5] ; $num
2290   12A4 DA            push d
2291   12A5 FA 05 00      lea d, [bp + 5] ; $num
2292   12A8 2A            mov b, [d]
2293   12A9 38 00 00      mov c, 0
2294   12AC             ; --- START FACTORS
2295   12AC D7            push a
2296   12AD FD D8         push g
2297   12AF 11            mov a, b
2298   12B0 FD 7A         mov g, c
2299   12B2 FD 2E 0A 00   mov32 cb, $0000000a
2299   12B6 00 00 
2300   12B8 FD D8         push g ; save 'g' as the div instruction uses it
2301   12BA AE            div a, b ; /, a: quotient, b: remainder
2302   12BB FD F1         pop g
2303   12BD FD 38         mov c, g
2304   12BF 27            mov b, a
2305   12C0 FD F1         pop g
2306   12C2 E4            pop a
2307   12C3             ; --- END FACTORS
2308   12C3 E7            pop d
2309   12C4 FD 43         mov [d], b
2310   12C6 0A 43 12      jmp _while66_cond
2311   12C9             _while66_exit:
2312   12C9             ; while (i > 0) { 
2313   12C9             _while73_cond:
2314   12C9 FA FA FF      lea d, [bp + -6] ; $i
2315   12CC 2A            mov b, [d]
2316   12CD 38 00 00      mov c, 0
2317   12D0             ; --- START RELATIONAL
2318   12D0 D7            push a
2319   12D1 11            mov a, b
2320   12D2 FD 2E 00 00   mov32 cb, $00000000
2320   12D6 00 00 
2321   12D8 B0            cmp a, b
2322   12D9 FD 7F         sgt ; >
2323   12DB E4            pop a
2324   12DC             ; --- END RELATIONAL
2325   12DC C0 00 00      cmp b, 0
2326   12DF C6 05 13      je _while73_exit
2327   12E2             _while73_block:
2328   12E2             ; putchar(digits[--i]); 
2329   12E2             ; --- START FUNCTION CALL
2330   12E2 FA FC FF      lea d, [bp + -4] ; $digits
2331   12E5 D7            push a
2332   12E6 DA            push d
2333   12E7 FA FA FF      lea d, [bp + -6] ; $i
2334   12EA 2A            mov b, [d]
2335   12EB FD 7D         dec b
2336   12ED FA FA FF      lea d, [bp + -6] ; $i
2337   12F0 FD 43         mov [d], b
2338   12F2 E7            pop d
2339   12F3 5A            add d, b
2340   12F4 E4            pop a
2341   12F5 32            mov bl, [d]
2342   12F6 A7 00         mov bh, 0
2343   12F8 38 00 00      mov c, 0
2344   12FB DD            push bl
2345   12FC 07 D8 0E      call putchar
2346   12FF 51 01 00      add sp, 1
2347   1302             ; --- END FUNCTION CALL
2348   1302 0A C9 12      jmp _while73_cond
2349   1305             _while73_exit:
2350   1305 F9            leave
2351   1306 09            ret
2352   1307             
2353   1307             printx16:
2354   1307 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2355   130A             ; --- BEGIN INLINE ASM SEGMENT
2356   130A FA 05 00      lea d, [bp + 5] ; $hex
2357   130D 2A            mov b, [d]
2358   130E             print_u16x_printx16:
2359   130E DD            push bl
2360   130F 30            mov bl, bh
2361   1310 07 2D 13      call _itoa_printx16        ; convert bh to char in A
2362   1313 2F            mov bl, al        ; save al
2363   1314 19 00         mov al, 0
2364   1316 05 03         syscall sys_io        ; display AH
2365   1318 24            mov ah, bl        ; retrieve al
2366   1319 19 00         mov al, 0
2367   131B 05 03         syscall sys_io        ; display AL
2368   131D EA            pop bl
2369   131E 07 2D 13      call _itoa_printx16        ; convert bh to char in A
2370   1321 2F            mov bl, al        ; save al
2371   1322 19 00         mov al, 0
2372   1324 05 03         syscall sys_io        ; display AH
2373   1326 24            mov ah, bl        ; retrieve al
2374   1327 19 00         mov al, 0
2375   1329 05 03         syscall sys_io        ; display AL
2376   132B             ; --- END INLINE ASM SEGMENT
2377   132B             ; return; 
2378   132B F9            leave
2379   132C 09            ret
2380   132D             ; --- BEGIN INLINE ASM SEGMENT
2381   132D             _itoa_printx16:
2382   132D DA            push d
2383   132E D8            push b
2384   132F A7 00         mov bh, 0
2385   1331 FD A4 04      shr bl, 4  
2386   1334 74            mov d, b
2387   1335 1F 47 13      mov al, [d + s_hex_digits_printx16]
2388   1338 23            mov ah, al
2389   1339 E5            pop b
2390   133A D8            push b
2391   133B A7 00         mov bh, 0
2392   133D FD 87 0F      and bl, $0F
2393   1340 74            mov d, b
2394   1341 1F 47 13      mov al, [d + s_hex_digits_printx16]
2395   1344 E5            pop b
2396   1345 E7            pop d
2397   1346 09            ret
2398   1347 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2398   134B 34 35 36 37 
2398   134F 38 39 41 42 
2398   1353 43 44 45 46 
2399   1357             ; --- END INLINE ASM SEGMENT
2400   1357 F9            leave
2401   1358 09            ret
2402   1359             ; --- END TEXT SEGMENT
2403   1359             
2404   1359             ; --- BEGIN DATA SEGMENT
2405   1359 07 00 0B 00 _expected_data: .dw $0007,$000b,$0011,$0019,$0023,$002f,$003d,$004d,$005f,$000f,
2405   135D 11 00 19 00 
2405   1361 23 00 2F 00 
2405   1365 3D 00 4D 00 
2405   1369 5F 00 0F 00 
2406   136D             
2407   136D 00 00 00 00 .fill 20, 0
2407   1371 00 00 00 00 
2407   1375 00 00 00 00 
2407   1379 00 00 00 00 
2407   137D 00 00 00 00 
2408   1381 3D 3D 3D 20 _s0: .db "=== Compiler Self-Test ===\n", 0
2408   1385 43 6F 6D 70 
2408   1389 69 6C 65 72 
2408   138D 20 53 65 6C 
2408   1391 66 2D 54 65 
2408   1395 73 74 20 3D 
2408   1399 3D 3D 0A 00 
2409   139D 0A 2A 2A 2A _s1: .db "\n*** ALL TESTS PASSED ***\n", 0
2409   13A1 20 41 4C 4C 
2409   13A5 20 54 45 53 
2409   13A9 54 53 20 50 
2409   13AD 41 53 53 45 
2409   13B1 44 20 2A 2A 
2409   13B5 2A 0A 00 
2410   13B8 0A 2A 2A 2A _s2: .db "\n*** TEST FAILED ***\n", 0
2410   13BC 20 54 45 53 
2410   13C0 54 20 46 41 
2410   13C4 49 4C 45 44 
2410   13C8 20 2A 2A 2A 
2410   13CC 0A 00 
2411   13CE 41 72 72 61 _s3: .db "Array mismatch at %d: got %d expected %d\n", 0
2411   13D2 79 20 6D 69 
2411   13D6 73 6D 61 74 
2411   13DA 63 68 20 61 
2411   13DE 74 20 25 64 
2411   13E2 3A 20 67 6F 
2411   13E6 74 20 25 64 
2411   13EA 20 65 78 70 
2411   13EE 65 63 74 65 
2411   13F2 64 20 25 64 
2411   13F6 0A 00 
2412   13F8 46 61 63 74 _s4: .db "Factorial failed: got %d expected 720\n", 0
2412   13FC 6F 72 69 61 
2412   1400 6C 20 66 61 
2412   1404 69 6C 65 64 
2412   1408 3A 20 67 6F 
2412   140C 74 20 25 64 
2412   1410 20 65 78 70 
2412   1414 65 63 74 65 
2412   1418 64 20 37 32 
2412   141C 30 0A 00 
2413   141F 53 74 72 75 _s5: .db "Struct check failed: (%d,%d)\n", 0
2413   1423 63 74 20 63 
2413   1427 68 65 63 6B 
2413   142B 20 66 61 69 
2413   142F 6C 65 64 3A 
2413   1433 20 28 25 64 
2413   1437 2C 25 64 29 
2413   143B 0A 00 
2414   143D 50 6F 69 6E _s6: .db "Pointer check failed: *p=%d *(p+5)=%d\n", 0
2414   1441 74 65 72 20 
2414   1445 63 68 65 63 
2414   1449 6B 20 66 61 
2414   144D 69 6C 65 64 
2414   1451 3A 20 2A 70 
2414   1455 3D 25 64 20 
2414   1459 2A 28 70 2B 
2414   145D 35 29 3D 25 
2414   1461 64 0A 00 
2415   1464 55 6E 65 78 _s7: .db "Unexpected format in printf.", 0
2415   1468 70 65 63 74 
2415   146C 65 64 20 66 
2415   1470 6F 72 6D 61 
2415   1474 74 20 69 6E 
2415   1478 20 70 72 69 
2415   147C 6E 74 66 2E 
2415   1480 00 
2416   1481 45 72 72 6F _s8: .db "Error: Unknown argument type.\n", 0
2416   1485 72 3A 20 55 
2416   1489 6E 6B 6E 6F 
2416   148D 77 6E 20 61 
2416   1491 72 67 75 6D 
2416   1495 65 6E 74 20 
2416   1499 74 79 70 65 
2416   149D 2E 0A 00 
2417   14A0             
2418   14A0 A2 14       _heap_top: .dw _heap
2419   14A2 00          _heap: .db 0
2420   14A3             ; --- END DATA SEGMENT
2421   14A3             
2422   14A3             .end
tasm: Number of errors = 0
