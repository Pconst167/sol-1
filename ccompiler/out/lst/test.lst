0001   0000             ; --- FILENAME: test.c
0002   0000             ; --- DATE:     14-10-2025 at 00:09:11
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; print_unsigned_long(0); 
0012   0408             ; --- START FUNCTION CALL
0013   0408 FD 2E 00 00   mov32 cb, $00000000
0013   040C 00 00 
0014   040E 12            mov a, c
0015   040F FD AA         swp a
0016   0411 D7            push a
0017   0412 FD AB         swp b
0018   0414 D8            push b
0019   0415 07 24 04      call print_unsigned_long
0020   0418 51 04 00      add sp, 4
0021   041B             ; --- END FUNCTION CALL
0022   041B             ; return 0; 
0023   041B FD 2E 00 00   mov32 cb, $00000000
0023   041F 00 00 
0024   0421 F9            leave
0025   0422 05 0B         syscall sys_terminate_proc
0026   0424             
0027   0424             print_unsigned_long:
0028   0424 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0029   0427             ; char digits[10]; 
0030   0427 52 0A 00      sub sp, 10
0031   042A             ; int i = 0; 
0032   042A 52 02 00      sub sp, 2
0033   042D             ; --- START LOCAL VAR INITIALIZATION
0034   042D FA F5 FF      lea d, [bp + -11] ; $i
0035   0430 DA            push d
0036   0431 FD 2E 00 00   mov32 cb, $00000000
0036   0435 00 00 
0037   0437 E7            pop d
0038   0438 FD 43         mov [d], b
0039   043A             ; --- END LOCAL VAR INITIALIZATION
0040   043A             ; if(num == 0){ 
0041   043A             _if1_cond:
0042   043A FA 05 00      lea d, [bp + 5] ; $num
0043   043D 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0044   0440 FD 39         mov c, b ; And place it into C
0045   0442 2A            mov b, [d] ; Lower Word in B
0046   0443             ; --- START RELATIONAL
0047   0443 D7            push a
0048   0444 FD D8         push g
0049   0446 11            mov a, b
0050   0447 FD 7A         mov g, c
0051   0449 FD 2E 00 00   mov32 cb, $00000000
0051   044D 00 00 
0052   044F 38 00 00      mov c, 0
0053   0452 FD AF         cmp32 ga, cb
0054   0454 FD 71         seq ; ==
0055   0456 FD F1         pop g
0056   0458 E4            pop a
0057   0459             ; --- END RELATIONAL
0058   0459 C0 00 00      cmp b, 0
0059   045C C6 71 04      je _if1_exit
0060   045F             _if1_TRUE:
0061   045F             ; putchar('0'); 
0062   045F             ; --- START FUNCTION CALL
0063   045F FD 2E 30 00   mov32 cb, $00000030
0063   0463 00 00 
0064   0465 DD            push bl
0065   0466 07 4F 05      call putchar
0066   0469 51 01 00      add sp, 1
0067   046C             ; --- END FUNCTION CALL
0068   046C             ; return; 
0069   046C F9            leave
0070   046D 09            ret
0071   046E 0A 71 04      jmp _if1_exit
0072   0471             _if1_exit:
0073   0471             ; while (num > 0) { 
0074   0471             _while2_cond:
0075   0471 FA 05 00      lea d, [bp + 5] ; $num
0076   0474 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0077   0477 FD 39         mov c, b ; And place it into C
0078   0479 2A            mov b, [d] ; Lower Word in B
0079   047A             ; --- START RELATIONAL
0080   047A D7            push a
0081   047B FD D8         push g
0082   047D 11            mov a, b
0083   047E FD 7A         mov g, c
0084   0480 FD 2E 00 00   mov32 cb, $00000000
0084   0484 00 00 
0085   0486 38 00 00      mov c, 0
0086   0489 FD AF         cmp32 ga, cb
0087   048B FD 81         sgu
0088   048D FD F1         pop g
0089   048F E4            pop a
0090   0490             ; --- END RELATIONAL
0091   0490 C0 00 00      cmp b, 0
0092   0493 C6 11 05      je _while2_exit
0093   0496             _while2_block:
0094   0496             ; digits[i++] = '0' + (num % 10); 
0095   0496 FA F7 FF      lea d, [bp + -9] ; $digits
0096   0499 D7            push a
0097   049A DA            push d
0098   049B FA F5 FF      lea d, [bp + -11] ; $i
0099   049E 2A            mov b, [d]
0100   049F 38 00 00      mov c, 0
0101   04A2 11            mov a, b
0102   04A3 FD 77         inc b
0103   04A5 FA F5 FF      lea d, [bp + -11] ; $i
0104   04A8 FD 43         mov [d], b
0105   04AA 27            mov b, a
0106   04AB E7            pop d
0107   04AC 5A            add d, b
0108   04AD E4            pop a
0109   04AE DA            push d
0110   04AF FD 2E 30 00   mov32 cb, $00000030
0110   04B3 00 00 
0111   04B5             ; --- START TERMS
0112   04B5 D7            push a
0113   04B6 11            mov a, b
0114   04B7 FA 05 00      lea d, [bp + 5] ; $num
0115   04BA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0116   04BD FD 39         mov c, b ; And place it into C
0117   04BF 2A            mov b, [d] ; Lower Word in B
0118   04C0             ; --- START FACTORS
0119   04C0 D7            push a
0120   04C1 FD D8         push g
0121   04C3 11            mov a, b
0122   04C4 FD 7A         mov g, c
0123   04C6 FD 2E 0A 00   mov32 cb, $0000000a
0123   04CA 00 00 
0124   04CC FD D8         push g ; save 'g' as the div instruction uses it
0125   04CE AE            div a, b ; %, a: quotient, b: remainder
0126   04CF 11            mov a, b
0127   04D0 FD F1         pop g
0128   04D2 FD 38         mov c, g
0129   04D4 27            mov b, a
0130   04D5 FD F1         pop g
0131   04D7 E4            pop a
0132   04D8             ; --- END FACTORS
0133   04D8 FD 22 00 00   mov g, 0
0134   04DC FD 15         add32 cb, ga
0135   04DE E4            pop a
0136   04DF             ; --- END TERMS
0137   04DF E7            pop d
0138   04E0 FD 3E         mov [d], bl
0139   04E2             ; num = num / 10; 
0140   04E2 FA 05 00      lea d, [bp + 5] ; $num
0141   04E5 DA            push d
0142   04E6 FA 05 00      lea d, [bp + 5] ; $num
0143   04E9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0144   04EC FD 39         mov c, b ; And place it into C
0145   04EE 2A            mov b, [d] ; Lower Word in B
0146   04EF             ; --- START FACTORS
0147   04EF D7            push a
0148   04F0 FD D8         push g
0149   04F2 11            mov a, b
0150   04F3 FD 7A         mov g, c
0151   04F5 FD 2E 0A 00   mov32 cb, $0000000a
0151   04F9 00 00 
0152   04FB FD D8         push g ; save 'g' as the div instruction uses it
0153   04FD AE            div a, b ; /, a: quotient, b: remainder
0154   04FE FD F1         pop g
0155   0500 FD 38         mov c, g
0156   0502 27            mov b, a
0157   0503 FD F1         pop g
0158   0505 E4            pop a
0159   0506             ; --- END FACTORS
0160   0506 E7            pop d
0161   0507 FD 43         mov [d], b
0162   0509 28            mov b, c
0163   050A FD 44 02 00   mov [d + 2], b
0164   050E 0A 71 04      jmp _while2_cond
0165   0511             _while2_exit:
0166   0511             ; while (i > 0) { 
0167   0511             _while9_cond:
0168   0511 FA F5 FF      lea d, [bp + -11] ; $i
0169   0514 2A            mov b, [d]
0170   0515 38 00 00      mov c, 0
0171   0518             ; --- START RELATIONAL
0172   0518 D7            push a
0173   0519 11            mov a, b
0174   051A FD 2E 00 00   mov32 cb, $00000000
0174   051E 00 00 
0175   0520 B0            cmp a, b
0176   0521 FD 7F         sgt ; >
0177   0523 E4            pop a
0178   0524             ; --- END RELATIONAL
0179   0524 C0 00 00      cmp b, 0
0180   0527 C6 4D 05      je _while9_exit
0181   052A             _while9_block:
0182   052A             ; putchar(digits[--i]); 
0183   052A             ; --- START FUNCTION CALL
0184   052A FA F7 FF      lea d, [bp + -9] ; $digits
0185   052D D7            push a
0186   052E DA            push d
0187   052F FA F5 FF      lea d, [bp + -11] ; $i
0188   0532 2A            mov b, [d]
0189   0533 FD 7D         dec b
0190   0535 FA F5 FF      lea d, [bp + -11] ; $i
0191   0538 FD 43         mov [d], b
0192   053A E7            pop d
0193   053B 5A            add d, b
0194   053C E4            pop a
0195   053D 32            mov bl, [d]
0196   053E A7 00         mov bh, 0
0197   0540 38 00 00      mov c, 0
0198   0543 DD            push bl
0199   0544 07 4F 05      call putchar
0200   0547 51 01 00      add sp, 1
0201   054A             ; --- END FUNCTION CALL
0202   054A 0A 11 05      jmp _while9_cond
0203   054D             _while9_exit:
0204   054D F9            leave
0205   054E 09            ret
0206   054F             
0207   054F             putchar:
0208   054F F8 00 00      enter 0 ; (push bp; mov bp, sp)
0209   0552             ; --- BEGIN INLINE ASM SEGMENT
0210   0552 FA 05 00      lea d, [bp + 5] ; $c
0211   0555 1E            mov al, [d]
0212   0556 23            mov ah, al
0213   0557 19 00         mov al, 0
0214   0559 05 03         syscall sys_io      ; char in AH
0215   055B             ; --- END INLINE ASM SEGMENT
0216   055B F9            leave
0217   055C 09            ret
0218   055D             ; --- END TEXT SEGMENT
0219   055D             
0220   055D             ; --- BEGIN DATA SEGMENT
0221   055D             
0222   055D 5F 05       _heap_top: .dw _heap
0223   055F 00          _heap: .db 0
0224   0560             ; --- END DATA SEGMENT
0225   0560             
0226   0560             .end
tasm: Number of errors = 0
