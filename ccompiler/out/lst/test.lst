0001   0000             ; --- FILENAME: test.c
0002   0000             ; --- DATE:     16-11-2025 at 17:19:21
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; printf("%d", 1234); 
0012   0408             ; --- START FUNCTION CALL
0013   0408 FD 2E D2 04   mov32 cb, $000004d2
0013   040C 00 00 
0014   040E FD AB         swp b
0015   0410 D8            push b
0016   0411 26 62 0D      mov b, _s0 ; "%d"
0017   0414 FD AB         swp b
0018   0416 D8            push b
0019   0417 07 26 04      call printf
0020   041A 51 04 00      add sp, 4
0021   041D             ; --- END FUNCTION CALL
0022   041D             ; return 0; 
0023   041D FD 2E 00 00   mov32 cb, $00000000
0023   0421 00 00 
0024   0423 F9            leave
0025   0424 05 0B         syscall sys_terminate_proc
0026   0426             
0027   0426             printf:
0028   0426 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0029   0429             ; char *p, *format_p; 
0030   0429 52 02 00      sub sp, 2
0031   042C 52 02 00      sub sp, 2
0032   042F             ; format_p = format; 
0033   042F FA FD FF      lea d, [bp + -3] ; $format_p
0034   0432 DA            push d
0035   0433 FA 05 00      lea d, [bp + 5] ; $format
0036   0436 2A            mov b, [d]
0037   0437 38 00 00      mov c, 0
0038   043A E7            pop d
0039   043B FD 43         mov [d], b
0040   043D             ; p = &format + 2; 
0041   043D FA FF FF      lea d, [bp + -1] ; $p
0042   0440 DA            push d
0043   0441 FA 05 00      lea d, [bp + 5] ; $format
0044   0444 2D            mov b, d
0045   0445             ; --- START TERMS
0046   0445 D7            push a
0047   0446 11            mov a, b
0048   0447 FD 2E 02 00   mov32 cb, $00000002
0048   044B 00 00 
0049   044D 56            add b, a
0050   044E E4            pop a
0051   044F             ; --- END TERMS
0052   044F E7            pop d
0053   0450 FD 43         mov [d], b
0054   0452             ; for(;;){ 
0055   0452             _for1_init:
0056   0452             _for1_cond:
0057   0452             _for1_block:
0058   0452             ; if(!*format_p) break; 
0059   0452             _if2_cond:
0060   0452 FA FD FF      lea d, [bp + -3] ; $format_p
0061   0455 2A            mov b, [d]
0062   0456 38 00 00      mov c, 0
0063   0459 74            mov d, b
0064   045A 32            mov bl, [d]
0065   045B A7 00         mov bh, 0
0066   045D 38 00 00      mov c, 0
0067   0460 C0 00 00      cmp b, 0
0068   0463 FD 71         seq ; !
0069   0465 C0 00 00      cmp b, 0
0070   0468 C6 71 04      je _if2_else
0071   046B             _if2_TRUE:
0072   046B             ; break; 
0073   046B 0A 16 07      jmp _for1_exit ; for break
0074   046E 0A 03 07      jmp _if2_exit
0075   0471             _if2_else:
0076   0471             ; if(*format_p == '%'){ 
0077   0471             _if3_cond:
0078   0471 FA FD FF      lea d, [bp + -3] ; $format_p
0079   0474 2A            mov b, [d]
0080   0475 38 00 00      mov c, 0
0081   0478 74            mov d, b
0082   0479 32            mov bl, [d]
0083   047A A7 00         mov bh, 0
0084   047C 38 00 00      mov c, 0
0085   047F             ; --- START RELATIONAL
0086   047F D7            push a
0087   0480 11            mov a, b
0088   0481 FD 2E 25 00   mov32 cb, $00000025
0088   0485 00 00 
0089   0487 B0            cmp a, b
0090   0488 FD 71         seq ; ==
0091   048A E4            pop a
0092   048B             ; --- END RELATIONAL
0093   048B C0 00 00      cmp b, 0
0094   048E C6 EE 06      je _if3_else
0095   0491             _if3_TRUE:
0096   0491             ; format_p++; 
0097   0491 FA FD FF      lea d, [bp + -3] ; $format_p
0098   0494 2A            mov b, [d]
0099   0495 38 00 00      mov c, 0
0100   0498 FD 77         inc b
0101   049A FA FD FF      lea d, [bp + -3] ; $format_p
0102   049D FD 43         mov [d], b
0103   049F FD 7D         dec b
0104   04A1             ; switch(*format_p){ 
0105   04A1             _switch4_expr:
0106   04A1 FA FD FF      lea d, [bp + -3] ; $format_p
0107   04A4 2A            mov b, [d]
0108   04A5 38 00 00      mov c, 0
0109   04A8 74            mov d, b
0110   04A9 32            mov bl, [d]
0111   04AA A7 00         mov bh, 0
0112   04AC 38 00 00      mov c, 0
0113   04AF             _switch4_comparisons:
0114   04AF C1 6C         cmp bl, $6c
0115   04B1 C6 E2 04      je _switch4_case0
0116   04B4 C1 4C         cmp bl, $4c
0117   04B6 C6 E2 04      je _switch4_case1
0118   04B9 C1 64         cmp bl, $64
0119   04BB C6 F2 05      je _switch4_case2
0120   04BE C1 69         cmp bl, $69
0121   04C0 C6 F2 05      je _switch4_case3
0122   04C3 C1 75         cmp bl, $75
0123   04C5 C6 22 06      je _switch4_case4
0124   04C8 C1 78         cmp bl, $78
0125   04CA C6 52 06      je _switch4_case5
0126   04CD C1 70         cmp bl, $70
0127   04CF C6 52 06      je _switch4_case6
0128   04D2 C1 63         cmp bl, $63
0129   04D4 C6 82 06      je _switch4_case7
0130   04D7 C1 73         cmp bl, $73
0131   04D9 C6 B2 06      je _switch4_case8
0132   04DC 0A DF 06      jmp _switch4_default
0133   04DF 0A EB 06      jmp _switch4_exit
0134   04E2             _switch4_case0:
0135   04E2             _switch4_case1:
0136   04E2             ; format_p++; 
0137   04E2 FA FD FF      lea d, [bp + -3] ; $format_p
0138   04E5 2A            mov b, [d]
0139   04E6 38 00 00      mov c, 0
0140   04E9 FD 77         inc b
0141   04EB FA FD FF      lea d, [bp + -3] ; $format_p
0142   04EE FD 43         mov [d], b
0143   04F0 FD 7D         dec b
0144   04F2             ; if(*format_p == 'd' || *format_p == 'i') 
0145   04F2             _if5_cond:
0146   04F2 FA FD FF      lea d, [bp + -3] ; $format_p
0147   04F5 2A            mov b, [d]
0148   04F6 38 00 00      mov c, 0
0149   04F9 74            mov d, b
0150   04FA 32            mov bl, [d]
0151   04FB A7 00         mov bh, 0
0152   04FD 38 00 00      mov c, 0
0153   0500             ; --- START RELATIONAL
0154   0500 D7            push a
0155   0501 11            mov a, b
0156   0502 FD 2E 64 00   mov32 cb, $00000064
0156   0506 00 00 
0157   0508 B0            cmp a, b
0158   0509 FD 71         seq ; ==
0159   050B E4            pop a
0160   050C             ; --- END RELATIONAL
0161   050C             ; --- START LOGICAL OR
0162   050C D7            push a
0163   050D 11            mov a, b
0164   050E FA FD FF      lea d, [bp + -3] ; $format_p
0165   0511 2A            mov b, [d]
0166   0512 38 00 00      mov c, 0
0167   0515 74            mov d, b
0168   0516 32            mov bl, [d]
0169   0517 A7 00         mov bh, 0
0170   0519 38 00 00      mov c, 0
0171   051C             ; --- START RELATIONAL
0172   051C D7            push a
0173   051D 11            mov a, b
0174   051E FD 2E 69 00   mov32 cb, $00000069
0174   0522 00 00 
0175   0524 B0            cmp a, b
0176   0525 FD 71         seq ; ==
0177   0527 E4            pop a
0178   0528             ; --- END RELATIONAL
0179   0528 FD A8         sor a, b ; ||
0180   052A E4            pop a
0181   052B             ; --- END LOGICAL OR
0182   052B C0 00 00      cmp b, 0
0183   052E C6 4F 05      je _if5_else
0184   0531             _if5_TRUE:
0185   0531             ; print_signed_long(*(long int*)p); 
0186   0531             ; --- START FUNCTION CALL
0187   0531 FA FF FF      lea d, [bp + -1] ; $p
0188   0534 2A            mov b, [d]
0189   0535 38 00 00      mov c, 0
0190   0538 74            mov d, b
0191   0539 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0192   053C FD 39         mov c, b ; And place it into C
0193   053E 2A            mov b, [d] ; Lower Word in B
0194   053F 12            mov a, c
0195   0540 FD AA         swp a
0196   0542 D7            push a
0197   0543 FD AB         swp b
0198   0545 D8            push b
0199   0546 07 18 07      call print_signed_long
0200   0549 51 04 00      add sp, 4
0201   054C             ; --- END FUNCTION CALL
0202   054C 0A D7 05      jmp _if5_exit
0203   054F             _if5_else:
0204   054F             ; if(*format_p == 'u') 
0205   054F             _if6_cond:
0206   054F FA FD FF      lea d, [bp + -3] ; $format_p
0207   0552 2A            mov b, [d]
0208   0553 38 00 00      mov c, 0
0209   0556 74            mov d, b
0210   0557 32            mov bl, [d]
0211   0558 A7 00         mov bh, 0
0212   055A 38 00 00      mov c, 0
0213   055D             ; --- START RELATIONAL
0214   055D D7            push a
0215   055E 11            mov a, b
0216   055F FD 2E 75 00   mov32 cb, $00000075
0216   0563 00 00 
0217   0565 B0            cmp a, b
0218   0566 FD 71         seq ; ==
0219   0568 E4            pop a
0220   0569             ; --- END RELATIONAL
0221   0569 C0 00 00      cmp b, 0
0222   056C C6 8D 05      je _if6_else
0223   056F             _if6_TRUE:
0224   056F             ; print_unsigned_long(*(unsigned long int*)p); 
0225   056F             ; --- START FUNCTION CALL
0226   056F FA FF FF      lea d, [bp + -1] ; $p
0227   0572 2A            mov b, [d]
0228   0573 38 00 00      mov c, 0
0229   0576 74            mov d, b
0230   0577 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0231   057A FD 39         mov c, b ; And place it into C
0232   057C 2A            mov b, [d] ; Lower Word in B
0233   057D 12            mov a, c
0234   057E FD AA         swp a
0235   0580 D7            push a
0236   0581 FD AB         swp b
0237   0583 D8            push b
0238   0584 07 EF 08      call print_unsigned_long
0239   0587 51 04 00      add sp, 4
0240   058A             ; --- END FUNCTION CALL
0241   058A 0A D7 05      jmp _if6_exit
0242   058D             _if6_else:
0243   058D             ; if(*format_p == 'x') 
0244   058D             _if7_cond:
0245   058D FA FD FF      lea d, [bp + -3] ; $format_p
0246   0590 2A            mov b, [d]
0247   0591 38 00 00      mov c, 0
0248   0594 74            mov d, b
0249   0595 32            mov bl, [d]
0250   0596 A7 00         mov bh, 0
0251   0598 38 00 00      mov c, 0
0252   059B             ; --- START RELATIONAL
0253   059B D7            push a
0254   059C 11            mov a, b
0255   059D FD 2E 78 00   mov32 cb, $00000078
0255   05A1 00 00 
0256   05A3 B0            cmp a, b
0257   05A4 FD 71         seq ; ==
0258   05A6 E4            pop a
0259   05A7             ; --- END RELATIONAL
0260   05A7 C0 00 00      cmp b, 0
0261   05AA C6 CB 05      je _if7_else
0262   05AD             _if7_TRUE:
0263   05AD             ; printx32(*(long int *)p); 
0264   05AD             ; --- START FUNCTION CALL
0265   05AD FA FF FF      lea d, [bp + -1] ; $p
0266   05B0 2A            mov b, [d]
0267   05B1 38 00 00      mov c, 0
0268   05B4 74            mov d, b
0269   05B5 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0270   05B8 FD 39         mov c, b ; And place it into C
0271   05BA 2A            mov b, [d] ; Lower Word in B
0272   05BB 12            mov a, c
0273   05BC FD AA         swp a
0274   05BE D7            push a
0275   05BF FD AB         swp b
0276   05C1 D8            push b
0277   05C2 07 1A 0A      call printx32
0278   05C5 51 04 00      add sp, 4
0279   05C8             ; --- END FUNCTION CALL
0280   05C8 0A D7 05      jmp _if7_exit
0281   05CB             _if7_else:
0282   05CB             ; err("Unexpected format in printf."); 
0283   05CB             ; --- START FUNCTION CALL
0284   05CB 26 65 0D      mov b, _s1 ; "Unexpected format in printf."
0285   05CE FD AB         swp b
0286   05D0 D8            push b
0287   05D1 07 7A 0A      call err
0288   05D4 51 02 00      add sp, 2
0289   05D7             ; --- END FUNCTION CALL
0290   05D7             _if7_exit:
0291   05D7             _if6_exit:
0292   05D7             _if5_exit:
0293   05D7             ; p = p + 4; 
0294   05D7 FA FF FF      lea d, [bp + -1] ; $p
0295   05DA DA            push d
0296   05DB FA FF FF      lea d, [bp + -1] ; $p
0297   05DE 2A            mov b, [d]
0298   05DF 38 00 00      mov c, 0
0299   05E2             ; --- START TERMS
0300   05E2 D7            push a
0301   05E3 11            mov a, b
0302   05E4 FD 2E 04 00   mov32 cb, $00000004
0302   05E8 00 00 
0303   05EA 56            add b, a
0304   05EB E4            pop a
0305   05EC             ; --- END TERMS
0306   05EC E7            pop d
0307   05ED FD 43         mov [d], b
0308   05EF             ; break; 
0309   05EF 0A EB 06      jmp _switch4_exit ; case break
0310   05F2             _switch4_case2:
0311   05F2             _switch4_case3:
0312   05F2             ; print_signed(*(int*)p); 
0313   05F2             ; --- START FUNCTION CALL
0314   05F2 FA FF FF      lea d, [bp + -1] ; $p
0315   05F5 2A            mov b, [d]
0316   05F6 38 00 00      mov c, 0
0317   05F9 74            mov d, b
0318   05FA 2A            mov b, [d]
0319   05FB 38 00 00      mov c, 0
0320   05FE FD AB         swp b
0321   0600 D8            push b
0322   0601 07 A8 0A      call print_signed
0323   0604 51 02 00      add sp, 2
0324   0607             ; --- END FUNCTION CALL
0325   0607             ; p = p + 2; 
0326   0607 FA FF FF      lea d, [bp + -1] ; $p
0327   060A DA            push d
0328   060B FA FF FF      lea d, [bp + -1] ; $p
0329   060E 2A            mov b, [d]
0330   060F 38 00 00      mov c, 0
0331   0612             ; --- START TERMS
0332   0612 D7            push a
0333   0613 11            mov a, b
0334   0614 FD 2E 02 00   mov32 cb, $00000002
0334   0618 00 00 
0335   061A 56            add b, a
0336   061B E4            pop a
0337   061C             ; --- END TERMS
0338   061C E7            pop d
0339   061D FD 43         mov [d], b
0340   061F             ; break; 
0341   061F 0A EB 06      jmp _switch4_exit ; case break
0342   0622             _switch4_case4:
0343   0622             ; print_unsigned(*(unsigned int*)p); 
0344   0622             ; --- START FUNCTION CALL
0345   0622 FA FF FF      lea d, [bp + -1] ; $p
0346   0625 2A            mov b, [d]
0347   0626 38 00 00      mov c, 0
0348   0629 74            mov d, b
0349   062A 2A            mov b, [d]
0350   062B 38 00 00      mov c, 0
0351   062E FD AB         swp b
0352   0630 D8            push b
0353   0631 07 0B 0C      call print_unsigned
0354   0634 51 02 00      add sp, 2
0355   0637             ; --- END FUNCTION CALL
0356   0637             ; p = p + 2; 
0357   0637 FA FF FF      lea d, [bp + -1] ; $p
0358   063A DA            push d
0359   063B FA FF FF      lea d, [bp + -1] ; $p
0360   063E 2A            mov b, [d]
0361   063F 38 00 00      mov c, 0
0362   0642             ; --- START TERMS
0363   0642 D7            push a
0364   0643 11            mov a, b
0365   0644 FD 2E 02 00   mov32 cb, $00000002
0365   0648 00 00 
0366   064A 56            add b, a
0367   064B E4            pop a
0368   064C             ; --- END TERMS
0369   064C E7            pop d
0370   064D FD 43         mov [d], b
0371   064F             ; break; 
0372   064F 0A EB 06      jmp _switch4_exit ; case break
0373   0652             _switch4_case5:
0374   0652             _switch4_case6:
0375   0652             ; printx16(*(int*)p); 
0376   0652             ; --- START FUNCTION CALL
0377   0652 FA FF FF      lea d, [bp + -1] ; $p
0378   0655 2A            mov b, [d]
0379   0656 38 00 00      mov c, 0
0380   0659 74            mov d, b
0381   065A 2A            mov b, [d]
0382   065B 38 00 00      mov c, 0
0383   065E FD AB         swp b
0384   0660 D8            push b
0385   0661 07 10 0D      call printx16
0386   0664 51 02 00      add sp, 2
0387   0667             ; --- END FUNCTION CALL
0388   0667             ; p = p + 2; 
0389   0667 FA FF FF      lea d, [bp + -1] ; $p
0390   066A DA            push d
0391   066B FA FF FF      lea d, [bp + -1] ; $p
0392   066E 2A            mov b, [d]
0393   066F 38 00 00      mov c, 0
0394   0672             ; --- START TERMS
0395   0672 D7            push a
0396   0673 11            mov a, b
0397   0674 FD 2E 02 00   mov32 cb, $00000002
0397   0678 00 00 
0398   067A 56            add b, a
0399   067B E4            pop a
0400   067C             ; --- END TERMS
0401   067C E7            pop d
0402   067D FD 43         mov [d], b
0403   067F             ; break; 
0404   067F 0A EB 06      jmp _switch4_exit ; case break
0405   0682             _switch4_case7:
0406   0682             ; putchar(*(char*)p); 
0407   0682             ; --- START FUNCTION CALL
0408   0682 FA FF FF      lea d, [bp + -1] ; $p
0409   0685 2A            mov b, [d]
0410   0686 38 00 00      mov c, 0
0411   0689 74            mov d, b
0412   068A 32            mov bl, [d]
0413   068B A7 00         mov bh, 0
0414   068D 38 00 00      mov c, 0
0415   0690 DD            push bl
0416   0691 07 E1 08      call putchar
0417   0694 51 01 00      add sp, 1
0418   0697             ; --- END FUNCTION CALL
0419   0697             ; p = p + 2; 
0420   0697 FA FF FF      lea d, [bp + -1] ; $p
0421   069A DA            push d
0422   069B FA FF FF      lea d, [bp + -1] ; $p
0423   069E 2A            mov b, [d]
0424   069F 38 00 00      mov c, 0
0425   06A2             ; --- START TERMS
0426   06A2 D7            push a
0427   06A3 11            mov a, b
0428   06A4 FD 2E 02 00   mov32 cb, $00000002
0428   06A8 00 00 
0429   06AA 56            add b, a
0430   06AB E4            pop a
0431   06AC             ; --- END TERMS
0432   06AC E7            pop d
0433   06AD FD 43         mov [d], b
0434   06AF             ; break; 
0435   06AF 0A EB 06      jmp _switch4_exit ; case break
0436   06B2             _switch4_case8:
0437   06B2             ; print(*(char**)p); 
0438   06B2             ; --- START FUNCTION CALL
0439   06B2 FA FF FF      lea d, [bp + -1] ; $p
0440   06B5 2A            mov b, [d]
0441   06B6 38 00 00      mov c, 0
0442   06B9 74            mov d, b
0443   06BA 2A            mov b, [d]
0444   06BB FD AB         swp b
0445   06BD D8            push b
0446   06BE 07 8F 0A      call print
0447   06C1 51 02 00      add sp, 2
0448   06C4             ; --- END FUNCTION CALL
0449   06C4             ; p = p + 2; 
0450   06C4 FA FF FF      lea d, [bp + -1] ; $p
0451   06C7 DA            push d
0452   06C8 FA FF FF      lea d, [bp + -1] ; $p
0453   06CB 2A            mov b, [d]
0454   06CC 38 00 00      mov c, 0
0455   06CF             ; --- START TERMS
0456   06CF D7            push a
0457   06D0 11            mov a, b
0458   06D1 FD 2E 02 00   mov32 cb, $00000002
0458   06D5 00 00 
0459   06D7 56            add b, a
0460   06D8 E4            pop a
0461   06D9             ; --- END TERMS
0462   06D9 E7            pop d
0463   06DA FD 43         mov [d], b
0464   06DC             ; break; 
0465   06DC 0A EB 06      jmp _switch4_exit ; case break
0466   06DF             _switch4_default:
0467   06DF             ; print("Error: Unknown argument type.\n"); 
0468   06DF             ; --- START FUNCTION CALL
0469   06DF 26 82 0D      mov b, _s2 ; "Error: Unknown argument type.\n"
0470   06E2 FD AB         swp b
0471   06E4 D8            push b
0472   06E5 07 8F 0A      call print
0473   06E8 51 02 00      add sp, 2
0474   06EB             ; --- END FUNCTION CALL
0475   06EB             _switch4_exit:
0476   06EB 0A 03 07      jmp _if3_exit
0477   06EE             _if3_else:
0478   06EE             ; putchar(*format_p); 
0479   06EE             ; --- START FUNCTION CALL
0480   06EE FA FD FF      lea d, [bp + -3] ; $format_p
0481   06F1 2A            mov b, [d]
0482   06F2 38 00 00      mov c, 0
0483   06F5 74            mov d, b
0484   06F6 32            mov bl, [d]
0485   06F7 A7 00         mov bh, 0
0486   06F9 38 00 00      mov c, 0
0487   06FC DD            push bl
0488   06FD 07 E1 08      call putchar
0489   0700 51 01 00      add sp, 1
0490   0703             ; --- END FUNCTION CALL
0491   0703             _if3_exit:
0492   0703             _if2_exit:
0493   0703             ; format_p++; 
0494   0703 FA FD FF      lea d, [bp + -3] ; $format_p
0495   0706 2A            mov b, [d]
0496   0707 38 00 00      mov c, 0
0497   070A FD 77         inc b
0498   070C FA FD FF      lea d, [bp + -3] ; $format_p
0499   070F FD 43         mov [d], b
0500   0711 FD 7D         dec b
0501   0713             _for1_update:
0502   0713 0A 52 04      jmp _for1_cond
0503   0716             _for1_exit:
0504   0716 F9            leave
0505   0717 09            ret
0506   0718             
0507   0718             print_signed_long:
0508   0718 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0509   071B             ; char digits[10];  // fits 2,147,483,647 
0510   071B 52 0A 00      sub sp, 10
0511   071E             ; int i = 0; 
0512   071E 52 02 00      sub sp, 2
0513   0721             ; --- START LOCAL VAR INITIALIZATION
0514   0721 FA F5 FF      lea d, [bp + -11] ; $i
0515   0724 DA            push d
0516   0725 FD 2E 00 00   mov32 cb, $00000000
0516   0729 00 00 
0517   072B E7            pop d
0518   072C FD 43         mov [d], b
0519   072E             ; --- END LOCAL VAR INITIALIZATION
0520   072E             ; unsigned long int absval; 
0521   072E 52 04 00      sub sp, 4
0522   0731             ; if (num < 0) { 
0523   0731             _if8_cond:
0524   0731 FA 05 00      lea d, [bp + 5] ; $num
0525   0734 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0526   0737 FD 39         mov c, b ; And place it into C
0527   0739 2A            mov b, [d] ; Lower Word in B
0528   073A             ; --- START RELATIONAL
0529   073A D7            push a
0530   073B FD D8         push g
0531   073D 11            mov a, b
0532   073E FD 7A         mov g, c
0533   0740 FD 2E 00 00   mov32 cb, $00000000
0533   0744 00 00 
0534   0746 38 00 00      mov c, 0
0535   0749 FD AF         cmp32 ga, cb
0536   074B FD 73         slt ; <
0537   074D FD F1         pop g
0538   074F E4            pop a
0539   0750             ; --- END RELATIONAL
0540   0750 C0 00 00      cmp b, 0
0541   0753 C6 B2 07      je _if8_else
0542   0756             _if8_TRUE:
0543   0756             ; putchar('-'); 
0544   0756             ; --- START FUNCTION CALL
0545   0756 FD 2E 2D 00   mov32 cb, $0000002d
0545   075A 00 00 
0546   075C DD            push bl
0547   075D 07 E1 08      call putchar
0548   0760 51 01 00      add sp, 1
0549   0763             ; --- END FUNCTION CALL
0550   0763             ; absval = (unsigned long int)(-(num + 1)) + 1; 
0551   0763 FA F1 FF      lea d, [bp + -15] ; $absval
0552   0766 DA            push d
0553   0767 FA 05 00      lea d, [bp + 5] ; $num
0554   076A 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0555   076D FD 39         mov c, b ; And place it into C
0556   076F 2A            mov b, [d] ; Lower Word in B
0557   0770             ; --- START TERMS
0558   0770 D7            push a
0559   0771 FD D8         push g
0560   0773 11            mov a, b
0561   0774 FD 7A         mov g, c
0562   0776 FD 2E 01 00   mov32 cb, $00000001
0562   077A 00 00 
0563   077C 38 00 00      mov c, 0
0564   077F FD 15         add32 cb, ga
0565   0781 FD F1         pop g
0566   0783 E4            pop a
0567   0784             ; --- END TERMS
0568   0784 12            mov a, c
0569   0785 95            not a
0570   0786 97            not b
0571   0787 55 01 00      add b, 1
0572   078A 5B 00 00      adc a, 0
0573   078D 39            mov c, a
0574   078E A7 00         mov bh, 0
0575   0790 38 00 00      mov c, 0
0576   0793             ; --- START TERMS
0577   0793 D7            push a
0578   0794 FD D8         push g
0579   0796 11            mov a, b
0580   0797 FD 7A         mov g, c
0581   0799 FD 2E 01 00   mov32 cb, $00000001
0581   079D 00 00 
0582   079F 38 00 00      mov c, 0
0583   07A2 FD 15         add32 cb, ga
0584   07A4 FD F1         pop g
0585   07A6 E4            pop a
0586   07A7             ; --- END TERMS
0587   07A7 E7            pop d
0588   07A8 FD 43         mov [d], b
0589   07AA 28            mov b, c
0590   07AB FD 44 02 00   mov [d + 2], b
0591   07AF 0A CC 07      jmp _if8_exit
0592   07B2             _if8_else:
0593   07B2             ; absval = (unsigned long int)num; 
0594   07B2 FA F1 FF      lea d, [bp + -15] ; $absval
0595   07B5 DA            push d
0596   07B6 FA 05 00      lea d, [bp + 5] ; $num
0597   07B9 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0598   07BC FD 39         mov c, b ; And place it into C
0599   07BE 2A            mov b, [d] ; Lower Word in B
0600   07BF A7 00         mov bh, 0
0601   07C1 38 00 00      mov c, 0
0602   07C4 E7            pop d
0603   07C5 FD 43         mov [d], b
0604   07C7 28            mov b, c
0605   07C8 FD 44 02 00   mov [d + 2], b
0606   07CC             _if8_exit:
0607   07CC             ; if (absval == 0) { 
0608   07CC             _if9_cond:
0609   07CC FA F1 FF      lea d, [bp + -15] ; $absval
0610   07CF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0611   07D2 FD 39         mov c, b ; And place it into C
0612   07D4 2A            mov b, [d] ; Lower Word in B
0613   07D5             ; --- START RELATIONAL
0614   07D5 D7            push a
0615   07D6 FD D8         push g
0616   07D8 11            mov a, b
0617   07D9 FD 7A         mov g, c
0618   07DB FD 2E 00 00   mov32 cb, $00000000
0618   07DF 00 00 
0619   07E1 38 00 00      mov c, 0
0620   07E4 FD AF         cmp32 ga, cb
0621   07E6 FD 71         seq ; ==
0622   07E8 FD F1         pop g
0623   07EA E4            pop a
0624   07EB             ; --- END RELATIONAL
0625   07EB C0 00 00      cmp b, 0
0626   07EE C6 03 08      je _if9_exit
0627   07F1             _if9_TRUE:
0628   07F1             ; putchar('0'); 
0629   07F1             ; --- START FUNCTION CALL
0630   07F1 FD 2E 30 00   mov32 cb, $00000030
0630   07F5 00 00 
0631   07F7 DD            push bl
0632   07F8 07 E1 08      call putchar
0633   07FB 51 01 00      add sp, 1
0634   07FE             ; --- END FUNCTION CALL
0635   07FE             ; return; 
0636   07FE F9            leave
0637   07FF 09            ret
0638   0800 0A 03 08      jmp _if9_exit
0639   0803             _if9_exit:
0640   0803             ; while (absval > 0) { 
0641   0803             _while10_cond:
0642   0803 FA F1 FF      lea d, [bp + -15] ; $absval
0643   0806 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0644   0809 FD 39         mov c, b ; And place it into C
0645   080B 2A            mov b, [d] ; Lower Word in B
0646   080C             ; --- START RELATIONAL
0647   080C D7            push a
0648   080D FD D8         push g
0649   080F 11            mov a, b
0650   0810 FD 7A         mov g, c
0651   0812 FD 2E 00 00   mov32 cb, $00000000
0651   0816 00 00 
0652   0818 38 00 00      mov c, 0
0653   081B FD AF         cmp32 ga, cb
0654   081D FD 81         sgu
0655   081F FD F1         pop g
0656   0821 E4            pop a
0657   0822             ; --- END RELATIONAL
0658   0822 C0 00 00      cmp b, 0
0659   0825 C6 A3 08      je _while10_exit
0660   0828             _while10_block:
0661   0828             ; digits[i++] = '0' + (absval % 10); 
0662   0828 FA F7 FF      lea d, [bp + -9] ; $digits
0663   082B D7            push a
0664   082C DA            push d
0665   082D FA F5 FF      lea d, [bp + -11] ; $i
0666   0830 2A            mov b, [d]
0667   0831 38 00 00      mov c, 0
0668   0834 11            mov a, b
0669   0835 FD 77         inc b
0670   0837 FA F5 FF      lea d, [bp + -11] ; $i
0671   083A FD 43         mov [d], b
0672   083C 27            mov b, a
0673   083D E7            pop d
0674   083E 5A            add d, b
0675   083F E4            pop a
0676   0840 DA            push d
0677   0841 FD 2E 30 00   mov32 cb, $00000030
0677   0845 00 00 
0678   0847             ; --- START TERMS
0679   0847 D7            push a
0680   0848 11            mov a, b
0681   0849 FA F1 FF      lea d, [bp + -15] ; $absval
0682   084C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0683   084F FD 39         mov c, b ; And place it into C
0684   0851 2A            mov b, [d] ; Lower Word in B
0685   0852             ; --- START FACTORS
0686   0852 D7            push a
0687   0853 FD D8         push g
0688   0855 11            mov a, b
0689   0856 FD 7A         mov g, c
0690   0858 FD 2E 0A 00   mov32 cb, $0000000a
0690   085C 00 00 
0691   085E FD D8         push g ; save 'g' as the div instruction uses it
0692   0860 AE            div a, b ; %, a: quotient, b: remainder
0693   0861 11            mov a, b
0694   0862 FD F1         pop g
0695   0864 FD 38         mov c, g
0696   0866 27            mov b, a
0697   0867 FD F1         pop g
0698   0869 E4            pop a
0699   086A             ; --- END FACTORS
0700   086A FD 22 00 00   mov g, 0
0701   086E FD 15         add32 cb, ga
0702   0870 E4            pop a
0703   0871             ; --- END TERMS
0704   0871 E7            pop d
0705   0872 FD 3E         mov [d], bl
0706   0874             ; absval = absval / 10; 
0707   0874 FA F1 FF      lea d, [bp + -15] ; $absval
0708   0877 DA            push d
0709   0878 FA F1 FF      lea d, [bp + -15] ; $absval
0710   087B 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0711   087E FD 39         mov c, b ; And place it into C
0712   0880 2A            mov b, [d] ; Lower Word in B
0713   0881             ; --- START FACTORS
0714   0881 D7            push a
0715   0882 FD D8         push g
0716   0884 11            mov a, b
0717   0885 FD 7A         mov g, c
0718   0887 FD 2E 0A 00   mov32 cb, $0000000a
0718   088B 00 00 
0719   088D FD D8         push g ; save 'g' as the div instruction uses it
0720   088F AE            div a, b ; /, a: quotient, b: remainder
0721   0890 FD F1         pop g
0722   0892 FD 38         mov c, g
0723   0894 27            mov b, a
0724   0895 FD F1         pop g
0725   0897 E4            pop a
0726   0898             ; --- END FACTORS
0727   0898 E7            pop d
0728   0899 FD 43         mov [d], b
0729   089B 28            mov b, c
0730   089C FD 44 02 00   mov [d + 2], b
0731   08A0 0A 03 08      jmp _while10_cond
0732   08A3             _while10_exit:
0733   08A3             ; while (i > 0) { 
0734   08A3             _while17_cond:
0735   08A3 FA F5 FF      lea d, [bp + -11] ; $i
0736   08A6 2A            mov b, [d]
0737   08A7 38 00 00      mov c, 0
0738   08AA             ; --- START RELATIONAL
0739   08AA D7            push a
0740   08AB 11            mov a, b
0741   08AC FD 2E 00 00   mov32 cb, $00000000
0741   08B0 00 00 
0742   08B2 B0            cmp a, b
0743   08B3 FD 7F         sgt ; >
0744   08B5 E4            pop a
0745   08B6             ; --- END RELATIONAL
0746   08B6 C0 00 00      cmp b, 0
0747   08B9 C6 DF 08      je _while17_exit
0748   08BC             _while17_block:
0749   08BC             ; putchar(digits[--i]); 
0750   08BC             ; --- START FUNCTION CALL
0751   08BC FA F7 FF      lea d, [bp + -9] ; $digits
0752   08BF D7            push a
0753   08C0 DA            push d
0754   08C1 FA F5 FF      lea d, [bp + -11] ; $i
0755   08C4 2A            mov b, [d]
0756   08C5 FD 7D         dec b
0757   08C7 FA F5 FF      lea d, [bp + -11] ; $i
0758   08CA FD 43         mov [d], b
0759   08CC E7            pop d
0760   08CD 5A            add d, b
0761   08CE E4            pop a
0762   08CF 32            mov bl, [d]
0763   08D0 A7 00         mov bh, 0
0764   08D2 38 00 00      mov c, 0
0765   08D5 DD            push bl
0766   08D6 07 E1 08      call putchar
0767   08D9 51 01 00      add sp, 1
0768   08DC             ; --- END FUNCTION CALL
0769   08DC 0A A3 08      jmp _while17_cond
0770   08DF             _while17_exit:
0771   08DF F9            leave
0772   08E0 09            ret
0773   08E1             
0774   08E1             putchar:
0775   08E1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0776   08E4             ; --- BEGIN INLINE ASM SEGMENT
0777   08E4 FA 05 00      lea d, [bp + 5] ; $c
0778   08E7 1E            mov al, [d]
0779   08E8 23            mov ah, al
0780   08E9 19 00         mov al, 0
0781   08EB 05 03         syscall sys_io      ; char in AH
0782   08ED             ; --- END INLINE ASM SEGMENT
0783   08ED F9            leave
0784   08EE 09            ret
0785   08EF             
0786   08EF             print_unsigned_long:
0787   08EF F8 00 00      enter 0 ; (push bp; mov bp, sp)
0788   08F2             ; char digits[10]; 
0789   08F2 52 0A 00      sub sp, 10
0790   08F5             ; int i = 0; 
0791   08F5 52 02 00      sub sp, 2
0792   08F8             ; --- START LOCAL VAR INITIALIZATION
0793   08F8 FA F5 FF      lea d, [bp + -11] ; $i
0794   08FB DA            push d
0795   08FC FD 2E 00 00   mov32 cb, $00000000
0795   0900 00 00 
0796   0902 E7            pop d
0797   0903 FD 43         mov [d], b
0798   0905             ; --- END LOCAL VAR INITIALIZATION
0799   0905             ; if(num == 0){ 
0800   0905             _if18_cond:
0801   0905 FA 05 00      lea d, [bp + 5] ; $num
0802   0908 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0803   090B FD 39         mov c, b ; And place it into C
0804   090D 2A            mov b, [d] ; Lower Word in B
0805   090E             ; --- START RELATIONAL
0806   090E D7            push a
0807   090F FD D8         push g
0808   0911 11            mov a, b
0809   0912 FD 7A         mov g, c
0810   0914 FD 2E 00 00   mov32 cb, $00000000
0810   0918 00 00 
0811   091A 38 00 00      mov c, 0
0812   091D FD AF         cmp32 ga, cb
0813   091F FD 71         seq ; ==
0814   0921 FD F1         pop g
0815   0923 E4            pop a
0816   0924             ; --- END RELATIONAL
0817   0924 C0 00 00      cmp b, 0
0818   0927 C6 3C 09      je _if18_exit
0819   092A             _if18_TRUE:
0820   092A             ; putchar('0'); 
0821   092A             ; --- START FUNCTION CALL
0822   092A FD 2E 30 00   mov32 cb, $00000030
0822   092E 00 00 
0823   0930 DD            push bl
0824   0931 07 E1 08      call putchar
0825   0934 51 01 00      add sp, 1
0826   0937             ; --- END FUNCTION CALL
0827   0937             ; return; 
0828   0937 F9            leave
0829   0938 09            ret
0830   0939 0A 3C 09      jmp _if18_exit
0831   093C             _if18_exit:
0832   093C             ; while (num > 0) { 
0833   093C             _while19_cond:
0834   093C FA 05 00      lea d, [bp + 5] ; $num
0835   093F 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0836   0942 FD 39         mov c, b ; And place it into C
0837   0944 2A            mov b, [d] ; Lower Word in B
0838   0945             ; --- START RELATIONAL
0839   0945 D7            push a
0840   0946 FD D8         push g
0841   0948 11            mov a, b
0842   0949 FD 7A         mov g, c
0843   094B FD 2E 00 00   mov32 cb, $00000000
0843   094F 00 00 
0844   0951 38 00 00      mov c, 0
0845   0954 FD AF         cmp32 ga, cb
0846   0956 FD 81         sgu
0847   0958 FD F1         pop g
0848   095A E4            pop a
0849   095B             ; --- END RELATIONAL
0850   095B C0 00 00      cmp b, 0
0851   095E C6 DC 09      je _while19_exit
0852   0961             _while19_block:
0853   0961             ; digits[i++] = '0' + (num % 10); 
0854   0961 FA F7 FF      lea d, [bp + -9] ; $digits
0855   0964 D7            push a
0856   0965 DA            push d
0857   0966 FA F5 FF      lea d, [bp + -11] ; $i
0858   0969 2A            mov b, [d]
0859   096A 38 00 00      mov c, 0
0860   096D 11            mov a, b
0861   096E FD 77         inc b
0862   0970 FA F5 FF      lea d, [bp + -11] ; $i
0863   0973 FD 43         mov [d], b
0864   0975 27            mov b, a
0865   0976 E7            pop d
0866   0977 5A            add d, b
0867   0978 E4            pop a
0868   0979 DA            push d
0869   097A FD 2E 30 00   mov32 cb, $00000030
0869   097E 00 00 
0870   0980             ; --- START TERMS
0871   0980 D7            push a
0872   0981 11            mov a, b
0873   0982 FA 05 00      lea d, [bp + 5] ; $num
0874   0985 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0875   0988 FD 39         mov c, b ; And place it into C
0876   098A 2A            mov b, [d] ; Lower Word in B
0877   098B             ; --- START FACTORS
0878   098B D7            push a
0879   098C FD D8         push g
0880   098E 11            mov a, b
0881   098F FD 7A         mov g, c
0882   0991 FD 2E 0A 00   mov32 cb, $0000000a
0882   0995 00 00 
0883   0997 FD D8         push g ; save 'g' as the div instruction uses it
0884   0999 AE            div a, b ; %, a: quotient, b: remainder
0885   099A 11            mov a, b
0886   099B FD F1         pop g
0887   099D FD 38         mov c, g
0888   099F 27            mov b, a
0889   09A0 FD F1         pop g
0890   09A2 E4            pop a
0891   09A3             ; --- END FACTORS
0892   09A3 FD 22 00 00   mov g, 0
0893   09A7 FD 15         add32 cb, ga
0894   09A9 E4            pop a
0895   09AA             ; --- END TERMS
0896   09AA E7            pop d
0897   09AB FD 3E         mov [d], bl
0898   09AD             ; num = num / 10; 
0899   09AD FA 05 00      lea d, [bp + 5] ; $num
0900   09B0 DA            push d
0901   09B1 FA 05 00      lea d, [bp + 5] ; $num
0902   09B4 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
0903   09B7 FD 39         mov c, b ; And place it into C
0904   09B9 2A            mov b, [d] ; Lower Word in B
0905   09BA             ; --- START FACTORS
0906   09BA D7            push a
0907   09BB FD D8         push g
0908   09BD 11            mov a, b
0909   09BE FD 7A         mov g, c
0910   09C0 FD 2E 0A 00   mov32 cb, $0000000a
0910   09C4 00 00 
0911   09C6 FD D8         push g ; save 'g' as the div instruction uses it
0912   09C8 AE            div a, b ; /, a: quotient, b: remainder
0913   09C9 FD F1         pop g
0914   09CB FD 38         mov c, g
0915   09CD 27            mov b, a
0916   09CE FD F1         pop g
0917   09D0 E4            pop a
0918   09D1             ; --- END FACTORS
0919   09D1 E7            pop d
0920   09D2 FD 43         mov [d], b
0921   09D4 28            mov b, c
0922   09D5 FD 44 02 00   mov [d + 2], b
0923   09D9 0A 3C 09      jmp _while19_cond
0924   09DC             _while19_exit:
0925   09DC             ; while (i > 0) { 
0926   09DC             _while26_cond:
0927   09DC FA F5 FF      lea d, [bp + -11] ; $i
0928   09DF 2A            mov b, [d]
0929   09E0 38 00 00      mov c, 0
0930   09E3             ; --- START RELATIONAL
0931   09E3 D7            push a
0932   09E4 11            mov a, b
0933   09E5 FD 2E 00 00   mov32 cb, $00000000
0933   09E9 00 00 
0934   09EB B0            cmp a, b
0935   09EC FD 7F         sgt ; >
0936   09EE E4            pop a
0937   09EF             ; --- END RELATIONAL
0938   09EF C0 00 00      cmp b, 0
0939   09F2 C6 18 0A      je _while26_exit
0940   09F5             _while26_block:
0941   09F5             ; putchar(digits[--i]); 
0942   09F5             ; --- START FUNCTION CALL
0943   09F5 FA F7 FF      lea d, [bp + -9] ; $digits
0944   09F8 D7            push a
0945   09F9 DA            push d
0946   09FA FA F5 FF      lea d, [bp + -11] ; $i
0947   09FD 2A            mov b, [d]
0948   09FE FD 7D         dec b
0949   0A00 FA F5 FF      lea d, [bp + -11] ; $i
0950   0A03 FD 43         mov [d], b
0951   0A05 E7            pop d
0952   0A06 5A            add d, b
0953   0A07 E4            pop a
0954   0A08 32            mov bl, [d]
0955   0A09 A7 00         mov bh, 0
0956   0A0B 38 00 00      mov c, 0
0957   0A0E DD            push bl
0958   0A0F 07 E1 08      call putchar
0959   0A12 51 01 00      add sp, 1
0960   0A15             ; --- END FUNCTION CALL
0961   0A15 0A DC 09      jmp _while26_cond
0962   0A18             _while26_exit:
0963   0A18 F9            leave
0964   0A19 09            ret
0965   0A1A             
0966   0A1A             printx32:
0967   0A1A F8 00 00      enter 0 ; (push bp; mov bp, sp)
0968   0A1D             ; --- BEGIN INLINE ASM SEGMENT
0969   0A1D FA 05 00      lea d, [bp + 5] ; $hex
0970   0A20 2B 02 00      mov b, [d+2]
0971   0A23 07 2C 0A      call print_u16x_printx32
0972   0A26 2A            mov b, [d]
0973   0A27 07 2C 0A      call print_u16x_printx32
0974   0A2A             ; --- END INLINE ASM SEGMENT
0975   0A2A             ; return; 
0976   0A2A F9            leave
0977   0A2B 09            ret
0978   0A2C             ; --- BEGIN INLINE ASM SEGMENT
0979   0A2C             print_u16x_printx32:
0980   0A2C D7            push a
0981   0A2D D8            push b
0982   0A2E DD            push bl
0983   0A2F 30            mov bl, bh
0984   0A30 07 4E 0A      call _itoa_printx32        ; convert bh to char in A
0985   0A33 2F            mov bl, al        ; save al
0986   0A34 19 00         mov al, 0
0987   0A36 05 03         syscall sys_io        ; display AH
0988   0A38 24            mov ah, bl        ; retrieve al
0989   0A39 19 00         mov al, 0
0990   0A3B 05 03         syscall sys_io        ; display AL
0991   0A3D EA            pop bl
0992   0A3E 07 4E 0A      call _itoa_printx32        ; convert bh to char in A
0993   0A41 2F            mov bl, al        ; save al
0994   0A42 19 00         mov al, 0
0995   0A44 05 03         syscall sys_io        ; display AH
0996   0A46 24            mov ah, bl        ; retrieve al
0997   0A47 19 00         mov al, 0
0998   0A49 05 03         syscall sys_io        ; display AL
0999   0A4B E5            pop b
1000   0A4C E4            pop a
1001   0A4D 09            ret
1002   0A4E             _itoa_printx32:
1003   0A4E DA            push d
1004   0A4F D8            push b
1005   0A50 A7 00         mov bh, 0
1006   0A52 FD A4 04      shr bl, 4  
1007   0A55 74            mov d, b
1008   0A56 1F 68 0A      mov al, [d + s_hex_digits_printx32]
1009   0A59 23            mov ah, al
1010   0A5A E5            pop b
1011   0A5B D8            push b
1012   0A5C A7 00         mov bh, 0
1013   0A5E FD 87 0F      and bl, $0F
1014   0A61 74            mov d, b
1015   0A62 1F 68 0A      mov al, [d + s_hex_digits_printx32]
1016   0A65 E5            pop b
1017   0A66 E7            pop d
1018   0A67 09            ret
1019   0A68 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
1019   0A6C 34 35 36 37 
1019   0A70 38 39 41 42 
1019   0A74 43 44 45 46 
1020   0A78             ; --- END INLINE ASM SEGMENT
1021   0A78 F9            leave
1022   0A79 09            ret
1023   0A7A             
1024   0A7A             err:
1025   0A7A F8 00 00      enter 0 ; (push bp; mov bp, sp)
1026   0A7D             ; print(e); 
1027   0A7D             ; --- START FUNCTION CALL
1028   0A7D FA 05 00      lea d, [bp + 5] ; $e
1029   0A80 2A            mov b, [d]
1030   0A81 38 00 00      mov c, 0
1031   0A84 FD AB         swp b
1032   0A86 D8            push b
1033   0A87 07 8F 0A      call print
1034   0A8A 51 02 00      add sp, 2
1035   0A8D             ; --- END FUNCTION CALL
1036   0A8D F9            leave
1037   0A8E 09            ret
1038   0A8F             
1039   0A8F             print:
1040   0A8F F8 00 00      enter 0 ; (push bp; mov bp, sp)
1041   0A92             ; --- BEGIN INLINE ASM SEGMENT
1042   0A92 FA 05 00      lea d, [bp + 5] ; $s
1043   0A95 FD 2A         mov d, [d]
1044   0A97             _puts_L1_print:
1045   0A97 1E            mov al, [d]
1046   0A98 B9 00         cmp al, 0
1047   0A9A C6 A6 0A      jz _puts_END_print
1048   0A9D 23            mov ah, al
1049   0A9E 19 00         mov al, 0
1050   0AA0 05 03         syscall sys_io
1051   0AA2 79            inc d
1052   0AA3 0A 97 0A      jmp _puts_L1_print
1053   0AA6             _puts_END_print:
1054   0AA6             ; --- END INLINE ASM SEGMENT
1055   0AA6 F9            leave
1056   0AA7 09            ret
1057   0AA8             
1058   0AA8             print_signed:
1059   0AA8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1060   0AAB             ; char digits[5];  // enough for "-32768" 
1061   0AAB 52 05 00      sub sp, 5
1062   0AAE             ; int i = 0; 
1063   0AAE 52 02 00      sub sp, 2
1064   0AB1             ; --- START LOCAL VAR INITIALIZATION
1065   0AB1 FA FA FF      lea d, [bp + -6] ; $i
1066   0AB4 DA            push d
1067   0AB5 FD 2E 00 00   mov32 cb, $00000000
1067   0AB9 00 00 
1068   0ABB E7            pop d
1069   0ABC FD 43         mov [d], b
1070   0ABE             ; --- END LOCAL VAR INITIALIZATION
1071   0ABE             ; unsigned int absval; 
1072   0ABE 52 02 00      sub sp, 2
1073   0AC1             ; if (num < 0) { 
1074   0AC1             _if27_cond:
1075   0AC1 FA 05 00      lea d, [bp + 5] ; $num
1076   0AC4 2A            mov b, [d]
1077   0AC5 38 00 00      mov c, 0
1078   0AC8             ; --- START RELATIONAL
1079   0AC8 D7            push a
1080   0AC9 11            mov a, b
1081   0ACA FD 2E 00 00   mov32 cb, $00000000
1081   0ACE 00 00 
1082   0AD0 B0            cmp a, b
1083   0AD1 FD 73         slt ; < (signed)
1084   0AD3 E4            pop a
1085   0AD4             ; --- END RELATIONAL
1086   0AD4 C0 00 00      cmp b, 0
1087   0AD7 C6 0E 0B      je _if27_else
1088   0ADA             _if27_TRUE:
1089   0ADA             ; putchar('-'); 
1090   0ADA             ; --- START FUNCTION CALL
1091   0ADA FD 2E 2D 00   mov32 cb, $0000002d
1091   0ADE 00 00 
1092   0AE0 DD            push bl
1093   0AE1 07 E1 08      call putchar
1094   0AE4 51 01 00      add sp, 1
1095   0AE7             ; --- END FUNCTION CALL
1096   0AE7             ; absval = (unsigned int)(-(num + 1)) + 1;  // safe for -32768 
1097   0AE7 FA F8 FF      lea d, [bp + -8] ; $absval
1098   0AEA DA            push d
1099   0AEB FA 05 00      lea d, [bp + 5] ; $num
1100   0AEE 2A            mov b, [d]
1101   0AEF 38 00 00      mov c, 0
1102   0AF2             ; --- START TERMS
1103   0AF2 D7            push a
1104   0AF3 11            mov a, b
1105   0AF4 FD 2E 01 00   mov32 cb, $00000001
1105   0AF8 00 00 
1106   0AFA 56            add b, a
1107   0AFB E4            pop a
1108   0AFC             ; --- END TERMS
1109   0AFC FD 97         neg b
1110   0AFE             ; --- START TERMS
1111   0AFE D7            push a
1112   0AFF 11            mov a, b
1113   0B00 FD 2E 01 00   mov32 cb, $00000001
1113   0B04 00 00 
1114   0B06 56            add b, a
1115   0B07 E4            pop a
1116   0B08             ; --- END TERMS
1117   0B08 E7            pop d
1118   0B09 FD 43         mov [d], b
1119   0B0B 0A 1C 0B      jmp _if27_exit
1120   0B0E             _if27_else:
1121   0B0E             ; absval = (unsigned int)num; 
1122   0B0E FA F8 FF      lea d, [bp + -8] ; $absval
1123   0B11 DA            push d
1124   0B12 FA 05 00      lea d, [bp + 5] ; $num
1125   0B15 2A            mov b, [d]
1126   0B16 38 00 00      mov c, 0
1127   0B19 E7            pop d
1128   0B1A FD 43         mov [d], b
1129   0B1C             _if27_exit:
1130   0B1C             ; if (absval == 0) { 
1131   0B1C             _if28_cond:
1132   0B1C FA F8 FF      lea d, [bp + -8] ; $absval
1133   0B1F 2A            mov b, [d]
1134   0B20 38 00 00      mov c, 0
1135   0B23             ; --- START RELATIONAL
1136   0B23 D7            push a
1137   0B24 11            mov a, b
1138   0B25 FD 2E 00 00   mov32 cb, $00000000
1138   0B29 00 00 
1139   0B2B B0            cmp a, b
1140   0B2C FD 71         seq ; ==
1141   0B2E E4            pop a
1142   0B2F             ; --- END RELATIONAL
1143   0B2F C0 00 00      cmp b, 0
1144   0B32 C6 47 0B      je _if28_exit
1145   0B35             _if28_TRUE:
1146   0B35             ; putchar('0'); 
1147   0B35             ; --- START FUNCTION CALL
1148   0B35 FD 2E 30 00   mov32 cb, $00000030
1148   0B39 00 00 
1149   0B3B DD            push bl
1150   0B3C 07 E1 08      call putchar
1151   0B3F 51 01 00      add sp, 1
1152   0B42             ; --- END FUNCTION CALL
1153   0B42             ; return; 
1154   0B42 F9            leave
1155   0B43 09            ret
1156   0B44 0A 47 0B      jmp _if28_exit
1157   0B47             _if28_exit:
1158   0B47             ; while (absval > 0) { 
1159   0B47             _while29_cond:
1160   0B47 FA F8 FF      lea d, [bp + -8] ; $absval
1161   0B4A 2A            mov b, [d]
1162   0B4B 38 00 00      mov c, 0
1163   0B4E             ; --- START RELATIONAL
1164   0B4E D7            push a
1165   0B4F 11            mov a, b
1166   0B50 FD 2E 00 00   mov32 cb, $00000000
1166   0B54 00 00 
1167   0B56 B0            cmp a, b
1168   0B57 FD 81         sgu ; > (unsigned)
1169   0B59 E4            pop a
1170   0B5A             ; --- END RELATIONAL
1171   0B5A C0 00 00      cmp b, 0
1172   0B5D C6 CD 0B      je _while29_exit
1173   0B60             _while29_block:
1174   0B60             ; digits[i++] = '0' + (absval % 10); 
1175   0B60 FA FC FF      lea d, [bp + -4] ; $digits
1176   0B63 D7            push a
1177   0B64 DA            push d
1178   0B65 FA FA FF      lea d, [bp + -6] ; $i
1179   0B68 2A            mov b, [d]
1180   0B69 38 00 00      mov c, 0
1181   0B6C 11            mov a, b
1182   0B6D FD 77         inc b
1183   0B6F FA FA FF      lea d, [bp + -6] ; $i
1184   0B72 FD 43         mov [d], b
1185   0B74 27            mov b, a
1186   0B75 E7            pop d
1187   0B76 5A            add d, b
1188   0B77 E4            pop a
1189   0B78 DA            push d
1190   0B79 FD 2E 30 00   mov32 cb, $00000030
1190   0B7D 00 00 
1191   0B7F             ; --- START TERMS
1192   0B7F D7            push a
1193   0B80 11            mov a, b
1194   0B81 FA F8 FF      lea d, [bp + -8] ; $absval
1195   0B84 2A            mov b, [d]
1196   0B85 38 00 00      mov c, 0
1197   0B88             ; --- START FACTORS
1198   0B88 D7            push a
1199   0B89 FD D8         push g
1200   0B8B 11            mov a, b
1201   0B8C FD 7A         mov g, c
1202   0B8E FD 2E 0A 00   mov32 cb, $0000000a
1202   0B92 00 00 
1203   0B94 FD D8         push g ; save 'g' as the div instruction uses it
1204   0B96 AE            div a, b ; %, a: quotient, b: remainder
1205   0B97 11            mov a, b
1206   0B98 FD F1         pop g
1207   0B9A FD 38         mov c, g
1208   0B9C 27            mov b, a
1209   0B9D FD F1         pop g
1210   0B9F E4            pop a
1211   0BA0             ; --- END FACTORS
1212   0BA0 56            add b, a
1213   0BA1 E4            pop a
1214   0BA2             ; --- END TERMS
1215   0BA2 E7            pop d
1216   0BA3 FD 3E         mov [d], bl
1217   0BA5             ; absval = absval / 10; 
1218   0BA5 FA F8 FF      lea d, [bp + -8] ; $absval
1219   0BA8 DA            push d
1220   0BA9 FA F8 FF      lea d, [bp + -8] ; $absval
1221   0BAC 2A            mov b, [d]
1222   0BAD 38 00 00      mov c, 0
1223   0BB0             ; --- START FACTORS
1224   0BB0 D7            push a
1225   0BB1 FD D8         push g
1226   0BB3 11            mov a, b
1227   0BB4 FD 7A         mov g, c
1228   0BB6 FD 2E 0A 00   mov32 cb, $0000000a
1228   0BBA 00 00 
1229   0BBC FD D8         push g ; save 'g' as the div instruction uses it
1230   0BBE AE            div a, b ; /, a: quotient, b: remainder
1231   0BBF FD F1         pop g
1232   0BC1 FD 38         mov c, g
1233   0BC3 27            mov b, a
1234   0BC4 FD F1         pop g
1235   0BC6 E4            pop a
1236   0BC7             ; --- END FACTORS
1237   0BC7 E7            pop d
1238   0BC8 FD 43         mov [d], b
1239   0BCA 0A 47 0B      jmp _while29_cond
1240   0BCD             _while29_exit:
1241   0BCD             ; while (i > 0) { 
1242   0BCD             _while36_cond:
1243   0BCD FA FA FF      lea d, [bp + -6] ; $i
1244   0BD0 2A            mov b, [d]
1245   0BD1 38 00 00      mov c, 0
1246   0BD4             ; --- START RELATIONAL
1247   0BD4 D7            push a
1248   0BD5 11            mov a, b
1249   0BD6 FD 2E 00 00   mov32 cb, $00000000
1249   0BDA 00 00 
1250   0BDC B0            cmp a, b
1251   0BDD FD 7F         sgt ; >
1252   0BDF E4            pop a
1253   0BE0             ; --- END RELATIONAL
1254   0BE0 C0 00 00      cmp b, 0
1255   0BE3 C6 09 0C      je _while36_exit
1256   0BE6             _while36_block:
1257   0BE6             ; putchar(digits[--i]); 
1258   0BE6             ; --- START FUNCTION CALL
1259   0BE6 FA FC FF      lea d, [bp + -4] ; $digits
1260   0BE9 D7            push a
1261   0BEA DA            push d
1262   0BEB FA FA FF      lea d, [bp + -6] ; $i
1263   0BEE 2A            mov b, [d]
1264   0BEF FD 7D         dec b
1265   0BF1 FA FA FF      lea d, [bp + -6] ; $i
1266   0BF4 FD 43         mov [d], b
1267   0BF6 E7            pop d
1268   0BF7 5A            add d, b
1269   0BF8 E4            pop a
1270   0BF9 32            mov bl, [d]
1271   0BFA A7 00         mov bh, 0
1272   0BFC 38 00 00      mov c, 0
1273   0BFF DD            push bl
1274   0C00 07 E1 08      call putchar
1275   0C03 51 01 00      add sp, 1
1276   0C06             ; --- END FUNCTION CALL
1277   0C06 0A CD 0B      jmp _while36_cond
1278   0C09             _while36_exit:
1279   0C09 F9            leave
1280   0C0A 09            ret
1281   0C0B             
1282   0C0B             print_unsigned:
1283   0C0B F8 00 00      enter 0 ; (push bp; mov bp, sp)
1284   0C0E             ; char digits[5]; 
1285   0C0E 52 05 00      sub sp, 5
1286   0C11             ; int i = 0; 
1287   0C11 52 02 00      sub sp, 2
1288   0C14             ; --- START LOCAL VAR INITIALIZATION
1289   0C14 FA FA FF      lea d, [bp + -6] ; $i
1290   0C17 DA            push d
1291   0C18 FD 2E 00 00   mov32 cb, $00000000
1291   0C1C 00 00 
1292   0C1E E7            pop d
1293   0C1F FD 43         mov [d], b
1294   0C21             ; --- END LOCAL VAR INITIALIZATION
1295   0C21             ; if(num == 0){ 
1296   0C21             _if37_cond:
1297   0C21 FA 05 00      lea d, [bp + 5] ; $num
1298   0C24 2A            mov b, [d]
1299   0C25 38 00 00      mov c, 0
1300   0C28             ; --- START RELATIONAL
1301   0C28 D7            push a
1302   0C29 11            mov a, b
1303   0C2A FD 2E 00 00   mov32 cb, $00000000
1303   0C2E 00 00 
1304   0C30 B0            cmp a, b
1305   0C31 FD 71         seq ; ==
1306   0C33 E4            pop a
1307   0C34             ; --- END RELATIONAL
1308   0C34 C0 00 00      cmp b, 0
1309   0C37 C6 4C 0C      je _if37_exit
1310   0C3A             _if37_TRUE:
1311   0C3A             ; putchar('0'); 
1312   0C3A             ; --- START FUNCTION CALL
1313   0C3A FD 2E 30 00   mov32 cb, $00000030
1313   0C3E 00 00 
1314   0C40 DD            push bl
1315   0C41 07 E1 08      call putchar
1316   0C44 51 01 00      add sp, 1
1317   0C47             ; --- END FUNCTION CALL
1318   0C47             ; return; 
1319   0C47 F9            leave
1320   0C48 09            ret
1321   0C49 0A 4C 0C      jmp _if37_exit
1322   0C4C             _if37_exit:
1323   0C4C             ; while (num > 0) { 
1324   0C4C             _while38_cond:
1325   0C4C FA 05 00      lea d, [bp + 5] ; $num
1326   0C4F 2A            mov b, [d]
1327   0C50 38 00 00      mov c, 0
1328   0C53             ; --- START RELATIONAL
1329   0C53 D7            push a
1330   0C54 11            mov a, b
1331   0C55 FD 2E 00 00   mov32 cb, $00000000
1331   0C59 00 00 
1332   0C5B B0            cmp a, b
1333   0C5C FD 81         sgu ; > (unsigned)
1334   0C5E E4            pop a
1335   0C5F             ; --- END RELATIONAL
1336   0C5F C0 00 00      cmp b, 0
1337   0C62 C6 D2 0C      je _while38_exit
1338   0C65             _while38_block:
1339   0C65             ; digits[i++] = '0' + (num % 10); 
1340   0C65 FA FC FF      lea d, [bp + -4] ; $digits
1341   0C68 D7            push a
1342   0C69 DA            push d
1343   0C6A FA FA FF      lea d, [bp + -6] ; $i
1344   0C6D 2A            mov b, [d]
1345   0C6E 38 00 00      mov c, 0
1346   0C71 11            mov a, b
1347   0C72 FD 77         inc b
1348   0C74 FA FA FF      lea d, [bp + -6] ; $i
1349   0C77 FD 43         mov [d], b
1350   0C79 27            mov b, a
1351   0C7A E7            pop d
1352   0C7B 5A            add d, b
1353   0C7C E4            pop a
1354   0C7D DA            push d
1355   0C7E FD 2E 30 00   mov32 cb, $00000030
1355   0C82 00 00 
1356   0C84             ; --- START TERMS
1357   0C84 D7            push a
1358   0C85 11            mov a, b
1359   0C86 FA 05 00      lea d, [bp + 5] ; $num
1360   0C89 2A            mov b, [d]
1361   0C8A 38 00 00      mov c, 0
1362   0C8D             ; --- START FACTORS
1363   0C8D D7            push a
1364   0C8E FD D8         push g
1365   0C90 11            mov a, b
1366   0C91 FD 7A         mov g, c
1367   0C93 FD 2E 0A 00   mov32 cb, $0000000a
1367   0C97 00 00 
1368   0C99 FD D8         push g ; save 'g' as the div instruction uses it
1369   0C9B AE            div a, b ; %, a: quotient, b: remainder
1370   0C9C 11            mov a, b
1371   0C9D FD F1         pop g
1372   0C9F FD 38         mov c, g
1373   0CA1 27            mov b, a
1374   0CA2 FD F1         pop g
1375   0CA4 E4            pop a
1376   0CA5             ; --- END FACTORS
1377   0CA5 56            add b, a
1378   0CA6 E4            pop a
1379   0CA7             ; --- END TERMS
1380   0CA7 E7            pop d
1381   0CA8 FD 3E         mov [d], bl
1382   0CAA             ; num = num / 10; 
1383   0CAA FA 05 00      lea d, [bp + 5] ; $num
1384   0CAD DA            push d
1385   0CAE FA 05 00      lea d, [bp + 5] ; $num
1386   0CB1 2A            mov b, [d]
1387   0CB2 38 00 00      mov c, 0
1388   0CB5             ; --- START FACTORS
1389   0CB5 D7            push a
1390   0CB6 FD D8         push g
1391   0CB8 11            mov a, b
1392   0CB9 FD 7A         mov g, c
1393   0CBB FD 2E 0A 00   mov32 cb, $0000000a
1393   0CBF 00 00 
1394   0CC1 FD D8         push g ; save 'g' as the div instruction uses it
1395   0CC3 AE            div a, b ; /, a: quotient, b: remainder
1396   0CC4 FD F1         pop g
1397   0CC6 FD 38         mov c, g
1398   0CC8 27            mov b, a
1399   0CC9 FD F1         pop g
1400   0CCB E4            pop a
1401   0CCC             ; --- END FACTORS
1402   0CCC E7            pop d
1403   0CCD FD 43         mov [d], b
1404   0CCF 0A 4C 0C      jmp _while38_cond
1405   0CD2             _while38_exit:
1406   0CD2             ; while (i > 0) { 
1407   0CD2             _while45_cond:
1408   0CD2 FA FA FF      lea d, [bp + -6] ; $i
1409   0CD5 2A            mov b, [d]
1410   0CD6 38 00 00      mov c, 0
1411   0CD9             ; --- START RELATIONAL
1412   0CD9 D7            push a
1413   0CDA 11            mov a, b
1414   0CDB FD 2E 00 00   mov32 cb, $00000000
1414   0CDF 00 00 
1415   0CE1 B0            cmp a, b
1416   0CE2 FD 7F         sgt ; >
1417   0CE4 E4            pop a
1418   0CE5             ; --- END RELATIONAL
1419   0CE5 C0 00 00      cmp b, 0
1420   0CE8 C6 0E 0D      je _while45_exit
1421   0CEB             _while45_block:
1422   0CEB             ; putchar(digits[--i]); 
1423   0CEB             ; --- START FUNCTION CALL
1424   0CEB FA FC FF      lea d, [bp + -4] ; $digits
1425   0CEE D7            push a
1426   0CEF DA            push d
1427   0CF0 FA FA FF      lea d, [bp + -6] ; $i
1428   0CF3 2A            mov b, [d]
1429   0CF4 FD 7D         dec b
1430   0CF6 FA FA FF      lea d, [bp + -6] ; $i
1431   0CF9 FD 43         mov [d], b
1432   0CFB E7            pop d
1433   0CFC 5A            add d, b
1434   0CFD E4            pop a
1435   0CFE 32            mov bl, [d]
1436   0CFF A7 00         mov bh, 0
1437   0D01 38 00 00      mov c, 0
1438   0D04 DD            push bl
1439   0D05 07 E1 08      call putchar
1440   0D08 51 01 00      add sp, 1
1441   0D0B             ; --- END FUNCTION CALL
1442   0D0B 0A D2 0C      jmp _while45_cond
1443   0D0E             _while45_exit:
1444   0D0E F9            leave
1445   0D0F 09            ret
1446   0D10             
1447   0D10             printx16:
1448   0D10 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1449   0D13             ; --- BEGIN INLINE ASM SEGMENT
1450   0D13 FA 05 00      lea d, [bp + 5] ; $hex
1451   0D16 2A            mov b, [d]
1452   0D17             print_u16x_printx16:
1453   0D17 DD            push bl
1454   0D18 30            mov bl, bh
1455   0D19 07 36 0D      call _itoa_printx16        ; convert bh to char in A
1456   0D1C 2F            mov bl, al        ; save al
1457   0D1D 19 00         mov al, 0
1458   0D1F 05 03         syscall sys_io        ; display AH
1459   0D21 24            mov ah, bl        ; retrieve al
1460   0D22 19 00         mov al, 0
1461   0D24 05 03         syscall sys_io        ; display AL
1462   0D26 EA            pop bl
1463   0D27 07 36 0D      call _itoa_printx16        ; convert bh to char in A
1464   0D2A 2F            mov bl, al        ; save al
1465   0D2B 19 00         mov al, 0
1466   0D2D 05 03         syscall sys_io        ; display AH
1467   0D2F 24            mov ah, bl        ; retrieve al
1468   0D30 19 00         mov al, 0
1469   0D32 05 03         syscall sys_io        ; display AL
1470   0D34             ; --- END INLINE ASM SEGMENT
1471   0D34             ; return; 
1472   0D34 F9            leave
1473   0D35 09            ret
1474   0D36             ; --- BEGIN INLINE ASM SEGMENT
1475   0D36             _itoa_printx16:
1476   0D36 DA            push d
1477   0D37 D8            push b
1478   0D38 A7 00         mov bh, 0
1479   0D3A FD A4 04      shr bl, 4  
1480   0D3D 74            mov d, b
1481   0D3E 1F 50 0D      mov al, [d + s_hex_digits_printx16]
1482   0D41 23            mov ah, al
1483   0D42 E5            pop b
1484   0D43 D8            push b
1485   0D44 A7 00         mov bh, 0
1486   0D46 FD 87 0F      and bl, $0F
1487   0D49 74            mov d, b
1488   0D4A 1F 50 0D      mov al, [d + s_hex_digits_printx16]
1489   0D4D E5            pop b
1490   0D4E E7            pop d
1491   0D4F 09            ret
1492   0D50 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
1492   0D54 34 35 36 37 
1492   0D58 38 39 41 42 
1492   0D5C 43 44 45 46 
1493   0D60             ; --- END INLINE ASM SEGMENT
1494   0D60 F9            leave
1495   0D61 09            ret
1496   0D62             ; --- END TEXT SEGMENT
1497   0D62             
1498   0D62             ; --- BEGIN DATA SEGMENT
1499   0D62 25 64 00    _s0: .db "%d", 0
1500   0D65 55 6E 65 78 _s1: .db "Unexpected format in printf.", 0
1500   0D69 70 65 63 74 
1500   0D6D 65 64 20 66 
1500   0D71 6F 72 6D 61 
1500   0D75 74 20 69 6E 
1500   0D79 20 70 72 69 
1500   0D7D 6E 74 66 2E 
1500   0D81 00 
1501   0D82 45 72 72 6F _s2: .db "Error: Unknown argument type.\n", 0
1501   0D86 72 3A 20 55 
1501   0D8A 6E 6B 6E 6F 
1501   0D8E 77 6E 20 61 
1501   0D92 72 67 75 6D 
1501   0D96 65 6E 74 20 
1501   0D9A 74 79 70 65 
1501   0D9E 2E 0A 00 
1502   0DA1             
1503   0DA1 A3 0D       _heap_top: .dw _heap
1504   0DA3 00          _heap: .db 0
1505   0DA4             ; --- END DATA SEGMENT
1506   0DA4             
1507   0DA4             .end
tasm: Number of errors = 0
