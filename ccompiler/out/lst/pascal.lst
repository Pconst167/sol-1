0001   0000             ; --- FILENAME: programs/pascal.c
0002   0000             ; --- DATE:     24-07-2025 at 19:22:17
0003   0000             .include "lib/asm/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0004   0000             .include "lib/asm/bios.exp"
0001+  0000             bios_reset_vector .equ  $01c0
0002+  0000             ide_buffer       .equ  $8204
0003+  0000             boot_origin      .equ  $8004
0004+  0000             bios_uart        .equ  $0002
0005+  0000             bios_ide         .equ  $0003
0005   0000             
0006   0000             ; --- BEGIN TEXT SEGMENT
0007   0400             .org text_org
0008   0400             main:
0009   0400 FD 49 E0 FF   mov bp, $FFE0 ;
0010   0404 FD 47 E0 FF   mov sp, $FFE0 ; Make space for argc(2 bytes) and for 10 pointers in argv (local variables)
0011   0408             ; coef = 1; 
0012   0408 3B A4 14      mov d, _coef ; $coef
0013   040B DA            push d
0014   040C FD 2E 01 00   mov32 cb, $00000001
0014   0410 00 00 
0015   0412 E7            pop d
0016   0413 FD 43         mov [d], b
0017   0415             ; print("Enter the number of rows: "); 
0018   0415             ; --- START FUNCTION CALL
0019   0415 26 B3 14      mov b, _s0 ; "Enter the number of rows: "
0020   0418 FD AB         swp b
0021   041A D8            push b
0022   041B 07 EC 05      call print
0023   041E 51 02 00      add sp, 2
0024   0421             ; --- END FUNCTION CALL
0025   0421             ; scanf("%d", &rows); 
0026   0421             ; --- START FUNCTION CALL
0027   0421 3B A6 14      mov d, _rows ; $rows
0028   0424 2D            mov b, d
0029   0425 FD AB         swp b
0030   0427 D8            push b
0031   0428 26 CE 14      mov b, _s1 ; "%d"
0032   042B FD AB         swp b
0033   042D D8            push b
0034   042E 07 05 06      call scanf
0035   0431 51 04 00      add sp, 4
0036   0434             ; --- END FUNCTION CALL
0037   0434             ; for (i = 0; i < rows; i=i+1) { 
0038   0434             _for1_init:
0039   0434 3B AA 14      mov d, _i ; $i
0040   0437 DA            push d
0041   0438 FD 2E 00 00   mov32 cb, $00000000
0041   043C 00 00 
0042   043E E7            pop d
0043   043F FD 43         mov [d], b
0044   0441             _for1_cond:
0045   0441 3B AA 14      mov d, _i ; $i
0046   0444 2A            mov b, [d]
0047   0445 38 00 00      mov c, 0
0048   0448             ; --- START RELATIONAL
0049   0448 D7            push a
0050   0449 11            mov a, b
0051   044A 3B A6 14      mov d, _rows ; $rows
0052   044D 2A            mov b, [d]
0053   044E 38 00 00      mov c, 0
0054   0451 B0            cmp a, b
0055   0452 FD 73         slt ; < (signed)
0056   0454 E4            pop a
0057   0455             ; --- END RELATIONAL
0058   0455 C0 00 00      cmp b, 0
0059   0458 C6 E9 05      je _for1_exit
0060   045B             _for1_block:
0061   045B             ; for (space = 1; space <= rows - i; space=space+1) print("\n"); 
0062   045B             _for2_init:
0063   045B 3B A8 14      mov d, _space ; $space
0064   045E DA            push d
0065   045F FD 2E 01 00   mov32 cb, $00000001
0065   0463 00 00 
0066   0465 E7            pop d
0067   0466 FD 43         mov [d], b
0068   0468             _for2_cond:
0069   0468 3B A8 14      mov d, _space ; $space
0070   046B 2A            mov b, [d]
0071   046C 38 00 00      mov c, 0
0072   046F             ; --- START RELATIONAL
0073   046F D7            push a
0074   0470 11            mov a, b
0075   0471 3B A6 14      mov d, _rows ; $rows
0076   0474 2A            mov b, [d]
0077   0475 38 00 00      mov c, 0
0078   0478             ; --- START TERMS
0079   0478 D7            push a
0080   0479 11            mov a, b
0081   047A 3B AA 14      mov d, _i ; $i
0082   047D 2A            mov b, [d]
0083   047E 38 00 00      mov c, 0
0084   0481 60            sub a, b
0085   0482 27            mov b, a
0086   0483 E4            pop a
0087   0484             ; --- END TERMS
0088   0484 B0            cmp a, b
0089   0485 FD 74         sle ; <= (signed)
0090   0487 E4            pop a
0091   0488             ; --- END RELATIONAL
0092   0488 C0 00 00      cmp b, 0
0093   048B C6 B5 04      je _for2_exit
0094   048E             _for2_block:
0095   048E             ; print("\n"); 
0096   048E             ; --- START FUNCTION CALL
0097   048E 26 D1 14      mov b, _s2 ; "\n"
0098   0491 FD AB         swp b
0099   0493 D8            push b
0100   0494 07 EC 05      call print
0101   0497 51 02 00      add sp, 2
0102   049A             ; --- END FUNCTION CALL
0103   049A             _for2_update:
0104   049A 3B A8 14      mov d, _space ; $space
0105   049D DA            push d
0106   049E 3B A8 14      mov d, _space ; $space
0107   04A1 2A            mov b, [d]
0108   04A2 38 00 00      mov c, 0
0109   04A5             ; --- START TERMS
0110   04A5 D7            push a
0111   04A6 11            mov a, b
0112   04A7 FD 2E 01 00   mov32 cb, $00000001
0112   04AB 00 00 
0113   04AD 56            add b, a
0114   04AE E4            pop a
0115   04AF             ; --- END TERMS
0116   04AF E7            pop d
0117   04B0 FD 43         mov [d], b
0118   04B2 0A 68 04      jmp _for2_cond
0119   04B5             _for2_exit:
0120   04B5             ; for (j = 0; j <= i; j=j+1){ 
0121   04B5             _for3_init:
0122   04B5 3B AC 14      mov d, _j ; $j
0123   04B8 DA            push d
0124   04B9 FD 2E 00 00   mov32 cb, $00000000
0124   04BD 00 00 
0125   04BF E7            pop d
0126   04C0 FD 43         mov [d], b
0127   04C2             _for3_cond:
0128   04C2 3B AC 14      mov d, _j ; $j
0129   04C5 2A            mov b, [d]
0130   04C6 38 00 00      mov c, 0
0131   04C9             ; --- START RELATIONAL
0132   04C9 D7            push a
0133   04CA 11            mov a, b
0134   04CB 3B AA 14      mov d, _i ; $i
0135   04CE 2A            mov b, [d]
0136   04CF 38 00 00      mov c, 0
0137   04D2 B0            cmp a, b
0138   04D3 FD 74         sle ; <= (signed)
0139   04D5 E4            pop a
0140   04D6             ; --- END RELATIONAL
0141   04D6 C0 00 00      cmp b, 0
0142   04D9 C6 CE 05      je _for3_exit
0143   04DC             _for3_block:
0144   04DC             ; if (j == 0 || i == 0) 
0145   04DC             _if4_cond:
0146   04DC 3B AC 14      mov d, _j ; $j
0147   04DF 2A            mov b, [d]
0148   04E0 38 00 00      mov c, 0
0149   04E3             ; --- START RELATIONAL
0150   04E3 D7            push a
0151   04E4 11            mov a, b
0152   04E5 FD 2E 00 00   mov32 cb, $00000000
0152   04E9 00 00 
0153   04EB B0            cmp a, b
0154   04EC FD 71         seq ; ==
0155   04EE E4            pop a
0156   04EF             ; --- END RELATIONAL
0157   04EF             ; --- START LOGICAL OR
0158   04EF D7            push a
0159   04F0 11            mov a, b
0160   04F1 3B AA 14      mov d, _i ; $i
0161   04F4 2A            mov b, [d]
0162   04F5 38 00 00      mov c, 0
0163   04F8             ; --- START RELATIONAL
0164   04F8 D7            push a
0165   04F9 11            mov a, b
0166   04FA FD 2E 00 00   mov32 cb, $00000000
0166   04FE 00 00 
0167   0500 B0            cmp a, b
0168   0501 FD 71         seq ; ==
0169   0503 E4            pop a
0170   0504             ; --- END RELATIONAL
0171   0504 FD A8         sor a, b ; ||
0172   0506 E4            pop a
0173   0507             ; --- END LOGICAL OR
0174   0507 C0 00 00      cmp b, 0
0175   050A C6 1D 05      je _if4_else
0176   050D             _if4_TRUE:
0177   050D             ; coef = 1; 
0178   050D 3B A4 14      mov d, _coef ; $coef
0179   0510 DA            push d
0180   0511 FD 2E 01 00   mov32 cb, $00000001
0180   0515 00 00 
0181   0517 E7            pop d
0182   0518 FD 43         mov [d], b
0183   051A 0A 91 05      jmp _if4_exit
0184   051D             _if4_else:
0185   051D             ; coef = coef * (i - j + 1) / j; 
0186   051D 3B A4 14      mov d, _coef ; $coef
0187   0520 DA            push d
0188   0521 3B A4 14      mov d, _coef ; $coef
0189   0524 2A            mov b, [d]
0190   0525 38 00 00      mov c, 0
0191   0528             ; --- START FACTORS
0192   0528 D7            push a
0193   0529 FD D8         push g
0194   052B 11            mov a, b
0195   052C FD 7A         mov g, c
0196   052E 3B AA 14      mov d, _i ; $i
0197   0531 2A            mov b, [d]
0198   0532 38 00 00      mov c, 0
0199   0535             ; --- START TERMS
0200   0535 D7            push a
0201   0536 11            mov a, b
0202   0537 3B AC 14      mov d, _j ; $j
0203   053A 2A            mov b, [d]
0204   053B 38 00 00      mov c, 0
0205   053E 60            sub a, b
0206   053F 27            mov b, a
0207   0540 11            mov a, b
0208   0541 FD 2E 01 00   mov32 cb, $00000001
0208   0545 00 00 
0209   0547 56            add b, a
0210   0548 E4            pop a
0211   0549             ; --- END TERMS
0212   0549 D7            push a     ; save left operand
0213   054A 8E            xor a, b   ; xor sign bits
0214   054B FD AA         swp a      ; swap bytes
0215   054D 83            mov cl, al ; save result of xor into 'dl'
0216   054E E4            pop a      ; restore left side operator
0217   054F DF            push cl    ; save result of xor above
0218   0550 FD AA         swp a  
0219   0552 93 80         test al, $80  
0220   0554 FD AA         swp a  
0221   0556 C6 5B 05      jz skip_invert_a_7  
0222   0559 FD 95         neg a 
0223   055B             skip_invert_a_7:   
0224   055B FD AB         swp b
0225   055D FD 93 80      test bl, $80  
0226   0560 FD AB         swp b
0227   0562 C6 67 05      jz skip_invert_b_7  
0228   0565 FD 97         neg b 
0229   0567             skip_invert_b_7:   
0230   0567 AC            mul a, b ; *
0231   0568 FD 78         mov g, a
0232   056A 11            mov a, b
0233   056B EA            pop bl
0234   056C FD 93 80      test bl, $80
0235   056F C6 7C 05      jz _same_signs_7
0236   0572 2F            mov bl, al
0237   0573 95            not a
0238   0574 FD 97         neg b
0239   0576 5B 00 00      adc a, 0
0240   0579 FD 78         mov g, a
0241   057B 11            mov a, b
0242   057C             _same_signs_7:
0243   057C 3B AC 14      mov d, _j ; $j
0244   057F 2A            mov b, [d]
0245   0580 38 00 00      mov c, 0
0246   0583 FD D8         push g ; save 'g' as the div instruction uses it
0247   0585 AE            div a, b ; /, a: quotient, b: remainder
0248   0586 FD F1         pop g
0249   0588 FD 38         mov c, g
0250   058A 27            mov b, a
0251   058B FD F1         pop g
0252   058D E4            pop a
0253   058E             ; --- END FACTORS
0254   058E E7            pop d
0255   058F FD 43         mov [d], b
0256   0591             _if4_exit:
0257   0591             ; printf("%u", coef); 
0258   0591             ; --- START FUNCTION CALL
0259   0591 3B A4 14      mov d, _coef ; $coef
0260   0594 2A            mov b, [d]
0261   0595 38 00 00      mov c, 0
0262   0598 FD AB         swp b
0263   059A D8            push b
0264   059B 26 D3 14      mov b, _s3 ; "%u"
0265   059E FD AB         swp b
0266   05A0 D8            push b
0267   05A1 07 C4 0B      call printf
0268   05A4 51 04 00      add sp, 4
0269   05A7             ; --- END FUNCTION CALL
0270   05A7             ; printf(" "); 
0271   05A7             ; --- START FUNCTION CALL
0272   05A7 26 D6 14      mov b, _s4 ; " "
0273   05AA FD AB         swp b
0274   05AC D8            push b
0275   05AD 07 C4 0B      call printf
0276   05B0 51 02 00      add sp, 2
0277   05B3             ; --- END FUNCTION CALL
0278   05B3             _for3_update:
0279   05B3 3B AC 14      mov d, _j ; $j
0280   05B6 DA            push d
0281   05B7 3B AC 14      mov d, _j ; $j
0282   05BA 2A            mov b, [d]
0283   05BB 38 00 00      mov c, 0
0284   05BE             ; --- START TERMS
0285   05BE D7            push a
0286   05BF 11            mov a, b
0287   05C0 FD 2E 01 00   mov32 cb, $00000001
0287   05C4 00 00 
0288   05C6 56            add b, a
0289   05C7 E4            pop a
0290   05C8             ; --- END TERMS
0291   05C8 E7            pop d
0292   05C9 FD 43         mov [d], b
0293   05CB 0A C2 04      jmp _for3_cond
0294   05CE             _for3_exit:
0295   05CE             _for1_update:
0296   05CE 3B AA 14      mov d, _i ; $i
0297   05D1 DA            push d
0298   05D2 3B AA 14      mov d, _i ; $i
0299   05D5 2A            mov b, [d]
0300   05D6 38 00 00      mov c, 0
0301   05D9             ; --- START TERMS
0302   05D9 D7            push a
0303   05DA 11            mov a, b
0304   05DB FD 2E 01 00   mov32 cb, $00000001
0304   05DF 00 00 
0305   05E1 56            add b, a
0306   05E2 E4            pop a
0307   05E3             ; --- END TERMS
0308   05E3 E7            pop d
0309   05E4 FD 43         mov [d], b
0310   05E6 0A 41 04      jmp _for1_cond
0311   05E9             _for1_exit:
0312   05E9             ; return; 
0313   05E9 F9            leave
0314   05EA 05 0B         syscall sys_terminate_proc
0315   05EC             
0316   05EC             print:
0317   05EC F8 00 00      enter 0 ; (push bp; mov bp, sp)
0318   05EF             ; --- BEGIN INLINE ASM SEGMENT
0319   05EF FA 05 00      lea d, [bp + 5] ; $s
0320   05F2 FD 2A         mov d, [d]
0321   05F4             _puts_L1_print:
0322   05F4 1E            mov al, [d]
0323   05F5 B9 00         cmp al, 0
0324   05F7 C6 03 06      jz _puts_END_print
0325   05FA 23            mov ah, al
0326   05FB 19 00         mov al, 0
0327   05FD 05 03         syscall sys_io
0328   05FF 79            inc d
0329   0600 0A F4 05      jmp _puts_L1_print
0330   0603             _puts_END_print:
0331   0603             ; --- END INLINE ASM SEGMENT
0332   0603 F9            leave
0333   0604 09            ret
0334   0605             
0335   0605             scanf:
0336   0605 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0337   0608             ; char *p, *format_p; 
0338   0608 52 02 00      sub sp, 2
0339   060B 52 02 00      sub sp, 2
0340   060E             ; char c; 
0341   060E 52 01 00      sub sp, 1
0342   0611             ; int i; 
0343   0611 52 02 00      sub sp, 2
0344   0614             ; char input_string[ 512                     ]; 
0345   0614 52 00 02      sub sp, 512
0346   0617             ; format_p = format; 
0347   0617 FA FD FF      lea d, [bp + -3] ; $format_p
0348   061A DA            push d
0349   061B FA 05 00      lea d, [bp + 5] ; $format
0350   061E 2A            mov b, [d]
0351   061F 38 00 00      mov c, 0
0352   0622 E7            pop d
0353   0623 FD 43         mov [d], b
0354   0625             ; p = &format + 2; 
0355   0625 FA FF FF      lea d, [bp + -1] ; $p
0356   0628 DA            push d
0357   0629 FA 05 00      lea d, [bp + 5] ; $format
0358   062C 2D            mov b, d
0359   062D             ; --- START TERMS
0360   062D D7            push a
0361   062E 11            mov a, b
0362   062F FD 2E 02 00   mov32 cb, $00000002
0362   0633 00 00 
0363   0635 56            add b, a
0364   0636 E4            pop a
0365   0637             ; --- END TERMS
0366   0637 E7            pop d
0367   0638 FD 43         mov [d], b
0368   063A             ; for(;;){ 
0369   063A             _for9_init:
0370   063A             _for9_cond:
0371   063A             _for9_block:
0372   063A             ; if(!*format_p) break; 
0373   063A             _if10_cond:
0374   063A FA FD FF      lea d, [bp + -3] ; $format_p
0375   063D 2A            mov b, [d]
0376   063E 38 00 00      mov c, 0
0377   0641 74            mov d, b
0378   0642 32            mov bl, [d]
0379   0643 A7 00         mov bh, 0
0380   0645 38 00 00      mov c, 0
0381   0648 C0 00 00      cmp b, 0
0382   064B FD 71         seq ; !
0383   064D C0 00 00      cmp b, 0
0384   0650 C6 59 06      je _if10_else
0385   0653             _if10_TRUE:
0386   0653             ; break; 
0387   0653 0A E1 08      jmp _for9_exit ; for break
0388   0656 0A DE 08      jmp _if10_exit
0389   0659             _if10_else:
0390   0659             ; if(*format_p == '%'){ 
0391   0659             _if11_cond:
0392   0659 FA FD FF      lea d, [bp + -3] ; $format_p
0393   065C 2A            mov b, [d]
0394   065D 38 00 00      mov c, 0
0395   0660 74            mov d, b
0396   0661 32            mov bl, [d]
0397   0662 A7 00         mov bh, 0
0398   0664 38 00 00      mov c, 0
0399   0667             ; --- START RELATIONAL
0400   0667 D7            push a
0401   0668 11            mov a, b
0402   0669 FD 2E 25 00   mov32 cb, $00000025
0402   066D 00 00 
0403   066F B0            cmp a, b
0404   0670 FD 71         seq ; ==
0405   0672 E4            pop a
0406   0673             ; --- END RELATIONAL
0407   0673 C0 00 00      cmp b, 0
0408   0676 C6 B9 08      je _if11_else
0409   0679             _if11_TRUE:
0410   0679             ; format_p++; 
0411   0679 FA FD FF      lea d, [bp + -3] ; $format_p
0412   067C 2A            mov b, [d]
0413   067D 38 00 00      mov c, 0
0414   0680 FD 77         inc b
0415   0682 FA FD FF      lea d, [bp + -3] ; $format_p
0416   0685 FD 43         mov [d], b
0417   0687 FD 7D         dec b
0418   0689             ; switch(*format_p){ 
0419   0689             _switch12_expr:
0420   0689 FA FD FF      lea d, [bp + -3] ; $format_p
0421   068C 2A            mov b, [d]
0422   068D 38 00 00      mov c, 0
0423   0690 74            mov d, b
0424   0691 32            mov bl, [d]
0425   0692 A7 00         mov bh, 0
0426   0694 38 00 00      mov c, 0
0427   0697             _switch12_comparisons:
0428   0697 C1 6C         cmp bl, $6c
0429   0699 C6 C5 06      je _switch12_case0
0430   069C C1 4C         cmp bl, $4c
0431   069E C6 C5 06      je _switch12_case1
0432   06A1 C1 64         cmp bl, $64
0433   06A3 C6 84 07      je _switch12_case2
0434   06A6 C1 69         cmp bl, $69
0435   06A8 C6 84 07      je _switch12_case3
0436   06AB C1 75         cmp bl, $75
0437   06AD C6 BD 07      je _switch12_case4
0438   06B0 C1 78         cmp bl, $78
0439   06B2 C6 F6 07      je _switch12_case5
0440   06B5 C1 63         cmp bl, $63
0441   06B7 C6 11 08      je _switch12_case6
0442   06BA C1 73         cmp bl, $73
0443   06BC C6 53 08      je _switch12_case7
0444   06BF 0A 9A 08      jmp _switch12_default
0445   06C2 0A A6 08      jmp _switch12_exit
0446   06C5             _switch12_case0:
0447   06C5             _switch12_case1:
0448   06C5             ; format_p++; 
0449   06C5 FA FD FF      lea d, [bp + -3] ; $format_p
0450   06C8 2A            mov b, [d]
0451   06C9 38 00 00      mov c, 0
0452   06CC FD 77         inc b
0453   06CE FA FD FF      lea d, [bp + -3] ; $format_p
0454   06D1 FD 43         mov [d], b
0455   06D3 FD 7D         dec b
0456   06D5             ; if(*format_p == 'd' || *format_p == 'i'); 
0457   06D5             _if13_cond:
0458   06D5 FA FD FF      lea d, [bp + -3] ; $format_p
0459   06D8 2A            mov b, [d]
0460   06D9 38 00 00      mov c, 0
0461   06DC 74            mov d, b
0462   06DD 32            mov bl, [d]
0463   06DE A7 00         mov bh, 0
0464   06E0 38 00 00      mov c, 0
0465   06E3             ; --- START RELATIONAL
0466   06E3 D7            push a
0467   06E4 11            mov a, b
0468   06E5 FD 2E 64 00   mov32 cb, $00000064
0468   06E9 00 00 
0469   06EB B0            cmp a, b
0470   06EC FD 71         seq ; ==
0471   06EE E4            pop a
0472   06EF             ; --- END RELATIONAL
0473   06EF             ; --- START LOGICAL OR
0474   06EF D7            push a
0475   06F0 11            mov a, b
0476   06F1 FA FD FF      lea d, [bp + -3] ; $format_p
0477   06F4 2A            mov b, [d]
0478   06F5 38 00 00      mov c, 0
0479   06F8 74            mov d, b
0480   06F9 32            mov bl, [d]
0481   06FA A7 00         mov bh, 0
0482   06FC 38 00 00      mov c, 0
0483   06FF             ; --- START RELATIONAL
0484   06FF D7            push a
0485   0700 11            mov a, b
0486   0701 FD 2E 69 00   mov32 cb, $00000069
0486   0705 00 00 
0487   0707 B0            cmp a, b
0488   0708 FD 71         seq ; ==
0489   070A E4            pop a
0490   070B             ; --- END RELATIONAL
0491   070B FD A8         sor a, b ; ||
0492   070D E4            pop a
0493   070E             ; --- END LOGICAL OR
0494   070E C0 00 00      cmp b, 0
0495   0711 C6 17 07      je _if13_else
0496   0714             _if13_TRUE:
0497   0714             ; ; 
0498   0714 0A 69 07      jmp _if13_exit
0499   0717             _if13_else:
0500   0717             ; if(*format_p == 'u'); 
0501   0717             _if14_cond:
0502   0717 FA FD FF      lea d, [bp + -3] ; $format_p
0503   071A 2A            mov b, [d]
0504   071B 38 00 00      mov c, 0
0505   071E 74            mov d, b
0506   071F 32            mov bl, [d]
0507   0720 A7 00         mov bh, 0
0508   0722 38 00 00      mov c, 0
0509   0725             ; --- START RELATIONAL
0510   0725 D7            push a
0511   0726 11            mov a, b
0512   0727 FD 2E 75 00   mov32 cb, $00000075
0512   072B 00 00 
0513   072D B0            cmp a, b
0514   072E FD 71         seq ; ==
0515   0730 E4            pop a
0516   0731             ; --- END RELATIONAL
0517   0731 C0 00 00      cmp b, 0
0518   0734 C6 3A 07      je _if14_else
0519   0737             _if14_TRUE:
0520   0737             ; ; 
0521   0737 0A 69 07      jmp _if14_exit
0522   073A             _if14_else:
0523   073A             ; if(*format_p == 'x'); 
0524   073A             _if15_cond:
0525   073A FA FD FF      lea d, [bp + -3] ; $format_p
0526   073D 2A            mov b, [d]
0527   073E 38 00 00      mov c, 0
0528   0741 74            mov d, b
0529   0742 32            mov bl, [d]
0530   0743 A7 00         mov bh, 0
0531   0745 38 00 00      mov c, 0
0532   0748             ; --- START RELATIONAL
0533   0748 D7            push a
0534   0749 11            mov a, b
0535   074A FD 2E 78 00   mov32 cb, $00000078
0535   074E 00 00 
0536   0750 B0            cmp a, b
0537   0751 FD 71         seq ; ==
0538   0753 E4            pop a
0539   0754             ; --- END RELATIONAL
0540   0754 C0 00 00      cmp b, 0
0541   0757 C6 5D 07      je _if15_else
0542   075A             _if15_TRUE:
0543   075A             ; ; 
0544   075A 0A 69 07      jmp _if15_exit
0545   075D             _if15_else:
0546   075D             ; err("Unexpected format in printf."); 
0547   075D             ; --- START FUNCTION CALL
0548   075D 26 D8 14      mov b, _s5 ; "Unexpected format in printf."
0549   0760 FD AB         swp b
0550   0762 D8            push b
0551   0763 07 E3 08      call err
0552   0766 51 02 00      add sp, 2
0553   0769             ; --- END FUNCTION CALL
0554   0769             _if15_exit:
0555   0769             _if14_exit:
0556   0769             _if13_exit:
0557   0769             ; p = p + 4; 
0558   0769 FA FF FF      lea d, [bp + -1] ; $p
0559   076C DA            push d
0560   076D FA FF FF      lea d, [bp + -1] ; $p
0561   0770 2A            mov b, [d]
0562   0771 38 00 00      mov c, 0
0563   0774             ; --- START TERMS
0564   0774 D7            push a
0565   0775 11            mov a, b
0566   0776 FD 2E 04 00   mov32 cb, $00000004
0566   077A 00 00 
0567   077C 56            add b, a
0568   077D E4            pop a
0569   077E             ; --- END TERMS
0570   077E E7            pop d
0571   077F FD 43         mov [d], b
0572   0781             ; break; 
0573   0781 0A A6 08      jmp _switch12_exit ; case break
0574   0784             _switch12_case2:
0575   0784             _switch12_case3:
0576   0784             ; i = scann(); 
0577   0784 FA FA FF      lea d, [bp + -6] ; $i
0578   0787 DA            push d
0579   0788             ; --- START FUNCTION CALL
0580   0788 07 F8 08      call scann
0581   078B E7            pop d
0582   078C FD 43         mov [d], b
0583   078E             ; **(int **)p = i; 
0584   078E FA FF FF      lea d, [bp + -1] ; $p
0585   0791 2A            mov b, [d]
0586   0792 38 00 00      mov c, 0
0587   0795 74            mov d, b
0588   0796 2A            mov b, [d]
0589   0797 D8            push b
0590   0798 FA FA FF      lea d, [bp + -6] ; $i
0591   079B 2A            mov b, [d]
0592   079C 38 00 00      mov c, 0
0593   079F E7            pop d
0594   07A0 FD 43         mov [d], b
0595   07A2             ; p = p + 2; 
0596   07A2 FA FF FF      lea d, [bp + -1] ; $p
0597   07A5 DA            push d
0598   07A6 FA FF FF      lea d, [bp + -1] ; $p
0599   07A9 2A            mov b, [d]
0600   07AA 38 00 00      mov c, 0
0601   07AD             ; --- START TERMS
0602   07AD D7            push a
0603   07AE 11            mov a, b
0604   07AF FD 2E 02 00   mov32 cb, $00000002
0604   07B3 00 00 
0605   07B5 56            add b, a
0606   07B6 E4            pop a
0607   07B7             ; --- END TERMS
0608   07B7 E7            pop d
0609   07B8 FD 43         mov [d], b
0610   07BA             ; break; 
0611   07BA 0A A6 08      jmp _switch12_exit ; case break
0612   07BD             _switch12_case4:
0613   07BD             ; i = scann(); 
0614   07BD FA FA FF      lea d, [bp + -6] ; $i
0615   07C0 DA            push d
0616   07C1             ; --- START FUNCTION CALL
0617   07C1 07 F8 08      call scann
0618   07C4 E7            pop d
0619   07C5 FD 43         mov [d], b
0620   07C7             ; **(int **)p = i; 
0621   07C7 FA FF FF      lea d, [bp + -1] ; $p
0622   07CA 2A            mov b, [d]
0623   07CB 38 00 00      mov c, 0
0624   07CE 74            mov d, b
0625   07CF 2A            mov b, [d]
0626   07D0 D8            push b
0627   07D1 FA FA FF      lea d, [bp + -6] ; $i
0628   07D4 2A            mov b, [d]
0629   07D5 38 00 00      mov c, 0
0630   07D8 E7            pop d
0631   07D9 FD 43         mov [d], b
0632   07DB             ; p = p + 2; 
0633   07DB FA FF FF      lea d, [bp + -1] ; $p
0634   07DE DA            push d
0635   07DF FA FF FF      lea d, [bp + -1] ; $p
0636   07E2 2A            mov b, [d]
0637   07E3 38 00 00      mov c, 0
0638   07E6             ; --- START TERMS
0639   07E6 D7            push a
0640   07E7 11            mov a, b
0641   07E8 FD 2E 02 00   mov32 cb, $00000002
0641   07EC 00 00 
0642   07EE 56            add b, a
0643   07EF E4            pop a
0644   07F0             ; --- END TERMS
0645   07F0 E7            pop d
0646   07F1 FD 43         mov [d], b
0647   07F3             ; break; 
0648   07F3 0A A6 08      jmp _switch12_exit ; case break
0649   07F6             _switch12_case5:
0650   07F6             ; p = p + 2; 
0651   07F6 FA FF FF      lea d, [bp + -1] ; $p
0652   07F9 DA            push d
0653   07FA FA FF FF      lea d, [bp + -1] ; $p
0654   07FD 2A            mov b, [d]
0655   07FE 38 00 00      mov c, 0
0656   0801             ; --- START TERMS
0657   0801 D7            push a
0658   0802 11            mov a, b
0659   0803 FD 2E 02 00   mov32 cb, $00000002
0659   0807 00 00 
0660   0809 56            add b, a
0661   080A E4            pop a
0662   080B             ; --- END TERMS
0663   080B E7            pop d
0664   080C FD 43         mov [d], b
0665   080E             ; break; 
0666   080E 0A A6 08      jmp _switch12_exit ; case break
0667   0811             _switch12_case6:
0668   0811             ; c = getchar(); 
0669   0811 FA FC FF      lea d, [bp + -4] ; $c
0670   0814 DA            push d
0671   0815             ; --- START FUNCTION CALL
0672   0815 07 09 0A      call getchar
0673   0818 E7            pop d
0674   0819 FD 3E         mov [d], bl
0675   081B             ; **(char **)p = *(char *)c; 
0676   081B FA FF FF      lea d, [bp + -1] ; $p
0677   081E 2A            mov b, [d]
0678   081F 38 00 00      mov c, 0
0679   0822 74            mov d, b
0680   0823 2A            mov b, [d]
0681   0824 D8            push b
0682   0825 FA FC FF      lea d, [bp + -4] ; $c
0683   0828 32            mov bl, [d]
0684   0829 A7 00         mov bh, 0
0685   082B 38 00 00      mov c, 0
0686   082E 74            mov d, b
0687   082F 32            mov bl, [d]
0688   0830 A7 00         mov bh, 0
0689   0832 38 00 00      mov c, 0
0690   0835 E7            pop d
0691   0836 FD 43         mov [d], b
0692   0838             ; p = p + 1; 
0693   0838 FA FF FF      lea d, [bp + -1] ; $p
0694   083B DA            push d
0695   083C FA FF FF      lea d, [bp + -1] ; $p
0696   083F 2A            mov b, [d]
0697   0840 38 00 00      mov c, 0
0698   0843             ; --- START TERMS
0699   0843 D7            push a
0700   0844 11            mov a, b
0701   0845 FD 2E 01 00   mov32 cb, $00000001
0701   0849 00 00 
0702   084B 56            add b, a
0703   084C E4            pop a
0704   084D             ; --- END TERMS
0705   084D E7            pop d
0706   084E FD 43         mov [d], b
0707   0850             ; break; 
0708   0850 0A A6 08      jmp _switch12_exit ; case break
0709   0853             _switch12_case7:
0710   0853             ; gets(input_string); 
0711   0853             ; --- START FUNCTION CALL
0712   0853 FA FA FD      lea d, [bp + -518] ; $input_string
0713   0856 2D            mov b, d
0714   0857 38 00 00      mov c, 0
0715   085A FD AB         swp b
0716   085C D8            push b
0717   085D 07 23 0A      call gets
0718   0860 51 02 00      add sp, 2
0719   0863             ; --- END FUNCTION CALL
0720   0863             ; strcpy(*(char **)p, input_string); 
0721   0863             ; --- START FUNCTION CALL
0722   0863 FA FA FD      lea d, [bp + -518] ; $input_string
0723   0866 2D            mov b, d
0724   0867 38 00 00      mov c, 0
0725   086A FD AB         swp b
0726   086C D8            push b
0727   086D FA FF FF      lea d, [bp + -1] ; $p
0728   0870 2A            mov b, [d]
0729   0871 38 00 00      mov c, 0
0730   0874 74            mov d, b
0731   0875 2A            mov b, [d]
0732   0876 FD AB         swp b
0733   0878 D8            push b
0734   0879 07 3C 0B      call strcpy
0735   087C 51 04 00      add sp, 4
0736   087F             ; --- END FUNCTION CALL
0737   087F             ; p = p + 2; 
0738   087F FA FF FF      lea d, [bp + -1] ; $p
0739   0882 DA            push d
0740   0883 FA FF FF      lea d, [bp + -1] ; $p
0741   0886 2A            mov b, [d]
0742   0887 38 00 00      mov c, 0
0743   088A             ; --- START TERMS
0744   088A D7            push a
0745   088B 11            mov a, b
0746   088C FD 2E 02 00   mov32 cb, $00000002
0746   0890 00 00 
0747   0892 56            add b, a
0748   0893 E4            pop a
0749   0894             ; --- END TERMS
0750   0894 E7            pop d
0751   0895 FD 43         mov [d], b
0752   0897             ; break; 
0753   0897 0A A6 08      jmp _switch12_exit ; case break
0754   089A             _switch12_default:
0755   089A             ; print("Error: Unknown argument type.\n"); 
0756   089A             ; --- START FUNCTION CALL
0757   089A 26 F5 14      mov b, _s6 ; "Error: Unknown argument type.\n"
0758   089D FD AB         swp b
0759   089F D8            push b
0760   08A0 07 EC 05      call print
0761   08A3 51 02 00      add sp, 2
0762   08A6             ; --- END FUNCTION CALL
0763   08A6             _switch12_exit:
0764   08A6             ; format_p++; 
0765   08A6 FA FD FF      lea d, [bp + -3] ; $format_p
0766   08A9 2A            mov b, [d]
0767   08AA 38 00 00      mov c, 0
0768   08AD FD 77         inc b
0769   08AF FA FD FF      lea d, [bp + -3] ; $format_p
0770   08B2 FD 43         mov [d], b
0771   08B4 FD 7D         dec b
0772   08B6 0A DE 08      jmp _if11_exit
0773   08B9             _if11_else:
0774   08B9             ; putchar(*format_p); 
0775   08B9             ; --- START FUNCTION CALL
0776   08B9 FA FD FF      lea d, [bp + -3] ; $format_p
0777   08BC 2A            mov b, [d]
0778   08BD 38 00 00      mov c, 0
0779   08C0 74            mov d, b
0780   08C1 32            mov bl, [d]
0781   08C2 A7 00         mov bh, 0
0782   08C4 38 00 00      mov c, 0
0783   08C7 DD            push bl
0784   08C8 07 B6 0B      call putchar
0785   08CB 51 01 00      add sp, 1
0786   08CE             ; --- END FUNCTION CALL
0787   08CE             ; format_p++; 
0788   08CE FA FD FF      lea d, [bp + -3] ; $format_p
0789   08D1 2A            mov b, [d]
0790   08D2 38 00 00      mov c, 0
0791   08D5 FD 77         inc b
0792   08D7 FA FD FF      lea d, [bp + -3] ; $format_p
0793   08DA FD 43         mov [d], b
0794   08DC FD 7D         dec b
0795   08DE             _if11_exit:
0796   08DE             _if10_exit:
0797   08DE             _for9_update:
0798   08DE 0A 3A 06      jmp _for9_cond
0799   08E1             _for9_exit:
0800   08E1 F9            leave
0801   08E2 09            ret
0802   08E3             
0803   08E3             err:
0804   08E3 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0805   08E6             ; print(e); 
0806   08E6             ; --- START FUNCTION CALL
0807   08E6 FA 05 00      lea d, [bp + 5] ; $e
0808   08E9 2A            mov b, [d]
0809   08EA 38 00 00      mov c, 0
0810   08ED FD AB         swp b
0811   08EF D8            push b
0812   08F0 07 EC 05      call print
0813   08F3 51 02 00      add sp, 2
0814   08F6             ; --- END FUNCTION CALL
0815   08F6 F9            leave
0816   08F7 09            ret
0817   08F8             
0818   08F8             scann:
0819   08F8 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0820   08FB             ; int m; 
0821   08FB 52 02 00      sub sp, 2
0822   08FE             ; --- BEGIN INLINE ASM SEGMENT
0823   08FE F8 08 00      enter 8
0824   0901 FA F9 FF      lea d, [bp +- 7]
0825   0904 07 4C 09      call _gets_scann
0826   0907 07 3C 09      call _strlen_scann      ; get string length in C
0827   090A 7E            dec c
0828   090B FD 4E         mov si, d
0829   090D 12            mov a, c
0830   090E FD 99         shl a
0831   0910 3B E9 09      mov d, table_power_scann
0832   0913 59            add d, a
0833   0914 38 00 00      mov c, 0
0834   0917             mul_loop_scann:
0835   0917 F6            lodsb      ; load ASCII to al
0836   0918 B9 00         cmp al, 0
0837   091A C6 2D 09      je mul_exit_scann
0838   091D 6F 30         sub al, $30    ; make into integer
0839   091F 22 00         mov ah, 0
0840   0921 2A            mov b, [d]
0841   0922 AC            mul a, b      ; result in B since it fits in 16bits
0842   0923 11            mov a, b
0843   0924 28            mov b, c
0844   0925 54            add a, b
0845   0926 39            mov c, a
0846   0927 63 02 00      sub d, 2
0847   092A 0A 17 09      jmp mul_loop_scann
0848   092D             mul_exit_scann:
0849   092D 12            mov a, c
0850   092E F9            leave
0851   092F FA FF FF      lea d, [bp + -1] ; $m
0852   0932 43            mov [d], a
0853   0933             ; --- END INLINE ASM SEGMENT
0854   0933             ; return m; 
0855   0933 FA FF FF      lea d, [bp + -1] ; $m
0856   0936 2A            mov b, [d]
0857   0937 38 00 00      mov c, 0
0858   093A F9            leave
0859   093B 09            ret
0860   093C             ; --- BEGIN INLINE ASM SEGMENT
0861   093C             _strlen_scann:
0862   093C DA            push d
0863   093D 38 00 00      mov c, 0
0864   0940             _strlen_L1_scann:
0865   0940 BD 00         cmp byte [d], 0
0866   0942 C6 4A 09      je _strlen_ret_scann
0867   0945 79            inc d
0868   0946 78            inc c
0869   0947 0A 40 09      jmp _strlen_L1_scann
0870   094A             _strlen_ret_scann:
0871   094A E7            pop d
0872   094B 09            ret
0873   094C             _gets_scann:
0874   094C DA            push d
0875   094D             _gets_loop_scann:
0876   094D 19 01         mov al, 1
0877   094F 05 03         syscall sys_io      ; receive in AH
0878   0951 B9 00         cmp al, 0        ; check error code (AL)
0879   0953 C6 4D 09      je _gets_loop_scann      ; if no char received, retry
0880   0956 76 1B         cmp ah, 27
0881   0958 C6 79 09      je _gets_ansi_esc_scann
0882   095B 76 0A         cmp ah, $0A        ; LF
0883   095D C6 E4 09      je _gets_end_scann
0884   0960 76 0D         cmp ah, $0D        ; CR
0885   0962 C6 E4 09      je _gets_end_scann
0886   0965 76 5C         cmp ah, $5C        ; '\\'
0887   0967 C6 A5 09      je _gets_escape_scann
0888   096A 76 08         cmp ah, $08      ; check for backspace
0889   096C C6 75 09      je _gets_backspace_scann
0890   096F 1A            mov al, ah
0891   0970 3E            mov [d], al
0892   0971 79            inc d
0893   0972 0A 4D 09      jmp _gets_loop_scann
0894   0975             _gets_backspace_scann:
0895   0975 7F            dec d
0896   0976 0A 4D 09      jmp _gets_loop_scann
0897   0979             _gets_ansi_esc_scann:
0898   0979 19 01         mov al, 1
0899   097B 05 03         syscall sys_io        ; receive in AH without echo
0900   097D B9 00         cmp al, 0          ; check error code (AL)
0901   097F C6 79 09      je _gets_ansi_esc_scann    ; if no char received, retry
0902   0982 76 5B         cmp ah, '['
0903   0984 C7 4D 09      jne _gets_loop_scann
0904   0987             _gets_ansi_esc_2_scann:
0905   0987 19 01         mov al, 1
0906   0989 05 03         syscall sys_io          ; receive in AH without echo
0907   098B B9 00         cmp al, 0            ; check error code (AL)
0908   098D C6 87 09      je _gets_ansi_esc_2_scann  ; if no char received, retry
0909   0990 76 44         cmp ah, 'D'
0910   0992 C6 9D 09      je _gets_left_arrow_scann
0911   0995 76 43         cmp ah, 'C'
0912   0997 C6 A1 09      je _gets_right_arrow_scann
0913   099A 0A 4D 09      jmp _gets_loop_scann
0914   099D             _gets_left_arrow_scann:
0915   099D 7F            dec d
0916   099E 0A 4D 09      jmp _gets_loop_scann
0917   09A1             _gets_right_arrow_scann:
0918   09A1 79            inc d
0919   09A2 0A 4D 09      jmp _gets_loop_scann
0920   09A5             _gets_escape_scann:
0921   09A5 19 01         mov al, 1
0922   09A7 05 03         syscall sys_io      ; receive in AH
0923   09A9 B9 00         cmp al, 0        ; check error code (AL)
0924   09AB C6 A5 09      je _gets_escape_scann      ; if no char received, retry
0925   09AE 76 6E         cmp ah, 'n'
0926   09B0 C6 CF 09      je _gets_LF_scann
0927   09B3 76 72         cmp ah, 'r'
0928   09B5 C6 D6 09      je _gets_CR_scann
0929   09B8 76 30         cmp ah, '0'
0930   09BA C6 DD 09      je _gets_NULL_scann
0931   09BD 76 5C         cmp ah, $5C  
0932   09BF C6 C8 09      je _gets_slash_scann
0933   09C2 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0934   09C3 3E            mov [d], al
0935   09C4 79            inc d
0936   09C5 0A 4D 09      jmp _gets_loop_scann
0937   09C8             _gets_slash_scann:
0938   09C8 19 5C         mov al, $5C
0939   09CA 3E            mov [d], al
0940   09CB 79            inc d
0941   09CC 0A 4D 09      jmp _gets_loop_scann
0942   09CF             _gets_LF_scann:
0943   09CF 19 0A         mov al, $0A
0944   09D1 3E            mov [d], al
0945   09D2 79            inc d
0946   09D3 0A 4D 09      jmp _gets_loop_scann
0947   09D6             _gets_CR_scann:
0948   09D6 19 0D         mov al, $0D
0949   09D8 3E            mov [d], al
0950   09D9 79            inc d
0951   09DA 0A 4D 09      jmp _gets_loop_scann
0952   09DD             _gets_NULL_scann:
0953   09DD 19 00         mov al, $00
0954   09DF 3E            mov [d], al
0955   09E0 79            inc d
0956   09E1 0A 4D 09      jmp _gets_loop_scann
0957   09E4             _gets_end_scann:
0958   09E4 19 00         mov al, 0
0959   09E6 3E            mov [d], al        ; terminate string
0960   09E7 E7            pop d
0961   09E8 09            ret
0962   09E9             table_power_scann:
0963   09E9 01 00       .dw 1              ; 1
0964   09EB 0A 00       .dw $A             ; 10
0965   09ED 64 00       .dw $64            ; 100
0966   09EF E8 03       .dw $3E8           ; 1000
0967   09F1 10 27       .dw $2710          ; 10000
0968   09F3 A0 86 01 00 .dw $86A0, $1      ; 100000
0969   09F7 40 42 0F 00 .dw $4240, $F      ; 1000000
0970   09FB 80 96 98 00 .dw $9680, $98     ; 10000000
0971   09FF 00 E1 F5 05 .dw $E100, $5F5    ; 100000000
0972   0A03 00 CA 9A 3B .dw $CA00, $3B9A   ; 1000000000
0973   0A07             ; --- END INLINE ASM SEGMENT
0974   0A07 F9            leave
0975   0A08 09            ret
0976   0A09             
0977   0A09             getchar:
0978   0A09 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0979   0A0C             ; char c; 
0980   0A0C 52 01 00      sub sp, 1
0981   0A0F             ; --- BEGIN INLINE ASM SEGMENT
0982   0A0F 19 01         mov al, 1
0983   0A11 05 03         syscall sys_io      ; receive in AH
0984   0A13 1A            mov al, ah
0985   0A14 FA 00 00      lea d, [bp + 0] ; $c
0986   0A17 3E            mov [d], al
0987   0A18             ; --- END INLINE ASM SEGMENT
0988   0A18             ; return c; 
0989   0A18 FA 00 00      lea d, [bp + 0] ; $c
0990   0A1B 32            mov bl, [d]
0991   0A1C A7 00         mov bh, 0
0992   0A1E 38 00 00      mov c, 0
0993   0A21 F9            leave
0994   0A22 09            ret
0995   0A23             
0996   0A23             gets:
0997   0A23 F8 00 00      enter 0 ; (push bp; mov bp, sp)
0998   0A26             ; --- BEGIN INLINE ASM SEGMENT
0999   0A26 FA 05 00      lea d, [bp + 5] ; $s
1000   0A29 15            mov a, [d]
1001   0A2A 3C            mov d, a
1002   0A2B 07 40 0A      call _gets_gets
1003   0A2E             ; --- END INLINE ASM SEGMENT
1004   0A2E             ; return strlen(s); 
1005   0A2E             ; --- START FUNCTION CALL
1006   0A2E FA 05 00      lea d, [bp + 5] ; $s
1007   0A31 2A            mov b, [d]
1008   0A32 38 00 00      mov c, 0
1009   0A35 FD AB         swp b
1010   0A37 D8            push b
1011   0A38 07 E1 0A      call strlen
1012   0A3B 51 02 00      add sp, 2
1013   0A3E             ; --- END FUNCTION CALL
1014   0A3E F9            leave
1015   0A3F 09            ret
1016   0A40             ; --- BEGIN INLINE ASM SEGMENT
1017   0A40             _gets_gets:
1018   0A40 D7            push a
1019   0A41 DA            push d
1020   0A42             _gets_loop_gets:
1021   0A42 19 01         mov al, 1
1022   0A44 05 03         syscall sys_io      ; receive in AH
1023   0A46 B9 00         cmp al, 0        ; check error code (AL)
1024   0A48 C6 42 0A      je _gets_loop_gets      ; if no char received, retry
1025   0A4B 76 1B         cmp ah, 27
1026   0A4D C6 6E 0A      je _gets_ansi_esc_gets
1027   0A50 76 0A         cmp ah, $0A        ; LF
1028   0A52 C6 D9 0A      je _gets_end_gets
1029   0A55 76 0D         cmp ah, $0D        ; CR
1030   0A57 C6 D9 0A      je _gets_end_gets
1031   0A5A 76 5C         cmp ah, $5C        ; '\\'
1032   0A5C C6 9A 0A      je _gets_escape_gets
1033   0A5F 76 08         cmp ah, $08      ; check for backspace
1034   0A61 C6 6A 0A      je _gets_backspace_gets
1035   0A64 1A            mov al, ah
1036   0A65 3E            mov [d], al
1037   0A66 79            inc d
1038   0A67 0A 42 0A      jmp _gets_loop_gets
1039   0A6A             _gets_backspace_gets:
1040   0A6A 7F            dec d
1041   0A6B 0A 42 0A      jmp _gets_loop_gets
1042   0A6E             _gets_ansi_esc_gets:
1043   0A6E 19 01         mov al, 1
1044   0A70 05 03         syscall sys_io        ; receive in AH without echo
1045   0A72 B9 00         cmp al, 0          ; check error code (AL)
1046   0A74 C6 6E 0A      je _gets_ansi_esc_gets    ; if no char received, retry
1047   0A77 76 5B         cmp ah, '['
1048   0A79 C7 42 0A      jne _gets_loop_gets
1049   0A7C             _gets_ansi_esc_2_gets:
1050   0A7C 19 01         mov al, 1
1051   0A7E 05 03         syscall sys_io          ; receive in AH without echo
1052   0A80 B9 00         cmp al, 0            ; check error code (AL)
1053   0A82 C6 7C 0A      je _gets_ansi_esc_2_gets  ; if no char received, retry
1054   0A85 76 44         cmp ah, 'D'
1055   0A87 C6 92 0A      je _gets_left_arrow_gets
1056   0A8A 76 43         cmp ah, 'C'
1057   0A8C C6 96 0A      je _gets_right_arrow_gets
1058   0A8F 0A 42 0A      jmp _gets_loop_gets
1059   0A92             _gets_left_arrow_gets:
1060   0A92 7F            dec d
1061   0A93 0A 42 0A      jmp _gets_loop_gets
1062   0A96             _gets_right_arrow_gets:
1063   0A96 79            inc d
1064   0A97 0A 42 0A      jmp _gets_loop_gets
1065   0A9A             _gets_escape_gets:
1066   0A9A 19 01         mov al, 1
1067   0A9C 05 03         syscall sys_io      ; receive in AH
1068   0A9E B9 00         cmp al, 0        ; check error code (AL)
1069   0AA0 C6 9A 0A      je _gets_escape_gets      ; if no char received, retry
1070   0AA3 76 6E         cmp ah, 'n'
1071   0AA5 C6 C4 0A      je _gets_LF_gets
1072   0AA8 76 72         cmp ah, 'r'
1073   0AAA C6 CB 0A      je _gets_CR_gets
1074   0AAD 76 30         cmp ah, '0'
1075   0AAF C6 D2 0A      je _gets_NULL_gets
1076   0AB2 76 5C         cmp ah, $5C  
1077   0AB4 C6 BD 0A      je _gets_slash_gets
1078   0AB7 1A            mov al, ah        ; if not a known escape, it is just a normal letter
1079   0AB8 3E            mov [d], al
1080   0AB9 79            inc d
1081   0ABA 0A 42 0A      jmp _gets_loop_gets
1082   0ABD             _gets_slash_gets:
1083   0ABD 19 5C         mov al, $5C
1084   0ABF 3E            mov [d], al
1085   0AC0 79            inc d
1086   0AC1 0A 42 0A      jmp _gets_loop_gets
1087   0AC4             _gets_LF_gets:
1088   0AC4 19 0A         mov al, $0A
1089   0AC6 3E            mov [d], al
1090   0AC7 79            inc d
1091   0AC8 0A 42 0A      jmp _gets_loop_gets
1092   0ACB             _gets_CR_gets:
1093   0ACB 19 0D         mov al, $0D
1094   0ACD 3E            mov [d], al
1095   0ACE 79            inc d
1096   0ACF 0A 42 0A      jmp _gets_loop_gets
1097   0AD2             _gets_NULL_gets:
1098   0AD2 19 00         mov al, $00
1099   0AD4 3E            mov [d], al
1100   0AD5 79            inc d
1101   0AD6 0A 42 0A      jmp _gets_loop_gets
1102   0AD9             _gets_end_gets:
1103   0AD9 19 00         mov al, 0
1104   0ADB 3E            mov [d], al        ; terminate string
1105   0ADC E7            pop d
1106   0ADD E4            pop a
1107   0ADE 09            ret
1108   0ADF             ; --- END INLINE ASM SEGMENT
1109   0ADF F9            leave
1110   0AE0 09            ret
1111   0AE1             
1112   0AE1             strlen:
1113   0AE1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1114   0AE4             ; int length; 
1115   0AE4 52 02 00      sub sp, 2
1116   0AE7             ; length = 0; 
1117   0AE7 FA FF FF      lea d, [bp + -1] ; $length
1118   0AEA DA            push d
1119   0AEB FD 2E 00 00   mov32 cb, $00000000
1119   0AEF 00 00 
1120   0AF1 E7            pop d
1121   0AF2 FD 43         mov [d], b
1122   0AF4             ; while (str[length] != 0) { 
1123   0AF4             _while16_cond:
1124   0AF4 FA 05 00      lea d, [bp + 5] ; $str
1125   0AF7 FD 2A         mov d, [d]
1126   0AF9 D7            push a
1127   0AFA DA            push d
1128   0AFB FA FF FF      lea d, [bp + -1] ; $length
1129   0AFE 2A            mov b, [d]
1130   0AFF 38 00 00      mov c, 0
1131   0B02 E7            pop d
1132   0B03 FD 13 01 00   mma 1 ; mov a, 1; mul a b; add d, b
1133   0B07 E4            pop a
1134   0B08 32            mov bl, [d]
1135   0B09 A7 00         mov bh, 0
1136   0B0B 38 00 00      mov c, 0
1137   0B0E             ; --- START RELATIONAL
1138   0B0E D7            push a
1139   0B0F 11            mov a, b
1140   0B10 FD 2E 00 00   mov32 cb, $00000000
1140   0B14 00 00 
1141   0B16 B0            cmp a, b
1142   0B17 FD 72         sneq ; !=
1143   0B19 E4            pop a
1144   0B1A             ; --- END RELATIONAL
1145   0B1A C0 00 00      cmp b, 0
1146   0B1D C6 33 0B      je _while16_exit
1147   0B20             _while16_block:
1148   0B20             ; length++; 
1149   0B20 FA FF FF      lea d, [bp + -1] ; $length
1150   0B23 2A            mov b, [d]
1151   0B24 38 00 00      mov c, 0
1152   0B27 11            mov a, b
1153   0B28 FD 77         inc b
1154   0B2A FA FF FF      lea d, [bp + -1] ; $length
1155   0B2D FD 43         mov [d], b
1156   0B2F 27            mov b, a
1157   0B30 0A F4 0A      jmp _while16_cond
1158   0B33             _while16_exit:
1159   0B33             ; return length; 
1160   0B33 FA FF FF      lea d, [bp + -1] ; $length
1161   0B36 2A            mov b, [d]
1162   0B37 38 00 00      mov c, 0
1163   0B3A F9            leave
1164   0B3B 09            ret
1165   0B3C             
1166   0B3C             strcpy:
1167   0B3C F8 00 00      enter 0 ; (push bp; mov bp, sp)
1168   0B3F             ; char *psrc; 
1169   0B3F 52 02 00      sub sp, 2
1170   0B42             ; char *pdest; 
1171   0B42 52 02 00      sub sp, 2
1172   0B45             ; psrc = src; 
1173   0B45 FA FF FF      lea d, [bp + -1] ; $psrc
1174   0B48 DA            push d
1175   0B49 FA 07 00      lea d, [bp + 7] ; $src
1176   0B4C 2A            mov b, [d]
1177   0B4D 38 00 00      mov c, 0
1178   0B50 E7            pop d
1179   0B51 FD 43         mov [d], b
1180   0B53             ; pdest = dest; 
1181   0B53 FA FD FF      lea d, [bp + -3] ; $pdest
1182   0B56 DA            push d
1183   0B57 FA 05 00      lea d, [bp + 5] ; $dest
1184   0B5A 2A            mov b, [d]
1185   0B5B 38 00 00      mov c, 0
1186   0B5E E7            pop d
1187   0B5F FD 43         mov [d], b
1188   0B61             ; while(*psrc) *pdest++ = *psrc++; 
1189   0B61             _while17_cond:
1190   0B61 FA FF FF      lea d, [bp + -1] ; $psrc
1191   0B64 2A            mov b, [d]
1192   0B65 38 00 00      mov c, 0
1193   0B68 74            mov d, b
1194   0B69 32            mov bl, [d]
1195   0B6A A7 00         mov bh, 0
1196   0B6C 38 00 00      mov c, 0
1197   0B6F C0 00 00      cmp b, 0
1198   0B72 C6 A3 0B      je _while17_exit
1199   0B75             _while17_block:
1200   0B75             ; *pdest++ = *psrc++; 
1201   0B75 FA FD FF      lea d, [bp + -3] ; $pdest
1202   0B78 2A            mov b, [d]
1203   0B79 38 00 00      mov c, 0
1204   0B7C FD 77         inc b
1205   0B7E FA FD FF      lea d, [bp + -3] ; $pdest
1206   0B81 FD 43         mov [d], b
1207   0B83 FD 7D         dec b
1208   0B85 D8            push b
1209   0B86 FA FF FF      lea d, [bp + -1] ; $psrc
1210   0B89 2A            mov b, [d]
1211   0B8A 38 00 00      mov c, 0
1212   0B8D FD 77         inc b
1213   0B8F FA FF FF      lea d, [bp + -1] ; $psrc
1214   0B92 FD 43         mov [d], b
1215   0B94 FD 7D         dec b
1216   0B96 74            mov d, b
1217   0B97 32            mov bl, [d]
1218   0B98 A7 00         mov bh, 0
1219   0B9A 38 00 00      mov c, 0
1220   0B9D E7            pop d
1221   0B9E FD 3E         mov [d], bl
1222   0BA0 0A 61 0B      jmp _while17_cond
1223   0BA3             _while17_exit:
1224   0BA3             ; *pdest = '\0'; 
1225   0BA3 FA FD FF      lea d, [bp + -3] ; $pdest
1226   0BA6 2A            mov b, [d]
1227   0BA7 38 00 00      mov c, 0
1228   0BAA D8            push b
1229   0BAB FD 2E 00 00   mov32 cb, $00000000
1229   0BAF 00 00 
1230   0BB1 E7            pop d
1231   0BB2 FD 3E         mov [d], bl
1232   0BB4 F9            leave
1233   0BB5 09            ret
1234   0BB6             
1235   0BB6             putchar:
1236   0BB6 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1237   0BB9             ; --- BEGIN INLINE ASM SEGMENT
1238   0BB9 FA 05 00      lea d, [bp + 5] ; $c
1239   0BBC 1E            mov al, [d]
1240   0BBD 23            mov ah, al
1241   0BBE 19 00         mov al, 0
1242   0BC0 05 03         syscall sys_io      ; char in AH
1243   0BC2             ; --- END INLINE ASM SEGMENT
1244   0BC2 F9            leave
1245   0BC3 09            ret
1246   0BC4             
1247   0BC4             printf:
1248   0BC4 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1249   0BC7             ; char *p, *format_p; 
1250   0BC7 52 02 00      sub sp, 2
1251   0BCA 52 02 00      sub sp, 2
1252   0BCD             ; format_p = format; 
1253   0BCD FA FD FF      lea d, [bp + -3] ; $format_p
1254   0BD0 DA            push d
1255   0BD1 FA 05 00      lea d, [bp + 5] ; $format
1256   0BD4 2A            mov b, [d]
1257   0BD5 38 00 00      mov c, 0
1258   0BD8 E7            pop d
1259   0BD9 FD 43         mov [d], b
1260   0BDB             ; p = &format + 2; 
1261   0BDB FA FF FF      lea d, [bp + -1] ; $p
1262   0BDE DA            push d
1263   0BDF FA 05 00      lea d, [bp + 5] ; $format
1264   0BE2 2D            mov b, d
1265   0BE3             ; --- START TERMS
1266   0BE3 D7            push a
1267   0BE4 11            mov a, b
1268   0BE5 FD 2E 02 00   mov32 cb, $00000002
1268   0BE9 00 00 
1269   0BEB 56            add b, a
1270   0BEC E4            pop a
1271   0BED             ; --- END TERMS
1272   0BED E7            pop d
1273   0BEE FD 43         mov [d], b
1274   0BF0             ; for(;;){ 
1275   0BF0             _for18_init:
1276   0BF0             _for18_cond:
1277   0BF0             _for18_block:
1278   0BF0             ; if(!*format_p) break; 
1279   0BF0             _if19_cond:
1280   0BF0 FA FD FF      lea d, [bp + -3] ; $format_p
1281   0BF3 2A            mov b, [d]
1282   0BF4 38 00 00      mov c, 0
1283   0BF7 74            mov d, b
1284   0BF8 32            mov bl, [d]
1285   0BF9 A7 00         mov bh, 0
1286   0BFB 38 00 00      mov c, 0
1287   0BFE C0 00 00      cmp b, 0
1288   0C01 FD 71         seq ; !
1289   0C03 C0 00 00      cmp b, 0
1290   0C06 C6 0F 0C      je _if19_else
1291   0C09             _if19_TRUE:
1292   0C09             ; break; 
1293   0C09 0A AF 0E      jmp _for18_exit ; for break
1294   0C0C 0A 9C 0E      jmp _if19_exit
1295   0C0F             _if19_else:
1296   0C0F             ; if(*format_p == '%'){ 
1297   0C0F             _if20_cond:
1298   0C0F FA FD FF      lea d, [bp + -3] ; $format_p
1299   0C12 2A            mov b, [d]
1300   0C13 38 00 00      mov c, 0
1301   0C16 74            mov d, b
1302   0C17 32            mov bl, [d]
1303   0C18 A7 00         mov bh, 0
1304   0C1A 38 00 00      mov c, 0
1305   0C1D             ; --- START RELATIONAL
1306   0C1D D7            push a
1307   0C1E 11            mov a, b
1308   0C1F FD 2E 25 00   mov32 cb, $00000025
1308   0C23 00 00 
1309   0C25 B0            cmp a, b
1310   0C26 FD 71         seq ; ==
1311   0C28 E4            pop a
1312   0C29             ; --- END RELATIONAL
1313   0C29 C0 00 00      cmp b, 0
1314   0C2C C6 87 0E      je _if20_else
1315   0C2F             _if20_TRUE:
1316   0C2F             ; format_p++; 
1317   0C2F FA FD FF      lea d, [bp + -3] ; $format_p
1318   0C32 2A            mov b, [d]
1319   0C33 38 00 00      mov c, 0
1320   0C36 FD 77         inc b
1321   0C38 FA FD FF      lea d, [bp + -3] ; $format_p
1322   0C3B FD 43         mov [d], b
1323   0C3D FD 7D         dec b
1324   0C3F             ; switch(*format_p){ 
1325   0C3F             _switch21_expr:
1326   0C3F FA FD FF      lea d, [bp + -3] ; $format_p
1327   0C42 2A            mov b, [d]
1328   0C43 38 00 00      mov c, 0
1329   0C46 74            mov d, b
1330   0C47 32            mov bl, [d]
1331   0C48 A7 00         mov bh, 0
1332   0C4A 38 00 00      mov c, 0
1333   0C4D             _switch21_comparisons:
1334   0C4D C1 6C         cmp bl, $6c
1335   0C4F C6 7B 0C      je _switch21_case0
1336   0C52 C1 4C         cmp bl, $4c
1337   0C54 C6 7B 0C      je _switch21_case1
1338   0C57 C1 64         cmp bl, $64
1339   0C59 C6 8B 0D      je _switch21_case2
1340   0C5C C1 69         cmp bl, $69
1341   0C5E C6 8B 0D      je _switch21_case3
1342   0C61 C1 75         cmp bl, $75
1343   0C63 C6 BB 0D      je _switch21_case4
1344   0C66 C1 78         cmp bl, $78
1345   0C68 C6 EB 0D      je _switch21_case5
1346   0C6B C1 63         cmp bl, $63
1347   0C6D C6 1B 0E      je _switch21_case6
1348   0C70 C1 73         cmp bl, $73
1349   0C72 C6 4B 0E      je _switch21_case7
1350   0C75 0A 78 0E      jmp _switch21_default
1351   0C78 0A 84 0E      jmp _switch21_exit
1352   0C7B             _switch21_case0:
1353   0C7B             _switch21_case1:
1354   0C7B             ; format_p++; 
1355   0C7B FA FD FF      lea d, [bp + -3] ; $format_p
1356   0C7E 2A            mov b, [d]
1357   0C7F 38 00 00      mov c, 0
1358   0C82 FD 77         inc b
1359   0C84 FA FD FF      lea d, [bp + -3] ; $format_p
1360   0C87 FD 43         mov [d], b
1361   0C89 FD 7D         dec b
1362   0C8B             ; if(*format_p == 'd' || *format_p == 'i') 
1363   0C8B             _if22_cond:
1364   0C8B FA FD FF      lea d, [bp + -3] ; $format_p
1365   0C8E 2A            mov b, [d]
1366   0C8F 38 00 00      mov c, 0
1367   0C92 74            mov d, b
1368   0C93 32            mov bl, [d]
1369   0C94 A7 00         mov bh, 0
1370   0C96 38 00 00      mov c, 0
1371   0C99             ; --- START RELATIONAL
1372   0C99 D7            push a
1373   0C9A 11            mov a, b
1374   0C9B FD 2E 64 00   mov32 cb, $00000064
1374   0C9F 00 00 
1375   0CA1 B0            cmp a, b
1376   0CA2 FD 71         seq ; ==
1377   0CA4 E4            pop a
1378   0CA5             ; --- END RELATIONAL
1379   0CA5             ; --- START LOGICAL OR
1380   0CA5 D7            push a
1381   0CA6 11            mov a, b
1382   0CA7 FA FD FF      lea d, [bp + -3] ; $format_p
1383   0CAA 2A            mov b, [d]
1384   0CAB 38 00 00      mov c, 0
1385   0CAE 74            mov d, b
1386   0CAF 32            mov bl, [d]
1387   0CB0 A7 00         mov bh, 0
1388   0CB2 38 00 00      mov c, 0
1389   0CB5             ; --- START RELATIONAL
1390   0CB5 D7            push a
1391   0CB6 11            mov a, b
1392   0CB7 FD 2E 69 00   mov32 cb, $00000069
1392   0CBB 00 00 
1393   0CBD B0            cmp a, b
1394   0CBE FD 71         seq ; ==
1395   0CC0 E4            pop a
1396   0CC1             ; --- END RELATIONAL
1397   0CC1 FD A8         sor a, b ; ||
1398   0CC3 E4            pop a
1399   0CC4             ; --- END LOGICAL OR
1400   0CC4 C0 00 00      cmp b, 0
1401   0CC7 C6 E8 0C      je _if22_else
1402   0CCA             _if22_TRUE:
1403   0CCA             ; print_signed_long(*(long *)p); 
1404   0CCA             ; --- START FUNCTION CALL
1405   0CCA FA FF FF      lea d, [bp + -1] ; $p
1406   0CCD 2A            mov b, [d]
1407   0CCE 38 00 00      mov c, 0
1408   0CD1 74            mov d, b
1409   0CD2 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1410   0CD5 FD 39         mov c, b ; And place it into C
1411   0CD7 2A            mov b, [d] ; Lower Word in B
1412   0CD8 12            mov a, c
1413   0CD9 FD AA         swp a
1414   0CDB D7            push a
1415   0CDC FD AB         swp b
1416   0CDE D8            push b
1417   0CDF 07 B1 0E      call print_signed_long
1418   0CE2 51 04 00      add sp, 4
1419   0CE5             ; --- END FUNCTION CALL
1420   0CE5 0A 70 0D      jmp _if22_exit
1421   0CE8             _if22_else:
1422   0CE8             ; if(*format_p == 'u') 
1423   0CE8             _if23_cond:
1424   0CE8 FA FD FF      lea d, [bp + -3] ; $format_p
1425   0CEB 2A            mov b, [d]
1426   0CEC 38 00 00      mov c, 0
1427   0CEF 74            mov d, b
1428   0CF0 32            mov bl, [d]
1429   0CF1 A7 00         mov bh, 0
1430   0CF3 38 00 00      mov c, 0
1431   0CF6             ; --- START RELATIONAL
1432   0CF6 D7            push a
1433   0CF7 11            mov a, b
1434   0CF8 FD 2E 75 00   mov32 cb, $00000075
1434   0CFC 00 00 
1435   0CFE B0            cmp a, b
1436   0CFF FD 71         seq ; ==
1437   0D01 E4            pop a
1438   0D02             ; --- END RELATIONAL
1439   0D02 C0 00 00      cmp b, 0
1440   0D05 C6 26 0D      je _if23_else
1441   0D08             _if23_TRUE:
1442   0D08             ; print_unsigned_long(*(unsigned long *)p); 
1443   0D08             ; --- START FUNCTION CALL
1444   0D08 FA FF FF      lea d, [bp + -1] ; $p
1445   0D0B 2A            mov b, [d]
1446   0D0C 38 00 00      mov c, 0
1447   0D0F 74            mov d, b
1448   0D10 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1449   0D13 FD 39         mov c, b ; And place it into C
1450   0D15 2A            mov b, [d] ; Lower Word in B
1451   0D16 12            mov a, c
1452   0D17 FD AA         swp a
1453   0D19 D7            push a
1454   0D1A FD AB         swp b
1455   0D1C D8            push b
1456   0D1D 07 43 10      call print_unsigned_long
1457   0D20 51 04 00      add sp, 4
1458   0D23             ; --- END FUNCTION CALL
1459   0D23 0A 70 0D      jmp _if23_exit
1460   0D26             _if23_else:
1461   0D26             ; if(*format_p == 'x') 
1462   0D26             _if24_cond:
1463   0D26 FA FD FF      lea d, [bp + -3] ; $format_p
1464   0D29 2A            mov b, [d]
1465   0D2A 38 00 00      mov c, 0
1466   0D2D 74            mov d, b
1467   0D2E 32            mov bl, [d]
1468   0D2F A7 00         mov bh, 0
1469   0D31 38 00 00      mov c, 0
1470   0D34             ; --- START RELATIONAL
1471   0D34 D7            push a
1472   0D35 11            mov a, b
1473   0D36 FD 2E 78 00   mov32 cb, $00000078
1473   0D3A 00 00 
1474   0D3C B0            cmp a, b
1475   0D3D FD 71         seq ; ==
1476   0D3F E4            pop a
1477   0D40             ; --- END RELATIONAL
1478   0D40 C0 00 00      cmp b, 0
1479   0D43 C6 64 0D      je _if24_else
1480   0D46             _if24_TRUE:
1481   0D46             ; printx32(*(long int *)p); 
1482   0D46             ; --- START FUNCTION CALL
1483   0D46 FA FF FF      lea d, [bp + -1] ; $p
1484   0D49 2A            mov b, [d]
1485   0D4A 38 00 00      mov c, 0
1486   0D4D 74            mov d, b
1487   0D4E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1488   0D51 FD 39         mov c, b ; And place it into C
1489   0D53 2A            mov b, [d] ; Lower Word in B
1490   0D54 12            mov a, c
1491   0D55 FD AA         swp a
1492   0D57 D7            push a
1493   0D58 FD AB         swp b
1494   0D5A D8            push b
1495   0D5B 07 81 11      call printx32
1496   0D5E 51 04 00      add sp, 4
1497   0D61             ; --- END FUNCTION CALL
1498   0D61 0A 70 0D      jmp _if24_exit
1499   0D64             _if24_else:
1500   0D64             ; err("Unexpected format in printf."); 
1501   0D64             ; --- START FUNCTION CALL
1502   0D64 26 D8 14      mov b, _s5 ; "Unexpected format in printf."
1503   0D67 FD AB         swp b
1504   0D69 D8            push b
1505   0D6A 07 E3 08      call err
1506   0D6D 51 02 00      add sp, 2
1507   0D70             ; --- END FUNCTION CALL
1508   0D70             _if24_exit:
1509   0D70             _if23_exit:
1510   0D70             _if22_exit:
1511   0D70             ; p = p + 4; 
1512   0D70 FA FF FF      lea d, [bp + -1] ; $p
1513   0D73 DA            push d
1514   0D74 FA FF FF      lea d, [bp + -1] ; $p
1515   0D77 2A            mov b, [d]
1516   0D78 38 00 00      mov c, 0
1517   0D7B             ; --- START TERMS
1518   0D7B D7            push a
1519   0D7C 11            mov a, b
1520   0D7D FD 2E 04 00   mov32 cb, $00000004
1520   0D81 00 00 
1521   0D83 56            add b, a
1522   0D84 E4            pop a
1523   0D85             ; --- END TERMS
1524   0D85 E7            pop d
1525   0D86 FD 43         mov [d], b
1526   0D88             ; break; 
1527   0D88 0A 84 0E      jmp _switch21_exit ; case break
1528   0D8B             _switch21_case2:
1529   0D8B             _switch21_case3:
1530   0D8B             ; print_signed(*(int*)p); 
1531   0D8B             ; --- START FUNCTION CALL
1532   0D8B FA FF FF      lea d, [bp + -1] ; $p
1533   0D8E 2A            mov b, [d]
1534   0D8F 38 00 00      mov c, 0
1535   0D92 74            mov d, b
1536   0D93 2A            mov b, [d]
1537   0D94 38 00 00      mov c, 0
1538   0D97 FD AB         swp b
1539   0D99 D8            push b
1540   0D9A 07 E1 11      call print_signed
1541   0D9D 51 02 00      add sp, 2
1542   0DA0             ; --- END FUNCTION CALL
1543   0DA0             ; p = p + 2; 
1544   0DA0 FA FF FF      lea d, [bp + -1] ; $p
1545   0DA3 DA            push d
1546   0DA4 FA FF FF      lea d, [bp + -1] ; $p
1547   0DA7 2A            mov b, [d]
1548   0DA8 38 00 00      mov c, 0
1549   0DAB             ; --- START TERMS
1550   0DAB D7            push a
1551   0DAC 11            mov a, b
1552   0DAD FD 2E 02 00   mov32 cb, $00000002
1552   0DB1 00 00 
1553   0DB3 56            add b, a
1554   0DB4 E4            pop a
1555   0DB5             ; --- END TERMS
1556   0DB5 E7            pop d
1557   0DB6 FD 43         mov [d], b
1558   0DB8             ; break; 
1559   0DB8 0A 84 0E      jmp _switch21_exit ; case break
1560   0DBB             _switch21_case4:
1561   0DBB             ; print_unsigned(*(unsigned int*)p); 
1562   0DBB             ; --- START FUNCTION CALL
1563   0DBB FA FF FF      lea d, [bp + -1] ; $p
1564   0DBE 2A            mov b, [d]
1565   0DBF 38 00 00      mov c, 0
1566   0DC2 74            mov d, b
1567   0DC3 2A            mov b, [d]
1568   0DC4 38 00 00      mov c, 0
1569   0DC7 FD AB         swp b
1570   0DC9 D8            push b
1571   0DCA 07 32 13      call print_unsigned
1572   0DCD 51 02 00      add sp, 2
1573   0DD0             ; --- END FUNCTION CALL
1574   0DD0             ; p = p + 2; 
1575   0DD0 FA FF FF      lea d, [bp + -1] ; $p
1576   0DD3 DA            push d
1577   0DD4 FA FF FF      lea d, [bp + -1] ; $p
1578   0DD7 2A            mov b, [d]
1579   0DD8 38 00 00      mov c, 0
1580   0DDB             ; --- START TERMS
1581   0DDB D7            push a
1582   0DDC 11            mov a, b
1583   0DDD FD 2E 02 00   mov32 cb, $00000002
1583   0DE1 00 00 
1584   0DE3 56            add b, a
1585   0DE4 E4            pop a
1586   0DE5             ; --- END TERMS
1587   0DE5 E7            pop d
1588   0DE6 FD 43         mov [d], b
1589   0DE8             ; break; 
1590   0DE8 0A 84 0E      jmp _switch21_exit ; case break
1591   0DEB             _switch21_case5:
1592   0DEB             ; printx16(*(int*)p); 
1593   0DEB             ; --- START FUNCTION CALL
1594   0DEB FA FF FF      lea d, [bp + -1] ; $p
1595   0DEE 2A            mov b, [d]
1596   0DEF 38 00 00      mov c, 0
1597   0DF2 74            mov d, b
1598   0DF3 2A            mov b, [d]
1599   0DF4 38 00 00      mov c, 0
1600   0DF7 FD AB         swp b
1601   0DF9 D8            push b
1602   0DFA 07 4A 14      call printx16
1603   0DFD 51 02 00      add sp, 2
1604   0E00             ; --- END FUNCTION CALL
1605   0E00             ; p = p + 2; 
1606   0E00 FA FF FF      lea d, [bp + -1] ; $p
1607   0E03 DA            push d
1608   0E04 FA FF FF      lea d, [bp + -1] ; $p
1609   0E07 2A            mov b, [d]
1610   0E08 38 00 00      mov c, 0
1611   0E0B             ; --- START TERMS
1612   0E0B D7            push a
1613   0E0C 11            mov a, b
1614   0E0D FD 2E 02 00   mov32 cb, $00000002
1614   0E11 00 00 
1615   0E13 56            add b, a
1616   0E14 E4            pop a
1617   0E15             ; --- END TERMS
1618   0E15 E7            pop d
1619   0E16 FD 43         mov [d], b
1620   0E18             ; break; 
1621   0E18 0A 84 0E      jmp _switch21_exit ; case break
1622   0E1B             _switch21_case6:
1623   0E1B             ; putchar(*(char*)p); 
1624   0E1B             ; --- START FUNCTION CALL
1625   0E1B FA FF FF      lea d, [bp + -1] ; $p
1626   0E1E 2A            mov b, [d]
1627   0E1F 38 00 00      mov c, 0
1628   0E22 74            mov d, b
1629   0E23 32            mov bl, [d]
1630   0E24 A7 00         mov bh, 0
1631   0E26 38 00 00      mov c, 0
1632   0E29 DD            push bl
1633   0E2A 07 B6 0B      call putchar
1634   0E2D 51 01 00      add sp, 1
1635   0E30             ; --- END FUNCTION CALL
1636   0E30             ; p = p + 2; 
1637   0E30 FA FF FF      lea d, [bp + -1] ; $p
1638   0E33 DA            push d
1639   0E34 FA FF FF      lea d, [bp + -1] ; $p
1640   0E37 2A            mov b, [d]
1641   0E38 38 00 00      mov c, 0
1642   0E3B             ; --- START TERMS
1643   0E3B D7            push a
1644   0E3C 11            mov a, b
1645   0E3D FD 2E 02 00   mov32 cb, $00000002
1645   0E41 00 00 
1646   0E43 56            add b, a
1647   0E44 E4            pop a
1648   0E45             ; --- END TERMS
1649   0E45 E7            pop d
1650   0E46 FD 43         mov [d], b
1651   0E48             ; break; 
1652   0E48 0A 84 0E      jmp _switch21_exit ; case break
1653   0E4B             _switch21_case7:
1654   0E4B             ; print(*(char**)p); 
1655   0E4B             ; --- START FUNCTION CALL
1656   0E4B FA FF FF      lea d, [bp + -1] ; $p
1657   0E4E 2A            mov b, [d]
1658   0E4F 38 00 00      mov c, 0
1659   0E52 74            mov d, b
1660   0E53 2A            mov b, [d]
1661   0E54 FD AB         swp b
1662   0E56 D8            push b
1663   0E57 07 EC 05      call print
1664   0E5A 51 02 00      add sp, 2
1665   0E5D             ; --- END FUNCTION CALL
1666   0E5D             ; p = p + 2; 
1667   0E5D FA FF FF      lea d, [bp + -1] ; $p
1668   0E60 DA            push d
1669   0E61 FA FF FF      lea d, [bp + -1] ; $p
1670   0E64 2A            mov b, [d]
1671   0E65 38 00 00      mov c, 0
1672   0E68             ; --- START TERMS
1673   0E68 D7            push a
1674   0E69 11            mov a, b
1675   0E6A FD 2E 02 00   mov32 cb, $00000002
1675   0E6E 00 00 
1676   0E70 56            add b, a
1677   0E71 E4            pop a
1678   0E72             ; --- END TERMS
1679   0E72 E7            pop d
1680   0E73 FD 43         mov [d], b
1681   0E75             ; break; 
1682   0E75 0A 84 0E      jmp _switch21_exit ; case break
1683   0E78             _switch21_default:
1684   0E78             ; print("Error: Unknown argument type.\n"); 
1685   0E78             ; --- START FUNCTION CALL
1686   0E78 26 F5 14      mov b, _s6 ; "Error: Unknown argument type.\n"
1687   0E7B FD AB         swp b
1688   0E7D D8            push b
1689   0E7E 07 EC 05      call print
1690   0E81 51 02 00      add sp, 2
1691   0E84             ; --- END FUNCTION CALL
1692   0E84             _switch21_exit:
1693   0E84 0A 9C 0E      jmp _if20_exit
1694   0E87             _if20_else:
1695   0E87             ; putchar(*format_p); 
1696   0E87             ; --- START FUNCTION CALL
1697   0E87 FA FD FF      lea d, [bp + -3] ; $format_p
1698   0E8A 2A            mov b, [d]
1699   0E8B 38 00 00      mov c, 0
1700   0E8E 74            mov d, b
1701   0E8F 32            mov bl, [d]
1702   0E90 A7 00         mov bh, 0
1703   0E92 38 00 00      mov c, 0
1704   0E95 DD            push bl
1705   0E96 07 B6 0B      call putchar
1706   0E99 51 01 00      add sp, 1
1707   0E9C             ; --- END FUNCTION CALL
1708   0E9C             _if20_exit:
1709   0E9C             _if19_exit:
1710   0E9C             ; format_p++; 
1711   0E9C FA FD FF      lea d, [bp + -3] ; $format_p
1712   0E9F 2A            mov b, [d]
1713   0EA0 38 00 00      mov c, 0
1714   0EA3 FD 77         inc b
1715   0EA5 FA FD FF      lea d, [bp + -3] ; $format_p
1716   0EA8 FD 43         mov [d], b
1717   0EAA FD 7D         dec b
1718   0EAC             _for18_update:
1719   0EAC 0A F0 0B      jmp _for18_cond
1720   0EAF             _for18_exit:
1721   0EAF F9            leave
1722   0EB0 09            ret
1723   0EB1             
1724   0EB1             print_signed_long:
1725   0EB1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1726   0EB4             ; char digits[10]; 
1727   0EB4 52 0A 00      sub sp, 10
1728   0EB7             ; int i = 0; 
1729   0EB7 52 02 00      sub sp, 2
1730   0EBA             ; --- START LOCAL VAR INITIALIZATION
1731   0EBA FA F5 FF      lea d, [bp + -11] ; $i
1732   0EBD DA            push d
1733   0EBE FD 2E 00 00   mov32 cb, $00000000
1733   0EC2 00 00 
1734   0EC4 E7            pop d
1735   0EC5 FD 43         mov [d], b
1736   0EC7             ; --- END LOCAL VAR INITIALIZATION
1737   0EC7             ; if (num < 0) { 
1738   0EC7             _if25_cond:
1739   0EC7 FA 05 00      lea d, [bp + 5] ; $num
1740   0ECA 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1741   0ECD FD 39         mov c, b ; And place it into C
1742   0ECF 2A            mov b, [d] ; Lower Word in B
1743   0ED0             ; --- START RELATIONAL
1744   0ED0 D7            push a
1745   0ED1 FD D8         push g
1746   0ED3 11            mov a, b
1747   0ED4 FD 7A         mov g, c
1748   0ED6 FD 2E 00 00   mov32 cb, $00000000
1748   0EDA 00 00 
1749   0EDC 38 00 00      mov c, 0
1750   0EDF FD AF         cmp32 ga, cb
1751   0EE1 FD 73         slt ; <
1752   0EE3 FD F1         pop g
1753   0EE5 E4            pop a
1754   0EE6             ; --- END RELATIONAL
1755   0EE6 C0 00 00      cmp b, 0
1756   0EE9 C6 1B 0F      je _if25_else
1757   0EEC             _if25_TRUE:
1758   0EEC             ; putchar('-'); 
1759   0EEC             ; --- START FUNCTION CALL
1760   0EEC FD 2E 2D 00   mov32 cb, $0000002d
1760   0EF0 00 00 
1761   0EF2 DD            push bl
1762   0EF3 07 B6 0B      call putchar
1763   0EF6 51 01 00      add sp, 1
1764   0EF9             ; --- END FUNCTION CALL
1765   0EF9             ; num = -num; 
1766   0EF9 FA 05 00      lea d, [bp + 5] ; $num
1767   0EFC DA            push d
1768   0EFD FA 05 00      lea d, [bp + 5] ; $num
1769   0F00 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1770   0F03 FD 39         mov c, b ; And place it into C
1771   0F05 2A            mov b, [d] ; Lower Word in B
1772   0F06 12            mov a, c
1773   0F07 95            not a
1774   0F08 97            not b
1775   0F09 55 01 00      add b, 1
1776   0F0C 5B 00 00      adc a, 0
1777   0F0F 39            mov c, a
1778   0F10 E7            pop d
1779   0F11 FD 43         mov [d], b
1780   0F13 28            mov b, c
1781   0F14 FD 44 02 00   mov [d + 2], b
1782   0F18 0A 52 0F      jmp _if25_exit
1783   0F1B             _if25_else:
1784   0F1B             ; if (num == 0) { 
1785   0F1B             _if26_cond:
1786   0F1B FA 05 00      lea d, [bp + 5] ; $num
1787   0F1E 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1788   0F21 FD 39         mov c, b ; And place it into C
1789   0F23 2A            mov b, [d] ; Lower Word in B
1790   0F24             ; --- START RELATIONAL
1791   0F24 D7            push a
1792   0F25 FD D8         push g
1793   0F27 11            mov a, b
1794   0F28 FD 7A         mov g, c
1795   0F2A FD 2E 00 00   mov32 cb, $00000000
1795   0F2E 00 00 
1796   0F30 38 00 00      mov c, 0
1797   0F33 FD AF         cmp32 ga, cb
1798   0F35 FD 71         seq ; ==
1799   0F37 FD F1         pop g
1800   0F39 E4            pop a
1801   0F3A             ; --- END RELATIONAL
1802   0F3A C0 00 00      cmp b, 0
1803   0F3D C6 52 0F      je _if26_exit
1804   0F40             _if26_TRUE:
1805   0F40             ; putchar('0'); 
1806   0F40             ; --- START FUNCTION CALL
1807   0F40 FD 2E 30 00   mov32 cb, $00000030
1807   0F44 00 00 
1808   0F46 DD            push bl
1809   0F47 07 B6 0B      call putchar
1810   0F4A 51 01 00      add sp, 1
1811   0F4D             ; --- END FUNCTION CALL
1812   0F4D             ; return; 
1813   0F4D F9            leave
1814   0F4E 09            ret
1815   0F4F 0A 52 0F      jmp _if26_exit
1816   0F52             _if26_exit:
1817   0F52             _if25_exit:
1818   0F52             ; while (num > 0) { 
1819   0F52             _while27_cond:
1820   0F52 FA 05 00      lea d, [bp + 5] ; $num
1821   0F55 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1822   0F58 FD 39         mov c, b ; And place it into C
1823   0F5A 2A            mov b, [d] ; Lower Word in B
1824   0F5B             ; --- START RELATIONAL
1825   0F5B D7            push a
1826   0F5C FD D8         push g
1827   0F5E 11            mov a, b
1828   0F5F FD 7A         mov g, c
1829   0F61 FD 2E 00 00   mov32 cb, $00000000
1829   0F65 00 00 
1830   0F67 38 00 00      mov c, 0
1831   0F6A FD AF         cmp32 ga, cb
1832   0F6C FD 7F         sgt
1833   0F6E FD F1         pop g
1834   0F70 E4            pop a
1835   0F71             ; --- END RELATIONAL
1836   0F71 C0 00 00      cmp b, 0
1837   0F74 C6 F9 0F      je _while27_exit
1838   0F77             _while27_block:
1839   0F77             ; digits[i] = '0' + (num % 10); 
1840   0F77 FA F7 FF      lea d, [bp + -9] ; $digits
1841   0F7A D7            push a
1842   0F7B DA            push d
1843   0F7C FA F5 FF      lea d, [bp + -11] ; $i
1844   0F7F 2A            mov b, [d]
1845   0F80 38 00 00      mov c, 0
1846   0F83 E7            pop d
1847   0F84 5A            add d, b
1848   0F85 E4            pop a
1849   0F86 DA            push d
1850   0F87 FD 2E 30 00   mov32 cb, $00000030
1850   0F8B 00 00 
1851   0F8D             ; --- START TERMS
1852   0F8D D7            push a
1853   0F8E 11            mov a, b
1854   0F8F FA 05 00      lea d, [bp + 5] ; $num
1855   0F92 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1856   0F95 FD 39         mov c, b ; And place it into C
1857   0F97 2A            mov b, [d] ; Lower Word in B
1858   0F98             ; --- START FACTORS
1859   0F98 D7            push a
1860   0F99 FD D8         push g
1861   0F9B 11            mov a, b
1862   0F9C FD 7A         mov g, c
1863   0F9E FD 2E 0A 00   mov32 cb, $0000000a
1863   0FA2 00 00 
1864   0FA4 FD D8         push g ; save 'g' as the div instruction uses it
1865   0FA6 AE            div a, b ; %, a: quotient, b: remainder
1866   0FA7 11            mov a, b
1867   0FA8 FD F1         pop g
1868   0FAA FD 38         mov c, g
1869   0FAC 27            mov b, a
1870   0FAD FD F1         pop g
1871   0FAF E4            pop a
1872   0FB0             ; --- END FACTORS
1873   0FB0 FD 22 00 00   mov g, 0
1874   0FB4 FD 15         add32 cb, ga
1875   0FB6 E4            pop a
1876   0FB7             ; --- END TERMS
1877   0FB7 E7            pop d
1878   0FB8 FD 3E         mov [d], bl
1879   0FBA             ; num = num / 10; 
1880   0FBA FA 05 00      lea d, [bp + 5] ; $num
1881   0FBD DA            push d
1882   0FBE FA 05 00      lea d, [bp + 5] ; $num
1883   0FC1 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1884   0FC4 FD 39         mov c, b ; And place it into C
1885   0FC6 2A            mov b, [d] ; Lower Word in B
1886   0FC7             ; --- START FACTORS
1887   0FC7 D7            push a
1888   0FC8 FD D8         push g
1889   0FCA 11            mov a, b
1890   0FCB FD 7A         mov g, c
1891   0FCD FD 2E 0A 00   mov32 cb, $0000000a
1891   0FD1 00 00 
1892   0FD3 FD D8         push g ; save 'g' as the div instruction uses it
1893   0FD5 AE            div a, b ; /, a: quotient, b: remainder
1894   0FD6 FD F1         pop g
1895   0FD8 FD 38         mov c, g
1896   0FDA 27            mov b, a
1897   0FDB FD F1         pop g
1898   0FDD E4            pop a
1899   0FDE             ; --- END FACTORS
1900   0FDE E7            pop d
1901   0FDF FD 43         mov [d], b
1902   0FE1 28            mov b, c
1903   0FE2 FD 44 02 00   mov [d + 2], b
1904   0FE6             ; i++; 
1905   0FE6 FA F5 FF      lea d, [bp + -11] ; $i
1906   0FE9 2A            mov b, [d]
1907   0FEA 38 00 00      mov c, 0
1908   0FED 11            mov a, b
1909   0FEE FD 77         inc b
1910   0FF0 FA F5 FF      lea d, [bp + -11] ; $i
1911   0FF3 FD 43         mov [d], b
1912   0FF5 27            mov b, a
1913   0FF6 0A 52 0F      jmp _while27_cond
1914   0FF9             _while27_exit:
1915   0FF9             ; while (i > 0) { 
1916   0FF9             _while34_cond:
1917   0FF9 FA F5 FF      lea d, [bp + -11] ; $i
1918   0FFC 2A            mov b, [d]
1919   0FFD 38 00 00      mov c, 0
1920   1000             ; --- START RELATIONAL
1921   1000 D7            push a
1922   1001 11            mov a, b
1923   1002 FD 2E 00 00   mov32 cb, $00000000
1923   1006 00 00 
1924   1008 B0            cmp a, b
1925   1009 FD 7F         sgt ; >
1926   100B E4            pop a
1927   100C             ; --- END RELATIONAL
1928   100C C0 00 00      cmp b, 0
1929   100F C6 41 10      je _while34_exit
1930   1012             _while34_block:
1931   1012             ; i--; 
1932   1012 FA F5 FF      lea d, [bp + -11] ; $i
1933   1015 2A            mov b, [d]
1934   1016 38 00 00      mov c, 0
1935   1019 11            mov a, b
1936   101A FD 7D         dec b
1937   101C FA F5 FF      lea d, [bp + -11] ; $i
1938   101F FD 43         mov [d], b
1939   1021 27            mov b, a
1940   1022             ; putchar(digits[i]); 
1941   1022             ; --- START FUNCTION CALL
1942   1022 FA F7 FF      lea d, [bp + -9] ; $digits
1943   1025 D7            push a
1944   1026 DA            push d
1945   1027 FA F5 FF      lea d, [bp + -11] ; $i
1946   102A 2A            mov b, [d]
1947   102B 38 00 00      mov c, 0
1948   102E E7            pop d
1949   102F 5A            add d, b
1950   1030 E4            pop a
1951   1031 32            mov bl, [d]
1952   1032 A7 00         mov bh, 0
1953   1034 38 00 00      mov c, 0
1954   1037 DD            push bl
1955   1038 07 B6 0B      call putchar
1956   103B 51 01 00      add sp, 1
1957   103E             ; --- END FUNCTION CALL
1958   103E 0A F9 0F      jmp _while34_cond
1959   1041             _while34_exit:
1960   1041 F9            leave
1961   1042 09            ret
1962   1043             
1963   1043             print_unsigned_long:
1964   1043 F8 00 00      enter 0 ; (push bp; mov bp, sp)
1965   1046             ; char digits[10]; 
1966   1046 52 0A 00      sub sp, 10
1967   1049             ; int i; 
1968   1049 52 02 00      sub sp, 2
1969   104C             ; i = 0; 
1970   104C FA F5 FF      lea d, [bp + -11] ; $i
1971   104F DA            push d
1972   1050 FD 2E 00 00   mov32 cb, $00000000
1972   1054 00 00 
1973   1056 E7            pop d
1974   1057 FD 43         mov [d], b
1975   1059             ; if(num == 0){ 
1976   1059             _if35_cond:
1977   1059 FA 05 00      lea d, [bp + 5] ; $num
1978   105C 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
1979   105F FD 39         mov c, b ; And place it into C
1980   1061 2A            mov b, [d] ; Lower Word in B
1981   1062             ; --- START RELATIONAL
1982   1062 D7            push a
1983   1063 FD D8         push g
1984   1065 11            mov a, b
1985   1066 FD 7A         mov g, c
1986   1068 FD 2E 00 00   mov32 cb, $00000000
1986   106C 00 00 
1987   106E 38 00 00      mov c, 0
1988   1071 FD AF         cmp32 ga, cb
1989   1073 FD 71         seq ; ==
1990   1075 FD F1         pop g
1991   1077 E4            pop a
1992   1078             ; --- END RELATIONAL
1993   1078 C0 00 00      cmp b, 0
1994   107B C6 90 10      je _if35_exit
1995   107E             _if35_TRUE:
1996   107E             ; putchar('0'); 
1997   107E             ; --- START FUNCTION CALL
1998   107E FD 2E 30 00   mov32 cb, $00000030
1998   1082 00 00 
1999   1084 DD            push bl
2000   1085 07 B6 0B      call putchar
2001   1088 51 01 00      add sp, 1
2002   108B             ; --- END FUNCTION CALL
2003   108B             ; return; 
2004   108B F9            leave
2005   108C 09            ret
2006   108D 0A 90 10      jmp _if35_exit
2007   1090             _if35_exit:
2008   1090             ; while (num > 0) { 
2009   1090             _while36_cond:
2010   1090 FA 05 00      lea d, [bp + 5] ; $num
2011   1093 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2012   1096 FD 39         mov c, b ; And place it into C
2013   1098 2A            mov b, [d] ; Lower Word in B
2014   1099             ; --- START RELATIONAL
2015   1099 D7            push a
2016   109A FD D8         push g
2017   109C 11            mov a, b
2018   109D FD 7A         mov g, c
2019   109F FD 2E 00 00   mov32 cb, $00000000
2019   10A3 00 00 
2020   10A5 38 00 00      mov c, 0
2021   10A8 FD AF         cmp32 ga, cb
2022   10AA FD 81         sgu
2023   10AC FD F1         pop g
2024   10AE E4            pop a
2025   10AF             ; --- END RELATIONAL
2026   10AF C0 00 00      cmp b, 0
2027   10B2 C6 37 11      je _while36_exit
2028   10B5             _while36_block:
2029   10B5             ; digits[i] = '0' + (num % 10); 
2030   10B5 FA F7 FF      lea d, [bp + -9] ; $digits
2031   10B8 D7            push a
2032   10B9 DA            push d
2033   10BA FA F5 FF      lea d, [bp + -11] ; $i
2034   10BD 2A            mov b, [d]
2035   10BE 38 00 00      mov c, 0
2036   10C1 E7            pop d
2037   10C2 5A            add d, b
2038   10C3 E4            pop a
2039   10C4 DA            push d
2040   10C5 FD 2E 30 00   mov32 cb, $00000030
2040   10C9 00 00 
2041   10CB             ; --- START TERMS
2042   10CB D7            push a
2043   10CC 11            mov a, b
2044   10CD FA 05 00      lea d, [bp + 5] ; $num
2045   10D0 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2046   10D3 FD 39         mov c, b ; And place it into C
2047   10D5 2A            mov b, [d] ; Lower Word in B
2048   10D6             ; --- START FACTORS
2049   10D6 D7            push a
2050   10D7 FD D8         push g
2051   10D9 11            mov a, b
2052   10DA FD 7A         mov g, c
2053   10DC FD 2E 0A 00   mov32 cb, $0000000a
2053   10E0 00 00 
2054   10E2 FD D8         push g ; save 'g' as the div instruction uses it
2055   10E4 AE            div a, b ; %, a: quotient, b: remainder
2056   10E5 11            mov a, b
2057   10E6 FD F1         pop g
2058   10E8 FD 38         mov c, g
2059   10EA 27            mov b, a
2060   10EB FD F1         pop g
2061   10ED E4            pop a
2062   10EE             ; --- END FACTORS
2063   10EE FD 22 00 00   mov g, 0
2064   10F2 FD 15         add32 cb, ga
2065   10F4 E4            pop a
2066   10F5             ; --- END TERMS
2067   10F5 E7            pop d
2068   10F6 FD 3E         mov [d], bl
2069   10F8             ; num = num / 10; 
2070   10F8 FA 05 00      lea d, [bp + 5] ; $num
2071   10FB DA            push d
2072   10FC FA 05 00      lea d, [bp + 5] ; $num
2073   10FF 2B 02 00      mov b, [d + 2] ; Upper Word of the Long Int
2074   1102 FD 39         mov c, b ; And place it into C
2075   1104 2A            mov b, [d] ; Lower Word in B
2076   1105             ; --- START FACTORS
2077   1105 D7            push a
2078   1106 FD D8         push g
2079   1108 11            mov a, b
2080   1109 FD 7A         mov g, c
2081   110B FD 2E 0A 00   mov32 cb, $0000000a
2081   110F 00 00 
2082   1111 FD D8         push g ; save 'g' as the div instruction uses it
2083   1113 AE            div a, b ; /, a: quotient, b: remainder
2084   1114 FD F1         pop g
2085   1116 FD 38         mov c, g
2086   1118 27            mov b, a
2087   1119 FD F1         pop g
2088   111B E4            pop a
2089   111C             ; --- END FACTORS
2090   111C E7            pop d
2091   111D FD 43         mov [d], b
2092   111F 28            mov b, c
2093   1120 FD 44 02 00   mov [d + 2], b
2094   1124             ; i++; 
2095   1124 FA F5 FF      lea d, [bp + -11] ; $i
2096   1127 2A            mov b, [d]
2097   1128 38 00 00      mov c, 0
2098   112B 11            mov a, b
2099   112C FD 77         inc b
2100   112E FA F5 FF      lea d, [bp + -11] ; $i
2101   1131 FD 43         mov [d], b
2102   1133 27            mov b, a
2103   1134 0A 90 10      jmp _while36_cond
2104   1137             _while36_exit:
2105   1137             ; while (i > 0) { 
2106   1137             _while43_cond:
2107   1137 FA F5 FF      lea d, [bp + -11] ; $i
2108   113A 2A            mov b, [d]
2109   113B 38 00 00      mov c, 0
2110   113E             ; --- START RELATIONAL
2111   113E D7            push a
2112   113F 11            mov a, b
2113   1140 FD 2E 00 00   mov32 cb, $00000000
2113   1144 00 00 
2114   1146 B0            cmp a, b
2115   1147 FD 7F         sgt ; >
2116   1149 E4            pop a
2117   114A             ; --- END RELATIONAL
2118   114A C0 00 00      cmp b, 0
2119   114D C6 7F 11      je _while43_exit
2120   1150             _while43_block:
2121   1150             ; i--; 
2122   1150 FA F5 FF      lea d, [bp + -11] ; $i
2123   1153 2A            mov b, [d]
2124   1154 38 00 00      mov c, 0
2125   1157 11            mov a, b
2126   1158 FD 7D         dec b
2127   115A FA F5 FF      lea d, [bp + -11] ; $i
2128   115D FD 43         mov [d], b
2129   115F 27            mov b, a
2130   1160             ; putchar(digits[i]); 
2131   1160             ; --- START FUNCTION CALL
2132   1160 FA F7 FF      lea d, [bp + -9] ; $digits
2133   1163 D7            push a
2134   1164 DA            push d
2135   1165 FA F5 FF      lea d, [bp + -11] ; $i
2136   1168 2A            mov b, [d]
2137   1169 38 00 00      mov c, 0
2138   116C E7            pop d
2139   116D 5A            add d, b
2140   116E E4            pop a
2141   116F 32            mov bl, [d]
2142   1170 A7 00         mov bh, 0
2143   1172 38 00 00      mov c, 0
2144   1175 DD            push bl
2145   1176 07 B6 0B      call putchar
2146   1179 51 01 00      add sp, 1
2147   117C             ; --- END FUNCTION CALL
2148   117C 0A 37 11      jmp _while43_cond
2149   117F             _while43_exit:
2150   117F F9            leave
2151   1180 09            ret
2152   1181             
2153   1181             printx32:
2154   1181 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2155   1184             ; --- BEGIN INLINE ASM SEGMENT
2156   1184 FA 05 00      lea d, [bp + 5] ; $hex
2157   1187 2B 02 00      mov b, [d+2]
2158   118A 07 93 11      call print_u16x_printx32
2159   118D 2A            mov b, [d]
2160   118E 07 93 11      call print_u16x_printx32
2161   1191             ; --- END INLINE ASM SEGMENT
2162   1191             ; return; 
2163   1191 F9            leave
2164   1192 09            ret
2165   1193             ; --- BEGIN INLINE ASM SEGMENT
2166   1193             print_u16x_printx32:
2167   1193 D7            push a
2168   1194 D8            push b
2169   1195 DD            push bl
2170   1196 30            mov bl, bh
2171   1197 07 B5 11      call _itoa_printx32        ; convert bh to char in A
2172   119A 2F            mov bl, al        ; save al
2173   119B 19 00         mov al, 0
2174   119D 05 03         syscall sys_io        ; display AH
2175   119F 24            mov ah, bl        ; retrieve al
2176   11A0 19 00         mov al, 0
2177   11A2 05 03         syscall sys_io        ; display AL
2178   11A4 EA            pop bl
2179   11A5 07 B5 11      call _itoa_printx32        ; convert bh to char in A
2180   11A8 2F            mov bl, al        ; save al
2181   11A9 19 00         mov al, 0
2182   11AB 05 03         syscall sys_io        ; display AH
2183   11AD 24            mov ah, bl        ; retrieve al
2184   11AE 19 00         mov al, 0
2185   11B0 05 03         syscall sys_io        ; display AL
2186   11B2 E5            pop b
2187   11B3 E4            pop a
2188   11B4 09            ret
2189   11B5             _itoa_printx32:
2190   11B5 DA            push d
2191   11B6 D8            push b
2192   11B7 A7 00         mov bh, 0
2193   11B9 FD A4 04      shr bl, 4  
2194   11BC 74            mov d, b
2195   11BD 1F CF 11      mov al, [d + s_hex_digits_printx32]
2196   11C0 23            mov ah, al
2197   11C1 E5            pop b
2198   11C2 D8            push b
2199   11C3 A7 00         mov bh, 0
2200   11C5 FD 87 0F      and bl, $0F
2201   11C8 74            mov d, b
2202   11C9 1F CF 11      mov al, [d + s_hex_digits_printx32]
2203   11CC E5            pop b
2204   11CD E7            pop d
2205   11CE 09            ret
2206   11CF 30 31 32 33 s_hex_digits_printx32: .db "0123456789ABCDEF"  
2206   11D3 34 35 36 37 
2206   11D7 38 39 41 42 
2206   11DB 43 44 45 46 
2207   11DF             ; --- END INLINE ASM SEGMENT
2208   11DF F9            leave
2209   11E0 09            ret
2210   11E1             
2211   11E1             print_signed:
2212   11E1 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2213   11E4             ; char digits[5]; 
2214   11E4 52 05 00      sub sp, 5
2215   11E7             ; int i = 0; 
2216   11E7 52 02 00      sub sp, 2
2217   11EA             ; --- START LOCAL VAR INITIALIZATION
2218   11EA FA FA FF      lea d, [bp + -6] ; $i
2219   11ED DA            push d
2220   11EE FD 2E 00 00   mov32 cb, $00000000
2220   11F2 00 00 
2221   11F4 E7            pop d
2222   11F5 FD 43         mov [d], b
2223   11F7             ; --- END LOCAL VAR INITIALIZATION
2224   11F7             ; if (num < 0) { 
2225   11F7             _if44_cond:
2226   11F7 FA 05 00      lea d, [bp + 5] ; $num
2227   11FA 2A            mov b, [d]
2228   11FB 38 00 00      mov c, 0
2229   11FE             ; --- START RELATIONAL
2230   11FE D7            push a
2231   11FF 11            mov a, b
2232   1200 FD 2E 00 00   mov32 cb, $00000000
2232   1204 00 00 
2233   1206 B0            cmp a, b
2234   1207 FD 73         slt ; < (signed)
2235   1209 E4            pop a
2236   120A             ; --- END RELATIONAL
2237   120A C0 00 00      cmp b, 0
2238   120D C6 30 12      je _if44_else
2239   1210             _if44_TRUE:
2240   1210             ; putchar('-'); 
2241   1210             ; --- START FUNCTION CALL
2242   1210 FD 2E 2D 00   mov32 cb, $0000002d
2242   1214 00 00 
2243   1216 DD            push bl
2244   1217 07 B6 0B      call putchar
2245   121A 51 01 00      add sp, 1
2246   121D             ; --- END FUNCTION CALL
2247   121D             ; num = -num; 
2248   121D FA 05 00      lea d, [bp + 5] ; $num
2249   1220 DA            push d
2250   1221 FA 05 00      lea d, [bp + 5] ; $num
2251   1224 2A            mov b, [d]
2252   1225 38 00 00      mov c, 0
2253   1228 FD 97         neg b
2254   122A E7            pop d
2255   122B FD 43         mov [d], b
2256   122D 0A 5B 12      jmp _if44_exit
2257   1230             _if44_else:
2258   1230             ; if (num == 0) { 
2259   1230             _if45_cond:
2260   1230 FA 05 00      lea d, [bp + 5] ; $num
2261   1233 2A            mov b, [d]
2262   1234 38 00 00      mov c, 0
2263   1237             ; --- START RELATIONAL
2264   1237 D7            push a
2265   1238 11            mov a, b
2266   1239 FD 2E 00 00   mov32 cb, $00000000
2266   123D 00 00 
2267   123F B0            cmp a, b
2268   1240 FD 71         seq ; ==
2269   1242 E4            pop a
2270   1243             ; --- END RELATIONAL
2271   1243 C0 00 00      cmp b, 0
2272   1246 C6 5B 12      je _if45_exit
2273   1249             _if45_TRUE:
2274   1249             ; putchar('0'); 
2275   1249             ; --- START FUNCTION CALL
2276   1249 FD 2E 30 00   mov32 cb, $00000030
2276   124D 00 00 
2277   124F DD            push bl
2278   1250 07 B6 0B      call putchar
2279   1253 51 01 00      add sp, 1
2280   1256             ; --- END FUNCTION CALL
2281   1256             ; return; 
2282   1256 F9            leave
2283   1257 09            ret
2284   1258 0A 5B 12      jmp _if45_exit
2285   125B             _if45_exit:
2286   125B             _if44_exit:
2287   125B             ; while (num > 0) { 
2288   125B             _while46_cond:
2289   125B FA 05 00      lea d, [bp + 5] ; $num
2290   125E 2A            mov b, [d]
2291   125F 38 00 00      mov c, 0
2292   1262             ; --- START RELATIONAL
2293   1262 D7            push a
2294   1263 11            mov a, b
2295   1264 FD 2E 00 00   mov32 cb, $00000000
2295   1268 00 00 
2296   126A B0            cmp a, b
2297   126B FD 7F         sgt ; >
2298   126D E4            pop a
2299   126E             ; --- END RELATIONAL
2300   126E C0 00 00      cmp b, 0
2301   1271 C6 E8 12      je _while46_exit
2302   1274             _while46_block:
2303   1274             ; digits[i] = '0' + (num % 10); 
2304   1274 FA FC FF      lea d, [bp + -4] ; $digits
2305   1277 D7            push a
2306   1278 DA            push d
2307   1279 FA FA FF      lea d, [bp + -6] ; $i
2308   127C 2A            mov b, [d]
2309   127D 38 00 00      mov c, 0
2310   1280 E7            pop d
2311   1281 5A            add d, b
2312   1282 E4            pop a
2313   1283 DA            push d
2314   1284 FD 2E 30 00   mov32 cb, $00000030
2314   1288 00 00 
2315   128A             ; --- START TERMS
2316   128A D7            push a
2317   128B 11            mov a, b
2318   128C FA 05 00      lea d, [bp + 5] ; $num
2319   128F 2A            mov b, [d]
2320   1290 38 00 00      mov c, 0
2321   1293             ; --- START FACTORS
2322   1293 D7            push a
2323   1294 FD D8         push g
2324   1296 11            mov a, b
2325   1297 FD 7A         mov g, c
2326   1299 FD 2E 0A 00   mov32 cb, $0000000a
2326   129D 00 00 
2327   129F FD D8         push g ; save 'g' as the div instruction uses it
2328   12A1 AE            div a, b ; %, a: quotient, b: remainder
2329   12A2 11            mov a, b
2330   12A3 FD F1         pop g
2331   12A5 FD 38         mov c, g
2332   12A7 27            mov b, a
2333   12A8 FD F1         pop g
2334   12AA E4            pop a
2335   12AB             ; --- END FACTORS
2336   12AB 56            add b, a
2337   12AC E4            pop a
2338   12AD             ; --- END TERMS
2339   12AD E7            pop d
2340   12AE FD 3E         mov [d], bl
2341   12B0             ; num = num / 10; 
2342   12B0 FA 05 00      lea d, [bp + 5] ; $num
2343   12B3 DA            push d
2344   12B4 FA 05 00      lea d, [bp + 5] ; $num
2345   12B7 2A            mov b, [d]
2346   12B8 38 00 00      mov c, 0
2347   12BB             ; --- START FACTORS
2348   12BB D7            push a
2349   12BC FD D8         push g
2350   12BE 11            mov a, b
2351   12BF FD 7A         mov g, c
2352   12C1 FD 2E 0A 00   mov32 cb, $0000000a
2352   12C5 00 00 
2353   12C7 FD D8         push g ; save 'g' as the div instruction uses it
2354   12C9 AE            div a, b ; /, a: quotient, b: remainder
2355   12CA FD F1         pop g
2356   12CC FD 38         mov c, g
2357   12CE 27            mov b, a
2358   12CF FD F1         pop g
2359   12D1 E4            pop a
2360   12D2             ; --- END FACTORS
2361   12D2 E7            pop d
2362   12D3 FD 43         mov [d], b
2363   12D5             ; i++; 
2364   12D5 FA FA FF      lea d, [bp + -6] ; $i
2365   12D8 2A            mov b, [d]
2366   12D9 38 00 00      mov c, 0
2367   12DC 11            mov a, b
2368   12DD FD 77         inc b
2369   12DF FA FA FF      lea d, [bp + -6] ; $i
2370   12E2 FD 43         mov [d], b
2371   12E4 27            mov b, a
2372   12E5 0A 5B 12      jmp _while46_cond
2373   12E8             _while46_exit:
2374   12E8             ; while (i > 0) { 
2375   12E8             _while53_cond:
2376   12E8 FA FA FF      lea d, [bp + -6] ; $i
2377   12EB 2A            mov b, [d]
2378   12EC 38 00 00      mov c, 0
2379   12EF             ; --- START RELATIONAL
2380   12EF D7            push a
2381   12F0 11            mov a, b
2382   12F1 FD 2E 00 00   mov32 cb, $00000000
2382   12F5 00 00 
2383   12F7 B0            cmp a, b
2384   12F8 FD 7F         sgt ; >
2385   12FA E4            pop a
2386   12FB             ; --- END RELATIONAL
2387   12FB C0 00 00      cmp b, 0
2388   12FE C6 30 13      je _while53_exit
2389   1301             _while53_block:
2390   1301             ; i--; 
2391   1301 FA FA FF      lea d, [bp + -6] ; $i
2392   1304 2A            mov b, [d]
2393   1305 38 00 00      mov c, 0
2394   1308 11            mov a, b
2395   1309 FD 7D         dec b
2396   130B FA FA FF      lea d, [bp + -6] ; $i
2397   130E FD 43         mov [d], b
2398   1310 27            mov b, a
2399   1311             ; putchar(digits[i]); 
2400   1311             ; --- START FUNCTION CALL
2401   1311 FA FC FF      lea d, [bp + -4] ; $digits
2402   1314 D7            push a
2403   1315 DA            push d
2404   1316 FA FA FF      lea d, [bp + -6] ; $i
2405   1319 2A            mov b, [d]
2406   131A 38 00 00      mov c, 0
2407   131D E7            pop d
2408   131E 5A            add d, b
2409   131F E4            pop a
2410   1320 32            mov bl, [d]
2411   1321 A7 00         mov bh, 0
2412   1323 38 00 00      mov c, 0
2413   1326 DD            push bl
2414   1327 07 B6 0B      call putchar
2415   132A 51 01 00      add sp, 1
2416   132D             ; --- END FUNCTION CALL
2417   132D 0A E8 12      jmp _while53_cond
2418   1330             _while53_exit:
2419   1330 F9            leave
2420   1331 09            ret
2421   1332             
2422   1332             print_unsigned:
2423   1332 F8 00 00      enter 0 ; (push bp; mov bp, sp)
2424   1335             ; char digits[5]; 
2425   1335 52 05 00      sub sp, 5
2426   1338             ; int i; 
2427   1338 52 02 00      sub sp, 2
2428   133B             ; i = 0; 
2429   133B FA FA FF      lea d, [bp + -6] ; $i
2430   133E DA            push d
2431   133F FD 2E 00 00   mov32 cb, $00000000
2431   1343 00 00 
2432   1345 E7            pop d
2433   1346 FD 43         mov [d], b
2434   1348             ; if(num == 0){ 
2435   1348             _if54_cond:
2436   1348 FA 05 00      lea d, [bp + 5] ; $num
2437   134B 2A            mov b, [d]
2438   134C 38 00 00      mov c, 0
2439   134F             ; --- START RELATIONAL
2440   134F D7            push a
2441   1350 11            mov a, b
2442   1351 FD 2E 00 00   mov32 cb, $00000000
2442   1355 00 00 
2443   1357 B0            cmp a, b
2444   1358 FD 71         seq ; ==
2445   135A E4            pop a
2446   135B             ; --- END RELATIONAL
2447   135B C0 00 00      cmp b, 0
2448   135E C6 73 13      je _if54_exit
2449   1361             _if54_TRUE:
2450   1361             ; putchar('0'); 
2451   1361             ; --- START FUNCTION CALL
2452   1361 FD 2E 30 00   mov32 cb, $00000030
2452   1365 00 00 
2453   1367 DD            push bl
2454   1368 07 B6 0B      call putchar
2455   136B 51 01 00      add sp, 1
2456   136E             ; --- END FUNCTION CALL
2457   136E             ; return; 
2458   136E F9            leave
2459   136F 09            ret
2460   1370 0A 73 13      jmp _if54_exit
2461   1373             _if54_exit:
2462   1373             ; while (num > 0) { 
2463   1373             _while55_cond:
2464   1373 FA 05 00      lea d, [bp + 5] ; $num
2465   1376 2A            mov b, [d]
2466   1377 38 00 00      mov c, 0
2467   137A             ; --- START RELATIONAL
2468   137A D7            push a
2469   137B 11            mov a, b
2470   137C FD 2E 00 00   mov32 cb, $00000000
2470   1380 00 00 
2471   1382 B0            cmp a, b
2472   1383 FD 81         sgu ; > (unsigned)
2473   1385 E4            pop a
2474   1386             ; --- END RELATIONAL
2475   1386 C0 00 00      cmp b, 0
2476   1389 C6 00 14      je _while55_exit
2477   138C             _while55_block:
2478   138C             ; digits[i] = '0' + (num % 10); 
2479   138C FA FC FF      lea d, [bp + -4] ; $digits
2480   138F D7            push a
2481   1390 DA            push d
2482   1391 FA FA FF      lea d, [bp + -6] ; $i
2483   1394 2A            mov b, [d]
2484   1395 38 00 00      mov c, 0
2485   1398 E7            pop d
2486   1399 5A            add d, b
2487   139A E4            pop a
2488   139B DA            push d
2489   139C FD 2E 30 00   mov32 cb, $00000030
2489   13A0 00 00 
2490   13A2             ; --- START TERMS
2491   13A2 D7            push a
2492   13A3 11            mov a, b
2493   13A4 FA 05 00      lea d, [bp + 5] ; $num
2494   13A7 2A            mov b, [d]
2495   13A8 38 00 00      mov c, 0
2496   13AB             ; --- START FACTORS
2497   13AB D7            push a
2498   13AC FD D8         push g
2499   13AE 11            mov a, b
2500   13AF FD 7A         mov g, c
2501   13B1 FD 2E 0A 00   mov32 cb, $0000000a
2501   13B5 00 00 
2502   13B7 FD D8         push g ; save 'g' as the div instruction uses it
2503   13B9 AE            div a, b ; %, a: quotient, b: remainder
2504   13BA 11            mov a, b
2505   13BB FD F1         pop g
2506   13BD FD 38         mov c, g
2507   13BF 27            mov b, a
2508   13C0 FD F1         pop g
2509   13C2 E4            pop a
2510   13C3             ; --- END FACTORS
2511   13C3 56            add b, a
2512   13C4 E4            pop a
2513   13C5             ; --- END TERMS
2514   13C5 E7            pop d
2515   13C6 FD 3E         mov [d], bl
2516   13C8             ; num = num / 10; 
2517   13C8 FA 05 00      lea d, [bp + 5] ; $num
2518   13CB DA            push d
2519   13CC FA 05 00      lea d, [bp + 5] ; $num
2520   13CF 2A            mov b, [d]
2521   13D0 38 00 00      mov c, 0
2522   13D3             ; --- START FACTORS
2523   13D3 D7            push a
2524   13D4 FD D8         push g
2525   13D6 11            mov a, b
2526   13D7 FD 7A         mov g, c
2527   13D9 FD 2E 0A 00   mov32 cb, $0000000a
2527   13DD 00 00 
2528   13DF FD D8         push g ; save 'g' as the div instruction uses it
2529   13E1 AE            div a, b ; /, a: quotient, b: remainder
2530   13E2 FD F1         pop g
2531   13E4 FD 38         mov c, g
2532   13E6 27            mov b, a
2533   13E7 FD F1         pop g
2534   13E9 E4            pop a
2535   13EA             ; --- END FACTORS
2536   13EA E7            pop d
2537   13EB FD 43         mov [d], b
2538   13ED             ; i++; 
2539   13ED FA FA FF      lea d, [bp + -6] ; $i
2540   13F0 2A            mov b, [d]
2541   13F1 38 00 00      mov c, 0
2542   13F4 11            mov a, b
2543   13F5 FD 77         inc b
2544   13F7 FA FA FF      lea d, [bp + -6] ; $i
2545   13FA FD 43         mov [d], b
2546   13FC 27            mov b, a
2547   13FD 0A 73 13      jmp _while55_cond
2548   1400             _while55_exit:
2549   1400             ; while (i > 0) { 
2550   1400             _while62_cond:
2551   1400 FA FA FF      lea d, [bp + -6] ; $i
2552   1403 2A            mov b, [d]
2553   1404 38 00 00      mov c, 0
2554   1407             ; --- START RELATIONAL
2555   1407 D7            push a
2556   1408 11            mov a, b
2557   1409 FD 2E 00 00   mov32 cb, $00000000
2557   140D 00 00 
2558   140F B0            cmp a, b
2559   1410 FD 7F         sgt ; >
2560   1412 E4            pop a
2561   1413             ; --- END RELATIONAL
2562   1413 C0 00 00      cmp b, 0
2563   1416 C6 48 14      je _while62_exit
2564   1419             _while62_block:
2565   1419             ; i--; 
2566   1419 FA FA FF      lea d, [bp + -6] ; $i
2567   141C 2A            mov b, [d]
2568   141D 38 00 00      mov c, 0
2569   1420 11            mov a, b
2570   1421 FD 7D         dec b
2571   1423 FA FA FF      lea d, [bp + -6] ; $i
2572   1426 FD 43         mov [d], b
2573   1428 27            mov b, a
2574   1429             ; putchar(digits[i]); 
2575   1429             ; --- START FUNCTION CALL
2576   1429 FA FC FF      lea d, [bp + -4] ; $digits
2577   142C D7            push a
2578   142D DA            push d
2579   142E FA FA FF      lea d, [bp + -6] ; $i
2580   1431 2A            mov b, [d]
2581   1432 38 00 00      mov c, 0
2582   1435 E7            pop d
2583   1436 5A            add d, b
2584   1437 E4            pop a
2585   1438 32            mov bl, [d]
2586   1439 A7 00         mov bh, 0
2587   143B 38 00 00      mov c, 0
2588   143E DD            push bl
2589   143F 07 B6 0B      call putchar
2590   1442 51 01 00      add sp, 1
2591   1445             ; --- END FUNCTION CALL
2592   1445 0A 00 14      jmp _while62_cond
2593   1448             _while62_exit:
2594   1448 F9            leave
2595   1449 09            ret
2596   144A             
2597   144A             printx16:
2598   144A F8 00 00      enter 0 ; (push bp; mov bp, sp)
2599   144D             ; --- BEGIN INLINE ASM SEGMENT
2600   144D FA 05 00      lea d, [bp + 5] ; $hex
2601   1450 2A            mov b, [d]
2602   1451             print_u16x_printx16:
2603   1451 DD            push bl
2604   1452 30            mov bl, bh
2605   1453 07 70 14      call _itoa_printx16        ; convert bh to char in A
2606   1456 2F            mov bl, al        ; save al
2607   1457 19 00         mov al, 0
2608   1459 05 03         syscall sys_io        ; display AH
2609   145B 24            mov ah, bl        ; retrieve al
2610   145C 19 00         mov al, 0
2611   145E 05 03         syscall sys_io        ; display AL
2612   1460 EA            pop bl
2613   1461 07 70 14      call _itoa_printx16        ; convert bh to char in A
2614   1464 2F            mov bl, al        ; save al
2615   1465 19 00         mov al, 0
2616   1467 05 03         syscall sys_io        ; display AH
2617   1469 24            mov ah, bl        ; retrieve al
2618   146A 19 00         mov al, 0
2619   146C 05 03         syscall sys_io        ; display AL
2620   146E             ; --- END INLINE ASM SEGMENT
2621   146E             ; return; 
2622   146E F9            leave
2623   146F 09            ret
2624   1470             ; --- BEGIN INLINE ASM SEGMENT
2625   1470             _itoa_printx16:
2626   1470 DA            push d
2627   1471 D8            push b
2628   1472 A7 00         mov bh, 0
2629   1474 FD A4 04      shr bl, 4  
2630   1477 74            mov d, b
2631   1478 1F 8A 14      mov al, [d + s_hex_digits_printx16]
2632   147B 23            mov ah, al
2633   147C E5            pop b
2634   147D D8            push b
2635   147E A7 00         mov bh, 0
2636   1480 FD 87 0F      and bl, $0F
2637   1483 74            mov d, b
2638   1484 1F 8A 14      mov al, [d + s_hex_digits_printx16]
2639   1487 E5            pop b
2640   1488 E7            pop d
2641   1489 09            ret
2642   148A 30 31 32 33 s_hex_digits_printx16:    .db "0123456789ABCDEF"  
2642   148E 34 35 36 37 
2642   1492 38 39 41 42 
2642   1496 43 44 45 46 
2643   149A             ; --- END INLINE ASM SEGMENT
2644   149A F9            leave
2645   149B 09            ret
2646   149C             ; --- END TEXT SEGMENT
2647   149C             
2648   149C             ; --- BEGIN DATA SEGMENT
2649   149C 20 20 20 20 _ss_data: .db "     ", 0
2649   14A0 20 00 
2650   14A2 9C 14       _ss: .dw _ss_data
2651   14A4 00 00       _coef: .fill 2, 0
2652   14A6 00 00       _rows: .fill 2, 0
2653   14A8 00 00       _space: .fill 2, 0
2654   14AA 00 00       _i: .fill 2, 0
2655   14AC 00 00       _j: .fill 2, 0
2656   14AE 0A 0D 00    _nl_data: .db "\n\r", 0
2657   14B1 AE 14       _nl: .dw _nl_data
2658   14B3 45 6E 74 65 _s0: .db "Enter the number of rows: ", 0
2658   14B7 72 20 74 68 
2658   14BB 65 20 6E 75 
2658   14BF 6D 62 65 72 
2658   14C3 20 6F 66 20 
2658   14C7 72 6F 77 73 
2658   14CB 3A 20 00 
2659   14CE 25 64 00    _s1: .db "%d", 0
2660   14D1 0A 00       _s2: .db "\n", 0
2661   14D3 25 75 00    _s3: .db "%u", 0
2662   14D6 20 00       _s4: .db " ", 0
2663   14D8 55 6E 65 78 _s5: .db "Unexpected format in printf.", 0
2663   14DC 70 65 63 74 
2663   14E0 65 64 20 66 
2663   14E4 6F 72 6D 61 
2663   14E8 74 20 69 6E 
2663   14EC 20 70 72 69 
2663   14F0 6E 74 66 2E 
2663   14F4 00 
2664   14F5 45 72 72 6F _s6: .db "Error: Unknown argument type.\n", 0
2664   14F9 72 3A 20 55 
2664   14FD 6E 6B 6E 6F 
2664   1501 77 6E 20 61 
2664   1505 72 67 75 6D 
2664   1509 65 6E 74 20 
2664   150D 74 79 70 65 
2664   1511 2E 0A 00 
2665   1514             
2666   1514 16 15       _heap_top: .dw _heap
2667   1516 00          _heap: .db 0
2668   1517             ; --- END DATA SEGMENT
2669   1517             
2670   1517             .end
tasm: Number of errors = 0
