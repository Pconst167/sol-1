0001   0000             .include "lib/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0002   0000             
0003   0400             .org text_org			; origin at 1024
0004   0400             
0005   0400             cmd_man:
0006   0400 3B E3 0C      mov d, s_telnet_clear
0007   0403 07 97 0B      call _puts
0008   0406 10 00 00      mov a, 0
0009   0409 42 7F 08      mov [prog], a			; move tokennizer pointer to the beginning of the arguments area (address 0)
0010   040C 07 E0 06      call get_token
0011   040F 1D 82 08      mov al, [tok]
0012   0412 B9 14         cmp al, tok_end
0013   0414 C6 41 04      je cmd_man_fail
0014   0417             
0015   0417 FD 4D 43 04   mov si, manpath
0016   041B FD 4F 53 04   mov di, temp_data
0017   041F 07 EF 09      call _strcpy        ; complete path with command name
0018   0422 FD 4D 83 08   mov si, tokstr
0019   0426 FD 4F 53 04   mov di, temp_data
0020   042A 07 FD 09      call _strcat        ; complete path with command name
0021   042D 3B 53 04      mov d, temp_data
0022   0430 FD 4F 92 0D   mov di, transient_area
0023   0434 19 14         mov al, 20
0024   0436 05 04         syscall sys_filesystem
0025   0438 3B 92 0D      mov d, transient_area
0026   043B 07 97 0B      call _puts
0027   043E 07 44 0B      call printnl
0028   0441             cmd_man_fail:
0029   0441 05 0B       	syscall sys_terminate_proc
0030   0443             
0031   0443 2F 75 73 72 manpath:  .db "/usr/share/man/", 0
0031   0447 2F 73 68 61 
0031   044B 72 65 2F 6D 
0031   044F 61 6E 2F 00 
0032   0453 00 00 00 00 temp_data: .fill 512, 0
0032   0457 00 00 00 00 
0032   045B 00 00 00 00 
0032   045F 00 00 00 00 
0032   0463 00 00 00 00 
0032   0467 00 00 00 00 
0032   046B 00 00 00 00 
0032   046F 00 00 00 00 
0032   0473 00 00 00 00 
0032   0477 00 00 00 00 
0032   047B 00 00 00 00 
0032   047F 00 00 00 00 
0032   0483 00 00 00 00 
0032   0487 00 00 00 00 
0032   048B 00 00 00 00 
0032   048F 00 00 00 00 
0032   0493 00 00 00 00 
0032   0497 00 00 00 00 
0032   049B 00 00 00 00 
0032   049F 00 00 00 00 
0032   04A3 00 00 00 00 
0032   04A7 00 00 00 00 
0032   04AB 00 00 00 00 
0032   04AF 00 00 00 00 
0032   04B3 00 00 00 00 
0032   04B7 00 00 00 00 
0032   04BB 00 00 00 00 
0032   04BF 00 00 00 00 
0032   04C3 00 00 00 00 
0032   04C7 00 00 00 00 
0032   04CB 00 00 00 00 
0032   04CF 00 00 00 00 
0032   04D3 00 00 00 00 
0032   04D7 00 00 00 00 
0032   04DB 00 00 00 00 
0032   04DF 00 00 00 00 
0032   04E3 00 00 00 00 
0032   04E7 00 00 00 00 
0032   04EB 00 00 00 00 
0032   04EF 00 00 00 00 
0032   04F3 00 00 00 00 
0032   04F7 00 00 00 00 
0032   04FB 00 00 00 00 
0032   04FF 00 00 00 00 
0032   0503 00 00 00 00 
0032   0507 00 00 00 00 
0032   050B 00 00 00 00 
0032   050F 00 00 00 00 
0032   0513 00 00 00 00 
0032   0517 00 00 00 00 
0032   051B 00 00 00 00 
0032   051F 00 00 00 00 
0032   0523 00 00 00 00 
0032   0527 00 00 00 00 
0032   052B 00 00 00 00 
0032   052F 00 00 00 00 
0032   0533 00 00 00 00 
0032   0537 00 00 00 00 
0032   053B 00 00 00 00 
0032   053F 00 00 00 00 
0032   0543 00 00 00 00 
0032   0547 00 00 00 00 
0032   054B 00 00 00 00 
0032   054F 00 00 00 00 
0032   0553 00 00 00 00 
0032   0557 00 00 00 00 
0032   055B 00 00 00 00 
0032   055F 00 00 00 00 
0032   0563 00 00 00 00 
0032   0567 00 00 00 00 
0032   056B 00 00 00 00 
0032   056F 00 00 00 00 
0032   0573 00 00 00 00 
0032   0577 00 00 00 00 
0032   057B 00 00 00 00 
0032   057F 00 00 00 00 
0032   0583 00 00 00 00 
0032   0587 00 00 00 00 
0032   058B 00 00 00 00 
0032   058F 00 00 00 00 
0032   0593 00 00 00 00 
0032   0597 00 00 00 00 
0032   059B 00 00 00 00 
0032   059F 00 00 00 00 
0032   05A3 00 00 00 00 
0032   05A7 00 00 00 00 
0032   05AB 00 00 00 00 
0032   05AF 00 00 00 00 
0032   05B3 00 00 00 00 
0032   05B7 00 00 00 00 
0032   05BB 00 00 00 00 
0032   05BF 00 00 00 00 
0032   05C3 00 00 00 00 
0032   05C7 00 00 00 00 
0032   05CB 00 00 00 00 
0032   05CF 00 00 00 00 
0032   05D3 00 00 00 00 
0032   05D7 00 00 00 00 
0032   05DB 00 00 00 00 
0032   05DF 00 00 00 00 
0032   05E3 00 00 00 00 
0032   05E7 00 00 00 00 
0032   05EB 00 00 00 00 
0032   05EF 00 00 00 00 
0032   05F3 00 00 00 00 
0032   05F7 00 00 00 00 
0032   05FB 00 00 00 00 
0032   05FF 00 00 00 00 
0032   0603 00 00 00 00 
0032   0607 00 00 00 00 
0032   060B 00 00 00 00 
0032   060F 00 00 00 00 
0032   0613 00 00 00 00 
0032   0617 00 00 00 00 
0032   061B 00 00 00 00 
0032   061F 00 00 00 00 
0032   0623 00 00 00 00 
0032   0627 00 00 00 00 
0032   062B 00 00 00 00 
0032   062F 00 00 00 00 
0032   0633 00 00 00 00 
0032   0637 00 00 00 00 
0032   063B 00 00 00 00 
0032   063F 00 00 00 00 
0032   0643 00 00 00 00 
0032   0647 00 00 00 00 
0032   064B 00 00 00 00 
0032   064F 00 00 00 00 
0033   0653 2F 00       s_fslash:  .db "/", 0
0034   0655             
0035   0655             .include "lib/token.asm"
0001+  0655             toktyp_identifier  .equ 0
0002+  0655             toktyp_keyword     .equ 1
0003+  0655             toktyp_delimiter   .equ 2
0004+  0655             toktyp_string      .equ 3
0005+  0655             toktyp_char        .equ 4
0006+  0655             toktyp_numeric     .equ 5
0007+  0655             toktyp_end         .equ 6
0008+  0655             
0009+  0655             tok_null           .equ 0
0010+  0655             tok_fslash         .equ 1
0011+  0655             tok_times          .equ 2
0012+  0655             tok_plus           .equ 3
0013+  0655             tok_minus          .equ 4
0014+  0655             tok_dot            .equ 5
0015+  0655             tok_semi           .equ 6
0016+  0655             tok_angle          .equ 7
0017+  0655             tok_tilde          .equ 8
0018+  0655             tok_equal          .equ 9
0019+  0655             tok_colon          .equ 10
0020+  0655             tok_comma          .equ 11
0021+  0655             
0022+  0655             tok_end            .equ 20
0023+  0655             
0024+  0655             
0025+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0655             ;; read a full command argment from shell input buffer
0027+  0655             ;; argument is written into tokstr
0028+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0655             get_arg:
0030+  0655 D7            push a
0031+  0656 E2            push si
0032+  0657 E3            push di
0033+  0658 19 00         mov al, 0
0034+  065A 3D 83 08      mov [tokstr], al      ; nullify tokstr string
0035+  065D 14 7F 08      mov a, [prog]
0036+  0660 4D            mov si, a
0037+  0661 FD 4F 83 08   mov di, tokstr
0038+  0665             get_arg_skip_spaces:
0039+  0665 F6            lodsb
0040+  0666 07 6B 0D      call _isspace
0041+  0669 C6 65 06      je get_arg_skip_spaces
0042+  066C             get_arg_l0:
0043+  066C B9 3B         cmp al, $3b        ; check if is ';'
0044+  066E C6 7B 06      je get_arg_end
0045+  0671 B9 00         cmp al, 0
0046+  0673 C6 7B 06      je get_arg_end      ; check if end of input
0047+  0676 F7            stosb
0048+  0677 F6            lodsb
0049+  0678 0A 6C 06      jmp get_arg_l0
0050+  067B             get_arg_end:
0051+  067B 19 00         mov al, 0
0052+  067D F7            stosb
0053+  067E D5 01 00      sub si, 1
0054+  0681 4E            mov a, si
0055+  0682 42 7F 08      mov [prog], a    ; update pointer
0056+  0685 F0            pop di
0057+  0686 EF            pop si
0058+  0687 E4            pop a
0059+  0688 09            ret
0060+  0689             
0061+  0689             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0689             ;; read a path formation from shell input buffer
0063+  0689             ;; path is written into tokstr
0064+  0689             ;; /usr/bin
0065+  0689             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0689             get_path:
0067+  0689 D7            push a
0068+  068A E2            push si
0069+  068B E3            push di
0070+  068C 19 00         mov al, 0
0071+  068E 3D 83 08      mov [tokstr], al      ; nullify tokstr string
0072+  0691 14 7F 08      mov a, [prog]
0073+  0694 4D            mov si, a
0074+  0695 FD 4F 83 08   mov di, tokstr
0075+  0699             get_path_skip_spaces:
0076+  0699 F6            lodsb
0077+  069A 07 6B 0D      call _isspace
0078+  069D C6 99 06      je get_path_skip_spaces
0079+  06A0             get_path_is_pathchar:
0080+  06A0 F7            stosb
0081+  06A1 F6            lodsb
0082+  06A2 07 F5 0C      call _isalnum      ;check if is alphanumeric
0083+  06A5 C6 A0 06      je get_path_is_pathchar
0084+  06A8 B9 2F         cmp al, '/'        ; check if is '/'
0085+  06AA C6 A0 06      je get_path_is_pathchar
0086+  06AD 19 00         mov al, 0
0087+  06AF F7            stosb
0088+  06B0 D5 01 00      sub si, 1
0089+  06B3 4E            mov a, si
0090+  06B4 42 7F 08      mov [prog], a    ; update pointer
0091+  06B7             get_path_end:
0092+  06B7 F0            pop di
0093+  06B8 EF            pop si
0094+  06B9 E4            pop a
0095+  06BA 09            ret
0096+  06BB             
0097+  06BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  06BB             ;; read a line
0099+  06BB             ;; line is written into tokstr
0100+  06BB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  06BB             get_line:
0102+  06BB D7            push a
0103+  06BC E2            push si
0104+  06BD E3            push di
0105+  06BE 19 00         mov al, 0
0106+  06C0 3D 83 08      mov [tokstr], al      ; nullify tokstr string
0107+  06C3 14 7F 08      mov a, [prog]
0108+  06C6 4D            mov si, a
0109+  06C7 FD 4F 83 08   mov di, tokstr
0110+  06CB             get_line_l0:
0111+  06CB F6            lodsb
0112+  06CC B9 0A         cmp al, $0a    ; check for new line
0113+  06CE C6 D5 06      je get_line_exit
0114+  06D1 F7            stosb
0115+  06D2 0A CB 06      jmp get_line_l0
0116+  06D5             get_line_exit:
0117+  06D5 19 00         mov al, 0
0118+  06D7 F7            stosb
0119+  06D8 4E            mov a, si
0120+  06D9 42 7F 08      mov [prog], a    ; update pointer
0121+  06DC F0            pop di
0122+  06DD EF            pop si
0123+  06DE E4            pop a
0124+  06DF 09            ret
0125+  06E0             
0126+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  06E0             ;; token parser
0128+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  06E0             get_token:
0130+  06E0 D7            push a
0131+  06E1 DA            push d
0132+  06E2 E2            push si
0133+  06E3 E3            push di
0134+  06E4 19 00         mov al, 0
0135+  06E6 3D 83 08      mov [tokstr], al      ; nullify tokstr string
0136+  06E9 19 00         mov al, tok_null
0137+  06EB 3D 82 08      mov [tok], al        ; nullify token
0138+  06EE 14 7F 08      mov a, [prog]
0139+  06F1 4D            mov si, a
0140+  06F2 FD 4F 83 08   mov di, tokstr
0141+  06F6             get_tok_skip_spaces:
0142+  06F6 F6            lodsb
0143+  06F7 07 6B 0D      call _isspace
0144+  06FA C6 F6 06      je get_tok_skip_spaces
0145+  06FD B9 00         cmp al, 0      ; check for end of input (null)
0146+  06FF C6 E4 07      je get_token_end
0147+  0702 B9 23         cmp al, '#'      ; comments!
0148+  0704 C6 12 08      je get_tok_comment
0149+  0707 07 F5 0C      call _isalnum
0150+  070A C6 F1 07      jz is_alphanumeric
0151+  070D             ; other token types
0152+  070D             get_token_slash:
0153+  070D B9 2F         cmp al, '/'        ; check if '/'
0154+  070F C7 27 07      jne get_token_minus
0155+  0712 F7            stosb          ; store '/' into token string
0156+  0713 19 00         mov al, 0
0157+  0715 F7            stosb          ; terminate token string
0158+  0716 19 01         mov al, tok_fslash
0159+  0718 3D 82 08      mov [tok], al      
0160+  071B 19 02         mov al, toktyp_delimiter
0161+  071D 3D 81 08      mov [toktyp], al
0162+  0720 4E            mov a, si
0163+  0721 42 7F 08      mov [prog], a    ; update pointer
0164+  0724 0A 0D 08      jmp get_token_return
0165+  0727             get_token_minus:
0166+  0727 B9 2D         cmp al, '-'        ; check if '-'
0167+  0729 C7 41 07      jne get_token_comma
0168+  072C F7            stosb          ; store '-' into token string
0169+  072D 19 00         mov al, 0
0170+  072F F7            stosb          ; terminate token string
0171+  0730 19 04         mov al, tok_minus
0172+  0732 3D 82 08      mov [tok], al      
0173+  0735 19 02         mov al, toktyp_delimiter
0174+  0737 3D 81 08      mov [toktyp], al
0175+  073A 4E            mov a, si
0176+  073B 42 7F 08      mov [prog], a    ; update pointer
0177+  073E 0A 0D 08      jmp get_token_return
0178+  0741             get_token_comma:
0179+  0741 B9 2C         cmp al, ','        ; check if ','
0180+  0743 C7 5B 07      jne get_token_semi
0181+  0746 F7            stosb          ; store ',' into token string
0182+  0747 19 00         mov al, 0
0183+  0749 F7            stosb          ; terminate token string
0184+  074A 19 0B         mov al, tok_comma
0185+  074C 3D 82 08      mov [tok], al      
0186+  074F 19 02         mov al, toktyp_delimiter
0187+  0751 3D 81 08      mov [toktyp], al
0188+  0754 4E            mov a, si
0189+  0755 42 7F 08      mov [prog], a    ; update pointer
0190+  0758 0A 0D 08      jmp get_token_return
0191+  075B             get_token_semi:
0192+  075B B9 3B         cmp al, $3b        ; check if ';'
0193+  075D C7 75 07      jne get_token_colon
0194+  0760 F7            stosb          ; store ';' into token string
0195+  0761 19 00         mov al, 0
0196+  0763 F7            stosb          ; terminate token string
0197+  0764 19 06         mov al, tok_semi
0198+  0766 3D 82 08      mov [tok], al      
0199+  0769 19 02         mov al, toktyp_delimiter
0200+  076B 3D 81 08      mov [toktyp], al
0201+  076E 4E            mov a, si
0202+  076F 42 7F 08      mov [prog], a    ; update pointer
0203+  0772 0A 0D 08      jmp get_token_return
0204+  0775             get_token_colon:
0205+  0775 B9 3A         cmp al, $3a        ; check if ':'
0206+  0777 C7 8F 07      jne get_token_angle
0207+  077A F7            stosb          ; store ':' into token string
0208+  077B 19 00         mov al, 0
0209+  077D F7            stosb          ; terminate token string
0210+  077E 19 0A         mov al, tok_colon
0211+  0780 3D 82 08      mov [tok], al      
0212+  0783 19 02         mov al, toktyp_delimiter
0213+  0785 3D 81 08      mov [toktyp], al
0214+  0788 4E            mov a, si
0215+  0789 42 7F 08      mov [prog], a    ; update pointer
0216+  078C 0A 0D 08      jmp get_token_return
0217+  078F             get_token_angle:
0218+  078F B9 3E         cmp al, $3e        ; check if '>'
0219+  0791 C7 A9 07      jne get_token_tilde
0220+  0794 F7            stosb          ; store '>' into token string
0221+  0795 19 00         mov al, 0
0222+  0797 F7            stosb          ; terminate token string
0223+  0798 19 07         mov al, tok_angle
0224+  079A 3D 82 08      mov [tok], al      
0225+  079D 19 02         mov al, toktyp_delimiter
0226+  079F 3D 81 08      mov [toktyp], al
0227+  07A2 4E            mov a, si
0228+  07A3 42 7F 08      mov [prog], a    ; update pointer
0229+  07A6 0A 0D 08      jmp get_token_return
0230+  07A9             get_token_tilde:
0231+  07A9 B9 7E         cmp al, '~'        ; check if '~'
0232+  07AB C7 C3 07      jne get_token_equal
0233+  07AE F7            stosb          ; store '~' into token string
0234+  07AF 19 00         mov al, 0
0235+  07B1 F7            stosb          ; terminate token string
0236+  07B2 19 08         mov al, tok_tilde
0237+  07B4 3D 82 08      mov [tok], al      
0238+  07B7 19 02         mov al, toktyp_delimiter
0239+  07B9 3D 81 08      mov [toktyp], al
0240+  07BC 4E            mov a, si
0241+  07BD 42 7F 08      mov [prog], a    ; update pointer
0242+  07C0 0A 0D 08      jmp get_token_return
0243+  07C3             get_token_equal:
0244+  07C3 B9 3D         cmp al, '='        ; check if '='
0245+  07C5 C7 DD 07      jne get_token_skip
0246+  07C8 F7            stosb          ; store '=' into token string
0247+  07C9 19 00         mov al, 0
0248+  07CB F7            stosb          ; terminate token string
0249+  07CC 19 09         mov al, tok_equal
0250+  07CE 3D 82 08      mov [tok], al      
0251+  07D1 19 02         mov al, toktyp_delimiter
0252+  07D3 3D 81 08      mov [toktyp], al
0253+  07D6 4E            mov a, si
0254+  07D7 42 7F 08      mov [prog], a    ; update pointer
0255+  07DA 0A 0D 08      jmp get_token_return
0256+  07DD             get_token_skip:
0257+  07DD 4E            mov a, si
0258+  07DE 42 7F 08      mov [prog], a    ; update pointer
0259+  07E1 0A 0D 08      jmp get_token_return
0260+  07E4             get_token_end:        ; end of file token
0261+  07E4 19 14         mov al, tok_end
0262+  07E6 3D 82 08      mov [tok], al
0263+  07E9 19 06         mov al, toktyp_end
0264+  07EB 3D 81 08      mov [toktyp], al
0265+  07EE 0A 0D 08      jmp get_token_return
0266+  07F1             is_alphanumeric:
0267+  07F1 F7            stosb
0268+  07F2 F6            lodsb
0269+  07F3 07 F5 0C      call _isalnum      ;check if is alphanumeric
0270+  07F6 C6 F1 07      jz is_alphanumeric
0271+  07F9 B9 2E         cmp al, $2e        ; check if is '.'
0272+  07FB C6 F1 07      je is_alphanumeric
0273+  07FE 19 00         mov al, 0
0274+  0800 F7            stosb
0275+  0801 19 00         mov al, toktyp_identifier
0276+  0803 3D 81 08      mov [toktyp], al
0277+  0806 D5 01 00      sub si, 1
0278+  0809 4E            mov a, si
0279+  080A 42 7F 08      mov [prog], a    ; update pointer
0280+  080D             get_token_return:
0281+  080D F0            pop di
0282+  080E EF            pop si
0283+  080F E7            pop d
0284+  0810 E4            pop a
0285+  0811 09            ret
0286+  0812             get_tok_comment:
0287+  0812 F6            lodsb
0288+  0813 B9 0A         cmp al, $0a      ; new line
0289+  0815 C7 12 08      jne get_tok_comment
0290+  0818 0A F6 06      jmp get_tok_skip_spaces
0291+  081B             
0292+  081B             
0293+  081B             get_number:
0294+  081B D7            push a
0295+  081C DA            push d
0296+  081D E2            push si
0297+  081E E3            push di
0298+  081F 19 00         mov al, 0
0299+  0821 3D 83 08      mov [tokstr], al      ; nullify tokstr string
0300+  0824 19 00         mov al, tok_null
0301+  0826 3D 82 08      mov [tok], al        ; nullify token
0302+  0829 14 7F 08      mov a, [prog]
0303+  082C 4D            mov si, a
0304+  082D FD 4F 83 08   mov di, tokstr
0305+  0831             get_number_skip_spaces:
0306+  0831 F6            lodsb
0307+  0832 07 6B 0D      call _isspace
0308+  0835 C6 31 08      je get_number_skip_spaces
0309+  0838 B9 00         cmp al, 0      ; check for end of input (null)
0310+  083A C7 4A 08      jne get_number_l0
0311+  083D 19 14         mov al, tok_end
0312+  083F 3D 82 08      mov [tok], al
0313+  0842 19 06         mov al, toktyp_end
0314+  0844 3D 81 08      mov [toktyp], al
0315+  0847 0A 61 08      jmp get_number_return
0316+  084A             get_number_l0:
0317+  084A F7            stosb
0318+  084B F6            lodsb
0319+  084C 07 FF 0C      call _isdigit      ;check if is numeric
0320+  084F C6 4A 08      jz get_number_l0
0321+  0852 19 00         mov al, 0
0322+  0854 F7            stosb
0323+  0855 19 05         mov al, toktyp_numeric
0324+  0857 3D 81 08      mov [toktyp], al
0325+  085A D5 01 00      sub si, 1
0326+  085D 4E            mov a, si
0327+  085E 42 7F 08      mov [prog], a    ; update pointer
0328+  0861             get_number_return:
0329+  0861 F0            pop di
0330+  0862 EF            pop si
0331+  0863 E7            pop d
0332+  0864 E4            pop a
0333+  0865 09            ret
0334+  0866             
0335+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0866             ;; put back token
0337+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  0866             _putback:
0339+  0866 D7            push a
0340+  0867 E2            push si
0341+  0868 FD 4D 83 08   mov si, tokstr  
0342+  086C             _putback_loop:
0343+  086C F6            lodsb
0344+  086D B9 00         cmp al, 0
0345+  086F C6 7C 08      je _putback_end
0346+  0872 14 7F 08      mov a, [prog]
0347+  0875 7D            dec a
0348+  0876 42 7F 08      mov [prog], a      ; update pointer
0349+  0879 0A 6C 08      jmp _putback_loop
0350+  087C             _putback_end:
0351+  087C EF            pop si
0352+  087D E4            pop a
0353+  087E 09            ret
0354+  087F             
0355+  087F             
0356+  087F             
0357+  087F             
0358+  087F 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  0881             
0360+  0881 00          toktyp:    .db 0          ; token type symbol
0361+  0882 00          tok:       .db 0          ; current token symbol
0362+  0883 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  0887 00 00 00 00 
0362+  088B 00 00 00 00 
0362+  088F 00 00 00 00 
0362+  0893 00 00 00 00 
0362+  0897 00 00 00 00 
0362+  089B 00 00 00 00 
0362+  089F 00 00 00 00 
0362+  08A3 00 00 00 00 
0362+  08A7 00 00 00 00 
0362+  08AB 00 00 00 00 
0362+  08AF 00 00 00 00 
0362+  08B3 00 00 00 00 
0362+  08B7 00 00 00 00 
0362+  08BB 00 00 00 00 
0362+  08BF 00 00 00 00 
0362+  08C3 00 00 00 00 
0362+  08C7 00 00 00 00 
0362+  08CB 00 00 00 00 
0362+  08CF 00 00 00 00 
0362+  08D3 00 00 00 00 
0362+  08D7 00 00 00 00 
0362+  08DB 00 00 00 00 
0362+  08DF 00 00 00 00 
0362+  08E3 00 00 00 00 
0362+  08E7 00 00 00 00 
0362+  08EB 00 00 00 00 
0362+  08EF 00 00 00 00 
0362+  08F3 00 00 00 00 
0362+  08F7 00 00 00 00 
0362+  08FB 00 00 00 00 
0362+  08FF 00 00 00 00 
0362+  0903 00 00 00 00 
0362+  0907 00 00 00 00 
0362+  090B 00 00 00 00 
0362+  090F 00 00 00 00 
0362+  0913 00 00 00 00 
0362+  0917 00 00 00 00 
0362+  091B 00 00 00 00 
0362+  091F 00 00 00 00 
0362+  0923 00 00 00 00 
0362+  0927 00 00 00 00 
0362+  092B 00 00 00 00 
0362+  092F 00 00 00 00 
0362+  0933 00 00 00 00 
0362+  0937 00 00 00 00 
0362+  093B 00 00 00 00 
0362+  093F 00 00 00 00 
0362+  0943 00 00 00 00 
0362+  0947 00 00 00 00 
0362+  094B 00 00 00 00 
0362+  094F 00 00 00 00 
0362+  0953 00 00 00 00 
0362+  0957 00 00 00 00 
0362+  095B 00 00 00 00 
0362+  095F 00 00 00 00 
0362+  0963 00 00 00 00 
0362+  0967 00 00 00 00 
0362+  096B 00 00 00 00 
0362+  096F 00 00 00 00 
0362+  0973 00 00 00 00 
0362+  0977 00 00 00 00 
0362+  097B 00 00 00 00 
0362+  097F 00 00 00 00 
0036   0983             .include "lib/stdio.asm"
0001+  0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0983             ; stdio.s
0003+  0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0983             .include "lib/string.asm"
0001++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0983             ; string.s
0003++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0983             
0005++ 0983             
0006++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0983             ; _strrev
0008++ 0983             ; reverse a string
0009++ 0983             ; d = string address
0010++ 0983             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0983             ; 01234
0012++ 0983             _strrev:
0013++ 0983 4B          	pusha
0014++ 0984 07 CA 09    	call _strlen	; length in c
0015++ 0987 12          	mov a, c
0016++ 0988 AF 01 00    	cmp a, 1
0017++ 098B D0 A5 09    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 098E 7D          	dec a
0019++ 098F FD 4E       	mov si, d	; beginning of string
0020++ 0991 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0993 59          	add d, a	; end of string
0022++ 0994 12          	mov a, c
0023++ 0995 FD 9B       	shr a		; divide by 2
0024++ 0997 39          	mov c, a	; c now counts the steps
0025++ 0998             _strrev_l0:
0026++ 0998 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0999 F6          	lodsb		; load left-side char into al; increase si
0028++ 099A 3E          	mov [d], al	; store left char into right side
0029++ 099B 1B          	mov al, bl
0030++ 099C F7          	stosb		; store right-side char into left-side; increase di
0031++ 099D 7E          	dec c
0032++ 099E 7F          	dec d
0033++ 099F C2 00 00    	cmp c, 0
0034++ 09A2 C7 98 09    	jne _strrev_l0
0035++ 09A5             _strrev_end:
0036++ 09A5 4C          	popa
0037++ 09A6 09          	ret
0038++ 09A7             	
0039++ 09A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 09A7             ; _strchr
0041++ 09A7             ; search string in d for char in al
0042++ 09A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 09A7             _strchr:
0044++ 09A7             _strchr_l0:
0045++ 09A7 32          	mov bl, [d]
0046++ 09A8 C1 00       	cmp bl, 0
0047++ 09AA C6 B5 09    	je _strchr_end
0048++ 09AD BA          	cmp al, bl
0049++ 09AE C6 B5 09    	je _strchr_end
0050++ 09B1 79          	inc d
0051++ 09B2 0A A7 09    	jmp _strchr_l0
0052++ 09B5             _strchr_end:
0053++ 09B5 1B          	mov al, bl
0054++ 09B6 09          	ret
0055++ 09B7             
0056++ 09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 09B7             ; _strstr
0058++ 09B7             ; find sub-string
0059++ 09B7             ; str1 in si
0060++ 09B7             ; str2 in di
0061++ 09B7             ; si points to end of source string
0062++ 09B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 09B7             _strstr:
0064++ 09B7 DB          	push al
0065++ 09B8 DA          	push d
0066++ 09B9 E3          	push di
0067++ 09BA             _strstr_loop:
0068++ 09BA F3          	cmpsb					; compare a byte of the strings
0069++ 09BB C7 C6 09    	jne _strstr_ret
0070++ 09BE FC 00 00    	lea d, [di + 0]
0071++ 09C1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 09C3 C7 BA 09    	jne _strstr_loop				; equal chars but not at end
0073++ 09C6             _strstr_ret:
0074++ 09C6 F0          	pop di
0075++ 09C7 E7          	pop d
0076++ 09C8 E8          	pop al
0077++ 09C9 09          	ret
0078++ 09CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 09CA             ; length of null terminated string
0080++ 09CA             ; result in c
0081++ 09CA             ; pointer in d
0082++ 09CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 09CA             _strlen:
0084++ 09CA DA          	push d
0085++ 09CB 38 00 00    	mov c, 0
0086++ 09CE             _strlen_l1:
0087++ 09CE BD 00       	cmp byte [d], 0
0088++ 09D0 C6 D8 09    	je _strlen_ret
0089++ 09D3 79          	inc d
0090++ 09D4 78          	inc c
0091++ 09D5 0A CE 09    	jmp _strlen_l1
0092++ 09D8             _strlen_ret:
0093++ 09D8 E7          	pop d
0094++ 09D9 09          	ret
0095++ 09DA             
0096++ 09DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 09DA             ; strcmp
0098++ 09DA             ; compare two strings
0099++ 09DA             ; str1 in si
0100++ 09DA             ; str2 in di
0101++ 09DA             ; create a string compairon instrucion ?????
0102++ 09DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 09DA             _strcmp:
0104++ 09DA DB          	push al
0105++ 09DB DA          	push d
0106++ 09DC E3          	push di
0107++ 09DD E2          	push si
0108++ 09DE             _strcmp_loop:
0109++ 09DE F3          	cmpsb					; compare a byte of the strings
0110++ 09DF C7 EA 09    	jne _strcmp_ret
0111++ 09E2 FB FF FF    	lea d, [si +- 1]
0112++ 09E5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 09E7 C7 DE 09    	jne _strcmp_loop				; equal chars but not at end
0114++ 09EA             _strcmp_ret:
0115++ 09EA EF          	pop si
0116++ 09EB F0          	pop di
0117++ 09EC E7          	pop d
0118++ 09ED E8          	pop al
0119++ 09EE 09          	ret
0120++ 09EF             
0121++ 09EF             
0122++ 09EF             ; strcpy
0123++ 09EF             ; copy null terminated string from si to di
0124++ 09EF             ; source in si
0125++ 09EF             ; destination in di
0126++ 09EF             _strcpy:
0127++ 09EF E2          	push si
0128++ 09F0 E3          	push di
0129++ 09F1 DB          	push al
0130++ 09F2             _strcpy_l1:
0131++ 09F2 F6          	lodsb
0132++ 09F3 F7          	stosb
0133++ 09F4 B9 00       	cmp al, 0
0134++ 09F6 C7 F2 09    	jne _strcpy_l1
0135++ 09F9             _strcpy_end:
0136++ 09F9 E8          	pop al
0137++ 09FA F0          	pop di
0138++ 09FB EF          	pop si
0139++ 09FC 09          	ret
0140++ 09FD             
0141++ 09FD             ; strcat
0142++ 09FD             ; concatenate a null terminated string into string at di, from string at si
0143++ 09FD             ; source in si
0144++ 09FD             ; destination in di
0145++ 09FD             _strcat:
0146++ 09FD E2          	push si
0147++ 09FE E3          	push di
0148++ 09FF D7          	push a
0149++ 0A00 DA          	push d
0150++ 0A01 50          	mov a, di
0151++ 0A02 3C          	mov d, a
0152++ 0A03             _strcat_goto_end_l1:
0153++ 0A03 BD 00       	cmp byte[d], 0
0154++ 0A05 C6 0C 0A    	je _strcat_start
0155++ 0A08 79          	inc d
0156++ 0A09 0A 03 0A    	jmp _strcat_goto_end_l1
0157++ 0A0C             _strcat_start:
0158++ 0A0C FD 50       	mov di, d
0159++ 0A0E             _strcat_l1:
0160++ 0A0E F6          	lodsb
0161++ 0A0F F7          	stosb
0162++ 0A10 B9 00       	cmp al, 0
0163++ 0A12 C7 0E 0A    	jne _strcat_l1
0164++ 0A15             _strcat_end:
0165++ 0A15 E7          	pop d
0166++ 0A16 E4          	pop a
0167++ 0A17 F0          	pop di
0168++ 0A18 EF          	pop si
0169++ 0A19 09          	ret
0170++ 0A1A             
0171++ 0A1A             
0005+  0A1A             
0006+  0A1A             
0007+  0A1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0A1A             ; convert ascii 'o'..'f' to integer 0..15
0009+  0A1A             ; ascii in bl
0010+  0A1A             ; result in al
0011+  0A1A             ; ascii for f = 0100 0110
0012+  0A1A             ; ascii for 9 = 0011 1001
0013+  0A1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0A1A             hex_ascii_encode:
0015+  0A1A 1B            mov al, bl
0016+  0A1B 93 40         test al, $40        ; test if letter or number
0017+  0A1D C7 23 0A      jnz hex_letter
0018+  0A20 87 0F         and al, $0f        ; get number
0019+  0A22 09            ret
0020+  0A23             hex_letter:
0021+  0A23 87 0F         and al, $0f        ; get letter
0022+  0A25 6A 09         add al, 9
0023+  0A27 09            ret
0024+  0A28             
0025+  0A28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0A28             ; atoi
0027+  0A28             ; 2 letter hex string in b
0028+  0A28             ; 8bit integer returned in al
0029+  0A28             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0A28             _atoi:
0031+  0A28 D8            push b
0032+  0A29 07 1A 0A      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0A2C 30            mov bl, bh
0034+  0A2D DB            push al          ; save a
0035+  0A2E 07 1A 0A      call hex_ascii_encode
0036+  0A31 EA            pop bl  
0037+  0A32 FD 9E 04      shl al, 4
0038+  0A35 8C            or al, bl
0039+  0A36 E5            pop b
0040+  0A37 09            ret  
0041+  0A38             
0042+  0A38             
0043+  0A38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0A38             ; scanf
0045+  0A38             ; no need for explanations!
0046+  0A38             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0A38             scanf:
0048+  0A38 09            ret
0049+  0A39             
0050+  0A39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0A39             ; itoa
0052+  0A39             ; 8bit value in bl
0053+  0A39             ; 2 byte ascii result in a
0054+  0A39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0A39             _itoa:
0056+  0A39 DA            push d
0057+  0A3A D8            push b
0058+  0A3B A7 00         mov bh, 0
0059+  0A3D FD A4 04      shr bl, 4  
0060+  0A40 74            mov d, b
0061+  0A41 1F D3 0C      mov al, [d + s_hex_digits]
0062+  0A44 23            mov ah, al
0063+  0A45               
0064+  0A45 E5            pop b
0065+  0A46 D8            push b
0066+  0A47 A7 00         mov bh, 0
0067+  0A49 FD 87 0F      and bl, $0f
0068+  0A4C 74            mov d, b
0069+  0A4D 1F D3 0C      mov al, [d + s_hex_digits]
0070+  0A50 E5            pop b
0071+  0A51 E7            pop d
0072+  0A52 09            ret
0073+  0A53             
0074+  0A53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0A53             ; hex string to binary
0076+  0A53             ; di = destination address
0077+  0A53             ; si = source
0078+  0A53             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0A53             _hex_to_int:
0080+  0A53             _hex_to_int_l1:
0081+  0A53 F6            lodsb          ; load from [si] to al
0082+  0A54 B9 00         cmp al, 0        ; check if ascii 0
0083+  0A56 C6 63 0A      jz _hex_to_int_ret
0084+  0A59 36            mov bh, al
0085+  0A5A F6            lodsb
0086+  0A5B 2F            mov bl, al
0087+  0A5C 07 28 0A      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0A5F F7            stosb          ; store al to [di]
0089+  0A60 0A 53 0A      jmp _hex_to_int_l1
0090+  0A63             _hex_to_int_ret:
0091+  0A63 09            ret    
0092+  0A64             
0093+  0A64             
0094+  0A64             
0095+  0A64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0A64             ; getchar
0097+  0A64             ; char in ah
0098+  0A64             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0A64             getch:
0100+  0A64 DB            push al
0101+  0A65             getch_retry:
0102+  0A65 19 01         mov al, 1
0103+  0A67 05 03         syscall sys_io      ; receive in ah
0104+  0A69 E8            pop al
0105+  0A6A 09            ret
0106+  0A6B             
0107+  0A6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0A6B             ; putchar
0109+  0A6B             ; char in ah
0110+  0A6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0A6B             _putchar:
0112+  0A6B DB            push al
0113+  0A6C 19 00         mov al, 0
0114+  0A6E 05 03         syscall sys_io      ; char in ah
0115+  0A70 E8            pop al
0116+  0A71 09            ret
0117+  0A72             
0118+  0A72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0A72             ;; input a string
0120+  0A72             ;; terminates with null
0121+  0A72             ;; pointer in d
0122+  0A72             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0A72             _gets:
0124+  0A72 D7            push a
0125+  0A73 DA            push d
0126+  0A74             _gets_loop:
0127+  0A74 19 01         mov al, 1
0128+  0A76 05 03         syscall sys_io      ; receive in ah
0129+  0A78 76 1B         cmp ah, 27
0130+  0A7A C6 9B 0A      je _gets_ansi_esc
0131+  0A7D 76 0A         cmp ah, $0a        ; lf
0132+  0A7F C6 F7 0A      je _gets_end
0133+  0A82 76 0D         cmp ah, $0d        ; cr
0134+  0A84 C6 F7 0A      je _gets_end
0135+  0A87 76 5C         cmp ah, $5c        ; '\\'
0136+  0A89 C6 BD 0A      je _gets_escape
0137+  0A8C 76 08         cmp ah, $08      ; check for backspace
0138+  0A8E C6 97 0A      je _gets_backspace
0139+  0A91 1A            mov al, ah
0140+  0A92 3E            mov [d], al
0141+  0A93 79            inc d
0142+  0A94 0A 74 0A      jmp _gets_loop
0143+  0A97             _gets_backspace:
0144+  0A97 7F            dec d
0145+  0A98 0A 74 0A      jmp _gets_loop
0146+  0A9B             _gets_ansi_esc:
0147+  0A9B 19 01         mov al, 1
0148+  0A9D 05 03         syscall sys_io        ; receive in ah without echo
0149+  0A9F 76 5B         cmp ah, '['
0150+  0AA1 C7 74 0A      jne _gets_loop
0151+  0AA4 19 01         mov al, 1
0152+  0AA6 05 03         syscall sys_io          ; receive in ah without echo
0153+  0AA8 76 64         cmp ah, 'd'
0154+  0AAA C6 B5 0A      je _gets_left_arrow
0155+  0AAD 76 63         cmp ah, 'c'
0156+  0AAF C6 B9 0A      je _gets_right_arrow
0157+  0AB2 0A 74 0A      jmp _gets_loop
0158+  0AB5             _gets_left_arrow:
0159+  0AB5 7F            dec d
0160+  0AB6 0A 74 0A      jmp _gets_loop
0161+  0AB9             _gets_right_arrow:
0162+  0AB9 79            inc d
0163+  0ABA 0A 74 0A      jmp _gets_loop
0164+  0ABD             _gets_escape:
0165+  0ABD 19 01         mov al, 1
0166+  0ABF 05 03         syscall sys_io      ; receive in ah
0167+  0AC1 76 6E         cmp ah, 'n'
0168+  0AC3 C6 E2 0A      je _gets_lf
0169+  0AC6 76 72         cmp ah, 'r'
0170+  0AC8 C6 E9 0A      je _gets_cr
0171+  0ACB 76 30         cmp ah, '0'
0172+  0ACD C6 F0 0A      je _gets_null
0173+  0AD0 76 5C         cmp ah, $5c  ; '\'
0174+  0AD2 C6 DB 0A      je _gets_slash
0175+  0AD5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0AD6 3E            mov [d], al
0177+  0AD7 79            inc d
0178+  0AD8 0A 74 0A      jmp _gets_loop
0179+  0ADB             _gets_slash:
0180+  0ADB 19 5C         mov al, $5c
0181+  0ADD 3E            mov [d], al
0182+  0ADE 79            inc d
0183+  0ADF 0A 74 0A      jmp _gets_loop
0184+  0AE2             _gets_lf:
0185+  0AE2 19 0A         mov al, $0a
0186+  0AE4 3E            mov [d], al
0187+  0AE5 79            inc d
0188+  0AE6 0A 74 0A      jmp _gets_loop
0189+  0AE9             _gets_cr:
0190+  0AE9 19 0D         mov al, $0d
0191+  0AEB 3E            mov [d], al
0192+  0AEC 79            inc d
0193+  0AED 0A 74 0A      jmp _gets_loop
0194+  0AF0             _gets_null:
0195+  0AF0 19 00         mov al, $00
0196+  0AF2 3E            mov [d], al
0197+  0AF3 79            inc d
0198+  0AF4 0A 74 0A      jmp _gets_loop
0199+  0AF7             _gets_end:
0200+  0AF7 19 00         mov al, 0
0201+  0AF9 3E            mov [d], al        ; terminate string
0202+  0AFA E7            pop d
0203+  0AFB E4            pop a
0204+  0AFC 09            ret
0205+  0AFD             
0206+  0AFD             
0207+  0AFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0AFD             ;; input text
0209+  0AFD             ;; terminated with ctrl+d
0210+  0AFD             ;; pointer in d
0211+  0AFD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0AFD             _gettxt:
0213+  0AFD D7            push a
0214+  0AFE DA            push d
0215+  0AFF             _gettxt_loop:
0216+  0AFF 19 01         mov al, 1
0217+  0B01 05 03         syscall sys_io      ; receive in ah
0218+  0B03 76 04         cmp ah, 4      ; eot
0219+  0B05 C6 3E 0B      je _gettxt_end
0220+  0B08 76 08         cmp ah, $08      ; check for backspace
0221+  0B0A C6 3A 0B      je _gettxt_backspace
0222+  0B0D 76 5C         cmp ah, $5c        ; '\'
0223+  0B0F C6 18 0B      je _gettxt_escape
0224+  0B12 1A            mov al, ah
0225+  0B13 3E            mov [d], al
0226+  0B14 79            inc d
0227+  0B15 0A FF 0A      jmp _gettxt_loop
0228+  0B18             _gettxt_escape:
0229+  0B18 19 01         mov al, 1
0230+  0B1A 05 03         syscall sys_io      ; receive in ah
0231+  0B1C 76 6E         cmp ah, 'n'
0232+  0B1E C6 2C 0B      je _gettxt_lf
0233+  0B21 76 72         cmp ah, 'r'
0234+  0B23 C6 33 0B      je _gettxt_cr
0235+  0B26 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0B27 3E            mov [d], al
0237+  0B28 79            inc d
0238+  0B29 0A FF 0A      jmp _gettxt_loop
0239+  0B2C             _gettxt_lf:
0240+  0B2C 19 0A         mov al, $0a
0241+  0B2E 3E            mov [d], al
0242+  0B2F 79            inc d
0243+  0B30 0A FF 0A      jmp _gettxt_loop
0244+  0B33             _gettxt_cr:
0245+  0B33 19 0D         mov al, $0d
0246+  0B35 3E            mov [d], al
0247+  0B36 79            inc d
0248+  0B37 0A FF 0A      jmp _gettxt_loop
0249+  0B3A             _gettxt_backspace:
0250+  0B3A 7F            dec d
0251+  0B3B 0A FF 0A      jmp _gettxt_loop
0252+  0B3E             _gettxt_end:
0253+  0B3E 19 00         mov al, 0
0254+  0B40 3E            mov [d], al        ; terminate string
0255+  0B41 E7            pop d
0256+  0B42 E4            pop a
0257+  0B43 09            ret
0258+  0B44             
0259+  0B44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0B44             ; print new line
0261+  0B44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0B44             printnl:
0263+  0B44 D7            push a
0264+  0B45 10 00 0A      mov a, $0a00
0265+  0B48 05 03         syscall sys_io
0266+  0B4A 10 00 0D      mov a, $0d00
0267+  0B4D 05 03         syscall sys_io
0268+  0B4F E4            pop a
0269+  0B50 09            ret
0270+  0B51             
0271+  0B51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0B51             ; _strtoint
0273+  0B51             ; 4 digit hex string number in d
0274+  0B51             ; integer returned in a
0275+  0B51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0B51             _strtointx:
0277+  0B51 D8            push b
0278+  0B52 32            mov bl, [d]
0279+  0B53 37            mov bh, bl
0280+  0B54 33 01 00      mov bl, [d + 1]
0281+  0B57 07 28 0A      call _atoi        ; convert to int in al
0282+  0B5A 23            mov ah, al        ; move to ah
0283+  0B5B 33 02 00      mov bl, [d + 2]
0284+  0B5E 37            mov bh, bl
0285+  0B5F 33 03 00      mov bl, [d + 3]
0286+  0B62 07 28 0A      call _atoi        ; convert to int in al
0287+  0B65 E5            pop b
0288+  0B66 09            ret
0289+  0B67             
0290+  0B67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0B67             ; _strtoint
0292+  0B67             ; 5 digit base10 string number in d
0293+  0B67             ; integer returned in a
0294+  0B67             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0B67             _strtoint:
0296+  0B67 E2            push si
0297+  0B68 D8            push b
0298+  0B69 D9            push c
0299+  0B6A DA            push d
0300+  0B6B 07 CA 09      call _strlen      ; get string length in c
0301+  0B6E 7E            dec c
0302+  0B6F FD 4E         mov si, d
0303+  0B71 12            mov a, c
0304+  0B72 FD 99         shl a
0305+  0B74 3B EB 0C      mov d, table_power
0306+  0B77 59            add d, a
0307+  0B78 38 00 00      mov c, 0
0308+  0B7B             _strtoint_l0:
0309+  0B7B F6            lodsb      ; load ascii to al
0310+  0B7C B9 00         cmp al, 0
0311+  0B7E C6 91 0B      je _strtoint_end
0312+  0B81 6F 30         sub al, $30    ; make into integer
0313+  0B83 22 00         mov ah, 0
0314+  0B85 2A            mov b, [d]
0315+  0B86 AC            mul a, b      ; result in b since it fits in 16bits
0316+  0B87 11            mov a, b
0317+  0B88 28            mov b, c
0318+  0B89 54            add a, b
0319+  0B8A 39            mov c, a
0320+  0B8B 63 02 00      sub d, 2
0321+  0B8E 0A 7B 0B      jmp _strtoint_l0
0322+  0B91             _strtoint_end:
0323+  0B91 12            mov a, c
0324+  0B92 E7            pop d
0325+  0B93 E6            pop c
0326+  0B94 E5            pop b
0327+  0B95 EF            pop si
0328+  0B96 09            ret
0329+  0B97             
0330+  0B97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0B97             ; print null terminated string
0332+  0B97             ; pointer in d
0333+  0B97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0B97             _puts:
0335+  0B97 D7            push a
0336+  0B98 DA            push d
0337+  0B99             _puts_l1:
0338+  0B99 1E            mov al, [d]
0339+  0B9A B9 00         cmp al, 0
0340+  0B9C C6 A8 0B      jz _puts_end
0341+  0B9F 23            mov ah, al
0342+  0BA0 19 00         mov al, 0
0343+  0BA2 05 03         syscall sys_io
0344+  0BA4 79            inc d
0345+  0BA5 0A 99 0B      jmp _puts_l1
0346+  0BA8             _puts_end:
0347+  0BA8 E7            pop d
0348+  0BA9 E4            pop a
0349+  0BAA 09            ret
0350+  0BAB             
0351+  0BAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0BAB             ; print n size string
0353+  0BAB             ; pointer in d
0354+  0BAB             ; size in c
0355+  0BAB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0BAB             _putsn:
0357+  0BAB DB            push al
0358+  0BAC DA            push d
0359+  0BAD D9            push c
0360+  0BAE             _putsn_l0:
0361+  0BAE 1E            mov al, [d]
0362+  0BAF 23            mov ah, al
0363+  0BB0 19 00         mov al, 0
0364+  0BB2 05 03         syscall sys_io
0365+  0BB4 79            inc d
0366+  0BB5 7E            dec c  
0367+  0BB6 C2 00 00      cmp c, 0
0368+  0BB9 C7 AE 0B      jne _putsn_l0
0369+  0BBC             _putsn_end:
0370+  0BBC E6            pop c
0371+  0BBD E7            pop d
0372+  0BBE E8            pop al
0373+  0BBF 09            ret
0374+  0BC0             
0375+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0BC0             ; print 16bit decimal number
0377+  0BC0             ; input number in a
0378+  0BC0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0BC0             print_u16d:
0380+  0BC0 D7            push a
0381+  0BC1 D8            push b
0382+  0BC2 FD D8         push g
0383+  0BC4 26 10 27      mov b, 10000
0384+  0BC7 AE            div a, b      ; get 10000's coeff.
0385+  0BC8 07 EC 0B      call print_number
0386+  0BCB 11            mov a, b
0387+  0BCC 26 E8 03      mov b, 1000
0388+  0BCF AE            div a, b      ; get 1000's coeff.
0389+  0BD0 07 EC 0B      call print_number
0390+  0BD3 11            mov a, b
0391+  0BD4 26 64 00      mov b, 100
0392+  0BD7 AE            div a, b
0393+  0BD8 07 EC 0B      call print_number
0394+  0BDB 11            mov a, b
0395+  0BDC 26 0A 00      mov b, 10
0396+  0BDF AE            div a, b
0397+  0BE0 07 EC 0B      call print_number
0398+  0BE3 1B            mov al, bl      ; 1's coeff in bl
0399+  0BE4 07 EC 0B      call print_number
0400+  0BE7 FD F1         pop g
0401+  0BE9 E5            pop b
0402+  0BEA E4            pop a
0403+  0BEB 09            ret
0404+  0BEC             
0405+  0BEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0BEC             ; print al
0407+  0BEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0BEC             print_number:
0409+  0BEC 6A 30         add al, $30
0410+  0BEE 23            mov ah, al
0411+  0BEF 07 6B 0A      call _putchar
0412+  0BF2 09            ret
0413+  0BF3             
0414+  0BF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0BF3             ; print 16bit hex integer
0416+  0BF3             ; integer value in reg b
0417+  0BF3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0BF3             print_u16x:
0419+  0BF3 D7            push a
0420+  0BF4 D8            push b
0421+  0BF5 DD            push bl
0422+  0BF6 30            mov bl, bh
0423+  0BF7 07 39 0A      call _itoa        ; convert bh to char in a
0424+  0BFA 2F            mov bl, al        ; save al
0425+  0BFB 19 00         mov al, 0
0426+  0BFD 05 03         syscall sys_io        ; display ah
0427+  0BFF 24            mov ah, bl        ; retrieve al
0428+  0C00 19 00         mov al, 0
0429+  0C02 05 03         syscall sys_io        ; display al
0430+  0C04             
0431+  0C04 EA            pop bl
0432+  0C05 07 39 0A      call _itoa        ; convert bh to char in a
0433+  0C08 2F            mov bl, al        ; save al
0434+  0C09 19 00         mov al, 0
0435+  0C0B 05 03         syscall sys_io        ; display ah
0436+  0C0D 24            mov ah, bl        ; retrieve al
0437+  0C0E 19 00         mov al, 0
0438+  0C10 05 03         syscall sys_io        ; display al
0439+  0C12             
0440+  0C12 E5            pop b
0441+  0C13 E4            pop a
0442+  0C14 09            ret
0443+  0C15             
0444+  0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0C15             ; input 16bit hex integer
0446+  0C15             ; read 16bit integer into a
0447+  0C15             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0C15             scan_u16x:
0449+  0C15 F8 10 00      enter 16
0450+  0C18 D8            push b
0451+  0C19 DA            push d
0452+  0C1A             
0453+  0C1A FA F1 FF      lea d, [bp + -15]
0454+  0C1D 07 72 0A      call _gets        ; get number
0455+  0C20             
0456+  0C20 32            mov bl, [d]
0457+  0C21 37            mov bh, bl
0458+  0C22 33 01 00      mov bl, [d + 1]
0459+  0C25 07 28 0A      call _atoi        ; convert to int in al
0460+  0C28 23            mov ah, al        ; move to ah
0461+  0C29             
0462+  0C29 33 02 00      mov bl, [d + 2]
0463+  0C2C 37            mov bh, bl
0464+  0C2D 33 03 00      mov bl, [d + 3]
0465+  0C30 07 28 0A      call _atoi        ; convert to int in al
0466+  0C33             
0467+  0C33 E7            pop d
0468+  0C34 E5            pop b
0469+  0C35 F9            leave
0470+  0C36 09            ret
0471+  0C37             
0472+  0C37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0C37             ; print 8bit hex integer
0474+  0C37             ; integer value in reg bl
0475+  0C37             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0C37             print_u8x:
0477+  0C37 D7            push a
0478+  0C38 DD            push bl
0479+  0C39             
0480+  0C39 07 39 0A      call _itoa        ; convert bl to char in a
0481+  0C3C 2F            mov bl, al        ; save al
0482+  0C3D 19 00         mov al, 0
0483+  0C3F 05 03         syscall sys_io        ; display ah
0484+  0C41 24            mov ah, bl        ; retrieve al
0485+  0C42 19 00         mov al, 0
0486+  0C44 05 03         syscall sys_io        ; display al
0487+  0C46             
0488+  0C46 EA            pop bl
0489+  0C47 E4            pop a
0490+  0C48 09            ret
0491+  0C49             
0492+  0C49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0C49             ; print 8bit decimal unsigned number
0494+  0C49             ; input number in al
0495+  0C49             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0C49             print_u8d:
0497+  0C49 D7            push a
0498+  0C4A D8            push b
0499+  0C4B FD D8         push g
0500+  0C4D 22 00         mov ah, 0
0501+  0C4F 26 64 00      mov b, 100
0502+  0C52 AE            div a, b
0503+  0C53 D8            push b      ; save remainder
0504+  0C54 B9 00         cmp al, 0
0505+  0C56 C6 60 0C      je skip100
0506+  0C59 6A 30         add al, $30
0507+  0C5B 23            mov ah, al
0508+  0C5C 19 00         mov al, 0
0509+  0C5E 05 03         syscall sys_io  ; print coeff
0510+  0C60             skip100:
0511+  0C60 E4            pop a
0512+  0C61 22 00         mov ah, 0
0513+  0C63 26 0A 00      mov b, 10
0514+  0C66 AE            div a, b
0515+  0C67 D8            push b      ; save remainder
0516+  0C68 B9 00         cmp al, 0
0517+  0C6A C6 74 0C      je skip10
0518+  0C6D 6A 30         add al, $30
0519+  0C6F 23            mov ah, al
0520+  0C70 19 00         mov al, 0
0521+  0C72 05 03         syscall sys_io  ; print coeff
0522+  0C74             skip10:
0523+  0C74 E4            pop a
0524+  0C75 1B            mov al, bl
0525+  0C76 6A 30         add al, $30
0526+  0C78 23            mov ah, al
0527+  0C79 19 00         mov al, 0
0528+  0C7B 05 03         syscall sys_io  ; print coeff
0529+  0C7D FD F1         pop g
0530+  0C7F E5            pop b
0531+  0C80 E4            pop a
0532+  0C81 09            ret
0533+  0C82             
0534+  0C82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0C82             ; input 8bit hex integer
0536+  0C82             ; read 8bit integer into al
0537+  0C82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0C82             scan_u8x:
0539+  0C82 F8 04 00      enter 4
0540+  0C85 D8            push b
0541+  0C86 DA            push d
0542+  0C87             
0543+  0C87 FA FD FF      lea d, [bp + -3]
0544+  0C8A 07 72 0A      call _gets        ; get number
0545+  0C8D             
0546+  0C8D 32            mov bl, [d]
0547+  0C8E 37            mov bh, bl
0548+  0C8F 33 01 00      mov bl, [d + 1]
0549+  0C92 07 28 0A      call _atoi        ; convert to int in al
0550+  0C95             
0551+  0C95 E7            pop d
0552+  0C96 E5            pop b
0553+  0C97 F9            leave
0554+  0C98 09            ret
0555+  0C99             
0556+  0C99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0C99             ; input decimal number
0558+  0C99             ; result in a
0559+  0C99             ; 655'\0'
0560+  0C99             ; low--------high
0561+  0C99             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0C99             scan_u16d:
0563+  0C99 F8 08 00      enter 8
0564+  0C9C E2            push si
0565+  0C9D D8            push b
0566+  0C9E D9            push c
0567+  0C9F DA            push d
0568+  0CA0 FA F9 FF      lea d, [bp +- 7]
0569+  0CA3 07 72 0A      call _gets
0570+  0CA6 07 CA 09      call _strlen      ; get string length in c
0571+  0CA9 7E            dec c
0572+  0CAA FD 4E         mov si, d
0573+  0CAC 12            mov a, c
0574+  0CAD FD 99         shl a
0575+  0CAF 3B EB 0C      mov d, table_power
0576+  0CB2 59            add d, a
0577+  0CB3 38 00 00      mov c, 0
0578+  0CB6             mul_loop:
0579+  0CB6 F6            lodsb      ; load ascii to al
0580+  0CB7 B9 00         cmp al, 0
0581+  0CB9 C6 CC 0C      je mul_exit
0582+  0CBC 6F 30         sub al, $30    ; make into integer
0583+  0CBE 22 00         mov ah, 0
0584+  0CC0 2A            mov b, [d]
0585+  0CC1 AC            mul a, b      ; result in b since it fits in 16bits
0586+  0CC2 11            mov a, b
0587+  0CC3 28            mov b, c
0588+  0CC4 54            add a, b
0589+  0CC5 39            mov c, a
0590+  0CC6 63 02 00      sub d, 2
0591+  0CC9 0A B6 0C      jmp mul_loop
0592+  0CCC             mul_exit:
0593+  0CCC 12            mov a, c
0594+  0CCD E7            pop d
0595+  0CCE E6            pop c
0596+  0CCF E5            pop b
0597+  0CD0 EF            pop si
0598+  0CD1 F9            leave
0599+  0CD2 09            ret
0600+  0CD3             
0601+  0CD3             
0602+  0CD3 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  0CD7 34 35 36 37 
0602+  0CDB 38 39 61 62 
0602+  0CDF 63 64 65 66 
0603+  0CE3 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  0CE7 1B 5B 68 00 
0604+  0CEB             
0605+  0CEB             table_power:
0606+  0CEB 01 00         .dw 1
0607+  0CED 0A 00         .dw 10
0608+  0CEF 64 00         .dw 100
0609+  0CF1 E8 03         .dw 1000
0610+  0CF3 10 27         .dw 100000037   0CF5             .include "lib/ctype.asm"
0001+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0CF5             ; ctype.s
0003+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0CF5             
0005+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0CF5             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  0CF5             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  0CF5             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  0CF5             ;; characters are supported.
0010+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0CF5             ;; _isalnum 
0012+  0CF5             ;; _isalpha 
0013+  0CF5             ;; islower 
0014+  0CF5             ;; isupper 
0015+  0CF5             ;; _isdigit 
0016+  0CF5             ;; isxdigit
0017+  0CF5             ;; iscntrl 
0018+  0CF5             ;; isgraph 
0019+  0CF5             ;; _isspace 
0020+  0CF5             ;; isblank 
0021+  0CF5             ;; isprint 
0022+  0CF5             ;; ispunct 
0023+  0CF5             ;; tolower 
0024+  0CF5             ;; toupper
0025+  0CF5             
0026+  0CF5             
0027+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0CF5             ;; is alphanumeric
0029+  0CF5             ;; sets zf according with result
0030+  0CF5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0CF5             _isalnum:
0032+  0CF5 07 12 0D    	call _isalpha
0033+  0CF8 C6 FE 0C    	je _isalnum_exit
0034+  0CFB 07 FF 0C    	call _isdigit
0035+  0CFE             _isalnum_exit:
0036+  0CFE 09          	ret	
0037+  0CFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0CFF             ;; is digit
0039+  0CFF             ;; sets zf according with result
0040+  0CFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0CFF             _isdigit:
0042+  0CFF DB          	push al
0043+  0D00 B9 30       	cmp al, '0'
0044+  0D02 C8 0E 0D    	jlu _isdigit_false
0045+  0D05 B9 39       	cmp al, '9'
0046+  0D07 D1 0E 0D    	jgu _isdigit_false
0047+  0D0A 87 00       	and al, 0	; set zf
0048+  0D0C E8          	pop al
0049+  0D0D 09          	ret
0050+  0D0E             _isdigit_false:
0051+  0D0E 8B 01       	or al, 1	; clear zf
0052+  0D10 E8          	pop al
0053+  0D11 09          	ret	
0054+  0D12             	
0055+  0D12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0D12             ;; is alpha
0057+  0D12             ;; sets zf according with result
0058+  0D12             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0D12             _isalpha:
0060+  0D12 DB          	push al
0061+  0D13 B9 5F       	cmp al, '_'
0062+  0D15 C6 35 0D    	je _isalpha_true
0063+  0D18 B9 2E       	cmp al, '.'
0064+  0D1A C6 35 0D    	je _isalpha_true
0065+  0D1D B9 61       	cmp al, 'a'
0066+  0D1F C8 31 0D    	jlu _isalpha_false
0067+  0D22 B9 7A       	cmp al, 'z'
0068+  0D24 D1 31 0D    	jgu _isalpha_false
0069+  0D27 B9 7A       	cmp al, 'z'
0070+  0D29 D0 35 0D    	jleu _isalpha_true
0071+  0D2C B9 61       	cmp al, 'a'
0072+  0D2E C9 35 0D    	jgeu _isalpha_true
0073+  0D31             _isalpha_false:
0074+  0D31 8B 01       	or al, 1	; clear zf
0075+  0D33 E8          	pop al
0076+  0D34 09          	ret
0077+  0D35             _isalpha_true:
0078+  0D35 87 00       	and al, 0	; set zf
0079+  0D37 E8          	pop al
0080+  0D38 09          	ret
0081+  0D39             
0082+  0D39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0D39             ;; is path-alpha
0084+  0D39             ;; sets zf according with result
0085+  0D39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0D39             ispath:
0087+  0D39 DB          	push al
0088+  0D3A 07 FF 0C    	call _isdigit
0089+  0D3D C6 67 0D    	je ispath_true
0090+  0D40 B9 5F       	cmp al, '_'
0091+  0D42 C6 67 0D    	je ispath_true
0092+  0D45 B9 2F       	cmp al, '/'
0093+  0D47 C6 67 0D    	je ispath_true
0094+  0D4A B9 2E       	cmp al, '.'
0095+  0D4C C6 67 0D    	je ispath_true
0096+  0D4F B9 61       	cmp al, 'a'
0097+  0D51 C8 63 0D    	jlu ispath_false
0098+  0D54 B9 7A       	cmp al, 'z'
0099+  0D56 D1 63 0D    	jgu ispath_false
0100+  0D59 B9 7A       	cmp al, 'z'
0101+  0D5B D0 67 0D    	jleu ispath_true
0102+  0D5E B9 61       	cmp al, 'a'
0103+  0D60 C9 67 0D    	jgeu ispath_true
0104+  0D63             ispath_false:
0105+  0D63 8B 01       	or al, 1	; clear zf
0106+  0D65 E8          	pop al
0107+  0D66 09          	ret
0108+  0D67             ispath_true:
0109+  0D67 87 00       	and al, 0	; set zf
0110+  0D69 E8          	pop al
0111+  0D6A 09          	ret
0112+  0D6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0D6B             ;; is space
0114+  0D6B             ;; sets zf according with result
0115+  0D6B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0D6B             _isspace:
0117+  0D6B B9 20       	cmp al, $20		; ' '
0118+  0D6D C6 81 0D    	je _isspace_exit
0119+  0D70 B9 09       	cmp al, $09		; '\t'
0120+  0D72 C6 81 0D    	je _isspace_exit
0121+  0D75 B9 0A       	cmp al, $0a		; '\n'
0122+  0D77 C6 81 0D    	je _isspace_exit
0123+  0D7A B9 0D       	cmp al, $0d		; '\r'
0124+  0D7C C6 81 0D    	je _isspace_exit
0125+  0D7F B9 0B       	cmp al, $0b		; '\v'
0126+  0D81             _isspace_exit:
0127+  0D81 09          	ret	
0128+  0D82             
0129+  0D82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0D82             ; to lower
0131+  0D82             ; input in al
0132+  0D82             ; output in al
0133+  0D82             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0D82             _to_lower:
0135+  0D82 B9 7A       	cmp al, 'z'
0136+  0D84 D1 89 0D    	jgu _to_lower_ret
0137+  0D87 6A 20       	add al, $20				; convert to lower case
0138+  0D89             _to_lower_ret:
0139+  0D89 09          	ret
0140+  0D8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0D8A             ; to upper
0142+  0D8A             ; input in al
0143+  0D8A             ; output in al
0144+  0D8A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0D8A             _to_upper:
0146+  0D8A B9 61       	cmp al, 'a'
0147+  0D8C C8 91 0D    	jlu _to_upper_ret
0148+  0D8F 6F 20       	sub al, $20			; convert to upper case
0149+  0D91             _to_upper_ret:
0150+  0D91 09          	ret
0151+  0D92             
0038   0D92             
0039   0D92             transient_area:
0040   0D92             
0041   0D92             .endtasm: Number of errors = 0
