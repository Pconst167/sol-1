0001   0000             .include "lib/kernel.exp"
0001+  0000             fdc_irq_event    .EQU  $195a
0002+  0000             sys_break        .EQU  $0000
0003+  0000             sys_rtc          .EQU  $0001
0004+  0000             sys_ide          .EQU  $0002
0005+  0000             sys_io           .EQU  $0003
0006+  0000             sys_filesystem   .EQU  $0004
0007+  0000             sys_create_proc  .EQU  $0005
0008+  0000             sys_list_proc    .EQU  $0006
0009+  0000             sys_datetime     .EQU  $0007
0010+  0000             sys_reboot       .EQU  $0008
0011+  0000             sys_pause_proc   .EQU  $0009
0012+  0000             sys_resume_proc  .EQU  $000a
0013+  0000             sys_terminate_proc .EQU  $000b
0014+  0000             sys_system       .EQU  $000c
0015+  0000             sys_fdc          .EQU  $000d
0016+  0000             text_org         .EQU  $0400
0002   0400             .org text_org
0003   0400             
0004   0400             ; _FDC_CONFIG       .equ $FFC0 
0005   0400             ; _FDC_STATUS_1     .equ $FFC1
0006   0400             ; _FDC_WD_STAT_CMD  .equ $FFC8
0007   0400             ; _FDC_WD_TRACK     .equ $FFC9
0008   0400             ; _FDC_WD_SECTOR    .equ $FFCA
0009   0400             ; _FDC_WD_DATA      .equ $FFCB
0010   0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011   0400             main:
0012   0400 FD 49 FF FF   mov bp, $FFFF
0013   0404 FD 47 FF FF   mov sp, $FFFF
0014   0408             
0015   0408             
0016   0408 3B 38 05      mov d, str0
0017   040B 07 70 07      call _puts
0018   040E               ; First, select drive 1 and de-select drive 0
0019   040E 3B C0 FF      mov d, $FFC0
0020   0411 19 02         mov al, 2       ; setparam call
0021   0413 2E 0A         mov bl, %00001010     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0022   0415 05 0C         syscall sys_system
0023   0417             
0024   0417 3B 4F 05      mov d, str1
0025   041A 07 70 07      call _puts
0026   041D             ; wait a little
0027   041D 38 FF 00      mov c, $FF
0028   0420             loop1:
0029   0420 7E            dec c
0030   0421 C7 20 04      jnz loop1
0031   0424             
0032   0424             
0033   0424             menu:
0034   0424 3B CA 04      mov d, s_menu
0035   0427 07 70 07      call _puts
0036   042A 07 3D 06      call getch
0037   042D 76 30         cmp ah, '0'
0038   042F C6 4D 04      je step_in
0039   0432 76 31         cmp ah, '1'
0040   0434 C6 65 04      je step_out
0041   0437 76 32         cmp ah, '2'
0042   0439 C6 59 04      je restore
0043   043C 76 33         cmp ah, '3'
0044   043E C6 71 04      je status1
0045   0441 76 34         cmp ah, '4'
0046   0443 C6 84 04      je status2
0047   0446 76 35         cmp ah, '5'
0048   0448 C6 97 04      je format
0049   044B 05 0B         syscall sys_terminate_proc
0050   044D             step_in:
0051   044D 3B C8 FF      mov d, $FFC8    ; wd1770
0052   0450 19 02         mov al, 2       ; setparam call
0053   0452 2E 53         mov bl, %01010011     ; step in
0054   0454 05 0C         syscall sys_system
0055   0456 0A 24 04      jmp menu
0056   0459             restore:
0057   0459             ; send restore command
0058   0459 3B C8 FF      mov d, $FFC8    ; wd1770
0059   045C 19 02         mov al, 2       ; setparam call
0060   045E 2E 03         mov bl, $03     ; restore command, 30ms rate
0061   0460 05 0C         syscall sys_system
0062   0462 0A 24 04      jmp menu
0063   0465             step_out:
0064   0465 3B C8 FF      mov d, $FFC8    ; wd1770
0065   0468 19 02         mov al, 2       ; setparam call
0066   046A 2E 73         mov bl, %01110011     ; step out
0067   046C 05 0C         syscall sys_system
0068   046E 0A 24 04      jmp menu
0069   0471             status1:
0070   0471 07 1D 07      call printnl
0071   0474 3B C1 FF      mov d, $FFC1    ; wd1770 status 1
0072   0477 19 04         mov al, 4       ; getparam call
0073   0479 05 0C         syscall sys_system
0074   047B 07 10 08      call print_u8x   ; print bl
0075   047E 07 1D 07      call printnl
0076   0481 0A 24 04      jmp menu
0077   0484             status2:
0078   0484 07 1D 07      call printnl
0079   0487 3B C8 FF      mov d, $FFC8    ; wd1770 status 
0080   048A 19 04         mov al, 4       ; getparam call
0081   048C 05 0C         syscall sys_system
0082   048E 07 10 08      call print_u8x   ; print bl
0083   0491 07 1D 07      call printnl
0084   0494 0A 24 04      jmp menu
0085   0497             format:
0086   0497 3B C1 04      mov d, s_track
0087   049A 07 70 07      call _puts
0088   049D 07 5B 08      call scan_u8x   ; in al
0089   04A0 2F            mov bl, al      ; track needs to be in bl
0090   04A1 19 00         mov al, 0       ; 0 = format
0091   04A3 05 0D         syscall sys_fdc 
0092   04A5 3B AE 04      mov d, s_format_done
0093   04A8 07 70 07      call _puts
0094   04AB 0A 24 04      jmp menu
0095   04AE             
0096   04AE 0A 66 6F 72 s_format_done: .db "\nformatting done.\n", 0
0096   04B2 6D 61 74 74 
0096   04B6 69 6E 67 20 
0096   04BA 64 6F 6E 65 
0096   04BE 2E 0A 00 
0097   04C1 0A 74 72 61 s_track: .db "\ntrack: ", 0
0097   04C5 63 6B 3A 20 
0097   04C9 00 
0098   04CA             
0099   04CA 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0099   04CE 73 74 65 70 
0099   04D2 20 69 6E 0A 
0100   04D6 31 2E 20 73         .db "1. step out\n", 
0100   04DA 74 65 70 20 
0100   04DE 6F 75 74 0A 
0101   04E2 32 2E 20 72         .db "2. restore\n", 
0101   04E6 65 73 74 6F 
0101   04EA 72 65 0A 
0102   04ED 33 2E 20 72         .db "3. read status 1\n", 
0102   04F1 65 61 64 20 
0102   04F5 73 74 61 74 
0102   04F9 75 73 20 31 
0102   04FD 0A 
0103   04FE 34 2E 20 72         .db "4. read status 2\n", 
0103   0502 65 61 64 20 
0103   0506 73 74 61 74 
0103   050A 75 73 20 32 
0103   050E 0A 
0104   050F 35 2E 20 66         .db "5. format track\n", 
0104   0513 6F 72 6D 61 
0104   0517 74 20 74 72 
0104   051B 61 63 6B 0A 
0105   051F 36 2E 20 65         .db "6. exit\n", 
0105   0523 78 69 74 0A 
0106   0527 0A 73 65 6C         .db "\nselect option: ", 0
0106   052B 65 63 74 20 
0106   052F 6F 70 74 69 
0106   0533 6F 6E 3A 20 
0106   0537 00 
0107   0538             
0108   0538 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0108   053C 65 63 74 69 
0108   0540 6E 67 20 64 
0108   0544 72 69 76 65 
0108   0548 20 31 2E 2E 
0108   054C 2E 0A 00 
0109   054F 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0109   0553 74 69 6E 67 
0109   0557 2E 2E 2E 0A 
0109   055B 00 
0110   055C             
0111   055C             .include "lib/stdio.asm"
0001+  055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  055C             ; stdio.s
0003+  055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  055C             .include "lib/string.asm"
0001++ 055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 055C             ; string.s
0003++ 055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 055C             
0005++ 055C             
0006++ 055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 055C             ; _strrev
0008++ 055C             ; reverse a string
0009++ 055C             ; D = string address
0010++ 055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 055C             ; 01234
0012++ 055C             _strrev:
0013++ 055C 4B          	pusha
0014++ 055D 07 A3 05    	call _strlen	; length in C
0015++ 0560 12          	mov a, c
0016++ 0561 AF 01 00    	cmp a, 1
0017++ 0564 D0 7E 05    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0567 7D          	dec a
0019++ 0568 FD 4E       	mov si, d	; beginning of string
0020++ 056A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 056C 59          	add d, a	; end of string
0022++ 056D 12          	mov a, c
0023++ 056E FD 9B       	shr a		; divide by 2
0024++ 0570 39          	mov c, a	; C now counts the steps
0025++ 0571             _strrev_L0:
0026++ 0571 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0572 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0573 3E          	mov [d], al	; store left char into right side
0029++ 0574 1B          	mov al, bl
0030++ 0575 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0576 7E          	dec c
0032++ 0577 7F          	dec d
0033++ 0578 C2 00 00    	cmp c, 0
0034++ 057B C7 71 05    	jne _strrev_L0
0035++ 057E             _strrev_end:
0036++ 057E 4C          	popa
0037++ 057F 09          	ret
0038++ 0580             	
0039++ 0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0580             ; _strchr
0041++ 0580             ; search string in D for char in AL
0042++ 0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0580             _strchr:
0044++ 0580             _strchr_L0:
0045++ 0580 32          	mov bl, [d]
0046++ 0581 C1 00       	cmp bl, 0
0047++ 0583 C6 8E 05    	je _strchr_end
0048++ 0586 BA          	cmp al, bl
0049++ 0587 C6 8E 05    	je _strchr_end
0050++ 058A 79          	inc d
0051++ 058B 0A 80 05    	jmp _strchr_L0
0052++ 058E             _strchr_end:
0053++ 058E 1B          	mov al, bl
0054++ 058F 09          	ret
0055++ 0590             
0056++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0590             ; _strstr
0058++ 0590             ; find sub-string
0059++ 0590             ; str1 in SI
0060++ 0590             ; str2 in DI
0061++ 0590             ; SI points to end of source string
0062++ 0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0590             _strstr:
0064++ 0590 DB          	push al
0065++ 0591 DA          	push d
0066++ 0592 E3          	push di
0067++ 0593             _strstr_loop:
0068++ 0593 F3          	cmpsb					; compare a byte of the strings
0069++ 0594 C7 9F 05    	jne _strstr_ret
0070++ 0597 FC 00 00    	lea d, [di + 0]
0071++ 059A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 059C C7 93 05    	jne _strstr_loop				; equal chars but not at end
0073++ 059F             _strstr_ret:
0074++ 059F F0          	pop di
0075++ 05A0 E7          	pop d
0076++ 05A1 E8          	pop al
0077++ 05A2 09          	ret
0078++ 05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05A3             ; length of null terminated string
0080++ 05A3             ; result in C
0081++ 05A3             ; pointer in D
0082++ 05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05A3             _strlen:
0084++ 05A3 DA          	push d
0085++ 05A4 38 00 00    	mov c, 0
0086++ 05A7             _strlen_L1:
0087++ 05A7 BD 00       	cmp byte [d], 0
0088++ 05A9 C6 B1 05    	je _strlen_ret
0089++ 05AC 79          	inc d
0090++ 05AD 78          	inc c
0091++ 05AE 0A A7 05    	jmp _strlen_L1
0092++ 05B1             _strlen_ret:
0093++ 05B1 E7          	pop d
0094++ 05B2 09          	ret
0095++ 05B3             
0096++ 05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05B3             ; STRCMP
0098++ 05B3             ; compare two strings
0099++ 05B3             ; str1 in SI
0100++ 05B3             ; str2 in DI
0101++ 05B3             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05B3             _strcmp:
0104++ 05B3 DB          	push al
0105++ 05B4 DA          	push d
0106++ 05B5 E3          	push di
0107++ 05B6 E2          	push si
0108++ 05B7             _strcmp_loop:
0109++ 05B7 F3          	cmpsb					; compare a byte of the strings
0110++ 05B8 C7 C3 05    	jne _strcmp_ret
0111++ 05BB FB FF FF    	lea d, [si +- 1]
0112++ 05BE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05C0 C7 B7 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 05C3             _strcmp_ret:
0115++ 05C3 EF          	pop si
0116++ 05C4 F0          	pop di
0117++ 05C5 E7          	pop d
0118++ 05C6 E8          	pop al
0119++ 05C7 09          	ret
0120++ 05C8             
0121++ 05C8             
0122++ 05C8             ; STRCPY
0123++ 05C8             ; copy null terminated string from SI to DI
0124++ 05C8             ; source in SI
0125++ 05C8             ; destination in DI
0126++ 05C8             _strcpy:
0127++ 05C8 E2          	push si
0128++ 05C9 E3          	push di
0129++ 05CA DB          	push al
0130++ 05CB             _strcpy_L1:
0131++ 05CB F6          	lodsb
0132++ 05CC F7          	stosb
0133++ 05CD B9 00       	cmp al, 0
0134++ 05CF C7 CB 05    	jne _strcpy_L1
0135++ 05D2             _strcpy_end:
0136++ 05D2 E8          	pop al
0137++ 05D3 F0          	pop di
0138++ 05D4 EF          	pop si
0139++ 05D5 09          	ret
0140++ 05D6             
0141++ 05D6             ; STRCAT
0142++ 05D6             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 05D6             ; source in SI
0144++ 05D6             ; destination in DI
0145++ 05D6             _strcat:
0146++ 05D6 E2          	push si
0147++ 05D7 E3          	push di
0148++ 05D8 D7          	push a
0149++ 05D9 DA          	push d
0150++ 05DA 50          	mov a, di
0151++ 05DB 3C          	mov d, a
0152++ 05DC             _strcat_goto_end_L1:
0153++ 05DC BD 00       	cmp byte[d], 0
0154++ 05DE C6 E5 05    	je _strcat_start
0155++ 05E1 79          	inc d
0156++ 05E2 0A DC 05    	jmp _strcat_goto_end_L1
0157++ 05E5             _strcat_start:
0158++ 05E5 FD 50       	mov di, d
0159++ 05E7             _strcat_L1:
0160++ 05E7 F6          	lodsb
0161++ 05E8 F7          	stosb
0162++ 05E9 B9 00       	cmp al, 0
0163++ 05EB C7 E7 05    	jne _strcat_L1
0164++ 05EE             _strcat_end:
0165++ 05EE E7          	pop d
0166++ 05EF E4          	pop a
0167++ 05F0 F0          	pop di
0168++ 05F1 EF          	pop si
0169++ 05F2 09          	ret
0170++ 05F3             
0171++ 05F3             
0005+  05F3             
0006+  05F3             
0007+  05F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  05F3             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  05F3             ; ASCII in BL
0010+  05F3             ; result in AL
0011+  05F3             ; ascii for F = 0100 0110
0012+  05F3             ; ascii for 9 = 0011 1001
0013+  05F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  05F3             hex_ascii_encode:
0015+  05F3 1B            mov al, bl
0016+  05F4 93 40         test al, $40        ; test if letter or number
0017+  05F6 C7 FC 05      jnz hex_letter
0018+  05F9 87 0F         and al, $0F        ; get number
0019+  05FB 09            ret
0020+  05FC             hex_letter:
0021+  05FC 87 0F         and al, $0F        ; get letter
0022+  05FE 6A 09         add al, 9
0023+  0600 09            ret
0024+  0601             
0025+  0601             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0601             ; ATOI
0027+  0601             ; 2 letter hex string in B
0028+  0601             ; 8bit integer returned in AL
0029+  0601             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0601             _atoi:
0031+  0601 D8            push b
0032+  0602 07 F3 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0605 30            mov bl, bh
0034+  0606 DB            push al          ; save a
0035+  0607 07 F3 05      call hex_ascii_encode
0036+  060A EA            pop bl  
0037+  060B FD 9E 04      shl al, 4
0038+  060E 8C            or al, bl
0039+  060F E5            pop b
0040+  0610 09            ret  
0041+  0611             
0042+  0611             
0043+  0611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0611             ; scanf
0045+  0611             ; no need for explanations!
0046+  0611             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0611             scanf:
0048+  0611 09            ret
0049+  0612             
0050+  0612             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0612             ; ITOA
0052+  0612             ; 8bit value in BL
0053+  0612             ; 2 byte ASCII result in A
0054+  0612             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0612             _itoa:
0056+  0612 DA            push d
0057+  0613 D8            push b
0058+  0614 A7 00         mov bh, 0
0059+  0616 FD A4 04      shr bl, 4  
0060+  0619 74            mov d, b
0061+  061A 1F AC 08      mov al, [d + s_hex_digits]
0062+  061D 23            mov ah, al
0063+  061E               
0064+  061E E5            pop b
0065+  061F D8            push b
0066+  0620 A7 00         mov bh, 0
0067+  0622 FD 87 0F      and bl, $0F
0068+  0625 74            mov d, b
0069+  0626 1F AC 08      mov al, [d + s_hex_digits]
0070+  0629 E5            pop b
0071+  062A E7            pop d
0072+  062B 09            ret
0073+  062C             
0074+  062C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  062C             ; HEX STRING TO BINARY
0076+  062C             ; di = destination address
0077+  062C             ; si = source
0078+  062C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  062C             _hex_to_int:
0080+  062C             _hex_to_int_L1:
0081+  062C F6            lodsb          ; load from [SI] to AL
0082+  062D B9 00         cmp al, 0        ; check if ASCII 0
0083+  062F C6 3C 06      jz _hex_to_int_ret
0084+  0632 36            mov bh, al
0085+  0633 F6            lodsb
0086+  0634 2F            mov bl, al
0087+  0635 07 01 06      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0638 F7            stosb          ; store AL to [DI]
0089+  0639 0A 2C 06      jmp _hex_to_int_L1
0090+  063C             _hex_to_int_ret:
0091+  063C 09            ret    
0092+  063D             
0093+  063D             
0094+  063D             
0095+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  063D             ; GETCHAR
0097+  063D             ; char in ah
0098+  063D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  063D             getch:
0100+  063D DB            push al
0101+  063E             getch_retry:
0102+  063E 19 01         mov al, 1
0103+  0640 05 03         syscall sys_io      ; receive in AH
0104+  0642 E8            pop al
0105+  0643 09            ret
0106+  0644             
0107+  0644             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0644             ; PUTCHAR
0109+  0644             ; char in ah
0110+  0644             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0644             _putchar:
0112+  0644 DB            push al
0113+  0645 19 00         mov al, 0
0114+  0647 05 03         syscall sys_io      ; char in AH
0115+  0649 E8            pop al
0116+  064A 09            ret
0117+  064B             
0118+  064B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  064B             ;; INPUT A STRING
0120+  064B             ;; terminates with null
0121+  064B             ;; pointer in D
0122+  064B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  064B             _gets:
0124+  064B D7            push a
0125+  064C DA            push d
0126+  064D             _gets_loop:
0127+  064D 19 01         mov al, 1
0128+  064F 05 03         syscall sys_io      ; receive in AH
0129+  0651 76 1B         cmp ah, 27
0130+  0653 C6 74 06      je _gets_ansi_esc
0131+  0656 76 0A         cmp ah, $0A        ; LF
0132+  0658 C6 D0 06      je _gets_end
0133+  065B 76 0D         cmp ah, $0D        ; CR
0134+  065D C6 D0 06      je _gets_end
0135+  0660 76 5C         cmp ah, $5C        ; '\\'
0136+  0662 C6 96 06      je _gets_escape
0137+  0665 76 08         cmp ah, $08      ; check for backspace
0138+  0667 C6 70 06      je _gets_backspace
0139+  066A 1A            mov al, ah
0140+  066B 3E            mov [d], al
0141+  066C 79            inc d
0142+  066D 0A 4D 06      jmp _gets_loop
0143+  0670             _gets_backspace:
0144+  0670 7F            dec d
0145+  0671 0A 4D 06      jmp _gets_loop
0146+  0674             _gets_ansi_esc:
0147+  0674 19 01         mov al, 1
0148+  0676 05 03         syscall sys_io        ; receive in AH without echo
0149+  0678 76 5B         cmp ah, '['
0150+  067A C7 4D 06      jne _gets_loop
0151+  067D 19 01         mov al, 1
0152+  067F 05 03         syscall sys_io          ; receive in AH without echo
0153+  0681 76 44         cmp ah, 'D'
0154+  0683 C6 8E 06      je _gets_left_arrow
0155+  0686 76 43         cmp ah, 'C'
0156+  0688 C6 92 06      je _gets_right_arrow
0157+  068B 0A 4D 06      jmp _gets_loop
0158+  068E             _gets_left_arrow:
0159+  068E 7F            dec d
0160+  068F 0A 4D 06      jmp _gets_loop
0161+  0692             _gets_right_arrow:
0162+  0692 79            inc d
0163+  0693 0A 4D 06      jmp _gets_loop
0164+  0696             _gets_escape:
0165+  0696 19 01         mov al, 1
0166+  0698 05 03         syscall sys_io      ; receive in AH
0167+  069A 76 6E         cmp ah, 'n'
0168+  069C C6 BB 06      je _gets_LF
0169+  069F 76 72         cmp ah, 'r'
0170+  06A1 C6 C2 06      je _gets_CR
0171+  06A4 76 30         cmp ah, '0'
0172+  06A6 C6 C9 06      je _gets_NULL
0173+  06A9 76 5C         cmp ah, $5C  ; '\'
0174+  06AB C6 B4 06      je _gets_slash
0175+  06AE 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  06AF 3E            mov [d], al
0177+  06B0 79            inc d
0178+  06B1 0A 4D 06      jmp _gets_loop
0179+  06B4             _gets_slash:
0180+  06B4 19 5C         mov al, $5C
0181+  06B6 3E            mov [d], al
0182+  06B7 79            inc d
0183+  06B8 0A 4D 06      jmp _gets_loop
0184+  06BB             _gets_LF:
0185+  06BB 19 0A         mov al, $0A
0186+  06BD 3E            mov [d], al
0187+  06BE 79            inc d
0188+  06BF 0A 4D 06      jmp _gets_loop
0189+  06C2             _gets_CR:
0190+  06C2 19 0D         mov al, $0D
0191+  06C4 3E            mov [d], al
0192+  06C5 79            inc d
0193+  06C6 0A 4D 06      jmp _gets_loop
0194+  06C9             _gets_NULL:
0195+  06C9 19 00         mov al, $00
0196+  06CB 3E            mov [d], al
0197+  06CC 79            inc d
0198+  06CD 0A 4D 06      jmp _gets_loop
0199+  06D0             _gets_end:
0200+  06D0 19 00         mov al, 0
0201+  06D2 3E            mov [d], al        ; terminate string
0202+  06D3 E7            pop d
0203+  06D4 E4            pop a
0204+  06D5 09            ret
0205+  06D6             
0206+  06D6             
0207+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  06D6             ;; INPUT TEXT
0209+  06D6             ;; terminated with CTRL+D
0210+  06D6             ;; pointer in D
0211+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  06D6             _gettxt:
0213+  06D6 D7            push a
0214+  06D7 DA            push d
0215+  06D8             _gettxt_loop:
0216+  06D8 19 01         mov al, 1
0217+  06DA 05 03         syscall sys_io      ; receive in AH
0218+  06DC 76 04         cmp ah, 4      ; EOT
0219+  06DE C6 17 07      je _gettxt_end
0220+  06E1 76 08         cmp ah, $08      ; check for backspace
0221+  06E3 C6 13 07      je _gettxt_backspace
0222+  06E6 76 5C         cmp ah, $5C        ; '\'
0223+  06E8 C6 F1 06      je _gettxt_escape
0224+  06EB 1A            mov al, ah
0225+  06EC 3E            mov [d], al
0226+  06ED 79            inc d
0227+  06EE 0A D8 06      jmp _gettxt_loop
0228+  06F1             _gettxt_escape:
0229+  06F1 19 01         mov al, 1
0230+  06F3 05 03         syscall sys_io      ; receive in AH
0231+  06F5 76 6E         cmp ah, 'n'
0232+  06F7 C6 05 07      je _gettxt_LF
0233+  06FA 76 72         cmp ah, 'r'
0234+  06FC C6 0C 07      je _gettxt_CR
0235+  06FF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0700 3E            mov [d], al
0237+  0701 79            inc d
0238+  0702 0A D8 06      jmp _gettxt_loop
0239+  0705             _gettxt_LF:
0240+  0705 19 0A         mov al, $0A
0241+  0707 3E            mov [d], al
0242+  0708 79            inc d
0243+  0709 0A D8 06      jmp _gettxt_loop
0244+  070C             _gettxt_CR:
0245+  070C 19 0D         mov al, $0D
0246+  070E 3E            mov [d], al
0247+  070F 79            inc d
0248+  0710 0A D8 06      jmp _gettxt_loop
0249+  0713             _gettxt_backspace:
0250+  0713 7F            dec d
0251+  0714 0A D8 06      jmp _gettxt_loop
0252+  0717             _gettxt_end:
0253+  0717 19 00         mov al, 0
0254+  0719 3E            mov [d], al        ; terminate string
0255+  071A E7            pop d
0256+  071B E4            pop a
0257+  071C 09            ret
0258+  071D             
0259+  071D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  071D             ; PRINT NEW LINE
0261+  071D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  071D             printnl:
0263+  071D D7            push a
0264+  071E 10 00 0A      mov a, $0A00
0265+  0721 05 03         syscall sys_io
0266+  0723 10 00 0D      mov a, $0D00
0267+  0726 05 03         syscall sys_io
0268+  0728 E4            pop a
0269+  0729 09            ret
0270+  072A             
0271+  072A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  072A             ; _strtoint
0273+  072A             ; 4 digit hex string number in d
0274+  072A             ; integer returned in A
0275+  072A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  072A             _strtointx:
0277+  072A D8            push b
0278+  072B 32            mov bl, [d]
0279+  072C 37            mov bh, bl
0280+  072D 33 01 00      mov bl, [d + 1]
0281+  0730 07 01 06      call _atoi        ; convert to int in AL
0282+  0733 23            mov ah, al        ; move to AH
0283+  0734 33 02 00      mov bl, [d + 2]
0284+  0737 37            mov bh, bl
0285+  0738 33 03 00      mov bl, [d + 3]
0286+  073B 07 01 06      call _atoi        ; convert to int in AL
0287+  073E E5            pop b
0288+  073F 09            ret
0289+  0740             
0290+  0740             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0740             ; _strtoint
0292+  0740             ; 5 digit base10 string number in d
0293+  0740             ; integer returned in A
0294+  0740             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0740             _strtoint:
0296+  0740 E2            push si
0297+  0741 D8            push b
0298+  0742 D9            push c
0299+  0743 DA            push d
0300+  0744 07 A3 05      call _strlen      ; get string length in C
0301+  0747 7E            dec c
0302+  0748 FD 4E         mov si, d
0303+  074A 12            mov a, c
0304+  074B FD 99         shl a
0305+  074D 3B C4 08      mov d, table_power
0306+  0750 59            add d, a
0307+  0751 38 00 00      mov c, 0
0308+  0754             _strtoint_L0:
0309+  0754 F6            lodsb      ; load ASCII to al
0310+  0755 B9 00         cmp al, 0
0311+  0757 C6 6A 07      je _strtoint_end
0312+  075A 6F 30         sub al, $30    ; make into integer
0313+  075C 22 00         mov ah, 0
0314+  075E 2A            mov b, [d]
0315+  075F AC            mul a, b      ; result in B since it fits in 16bits
0316+  0760 11            mov a, b
0317+  0761 28            mov b, c
0318+  0762 54            add a, b
0319+  0763 39            mov c, a
0320+  0764 63 02 00      sub d, 2
0321+  0767 0A 54 07      jmp _strtoint_L0
0322+  076A             _strtoint_end:
0323+  076A 12            mov a, c
0324+  076B E7            pop d
0325+  076C E6            pop c
0326+  076D E5            pop b
0327+  076E EF            pop si
0328+  076F 09            ret
0329+  0770             
0330+  0770             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0770             ; PRINT NULL TERMINATED STRING
0332+  0770             ; pointer in D
0333+  0770             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0770             _puts:
0335+  0770 D7            push a
0336+  0771 DA            push d
0337+  0772             _puts_L1:
0338+  0772 1E            mov al, [d]
0339+  0773 B9 00         cmp al, 0
0340+  0775 C6 81 07      jz _puts_END
0341+  0778 23            mov ah, al
0342+  0779 19 00         mov al, 0
0343+  077B 05 03         syscall sys_io
0344+  077D 79            inc d
0345+  077E 0A 72 07      jmp _puts_L1
0346+  0781             _puts_END:
0347+  0781 E7            pop d
0348+  0782 E4            pop a
0349+  0783 09            ret
0350+  0784             
0351+  0784             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0784             ; PRINT N SIZE STRING
0353+  0784             ; pointer in D
0354+  0784             ; size in C
0355+  0784             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0784             _putsn:
0357+  0784 DB            push al
0358+  0785 DA            push d
0359+  0786 D9            push c
0360+  0787             _putsn_L0:
0361+  0787 1E            mov al, [d]
0362+  0788 23            mov ah, al
0363+  0789 19 00         mov al, 0
0364+  078B 05 03         syscall sys_io
0365+  078D 79            inc d
0366+  078E 7E            dec c  
0367+  078F C2 00 00      cmp c, 0
0368+  0792 C7 87 07      jne _putsn_L0
0369+  0795             _putsn_end:
0370+  0795 E6            pop c
0371+  0796 E7            pop d
0372+  0797 E8            pop al
0373+  0798 09            ret
0374+  0799             
0375+  0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0799             ; print 16bit decimal number
0377+  0799             ; input number in A
0378+  0799             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0799             print_u16d:
0380+  0799 D7            push a
0381+  079A D8            push b
0382+  079B FD D8         push g
0383+  079D 26 10 27      mov b, 10000
0384+  07A0 AE            div a, b      ; get 10000's coeff.
0385+  07A1 07 C5 07      call print_number
0386+  07A4 11            mov a, b
0387+  07A5 26 E8 03      mov b, 1000
0388+  07A8 AE            div a, b      ; get 1000's coeff.
0389+  07A9 07 C5 07      call print_number
0390+  07AC 11            mov a, b
0391+  07AD 26 64 00      mov b, 100
0392+  07B0 AE            div a, b
0393+  07B1 07 C5 07      call print_number
0394+  07B4 11            mov a, b
0395+  07B5 26 0A 00      mov b, 10
0396+  07B8 AE            div a, b
0397+  07B9 07 C5 07      call print_number
0398+  07BC 1B            mov al, bl      ; 1's coeff in bl
0399+  07BD 07 C5 07      call print_number
0400+  07C0 FD F1         pop g
0401+  07C2 E5            pop b
0402+  07C3 E4            pop a
0403+  07C4 09            ret
0404+  07C5             
0405+  07C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07C5             ; print AL
0407+  07C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  07C5             print_number:
0409+  07C5 6A 30         add al, $30
0410+  07C7 23            mov ah, al
0411+  07C8 07 44 06      call _putchar
0412+  07CB 09            ret
0413+  07CC             
0414+  07CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  07CC             ; PRINT 16BIT HEX INTEGER
0416+  07CC             ; integer value in reg B
0417+  07CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  07CC             print_u16x:
0419+  07CC D7            push a
0420+  07CD D8            push b
0421+  07CE DD            push bl
0422+  07CF 30            mov bl, bh
0423+  07D0 07 12 06      call _itoa        ; convert bh to char in A
0424+  07D3 2F            mov bl, al        ; save al
0425+  07D4 19 00         mov al, 0
0426+  07D6 05 03         syscall sys_io        ; display AH
0427+  07D8 24            mov ah, bl        ; retrieve al
0428+  07D9 19 00         mov al, 0
0429+  07DB 05 03         syscall sys_io        ; display AL
0430+  07DD             
0431+  07DD EA            pop bl
0432+  07DE 07 12 06      call _itoa        ; convert bh to char in A
0433+  07E1 2F            mov bl, al        ; save al
0434+  07E2 19 00         mov al, 0
0435+  07E4 05 03         syscall sys_io        ; display AH
0436+  07E6 24            mov ah, bl        ; retrieve al
0437+  07E7 19 00         mov al, 0
0438+  07E9 05 03         syscall sys_io        ; display AL
0439+  07EB             
0440+  07EB E5            pop b
0441+  07EC E4            pop a
0442+  07ED 09            ret
0443+  07EE             
0444+  07EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  07EE             ; INPUT 16BIT HEX INTEGER
0446+  07EE             ; read 16bit integer into A
0447+  07EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  07EE             scan_u16x:
0449+  07EE F8 10 00      enter 16
0450+  07F1 D8            push b
0451+  07F2 DA            push d
0452+  07F3             
0453+  07F3 FA F1 FF      lea d, [bp + -15]
0454+  07F6 07 4B 06      call _gets        ; get number
0455+  07F9             
0456+  07F9 32            mov bl, [d]
0457+  07FA 37            mov bh, bl
0458+  07FB 33 01 00      mov bl, [d + 1]
0459+  07FE 07 01 06      call _atoi        ; convert to int in AL
0460+  0801 23            mov ah, al        ; move to AH
0461+  0802             
0462+  0802 33 02 00      mov bl, [d + 2]
0463+  0805 37            mov bh, bl
0464+  0806 33 03 00      mov bl, [d + 3]
0465+  0809 07 01 06      call _atoi        ; convert to int in AL
0466+  080C             
0467+  080C E7            pop d
0468+  080D E5            pop b
0469+  080E F9            leave
0470+  080F 09            ret
0471+  0810             
0472+  0810             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0810             ; PRINT 8bit HEX INTEGER
0474+  0810             ; integer value in reg bl
0475+  0810             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0810             print_u8x:
0477+  0810 D7            push a
0478+  0811 DD            push bl
0479+  0812             
0480+  0812 07 12 06      call _itoa        ; convert bl to char in A
0481+  0815 2F            mov bl, al        ; save al
0482+  0816 19 00         mov al, 0
0483+  0818 05 03         syscall sys_io        ; display AH
0484+  081A 24            mov ah, bl        ; retrieve al
0485+  081B 19 00         mov al, 0
0486+  081D 05 03         syscall sys_io        ; display AL
0487+  081F             
0488+  081F EA            pop bl
0489+  0820 E4            pop a
0490+  0821 09            ret
0491+  0822             
0492+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0822             ; print 8bit decimal unsigned number
0494+  0822             ; input number in AL
0495+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0822             print_u8d:
0497+  0822 D7            push a
0498+  0823 D8            push b
0499+  0824 FD D8         push g
0500+  0826 22 00         mov ah, 0
0501+  0828 26 64 00      mov b, 100
0502+  082B AE            div a, b
0503+  082C D8            push b      ; save remainder
0504+  082D B9 00         cmp al, 0
0505+  082F C6 39 08      je skip100
0506+  0832 6A 30         add al, $30
0507+  0834 23            mov ah, al
0508+  0835 19 00         mov al, 0
0509+  0837 05 03         syscall sys_io  ; print coeff
0510+  0839             skip100:
0511+  0839 E4            pop a
0512+  083A 22 00         mov ah, 0
0513+  083C 26 0A 00      mov b, 10
0514+  083F AE            div a, b
0515+  0840 D8            push b      ; save remainder
0516+  0841 B9 00         cmp al, 0
0517+  0843 C6 4D 08      je skip10
0518+  0846 6A 30         add al, $30
0519+  0848 23            mov ah, al
0520+  0849 19 00         mov al, 0
0521+  084B 05 03         syscall sys_io  ; print coeff
0522+  084D             skip10:
0523+  084D E4            pop a
0524+  084E 1B            mov al, bl
0525+  084F 6A 30         add al, $30
0526+  0851 23            mov ah, al
0527+  0852 19 00         mov al, 0
0528+  0854 05 03         syscall sys_io  ; print coeff
0529+  0856 FD F1         pop g
0530+  0858 E5            pop b
0531+  0859 E4            pop a
0532+  085A 09            ret
0533+  085B             
0534+  085B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  085B             ; INPUT 8BIT HEX INTEGER
0536+  085B             ; read 8bit integer into AL
0537+  085B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  085B             scan_u8x:
0539+  085B F8 04 00      enter 4
0540+  085E D8            push b
0541+  085F DA            push d
0542+  0860             
0543+  0860 FA FD FF      lea d, [bp + -3]
0544+  0863 07 4B 06      call _gets        ; get number
0545+  0866             
0546+  0866 32            mov bl, [d]
0547+  0867 37            mov bh, bl
0548+  0868 33 01 00      mov bl, [d + 1]
0549+  086B 07 01 06      call _atoi        ; convert to int in AL
0550+  086E             
0551+  086E E7            pop d
0552+  086F E5            pop b
0553+  0870 F9            leave
0554+  0871 09            ret
0555+  0872             
0556+  0872             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0872             ; input decimal number
0558+  0872             ; result in A
0559+  0872             ; 655'\0'
0560+  0872             ; low--------high
0561+  0872             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0872             scan_u16d:
0563+  0872 F8 08 00      enter 8
0564+  0875 E2            push si
0565+  0876 D8            push b
0566+  0877 D9            push c
0567+  0878 DA            push d
0568+  0879 FA F9 FF      lea d, [bp +- 7]
0569+  087C 07 4B 06      call _gets
0570+  087F 07 A3 05      call _strlen      ; get string length in C
0571+  0882 7E            dec c
0572+  0883 FD 4E         mov si, d
0573+  0885 12            mov a, c
0574+  0886 FD 99         shl a
0575+  0888 3B C4 08      mov d, table_power
0576+  088B 59            add d, a
0577+  088C 38 00 00      mov c, 0
0578+  088F             mul_loop:
0579+  088F F6            lodsb      ; load ASCII to al
0580+  0890 B9 00         cmp al, 0
0581+  0892 C6 A5 08      je mul_exit
0582+  0895 6F 30         sub al, $30    ; make into integer
0583+  0897 22 00         mov ah, 0
0584+  0899 2A            mov b, [d]
0585+  089A AC            mul a, b      ; result in B since it fits in 16bits
0586+  089B 11            mov a, b
0587+  089C 28            mov b, c
0588+  089D 54            add a, b
0589+  089E 39            mov c, a
0590+  089F 63 02 00      sub d, 2
0591+  08A2 0A 8F 08      jmp mul_loop
0592+  08A5             mul_exit:
0593+  08A5 12            mov a, c
0594+  08A6 E7            pop d
0595+  08A7 E6            pop c
0596+  08A8 E5            pop b
0597+  08A9 EF            pop si
0598+  08AA F9            leave
0599+  08AB 09            ret
0600+  08AC             
0601+  08AC             
0602+  08AC 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  08B0 34 35 36 37 
0602+  08B4 38 39 41 42 
0602+  08B8 43 44 45 46 
0603+  08BC 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  08C0 1B 5B 48 00 
0604+  08C4             
0605+  08C4             table_power:
0606+  08C4 01 00         .dw 1
0607+  08C6 0A 00         .dw 10
0608+  08C8 64 00         .dw 100
0609+  08CA E8 03         .dw 1000
0610+  08CC 10 27         .dw 100000112   08CE             .end
tasm: Number of errors = 0
