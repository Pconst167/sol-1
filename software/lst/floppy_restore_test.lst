0001   0000             .include "lib/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             sys_fdc_restore  .EQU  $0000
0016+  0000             sys_fdc_step     .EQU  $0001
0017+  0000             sys_fdc_step_in  .EQU  $0002
0018+  0000             sys_fdc_step_out .EQU  $0003
0019+  0000             sys_fdc_seek     .EQU  $0004
0020+  0000             sys_fdc_format   .EQU  $0005
0021+  0000             sys_fdc_read_addr .EQU  $0006
0022+  0000             sys_fdc_read_track .EQU  $0007
0023+  0000             sys_fdc_read_sect .EQU  $0008
0024+  0000             sys_fdc_write_sect .EQU  $0009
0025+  0000             sys_fdc_force_int .EQU  $000a
0026+  0000             sys_fdc_status0  .EQU  $000b
0027+  0000             sys_fdc_status1  .EQU  $000c
0028+  0000             text_org         .EQU  $0400
0002   0400             .org text_org
0003   0400             
0004   0400             ; sys_fdc_restore
0005   0400             ; sys_fdc_step
0006   0400             ; sys_fdc_step_in
0007   0400             ; sys_fdc_step_out
0008   0400             ; sys_fdc_seek
0009   0400             ; sys_fdc_format
0010   0400             ; sys_fdc_read_addr
0011   0400             ; sys_fdc_read_track
0012   0400             ; sys_fdc_read_sect
0013   0400             ; sys_fdc_write_sect
0014   0400             ; sys_fdc_force_int
0015   0400             
0016   0400             main:
0017   0400 FD 49 FF FF   mov bp, $ffff
0018   0404 FD 47 FF FF   mov sp, $ffff
0019   0408             
0020   0408 3B 4B 06      mov d, str0
0021   040B 07 20 09      call _puts
0022   040E               ; First, select drive 1 and de-select drive 0
0023   040E 3B C0 FF      mov d, $FFC0
0024   0411 19 02         mov al, 2       ; setparam call
0025   0413 2E 0A         mov bl, %00001010     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0026   0415 05 0C         syscall sys_system
0027   0417             
0028   0417             menu:
0029   0417 3B 9F 05      mov d, s_menu
0030   041A 07 20 09      call _puts
0031   041D 07 ED 07      call getch
0032   0420 76 30         cmp ah, '0'
0033   0422 C6 63 04      je step_in
0034   0425 76 31         cmp ah, '1'
0035   0427 C6 6A 04      je step_out
0036   042A 76 32         cmp ah, '2'
0037   042C C6 55 04      je restore
0038   042F 76 33         cmp ah, '3'
0039   0431 C6 F2 04      je status1
0040   0434 76 34         cmp ah, '4'
0041   0436 C6 03 05      je status2
0042   0439 76 35         cmp ah, '5'
0043   043B C6 78 04      je format
0044   043E 76 36         cmp ah, '6'
0045   0440 C6 8F 04      je read_track
0046   0443 76 37         cmp ah, '7'
0047   0445 C6 9A 04      je read_sect
0048   0448 76 38         cmp ah, '8'
0049   044A C6 E1 04      je fdc_options
0050   044D 76 39         cmp ah, '9'
0051   044F C6 C2 04      je fdc_write_sec
0052   0452 0A 17 04      jmp menu
0053   0455             restore:
0054   0455 19 00         mov al, 0
0055   0457 05 0D         syscall sys_fdc
0056   0459 0A 17 04      jmp menu
0057   045C             step:
0058   045C 19 01         mov al, 1
0059   045E 05 0D         syscall sys_fdc
0060   0460 0A 17 04      jmp menu
0061   0463             step_in:
0062   0463 19 02         mov al, 2
0063   0465 05 0D         syscall sys_fdc
0064   0467 0A 17 04      jmp menu
0065   046A             step_out:
0066   046A 19 03         mov al, 3
0067   046C 05 0D         syscall sys_fdc
0068   046E 0A 17 04      jmp menu
0069   0471             seek:
0070   0471 19 04         mov al, 4
0071   0473 05 0D         syscall sys_fdc
0072   0475 0A 17 04      jmp menu
0073   0478             format:
0074   0478 3B 96 05      mov d, s_track
0075   047B 07 20 09      call _puts
0076   047E 07 0B 0A      call scan_u8x   ; in al
0077   0481 2F            mov bl, al      ; track needs to be in bl
0078   0482 19 05         mov al, 5
0079   0484 05 0D         syscall sys_fdc
0080   0486 3B 3C 06      mov d, s_format_done
0081   0489 07 20 09      call _puts
0082   048C 0A 17 04      jmp menu
0083   048F             read_track:
0084   048F 19 06         mov al, 6
0085   0491 FD 4F 0B 07   mov di, transient_data
0086   0495 05 0D         syscall sys_fdc
0087   0497 0A 17 04      jmp menu
0088   049A             read_sect:
0089   049A 3B 6F 06      mov d, s1
0090   049D 07 20 09      call _puts
0091   04A0 07 0B 0A      call scan_u8x
0092   04A3 36            mov bh, al
0093   04A4 3B 78 06      mov d, s2
0094   04A7 07 20 09      call _puts
0095   04AA 07 0B 0A      call scan_u8x ; in al 
0096   04AD 2F            mov bl, al
0097   04AE 19 07         mov al, 7
floppy_restore_test.asm line 0098: Label not found: (transient_area)
floppy_restore_test.asm line 0098: Unused data in MS byte of argument. (2)
0098   04B0 FD 4F 00 00   mov di, transient_area
floppy_restore_test.asm line 0099: Label not found: (transient_area)
floppy_restore_test.asm line 0099: Unused data in MS byte of argument. (2)
0099   04B4 3B 00 00      mov d, transient_area
0100   04B7 26 80 00      mov b, 128
0101   04BA 07 14 05      call cmd_hexd
0102   04BD 05 0D         syscall sys_fdc
0103   04BF 0A 17 04      jmp menu
0104   04C2             fdc_write_sec:
0105   04C2 3B 6F 06      mov d, s1
0106   04C5 07 20 09      call _puts
0107   04C8 07 0B 0A      call scan_u8x
0108   04CB 36            mov bh, al
0109   04CC 3B 78 06      mov d, s2
0110   04CF 07 20 09      call _puts
0111   04D2 07 0B 0A      call scan_u8x ; in al
0112   04D5 2F            mov bl, al
0113   04D6 19 08         mov al, 8
0114   04D8 FD 4D 8B 06   mov si, fdc_sec_data
0115   04DC 05 0D         syscall sys_fdc
0116   04DE 0A 17 04      jmp menu
0117   04E1             fdc_options:
0118   04E1 3B 82 06      mov d, ss3
0119   04E4 07 20 09      call _puts
0120   04E7 07 0B 0A      call scan_u8x
0121   04EA 2F            mov bl, al
0122   04EB 19 02         mov al, 2
0123   04ED 05 0C         syscall sys_system
0124   04EF 0A 17 04      jmp menu
0125   04F2             status1:
0126   04F2 07 CD 08      call printnl
0127   04F5 19 0B         mov al, 11       ; getparam call
0128   04F7 05 0D         syscall sys_fdc
0129   04F9 2F            mov bl, al
0130   04FA 07 C0 09      call print_u8x   ; print bl
0131   04FD 07 CD 08      call printnl
0132   0500 0A 17 04      jmp menu
0133   0503             status2:
0134   0503 07 CD 08      call printnl
0135   0506 19 0C         mov al, 12      ; getparam call
0136   0508 05 0D         syscall sys_fdc
0137   050A 2F            mov bl, al
0138   050B 07 C0 09      call print_u8x   ; print bl
0139   050E 07 CD 08      call printnl
0140   0511 0A 17 04      jmp menu
0141   0514             
0142   0514             ; b : len
0143   0514             ; d: data address
0144   0514             cmd_hexd:
0145   0514 13            mov a, d
0146   0515 42 92 05      mov [start], a
0147   0518 11            mov a, b
0148   0519 42 94 05      mov [length], a
0149   051C             
0150   051C 14 92 05    	mov a, [start]
0151   051F 3C            mov d, a        ; dump pointer in d
0152   0520 38 00 00      mov c, 0
0153   0523             dump_loop:
0154   0523 84            mov al, cl
0155   0524 87 0F         and al, $0f
0156   0526 C6 75 05      jz print_base
0157   0529             back:
0158   0529 1E            mov al, [d]        ; read byte
0159   052A 2F            mov bl, al
0160   052B 07 C0 09      call print_u8x
0161   052E 10 00 20      mov a, $2000
0162   0531 05 03         syscall sys_io      ; space
0163   0533 84            mov al, cl
0164   0534 87 0F         and al, $0f
0165   0536 B9 0F         cmp al, $0f
0166   0538 C6 4F 05      je print_ascii
0167   053B             back1:
0168   053B 79            inc d
0169   053C 78            inc c
0170   053D 14 94 05      mov a, [length]
0171   0540 B1            cmp a, c
0172   0541 C7 23 05      jne dump_loop
0173   0544               
0174   0544 10 00 0A      mov a, $0a00
0175   0547 05 03         syscall sys_io
0176   0549 10 00 0D      mov a, $0d00
0177   054C 05 03         syscall sys_io
0178   054E               ;call printnl
0179   054E             
0180   054E 09            ret
0181   054F             
0182   054F             print_ascii:
0183   054F 63 10 00      sub d, 16
0184   0552 26 10 00      mov b, 16
0185   0555             print_ascii_l:
0186   0555 79            inc d
0187   0556 1E            mov al, [d]        ; read byte
0188   0557 B9 20         cmp al, $20
0189   0559 C8 61 05      jlu dot
0190   055C B9 7E         cmp al, $7e
0191   055E D0 69 05      jleu ascii
0192   0561             dot:
0193   0561 10 00 2E      mov a, $2e00
0194   0564 05 03         syscall sys_io
0195   0566 0A 6E 05      jmp ascii_continue
0196   0569             ascii:
0197   0569 23            mov ah, al
0198   056A 19 00         mov al, 0
0199   056C 05 03         syscall sys_io
0200   056E             ascii_continue:
0201   056E FD A9 55 05   loopb print_ascii_l
0202   0572 0A 3B 05      jmp back1
0203   0575             print_base:
0204   0575 10 00 0A      mov a, $0a00
0205   0578 05 03         syscall sys_io
0206   057A 10 00 0D      mov a, $0d00
0207   057D 05 03         syscall sys_io
0208   057F 2D            mov b, d
floppy_restore_test.asm line 0209: Label not found: (transient_area)
floppy_restore_test.asm line 0209: Unused data in MS byte of argument. (2)
0209   0580 61 00 00      sub b, transient_area
0210   0583 07 7C 09      call print_u16x        ; display row
floppy_restore_test.asm line 0211: Label not found: (transient_area)
floppy_restore_test.asm line 0211: Unused data in MS byte of argument. (2)
0211   0586 55 00 00      add b, transient_area
0212   0589 10 00 20      mov a, $2000
0213   058C 05 03         syscall sys_io
0214   058E 0A 29 05      jmp back
0215   0591             
0216   0591 09            ret
0217   0592             
0218   0592 00 00       start:   .dw 0
0219   0594 00 04       length:  .dw 1024
0220   0596             
0221   0596             
0222   0596 0A 74 72 61 s_track: .db "\ntrack: ", 0
0222   059A 63 6B 3A 20 
0222   059E 00 
0223   059F             
0224   059F 0A 30 2E 20 s_menu:  .db "\n0. step in\n"
0224   05A3 73 74 65 70 
0224   05A7 20 69 6E 0A 
0225   05AB 31 2E 20 73          .db "1. step out\n", 
0225   05AF 74 65 70 20 
0225   05B3 6F 75 74 0A 
0226   05B7 32 2E 20 72          .db "2. restore\n", 
0226   05BB 65 73 74 6F 
0226   05BF 72 65 0A 
0227   05C2 33 2E 20 72          .db "3. read status 1\n", 
0227   05C6 65 61 64 20 
0227   05CA 73 74 61 74 
0227   05CE 75 73 20 31 
0227   05D2 0A 
0228   05D3 34 2E 20 72          .db "4. read status 2\n", 
0228   05D7 65 61 64 20 
0228   05DB 73 74 61 74 
0228   05DF 75 73 20 32 
0228   05E3 0A 
0229   05E4 35 2E 20 66          .db "5. format track\n", 
0229   05E8 6F 72 6D 61 
0229   05EC 74 20 74 72 
0229   05F0 61 63 6B 0A 
0230   05F4 36 2E 20 72          .db "6. read track\n", 
0230   05F8 65 61 64 20 
0230   05FC 74 72 61 63 
0230   0600 6B 0A 
0231   0602 37 2E 20 72          .db "7. read sector\n", 
0231   0606 65 61 64 20 
0231   060A 73 65 63 74 
0231   060E 6F 72 0A 
0232   0611 38 2E 20 63          .db "8. config\n", 
0232   0615 6F 6E 66 69 
0232   0619 67 0A 
0233   061B 39 2E 20 77          .db "9. write sector\n", 
0233   061F 72 69 74 65 
0233   0623 20 73 65 63 
0233   0627 74 6F 72 0A 
0234   062B 0A 73 65 6C          .db "\nselect option: ", 0
0234   062F 65 63 74 20 
0234   0633 6F 70 74 69 
0234   0637 6F 6E 3A 20 
0234   063B 00 
0235   063C             
0236   063C 0A 66 6F 72 s_format_done: .db "\nformat done.\n", 0
0236   0640 6D 61 74 20 
0236   0644 64 6F 6E 65 
0236   0648 2E 0A 00 
0237   064B 0A 73 65 6C str0:    .db "\nselecting drive 0...\n", 0
0237   064F 65 63 74 69 
0237   0653 6E 67 20 64 
0237   0657 72 69 76 65 
0237   065B 20 30 2E 2E 
0237   065F 2E 0A 00 
0238   0662 0A 77 61 69 str1:    .db "\nwaiting...\n", 0
0238   0666 74 69 6E 67 
0238   066A 2E 2E 2E 0A 
0238   066E 00 
0239   066F 0A 74 72 61 s1:      .db "\ntrack: ", 0
0239   0673 63 6B 3A 20 
0239   0677 00 
0240   0678 0A 73 65 63 s2:      .db "\nsector: ", 0
0240   067C 74 6F 72 3A 
0240   0680 20 00 
0241   0682 0A 76 61 6C ss3:     .db "\nvalue: ", 0
0241   0686 75 65 3A 20 
0241   068A 00 
0242   068B             
0243   068B             fdc_sec_data:
0244   068B FF EE E0 55   .db $ff, $ee, $e0, $55, $66, $33, $42, $aa, $ae, $67, $23, $11, $23, $56, $88, $99,
0244   068F 66 33 42 AA 
0244   0693 AE 67 23 11 
0244   0697 23 56 88 99 
0245   069B 1F 2E 40 53   .db $1f, $2e, $40, $53, $63, $43, $52, $1a, $a4, $67, $03, $31, $43, $56, $48, $f9,
0245   069F 63 43 52 1A 
0245   06A3 A4 67 03 31 
0245   06A7 43 56 48 F9 
0246   06AB 2F 3E 50 57   .db $2f, $3e, $50, $57, $62, $53, $21, $2a, $a3, $17, $73, $41, $53, $46, $38, $b9,
0246   06AF 62 53 21 2A 
0246   06B3 A3 17 73 41 
0246   06B7 53 46 38 B9 
0247   06BB 6F 4E 20 56   .db $6f, $4e, $20, $56, $67, $63, $20, $6a, $a2, $27, $53, $61, $23, $16, $28, $e9,
0247   06BF 67 63 20 6A 
0247   06C3 A2 27 53 61 
0247   06C7 23 16 28 E9 
0248   06CB AF 7E 10 52   .db $af, $7e, $10, $52, $62, $73, $18, $5a, $a1, $37, $43, $51, $13, $26, $18, $a9,
0248   06CF 62 73 18 5A 
0248   06D3 A1 37 43 51 
0248   06D7 13 26 18 A9 
0249   06DB 6F 3E 90 51   .db $6f, $3e, $90, $51, $63, $03, $18, $4a, $a5, $67, $33, $41, $43, $36, $68, $c9,
0249   06DF 63 03 18 4A 
0249   06E3 A5 67 33 41 
0249   06E7 43 36 68 C9 
0250   06EB 8F 5E 60 55   .db $8f, $5e, $60, $55, $68, $23, $18, $3a, $a3, $57, $23, $31, $73, $36, $48, $b9,
0250   06EF 68 23 18 3A 
0250   06F3 A3 57 23 31 
0250   06F7 73 36 48 B9 
0251   06FB 2F 1E 40 53   .db $2f, $1e, $40, $53, $69, $13, $19, $3a, $a1, $48, $23, $21, $53, $46, $38, $a9
0251   06FF 69 13 19 3A 
0251   0703 A1 48 23 21 
0251   0707 53 46 38 A9 
0252   070B             
0253   070B 00          transient_data: .db 0
0254   070C             
0255   070C             .include "lib/stdio.asm"
0001+  070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  070C             ; stdio.s
0003+  070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  070C             .include "lib/string.asm"
0001++ 070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 070C             ; string.s
0003++ 070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 070C             
0005++ 070C             
0006++ 070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 070C             ; _strrev
0008++ 070C             ; reverse a string
0009++ 070C             ; d = string address
0010++ 070C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 070C             ; 01234
0012++ 070C             _strrev:
0013++ 070C 4B          	pusha
0014++ 070D 07 53 07    	call _strlen	; length in c
0015++ 0710 12          	mov a, c
0016++ 0711 AF 01 00    	cmp a, 1
0017++ 0714 D0 2E 07    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0717 7D          	dec a
0019++ 0718 FD 4E       	mov si, d	; beginning of string
0020++ 071A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 071C 59          	add d, a	; end of string
0022++ 071D 12          	mov a, c
0023++ 071E FD 9B       	shr a		; divide by 2
0024++ 0720 39          	mov c, a	; c now counts the steps
0025++ 0721             _strrev_l0:
0026++ 0721 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0722 F6          	lodsb		; load left-side char into al; increase si
0028++ 0723 3E          	mov [d], al	; store left char into right side
0029++ 0724 1B          	mov al, bl
0030++ 0725 F7          	stosb		; store right-side char into left-side; increase di
0031++ 0726 7E          	dec c
0032++ 0727 7F          	dec d
0033++ 0728 C2 00 00    	cmp c, 0
0034++ 072B C7 21 07    	jne _strrev_l0
0035++ 072E             _strrev_end:
0036++ 072E 4C          	popa
0037++ 072F 09          	ret
0038++ 0730             	
0039++ 0730             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0730             ; _strchr
0041++ 0730             ; search string in d for char in al
0042++ 0730             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0730             _strchr:
0044++ 0730             _strchr_l0:
0045++ 0730 32          	mov bl, [d]
0046++ 0731 C1 00       	cmp bl, 0
0047++ 0733 C6 3E 07    	je _strchr_end
0048++ 0736 BA          	cmp al, bl
0049++ 0737 C6 3E 07    	je _strchr_end
0050++ 073A 79          	inc d
0051++ 073B 0A 30 07    	jmp _strchr_l0
0052++ 073E             _strchr_end:
0053++ 073E 1B          	mov al, bl
0054++ 073F 09          	ret
0055++ 0740             
0056++ 0740             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0740             ; _strstr
0058++ 0740             ; find sub-string
0059++ 0740             ; str1 in si
0060++ 0740             ; str2 in di
0061++ 0740             ; si points to end of source string
0062++ 0740             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0740             _strstr:
0064++ 0740 DB          	push al
0065++ 0741 DA          	push d
0066++ 0742 E3          	push di
0067++ 0743             _strstr_loop:
0068++ 0743 F3          	cmpsb					; compare a byte of the strings
0069++ 0744 C7 4F 07    	jne _strstr_ret
0070++ 0747 FC 00 00    	lea d, [di + 0]
0071++ 074A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 074C C7 43 07    	jne _strstr_loop				; equal chars but not at end
0073++ 074F             _strstr_ret:
0074++ 074F F0          	pop di
0075++ 0750 E7          	pop d
0076++ 0751 E8          	pop al
0077++ 0752 09          	ret
0078++ 0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0753             ; length of null terminated string
0080++ 0753             ; result in c
0081++ 0753             ; pointer in d
0082++ 0753             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0753             _strlen:
0084++ 0753 DA          	push d
0085++ 0754 38 00 00    	mov c, 0
0086++ 0757             _strlen_l1:
0087++ 0757 BD 00       	cmp byte [d], 0
0088++ 0759 C6 61 07    	je _strlen_ret
0089++ 075C 79          	inc d
0090++ 075D 78          	inc c
0091++ 075E 0A 57 07    	jmp _strlen_l1
0092++ 0761             _strlen_ret:
0093++ 0761 E7          	pop d
0094++ 0762 09          	ret
0095++ 0763             
0096++ 0763             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0763             ; strcmp
0098++ 0763             ; compare two strings
0099++ 0763             ; str1 in si
0100++ 0763             ; str2 in di
0101++ 0763             ; create a string compairon instrucion ?????
0102++ 0763             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0763             _strcmp:
0104++ 0763 DB          	push al
0105++ 0764 DA          	push d
0106++ 0765 E3          	push di
0107++ 0766 E2          	push si
0108++ 0767             _strcmp_loop:
0109++ 0767 F3          	cmpsb					; compare a byte of the strings
0110++ 0768 C7 73 07    	jne _strcmp_ret
0111++ 076B FB FF FF    	lea d, [si +- 1]
0112++ 076E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0770 C7 67 07    	jne _strcmp_loop				; equal chars but not at end
0114++ 0773             _strcmp_ret:
0115++ 0773 EF          	pop si
0116++ 0774 F0          	pop di
0117++ 0775 E7          	pop d
0118++ 0776 E8          	pop al
0119++ 0777 09          	ret
0120++ 0778             
0121++ 0778             
0122++ 0778             ; strcpy
0123++ 0778             ; copy null terminated string from si to di
0124++ 0778             ; source in si
0125++ 0778             ; destination in di
0126++ 0778             _strcpy:
0127++ 0778 E2          	push si
0128++ 0779 E3          	push di
0129++ 077A DB          	push al
0130++ 077B             _strcpy_l1:
0131++ 077B F6          	lodsb
0132++ 077C F7          	stosb
0133++ 077D B9 00       	cmp al, 0
0134++ 077F C7 7B 07    	jne _strcpy_l1
0135++ 0782             _strcpy_end:
0136++ 0782 E8          	pop al
0137++ 0783 F0          	pop di
0138++ 0784 EF          	pop si
0139++ 0785 09          	ret
0140++ 0786             
0141++ 0786             ; strcat
0142++ 0786             ; concatenate a null terminated string into string at di, from string at si
0143++ 0786             ; source in si
0144++ 0786             ; destination in di
0145++ 0786             _strcat:
0146++ 0786 E2          	push si
0147++ 0787 E3          	push di
0148++ 0788 D7          	push a
0149++ 0789 DA          	push d
0150++ 078A 50          	mov a, di
0151++ 078B 3C          	mov d, a
0152++ 078C             _strcat_goto_end_l1:
0153++ 078C BD 00       	cmp byte[d], 0
0154++ 078E C6 95 07    	je _strcat_start
0155++ 0791 79          	inc d
0156++ 0792 0A 8C 07    	jmp _strcat_goto_end_l1
0157++ 0795             _strcat_start:
0158++ 0795 FD 50       	mov di, d
0159++ 0797             _strcat_l1:
0160++ 0797 F6          	lodsb
0161++ 0798 F7          	stosb
0162++ 0799 B9 00       	cmp al, 0
0163++ 079B C7 97 07    	jne _strcat_l1
0164++ 079E             _strcat_end:
0165++ 079E E7          	pop d
0166++ 079F E4          	pop a
0167++ 07A0 F0          	pop di
0168++ 07A1 EF          	pop si
0169++ 07A2 09          	ret
0170++ 07A3             
0171++ 07A3             
0005+  07A3             
0006+  07A3             
0007+  07A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  07A3             ; convert ascii 'o'..'f' to integer 0..15
0009+  07A3             ; ascii in bl
0010+  07A3             ; result in al
0011+  07A3             ; ascii for f = 0100 0110
0012+  07A3             ; ascii for 9 = 0011 1001
0013+  07A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  07A3             hex_ascii_encode:
0015+  07A3 1B            mov al, bl
0016+  07A4 93 40         test al, $40        ; test if letter or number
0017+  07A6 C7 AC 07      jnz hex_letter
0018+  07A9 87 0F         and al, $0f        ; get number
0019+  07AB 09            ret
0020+  07AC             hex_letter:
0021+  07AC 87 0F         and al, $0f        ; get letter
0022+  07AE 6A 09         add al, 9
0023+  07B0 09            ret
0024+  07B1             
0025+  07B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  07B1             ; atoi
0027+  07B1             ; 2 letter hex string in b
0028+  07B1             ; 8bit integer returned in al
0029+  07B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  07B1             _atoi:
0031+  07B1 D8            push b
0032+  07B2 07 A3 07      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  07B5 30            mov bl, bh
0034+  07B6 DB            push al          ; save a
0035+  07B7 07 A3 07      call hex_ascii_encode
0036+  07BA EA            pop bl  
0037+  07BB FD 9E 04      shl al, 4
0038+  07BE 8C            or al, bl
0039+  07BF E5            pop b
0040+  07C0 09            ret  
0041+  07C1             
0042+  07C1             
0043+  07C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  07C1             ; scanf
0045+  07C1             ; no need for explanations!
0046+  07C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  07C1             scanf:
0048+  07C1 09            ret
0049+  07C2             
0050+  07C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  07C2             ; itoa
0052+  07C2             ; 8bit value in bl
0053+  07C2             ; 2 byte ascii result in a
0054+  07C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  07C2             _itoa:
0056+  07C2 DA            push d
0057+  07C3 D8            push b
0058+  07C4 A7 00         mov bh, 0
0059+  07C6 FD A4 04      shr bl, 4  
0060+  07C9 74            mov d, b
0061+  07CA 1F 5C 0A      mov al, [d + s_hex_digits]
0062+  07CD 23            mov ah, al
0063+  07CE               
0064+  07CE E5            pop b
0065+  07CF D8            push b
0066+  07D0 A7 00         mov bh, 0
0067+  07D2 FD 87 0F      and bl, $0f
0068+  07D5 74            mov d, b
0069+  07D6 1F 5C 0A      mov al, [d + s_hex_digits]
0070+  07D9 E5            pop b
0071+  07DA E7            pop d
0072+  07DB 09            ret
0073+  07DC             
0074+  07DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  07DC             ; hex string to binary
0076+  07DC             ; di = destination address
0077+  07DC             ; si = source
0078+  07DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  07DC             _hex_to_int:
0080+  07DC             _hex_to_int_l1:
0081+  07DC F6            lodsb          ; load from [si] to al
0082+  07DD B9 00         cmp al, 0        ; check if ascii 0
0083+  07DF C6 EC 07      jz _hex_to_int_ret
0084+  07E2 36            mov bh, al
0085+  07E3 F6            lodsb
0086+  07E4 2F            mov bl, al
0087+  07E5 07 B1 07      call _atoi        ; convert ascii byte in b to int (to al)
0088+  07E8 F7            stosb          ; store al to [di]
0089+  07E9 0A DC 07      jmp _hex_to_int_l1
0090+  07EC             _hex_to_int_ret:
0091+  07EC 09            ret    
0092+  07ED             
0093+  07ED             
0094+  07ED             
0095+  07ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  07ED             ; getchar
0097+  07ED             ; char in ah
0098+  07ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  07ED             getch:
0100+  07ED DB            push al
0101+  07EE             getch_retry:
0102+  07EE 19 01         mov al, 1
0103+  07F0 05 03         syscall sys_io      ; receive in ah
0104+  07F2 E8            pop al
0105+  07F3 09            ret
0106+  07F4             
0107+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  07F4             ; putchar
0109+  07F4             ; char in ah
0110+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  07F4             _putchar:
0112+  07F4 DB            push al
0113+  07F5 19 00         mov al, 0
0114+  07F7 05 03         syscall sys_io      ; char in ah
0115+  07F9 E8            pop al
0116+  07FA 09            ret
0117+  07FB             
0118+  07FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  07FB             ;; input a string
0120+  07FB             ;; terminates with null
0121+  07FB             ;; pointer in d
0122+  07FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  07FB             _gets:
0124+  07FB D7            push a
0125+  07FC DA            push d
0126+  07FD             _gets_loop:
0127+  07FD 19 01         mov al, 1
0128+  07FF 05 03         syscall sys_io      ; receive in ah
0129+  0801 76 1B         cmp ah, 27
0130+  0803 C6 24 08      je _gets_ansi_esc
0131+  0806 76 0A         cmp ah, $0a        ; lf
0132+  0808 C6 80 08      je _gets_end
0133+  080B 76 0D         cmp ah, $0d        ; cr
0134+  080D C6 80 08      je _gets_end
0135+  0810 76 5C         cmp ah, $5c        ; '\\'
0136+  0812 C6 46 08      je _gets_escape
0137+  0815 76 08         cmp ah, $08      ; check for backspace
0138+  0817 C6 20 08      je _gets_backspace
0139+  081A 1A            mov al, ah
0140+  081B 3E            mov [d], al
0141+  081C 79            inc d
0142+  081D 0A FD 07      jmp _gets_loop
0143+  0820             _gets_backspace:
0144+  0820 7F            dec d
0145+  0821 0A FD 07      jmp _gets_loop
0146+  0824             _gets_ansi_esc:
0147+  0824 19 01         mov al, 1
0148+  0826 05 03         syscall sys_io        ; receive in ah without echo
0149+  0828 76 5B         cmp ah, '['
0150+  082A C7 FD 07      jne _gets_loop
0151+  082D 19 01         mov al, 1
0152+  082F 05 03         syscall sys_io          ; receive in ah without echo
0153+  0831 76 64         cmp ah, 'd'
0154+  0833 C6 3E 08      je _gets_left_arrow
0155+  0836 76 63         cmp ah, 'c'
0156+  0838 C6 42 08      je _gets_right_arrow
0157+  083B 0A FD 07      jmp _gets_loop
0158+  083E             _gets_left_arrow:
0159+  083E 7F            dec d
0160+  083F 0A FD 07      jmp _gets_loop
0161+  0842             _gets_right_arrow:
0162+  0842 79            inc d
0163+  0843 0A FD 07      jmp _gets_loop
0164+  0846             _gets_escape:
0165+  0846 19 01         mov al, 1
0166+  0848 05 03         syscall sys_io      ; receive in ah
0167+  084A 76 6E         cmp ah, 'n'
0168+  084C C6 6B 08      je _gets_lf
0169+  084F 76 72         cmp ah, 'r'
0170+  0851 C6 72 08      je _gets_cr
0171+  0854 76 30         cmp ah, '0'
0172+  0856 C6 79 08      je _gets_null
0173+  0859 76 5C         cmp ah, $5c  ; '\'
0174+  085B C6 64 08      je _gets_slash
0175+  085E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  085F 3E            mov [d], al
0177+  0860 79            inc d
0178+  0861 0A FD 07      jmp _gets_loop
0179+  0864             _gets_slash:
0180+  0864 19 5C         mov al, $5c
0181+  0866 3E            mov [d], al
0182+  0867 79            inc d
0183+  0868 0A FD 07      jmp _gets_loop
0184+  086B             _gets_lf:
0185+  086B 19 0A         mov al, $0a
0186+  086D 3E            mov [d], al
0187+  086E 79            inc d
0188+  086F 0A FD 07      jmp _gets_loop
0189+  0872             _gets_cr:
0190+  0872 19 0D         mov al, $0d
0191+  0874 3E            mov [d], al
0192+  0875 79            inc d
0193+  0876 0A FD 07      jmp _gets_loop
0194+  0879             _gets_null:
0195+  0879 19 00         mov al, $00
0196+  087B 3E            mov [d], al
0197+  087C 79            inc d
0198+  087D 0A FD 07      jmp _gets_loop
0199+  0880             _gets_end:
0200+  0880 19 00         mov al, 0
0201+  0882 3E            mov [d], al        ; terminate string
0202+  0883 E7            pop d
0203+  0884 E4            pop a
0204+  0885 09            ret
0205+  0886             
0206+  0886             
0207+  0886             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0886             ;; input text
0209+  0886             ;; terminated with ctrl+d
0210+  0886             ;; pointer in d
0211+  0886             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0886             _gettxt:
0213+  0886 D7            push a
0214+  0887 DA            push d
0215+  0888             _gettxt_loop:
0216+  0888 19 01         mov al, 1
0217+  088A 05 03         syscall sys_io      ; receive in ah
0218+  088C 76 04         cmp ah, 4      ; eot
0219+  088E C6 C7 08      je _gettxt_end
0220+  0891 76 08         cmp ah, $08      ; check for backspace
0221+  0893 C6 C3 08      je _gettxt_backspace
0222+  0896 76 5C         cmp ah, $5c        ; '\'
0223+  0898 C6 A1 08      je _gettxt_escape
0224+  089B 1A            mov al, ah
0225+  089C 3E            mov [d], al
0226+  089D 79            inc d
0227+  089E 0A 88 08      jmp _gettxt_loop
0228+  08A1             _gettxt_escape:
0229+  08A1 19 01         mov al, 1
0230+  08A3 05 03         syscall sys_io      ; receive in ah
0231+  08A5 76 6E         cmp ah, 'n'
0232+  08A7 C6 B5 08      je _gettxt_lf
0233+  08AA 76 72         cmp ah, 'r'
0234+  08AC C6 BC 08      je _gettxt_cr
0235+  08AF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  08B0 3E            mov [d], al
0237+  08B1 79            inc d
0238+  08B2 0A 88 08      jmp _gettxt_loop
0239+  08B5             _gettxt_lf:
0240+  08B5 19 0A         mov al, $0a
0241+  08B7 3E            mov [d], al
0242+  08B8 79            inc d
0243+  08B9 0A 88 08      jmp _gettxt_loop
0244+  08BC             _gettxt_cr:
0245+  08BC 19 0D         mov al, $0d
0246+  08BE 3E            mov [d], al
0247+  08BF 79            inc d
0248+  08C0 0A 88 08      jmp _gettxt_loop
0249+  08C3             _gettxt_backspace:
0250+  08C3 7F            dec d
0251+  08C4 0A 88 08      jmp _gettxt_loop
0252+  08C7             _gettxt_end:
0253+  08C7 19 00         mov al, 0
0254+  08C9 3E            mov [d], al        ; terminate string
0255+  08CA E7            pop d
0256+  08CB E4            pop a
0257+  08CC 09            ret
0258+  08CD             
0259+  08CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  08CD             ; print new line
0261+  08CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  08CD             printnl:
0263+  08CD D7            push a
0264+  08CE 10 00 0A      mov a, $0a00
0265+  08D1 05 03         syscall sys_io
0266+  08D3 10 00 0D      mov a, $0d00
0267+  08D6 05 03         syscall sys_io
0268+  08D8 E4            pop a
0269+  08D9 09            ret
0270+  08DA             
0271+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  08DA             ; _strtoint
0273+  08DA             ; 4 digit hex string number in d
0274+  08DA             ; integer returned in a
0275+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  08DA             _strtointx:
0277+  08DA D8            push b
0278+  08DB 32            mov bl, [d]
0279+  08DC 37            mov bh, bl
0280+  08DD 33 01 00      mov bl, [d + 1]
0281+  08E0 07 B1 07      call _atoi        ; convert to int in al
0282+  08E3 23            mov ah, al        ; move to ah
0283+  08E4 33 02 00      mov bl, [d + 2]
0284+  08E7 37            mov bh, bl
0285+  08E8 33 03 00      mov bl, [d + 3]
0286+  08EB 07 B1 07      call _atoi        ; convert to int in al
0287+  08EE E5            pop b
0288+  08EF 09            ret
0289+  08F0             
0290+  08F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  08F0             ; _strtoint
0292+  08F0             ; 5 digit base10 string number in d
0293+  08F0             ; integer returned in a
0294+  08F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  08F0             _strtoint:
0296+  08F0 E2            push si
0297+  08F1 D8            push b
0298+  08F2 D9            push c
0299+  08F3 DA            push d
0300+  08F4 07 53 07      call _strlen      ; get string length in c
0301+  08F7 7E            dec c
0302+  08F8 FD 4E         mov si, d
0303+  08FA 12            mov a, c
0304+  08FB FD 99         shl a
0305+  08FD 3B 74 0A      mov d, table_power
0306+  0900 59            add d, a
0307+  0901 38 00 00      mov c, 0
0308+  0904             _strtoint_l0:
0309+  0904 F6            lodsb      ; load ascii to al
0310+  0905 B9 00         cmp al, 0
0311+  0907 C6 1A 09      je _strtoint_end
0312+  090A 6F 30         sub al, $30    ; make into integer
0313+  090C 22 00         mov ah, 0
0314+  090E 2A            mov b, [d]
0315+  090F AC            mul a, b      ; result in b since it fits in 16bits
0316+  0910 11            mov a, b
0317+  0911 28            mov b, c
0318+  0912 54            add a, b
0319+  0913 39            mov c, a
0320+  0914 63 02 00      sub d, 2
0321+  0917 0A 04 09      jmp _strtoint_l0
0322+  091A             _strtoint_end:
0323+  091A 12            mov a, c
0324+  091B E7            pop d
0325+  091C E6            pop c
0326+  091D E5            pop b
0327+  091E EF            pop si
0328+  091F 09            ret
0329+  0920             
0330+  0920             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0920             ; print null terminated string
0332+  0920             ; pointer in d
0333+  0920             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0920             _puts:
0335+  0920 D7            push a
0336+  0921 DA            push d
0337+  0922             _puts_l1:
0338+  0922 1E            mov al, [d]
0339+  0923 B9 00         cmp al, 0
0340+  0925 C6 31 09      jz _puts_end
0341+  0928 23            mov ah, al
0342+  0929 19 00         mov al, 0
0343+  092B 05 03         syscall sys_io
0344+  092D 79            inc d
0345+  092E 0A 22 09      jmp _puts_l1
0346+  0931             _puts_end:
0347+  0931 E7            pop d
0348+  0932 E4            pop a
0349+  0933 09            ret
0350+  0934             
0351+  0934             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0934             ; print n size string
0353+  0934             ; pointer in d
0354+  0934             ; size in c
0355+  0934             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0934             _putsn:
0357+  0934 DB            push al
0358+  0935 DA            push d
0359+  0936 D9            push c
0360+  0937             _putsn_l0:
0361+  0937 1E            mov al, [d]
0362+  0938 23            mov ah, al
0363+  0939 19 00         mov al, 0
0364+  093B 05 03         syscall sys_io
0365+  093D 79            inc d
0366+  093E 7E            dec c  
0367+  093F C2 00 00      cmp c, 0
0368+  0942 C7 37 09      jne _putsn_l0
0369+  0945             _putsn_end:
0370+  0945 E6            pop c
0371+  0946 E7            pop d
0372+  0947 E8            pop al
0373+  0948 09            ret
0374+  0949             
0375+  0949             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0949             ; print 16bit decimal number
0377+  0949             ; input number in a
0378+  0949             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0949             print_u16d:
0380+  0949 D7            push a
0381+  094A D8            push b
0382+  094B FD D8         push g
0383+  094D 26 10 27      mov b, 10000
0384+  0950 AE            div a, b      ; get 10000's coeff.
0385+  0951 07 75 09      call print_number
0386+  0954 11            mov a, b
0387+  0955 26 E8 03      mov b, 1000
0388+  0958 AE            div a, b      ; get 1000's coeff.
0389+  0959 07 75 09      call print_number
0390+  095C 11            mov a, b
0391+  095D 26 64 00      mov b, 100
0392+  0960 AE            div a, b
0393+  0961 07 75 09      call print_number
0394+  0964 11            mov a, b
0395+  0965 26 0A 00      mov b, 10
0396+  0968 AE            div a, b
0397+  0969 07 75 09      call print_number
0398+  096C 1B            mov al, bl      ; 1's coeff in bl
0399+  096D 07 75 09      call print_number
0400+  0970 FD F1         pop g
0401+  0972 E5            pop b
0402+  0973 E4            pop a
0403+  0974 09            ret
0404+  0975             
0405+  0975             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0975             ; print al
0407+  0975             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0975             print_number:
0409+  0975 6A 30         add al, $30
0410+  0977 23            mov ah, al
0411+  0978 07 F4 07      call _putchar
0412+  097B 09            ret
0413+  097C             
0414+  097C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  097C             ; print 16bit hex integer
0416+  097C             ; integer value in reg b
0417+  097C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  097C             print_u16x:
0419+  097C D7            push a
0420+  097D D8            push b
0421+  097E DD            push bl
0422+  097F 30            mov bl, bh
0423+  0980 07 C2 07      call _itoa        ; convert bh to char in a
0424+  0983 2F            mov bl, al        ; save al
0425+  0984 19 00         mov al, 0
0426+  0986 05 03         syscall sys_io        ; display ah
0427+  0988 24            mov ah, bl        ; retrieve al
0428+  0989 19 00         mov al, 0
0429+  098B 05 03         syscall sys_io        ; display al
0430+  098D             
0431+  098D EA            pop bl
0432+  098E 07 C2 07      call _itoa        ; convert bh to char in a
0433+  0991 2F            mov bl, al        ; save al
0434+  0992 19 00         mov al, 0
0435+  0994 05 03         syscall sys_io        ; display ah
0436+  0996 24            mov ah, bl        ; retrieve al
0437+  0997 19 00         mov al, 0
0438+  0999 05 03         syscall sys_io        ; display al
0439+  099B             
0440+  099B E5            pop b
0441+  099C E4            pop a
0442+  099D 09            ret
0443+  099E             
0444+  099E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  099E             ; input 16bit hex integer
0446+  099E             ; read 16bit integer into a
0447+  099E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  099E             scan_u16x:
0449+  099E F8 10 00      enter 16
0450+  09A1 D8            push b
0451+  09A2 DA            push d
0452+  09A3             
0453+  09A3 FA F1 FF      lea d, [bp + -15]
0454+  09A6 07 FB 07      call _gets        ; get number
0455+  09A9             
0456+  09A9 32            mov bl, [d]
0457+  09AA 37            mov bh, bl
0458+  09AB 33 01 00      mov bl, [d + 1]
0459+  09AE 07 B1 07      call _atoi        ; convert to int in al
0460+  09B1 23            mov ah, al        ; move to ah
0461+  09B2             
0462+  09B2 33 02 00      mov bl, [d + 2]
0463+  09B5 37            mov bh, bl
0464+  09B6 33 03 00      mov bl, [d + 3]
0465+  09B9 07 B1 07      call _atoi        ; convert to int in al
0466+  09BC             
0467+  09BC E7            pop d
0468+  09BD E5            pop b
0469+  09BE F9            leave
0470+  09BF 09            ret
0471+  09C0             
0472+  09C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  09C0             ; print 8bit hex integer
0474+  09C0             ; integer value in reg bl
0475+  09C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  09C0             print_u8x:
0477+  09C0 D7            push a
0478+  09C1 DD            push bl
0479+  09C2             
0480+  09C2 07 C2 07      call _itoa        ; convert bl to char in a
0481+  09C5 2F            mov bl, al        ; save al
0482+  09C6 19 00         mov al, 0
0483+  09C8 05 03         syscall sys_io        ; display ah
0484+  09CA 24            mov ah, bl        ; retrieve al
0485+  09CB 19 00         mov al, 0
0486+  09CD 05 03         syscall sys_io        ; display al
0487+  09CF             
0488+  09CF EA            pop bl
0489+  09D0 E4            pop a
0490+  09D1 09            ret
0491+  09D2             
0492+  09D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  09D2             ; print 8bit decimal unsigned number
0494+  09D2             ; input number in al
0495+  09D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  09D2             print_u8d:
0497+  09D2 D7            push a
0498+  09D3 D8            push b
0499+  09D4 FD D8         push g
0500+  09D6 22 00         mov ah, 0
0501+  09D8 26 64 00      mov b, 100
0502+  09DB AE            div a, b
0503+  09DC D8            push b      ; save remainder
0504+  09DD B9 00         cmp al, 0
0505+  09DF C6 E9 09      je skip100
0506+  09E2 6A 30         add al, $30
0507+  09E4 23            mov ah, al
0508+  09E5 19 00         mov al, 0
0509+  09E7 05 03         syscall sys_io  ; print coeff
0510+  09E9             skip100:
0511+  09E9 E4            pop a
0512+  09EA 22 00         mov ah, 0
0513+  09EC 26 0A 00      mov b, 10
0514+  09EF AE            div a, b
0515+  09F0 D8            push b      ; save remainder
0516+  09F1 B9 00         cmp al, 0
0517+  09F3 C6 FD 09      je skip10
0518+  09F6 6A 30         add al, $30
0519+  09F8 23            mov ah, al
0520+  09F9 19 00         mov al, 0
0521+  09FB 05 03         syscall sys_io  ; print coeff
0522+  09FD             skip10:
0523+  09FD E4            pop a
0524+  09FE 1B            mov al, bl
0525+  09FF 6A 30         add al, $30
0526+  0A01 23            mov ah, al
0527+  0A02 19 00         mov al, 0
0528+  0A04 05 03         syscall sys_io  ; print coeff
0529+  0A06 FD F1         pop g
0530+  0A08 E5            pop b
0531+  0A09 E4            pop a
0532+  0A0A 09            ret
0533+  0A0B             
0534+  0A0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0A0B             ; input 8bit hex integer
0536+  0A0B             ; read 8bit integer into al
0537+  0A0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0A0B             scan_u8x:
0539+  0A0B F8 04 00      enter 4
0540+  0A0E D8            push b
0541+  0A0F DA            push d
0542+  0A10             
0543+  0A10 FA FD FF      lea d, [bp + -3]
0544+  0A13 07 FB 07      call _gets        ; get number
0545+  0A16             
0546+  0A16 32            mov bl, [d]
0547+  0A17 37            mov bh, bl
0548+  0A18 33 01 00      mov bl, [d + 1]
0549+  0A1B 07 B1 07      call _atoi        ; convert to int in al
0550+  0A1E             
0551+  0A1E E7            pop d
0552+  0A1F E5            pop b
0553+  0A20 F9            leave
0554+  0A21 09            ret
0555+  0A22             
0556+  0A22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0A22             ; input decimal number
0558+  0A22             ; result in a
0559+  0A22             ; 655'\0'
0560+  0A22             ; low--------high
0561+  0A22             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0A22             scan_u16d:
0563+  0A22 F8 08 00      enter 8
0564+  0A25 E2            push si
0565+  0A26 D8            push b
0566+  0A27 D9            push c
0567+  0A28 DA            push d
0568+  0A29 FA F9 FF      lea d, [bp +- 7]
0569+  0A2C 07 FB 07      call _gets
0570+  0A2F 07 53 07      call _strlen      ; get string length in c
0571+  0A32 7E            dec c
0572+  0A33 FD 4E         mov si, d
0573+  0A35 12            mov a, c
0574+  0A36 FD 99         shl a
0575+  0A38 3B 74 0A      mov d, table_power
0576+  0A3B 59            add d, a
0577+  0A3C 38 00 00      mov c, 0
0578+  0A3F             mul_loop:
0579+  0A3F F6            lodsb      ; load ascii to al
0580+  0A40 B9 00         cmp al, 0
0581+  0A42 C6 55 0A      je mul_exit
0582+  0A45 6F 30         sub al, $30    ; make into integer
0583+  0A47 22 00         mov ah, 0
0584+  0A49 2A            mov b, [d]
0585+  0A4A AC            mul a, b      ; result in b since it fits in 16bits
0586+  0A4B 11            mov a, b
0587+  0A4C 28            mov b, c
0588+  0A4D 54            add a, b
0589+  0A4E 39            mov c, a
0590+  0A4F 63 02 00      sub d, 2
0591+  0A52 0A 3F 0A      jmp mul_loop
0592+  0A55             mul_exit:
0593+  0A55 12            mov a, c
0594+  0A56 E7            pop d
0595+  0A57 E6            pop c
0596+  0A58 E5            pop b
0597+  0A59 EF            pop si
0598+  0A5A F9            leave
0599+  0A5B 09            ret
0600+  0A5C             
0601+  0A5C             
0602+  0A5C 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  0A60 34 35 36 37 
0602+  0A64 38 39 61 62 
0602+  0A68 63 64 65 66 
0603+  0A6C 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  0A70 1B 5B 68 00 
0604+  0A74             
0605+  0A74             table_power:
0606+  0A74 01 00         .dw 1
0607+  0A76 0A 00         .dw 10
0608+  0A78 64 00         .dw 100
0609+  0A7A E8 03         .dw 1000
0610+  0A7C 10 27         .dw 100000256   0A7E             .end
tasm: Number of errors = 8
