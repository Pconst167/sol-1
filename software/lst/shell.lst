0001   0000             .include "lib/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0002   0000             
0003   0000             STACK_BEGIN:  .equ $F7FF  ; beginning of stack
0004   0000             
0005   0400             .org text_org      ; origin at 1024
0006   0400             
0007   0400             shell_main:  
0008   0400 FD 49 FF F7   mov bp, STACK_BEGIN
0009   0404 FD 47 FF F7   mov sp, STACK_BEGIN
0010   0408             
0011   0408             ; open config file
0012   0408             ; example: path=/usr/bin;
0013   0408             ; read path config entry
0014   0408 3B 18 07      mov d, s_etc_config   ; '/etc/shell.cfg'
0015   040B FD 4D 2C 07   mov si, s_path        ; config entry name is "path"
0016   040F FD 4F 8A 06   mov di, path          ; config value destination is the var that holds the path variable
0017   0413 07 B6 04      call read_config
0018   0416 3B 8A 06      mov d, path
0019   0419 07 6D 0F      call _puts
0020   041C             
0021   041C             ; open config file
0022   041C             ; read home directory config entry
0023   041C 3B 18 07      mov d, s_etc_config     ; '/etc/shell.cfg'
0024   041F FD 4D 27 07   mov si, s_home          ; config entry name is "home"
0025   0423 FD 4F 0A 06   mov di, homedir         ; config value destination is the var that holds the home directory path
0026   0427 07 B6 04      call read_config  
0027   042A             
0028   042A 07 1A 0F      call printnl
0029   042D             
0030   042D 10 0A 07      mov a, s_etc_shellrc
0031   0430 42 92 13      mov [prog], a
0032   0433 07 FF 04      call cmd_shell
0033   0436             
0034   0436             shell_L0:
0035   0436 3B 4F 07      mov d, s_sol1
0036   0439 07 6D 0F      call _puts
0037   043C 19 12         mov al, 18
0038   043E 05 04         syscall sys_filesystem        ; print current path
0039   0440 3B 49 07      mov d, s_hash
0040   0443 07 6D 0F      call _puts
0041   0446 3B 57 07      mov d, shell_input_buff
0042   0449 13            mov a, d
0043   044A 42 92 13      mov [prog], a      ; reset tokenizer buffer pointer
0044   044D 07 48 0E      call _gets            ; get command
0045   0450 07 56 04      call cmd_parser
0046   0453 0A 36 04      jmp shell_L0
0047   0456             
0048   0456             cmd_parser:
0049   0456 07 F3 11      call get_token          ; get command into tokstr
0050   0459 FD 4F F7 05   mov di, commands
0051   045D FD 10         cla
0052   045F 42 57 09      mov [parser_index], a    ; reset commands index
0053   0462             parser_L0:
0054   0462 FD 4D 96 13   mov si, tokstr
0055   0466 07 B0 0D      call _strcmp
0056   0469 C6 91 04      je parser_cmd_equal
0057   046C             parser_L0_L0:
0058   046C FC 00 00      lea d, [di + 0]
0059   046F BD 00         cmp byte[d], 0
0060   0471 C6 7A 04      je parser_L0_L0_exit      ; run through the keyword until finding NULL
0061   0474 D4 01 00      add di, 1
0062   0477 0A 6C 04      jmp parser_L0_L0
0063   047A             parser_L0_L0_exit:
0064   047A D4 01 00      add di, 1        ; then skip NULL byte at the end 
0065   047D 14 57 09      mov a, [parser_index]
0066   0480 53 02 00      add a, 2
0067   0483 42 57 09      mov [parser_index], a      ; increase commands table index
0068   0486 FC 00 00      lea d, [di + 0]
0069   0489 BD 00         cmp byte[d], 0
0070   048B C6 AC 04      je parser_cmd_not_found
0071   048E 0A 62 04      jmp parser_L0
0072   0491             parser_cmd_equal:
0073   0491 07 1A 0F      call printnl
0074   0494 14 57 09      mov a, [parser_index]      ; get the keyword pointer
0075   0497 FD 07 04 06   call [a + keyword_ptrs]    ; execute command
0076   049B 07 1A 0F      call printnl
0077   049E             parser_retry:
0078   049E 07 F3 11      call get_token
0079   04A1 BC 95 13 06   cmp byte[tok], TOK_SEMI
0080   04A5 C6 56 04      je cmd_parser
0081   04A8 07 79 13      call _putback
0082   04AB 09            ret
0083   04AC             parser_cmd_not_found:
0084   04AC 07 79 13      call _putback
0085   04AF 07 5F 05      call cmd_exec      ; execute as file/program
0086   04B2 0A 9E 04      jmp parser_retry    ; check for more commands
0087   04B5 09            ret
0088   04B6             
0089   04B6             ; inputs:
0090   04B6             ; D = filename ptr
0091   04B6             ; SI = entry name ptr
0092   04B6             ; DI = output value string ptr
0093   04B6             read_config:
0094   04B6 E3            push di
0095   04B7 E2            push si
0096   04B8 FD 4F 96 14   mov di, shell_transient_area
0097   04BC 19 14         mov al, 20
0098   04BE 05 04         syscall sys_filesystem        ; read entire config file
0099   04C0 10 96 14      mov a, shell_transient_area
0100   04C3 42 92 13      mov [prog], a
0101   04C6 EF            pop si
0102   04C7             read_config_L0:
0103   04C7 07 F3 11      call get_token
0104   04CA BC 95 13 14   cmp byte[tok], TOK_END
0105   04CE C6 FA 04      je read_config_EOF
0106   04D1 FD 4F 96 13   mov di, tokstr
0107   04D5 07 B0 0D      call _strcmp
0108   04D8 C6 E8 04      je read_config_found_entry
0109   04DB             read_config_L0_L0:
0110   04DB 07 F3 11      call get_token
0111   04DE BC 95 13 06   cmp byte[tok], TOK_SEMI
0112   04E2 C6 C7 04      je read_config_L0
0113   04E5 0A DB 04      jmp read_config_L0_L0
0114   04E8             read_config_found_entry:
0115   04E8 07 F3 11      call get_token      ; bypass '=' sign
0116   04EB F0            pop di
0117   04EC 14 92 13      mov a, [prog]
0118   04EF 4D            mov si, a
0119   04F0             read_conf_L1:
0120   04F0 F6            lodsb
0121   04F1 B9 3B         cmp al, $3B        ; ';'
0122   04F3 C6 FB 04      je read_config_EOF_2
0123   04F6 F7            stosb
0124   04F7 0A F0 04      jmp read_conf_L1
0125   04FA             read_config_EOF:
0126   04FA F0            pop di
0127   04FB             read_config_EOF_2:
0128   04FB 19 00         mov al, 0
0129   04FD F7            stosb          ; terminate value with NULL
0130   04FE 09            ret
0131   04FF             
0132   04FF             ;  sol shell
0133   04FF             cmd_shell:
0134   04FF 07 9C 11      call get_path
0135   0502 3B 96 13      mov d, tokstr
0136   0505 FD 4F 96 14   mov di, shell_transient_area
0137   0509 19 14         mov al, 20
0138   050B 05 04         syscall sys_filesystem        ; read textfile 
0139   050D               
0140   050D 3B 96 14      mov d, shell_transient_area
0141   0510 13            mov a, d
0142   0511 42 92 13      mov [prog], a      ; reset tokenizer buffer pointer
0143   0514 07 56 04      call cmd_parser
0144   0517             
0145   0517 07 1A 0F      call printnl
0146   051A 09            ret
0147   051B             
0148   051B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0149   051B             ;; CD
0150   051B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0151   051B             ; search for given directory inside current dir
0152   051B             ; if found, read its LBA, and switch directories
0153   051B             ; example:  cd /usr/bin; ls
0154   051B             ;       cd /usr/bin;
0155   051B             ;      cd /usr/bin
0156   051B             cmd_cd:
0157   051B 07 F3 11      call get_token
0158   051E 1D 95 13      mov al, [tok]
0159   0521 B9 14         cmp al, TOK_END
0160   0523 C6 4D 05      je cmd_cd_gotohome
0161   0526 B9 06         cmp al, TOK_SEMI
0162   0528 C6 4D 05      je cmd_cd_gotohome
0163   052B B9 08         cmp al, TOK_TILDE
0164   052D C6 4D 05      je cmd_cd_gotohome
0165   0530 07 79 13      call _putback
0166   0533 07 9C 11      call get_path    ; get the path for the cd command
0167   0536             cmd_cd_syscall:
0168   0536 3B 96 13      mov d, tokstr
0169   0539 19 13         mov al, 19
0170   053B 05 04         syscall sys_filesystem  ; get dirID in A
0171   053D AF FF FF      cmp a, $FFFF
0172   0540 C6 5E 05      je cmd_cd_fail
0173   0543 27            mov b, a
0174   0544 19 03         mov al, 3
0175   0546 05 04         syscall sys_filesystem  ; set dir to B
0176   0548             
0177   0548             ; apply 'ls' to the directory
0178   0548 19 04       	mov al, 4
0179   054A 05 04       	syscall sys_filesystem
0180   054C 09            ret
0181   054D             cmd_cd_gotohome:
0182   054D 07 79 13      call _putback
0183   0550 FD 4D 0A 06   mov si, homedir
0184   0554 FD 4F 96 13   mov di, tokstr
0185   0558 07 C5 0D      call _strcpy
0186   055B 0A 36 05      jmp cmd_cd_syscall
0187   055E             cmd_cd_fail:
0188   055E 09            ret
0189   055F             
0190   055F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0191   055F             ;; EXEC/OPEN PROGRAM/FILE
0192   055F             ;; 'filename' maps to '$path/filename'
0193   055F             ;; './file' or '/a/directory/file' loads a file directly
0194   055F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0195   055F             cmd_exec:
0196   055F BC 95 13 14   cmp byte[tok], TOK_END
0197   0563 C6 E9 05      je cmd_exec_ret    ; check for NULL input
0198   0566 07 9C 11      call get_path    ; get file path 
0199   0569 14 92 13      mov a, [prog]
0200   056C D7            push a        ; save argument pointer
0201   056D FD 4D 96 13   mov si, tokstr
0202   0571 FD 4F 59 09   mov di, temp_data1
0203   0575 07 C5 0D      call _strcpy      ; copy filename for later
0204   0578 BC 96 13 2F   cmp byte[tokstr], '/'  ; check first character of path
0205   057C C6 DA 05      je cmd_exec_abs
0206   057F BC 96 13 2E   cmp byte[tokstr], '.'  ; check first character of path
0207   0583 C6 DA 05      je cmd_exec_abs
0208   0586 10 8A 06      mov a, path
0209   0589 42 92 13      mov [prog], a    ; set token pointer to $path beginning
0210   058C             cmd_exec_L0:
0211   058C 07 9C 11      call get_path    ; get a path option
0212   058F FD 4D 96 13   mov si, tokstr
0213   0593 FD 4F 59 0B   mov di, temp_data
0214   0597 07 C5 0D      call _strcpy      ; firstly, form address from one of the '$path' addresses
0215   059A FD 4D 4D 07   mov si, s_fslash
0216   059E FD 4F 59 0B   mov di, temp_data
0217   05A2 07 D3 0D      call _strcat      ; add '/' in between $path component and filename
0218   05A5 FD 4D 59 09   mov si, temp_data1
0219   05A9 FD 4F 59 0B   mov di, temp_data
0220   05AD 07 D3 0D      call _strcat      ; now glue the given filename to the total path
0221   05B0 3B 59 0B      mov d, temp_data
0222   05B3 19 15         mov al, 21
0223   05B5 05 04         syscall sys_filesystem  ; now we check whether such a file exists. success code is given in A. if 0, file does not exist
0224   05B7 AF 00 00      cmp a, 0
0225   05BA C7 CA 05      jne cmd_exec_path_exists
0226   05BD 07 F3 11      call get_token
0227   05C0 BC 95 13 06   cmp byte[tok], TOK_SEMI
0228   05C4 C7 8C 05      jne cmd_exec_L0    ; if not ';' at the end, then token must be a separator. so try another path
0229   05C7 0A EA 05      jmp cmd_exec_unknown
0230   05CA             cmd_exec_path_exists:
0231   05CA E4            pop a        ; retrieve token pointer which points to the arguments given
0232   05CB 42 92 13      mov [prog], a
0233   05CE 07 68 11      call get_arg    ; if however, $path/filename was found, then we execute it
0234   05D1 26 96 13      mov b, tokstr
0235   05D4 3B 59 0B      mov d, temp_data
0236   05D7 05 05         syscall sys_create_proc
0237   05D9 09            ret
0238   05DA             cmd_exec_abs:  ; execute as absolute path
0239   05DA E4            pop a
0240   05DB 42 92 13      mov [prog], a
0241   05DE 07 68 11      call get_arg
0242   05E1 26 96 13      mov b, tokstr
0243   05E4 3B 59 09      mov d, temp_data1  ;original filename
0244   05E7 05 05         syscall sys_create_proc
0245   05E9             cmd_exec_ret:
0246   05E9 09            ret
0247   05EA             cmd_exec_unknown:
0248   05EA E4            pop a
0249   05EB 09            ret
0250   05EC             
0251   05EC             cmd_fg:
0252   05EC 07 F3 11      call get_token
0253   05EF 1D 96 13      mov al, [tokstr]
0254   05F2 6F 30         sub al, $30
0255   05F4 05 0A         syscall sys_resume_proc
0256   05F6 09            ret
0257   05F7             
0258   05F7             commands:         
0259   05F7 63 64 00      .db "cd", 0
0260   05FA 66 67 00      .db "fg", 0
0261   05FD 73 68 65 6C   .db "shell", 0
0261   0601 6C 00 
0262   0603 00            .db 0
0263   0604             
0264   0604             keyword_ptrs:     
0265   0604 1B 05         .dw cmd_cd
0266   0606 EC 05         .dw cmd_fg
0267   0608 FF 04         .dw cmd_shell
0268   060A             
0269   060A 00 00 00 00 homedir:          .fill 128, 0
0269   060E 00 00 00 00 
0269   0612 00 00 00 00 
0269   0616 00 00 00 00 
0269   061A 00 00 00 00 
0269   061E 00 00 00 00 
0269   0622 00 00 00 00 
0269   0626 00 00 00 00 
0269   062A 00 00 00 00 
0269   062E 00 00 00 00 
0269   0632 00 00 00 00 
0269   0636 00 00 00 00 
0269   063A 00 00 00 00 
0269   063E 00 00 00 00 
0269   0642 00 00 00 00 
0269   0646 00 00 00 00 
0269   064A 00 00 00 00 
0269   064E 00 00 00 00 
0269   0652 00 00 00 00 
0269   0656 00 00 00 00 
0269   065A 00 00 00 00 
0269   065E 00 00 00 00 
0269   0662 00 00 00 00 
0269   0666 00 00 00 00 
0269   066A 00 00 00 00 
0269   066E 00 00 00 00 
0269   0672 00 00 00 00 
0269   0676 00 00 00 00 
0269   067A 00 00 00 00 
0269   067E 00 00 00 00 
0269   0682 00 00 00 00 
0269   0686 00 00 00 00 
0270   068A 00 00 00 00 path:             .fill 128, 0    ; $path environment variable 
0270   068E 00 00 00 00 
0270   0692 00 00 00 00 
0270   0696 00 00 00 00 
0270   069A 00 00 00 00 
0270   069E 00 00 00 00 
0270   06A2 00 00 00 00 
0270   06A6 00 00 00 00 
0270   06AA 00 00 00 00 
0270   06AE 00 00 00 00 
0270   06B2 00 00 00 00 
0270   06B6 00 00 00 00 
0270   06BA 00 00 00 00 
0270   06BE 00 00 00 00 
0270   06C2 00 00 00 00 
0270   06C6 00 00 00 00 
0270   06CA 00 00 00 00 
0270   06CE 00 00 00 00 
0270   06D2 00 00 00 00 
0270   06D6 00 00 00 00 
0270   06DA 00 00 00 00 
0270   06DE 00 00 00 00 
0270   06E2 00 00 00 00 
0270   06E6 00 00 00 00 
0270   06EA 00 00 00 00 
0270   06EE 00 00 00 00 
0270   06F2 00 00 00 00 
0270   06F6 00 00 00 00 
0270   06FA 00 00 00 00 
0270   06FE 00 00 00 00 
0270   0702 00 00 00 00 
0270   0706 00 00 00 00 
0271   070A             
0272   070A 2F 65 74 63 s_etc_shellrc:    .db "/etc/.shellrc", 0
0272   070E 2F 2E 73 68 
0272   0712 65 6C 6C 72 
0272   0716 63 00 
0273   0718 2F 65 74 63 s_etc_config:     .db "/etc/shell.cfg", 0
0273   071C 2F 73 68 65 
0273   0720 6C 6C 2E 63 
0273   0724 66 67 00 
0274   0727 68 6F 6D 65 s_home:           .db "home", 0
0274   072B 00 
0275   072C 70 61 74 68 s_path:           .db "path", 0
0275   0730 00 
0276   0731             
0277   0731 1B 5B 32 4A s_rebooting:      .db "\033[2J\033[H", "now rebooting...", 0
0277   0735 1B 5B 48 6E 
0277   0739 6F 77 20 72 
0277   073D 65 62 6F 6F 
0277   0741 74 69 6E 67 
0277   0745 2E 2E 2E 00 
0278   0749 20 23 20 00 s_hash:           .db " # ", 0
0279   074D 2F 00       s_fslash:         .db "/", 0
0280   074F 53 6F 6C 2D s_sol1:           .db "Sol-1:", 0, 0
0280   0753 31 3A 00 00 
0281   0757             
0282   0757 00 00 00 00 shell_input_buff: .fill 512, 0
0282   075B 00 00 00 00 
0282   075F 00 00 00 00 
0282   0763 00 00 00 00 
0282   0767 00 00 00 00 
0282   076B 00 00 00 00 
0282   076F 00 00 00 00 
0282   0773 00 00 00 00 
0282   0777 00 00 00 00 
0282   077B 00 00 00 00 
0282   077F 00 00 00 00 
0282   0783 00 00 00 00 
0282   0787 00 00 00 00 
0282   078B 00 00 00 00 
0282   078F 00 00 00 00 
0282   0793 00 00 00 00 
0282   0797 00 00 00 00 
0282   079B 00 00 00 00 
0282   079F 00 00 00 00 
0282   07A3 00 00 00 00 
0282   07A7 00 00 00 00 
0282   07AB 00 00 00 00 
0282   07AF 00 00 00 00 
0282   07B3 00 00 00 00 
0282   07B7 00 00 00 00 
0282   07BB 00 00 00 00 
0282   07BF 00 00 00 00 
0282   07C3 00 00 00 00 
0282   07C7 00 00 00 00 
0282   07CB 00 00 00 00 
0282   07CF 00 00 00 00 
0282   07D3 00 00 00 00 
0282   07D7 00 00 00 00 
0282   07DB 00 00 00 00 
0282   07DF 00 00 00 00 
0282   07E3 00 00 00 00 
0282   07E7 00 00 00 00 
0282   07EB 00 00 00 00 
0282   07EF 00 00 00 00 
0282   07F3 00 00 00 00 
0282   07F7 00 00 00 00 
0282   07FB 00 00 00 00 
0282   07FF 00 00 00 00 
0282   0803 00 00 00 00 
0282   0807 00 00 00 00 
0282   080B 00 00 00 00 
0282   080F 00 00 00 00 
0282   0813 00 00 00 00 
0282   0817 00 00 00 00 
0282   081B 00 00 00 00 
0282   081F 00 00 00 00 
0282   0823 00 00 00 00 
0282   0827 00 00 00 00 
0282   082B 00 00 00 00 
0282   082F 00 00 00 00 
0282   0833 00 00 00 00 
0282   0837 00 00 00 00 
0282   083B 00 00 00 00 
0282   083F 00 00 00 00 
0282   0843 00 00 00 00 
0282   0847 00 00 00 00 
0282   084B 00 00 00 00 
0282   084F 00 00 00 00 
0282   0853 00 00 00 00 
0282   0857 00 00 00 00 
0282   085B 00 00 00 00 
0282   085F 00 00 00 00 
0282   0863 00 00 00 00 
0282   0867 00 00 00 00 
0282   086B 00 00 00 00 
0282   086F 00 00 00 00 
0282   0873 00 00 00 00 
0282   0877 00 00 00 00 
0282   087B 00 00 00 00 
0282   087F 00 00 00 00 
0282   0883 00 00 00 00 
0282   0887 00 00 00 00 
0282   088B 00 00 00 00 
0282   088F 00 00 00 00 
0282   0893 00 00 00 00 
0282   0897 00 00 00 00 
0282   089B 00 00 00 00 
0282   089F 00 00 00 00 
0282   08A3 00 00 00 00 
0282   08A7 00 00 00 00 
0282   08AB 00 00 00 00 
0282   08AF 00 00 00 00 
0282   08B3 00 00 00 00 
0282   08B7 00 00 00 00 
0282   08BB 00 00 00 00 
0282   08BF 00 00 00 00 
0282   08C3 00 00 00 00 
0282   08C7 00 00 00 00 
0282   08CB 00 00 00 00 
0282   08CF 00 00 00 00 
0282   08D3 00 00 00 00 
0282   08D7 00 00 00 00 
0282   08DB 00 00 00 00 
0282   08DF 00 00 00 00 
0282   08E3 00 00 00 00 
0282   08E7 00 00 00 00 
0282   08EB 00 00 00 00 
0282   08EF 00 00 00 00 
0282   08F3 00 00 00 00 
0282   08F7 00 00 00 00 
0282   08FB 00 00 00 00 
0282   08FF 00 00 00 00 
0282   0903 00 00 00 00 
0282   0907 00 00 00 00 
0282   090B 00 00 00 00 
0282   090F 00 00 00 00 
0282   0913 00 00 00 00 
0282   0917 00 00 00 00 
0282   091B 00 00 00 00 
0282   091F 00 00 00 00 
0282   0923 00 00 00 00 
0282   0927 00 00 00 00 
0282   092B 00 00 00 00 
0282   092F 00 00 00 00 
0282   0933 00 00 00 00 
0282   0937 00 00 00 00 
0282   093B 00 00 00 00 
0282   093F 00 00 00 00 
0282   0943 00 00 00 00 
0282   0947 00 00 00 00 
0282   094B 00 00 00 00 
0282   094F 00 00 00 00 
0282   0953 00 00 00 00 
0283   0957 00 00       parser_index:     .dw 0
0284   0959             
0285   0959 00 00 00 00 temp_data1:       .fill 512, 0
0285   095D 00 00 00 00 
0285   0961 00 00 00 00 
0285   0965 00 00 00 00 
0285   0969 00 00 00 00 
0285   096D 00 00 00 00 
0285   0971 00 00 00 00 
0285   0975 00 00 00 00 
0285   0979 00 00 00 00 
0285   097D 00 00 00 00 
0285   0981 00 00 00 00 
0285   0985 00 00 00 00 
0285   0989 00 00 00 00 
0285   098D 00 00 00 00 
0285   0991 00 00 00 00 
0285   0995 00 00 00 00 
0285   0999 00 00 00 00 
0285   099D 00 00 00 00 
0285   09A1 00 00 00 00 
0285   09A5 00 00 00 00 
0285   09A9 00 00 00 00 
0285   09AD 00 00 00 00 
0285   09B1 00 00 00 00 
0285   09B5 00 00 00 00 
0285   09B9 00 00 00 00 
0285   09BD 00 00 00 00 
0285   09C1 00 00 00 00 
0285   09C5 00 00 00 00 
0285   09C9 00 00 00 00 
0285   09CD 00 00 00 00 
0285   09D1 00 00 00 00 
0285   09D5 00 00 00 00 
0285   09D9 00 00 00 00 
0285   09DD 00 00 00 00 
0285   09E1 00 00 00 00 
0285   09E5 00 00 00 00 
0285   09E9 00 00 00 00 
0285   09ED 00 00 00 00 
0285   09F1 00 00 00 00 
0285   09F5 00 00 00 00 
0285   09F9 00 00 00 00 
0285   09FD 00 00 00 00 
0285   0A01 00 00 00 00 
0285   0A05 00 00 00 00 
0285   0A09 00 00 00 00 
0285   0A0D 00 00 00 00 
0285   0A11 00 00 00 00 
0285   0A15 00 00 00 00 
0285   0A19 00 00 00 00 
0285   0A1D 00 00 00 00 
0285   0A21 00 00 00 00 
0285   0A25 00 00 00 00 
0285   0A29 00 00 00 00 
0285   0A2D 00 00 00 00 
0285   0A31 00 00 00 00 
0285   0A35 00 00 00 00 
0285   0A39 00 00 00 00 
0285   0A3D 00 00 00 00 
0285   0A41 00 00 00 00 
0285   0A45 00 00 00 00 
0285   0A49 00 00 00 00 
0285   0A4D 00 00 00 00 
0285   0A51 00 00 00 00 
0285   0A55 00 00 00 00 
0285   0A59 00 00 00 00 
0285   0A5D 00 00 00 00 
0285   0A61 00 00 00 00 
0285   0A65 00 00 00 00 
0285   0A69 00 00 00 00 
0285   0A6D 00 00 00 00 
0285   0A71 00 00 00 00 
0285   0A75 00 00 00 00 
0285   0A79 00 00 00 00 
0285   0A7D 00 00 00 00 
0285   0A81 00 00 00 00 
0285   0A85 00 00 00 00 
0285   0A89 00 00 00 00 
0285   0A8D 00 00 00 00 
0285   0A91 00 00 00 00 
0285   0A95 00 00 00 00 
0285   0A99 00 00 00 00 
0285   0A9D 00 00 00 00 
0285   0AA1 00 00 00 00 
0285   0AA5 00 00 00 00 
0285   0AA9 00 00 00 00 
0285   0AAD 00 00 00 00 
0285   0AB1 00 00 00 00 
0285   0AB5 00 00 00 00 
0285   0AB9 00 00 00 00 
0285   0ABD 00 00 00 00 
0285   0AC1 00 00 00 00 
0285   0AC5 00 00 00 00 
0285   0AC9 00 00 00 00 
0285   0ACD 00 00 00 00 
0285   0AD1 00 00 00 00 
0285   0AD5 00 00 00 00 
0285   0AD9 00 00 00 00 
0285   0ADD 00 00 00 00 
0285   0AE1 00 00 00 00 
0285   0AE5 00 00 00 00 
0285   0AE9 00 00 00 00 
0285   0AED 00 00 00 00 
0285   0AF1 00 00 00 00 
0285   0AF5 00 00 00 00 
0285   0AF9 00 00 00 00 
0285   0AFD 00 00 00 00 
0285   0B01 00 00 00 00 
0285   0B05 00 00 00 00 
0285   0B09 00 00 00 00 
0285   0B0D 00 00 00 00 
0285   0B11 00 00 00 00 
0285   0B15 00 00 00 00 
0285   0B19 00 00 00 00 
0285   0B1D 00 00 00 00 
0285   0B21 00 00 00 00 
0285   0B25 00 00 00 00 
0285   0B29 00 00 00 00 
0285   0B2D 00 00 00 00 
0285   0B31 00 00 00 00 
0285   0B35 00 00 00 00 
0285   0B39 00 00 00 00 
0285   0B3D 00 00 00 00 
0285   0B41 00 00 00 00 
0285   0B45 00 00 00 00 
0285   0B49 00 00 00 00 
0285   0B4D 00 00 00 00 
0285   0B51 00 00 00 00 
0285   0B55 00 00 00 00 
0286   0B59 00 00 00 00 temp_data:        .fill 512, 0
0286   0B5D 00 00 00 00 
0286   0B61 00 00 00 00 
0286   0B65 00 00 00 00 
0286   0B69 00 00 00 00 
0286   0B6D 00 00 00 00 
0286   0B71 00 00 00 00 
0286   0B75 00 00 00 00 
0286   0B79 00 00 00 00 
0286   0B7D 00 00 00 00 
0286   0B81 00 00 00 00 
0286   0B85 00 00 00 00 
0286   0B89 00 00 00 00 
0286   0B8D 00 00 00 00 
0286   0B91 00 00 00 00 
0286   0B95 00 00 00 00 
0286   0B99 00 00 00 00 
0286   0B9D 00 00 00 00 
0286   0BA1 00 00 00 00 
0286   0BA5 00 00 00 00 
0286   0BA9 00 00 00 00 
0286   0BAD 00 00 00 00 
0286   0BB1 00 00 00 00 
0286   0BB5 00 00 00 00 
0286   0BB9 00 00 00 00 
0286   0BBD 00 00 00 00 
0286   0BC1 00 00 00 00 
0286   0BC5 00 00 00 00 
0286   0BC9 00 00 00 00 
0286   0BCD 00 00 00 00 
0286   0BD1 00 00 00 00 
0286   0BD5 00 00 00 00 
0286   0BD9 00 00 00 00 
0286   0BDD 00 00 00 00 
0286   0BE1 00 00 00 00 
0286   0BE5 00 00 00 00 
0286   0BE9 00 00 00 00 
0286   0BED 00 00 00 00 
0286   0BF1 00 00 00 00 
0286   0BF5 00 00 00 00 
0286   0BF9 00 00 00 00 
0286   0BFD 00 00 00 00 
0286   0C01 00 00 00 00 
0286   0C05 00 00 00 00 
0286   0C09 00 00 00 00 
0286   0C0D 00 00 00 00 
0286   0C11 00 00 00 00 
0286   0C15 00 00 00 00 
0286   0C19 00 00 00 00 
0286   0C1D 00 00 00 00 
0286   0C21 00 00 00 00 
0286   0C25 00 00 00 00 
0286   0C29 00 00 00 00 
0286   0C2D 00 00 00 00 
0286   0C31 00 00 00 00 
0286   0C35 00 00 00 00 
0286   0C39 00 00 00 00 
0286   0C3D 00 00 00 00 
0286   0C41 00 00 00 00 
0286   0C45 00 00 00 00 
0286   0C49 00 00 00 00 
0286   0C4D 00 00 00 00 
0286   0C51 00 00 00 00 
0286   0C55 00 00 00 00 
0286   0C59 00 00 00 00 
0286   0C5D 00 00 00 00 
0286   0C61 00 00 00 00 
0286   0C65 00 00 00 00 
0286   0C69 00 00 00 00 
0286   0C6D 00 00 00 00 
0286   0C71 00 00 00 00 
0286   0C75 00 00 00 00 
0286   0C79 00 00 00 00 
0286   0C7D 00 00 00 00 
0286   0C81 00 00 00 00 
0286   0C85 00 00 00 00 
0286   0C89 00 00 00 00 
0286   0C8D 00 00 00 00 
0286   0C91 00 00 00 00 
0286   0C95 00 00 00 00 
0286   0C99 00 00 00 00 
0286   0C9D 00 00 00 00 
0286   0CA1 00 00 00 00 
0286   0CA5 00 00 00 00 
0286   0CA9 00 00 00 00 
0286   0CAD 00 00 00 00 
0286   0CB1 00 00 00 00 
0286   0CB5 00 00 00 00 
0286   0CB9 00 00 00 00 
0286   0CBD 00 00 00 00 
0286   0CC1 00 00 00 00 
0286   0CC5 00 00 00 00 
0286   0CC9 00 00 00 00 
0286   0CCD 00 00 00 00 
0286   0CD1 00 00 00 00 
0286   0CD5 00 00 00 00 
0286   0CD9 00 00 00 00 
0286   0CDD 00 00 00 00 
0286   0CE1 00 00 00 00 
0286   0CE5 00 00 00 00 
0286   0CE9 00 00 00 00 
0286   0CED 00 00 00 00 
0286   0CF1 00 00 00 00 
0286   0CF5 00 00 00 00 
0286   0CF9 00 00 00 00 
0286   0CFD 00 00 00 00 
0286   0D01 00 00 00 00 
0286   0D05 00 00 00 00 
0286   0D09 00 00 00 00 
0286   0D0D 00 00 00 00 
0286   0D11 00 00 00 00 
0286   0D15 00 00 00 00 
0286   0D19 00 00 00 00 
0286   0D1D 00 00 00 00 
0286   0D21 00 00 00 00 
0286   0D25 00 00 00 00 
0286   0D29 00 00 00 00 
0286   0D2D 00 00 00 00 
0286   0D31 00 00 00 00 
0286   0D35 00 00 00 00 
0286   0D39 00 00 00 00 
0286   0D3D 00 00 00 00 
0286   0D41 00 00 00 00 
0286   0D45 00 00 00 00 
0286   0D49 00 00 00 00 
0286   0D4D 00 00 00 00 
0286   0D51 00 00 00 00 
0286   0D55 00 00 00 00 
0287   0D59             
0288   0D59             .include "lib/stdio.asm"
0001+  0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D59             ; stdio.s
0003+  0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D59             .include "lib/string.asm"
0001++ 0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0D59             ; string.s
0003++ 0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0D59             
0005++ 0D59             
0006++ 0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0D59             ; _strrev
0008++ 0D59             ; reverse a string
0009++ 0D59             ; D = string address
0010++ 0D59             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0D59             ; 01234
0012++ 0D59             _strrev:
0013++ 0D59 4B          	pusha
0014++ 0D5A 07 A0 0D    	call _strlen	; length in C
0015++ 0D5D 12          	mov a, c
0016++ 0D5E AF 01 00    	cmp a, 1
0017++ 0D61 D0 7B 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0D64 7D          	dec a
0019++ 0D65 FD 4E       	mov si, d	; beginning of string
0020++ 0D67 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0D69 59          	add d, a	; end of string
0022++ 0D6A 12          	mov a, c
0023++ 0D6B FD 9B       	shr a		; divide by 2
0024++ 0D6D 39          	mov c, a	; C now counts the steps
0025++ 0D6E             _strrev_L0:
0026++ 0D6E 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0D6F F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0D70 3E          	mov [d], al	; store left char into right side
0029++ 0D71 1B          	mov al, bl
0030++ 0D72 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 0D73 7E          	dec c
0032++ 0D74 7F          	dec d
0033++ 0D75 C2 00 00    	cmp c, 0
0034++ 0D78 C7 6E 0D    	jne _strrev_L0
0035++ 0D7B             _strrev_end:
0036++ 0D7B 4C          	popa
0037++ 0D7C 09          	ret
0038++ 0D7D             	
0039++ 0D7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0D7D             ; _strchr
0041++ 0D7D             ; search string in D for char in AL
0042++ 0D7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0D7D             _strchr:
0044++ 0D7D             _strchr_L0:
0045++ 0D7D 32          	mov bl, [d]
0046++ 0D7E C1 00       	cmp bl, 0
0047++ 0D80 C6 8B 0D    	je _strchr_end
0048++ 0D83 BA          	cmp al, bl
0049++ 0D84 C6 8B 0D    	je _strchr_end
0050++ 0D87 79          	inc d
0051++ 0D88 0A 7D 0D    	jmp _strchr_L0
0052++ 0D8B             _strchr_end:
0053++ 0D8B 1B          	mov al, bl
0054++ 0D8C 09          	ret
0055++ 0D8D             
0056++ 0D8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0D8D             ; _strstr
0058++ 0D8D             ; find sub-string
0059++ 0D8D             ; str1 in SI
0060++ 0D8D             ; str2 in DI
0061++ 0D8D             ; SI points to end of source string
0062++ 0D8D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0D8D             _strstr:
0064++ 0D8D DB          	push al
0065++ 0D8E DA          	push d
0066++ 0D8F E3          	push di
0067++ 0D90             _strstr_loop:
0068++ 0D90 F3          	cmpsb					; compare a byte of the strings
0069++ 0D91 C7 9C 0D    	jne _strstr_ret
0070++ 0D94 FC 00 00    	lea d, [di + 0]
0071++ 0D97 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0D99 C7 90 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0D9C             _strstr_ret:
0074++ 0D9C F0          	pop di
0075++ 0D9D E7          	pop d
0076++ 0D9E E8          	pop al
0077++ 0D9F 09          	ret
0078++ 0DA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0DA0             ; length of null terminated string
0080++ 0DA0             ; result in C
0081++ 0DA0             ; pointer in D
0082++ 0DA0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0DA0             _strlen:
0084++ 0DA0 DA          	push d
0085++ 0DA1 38 00 00    	mov c, 0
0086++ 0DA4             _strlen_L1:
0087++ 0DA4 BD 00       	cmp byte [d], 0
0088++ 0DA6 C6 AE 0D    	je _strlen_ret
0089++ 0DA9 79          	inc d
0090++ 0DAA 78          	inc c
0091++ 0DAB 0A A4 0D    	jmp _strlen_L1
0092++ 0DAE             _strlen_ret:
0093++ 0DAE E7          	pop d
0094++ 0DAF 09          	ret
0095++ 0DB0             
0096++ 0DB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0DB0             ; STRCMP
0098++ 0DB0             ; compare two strings
0099++ 0DB0             ; str1 in SI
0100++ 0DB0             ; str2 in DI
0101++ 0DB0             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0DB0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0DB0             _strcmp:
0104++ 0DB0 DB          	push al
0105++ 0DB1 DA          	push d
0106++ 0DB2 E3          	push di
0107++ 0DB3 E2          	push si
0108++ 0DB4             _strcmp_loop:
0109++ 0DB4 F3          	cmpsb					; compare a byte of the strings
0110++ 0DB5 C7 C0 0D    	jne _strcmp_ret
0111++ 0DB8 FB FF FF    	lea d, [si +- 1]
0112++ 0DBB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0DBD C7 B4 0D    	jne _strcmp_loop				; equal chars but not at end
0114++ 0DC0             _strcmp_ret:
0115++ 0DC0 EF          	pop si
0116++ 0DC1 F0          	pop di
0117++ 0DC2 E7          	pop d
0118++ 0DC3 E8          	pop al
0119++ 0DC4 09          	ret
0120++ 0DC5             
0121++ 0DC5             
0122++ 0DC5             ; STRCPY
0123++ 0DC5             ; copy null terminated string from SI to DI
0124++ 0DC5             ; source in SI
0125++ 0DC5             ; destination in DI
0126++ 0DC5             _strcpy:
0127++ 0DC5 E2          	push si
0128++ 0DC6 E3          	push di
0129++ 0DC7 DB          	push al
0130++ 0DC8             _strcpy_L1:
0131++ 0DC8 F6          	lodsb
0132++ 0DC9 F7          	stosb
0133++ 0DCA B9 00       	cmp al, 0
0134++ 0DCC C7 C8 0D    	jne _strcpy_L1
0135++ 0DCF             _strcpy_end:
0136++ 0DCF E8          	pop al
0137++ 0DD0 F0          	pop di
0138++ 0DD1 EF          	pop si
0139++ 0DD2 09          	ret
0140++ 0DD3             
0141++ 0DD3             ; STRCAT
0142++ 0DD3             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0DD3             ; source in SI
0144++ 0DD3             ; destination in DI
0145++ 0DD3             _strcat:
0146++ 0DD3 E2          	push si
0147++ 0DD4 E3          	push di
0148++ 0DD5 D7          	push a
0149++ 0DD6 DA          	push d
0150++ 0DD7 50          	mov a, di
0151++ 0DD8 3C          	mov d, a
0152++ 0DD9             _strcat_goto_end_L1:
0153++ 0DD9 BD 00       	cmp byte[d], 0
0154++ 0DDB C6 E2 0D    	je _strcat_start
0155++ 0DDE 79          	inc d
0156++ 0DDF 0A D9 0D    	jmp _strcat_goto_end_L1
0157++ 0DE2             _strcat_start:
0158++ 0DE2 FD 50       	mov di, d
0159++ 0DE4             _strcat_L1:
0160++ 0DE4 F6          	lodsb
0161++ 0DE5 F7          	stosb
0162++ 0DE6 B9 00       	cmp al, 0
0163++ 0DE8 C7 E4 0D    	jne _strcat_L1
0164++ 0DEB             _strcat_end:
0165++ 0DEB E7          	pop d
0166++ 0DEC E4          	pop a
0167++ 0DED F0          	pop di
0168++ 0DEE EF          	pop si
0169++ 0DEF 09          	ret
0170++ 0DF0             
0171++ 0DF0             
0005+  0DF0             
0006+  0DF0             
0007+  0DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0DF0             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0DF0             ; ASCII in BL
0010+  0DF0             ; result in AL
0011+  0DF0             ; ascii for F = 0100 0110
0012+  0DF0             ; ascii for 9 = 0011 1001
0013+  0DF0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0DF0             hex_ascii_encode:
0015+  0DF0 1B            mov al, bl
0016+  0DF1 93 40         test al, $40        ; test if letter or number
0017+  0DF3 C7 F9 0D      jnz hex_letter
0018+  0DF6 87 0F         and al, $0F        ; get number
0019+  0DF8 09            ret
0020+  0DF9             hex_letter:
0021+  0DF9 87 0F         and al, $0F        ; get letter
0022+  0DFB 6A 09         add al, 9
0023+  0DFD 09            ret
0024+  0DFE             
0025+  0DFE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0DFE             ; ATOI
0027+  0DFE             ; 2 letter hex string in B
0028+  0DFE             ; 8bit integer returned in AL
0029+  0DFE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0DFE             _atoi:
0031+  0DFE D8            push b
0032+  0DFF 07 F0 0D      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0E02 30            mov bl, bh
0034+  0E03 DB            push al          ; save a
0035+  0E04 07 F0 0D      call hex_ascii_encode
0036+  0E07 EA            pop bl  
0037+  0E08 FD 9E 04      shl al, 4
0038+  0E0B 8C            or al, bl
0039+  0E0C E5            pop b
0040+  0E0D 09            ret  
0041+  0E0E             
0042+  0E0E             
0043+  0E0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E0E             ; scanf
0045+  0E0E             ; no need for explanations!
0046+  0E0E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E0E             scanf:
0048+  0E0E 09            ret
0049+  0E0F             
0050+  0E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E0F             ; ITOA
0052+  0E0F             ; 8bit value in BL
0053+  0E0F             ; 2 byte ASCII result in A
0054+  0E0F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E0F             _itoa:
0056+  0E0F DA            push d
0057+  0E10 D8            push b
0058+  0E11 A7 00         mov bh, 0
0059+  0E13 FD A4 04      shr bl, 4  
0060+  0E16 74            mov d, b
0061+  0E17 1F A9 10      mov al, [d + s_hex_digits]
0062+  0E1A 23            mov ah, al
0063+  0E1B               
0064+  0E1B E5            pop b
0065+  0E1C D8            push b
0066+  0E1D A7 00         mov bh, 0
0067+  0E1F FD 87 0F      and bl, $0F
0068+  0E22 74            mov d, b
0069+  0E23 1F A9 10      mov al, [d + s_hex_digits]
0070+  0E26 E5            pop b
0071+  0E27 E7            pop d
0072+  0E28 09            ret
0073+  0E29             
0074+  0E29             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E29             ; HEX STRING TO BINARY
0076+  0E29             ; di = destination address
0077+  0E29             ; si = source
0078+  0E29             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E29             _hex_to_int:
0080+  0E29             _hex_to_int_L1:
0081+  0E29 F6            lodsb          ; load from [SI] to AL
0082+  0E2A B9 00         cmp al, 0        ; check if ASCII 0
0083+  0E2C C6 39 0E      jz _hex_to_int_ret
0084+  0E2F 36            mov bh, al
0085+  0E30 F6            lodsb
0086+  0E31 2F            mov bl, al
0087+  0E32 07 FE 0D      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0E35 F7            stosb          ; store AL to [DI]
0089+  0E36 0A 29 0E      jmp _hex_to_int_L1
0090+  0E39             _hex_to_int_ret:
0091+  0E39 09            ret    
0092+  0E3A             
0093+  0E3A             
0094+  0E3A             
0095+  0E3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E3A             ; GETCHAR
0097+  0E3A             ; char in ah
0098+  0E3A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E3A             getch:
0100+  0E3A DB            push al
0101+  0E3B             getch_retry:
0102+  0E3B 19 01         mov al, 1
0103+  0E3D 05 03         syscall sys_io      ; receive in AH
0104+  0E3F E8            pop al
0105+  0E40 09            ret
0106+  0E41             
0107+  0E41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E41             ; PUTCHAR
0109+  0E41             ; char in ah
0110+  0E41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E41             _putchar:
0112+  0E41 DB            push al
0113+  0E42 19 00         mov al, 0
0114+  0E44 05 03         syscall sys_io      ; char in AH
0115+  0E46 E8            pop al
0116+  0E47 09            ret
0117+  0E48             
0118+  0E48             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0E48             ;; INPUT A STRING
0120+  0E48             ;; terminates with null
0121+  0E48             ;; pointer in D
0122+  0E48             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0E48             _gets:
0124+  0E48 D7            push a
0125+  0E49 DA            push d
0126+  0E4A             _gets_loop:
0127+  0E4A 19 01         mov al, 1
0128+  0E4C 05 03         syscall sys_io      ; receive in AH
0129+  0E4E 76 1B         cmp ah, 27
0130+  0E50 C6 71 0E      je _gets_ansi_esc
0131+  0E53 76 0A         cmp ah, $0A        ; LF
0132+  0E55 C6 CD 0E      je _gets_end
0133+  0E58 76 0D         cmp ah, $0D        ; CR
0134+  0E5A C6 CD 0E      je _gets_end
0135+  0E5D 76 5C         cmp ah, $5C        ; '\\'
0136+  0E5F C6 93 0E      je _gets_escape
0137+  0E62 76 08         cmp ah, $08      ; check for backspace
0138+  0E64 C6 6D 0E      je _gets_backspace
0139+  0E67 1A            mov al, ah
0140+  0E68 3E            mov [d], al
0141+  0E69 79            inc d
0142+  0E6A 0A 4A 0E      jmp _gets_loop
0143+  0E6D             _gets_backspace:
0144+  0E6D 7F            dec d
0145+  0E6E 0A 4A 0E      jmp _gets_loop
0146+  0E71             _gets_ansi_esc:
0147+  0E71 19 01         mov al, 1
0148+  0E73 05 03         syscall sys_io        ; receive in AH without echo
0149+  0E75 76 5B         cmp ah, '['
0150+  0E77 C7 4A 0E      jne _gets_loop
0151+  0E7A 19 01         mov al, 1
0152+  0E7C 05 03         syscall sys_io          ; receive in AH without echo
0153+  0E7E 76 44         cmp ah, 'D'
0154+  0E80 C6 8B 0E      je _gets_left_arrow
0155+  0E83 76 43         cmp ah, 'C'
0156+  0E85 C6 8F 0E      je _gets_right_arrow
0157+  0E88 0A 4A 0E      jmp _gets_loop
0158+  0E8B             _gets_left_arrow:
0159+  0E8B 7F            dec d
0160+  0E8C 0A 4A 0E      jmp _gets_loop
0161+  0E8F             _gets_right_arrow:
0162+  0E8F 79            inc d
0163+  0E90 0A 4A 0E      jmp _gets_loop
0164+  0E93             _gets_escape:
0165+  0E93 19 01         mov al, 1
0166+  0E95 05 03         syscall sys_io      ; receive in AH
0167+  0E97 76 6E         cmp ah, 'n'
0168+  0E99 C6 B8 0E      je _gets_LF
0169+  0E9C 76 72         cmp ah, 'r'
0170+  0E9E C6 BF 0E      je _gets_CR
0171+  0EA1 76 30         cmp ah, '0'
0172+  0EA3 C6 C6 0E      je _gets_NULL
0173+  0EA6 76 5C         cmp ah, $5C  ; '\'
0174+  0EA8 C6 B1 0E      je _gets_slash
0175+  0EAB 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0EAC 3E            mov [d], al
0177+  0EAD 79            inc d
0178+  0EAE 0A 4A 0E      jmp _gets_loop
0179+  0EB1             _gets_slash:
0180+  0EB1 19 5C         mov al, $5C
0181+  0EB3 3E            mov [d], al
0182+  0EB4 79            inc d
0183+  0EB5 0A 4A 0E      jmp _gets_loop
0184+  0EB8             _gets_LF:
0185+  0EB8 19 0A         mov al, $0A
0186+  0EBA 3E            mov [d], al
0187+  0EBB 79            inc d
0188+  0EBC 0A 4A 0E      jmp _gets_loop
0189+  0EBF             _gets_CR:
0190+  0EBF 19 0D         mov al, $0D
0191+  0EC1 3E            mov [d], al
0192+  0EC2 79            inc d
0193+  0EC3 0A 4A 0E      jmp _gets_loop
0194+  0EC6             _gets_NULL:
0195+  0EC6 19 00         mov al, $00
0196+  0EC8 3E            mov [d], al
0197+  0EC9 79            inc d
0198+  0ECA 0A 4A 0E      jmp _gets_loop
0199+  0ECD             _gets_end:
0200+  0ECD 19 00         mov al, 0
0201+  0ECF 3E            mov [d], al        ; terminate string
0202+  0ED0 E7            pop d
0203+  0ED1 E4            pop a
0204+  0ED2 09            ret
0205+  0ED3             
0206+  0ED3             
0207+  0ED3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0ED3             ;; INPUT TEXT
0209+  0ED3             ;; terminated with CTRL+D
0210+  0ED3             ;; pointer in D
0211+  0ED3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0ED3             _gettxt:
0213+  0ED3 D7            push a
0214+  0ED4 DA            push d
0215+  0ED5             _gettxt_loop:
0216+  0ED5 19 01         mov al, 1
0217+  0ED7 05 03         syscall sys_io      ; receive in AH
0218+  0ED9 76 04         cmp ah, 4      ; EOT
0219+  0EDB C6 14 0F      je _gettxt_end
0220+  0EDE 76 08         cmp ah, $08      ; check for backspace
0221+  0EE0 C6 10 0F      je _gettxt_backspace
0222+  0EE3 76 5C         cmp ah, $5C        ; '\'
0223+  0EE5 C6 EE 0E      je _gettxt_escape
0224+  0EE8 1A            mov al, ah
0225+  0EE9 3E            mov [d], al
0226+  0EEA 79            inc d
0227+  0EEB 0A D5 0E      jmp _gettxt_loop
0228+  0EEE             _gettxt_escape:
0229+  0EEE 19 01         mov al, 1
0230+  0EF0 05 03         syscall sys_io      ; receive in AH
0231+  0EF2 76 6E         cmp ah, 'n'
0232+  0EF4 C6 02 0F      je _gettxt_LF
0233+  0EF7 76 72         cmp ah, 'r'
0234+  0EF9 C6 09 0F      je _gettxt_CR
0235+  0EFC 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0EFD 3E            mov [d], al
0237+  0EFE 79            inc d
0238+  0EFF 0A D5 0E      jmp _gettxt_loop
0239+  0F02             _gettxt_LF:
0240+  0F02 19 0A         mov al, $0A
0241+  0F04 3E            mov [d], al
0242+  0F05 79            inc d
0243+  0F06 0A D5 0E      jmp _gettxt_loop
0244+  0F09             _gettxt_CR:
0245+  0F09 19 0D         mov al, $0D
0246+  0F0B 3E            mov [d], al
0247+  0F0C 79            inc d
0248+  0F0D 0A D5 0E      jmp _gettxt_loop
0249+  0F10             _gettxt_backspace:
0250+  0F10 7F            dec d
0251+  0F11 0A D5 0E      jmp _gettxt_loop
0252+  0F14             _gettxt_end:
0253+  0F14 19 00         mov al, 0
0254+  0F16 3E            mov [d], al        ; terminate string
0255+  0F17 E7            pop d
0256+  0F18 E4            pop a
0257+  0F19 09            ret
0258+  0F1A             
0259+  0F1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0F1A             ; PRINT NEW LINE
0261+  0F1A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0F1A             printnl:
0263+  0F1A D7            push a
0264+  0F1B 10 00 0A      mov a, $0A00
0265+  0F1E 05 03         syscall sys_io
0266+  0F20 10 00 0D      mov a, $0D00
0267+  0F23 05 03         syscall sys_io
0268+  0F25 E4            pop a
0269+  0F26 09            ret
0270+  0F27             
0271+  0F27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0F27             ; _strtoint
0273+  0F27             ; 4 digit hex string number in d
0274+  0F27             ; integer returned in A
0275+  0F27             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F27             _strtointx:
0277+  0F27 D8            push b
0278+  0F28 32            mov bl, [d]
0279+  0F29 37            mov bh, bl
0280+  0F2A 33 01 00      mov bl, [d + 1]
0281+  0F2D 07 FE 0D      call _atoi        ; convert to int in AL
0282+  0F30 23            mov ah, al        ; move to AH
0283+  0F31 33 02 00      mov bl, [d + 2]
0284+  0F34 37            mov bh, bl
0285+  0F35 33 03 00      mov bl, [d + 3]
0286+  0F38 07 FE 0D      call _atoi        ; convert to int in AL
0287+  0F3B E5            pop b
0288+  0F3C 09            ret
0289+  0F3D             
0290+  0F3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0F3D             ; _strtoint
0292+  0F3D             ; 5 digit base10 string number in d
0293+  0F3D             ; integer returned in A
0294+  0F3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0F3D             _strtoint:
0296+  0F3D E2            push si
0297+  0F3E D8            push b
0298+  0F3F D9            push c
0299+  0F40 DA            push d
0300+  0F41 07 A0 0D      call _strlen      ; get string length in C
0301+  0F44 7E            dec c
0302+  0F45 FD 4E         mov si, d
0303+  0F47 12            mov a, c
0304+  0F48 FD 99         shl a
0305+  0F4A 3B C1 10      mov d, table_power
0306+  0F4D 59            add d, a
0307+  0F4E 38 00 00      mov c, 0
0308+  0F51             _strtoint_L0:
0309+  0F51 F6            lodsb      ; load ASCII to al
0310+  0F52 B9 00         cmp al, 0
0311+  0F54 C6 67 0F      je _strtoint_end
0312+  0F57 6F 30         sub al, $30    ; make into integer
0313+  0F59 22 00         mov ah, 0
0314+  0F5B 2A            mov b, [d]
0315+  0F5C AC            mul a, b      ; result in B since it fits in 16bits
0316+  0F5D 11            mov a, b
0317+  0F5E 28            mov b, c
0318+  0F5F 54            add a, b
0319+  0F60 39            mov c, a
0320+  0F61 63 02 00      sub d, 2
0321+  0F64 0A 51 0F      jmp _strtoint_L0
0322+  0F67             _strtoint_end:
0323+  0F67 12            mov a, c
0324+  0F68 E7            pop d
0325+  0F69 E6            pop c
0326+  0F6A E5            pop b
0327+  0F6B EF            pop si
0328+  0F6C 09            ret
0329+  0F6D             
0330+  0F6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0F6D             ; PRINT NULL TERMINATED STRING
0332+  0F6D             ; pointer in D
0333+  0F6D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0F6D             _puts:
0335+  0F6D D7            push a
0336+  0F6E DA            push d
0337+  0F6F             _puts_L1:
0338+  0F6F 1E            mov al, [d]
0339+  0F70 B9 00         cmp al, 0
0340+  0F72 C6 7E 0F      jz _puts_END
0341+  0F75 23            mov ah, al
0342+  0F76 19 00         mov al, 0
0343+  0F78 05 03         syscall sys_io
0344+  0F7A 79            inc d
0345+  0F7B 0A 6F 0F      jmp _puts_L1
0346+  0F7E             _puts_END:
0347+  0F7E E7            pop d
0348+  0F7F E4            pop a
0349+  0F80 09            ret
0350+  0F81             
0351+  0F81             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0F81             ; PRINT N SIZE STRING
0353+  0F81             ; pointer in D
0354+  0F81             ; size in C
0355+  0F81             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0F81             _putsn:
0357+  0F81 DB            push al
0358+  0F82 DA            push d
0359+  0F83 D9            push c
0360+  0F84             _putsn_L0:
0361+  0F84 1E            mov al, [d]
0362+  0F85 23            mov ah, al
0363+  0F86 19 00         mov al, 0
0364+  0F88 05 03         syscall sys_io
0365+  0F8A 79            inc d
0366+  0F8B 7E            dec c  
0367+  0F8C C2 00 00      cmp c, 0
0368+  0F8F C7 84 0F      jne _putsn_L0
0369+  0F92             _putsn_end:
0370+  0F92 E6            pop c
0371+  0F93 E7            pop d
0372+  0F94 E8            pop al
0373+  0F95 09            ret
0374+  0F96             
0375+  0F96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0F96             ; print 16bit decimal number
0377+  0F96             ; input number in A
0378+  0F96             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0F96             print_u16d:
0380+  0F96 D7            push a
0381+  0F97 D8            push b
0382+  0F98 FD D8         push g
0383+  0F9A 26 10 27      mov b, 10000
0384+  0F9D AE            div a, b      ; get 10000's coeff.
0385+  0F9E 07 C2 0F      call print_number
0386+  0FA1 11            mov a, b
0387+  0FA2 26 E8 03      mov b, 1000
0388+  0FA5 AE            div a, b      ; get 1000's coeff.
0389+  0FA6 07 C2 0F      call print_number
0390+  0FA9 11            mov a, b
0391+  0FAA 26 64 00      mov b, 100
0392+  0FAD AE            div a, b
0393+  0FAE 07 C2 0F      call print_number
0394+  0FB1 11            mov a, b
0395+  0FB2 26 0A 00      mov b, 10
0396+  0FB5 AE            div a, b
0397+  0FB6 07 C2 0F      call print_number
0398+  0FB9 1B            mov al, bl      ; 1's coeff in bl
0399+  0FBA 07 C2 0F      call print_number
0400+  0FBD FD F1         pop g
0401+  0FBF E5            pop b
0402+  0FC0 E4            pop a
0403+  0FC1 09            ret
0404+  0FC2             
0405+  0FC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0FC2             ; print AL
0407+  0FC2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0FC2             print_number:
0409+  0FC2 6A 30         add al, $30
0410+  0FC4 23            mov ah, al
0411+  0FC5 07 41 0E      call _putchar
0412+  0FC8 09            ret
0413+  0FC9             
0414+  0FC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0FC9             ; PRINT 16BIT HEX INTEGER
0416+  0FC9             ; integer value in reg B
0417+  0FC9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0FC9             print_u16x:
0419+  0FC9 D7            push a
0420+  0FCA D8            push b
0421+  0FCB DD            push bl
0422+  0FCC 30            mov bl, bh
0423+  0FCD 07 0F 0E      call _itoa        ; convert bh to char in A
0424+  0FD0 2F            mov bl, al        ; save al
0425+  0FD1 19 00         mov al, 0
0426+  0FD3 05 03         syscall sys_io        ; display AH
0427+  0FD5 24            mov ah, bl        ; retrieve al
0428+  0FD6 19 00         mov al, 0
0429+  0FD8 05 03         syscall sys_io        ; display AL
0430+  0FDA             
0431+  0FDA EA            pop bl
0432+  0FDB 07 0F 0E      call _itoa        ; convert bh to char in A
0433+  0FDE 2F            mov bl, al        ; save al
0434+  0FDF 19 00         mov al, 0
0435+  0FE1 05 03         syscall sys_io        ; display AH
0436+  0FE3 24            mov ah, bl        ; retrieve al
0437+  0FE4 19 00         mov al, 0
0438+  0FE6 05 03         syscall sys_io        ; display AL
0439+  0FE8             
0440+  0FE8 E5            pop b
0441+  0FE9 E4            pop a
0442+  0FEA 09            ret
0443+  0FEB             
0444+  0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0FEB             ; INPUT 16BIT HEX INTEGER
0446+  0FEB             ; read 16bit integer into A
0447+  0FEB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0FEB             scan_u16x:
0449+  0FEB F8 10 00      enter 16
0450+  0FEE D8            push b
0451+  0FEF DA            push d
0452+  0FF0             
0453+  0FF0 FA F1 FF      lea d, [bp + -15]
0454+  0FF3 07 48 0E      call _gets        ; get number
0455+  0FF6             
0456+  0FF6 32            mov bl, [d]
0457+  0FF7 37            mov bh, bl
0458+  0FF8 33 01 00      mov bl, [d + 1]
0459+  0FFB 07 FE 0D      call _atoi        ; convert to int in AL
0460+  0FFE 23            mov ah, al        ; move to AH
0461+  0FFF             
0462+  0FFF 33 02 00      mov bl, [d + 2]
0463+  1002 37            mov bh, bl
0464+  1003 33 03 00      mov bl, [d + 3]
0465+  1006 07 FE 0D      call _atoi        ; convert to int in AL
0466+  1009             
0467+  1009 E7            pop d
0468+  100A E5            pop b
0469+  100B F9            leave
0470+  100C 09            ret
0471+  100D             
0472+  100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  100D             ; PRINT 8bit HEX INTEGER
0474+  100D             ; integer value in reg bl
0475+  100D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  100D             print_u8x:
0477+  100D D7            push a
0478+  100E DD            push bl
0479+  100F             
0480+  100F 07 0F 0E      call _itoa        ; convert bl to char in A
0481+  1012 2F            mov bl, al        ; save al
0482+  1013 19 00         mov al, 0
0483+  1015 05 03         syscall sys_io        ; display AH
0484+  1017 24            mov ah, bl        ; retrieve al
0485+  1018 19 00         mov al, 0
0486+  101A 05 03         syscall sys_io        ; display AL
0487+  101C             
0488+  101C EA            pop bl
0489+  101D E4            pop a
0490+  101E 09            ret
0491+  101F             
0492+  101F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  101F             ; print 8bit decimal unsigned number
0494+  101F             ; input number in AL
0495+  101F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  101F             print_u8d:
0497+  101F D7            push a
0498+  1020 D8            push b
0499+  1021 FD D8         push g
0500+  1023 22 00         mov ah, 0
0501+  1025 26 64 00      mov b, 100
0502+  1028 AE            div a, b
0503+  1029 D8            push b      ; save remainder
0504+  102A B9 00         cmp al, 0
0505+  102C C6 36 10      je skip100
0506+  102F 6A 30         add al, $30
0507+  1031 23            mov ah, al
0508+  1032 19 00         mov al, 0
0509+  1034 05 03         syscall sys_io  ; print coeff
0510+  1036             skip100:
0511+  1036 E4            pop a
0512+  1037 22 00         mov ah, 0
0513+  1039 26 0A 00      mov b, 10
0514+  103C AE            div a, b
0515+  103D D8            push b      ; save remainder
0516+  103E B9 00         cmp al, 0
0517+  1040 C6 4A 10      je skip10
0518+  1043 6A 30         add al, $30
0519+  1045 23            mov ah, al
0520+  1046 19 00         mov al, 0
0521+  1048 05 03         syscall sys_io  ; print coeff
0522+  104A             skip10:
0523+  104A E4            pop a
0524+  104B 1B            mov al, bl
0525+  104C 6A 30         add al, $30
0526+  104E 23            mov ah, al
0527+  104F 19 00         mov al, 0
0528+  1051 05 03         syscall sys_io  ; print coeff
0529+  1053 FD F1         pop g
0530+  1055 E5            pop b
0531+  1056 E4            pop a
0532+  1057 09            ret
0533+  1058             
0534+  1058             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1058             ; INPUT 8BIT HEX INTEGER
0536+  1058             ; read 8bit integer into AL
0537+  1058             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1058             scan_u8x:
0539+  1058 F8 04 00      enter 4
0540+  105B D8            push b
0541+  105C DA            push d
0542+  105D             
0543+  105D FA FD FF      lea d, [bp + -3]
0544+  1060 07 48 0E      call _gets        ; get number
0545+  1063             
0546+  1063 32            mov bl, [d]
0547+  1064 37            mov bh, bl
0548+  1065 33 01 00      mov bl, [d + 1]
0549+  1068 07 FE 0D      call _atoi        ; convert to int in AL
0550+  106B             
0551+  106B E7            pop d
0552+  106C E5            pop b
0553+  106D F9            leave
0554+  106E 09            ret
0555+  106F             
0556+  106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  106F             ; input decimal number
0558+  106F             ; result in A
0559+  106F             ; 655'\0'
0560+  106F             ; low--------high
0561+  106F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  106F             scan_u16d:
0563+  106F F8 08 00      enter 8
0564+  1072 E2            push si
0565+  1073 D8            push b
0566+  1074 D9            push c
0567+  1075 DA            push d
0568+  1076 FA F9 FF      lea d, [bp +- 7]
0569+  1079 07 48 0E      call _gets
0570+  107C 07 A0 0D      call _strlen      ; get string length in C
0571+  107F 7E            dec c
0572+  1080 FD 4E         mov si, d
0573+  1082 12            mov a, c
0574+  1083 FD 99         shl a
0575+  1085 3B C1 10      mov d, table_power
0576+  1088 59            add d, a
0577+  1089 38 00 00      mov c, 0
0578+  108C             mul_loop:
0579+  108C F6            lodsb      ; load ASCII to al
0580+  108D B9 00         cmp al, 0
0581+  108F C6 A2 10      je mul_exit
0582+  1092 6F 30         sub al, $30    ; make into integer
0583+  1094 22 00         mov ah, 0
0584+  1096 2A            mov b, [d]
0585+  1097 AC            mul a, b      ; result in B since it fits in 16bits
0586+  1098 11            mov a, b
0587+  1099 28            mov b, c
0588+  109A 54            add a, b
0589+  109B 39            mov c, a
0590+  109C 63 02 00      sub d, 2
0591+  109F 0A 8C 10      jmp mul_loop
0592+  10A2             mul_exit:
0593+  10A2 12            mov a, c
0594+  10A3 E7            pop d
0595+  10A4 E6            pop c
0596+  10A5 E5            pop b
0597+  10A6 EF            pop si
0598+  10A7 F9            leave
0599+  10A8 09            ret
0600+  10A9             
0601+  10A9             
0602+  10A9 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  10AD 34 35 36 37 
0602+  10B1 38 39 41 42 
0602+  10B5 43 44 45 46 
0603+  10B9 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  10BD 1B 5B 48 00 
0604+  10C1             
0605+  10C1             table_power:
0606+  10C1 01 00         .dw 1
0607+  10C3 0A 00         .dw 10
0608+  10C5 64 00         .dw 100
0609+  10C7 E8 03         .dw 1000
0610+  10C9 10 27         .dw 100000289   10CB             .include "lib/ctype.asm"
0001+  10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10CB             ; ctype.s
0003+  10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10CB             
0005+  10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  10CB             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  10CB             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  10CB             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  10CB             ;; characters are supported.
0010+  10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  10CB             ;; _isalnum 
0012+  10CB             ;; _isalpha 
0013+  10CB             ;; islower 
0014+  10CB             ;; isupper 
0015+  10CB             ;; _isdigit 
0016+  10CB             ;; isxdigit
0017+  10CB             ;; iscntrl 
0018+  10CB             ;; isgraph 
0019+  10CB             ;; _isspace 
0020+  10CB             ;; isblank 
0021+  10CB             ;; isprint 
0022+  10CB             ;; ispunct 
0023+  10CB             ;; tolower 
0024+  10CB             ;; toupper
0025+  10CB             
0026+  10CB             
0027+  10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  10CB             ;; IS ALPHANUMERIC
0029+  10CB             ;; sets ZF according with result
0030+  10CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  10CB             _isalnum:
0032+  10CB 07 E8 10    	call _isalpha
0033+  10CE C6 D4 10    	je _isalnum_exit
0034+  10D1 07 D5 10    	call _isdigit
0035+  10D4             _isalnum_exit:
0036+  10D4 09          	ret	
0037+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  10D5             ;; IS DIGIT
0039+  10D5             ;; sets ZF according with result
0040+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  10D5             _isdigit:
0042+  10D5 DB          	push al
0043+  10D6 B9 30       	cmp al, '0'
0044+  10D8 C8 E4 10    	jlu _isdigit_false
0045+  10DB B9 39       	cmp al, '9'
0046+  10DD D1 E4 10    	jgu _isdigit_false
0047+  10E0 87 00       	and al, 0	; set ZF
0048+  10E2 E8          	pop al
0049+  10E3 09          	ret
0050+  10E4             _isdigit_false:
0051+  10E4 8B 01       	or al, 1	; clear ZF
0052+  10E6 E8          	pop al
0053+  10E7 09          	ret	
0054+  10E8             	
0055+  10E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  10E8             ;; IS ALPHA
0057+  10E8             ;; sets ZF according with result
0058+  10E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  10E8             _isalpha:
0060+  10E8 DB          	push al
0061+  10E9 B9 5F       	cmp al, '_'
0062+  10EB C6 0B 11    	je _isalpha_true
0063+  10EE B9 2E       	cmp al, '.'
0064+  10F0 C6 0B 11    	je _isalpha_true
0065+  10F3 B9 41       	cmp al, 'A'
0066+  10F5 C8 07 11    	jlu _isalpha_false
0067+  10F8 B9 7A       	cmp al, 'z'
0068+  10FA D1 07 11    	jgu _isalpha_false
0069+  10FD B9 5A       	cmp al, 'Z'
0070+  10FF D0 0B 11    	jleu _isalpha_true
0071+  1102 B9 61       	cmp al, 'a'
0072+  1104 C9 0B 11    	jgeu _isalpha_true
0073+  1107             _isalpha_false:
0074+  1107 8B 01       	or al, 1	; clear ZF
0075+  1109 E8          	pop al
0076+  110A 09          	ret
0077+  110B             _isalpha_true:
0078+  110B 87 00       	and al, 0	; set ZF
0079+  110D E8          	pop al
0080+  110E 09          	ret
0081+  110F             
0082+  110F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  110F             ;; IS PATH-ALPHA
0084+  110F             ;; sets ZF according with result
0085+  110F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  110F             ispath:
0087+  110F DB          	push al
0088+  1110 07 D5 10    	call _isdigit
0089+  1113 C6 3D 11    	je ispath_true
0090+  1116 B9 5F       	cmp al, '_'
0091+  1118 C6 3D 11    	je ispath_true
0092+  111B B9 2F       	cmp al, '/'
0093+  111D C6 3D 11    	je ispath_true
0094+  1120 B9 2E       	cmp al, '.'
0095+  1122 C6 3D 11    	je ispath_true
0096+  1125 B9 41       	cmp al, 'A'
0097+  1127 C8 39 11    	jlu ispath_false
0098+  112A B9 7A       	cmp al, 'z'
0099+  112C D1 39 11    	jgu ispath_false
0100+  112F B9 5A       	cmp al, 'Z'
0101+  1131 D0 3D 11    	jleu ispath_true
0102+  1134 B9 61       	cmp al, 'a'
0103+  1136 C9 3D 11    	jgeu ispath_true
0104+  1139             ispath_false:
0105+  1139 8B 01       	or al, 1	; clear ZF
0106+  113B E8          	pop al
0107+  113C 09          	ret
0108+  113D             ispath_true:
0109+  113D 87 00       	and al, 0	; set ZF
0110+  113F E8          	pop al
0111+  1140 09          	ret
0112+  1141             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1141             ;; IS SPACE
0114+  1141             ;; sets ZF according with result
0115+  1141             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1141             _isspace:
0117+  1141 B9 20       	cmp al, $20		; ' '
0118+  1143 C6 57 11    	je _isspace_exit
0119+  1146 B9 09       	cmp al, $09		; '\t'
0120+  1148 C6 57 11    	je _isspace_exit
0121+  114B B9 0A       	cmp al, $0A		; '\n'
0122+  114D C6 57 11    	je _isspace_exit
0123+  1150 B9 0D       	cmp al, $0D		; '\r'
0124+  1152 C6 57 11    	je _isspace_exit
0125+  1155 B9 0B       	cmp al, $0B		; '\v'
0126+  1157             _isspace_exit:
0127+  1157 09          	ret	
0128+  1158             
0129+  1158             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1158             ; TO LOWER
0131+  1158             ; input in AL
0132+  1158             ; output in AL
0133+  1158             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1158             _to_lower:
0135+  1158 B9 5A       	cmp al, 'Z'
0136+  115A D1 5F 11    	jgu _to_lower_ret
0137+  115D 6A 20       	add al, $20				; convert to lower case
0138+  115F             _to_lower_ret:
0139+  115F 09          	ret
0140+  1160             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1160             ; TO UPPER
0142+  1160             ; input in AL
0143+  1160             ; output in AL
0144+  1160             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1160             _to_upper:
0146+  1160 B9 61       	cmp al, 'a'
0147+  1162 C8 67 11    	jlu _to_upper_ret
0148+  1165 6F 20       	sub al, $20			; convert to upper case
0149+  1167             _to_upper_ret:
0150+  1167 09          	ret
0151+  1168             
0290   1168             .include "lib/token.asm"
0001+  1168             TOKTYP_IDENTIFIER  .equ 0
0002+  1168             TOKTYP_KEYWORD     .equ 1
0003+  1168             TOKTYP_DELIMITER   .equ 2
0004+  1168             TOKTYP_STRING      .equ 3
0005+  1168             TOKTYP_CHAR        .equ 4
0006+  1168             TOKTYP_NUMERIC     .equ 5
0007+  1168             TOKTYP_END         .equ 6
0008+  1168             
0009+  1168             TOK_NULL           .equ 0
0010+  1168             TOK_FSLASH         .equ 1
0011+  1168             TOK_TIMES          .equ 2
0012+  1168             TOK_PLUS           .equ 3
0013+  1168             TOK_MINUS          .equ 4
0014+  1168             TOK_DOT            .equ 5
0015+  1168             TOK_SEMI           .equ 6
0016+  1168             TOK_ANGLE          .equ 7
0017+  1168             TOK_TILDE          .equ 8
0018+  1168             TOK_EQUAL          .equ 9
0019+  1168             TOK_COLON          .equ 10
0020+  1168             TOK_COMMA          .equ 11
0021+  1168             
0022+  1168             TOK_END            .equ 20
0023+  1168             
0024+  1168             
0025+  1168             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1168             ;; read a full command argment from shell input buffer
0027+  1168             ;; argument is written into tokstr
0028+  1168             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1168             get_arg:
0030+  1168 D7            push a
0031+  1169 E2            push si
0032+  116A E3            push di
0033+  116B 19 00         mov al, 0
0034+  116D 3D 96 13      mov [tokstr], al      ; nullify tokstr string
0035+  1170 14 92 13      mov a, [prog]
0036+  1173 4D            mov si, a
0037+  1174 FD 4F 96 13   mov di, tokstr
0038+  1178             get_arg_skip_spaces:
0039+  1178 F6            lodsb
0040+  1179 07 41 11      call _isspace
0041+  117C C6 78 11      je get_arg_skip_spaces
0042+  117F             get_arg_L0:
0043+  117F B9 3B         cmp al, $3B        ; check if is ';'
0044+  1181 C6 8E 11      je get_arg_end
0045+  1184 B9 00         cmp al, 0
0046+  1186 C6 8E 11      je get_arg_end      ; check if end of input
0047+  1189 F7            stosb
0048+  118A F6            lodsb
0049+  118B 0A 7F 11      jmp get_arg_L0
0050+  118E             get_arg_end:
0051+  118E 19 00         mov al, 0
0052+  1190 F7            stosb
0053+  1191 D5 01 00      sub si, 1
0054+  1194 4E            mov a, si
0055+  1195 42 92 13      mov [prog], a    ; update pointer
0056+  1198 F0            pop di
0057+  1199 EF            pop si
0058+  119A E4            pop a
0059+  119B 09            ret
0060+  119C             
0061+  119C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  119C             ;; read a path formation from shell input buffer
0063+  119C             ;; path is written into tokstr
0064+  119C             ;; /usr/bin
0065+  119C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  119C             get_path:
0067+  119C D7            push a
0068+  119D E2            push si
0069+  119E E3            push di
0070+  119F 19 00         mov al, 0
0071+  11A1 3D 96 13      mov [tokstr], al      ; nullify tokstr string
0072+  11A4 14 92 13      mov a, [prog]
0073+  11A7 4D            mov si, a
0074+  11A8 FD 4F 96 13   mov di, tokstr
0075+  11AC             get_path_skip_spaces:
0076+  11AC F6            lodsb
0077+  11AD 07 41 11      call _isspace
0078+  11B0 C6 AC 11      je get_path_skip_spaces
0079+  11B3             get_path_is_pathchar:
0080+  11B3 F7            stosb
0081+  11B4 F6            lodsb
0082+  11B5 07 CB 10      call _isalnum      ;check if is alphanumeric
0083+  11B8 C6 B3 11      je get_path_is_pathchar
0084+  11BB B9 2F         cmp al, '/'        ; check if is '/'
0085+  11BD C6 B3 11      je get_path_is_pathchar
0086+  11C0 19 00         mov al, 0
0087+  11C2 F7            stosb
0088+  11C3 D5 01 00      sub si, 1
0089+  11C6 4E            mov a, si
0090+  11C7 42 92 13      mov [prog], a    ; update pointer
0091+  11CA             get_path_end:
0092+  11CA F0            pop di
0093+  11CB EF            pop si
0094+  11CC E4            pop a
0095+  11CD 09            ret
0096+  11CE             
0097+  11CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  11CE             ;; read a line
0099+  11CE             ;; line is written into tokstr
0100+  11CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  11CE             get_line:
0102+  11CE D7            push a
0103+  11CF E2            push si
0104+  11D0 E3            push di
0105+  11D1 19 00         mov al, 0
0106+  11D3 3D 96 13      mov [tokstr], al      ; nullify tokstr string
0107+  11D6 14 92 13      mov a, [prog]
0108+  11D9 4D            mov si, a
0109+  11DA FD 4F 96 13   mov di, tokstr
0110+  11DE             get_line_L0:
0111+  11DE F6            lodsb
0112+  11DF B9 0A         cmp al, $0A    ; check for new line
0113+  11E1 C6 E8 11      je get_line_exit
0114+  11E4 F7            stosb
0115+  11E5 0A DE 11      jmp get_line_L0
0116+  11E8             get_line_exit:
0117+  11E8 19 00         mov al, 0
0118+  11EA F7            stosb
0119+  11EB 4E            mov a, si
0120+  11EC 42 92 13      mov [prog], a    ; update pointer
0121+  11EF F0            pop di
0122+  11F0 EF            pop si
0123+  11F1 E4            pop a
0124+  11F2 09            ret
0125+  11F3             
0126+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  11F3             ;; token parser
0128+  11F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  11F3             get_token:
0130+  11F3 D7            push a
0131+  11F4 DA            push d
0132+  11F5 E2            push si
0133+  11F6 E3            push di
0134+  11F7 19 00         mov al, 0
0135+  11F9 3D 96 13      mov [tokstr], al      ; nullify tokstr string
0136+  11FC 19 00         mov al, TOK_NULL
0137+  11FE 3D 95 13      mov [tok], al        ; nullify token
0138+  1201 14 92 13      mov a, [prog]
0139+  1204 4D            mov si, a
0140+  1205 FD 4F 96 13   mov di, tokstr
0141+  1209             get_tok_skip_spaces:
0142+  1209 F6            lodsb
0143+  120A 07 41 11      call _isspace
0144+  120D C6 09 12      je get_tok_skip_spaces
0145+  1210 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  1212 C6 F7 12      je get_token_end
0147+  1215 B9 23         cmp al, '#'      ; comments!
0148+  1217 C6 25 13      je get_tok_comment
0149+  121A 07 CB 10      call _isalnum
0150+  121D C6 04 13      jz is_alphanumeric
0151+  1220             ; other token types
0152+  1220             get_token_slash:
0153+  1220 B9 2F         cmp al, '/'        ; check if '/'
0154+  1222 C7 3A 12      jne get_token_minus
0155+  1225 F7            stosb          ; store '/' into token string
0156+  1226 19 00         mov al, 0
0157+  1228 F7            stosb          ; terminate token string
0158+  1229 19 01         mov al, TOK_FSLASH
0159+  122B 3D 95 13      mov [tok], al      
0160+  122E 19 02         mov al, TOKTYP_DELIMITER
0161+  1230 3D 94 13      mov [toktyp], al
0162+  1233 4E            mov a, si
0163+  1234 42 92 13      mov [prog], a    ; update pointer
0164+  1237 0A 20 13      jmp get_token_return
0165+  123A             get_token_minus:
0166+  123A B9 2D         cmp al, '-'        ; check if '-'
0167+  123C C7 54 12      jne get_token_comma
0168+  123F F7            stosb          ; store '-' into token string
0169+  1240 19 00         mov al, 0
0170+  1242 F7            stosb          ; terminate token string
0171+  1243 19 04         mov al, TOK_MINUS
0172+  1245 3D 95 13      mov [tok], al      
0173+  1248 19 02         mov al, TOKTYP_DELIMITER
0174+  124A 3D 94 13      mov [toktyp], al
0175+  124D 4E            mov a, si
0176+  124E 42 92 13      mov [prog], a    ; update pointer
0177+  1251 0A 20 13      jmp get_token_return
0178+  1254             get_token_comma:
0179+  1254 B9 2C         cmp al, ','        ; check if ','
0180+  1256 C7 6E 12      jne get_token_semi
0181+  1259 F7            stosb          ; store ',' into token string
0182+  125A 19 00         mov al, 0
0183+  125C F7            stosb          ; terminate token string
0184+  125D 19 0B         mov al, TOK_COMMA
0185+  125F 3D 95 13      mov [tok], al      
0186+  1262 19 02         mov al, TOKTYP_DELIMITER
0187+  1264 3D 94 13      mov [toktyp], al
0188+  1267 4E            mov a, si
0189+  1268 42 92 13      mov [prog], a    ; update pointer
0190+  126B 0A 20 13      jmp get_token_return
0191+  126E             get_token_semi:
0192+  126E B9 3B         cmp al, $3B        ; check if ';'
0193+  1270 C7 88 12      jne get_token_colon
0194+  1273 F7            stosb          ; store ';' into token string
0195+  1274 19 00         mov al, 0
0196+  1276 F7            stosb          ; terminate token string
0197+  1277 19 06         mov al, TOK_SEMI
0198+  1279 3D 95 13      mov [tok], al      
0199+  127C 19 02         mov al, TOKTYP_DELIMITER
0200+  127E 3D 94 13      mov [toktyp], al
0201+  1281 4E            mov a, si
0202+  1282 42 92 13      mov [prog], a    ; update pointer
0203+  1285 0A 20 13      jmp get_token_return
0204+  1288             get_token_colon:
0205+  1288 B9 3A         cmp al, $3A        ; check if ':'
0206+  128A C7 A2 12      jne get_token_angle
0207+  128D F7            stosb          ; store ':' into token string
0208+  128E 19 00         mov al, 0
0209+  1290 F7            stosb          ; terminate token string
0210+  1291 19 0A         mov al, TOK_COLON
0211+  1293 3D 95 13      mov [tok], al      
0212+  1296 19 02         mov al, TOKTYP_DELIMITER
0213+  1298 3D 94 13      mov [toktyp], al
0214+  129B 4E            mov a, si
0215+  129C 42 92 13      mov [prog], a    ; update pointer
0216+  129F 0A 20 13      jmp get_token_return
0217+  12A2             get_token_angle:
0218+  12A2 B9 3E         cmp al, $3E        ; check if '>'
0219+  12A4 C7 BC 12      jne get_token_tilde
0220+  12A7 F7            stosb          ; store '>' into token string
0221+  12A8 19 00         mov al, 0
0222+  12AA F7            stosb          ; terminate token string
0223+  12AB 19 07         mov al, TOK_ANGLE
0224+  12AD 3D 95 13      mov [tok], al      
0225+  12B0 19 02         mov al, TOKTYP_DELIMITER
0226+  12B2 3D 94 13      mov [toktyp], al
0227+  12B5 4E            mov a, si
0228+  12B6 42 92 13      mov [prog], a    ; update pointer
0229+  12B9 0A 20 13      jmp get_token_return
0230+  12BC             get_token_tilde:
0231+  12BC B9 7E         cmp al, '~'        ; check if '~'
0232+  12BE C7 D6 12      jne get_token_equal
0233+  12C1 F7            stosb          ; store '~' into token string
0234+  12C2 19 00         mov al, 0
0235+  12C4 F7            stosb          ; terminate token string
0236+  12C5 19 08         mov al, TOK_TILDE
0237+  12C7 3D 95 13      mov [tok], al      
0238+  12CA 19 02         mov al, TOKTYP_DELIMITER
0239+  12CC 3D 94 13      mov [toktyp], al
0240+  12CF 4E            mov a, si
0241+  12D0 42 92 13      mov [prog], a    ; update pointer
0242+  12D3 0A 20 13      jmp get_token_return
0243+  12D6             get_token_equal:
0244+  12D6 B9 3D         cmp al, '='        ; check if '='
0245+  12D8 C7 F0 12      jne get_token_skip
0246+  12DB F7            stosb          ; store '=' into token string
0247+  12DC 19 00         mov al, 0
0248+  12DE F7            stosb          ; terminate token string
0249+  12DF 19 09         mov al, TOK_EQUAL
0250+  12E1 3D 95 13      mov [tok], al      
0251+  12E4 19 02         mov al, TOKTYP_DELIMITER
0252+  12E6 3D 94 13      mov [toktyp], al
0253+  12E9 4E            mov a, si
0254+  12EA 42 92 13      mov [prog], a    ; update pointer
0255+  12ED 0A 20 13      jmp get_token_return
0256+  12F0             get_token_skip:
0257+  12F0 4E            mov a, si
0258+  12F1 42 92 13      mov [prog], a    ; update pointer
0259+  12F4 0A 20 13      jmp get_token_return
0260+  12F7             get_token_end:        ; end of file token
0261+  12F7 19 14         mov al, TOK_END
0262+  12F9 3D 95 13      mov [tok], al
0263+  12FC 19 06         mov al, TOKTYP_END
0264+  12FE 3D 94 13      mov [toktyp], al
0265+  1301 0A 20 13      jmp get_token_return
0266+  1304             is_alphanumeric:
0267+  1304 F7            stosb
0268+  1305 F6            lodsb
0269+  1306 07 CB 10      call _isalnum      ;check if is alphanumeric
0270+  1309 C6 04 13      jz is_alphanumeric
0271+  130C B9 2E         cmp al, $2E        ; check if is '.'
0272+  130E C6 04 13      je is_alphanumeric
0273+  1311 19 00         mov al, 0
0274+  1313 F7            stosb
0275+  1314 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1316 3D 94 13      mov [toktyp], al
0277+  1319 D5 01 00      sub si, 1
0278+  131C 4E            mov a, si
0279+  131D 42 92 13      mov [prog], a    ; update pointer
0280+  1320             get_token_return:
0281+  1320 F0            pop di
0282+  1321 EF            pop si
0283+  1322 E7            pop d
0284+  1323 E4            pop a
0285+  1324 09            ret
0286+  1325             get_tok_comment:
0287+  1325 F6            lodsb
0288+  1326 B9 0A         cmp al, $0A      ; new line
0289+  1328 C7 25 13      jne get_tok_comment
0290+  132B 0A 09 12      jmp get_tok_skip_spaces
0291+  132E             
0292+  132E             
0293+  132E             get_number:
0294+  132E D7            push a
0295+  132F DA            push d
0296+  1330 E2            push si
0297+  1331 E3            push di
0298+  1332 19 00         mov al, 0
0299+  1334 3D 96 13      mov [tokstr], al      ; nullify tokstr string
0300+  1337 19 00         mov al, TOK_NULL
0301+  1339 3D 95 13      mov [tok], al        ; nullify token
0302+  133C 14 92 13      mov a, [prog]
0303+  133F 4D            mov si, a
0304+  1340 FD 4F 96 13   mov di, tokstr
0305+  1344             get_number_skip_spaces:
0306+  1344 F6            lodsb
0307+  1345 07 41 11      call _isspace
0308+  1348 C6 44 13      je get_number_skip_spaces
0309+  134B B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  134D C7 5D 13      jne get_number_L0
0311+  1350 19 14         mov al, TOK_END
0312+  1352 3D 95 13      mov [tok], al
0313+  1355 19 06         mov al, TOKTYP_END
0314+  1357 3D 94 13      mov [toktyp], al
0315+  135A 0A 74 13      jmp get_number_return
0316+  135D             get_number_L0:
0317+  135D F7            stosb
0318+  135E F6            lodsb
0319+  135F 07 D5 10      call _isdigit      ;check if is numeric
0320+  1362 C6 5D 13      jz get_number_L0
0321+  1365 19 00         mov al, 0
0322+  1367 F7            stosb
0323+  1368 19 05         mov al, TOKTYP_NUMERIC
0324+  136A 3D 94 13      mov [toktyp], al
0325+  136D D5 01 00      sub si, 1
0326+  1370 4E            mov a, si
0327+  1371 42 92 13      mov [prog], a    ; update pointer
0328+  1374             get_number_return:
0329+  1374 F0            pop di
0330+  1375 EF            pop si
0331+  1376 E7            pop d
0332+  1377 E4            pop a
0333+  1378 09            ret
0334+  1379             
0335+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1379             ;; PUT BACK TOKEN
0337+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1379             _putback:
0339+  1379 D7            push a
0340+  137A E2            push si
0341+  137B FD 4D 96 13   mov si, tokstr  
0342+  137F             _putback_loop:
0343+  137F F6            lodsb
0344+  1380 B9 00         cmp al, 0
0345+  1382 C6 8F 13      je _putback_end
0346+  1385 14 92 13      mov a, [prog]
0347+  1388 7D            dec a
0348+  1389 42 92 13      mov [prog], a      ; update pointer
0349+  138C 0A 7F 13      jmp _putback_loop
0350+  138F             _putback_end:
0351+  138F EF            pop si
0352+  1390 E4            pop a
0353+  1391 09            ret
0354+  1392             
0355+  1392             
0356+  1392             
0357+  1392             
0358+  1392 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1394             
0360+  1394 00          toktyp:    .db 0          ; token type symbol
0361+  1395 00          tok:       .db 0          ; current token symbol
0362+  1396 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  139A 00 00 00 00 
0362+  139E 00 00 00 00 
0362+  13A2 00 00 00 00 
0362+  13A6 00 00 00 00 
0362+  13AA 00 00 00 00 
0362+  13AE 00 00 00 00 
0362+  13B2 00 00 00 00 
0362+  13B6 00 00 00 00 
0362+  13BA 00 00 00 00 
0362+  13BE 00 00 00 00 
0362+  13C2 00 00 00 00 
0362+  13C6 00 00 00 00 
0362+  13CA 00 00 00 00 
0362+  13CE 00 00 00 00 
0362+  13D2 00 00 00 00 
0362+  13D6 00 00 00 00 
0362+  13DA 00 00 00 00 
0362+  13DE 00 00 00 00 
0362+  13E2 00 00 00 00 
0362+  13E6 00 00 00 00 
0362+  13EA 00 00 00 00 
0362+  13EE 00 00 00 00 
0362+  13F2 00 00 00 00 
0362+  13F6 00 00 00 00 
0362+  13FA 00 00 00 00 
0362+  13FE 00 00 00 00 
0362+  1402 00 00 00 00 
0362+  1406 00 00 00 00 
0362+  140A 00 00 00 00 
0362+  140E 00 00 00 00 
0362+  1412 00 00 00 00 
0362+  1416 00 00 00 00 
0362+  141A 00 00 00 00 
0362+  141E 00 00 00 00 
0362+  1422 00 00 00 00 
0362+  1426 00 00 00 00 
0362+  142A 00 00 00 00 
0362+  142E 00 00 00 00 
0362+  1432 00 00 00 00 
0362+  1436 00 00 00 00 
0362+  143A 00 00 00 00 
0362+  143E 00 00 00 00 
0362+  1442 00 00 00 00 
0362+  1446 00 00 00 00 
0362+  144A 00 00 00 00 
0362+  144E 00 00 00 00 
0362+  1452 00 00 00 00 
0362+  1456 00 00 00 00 
0362+  145A 00 00 00 00 
0362+  145E 00 00 00 00 
0362+  1462 00 00 00 00 
0362+  1466 00 00 00 00 
0362+  146A 00 00 00 00 
0362+  146E 00 00 00 00 
0362+  1472 00 00 00 00 
0362+  1476 00 00 00 00 
0362+  147A 00 00 00 00 
0362+  147E 00 00 00 00 
0362+  1482 00 00 00 00 
0362+  1486 00 00 00 00 
0362+  148A 00 00 00 00 
0362+  148E 00 00 00 00 
0362+  1492 00 00 00 00 
0291   1496             
0292   1496             shell_transient_area:  ; shell transient data area
0293   1496             
0294   1496             .end
tasm: Number of errors = 0
