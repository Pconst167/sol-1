0001   0000             .include "lib/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             text_org         .EQU  $0400
0002   0000             
0003   0000             stack_begin:  .equ $f7ff  ; beginning of stack
0004   0000             
0005   0400             .org text_org      ; origin at 1024
0006   0400             
0007   0400             shell_main:  
0008   0400 FD 49 FF F7   mov bp, stack_begin
0009   0404 FD 47 FF F7   mov sp, stack_begin
0010   0408             
0011   0408             ; open config file
0012   0408             ; example: path=/usr/bin;
0013   0408             ; read path config entry
0014   0408 3B 14 07      mov d, s_etc_config   ; '/etc/shell.cfg'
0015   040B FD 4D 28 07   mov si, s_path        ; config entry name is "path"
0016   040F FD 4F 86 06   mov di, path          ; config value destination is the var that holds the path variable
0017   0413 07 B6 04      call read_config
0018   0416 3B 86 06      mov d, path
0019   0419 07 69 0F      call _puts
0020   041C             
0021   041C             ; open config file
0022   041C             ; read home directory config entry
0023   041C 3B 14 07      mov d, s_etc_config     ; '/etc/shell.cfg'
0024   041F FD 4D 23 07   mov si, s_home          ; config entry name is "home"
0025   0423 FD 4F 06 06   mov di, homedir         ; config value destination is the var that holds the home directory path
0026   0427 07 B6 04      call read_config  
0027   042A             
0028   042A 07 16 0F      call printnl
0029   042D             
0030   042D 10 06 07      mov a, s_etc_shellrc
0031   0430 42 8E 13      mov [prog], a
0032   0433 07 FF 04      call cmd_shell
0033   0436             
0034   0436             shell_l0:
0035   0436 3B 4B 07      mov d, s_sol1
0036   0439 07 69 0F      call _puts
0037   043C 19 12         mov al, 18
0038   043E 05 04         syscall sys_filesystem        ; print current path
0039   0440 3B 45 07      mov d, s_hash
0040   0443 07 69 0F      call _puts
0041   0446 3B 53 07      mov d, shell_input_buff
0042   0449 13            mov a, d
0043   044A 42 8E 13      mov [prog], a      ; reset tokenizer buffer pointer
0044   044D 07 44 0E      call _gets            ; get command
0045   0450 07 56 04      call cmd_parser
0046   0453 0A 36 04      jmp shell_l0
0047   0456             
0048   0456             cmd_parser:
0049   0456 07 EF 11      call get_token          ; get command into tokstr
0050   0459 FD 4F F3 05   mov di, commands
0051   045D FD 10         cla
0052   045F 42 53 09      mov [parser_index], a    ; reset commands index
0053   0462             parser_l0:
0054   0462 FD 4D 92 13   mov si, tokstr
0055   0466 07 AC 0D      call _strcmp
0056   0469 C6 91 04      je parser_cmd_equal
0057   046C             parser_l0_l0:
0058   046C FC 00 00      lea d, [di + 0]
0059   046F BD 00         cmp byte[d], 0
0060   0471 C6 7A 04      je parser_l0_l0_exit      ; run through the keyword until finding null
0061   0474 D4 01 00      add di, 1
0062   0477 0A 6C 04      jmp parser_l0_l0
0063   047A             parser_l0_l0_exit:
0064   047A D4 01 00      add di, 1        ; then skip null byte at the end 
0065   047D 14 53 09      mov a, [parser_index]
0066   0480 53 02 00      add a, 2
0067   0483 42 53 09      mov [parser_index], a      ; increase commands table index
0068   0486 FC 00 00      lea d, [di + 0]
0069   0489 BD 00         cmp byte[d], 0
0070   048B C6 AC 04      je parser_cmd_not_found
0071   048E 0A 62 04      jmp parser_l0
0072   0491             parser_cmd_equal:
0073   0491 07 16 0F      call printnl
0074   0494 14 53 09      mov a, [parser_index]      ; get the keyword pointer
0075   0497 FD 07 00 06   call [a + keyword_ptrs]    ; execute command
0076   049B 07 16 0F      call printnl
0077   049E             parser_retry:
0078   049E 07 EF 11      call get_token
0079   04A1 BC 91 13 06   cmp byte[tok], tok_semi
0080   04A5 C6 56 04      je cmd_parser
0081   04A8 07 75 13      call _putback
0082   04AB 09            ret
0083   04AC             parser_cmd_not_found:
0084   04AC 07 75 13      call _putback
0085   04AF 07 5B 05      call cmd_exec      ; execute as file/program
0086   04B2 0A 9E 04      jmp parser_retry    ; check for more commands
0087   04B5 09            ret
0088   04B6             
0089   04B6             ; inputs:
0090   04B6             ; d = filename ptr
0091   04B6             ; si = entry name ptr
0092   04B6             ; di = output value string ptr
0093   04B6             read_config:
0094   04B6 E3            push di
0095   04B7 E2            push si
0096   04B8 FD 4F 92 14   mov di, shell_transient_area
0097   04BC 19 14         mov al, 20
0098   04BE 05 04         syscall sys_filesystem        ; read entire config file
0099   04C0 10 92 14      mov a, shell_transient_area
0100   04C3 42 8E 13      mov [prog], a
0101   04C6 EF            pop si
0102   04C7             read_config_l0:
0103   04C7 07 EF 11      call get_token
0104   04CA BC 91 13 14   cmp byte[tok], tok_end
0105   04CE C6 FA 04      je read_config_eof
0106   04D1 FD 4F 92 13   mov di, tokstr
0107   04D5 07 AC 0D      call _strcmp
0108   04D8 C6 E8 04      je read_config_found_entry
0109   04DB             read_config_l0_l0:
0110   04DB 07 EF 11      call get_token
0111   04DE BC 91 13 06   cmp byte[tok], tok_semi
0112   04E2 C6 C7 04      je read_config_l0
0113   04E5 0A DB 04      jmp read_config_l0_l0
0114   04E8             read_config_found_entry:
0115   04E8 07 EF 11      call get_token      ; bypass '=' sign
0116   04EB F0            pop di
0117   04EC 14 8E 13      mov a, [prog]
0118   04EF 4D            mov si, a
0119   04F0             read_conf_l1:
0120   04F0 F6            lodsb
0121   04F1 B9 3B         cmp al, $3b        ; ';'
0122   04F3 C6 FB 04      je read_config_eof_2
0123   04F6 F7            stosb
0124   04F7 0A F0 04      jmp read_conf_l1
0125   04FA             read_config_eof:
0126   04FA F0            pop di
0127   04FB             read_config_eof_2:
0128   04FB 19 00         mov al, 0
0129   04FD F7            stosb          ; terminate value with null
0130   04FE 09            ret
0131   04FF             
0132   04FF             ;  sol shell
0133   04FF             cmd_shell:
0134   04FF 07 98 11      call get_path
0135   0502 3B 92 13      mov d, tokstr
0136   0505 FD 4F 92 14   mov di, shell_transient_area
0137   0509 19 14         mov al, 20
0138   050B 05 04         syscall sys_filesystem        ; read textfile 
0139   050D               
0140   050D 3B 92 14      mov d, shell_transient_area
0141   0510 13            mov a, d
0142   0511 42 8E 13      mov [prog], a      ; reset tokenizer buffer pointer
0143   0514 07 56 04      call cmd_parser
0144   0517             
0145   0517 07 16 0F      call printnl
0146   051A 09            ret
0147   051B             
0148   051B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0149   051B             ;; cd
0150   051B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0151   051B             ; search for given directory inside current dir
0152   051B             ; if found, read its lba, and switch directories
0153   051B             ; example:  cd /usr/bin; ls
0154   051B             ;       cd /usr/bin;
0155   051B             ;      cd /usr/bin
0156   051B             cmd_cd:
0157   051B 07 EF 11      call get_token
0158   051E 1D 91 13      mov al, [tok]
0159   0521 B9 14         cmp al, tok_end
0160   0523 C6 49 05      je cmd_cd_gotohome
0161   0526 B9 06         cmp al, tok_semi
0162   0528 C6 49 05      je cmd_cd_gotohome
0163   052B B9 08         cmp al, tok_tilde
0164   052D C6 49 05      je cmd_cd_gotohome
0165   0530 07 75 13      call _putback
0166   0533 07 98 11      call get_path    ; get the path for the cd command
0167   0536             cmd_cd_syscall:
0168   0536 3B 92 13      mov d, tokstr
0169   0539 19 13         mov al, 19
0170   053B 05 04         syscall sys_filesystem  ; get dirid in a
0171   053D AF FF FF      cmp a, $ffff
0172   0540 C6 5A 05      je cmd_cd_fail
0173   0543 27            mov b, a
0174   0544 19 03         mov al, 3
0175   0546 05 04         syscall sys_filesystem  ; set dir to b
0176   0548             
0177   0548 09            ret
0178   0549             cmd_cd_gotohome:
0179   0549 07 75 13      call _putback
0180   054C FD 4D 06 06   mov si, homedir
0181   0550 FD 4F 92 13   mov di, tokstr
0182   0554 07 C1 0D      call _strcpy
0183   0557 0A 36 05      jmp cmd_cd_syscall
0184   055A             cmd_cd_fail:
0185   055A 09            ret
0186   055B             
0187   055B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0188   055B             ;; exec/open program/file
0189   055B             ;; 'filename' maps to '$path/filename'
0190   055B             ;; './file' or '/a/directory/file' loads a file directly
0191   055B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0192   055B             cmd_exec:
0193   055B BC 91 13 14   cmp byte[tok], tok_end
0194   055F C6 E5 05      je cmd_exec_ret    ; check for null input
0195   0562 07 98 11      call get_path    ; get file path 
0196   0565 14 8E 13      mov a, [prog]
0197   0568 D7            push a        ; save argument pointer
0198   0569 FD 4D 92 13   mov si, tokstr
0199   056D FD 4F 55 09   mov di, temp_data1
0200   0571 07 C1 0D      call _strcpy      ; copy filename for later
0201   0574 BC 92 13 2F   cmp byte[tokstr], '/'  ; check first character of path
0202   0578 C6 D6 05      je cmd_exec_abs
0203   057B BC 92 13 2E   cmp byte[tokstr], '.'  ; check first character of path
0204   057F C6 D6 05      je cmd_exec_abs
0205   0582 10 86 06      mov a, path
0206   0585 42 8E 13      mov [prog], a    ; set token pointer to $path beginning
0207   0588             cmd_exec_l0:
0208   0588 07 98 11      call get_path    ; get a path option
0209   058B FD 4D 92 13   mov si, tokstr
0210   058F FD 4F 55 0B   mov di, temp_data
0211   0593 07 C1 0D      call _strcpy      ; firstly, form address from one of the '$path' addresses
0212   0596 FD 4D 49 07   mov si, s_fslash
0213   059A FD 4F 55 0B   mov di, temp_data
0214   059E 07 CF 0D      call _strcat      ; add '/' in between $path component and filename
0215   05A1 FD 4D 55 09   mov si, temp_data1
0216   05A5 FD 4F 55 0B   mov di, temp_data
0217   05A9 07 CF 0D      call _strcat      ; now glue the given filename to the total path
0218   05AC 3B 55 0B      mov d, temp_data
0219   05AF 19 15         mov al, 21
0220   05B1 05 04         syscall sys_filesystem  ; now we check whether such a file exists. success code is given in a. if 0, file does not exist
0221   05B3 AF 00 00      cmp a, 0
0222   05B6 C7 C6 05      jne cmd_exec_path_exists
0223   05B9 07 EF 11      call get_token
0224   05BC BC 91 13 06   cmp byte[tok], tok_semi
0225   05C0 C7 88 05      jne cmd_exec_l0    ; if not ';' at the end, then token must be a separator. so try another path
0226   05C3 0A E6 05      jmp cmd_exec_unknown
0227   05C6             cmd_exec_path_exists:
0228   05C6 E4            pop a        ; retrieve token pointer which points to the arguments given
0229   05C7 42 8E 13      mov [prog], a
0230   05CA 07 64 11      call get_arg    ; if however, $path/filename was found, then we execute it
0231   05CD 26 92 13      mov b, tokstr
0232   05D0 3B 55 0B      mov d, temp_data
0233   05D3 05 05         syscall sys_create_proc
0234   05D5 09            ret
0235   05D6             cmd_exec_abs:  ; execute as absolute path
0236   05D6 E4            pop a
0237   05D7 42 8E 13      mov [prog], a
0238   05DA 07 64 11      call get_arg
0239   05DD 26 92 13      mov b, tokstr
0240   05E0 3B 55 09      mov d, temp_data1  ;original filename
0241   05E3 05 05         syscall sys_create_proc
0242   05E5             cmd_exec_ret:
0243   05E5 09            ret
0244   05E6             cmd_exec_unknown:
0245   05E6 E4            pop a
0246   05E7 09            ret
0247   05E8             
0248   05E8             cmd_fg:
0249   05E8 07 EF 11      call get_token
0250   05EB 1D 92 13      mov al, [tokstr]
0251   05EE 6F 30         sub al, $30
0252   05F0 05 0A         syscall sys_resume_proc
0253   05F2 09            ret
0254   05F3             
0255   05F3             commands:         
0256   05F3 63 64 00      .db "cd", 0
0257   05F6 66 67 00      .db "fg", 0
0258   05F9 73 68 65 6C   .db "shell", 0
0258   05FD 6C 00 
0259   05FF 00            .db 0
0260   0600             
0261   0600             keyword_ptrs:     
0262   0600 1B 05         .dw cmd_cd
0263   0602 E8 05         .dw cmd_fg
0264   0604 FF 04         .dw cmd_shell
0265   0606             
0266   0606 00 00 00 00 homedir:          .fill 128, 0
0266   060A 00 00 00 00 
0266   060E 00 00 00 00 
0266   0612 00 00 00 00 
0266   0616 00 00 00 00 
0266   061A 00 00 00 00 
0266   061E 00 00 00 00 
0266   0622 00 00 00 00 
0266   0626 00 00 00 00 
0266   062A 00 00 00 00 
0266   062E 00 00 00 00 
0266   0632 00 00 00 00 
0266   0636 00 00 00 00 
0266   063A 00 00 00 00 
0266   063E 00 00 00 00 
0266   0642 00 00 00 00 
0266   0646 00 00 00 00 
0266   064A 00 00 00 00 
0266   064E 00 00 00 00 
0266   0652 00 00 00 00 
0266   0656 00 00 00 00 
0266   065A 00 00 00 00 
0266   065E 00 00 00 00 
0266   0662 00 00 00 00 
0266   0666 00 00 00 00 
0266   066A 00 00 00 00 
0266   066E 00 00 00 00 
0266   0672 00 00 00 00 
0266   0676 00 00 00 00 
0266   067A 00 00 00 00 
0266   067E 00 00 00 00 
0266   0682 00 00 00 00 
0267   0686 00 00 00 00 path:             .fill 128, 0    ; $path environment variable 
0267   068A 00 00 00 00 
0267   068E 00 00 00 00 
0267   0692 00 00 00 00 
0267   0696 00 00 00 00 
0267   069A 00 00 00 00 
0267   069E 00 00 00 00 
0267   06A2 00 00 00 00 
0267   06A6 00 00 00 00 
0267   06AA 00 00 00 00 
0267   06AE 00 00 00 00 
0267   06B2 00 00 00 00 
0267   06B6 00 00 00 00 
0267   06BA 00 00 00 00 
0267   06BE 00 00 00 00 
0267   06C2 00 00 00 00 
0267   06C6 00 00 00 00 
0267   06CA 00 00 00 00 
0267   06CE 00 00 00 00 
0267   06D2 00 00 00 00 
0267   06D6 00 00 00 00 
0267   06DA 00 00 00 00 
0267   06DE 00 00 00 00 
0267   06E2 00 00 00 00 
0267   06E6 00 00 00 00 
0267   06EA 00 00 00 00 
0267   06EE 00 00 00 00 
0267   06F2 00 00 00 00 
0267   06F6 00 00 00 00 
0267   06FA 00 00 00 00 
0267   06FE 00 00 00 00 
0267   0702 00 00 00 00 
0268   0706             
0269   0706 2F 65 74 63 s_etc_shellrc:    .db "/etc/.shellrc", 0
0269   070A 2F 2E 73 68 
0269   070E 65 6C 6C 72 
0269   0712 63 00 
0270   0714 2F 65 74 63 s_etc_config:     .db "/etc/shell.cfg", 0
0270   0718 2F 73 68 65 
0270   071C 6C 6C 2E 63 
0270   0720 66 67 00 
0271   0723 68 6F 6D 65 s_home:           .db "home", 0
0271   0727 00 
0272   0728 70 61 74 68 s_path:           .db "path", 0
0272   072C 00 
0273   072D             
0274   072D 1B 5B 32 4A s_rebooting:      .db "\033[2J\033[H", "now rebooting...", 0
0274   0731 1B 5B 48 6E 
0274   0735 6F 77 20 72 
0274   0739 65 62 6F 6F 
0274   073D 74 69 6E 67 
0274   0741 2E 2E 2E 00 
0275   0745 20 23 20 00 s_hash:           .db " # ", 0
0276   0749 2F 00       s_fslash:         .db "/", 0
0277   074B 53 6F 6C 2D s_sol1:           .db "Sol-1:", 0, 0
0277   074F 31 3A 00 00 
0278   0753             
0279   0753 00 00 00 00 shell_input_buff: .fill 512, 0
0279   0757 00 00 00 00 
0279   075B 00 00 00 00 
0279   075F 00 00 00 00 
0279   0763 00 00 00 00 
0279   0767 00 00 00 00 
0279   076B 00 00 00 00 
0279   076F 00 00 00 00 
0279   0773 00 00 00 00 
0279   0777 00 00 00 00 
0279   077B 00 00 00 00 
0279   077F 00 00 00 00 
0279   0783 00 00 00 00 
0279   0787 00 00 00 00 
0279   078B 00 00 00 00 
0279   078F 00 00 00 00 
0279   0793 00 00 00 00 
0279   0797 00 00 00 00 
0279   079B 00 00 00 00 
0279   079F 00 00 00 00 
0279   07A3 00 00 00 00 
0279   07A7 00 00 00 00 
0279   07AB 00 00 00 00 
0279   07AF 00 00 00 00 
0279   07B3 00 00 00 00 
0279   07B7 00 00 00 00 
0279   07BB 00 00 00 00 
0279   07BF 00 00 00 00 
0279   07C3 00 00 00 00 
0279   07C7 00 00 00 00 
0279   07CB 00 00 00 00 
0279   07CF 00 00 00 00 
0279   07D3 00 00 00 00 
0279   07D7 00 00 00 00 
0279   07DB 00 00 00 00 
0279   07DF 00 00 00 00 
0279   07E3 00 00 00 00 
0279   07E7 00 00 00 00 
0279   07EB 00 00 00 00 
0279   07EF 00 00 00 00 
0279   07F3 00 00 00 00 
0279   07F7 00 00 00 00 
0279   07FB 00 00 00 00 
0279   07FF 00 00 00 00 
0279   0803 00 00 00 00 
0279   0807 00 00 00 00 
0279   080B 00 00 00 00 
0279   080F 00 00 00 00 
0279   0813 00 00 00 00 
0279   0817 00 00 00 00 
0279   081B 00 00 00 00 
0279   081F 00 00 00 00 
0279   0823 00 00 00 00 
0279   0827 00 00 00 00 
0279   082B 00 00 00 00 
0279   082F 00 00 00 00 
0279   0833 00 00 00 00 
0279   0837 00 00 00 00 
0279   083B 00 00 00 00 
0279   083F 00 00 00 00 
0279   0843 00 00 00 00 
0279   0847 00 00 00 00 
0279   084B 00 00 00 00 
0279   084F 00 00 00 00 
0279   0853 00 00 00 00 
0279   0857 00 00 00 00 
0279   085B 00 00 00 00 
0279   085F 00 00 00 00 
0279   0863 00 00 00 00 
0279   0867 00 00 00 00 
0279   086B 00 00 00 00 
0279   086F 00 00 00 00 
0279   0873 00 00 00 00 
0279   0877 00 00 00 00 
0279   087B 00 00 00 00 
0279   087F 00 00 00 00 
0279   0883 00 00 00 00 
0279   0887 00 00 00 00 
0279   088B 00 00 00 00 
0279   088F 00 00 00 00 
0279   0893 00 00 00 00 
0279   0897 00 00 00 00 
0279   089B 00 00 00 00 
0279   089F 00 00 00 00 
0279   08A3 00 00 00 00 
0279   08A7 00 00 00 00 
0279   08AB 00 00 00 00 
0279   08AF 00 00 00 00 
0279   08B3 00 00 00 00 
0279   08B7 00 00 00 00 
0279   08BB 00 00 00 00 
0279   08BF 00 00 00 00 
0279   08C3 00 00 00 00 
0279   08C7 00 00 00 00 
0279   08CB 00 00 00 00 
0279   08CF 00 00 00 00 
0279   08D3 00 00 00 00 
0279   08D7 00 00 00 00 
0279   08DB 00 00 00 00 
0279   08DF 00 00 00 00 
0279   08E3 00 00 00 00 
0279   08E7 00 00 00 00 
0279   08EB 00 00 00 00 
0279   08EF 00 00 00 00 
0279   08F3 00 00 00 00 
0279   08F7 00 00 00 00 
0279   08FB 00 00 00 00 
0279   08FF 00 00 00 00 
0279   0903 00 00 00 00 
0279   0907 00 00 00 00 
0279   090B 00 00 00 00 
0279   090F 00 00 00 00 
0279   0913 00 00 00 00 
0279   0917 00 00 00 00 
0279   091B 00 00 00 00 
0279   091F 00 00 00 00 
0279   0923 00 00 00 00 
0279   0927 00 00 00 00 
0279   092B 00 00 00 00 
0279   092F 00 00 00 00 
0279   0933 00 00 00 00 
0279   0937 00 00 00 00 
0279   093B 00 00 00 00 
0279   093F 00 00 00 00 
0279   0943 00 00 00 00 
0279   0947 00 00 00 00 
0279   094B 00 00 00 00 
0279   094F 00 00 00 00 
0280   0953 00 00       parser_index:     .dw 0
0281   0955             
0282   0955 00 00 00 00 temp_data1:       .fill 512, 0
0282   0959 00 00 00 00 
0282   095D 00 00 00 00 
0282   0961 00 00 00 00 
0282   0965 00 00 00 00 
0282   0969 00 00 00 00 
0282   096D 00 00 00 00 
0282   0971 00 00 00 00 
0282   0975 00 00 00 00 
0282   0979 00 00 00 00 
0282   097D 00 00 00 00 
0282   0981 00 00 00 00 
0282   0985 00 00 00 00 
0282   0989 00 00 00 00 
0282   098D 00 00 00 00 
0282   0991 00 00 00 00 
0282   0995 00 00 00 00 
0282   0999 00 00 00 00 
0282   099D 00 00 00 00 
0282   09A1 00 00 00 00 
0282   09A5 00 00 00 00 
0282   09A9 00 00 00 00 
0282   09AD 00 00 00 00 
0282   09B1 00 00 00 00 
0282   09B5 00 00 00 00 
0282   09B9 00 00 00 00 
0282   09BD 00 00 00 00 
0282   09C1 00 00 00 00 
0282   09C5 00 00 00 00 
0282   09C9 00 00 00 00 
0282   09CD 00 00 00 00 
0282   09D1 00 00 00 00 
0282   09D5 00 00 00 00 
0282   09D9 00 00 00 00 
0282   09DD 00 00 00 00 
0282   09E1 00 00 00 00 
0282   09E5 00 00 00 00 
0282   09E9 00 00 00 00 
0282   09ED 00 00 00 00 
0282   09F1 00 00 00 00 
0282   09F5 00 00 00 00 
0282   09F9 00 00 00 00 
0282   09FD 00 00 00 00 
0282   0A01 00 00 00 00 
0282   0A05 00 00 00 00 
0282   0A09 00 00 00 00 
0282   0A0D 00 00 00 00 
0282   0A11 00 00 00 00 
0282   0A15 00 00 00 00 
0282   0A19 00 00 00 00 
0282   0A1D 00 00 00 00 
0282   0A21 00 00 00 00 
0282   0A25 00 00 00 00 
0282   0A29 00 00 00 00 
0282   0A2D 00 00 00 00 
0282   0A31 00 00 00 00 
0282   0A35 00 00 00 00 
0282   0A39 00 00 00 00 
0282   0A3D 00 00 00 00 
0282   0A41 00 00 00 00 
0282   0A45 00 00 00 00 
0282   0A49 00 00 00 00 
0282   0A4D 00 00 00 00 
0282   0A51 00 00 00 00 
0282   0A55 00 00 00 00 
0282   0A59 00 00 00 00 
0282   0A5D 00 00 00 00 
0282   0A61 00 00 00 00 
0282   0A65 00 00 00 00 
0282   0A69 00 00 00 00 
0282   0A6D 00 00 00 00 
0282   0A71 00 00 00 00 
0282   0A75 00 00 00 00 
0282   0A79 00 00 00 00 
0282   0A7D 00 00 00 00 
0282   0A81 00 00 00 00 
0282   0A85 00 00 00 00 
0282   0A89 00 00 00 00 
0282   0A8D 00 00 00 00 
0282   0A91 00 00 00 00 
0282   0A95 00 00 00 00 
0282   0A99 00 00 00 00 
0282   0A9D 00 00 00 00 
0282   0AA1 00 00 00 00 
0282   0AA5 00 00 00 00 
0282   0AA9 00 00 00 00 
0282   0AAD 00 00 00 00 
0282   0AB1 00 00 00 00 
0282   0AB5 00 00 00 00 
0282   0AB9 00 00 00 00 
0282   0ABD 00 00 00 00 
0282   0AC1 00 00 00 00 
0282   0AC5 00 00 00 00 
0282   0AC9 00 00 00 00 
0282   0ACD 00 00 00 00 
0282   0AD1 00 00 00 00 
0282   0AD5 00 00 00 00 
0282   0AD9 00 00 00 00 
0282   0ADD 00 00 00 00 
0282   0AE1 00 00 00 00 
0282   0AE5 00 00 00 00 
0282   0AE9 00 00 00 00 
0282   0AED 00 00 00 00 
0282   0AF1 00 00 00 00 
0282   0AF5 00 00 00 00 
0282   0AF9 00 00 00 00 
0282   0AFD 00 00 00 00 
0282   0B01 00 00 00 00 
0282   0B05 00 00 00 00 
0282   0B09 00 00 00 00 
0282   0B0D 00 00 00 00 
0282   0B11 00 00 00 00 
0282   0B15 00 00 00 00 
0282   0B19 00 00 00 00 
0282   0B1D 00 00 00 00 
0282   0B21 00 00 00 00 
0282   0B25 00 00 00 00 
0282   0B29 00 00 00 00 
0282   0B2D 00 00 00 00 
0282   0B31 00 00 00 00 
0282   0B35 00 00 00 00 
0282   0B39 00 00 00 00 
0282   0B3D 00 00 00 00 
0282   0B41 00 00 00 00 
0282   0B45 00 00 00 00 
0282   0B49 00 00 00 00 
0282   0B4D 00 00 00 00 
0282   0B51 00 00 00 00 
0283   0B55 00 00 00 00 temp_data:        .fill 512, 0
0283   0B59 00 00 00 00 
0283   0B5D 00 00 00 00 
0283   0B61 00 00 00 00 
0283   0B65 00 00 00 00 
0283   0B69 00 00 00 00 
0283   0B6D 00 00 00 00 
0283   0B71 00 00 00 00 
0283   0B75 00 00 00 00 
0283   0B79 00 00 00 00 
0283   0B7D 00 00 00 00 
0283   0B81 00 00 00 00 
0283   0B85 00 00 00 00 
0283   0B89 00 00 00 00 
0283   0B8D 00 00 00 00 
0283   0B91 00 00 00 00 
0283   0B95 00 00 00 00 
0283   0B99 00 00 00 00 
0283   0B9D 00 00 00 00 
0283   0BA1 00 00 00 00 
0283   0BA5 00 00 00 00 
0283   0BA9 00 00 00 00 
0283   0BAD 00 00 00 00 
0283   0BB1 00 00 00 00 
0283   0BB5 00 00 00 00 
0283   0BB9 00 00 00 00 
0283   0BBD 00 00 00 00 
0283   0BC1 00 00 00 00 
0283   0BC5 00 00 00 00 
0283   0BC9 00 00 00 00 
0283   0BCD 00 00 00 00 
0283   0BD1 00 00 00 00 
0283   0BD5 00 00 00 00 
0283   0BD9 00 00 00 00 
0283   0BDD 00 00 00 00 
0283   0BE1 00 00 00 00 
0283   0BE5 00 00 00 00 
0283   0BE9 00 00 00 00 
0283   0BED 00 00 00 00 
0283   0BF1 00 00 00 00 
0283   0BF5 00 00 00 00 
0283   0BF9 00 00 00 00 
0283   0BFD 00 00 00 00 
0283   0C01 00 00 00 00 
0283   0C05 00 00 00 00 
0283   0C09 00 00 00 00 
0283   0C0D 00 00 00 00 
0283   0C11 00 00 00 00 
0283   0C15 00 00 00 00 
0283   0C19 00 00 00 00 
0283   0C1D 00 00 00 00 
0283   0C21 00 00 00 00 
0283   0C25 00 00 00 00 
0283   0C29 00 00 00 00 
0283   0C2D 00 00 00 00 
0283   0C31 00 00 00 00 
0283   0C35 00 00 00 00 
0283   0C39 00 00 00 00 
0283   0C3D 00 00 00 00 
0283   0C41 00 00 00 00 
0283   0C45 00 00 00 00 
0283   0C49 00 00 00 00 
0283   0C4D 00 00 00 00 
0283   0C51 00 00 00 00 
0283   0C55 00 00 00 00 
0283   0C59 00 00 00 00 
0283   0C5D 00 00 00 00 
0283   0C61 00 00 00 00 
0283   0C65 00 00 00 00 
0283   0C69 00 00 00 00 
0283   0C6D 00 00 00 00 
0283   0C71 00 00 00 00 
0283   0C75 00 00 00 00 
0283   0C79 00 00 00 00 
0283   0C7D 00 00 00 00 
0283   0C81 00 00 00 00 
0283   0C85 00 00 00 00 
0283   0C89 00 00 00 00 
0283   0C8D 00 00 00 00 
0283   0C91 00 00 00 00 
0283   0C95 00 00 00 00 
0283   0C99 00 00 00 00 
0283   0C9D 00 00 00 00 
0283   0CA1 00 00 00 00 
0283   0CA5 00 00 00 00 
0283   0CA9 00 00 00 00 
0283   0CAD 00 00 00 00 
0283   0CB1 00 00 00 00 
0283   0CB5 00 00 00 00 
0283   0CB9 00 00 00 00 
0283   0CBD 00 00 00 00 
0283   0CC1 00 00 00 00 
0283   0CC5 00 00 00 00 
0283   0CC9 00 00 00 00 
0283   0CCD 00 00 00 00 
0283   0CD1 00 00 00 00 
0283   0CD5 00 00 00 00 
0283   0CD9 00 00 00 00 
0283   0CDD 00 00 00 00 
0283   0CE1 00 00 00 00 
0283   0CE5 00 00 00 00 
0283   0CE9 00 00 00 00 
0283   0CED 00 00 00 00 
0283   0CF1 00 00 00 00 
0283   0CF5 00 00 00 00 
0283   0CF9 00 00 00 00 
0283   0CFD 00 00 00 00 
0283   0D01 00 00 00 00 
0283   0D05 00 00 00 00 
0283   0D09 00 00 00 00 
0283   0D0D 00 00 00 00 
0283   0D11 00 00 00 00 
0283   0D15 00 00 00 00 
0283   0D19 00 00 00 00 
0283   0D1D 00 00 00 00 
0283   0D21 00 00 00 00 
0283   0D25 00 00 00 00 
0283   0D29 00 00 00 00 
0283   0D2D 00 00 00 00 
0283   0D31 00 00 00 00 
0283   0D35 00 00 00 00 
0283   0D39 00 00 00 00 
0283   0D3D 00 00 00 00 
0283   0D41 00 00 00 00 
0283   0D45 00 00 00 00 
0283   0D49 00 00 00 00 
0283   0D4D 00 00 00 00 
0283   0D51 00 00 00 00 
0284   0D55             
0285   0D55             .include "lib/stdio.asm"
0001+  0D55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0D55             ; stdio.s
0003+  0D55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0D55             .include "lib/string.asm"
0001++ 0D55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0D55             ; string.s
0003++ 0D55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0D55             
0005++ 0D55             
0006++ 0D55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0D55             ; _strrev
0008++ 0D55             ; reverse a string
0009++ 0D55             ; d = string address
0010++ 0D55             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0D55             ; 01234
0012++ 0D55             _strrev:
0013++ 0D55 4B          	pusha
0014++ 0D56 07 9C 0D    	call _strlen	; length in c
0015++ 0D59 12          	mov a, c
0016++ 0D5A AF 01 00    	cmp a, 1
0017++ 0D5D D0 77 0D    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0D60 7D          	dec a
0019++ 0D61 FD 4E       	mov si, d	; beginning of string
0020++ 0D63 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0D65 59          	add d, a	; end of string
0022++ 0D66 12          	mov a, c
0023++ 0D67 FD 9B       	shr a		; divide by 2
0024++ 0D69 39          	mov c, a	; c now counts the steps
0025++ 0D6A             _strrev_l0:
0026++ 0D6A 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0D6B F6          	lodsb		; load left-side char into al; increase si
0028++ 0D6C 3E          	mov [d], al	; store left char into right side
0029++ 0D6D 1B          	mov al, bl
0030++ 0D6E F7          	stosb		; store right-side char into left-side; increase di
0031++ 0D6F 7E          	dec c
0032++ 0D70 7F          	dec d
0033++ 0D71 C2 00 00    	cmp c, 0
0034++ 0D74 C7 6A 0D    	jne _strrev_l0
0035++ 0D77             _strrev_end:
0036++ 0D77 4C          	popa
0037++ 0D78 09          	ret
0038++ 0D79             	
0039++ 0D79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0D79             ; _strchr
0041++ 0D79             ; search string in d for char in al
0042++ 0D79             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0D79             _strchr:
0044++ 0D79             _strchr_l0:
0045++ 0D79 32          	mov bl, [d]
0046++ 0D7A C1 00       	cmp bl, 0
0047++ 0D7C C6 87 0D    	je _strchr_end
0048++ 0D7F BA          	cmp al, bl
0049++ 0D80 C6 87 0D    	je _strchr_end
0050++ 0D83 79          	inc d
0051++ 0D84 0A 79 0D    	jmp _strchr_l0
0052++ 0D87             _strchr_end:
0053++ 0D87 1B          	mov al, bl
0054++ 0D88 09          	ret
0055++ 0D89             
0056++ 0D89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0D89             ; _strstr
0058++ 0D89             ; find sub-string
0059++ 0D89             ; str1 in si
0060++ 0D89             ; str2 in di
0061++ 0D89             ; si points to end of source string
0062++ 0D89             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0D89             _strstr:
0064++ 0D89 DB          	push al
0065++ 0D8A DA          	push d
0066++ 0D8B E3          	push di
0067++ 0D8C             _strstr_loop:
0068++ 0D8C F3          	cmpsb					; compare a byte of the strings
0069++ 0D8D C7 98 0D    	jne _strstr_ret
0070++ 0D90 FC 00 00    	lea d, [di + 0]
0071++ 0D93 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0D95 C7 8C 0D    	jne _strstr_loop				; equal chars but not at end
0073++ 0D98             _strstr_ret:
0074++ 0D98 F0          	pop di
0075++ 0D99 E7          	pop d
0076++ 0D9A E8          	pop al
0077++ 0D9B 09          	ret
0078++ 0D9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0D9C             ; length of null terminated string
0080++ 0D9C             ; result in c
0081++ 0D9C             ; pointer in d
0082++ 0D9C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0D9C             _strlen:
0084++ 0D9C DA          	push d
0085++ 0D9D 38 00 00    	mov c, 0
0086++ 0DA0             _strlen_l1:
0087++ 0DA0 BD 00       	cmp byte [d], 0
0088++ 0DA2 C6 AA 0D    	je _strlen_ret
0089++ 0DA5 79          	inc d
0090++ 0DA6 78          	inc c
0091++ 0DA7 0A A0 0D    	jmp _strlen_l1
0092++ 0DAA             _strlen_ret:
0093++ 0DAA E7          	pop d
0094++ 0DAB 09          	ret
0095++ 0DAC             
0096++ 0DAC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0DAC             ; strcmp
0098++ 0DAC             ; compare two strings
0099++ 0DAC             ; str1 in si
0100++ 0DAC             ; str2 in di
0101++ 0DAC             ; create a string compairon instrucion ?????
0102++ 0DAC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0DAC             _strcmp:
0104++ 0DAC DB          	push al
0105++ 0DAD DA          	push d
0106++ 0DAE E3          	push di
0107++ 0DAF E2          	push si
0108++ 0DB0             _strcmp_loop:
0109++ 0DB0 F3          	cmpsb					; compare a byte of the strings
0110++ 0DB1 C7 BC 0D    	jne _strcmp_ret
0111++ 0DB4 FB FF FF    	lea d, [si +- 1]
0112++ 0DB7 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0DB9 C7 B0 0D    	jne _strcmp_loop				; equal chars but not at end
0114++ 0DBC             _strcmp_ret:
0115++ 0DBC EF          	pop si
0116++ 0DBD F0          	pop di
0117++ 0DBE E7          	pop d
0118++ 0DBF E8          	pop al
0119++ 0DC0 09          	ret
0120++ 0DC1             
0121++ 0DC1             
0122++ 0DC1             ; strcpy
0123++ 0DC1             ; copy null terminated string from si to di
0124++ 0DC1             ; source in si
0125++ 0DC1             ; destination in di
0126++ 0DC1             _strcpy:
0127++ 0DC1 E2          	push si
0128++ 0DC2 E3          	push di
0129++ 0DC3 DB          	push al
0130++ 0DC4             _strcpy_l1:
0131++ 0DC4 F6          	lodsb
0132++ 0DC5 F7          	stosb
0133++ 0DC6 B9 00       	cmp al, 0
0134++ 0DC8 C7 C4 0D    	jne _strcpy_l1
0135++ 0DCB             _strcpy_end:
0136++ 0DCB E8          	pop al
0137++ 0DCC F0          	pop di
0138++ 0DCD EF          	pop si
0139++ 0DCE 09          	ret
0140++ 0DCF             
0141++ 0DCF             ; strcat
0142++ 0DCF             ; concatenate a null terminated string into string at di, from string at si
0143++ 0DCF             ; source in si
0144++ 0DCF             ; destination in di
0145++ 0DCF             _strcat:
0146++ 0DCF E2          	push si
0147++ 0DD0 E3          	push di
0148++ 0DD1 D7          	push a
0149++ 0DD2 DA          	push d
0150++ 0DD3 50          	mov a, di
0151++ 0DD4 3C          	mov d, a
0152++ 0DD5             _strcat_goto_end_l1:
0153++ 0DD5 BD 00       	cmp byte[d], 0
0154++ 0DD7 C6 DE 0D    	je _strcat_start
0155++ 0DDA 79          	inc d
0156++ 0DDB 0A D5 0D    	jmp _strcat_goto_end_l1
0157++ 0DDE             _strcat_start:
0158++ 0DDE FD 50       	mov di, d
0159++ 0DE0             _strcat_l1:
0160++ 0DE0 F6          	lodsb
0161++ 0DE1 F7          	stosb
0162++ 0DE2 B9 00       	cmp al, 0
0163++ 0DE4 C7 E0 0D    	jne _strcat_l1
0164++ 0DE7             _strcat_end:
0165++ 0DE7 E7          	pop d
0166++ 0DE8 E4          	pop a
0167++ 0DE9 F0          	pop di
0168++ 0DEA EF          	pop si
0169++ 0DEB 09          	ret
0170++ 0DEC             
0171++ 0DEC             
0005+  0DEC             
0006+  0DEC             
0007+  0DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0DEC             ; convert ascii 'o'..'f' to integer 0..15
0009+  0DEC             ; ascii in bl
0010+  0DEC             ; result in al
0011+  0DEC             ; ascii for f = 0100 0110
0012+  0DEC             ; ascii for 9 = 0011 1001
0013+  0DEC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0DEC             hex_ascii_encode:
0015+  0DEC 1B            mov al, bl
0016+  0DED 93 40         test al, $40        ; test if letter or number
0017+  0DEF C7 F5 0D      jnz hex_letter
0018+  0DF2 87 0F         and al, $0f        ; get number
0019+  0DF4 09            ret
0020+  0DF5             hex_letter:
0021+  0DF5 87 0F         and al, $0f        ; get letter
0022+  0DF7 6A 09         add al, 9
0023+  0DF9 09            ret
0024+  0DFA             
0025+  0DFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0DFA             ; atoi
0027+  0DFA             ; 2 letter hex string in b
0028+  0DFA             ; 8bit integer returned in al
0029+  0DFA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0DFA             _atoi:
0031+  0DFA D8            push b
0032+  0DFB 07 EC 0D      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0DFE 30            mov bl, bh
0034+  0DFF DB            push al          ; save a
0035+  0E00 07 EC 0D      call hex_ascii_encode
0036+  0E03 EA            pop bl  
0037+  0E04 FD 9E 04      shl al, 4
0038+  0E07 8C            or al, bl
0039+  0E08 E5            pop b
0040+  0E09 09            ret  
0041+  0E0A             
0042+  0E0A             
0043+  0E0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0E0A             ; scanf
0045+  0E0A             ; no need for explanations!
0046+  0E0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0E0A             scanf:
0048+  0E0A 09            ret
0049+  0E0B             
0050+  0E0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0E0B             ; itoa
0052+  0E0B             ; 8bit value in bl
0053+  0E0B             ; 2 byte ascii result in a
0054+  0E0B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0E0B             _itoa:
0056+  0E0B DA            push d
0057+  0E0C D8            push b
0058+  0E0D A7 00         mov bh, 0
0059+  0E0F FD A4 04      shr bl, 4  
0060+  0E12 74            mov d, b
0061+  0E13 1F A5 10      mov al, [d + s_hex_digits]
0062+  0E16 23            mov ah, al
0063+  0E17               
0064+  0E17 E5            pop b
0065+  0E18 D8            push b
0066+  0E19 A7 00         mov bh, 0
0067+  0E1B FD 87 0F      and bl, $0f
0068+  0E1E 74            mov d, b
0069+  0E1F 1F A5 10      mov al, [d + s_hex_digits]
0070+  0E22 E5            pop b
0071+  0E23 E7            pop d
0072+  0E24 09            ret
0073+  0E25             
0074+  0E25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0E25             ; hex string to binary
0076+  0E25             ; di = destination address
0077+  0E25             ; si = source
0078+  0E25             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0E25             _hex_to_int:
0080+  0E25             _hex_to_int_l1:
0081+  0E25 F6            lodsb          ; load from [si] to al
0082+  0E26 B9 00         cmp al, 0        ; check if ascii 0
0083+  0E28 C6 35 0E      jz _hex_to_int_ret
0084+  0E2B 36            mov bh, al
0085+  0E2C F6            lodsb
0086+  0E2D 2F            mov bl, al
0087+  0E2E 07 FA 0D      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0E31 F7            stosb          ; store al to [di]
0089+  0E32 0A 25 0E      jmp _hex_to_int_l1
0090+  0E35             _hex_to_int_ret:
0091+  0E35 09            ret    
0092+  0E36             
0093+  0E36             
0094+  0E36             
0095+  0E36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0E36             ; getchar
0097+  0E36             ; char in ah
0098+  0E36             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0E36             getch:
0100+  0E36 DB            push al
0101+  0E37             getch_retry:
0102+  0E37 19 01         mov al, 1
0103+  0E39 05 03         syscall sys_io      ; receive in ah
0104+  0E3B E8            pop al
0105+  0E3C 09            ret
0106+  0E3D             
0107+  0E3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0E3D             ; putchar
0109+  0E3D             ; char in ah
0110+  0E3D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0E3D             _putchar:
0112+  0E3D DB            push al
0113+  0E3E 19 00         mov al, 0
0114+  0E40 05 03         syscall sys_io      ; char in ah
0115+  0E42 E8            pop al
0116+  0E43 09            ret
0117+  0E44             
0118+  0E44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0E44             ;; input a string
0120+  0E44             ;; terminates with null
0121+  0E44             ;; pointer in d
0122+  0E44             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0E44             _gets:
0124+  0E44 D7            push a
0125+  0E45 DA            push d
0126+  0E46             _gets_loop:
0127+  0E46 19 01         mov al, 1
0128+  0E48 05 03         syscall sys_io      ; receive in ah
0129+  0E4A 76 1B         cmp ah, 27
0130+  0E4C C6 6D 0E      je _gets_ansi_esc
0131+  0E4F 76 0A         cmp ah, $0a        ; lf
0132+  0E51 C6 C9 0E      je _gets_end
0133+  0E54 76 0D         cmp ah, $0d        ; cr
0134+  0E56 C6 C9 0E      je _gets_end
0135+  0E59 76 5C         cmp ah, $5c        ; '\\'
0136+  0E5B C6 8F 0E      je _gets_escape
0137+  0E5E 76 08         cmp ah, $08      ; check for backspace
0138+  0E60 C6 69 0E      je _gets_backspace
0139+  0E63 1A            mov al, ah
0140+  0E64 3E            mov [d], al
0141+  0E65 79            inc d
0142+  0E66 0A 46 0E      jmp _gets_loop
0143+  0E69             _gets_backspace:
0144+  0E69 7F            dec d
0145+  0E6A 0A 46 0E      jmp _gets_loop
0146+  0E6D             _gets_ansi_esc:
0147+  0E6D 19 01         mov al, 1
0148+  0E6F 05 03         syscall sys_io        ; receive in ah without echo
0149+  0E71 76 5B         cmp ah, '['
0150+  0E73 C7 46 0E      jne _gets_loop
0151+  0E76 19 01         mov al, 1
0152+  0E78 05 03         syscall sys_io          ; receive in ah without echo
0153+  0E7A 76 64         cmp ah, 'd'
0154+  0E7C C6 87 0E      je _gets_left_arrow
0155+  0E7F 76 63         cmp ah, 'c'
0156+  0E81 C6 8B 0E      je _gets_right_arrow
0157+  0E84 0A 46 0E      jmp _gets_loop
0158+  0E87             _gets_left_arrow:
0159+  0E87 7F            dec d
0160+  0E88 0A 46 0E      jmp _gets_loop
0161+  0E8B             _gets_right_arrow:
0162+  0E8B 79            inc d
0163+  0E8C 0A 46 0E      jmp _gets_loop
0164+  0E8F             _gets_escape:
0165+  0E8F 19 01         mov al, 1
0166+  0E91 05 03         syscall sys_io      ; receive in ah
0167+  0E93 76 6E         cmp ah, 'n'
0168+  0E95 C6 B4 0E      je _gets_lf
0169+  0E98 76 72         cmp ah, 'r'
0170+  0E9A C6 BB 0E      je _gets_cr
0171+  0E9D 76 30         cmp ah, '0'
0172+  0E9F C6 C2 0E      je _gets_null
0173+  0EA2 76 5C         cmp ah, $5c  ; '\'
0174+  0EA4 C6 AD 0E      je _gets_slash
0175+  0EA7 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0EA8 3E            mov [d], al
0177+  0EA9 79            inc d
0178+  0EAA 0A 46 0E      jmp _gets_loop
0179+  0EAD             _gets_slash:
0180+  0EAD 19 5C         mov al, $5c
0181+  0EAF 3E            mov [d], al
0182+  0EB0 79            inc d
0183+  0EB1 0A 46 0E      jmp _gets_loop
0184+  0EB4             _gets_lf:
0185+  0EB4 19 0A         mov al, $0a
0186+  0EB6 3E            mov [d], al
0187+  0EB7 79            inc d
0188+  0EB8 0A 46 0E      jmp _gets_loop
0189+  0EBB             _gets_cr:
0190+  0EBB 19 0D         mov al, $0d
0191+  0EBD 3E            mov [d], al
0192+  0EBE 79            inc d
0193+  0EBF 0A 46 0E      jmp _gets_loop
0194+  0EC2             _gets_null:
0195+  0EC2 19 00         mov al, $00
0196+  0EC4 3E            mov [d], al
0197+  0EC5 79            inc d
0198+  0EC6 0A 46 0E      jmp _gets_loop
0199+  0EC9             _gets_end:
0200+  0EC9 19 00         mov al, 0
0201+  0ECB 3E            mov [d], al        ; terminate string
0202+  0ECC E7            pop d
0203+  0ECD E4            pop a
0204+  0ECE 09            ret
0205+  0ECF             
0206+  0ECF             
0207+  0ECF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0ECF             ;; input text
0209+  0ECF             ;; terminated with ctrl+d
0210+  0ECF             ;; pointer in d
0211+  0ECF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0ECF             _gettxt:
0213+  0ECF D7            push a
0214+  0ED0 DA            push d
0215+  0ED1             _gettxt_loop:
0216+  0ED1 19 01         mov al, 1
0217+  0ED3 05 03         syscall sys_io      ; receive in ah
0218+  0ED5 76 04         cmp ah, 4      ; eot
0219+  0ED7 C6 10 0F      je _gettxt_end
0220+  0EDA 76 08         cmp ah, $08      ; check for backspace
0221+  0EDC C6 0C 0F      je _gettxt_backspace
0222+  0EDF 76 5C         cmp ah, $5c        ; '\'
0223+  0EE1 C6 EA 0E      je _gettxt_escape
0224+  0EE4 1A            mov al, ah
0225+  0EE5 3E            mov [d], al
0226+  0EE6 79            inc d
0227+  0EE7 0A D1 0E      jmp _gettxt_loop
0228+  0EEA             _gettxt_escape:
0229+  0EEA 19 01         mov al, 1
0230+  0EEC 05 03         syscall sys_io      ; receive in ah
0231+  0EEE 76 6E         cmp ah, 'n'
0232+  0EF0 C6 FE 0E      je _gettxt_lf
0233+  0EF3 76 72         cmp ah, 'r'
0234+  0EF5 C6 05 0F      je _gettxt_cr
0235+  0EF8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0EF9 3E            mov [d], al
0237+  0EFA 79            inc d
0238+  0EFB 0A D1 0E      jmp _gettxt_loop
0239+  0EFE             _gettxt_lf:
0240+  0EFE 19 0A         mov al, $0a
0241+  0F00 3E            mov [d], al
0242+  0F01 79            inc d
0243+  0F02 0A D1 0E      jmp _gettxt_loop
0244+  0F05             _gettxt_cr:
0245+  0F05 19 0D         mov al, $0d
0246+  0F07 3E            mov [d], al
0247+  0F08 79            inc d
0248+  0F09 0A D1 0E      jmp _gettxt_loop
0249+  0F0C             _gettxt_backspace:
0250+  0F0C 7F            dec d
0251+  0F0D 0A D1 0E      jmp _gettxt_loop
0252+  0F10             _gettxt_end:
0253+  0F10 19 00         mov al, 0
0254+  0F12 3E            mov [d], al        ; terminate string
0255+  0F13 E7            pop d
0256+  0F14 E4            pop a
0257+  0F15 09            ret
0258+  0F16             
0259+  0F16             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0F16             ; print new line
0261+  0F16             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0F16             printnl:
0263+  0F16 D7            push a
0264+  0F17 10 00 0A      mov a, $0a00
0265+  0F1A 05 03         syscall sys_io
0266+  0F1C 10 00 0D      mov a, $0d00
0267+  0F1F 05 03         syscall sys_io
0268+  0F21 E4            pop a
0269+  0F22 09            ret
0270+  0F23             
0271+  0F23             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0F23             ; _strtoint
0273+  0F23             ; 4 digit hex string number in d
0274+  0F23             ; integer returned in a
0275+  0F23             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0F23             _strtointx:
0277+  0F23 D8            push b
0278+  0F24 32            mov bl, [d]
0279+  0F25 37            mov bh, bl
0280+  0F26 33 01 00      mov bl, [d + 1]
0281+  0F29 07 FA 0D      call _atoi        ; convert to int in al
0282+  0F2C 23            mov ah, al        ; move to ah
0283+  0F2D 33 02 00      mov bl, [d + 2]
0284+  0F30 37            mov bh, bl
0285+  0F31 33 03 00      mov bl, [d + 3]
0286+  0F34 07 FA 0D      call _atoi        ; convert to int in al
0287+  0F37 E5            pop b
0288+  0F38 09            ret
0289+  0F39             
0290+  0F39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0F39             ; _strtoint
0292+  0F39             ; 5 digit base10 string number in d
0293+  0F39             ; integer returned in a
0294+  0F39             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0F39             _strtoint:
0296+  0F39 E2            push si
0297+  0F3A D8            push b
0298+  0F3B D9            push c
0299+  0F3C DA            push d
0300+  0F3D 07 9C 0D      call _strlen      ; get string length in c
0301+  0F40 7E            dec c
0302+  0F41 FD 4E         mov si, d
0303+  0F43 12            mov a, c
0304+  0F44 FD 99         shl a
0305+  0F46 3B BD 10      mov d, table_power
0306+  0F49 59            add d, a
0307+  0F4A 38 00 00      mov c, 0
0308+  0F4D             _strtoint_l0:
0309+  0F4D F6            lodsb      ; load ascii to al
0310+  0F4E B9 00         cmp al, 0
0311+  0F50 C6 63 0F      je _strtoint_end
0312+  0F53 6F 30         sub al, $30    ; make into integer
0313+  0F55 22 00         mov ah, 0
0314+  0F57 2A            mov b, [d]
0315+  0F58 AC            mul a, b      ; result in b since it fits in 16bits
0316+  0F59 11            mov a, b
0317+  0F5A 28            mov b, c
0318+  0F5B 54            add a, b
0319+  0F5C 39            mov c, a
0320+  0F5D 63 02 00      sub d, 2
0321+  0F60 0A 4D 0F      jmp _strtoint_l0
0322+  0F63             _strtoint_end:
0323+  0F63 12            mov a, c
0324+  0F64 E7            pop d
0325+  0F65 E6            pop c
0326+  0F66 E5            pop b
0327+  0F67 EF            pop si
0328+  0F68 09            ret
0329+  0F69             
0330+  0F69             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0F69             ; print null terminated string
0332+  0F69             ; pointer in d
0333+  0F69             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0F69             _puts:
0335+  0F69 D7            push a
0336+  0F6A DA            push d
0337+  0F6B             _puts_l1:
0338+  0F6B 1E            mov al, [d]
0339+  0F6C B9 00         cmp al, 0
0340+  0F6E C6 7A 0F      jz _puts_end
0341+  0F71 23            mov ah, al
0342+  0F72 19 00         mov al, 0
0343+  0F74 05 03         syscall sys_io
0344+  0F76 79            inc d
0345+  0F77 0A 6B 0F      jmp _puts_l1
0346+  0F7A             _puts_end:
0347+  0F7A E7            pop d
0348+  0F7B E4            pop a
0349+  0F7C 09            ret
0350+  0F7D             
0351+  0F7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0F7D             ; print n size string
0353+  0F7D             ; pointer in d
0354+  0F7D             ; size in c
0355+  0F7D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0F7D             _putsn:
0357+  0F7D DB            push al
0358+  0F7E DA            push d
0359+  0F7F D9            push c
0360+  0F80             _putsn_l0:
0361+  0F80 1E            mov al, [d]
0362+  0F81 23            mov ah, al
0363+  0F82 19 00         mov al, 0
0364+  0F84 05 03         syscall sys_io
0365+  0F86 79            inc d
0366+  0F87 7E            dec c  
0367+  0F88 C2 00 00      cmp c, 0
0368+  0F8B C7 80 0F      jne _putsn_l0
0369+  0F8E             _putsn_end:
0370+  0F8E E6            pop c
0371+  0F8F E7            pop d
0372+  0F90 E8            pop al
0373+  0F91 09            ret
0374+  0F92             
0375+  0F92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0F92             ; print 16bit decimal number
0377+  0F92             ; input number in a
0378+  0F92             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0F92             print_u16d:
0380+  0F92 D7            push a
0381+  0F93 D8            push b
0382+  0F94 FD D8         push g
0383+  0F96 26 10 27      mov b, 10000
0384+  0F99 AE            div a, b      ; get 10000's coeff.
0385+  0F9A 07 BE 0F      call print_number
0386+  0F9D 11            mov a, b
0387+  0F9E 26 E8 03      mov b, 1000
0388+  0FA1 AE            div a, b      ; get 1000's coeff.
0389+  0FA2 07 BE 0F      call print_number
0390+  0FA5 11            mov a, b
0391+  0FA6 26 64 00      mov b, 100
0392+  0FA9 AE            div a, b
0393+  0FAA 07 BE 0F      call print_number
0394+  0FAD 11            mov a, b
0395+  0FAE 26 0A 00      mov b, 10
0396+  0FB1 AE            div a, b
0397+  0FB2 07 BE 0F      call print_number
0398+  0FB5 1B            mov al, bl      ; 1's coeff in bl
0399+  0FB6 07 BE 0F      call print_number
0400+  0FB9 FD F1         pop g
0401+  0FBB E5            pop b
0402+  0FBC E4            pop a
0403+  0FBD 09            ret
0404+  0FBE             
0405+  0FBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0FBE             ; print al
0407+  0FBE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0FBE             print_number:
0409+  0FBE 6A 30         add al, $30
0410+  0FC0 23            mov ah, al
0411+  0FC1 07 3D 0E      call _putchar
0412+  0FC4 09            ret
0413+  0FC5             
0414+  0FC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0FC5             ; print 16bit hex integer
0416+  0FC5             ; integer value in reg b
0417+  0FC5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0FC5             print_u16x:
0419+  0FC5 D7            push a
0420+  0FC6 D8            push b
0421+  0FC7 DD            push bl
0422+  0FC8 30            mov bl, bh
0423+  0FC9 07 0B 0E      call _itoa        ; convert bh to char in a
0424+  0FCC 2F            mov bl, al        ; save al
0425+  0FCD 19 00         mov al, 0
0426+  0FCF 05 03         syscall sys_io        ; display ah
0427+  0FD1 24            mov ah, bl        ; retrieve al
0428+  0FD2 19 00         mov al, 0
0429+  0FD4 05 03         syscall sys_io        ; display al
0430+  0FD6             
0431+  0FD6 EA            pop bl
0432+  0FD7 07 0B 0E      call _itoa        ; convert bh to char in a
0433+  0FDA 2F            mov bl, al        ; save al
0434+  0FDB 19 00         mov al, 0
0435+  0FDD 05 03         syscall sys_io        ; display ah
0436+  0FDF 24            mov ah, bl        ; retrieve al
0437+  0FE0 19 00         mov al, 0
0438+  0FE2 05 03         syscall sys_io        ; display al
0439+  0FE4             
0440+  0FE4 E5            pop b
0441+  0FE5 E4            pop a
0442+  0FE6 09            ret
0443+  0FE7             
0444+  0FE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0FE7             ; input 16bit hex integer
0446+  0FE7             ; read 16bit integer into a
0447+  0FE7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0FE7             scan_u16x:
0449+  0FE7 F8 10 00      enter 16
0450+  0FEA D8            push b
0451+  0FEB DA            push d
0452+  0FEC             
0453+  0FEC FA F1 FF      lea d, [bp + -15]
0454+  0FEF 07 44 0E      call _gets        ; get number
0455+  0FF2             
0456+  0FF2 32            mov bl, [d]
0457+  0FF3 37            mov bh, bl
0458+  0FF4 33 01 00      mov bl, [d + 1]
0459+  0FF7 07 FA 0D      call _atoi        ; convert to int in al
0460+  0FFA 23            mov ah, al        ; move to ah
0461+  0FFB             
0462+  0FFB 33 02 00      mov bl, [d + 2]
0463+  0FFE 37            mov bh, bl
0464+  0FFF 33 03 00      mov bl, [d + 3]
0465+  1002 07 FA 0D      call _atoi        ; convert to int in al
0466+  1005             
0467+  1005 E7            pop d
0468+  1006 E5            pop b
0469+  1007 F9            leave
0470+  1008 09            ret
0471+  1009             
0472+  1009             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1009             ; print 8bit hex integer
0474+  1009             ; integer value in reg bl
0475+  1009             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1009             print_u8x:
0477+  1009 D7            push a
0478+  100A DD            push bl
0479+  100B             
0480+  100B 07 0B 0E      call _itoa        ; convert bl to char in a
0481+  100E 2F            mov bl, al        ; save al
0482+  100F 19 00         mov al, 0
0483+  1011 05 03         syscall sys_io        ; display ah
0484+  1013 24            mov ah, bl        ; retrieve al
0485+  1014 19 00         mov al, 0
0486+  1016 05 03         syscall sys_io        ; display al
0487+  1018             
0488+  1018 EA            pop bl
0489+  1019 E4            pop a
0490+  101A 09            ret
0491+  101B             
0492+  101B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  101B             ; print 8bit decimal unsigned number
0494+  101B             ; input number in al
0495+  101B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  101B             print_u8d:
0497+  101B D7            push a
0498+  101C D8            push b
0499+  101D FD D8         push g
0500+  101F 22 00         mov ah, 0
0501+  1021 26 64 00      mov b, 100
0502+  1024 AE            div a, b
0503+  1025 D8            push b      ; save remainder
0504+  1026 B9 00         cmp al, 0
0505+  1028 C6 32 10      je skip100
0506+  102B 6A 30         add al, $30
0507+  102D 23            mov ah, al
0508+  102E 19 00         mov al, 0
0509+  1030 05 03         syscall sys_io  ; print coeff
0510+  1032             skip100:
0511+  1032 E4            pop a
0512+  1033 22 00         mov ah, 0
0513+  1035 26 0A 00      mov b, 10
0514+  1038 AE            div a, b
0515+  1039 D8            push b      ; save remainder
0516+  103A B9 00         cmp al, 0
0517+  103C C6 46 10      je skip10
0518+  103F 6A 30         add al, $30
0519+  1041 23            mov ah, al
0520+  1042 19 00         mov al, 0
0521+  1044 05 03         syscall sys_io  ; print coeff
0522+  1046             skip10:
0523+  1046 E4            pop a
0524+  1047 1B            mov al, bl
0525+  1048 6A 30         add al, $30
0526+  104A 23            mov ah, al
0527+  104B 19 00         mov al, 0
0528+  104D 05 03         syscall sys_io  ; print coeff
0529+  104F FD F1         pop g
0530+  1051 E5            pop b
0531+  1052 E4            pop a
0532+  1053 09            ret
0533+  1054             
0534+  1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1054             ; input 8bit hex integer
0536+  1054             ; read 8bit integer into al
0537+  1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1054             scan_u8x:
0539+  1054 F8 04 00      enter 4
0540+  1057 D8            push b
0541+  1058 DA            push d
0542+  1059             
0543+  1059 FA FD FF      lea d, [bp + -3]
0544+  105C 07 44 0E      call _gets        ; get number
0545+  105F             
0546+  105F 32            mov bl, [d]
0547+  1060 37            mov bh, bl
0548+  1061 33 01 00      mov bl, [d + 1]
0549+  1064 07 FA 0D      call _atoi        ; convert to int in al
0550+  1067             
0551+  1067 E7            pop d
0552+  1068 E5            pop b
0553+  1069 F9            leave
0554+  106A 09            ret
0555+  106B             
0556+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  106B             ; input decimal number
0558+  106B             ; result in a
0559+  106B             ; 655'\0'
0560+  106B             ; low--------high
0561+  106B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  106B             scan_u16d:
0563+  106B F8 08 00      enter 8
0564+  106E E2            push si
0565+  106F D8            push b
0566+  1070 D9            push c
0567+  1071 DA            push d
0568+  1072 FA F9 FF      lea d, [bp +- 7]
0569+  1075 07 44 0E      call _gets
0570+  1078 07 9C 0D      call _strlen      ; get string length in c
0571+  107B 7E            dec c
0572+  107C FD 4E         mov si, d
0573+  107E 12            mov a, c
0574+  107F FD 99         shl a
0575+  1081 3B BD 10      mov d, table_power
0576+  1084 59            add d, a
0577+  1085 38 00 00      mov c, 0
0578+  1088             mul_loop:
0579+  1088 F6            lodsb      ; load ascii to al
0580+  1089 B9 00         cmp al, 0
0581+  108B C6 9E 10      je mul_exit
0582+  108E 6F 30         sub al, $30    ; make into integer
0583+  1090 22 00         mov ah, 0
0584+  1092 2A            mov b, [d]
0585+  1093 AC            mul a, b      ; result in b since it fits in 16bits
0586+  1094 11            mov a, b
0587+  1095 28            mov b, c
0588+  1096 54            add a, b
0589+  1097 39            mov c, a
0590+  1098 63 02 00      sub d, 2
0591+  109B 0A 88 10      jmp mul_loop
0592+  109E             mul_exit:
0593+  109E 12            mov a, c
0594+  109F E7            pop d
0595+  10A0 E6            pop c
0596+  10A1 E5            pop b
0597+  10A2 EF            pop si
0598+  10A3 F9            leave
0599+  10A4 09            ret
0600+  10A5             
0601+  10A5             
0602+  10A5 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  10A9 34 35 36 37 
0602+  10AD 38 39 61 62 
0602+  10B1 63 64 65 66 
0603+  10B5 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  10B9 1B 5B 68 00 
0604+  10BD             
0605+  10BD             table_power:
0606+  10BD 01 00         .dw 1
0607+  10BF 0A 00         .dw 10
0608+  10C1 64 00         .dw 100
0609+  10C3 E8 03         .dw 1000
0610+  10C5 10 27         .dw 100000286   10C7             .include "lib/ctype.asm"
0001+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10C7             ; ctype.s
0003+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10C7             
0005+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  10C7             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  10C7             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  10C7             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  10C7             ;; characters are supported.
0010+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  10C7             ;; _isalnum 
0012+  10C7             ;; _isalpha 
0013+  10C7             ;; islower 
0014+  10C7             ;; isupper 
0015+  10C7             ;; _isdigit 
0016+  10C7             ;; isxdigit
0017+  10C7             ;; iscntrl 
0018+  10C7             ;; isgraph 
0019+  10C7             ;; _isspace 
0020+  10C7             ;; isblank 
0021+  10C7             ;; isprint 
0022+  10C7             ;; ispunct 
0023+  10C7             ;; tolower 
0024+  10C7             ;; toupper
0025+  10C7             
0026+  10C7             
0027+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  10C7             ;; is alphanumeric
0029+  10C7             ;; sets zf according with result
0030+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  10C7             _isalnum:
0032+  10C7 07 E4 10    	call _isalpha
0033+  10CA C6 D0 10    	je _isalnum_exit
0034+  10CD 07 D1 10    	call _isdigit
0035+  10D0             _isalnum_exit:
0036+  10D0 09          	ret	
0037+  10D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  10D1             ;; is digit
0039+  10D1             ;; sets zf according with result
0040+  10D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  10D1             _isdigit:
0042+  10D1 DB          	push al
0043+  10D2 B9 30       	cmp al, '0'
0044+  10D4 C8 E0 10    	jlu _isdigit_false
0045+  10D7 B9 39       	cmp al, '9'
0046+  10D9 D1 E0 10    	jgu _isdigit_false
0047+  10DC 87 00       	and al, 0	; set zf
0048+  10DE E8          	pop al
0049+  10DF 09          	ret
0050+  10E0             _isdigit_false:
0051+  10E0 8B 01       	or al, 1	; clear zf
0052+  10E2 E8          	pop al
0053+  10E3 09          	ret	
0054+  10E4             	
0055+  10E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  10E4             ;; is alpha
0057+  10E4             ;; sets zf according with result
0058+  10E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  10E4             _isalpha:
0060+  10E4 DB          	push al
0061+  10E5 B9 5F       	cmp al, '_'
0062+  10E7 C6 07 11    	je _isalpha_true
0063+  10EA B9 2E       	cmp al, '.'
0064+  10EC C6 07 11    	je _isalpha_true
0065+  10EF B9 61       	cmp al, 'a'
0066+  10F1 C8 03 11    	jlu _isalpha_false
0067+  10F4 B9 7A       	cmp al, 'z'
0068+  10F6 D1 03 11    	jgu _isalpha_false
0069+  10F9 B9 7A       	cmp al, 'z'
0070+  10FB D0 07 11    	jleu _isalpha_true
0071+  10FE B9 61       	cmp al, 'a'
0072+  1100 C9 07 11    	jgeu _isalpha_true
0073+  1103             _isalpha_false:
0074+  1103 8B 01       	or al, 1	; clear zf
0075+  1105 E8          	pop al
0076+  1106 09          	ret
0077+  1107             _isalpha_true:
0078+  1107 87 00       	and al, 0	; set zf
0079+  1109 E8          	pop al
0080+  110A 09          	ret
0081+  110B             
0082+  110B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  110B             ;; is path-alpha
0084+  110B             ;; sets zf according with result
0085+  110B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  110B             ispath:
0087+  110B DB          	push al
0088+  110C 07 D1 10    	call _isdigit
0089+  110F C6 39 11    	je ispath_true
0090+  1112 B9 5F       	cmp al, '_'
0091+  1114 C6 39 11    	je ispath_true
0092+  1117 B9 2F       	cmp al, '/'
0093+  1119 C6 39 11    	je ispath_true
0094+  111C B9 2E       	cmp al, '.'
0095+  111E C6 39 11    	je ispath_true
0096+  1121 B9 61       	cmp al, 'a'
0097+  1123 C8 35 11    	jlu ispath_false
0098+  1126 B9 7A       	cmp al, 'z'
0099+  1128 D1 35 11    	jgu ispath_false
0100+  112B B9 7A       	cmp al, 'z'
0101+  112D D0 39 11    	jleu ispath_true
0102+  1130 B9 61       	cmp al, 'a'
0103+  1132 C9 39 11    	jgeu ispath_true
0104+  1135             ispath_false:
0105+  1135 8B 01       	or al, 1	; clear zf
0106+  1137 E8          	pop al
0107+  1138 09          	ret
0108+  1139             ispath_true:
0109+  1139 87 00       	and al, 0	; set zf
0110+  113B E8          	pop al
0111+  113C 09          	ret
0112+  113D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  113D             ;; is space
0114+  113D             ;; sets zf according with result
0115+  113D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  113D             _isspace:
0117+  113D B9 20       	cmp al, $20		; ' '
0118+  113F C6 53 11    	je _isspace_exit
0119+  1142 B9 09       	cmp al, $09		; '\t'
0120+  1144 C6 53 11    	je _isspace_exit
0121+  1147 B9 0A       	cmp al, $0a		; '\n'
0122+  1149 C6 53 11    	je _isspace_exit
0123+  114C B9 0D       	cmp al, $0d		; '\r'
0124+  114E C6 53 11    	je _isspace_exit
0125+  1151 B9 0B       	cmp al, $0b		; '\v'
0126+  1153             _isspace_exit:
0127+  1153 09          	ret	
0128+  1154             
0129+  1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1154             ; to lower
0131+  1154             ; input in al
0132+  1154             ; output in al
0133+  1154             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1154             _to_lower:
0135+  1154 B9 7A       	cmp al, 'z'
0136+  1156 D1 5B 11    	jgu _to_lower_ret
0137+  1159 6A 20       	add al, $20				; convert to lower case
0138+  115B             _to_lower_ret:
0139+  115B 09          	ret
0140+  115C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  115C             ; to upper
0142+  115C             ; input in al
0143+  115C             ; output in al
0144+  115C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  115C             _to_upper:
0146+  115C B9 61       	cmp al, 'a'
0147+  115E C8 63 11    	jlu _to_upper_ret
0148+  1161 6F 20       	sub al, $20			; convert to upper case
0149+  1163             _to_upper_ret:
0150+  1163 09          	ret
0151+  1164             
0287   1164             .include "lib/token.asm"
0001+  1164             toktyp_identifier  .equ 0
0002+  1164             toktyp_keyword     .equ 1
0003+  1164             toktyp_delimiter   .equ 2
0004+  1164             toktyp_string      .equ 3
0005+  1164             toktyp_char        .equ 4
0006+  1164             toktyp_numeric     .equ 5
0007+  1164             toktyp_end         .equ 6
0008+  1164             
0009+  1164             tok_null           .equ 0
0010+  1164             tok_fslash         .equ 1
0011+  1164             tok_times          .equ 2
0012+  1164             tok_plus           .equ 3
0013+  1164             tok_minus          .equ 4
0014+  1164             tok_dot            .equ 5
0015+  1164             tok_semi           .equ 6
0016+  1164             tok_angle          .equ 7
0017+  1164             tok_tilde          .equ 8
0018+  1164             tok_equal          .equ 9
0019+  1164             tok_colon          .equ 10
0020+  1164             tok_comma          .equ 11
0021+  1164             
0022+  1164             tok_end            .equ 20
0023+  1164             
0024+  1164             
0025+  1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1164             ;; read a full command argment from shell input buffer
0027+  1164             ;; argument is written into tokstr
0028+  1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1164             get_arg:
0030+  1164 D7            push a
0031+  1165 E2            push si
0032+  1166 E3            push di
0033+  1167 19 00         mov al, 0
0034+  1169 3D 92 13      mov [tokstr], al      ; nullify tokstr string
0035+  116C 14 8E 13      mov a, [prog]
0036+  116F 4D            mov si, a
0037+  1170 FD 4F 92 13   mov di, tokstr
0038+  1174             get_arg_skip_spaces:
0039+  1174 F6            lodsb
0040+  1175 07 3D 11      call _isspace
0041+  1178 C6 74 11      je get_arg_skip_spaces
0042+  117B             get_arg_l0:
0043+  117B B9 3B         cmp al, $3b        ; check if is ';'
0044+  117D C6 8A 11      je get_arg_end
0045+  1180 B9 00         cmp al, 0
0046+  1182 C6 8A 11      je get_arg_end      ; check if end of input
0047+  1185 F7            stosb
0048+  1186 F6            lodsb
0049+  1187 0A 7B 11      jmp get_arg_l0
0050+  118A             get_arg_end:
0051+  118A 19 00         mov al, 0
0052+  118C F7            stosb
0053+  118D D5 01 00      sub si, 1
0054+  1190 4E            mov a, si
0055+  1191 42 8E 13      mov [prog], a    ; update pointer
0056+  1194 F0            pop di
0057+  1195 EF            pop si
0058+  1196 E4            pop a
0059+  1197 09            ret
0060+  1198             
0061+  1198             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1198             ;; read a path formation from shell input buffer
0063+  1198             ;; path is written into tokstr
0064+  1198             ;; /usr/bin
0065+  1198             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1198             get_path:
0067+  1198 D7            push a
0068+  1199 E2            push si
0069+  119A E3            push di
0070+  119B 19 00         mov al, 0
0071+  119D 3D 92 13      mov [tokstr], al      ; nullify tokstr string
0072+  11A0 14 8E 13      mov a, [prog]
0073+  11A3 4D            mov si, a
0074+  11A4 FD 4F 92 13   mov di, tokstr
0075+  11A8             get_path_skip_spaces:
0076+  11A8 F6            lodsb
0077+  11A9 07 3D 11      call _isspace
0078+  11AC C6 A8 11      je get_path_skip_spaces
0079+  11AF             get_path_is_pathchar:
0080+  11AF F7            stosb
0081+  11B0 F6            lodsb
0082+  11B1 07 C7 10      call _isalnum      ;check if is alphanumeric
0083+  11B4 C6 AF 11      je get_path_is_pathchar
0084+  11B7 B9 2F         cmp al, '/'        ; check if is '/'
0085+  11B9 C6 AF 11      je get_path_is_pathchar
0086+  11BC 19 00         mov al, 0
0087+  11BE F7            stosb
0088+  11BF D5 01 00      sub si, 1
0089+  11C2 4E            mov a, si
0090+  11C3 42 8E 13      mov [prog], a    ; update pointer
0091+  11C6             get_path_end:
0092+  11C6 F0            pop di
0093+  11C7 EF            pop si
0094+  11C8 E4            pop a
0095+  11C9 09            ret
0096+  11CA             
0097+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  11CA             ;; read a line
0099+  11CA             ;; line is written into tokstr
0100+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  11CA             get_line:
0102+  11CA D7            push a
0103+  11CB E2            push si
0104+  11CC E3            push di
0105+  11CD 19 00         mov al, 0
0106+  11CF 3D 92 13      mov [tokstr], al      ; nullify tokstr string
0107+  11D2 14 8E 13      mov a, [prog]
0108+  11D5 4D            mov si, a
0109+  11D6 FD 4F 92 13   mov di, tokstr
0110+  11DA             get_line_l0:
0111+  11DA F6            lodsb
0112+  11DB B9 0A         cmp al, $0a    ; check for new line
0113+  11DD C6 E4 11      je get_line_exit
0114+  11E0 F7            stosb
0115+  11E1 0A DA 11      jmp get_line_l0
0116+  11E4             get_line_exit:
0117+  11E4 19 00         mov al, 0
0118+  11E6 F7            stosb
0119+  11E7 4E            mov a, si
0120+  11E8 42 8E 13      mov [prog], a    ; update pointer
0121+  11EB F0            pop di
0122+  11EC EF            pop si
0123+  11ED E4            pop a
0124+  11EE 09            ret
0125+  11EF             
0126+  11EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  11EF             ;; token parser
0128+  11EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  11EF             get_token:
0130+  11EF D7            push a
0131+  11F0 DA            push d
0132+  11F1 E2            push si
0133+  11F2 E3            push di
0134+  11F3 19 00         mov al, 0
0135+  11F5 3D 92 13      mov [tokstr], al      ; nullify tokstr string
0136+  11F8 19 00         mov al, tok_null
0137+  11FA 3D 91 13      mov [tok], al        ; nullify token
0138+  11FD 14 8E 13      mov a, [prog]
0139+  1200 4D            mov si, a
0140+  1201 FD 4F 92 13   mov di, tokstr
0141+  1205             get_tok_skip_spaces:
0142+  1205 F6            lodsb
0143+  1206 07 3D 11      call _isspace
0144+  1209 C6 05 12      je get_tok_skip_spaces
0145+  120C B9 00         cmp al, 0      ; check for end of input (null)
0146+  120E C6 F3 12      je get_token_end
0147+  1211 B9 23         cmp al, '#'      ; comments!
0148+  1213 C6 21 13      je get_tok_comment
0149+  1216 07 C7 10      call _isalnum
0150+  1219 C6 00 13      jz is_alphanumeric
0151+  121C             ; other token types
0152+  121C             get_token_slash:
0153+  121C B9 2F         cmp al, '/'        ; check if '/'
0154+  121E C7 36 12      jne get_token_minus
0155+  1221 F7            stosb          ; store '/' into token string
0156+  1222 19 00         mov al, 0
0157+  1224 F7            stosb          ; terminate token string
0158+  1225 19 01         mov al, tok_fslash
0159+  1227 3D 91 13      mov [tok], al      
0160+  122A 19 02         mov al, toktyp_delimiter
0161+  122C 3D 90 13      mov [toktyp], al
0162+  122F 4E            mov a, si
0163+  1230 42 8E 13      mov [prog], a    ; update pointer
0164+  1233 0A 1C 13      jmp get_token_return
0165+  1236             get_token_minus:
0166+  1236 B9 2D         cmp al, '-'        ; check if '-'
0167+  1238 C7 50 12      jne get_token_comma
0168+  123B F7            stosb          ; store '-' into token string
0169+  123C 19 00         mov al, 0
0170+  123E F7            stosb          ; terminate token string
0171+  123F 19 04         mov al, tok_minus
0172+  1241 3D 91 13      mov [tok], al      
0173+  1244 19 02         mov al, toktyp_delimiter
0174+  1246 3D 90 13      mov [toktyp], al
0175+  1249 4E            mov a, si
0176+  124A 42 8E 13      mov [prog], a    ; update pointer
0177+  124D 0A 1C 13      jmp get_token_return
0178+  1250             get_token_comma:
0179+  1250 B9 2C         cmp al, ','        ; check if ','
0180+  1252 C7 6A 12      jne get_token_semi
0181+  1255 F7            stosb          ; store ',' into token string
0182+  1256 19 00         mov al, 0
0183+  1258 F7            stosb          ; terminate token string
0184+  1259 19 0B         mov al, tok_comma
0185+  125B 3D 91 13      mov [tok], al      
0186+  125E 19 02         mov al, toktyp_delimiter
0187+  1260 3D 90 13      mov [toktyp], al
0188+  1263 4E            mov a, si
0189+  1264 42 8E 13      mov [prog], a    ; update pointer
0190+  1267 0A 1C 13      jmp get_token_return
0191+  126A             get_token_semi:
0192+  126A B9 3B         cmp al, $3b        ; check if ';'
0193+  126C C7 84 12      jne get_token_colon
0194+  126F F7            stosb          ; store ';' into token string
0195+  1270 19 00         mov al, 0
0196+  1272 F7            stosb          ; terminate token string
0197+  1273 19 06         mov al, tok_semi
0198+  1275 3D 91 13      mov [tok], al      
0199+  1278 19 02         mov al, toktyp_delimiter
0200+  127A 3D 90 13      mov [toktyp], al
0201+  127D 4E            mov a, si
0202+  127E 42 8E 13      mov [prog], a    ; update pointer
0203+  1281 0A 1C 13      jmp get_token_return
0204+  1284             get_token_colon:
0205+  1284 B9 3A         cmp al, $3a        ; check if ':'
0206+  1286 C7 9E 12      jne get_token_angle
0207+  1289 F7            stosb          ; store ':' into token string
0208+  128A 19 00         mov al, 0
0209+  128C F7            stosb          ; terminate token string
0210+  128D 19 0A         mov al, tok_colon
0211+  128F 3D 91 13      mov [tok], al      
0212+  1292 19 02         mov al, toktyp_delimiter
0213+  1294 3D 90 13      mov [toktyp], al
0214+  1297 4E            mov a, si
0215+  1298 42 8E 13      mov [prog], a    ; update pointer
0216+  129B 0A 1C 13      jmp get_token_return
0217+  129E             get_token_angle:
0218+  129E B9 3E         cmp al, $3e        ; check if '>'
0219+  12A0 C7 B8 12      jne get_token_tilde
0220+  12A3 F7            stosb          ; store '>' into token string
0221+  12A4 19 00         mov al, 0
0222+  12A6 F7            stosb          ; terminate token string
0223+  12A7 19 07         mov al, tok_angle
0224+  12A9 3D 91 13      mov [tok], al      
0225+  12AC 19 02         mov al, toktyp_delimiter
0226+  12AE 3D 90 13      mov [toktyp], al
0227+  12B1 4E            mov a, si
0228+  12B2 42 8E 13      mov [prog], a    ; update pointer
0229+  12B5 0A 1C 13      jmp get_token_return
0230+  12B8             get_token_tilde:
0231+  12B8 B9 7E         cmp al, '~'        ; check if '~'
0232+  12BA C7 D2 12      jne get_token_equal
0233+  12BD F7            stosb          ; store '~' into token string
0234+  12BE 19 00         mov al, 0
0235+  12C0 F7            stosb          ; terminate token string
0236+  12C1 19 08         mov al, tok_tilde
0237+  12C3 3D 91 13      mov [tok], al      
0238+  12C6 19 02         mov al, toktyp_delimiter
0239+  12C8 3D 90 13      mov [toktyp], al
0240+  12CB 4E            mov a, si
0241+  12CC 42 8E 13      mov [prog], a    ; update pointer
0242+  12CF 0A 1C 13      jmp get_token_return
0243+  12D2             get_token_equal:
0244+  12D2 B9 3D         cmp al, '='        ; check if '='
0245+  12D4 C7 EC 12      jne get_token_skip
0246+  12D7 F7            stosb          ; store '=' into token string
0247+  12D8 19 00         mov al, 0
0248+  12DA F7            stosb          ; terminate token string
0249+  12DB 19 09         mov al, tok_equal
0250+  12DD 3D 91 13      mov [tok], al      
0251+  12E0 19 02         mov al, toktyp_delimiter
0252+  12E2 3D 90 13      mov [toktyp], al
0253+  12E5 4E            mov a, si
0254+  12E6 42 8E 13      mov [prog], a    ; update pointer
0255+  12E9 0A 1C 13      jmp get_token_return
0256+  12EC             get_token_skip:
0257+  12EC 4E            mov a, si
0258+  12ED 42 8E 13      mov [prog], a    ; update pointer
0259+  12F0 0A 1C 13      jmp get_token_return
0260+  12F3             get_token_end:        ; end of file token
0261+  12F3 19 14         mov al, tok_end
0262+  12F5 3D 91 13      mov [tok], al
0263+  12F8 19 06         mov al, toktyp_end
0264+  12FA 3D 90 13      mov [toktyp], al
0265+  12FD 0A 1C 13      jmp get_token_return
0266+  1300             is_alphanumeric:
0267+  1300 F7            stosb
0268+  1301 F6            lodsb
0269+  1302 07 C7 10      call _isalnum      ;check if is alphanumeric
0270+  1305 C6 00 13      jz is_alphanumeric
0271+  1308 B9 2E         cmp al, $2e        ; check if is '.'
0272+  130A C6 00 13      je is_alphanumeric
0273+  130D 19 00         mov al, 0
0274+  130F F7            stosb
0275+  1310 19 00         mov al, toktyp_identifier
0276+  1312 3D 90 13      mov [toktyp], al
0277+  1315 D5 01 00      sub si, 1
0278+  1318 4E            mov a, si
0279+  1319 42 8E 13      mov [prog], a    ; update pointer
0280+  131C             get_token_return:
0281+  131C F0            pop di
0282+  131D EF            pop si
0283+  131E E7            pop d
0284+  131F E4            pop a
0285+  1320 09            ret
0286+  1321             get_tok_comment:
0287+  1321 F6            lodsb
0288+  1322 B9 0A         cmp al, $0a      ; new line
0289+  1324 C7 21 13      jne get_tok_comment
0290+  1327 0A 05 12      jmp get_tok_skip_spaces
0291+  132A             
0292+  132A             
0293+  132A             get_number:
0294+  132A D7            push a
0295+  132B DA            push d
0296+  132C E2            push si
0297+  132D E3            push di
0298+  132E 19 00         mov al, 0
0299+  1330 3D 92 13      mov [tokstr], al      ; nullify tokstr string
0300+  1333 19 00         mov al, tok_null
0301+  1335 3D 91 13      mov [tok], al        ; nullify token
0302+  1338 14 8E 13      mov a, [prog]
0303+  133B 4D            mov si, a
0304+  133C FD 4F 92 13   mov di, tokstr
0305+  1340             get_number_skip_spaces:
0306+  1340 F6            lodsb
0307+  1341 07 3D 11      call _isspace
0308+  1344 C6 40 13      je get_number_skip_spaces
0309+  1347 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1349 C7 59 13      jne get_number_l0
0311+  134C 19 14         mov al, tok_end
0312+  134E 3D 91 13      mov [tok], al
0313+  1351 19 06         mov al, toktyp_end
0314+  1353 3D 90 13      mov [toktyp], al
0315+  1356 0A 70 13      jmp get_number_return
0316+  1359             get_number_l0:
0317+  1359 F7            stosb
0318+  135A F6            lodsb
0319+  135B 07 D1 10      call _isdigit      ;check if is numeric
0320+  135E C6 59 13      jz get_number_l0
0321+  1361 19 00         mov al, 0
0322+  1363 F7            stosb
0323+  1364 19 05         mov al, toktyp_numeric
0324+  1366 3D 90 13      mov [toktyp], al
0325+  1369 D5 01 00      sub si, 1
0326+  136C 4E            mov a, si
0327+  136D 42 8E 13      mov [prog], a    ; update pointer
0328+  1370             get_number_return:
0329+  1370 F0            pop di
0330+  1371 EF            pop si
0331+  1372 E7            pop d
0332+  1373 E4            pop a
0333+  1374 09            ret
0334+  1375             
0335+  1375             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1375             ;; put back token
0337+  1375             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1375             _putback:
0339+  1375 D7            push a
0340+  1376 E2            push si
0341+  1377 FD 4D 92 13   mov si, tokstr  
0342+  137B             _putback_loop:
0343+  137B F6            lodsb
0344+  137C B9 00         cmp al, 0
0345+  137E C6 8B 13      je _putback_end
0346+  1381 14 8E 13      mov a, [prog]
0347+  1384 7D            dec a
0348+  1385 42 8E 13      mov [prog], a      ; update pointer
0349+  1388 0A 7B 13      jmp _putback_loop
0350+  138B             _putback_end:
0351+  138B EF            pop si
0352+  138C E4            pop a
0353+  138D 09            ret
0354+  138E             
0355+  138E             
0356+  138E             
0357+  138E             
0358+  138E 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1390             
0360+  1390 00          toktyp:    .db 0          ; token type symbol
0361+  1391 00          tok:       .db 0          ; current token symbol
0362+  1392 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1396 00 00 00 00 
0362+  139A 00 00 00 00 
0362+  139E 00 00 00 00 
0362+  13A2 00 00 00 00 
0362+  13A6 00 00 00 00 
0362+  13AA 00 00 00 00 
0362+  13AE 00 00 00 00 
0362+  13B2 00 00 00 00 
0362+  13B6 00 00 00 00 
0362+  13BA 00 00 00 00 
0362+  13BE 00 00 00 00 
0362+  13C2 00 00 00 00 
0362+  13C6 00 00 00 00 
0362+  13CA 00 00 00 00 
0362+  13CE 00 00 00 00 
0362+  13D2 00 00 00 00 
0362+  13D6 00 00 00 00 
0362+  13DA 00 00 00 00 
0362+  13DE 00 00 00 00 
0362+  13E2 00 00 00 00 
0362+  13E6 00 00 00 00 
0362+  13EA 00 00 00 00 
0362+  13EE 00 00 00 00 
0362+  13F2 00 00 00 00 
0362+  13F6 00 00 00 00 
0362+  13FA 00 00 00 00 
0362+  13FE 00 00 00 00 
0362+  1402 00 00 00 00 
0362+  1406 00 00 00 00 
0362+  140A 00 00 00 00 
0362+  140E 00 00 00 00 
0362+  1412 00 00 00 00 
0362+  1416 00 00 00 00 
0362+  141A 00 00 00 00 
0362+  141E 00 00 00 00 
0362+  1422 00 00 00 00 
0362+  1426 00 00 00 00 
0362+  142A 00 00 00 00 
0362+  142E 00 00 00 00 
0362+  1432 00 00 00 00 
0362+  1436 00 00 00 00 
0362+  143A 00 00 00 00 
0362+  143E 00 00 00 00 
0362+  1442 00 00 00 00 
0362+  1446 00 00 00 00 
0362+  144A 00 00 00 00 
0362+  144E 00 00 00 00 
0362+  1452 00 00 00 00 
0362+  1456 00 00 00 00 
0362+  145A 00 00 00 00 
0362+  145E 00 00 00 00 
0362+  1462 00 00 00 00 
0362+  1466 00 00 00 00 
0362+  146A 00 00 00 00 
0362+  146E 00 00 00 00 
0362+  1472 00 00 00 00 
0362+  1476 00 00 00 00 
0362+  147A 00 00 00 00 
0362+  147E 00 00 00 00 
0362+  1482 00 00 00 00 
0362+  1486 00 00 00 00 
0362+  148A 00 00 00 00 
0362+  148E 00 00 00 00 
0288   1492             
0289   1492             shell_transient_area:  ; shell transient data area
0290   1492             
0291   1492             .end
tasm: Number of errors = 0
