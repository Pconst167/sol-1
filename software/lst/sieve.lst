0001   0000             .include "lib/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0002   0000             
0003   0400             .org text_org			; origin at 1024
0004   0400             
0005   0400             TRUE:	.equ 1
0006   0400             FALSE:	.equ 0
0007   0400             SIZE:	.equ 8190
0008   0400             SIZEP1:	.equ 8191
0009   0400             
0010   0400             main:
0011   0400 3B A2 04    	mov d, s_title
0012   0403 07 A8 07    	call _puts
0013   0406             
0014   0406 10 01 00    	mov a, 1
0015   0409 42 92 05    	mov [iter], a
0016   040C             L0:
0017   040C FD 10       	cla
0018   040E 42 90 05    	mov [count], a
0019   0411 42 8A 05    	mov [i], a
0020   0414             L0_0:
0021   0414 14 8A 05    	mov a, [i]
0022   0417 3C          	mov d, a
0023   0418 19 01       	mov al, TRUE
0024   041A 3F 06 09    	mov [d + flags], al
0025   041D 14 8A 05    	mov a, [i]
0026   0420 77          	inc a
0027   0421 42 8A 05    	mov [i], a
0028   0424 AF FE 1F    	cmp a, SIZE
0029   0427 D0 14 04    	jleu L0_0	
0030   042A             
0031   042A 10 00 00    	mov a, 0
0032   042D 42 8A 05    	mov [i], a
0033   0430             L0_1:
0034   0430 14 8A 05    	mov a, [i]
0035   0433 3C          	mov d, a
0036   0434 1F 06 09    	mov al, [d + flags]
0037   0437 B9 01       	cmp al, TRUE
0038   0439 C6 59 04    	je IF_0_TRUE
0039   043C             L0_1_COND:	
0040   043C 14 8A 05    	mov a, [i]
0041   043F 77          	inc a
0042   0440 42 8A 05    	mov [i], a
0043   0443 AF FE 1F    	cmp a, SIZE
0044   0446 D0 30 04    	jleu L0_1	
0045   0449             L0_COND:
0046   0449 14 92 05    	mov a, [iter]
0047   044C 77          	inc a
0048   044D 42 92 05    	mov [iter], a
0049   0450 AF 0A 00    	cmp a, 10
0050   0453 D0 0C 04    	jleu L0
0051   0456 0A 94 04    	jmp L0_EXIT
0052   0459             IF_0_TRUE:
0053   0459 29 8A 05    	mov b, [i]
0054   045C 14 8A 05    	mov a, [i]
0055   045F 54          	add a, b
0056   0460 53 03 00    	add a, 3
0057   0463 42 8C 05    	mov [prime], a		; prime = i + i + 3
0058   0466 54          	add a, b
0059   0467 42 8E 05    	mov [k], a			; k = i + prime	
0060   046A             WHILE:
0061   046A 14 8E 05    	mov a, [k]
0062   046D 26 FE 1F    	mov b, SIZE
0063   0470 B0          	cmp a, b
0064   0471 D1 8A 04    	jgu WHILE_EXIT
0065   0474 14 8E 05    	mov a, [k]
0066   0477 3C          	mov d, a
0067   0478 19 00       	mov al, FALSE
0068   047A 3F 06 09    	mov [d + flags], al
0069   047D 14 8E 05    	mov a, [k]
0070   0480 29 8C 05    	mov b, [prime]
0071   0483 54          	add a, b
0072   0484 42 8E 05    	mov [k], a
0073   0487 0A 6A 04    	jmp WHILE
0074   048A             WHILE_EXIT:	
0075   048A 14 90 05    	mov a, [count]
0076   048D 77          	inc a
0077   048E 42 90 05    	mov [count], a	
0078   0491 0A 3C 04    	jmp L0_1_COND
0079   0494             
0080   0494             L0_EXIT:
0081   0494 14 90 05    	mov a, [count]
0082   0497 07 D1 07    	call print_u16d
0083   049A 3B 4D 05    	mov d, s_result
0084   049D 07 A8 07    	call _puts
0085   04A0             
0086   04A0 05 0B       	syscall sys_terminate_proc
0087   04A2             
0088   04A2 2D 2D 2D 2D s_title:	.db "-----------------------------------------------\n"
0088   04A6 2D 2D 2D 2D 
0088   04AA 2D 2D 2D 2D 
0088   04AE 2D 2D 2D 2D 
0088   04B2 2D 2D 2D 2D 
0088   04B6 2D 2D 2D 2D 
0088   04BA 2D 2D 2D 2D 
0088   04BE 2D 2D 2D 2D 
0088   04C2 2D 2D 2D 2D 
0088   04C6 2D 2D 2D 2D 
0088   04CA 2D 2D 2D 2D 
0088   04CE 2D 2D 2D 0A 
0089   04D2 42 79 74 65 			.db "Byte Magazine\'s Sieve of Erastothenes Benchmark\n"
0089   04D6 20 4D 61 67 
0089   04DA 61 7A 69 6E 
0089   04DE 65 27 73 20 
0089   04E2 53 69 65 76 
0089   04E6 65 20 6F 66 
0089   04EA 20 45 72 61 
0089   04EE 73 74 6F 74 
0089   04F2 68 65 6E 65 
0089   04F6 73 20 42 65 
0089   04FA 6E 63 68 6D 
0089   04FE 61 72 6B 0A 
0090   0502 53 69 7A 65 			.db "Size: 8192\n"
0090   0506 3A 20 38 31 
0090   050A 39 32 0A 
0091   050D 49 74 65 72 			.db "Iterations: 10\n"
0091   0511 61 74 69 6F 
0091   0515 6E 73 3A 20 
0091   0519 31 30 0A 
0092   051C 2D 2D 2D 2D 			.db "-----------------------------------------------\n", 0
0092   0520 2D 2D 2D 2D 
0092   0524 2D 2D 2D 2D 
0092   0528 2D 2D 2D 2D 
0092   052C 2D 2D 2D 2D 
0092   0530 2D 2D 2D 2D 
0092   0534 2D 2D 2D 2D 
0092   0538 2D 2D 2D 2D 
0092   053C 2D 2D 2D 2D 
0092   0540 2D 2D 2D 2D 
0092   0544 2D 2D 2D 2D 
0092   0548 2D 2D 2D 0A 
0092   054C 00 
0093   054D             
0094   054D 20 70 72 69 s_result:	.db " primes.\n"
0094   0551 6D 65 73 2E 
0094   0555 0A 
0095   0556 2D 2D 2D 2D 			.db "-----------------------------------------------\n", 0
0095   055A 2D 2D 2D 2D 
0095   055E 2D 2D 2D 2D 
0095   0562 2D 2D 2D 2D 
0095   0566 2D 2D 2D 2D 
0095   056A 2D 2D 2D 2D 
0095   056E 2D 2D 2D 2D 
0095   0572 2D 2D 2D 2D 
0095   0576 2D 2D 2D 2D 
0095   057A 2D 2D 2D 2D 
0095   057E 2D 2D 2D 2D 
0095   0582 2D 2D 2D 0A 
0095   0586 00 
0096   0587             
0097   0587 2C 20 00    s_comma:	.db ", ", 0
0098   058A             
0099   058A 00 00       i:		.dw
0100   058C 00 00       prime:	.dw
0101   058E 00 00       k:		.dw
0102   0590 00 00       count:	.dw
0103   0592 00 00       iter:	.dw
0104   0594             
0105   0594             
0106   0594             .include "lib/stdio.asm"
0001+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0594             ; stdio.s
0003+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0594             .include "lib/string.asm"
0001++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0594             ; string.s
0003++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0594             
0005++ 0594             
0006++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0594             ; _strrev
0008++ 0594             ; reverse a string
0009++ 0594             ; d = string address
0010++ 0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0594             ; 01234
0012++ 0594             _strrev:
0013++ 0594 4B          	pusha
0014++ 0595 07 DB 05    	call _strlen	; length in c
0015++ 0598 12          	mov a, c
0016++ 0599 AF 01 00    	cmp a, 1
0017++ 059C D0 B6 05    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 059F 7D          	dec a
0019++ 05A0 FD 4E       	mov si, d	; beginning of string
0020++ 05A2 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 05A4 59          	add d, a	; end of string
0022++ 05A5 12          	mov a, c
0023++ 05A6 FD 9B       	shr a		; divide by 2
0024++ 05A8 39          	mov c, a	; c now counts the steps
0025++ 05A9             _strrev_l0:
0026++ 05A9 32          	mov bl, [d]	; save load right-side char into bl
0027++ 05AA F6          	lodsb		; load left-side char into al; increase si
0028++ 05AB 3E          	mov [d], al	; store left char into right side
0029++ 05AC 1B          	mov al, bl
0030++ 05AD F7          	stosb		; store right-side char into left-side; increase di
0031++ 05AE 7E          	dec c
0032++ 05AF 7F          	dec d
0033++ 05B0 C2 00 00    	cmp c, 0
0034++ 05B3 C7 A9 05    	jne _strrev_l0
0035++ 05B6             _strrev_end:
0036++ 05B6 4C          	popa
0037++ 05B7 09          	ret
0038++ 05B8             	
0039++ 05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 05B8             ; _strchr
0041++ 05B8             ; search string in d for char in al
0042++ 05B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 05B8             _strchr:
0044++ 05B8             _strchr_l0:
0045++ 05B8 32          	mov bl, [d]
0046++ 05B9 C1 00       	cmp bl, 0
0047++ 05BB C6 C6 05    	je _strchr_end
0048++ 05BE BA          	cmp al, bl
0049++ 05BF C6 C6 05    	je _strchr_end
0050++ 05C2 79          	inc d
0051++ 05C3 0A B8 05    	jmp _strchr_l0
0052++ 05C6             _strchr_end:
0053++ 05C6 1B          	mov al, bl
0054++ 05C7 09          	ret
0055++ 05C8             
0056++ 05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 05C8             ; _strstr
0058++ 05C8             ; find sub-string
0059++ 05C8             ; str1 in si
0060++ 05C8             ; str2 in di
0061++ 05C8             ; si points to end of source string
0062++ 05C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 05C8             _strstr:
0064++ 05C8 DB          	push al
0065++ 05C9 DA          	push d
0066++ 05CA E3          	push di
0067++ 05CB             _strstr_loop:
0068++ 05CB F3          	cmpsb					; compare a byte of the strings
0069++ 05CC C7 D7 05    	jne _strstr_ret
0070++ 05CF FC 00 00    	lea d, [di + 0]
0071++ 05D2 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05D4 C7 CB 05    	jne _strstr_loop				; equal chars but not at end
0073++ 05D7             _strstr_ret:
0074++ 05D7 F0          	pop di
0075++ 05D8 E7          	pop d
0076++ 05D9 E8          	pop al
0077++ 05DA 09          	ret
0078++ 05DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05DB             ; length of null terminated string
0080++ 05DB             ; result in c
0081++ 05DB             ; pointer in d
0082++ 05DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05DB             _strlen:
0084++ 05DB DA          	push d
0085++ 05DC 38 00 00    	mov c, 0
0086++ 05DF             _strlen_l1:
0087++ 05DF BD 00       	cmp byte [d], 0
0088++ 05E1 C6 E9 05    	je _strlen_ret
0089++ 05E4 79          	inc d
0090++ 05E5 78          	inc c
0091++ 05E6 0A DF 05    	jmp _strlen_l1
0092++ 05E9             _strlen_ret:
0093++ 05E9 E7          	pop d
0094++ 05EA 09          	ret
0095++ 05EB             
0096++ 05EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05EB             ; strcmp
0098++ 05EB             ; compare two strings
0099++ 05EB             ; str1 in si
0100++ 05EB             ; str2 in di
0101++ 05EB             ; create a string compairon instrucion ?????
0102++ 05EB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05EB             _strcmp:
0104++ 05EB DB          	push al
0105++ 05EC DA          	push d
0106++ 05ED E3          	push di
0107++ 05EE E2          	push si
0108++ 05EF             _strcmp_loop:
0109++ 05EF F3          	cmpsb					; compare a byte of the strings
0110++ 05F0 C7 FB 05    	jne _strcmp_ret
0111++ 05F3 FB FF FF    	lea d, [si +- 1]
0112++ 05F6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05F8 C7 EF 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 05FB             _strcmp_ret:
0115++ 05FB EF          	pop si
0116++ 05FC F0          	pop di
0117++ 05FD E7          	pop d
0118++ 05FE E8          	pop al
0119++ 05FF 09          	ret
0120++ 0600             
0121++ 0600             
0122++ 0600             ; strcpy
0123++ 0600             ; copy null terminated string from si to di
0124++ 0600             ; source in si
0125++ 0600             ; destination in di
0126++ 0600             _strcpy:
0127++ 0600 E2          	push si
0128++ 0601 E3          	push di
0129++ 0602 DB          	push al
0130++ 0603             _strcpy_l1:
0131++ 0603 F6          	lodsb
0132++ 0604 F7          	stosb
0133++ 0605 B9 00       	cmp al, 0
0134++ 0607 C7 03 06    	jne _strcpy_l1
0135++ 060A             _strcpy_end:
0136++ 060A E8          	pop al
0137++ 060B F0          	pop di
0138++ 060C EF          	pop si
0139++ 060D 09          	ret
0140++ 060E             
0141++ 060E             ; strcat
0142++ 060E             ; concatenate a null terminated string into string at di, from string at si
0143++ 060E             ; source in si
0144++ 060E             ; destination in di
0145++ 060E             _strcat:
0146++ 060E E2          	push si
0147++ 060F E3          	push di
0148++ 0610 D7          	push a
0149++ 0611 DA          	push d
0150++ 0612 50          	mov a, di
0151++ 0613 3C          	mov d, a
0152++ 0614             _strcat_goto_end_l1:
0153++ 0614 BD 00       	cmp byte[d], 0
0154++ 0616 C6 1D 06    	je _strcat_start
0155++ 0619 79          	inc d
0156++ 061A 0A 14 06    	jmp _strcat_goto_end_l1
0157++ 061D             _strcat_start:
0158++ 061D FD 50       	mov di, d
0159++ 061F             _strcat_l1:
0160++ 061F F6          	lodsb
0161++ 0620 F7          	stosb
0162++ 0621 B9 00       	cmp al, 0
0163++ 0623 C7 1F 06    	jne _strcat_l1
0164++ 0626             _strcat_end:
0165++ 0626 E7          	pop d
0166++ 0627 E4          	pop a
0167++ 0628 F0          	pop di
0168++ 0629 EF          	pop si
0169++ 062A 09          	ret
0170++ 062B             
0171++ 062B             
0005+  062B             
0006+  062B             
0007+  062B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  062B             ; convert ascii 'o'..'f' to integer 0..15
0009+  062B             ; ascii in bl
0010+  062B             ; result in al
0011+  062B             ; ascii for f = 0100 0110
0012+  062B             ; ascii for 9 = 0011 1001
0013+  062B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  062B             hex_ascii_encode:
0015+  062B 1B            mov al, bl
0016+  062C 93 40         test al, $40        ; test if letter or number
0017+  062E C7 34 06      jnz hex_letter
0018+  0631 87 0F         and al, $0f        ; get number
0019+  0633 09            ret
0020+  0634             hex_letter:
0021+  0634 87 0F         and al, $0f        ; get letter
0022+  0636 6A 09         add al, 9
0023+  0638 09            ret
0024+  0639             
0025+  0639             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0639             ; atoi
0027+  0639             ; 2 letter hex string in b
0028+  0639             ; 8bit integer returned in al
0029+  0639             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0639             _atoi:
0031+  0639 D8            push b
0032+  063A 07 2B 06      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  063D 30            mov bl, bh
0034+  063E DB            push al          ; save a
0035+  063F 07 2B 06      call hex_ascii_encode
0036+  0642 EA            pop bl  
0037+  0643 FD 9E 04      shl al, 4
0038+  0646 8C            or al, bl
0039+  0647 E5            pop b
0040+  0648 09            ret  
0041+  0649             
0042+  0649             
0043+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0649             ; scanf
0045+  0649             ; no need for explanations!
0046+  0649             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0649             scanf:
0048+  0649 09            ret
0049+  064A             
0050+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  064A             ; itoa
0052+  064A             ; 8bit value in bl
0053+  064A             ; 2 byte ascii result in a
0054+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  064A             _itoa:
0056+  064A DA            push d
0057+  064B D8            push b
0058+  064C A7 00         mov bh, 0
0059+  064E FD A4 04      shr bl, 4  
0060+  0651 74            mov d, b
0061+  0652 1F E4 08      mov al, [d + s_hex_digits]
0062+  0655 23            mov ah, al
0063+  0656               
0064+  0656 E5            pop b
0065+  0657 D8            push b
0066+  0658 A7 00         mov bh, 0
0067+  065A FD 87 0F      and bl, $0f
0068+  065D 74            mov d, b
0069+  065E 1F E4 08      mov al, [d + s_hex_digits]
0070+  0661 E5            pop b
0071+  0662 E7            pop d
0072+  0663 09            ret
0073+  0664             
0074+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0664             ; hex string to binary
0076+  0664             ; di = destination address
0077+  0664             ; si = source
0078+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0664             _hex_to_int:
0080+  0664             _hex_to_int_l1:
0081+  0664 F6            lodsb          ; load from [si] to al
0082+  0665 B9 00         cmp al, 0        ; check if ascii 0
0083+  0667 C6 74 06      jz _hex_to_int_ret
0084+  066A 36            mov bh, al
0085+  066B F6            lodsb
0086+  066C 2F            mov bl, al
0087+  066D 07 39 06      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0670 F7            stosb          ; store al to [di]
0089+  0671 0A 64 06      jmp _hex_to_int_l1
0090+  0674             _hex_to_int_ret:
0091+  0674 09            ret    
0092+  0675             
0093+  0675             
0094+  0675             
0095+  0675             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0675             ; getchar
0097+  0675             ; char in ah
0098+  0675             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0675             getch:
0100+  0675 DB            push al
0101+  0676             getch_retry:
0102+  0676 19 01         mov al, 1
0103+  0678 05 03         syscall sys_io      ; receive in ah
0104+  067A E8            pop al
0105+  067B 09            ret
0106+  067C             
0107+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  067C             ; putchar
0109+  067C             ; char in ah
0110+  067C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  067C             _putchar:
0112+  067C DB            push al
0113+  067D 19 00         mov al, 0
0114+  067F 05 03         syscall sys_io      ; char in ah
0115+  0681 E8            pop al
0116+  0682 09            ret
0117+  0683             
0118+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0683             ;; input a string
0120+  0683             ;; terminates with null
0121+  0683             ;; pointer in d
0122+  0683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0683             _gets:
0124+  0683 D7            push a
0125+  0684 DA            push d
0126+  0685             _gets_loop:
0127+  0685 19 01         mov al, 1
0128+  0687 05 03         syscall sys_io      ; receive in ah
0129+  0689 76 1B         cmp ah, 27
0130+  068B C6 AC 06      je _gets_ansi_esc
0131+  068E 76 0A         cmp ah, $0a        ; lf
0132+  0690 C6 08 07      je _gets_end
0133+  0693 76 0D         cmp ah, $0d        ; cr
0134+  0695 C6 08 07      je _gets_end
0135+  0698 76 5C         cmp ah, $5c        ; '\\'
0136+  069A C6 CE 06      je _gets_escape
0137+  069D 76 08         cmp ah, $08      ; check for backspace
0138+  069F C6 A8 06      je _gets_backspace
0139+  06A2 1A            mov al, ah
0140+  06A3 3E            mov [d], al
0141+  06A4 79            inc d
0142+  06A5 0A 85 06      jmp _gets_loop
0143+  06A8             _gets_backspace:
0144+  06A8 7F            dec d
0145+  06A9 0A 85 06      jmp _gets_loop
0146+  06AC             _gets_ansi_esc:
0147+  06AC 19 01         mov al, 1
0148+  06AE 05 03         syscall sys_io        ; receive in ah without echo
0149+  06B0 76 5B         cmp ah, '['
0150+  06B2 C7 85 06      jne _gets_loop
0151+  06B5 19 01         mov al, 1
0152+  06B7 05 03         syscall sys_io          ; receive in ah without echo
0153+  06B9 76 64         cmp ah, 'd'
0154+  06BB C6 C6 06      je _gets_left_arrow
0155+  06BE 76 63         cmp ah, 'c'
0156+  06C0 C6 CA 06      je _gets_right_arrow
0157+  06C3 0A 85 06      jmp _gets_loop
0158+  06C6             _gets_left_arrow:
0159+  06C6 7F            dec d
0160+  06C7 0A 85 06      jmp _gets_loop
0161+  06CA             _gets_right_arrow:
0162+  06CA 79            inc d
0163+  06CB 0A 85 06      jmp _gets_loop
0164+  06CE             _gets_escape:
0165+  06CE 19 01         mov al, 1
0166+  06D0 05 03         syscall sys_io      ; receive in ah
0167+  06D2 76 6E         cmp ah, 'n'
0168+  06D4 C6 F3 06      je _gets_lf
0169+  06D7 76 72         cmp ah, 'r'
0170+  06D9 C6 FA 06      je _gets_cr
0171+  06DC 76 30         cmp ah, '0'
0172+  06DE C6 01 07      je _gets_null
0173+  06E1 76 5C         cmp ah, $5c  ; '\'
0174+  06E3 C6 EC 06      je _gets_slash
0175+  06E6 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  06E7 3E            mov [d], al
0177+  06E8 79            inc d
0178+  06E9 0A 85 06      jmp _gets_loop
0179+  06EC             _gets_slash:
0180+  06EC 19 5C         mov al, $5c
0181+  06EE 3E            mov [d], al
0182+  06EF 79            inc d
0183+  06F0 0A 85 06      jmp _gets_loop
0184+  06F3             _gets_lf:
0185+  06F3 19 0A         mov al, $0a
0186+  06F5 3E            mov [d], al
0187+  06F6 79            inc d
0188+  06F7 0A 85 06      jmp _gets_loop
0189+  06FA             _gets_cr:
0190+  06FA 19 0D         mov al, $0d
0191+  06FC 3E            mov [d], al
0192+  06FD 79            inc d
0193+  06FE 0A 85 06      jmp _gets_loop
0194+  0701             _gets_null:
0195+  0701 19 00         mov al, $00
0196+  0703 3E            mov [d], al
0197+  0704 79            inc d
0198+  0705 0A 85 06      jmp _gets_loop
0199+  0708             _gets_end:
0200+  0708 19 00         mov al, 0
0201+  070A 3E            mov [d], al        ; terminate string
0202+  070B E7            pop d
0203+  070C E4            pop a
0204+  070D 09            ret
0205+  070E             
0206+  070E             
0207+  070E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  070E             ;; input text
0209+  070E             ;; terminated with ctrl+d
0210+  070E             ;; pointer in d
0211+  070E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  070E             _gettxt:
0213+  070E D7            push a
0214+  070F DA            push d
0215+  0710             _gettxt_loop:
0216+  0710 19 01         mov al, 1
0217+  0712 05 03         syscall sys_io      ; receive in ah
0218+  0714 76 04         cmp ah, 4      ; eot
0219+  0716 C6 4F 07      je _gettxt_end
0220+  0719 76 08         cmp ah, $08      ; check for backspace
0221+  071B C6 4B 07      je _gettxt_backspace
0222+  071E 76 5C         cmp ah, $5c        ; '\'
0223+  0720 C6 29 07      je _gettxt_escape
0224+  0723 1A            mov al, ah
0225+  0724 3E            mov [d], al
0226+  0725 79            inc d
0227+  0726 0A 10 07      jmp _gettxt_loop
0228+  0729             _gettxt_escape:
0229+  0729 19 01         mov al, 1
0230+  072B 05 03         syscall sys_io      ; receive in ah
0231+  072D 76 6E         cmp ah, 'n'
0232+  072F C6 3D 07      je _gettxt_lf
0233+  0732 76 72         cmp ah, 'r'
0234+  0734 C6 44 07      je _gettxt_cr
0235+  0737 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0738 3E            mov [d], al
0237+  0739 79            inc d
0238+  073A 0A 10 07      jmp _gettxt_loop
0239+  073D             _gettxt_lf:
0240+  073D 19 0A         mov al, $0a
0241+  073F 3E            mov [d], al
0242+  0740 79            inc d
0243+  0741 0A 10 07      jmp _gettxt_loop
0244+  0744             _gettxt_cr:
0245+  0744 19 0D         mov al, $0d
0246+  0746 3E            mov [d], al
0247+  0747 79            inc d
0248+  0748 0A 10 07      jmp _gettxt_loop
0249+  074B             _gettxt_backspace:
0250+  074B 7F            dec d
0251+  074C 0A 10 07      jmp _gettxt_loop
0252+  074F             _gettxt_end:
0253+  074F 19 00         mov al, 0
0254+  0751 3E            mov [d], al        ; terminate string
0255+  0752 E7            pop d
0256+  0753 E4            pop a
0257+  0754 09            ret
0258+  0755             
0259+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0755             ; print new line
0261+  0755             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0755             printnl:
0263+  0755 D7            push a
0264+  0756 10 00 0A      mov a, $0a00
0265+  0759 05 03         syscall sys_io
0266+  075B 10 00 0D      mov a, $0d00
0267+  075E 05 03         syscall sys_io
0268+  0760 E4            pop a
0269+  0761 09            ret
0270+  0762             
0271+  0762             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0762             ; _strtoint
0273+  0762             ; 4 digit hex string number in d
0274+  0762             ; integer returned in a
0275+  0762             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0762             _strtointx:
0277+  0762 D8            push b
0278+  0763 32            mov bl, [d]
0279+  0764 37            mov bh, bl
0280+  0765 33 01 00      mov bl, [d + 1]
0281+  0768 07 39 06      call _atoi        ; convert to int in al
0282+  076B 23            mov ah, al        ; move to ah
0283+  076C 33 02 00      mov bl, [d + 2]
0284+  076F 37            mov bh, bl
0285+  0770 33 03 00      mov bl, [d + 3]
0286+  0773 07 39 06      call _atoi        ; convert to int in al
0287+  0776 E5            pop b
0288+  0777 09            ret
0289+  0778             
0290+  0778             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0778             ; _strtoint
0292+  0778             ; 5 digit base10 string number in d
0293+  0778             ; integer returned in a
0294+  0778             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0778             _strtoint:
0296+  0778 E2            push si
0297+  0779 D8            push b
0298+  077A D9            push c
0299+  077B DA            push d
0300+  077C 07 DB 05      call _strlen      ; get string length in c
0301+  077F 7E            dec c
0302+  0780 FD 4E         mov si, d
0303+  0782 12            mov a, c
0304+  0783 FD 99         shl a
0305+  0785 3B FC 08      mov d, table_power
0306+  0788 59            add d, a
0307+  0789 38 00 00      mov c, 0
0308+  078C             _strtoint_l0:
0309+  078C F6            lodsb      ; load ascii to al
0310+  078D B9 00         cmp al, 0
0311+  078F C6 A2 07      je _strtoint_end
0312+  0792 6F 30         sub al, $30    ; make into integer
0313+  0794 22 00         mov ah, 0
0314+  0796 2A            mov b, [d]
0315+  0797 AC            mul a, b      ; result in b since it fits in 16bits
0316+  0798 11            mov a, b
0317+  0799 28            mov b, c
0318+  079A 54            add a, b
0319+  079B 39            mov c, a
0320+  079C 63 02 00      sub d, 2
0321+  079F 0A 8C 07      jmp _strtoint_l0
0322+  07A2             _strtoint_end:
0323+  07A2 12            mov a, c
0324+  07A3 E7            pop d
0325+  07A4 E6            pop c
0326+  07A5 E5            pop b
0327+  07A6 EF            pop si
0328+  07A7 09            ret
0329+  07A8             
0330+  07A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  07A8             ; print null terminated string
0332+  07A8             ; pointer in d
0333+  07A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  07A8             _puts:
0335+  07A8 D7            push a
0336+  07A9 DA            push d
0337+  07AA             _puts_l1:
0338+  07AA 1E            mov al, [d]
0339+  07AB B9 00         cmp al, 0
0340+  07AD C6 B9 07      jz _puts_end
0341+  07B0 23            mov ah, al
0342+  07B1 19 00         mov al, 0
0343+  07B3 05 03         syscall sys_io
0344+  07B5 79            inc d
0345+  07B6 0A AA 07      jmp _puts_l1
0346+  07B9             _puts_end:
0347+  07B9 E7            pop d
0348+  07BA E4            pop a
0349+  07BB 09            ret
0350+  07BC             
0351+  07BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  07BC             ; print n size string
0353+  07BC             ; pointer in d
0354+  07BC             ; size in c
0355+  07BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  07BC             _putsn:
0357+  07BC DB            push al
0358+  07BD DA            push d
0359+  07BE D9            push c
0360+  07BF             _putsn_l0:
0361+  07BF 1E            mov al, [d]
0362+  07C0 23            mov ah, al
0363+  07C1 19 00         mov al, 0
0364+  07C3 05 03         syscall sys_io
0365+  07C5 79            inc d
0366+  07C6 7E            dec c  
0367+  07C7 C2 00 00      cmp c, 0
0368+  07CA C7 BF 07      jne _putsn_l0
0369+  07CD             _putsn_end:
0370+  07CD E6            pop c
0371+  07CE E7            pop d
0372+  07CF E8            pop al
0373+  07D0 09            ret
0374+  07D1             
0375+  07D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  07D1             ; print 16bit decimal number
0377+  07D1             ; input number in a
0378+  07D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07D1             print_u16d:
0380+  07D1 D7            push a
0381+  07D2 D8            push b
0382+  07D3 FD D8         push g
0383+  07D5 26 10 27      mov b, 10000
0384+  07D8 AE            div a, b      ; get 10000's coeff.
0385+  07D9 07 FD 07      call print_number
0386+  07DC 11            mov a, b
0387+  07DD 26 E8 03      mov b, 1000
0388+  07E0 AE            div a, b      ; get 1000's coeff.
0389+  07E1 07 FD 07      call print_number
0390+  07E4 11            mov a, b
0391+  07E5 26 64 00      mov b, 100
0392+  07E8 AE            div a, b
0393+  07E9 07 FD 07      call print_number
0394+  07EC 11            mov a, b
0395+  07ED 26 0A 00      mov b, 10
0396+  07F0 AE            div a, b
0397+  07F1 07 FD 07      call print_number
0398+  07F4 1B            mov al, bl      ; 1's coeff in bl
0399+  07F5 07 FD 07      call print_number
0400+  07F8 FD F1         pop g
0401+  07FA E5            pop b
0402+  07FB E4            pop a
0403+  07FC 09            ret
0404+  07FD             
0405+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07FD             ; print al
0407+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  07FD             print_number:
0409+  07FD 6A 30         add al, $30
0410+  07FF 23            mov ah, al
0411+  0800 07 7C 06      call _putchar
0412+  0803 09            ret
0413+  0804             
0414+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0804             ; print 16bit hex integer
0416+  0804             ; integer value in reg b
0417+  0804             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0804             print_u16x:
0419+  0804 D7            push a
0420+  0805 D8            push b
0421+  0806 DD            push bl
0422+  0807 30            mov bl, bh
0423+  0808 07 4A 06      call _itoa        ; convert bh to char in a
0424+  080B 2F            mov bl, al        ; save al
0425+  080C 19 00         mov al, 0
0426+  080E 05 03         syscall sys_io        ; display ah
0427+  0810 24            mov ah, bl        ; retrieve al
0428+  0811 19 00         mov al, 0
0429+  0813 05 03         syscall sys_io        ; display al
0430+  0815             
0431+  0815 EA            pop bl
0432+  0816 07 4A 06      call _itoa        ; convert bh to char in a
0433+  0819 2F            mov bl, al        ; save al
0434+  081A 19 00         mov al, 0
0435+  081C 05 03         syscall sys_io        ; display ah
0436+  081E 24            mov ah, bl        ; retrieve al
0437+  081F 19 00         mov al, 0
0438+  0821 05 03         syscall sys_io        ; display al
0439+  0823             
0440+  0823 E5            pop b
0441+  0824 E4            pop a
0442+  0825 09            ret
0443+  0826             
0444+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0826             ; input 16bit hex integer
0446+  0826             ; read 16bit integer into a
0447+  0826             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0826             scan_u16x:
0449+  0826 F8 10 00      enter 16
0450+  0829 D8            push b
0451+  082A DA            push d
0452+  082B             
0453+  082B FA F1 FF      lea d, [bp + -15]
0454+  082E 07 83 06      call _gets        ; get number
0455+  0831             
0456+  0831 32            mov bl, [d]
0457+  0832 37            mov bh, bl
0458+  0833 33 01 00      mov bl, [d + 1]
0459+  0836 07 39 06      call _atoi        ; convert to int in al
0460+  0839 23            mov ah, al        ; move to ah
0461+  083A             
0462+  083A 33 02 00      mov bl, [d + 2]
0463+  083D 37            mov bh, bl
0464+  083E 33 03 00      mov bl, [d + 3]
0465+  0841 07 39 06      call _atoi        ; convert to int in al
0466+  0844             
0467+  0844 E7            pop d
0468+  0845 E5            pop b
0469+  0846 F9            leave
0470+  0847 09            ret
0471+  0848             
0472+  0848             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0848             ; print 8bit hex integer
0474+  0848             ; integer value in reg bl
0475+  0848             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0848             print_u8x:
0477+  0848 D7            push a
0478+  0849 DD            push bl
0479+  084A             
0480+  084A 07 4A 06      call _itoa        ; convert bl to char in a
0481+  084D 2F            mov bl, al        ; save al
0482+  084E 19 00         mov al, 0
0483+  0850 05 03         syscall sys_io        ; display ah
0484+  0852 24            mov ah, bl        ; retrieve al
0485+  0853 19 00         mov al, 0
0486+  0855 05 03         syscall sys_io        ; display al
0487+  0857             
0488+  0857 EA            pop bl
0489+  0858 E4            pop a
0490+  0859 09            ret
0491+  085A             
0492+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  085A             ; print 8bit decimal unsigned number
0494+  085A             ; input number in al
0495+  085A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  085A             print_u8d:
0497+  085A D7            push a
0498+  085B D8            push b
0499+  085C FD D8         push g
0500+  085E 22 00         mov ah, 0
0501+  0860 26 64 00      mov b, 100
0502+  0863 AE            div a, b
0503+  0864 D8            push b      ; save remainder
0504+  0865 B9 00         cmp al, 0
0505+  0867 C6 71 08      je skip100
0506+  086A 6A 30         add al, $30
0507+  086C 23            mov ah, al
0508+  086D 19 00         mov al, 0
0509+  086F 05 03         syscall sys_io  ; print coeff
0510+  0871             skip100:
0511+  0871 E4            pop a
0512+  0872 22 00         mov ah, 0
0513+  0874 26 0A 00      mov b, 10
0514+  0877 AE            div a, b
0515+  0878 D8            push b      ; save remainder
0516+  0879 B9 00         cmp al, 0
0517+  087B C6 85 08      je skip10
0518+  087E 6A 30         add al, $30
0519+  0880 23            mov ah, al
0520+  0881 19 00         mov al, 0
0521+  0883 05 03         syscall sys_io  ; print coeff
0522+  0885             skip10:
0523+  0885 E4            pop a
0524+  0886 1B            mov al, bl
0525+  0887 6A 30         add al, $30
0526+  0889 23            mov ah, al
0527+  088A 19 00         mov al, 0
0528+  088C 05 03         syscall sys_io  ; print coeff
0529+  088E FD F1         pop g
0530+  0890 E5            pop b
0531+  0891 E4            pop a
0532+  0892 09            ret
0533+  0893             
0534+  0893             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0893             ; input 8bit hex integer
0536+  0893             ; read 8bit integer into al
0537+  0893             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0893             scan_u8x:
0539+  0893 F8 04 00      enter 4
0540+  0896 D8            push b
0541+  0897 DA            push d
0542+  0898             
0543+  0898 FA FD FF      lea d, [bp + -3]
0544+  089B 07 83 06      call _gets        ; get number
0545+  089E             
0546+  089E 32            mov bl, [d]
0547+  089F 37            mov bh, bl
0548+  08A0 33 01 00      mov bl, [d + 1]
0549+  08A3 07 39 06      call _atoi        ; convert to int in al
0550+  08A6             
0551+  08A6 E7            pop d
0552+  08A7 E5            pop b
0553+  08A8 F9            leave
0554+  08A9 09            ret
0555+  08AA             
0556+  08AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  08AA             ; input decimal number
0558+  08AA             ; result in a
0559+  08AA             ; 655'\0'
0560+  08AA             ; low--------high
0561+  08AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  08AA             scan_u16d:
0563+  08AA F8 08 00      enter 8
0564+  08AD E2            push si
0565+  08AE D8            push b
0566+  08AF D9            push c
0567+  08B0 DA            push d
0568+  08B1 FA F9 FF      lea d, [bp +- 7]
0569+  08B4 07 83 06      call _gets
0570+  08B7 07 DB 05      call _strlen      ; get string length in c
0571+  08BA 7E            dec c
0572+  08BB FD 4E         mov si, d
0573+  08BD 12            mov a, c
0574+  08BE FD 99         shl a
0575+  08C0 3B FC 08      mov d, table_power
0576+  08C3 59            add d, a
0577+  08C4 38 00 00      mov c, 0
0578+  08C7             mul_loop:
0579+  08C7 F6            lodsb      ; load ascii to al
0580+  08C8 B9 00         cmp al, 0
0581+  08CA C6 DD 08      je mul_exit
0582+  08CD 6F 30         sub al, $30    ; make into integer
0583+  08CF 22 00         mov ah, 0
0584+  08D1 2A            mov b, [d]
0585+  08D2 AC            mul a, b      ; result in b since it fits in 16bits
0586+  08D3 11            mov a, b
0587+  08D4 28            mov b, c
0588+  08D5 54            add a, b
0589+  08D6 39            mov c, a
0590+  08D7 63 02 00      sub d, 2
0591+  08DA 0A C7 08      jmp mul_loop
0592+  08DD             mul_exit:
0593+  08DD 12            mov a, c
0594+  08DE E7            pop d
0595+  08DF E6            pop c
0596+  08E0 E5            pop b
0597+  08E1 EF            pop si
0598+  08E2 F9            leave
0599+  08E3 09            ret
0600+  08E4             
0601+  08E4             
0602+  08E4 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  08E8 34 35 36 37 
0602+  08EC 38 39 61 62 
0602+  08F0 63 64 65 66 
0603+  08F4 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  08F8 1B 5B 68 00 
0604+  08FC             
0605+  08FC             table_power:
0606+  08FC 01 00         .dw 1
0607+  08FE 0A 00         .dw 10
0608+  0900 64 00         .dw 100
0609+  0902 E8 03         .dw 1000
0610+  0904 10 27         .dw 100000107   0906             
0108   0906 00          flags:	.db
0109   0907             
0110   0907             .end
0111   0907             
tasm: Number of errors = 0
