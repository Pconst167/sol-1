0001   0000             .include "lib/kernel.exp"
0001+  0000             sys_break        .EQU  $0000
0002+  0000             sys_rtc          .EQU  $0001
0003+  0000             sys_ide          .EQU  $0002
0004+  0000             sys_io           .EQU  $0003
0005+  0000             sys_filesystem   .EQU  $0004
0006+  0000             sys_create_proc  .EQU  $0005
0007+  0000             sys_list_proc    .EQU  $0006
0008+  0000             sys_datetime     .EQU  $0007
0009+  0000             sys_reboot       .EQU  $0008
0010+  0000             sys_pause_proc   .EQU  $0009
0011+  0000             sys_resume_proc  .EQU  $000a
0012+  0000             sys_terminate_proc .EQU  $000b
0013+  0000             sys_system       .EQU  $000c
0014+  0000             sys_fdc          .EQU  $000d
0015+  0000             sys_fdc_restore  .EQU  $0000
0016+  0000             sys_fdc_step     .EQU  $0001
0017+  0000             sys_fdc_step_in  .EQU  $0002
0018+  0000             sys_fdc_step_out .EQU  $0003
0019+  0000             sys_fdc_seek     .EQU  $0004
0020+  0000             sys_fdc_format   .EQU  $0005
0021+  0000             sys_fdc_read_addr .EQU  $0006
0022+  0000             sys_fdc_read_track .EQU  $0007
0023+  0000             sys_fdc_read_sect .EQU  $0008
0024+  0000             sys_fdc_write_sect .EQU  $0009
0025+  0000             sys_fdc_force_int .EQU  $000a
0026+  0000             sys_fdc_status0  .EQU  $000b
0027+  0000             sys_fdc_status1  .EQU  $000c
0028+  0000             text_org         .EQU  $0400
0002   0400             .org text_org
0003   0400             
0004   0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0005   0400             ; FFC0    5.25" Floppy Drive Block
0006   0400             ;   - FFC0  (Last 4 bits: 0000)    Output Port (377 Flip-Flop)                       Note: A3 Address line = 0
0007   0400             ;   - FFC1  (Last 4 bits: 0001)    Input Port  (244 Buffer)                          Note: A3 Address line = 0
0008   0400             ;   - FFC8  (Last 4 bits: 1000)    FDC         (WD1770 Floppy Drive Controller)      Note: A3 Address line = 1
0009   0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0010   0400             ; floppy drive system calls
0011   0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0012   0400             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0013   0400             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0014   0400             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0015   0400             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0016   0400             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0017   0400             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0018   0400             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0019   0400             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0020   0400             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0021   0400             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0022   0400             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0023   0400             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0024   0400             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0025   0400             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0026   0400             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0027   0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028   0400             ; _FDC_CONFIG       .equ $FFC0 
0029   0400             ; _FDC_STATUS_1     .equ $FFC1
0030   0400             ; _FDC_WD_STAT_CMD  .equ $FFC8
0031   0400             ; _FDC_WD_TRACK     .equ $FFC9
0032   0400             ; _FDC_WD_SECTOR    .equ $FFCA
0033   0400             ; _FDC_WD_DATA      .equ $FFCB
0034   0400             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0035   0400             main:
0036   0400 FD 49 FF FF   mov bp, $FFFF
0037   0404 FD 47 FF FF   mov sp, $FFFF
0038   0408             
0039   0408 3B 5B 04      mov d, str0
0040   040B 07 D1 06      call _puts
0041   040E               ; First, select drive 1 and de-select drive 0
0042   040E 3B C0 FF      mov d, $FFC0    ; floppy configuration output port
0043   0411 19 02         mov al, 2       ; setparam call
0044   0413 2E 09         mov bl, $09     ; %00001001 : turn LED on, disable double density, select side 0, select drive 1, do not select drive 0
0045   0415 05 0C         syscall sys_system
0046   0417             
0047   0417 3B 74 04      mov d, str1
0048   041A 07 D1 06      call _puts
0049   041D             ; wait a little
0050   041D 38 FF 00      mov c, $FF
0051   0420             loop1:
0052   0420 7E            dec c
0053   0421 C2 00 00      cmp c, 0
0054   0424 C7 20 04      jnz loop1
0055   0427             
0056   0427 3B 83 04      mov d, str2
0057   042A 07 D1 06      call _puts
0058   042D             ; send restore command
0059   042D 3B C8 FF      mov d, $FFC8    ; wd1770
0060   0430 19 02         mov al, 2       ; setparam call
0061   0432 2E 03         mov bl, $03     ; restore command, 30ms rate
0062   0434 05 0C         syscall sys_system
0063   0436             
0064   0436 3B 74 04      mov d, str1
0065   0439 07 D1 06      call _puts
0066   043C             ; wait a little
0067   043C 38 FF 00      mov c, $FF
0068   043F             loop2:
0069   043F 7E            dec c
0070   0440 C2 00 00      cmp c, 0
0071   0443 C7 3F 04      jnz loop2
0072   0446             
0073   0446 3B C1 FF      mov d, $FFC1    ; floppy input port
0074   0449 19 04         mov al, 4       ; getparam
0075   044B 05 0C         syscall sys_system
0076   044D 3B A2 04      mov d, str3
0077   0450 07 D1 06      call _puts
0078   0453 07 71 07      call print_u8x  ; print vlue in 'bl'
0079   0456 07 7E 06      call printnl
0080   0459             
0081   0459 05 0B         syscall sys_terminate_proc
0082   045B             
0083   045B 0A 0D 73 65 str0: .db $a, $d, "selecting drive 1...", $a, $d, 0
0083   045F 6C 65 63 74 
0083   0463 69 6E 67 20 
0083   0467 64 72 69 76 
0083   046B 65 20 31 2E 
0083   046F 2E 2E 0A 0D 
0083   0473 00 
0084   0474 0A 0D 77 61 str1: .db $a, $d, "waiting...", $a, $d, 0
0084   0478 69 74 69 6E 
0084   047C 67 2E 2E 2E 
0084   0480 0A 0D 00 
0085   0483 0A 0D 73 65 str2: .db $a, $d, "sending restore command...", $a, $d, 0
0085   0487 6E 64 69 6E 
0085   048B 67 20 72 65 
0085   048F 73 74 6F 72 
0085   0493 65 20 63 6F 
0085   0497 6D 6D 61 6E 
0085   049B 64 2E 2E 2E 
0085   049F 0A 0D 00 
0086   04A2 0A 0D 66 6C str3: .db $a, $d, "floppy status register: ", 0
0086   04A6 6F 70 70 79 
0086   04AA 20 73 74 61 
0086   04AE 74 75 73 20 
0086   04B2 72 65 67 69 
0086   04B6 73 74 65 72 
0086   04BA 3A 20 00 
0087   04BD             
0088   04BD             .include "lib/stdio.asm"
0001+  04BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04BD             ; stdio.s
0003+  04BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04BD             .include "lib/string.asm"
0001++ 04BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04BD             ; string.s
0003++ 04BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04BD             
0005++ 04BD             
0006++ 04BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04BD             ; _strrev
0008++ 04BD             ; reverse a string
0009++ 04BD             ; d = string address
0010++ 04BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04BD             ; 01234
0012++ 04BD             _strrev:
0013++ 04BD 4B          	pusha
0014++ 04BE 07 04 05    	call _strlen	; length in c
0015++ 04C1 12          	mov a, c
0016++ 04C2 AF 01 00    	cmp a, 1
0017++ 04C5 D0 DF 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04C8 7D          	dec a
0019++ 04C9 FD 4E       	mov si, d	; beginning of string
0020++ 04CB FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04CD 59          	add d, a	; end of string
0022++ 04CE 12          	mov a, c
0023++ 04CF FD 9B       	shr a		; divide by 2
0024++ 04D1 39          	mov c, a	; c now counts the steps
0025++ 04D2             _strrev_l0:
0026++ 04D2 32          	mov bl, [d]	; save load right-side char into bl
0027++ 04D3 F6          	lodsb		; load left-side char into al; increase si
0028++ 04D4 3E          	mov [d], al	; store left char into right side
0029++ 04D5 1B          	mov al, bl
0030++ 04D6 F7          	stosb		; store right-side char into left-side; increase di
0031++ 04D7 7E          	dec c
0032++ 04D8 7F          	dec d
0033++ 04D9 C2 00 00    	cmp c, 0
0034++ 04DC C7 D2 04    	jne _strrev_l0
0035++ 04DF             _strrev_end:
0036++ 04DF 4C          	popa
0037++ 04E0 09          	ret
0038++ 04E1             	
0039++ 04E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04E1             ; _strchr
0041++ 04E1             ; search string in d for char in al
0042++ 04E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04E1             _strchr:
0044++ 04E1             _strchr_l0:
0045++ 04E1 32          	mov bl, [d]
0046++ 04E2 C1 00       	cmp bl, 0
0047++ 04E4 C6 EF 04    	je _strchr_end
0048++ 04E7 BA          	cmp al, bl
0049++ 04E8 C6 EF 04    	je _strchr_end
0050++ 04EB 79          	inc d
0051++ 04EC 0A E1 04    	jmp _strchr_l0
0052++ 04EF             _strchr_end:
0053++ 04EF 1B          	mov al, bl
0054++ 04F0 09          	ret
0055++ 04F1             
0056++ 04F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04F1             ; _strstr
0058++ 04F1             ; find sub-string
0059++ 04F1             ; str1 in si
0060++ 04F1             ; str2 in di
0061++ 04F1             ; si points to end of source string
0062++ 04F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04F1             _strstr:
0064++ 04F1 DB          	push al
0065++ 04F2 DA          	push d
0066++ 04F3 E3          	push di
0067++ 04F4             _strstr_loop:
0068++ 04F4 F3          	cmpsb					; compare a byte of the strings
0069++ 04F5 C7 00 05    	jne _strstr_ret
0070++ 04F8 FC 00 00    	lea d, [di + 0]
0071++ 04FB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04FD C7 F4 04    	jne _strstr_loop				; equal chars but not at end
0073++ 0500             _strstr_ret:
0074++ 0500 F0          	pop di
0075++ 0501 E7          	pop d
0076++ 0502 E8          	pop al
0077++ 0503 09          	ret
0078++ 0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0504             ; length of null terminated string
0080++ 0504             ; result in c
0081++ 0504             ; pointer in d
0082++ 0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0504             _strlen:
0084++ 0504 DA          	push d
0085++ 0505 38 00 00    	mov c, 0
0086++ 0508             _strlen_l1:
0087++ 0508 BD 00       	cmp byte [d], 0
0088++ 050A C6 12 05    	je _strlen_ret
0089++ 050D 79          	inc d
0090++ 050E 78          	inc c
0091++ 050F 0A 08 05    	jmp _strlen_l1
0092++ 0512             _strlen_ret:
0093++ 0512 E7          	pop d
0094++ 0513 09          	ret
0095++ 0514             
0096++ 0514             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0514             ; strcmp
0098++ 0514             ; compare two strings
0099++ 0514             ; str1 in si
0100++ 0514             ; str2 in di
0101++ 0514             ; create a string compairon instrucion ?????
0102++ 0514             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0514             _strcmp:
0104++ 0514 DB          	push al
0105++ 0515 DA          	push d
0106++ 0516 E3          	push di
0107++ 0517 E2          	push si
0108++ 0518             _strcmp_loop:
0109++ 0518 F3          	cmpsb					; compare a byte of the strings
0110++ 0519 C7 24 05    	jne _strcmp_ret
0111++ 051C FB FF FF    	lea d, [si +- 1]
0112++ 051F BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0521 C7 18 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 0524             _strcmp_ret:
0115++ 0524 EF          	pop si
0116++ 0525 F0          	pop di
0117++ 0526 E7          	pop d
0118++ 0527 E8          	pop al
0119++ 0528 09          	ret
0120++ 0529             
0121++ 0529             
0122++ 0529             ; strcpy
0123++ 0529             ; copy null terminated string from si to di
0124++ 0529             ; source in si
0125++ 0529             ; destination in di
0126++ 0529             _strcpy:
0127++ 0529 E2          	push si
0128++ 052A E3          	push di
0129++ 052B DB          	push al
0130++ 052C             _strcpy_l1:
0131++ 052C F6          	lodsb
0132++ 052D F7          	stosb
0133++ 052E B9 00       	cmp al, 0
0134++ 0530 C7 2C 05    	jne _strcpy_l1
0135++ 0533             _strcpy_end:
0136++ 0533 E8          	pop al
0137++ 0534 F0          	pop di
0138++ 0535 EF          	pop si
0139++ 0536 09          	ret
0140++ 0537             
0141++ 0537             ; strcat
0142++ 0537             ; concatenate a null terminated string into string at di, from string at si
0143++ 0537             ; source in si
0144++ 0537             ; destination in di
0145++ 0537             _strcat:
0146++ 0537 E2          	push si
0147++ 0538 E3          	push di
0148++ 0539 D7          	push a
0149++ 053A DA          	push d
0150++ 053B 50          	mov a, di
0151++ 053C 3C          	mov d, a
0152++ 053D             _strcat_goto_end_l1:
0153++ 053D BD 00       	cmp byte[d], 0
0154++ 053F C6 46 05    	je _strcat_start
0155++ 0542 79          	inc d
0156++ 0543 0A 3D 05    	jmp _strcat_goto_end_l1
0157++ 0546             _strcat_start:
0158++ 0546 FD 50       	mov di, d
0159++ 0548             _strcat_l1:
0160++ 0548 F6          	lodsb
0161++ 0549 F7          	stosb
0162++ 054A B9 00       	cmp al, 0
0163++ 054C C7 48 05    	jne _strcat_l1
0164++ 054F             _strcat_end:
0165++ 054F E7          	pop d
0166++ 0550 E4          	pop a
0167++ 0551 F0          	pop di
0168++ 0552 EF          	pop si
0169++ 0553 09          	ret
0170++ 0554             
0171++ 0554             
0005+  0554             
0006+  0554             
0007+  0554             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0554             ; convert ascii 'o'..'f' to integer 0..15
0009+  0554             ; ascii in bl
0010+  0554             ; result in al
0011+  0554             ; ascii for f = 0100 0110
0012+  0554             ; ascii for 9 = 0011 1001
0013+  0554             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0554             hex_ascii_encode:
0015+  0554 1B            mov al, bl
0016+  0555 93 40         test al, $40        ; test if letter or number
0017+  0557 C7 5D 05      jnz hex_letter
0018+  055A 87 0F         and al, $0f        ; get number
0019+  055C 09            ret
0020+  055D             hex_letter:
0021+  055D 87 0F         and al, $0f        ; get letter
0022+  055F 6A 09         add al, 9
0023+  0561 09            ret
0024+  0562             
0025+  0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0562             ; atoi
0027+  0562             ; 2 letter hex string in b
0028+  0562             ; 8bit integer returned in al
0029+  0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0562             _atoi:
0031+  0562 D8            push b
0032+  0563 07 54 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0566 30            mov bl, bh
0034+  0567 DB            push al          ; save a
0035+  0568 07 54 05      call hex_ascii_encode
0036+  056B EA            pop bl  
0037+  056C FD 9E 04      shl al, 4
0038+  056F 8C            or al, bl
0039+  0570 E5            pop b
0040+  0571 09            ret  
0041+  0572             
0042+  0572             
0043+  0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0572             ; scanf
0045+  0572             ; no need for explanations!
0046+  0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0572             scanf:
0048+  0572 09            ret
0049+  0573             
0050+  0573             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0573             ; itoa
0052+  0573             ; 8bit value in bl
0053+  0573             ; 2 byte ascii result in a
0054+  0573             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0573             _itoa:
0056+  0573 DA            push d
0057+  0574 D8            push b
0058+  0575 A7 00         mov bh, 0
0059+  0577 FD A4 04      shr bl, 4  
0060+  057A 74            mov d, b
0061+  057B 1F 0D 08      mov al, [d + s_hex_digits]
0062+  057E 23            mov ah, al
0063+  057F               
0064+  057F E5            pop b
0065+  0580 D8            push b
0066+  0581 A7 00         mov bh, 0
0067+  0583 FD 87 0F      and bl, $0f
0068+  0586 74            mov d, b
0069+  0587 1F 0D 08      mov al, [d + s_hex_digits]
0070+  058A E5            pop b
0071+  058B E7            pop d
0072+  058C 09            ret
0073+  058D             
0074+  058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  058D             ; hex string to binary
0076+  058D             ; di = destination address
0077+  058D             ; si = source
0078+  058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  058D             _hex_to_int:
0080+  058D             _hex_to_int_l1:
0081+  058D F6            lodsb          ; load from [si] to al
0082+  058E B9 00         cmp al, 0        ; check if ascii 0
0083+  0590 C6 9D 05      jz _hex_to_int_ret
0084+  0593 36            mov bh, al
0085+  0594 F6            lodsb
0086+  0595 2F            mov bl, al
0087+  0596 07 62 05      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0599 F7            stosb          ; store al to [di]
0089+  059A 0A 8D 05      jmp _hex_to_int_l1
0090+  059D             _hex_to_int_ret:
0091+  059D 09            ret    
0092+  059E             
0093+  059E             
0094+  059E             
0095+  059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  059E             ; getchar
0097+  059E             ; char in ah
0098+  059E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  059E             getch:
0100+  059E DB            push al
0101+  059F             getch_retry:
0102+  059F 19 01         mov al, 1
0103+  05A1 05 03         syscall sys_io      ; receive in ah
0104+  05A3 E8            pop al
0105+  05A4 09            ret
0106+  05A5             
0107+  05A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  05A5             ; putchar
0109+  05A5             ; char in ah
0110+  05A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05A5             _putchar:
0112+  05A5 DB            push al
0113+  05A6 19 00         mov al, 0
0114+  05A8 05 03         syscall sys_io      ; char in ah
0115+  05AA E8            pop al
0116+  05AB 09            ret
0117+  05AC             
0118+  05AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  05AC             ;; input a string
0120+  05AC             ;; terminates with null
0121+  05AC             ;; pointer in d
0122+  05AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  05AC             _gets:
0124+  05AC D7            push a
0125+  05AD DA            push d
0126+  05AE             _gets_loop:
0127+  05AE 19 01         mov al, 1
0128+  05B0 05 03         syscall sys_io      ; receive in ah
0129+  05B2 76 1B         cmp ah, 27
0130+  05B4 C6 D5 05      je _gets_ansi_esc
0131+  05B7 76 0A         cmp ah, $0a        ; lf
0132+  05B9 C6 31 06      je _gets_end
0133+  05BC 76 0D         cmp ah, $0d        ; cr
0134+  05BE C6 31 06      je _gets_end
0135+  05C1 76 5C         cmp ah, $5c        ; '\\'
0136+  05C3 C6 F7 05      je _gets_escape
0137+  05C6 76 08         cmp ah, $08      ; check for backspace
0138+  05C8 C6 D1 05      je _gets_backspace
0139+  05CB 1A            mov al, ah
0140+  05CC 3E            mov [d], al
0141+  05CD 79            inc d
0142+  05CE 0A AE 05      jmp _gets_loop
0143+  05D1             _gets_backspace:
0144+  05D1 7F            dec d
0145+  05D2 0A AE 05      jmp _gets_loop
0146+  05D5             _gets_ansi_esc:
0147+  05D5 19 01         mov al, 1
0148+  05D7 05 03         syscall sys_io        ; receive in ah without echo
0149+  05D9 76 5B         cmp ah, '['
0150+  05DB C7 AE 05      jne _gets_loop
0151+  05DE 19 01         mov al, 1
0152+  05E0 05 03         syscall sys_io          ; receive in ah without echo
0153+  05E2 76 64         cmp ah, 'd'
0154+  05E4 C6 EF 05      je _gets_left_arrow
0155+  05E7 76 63         cmp ah, 'c'
0156+  05E9 C6 F3 05      je _gets_right_arrow
0157+  05EC 0A AE 05      jmp _gets_loop
0158+  05EF             _gets_left_arrow:
0159+  05EF 7F            dec d
0160+  05F0 0A AE 05      jmp _gets_loop
0161+  05F3             _gets_right_arrow:
0162+  05F3 79            inc d
0163+  05F4 0A AE 05      jmp _gets_loop
0164+  05F7             _gets_escape:
0165+  05F7 19 01         mov al, 1
0166+  05F9 05 03         syscall sys_io      ; receive in ah
0167+  05FB 76 6E         cmp ah, 'n'
0168+  05FD C6 1C 06      je _gets_lf
0169+  0600 76 72         cmp ah, 'r'
0170+  0602 C6 23 06      je _gets_cr
0171+  0605 76 30         cmp ah, '0'
0172+  0607 C6 2A 06      je _gets_null
0173+  060A 76 5C         cmp ah, $5c  ; '\'
0174+  060C C6 15 06      je _gets_slash
0175+  060F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0610 3E            mov [d], al
0177+  0611 79            inc d
0178+  0612 0A AE 05      jmp _gets_loop
0179+  0615             _gets_slash:
0180+  0615 19 5C         mov al, $5c
0181+  0617 3E            mov [d], al
0182+  0618 79            inc d
0183+  0619 0A AE 05      jmp _gets_loop
0184+  061C             _gets_lf:
0185+  061C 19 0A         mov al, $0a
0186+  061E 3E            mov [d], al
0187+  061F 79            inc d
0188+  0620 0A AE 05      jmp _gets_loop
0189+  0623             _gets_cr:
0190+  0623 19 0D         mov al, $0d
0191+  0625 3E            mov [d], al
0192+  0626 79            inc d
0193+  0627 0A AE 05      jmp _gets_loop
0194+  062A             _gets_null:
0195+  062A 19 00         mov al, $00
0196+  062C 3E            mov [d], al
0197+  062D 79            inc d
0198+  062E 0A AE 05      jmp _gets_loop
0199+  0631             _gets_end:
0200+  0631 19 00         mov al, 0
0201+  0633 3E            mov [d], al        ; terminate string
0202+  0634 E7            pop d
0203+  0635 E4            pop a
0204+  0636 09            ret
0205+  0637             
0206+  0637             
0207+  0637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0637             ;; input text
0209+  0637             ;; terminated with ctrl+d
0210+  0637             ;; pointer in d
0211+  0637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0637             _gettxt:
0213+  0637 D7            push a
0214+  0638 DA            push d
0215+  0639             _gettxt_loop:
0216+  0639 19 01         mov al, 1
0217+  063B 05 03         syscall sys_io      ; receive in ah
0218+  063D 76 04         cmp ah, 4      ; eot
0219+  063F C6 78 06      je _gettxt_end
0220+  0642 76 08         cmp ah, $08      ; check for backspace
0221+  0644 C6 74 06      je _gettxt_backspace
0222+  0647 76 5C         cmp ah, $5c        ; '\'
0223+  0649 C6 52 06      je _gettxt_escape
0224+  064C 1A            mov al, ah
0225+  064D 3E            mov [d], al
0226+  064E 79            inc d
0227+  064F 0A 39 06      jmp _gettxt_loop
0228+  0652             _gettxt_escape:
0229+  0652 19 01         mov al, 1
0230+  0654 05 03         syscall sys_io      ; receive in ah
0231+  0656 76 6E         cmp ah, 'n'
0232+  0658 C6 66 06      je _gettxt_lf
0233+  065B 76 72         cmp ah, 'r'
0234+  065D C6 6D 06      je _gettxt_cr
0235+  0660 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0661 3E            mov [d], al
0237+  0662 79            inc d
0238+  0663 0A 39 06      jmp _gettxt_loop
0239+  0666             _gettxt_lf:
0240+  0666 19 0A         mov al, $0a
0241+  0668 3E            mov [d], al
0242+  0669 79            inc d
0243+  066A 0A 39 06      jmp _gettxt_loop
0244+  066D             _gettxt_cr:
0245+  066D 19 0D         mov al, $0d
0246+  066F 3E            mov [d], al
0247+  0670 79            inc d
0248+  0671 0A 39 06      jmp _gettxt_loop
0249+  0674             _gettxt_backspace:
0250+  0674 7F            dec d
0251+  0675 0A 39 06      jmp _gettxt_loop
0252+  0678             _gettxt_end:
0253+  0678 19 00         mov al, 0
0254+  067A 3E            mov [d], al        ; terminate string
0255+  067B E7            pop d
0256+  067C E4            pop a
0257+  067D 09            ret
0258+  067E             
0259+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  067E             ; print new line
0261+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  067E             printnl:
0263+  067E D7            push a
0264+  067F 10 00 0A      mov a, $0a00
0265+  0682 05 03         syscall sys_io
0266+  0684 10 00 0D      mov a, $0d00
0267+  0687 05 03         syscall sys_io
0268+  0689 E4            pop a
0269+  068A 09            ret
0270+  068B             
0271+  068B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  068B             ; _strtoint
0273+  068B             ; 4 digit hex string number in d
0274+  068B             ; integer returned in a
0275+  068B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  068B             _strtointx:
0277+  068B D8            push b
0278+  068C 32            mov bl, [d]
0279+  068D 37            mov bh, bl
0280+  068E 33 01 00      mov bl, [d + 1]
0281+  0691 07 62 05      call _atoi        ; convert to int in al
0282+  0694 23            mov ah, al        ; move to ah
0283+  0695 33 02 00      mov bl, [d + 2]
0284+  0698 37            mov bh, bl
0285+  0699 33 03 00      mov bl, [d + 3]
0286+  069C 07 62 05      call _atoi        ; convert to int in al
0287+  069F E5            pop b
0288+  06A0 09            ret
0289+  06A1             
0290+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  06A1             ; _strtoint
0292+  06A1             ; 5 digit base10 string number in d
0293+  06A1             ; integer returned in a
0294+  06A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  06A1             _strtoint:
0296+  06A1 E2            push si
0297+  06A2 D8            push b
0298+  06A3 D9            push c
0299+  06A4 DA            push d
0300+  06A5 07 04 05      call _strlen      ; get string length in c
0301+  06A8 7E            dec c
0302+  06A9 FD 4E         mov si, d
0303+  06AB 12            mov a, c
0304+  06AC FD 99         shl a
0305+  06AE 3B 25 08      mov d, table_power
0306+  06B1 59            add d, a
0307+  06B2 38 00 00      mov c, 0
0308+  06B5             _strtoint_l0:
0309+  06B5 F6            lodsb      ; load ascii to al
0310+  06B6 B9 00         cmp al, 0
0311+  06B8 C6 CB 06      je _strtoint_end
0312+  06BB 6F 30         sub al, $30    ; make into integer
0313+  06BD 22 00         mov ah, 0
0314+  06BF 2A            mov b, [d]
0315+  06C0 AC            mul a, b      ; result in b since it fits in 16bits
0316+  06C1 11            mov a, b
0317+  06C2 28            mov b, c
0318+  06C3 54            add a, b
0319+  06C4 39            mov c, a
0320+  06C5 63 02 00      sub d, 2
0321+  06C8 0A B5 06      jmp _strtoint_l0
0322+  06CB             _strtoint_end:
0323+  06CB 12            mov a, c
0324+  06CC E7            pop d
0325+  06CD E6            pop c
0326+  06CE E5            pop b
0327+  06CF EF            pop si
0328+  06D0 09            ret
0329+  06D1             
0330+  06D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  06D1             ; print null terminated string
0332+  06D1             ; pointer in d
0333+  06D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  06D1             _puts:
0335+  06D1 D7            push a
0336+  06D2 DA            push d
0337+  06D3             _puts_l1:
0338+  06D3 1E            mov al, [d]
0339+  06D4 B9 00         cmp al, 0
0340+  06D6 C6 E2 06      jz _puts_end
0341+  06D9 23            mov ah, al
0342+  06DA 19 00         mov al, 0
0343+  06DC 05 03         syscall sys_io
0344+  06DE 79            inc d
0345+  06DF 0A D3 06      jmp _puts_l1
0346+  06E2             _puts_end:
0347+  06E2 E7            pop d
0348+  06E3 E4            pop a
0349+  06E4 09            ret
0350+  06E5             
0351+  06E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  06E5             ; print n size string
0353+  06E5             ; pointer in d
0354+  06E5             ; size in c
0355+  06E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  06E5             _putsn:
0357+  06E5 DB            push al
0358+  06E6 DA            push d
0359+  06E7 D9            push c
0360+  06E8             _putsn_l0:
0361+  06E8 1E            mov al, [d]
0362+  06E9 23            mov ah, al
0363+  06EA 19 00         mov al, 0
0364+  06EC 05 03         syscall sys_io
0365+  06EE 79            inc d
0366+  06EF 7E            dec c  
0367+  06F0 C2 00 00      cmp c, 0
0368+  06F3 C7 E8 06      jne _putsn_l0
0369+  06F6             _putsn_end:
0370+  06F6 E6            pop c
0371+  06F7 E7            pop d
0372+  06F8 E8            pop al
0373+  06F9 09            ret
0374+  06FA             
0375+  06FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  06FA             ; print 16bit decimal number
0377+  06FA             ; input number in a
0378+  06FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06FA             print_u16d:
0380+  06FA D7            push a
0381+  06FB D8            push b
0382+  06FC FD D8         push g
0383+  06FE 26 10 27      mov b, 10000
0384+  0701 AE            div a, b      ; get 10000's coeff.
0385+  0702 07 26 07      call print_number
0386+  0705 11            mov a, b
0387+  0706 26 E8 03      mov b, 1000
0388+  0709 AE            div a, b      ; get 1000's coeff.
0389+  070A 07 26 07      call print_number
0390+  070D 11            mov a, b
0391+  070E 26 64 00      mov b, 100
0392+  0711 AE            div a, b
0393+  0712 07 26 07      call print_number
0394+  0715 11            mov a, b
0395+  0716 26 0A 00      mov b, 10
0396+  0719 AE            div a, b
0397+  071A 07 26 07      call print_number
0398+  071D 1B            mov al, bl      ; 1's coeff in bl
0399+  071E 07 26 07      call print_number
0400+  0721 FD F1         pop g
0401+  0723 E5            pop b
0402+  0724 E4            pop a
0403+  0725 09            ret
0404+  0726             
0405+  0726             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0726             ; print al
0407+  0726             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0726             print_number:
0409+  0726 6A 30         add al, $30
0410+  0728 23            mov ah, al
0411+  0729 07 A5 05      call _putchar
0412+  072C 09            ret
0413+  072D             
0414+  072D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  072D             ; print 16bit hex integer
0416+  072D             ; integer value in reg b
0417+  072D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  072D             print_u16x:
0419+  072D D7            push a
0420+  072E D8            push b
0421+  072F DD            push bl
0422+  0730 30            mov bl, bh
0423+  0731 07 73 05      call _itoa        ; convert bh to char in a
0424+  0734 2F            mov bl, al        ; save al
0425+  0735 19 00         mov al, 0
0426+  0737 05 03         syscall sys_io        ; display ah
0427+  0739 24            mov ah, bl        ; retrieve al
0428+  073A 19 00         mov al, 0
0429+  073C 05 03         syscall sys_io        ; display al
0430+  073E             
0431+  073E EA            pop bl
0432+  073F 07 73 05      call _itoa        ; convert bh to char in a
0433+  0742 2F            mov bl, al        ; save al
0434+  0743 19 00         mov al, 0
0435+  0745 05 03         syscall sys_io        ; display ah
0436+  0747 24            mov ah, bl        ; retrieve al
0437+  0748 19 00         mov al, 0
0438+  074A 05 03         syscall sys_io        ; display al
0439+  074C             
0440+  074C E5            pop b
0441+  074D E4            pop a
0442+  074E 09            ret
0443+  074F             
0444+  074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  074F             ; input 16bit hex integer
0446+  074F             ; read 16bit integer into a
0447+  074F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  074F             scan_u16x:
0449+  074F F8 10 00      enter 16
0450+  0752 D8            push b
0451+  0753 DA            push d
0452+  0754             
0453+  0754 FA F1 FF      lea d, [bp + -15]
0454+  0757 07 AC 05      call _gets        ; get number
0455+  075A             
0456+  075A 32            mov bl, [d]
0457+  075B 37            mov bh, bl
0458+  075C 33 01 00      mov bl, [d + 1]
0459+  075F 07 62 05      call _atoi        ; convert to int in al
0460+  0762 23            mov ah, al        ; move to ah
0461+  0763             
0462+  0763 33 02 00      mov bl, [d + 2]
0463+  0766 37            mov bh, bl
0464+  0767 33 03 00      mov bl, [d + 3]
0465+  076A 07 62 05      call _atoi        ; convert to int in al
0466+  076D             
0467+  076D E7            pop d
0468+  076E E5            pop b
0469+  076F F9            leave
0470+  0770 09            ret
0471+  0771             
0472+  0771             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0771             ; print 8bit hex integer
0474+  0771             ; integer value in reg bl
0475+  0771             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0771             print_u8x:
0477+  0771 D7            push a
0478+  0772 DD            push bl
0479+  0773             
0480+  0773 07 73 05      call _itoa        ; convert bl to char in a
0481+  0776 2F            mov bl, al        ; save al
0482+  0777 19 00         mov al, 0
0483+  0779 05 03         syscall sys_io        ; display ah
0484+  077B 24            mov ah, bl        ; retrieve al
0485+  077C 19 00         mov al, 0
0486+  077E 05 03         syscall sys_io        ; display al
0487+  0780             
0488+  0780 EA            pop bl
0489+  0781 E4            pop a
0490+  0782 09            ret
0491+  0783             
0492+  0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0783             ; print 8bit decimal unsigned number
0494+  0783             ; input number in al
0495+  0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0783             print_u8d:
0497+  0783 D7            push a
0498+  0784 D8            push b
0499+  0785 FD D8         push g
0500+  0787 22 00         mov ah, 0
0501+  0789 26 64 00      mov b, 100
0502+  078C AE            div a, b
0503+  078D D8            push b      ; save remainder
0504+  078E B9 00         cmp al, 0
0505+  0790 C6 9A 07      je skip100
0506+  0793 6A 30         add al, $30
0507+  0795 23            mov ah, al
0508+  0796 19 00         mov al, 0
0509+  0798 05 03         syscall sys_io  ; print coeff
0510+  079A             skip100:
0511+  079A E4            pop a
0512+  079B 22 00         mov ah, 0
0513+  079D 26 0A 00      mov b, 10
0514+  07A0 AE            div a, b
0515+  07A1 D8            push b      ; save remainder
0516+  07A2 B9 00         cmp al, 0
0517+  07A4 C6 AE 07      je skip10
0518+  07A7 6A 30         add al, $30
0519+  07A9 23            mov ah, al
0520+  07AA 19 00         mov al, 0
0521+  07AC 05 03         syscall sys_io  ; print coeff
0522+  07AE             skip10:
0523+  07AE E4            pop a
0524+  07AF 1B            mov al, bl
0525+  07B0 6A 30         add al, $30
0526+  07B2 23            mov ah, al
0527+  07B3 19 00         mov al, 0
0528+  07B5 05 03         syscall sys_io  ; print coeff
0529+  07B7 FD F1         pop g
0530+  07B9 E5            pop b
0531+  07BA E4            pop a
0532+  07BB 09            ret
0533+  07BC             
0534+  07BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  07BC             ; input 8bit hex integer
0536+  07BC             ; read 8bit integer into al
0537+  07BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  07BC             scan_u8x:
0539+  07BC F8 04 00      enter 4
0540+  07BF D8            push b
0541+  07C0 DA            push d
0542+  07C1             
0543+  07C1 FA FD FF      lea d, [bp + -3]
0544+  07C4 07 AC 05      call _gets        ; get number
0545+  07C7             
0546+  07C7 32            mov bl, [d]
0547+  07C8 37            mov bh, bl
0548+  07C9 33 01 00      mov bl, [d + 1]
0549+  07CC 07 62 05      call _atoi        ; convert to int in al
0550+  07CF             
0551+  07CF E7            pop d
0552+  07D0 E5            pop b
0553+  07D1 F9            leave
0554+  07D2 09            ret
0555+  07D3             
0556+  07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  07D3             ; input decimal number
0558+  07D3             ; result in a
0559+  07D3             ; 655'\0'
0560+  07D3             ; low--------high
0561+  07D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  07D3             scan_u16d:
0563+  07D3 F8 08 00      enter 8
0564+  07D6 E2            push si
0565+  07D7 D8            push b
0566+  07D8 D9            push c
0567+  07D9 DA            push d
0568+  07DA FA F9 FF      lea d, [bp +- 7]
0569+  07DD 07 AC 05      call _gets
0570+  07E0 07 04 05      call _strlen      ; get string length in c
0571+  07E3 7E            dec c
0572+  07E4 FD 4E         mov si, d
0573+  07E6 12            mov a, c
0574+  07E7 FD 99         shl a
0575+  07E9 3B 25 08      mov d, table_power
0576+  07EC 59            add d, a
0577+  07ED 38 00 00      mov c, 0
0578+  07F0             mul_loop:
0579+  07F0 F6            lodsb      ; load ascii to al
0580+  07F1 B9 00         cmp al, 0
0581+  07F3 C6 06 08      je mul_exit
0582+  07F6 6F 30         sub al, $30    ; make into integer
0583+  07F8 22 00         mov ah, 0
0584+  07FA 2A            mov b, [d]
0585+  07FB AC            mul a, b      ; result in b since it fits in 16bits
0586+  07FC 11            mov a, b
0587+  07FD 28            mov b, c
0588+  07FE 54            add a, b
0589+  07FF 39            mov c, a
0590+  0800 63 02 00      sub d, 2
0591+  0803 0A F0 07      jmp mul_loop
0592+  0806             mul_exit:
0593+  0806 12            mov a, c
0594+  0807 E7            pop d
0595+  0808 E6            pop c
0596+  0809 E5            pop b
0597+  080A EF            pop si
0598+  080B F9            leave
0599+  080C 09            ret
0600+  080D             
0601+  080D             
0602+  080D 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  0811 34 35 36 37 
0602+  0815 38 39 61 62 
0602+  0819 63 64 65 66 
0603+  081D 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  0821 1B 5B 68 00 
0604+  0825             
0605+  0825             table_power:
0606+  0825 01 00         .dw 1
0607+  0827 0A 00         .dw 10
0608+  0829 64 00         .dw 100
0609+  082B E8 03         .dw 1000
0610+  082D 10 27         .dw 100000089   082F             .end
tasm: Number of errors = 0
