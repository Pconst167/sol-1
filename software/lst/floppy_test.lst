0001   0000             .include "lib/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format    .EQU  $0005
0007+  0000             fdc_al_read_addr .EQU  $0006
0008+  0000             fdc_al_read_track .EQU  $0007
0009+  0000             fdc_al_read_sect .EQU  $0008
0010+  0000             fdc_al_write_sect .EQU  $0009
0011+  0000             fdc_al_force_int .EQU  $000a
0012+  0000             fdc_al_status0   .EQU  $000b
0013+  0000             fdc_al_status1   .EQU  $000c
0014+  0000             sys_break        .EQU  $0000
0015+  0000             sys_rtc          .EQU  $0001
0016+  0000             sys_ide          .EQU  $0002
0017+  0000             sys_io           .EQU  $0003
0018+  0000             sys_filesystem   .EQU  $0004
0019+  0000             sys_create_proc  .EQU  $0005
0020+  0000             sys_list_proc    .EQU  $0006
0021+  0000             sys_datetime     .EQU  $0007
0022+  0000             sys_reboot       .EQU  $0008
0023+  0000             sys_pause_proc   .EQU  $0009
0024+  0000             sys_resume_proc  .EQU  $000a
0025+  0000             sys_terminate_proc .EQU  $000b
0026+  0000             sys_system       .EQU  $000c
0027+  0000             sys_fdc          .EQU  $000d
0028+  0000             text_org         .EQU  $0400
0002   0400             .org text_org
0003   0400             
0004   0400             ; sys_fdc_restore
0005   0400             ; sys_fdc_step
0006   0400             ; sys_fdc_step_in
0007   0400             ; sys_fdc_step_out
0008   0400             ; sys_fdc_seek
0009   0400             ; sys_fdc_format
0010   0400             ; sys_fdc_read_addr
0011   0400             ; sys_fdc_read_track
0012   0400             ; sys_fdc_read_sect
0013   0400             ; sys_fdc_write_sect
0014   0400             ; sys_fdc_force_int
0015   0400             
0016   0400             main:
0017   0400 FD 49 FF FF   mov bp, $ffff
0018   0404 FD 47 FF FF   mov sp, $ffff
0019   0408             
0020   0408 3B 4A 06      mov d, str0
0021   040B 07 1F 09      call _puts
0022   040E               ; First, select drive 1 and de-select drive 0
0023   040E 3B C0 FF      mov d, $FFC0
0024   0411 19 02         mov al, 2       ; setparam call
0025   0413 2E 0A         mov bl, %00001010     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0026   0415 05 0C         syscall sys_system
0027   0417             
0028   0417             menu:
0029   0417 3B 9E 05      mov d, s_menu
0030   041A 07 1F 09      call _puts
0031   041D 07 EC 07      call getch
0032   0420 76 30         cmp ah, '0'
0033   0422 C6 63 04      je step_in
0034   0425 76 31         cmp ah, '1'
0035   0427 C6 6A 04      je step_out
0036   042A 76 32         cmp ah, '2'
0037   042C C6 55 04      je restore
0038   042F 76 33         cmp ah, '3'
0039   0431 C6 FC 04      je status0
0040   0434 76 34         cmp ah, '4'
0041   0436 C6 0D 05      je status1
0042   0439 76 35         cmp ah, '5'
0043   043B C6 78 04      je format
0044   043E 76 36         cmp ah, '6'
0045   0440 C6 8F 04      je read_track
0046   0443 76 37         cmp ah, '7'
0047   0445 C6 A4 04      je read_sect
0048   0448 76 38         cmp ah, '8'
0049   044A C6 EB 04      je fdc_options
0050   044D 76 39         cmp ah, '9'
0051   044F C6 CC 04      je fdc_write_sec
0052   0452 0A 17 04      jmp menu
0053   0455             
0054   0455             restore:
0055   0455 19 00         mov al, fdc_al_restore
0056   0457 05 0D         syscall sys_fdc
0057   0459 0A 17 04      jmp menu
0058   045C             step:
0059   045C 19 01         mov al, fdc_al_step
0060   045E 05 0D         syscall sys_fdc
0061   0460 0A 17 04      jmp menu
0062   0463             step_in:
0063   0463 19 02         mov al, fdc_al_step_in
0064   0465 05 0D         syscall sys_fdc
0065   0467 0A 17 04      jmp menu
0066   046A             step_out:
0067   046A 19 03         mov al, fdc_al_step_out
0068   046C 05 0D         syscall sys_fdc
0069   046E 0A 17 04      jmp menu
0070   0471             seek:
0071   0471 19 04         mov al, fdc_al_seek
0072   0473 05 0D         syscall sys_fdc
0073   0475 0A 17 04      jmp menu
0074   0478             
0075   0478             format:
0076   0478 3B 95 05      mov d, s_track
0077   047B 07 1F 09      call _puts
0078   047E 07 0A 0A      call scan_u8x   ; in al
0079   0481 2F            mov bl, al      ; track needs to be in bl
0080   0482 19 05         mov al, fdc_al_format
0081   0484 05 0D         syscall sys_fdc
0082   0486 3B 3B 06      mov d, s_format_done
0083   0489 07 1F 09      call _puts
0084   048C 0A 17 04      jmp menu
0085   048F             
0086   048F             read_track:
0087   048F 19 07         mov al, fdc_al_read_track
0088   0491 FD 4F 0A 07   mov di, transient_area
0089   0495 05 0D         syscall sys_fdc
0090   0497 27            mov b, a   ; number of bytes to output
0091   0498 3B 0A 07      mov d, transient_area
0092   049B 07 1E 05      call cmd_hexd
0093   049E 0A 17 04      jmp menu
0094   04A1             
0095   04A1             read_addr:
0096   04A1 0A 17 04      jmp menu
0097   04A4             
0098   04A4             read_sect:
0099   04A4 3B 6E 06      mov d, s1
0100   04A7 07 1F 09      call _puts
0101   04AA 07 0A 0A      call scan_u8x
0102   04AD 36            mov bh, al
0103   04AE 3B 77 06      mov d, s2
0104   04B1 07 1F 09      call _puts
0105   04B4 07 0A 0A      call scan_u8x ; in al 
0106   04B7 2F            mov bl, al
0107   04B8 19 08         mov al, fdc_al_read_sect
0108   04BA FD 4F 0A 07   mov di, transient_area
0109   04BE 05 0D         syscall sys_fdc
0110   04C0 3B 0A 07      mov d, transient_area
0111   04C3 26 80 00      mov b, 128
0112   04C6 07 1E 05      call cmd_hexd
0113   04C9 0A 17 04      jmp menu
0114   04CC             
0115   04CC             fdc_write_sec:
0116   04CC 3B 6E 06      mov d, s1
0117   04CF 07 1F 09      call _puts
0118   04D2 07 0A 0A      call scan_u8x
0119   04D5 36            mov bh, al
0120   04D6 3B 77 06      mov d, s2
0121   04D9 07 1F 09      call _puts
0122   04DC 07 0A 0A      call scan_u8x ; in al
0123   04DF 2F            mov bl, al
0124   04E0 19 09         mov al, fdc_al_write_sect
0125   04E2 FD 4D 8A 06   mov si, fdc_sec_data
0126   04E6 05 0D         syscall sys_fdc
0127   04E8 0A 17 04      jmp menu
0128   04EB             
0129   04EB             fdc_options:
0130   04EB 3B 81 06      mov d, ss3
0131   04EE 07 1F 09      call _puts
0132   04F1 07 0A 0A      call scan_u8x
0133   04F4 2F            mov bl, al
0134   04F5 19 02         mov al, 2
0135   04F7 05 0C         syscall sys_system
0136   04F9 0A 17 04      jmp menu
0137   04FC             
0138   04FC             status0:
0139   04FC 07 CC 08      call printnl
0140   04FF 19 0B         mov al, fdc_al_status0
0141   0501 05 0D         syscall sys_fdc
0142   0503 2F            mov bl, al
0143   0504 07 BF 09      call print_u8x   ; print bl
0144   0507 07 CC 08      call printnl
0145   050A 0A 17 04      jmp menu
0146   050D             
0147   050D             status1:
0148   050D 07 CC 08      call printnl
0149   0510 19 0C         mov al, fdc_al_status1
0150   0512 05 0D         syscall sys_fdc
0151   0514 2F            mov bl, al
0152   0515 07 BF 09      call print_u8x   ; print bl
0153   0518 07 CC 08      call printnl
0154   051B 0A 17 04      jmp menu
0155   051E             
0156   051E             
0157   051E             ; b : len
0158   051E             ; d: data address
0159   051E             cmd_hexd:
0160   051E 07 CC 08      call printnl
0161   0521 13            mov a, d
0162   0522 42 91 05      mov [start], a
0163   0525 FD 42 93 05   mov [length], b
0164   0529             
0165   0529 14 91 05    	mov a, [start]
0166   052C 3C            mov d, a        ; dump pointer in d
0167   052D 38 00 00      mov c, 0
0168   0530             dump_loop:
0169   0530 84            mov al, cl
0170   0531 87 0F         and al, $0f
0171   0533 C6 7B 05      jz print_base
0172   0536             back:
0173   0536 1E            mov al, [d]        ; read byte
0174   0537 2F            mov bl, al
0175   0538 07 BF 09      call print_u8x
0176   053B 10 00 20      mov a, $2000
0177   053E 05 03         syscall sys_io      ; space
0178   0540 84            mov al, cl
0179   0541 87 0F         and al, $0f
0180   0543 B9 0F         cmp al, $0f
0181   0545 C6 55 05      je print_ascii
0182   0548             back1:
0183   0548 79            inc d
0184   0549 78            inc c
0185   054A 14 93 05      mov a, [length]
0186   054D B1            cmp a, c
0187   054E C7 30 05      jne dump_loop
0188   0551 07 CC 08      call printnl
0189   0554 09            ret
0190   0555             
0191   0555             print_ascii:
0192   0555 63 10 00      sub d, 16
0193   0558 26 10 00      mov b, 16
0194   055B             print_ascii_l:
0195   055B 79            inc d
0196   055C 1E            mov al, [d]        ; read byte
0197   055D B9 20         cmp al, $20
0198   055F C8 67 05      jlu dot
0199   0562 B9 7E         cmp al, $7e
0200   0564 D0 6F 05      jleu ascii
0201   0567             dot:
0202   0567 10 00 2E      mov a, $2e00
0203   056A 05 03         syscall sys_io
0204   056C 0A 74 05      jmp ascii_continue
0205   056F             ascii:
0206   056F 23            mov ah, al
0207   0570 19 00         mov al, 0
0208   0572 05 03         syscall sys_io
0209   0574             ascii_continue:
0210   0574 FD A9 5B 05   loopb print_ascii_l
0211   0578 0A 48 05      jmp back1
0212   057B             print_base:
0213   057B 07 CC 08      call printnl
0214   057E 2D            mov b, d
0215   057F 61 0A 07      sub b, transient_area
0216   0582 07 7B 09      call print_u16x        ; display row
0217   0585 55 0A 07      add b, transient_area
0218   0588 10 00 20      mov a, $2000
0219   058B 05 03         syscall sys_io
0220   058D 0A 36 05      jmp back
0221   0590 09            ret
0222   0591             
0223   0591 00 00       start:   .dw 0
0224   0593 00 04       length:  .dw 1024
0225   0595             
0226   0595             
0227   0595 0A 74 72 61 s_track: .db "\ntrack: ", 0
0227   0599 63 6B 3A 20 
0227   059D 00 
0228   059E             
0229   059E 0A 30 2E 20 s_menu:  .db "\n0. step in\n"
0229   05A2 73 74 65 70 
0229   05A6 20 69 6E 0A 
0230   05AA 31 2E 20 73          .db "1. step out\n", 
0230   05AE 74 65 70 20 
0230   05B2 6F 75 74 0A 
0231   05B6 32 2E 20 72          .db "2. restore\n", 
0231   05BA 65 73 74 6F 
0231   05BE 72 65 0A 
0232   05C1 33 2E 20 72          .db "3. read status 1\n", 
0232   05C5 65 61 64 20 
0232   05C9 73 74 61 74 
0232   05CD 75 73 20 31 
0232   05D1 0A 
0233   05D2 34 2E 20 72          .db "4. read status 2\n", 
0233   05D6 65 61 64 20 
0233   05DA 73 74 61 74 
0233   05DE 75 73 20 32 
0233   05E2 0A 
0234   05E3 35 2E 20 66          .db "5. format track\n", 
0234   05E7 6F 72 6D 61 
0234   05EB 74 20 74 72 
0234   05EF 61 63 6B 0A 
0235   05F3 36 2E 20 72          .db "6. read track\n", 
0235   05F7 65 61 64 20 
0235   05FB 74 72 61 63 
0235   05FF 6B 0A 
0236   0601 37 2E 20 72          .db "7. read sector\n", 
0236   0605 65 61 64 20 
0236   0609 73 65 63 74 
0236   060D 6F 72 0A 
0237   0610 38 2E 20 63          .db "8. config\n", 
0237   0614 6F 6E 66 69 
0237   0618 67 0A 
0238   061A 39 2E 20 77          .db "9. write sector\n", 
0238   061E 72 69 74 65 
0238   0622 20 73 65 63 
0238   0626 74 6F 72 0A 
0239   062A 0A 73 65 6C          .db "\nselect option: ", 0
0239   062E 65 63 74 20 
0239   0632 6F 70 74 69 
0239   0636 6F 6E 3A 20 
0239   063A 00 
0240   063B             
0241   063B 0A 66 6F 72 s_format_done: .db "\nformat done.\n", 0
0241   063F 6D 61 74 20 
0241   0643 64 6F 6E 65 
0241   0647 2E 0A 00 
0242   064A 0A 73 65 6C str0:    .db "\nselecting drive 0...\n", 0
0242   064E 65 63 74 69 
0242   0652 6E 67 20 64 
0242   0656 72 69 76 65 
0242   065A 20 30 2E 2E 
0242   065E 2E 0A 00 
0243   0661 0A 77 61 69 str1:    .db "\nwaiting...\n", 0
0243   0665 74 69 6E 67 
0243   0669 2E 2E 2E 0A 
0243   066D 00 
0244   066E 0A 74 72 61 s1:      .db "\ntrack: ", 0
0244   0672 63 6B 3A 20 
0244   0676 00 
0245   0677 0A 73 65 63 s2:      .db "\nsector: ", 0
0245   067B 74 6F 72 3A 
0245   067F 20 00 
0246   0681 0A 76 61 6C ss3:     .db "\nvalue: ", 0
0246   0685 75 65 3A 20 
0246   0689 00 
0247   068A             
0248   068A             fdc_sec_data:
0249   068A FF EE E0 55   .db $ff, $ee, $e0, $55, $66, $33, $42, $aa, $ae, $67, $23, $11, $23, $56, $88, $99,
0249   068E 66 33 42 AA 
0249   0692 AE 67 23 11 
0249   0696 23 56 88 99 
0250   069A 1F 2E 40 53   .db $1f, $2e, $40, $53, $63, $43, $52, $1a, $a4, $67, $03, $31, $43, $56, $48, $f9,
0250   069E 63 43 52 1A 
0250   06A2 A4 67 03 31 
0250   06A6 43 56 48 F9 
0251   06AA 2F 3E 50 57   .db $2f, $3e, $50, $57, $62, $53, $21, $2a, $a3, $17, $73, $41, $53, $46, $38, $b9,
0251   06AE 62 53 21 2A 
0251   06B2 A3 17 73 41 
0251   06B6 53 46 38 B9 
0252   06BA 6F 4E 20 56   .db $6f, $4e, $20, $56, $67, $63, $20, $6a, $a2, $27, $53, $61, $23, $16, $28, $e9,
0252   06BE 67 63 20 6A 
0252   06C2 A2 27 53 61 
0252   06C6 23 16 28 E9 
0253   06CA AF 7E 10 52   .db $af, $7e, $10, $52, $62, $73, $18, $5a, $a1, $37, $43, $51, $13, $26, $18, $a9,
0253   06CE 62 73 18 5A 
0253   06D2 A1 37 43 51 
0253   06D6 13 26 18 A9 
0254   06DA 6F 3E 90 51   .db $6f, $3e, $90, $51, $63, $03, $18, $4a, $a5, $67, $33, $41, $43, $36, $68, $c9,
0254   06DE 63 03 18 4A 
0254   06E2 A5 67 33 41 
0254   06E6 43 36 68 C9 
0255   06EA 8F 5E 60 55   .db $8f, $5e, $60, $55, $68, $23, $18, $3a, $a3, $57, $23, $31, $73, $36, $48, $b9,
0255   06EE 68 23 18 3A 
0255   06F2 A3 57 23 31 
0255   06F6 73 36 48 B9 
0256   06FA 2F 1E 40 53   .db $2f, $1e, $40, $53, $69, $13, $19, $3a, $a1, $48, $23, $21, $53, $46, $38, $a9
0256   06FE 69 13 19 3A 
0256   0702 A1 48 23 21 
0256   0706 53 46 38 A9 
0257   070A             
0258   070A 00          transient_area: .db 0
0259   070B             
0260   070B             .include "lib/stdio.asm"
0001+  070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  070B             ; stdio.s
0003+  070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  070B             .include "lib/string.asm"
0001++ 070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 070B             ; string.s
0003++ 070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 070B             
0005++ 070B             
0006++ 070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 070B             ; _strrev
0008++ 070B             ; reverse a string
0009++ 070B             ; d = string address
0010++ 070B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 070B             ; 01234
0012++ 070B             _strrev:
0013++ 070B 4B          	pusha
0014++ 070C 07 52 07    	call _strlen	; length in c
0015++ 070F 12          	mov a, c
0016++ 0710 AF 01 00    	cmp a, 1
0017++ 0713 D0 2D 07    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0716 7D          	dec a
0019++ 0717 FD 4E       	mov si, d	; beginning of string
0020++ 0719 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 071B 59          	add d, a	; end of string
0022++ 071C 12          	mov a, c
0023++ 071D FD 9B       	shr a		; divide by 2
0024++ 071F 39          	mov c, a	; c now counts the steps
0025++ 0720             _strrev_l0:
0026++ 0720 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0721 F6          	lodsb		; load left-side char into al; increase si
0028++ 0722 3E          	mov [d], al	; store left char into right side
0029++ 0723 1B          	mov al, bl
0030++ 0724 F7          	stosb		; store right-side char into left-side; increase di
0031++ 0725 7E          	dec c
0032++ 0726 7F          	dec d
0033++ 0727 C2 00 00    	cmp c, 0
0034++ 072A C7 20 07    	jne _strrev_l0
0035++ 072D             _strrev_end:
0036++ 072D 4C          	popa
0037++ 072E 09          	ret
0038++ 072F             	
0039++ 072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 072F             ; _strchr
0041++ 072F             ; search string in d for char in al
0042++ 072F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 072F             _strchr:
0044++ 072F             _strchr_l0:
0045++ 072F 32          	mov bl, [d]
0046++ 0730 C1 00       	cmp bl, 0
0047++ 0732 C6 3D 07    	je _strchr_end
0048++ 0735 BA          	cmp al, bl
0049++ 0736 C6 3D 07    	je _strchr_end
0050++ 0739 79          	inc d
0051++ 073A 0A 2F 07    	jmp _strchr_l0
0052++ 073D             _strchr_end:
0053++ 073D 1B          	mov al, bl
0054++ 073E 09          	ret
0055++ 073F             
0056++ 073F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 073F             ; _strstr
0058++ 073F             ; find sub-string
0059++ 073F             ; str1 in si
0060++ 073F             ; str2 in di
0061++ 073F             ; si points to end of source string
0062++ 073F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 073F             _strstr:
0064++ 073F DB          	push al
0065++ 0740 DA          	push d
0066++ 0741 E3          	push di
0067++ 0742             _strstr_loop:
0068++ 0742 F3          	cmpsb					; compare a byte of the strings
0069++ 0743 C7 4E 07    	jne _strstr_ret
0070++ 0746 FC 00 00    	lea d, [di + 0]
0071++ 0749 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 074B C7 42 07    	jne _strstr_loop				; equal chars but not at end
0073++ 074E             _strstr_ret:
0074++ 074E F0          	pop di
0075++ 074F E7          	pop d
0076++ 0750 E8          	pop al
0077++ 0751 09          	ret
0078++ 0752             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0752             ; length of null terminated string
0080++ 0752             ; result in c
0081++ 0752             ; pointer in d
0082++ 0752             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0752             _strlen:
0084++ 0752 DA          	push d
0085++ 0753 38 00 00    	mov c, 0
0086++ 0756             _strlen_l1:
0087++ 0756 BD 00       	cmp byte [d], 0
0088++ 0758 C6 60 07    	je _strlen_ret
0089++ 075B 79          	inc d
0090++ 075C 78          	inc c
0091++ 075D 0A 56 07    	jmp _strlen_l1
0092++ 0760             _strlen_ret:
0093++ 0760 E7          	pop d
0094++ 0761 09          	ret
0095++ 0762             
0096++ 0762             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0762             ; strcmp
0098++ 0762             ; compare two strings
0099++ 0762             ; str1 in si
0100++ 0762             ; str2 in di
0101++ 0762             ; create a string compairon instrucion ?????
0102++ 0762             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0762             _strcmp:
0104++ 0762 DB          	push al
0105++ 0763 DA          	push d
0106++ 0764 E3          	push di
0107++ 0765 E2          	push si
0108++ 0766             _strcmp_loop:
0109++ 0766 F3          	cmpsb					; compare a byte of the strings
0110++ 0767 C7 72 07    	jne _strcmp_ret
0111++ 076A FB FF FF    	lea d, [si +- 1]
0112++ 076D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 076F C7 66 07    	jne _strcmp_loop				; equal chars but not at end
0114++ 0772             _strcmp_ret:
0115++ 0772 EF          	pop si
0116++ 0773 F0          	pop di
0117++ 0774 E7          	pop d
0118++ 0775 E8          	pop al
0119++ 0776 09          	ret
0120++ 0777             
0121++ 0777             
0122++ 0777             ; strcpy
0123++ 0777             ; copy null terminated string from si to di
0124++ 0777             ; source in si
0125++ 0777             ; destination in di
0126++ 0777             _strcpy:
0127++ 0777 E2          	push si
0128++ 0778 E3          	push di
0129++ 0779 DB          	push al
0130++ 077A             _strcpy_l1:
0131++ 077A F6          	lodsb
0132++ 077B F7          	stosb
0133++ 077C B9 00       	cmp al, 0
0134++ 077E C7 7A 07    	jne _strcpy_l1
0135++ 0781             _strcpy_end:
0136++ 0781 E8          	pop al
0137++ 0782 F0          	pop di
0138++ 0783 EF          	pop si
0139++ 0784 09          	ret
0140++ 0785             
0141++ 0785             ; strcat
0142++ 0785             ; concatenate a null terminated string into string at di, from string at si
0143++ 0785             ; source in si
0144++ 0785             ; destination in di
0145++ 0785             _strcat:
0146++ 0785 E2          	push si
0147++ 0786 E3          	push di
0148++ 0787 D7          	push a
0149++ 0788 DA          	push d
0150++ 0789 50          	mov a, di
0151++ 078A 3C          	mov d, a
0152++ 078B             _strcat_goto_end_l1:
0153++ 078B BD 00       	cmp byte[d], 0
0154++ 078D C6 94 07    	je _strcat_start
0155++ 0790 79          	inc d
0156++ 0791 0A 8B 07    	jmp _strcat_goto_end_l1
0157++ 0794             _strcat_start:
0158++ 0794 FD 50       	mov di, d
0159++ 0796             _strcat_l1:
0160++ 0796 F6          	lodsb
0161++ 0797 F7          	stosb
0162++ 0798 B9 00       	cmp al, 0
0163++ 079A C7 96 07    	jne _strcat_l1
0164++ 079D             _strcat_end:
0165++ 079D E7          	pop d
0166++ 079E E4          	pop a
0167++ 079F F0          	pop di
0168++ 07A0 EF          	pop si
0169++ 07A1 09          	ret
0170++ 07A2             
0171++ 07A2             
0005+  07A2             
0006+  07A2             
0007+  07A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  07A2             ; convert ascii 'o'..'f' to integer 0..15
0009+  07A2             ; ascii in bl
0010+  07A2             ; result in al
0011+  07A2             ; ascii for f = 0100 0110
0012+  07A2             ; ascii for 9 = 0011 1001
0013+  07A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  07A2             hex_ascii_encode:
0015+  07A2 1B            mov al, bl
0016+  07A3 93 40         test al, $40        ; test if letter or number
0017+  07A5 C7 AB 07      jnz hex_letter
0018+  07A8 87 0F         and al, $0f        ; get number
0019+  07AA 09            ret
0020+  07AB             hex_letter:
0021+  07AB 87 0F         and al, $0f        ; get letter
0022+  07AD 6A 09         add al, 9
0023+  07AF 09            ret
0024+  07B0             
0025+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  07B0             ; atoi
0027+  07B0             ; 2 letter hex string in b
0028+  07B0             ; 8bit integer returned in al
0029+  07B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  07B0             _atoi:
0031+  07B0 D8            push b
0032+  07B1 07 A2 07      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  07B4 30            mov bl, bh
0034+  07B5 DB            push al          ; save a
0035+  07B6 07 A2 07      call hex_ascii_encode
0036+  07B9 EA            pop bl  
0037+  07BA FD 9E 04      shl al, 4
0038+  07BD 8C            or al, bl
0039+  07BE E5            pop b
0040+  07BF 09            ret  
0041+  07C0             
0042+  07C0             
0043+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  07C0             ; scanf
0045+  07C0             ; no need for explanations!
0046+  07C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  07C0             scanf:
0048+  07C0 09            ret
0049+  07C1             
0050+  07C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  07C1             ; itoa
0052+  07C1             ; 8bit value in bl
0053+  07C1             ; 2 byte ascii result in a
0054+  07C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  07C1             _itoa:
0056+  07C1 DA            push d
0057+  07C2 D8            push b
0058+  07C3 A7 00         mov bh, 0
0059+  07C5 FD A4 04      shr bl, 4  
0060+  07C8 74            mov d, b
0061+  07C9 1F 5B 0A      mov al, [d + s_hex_digits]
0062+  07CC 23            mov ah, al
0063+  07CD               
0064+  07CD E5            pop b
0065+  07CE D8            push b
0066+  07CF A7 00         mov bh, 0
0067+  07D1 FD 87 0F      and bl, $0f
0068+  07D4 74            mov d, b
0069+  07D5 1F 5B 0A      mov al, [d + s_hex_digits]
0070+  07D8 E5            pop b
0071+  07D9 E7            pop d
0072+  07DA 09            ret
0073+  07DB             
0074+  07DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  07DB             ; hex string to binary
0076+  07DB             ; di = destination address
0077+  07DB             ; si = source
0078+  07DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  07DB             _hex_to_int:
0080+  07DB             _hex_to_int_l1:
0081+  07DB F6            lodsb          ; load from [si] to al
0082+  07DC B9 00         cmp al, 0        ; check if ascii 0
0083+  07DE C6 EB 07      jz _hex_to_int_ret
0084+  07E1 36            mov bh, al
0085+  07E2 F6            lodsb
0086+  07E3 2F            mov bl, al
0087+  07E4 07 B0 07      call _atoi        ; convert ascii byte in b to int (to al)
0088+  07E7 F7            stosb          ; store al to [di]
0089+  07E8 0A DB 07      jmp _hex_to_int_l1
0090+  07EB             _hex_to_int_ret:
0091+  07EB 09            ret    
0092+  07EC             
0093+  07EC             
0094+  07EC             
0095+  07EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  07EC             ; getchar
0097+  07EC             ; char in ah
0098+  07EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  07EC             getch:
0100+  07EC DB            push al
0101+  07ED             getch_retry:
0102+  07ED 19 01         mov al, 1
0103+  07EF 05 03         syscall sys_io      ; receive in ah
0104+  07F1 E8            pop al
0105+  07F2 09            ret
0106+  07F3             
0107+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  07F3             ; putchar
0109+  07F3             ; char in ah
0110+  07F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  07F3             _putchar:
0112+  07F3 DB            push al
0113+  07F4 19 00         mov al, 0
0114+  07F6 05 03         syscall sys_io      ; char in ah
0115+  07F8 E8            pop al
0116+  07F9 09            ret
0117+  07FA             
0118+  07FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  07FA             ;; input a string
0120+  07FA             ;; terminates with null
0121+  07FA             ;; pointer in d
0122+  07FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  07FA             _gets:
0124+  07FA D7            push a
0125+  07FB DA            push d
0126+  07FC             _gets_loop:
0127+  07FC 19 01         mov al, 1
0128+  07FE 05 03         syscall sys_io      ; receive in ah
0129+  0800 76 1B         cmp ah, 27
0130+  0802 C6 23 08      je _gets_ansi_esc
0131+  0805 76 0A         cmp ah, $0a        ; lf
0132+  0807 C6 7F 08      je _gets_end
0133+  080A 76 0D         cmp ah, $0d        ; cr
0134+  080C C6 7F 08      je _gets_end
0135+  080F 76 5C         cmp ah, $5c        ; '\\'
0136+  0811 C6 45 08      je _gets_escape
0137+  0814 76 08         cmp ah, $08      ; check for backspace
0138+  0816 C6 1F 08      je _gets_backspace
0139+  0819 1A            mov al, ah
0140+  081A 3E            mov [d], al
0141+  081B 79            inc d
0142+  081C 0A FC 07      jmp _gets_loop
0143+  081F             _gets_backspace:
0144+  081F 7F            dec d
0145+  0820 0A FC 07      jmp _gets_loop
0146+  0823             _gets_ansi_esc:
0147+  0823 19 01         mov al, 1
0148+  0825 05 03         syscall sys_io        ; receive in ah without echo
0149+  0827 76 5B         cmp ah, '['
0150+  0829 C7 FC 07      jne _gets_loop
0151+  082C 19 01         mov al, 1
0152+  082E 05 03         syscall sys_io          ; receive in ah without echo
0153+  0830 76 64         cmp ah, 'd'
0154+  0832 C6 3D 08      je _gets_left_arrow
0155+  0835 76 63         cmp ah, 'c'
0156+  0837 C6 41 08      je _gets_right_arrow
0157+  083A 0A FC 07      jmp _gets_loop
0158+  083D             _gets_left_arrow:
0159+  083D 7F            dec d
0160+  083E 0A FC 07      jmp _gets_loop
0161+  0841             _gets_right_arrow:
0162+  0841 79            inc d
0163+  0842 0A FC 07      jmp _gets_loop
0164+  0845             _gets_escape:
0165+  0845 19 01         mov al, 1
0166+  0847 05 03         syscall sys_io      ; receive in ah
0167+  0849 76 6E         cmp ah, 'n'
0168+  084B C6 6A 08      je _gets_lf
0169+  084E 76 72         cmp ah, 'r'
0170+  0850 C6 71 08      je _gets_cr
0171+  0853 76 30         cmp ah, '0'
0172+  0855 C6 78 08      je _gets_null
0173+  0858 76 5C         cmp ah, $5c  ; '\'
0174+  085A C6 63 08      je _gets_slash
0175+  085D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  085E 3E            mov [d], al
0177+  085F 79            inc d
0178+  0860 0A FC 07      jmp _gets_loop
0179+  0863             _gets_slash:
0180+  0863 19 5C         mov al, $5c
0181+  0865 3E            mov [d], al
0182+  0866 79            inc d
0183+  0867 0A FC 07      jmp _gets_loop
0184+  086A             _gets_lf:
0185+  086A 19 0A         mov al, $0a
0186+  086C 3E            mov [d], al
0187+  086D 79            inc d
0188+  086E 0A FC 07      jmp _gets_loop
0189+  0871             _gets_cr:
0190+  0871 19 0D         mov al, $0d
0191+  0873 3E            mov [d], al
0192+  0874 79            inc d
0193+  0875 0A FC 07      jmp _gets_loop
0194+  0878             _gets_null:
0195+  0878 19 00         mov al, $00
0196+  087A 3E            mov [d], al
0197+  087B 79            inc d
0198+  087C 0A FC 07      jmp _gets_loop
0199+  087F             _gets_end:
0200+  087F 19 00         mov al, 0
0201+  0881 3E            mov [d], al        ; terminate string
0202+  0882 E7            pop d
0203+  0883 E4            pop a
0204+  0884 09            ret
0205+  0885             
0206+  0885             
0207+  0885             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0885             ;; input text
0209+  0885             ;; terminated with ctrl+d
0210+  0885             ;; pointer in d
0211+  0885             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0885             _gettxt:
0213+  0885 D7            push a
0214+  0886 DA            push d
0215+  0887             _gettxt_loop:
0216+  0887 19 01         mov al, 1
0217+  0889 05 03         syscall sys_io      ; receive in ah
0218+  088B 76 04         cmp ah, 4      ; eot
0219+  088D C6 C6 08      je _gettxt_end
0220+  0890 76 08         cmp ah, $08      ; check for backspace
0221+  0892 C6 C2 08      je _gettxt_backspace
0222+  0895 76 5C         cmp ah, $5c        ; '\'
0223+  0897 C6 A0 08      je _gettxt_escape
0224+  089A 1A            mov al, ah
0225+  089B 3E            mov [d], al
0226+  089C 79            inc d
0227+  089D 0A 87 08      jmp _gettxt_loop
0228+  08A0             _gettxt_escape:
0229+  08A0 19 01         mov al, 1
0230+  08A2 05 03         syscall sys_io      ; receive in ah
0231+  08A4 76 6E         cmp ah, 'n'
0232+  08A6 C6 B4 08      je _gettxt_lf
0233+  08A9 76 72         cmp ah, 'r'
0234+  08AB C6 BB 08      je _gettxt_cr
0235+  08AE 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  08AF 3E            mov [d], al
0237+  08B0 79            inc d
0238+  08B1 0A 87 08      jmp _gettxt_loop
0239+  08B4             _gettxt_lf:
0240+  08B4 19 0A         mov al, $0a
0241+  08B6 3E            mov [d], al
0242+  08B7 79            inc d
0243+  08B8 0A 87 08      jmp _gettxt_loop
0244+  08BB             _gettxt_cr:
0245+  08BB 19 0D         mov al, $0d
0246+  08BD 3E            mov [d], al
0247+  08BE 79            inc d
0248+  08BF 0A 87 08      jmp _gettxt_loop
0249+  08C2             _gettxt_backspace:
0250+  08C2 7F            dec d
0251+  08C3 0A 87 08      jmp _gettxt_loop
0252+  08C6             _gettxt_end:
0253+  08C6 19 00         mov al, 0
0254+  08C8 3E            mov [d], al        ; terminate string
0255+  08C9 E7            pop d
0256+  08CA E4            pop a
0257+  08CB 09            ret
0258+  08CC             
0259+  08CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  08CC             ; print new line
0261+  08CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  08CC             printnl:
0263+  08CC D7            push a
0264+  08CD 10 00 0A      mov a, $0a00
0265+  08D0 05 03         syscall sys_io
0266+  08D2 10 00 0D      mov a, $0d00
0267+  08D5 05 03         syscall sys_io
0268+  08D7 E4            pop a
0269+  08D8 09            ret
0270+  08D9             
0271+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  08D9             ; _strtoint
0273+  08D9             ; 4 digit hex string number in d
0274+  08D9             ; integer returned in a
0275+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  08D9             _strtointx:
0277+  08D9 D8            push b
0278+  08DA 32            mov bl, [d]
0279+  08DB 37            mov bh, bl
0280+  08DC 33 01 00      mov bl, [d + 1]
0281+  08DF 07 B0 07      call _atoi        ; convert to int in al
0282+  08E2 23            mov ah, al        ; move to ah
0283+  08E3 33 02 00      mov bl, [d + 2]
0284+  08E6 37            mov bh, bl
0285+  08E7 33 03 00      mov bl, [d + 3]
0286+  08EA 07 B0 07      call _atoi        ; convert to int in al
0287+  08ED E5            pop b
0288+  08EE 09            ret
0289+  08EF             
0290+  08EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  08EF             ; _strtoint
0292+  08EF             ; 5 digit base10 string number in d
0293+  08EF             ; integer returned in a
0294+  08EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  08EF             _strtoint:
0296+  08EF E2            push si
0297+  08F0 D8            push b
0298+  08F1 D9            push c
0299+  08F2 DA            push d
0300+  08F3 07 52 07      call _strlen      ; get string length in c
0301+  08F6 7E            dec c
0302+  08F7 FD 4E         mov si, d
0303+  08F9 12            mov a, c
0304+  08FA FD 99         shl a
0305+  08FC 3B 73 0A      mov d, table_power
0306+  08FF 59            add d, a
0307+  0900 38 00 00      mov c, 0
0308+  0903             _strtoint_l0:
0309+  0903 F6            lodsb      ; load ascii to al
0310+  0904 B9 00         cmp al, 0
0311+  0906 C6 19 09      je _strtoint_end
0312+  0909 6F 30         sub al, $30    ; make into integer
0313+  090B 22 00         mov ah, 0
0314+  090D 2A            mov b, [d]
0315+  090E AC            mul a, b      ; result in b since it fits in 16bits
0316+  090F 11            mov a, b
0317+  0910 28            mov b, c
0318+  0911 54            add a, b
0319+  0912 39            mov c, a
0320+  0913 63 02 00      sub d, 2
0321+  0916 0A 03 09      jmp _strtoint_l0
0322+  0919             _strtoint_end:
0323+  0919 12            mov a, c
0324+  091A E7            pop d
0325+  091B E6            pop c
0326+  091C E5            pop b
0327+  091D EF            pop si
0328+  091E 09            ret
0329+  091F             
0330+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  091F             ; print null terminated string
0332+  091F             ; pointer in d
0333+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  091F             _puts:
0335+  091F D7            push a
0336+  0920 DA            push d
0337+  0921             _puts_l1:
0338+  0921 1E            mov al, [d]
0339+  0922 B9 00         cmp al, 0
0340+  0924 C6 30 09      jz _puts_end
0341+  0927 23            mov ah, al
0342+  0928 19 00         mov al, 0
0343+  092A 05 03         syscall sys_io
0344+  092C 79            inc d
0345+  092D 0A 21 09      jmp _puts_l1
0346+  0930             _puts_end:
0347+  0930 E7            pop d
0348+  0931 E4            pop a
0349+  0932 09            ret
0350+  0933             
0351+  0933             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0933             ; print n size string
0353+  0933             ; pointer in d
0354+  0933             ; size in c
0355+  0933             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0933             _putsn:
0357+  0933 DB            push al
0358+  0934 DA            push d
0359+  0935 D9            push c
0360+  0936             _putsn_l0:
0361+  0936 1E            mov al, [d]
0362+  0937 23            mov ah, al
0363+  0938 19 00         mov al, 0
0364+  093A 05 03         syscall sys_io
0365+  093C 79            inc d
0366+  093D 7E            dec c  
0367+  093E C2 00 00      cmp c, 0
0368+  0941 C7 36 09      jne _putsn_l0
0369+  0944             _putsn_end:
0370+  0944 E6            pop c
0371+  0945 E7            pop d
0372+  0946 E8            pop al
0373+  0947 09            ret
0374+  0948             
0375+  0948             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0948             ; print 16bit decimal number
0377+  0948             ; input number in a
0378+  0948             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0948             print_u16d:
0380+  0948 D7            push a
0381+  0949 D8            push b
0382+  094A FD D8         push g
0383+  094C 26 10 27      mov b, 10000
0384+  094F AE            div a, b      ; get 10000's coeff.
0385+  0950 07 74 09      call print_number
0386+  0953 11            mov a, b
0387+  0954 26 E8 03      mov b, 1000
0388+  0957 AE            div a, b      ; get 1000's coeff.
0389+  0958 07 74 09      call print_number
0390+  095B 11            mov a, b
0391+  095C 26 64 00      mov b, 100
0392+  095F AE            div a, b
0393+  0960 07 74 09      call print_number
0394+  0963 11            mov a, b
0395+  0964 26 0A 00      mov b, 10
0396+  0967 AE            div a, b
0397+  0968 07 74 09      call print_number
0398+  096B 1B            mov al, bl      ; 1's coeff in bl
0399+  096C 07 74 09      call print_number
0400+  096F FD F1         pop g
0401+  0971 E5            pop b
0402+  0972 E4            pop a
0403+  0973 09            ret
0404+  0974             
0405+  0974             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0974             ; print al
0407+  0974             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0974             print_number:
0409+  0974 6A 30         add al, $30
0410+  0976 23            mov ah, al
0411+  0977 07 F3 07      call _putchar
0412+  097A 09            ret
0413+  097B             
0414+  097B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  097B             ; print 16bit hex integer
0416+  097B             ; integer value in reg b
0417+  097B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  097B             print_u16x:
0419+  097B D7            push a
0420+  097C D8            push b
0421+  097D DD            push bl
0422+  097E 30            mov bl, bh
0423+  097F 07 C1 07      call _itoa        ; convert bh to char in a
0424+  0982 2F            mov bl, al        ; save al
0425+  0983 19 00         mov al, 0
0426+  0985 05 03         syscall sys_io        ; display ah
0427+  0987 24            mov ah, bl        ; retrieve al
0428+  0988 19 00         mov al, 0
0429+  098A 05 03         syscall sys_io        ; display al
0430+  098C             
0431+  098C EA            pop bl
0432+  098D 07 C1 07      call _itoa        ; convert bh to char in a
0433+  0990 2F            mov bl, al        ; save al
0434+  0991 19 00         mov al, 0
0435+  0993 05 03         syscall sys_io        ; display ah
0436+  0995 24            mov ah, bl        ; retrieve al
0437+  0996 19 00         mov al, 0
0438+  0998 05 03         syscall sys_io        ; display al
0439+  099A             
0440+  099A E5            pop b
0441+  099B E4            pop a
0442+  099C 09            ret
0443+  099D             
0444+  099D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  099D             ; input 16bit hex integer
0446+  099D             ; read 16bit integer into a
0447+  099D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  099D             scan_u16x:
0449+  099D F8 10 00      enter 16
0450+  09A0 D8            push b
0451+  09A1 DA            push d
0452+  09A2             
0453+  09A2 FA F1 FF      lea d, [bp + -15]
0454+  09A5 07 FA 07      call _gets        ; get number
0455+  09A8             
0456+  09A8 32            mov bl, [d]
0457+  09A9 37            mov bh, bl
0458+  09AA 33 01 00      mov bl, [d + 1]
0459+  09AD 07 B0 07      call _atoi        ; convert to int in al
0460+  09B0 23            mov ah, al        ; move to ah
0461+  09B1             
0462+  09B1 33 02 00      mov bl, [d + 2]
0463+  09B4 37            mov bh, bl
0464+  09B5 33 03 00      mov bl, [d + 3]
0465+  09B8 07 B0 07      call _atoi        ; convert to int in al
0466+  09BB             
0467+  09BB E7            pop d
0468+  09BC E5            pop b
0469+  09BD F9            leave
0470+  09BE 09            ret
0471+  09BF             
0472+  09BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  09BF             ; print 8bit hex integer
0474+  09BF             ; integer value in reg bl
0475+  09BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  09BF             print_u8x:
0477+  09BF D7            push a
0478+  09C0 DD            push bl
0479+  09C1             
0480+  09C1 07 C1 07      call _itoa        ; convert bl to char in a
0481+  09C4 2F            mov bl, al        ; save al
0482+  09C5 19 00         mov al, 0
0483+  09C7 05 03         syscall sys_io        ; display ah
0484+  09C9 24            mov ah, bl        ; retrieve al
0485+  09CA 19 00         mov al, 0
0486+  09CC 05 03         syscall sys_io        ; display al
0487+  09CE             
0488+  09CE EA            pop bl
0489+  09CF E4            pop a
0490+  09D0 09            ret
0491+  09D1             
0492+  09D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  09D1             ; print 8bit decimal unsigned number
0494+  09D1             ; input number in al
0495+  09D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  09D1             print_u8d:
0497+  09D1 D7            push a
0498+  09D2 D8            push b
0499+  09D3 FD D8         push g
0500+  09D5 22 00         mov ah, 0
0501+  09D7 26 64 00      mov b, 100
0502+  09DA AE            div a, b
0503+  09DB D8            push b      ; save remainder
0504+  09DC B9 00         cmp al, 0
0505+  09DE C6 E8 09      je skip100
0506+  09E1 6A 30         add al, $30
0507+  09E3 23            mov ah, al
0508+  09E4 19 00         mov al, 0
0509+  09E6 05 03         syscall sys_io  ; print coeff
0510+  09E8             skip100:
0511+  09E8 E4            pop a
0512+  09E9 22 00         mov ah, 0
0513+  09EB 26 0A 00      mov b, 10
0514+  09EE AE            div a, b
0515+  09EF D8            push b      ; save remainder
0516+  09F0 B9 00         cmp al, 0
0517+  09F2 C6 FC 09      je skip10
0518+  09F5 6A 30         add al, $30
0519+  09F7 23            mov ah, al
0520+  09F8 19 00         mov al, 0
0521+  09FA 05 03         syscall sys_io  ; print coeff
0522+  09FC             skip10:
0523+  09FC E4            pop a
0524+  09FD 1B            mov al, bl
0525+  09FE 6A 30         add al, $30
0526+  0A00 23            mov ah, al
0527+  0A01 19 00         mov al, 0
0528+  0A03 05 03         syscall sys_io  ; print coeff
0529+  0A05 FD F1         pop g
0530+  0A07 E5            pop b
0531+  0A08 E4            pop a
0532+  0A09 09            ret
0533+  0A0A             
0534+  0A0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0A0A             ; input 8bit hex integer
0536+  0A0A             ; read 8bit integer into al
0537+  0A0A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0A0A             scan_u8x:
0539+  0A0A F8 04 00      enter 4
0540+  0A0D D8            push b
0541+  0A0E DA            push d
0542+  0A0F             
0543+  0A0F FA FD FF      lea d, [bp + -3]
0544+  0A12 07 FA 07      call _gets        ; get number
0545+  0A15             
0546+  0A15 32            mov bl, [d]
0547+  0A16 37            mov bh, bl
0548+  0A17 33 01 00      mov bl, [d + 1]
0549+  0A1A 07 B0 07      call _atoi        ; convert to int in al
0550+  0A1D             
0551+  0A1D E7            pop d
0552+  0A1E E5            pop b
0553+  0A1F F9            leave
0554+  0A20 09            ret
0555+  0A21             
0556+  0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0A21             ; input decimal number
0558+  0A21             ; result in a
0559+  0A21             ; 655'\0'
0560+  0A21             ; low--------high
0561+  0A21             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0A21             scan_u16d:
0563+  0A21 F8 08 00      enter 8
0564+  0A24 E2            push si
0565+  0A25 D8            push b
0566+  0A26 D9            push c
0567+  0A27 DA            push d
0568+  0A28 FA F9 FF      lea d, [bp +- 7]
0569+  0A2B 07 FA 07      call _gets
0570+  0A2E 07 52 07      call _strlen      ; get string length in c
0571+  0A31 7E            dec c
0572+  0A32 FD 4E         mov si, d
0573+  0A34 12            mov a, c
0574+  0A35 FD 99         shl a
0575+  0A37 3B 73 0A      mov d, table_power
0576+  0A3A 59            add d, a
0577+  0A3B 38 00 00      mov c, 0
0578+  0A3E             mul_loop:
0579+  0A3E F6            lodsb      ; load ascii to al
0580+  0A3F B9 00         cmp al, 0
0581+  0A41 C6 54 0A      je mul_exit
0582+  0A44 6F 30         sub al, $30    ; make into integer
0583+  0A46 22 00         mov ah, 0
0584+  0A48 2A            mov b, [d]
0585+  0A49 AC            mul a, b      ; result in b since it fits in 16bits
0586+  0A4A 11            mov a, b
0587+  0A4B 28            mov b, c
0588+  0A4C 54            add a, b
0589+  0A4D 39            mov c, a
0590+  0A4E 63 02 00      sub d, 2
0591+  0A51 0A 3E 0A      jmp mul_loop
0592+  0A54             mul_exit:
0593+  0A54 12            mov a, c
0594+  0A55 E7            pop d
0595+  0A56 E6            pop c
0596+  0A57 E5            pop b
0597+  0A58 EF            pop si
0598+  0A59 F9            leave
0599+  0A5A 09            ret
0600+  0A5B             
0601+  0A5B             
0602+  0A5B 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  0A5F 34 35 36 37 
0602+  0A63 38 39 61 62 
0602+  0A67 63 64 65 66 
0603+  0A6B 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  0A6F 1B 5B 68 00 
0604+  0A73             
0605+  0A73             table_power:
0606+  0A73 01 00         .dw 1
0607+  0A75 0A 00         .dw 10
0608+  0A77 64 00         .dw 100
0609+  0A79 E8 03         .dw 1000
0610+  0A7B 10 27         .dw 100000261   0A7D             .end
tasm: Number of errors = 0
