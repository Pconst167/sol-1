0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 series minicomputer bios version 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; memory map
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000    rom begin
0009   0000             ; ....
0010   0000             ; 7fff    rom end
0011   0000             ;
0012   0000             ; 8000    ram begin
0013   0000             ; ....
0014   0000             ; f7ff    stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; i/o map
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; ff80    uart 0    (16550)
0020   0000             ; ff90    uart 1    (16550)
0021   0000             ; ffa0    rtc       (m48t02)
0022   0000             ; ffb0    pio 0     (8255)
0023   0000             ; ffc0    pio 1     (8255)
0024   0000             ; ffd0    ide       (compact flash / pata)
0025   0000             ; ffe0    timer     (8253)
0026   0000             ; fff0    bios configuration nv-ram store area
0027   0000             
0028   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029   0000             ; system constants / equations
0030   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031   0000             _uart0_data      .equ $ff80        		 ; data
0032   0000             _uart0_dlab_0    .equ $ff80        		 ; divisor latch low byte
0033   0000             _uart0_dlab_1    .equ $ff81        		 ; divisor latch high byte
0034   0000             _uart0_ier       .equ $ff81        		 ; interrupt enable register
0035   0000             _uart0_fcr       .equ $ff82        		 ; fifo control register
0036   0000             _uart0_lcr       .equ $ff83        		 ; line control register
0037   0000             _uart0_lsr       .equ $ff85        		 ; line status register
0038   0000             
0039   0000             _ide_base        .equ $ffd0        		 ; ide base
0040   0000             _ide_r0          .equ _ide_base + 0    ; data port
0041   0000             _ide_r1          .equ _ide_base + 1    ; read: error code, write: feature
0042   0000             _ide_r2          .equ _ide_base + 2    ; number of sectors to transfer
0043   0000             _ide_r3          .equ _ide_base + 3    ; sector address lba 0 [0:7]
0044   0000             _ide_r4          .equ _ide_base + 4    ; sector address lba 1 [8:15]
0045   0000             _ide_r5          .equ _ide_base + 5    ; sector address lba 2 [16:23]
0046   0000             _ide_r6          .equ _ide_base + 6    ; sector address lba 3 [24:27 (lsb)]
0047   0000             _ide_r7          .equ _ide_base + 7    ; read: status, write: command
0048   0000             
0049   0000             _7seg_display    .equ $ffb0        		 ; bios post code hex display (2 digits)
0050   0000             _bios_post_ctrl  .equ $ffb3        		 ; bios post display control register, 80h = as output
0051   0000             _pio_a           .equ $ffb0    
0052   0000             _pio_b           .equ $ffb1
0053   0000             _pio_c           .equ $ffb2
0054   0000             _pio_control     .equ $ffb3        		 ; pio control port
0055   0000             
0056   0000             _timer_c_0       .equ $ffe0        		 ; timer counter 0
0057   0000             _timer_c_1       .equ $ffe1        		 ; timer counter 1
0058   0000             _timer_c_2       .equ $ffe2        		 ; timer counter 2
0059   0000             _timer_ctrl      .equ $ffe3        		 ; timer control register
0060   0000             
0061   0000             _stack_begin     .equ $f7ff       		 ; beginning of stack
0062   0000             _global_base     .equ $8000       		 ; base of global variable block
0063   0000             
0064   0000             
0065   0000             boot_origin:     .equ _global_base + 2 + 2
0066   0000             
0067   0000             ide_buffer:      .equ _global_base + 2 + 2 + 512
0068   0000             
0069   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070   0000             ; global system variables
0071   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0072   0000             
0073   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0074   0000             ; external interrupt table
0075   0000             ; highest priority at lowest address
0076   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0077   0000 34 00       .dw int_0
0078   0002 35 00       .dw int_1
0079   0004 36 00       .dw int_2
0080   0006 37 00       .dw int_3
0081   0008 38 00       .dw int_4
0082   000A 39 00       .dw int_5
0083   000C 3A 00       .dw int_6
0084   000E 3B 00       .dw int_7
0085   0010             
0086   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0087   0010             ; reset vector declaration
0088   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0089   0010 C0 01       .dw bios_reset_vector
0090   0012             
0091   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0092   0012             ;; exception vector table
0093   0012             ;; total of 7 entries, starting at address $0012
0094   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095   0012 3C 00       .dw trap_privilege  
0096   0014 52 00       .dw trap_div_zero  
0097   0016 5F 00       .dw undefined_opcode
0098   0018 00 00       .dw 0
0099   001A 00 00       .dw 0
0100   001C 00 00       .dw 0
0101   001E 00 00       .dw 0
0102   0020             
0103   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0104   0020             ;; system call vector table
0105   0020             ;; starts at address $0020
0106   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0107   0020 45 00       .dw trap_breakpoint
0108   0022 60 00       .dw rtc_services        
0109   0024 96 00       .dw uart_services        
0110   0026 EE 00       .dw ide_services  
0111   0028 00 00       .dw 0
0112   002A 00 00       .dw 0
0113   002C 00 00       .dw 0
0114   002E 00 00       .dw 0
0115   0030 00 00       .dw 0
0116   0032 00 00       .dw 0  
0117   0034             
0118   0034             bios_bkpt  .equ 0
0119   0034             bios_rtc   .equ 1
0120   0034             bios_uart  .equ 2
0121   0034             bios_ide   .equ 3
0122   0034             
0123   0034             .export bios_reset_vector
0124   0034             .export ide_buffer
0125   0034             .export boot_origin
0126   0034             .export bios_uart
0127   0034             .export bios_ide
0128   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129   0034             ; external interrupts' code block
0130   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0131   0034             int_0:
0132   0034 06            sysret
0133   0035             int_1:
0134   0035 06            sysret
0135   0036             int_2:
0136   0036 06            sysret
0137   0037             int_3:
0138   0037 06            sysret
0139   0038             int_4:
0140   0038 06            sysret
0141   0039             int_5:
0142   0039 06            sysret
0143   003A             int_6:  
0144   003A 06            sysret
0145   003B             int_7:
0146   003B 06            sysret
0147   003C             
0148   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0149   003C             ; exceptions
0150   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0151   003C             
0152   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0153   003C             ; privilege exception
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             trap_privilege:
0156   003C DA            push d
0157   003D 3B B5 05      mov d, s_priv1
0158   0040 07 82 02      call _puts
0159   0043 E7            pop d
0160   0044                           ; enable interrupts
0161   0044 06            sysret
0162   0045             
0163   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0164   0045             ; breakpoint exception
0165   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0166   0045             trap_breakpoint:
0167   0045 D7            push a
0168   0046 DA            push d
0169   0047 E1            pushf
0170   0048               
0171   0048 3B 9D 05      mov d, s_bkpt
0172   004B 07 82 02      call _puts
0173   004E               
0174   004E EE            popf
0175   004F E7            pop d
0176   0050 E4            pop a
0177   0051                           ; enable interrupts
0178   0051 06            sysret
0179   0052             
0180   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0181   0052             ; divide by zero exception
0182   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0183   0052             trap_div_zero:
0184   0052 D7            push a
0185   0053 DA            push d
0186   0054 E1            pushf
0187   0055               
0188   0055 3B FD 05      mov d, s_divzero
0189   0058 07 82 02      call _puts
0190   005B               
0191   005B EE            popf
0192   005C E7            pop d
0193   005D E4            pop a
0194   005E                           ; enable interrupts
0195   005E 06            sysret
0196   005F             
0197   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0198   005F             ; undefined opcode exception
0199   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0200   005F             undefined_opcode:
0201   005F 06            sysret
0202   0060               
0203   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0204   0060             ; rtc services interrupt
0205   0060             ; rtc i/o bank = ffa0 to ffaf
0206   0060             ; ffa0 to ffa7 is scratch ram
0207   0060             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0208   0060             ; al = 0..6 -> get
0209   0060             ; al = 7..d -> set
0210   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0211   0060             rtc_services:
0212   0060 DB            push al
0213   0061 DA            push d
0214   0062 B9 06         cmp al, 6
0215   0064 D1 79 00      jgu rtc_set
0216   0067             rtc_get:
0217   0067 6A A9         add al, $a9      ; generate rtc address to get to address a9 of clock
0218   0069 22 FF         mov ah, $ff    
0219   006B 3C            mov d, a        ; get to ffa9 + offset
0220   006C F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0221   0070 1E            mov al, [d]      ; get data
0222   0071 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset r bit
0223   0075 23            mov ah, al
0224   0076 E7            pop d
0225   0077 E8            pop al
0226   0078 06            sysret
0227   0079             rtc_set:
0228   0079 DD            push bl
0229   007A 99            mov bl, ah    ; set data aside
0230   007B 6A A2         add al, $a2    ; generate rtc address to get to address a9 of clock
0231   007D 22 FF         mov ah, $ff    
0232   007F 3C            mov d, a    ; get to ffa9 + offset
0233   0080 1B            mov al, bl    ; get data back
0234   0081 F2 A8 FF 80   mov byte[$ffa8], $80  ; set w bit to 1
0235   0085 3E            mov [d], al    ; set data
0236   0086 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset write bit
0237   008A EA            pop bl
0238   008B E7            pop d
0239   008C E8            pop al
0240   008D 06            sysret
0241   008E             
0242   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0243   008E             ; int 4
0244   008E             ; uart services interrupt
0245   008E             ; al = option
0246   008E             ; ah = data
0247   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0248   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0249   008E             uart_serv_tbl:
0250   008E 9A 00         .dw uart_init
0251   0090 B3 00         .dw uart_send
0252   0092 C0 00         .dw uart_receive
0253   0094 CD 00         .dw uart_receive_e
0254   0096             uart_services:
0255   0096 FD 0A 8E 00   jmp [uart_serv_tbl + al]
0256   009A             
0257   009A             uart_init:
0258   009A F2 83 FF 8F   mov byte[_uart0_lcr], %10001111      ; 8 data, 2 stop, odd parity, divisor latch = 1, uart address 3 = line control register
0259   009E F2 80 FF 03   mov byte[_uart0_dlab_0], 3      ; baud = 38400
0260   00A2 F2 81 FF 00   mov byte[_uart0_dlab_1], 0      ; divisor latch high byte = 0      
0261   00A6 F2 83 FF 0F   mov byte[_uart0_lcr], %00001111      ; divisor latch = 0, uart address 3 = line control register
0262   00AA F2 81 FF 00   mov byte[_uart0_ier], 0      ; disable all uart interrupts
0263   00AE F2 82 FF 00   mov byte[_uart0_fcr], 0      ; disable fifo
0264   00B2 06            sysret
0265   00B3             
0266   00B3             uart_send:
0267   00B3 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0268   00B6 93 20         test al, 20h          ; isolate transmitter empty
0269   00B8 C6 B3 00      jz uart_send    
0270   00BB 1A            mov al, ah
0271   00BC 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0272   00BF 06            sysret
0273   00C0             
0274   00C0             uart_receive:
0275   00C0 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0276   00C3 93 01         test al, 1          ; isolate data ready
0277   00C5 C6 C0 00      jz uart_receive
0278   00C8 1D 80 FF      mov al, [_uart0_data]      ; get character
0279   00CB 23            mov ah, al
0280   00CC 06            sysret
0281   00CD             
0282   00CD             uart_receive_e:
0283   00CD 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0284   00D0 93 01         test al, 1          ; isolate data ready
0285   00D2 C6 CD 00      jz uart_receive_e
0286   00D5 1D 80 FF      mov al, [_uart0_data]      ; get character
0287   00D8 23            mov ah, al
0288   00D9             uart_receive_e_loop:
0289   00D9 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0290   00DC 93 20         test al, 20h          ; isolate transmitter empty
0291   00DE C6 D9 00      jz uart_receive_e_loop
0292   00E1 1A            mov al, ah
0293   00E2 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0294   00E5 06            sysret
0295   00E6               
0296   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0297   00E6             ; ide services interrupt
0298   00E6             ; al = option
0299   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0300   00E6             ; ide read/write sector
0301   00E6             ; 512 bytes
0302   00E6             ; user buffer pointer in d
0303   00E6             ; kernel buffer pointer = ide_buffer
0304   00E6             ; ah = number of sectors
0305   00E6             ; cb = lba bytes 3..0
0306   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0307   00E6             ide_serv_tbl:
0308   00E6 F2 00         .dw ide_reset
0309   00E8 06 01         .dw ide_sleep
0310   00EA 15 01         .dw ide_read_sect
0311   00EC 36 01         .dw ide_write_sect
0312   00EE             ide_services:
0313   00EE FD 0A E6 00   jmp [ide_serv_tbl + al]  
0314   00F2             ide_reset:      
0315   00F2 F2 D7 FF 04   mov byte[_ide_r7], 4    ; reset ide
0316   00F6 07 87 01      call ide_wait        ; wait for ide ready             
0317   00F9 F2 D6 FF E0   mov byte[_ide_r6], $e0    ; lba3= 0, master, mode= lba        
0318   00FD F2 D1 FF 01   mov byte[_ide_r1], 1    ; 8-bit transfers      
0319   0101 F2 D7 FF EF   mov byte[_ide_r7], $ef    ; set feature command
0320   0105 06            sysret
0321   0106             ide_sleep:
0322   0106 07 87 01      call ide_wait          ; wait for ide ready             
0323   0109 F2 D6 FF 40   mov byte [_ide_r6], %01000000  ; lba[3:0](reserved), bit 6=1
0324   010D F2 D7 FF E6   mov byte [_ide_r7], $e6    ; sleep command
0325   0111 07 87 01      call ide_wait          ; wait for ide ready
0326   0114 06            sysret
0327   0115             ide_read_sect:
0328   0115 1A            mov al, ah
0329   0116 24            mov ah, bl
0330   0117 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0331   011A 1C            mov al, bh
0332   011B 3D D4 FF      mov [_ide_r4], al
0333   011E 12            mov a, c
0334   011F 3D D5 FF      mov [_ide_r5], al
0335   0122 1A            mov al, ah
0336   0123 87 0F         and al, %00001111
0337   0125 8B E0         or al, %11100000      ; mode lba, master
0338   0127 3D D6 FF      mov [_ide_r6], al
0339   012A 07 87 01      call ide_wait
0340   012D 19 20         mov al, 20h
0341   012F 3D D7 FF      mov [_ide_r7], al      ; read sector cmd
0342   0132 07 57 01      call ide_read  
0343   0135 06            sysret
0344   0136             ide_write_sect:
0345   0136 1A            mov al, ah
0346   0137 24            mov ah, bl
0347   0138 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0348   013B 1C            mov al, bh
0349   013C 3D D4 FF      mov [_ide_r4], al
0350   013F 12            mov a, c
0351   0140 3D D5 FF      mov [_ide_r5], al
0352   0143 1A            mov al, ah
0353   0144 87 0F         and al, %00001111
0354   0146 8B E0         or al, %11100000      ; mode lba, master
0355   0148 3D D6 FF      mov [_ide_r6], al
0356   014B 07 87 01      call ide_wait
0357   014E 19 30         mov al, 30h
0358   0150 3D D7 FF      mov [_ide_r7], al      ; write sector cmd
0359   0153 07 6F 01      call ide_write      
0360   0156 06            sysret
0361   0157             
0362   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0363   0157             ; read ide data
0364   0157             ; pointer in d
0365   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0366   0157             ide_read:
0367   0157 DB            push al
0368   0158 DA            push d
0369   0159             ide_read_loop:
0370   0159 07 87 01      call ide_wait
0371   015C 1D D7 FF      mov al, [_ide_r7]
0372   015F 87 08         and al, %00001000      ; drq flag
0373   0161 C6 6C 01      jz ide_read_end
0374   0164 1D D0 FF      mov al, [_ide_r0]
0375   0167 3E            mov [d], al
0376   0168 79            inc d
0377   0169 0A 59 01      jmp ide_read_loop
0378   016C             ide_read_end:
0379   016C E7            pop d
0380   016D E8            pop al
0381   016E 09            ret
0382   016F             
0383   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0384   016F             ; write ide data
0385   016F             ; data pointer in d
0386   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0387   016F             ide_write:
0388   016F DB            push al
0389   0170 DA            push d
0390   0171             ide_write_loop:
0391   0171 07 87 01      call ide_wait
0392   0174 1D D7 FF      mov al, [_ide_r7]
0393   0177 87 08         and al, %00001000      ; drq flag
0394   0179 C6 84 01      jz ide_write_end
0395   017C 1E            mov al, [d]
0396   017D 3D D0 FF      mov [_ide_r0], al
0397   0180 79            inc d 
0398   0181 0A 71 01      jmp ide_write_loop
0399   0184             ide_write_end:
0400   0184 E7            pop d
0401   0185 E8            pop al
0402   0186 09            ret
0403   0187             
0404   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0405   0187             ; wait for ide to be ready
0406   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0407   0187             ide_wait:
0408   0187 1D D7 FF      mov al, [_ide_r7]  
0409   018A 87 80         and al, 80h        ; busy flag
0410   018C C7 87 01      jnz ide_wait
0411   018F 09            ret
0412   0190             
0413   0190             ; ************************************************************
0414   0190             ; get hex file
0415   0190             ; di = destination address
0416   0190             ; return length in bytes in c
0417   0190             ; ************************************************************
0418   0190             _load_hex:
0419   0190 D2            push bp
0420   0191 9B            mov bp, sp
0421   0192 D7            push a
0422   0193 D8            push b
0423   0194 DA            push d
0424   0195 E2            push si
0425   0196 E3            push di
0426   0197 52 00 60      sub sp, $6000        ; string data block
0427   019A 38 00 00      mov c, 0
0428   019D               
0429   019D 48            mov a, sp
0430   019E 77            inc a
0431   019F 3C            mov d, a        ; start of string data block
0432   01A0 07 F5 02      call _getse        ; get program string
0433   01A3 4D            mov si, a
0434   01A4             
0435   01A4             __load_hex_loop:
0436   01A4 F6            lodsb          ; load from [SI] to AL
0437   01A5 B9 00         cmp al, 0        ; check if ASCII 0
0438   01A7 C6 B5 01      jz __load_hex_ret
0439   01AA 36            mov bh, al
0440   01AB F6            lodsb
0441   01AC 2F            mov bl, al
0442   01AD 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0443   01B0 F7            stosb          ; store AL to [DI]
0444   01B1 78            inc c
0445   01B2 0A A4 01      jmp __load_hex_loop
0446   01B5             __load_hex_ret:
0447   01B5 51 00 60      add sp, $6000
0448   01B8 F0            pop di
0449   01B9 EF            pop si
0450   01BA E7            pop d
0451   01BB E5            pop b
0452   01BC E4            pop a
0453   01BD 9C            mov sp, bp
0454   01BE F1            pop bp
0455   01BF 09            ret
0456   01C0               
0457   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0458   01C0             ; bios entry point
0459   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0460   01C0             bios_reset_vector:
0461   01C0 19 00         mov al, %00000000        ; interrupts = off, mode = sup, paging = off, halt-flag = off, display_load = on
0462   01C2 0D            stostat
0463   01C3               
0464   01C3 10 FF F7      mov a, _stack_begin
0465   01C6 47            mov sp, a
0466   01C7 49            mov bp, a      ; setup stack and frame
0467   01C8             
0468   01C8 19 00         mov al, 0
0469   01CA 05 02         syscall bios_uart
0470   01CC               
0471   01CC 3B EA 03      mov d, s_welcome
0472   01CF 07 82 02      call _puts          ; print welcome msg
0473   01D2             
0474   01D2 07 F2 01      call bios_peripherals_setup
0475   01D5               
0476   01D5 3B 3D 04      mov d, s_boot1
0477   01D8 07 82 02      call _puts
0478   01DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0479   01DB 38 00 00      mov c, 0
0480   01DE 26 00 00      mov b, 0          ; start at disk sector 0
0481   01E1 3B 04 80      mov d, boot_origin    ; we read into the bios ide buffer
0482   01E4 10 02 01      mov a, $0102        ; disk read, 1 sector
0483   01E7 05 03         syscall bios_ide      ; read sector  
0484   01E9               
0485   01E9 3B 53 04      mov d, s_boot2
0486   01EC 07 82 02      call _puts
0487   01EF             
0488   01EF 0A 04 80      jmp boot_origin
0489   01F2             
0490   01F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0491   01F2             
0492   01F2             bios_peripherals_setup:
0493   01F2 3B AD 04      mov d, s_init
0494   01F5 07 82 02      call _puts
0495   01F8               
0496   01F8 3B 66 04      mov d, s_bios3
0497   01FB 07 82 02      call _puts
0498   01FE 19 00         mov al, 0            ; reset ide
0499   0200 05 03         syscall bios_ide  
0500   0202               
0501   0202 3B 7C 04      mov d, s_bios4
0502   0205 07 82 02      call _puts
0503   0208               
0504   0208 19 30         mov al, %00110000          ; counter 0, load both bytes, mode 0, binary
0505   020A 3D E3 FF      mov [_timer_ctrl], al
0506   020D 19 FF         mov al, $ff
0507   020F 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 low byte
0508   0212 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 high byte
0509   0215               
0510   0215 3B 92 04      mov d, s_bios5
0511   0218 07 82 02      call _puts
0512   021B 19 80         mov al, $80
0513   021D 3D B3 FF      mov [_bios_post_ctrl], al      ; set pio_a to output mode
0514   0220 19 00         mov al, 0
0515   0222 3D B0 FF      mov [_7seg_display], al      ; post code = 00
0516   0225 09            ret
0517   0226             
0518   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0519   0226             ; print 16bit hex integer
0520   0226             ; integer value in reg b
0521   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0522   0226             print_u16x:
0523   0226 E1            pushf
0524   0227 D7            push a
0525   0228 D8            push b
0526   0229 DD            push bl
0527   022A 30            mov bl, bh
0528   022B 07 70 03      call _itoa        ; convert bh to char in a
0529   022E 2F            mov bl, al        ; save al  
0530   022F 19 01         mov al, 1
0531   0231 05 02         syscall bios_uart        ; display ah
0532   0233 24            mov ah, bl        ; retrieve al
0533   0234 19 01         mov al, 1
0534   0236 05 02         syscall bios_uart        ; display al
0535   0238             
0536   0238 EA            pop bl
0537   0239 07 70 03      call _itoa        ; convert bh to char in a
0538   023C 2F            mov bl, al        ; save al
0539   023D 19 01         mov al, 1
0540   023F 05 02         syscall bios_uart        ; display ah
0541   0241 24            mov ah, bl        ; retrieve al
0542   0242 19 01         mov al, 1
0543   0244 05 02         syscall bios_uart        ; display al
0544   0246             
0545   0246 E5            pop b
0546   0247 E4            pop a
0547   0248 EE            popf
0548   0249 09            ret
0549   024A             
0550   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0551   024A             ; input 16bit hex integer
0552   024A             ; read 16bit integer into a
0553   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0554   024A             scan_u16x:
0555   024A F8 10 00      enter 16
0556   024D E1            pushf
0557   024E D8            push b
0558   024F DA            push d
0559   0250             
0560   0250 FA F1 FF      lea d, [bp + -15]
0561   0253 07 F5 02      call _getse        ; get number
0562   0256             
0563   0256 32            mov bl, [d]
0564   0257 37            mov bh, bl
0565   0258 33 01 00      mov bl, [d + 1]
0566   025B 07 5E 03      call _atoi        ; convert to int in al
0567   025E 23            mov ah, al        ; move to ah
0568   025F               
0569   025F 33 02 00      mov bl, [d + 2]
0570   0262 37            mov bh, bl
0571   0263 33 03 00      mov bl, [d + 3]
0572   0266 07 5E 03      call _atoi        ; convert to int in al
0573   0269               
0574   0269 E7            pop d  
0575   026A E5            pop b
0576   026B EE            popf
0577   026C F9            leave
0578   026D 09            ret
0579   026E             
0580   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0581   026E             ; print 8bit hex integer
0582   026E             ; byte value in reg bl
0583   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0584   026E             xput_u8:
0585   026E D7            push a
0586   026F DD            push bl
0587   0270 E1            pushf
0588   0271             
0589   0271 07 70 03      call _itoa          ; convert bl to char in a
0590   0274 2F            mov bl, al          ; save al  
0591   0275 19 01         mov al, 1
0592   0277 05 02         syscall bios_uart        ; display ah
0593   0279 24            mov ah, bl          ; retrieve al
0594   027A 19 01         mov al, 1
0595   027C 05 02         syscall bios_uart        ; display al
0596   027E               
0597   027E EE            popf
0598   027F EA            pop bl
0599   0280 E4            pop a
0600   0281 09            ret
0601   0282             
0602   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0603   0282             ; print null terminated string
0604   0282             ; pointer in d
0605   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0606   0282             _puts:
0607   0282 D7            push a
0608   0283 DA            push d
0609   0284 E1            pushf
0610   0285             _puts_l1:
0611   0285 1E            mov al, [d]
0612   0286 B9 00         cmp al, 0
0613   0288 C6 9B 02      jz _puts_end
0614   028B             _puts_l2:
0615   028B 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0616   028E 93 20         test al, $20          ; isolate transmitter empty
0617   0290 C6 8B 02      jz _puts_l2    
0618   0293 1E            mov al, [d]
0619   0294 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0620   0297 79            inc d  
0621   0298 0A 85 02      jmp _puts_l1
0622   029B             _puts_end:
0623   029B EE            popf
0624   029C E7            pop d
0625   029D E4            pop a
0626   029E 09            ret
0627   029F             
0628   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0629   029F             ; _putchar
0630   029F             ; char in ah
0631   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0632   029F             _putchar:
0633   029F D7            push a
0634   02A0 E1            pushf
0635   02A1             _putchar_l1:
0636   02A1 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0637   02A4 93 20         test al, 20h          ; isolate transmitter empty
0638   02A6 C6 A1 02      jz _putchar_l1    
0639   02A9 1A            mov al, ah
0640   02AA 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0641   02AD EE            popf
0642   02AE E4            pop a
0643   02AF 09            ret
0644   02B0               
0645   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0646   02B0             ;; input a string with no echo
0647   02B0             ;; terminates with null
0648   02B0             ;; pointer in d
0649   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0650   02B0             _gets:
0651   02B0 E1            pushf
0652   02B1 D7            push a
0653   02B2 DA            push d
0654   02B3             _gets_loop:
0655   02B3 19 02         mov al, 2
0656   02B5 05 02         syscall bios_uart      ; receive in ah
0657   02B7 76 0A         cmp ah, 0ah        ; lf
0658   02B9 C6 EE 02      je _gets_end
0659   02BC 76 0D         cmp ah, 0dh        ; cr
0660   02BE C6 EE 02      je _gets_end
0661   02C1 76 5C         cmp ah, $5c        ; '\\'
0662   02C3 C6 CC 02      je _gets_escape
0663   02C6 1A            mov al, ah
0664   02C7 3E            mov [d], al
0665   02C8 79            inc d
0666   02C9 0A B3 02      jmp _gets_loop
0667   02CC             _gets_escape:
0668   02CC 19 02         mov al, 2
0669   02CE 05 02         syscall bios_uart      ; receive in ah
0670   02D0 76 6E         cmp ah, 'n'
0671   02D2 C6 E0 02      je _gets_lf
0672   02D5 76 72         cmp ah, 'r'
0673   02D7 C6 E7 02      je _gets_cr
0674   02DA 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0675   02DB 3E            mov [d], al
0676   02DC 79            inc d
0677   02DD 0A B3 02      jmp _gets_loop
0678   02E0             _gets_lf:
0679   02E0 19 0A         mov al, $0a
0680   02E2 3E            mov [d], al
0681   02E3 79            inc d
0682   02E4 0A B3 02      jmp _gets_loop
0683   02E7             _gets_cr:
0684   02E7 19 0D         mov al, $0d
0685   02E9 3E            mov [d], al
0686   02EA 79            inc d
0687   02EB 0A B3 02      jmp _gets_loop
0688   02EE             _gets_end:
0689   02EE 19 00         mov al, 0
0690   02F0 3E            mov [d], al        ; terminate string
0691   02F1 E7            pop d
0692   02F2 E4            pop a
0693   02F3 EE            popf
0694   02F4 09            ret
0695   02F5             
0696   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0697   02F5             ;; INPUT A STRING with echo
0698   02F5             ;; terminates with null
0699   02F5             ;; pointer in D
0700   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0701   02F5             _getse:
0702   02F5 E1            pushf
0703   02F6 D7            push a
0704   02F7 DA            push d
0705   02F8             _getse_loop:
0706   02F8 19 03         mov al, 3
0707   02FA 05 02         syscall bios_uart      ; receive in AH
0708   02FC 76 0A         cmp ah, 0Ah        ; LF
0709   02FE C6 33 03      je _getse_end
0710   0301 76 0D         cmp ah, 0Dh        ; CR
0711   0303 C6 33 03      je _getse_end
0712   0306 76 5C         cmp ah, $5C        ; '\\'
0713   0308 C6 11 03      je _getse_escape
0714   030B 1A            mov al, ah
0715   030C 3E            mov [d], al
0716   030D 79            inc d
0717   030E 0A F8 02      jmp _getse_loop
0718   0311             _getse_escape:
0719   0311 19 03         mov al, 3
0720   0313 05 02         syscall bios_uart      ; receive in AH
0721   0315 76 6E         cmp ah, 'n'
0722   0317 C6 25 03      je _getse_LF
0723   031A 76 72         cmp ah, 'r'
0724   031C C6 2C 03      je _getse_CR
0725   031F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0726   0320 3E            mov [d], al
0727   0321 79            inc d
0728   0322 0A F8 02      jmp _getse_loop
0729   0325             _getse_LF:
0730   0325 19 0A         mov al, $0A
0731   0327 3E            mov [d], al
0732   0328 79            inc d
0733   0329 0A F8 02      jmp _getse_loop
0734   032C             _getse_CR:
0735   032C 19 0D         mov al, $0D
0736   032E 3E            mov [d], al
0737   032F 79            inc d
0738   0330 0A F8 02      jmp _getse_loop
0739   0333             _getse_end:
0740   0333 19 00         mov al, 0
0741   0335 3E            mov [d], al        ; terminate string
0742   0336 E7            pop d
0743   0337 E4            pop a
0744   0338 EE            popf
0745   0339 09            ret
0746   033A             
0747   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0748   033A             ; PRINT NEW LINE
0749   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0750   033A             put_nl:
0751   033A E1            pushf
0752   033B D7            push a
0753   033C 10 01 0A      mov a, $0A01
0754   033F 05 02         syscall bios_uart
0755   0341 10 01 0D      mov a, $0D01
0756   0344 05 02         syscall bios_uart
0757   0346 E4            pop a
0758   0347 EE            popf
0759   0348 09            ret
0760   0349             
0761   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0762   0349             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0763   0349             ; ASCII in BL
0764   0349             ; result in AL
0765   0349             ; ascii for F = 0100 0110
0766   0349             ; ascii for 9 = 0011 1001
0767   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0768   0349             hex_ascii_encode:
0769   0349 1B            mov al, bl  
0770   034A 93 40         test al, 40h        ; test if letter or number
0771   034C C7 52 03      jnz hex_letter
0772   034F 87 0F         and al, 0Fh        ; get number
0773   0351 09            ret
0774   0352             hex_letter:
0775   0352 DC            push ah
0776   0353 24            mov ah, bl
0777   0354 07 AD 03      call _to_upper
0778   0357 1A            mov al, ah  
0779   0358 87 0F         and al, 0Fh        ; get letter
0780   035A 6A 09         add al, 9
0781   035C E9            pop ah
0782   035D 09            ret
0783   035E             
0784   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0785   035E             ; ATOI
0786   035E             ; 2 letter hex string in B
0787   035E             ; 8bit integer returned in AL
0788   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0789   035E             _atoi:
0790   035E E1            pushf
0791   035F D8            push b
0792   0360                 
0793   0360 07 49 03      call hex_ascii_encode      ; convert BL to 4bit code in AL
0794   0363 30            mov bl, bh
0795   0364 DB            push al          ; save a
0796   0365 07 49 03      call hex_ascii_encode
0797   0368 EA            pop bl  
0798   0369 FD 9E 04      shl al, 4
0799   036C 8C            or al, bl
0800   036D               
0801   036D E5            pop b
0802   036E EE            popf
0803   036F 09            ret  
0804   0370             
0805   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0806   0370             ; ITOA
0807   0370             ; 8bit value in BL
0808   0370             ; 2 byte ASCII result in A
0809   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0810   0370             _itoa:
0811   0370 E1            pushf
0812   0371 DA            push d
0813   0372 DE            push bh
0814   0373 DD            push bl
0815   0374             
0816   0374 A7 00         mov bh, 0
0817   0376               
0818   0376 FD 87 0F      and bl, $0F
0819   0379 3B 8D 05      mov d, s_hex_digits
0820   037C 5A            add d, b
0821   037D 1E            mov al, [d]        ; get ASCII
0822   037E EA            pop bl
0823   037F 52 01 00      sub sp, 1        ; push bl back
0824   0382 DB            push al
0825   0383               
0826   0383 FD 87 F0      and bl, $F0
0827   0386 FD A4 04      shr bl, 4
0828   0389 3B 8D 05      mov d, s_hex_digits
0829   038C 5A            add d, b
0830   038D 1E            mov al, [d]        ; get ASCII
0831   038E             
0832   038E 23            mov ah, al
0833   038F E8            pop al  
0834   0390               
0835   0390 EA            pop bl
0836   0391 EB            pop bh
0837   0392 E7            pop d
0838   0393 EE            popf
0839   0394 09            ret
0840   0395             
0841   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0842   0395             ; STRCMP
0843   0395             ; compare two strings
0844   0395             ; str1 in SI
0845   0395             ; str2 in DI
0846   0395             ; changes: AL SI DI
0847   0395             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0848   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0849   0395             _strcmp:
0850   0395             _strcmp_loop:
0851   0395 F3            cmpsb          ; compare a byte of the strings
0852   0396 C7 A2 03      jne _strcmp_ret
0853   0399 FB FF FF      lea d, [si + -1]
0854   039C 1E            mov al, [d]
0855   039D B9 00         cmp al, 0        ; check if at end of string (null)
0856   039F C7 95 03      jne _strcmp_loop        ; equal chars but not at end
0857   03A2             _strcmp_ret:        
0858   03A2 09            ret
0859   03A3             
0860   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0861   03A3             ; TO LOWER
0862   03A3             ; input in AL
0863   03A3             ; output in AL
0864   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0865   03A3             _to_lower:
0866   03A3 E1            pushf
0867   03A4 B9 5A         cmp al, 'Z'
0868   03A6 D1 AB 03      jgu _to_lower_ret
0869   03A9 6A 20         add al, 20h        ; convert to lower case
0870   03AB             _to_lower_ret:
0871   03AB EE            popf
0872   03AC 09            ret
0873   03AD             
0874   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0875   03AD             ; TO UPPER
0876   03AD             ; input in AL
0877   03AD             ; output in AL
0878   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0879   03AD             _to_upper:
0880   03AD E1            pushf
0881   03AE B9 61         cmp al, 'a'
0882   03B0 C8 B5 03      jlu _to_upper_ret
0883   03B3 6F 20         sub al, 20h        ; convert to upper case
0884   03B5             _to_upper_ret:
0885   03B5 EE            popf
0886   03B6 09            ret
0887   03B7             
0888   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0889   03B7             ; PRINT DECIMAL INTEGER
0890   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0891   03B7             print_decimal:
0892   03B7 09            ret
0893   03B8             
0894   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0895   03B8             ; GET HEX FILE
0896   03B8             ; di = destination address
0897   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0898   03B8             load_hex:
0899   03B8 F8 00 60      enter $6000
0900   03BB               
0901   03BB 10 00 90      mov a, $9000          ; destination
0902   03BE 4F            mov di, a  
0903   03BF                         ; string data block
0904   03BF FA 01 A0      lea d, [bp + -24575]      ; start of string data block
0905   03C2 07 F5 02      call _getse          ; get program string
0906   03C5 13            mov a, d
0907   03C6 4D            mov si, a
0908   03C7             load_hex_loop:
0909   03C7 F6            lodsb          ; load from [SI] to AL
0910   03C8 B9 00         cmp al, 0        ; check if ASCII 0
0911   03CA C6 D7 03      jz load_hex_ret
0912   03CD 36            mov bh, al
0913   03CE F6            lodsb
0914   03CF 2F            mov bl, al
0915   03D0 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0916   03D3 F7            stosb          ; store AL to [DI]
0917   03D4 0A C7 03      jmp load_hex_loop
0918   03D7             load_hex_ret:
0919   03D7 F9            leave
0920   03D8 09            ret
0921   03D9             
0922   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0923   03D9             ; HEX STRING TO BINARY
0924   03D9             ; di = destination address
0925   03D9             ; si = source
0926   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0927   03D9             _hex_to_int:
0928   03D9             _hex_to_int_L1:
0929   03D9 F6            lodsb          ; load from [SI] to AL
0930   03DA B9 00         cmp al, 0        ; check if ASCII 0
0931   03DC C6 E9 03      jz _hex_to_int_ret
0932   03DF 36            mov bh, al
0933   03E0 F6            lodsb
0934   03E1 2F            mov bl, al
0935   03E2 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0936   03E5 F7            stosb          ; store AL to [DI]
0937   03E6 0A D9 03      jmp _hex_to_int_L1
0938   03E9             _hex_to_int_ret:
0939   03E9 09            ret  
0940   03EA             
0941   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0942   03EA             ; data block
0943   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0944   03EA 0A 0A 0D 53 s_welcome:      .db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0944   03EE 6F 6C 2D 31 
0944   03F2 20 37 34 48 
0944   03F6 43 20 48 6F 
0944   03FA 6D 65 62 72 
0944   03FE 65 77 43 50 
0944   0402 55 20 4D 69 
0944   0406 6E 69 43 6F 
0944   040A 6D 70 75 74 
0944   040E 65 72 0A 
0945   0411 42 49 4F 53                 .db "BIOS Version 0.1\n\n\r"
0945   0415 20 56 65 72 
0945   0419 73 69 6F 6E 
0945   041D 20 30 2E 31 
0945   0421 0A 0A 0D 
0946   0424 74 65 72 6D                 .db "terminal-1 initialized\n\r", 0
0946   0428 69 6E 61 6C 
0946   042C 2D 31 20 69 
0946   0430 6E 69 74 69 
0946   0434 61 6C 69 7A 
0946   0438 65 64 0A 0D 
0946   043C 00 
0947   043D                     
0948   043D 72 65 61 64 s_boot1:        .db "reading boot sector\n\r", 0
0948   0441 69 6E 67 20 
0948   0445 62 6F 6F 74 
0948   0449 20 73 65 63 
0948   044D 74 6F 72 0A 
0948   0451 0D 00 
0949   0453 62 6F 6F 74 s_boot2:        .db "boot-sector read\n\r", 0
0949   0457 2D 73 65 63 
0949   045B 74 6F 72 20 
0949   045F 72 65 61 64 
0949   0463 0A 0D 00 
0950   0466                     
0951   0466 72 65 73 65 s_bios3:        .db "resetting IDE-drive\n\r", 0
0951   046A 74 74 69 6E 
0951   046E 67 20 49 44 
0951   0472 45 2D 64 72 
0951   0476 69 76 65 0A 
0951   047A 0D 00 
0952   047C 63 6F 6E 66 s_bios4:        .db "configuring Timer-1\n\r", 0
0952   0480 69 67 75 72 
0952   0484 69 6E 67 20 
0952   0488 54 69 6D 65 
0952   048C 72 2D 31 0A 
0952   0490 0D 00 
0953   0492 50 49 4F 2D s_bios5:        .db "PIO-A set to output mode\n\r", 0
0953   0496 41 20 73 65 
0953   049A 74 20 74 6F 
0953   049E 20 6F 75 74 
0953   04A2 70 75 74 20 
0953   04A6 6D 6F 64 65 
0953   04AA 0A 0D 00 
0954   04AD             
0955   04AD 65 6E 74 65 s_init:         .db "entering real-mode [supervisor on; paging off]\n\r"
0955   04B1 72 69 6E 67 
0955   04B5 20 72 65 61 
0955   04B9 6C 2D 6D 6F 
0955   04BD 64 65 20 5B 
0955   04C1 73 75 70 65 
0955   04C5 72 76 69 73 
0955   04C9 6F 72 20 6F 
0955   04CD 6E 3B 20 70 
0955   04D1 61 67 69 6E 
0955   04D5 67 20 6F 66 
0955   04D9 66 5D 0A 0D 
0956   04DD 69 6E 74 65                 .db "interrupts disabled\n\r"
0956   04E1 72 72 75 70 
0956   04E5 74 73 20 64 
0956   04E9 69 73 61 62 
0956   04ED 6C 65 64 0A 
0956   04F1 0D 
0957   04F2 64 69 73 70                 .db "display register loading disabled\n\r", 0
0957   04F6 6C 61 79 20 
0957   04FA 72 65 67 69 
0957   04FE 73 74 65 72 
0957   0502 20 6C 6F 61 
0957   0506 64 69 6E 67 
0957   050A 20 64 69 73 
0957   050E 61 62 6C 65 
0957   0512 64 0A 0D 00 
0958   0516             
0959   0516 0A          s_nl_2:         .db "\n"
0960   0517 0A 0D 00    s_nl_1:         .db "\n\r", 0
0961   051A             
0962   051A 64 61 74 61 s_enter_prog:   .db "data: ", 0
0962   051E 3A 20 00 
0963   0521 6F 72 69 67 s_origin_addr:  .db "origin address: ", 0
0963   0525 69 6E 20 61 
0963   0529 64 64 72 65 
0963   052D 73 73 3A 20 
0963   0531 00 
0964   0532             
0965   0532 53 65 72 69 s_ide_serial:   .db "Serial: ", 0
0965   0536 61 6C 3A 20 
0965   053A 00 
0966   053B 46 69 72 6D s_ide_firm:     .db "Firmware: ", 0
0966   053F 77 61 72 65 
0966   0543 3A 20 00 
0967   0546 4D 6F 64 65 s_ide_model:    .db "Model: ", 0
0967   054A 6C 3A 20 00 
0968   054E 4E 75 6D 62 s_sectors:      .db "Number of sectors: ", 0
0968   0552 65 72 20 6F 
0968   0556 66 20 73 65 
0968   055A 63 74 6F 72 
0968   055E 73 3A 20 00 
0969   0562 4C 42 41 20 s_lba0:         .db "LBA 0: ", 0
0969   0566 30 3A 20 00 
0970   056A 4C 42 41 20 s_lba1:         .db "LBA 1: ", 0
0970   056E 31 3A 20 00 
0971   0572 4C 42 41 20 s_lba2:         .db "LBA 2: ", 0
0971   0576 32 3A 20 00 
0972   057A 4C 42 41 20 s_lba3:         .db "LBA 3: ", 0
0972   057E 33 3A 20 00 
0973   0582 0A 0D 45 72 s_error:        .db "\n\rError.\n\r", 0
0973   0586 72 6F 72 2E 
0973   058A 0A 0D 00 
0974   058D                             
0975   058D 30 31 32 33 s_hex_digits:   .db "0123456789ABCDEF"
0975   0591 34 35 36 37 
0975   0595 38 39 41 42 
0975   0599 43 44 45 46 
0976   059D 74 68 69 73 s_bkpt:         .db "this is the breakpoint.", 0
0976   05A1 20 69 73 20 
0976   05A5 74 68 65 20 
0976   05A9 62 72 65 61 
0976   05AD 6B 70 6F 69 
0976   05B1 6E 74 2E 00 
0977   05B5                             
0978   05B5 0A 0A 0D 73 s_priv1:        .db "\n\n\rsoftware failure: privilege exception "
0978   05B9 6F 66 74 77 
0978   05BD 61 72 65 20 
0978   05C1 66 61 69 6C 
0978   05C5 75 72 65 3A 
0978   05C9 20 70 72 69 
0978   05CD 76 69 6C 65 
0978   05D1 67 65 20 65 
0978   05D5 78 63 65 70 
0978   05D9 74 69 6F 6E 
0978   05DD 20 
0979   05DE 70 72 65 73                 .db "press any key to continue...\n\r", 0
0979   05E2 73 20 61 6E 
0979   05E6 79 20 6B 65 
0979   05EA 79 20 74 6F 
0979   05EE 20 63 6F 6E 
0979   05F2 74 69 6E 75 
0979   05F6 65 2E 2E 2E 
0979   05FA 0A 0D 00 
0980   05FD 0A 0D 65 78 s_divzero:      .db "\n\rexception: zero division\n\r", 0
0980   0601 63 65 70 74 
0980   0605 69 6F 6E 3A 
0980   0609 20 7A 65 72 
0980   060D 6F 20 64 69 
0980   0611 76 69 73 69 
0980   0615 6F 6E 0A 0D 
0980   0619 00 
0981   061A             
0982   061A             .end
tasm: Number of errors = 0
