0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 series minicomputer bios version 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; memory map
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000    rom begin
0009   0000             ; ....
0010   0000             ; 7fff    rom end
0011   0000             ;
0012   0000             ; 8000    ram begin
0013   0000             ; ....
0014   0000             ; f7ff    stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; i/o map
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; ff80    uart 0    (16550)
0020   0000             ; ff90    uart 1    (16550)
0021   0000             ; ffa0    rtc       (m48t02)
0022   0000             ; ffb0    pio 0     (8255)
0023   0000             ; ffc0    pio 1     (8255)
0024   0000             ; ffd0    ide       (compact flash / pata)
0025   0000             ; ffe0    timer     (8253)
0026   0000             ; fff0    bios configuration nv-ram store area
0027   0000             
0028   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029   0000             ; system constants / equations
0030   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031   0000             _uart0_data      .equ $ff80        		 ; data
0032   0000             _uart0_dlab_0    .equ $ff80        		 ; divisor latch low byte
0033   0000             _uart0_dlab_1    .equ $ff81        		 ; divisor latch high byte
0034   0000             _uart0_ier       .equ $ff81        		 ; interrupt enable register
0035   0000             _uart0_fcr       .equ $ff82        		 ; fifo control register
0036   0000             _uart0_lcr       .equ $ff83        		 ; line control register
0037   0000             _uart0_lsr       .equ $ff85        		 ; line status register
0038   0000             
0039   0000             _ide_base        .equ $ffd0        		 ; ide base
0040   0000             _ide_r0          .equ _ide_base + 0    ; data port
0041   0000             _ide_r1          .equ _ide_base + 1    ; read: error code, write: feature
0042   0000             _ide_r2          .equ _ide_base + 2    ; number of sectors to transfer
0043   0000             _ide_r3          .equ _ide_base + 3    ; sector address lba 0 [0:7]
0044   0000             _ide_r4          .equ _ide_base + 4    ; sector address lba 1 [8:15]
0045   0000             _ide_r5          .equ _ide_base + 5    ; sector address lba 2 [16:23]
0046   0000             _ide_r6          .equ _ide_base + 6    ; sector address lba 3 [24:27 (lsb)]
0047   0000             _ide_r7          .equ _ide_base + 7    ; read: status, write: command
0048   0000             
0049   0000             _7seg_display    .equ $ffb0        		 ; bios post code hex display (2 digits)
0050   0000             _bios_post_ctrl  .equ $ffb3        		 ; bios post display control register, 80h = as output
0051   0000             _pio_a           .equ $ffb0    
0052   0000             _pio_b           .equ $ffb1
0053   0000             _pio_c           .equ $ffb2
0054   0000             _pio_control     .equ $ffb3        		 ; pio control port
0055   0000             
0056   0000             _timer_c_0       .equ $ffe0        		 ; timer counter 0
0057   0000             _timer_c_1       .equ $ffe1        		 ; timer counter 1
0058   0000             _timer_c_2       .equ $ffe2        		 ; timer counter 2
0059   0000             _timer_ctrl      .equ $ffe3        		 ; timer control register
0060   0000             
0061   0000             _stack_begin     .equ $f7ff       		 ; beginning of stack
0062   0000             _global_base     .equ $8000       		 ; base of global variable block
0063   0000             
0064   0000             
0065   0000             boot_origin:     .equ _global_base + 2 + 2
0066   0000             
0067   0000             ide_buffer:      .equ _global_base + 2 + 2 + 512
0068   0000             
0069   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070   0000             ; global system variables
0071   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0072   0000             
0073   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0074   0000             ; external interrupt table
0075   0000             ; highest priority at lowest address
0076   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0077   0000 34 00       .dw int_0
0078   0002 35 00       .dw int_1
0079   0004 36 00       .dw int_2
0080   0006 37 00       .dw int_3
0081   0008 38 00       .dw int_4
0082   000A 39 00       .dw int_5
0083   000C 3A 00       .dw int_6
0084   000E 3B 00       .dw int_7
0085   0010             
0086   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0087   0010             ; reset vector declaration
0088   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0089   0010 C0 01       .dw bios_reset_vector
0090   0012             
0091   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0092   0012             ;; exception vector table
0093   0012             ;; total of 7 entries, starting at address $0012
0094   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095   0012 3C 00       .dw trap_privilege  
0096   0014 52 00       .dw trap_div_zero  
0097   0016 5F 00       .dw undefined_opcode
0098   0018 00 00       .dw 0
0099   001A 00 00       .dw 0
0100   001C 00 00       .dw 0
0101   001E 00 00       .dw 0
0102   0020             
0103   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0104   0020             ;; system call vector table
0105   0020             ;; starts at address $0020
0106   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0107   0020 45 00       .dw trap_breakpoint
0108   0022 60 00       .dw rtc_services        
0109   0024 96 00       .dw uart_services        
0110   0026 EE 00       .dw ide_services  
0111   0028 00 00       .dw 0
0112   002A 00 00       .dw 0
0113   002C 00 00       .dw 0
0114   002E 00 00       .dw 0
0115   0030 00 00       .dw 0
0116   0032 00 00       .dw 0  
0117   0034             
0118   0034             bios_bkpt  .equ 0
0119   0034             bios_rtc   .equ 1
0120   0034             bios_uart  .equ 2
0121   0034             bios_ide   .equ 3
0122   0034             
0123   0034             .export bios_reset_vector
0124   0034             .export ide_buffer
0125   0034             .export boot_origin
0126   0034             .export bios_uart
0127   0034             .export bios_ide
0128   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129   0034             ; external interrupts' code block
0130   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0131   0034             int_0:
0132   0034 06            sysret
0133   0035             int_1:
0134   0035 06            sysret
0135   0036             int_2:
0136   0036 06            sysret
0137   0037             int_3:
0138   0037 06            sysret
0139   0038             int_4:
0140   0038 06            sysret
0141   0039             int_5:
0142   0039 06            sysret
0143   003A             int_6:  
0144   003A 06            sysret
0145   003B             int_7:
0146   003B 06            sysret
0147   003C             
0148   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0149   003C             ; exceptions
0150   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0151   003C             
0152   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0153   003C             ; privilege exception
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             trap_privilege:
0156   003C DA            push d
0157   003D             
0158   003D 3B B5 05      mov d, s_priv1
0159   0040 07 82 02      call _puts
0160   0043             
0161   0043 E7            pop d
0162   0044                           ; enable interrupts
0163   0044 06            sysret
0164   0045             
0165   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0166   0045             ; breakpoint exception
0167   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0168   0045             trap_breakpoint:
0169   0045 D7            push a
0170   0046 DA            push d
0171   0047 E1            pushf
0172   0048               
0173   0048 3B 9D 05      mov d, s_bkpt
0174   004B 07 82 02      call _puts
0175   004E               
0176   004E EE            popf
0177   004F E7            pop d
0178   0050 E4            pop a
0179   0051                           ; enable interrupts
0180   0051 06            sysret
0181   0052             
0182   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0183   0052             ; divide by zero exception
0184   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0185   0052             trap_div_zero:
0186   0052 D7            push a
0187   0053 DA            push d
0188   0054 E1            pushf
0189   0055               
0190   0055 3B FD 05      mov d, s_divzero
0191   0058 07 82 02      call _puts
0192   005B               
0193   005B EE            popf
0194   005C E7            pop d
0195   005D E4            pop a
0196   005E                           ; enable interrupts
0197   005E 06            sysret
0198   005F             
0199   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0200   005F             ; undefined opcode exception
0201   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0202   005F             undefined_opcode:
0203   005F 06            sysret
0204   0060               
0205   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0206   0060             ; rtc services interrupt
0207   0060             ; rtc i/o bank = ffa0 to ffaf
0208   0060             ; ffa0 to ffa7 is scratch ram
0209   0060             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0210   0060             ; al = 0..6 -> get
0211   0060             ; al = 7..d -> set
0212   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0213   0060             rtc_services:
0214   0060 DB            push al
0215   0061 DA            push d
0216   0062 B9 06         cmp al, 6
0217   0064 D1 79 00      jgu rtc_set
0218   0067             rtc_get:
0219   0067 6A A9         add al, $a9      ; generate rtc address to get to address a9 of clock
0220   0069 22 FF         mov ah, $ff    
0221   006B 3C            mov d, a        ; get to ffa9 + offset
0222   006C F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0223   0070 1E            mov al, [d]      ; get data
0224   0071 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset r bit
0225   0075 23            mov ah, al
0226   0076 E7            pop d
0227   0077 E8            pop al
0228   0078 06            sysret
0229   0079             rtc_set:
0230   0079 DD            push bl
0231   007A 99            mov bl, ah    ; set data aside
0232   007B 6A A2         add al, $a2    ; generate rtc address to get to address a9 of clock
0233   007D 22 FF         mov ah, $ff    
0234   007F 3C            mov d, a    ; get to ffa9 + offset
0235   0080 1B            mov al, bl    ; get data back
0236   0081 F2 A8 FF 80   mov byte[$ffa8], $80  ; set w bit to 1
0237   0085 3E            mov [d], al    ; set data
0238   0086 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset write bit
0239   008A EA            pop bl
0240   008B E7            pop d
0241   008C E8            pop al
0242   008D 06            sysret
0243   008E             
0244   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0245   008E             ; int 4
0246   008E             ; uart services interrupt
0247   008E             ; al = option
0248   008E             ; ah = data
0249   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0250   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0251   008E             uart_serv_tbl:
0252   008E 9A 00         .dw uart_init
0253   0090 B3 00         .dw uart_send
0254   0092 C0 00         .dw uart_receive
0255   0094 CD 00         .dw uart_receive_e
0256   0096             uart_services:
0257   0096 FD 0A 8E 00   jmp [uart_serv_tbl + al]
0258   009A             uart_init:
0259   009A F2 83 FF 83   mov byte[_uart0_lcr], 83h      ; 8 data, 1 stop, no parity  , divisor latch = 1, uart address 3 = line control register
0260   009E F2 80 FF 0C   mov byte[_uart0_dlab_0], 12      ; baud = 9600
0261   00A2 F2 81 FF 00   mov byte[_uart0_dlab_1], 0      ; divisor latch high byte = 0      
0262   00A6 F2 83 FF 03   mov byte[_uart0_lcr], 3      ; divisor latch = 0, uart address 3 = line control register
0263   00AA F2 81 FF 00   mov byte[_uart0_ier], 0      ; disable all uart interrupts
0264   00AE F2 82 FF 00   mov byte[_uart0_fcr], 0      ; disable fifo
0265   00B2 06            sysret
0266   00B3             uart_send:
0267   00B3 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0268   00B6 93 20         test al, 20h          ; isolate transmitter empty
0269   00B8 C6 B3 00      jz uart_send    
0270   00BB 1A            mov al, ah
0271   00BC 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0272   00BF 06            sysret
0273   00C0             uart_receive:
0274   00C0 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0275   00C3 93 01         test al, 1          ; isolate data ready
0276   00C5 C6 C0 00      jz uart_receive
0277   00C8 1D 80 FF      mov al, [_uart0_data]      ; get character
0278   00CB 23            mov ah, al
0279   00CC 06            sysret
0280   00CD             uart_receive_e:
0281   00CD 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0282   00D0 93 01         test al, 1          ; isolate data ready
0283   00D2 C6 CD 00      jz uart_receive_e
0284   00D5 1D 80 FF      mov al, [_uart0_data]      ; get character
0285   00D8 23            mov ah, al
0286   00D9             uart_receive_e_loop:
0287   00D9 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0288   00DC 93 20         test al, 20h          ; isolate transmitter empty
0289   00DE C6 D9 00      jz uart_receive_e_loop
0290   00E1 1A            mov al, ah
0291   00E2 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0292   00E5 06            sysret
0293   00E6               
0294   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295   00E6             ; ide services interrupt
0296   00E6             ; al = option
0297   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0298   00E6             ; ide read/write sector
0299   00E6             ; 512 bytes
0300   00E6             ; user buffer pointer in d
0301   00E6             ; kernel buffer pointer = ide_buffer
0302   00E6             ; ah = number of sectors
0303   00E6             ; cb = lba bytes 3..0
0304   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0305   00E6             ide_serv_tbl:
0306   00E6 F2 00         .dw ide_reset
0307   00E8 06 01         .dw ide_sleep
0308   00EA 15 01         .dw ide_read_sect
0309   00EC 36 01         .dw ide_write_sect
0310   00EE             ide_services:
0311   00EE FD 0A E6 00   jmp [ide_serv_tbl + al]  
0312   00F2             ide_reset:      
0313   00F2 F2 D7 FF 04   mov byte[_ide_r7], 4    ; reset ide
0314   00F6 07 87 01      call ide_wait        ; wait for ide ready             
0315   00F9 F2 D6 FF E0   mov byte[_ide_r6], $e0    ; lba3= 0, master, mode= lba        
0316   00FD F2 D1 FF 01   mov byte[_ide_r1], 1    ; 8-bit transfers      
0317   0101 F2 D7 FF EF   mov byte[_ide_r7], $ef    ; set feature command
0318   0105 06            sysret
0319   0106             ide_sleep:
0320   0106 07 87 01      call ide_wait          ; wait for ide ready             
0321   0109 F2 D6 FF 40   mov byte [_ide_r6], %01000000  ; lba[3:0](reserved), bit 6=1
0322   010D F2 D7 FF E6   mov byte [_ide_r7], $e6    ; sleep command
0323   0111 07 87 01      call ide_wait          ; wait for ide ready
0324   0114 06            sysret
0325   0115             ide_read_sect:
0326   0115 1A            mov al, ah
0327   0116 24            mov ah, bl
0328   0117 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0329   011A 1C            mov al, bh
0330   011B 3D D4 FF      mov [_ide_r4], al
0331   011E 12            mov a, c
0332   011F 3D D5 FF      mov [_ide_r5], al
0333   0122 1A            mov al, ah
0334   0123 87 0F         and al, %00001111
0335   0125 8B E0         or al, %11100000      ; mode lba, master
0336   0127 3D D6 FF      mov [_ide_r6], al
0337   012A 07 87 01      call ide_wait
0338   012D 19 20         mov al, 20h
0339   012F 3D D7 FF      mov [_ide_r7], al      ; read sector cmd
0340   0132 07 57 01      call ide_read  
0341   0135 06            sysret
0342   0136             ide_write_sect:
0343   0136 1A            mov al, ah
0344   0137 24            mov ah, bl
0345   0138 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0346   013B 1C            mov al, bh
0347   013C 3D D4 FF      mov [_ide_r4], al
0348   013F 12            mov a, c
0349   0140 3D D5 FF      mov [_ide_r5], al
0350   0143 1A            mov al, ah
0351   0144 87 0F         and al, %00001111
0352   0146 8B E0         or al, %11100000      ; mode lba, master
0353   0148 3D D6 FF      mov [_ide_r6], al
0354   014B 07 87 01      call ide_wait
0355   014E 19 30         mov al, 30h
0356   0150 3D D7 FF      mov [_ide_r7], al      ; write sector cmd
0357   0153 07 6F 01      call ide_write      
0358   0156 06            sysret
0359   0157             
0360   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0361   0157             ; read ide data
0362   0157             ; pointer in d
0363   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0364   0157             ide_read:
0365   0157 DB            push al
0366   0158 DA            push d
0367   0159             ide_read_loop:
0368   0159 07 87 01      call ide_wait
0369   015C 1D D7 FF      mov al, [_ide_r7]
0370   015F 87 08         and al, %00001000      ; drq flag
0371   0161 C6 6C 01      jz ide_read_end
0372   0164 1D D0 FF      mov al, [_ide_r0]
0373   0167 3E            mov [d], al
0374   0168 79            inc d
0375   0169 0A 59 01      jmp ide_read_loop
0376   016C             ide_read_end:
0377   016C E7            pop d
0378   016D E8            pop al
0379   016E 09            ret
0380   016F             
0381   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0382   016F             ; write ide data
0383   016F             ; data pointer in d
0384   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0385   016F             ide_write:
0386   016F DB            push al
0387   0170 DA            push d
0388   0171             ide_write_loop:
0389   0171 07 87 01      call ide_wait
0390   0174 1D D7 FF      mov al, [_ide_r7]
0391   0177 87 08         and al, %00001000      ; drq flag
0392   0179 C6 84 01      jz ide_write_end
0393   017C 1E            mov al, [d]
0394   017D 3D D0 FF      mov [_ide_r0], al
0395   0180 79            inc d 
0396   0181 0A 71 01      jmp ide_write_loop
0397   0184             ide_write_end:
0398   0184 E7            pop d
0399   0185 E8            pop al
0400   0186 09            ret
0401   0187             
0402   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403   0187             ; wait for ide to be ready
0404   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0405   0187             ide_wait:
0406   0187 1D D7 FF      mov al, [_ide_r7]  
0407   018A 87 80         and al, 80h        ; busy flag
0408   018C C7 87 01      jnz ide_wait
0409   018F 09            ret
0410   0190             
0411   0190             ; ************************************************************
0412   0190             ; get hex file
0413   0190             ; di = destination address
0414   0190             ; return length in bytes in c
0415   0190             ; ************************************************************
0416   0190             _load_hex:
0417   0190 D2            push bp
0418   0191 9B            mov bp, sp
0419   0192 D7            push a
0420   0193 D8            push b
0421   0194 DA            push d
0422   0195 E2            push si
0423   0196 E3            push di
0424   0197 52 00 60      sub sp, $6000        ; string data block
0425   019A 38 00 00      mov c, 0
0426   019D               
0427   019D 48            mov a, sp
0428   019E 77            inc a
0429   019F 3C            mov d, a        ; start of string data block
0430   01A0 07 F5 02      call _getse        ; get program string
0431   01A3 4D            mov si, a
0432   01A4             
0433   01A4             __load_hex_loop:
0434   01A4 F6            lodsb          ; load from [SI] to AL
0435   01A5 B9 00         cmp al, 0        ; check if ASCII 0
0436   01A7 C6 B5 01      jz __load_hex_ret
0437   01AA 36            mov bh, al
0438   01AB F6            lodsb
0439   01AC 2F            mov bl, al
0440   01AD 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0441   01B0 F7            stosb          ; store AL to [DI]
0442   01B1 78            inc c
0443   01B2 0A A4 01      jmp __load_hex_loop
0444   01B5             __load_hex_ret:
0445   01B5 51 00 60      add sp, $6000
0446   01B8 F0            pop di
0447   01B9 EF            pop si
0448   01BA E7            pop d
0449   01BB E5            pop b
0450   01BC E4            pop a
0451   01BD 9C            mov sp, bp
0452   01BE F1            pop bp
0453   01BF 09            ret
0454   01C0               
0455   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0456   01C0             ; bios entry point
0457   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0458   01C0             bios_reset_vector:
0459   01C0 19 00         mov al, %00000000        ; interrupts = off, mode = sup, paging = off, halt-flag = off, display_load = on
0460   01C2 0D            stostat
0461   01C3               
0462   01C3 10 FF F7      mov a, _stack_begin
0463   01C6 47            mov sp, a
0464   01C7 49            mov bp, a      ; setup stack and frame
0465   01C8             
0466   01C8 19 00         mov al, 0
0467   01CA 05 02         syscall bios_uart
0468   01CC               
0469   01CC 3B EA 03      mov d, s_welcome
0470   01CF 07 82 02      call _puts          ; print welcome msg
0471   01D2             
0472   01D2 07 F2 01      call bios_peripherals_setup
0473   01D5               
0474   01D5 3B 3D 04      mov d, s_boot1
0475   01D8 07 82 02      call _puts
0476   01DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0477   01DB 38 00 00      mov c, 0
0478   01DE 26 00 00      mov b, 0          ; start at disk sector 0
0479   01E1 3B 04 80      mov d, boot_origin    ; we read into the bios ide buffer
0480   01E4 10 02 01      mov a, $0102        ; disk read, 1 sector
0481   01E7 05 03         syscall bios_ide      ; read sector  
0482   01E9               
0483   01E9 3B 53 04      mov d, s_boot2
0484   01EC 07 82 02      call _puts
0485   01EF             
0486   01EF 0A 04 80      jmp boot_origin
0487   01F2             
0488   01F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0489   01F2             
0490   01F2             bios_peripherals_setup:
0491   01F2 3B AD 04      mov d, s_init
0492   01F5 07 82 02      call _puts
0493   01F8               
0494   01F8 3B 66 04      mov d, s_bios3
0495   01FB 07 82 02      call _puts
0496   01FE 19 00         mov al, 0            ; reset ide
0497   0200 05 03         syscall bios_ide  
0498   0202               
0499   0202 3B 7C 04      mov d, s_bios4
0500   0205 07 82 02      call _puts
0501   0208               
0502   0208 19 30         mov al, %00110000          ; counter 0, load both bytes, mode 0, binary
0503   020A 3D E3 FF      mov [_timer_ctrl], al
0504   020D 19 FF         mov al, $ff
0505   020F 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 low byte
0506   0212 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 high byte
0507   0215               
0508   0215 3B 92 04      mov d, s_bios5
0509   0218 07 82 02      call _puts
0510   021B 19 80         mov al, $80
0511   021D 3D B3 FF      mov [_bios_post_ctrl], al      ; set pio_a to output mode
0512   0220 19 00         mov al, 0
0513   0222 3D B0 FF      mov [_7seg_display], al      ; post code = 00
0514   0225 09            ret
0515   0226             
0516   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0517   0226             ; print 16bit hex integer
0518   0226             ; integer value in reg b
0519   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0520   0226             print_u16x:
0521   0226 E1            pushf
0522   0227 D7            push a
0523   0228 D8            push b
0524   0229 DD            push bl
0525   022A 30            mov bl, bh
0526   022B 07 70 03      call _itoa        ; convert bh to char in a
0527   022E 2F            mov bl, al        ; save al  
0528   022F 19 01         mov al, 1
0529   0231 05 02         syscall bios_uart        ; display ah
0530   0233 24            mov ah, bl        ; retrieve al
0531   0234 19 01         mov al, 1
0532   0236 05 02         syscall bios_uart        ; display al
0533   0238             
0534   0238 EA            pop bl
0535   0239 07 70 03      call _itoa        ; convert bh to char in a
0536   023C 2F            mov bl, al        ; save al
0537   023D 19 01         mov al, 1
0538   023F 05 02         syscall bios_uart        ; display ah
0539   0241 24            mov ah, bl        ; retrieve al
0540   0242 19 01         mov al, 1
0541   0244 05 02         syscall bios_uart        ; display al
0542   0246             
0543   0246 E5            pop b
0544   0247 E4            pop a
0545   0248 EE            popf
0546   0249 09            ret
0547   024A             
0548   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0549   024A             ; input 16bit hex integer
0550   024A             ; read 16bit integer into a
0551   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0552   024A             scan_u16x:
0553   024A F8 10 00      enter 16
0554   024D E1            pushf
0555   024E D8            push b
0556   024F DA            push d
0557   0250             
0558   0250 FA F1 FF      lea d, [bp + -15]
0559   0253 07 F5 02      call _getse        ; get number
0560   0256             
0561   0256 32            mov bl, [d]
0562   0257 37            mov bh, bl
0563   0258 33 01 00      mov bl, [d + 1]
0564   025B 07 5E 03      call _atoi        ; convert to int in al
0565   025E 23            mov ah, al        ; move to ah
0566   025F               
0567   025F 33 02 00      mov bl, [d + 2]
0568   0262 37            mov bh, bl
0569   0263 33 03 00      mov bl, [d + 3]
0570   0266 07 5E 03      call _atoi        ; convert to int in al
0571   0269               
0572   0269 E7            pop d  
0573   026A E5            pop b
0574   026B EE            popf
0575   026C F9            leave
0576   026D 09            ret
0577   026E             
0578   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0579   026E             ; print 8bit hex integer
0580   026E             ; byte value in reg bl
0581   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0582   026E             xput_u8:
0583   026E D7            push a
0584   026F DD            push bl
0585   0270 E1            pushf
0586   0271             
0587   0271 07 70 03      call _itoa          ; convert bl to char in a
0588   0274 2F            mov bl, al          ; save al  
0589   0275 19 01         mov al, 1
0590   0277 05 02         syscall bios_uart        ; display ah
0591   0279 24            mov ah, bl          ; retrieve al
0592   027A 19 01         mov al, 1
0593   027C 05 02         syscall bios_uart        ; display al
0594   027E               
0595   027E EE            popf
0596   027F EA            pop bl
0597   0280 E4            pop a
0598   0281 09            ret
0599   0282             
0600   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0601   0282             ; print null terminated string
0602   0282             ; pointer in d
0603   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0604   0282             _puts:
0605   0282 D7            push a
0606   0283 DA            push d
0607   0284 E1            pushf
0608   0285             _puts_l1:
0609   0285 1E            mov al, [d]
0610   0286 B9 00         cmp al, 0
0611   0288 C6 9B 02      jz _puts_end
0612   028B             _puts_l2:
0613   028B 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0614   028E 93 20         test al, $20          ; isolate transmitter empty
0615   0290 C6 8B 02      jz _puts_l2    
0616   0293 1E            mov al, [d]
0617   0294 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0618   0297 79            inc d  
0619   0298 0A 85 02      jmp _puts_l1
0620   029B             _puts_end:
0621   029B EE            popf
0622   029C E7            pop d
0623   029D E4            pop a
0624   029E 09            ret
0625   029F             
0626   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0627   029F             ; _putchar
0628   029F             ; char in ah
0629   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0630   029F             _putchar:
0631   029F D7            push a
0632   02A0 E1            pushf
0633   02A1             _putchar_l1:
0634   02A1 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0635   02A4 93 20         test al, 20h          ; isolate transmitter empty
0636   02A6 C6 A1 02      jz _putchar_l1    
0637   02A9 1A            mov al, ah
0638   02AA 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0639   02AD EE            popf
0640   02AE E4            pop a
0641   02AF 09            ret
0642   02B0               
0643   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0644   02B0             ;; input a string with no echo
0645   02B0             ;; terminates with null
0646   02B0             ;; pointer in d
0647   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0648   02B0             _gets:
0649   02B0 E1            pushf
0650   02B1 D7            push a
0651   02B2 DA            push d
0652   02B3             _gets_loop:
0653   02B3 19 02         mov al, 2
0654   02B5 05 02         syscall bios_uart      ; receive in ah
0655   02B7 76 0A         cmp ah, 0ah        ; lf
0656   02B9 C6 EE 02      je _gets_end
0657   02BC 76 0D         cmp ah, 0dh        ; cr
0658   02BE C6 EE 02      je _gets_end
0659   02C1 76 5C         cmp ah, $5c        ; '\\'
0660   02C3 C6 CC 02      je _gets_escape
0661   02C6 1A            mov al, ah
0662   02C7 3E            mov [d], al
0663   02C8 79            inc d
0664   02C9 0A B3 02      jmp _gets_loop
0665   02CC             _gets_escape:
0666   02CC 19 02         mov al, 2
0667   02CE 05 02         syscall bios_uart      ; receive in ah
0668   02D0 76 6E         cmp ah, 'n'
0669   02D2 C6 E0 02      je _gets_lf
0670   02D5 76 72         cmp ah, 'r'
0671   02D7 C6 E7 02      je _gets_cr
0672   02DA 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0673   02DB 3E            mov [d], al
0674   02DC 79            inc d
0675   02DD 0A B3 02      jmp _gets_loop
0676   02E0             _gets_lf:
0677   02E0 19 0A         mov al, $0a
0678   02E2 3E            mov [d], al
0679   02E3 79            inc d
0680   02E4 0A B3 02      jmp _gets_loop
0681   02E7             _gets_cr:
0682   02E7 19 0D         mov al, $0d
0683   02E9 3E            mov [d], al
0684   02EA 79            inc d
0685   02EB 0A B3 02      jmp _gets_loop
0686   02EE             _gets_end:
0687   02EE 19 00         mov al, 0
0688   02F0 3E            mov [d], al        ; terminate string
0689   02F1 E7            pop d
0690   02F2 E4            pop a
0691   02F3 EE            popf
0692   02F4 09            ret
0693   02F5             
0694   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0695   02F5             ;; INPUT A STRING with echo
0696   02F5             ;; terminates with null
0697   02F5             ;; pointer in D
0698   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0699   02F5             _getse:
0700   02F5 E1            pushf
0701   02F6 D7            push a
0702   02F7 DA            push d
0703   02F8             _getse_loop:
0704   02F8 19 03         mov al, 3
0705   02FA 05 02         syscall bios_uart      ; receive in AH
0706   02FC 76 0A         cmp ah, 0Ah        ; LF
0707   02FE C6 33 03      je _getse_end
0708   0301 76 0D         cmp ah, 0Dh        ; CR
0709   0303 C6 33 03      je _getse_end
0710   0306 76 5C         cmp ah, $5C        ; '\\'
0711   0308 C6 11 03      je _getse_escape
0712   030B 1A            mov al, ah
0713   030C 3E            mov [d], al
0714   030D 79            inc d
0715   030E 0A F8 02      jmp _getse_loop
0716   0311             _getse_escape:
0717   0311 19 03         mov al, 3
0718   0313 05 02         syscall bios_uart      ; receive in AH
0719   0315 76 6E         cmp ah, 'n'
0720   0317 C6 25 03      je _getse_LF
0721   031A 76 72         cmp ah, 'r'
0722   031C C6 2C 03      je _getse_CR
0723   031F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0724   0320 3E            mov [d], al
0725   0321 79            inc d
0726   0322 0A F8 02      jmp _getse_loop
0727   0325             _getse_LF:
0728   0325 19 0A         mov al, $0A
0729   0327 3E            mov [d], al
0730   0328 79            inc d
0731   0329 0A F8 02      jmp _getse_loop
0732   032C             _getse_CR:
0733   032C 19 0D         mov al, $0D
0734   032E 3E            mov [d], al
0735   032F 79            inc d
0736   0330 0A F8 02      jmp _getse_loop
0737   0333             _getse_end:
0738   0333 19 00         mov al, 0
0739   0335 3E            mov [d], al        ; terminate string
0740   0336 E7            pop d
0741   0337 E4            pop a
0742   0338 EE            popf
0743   0339 09            ret
0744   033A             
0745   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0746   033A             ; PRINT NEW LINE
0747   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0748   033A             put_nl:
0749   033A E1            pushf
0750   033B D7            push a
0751   033C 10 01 0A      mov a, $0A01
0752   033F 05 02         syscall bios_uart
0753   0341 10 01 0D      mov a, $0D01
0754   0344 05 02         syscall bios_uart
0755   0346 E4            pop a
0756   0347 EE            popf
0757   0348 09            ret
0758   0349             
0759   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0760   0349             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0761   0349             ; ASCII in BL
0762   0349             ; result in AL
0763   0349             ; ascii for F = 0100 0110
0764   0349             ; ascii for 9 = 0011 1001
0765   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0766   0349             hex_ascii_encode:
0767   0349 1B            mov al, bl  
0768   034A 93 40         test al, 40h        ; test if letter or number
0769   034C C7 52 03      jnz hex_letter
0770   034F 87 0F         and al, 0Fh        ; get number
0771   0351 09            ret
0772   0352             hex_letter:
0773   0352 DC            push ah
0774   0353 24            mov ah, bl
0775   0354 07 AD 03      call _to_upper
0776   0357 1A            mov al, ah  
0777   0358 87 0F         and al, 0Fh        ; get letter
0778   035A 6A 09         add al, 9
0779   035C E9            pop ah
0780   035D 09            ret
0781   035E             
0782   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0783   035E             ; ATOI
0784   035E             ; 2 letter hex string in B
0785   035E             ; 8bit integer returned in AL
0786   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0787   035E             _atoi:
0788   035E E1            pushf
0789   035F D8            push b
0790   0360                 
0791   0360 07 49 03      call hex_ascii_encode      ; convert BL to 4bit code in AL
0792   0363 30            mov bl, bh
0793   0364 DB            push al          ; save a
0794   0365 07 49 03      call hex_ascii_encode
0795   0368 EA            pop bl  
0796   0369 FD 9E 04      shl al, 4
0797   036C 8C            or al, bl
0798   036D               
0799   036D E5            pop b
0800   036E EE            popf
0801   036F 09            ret  
0802   0370             
0803   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0804   0370             ; ITOA
0805   0370             ; 8bit value in BL
0806   0370             ; 2 byte ASCII result in A
0807   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0808   0370             _itoa:
0809   0370 E1            pushf
0810   0371 DA            push d
0811   0372 DE            push bh
0812   0373 DD            push bl
0813   0374             
0814   0374 A7 00         mov bh, 0
0815   0376               
0816   0376 FD 87 0F      and bl, $0F
0817   0379 3B 8D 05      mov d, s_hex_digits
0818   037C 5A            add d, b
0819   037D 1E            mov al, [d]        ; get ASCII
0820   037E EA            pop bl
0821   037F 52 01 00      sub sp, 1        ; push bl back
0822   0382 DB            push al
0823   0383               
0824   0383 FD 87 F0      and bl, $F0
0825   0386 FD A4 04      shr bl, 4
0826   0389 3B 8D 05      mov d, s_hex_digits
0827   038C 5A            add d, b
0828   038D 1E            mov al, [d]        ; get ASCII
0829   038E             
0830   038E 23            mov ah, al
0831   038F E8            pop al  
0832   0390               
0833   0390 EA            pop bl
0834   0391 EB            pop bh
0835   0392 E7            pop d
0836   0393 EE            popf
0837   0394 09            ret
0838   0395             
0839   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0840   0395             ; STRCMP
0841   0395             ; compare two strings
0842   0395             ; str1 in SI
0843   0395             ; str2 in DI
0844   0395             ; changes: AL SI DI
0845   0395             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0846   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0847   0395             _strcmp:
0848   0395             _strcmp_loop:
0849   0395 F3            cmpsb          ; compare a byte of the strings
0850   0396 C7 A2 03      jne _strcmp_ret
0851   0399 FB FF FF      lea d, [si + -1]
0852   039C 1E            mov al, [d]
0853   039D B9 00         cmp al, 0        ; check if at end of string (null)
0854   039F C7 95 03      jne _strcmp_loop        ; equal chars but not at end
0855   03A2             _strcmp_ret:        
0856   03A2 09            ret
0857   03A3             
0858   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0859   03A3             ; TO LOWER
0860   03A3             ; input in AL
0861   03A3             ; output in AL
0862   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0863   03A3             _to_lower:
0864   03A3 E1            pushf
0865   03A4 B9 5A         cmp al, 'Z'
0866   03A6 D1 AB 03      jgu _to_lower_ret
0867   03A9 6A 20         add al, 20h        ; convert to lower case
0868   03AB             _to_lower_ret:
0869   03AB EE            popf
0870   03AC 09            ret
0871   03AD             
0872   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0873   03AD             ; TO UPPER
0874   03AD             ; input in AL
0875   03AD             ; output in AL
0876   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0877   03AD             _to_upper:
0878   03AD E1            pushf
0879   03AE B9 61         cmp al, 'a'
0880   03B0 C8 B5 03      jlu _to_upper_ret
0881   03B3 6F 20         sub al, 20h        ; convert to upper case
0882   03B5             _to_upper_ret:
0883   03B5 EE            popf
0884   03B6 09            ret
0885   03B7             
0886   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0887   03B7             ; PRINT DECIMAL INTEGER
0888   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0889   03B7             print_decimal:
0890   03B7 09            ret
0891   03B8             
0892   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0893   03B8             ; GET HEX FILE
0894   03B8             ; di = destination address
0895   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0896   03B8             load_hex:
0897   03B8 F8 00 60      enter $6000
0898   03BB               
0899   03BB 10 00 90      mov a, $9000          ; destination
0900   03BE 4F            mov di, a  
0901   03BF                         ; string data block
0902   03BF FA 01 A0      lea d, [bp + -24575]      ; start of string data block
0903   03C2 07 F5 02      call _getse          ; get program string
0904   03C5 13            mov a, d
0905   03C6 4D            mov si, a
0906   03C7             load_hex_loop:
0907   03C7 F6            lodsb          ; load from [SI] to AL
0908   03C8 B9 00         cmp al, 0        ; check if ASCII 0
0909   03CA C6 D7 03      jz load_hex_ret
0910   03CD 36            mov bh, al
0911   03CE F6            lodsb
0912   03CF 2F            mov bl, al
0913   03D0 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0914   03D3 F7            stosb          ; store AL to [DI]
0915   03D4 0A C7 03      jmp load_hex_loop
0916   03D7             load_hex_ret:
0917   03D7 F9            leave
0918   03D8 09            ret
0919   03D9             
0920   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0921   03D9             ; HEX STRING TO BINARY
0922   03D9             ; di = destination address
0923   03D9             ; si = source
0924   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0925   03D9             _hex_to_int:
0926   03D9             _hex_to_int_L1:
0927   03D9 F6            lodsb          ; load from [SI] to AL
0928   03DA B9 00         cmp al, 0        ; check if ASCII 0
0929   03DC C6 E9 03      jz _hex_to_int_ret
0930   03DF 36            mov bh, al
0931   03E0 F6            lodsb
0932   03E1 2F            mov bl, al
0933   03E2 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0934   03E5 F7            stosb          ; store AL to [DI]
0935   03E6 0A D9 03      jmp _hex_to_int_L1
0936   03E9             _hex_to_int_ret:
0937   03E9 09            ret  
0938   03EA             
0939   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0940   03EA             ; data block
0941   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0942   03EA 0A 0A 0D 53 s_welcome:      .db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0942   03EE 6F 6C 2D 31 
0942   03F2 20 37 34 48 
0942   03F6 43 20 48 6F 
0942   03FA 6D 65 62 72 
0942   03FE 65 77 43 50 
0942   0402 55 20 4D 69 
0942   0406 6E 69 43 6F 
0942   040A 6D 70 75 74 
0942   040E 65 72 0A 
0943   0411 42 49 4F 53                 .db "BIOS Version 0.1\n\n\r"
0943   0415 20 56 65 72 
0943   0419 73 69 6F 6E 
0943   041D 20 30 2E 31 
0943   0421 0A 0A 0D 
0944   0424 74 65 72 6D                 .db "terminal-1 initialized\n\r", 0
0944   0428 69 6E 61 6C 
0944   042C 2D 31 20 69 
0944   0430 6E 69 74 69 
0944   0434 61 6C 69 7A 
0944   0438 65 64 0A 0D 
0944   043C 00 
0945   043D                     
0946   043D 72 65 61 64 s_boot1:        .db "reading boot sector\n\r", 0
0946   0441 69 6E 67 20 
0946   0445 62 6F 6F 74 
0946   0449 20 73 65 63 
0946   044D 74 6F 72 0A 
0946   0451 0D 00 
0947   0453 62 6F 6F 74 s_boot2:        .db "boot-sector read\n\r", 0
0947   0457 2D 73 65 63 
0947   045B 74 6F 72 20 
0947   045F 72 65 61 64 
0947   0463 0A 0D 00 
0948   0466                     
0949   0466 72 65 73 65 s_bios3:        .db "resetting IDE-drive\n\r", 0
0949   046A 74 74 69 6E 
0949   046E 67 20 49 44 
0949   0472 45 2D 64 72 
0949   0476 69 76 65 0A 
0949   047A 0D 00 
0950   047C 63 6F 6E 66 s_bios4:        .db "configuring Timer-1\n\r", 0
0950   0480 69 67 75 72 
0950   0484 69 6E 67 20 
0950   0488 54 69 6D 65 
0950   048C 72 2D 31 0A 
0950   0490 0D 00 
0951   0492 50 49 4F 2D s_bios5:        .db "PIO-A set to output mode\n\r", 0
0951   0496 41 20 73 65 
0951   049A 74 20 74 6F 
0951   049E 20 6F 75 74 
0951   04A2 70 75 74 20 
0951   04A6 6D 6F 64 65 
0951   04AA 0A 0D 00 
0952   04AD             
0953   04AD 65 6E 74 65 s_init:         .db "entering real-mode [supervisor on; paging off]\n\r"
0953   04B1 72 69 6E 67 
0953   04B5 20 72 65 61 
0953   04B9 6C 2D 6D 6F 
0953   04BD 64 65 20 5B 
0953   04C1 73 75 70 65 
0953   04C5 72 76 69 73 
0953   04C9 6F 72 20 6F 
0953   04CD 6E 3B 20 70 
0953   04D1 61 67 69 6E 
0953   04D5 67 20 6F 66 
0953   04D9 66 5D 0A 0D 
0954   04DD 69 6E 74 65                 .db "interrupts disabled\n\r"
0954   04E1 72 72 75 70 
0954   04E5 74 73 20 64 
0954   04E9 69 73 61 62 
0954   04ED 6C 65 64 0A 
0954   04F1 0D 
0955   04F2 64 69 73 70                 .db "display register loading disabled\n\r", 0
0955   04F6 6C 61 79 20 
0955   04FA 72 65 67 69 
0955   04FE 73 74 65 72 
0955   0502 20 6C 6F 61 
0955   0506 64 69 6E 67 
0955   050A 20 64 69 73 
0955   050E 61 62 6C 65 
0955   0512 64 0A 0D 00 
0956   0516             
0957   0516 0A          s_nl_2:         .db "\n"
0958   0517 0A 0D 00    s_nl_1:         .db "\n\r", 0
0959   051A             
0960   051A 64 61 74 61 s_enter_prog:   .db "data: ", 0
0960   051E 3A 20 00 
0961   0521 6F 72 69 67 s_origin_addr:  .db "origin address: ", 0
0961   0525 69 6E 20 61 
0961   0529 64 64 72 65 
0961   052D 73 73 3A 20 
0961   0531 00 
0962   0532             
0963   0532 53 65 72 69 s_ide_serial:   .db "Serial: ", 0
0963   0536 61 6C 3A 20 
0963   053A 00 
0964   053B 46 69 72 6D s_ide_firm:     .db "Firmware: ", 0
0964   053F 77 61 72 65 
0964   0543 3A 20 00 
0965   0546 4D 6F 64 65 s_ide_model:    .db "Model: ", 0
0965   054A 6C 3A 20 00 
0966   054E 4E 75 6D 62 s_sectors:      .db "Number of sectors: ", 0
0966   0552 65 72 20 6F 
0966   0556 66 20 73 65 
0966   055A 63 74 6F 72 
0966   055E 73 3A 20 00 
0967   0562 4C 42 41 20 s_lba0:         .db "LBA 0: ", 0
0967   0566 30 3A 20 00 
0968   056A 4C 42 41 20 s_lba1:         .db "LBA 1: ", 0
0968   056E 31 3A 20 00 
0969   0572 4C 42 41 20 s_lba2:         .db "LBA 2: ", 0
0969   0576 32 3A 20 00 
0970   057A 4C 42 41 20 s_lba3:         .db "LBA 3: ", 0
0970   057E 33 3A 20 00 
0971   0582 0A 0D 45 72 s_error:        .db "\n\rError.\n\r", 0
0971   0586 72 6F 72 2E 
0971   058A 0A 0D 00 
0972   058D                             
0973   058D 30 31 32 33 s_hex_digits:   .db "0123456789ABCDEF"
0973   0591 34 35 36 37 
0973   0595 38 39 41 42 
0973   0599 43 44 45 46 
0974   059D 74 68 69 73 s_bkpt:         .db "this is the breakpoint.", 0
0974   05A1 20 69 73 20 
0974   05A5 74 68 65 20 
0974   05A9 62 72 65 61 
0974   05AD 6B 70 6F 69 
0974   05B1 6E 74 2E 00 
0975   05B5                             
0976   05B5 0A 0A 0D 73 s_priv1:        .db "\n\n\rsoftware failure: privilege exception "
0976   05B9 6F 66 74 77 
0976   05BD 61 72 65 20 
0976   05C1 66 61 69 6C 
0976   05C5 75 72 65 3A 
0976   05C9 20 70 72 69 
0976   05CD 76 69 6C 65 
0976   05D1 67 65 20 65 
0976   05D5 78 63 65 70 
0976   05D9 74 69 6F 6E 
0976   05DD 20 
0977   05DE 70 72 65 73                 .db "press any key to continue...\n\r", 0
0977   05E2 73 20 61 6E 
0977   05E6 79 20 6B 65 
0977   05EA 79 20 74 6F 
0977   05EE 20 63 6F 6E 
0977   05F2 74 69 6E 75 
0977   05F6 65 2E 2E 2E 
0977   05FA 0A 0D 00 
0978   05FD 0A 0D 65 78 s_divzero:      .db "\n\rexception: zero division\n\r", 0
0978   0601 63 65 70 74 
0978   0605 69 6F 6E 3A 
0978   0609 20 7A 65 72 
0978   060D 6F 20 64 69 
0978   0611 76 69 73 69 
0978   0615 6F 6E 0A 0D 
0978   0619 00 
0979   061A             
0980   061A             .end
tasm: Number of errors = 0
