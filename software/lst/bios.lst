0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 series minicomputer bios version 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; memory map
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000    rom begin
0009   0000             ; ....
0010   0000             ; 7fff    rom end
0011   0000             ;
0012   0000             ; 8000    ram begin
0013   0000             ; ....
0014   0000             ; f7ff    stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; i/o map
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; ff80    uart 0    (16550)
0020   0000             ; ff90    uart 1    (16550)
0021   0000             ; ffa0    rtc       (m48t02)
0022   0000             ; ffb0    pio 0     (8255)
0023   0000             ; ffc0    pio 1     (8255)
0024   0000             ; ffd0    ide       (compact flash / pata)
0025   0000             ; ffe0    timer     (8253)
0026   0000             ; fff0    bios configuration nv-ram store area
0027   0000             
0028   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029   0000             ; system constants / equations
0030   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031   0000             _uart0_data      .equ $ff80        		 ; data
0032   0000             _uart0_dlab_0    .equ $ff80        		 ; divisor latch low byte
0033   0000             _uart0_dlab_1    .equ $ff81        		 ; divisor latch high byte
0034   0000             _uart0_ier       .equ $ff81        		 ; interrupt enable register
0035   0000             _uart0_fcr       .equ $ff82        		 ; fifo control register
0036   0000             _uart0_lcr       .equ $ff83        		 ; line control register
0037   0000             _uart0_lsr       .equ $ff85        		 ; line status register
0038   0000             
0039   0000             _ide_base        .equ $ffd0        		 ; ide base
0040   0000             _ide_r0          .equ _ide_base + 0    ; data port
0041   0000             _ide_r1          .equ _ide_base + 1    ; read: error code, write: feature
0042   0000             _ide_r2          .equ _ide_base + 2    ; number of sectors to transfer
0043   0000             _ide_r3          .equ _ide_base + 3    ; sector address lba 0 [0:7]
0044   0000             _ide_r4          .equ _ide_base + 4    ; sector address lba 1 [8:15]
0045   0000             _ide_r5          .equ _ide_base + 5    ; sector address lba 2 [16:23]
0046   0000             _ide_r6          .equ _ide_base + 6    ; sector address lba 3 [24:27 (lsb)]
0047   0000             _ide_r7          .equ _ide_base + 7    ; read: status, write: command
0048   0000             
0049   0000             _7seg_display    .equ $ffb0        		 ; bios post code hex display (2 digits)
0050   0000             _bios_post_ctrl  .equ $ffb3        		 ; bios post display control register, 80h = as output
0051   0000             _pio_a           .equ $ffb0    
0052   0000             _pio_b           .equ $ffb1
0053   0000             _pio_c           .equ $ffb2
0054   0000             _pio_control     .equ $ffb3        		 ; pio control port
0055   0000             
0056   0000             _timer_c_0       .equ $ffe0        		 ; timer counter 0
0057   0000             _timer_c_1       .equ $ffe1        		 ; timer counter 1
0058   0000             _timer_c_2       .equ $ffe2        		 ; timer counter 2
0059   0000             _timer_ctrl      .equ $ffe3        		 ; timer control register
0060   0000             
0061   0000             _stack_begin     .equ $f7ff       		 ; beginning of stack
0062   0000             _global_base     .equ $8000       		 ; base of global variable block
0063   0000             
0064   0000             
0065   0000             boot_origin:     .equ _global_base + 2 + 2
0066   0000             ide_buffer:      .equ boot_origin + 1024
0067   0000             inode_buffer:    .equ ide_buffer + 2048
0068   0000             
0069   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070   0000             ; global system variables
0071   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0072   0000             
0073   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0074   0000             ; external interrupt table
0075   0000             ; highest priority at lowest address
0076   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0077   0000 34 00       .dw int_0
0078   0002 35 00       .dw int_1
0079   0004 36 00       .dw int_2
0080   0006 37 00       .dw int_3
0081   0008 38 00       .dw int_4
0082   000A 39 00       .dw int_5
0083   000C 3A 00       .dw int_6
0084   000E 3B 00       .dw int_7
0085   0010             
0086   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0087   0010             ; reset vector declaration
0088   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0089   0010 90 01       .dw bios_reset_vector
0090   0012             
0091   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0092   0012             ;; exception vector table
0093   0012             ;; total of 7 entries, starting at address $0012
0094   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095   0012 3C 00       .dw trap_privilege  
0096   0014 52 00       .dw trap_div_zero  
0097   0016 5F 00       .dw undefined_opcode
0098   0018 00 00       .dw 0
0099   001A 00 00       .dw 0
0100   001C 00 00       .dw 0
0101   001E 00 00       .dw 0
0102   0020             
0103   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0104   0020             ;; system call vector table
0105   0020             ;; starts at address $0020
0106   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0107   0020 45 00       .dw trap_breakpoint
0108   0022 60 00       .dw rtc_services        
0109   0024 96 00       .dw uart_services        
0110   0026 EE 00       .dw ide_services  
0111   0028 00 00       .dw 0
0112   002A 00 00       .dw 0
0113   002C 00 00       .dw 0
0114   002E 00 00       .dw 0
0115   0030 00 00       .dw 0
0116   0032 00 00       .dw 0  
0117   0034             
0118   0034             bios_bkpt  .equ 0
0119   0034             bios_rtc   .equ 1
0120   0034             bios_uart  .equ 2
0121   0034             bios_ide   .equ 3
0122   0034             
0123   0034             .export bios_reset_vector
0124   0034             .export ide_buffer
0125   0034             .export inode_buffer
0126   0034             .export boot_origin
0127   0034             .export bios_uart
0128   0034             .export bios_ide
0129   0034             .export __puts
0130   0034             .export __print_u16d
0131   0034             .export __print_u16x
0132   0034             .export __xput_u8
0133   0034             
0134   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0034             ; external interrupts' code block
0136   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0137   0034             int_0:
0138   0034 06            sysret
0139   0035             int_1:
0140   0035 06            sysret
0141   0036             int_2:
0142   0036 06            sysret
0143   0037             int_3:
0144   0037 06            sysret
0145   0038             int_4:
0146   0038 06            sysret
0147   0039             int_5:
0148   0039 06            sysret
0149   003A             int_6:  
0150   003A 06            sysret
0151   003B             int_7:
0152   003B 06            sysret
0153   003C             
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             ; exceptions
0156   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0157   003C             
0158   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0159   003C             ; privilege exception
0160   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0161   003C             trap_privilege:
0162   003C DA            push d
0163   003D 3B 88 05      mov d, s_priv1
0164   0040 07 52 02      call __puts
0165   0043 E7            pop d
0166   0044                           ; enable interrupts
0167   0044 06            sysret
0168   0045             
0169   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0170   0045             ; breakpoint exception
0171   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0172   0045             trap_breakpoint:
0173   0045 D7            push a
0174   0046 DA            push d
0175   0047 E1            pushf
0176   0048               
0177   0048 3B 70 05      mov d, s_bkpt
0178   004B 07 52 02      call __puts
0179   004E               
0180   004E EE            popf
0181   004F E7            pop d
0182   0050 E4            pop a
0183   0051                           ; enable interrupts
0184   0051 06            sysret
0185   0052             
0186   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0187   0052             ; divide by zero exception
0188   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0189   0052             trap_div_zero:
0190   0052 D7            push a
0191   0053 DA            push d
0192   0054 E1            pushf
0193   0055               
0194   0055 3B D0 05      mov d, s_divzero
0195   0058 07 52 02      call __puts
0196   005B               
0197   005B EE            popf
0198   005C E7            pop d
0199   005D E4            pop a
0200   005E                           ; enable interrupts
0201   005E 06            sysret
0202   005F             
0203   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0204   005F             ; undefined opcode exception
0205   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0206   005F             undefined_opcode:
0207   005F 06            sysret
0208   0060               
0209   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0210   0060             ; rtc services interrupt
0211   0060             ; rtc i/o bank = ffa0 to ffaf
0212   0060             ; ffa0 to ffa7 is scratch ram
0213   0060             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0214   0060             ; al = 0..6 -> get
0215   0060             ; al = 7..d -> set
0216   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0217   0060             rtc_services:
0218   0060 DB            push al
0219   0061 DA            push d
0220   0062 B9 06         cmp al, 6
0221   0064 D1 79 00      jgu rtc_set
0222   0067             rtc_get:
0223   0067 6A A9         add al, $a9      ; generate rtc address to get to address a9 of clock
0224   0069 22 FF         mov ah, $ff    
0225   006B 3C            mov d, a        ; get to ffa9 + offset
0226   006C F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0227   0070 1E            mov al, [d]      ; get data
0228   0071 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset r bit
0229   0075 23            mov ah, al
0230   0076 E7            pop d
0231   0077 E8            pop al
0232   0078 06            sysret
0233   0079             rtc_set:
0234   0079 DD            push bl
0235   007A 99            mov bl, ah    ; set data aside
0236   007B 6A A2         add al, $a2    ; generate rtc address to get to address a9 of clock
0237   007D 22 FF         mov ah, $ff    
0238   007F 3C            mov d, a    ; get to ffa9 + offset
0239   0080 1B            mov al, bl    ; get data back
0240   0081 F2 A8 FF 80   mov byte[$ffa8], $80  ; set w bit to 1
0241   0085 3E            mov [d], al    ; set data
0242   0086 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset write bit
0243   008A EA            pop bl
0244   008B E7            pop d
0245   008C E8            pop al
0246   008D 06            sysret
0247   008E             
0248   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0249   008E             ; int 4
0250   008E             ; uart services interrupt
0251   008E             ; al = option
0252   008E             ; ah = data
0253   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0254   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0255   008E             uart_serv_tbl:
0256   008E 9A 00         .dw uart_init
0257   0090 B3 00         .dw uart_send
0258   0092 C0 00         .dw uart_receive
0259   0094 CD 00         .dw uart_receive_e
0260   0096             uart_services:
0261   0096 FD 0A 8E 00   jmp [uart_serv_tbl + al]
0262   009A             
0263   009A             uart_init:
0264   009A F2 83 FF 8F   mov byte[_uart0_lcr], %10001111      ; 8 data, 2 stop, even parity, divisor latch = 1, uart address 3 = line control register
0265   009E F2 80 FF 03   mov byte[_uart0_dlab_0], 3      ; baud = 38400
0266   00A2 F2 81 FF 00   mov byte[_uart0_dlab_1], 0      ; divisor latch high byte = 0      
0267   00A6 F2 83 FF 0F   mov byte[_uart0_lcr], %00001111      ; divisor latch = 0, uart address 3 = line control register
0268   00AA F2 81 FF 00   mov byte[_uart0_ier], 0      ; disable all uart interrupts
0269   00AE F2 82 FF 00   mov byte[_uart0_fcr], 0      ; disable fifo
0270   00B2 06            sysret
0271   00B3             
0272   00B3             uart_send:
0273   00B3 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0274   00B6 93 20         test al, 20h          ; isolate transmitter empty
0275   00B8 C6 B3 00      jz uart_send    
0276   00BB 1A            mov al, ah
0277   00BC 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0278   00BF 06            sysret
0279   00C0             
0280   00C0             uart_receive:
0281   00C0 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0282   00C3 93 01         test al, 1          ; isolate data ready
0283   00C5 C6 C0 00      jz uart_receive
0284   00C8 1D 80 FF      mov al, [_uart0_data]      ; get character
0285   00CB 23            mov ah, al
0286   00CC 06            sysret
0287   00CD             
0288   00CD             uart_receive_e:
0289   00CD 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0290   00D0 93 01         test al, 1          ; isolate data ready
0291   00D2 C6 CD 00      jz uart_receive_e
0292   00D5 1D 80 FF      mov al, [_uart0_data]      ; get character
0293   00D8 23            mov ah, al
0294   00D9             uart_receive_e_loop:
0295   00D9 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0296   00DC 93 20         test al, 20h          ; isolate transmitter empty
0297   00DE C6 D9 00      jz uart_receive_e_loop
0298   00E1 1A            mov al, ah
0299   00E2 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0300   00E5 06            sysret
0301   00E6               
0302   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303   00E6             ; ide services interrupt
0304   00E6             ; al = option
0305   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0306   00E6             ; ide read/write sector
0307   00E6             ; 512 bytes
0308   00E6             ; user buffer pointer in d
0309   00E6             ; kernel buffer pointer = ide_buffer
0310   00E6             ; ah = number of sectors
0311   00E6             ; cb = lba bytes 3..0
0312   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0313   00E6             ide_serv_tbl:
0314   00E6 F2 00         .dw ide_reset
0315   00E8 06 01         .dw ide_sleep
0316   00EA 15 01         .dw ide_read_sect
0317   00EC 36 01         .dw ide_write_sect
0318   00EE             ide_services:
0319   00EE FD 0A E6 00   jmp [ide_serv_tbl + al]  
0320   00F2             ide_reset:      
0321   00F2 F2 D7 FF 04   mov byte[_ide_r7], 4    ; reset ide
0322   00F6 07 87 01      call ide_wait        ; wait for ide ready             
0323   00F9 F2 D6 FF E0   mov byte[_ide_r6], $e0    ; lba3= 0, master, mode= lba        
0324   00FD F2 D1 FF 01   mov byte[_ide_r1], 1    ; 8-bit transfers      
0325   0101 F2 D7 FF EF   mov byte[_ide_r7], $ef    ; set feature command
0326   0105 06            sysret
0327   0106             ide_sleep:
0328   0106 07 87 01      call ide_wait          ; wait for ide ready             
0329   0109 F2 D6 FF 40   mov byte [_ide_r6], %01000000  ; lba[3:0](reserved), bit 6=1
0330   010D F2 D7 FF E6   mov byte [_ide_r7], $e6    ; sleep command
0331   0111 07 87 01      call ide_wait          ; wait for ide ready
0332   0114 06            sysret
0333   0115             ide_read_sect:
0334   0115 1A            mov al, ah
0335   0116 24            mov ah, bl
0336   0117 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0337   011A 1C            mov al, bh
0338   011B 3D D4 FF      mov [_ide_r4], al
0339   011E 12            mov a, c
0340   011F 3D D5 FF      mov [_ide_r5], al
0341   0122 1A            mov al, ah
0342   0123 87 0F         and al, %00001111
0343   0125 8B E0         or al, %11100000      ; mode lba, master
0344   0127 3D D6 FF      mov [_ide_r6], al
0345   012A 07 87 01      call ide_wait
0346   012D 19 20         mov al, 20h
0347   012F 3D D7 FF      mov [_ide_r7], al      ; read sector cmd
0348   0132 07 57 01      call ide_read  
0349   0135 06            sysret
0350   0136             ide_write_sect:
0351   0136 1A            mov al, ah
0352   0137 24            mov ah, bl
0353   0138 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0354   013B 1C            mov al, bh
0355   013C 3D D4 FF      mov [_ide_r4], al
0356   013F 12            mov a, c
0357   0140 3D D5 FF      mov [_ide_r5], al
0358   0143 1A            mov al, ah
0359   0144 87 0F         and al, %00001111
0360   0146 8B E0         or al, %11100000      ; mode lba, master
0361   0148 3D D6 FF      mov [_ide_r6], al
0362   014B 07 87 01      call ide_wait
0363   014E 19 30         mov al, 30h
0364   0150 3D D7 FF      mov [_ide_r7], al      ; write sector cmd
0365   0153 07 6F 01      call ide_write      
0366   0156 06            sysret
0367   0157             
0368   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0369   0157             ; read ide data
0370   0157             ; pointer in d
0371   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0372   0157             ide_read:
0373   0157 DB            push al
0374   0158 DA            push d
0375   0159             ide_read_loop:
0376   0159 07 87 01      call ide_wait
0377   015C 1D D7 FF      mov al, [_ide_r7]
0378   015F 87 08         and al, %00001000      ; drq flag
0379   0161 C6 6C 01      jz ide_read_end
0380   0164 1D D0 FF      mov al, [_ide_r0]
0381   0167 3E            mov [d], al
0382   0168 79            inc d
0383   0169 0A 59 01      jmp ide_read_loop
0384   016C             ide_read_end:
0385   016C E7            pop d
0386   016D E8            pop al
0387   016E 09            ret
0388   016F             
0389   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0390   016F             ; write ide data
0391   016F             ; data pointer in d
0392   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393   016F             ide_write:
0394   016F DB            push al
0395   0170 DA            push d
0396   0171             ide_write_loop:
0397   0171 07 87 01      call ide_wait
0398   0174 1D D7 FF      mov al, [_ide_r7]
0399   0177 87 08         and al, %00001000      ; drq flag
0400   0179 C6 84 01      jz ide_write_end
0401   017C 1E            mov al, [d]
0402   017D 3D D0 FF      mov [_ide_r0], al
0403   0180 79            inc d 
0404   0181 0A 71 01      jmp ide_write_loop
0405   0184             ide_write_end:
0406   0184 E7            pop d
0407   0185 E8            pop al
0408   0186 09            ret
0409   0187             
0410   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0411   0187             ; wait for ide to be ready
0412   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0413   0187             ide_wait:
0414   0187 1D D7 FF      mov al, [_ide_r7]  
0415   018A 87 80         and al, 80h        ; busy flag
0416   018C C7 87 01      jnz ide_wait
0417   018F 09            ret
0418   0190             
0419   0190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0420   0190             ; bios entry point
0421   0190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0422   0190             bios_reset_vector:
0423   0190 19 00         mov al, %00000000        ; interrupts = off, mode = sup, paging = off, halt-flag = off, display_load = on
0424   0192 0D            stostat
0425   0193               
0426   0193 10 FF F7      mov a, _stack_begin
0427   0196 47            mov sp, a
0428   0197 49            mov bp, a      ; setup stack and frame
0429   0198             
0430   0198 19 00         mov al, 0
0431   019A 05 02         syscall bios_uart
0432   019C               
0433   019C 3B BD 03      mov d, s_welcome
0434   019F 07 52 02      call __puts          ; print welcome msg
0435   01A2             
0436   01A2 07 C2 01      call bios_peripherals_setup
0437   01A5               
0438   01A5 3B 10 04      mov d, s_boot1
0439   01A8 07 52 02      call __puts
0440   01AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0441   01AB 38 00 00      mov c, 0
0442   01AE 26 00 00      mov b, 0          ; start at disk sector 0
0443   01B1 3B 04 80      mov d, boot_origin    ; we read into the bios ide buffer
0444   01B4 10 02 02      mov a, $0202        ; disk read, 2 sectors
0445   01B7 05 03         syscall bios_ide      ; read sector  
0446   01B9               
0447   01B9 3B 26 04      mov d, s_boot2
0448   01BC 07 52 02      call __puts
0449   01BF             
0450   01BF 0A 04 80      jmp boot_origin
0451   01C2             
0452   01C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0453   01C2             
0454   01C2             bios_peripherals_setup:
0455   01C2 3B 80 04      mov d, s_init
0456   01C5 07 52 02      call __puts
0457   01C8               
0458   01C8 3B 39 04      mov d, s_bios3
0459   01CB 07 52 02      call __puts
0460   01CE 19 00         mov al, 0            ; reset ide
0461   01D0 05 03         syscall bios_ide  
0462   01D2               
0463   01D2 3B 4F 04      mov d, s_bios4
0464   01D5 07 52 02      call __puts
0465   01D8               
0466   01D8 19 30         mov al, %00110000          ; counter 0, load both bytes, mode 0, binary
0467   01DA 3D E3 FF      mov [_timer_ctrl], al
0468   01DD 19 FF         mov al, $ff
0469   01DF 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 low byte
0470   01E2 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 high byte
0471   01E5               
0472   01E5 3B 65 04      mov d, s_bios5
0473   01E8 07 52 02      call __puts
0474   01EB 19 80         mov al, $80
0475   01ED 3D B3 FF      mov [_bios_post_ctrl], al      ; set pio_a to output mode
0476   01F0 19 00         mov al, 0
0477   01F2 3D B0 FF      mov [_7seg_display], al      ; post code = 00
0478   01F5 09            ret
0479   01F6             
0480   01F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0481   01F6             ; print 16bit hex integer
0482   01F6             ; integer value in reg b
0483   01F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0484   01F6             __print_u16x:
0485   01F6 E1            pushf
0486   01F7 D7            push a
0487   01F8 D8            push b
0488   01F9 DD            push bl
0489   01FA 30            mov bl, bh
0490   01FB 07 31 03      call _itoa        ; convert bh to char in a
0491   01FE 2F            mov bl, al        ; save al  
0492   01FF 19 01         mov al, 1
0493   0201 05 02         syscall bios_uart        ; display ah
0494   0203 24            mov ah, bl        ; retrieve al
0495   0204 19 01         mov al, 1
0496   0206 05 02         syscall bios_uart        ; display al
0497   0208             
0498   0208 EA            pop bl
0499   0209 07 31 03      call _itoa        ; convert bh to char in a
0500   020C 2F            mov bl, al        ; save al
0501   020D 19 01         mov al, 1
0502   020F 05 02         syscall bios_uart        ; display ah
0503   0211 24            mov ah, bl        ; retrieve al
0504   0212 19 01         mov al, 1
0505   0214 05 02         syscall bios_uart        ; display al
0506   0216             
0507   0216 E5            pop b
0508   0217 E4            pop a
0509   0218 EE            popf
0510   0219 09            ret
0511   021A             
0512   021A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0513   021A             ; input 16bit hex integer
0514   021A             ; read 16bit integer into a
0515   021A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0516   021A             scan_u16x:
0517   021A F8 10 00      enter 16
0518   021D E1            pushf
0519   021E D8            push b
0520   021F DA            push d
0521   0220             
0522   0220 FA F1 FF      lea d, [bp + -15]
0523   0223 07 C5 02      call _getse        ; get number
0524   0226             
0525   0226 32            mov bl, [d]
0526   0227 37            mov bh, bl
0527   0228 33 01 00      mov bl, [d + 1]
0528   022B 07 1F 03      call _atoi        ; convert to int in al
0529   022E 23            mov ah, al        ; move to ah
0530   022F               
0531   022F 33 02 00      mov bl, [d + 2]
0532   0232 37            mov bh, bl
0533   0233 33 03 00      mov bl, [d + 3]
0534   0236 07 1F 03      call _atoi        ; convert to int in al
0535   0239               
0536   0239 E7            pop d  
0537   023A E5            pop b
0538   023B EE            popf
0539   023C F9            leave
0540   023D 09            ret
0541   023E             
0542   023E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0543   023E             ; print 8bit hex integer
0544   023E             ; byte value in reg bl
0545   023E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0546   023E             __xput_u8:
0547   023E D7            push a
0548   023F DD            push bl
0549   0240 E1            pushf
0550   0241             
0551   0241 07 31 03      call _itoa          ; convert bl to char in a
0552   0244 2F            mov bl, al          ; save al  
0553   0245 19 01         mov al, 1
0554   0247 05 02         syscall bios_uart        ; display ah
0555   0249 24            mov ah, bl          ; retrieve al
0556   024A 19 01         mov al, 1
0557   024C 05 02         syscall bios_uart        ; display al
0558   024E               
0559   024E EE            popf
0560   024F EA            pop bl
0561   0250 E4            pop a
0562   0251 09            ret
0563   0252             
0564   0252             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0565   0252             ; print null terminated string
0566   0252             ; pointer in d
0567   0252             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0568   0252             __puts:
0569   0252 D7            push a
0570   0253 DA            push d
0571   0254 E1            pushf
0572   0255             __puts_l1:
0573   0255 1E            mov al, [d]
0574   0256 B9 00         cmp al, 0
0575   0258 C6 6B 02      jz __puts_end
0576   025B             __puts_l2:
0577   025B 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0578   025E 93 20         test al, $20          ; isolate transmitter empty
0579   0260 C6 5B 02      jz __puts_l2    
0580   0263 1E            mov al, [d]
0581   0264 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0582   0267 79            inc d  
0583   0268 0A 55 02      jmp __puts_l1
0584   026B             __puts_end:
0585   026B EE            popf
0586   026C E7            pop d
0587   026D E4            pop a
0588   026E 09            ret
0589   026F             
0590   026F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0591   026F             ; _putchar
0592   026F             ; char in ah
0593   026F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0594   026F             _putchar:
0595   026F D7            push a
0596   0270 E1            pushf
0597   0271             _putchar_l1:
0598   0271 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0599   0274 93 20         test al, 20h          ; isolate transmitter empty
0600   0276 C6 71 02      jz _putchar_l1    
0601   0279 1A            mov al, ah
0602   027A 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0603   027D EE            popf
0604   027E E4            pop a
0605   027F 09            ret
0606   0280               
0607   0280             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0608   0280             ;; input a string with no echo
0609   0280             ;; terminates with null
0610   0280             ;; pointer in d
0611   0280             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0612   0280             _gets:
0613   0280 E1            pushf
0614   0281 D7            push a
0615   0282 DA            push d
0616   0283             _gets_loop:
0617   0283 19 02         mov al, 2
0618   0285 05 02         syscall bios_uart      ; receive in ah
0619   0287 76 0A         cmp ah, 0ah        ; lf
0620   0289 C6 BE 02      je _gets_end
0621   028C 76 0D         cmp ah, 0dh        ; cr
0622   028E C6 BE 02      je _gets_end
0623   0291 76 5C         cmp ah, $5c        ; '\\'
0624   0293 C6 9C 02      je _gets_escape
0625   0296 1A            mov al, ah
0626   0297 3E            mov [d], al
0627   0298 79            inc d
0628   0299 0A 83 02      jmp _gets_loop
0629   029C             _gets_escape:
0630   029C 19 02         mov al, 2
0631   029E 05 02         syscall bios_uart      ; receive in ah
0632   02A0 76 6E         cmp ah, 'n'
0633   02A2 C6 B0 02      je _gets_lf
0634   02A5 76 72         cmp ah, 'r'
0635   02A7 C6 B7 02      je _gets_cr
0636   02AA 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0637   02AB 3E            mov [d], al
0638   02AC 79            inc d
0639   02AD 0A 83 02      jmp _gets_loop
0640   02B0             _gets_lf:
0641   02B0 19 0A         mov al, $0a
0642   02B2 3E            mov [d], al
0643   02B3 79            inc d
0644   02B4 0A 83 02      jmp _gets_loop
0645   02B7             _gets_cr:
0646   02B7 19 0D         mov al, $0d
0647   02B9 3E            mov [d], al
0648   02BA 79            inc d
0649   02BB 0A 83 02      jmp _gets_loop
0650   02BE             _gets_end:
0651   02BE 19 00         mov al, 0
0652   02C0 3E            mov [d], al        ; terminate string
0653   02C1 E7            pop d
0654   02C2 E4            pop a
0655   02C3 EE            popf
0656   02C4 09            ret
0657   02C5             
0658   02C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0659   02C5             ;; INPUT A STRING with echo
0660   02C5             ;; terminates with null
0661   02C5             ;; pointer in D
0662   02C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0663   02C5             _getse:
0664   02C5 E1            pushf
0665   02C6 D7            push a
0666   02C7 DA            push d
0667   02C8             _getse_loop:
0668   02C8 19 03         mov al, 3
0669   02CA 05 02         syscall bios_uart      ; receive in AH
0670   02CC 76 0A         cmp ah, 0Ah        ; LF
0671   02CE C6 03 03      je _getse_end
0672   02D1 76 0D         cmp ah, 0Dh        ; CR
0673   02D3 C6 03 03      je _getse_end
0674   02D6 76 5C         cmp ah, $5C        ; '\\'
0675   02D8 C6 E1 02      je _getse_escape
0676   02DB 1A            mov al, ah
0677   02DC 3E            mov [d], al
0678   02DD 79            inc d
0679   02DE 0A C8 02      jmp _getse_loop
0680   02E1             _getse_escape:
0681   02E1 19 03         mov al, 3
0682   02E3 05 02         syscall bios_uart      ; receive in AH
0683   02E5 76 6E         cmp ah, 'n'
0684   02E7 C6 F5 02      je _getse_LF
0685   02EA 76 72         cmp ah, 'r'
0686   02EC C6 FC 02      je _getse_CR
0687   02EF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0688   02F0 3E            mov [d], al
0689   02F1 79            inc d
0690   02F2 0A C8 02      jmp _getse_loop
0691   02F5             _getse_LF:
0692   02F5 19 0A         mov al, $0A
0693   02F7 3E            mov [d], al
0694   02F8 79            inc d
0695   02F9 0A C8 02      jmp _getse_loop
0696   02FC             _getse_CR:
0697   02FC 19 0D         mov al, $0D
0698   02FE 3E            mov [d], al
0699   02FF 79            inc d
0700   0300 0A C8 02      jmp _getse_loop
0701   0303             _getse_end:
0702   0303 19 00         mov al, 0
0703   0305 3E            mov [d], al        ; terminate string
0704   0306 E7            pop d
0705   0307 E4            pop a
0706   0308 EE            popf
0707   0309 09            ret
0708   030A             
0709   030A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0710   030A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0711   030A             ; ASCII in BL
0712   030A             ; result in AL
0713   030A             ; ascii for F = 0100 0110
0714   030A             ; ascii for 9 = 0011 1001
0715   030A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0716   030A             hex_ascii_encode:
0717   030A 1B            mov al, bl  
0718   030B 93 40         test al, 40h        ; test if letter or number
0719   030D C7 13 03      jnz hex_letter
0720   0310 87 0F         and al, 0Fh        ; get number
0721   0312 09            ret
0722   0313             hex_letter:
0723   0313 DC            push ah
0724   0314 24            mov ah, bl
0725   0315 07 6E 03      call _to_upper
0726   0318 1A            mov al, ah  
0727   0319 87 0F         and al, 0Fh        ; get letter
0728   031B 6A 09         add al, 9
0729   031D E9            pop ah
0730   031E 09            ret
0731   031F             
0732   031F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0733   031F             ; ATOI
0734   031F             ; 2 letter hex string in B
0735   031F             ; 8bit integer returned in AL
0736   031F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0737   031F             _atoi:
0738   031F E1            pushf
0739   0320 D8            push b
0740   0321                 
0741   0321 07 0A 03      call hex_ascii_encode      ; convert BL to 4bit code in AL
0742   0324 30            mov bl, bh
0743   0325 DB            push al          ; save a
0744   0326 07 0A 03      call hex_ascii_encode
0745   0329 EA            pop bl  
0746   032A FD 9E 04      shl al, 4
0747   032D 8C            or al, bl
0748   032E               
0749   032E E5            pop b
0750   032F EE            popf
0751   0330 09            ret  
0752   0331             
0753   0331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0754   0331             ; ITOA
0755   0331             ; 8bit value in BL
0756   0331             ; 2 byte ASCII result in A
0757   0331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0758   0331             _itoa:
0759   0331 E1            pushf
0760   0332 DA            push d
0761   0333 DE            push bh
0762   0334 DD            push bl
0763   0335             
0764   0335 A7 00         mov bh, 0
0765   0337               
0766   0337 FD 87 0F      and bl, $0F
0767   033A 3B 60 05      mov d, s_hex_digits
0768   033D 5A            add d, b
0769   033E 1E            mov al, [d]        ; get ASCII
0770   033F EA            pop bl
0771   0340 52 01 00      sub sp, 1        ; push bl back
0772   0343 DB            push al
0773   0344               
0774   0344 FD 87 F0      and bl, $F0
0775   0347 FD A4 04      shr bl, 4
0776   034A 3B 60 05      mov d, s_hex_digits
0777   034D 5A            add d, b
0778   034E 1E            mov al, [d]        ; get ASCII
0779   034F             
0780   034F 23            mov ah, al
0781   0350 E8            pop al  
0782   0351               
0783   0351 EA            pop bl
0784   0352 EB            pop bh
0785   0353 E7            pop d
0786   0354 EE            popf
0787   0355 09            ret
0788   0356             
0789   0356             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0790   0356             ; STRCMP
0791   0356             ; compare two strings
0792   0356             ; str1 in SI
0793   0356             ; str2 in DI
0794   0356             ; changes: AL SI DI
0795   0356             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0796   0356             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0797   0356             _strcmp:
0798   0356             _strcmp_loop:
0799   0356 F3            cmpsb          ; compare a byte of the strings
0800   0357 C7 63 03      jne _strcmp_ret
0801   035A FB FF FF      lea d, [si + -1]
0802   035D 1E            mov al, [d]
0803   035E B9 00         cmp al, 0        ; check if at end of string (null)
0804   0360 C7 56 03      jne _strcmp_loop        ; equal chars but not at end
0805   0363             _strcmp_ret:        
0806   0363 09            ret
0807   0364             
0808   0364             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0809   0364             ; TO LOWER
0810   0364             ; input in AL
0811   0364             ; output in AL
0812   0364             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0813   0364             _to_lower:
0814   0364 E1            pushf
0815   0365 B9 5A         cmp al, 'Z'
0816   0367 D1 6C 03      jgu _to_lower_ret
0817   036A 6A 20         add al, 20h        ; convert to lower case
0818   036C             _to_lower_ret:
0819   036C EE            popf
0820   036D 09            ret
0821   036E             
0822   036E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0823   036E             ; TO UPPER
0824   036E             ; input in AL
0825   036E             ; output in AL
0826   036E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0827   036E             _to_upper:
0828   036E E1            pushf
0829   036F B9 61         cmp al, 'a'
0830   0371 C8 76 03      jlu _to_upper_ret
0831   0374 6F 20         sub al, 20h        ; convert to upper case
0832   0376             _to_upper_ret:
0833   0376 EE            popf
0834   0377 09            ret
0835   0378             
0836   0378             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0837   0378             ; PRINT DECIMAL INTEGER
0838   0378             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0839   0378             print_decimal:
0840   0378 09            ret
0841   0379             
0842   0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0843   0379             ; print 16bit decimal number
0844   0379             ; input number in a
0845   0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0846   0379             __print_u16d:
0847   0379 D7            push a
0848   037A D8            push b
0849   037B FD D8         push g
0850   037D 26 10 27      mov b, 10000
0851   0380 AE            div a, b      ; get 10000's coeff.
0852   0381 07 A5 03      call print_number
0853   0384 11            mov a, b
0854   0385 26 E8 03      mov b, 1000
0855   0388 AE            div a, b      ; get 1000's coeff.
0856   0389 07 A5 03      call print_number
0857   038C 11            mov a, b
0858   038D 26 64 00      mov b, 100
0859   0390 AE            div a, b
0860   0391 07 A5 03      call print_number
0861   0394 11            mov a, b
0862   0395 26 0A 00      mov b, 10
0863   0398 AE            div a, b
0864   0399 07 A5 03      call print_number
0865   039C 1B            mov al, bl      ; 1's coeff in bl
0866   039D 07 A5 03      call print_number
0867   03A0 FD F1         pop g
0868   03A2 E5            pop b
0869   03A3 E4            pop a
0870   03A4 09            ret
0871   03A5             
0872   03A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0873   03A5             ; print al
0874   03A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0875   03A5             print_number:
0876   03A5 6A 30         add al, $30
0877   03A7 23            mov ah, al
0878   03A8 07 6F 02      call _putchar
0879   03AB 09            ret
0880   03AC             
0881   03AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0882   03AC             ; HEX STRING TO BINARY
0883   03AC             ; di = destination address
0884   03AC             ; si = source
0885   03AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0886   03AC             _hex_to_int:
0887   03AC             _hex_to_int_L1:
0888   03AC F6            lodsb          ; load from [SI] to AL
0889   03AD B9 00         cmp al, 0        ; check if ASCII 0
0890   03AF C6 BC 03      jz _hex_to_int_ret
0891   03B2 36            mov bh, al
0892   03B3 F6            lodsb
0893   03B4 2F            mov bl, al
0894   03B5 07 1F 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0895   03B8 F7            stosb          ; store AL to [DI]
0896   03B9 0A AC 03      jmp _hex_to_int_L1
0897   03BC             _hex_to_int_ret:
0898   03BC 09            ret  
0899   03BD             
0900   03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0901   03BD             ; data block
0902   03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0903   03BD 0A 0A 0D 53 s_welcome:      .db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0903   03C1 6F 6C 2D 31 
0903   03C5 20 37 34 48 
0903   03C9 43 20 48 6F 
0903   03CD 6D 65 62 72 
0903   03D1 65 77 43 50 
0903   03D5 55 20 4D 69 
0903   03D9 6E 69 43 6F 
0903   03DD 6D 70 75 74 
0903   03E1 65 72 0A 
0904   03E4 42 49 4F 53                 .db "BIOS Version 0.1\n\n\r"
0904   03E8 20 56 65 72 
0904   03EC 73 69 6F 6E 
0904   03F0 20 30 2E 31 
0904   03F4 0A 0A 0D 
0905   03F7 74 65 72 6D                 .db "terminal-1 initialized\n\r", 0
0905   03FB 69 6E 61 6C 
0905   03FF 2D 31 20 69 
0905   0403 6E 69 74 69 
0905   0407 61 6C 69 7A 
0905   040B 65 64 0A 0D 
0905   040F 00 
0906   0410                     
0907   0410 72 65 61 64 s_boot1:        .db "reading boot sector\n\r", 0
0907   0414 69 6E 67 20 
0907   0418 62 6F 6F 74 
0907   041C 20 73 65 63 
0907   0420 74 6F 72 0A 
0907   0424 0D 00 
0908   0426 62 6F 6F 74 s_boot2:        .db "boot-sector read\n\r", 0
0908   042A 2D 73 65 63 
0908   042E 74 6F 72 20 
0908   0432 72 65 61 64 
0908   0436 0A 0D 00 
0909   0439                     
0910   0439 72 65 73 65 s_bios3:        .db "resetting IDE-drive\n\r", 0
0910   043D 74 74 69 6E 
0910   0441 67 20 49 44 
0910   0445 45 2D 64 72 
0910   0449 69 76 65 0A 
0910   044D 0D 00 
0911   044F 63 6F 6E 66 s_bios4:        .db "configuring Timer-1\n\r", 0
0911   0453 69 67 75 72 
0911   0457 69 6E 67 20 
0911   045B 54 69 6D 65 
0911   045F 72 2D 31 0A 
0911   0463 0D 00 
0912   0465 50 49 4F 2D s_bios5:        .db "PIO-A set to output mode\n\r", 0
0912   0469 41 20 73 65 
0912   046D 74 20 74 6F 
0912   0471 20 6F 75 74 
0912   0475 70 75 74 20 
0912   0479 6D 6F 64 65 
0912   047D 0A 0D 00 
0913   0480             
0914   0480 65 6E 74 65 s_init:         .db "entering real-mode [supervisor on; paging off]\n\r"
0914   0484 72 69 6E 67 
0914   0488 20 72 65 61 
0914   048C 6C 2D 6D 6F 
0914   0490 64 65 20 5B 
0914   0494 73 75 70 65 
0914   0498 72 76 69 73 
0914   049C 6F 72 20 6F 
0914   04A0 6E 3B 20 70 
0914   04A4 61 67 69 6E 
0914   04A8 67 20 6F 66 
0914   04AC 66 5D 0A 0D 
0915   04B0 69 6E 74 65                 .db "interrupts disabled\n\r"
0915   04B4 72 72 75 70 
0915   04B8 74 73 20 64 
0915   04BC 69 73 61 62 
0915   04C0 6C 65 64 0A 
0915   04C4 0D 
0916   04C5 64 69 73 70                 .db "display register loading disabled\n\r", 0
0916   04C9 6C 61 79 20 
0916   04CD 72 65 67 69 
0916   04D1 73 74 65 72 
0916   04D5 20 6C 6F 61 
0916   04D9 64 69 6E 67 
0916   04DD 20 64 69 73 
0916   04E1 61 62 6C 65 
0916   04E5 64 0A 0D 00 
0917   04E9             
0918   04E9 0A          s_nl_2:         .db "\n"
0919   04EA 0A 0D 00    s_nl_1:         .db "\n\r", 0
0920   04ED             
0921   04ED 64 61 74 61 s_enter_prog:   .db "data: ", 0
0921   04F1 3A 20 00 
0922   04F4 6F 72 69 67 s_origin_addr:  .db "origin address: ", 0
0922   04F8 69 6E 20 61 
0922   04FC 64 64 72 65 
0922   0500 73 73 3A 20 
0922   0504 00 
0923   0505             
0924   0505 53 65 72 69 s_ide_serial:   .db "Serial: ", 0
0924   0509 61 6C 3A 20 
0924   050D 00 
0925   050E 46 69 72 6D s_ide_firm:     .db "Firmware: ", 0
0925   0512 77 61 72 65 
0925   0516 3A 20 00 
0926   0519 4D 6F 64 65 s_ide_model:    .db "Model: ", 0
0926   051D 6C 3A 20 00 
0927   0521 4E 75 6D 62 s_sectors:      .db "Number of sectors: ", 0
0927   0525 65 72 20 6F 
0927   0529 66 20 73 65 
0927   052D 63 74 6F 72 
0927   0531 73 3A 20 00 
0928   0535 4C 42 41 20 s_lba0:         .db "LBA 0: ", 0
0928   0539 30 3A 20 00 
0929   053D 4C 42 41 20 s_lba1:         .db "LBA 1: ", 0
0929   0541 31 3A 20 00 
0930   0545 4C 42 41 20 s_lba2:         .db "LBA 2: ", 0
0930   0549 32 3A 20 00 
0931   054D 4C 42 41 20 s_lba3:         .db "LBA 3: ", 0
0931   0551 33 3A 20 00 
0932   0555 0A 0D 45 72 s_error:        .db "\n\rError.\n\r", 0
0932   0559 72 6F 72 2E 
0932   055D 0A 0D 00 
0933   0560                             
0934   0560 30 31 32 33 s_hex_digits:   .db "0123456789ABCDEF"
0934   0564 34 35 36 37 
0934   0568 38 39 41 42 
0934   056C 43 44 45 46 
0935   0570 74 68 69 73 s_bkpt:         .db "this is the breakpoint.", 0
0935   0574 20 69 73 20 
0935   0578 74 68 65 20 
0935   057C 62 72 65 61 
0935   0580 6B 70 6F 69 
0935   0584 6E 74 2E 00 
0936   0588                             
0937   0588 0A 0A 0D 73 s_priv1:        .db "\n\n\rsoftware failure: privilege exception "
0937   058C 6F 66 74 77 
0937   0590 61 72 65 20 
0937   0594 66 61 69 6C 
0937   0598 75 72 65 3A 
0937   059C 20 70 72 69 
0937   05A0 76 69 6C 65 
0937   05A4 67 65 20 65 
0937   05A8 78 63 65 70 
0937   05AC 74 69 6F 6E 
0937   05B0 20 
0938   05B1 70 72 65 73                 .db "press any key to continue...\n\r", 0
0938   05B5 73 20 61 6E 
0938   05B9 79 20 6B 65 
0938   05BD 79 20 74 6F 
0938   05C1 20 63 6F 6E 
0938   05C5 74 69 6E 75 
0938   05C9 65 2E 2E 2E 
0938   05CD 0A 0D 00 
0939   05D0 0A 0D 65 78 s_divzero:      .db "\n\rexception: zero division\n\r", 0
0939   05D4 63 65 70 74 
0939   05D8 69 6F 6E 3A 
0939   05DC 20 7A 65 72 
0939   05E0 6F 20 64 69 
0939   05E4 76 69 73 69 
0939   05E8 6F 6E 0A 0D 
0939   05EC 00 
0940   05ED             
0941   05ED             .end
tasm: Number of errors = 0
