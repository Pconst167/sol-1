0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 series minicomputer bios version 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; memory map
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000    rom begin
0009   0000             ; ....
0010   0000             ; 7fff    rom end
0011   0000             ;
0012   0000             ; 8000    ram begin
0013   0000             ; ....
0014   0000             ; f7ff    stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; i/o map
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; ff80    uart 0    (16550)
0020   0000             ; ff90    uart 1    (16550)
0021   0000             ; ffa0    rtc       (m48t02)
0022   0000             ; ffb0    pio 0     (8255)
0023   0000             ; ffc0    pio 1     (8255)
0024   0000             ; ffd0    ide       (compact flash / pata)
0025   0000             ; ffe0    timer     (8253)
0026   0000             ; fff0    bios configuration nv-ram store area
0027   0000             
0028   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029   0000             ; system constants / equations
0030   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031   0000             _uart0_data      .equ $ff80        		 ; data
0032   0000             _uart0_dlab_0    .equ $ff80        		 ; divisor latch low byte
0033   0000             _uart0_dlab_1    .equ $ff81        		 ; divisor latch high byte
0034   0000             _uart0_ier       .equ $ff81        		 ; interrupt enable register
0035   0000             _uart0_fcr       .equ $ff82        		 ; fifo control register
0036   0000             _uart0_lcr       .equ $ff83        		 ; line control register
0037   0000             _uart0_lsr       .equ $ff85        		 ; line status register
0038   0000             
0039   0000             _ide_base        .equ $ffd0        		 ; ide base
0040   0000             _ide_r0          .equ _ide_base + 0    ; data port
0041   0000             _ide_r1          .equ _ide_base + 1    ; read: error code, write: feature
0042   0000             _ide_r2          .equ _ide_base + 2    ; number of sectors to transfer
0043   0000             _ide_r3          .equ _ide_base + 3    ; sector address lba 0 [0:7]
0044   0000             _ide_r4          .equ _ide_base + 4    ; sector address lba 1 [8:15]
0045   0000             _ide_r5          .equ _ide_base + 5    ; sector address lba 2 [16:23]
0046   0000             _ide_r6          .equ _ide_base + 6    ; sector address lba 3 [24:27 (lsb)]
0047   0000             _ide_r7          .equ _ide_base + 7    ; read: status, write: command
0048   0000             
0049   0000             _7seg_display    .equ $ffb0        		 ; bios post code hex display (2 digits)
0050   0000             _bios_post_ctrl  .equ $ffb3        		 ; bios post display control register, 80h = as output
0051   0000             _pio_a           .equ $ffb0    
0052   0000             _pio_b           .equ $ffb1
0053   0000             _pio_c           .equ $ffb2
0054   0000             _pio_control     .equ $ffb3        		 ; pio control port
0055   0000             
0056   0000             _timer_c_0       .equ $ffe0        		 ; timer counter 0
0057   0000             _timer_c_1       .equ $ffe1        		 ; timer counter 1
0058   0000             _timer_c_2       .equ $ffe2        		 ; timer counter 2
0059   0000             _timer_ctrl      .equ $ffe3        		 ; timer control register
0060   0000             
0061   0000             _stack_begin     .equ $f7ff       		 ; beginning of stack
0062   0000             _global_base     .equ $8000       		 ; base of global variable block
0063   0000             
0064   0000             
0065   0000             boot_origin:     .equ _global_base + 2 + 2
0066   0000             
0067   0000             ide_buffer:      .equ _global_base + 2 + 2 + 512
0068   0000             
0069   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070   0000             ; global system variables
0071   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0072   0000             
0073   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0074   0000             ; external interrupt table
0075   0000             ; highest priority at lowest address
0076   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0077   0000 34 00       .dw int_0
0078   0002 35 00       .dw int_1
0079   0004 36 00       .dw int_2
0080   0006 37 00       .dw int_3
0081   0008 38 00       .dw int_4
0082   000A 39 00       .dw int_5
0083   000C 3A 00       .dw int_6
0084   000E 3B 00       .dw int_7
0085   0010             
0086   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0087   0010             ; reset vector declaration
0088   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0089   0010 C0 01       .dw bios_reset_vector
0090   0012             
0091   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0092   0012             ;; exception vector table
0093   0012             ;; total of 7 entries, starting at address $0012
0094   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095   0012 3C 00       .dw trap_privilege  
0096   0014 52 00       .dw trap_div_zero  
0097   0016 5F 00       .dw undefined_opcode
0098   0018 00 00       .dw 0
0099   001A 00 00       .dw 0
0100   001C 00 00       .dw 0
0101   001E 00 00       .dw 0
0102   0020             
0103   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0104   0020             ;; system call vector table
0105   0020             ;; starts at address $0020
0106   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0107   0020 45 00       .dw trap_breakpoint
0108   0022 60 00       .dw rtc_services        
0109   0024 96 00       .dw uart_services        
0110   0026 EE 00       .dw ide_services  
0111   0028 00 00       .dw 0
0112   002A 00 00       .dw 0
0113   002C 00 00       .dw 0
0114   002E 00 00       .dw 0
0115   0030 00 00       .dw 0
0116   0032 00 00       .dw 0  
0117   0034             
0118   0034             bios_bkpt  .equ 0
0119   0034             bios_rtc   .equ 1
0120   0034             bios_uart  .equ 2
0121   0034             bios_ide   .equ 3
0122   0034             
0123   0034             .export bios_reset_vector
0124   0034             .export ide_buffer
0125   0034             .export boot_origin
0126   0034             .export bios_uart
0127   0034             .export bios_ide
0128   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129   0034             ; external interrupts' code block
0130   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0131   0034             int_0:
0132   0034 06            sysret
0133   0035             int_1:
0134   0035 06            sysret
0135   0036             int_2:
0136   0036 06            sysret
0137   0037             int_3:
0138   0037 06            sysret
0139   0038             int_4:
0140   0038 06            sysret
0141   0039             int_5:
0142   0039 06            sysret
0143   003A             int_6:  
0144   003A 06            sysret
0145   003B             int_7:
0146   003B 06            sysret
0147   003C             
0148   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0149   003C             ; exceptions
0150   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0151   003C             
0152   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0153   003C             ; privilege exception
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             trap_privilege:
0156   003C DA            push d
0157   003D 3B B5 05      mov d, s_priv1
0158   0040 07 82 02      call _puts
0159   0043 E7            pop d
0160   0044                           ; enable interrupts
0161   0044 06            sysret
0162   0045             
0163   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0164   0045             ; breakpoint exception
0165   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0166   0045             trap_breakpoint:
0167   0045 D7            push a
0168   0046 DA            push d
0169   0047 E1            pushf
0170   0048               
0171   0048 3B 9D 05      mov d, s_bkpt
0172   004B 07 82 02      call _puts
0173   004E               
0174   004E EE            popf
0175   004F E7            pop d
0176   0050 E4            pop a
0177   0051                           ; enable interrupts
0178   0051 06            sysret
0179   0052             
0180   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0181   0052             ; divide by zero exception
0182   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0183   0052             trap_div_zero:
0184   0052 D7            push a
0185   0053 DA            push d
0186   0054 E1            pushf
0187   0055               
0188   0055 3B FD 05      mov d, s_divzero
0189   0058 07 82 02      call _puts
0190   005B               
0191   005B EE            popf
0192   005C E7            pop d
0193   005D E4            pop a
0194   005E                           ; enable interrupts
0195   005E 06            sysret
0196   005F             
0197   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0198   005F             ; undefined opcode exception
0199   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0200   005F             undefined_opcode:
0201   005F 06            sysret
0202   0060               
0203   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0204   0060             ; rtc services interrupt
0205   0060             ; rtc i/o bank = ffa0 to ffaf
0206   0060             ; ffa0 to ffa7 is scratch ram
0207   0060             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0208   0060             ; al = 0..6 -> get
0209   0060             ; al = 7..d -> set
0210   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0211   0060             rtc_services:
0212   0060 DB            push al
0213   0061 DA            push d
0214   0062 B9 06         cmp al, 6
0215   0064 D1 79 00      jgu rtc_set
0216   0067             rtc_get:
0217   0067 6A A9         add al, $a9      ; generate rtc address to get to address a9 of clock
0218   0069 22 FF         mov ah, $ff    
0219   006B 3C            mov d, a        ; get to ffa9 + offset
0220   006C F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0221   0070 1E            mov al, [d]      ; get data
0222   0071 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset r bit
0223   0075 23            mov ah, al
0224   0076 E7            pop d
0225   0077 E8            pop al
0226   0078 06            sysret
0227   0079             rtc_set:
0228   0079 DD            push bl
0229   007A 99            mov bl, ah    ; set data aside
0230   007B 6A A2         add al, $a2    ; generate rtc address to get to address a9 of clock
0231   007D 22 FF         mov ah, $ff    
0232   007F 3C            mov d, a    ; get to ffa9 + offset
0233   0080 1B            mov al, bl    ; get data back
0234   0081 F2 A8 FF 80   mov byte[$ffa8], $80  ; set w bit to 1
0235   0085 3E            mov [d], al    ; set data
0236   0086 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset write bit
0237   008A EA            pop bl
0238   008B E7            pop d
0239   008C E8            pop al
0240   008D 06            sysret
0241   008E             
0242   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0243   008E             ; int 4
0244   008E             ; uart services interrupt
0245   008E             ; al = option
0246   008E             ; ah = data
0247   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0248   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0249   008E             uart_serv_tbl:
0250   008E 9A 00         .dw uart_init
0251   0090 B3 00         .dw uart_send
0252   0092 C0 00         .dw uart_receive
0253   0094 CD 00         .dw uart_receive_e
0254   0096             uart_services:
0255   0096 FD 0A 8E 00   jmp [uart_serv_tbl + al]
0256   009A             uart_init:
0257   009A F2 83 FF 8F   mov byte[_uart0_lcr], %10001111      ; 8 data, 2 stop, odd parity, divisor latch = 1, uart address 3 = line control register
0258   009E F2 80 FF 03   mov byte[_uart0_dlab_0], 3      ; baud = 38400
0259   00A2 F2 81 FF 00   mov byte[_uart0_dlab_1], 0      ; divisor latch high byte = 0      
0260   00A6 F2 83 FF 0F   mov byte[_uart0_lcr], %00001111      ; divisor latch = 0, uart address 3 = line control register
0261   00AA F2 81 FF 00   mov byte[_uart0_ier], 0      ; disable all uart interrupts
0262   00AE F2 82 FF 00   mov byte[_uart0_fcr], 0      ; disable fifo
0263   00B2 06            sysret
0264   00B3             uart_send:
0265   00B3 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0266   00B6 93 20         test al, 20h          ; isolate transmitter empty
0267   00B8 C6 B3 00      jz uart_send    
0268   00BB 1A            mov al, ah
0269   00BC 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0270   00BF 06            sysret
0271   00C0             uart_receive:
0272   00C0 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0273   00C3 93 01         test al, 1          ; isolate data ready
0274   00C5 C6 C0 00      jz uart_receive
0275   00C8 1D 80 FF      mov al, [_uart0_data]      ; get character
0276   00CB 23            mov ah, al
0277   00CC 06            sysret
0278   00CD             uart_receive_e:
0279   00CD 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0280   00D0 93 01         test al, 1          ; isolate data ready
0281   00D2 C6 CD 00      jz uart_receive_e
0282   00D5 1D 80 FF      mov al, [_uart0_data]      ; get character
0283   00D8 23            mov ah, al
0284   00D9             uart_receive_e_loop:
0285   00D9 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0286   00DC 93 20         test al, 20h          ; isolate transmitter empty
0287   00DE C6 D9 00      jz uart_receive_e_loop
0288   00E1 1A            mov al, ah
0289   00E2 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0290   00E5 06            sysret
0291   00E6               
0292   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0293   00E6             ; ide services interrupt
0294   00E6             ; al = option
0295   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0296   00E6             ; ide read/write sector
0297   00E6             ; 512 bytes
0298   00E6             ; user buffer pointer in d
0299   00E6             ; kernel buffer pointer = ide_buffer
0300   00E6             ; ah = number of sectors
0301   00E6             ; cb = lba bytes 3..0
0302   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0303   00E6             ide_serv_tbl:
0304   00E6 F2 00         .dw ide_reset
0305   00E8 06 01         .dw ide_sleep
0306   00EA 15 01         .dw ide_read_sect
0307   00EC 36 01         .dw ide_write_sect
0308   00EE             ide_services:
0309   00EE FD 0A E6 00   jmp [ide_serv_tbl + al]  
0310   00F2             ide_reset:      
0311   00F2 F2 D7 FF 04   mov byte[_ide_r7], 4    ; reset ide
0312   00F6 07 87 01      call ide_wait        ; wait for ide ready             
0313   00F9 F2 D6 FF E0   mov byte[_ide_r6], $e0    ; lba3= 0, master, mode= lba        
0314   00FD F2 D1 FF 01   mov byte[_ide_r1], 1    ; 8-bit transfers      
0315   0101 F2 D7 FF EF   mov byte[_ide_r7], $ef    ; set feature command
0316   0105 06            sysret
0317   0106             ide_sleep:
0318   0106 07 87 01      call ide_wait          ; wait for ide ready             
0319   0109 F2 D6 FF 40   mov byte [_ide_r6], %01000000  ; lba[3:0](reserved), bit 6=1
0320   010D F2 D7 FF E6   mov byte [_ide_r7], $e6    ; sleep command
0321   0111 07 87 01      call ide_wait          ; wait for ide ready
0322   0114 06            sysret
0323   0115             ide_read_sect:
0324   0115 1A            mov al, ah
0325   0116 24            mov ah, bl
0326   0117 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0327   011A 1C            mov al, bh
0328   011B 3D D4 FF      mov [_ide_r4], al
0329   011E 12            mov a, c
0330   011F 3D D5 FF      mov [_ide_r5], al
0331   0122 1A            mov al, ah
0332   0123 87 0F         and al, %00001111
0333   0125 8B E0         or al, %11100000      ; mode lba, master
0334   0127 3D D6 FF      mov [_ide_r6], al
0335   012A 07 87 01      call ide_wait
0336   012D 19 20         mov al, 20h
0337   012F 3D D7 FF      mov [_ide_r7], al      ; read sector cmd
0338   0132 07 57 01      call ide_read  
0339   0135 06            sysret
0340   0136             ide_write_sect:
0341   0136 1A            mov al, ah
0342   0137 24            mov ah, bl
0343   0138 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0344   013B 1C            mov al, bh
0345   013C 3D D4 FF      mov [_ide_r4], al
0346   013F 12            mov a, c
0347   0140 3D D5 FF      mov [_ide_r5], al
0348   0143 1A            mov al, ah
0349   0144 87 0F         and al, %00001111
0350   0146 8B E0         or al, %11100000      ; mode lba, master
0351   0148 3D D6 FF      mov [_ide_r6], al
0352   014B 07 87 01      call ide_wait
0353   014E 19 30         mov al, 30h
0354   0150 3D D7 FF      mov [_ide_r7], al      ; write sector cmd
0355   0153 07 6F 01      call ide_write      
0356   0156 06            sysret
0357   0157             
0358   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0359   0157             ; read ide data
0360   0157             ; pointer in d
0361   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0362   0157             ide_read:
0363   0157 DB            push al
0364   0158 DA            push d
0365   0159             ide_read_loop:
0366   0159 07 87 01      call ide_wait
0367   015C 1D D7 FF      mov al, [_ide_r7]
0368   015F 87 08         and al, %00001000      ; drq flag
0369   0161 C6 6C 01      jz ide_read_end
0370   0164 1D D0 FF      mov al, [_ide_r0]
0371   0167 3E            mov [d], al
0372   0168 79            inc d
0373   0169 0A 59 01      jmp ide_read_loop
0374   016C             ide_read_end:
0375   016C E7            pop d
0376   016D E8            pop al
0377   016E 09            ret
0378   016F             
0379   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0380   016F             ; write ide data
0381   016F             ; data pointer in d
0382   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0383   016F             ide_write:
0384   016F DB            push al
0385   0170 DA            push d
0386   0171             ide_write_loop:
0387   0171 07 87 01      call ide_wait
0388   0174 1D D7 FF      mov al, [_ide_r7]
0389   0177 87 08         and al, %00001000      ; drq flag
0390   0179 C6 84 01      jz ide_write_end
0391   017C 1E            mov al, [d]
0392   017D 3D D0 FF      mov [_ide_r0], al
0393   0180 79            inc d 
0394   0181 0A 71 01      jmp ide_write_loop
0395   0184             ide_write_end:
0396   0184 E7            pop d
0397   0185 E8            pop al
0398   0186 09            ret
0399   0187             
0400   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0401   0187             ; wait for ide to be ready
0402   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403   0187             ide_wait:
0404   0187 1D D7 FF      mov al, [_ide_r7]  
0405   018A 87 80         and al, 80h        ; busy flag
0406   018C C7 87 01      jnz ide_wait
0407   018F 09            ret
0408   0190             
0409   0190             ; ************************************************************
0410   0190             ; get hex file
0411   0190             ; di = destination address
0412   0190             ; return length in bytes in c
0413   0190             ; ************************************************************
0414   0190             _load_hex:
0415   0190 D2            push bp
0416   0191 9B            mov bp, sp
0417   0192 D7            push a
0418   0193 D8            push b
0419   0194 DA            push d
0420   0195 E2            push si
0421   0196 E3            push di
0422   0197 52 00 60      sub sp, $6000        ; string data block
0423   019A 38 00 00      mov c, 0
0424   019D               
0425   019D 48            mov a, sp
0426   019E 77            inc a
0427   019F 3C            mov d, a        ; start of string data block
0428   01A0 07 F5 02      call _getse        ; get program string
0429   01A3 4D            mov si, a
0430   01A4             
0431   01A4             __load_hex_loop:
0432   01A4 F6            lodsb          ; load from [SI] to AL
0433   01A5 B9 00         cmp al, 0        ; check if ASCII 0
0434   01A7 C6 B5 01      jz __load_hex_ret
0435   01AA 36            mov bh, al
0436   01AB F6            lodsb
0437   01AC 2F            mov bl, al
0438   01AD 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0439   01B0 F7            stosb          ; store AL to [DI]
0440   01B1 78            inc c
0441   01B2 0A A4 01      jmp __load_hex_loop
0442   01B5             __load_hex_ret:
0443   01B5 51 00 60      add sp, $6000
0444   01B8 F0            pop di
0445   01B9 EF            pop si
0446   01BA E7            pop d
0447   01BB E5            pop b
0448   01BC E4            pop a
0449   01BD 9C            mov sp, bp
0450   01BE F1            pop bp
0451   01BF 09            ret
0452   01C0               
0453   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0454   01C0             ; bios entry point
0455   01C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0456   01C0             bios_reset_vector:
0457   01C0 19 00         mov al, %00000000        ; interrupts = off, mode = sup, paging = off, halt-flag = off, display_load = on
0458   01C2 0D            stostat
0459   01C3               
0460   01C3 10 FF F7      mov a, _stack_begin
0461   01C6 47            mov sp, a
0462   01C7 49            mov bp, a      ; setup stack and frame
0463   01C8             
0464   01C8 19 00         mov al, 0
0465   01CA 05 02         syscall bios_uart
0466   01CC               
0467   01CC 3B EA 03      mov d, s_welcome
0468   01CF 07 82 02      call _puts          ; print welcome msg
0469   01D2             
0470   01D2 07 F2 01      call bios_peripherals_setup
0471   01D5               
0472   01D5 3B 3D 04      mov d, s_boot1
0473   01D8 07 82 02      call _puts
0474   01DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0475   01DB 38 00 00      mov c, 0
0476   01DE 26 00 00      mov b, 0          ; start at disk sector 0
0477   01E1 3B 04 80      mov d, boot_origin    ; we read into the bios ide buffer
0478   01E4 10 02 01      mov a, $0102        ; disk read, 1 sector
0479   01E7 05 03         syscall bios_ide      ; read sector  
0480   01E9               
0481   01E9 3B 53 04      mov d, s_boot2
0482   01EC 07 82 02      call _puts
0483   01EF             
0484   01EF 0A 04 80      jmp boot_origin
0485   01F2             
0486   01F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0487   01F2             
0488   01F2             bios_peripherals_setup:
0489   01F2 3B AD 04      mov d, s_init
0490   01F5 07 82 02      call _puts
0491   01F8               
0492   01F8 3B 66 04      mov d, s_bios3
0493   01FB 07 82 02      call _puts
0494   01FE 19 00         mov al, 0            ; reset ide
0495   0200 05 03         syscall bios_ide  
0496   0202               
0497   0202 3B 7C 04      mov d, s_bios4
0498   0205 07 82 02      call _puts
0499   0208               
0500   0208 19 30         mov al, %00110000          ; counter 0, load both bytes, mode 0, binary
0501   020A 3D E3 FF      mov [_timer_ctrl], al
0502   020D 19 FF         mov al, $ff
0503   020F 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 low byte
0504   0212 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 high byte
0505   0215               
0506   0215 3B 92 04      mov d, s_bios5
0507   0218 07 82 02      call _puts
0508   021B 19 80         mov al, $80
0509   021D 3D B3 FF      mov [_bios_post_ctrl], al      ; set pio_a to output mode
0510   0220 19 00         mov al, 0
0511   0222 3D B0 FF      mov [_7seg_display], al      ; post code = 00
0512   0225 09            ret
0513   0226             
0514   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0515   0226             ; print 16bit hex integer
0516   0226             ; integer value in reg b
0517   0226             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0518   0226             print_u16x:
0519   0226 E1            pushf
0520   0227 D7            push a
0521   0228 D8            push b
0522   0229 DD            push bl
0523   022A 30            mov bl, bh
0524   022B 07 70 03      call _itoa        ; convert bh to char in a
0525   022E 2F            mov bl, al        ; save al  
0526   022F 19 01         mov al, 1
0527   0231 05 02         syscall bios_uart        ; display ah
0528   0233 24            mov ah, bl        ; retrieve al
0529   0234 19 01         mov al, 1
0530   0236 05 02         syscall bios_uart        ; display al
0531   0238             
0532   0238 EA            pop bl
0533   0239 07 70 03      call _itoa        ; convert bh to char in a
0534   023C 2F            mov bl, al        ; save al
0535   023D 19 01         mov al, 1
0536   023F 05 02         syscall bios_uart        ; display ah
0537   0241 24            mov ah, bl        ; retrieve al
0538   0242 19 01         mov al, 1
0539   0244 05 02         syscall bios_uart        ; display al
0540   0246             
0541   0246 E5            pop b
0542   0247 E4            pop a
0543   0248 EE            popf
0544   0249 09            ret
0545   024A             
0546   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0547   024A             ; input 16bit hex integer
0548   024A             ; read 16bit integer into a
0549   024A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0550   024A             scan_u16x:
0551   024A F8 10 00      enter 16
0552   024D E1            pushf
0553   024E D8            push b
0554   024F DA            push d
0555   0250             
0556   0250 FA F1 FF      lea d, [bp + -15]
0557   0253 07 F5 02      call _getse        ; get number
0558   0256             
0559   0256 32            mov bl, [d]
0560   0257 37            mov bh, bl
0561   0258 33 01 00      mov bl, [d + 1]
0562   025B 07 5E 03      call _atoi        ; convert to int in al
0563   025E 23            mov ah, al        ; move to ah
0564   025F               
0565   025F 33 02 00      mov bl, [d + 2]
0566   0262 37            mov bh, bl
0567   0263 33 03 00      mov bl, [d + 3]
0568   0266 07 5E 03      call _atoi        ; convert to int in al
0569   0269               
0570   0269 E7            pop d  
0571   026A E5            pop b
0572   026B EE            popf
0573   026C F9            leave
0574   026D 09            ret
0575   026E             
0576   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0577   026E             ; print 8bit hex integer
0578   026E             ; byte value in reg bl
0579   026E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0580   026E             xput_u8:
0581   026E D7            push a
0582   026F DD            push bl
0583   0270 E1            pushf
0584   0271             
0585   0271 07 70 03      call _itoa          ; convert bl to char in a
0586   0274 2F            mov bl, al          ; save al  
0587   0275 19 01         mov al, 1
0588   0277 05 02         syscall bios_uart        ; display ah
0589   0279 24            mov ah, bl          ; retrieve al
0590   027A 19 01         mov al, 1
0591   027C 05 02         syscall bios_uart        ; display al
0592   027E               
0593   027E EE            popf
0594   027F EA            pop bl
0595   0280 E4            pop a
0596   0281 09            ret
0597   0282             
0598   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0599   0282             ; print null terminated string
0600   0282             ; pointer in d
0601   0282             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0602   0282             _puts:
0603   0282 D7            push a
0604   0283 DA            push d
0605   0284 E1            pushf
0606   0285             _puts_l1:
0607   0285 1E            mov al, [d]
0608   0286 B9 00         cmp al, 0
0609   0288 C6 9B 02      jz _puts_end
0610   028B             _puts_l2:
0611   028B 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0612   028E 93 20         test al, $20          ; isolate transmitter empty
0613   0290 C6 8B 02      jz _puts_l2    
0614   0293 1E            mov al, [d]
0615   0294 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0616   0297 79            inc d  
0617   0298 0A 85 02      jmp _puts_l1
0618   029B             _puts_end:
0619   029B EE            popf
0620   029C E7            pop d
0621   029D E4            pop a
0622   029E 09            ret
0623   029F             
0624   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0625   029F             ; _putchar
0626   029F             ; char in ah
0627   029F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0628   029F             _putchar:
0629   029F D7            push a
0630   02A0 E1            pushf
0631   02A1             _putchar_l1:
0632   02A1 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0633   02A4 93 20         test al, 20h          ; isolate transmitter empty
0634   02A6 C6 A1 02      jz _putchar_l1    
0635   02A9 1A            mov al, ah
0636   02AA 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0637   02AD EE            popf
0638   02AE E4            pop a
0639   02AF 09            ret
0640   02B0               
0641   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0642   02B0             ;; input a string with no echo
0643   02B0             ;; terminates with null
0644   02B0             ;; pointer in d
0645   02B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0646   02B0             _gets:
0647   02B0 E1            pushf
0648   02B1 D7            push a
0649   02B2 DA            push d
0650   02B3             _gets_loop:
0651   02B3 19 02         mov al, 2
0652   02B5 05 02         syscall bios_uart      ; receive in ah
0653   02B7 76 0A         cmp ah, 0ah        ; lf
0654   02B9 C6 EE 02      je _gets_end
0655   02BC 76 0D         cmp ah, 0dh        ; cr
0656   02BE C6 EE 02      je _gets_end
0657   02C1 76 5C         cmp ah, $5c        ; '\\'
0658   02C3 C6 CC 02      je _gets_escape
0659   02C6 1A            mov al, ah
0660   02C7 3E            mov [d], al
0661   02C8 79            inc d
0662   02C9 0A B3 02      jmp _gets_loop
0663   02CC             _gets_escape:
0664   02CC 19 02         mov al, 2
0665   02CE 05 02         syscall bios_uart      ; receive in ah
0666   02D0 76 6E         cmp ah, 'n'
0667   02D2 C6 E0 02      je _gets_lf
0668   02D5 76 72         cmp ah, 'r'
0669   02D7 C6 E7 02      je _gets_cr
0670   02DA 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0671   02DB 3E            mov [d], al
0672   02DC 79            inc d
0673   02DD 0A B3 02      jmp _gets_loop
0674   02E0             _gets_lf:
0675   02E0 19 0A         mov al, $0a
0676   02E2 3E            mov [d], al
0677   02E3 79            inc d
0678   02E4 0A B3 02      jmp _gets_loop
0679   02E7             _gets_cr:
0680   02E7 19 0D         mov al, $0d
0681   02E9 3E            mov [d], al
0682   02EA 79            inc d
0683   02EB 0A B3 02      jmp _gets_loop
0684   02EE             _gets_end:
0685   02EE 19 00         mov al, 0
0686   02F0 3E            mov [d], al        ; terminate string
0687   02F1 E7            pop d
0688   02F2 E4            pop a
0689   02F3 EE            popf
0690   02F4 09            ret
0691   02F5             
0692   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0693   02F5             ;; INPUT A STRING with echo
0694   02F5             ;; terminates with null
0695   02F5             ;; pointer in D
0696   02F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0697   02F5             _getse:
0698   02F5 E1            pushf
0699   02F6 D7            push a
0700   02F7 DA            push d
0701   02F8             _getse_loop:
0702   02F8 19 03         mov al, 3
0703   02FA 05 02         syscall bios_uart      ; receive in AH
0704   02FC 76 0A         cmp ah, 0Ah        ; LF
0705   02FE C6 33 03      je _getse_end
0706   0301 76 0D         cmp ah, 0Dh        ; CR
0707   0303 C6 33 03      je _getse_end
0708   0306 76 5C         cmp ah, $5C        ; '\\'
0709   0308 C6 11 03      je _getse_escape
0710   030B 1A            mov al, ah
0711   030C 3E            mov [d], al
0712   030D 79            inc d
0713   030E 0A F8 02      jmp _getse_loop
0714   0311             _getse_escape:
0715   0311 19 03         mov al, 3
0716   0313 05 02         syscall bios_uart      ; receive in AH
0717   0315 76 6E         cmp ah, 'n'
0718   0317 C6 25 03      je _getse_LF
0719   031A 76 72         cmp ah, 'r'
0720   031C C6 2C 03      je _getse_CR
0721   031F 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0722   0320 3E            mov [d], al
0723   0321 79            inc d
0724   0322 0A F8 02      jmp _getse_loop
0725   0325             _getse_LF:
0726   0325 19 0A         mov al, $0A
0727   0327 3E            mov [d], al
0728   0328 79            inc d
0729   0329 0A F8 02      jmp _getse_loop
0730   032C             _getse_CR:
0731   032C 19 0D         mov al, $0D
0732   032E 3E            mov [d], al
0733   032F 79            inc d
0734   0330 0A F8 02      jmp _getse_loop
0735   0333             _getse_end:
0736   0333 19 00         mov al, 0
0737   0335 3E            mov [d], al        ; terminate string
0738   0336 E7            pop d
0739   0337 E4            pop a
0740   0338 EE            popf
0741   0339 09            ret
0742   033A             
0743   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0744   033A             ; PRINT NEW LINE
0745   033A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0746   033A             put_nl:
0747   033A E1            pushf
0748   033B D7            push a
0749   033C 10 01 0A      mov a, $0A01
0750   033F 05 02         syscall bios_uart
0751   0341 10 01 0D      mov a, $0D01
0752   0344 05 02         syscall bios_uart
0753   0346 E4            pop a
0754   0347 EE            popf
0755   0348 09            ret
0756   0349             
0757   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0758   0349             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0759   0349             ; ASCII in BL
0760   0349             ; result in AL
0761   0349             ; ascii for F = 0100 0110
0762   0349             ; ascii for 9 = 0011 1001
0763   0349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0764   0349             hex_ascii_encode:
0765   0349 1B            mov al, bl  
0766   034A 93 40         test al, 40h        ; test if letter or number
0767   034C C7 52 03      jnz hex_letter
0768   034F 87 0F         and al, 0Fh        ; get number
0769   0351 09            ret
0770   0352             hex_letter:
0771   0352 DC            push ah
0772   0353 24            mov ah, bl
0773   0354 07 AD 03      call _to_upper
0774   0357 1A            mov al, ah  
0775   0358 87 0F         and al, 0Fh        ; get letter
0776   035A 6A 09         add al, 9
0777   035C E9            pop ah
0778   035D 09            ret
0779   035E             
0780   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0781   035E             ; ATOI
0782   035E             ; 2 letter hex string in B
0783   035E             ; 8bit integer returned in AL
0784   035E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0785   035E             _atoi:
0786   035E E1            pushf
0787   035F D8            push b
0788   0360                 
0789   0360 07 49 03      call hex_ascii_encode      ; convert BL to 4bit code in AL
0790   0363 30            mov bl, bh
0791   0364 DB            push al          ; save a
0792   0365 07 49 03      call hex_ascii_encode
0793   0368 EA            pop bl  
0794   0369 FD 9E 04      shl al, 4
0795   036C 8C            or al, bl
0796   036D               
0797   036D E5            pop b
0798   036E EE            popf
0799   036F 09            ret  
0800   0370             
0801   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0802   0370             ; ITOA
0803   0370             ; 8bit value in BL
0804   0370             ; 2 byte ASCII result in A
0805   0370             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0806   0370             _itoa:
0807   0370 E1            pushf
0808   0371 DA            push d
0809   0372 DE            push bh
0810   0373 DD            push bl
0811   0374             
0812   0374 A7 00         mov bh, 0
0813   0376               
0814   0376 FD 87 0F      and bl, $0F
0815   0379 3B 8D 05      mov d, s_hex_digits
0816   037C 5A            add d, b
0817   037D 1E            mov al, [d]        ; get ASCII
0818   037E EA            pop bl
0819   037F 52 01 00      sub sp, 1        ; push bl back
0820   0382 DB            push al
0821   0383               
0822   0383 FD 87 F0      and bl, $F0
0823   0386 FD A4 04      shr bl, 4
0824   0389 3B 8D 05      mov d, s_hex_digits
0825   038C 5A            add d, b
0826   038D 1E            mov al, [d]        ; get ASCII
0827   038E             
0828   038E 23            mov ah, al
0829   038F E8            pop al  
0830   0390               
0831   0390 EA            pop bl
0832   0391 EB            pop bh
0833   0392 E7            pop d
0834   0393 EE            popf
0835   0394 09            ret
0836   0395             
0837   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0838   0395             ; STRCMP
0839   0395             ; compare two strings
0840   0395             ; str1 in SI
0841   0395             ; str2 in DI
0842   0395             ; changes: AL SI DI
0843   0395             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0844   0395             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0845   0395             _strcmp:
0846   0395             _strcmp_loop:
0847   0395 F3            cmpsb          ; compare a byte of the strings
0848   0396 C7 A2 03      jne _strcmp_ret
0849   0399 FB FF FF      lea d, [si + -1]
0850   039C 1E            mov al, [d]
0851   039D B9 00         cmp al, 0        ; check if at end of string (null)
0852   039F C7 95 03      jne _strcmp_loop        ; equal chars but not at end
0853   03A2             _strcmp_ret:        
0854   03A2 09            ret
0855   03A3             
0856   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0857   03A3             ; TO LOWER
0858   03A3             ; input in AL
0859   03A3             ; output in AL
0860   03A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0861   03A3             _to_lower:
0862   03A3 E1            pushf
0863   03A4 B9 5A         cmp al, 'Z'
0864   03A6 D1 AB 03      jgu _to_lower_ret
0865   03A9 6A 20         add al, 20h        ; convert to lower case
0866   03AB             _to_lower_ret:
0867   03AB EE            popf
0868   03AC 09            ret
0869   03AD             
0870   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0871   03AD             ; TO UPPER
0872   03AD             ; input in AL
0873   03AD             ; output in AL
0874   03AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0875   03AD             _to_upper:
0876   03AD E1            pushf
0877   03AE B9 61         cmp al, 'a'
0878   03B0 C8 B5 03      jlu _to_upper_ret
0879   03B3 6F 20         sub al, 20h        ; convert to upper case
0880   03B5             _to_upper_ret:
0881   03B5 EE            popf
0882   03B6 09            ret
0883   03B7             
0884   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0885   03B7             ; PRINT DECIMAL INTEGER
0886   03B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0887   03B7             print_decimal:
0888   03B7 09            ret
0889   03B8             
0890   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0891   03B8             ; GET HEX FILE
0892   03B8             ; di = destination address
0893   03B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0894   03B8             load_hex:
0895   03B8 F8 00 60      enter $6000
0896   03BB               
0897   03BB 10 00 90      mov a, $9000          ; destination
0898   03BE 4F            mov di, a  
0899   03BF                         ; string data block
0900   03BF FA 01 A0      lea d, [bp + -24575]      ; start of string data block
0901   03C2 07 F5 02      call _getse          ; get program string
0902   03C5 13            mov a, d
0903   03C6 4D            mov si, a
0904   03C7             load_hex_loop:
0905   03C7 F6            lodsb          ; load from [SI] to AL
0906   03C8 B9 00         cmp al, 0        ; check if ASCII 0
0907   03CA C6 D7 03      jz load_hex_ret
0908   03CD 36            mov bh, al
0909   03CE F6            lodsb
0910   03CF 2F            mov bl, al
0911   03D0 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0912   03D3 F7            stosb          ; store AL to [DI]
0913   03D4 0A C7 03      jmp load_hex_loop
0914   03D7             load_hex_ret:
0915   03D7 F9            leave
0916   03D8 09            ret
0917   03D9             
0918   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0919   03D9             ; HEX STRING TO BINARY
0920   03D9             ; di = destination address
0921   03D9             ; si = source
0922   03D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0923   03D9             _hex_to_int:
0924   03D9             _hex_to_int_L1:
0925   03D9 F6            lodsb          ; load from [SI] to AL
0926   03DA B9 00         cmp al, 0        ; check if ASCII 0
0927   03DC C6 E9 03      jz _hex_to_int_ret
0928   03DF 36            mov bh, al
0929   03E0 F6            lodsb
0930   03E1 2F            mov bl, al
0931   03E2 07 5E 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0932   03E5 F7            stosb          ; store AL to [DI]
0933   03E6 0A D9 03      jmp _hex_to_int_L1
0934   03E9             _hex_to_int_ret:
0935   03E9 09            ret  
0936   03EA             
0937   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0938   03EA             ; data block
0939   03EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0940   03EA 0A 0A 0D 53 s_welcome:      .db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0940   03EE 6F 6C 2D 31 
0940   03F2 20 37 34 48 
0940   03F6 43 20 48 6F 
0940   03FA 6D 65 62 72 
0940   03FE 65 77 43 50 
0940   0402 55 20 4D 69 
0940   0406 6E 69 43 6F 
0940   040A 6D 70 75 74 
0940   040E 65 72 0A 
0941   0411 42 49 4F 53                 .db "BIOS Version 0.1\n\n\r"
0941   0415 20 56 65 72 
0941   0419 73 69 6F 6E 
0941   041D 20 30 2E 31 
0941   0421 0A 0A 0D 
0942   0424 74 65 72 6D                 .db "terminal-1 initialized\n\r", 0
0942   0428 69 6E 61 6C 
0942   042C 2D 31 20 69 
0942   0430 6E 69 74 69 
0942   0434 61 6C 69 7A 
0942   0438 65 64 0A 0D 
0942   043C 00 
0943   043D                     
0944   043D 72 65 61 64 s_boot1:        .db "reading boot sector\n\r", 0
0944   0441 69 6E 67 20 
0944   0445 62 6F 6F 74 
0944   0449 20 73 65 63 
0944   044D 74 6F 72 0A 
0944   0451 0D 00 
0945   0453 62 6F 6F 74 s_boot2:        .db "boot-sector read\n\r", 0
0945   0457 2D 73 65 63 
0945   045B 74 6F 72 20 
0945   045F 72 65 61 64 
0945   0463 0A 0D 00 
0946   0466                     
0947   0466 72 65 73 65 s_bios3:        .db "resetting IDE-drive\n\r", 0
0947   046A 74 74 69 6E 
0947   046E 67 20 49 44 
0947   0472 45 2D 64 72 
0947   0476 69 76 65 0A 
0947   047A 0D 00 
0948   047C 63 6F 6E 66 s_bios4:        .db "configuring Timer-1\n\r", 0
0948   0480 69 67 75 72 
0948   0484 69 6E 67 20 
0948   0488 54 69 6D 65 
0948   048C 72 2D 31 0A 
0948   0490 0D 00 
0949   0492 50 49 4F 2D s_bios5:        .db "PIO-A set to output mode\n\r", 0
0949   0496 41 20 73 65 
0949   049A 74 20 74 6F 
0949   049E 20 6F 75 74 
0949   04A2 70 75 74 20 
0949   04A6 6D 6F 64 65 
0949   04AA 0A 0D 00 
0950   04AD             
0951   04AD 65 6E 74 65 s_init:         .db "entering real-mode [supervisor on; paging off]\n\r"
0951   04B1 72 69 6E 67 
0951   04B5 20 72 65 61 
0951   04B9 6C 2D 6D 6F 
0951   04BD 64 65 20 5B 
0951   04C1 73 75 70 65 
0951   04C5 72 76 69 73 
0951   04C9 6F 72 20 6F 
0951   04CD 6E 3B 20 70 
0951   04D1 61 67 69 6E 
0951   04D5 67 20 6F 66 
0951   04D9 66 5D 0A 0D 
0952   04DD 69 6E 74 65                 .db "interrupts disabled\n\r"
0952   04E1 72 72 75 70 
0952   04E5 74 73 20 64 
0952   04E9 69 73 61 62 
0952   04ED 6C 65 64 0A 
0952   04F1 0D 
0953   04F2 64 69 73 70                 .db "display register loading disabled\n\r", 0
0953   04F6 6C 61 79 20 
0953   04FA 72 65 67 69 
0953   04FE 73 74 65 72 
0953   0502 20 6C 6F 61 
0953   0506 64 69 6E 67 
0953   050A 20 64 69 73 
0953   050E 61 62 6C 65 
0953   0512 64 0A 0D 00 
0954   0516             
0955   0516 0A          s_nl_2:         .db "\n"
0956   0517 0A 0D 00    s_nl_1:         .db "\n\r", 0
0957   051A             
0958   051A 64 61 74 61 s_enter_prog:   .db "data: ", 0
0958   051E 3A 20 00 
0959   0521 6F 72 69 67 s_origin_addr:  .db "origin address: ", 0
0959   0525 69 6E 20 61 
0959   0529 64 64 72 65 
0959   052D 73 73 3A 20 
0959   0531 00 
0960   0532             
0961   0532 53 65 72 69 s_ide_serial:   .db "Serial: ", 0
0961   0536 61 6C 3A 20 
0961   053A 00 
0962   053B 46 69 72 6D s_ide_firm:     .db "Firmware: ", 0
0962   053F 77 61 72 65 
0962   0543 3A 20 00 
0963   0546 4D 6F 64 65 s_ide_model:    .db "Model: ", 0
0963   054A 6C 3A 20 00 
0964   054E 4E 75 6D 62 s_sectors:      .db "Number of sectors: ", 0
0964   0552 65 72 20 6F 
0964   0556 66 20 73 65 
0964   055A 63 74 6F 72 
0964   055E 73 3A 20 00 
0965   0562 4C 42 41 20 s_lba0:         .db "LBA 0: ", 0
0965   0566 30 3A 20 00 
0966   056A 4C 42 41 20 s_lba1:         .db "LBA 1: ", 0
0966   056E 31 3A 20 00 
0967   0572 4C 42 41 20 s_lba2:         .db "LBA 2: ", 0
0967   0576 32 3A 20 00 
0968   057A 4C 42 41 20 s_lba3:         .db "LBA 3: ", 0
0968   057E 33 3A 20 00 
0969   0582 0A 0D 45 72 s_error:        .db "\n\rError.\n\r", 0
0969   0586 72 6F 72 2E 
0969   058A 0A 0D 00 
0970   058D                             
0971   058D 30 31 32 33 s_hex_digits:   .db "0123456789ABCDEF"
0971   0591 34 35 36 37 
0971   0595 38 39 41 42 
0971   0599 43 44 45 46 
0972   059D 74 68 69 73 s_bkpt:         .db "this is the breakpoint.", 0
0972   05A1 20 69 73 20 
0972   05A5 74 68 65 20 
0972   05A9 62 72 65 61 
0972   05AD 6B 70 6F 69 
0972   05B1 6E 74 2E 00 
0973   05B5                             
0974   05B5 0A 0A 0D 73 s_priv1:        .db "\n\n\rsoftware failure: privilege exception "
0974   05B9 6F 66 74 77 
0974   05BD 61 72 65 20 
0974   05C1 66 61 69 6C 
0974   05C5 75 72 65 3A 
0974   05C9 20 70 72 69 
0974   05CD 76 69 6C 65 
0974   05D1 67 65 20 65 
0974   05D5 78 63 65 70 
0974   05D9 74 69 6F 6E 
0974   05DD 20 
0975   05DE 70 72 65 73                 .db "press any key to continue...\n\r", 0
0975   05E2 73 20 61 6E 
0975   05E6 79 20 6B 65 
0975   05EA 79 20 74 6F 
0975   05EE 20 63 6F 6E 
0975   05F2 74 69 6E 75 
0975   05F6 65 2E 2E 2E 
0975   05FA 0A 0D 00 
0976   05FD 0A 0D 65 78 s_divzero:      .db "\n\rexception: zero division\n\r", 0
0976   0601 63 65 70 74 
0976   0605 69 6F 6E 3A 
0976   0609 20 7A 65 72 
0976   060D 6F 20 64 69 
0976   0611 76 69 73 69 
0976   0615 6F 6E 0A 0D 
0976   0619 00 
0977   061A             
0978   061A             .end
tasm: Number of errors = 0
