0001   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002   0000             ; 74 series minicomputer bios version 1.0
0003   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004   0000             
0005   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006   0000             ; memory map
0007   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008   0000             ; 0000    rom begin
0009   0000             ; ....
0010   0000             ; 7fff    rom end
0011   0000             ;
0012   0000             ; 8000    ram begin
0013   0000             ; ....
0014   0000             ; f7ff    stack root
0015   0000             
0016   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0017   0000             ; i/o map
0018   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0019   0000             ; ff80    uart 0    (16550)
0020   0000             ; ff90    uart 1    (16550)
0021   0000             ; ffa0    rtc       (m48t02)
0022   0000             ; ffb0    pio 0     (8255)
0023   0000             ; ffc0    pio 1     (8255)
0024   0000             ; ffd0    ide       (compact flash / pata)
0025   0000             ; ffe0    timer     (8253)
0026   0000             ; fff0    bios configuration nv-ram store area
0027   0000             
0028   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029   0000             ; system constants / equations
0030   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031   0000             _uart0_data      .equ $ff80        		 ; data
0032   0000             _uart0_dlab_0    .equ $ff80        		 ; divisor latch low byte
0033   0000             _uart0_dlab_1    .equ $ff81        		 ; divisor latch high byte
0034   0000             _uart0_ier       .equ $ff81        		 ; interrupt enable register
0035   0000             _uart0_fcr       .equ $ff82        		 ; fifo control register
0036   0000             _uart0_lcr       .equ $ff83        		 ; line control register
0037   0000             _uart0_lsr       .equ $ff85        		 ; line status register
0038   0000             
0039   0000             _ide_base        .equ $ffd0        		 ; ide base
0040   0000             _ide_r0          .equ _ide_base + 0    ; data port
0041   0000             _ide_r1          .equ _ide_base + 1    ; read: error code, write: feature
0042   0000             _ide_r2          .equ _ide_base + 2    ; number of sectors to transfer
0043   0000             _ide_r3          .equ _ide_base + 3    ; sector address lba 0 [0:7]
0044   0000             _ide_r4          .equ _ide_base + 4    ; sector address lba 1 [8:15]
0045   0000             _ide_r5          .equ _ide_base + 5    ; sector address lba 2 [16:23]
0046   0000             _ide_r6          .equ _ide_base + 6    ; sector address lba 3 [24:27 (lsb)]
0047   0000             _ide_r7          .equ _ide_base + 7    ; read: status, write: command
0048   0000             
0049   0000             _7seg_display    .equ $ffb0        		 ; bios post code hex display (2 digits)
0050   0000             _bios_post_ctrl  .equ $ffb3        		 ; bios post display control register, 80h = as output
0051   0000             _pio_a           .equ $ffb0    
0052   0000             _pio_b           .equ $ffb1
0053   0000             _pio_c           .equ $ffb2
0054   0000             _pio_control     .equ $ffb3        		 ; pio control port
0055   0000             
0056   0000             _timer_c_0       .equ $ffe0        		 ; timer counter 0
0057   0000             _timer_c_1       .equ $ffe1        		 ; timer counter 1
0058   0000             _timer_c_2       .equ $ffe2        		 ; timer counter 2
0059   0000             _timer_ctrl      .equ $ffe3        		 ; timer control register
0060   0000             
0061   0000             _stack_begin     .equ $f7ff       		 ; beginning of stack
0062   0000             _global_base     .equ $8000       		 ; base of global variable block
0063   0000             
0064   0000             
0065   0000             boot_origin:     .equ _global_base + 2 + 2
0066   0000             
0067   0000             ide_buffer:      .equ _global_base + 2 + 2 + 1024
0068   0000             
0069   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0070   0000             ; global system variables
0071   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0072   0000             
0073   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0074   0000             ; external interrupt table
0075   0000             ; highest priority at lowest address
0076   0000             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0077   0000 34 00       .dw int_0
0078   0002 35 00       .dw int_1
0079   0004 36 00       .dw int_2
0080   0006 37 00       .dw int_3
0081   0008 38 00       .dw int_4
0082   000A 39 00       .dw int_5
0083   000C 3A 00       .dw int_6
0084   000E 3B 00       .dw int_7
0085   0010             
0086   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0087   0010             ; reset vector declaration
0088   0010             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0089   0010 90 01       .dw bios_reset_vector
0090   0012             
0091   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0092   0012             ;; exception vector table
0093   0012             ;; total of 7 entries, starting at address $0012
0094   0012             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0095   0012 3C 00       .dw trap_privilege  
0096   0014 52 00       .dw trap_div_zero  
0097   0016 5F 00       .dw undefined_opcode
0098   0018 00 00       .dw 0
0099   001A 00 00       .dw 0
0100   001C 00 00       .dw 0
0101   001E 00 00       .dw 0
0102   0020             
0103   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0104   0020             ;; system call vector table
0105   0020             ;; starts at address $0020
0106   0020             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0107   0020 45 00       .dw trap_breakpoint
0108   0022 60 00       .dw rtc_services        
0109   0024 96 00       .dw uart_services        
0110   0026 EE 00       .dw ide_services  
0111   0028 00 00       .dw 0
0112   002A 00 00       .dw 0
0113   002C 00 00       .dw 0
0114   002E 00 00       .dw 0
0115   0030 00 00       .dw 0
0116   0032 00 00       .dw 0  
0117   0034             
0118   0034             bios_bkpt  .equ 0
0119   0034             bios_rtc   .equ 1
0120   0034             bios_uart  .equ 2
0121   0034             bios_ide   .equ 3
0122   0034             
0123   0034             .export bios_reset_vector
0124   0034             .export ide_buffer
0125   0034             .export boot_origin
0126   0034             .export bios_uart
0127   0034             .export bios_ide
0128   0034             .export _puts
0129   0034             .export print_u16d
0130   0034             .export printnl
0131   0034             
0132   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0133   0034             ; external interrupts' code block
0134   0034             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0135   0034             int_0:
0136   0034 06            sysret
0137   0035             int_1:
0138   0035 06            sysret
0139   0036             int_2:
0140   0036 06            sysret
0141   0037             int_3:
0142   0037 06            sysret
0143   0038             int_4:
0144   0038 06            sysret
0145   0039             int_5:
0146   0039 06            sysret
0147   003A             int_6:  
0148   003A 06            sysret
0149   003B             int_7:
0150   003B 06            sysret
0151   003C             
0152   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0153   003C             ; exceptions
0154   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0155   003C             
0156   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0157   003C             ; privilege exception
0158   003C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0159   003C             trap_privilege:
0160   003C DA            push d
0161   003D 3B 90 05      mov d, s_priv1
0162   0040 07 52 02      call _puts
0163   0043 E7            pop d
0164   0044                           ; enable interrupts
0165   0044 06            sysret
0166   0045             
0167   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0168   0045             ; breakpoint exception
0169   0045             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0170   0045             trap_breakpoint:
0171   0045 D7            push a
0172   0046 DA            push d
0173   0047 E1            pushf
0174   0048               
0175   0048 3B 78 05      mov d, s_bkpt
0176   004B 07 52 02      call _puts
0177   004E               
0178   004E EE            popf
0179   004F E7            pop d
0180   0050 E4            pop a
0181   0051                           ; enable interrupts
0182   0051 06            sysret
0183   0052             
0184   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0185   0052             ; divide by zero exception
0186   0052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0187   0052             trap_div_zero:
0188   0052 D7            push a
0189   0053 DA            push d
0190   0054 E1            pushf
0191   0055               
0192   0055 3B D8 05      mov d, s_divzero
0193   0058 07 52 02      call _puts
0194   005B               
0195   005B EE            popf
0196   005C E7            pop d
0197   005D E4            pop a
0198   005E                           ; enable interrupts
0199   005E 06            sysret
0200   005F             
0201   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0202   005F             ; undefined opcode exception
0203   005F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0204   005F             undefined_opcode:
0205   005F 06            sysret
0206   0060               
0207   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208   0060             ; rtc services interrupt
0209   0060             ; rtc i/o bank = ffa0 to ffaf
0210   0060             ; ffa0 to ffa7 is scratch ram
0211   0060             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0212   0060             ; al = 0..6 -> get
0213   0060             ; al = 7..d -> set
0214   0060             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0215   0060             rtc_services:
0216   0060 DB            push al
0217   0061 DA            push d
0218   0062 B9 06         cmp al, 6
0219   0064 D1 79 00      jgu rtc_set
0220   0067             rtc_get:
0221   0067 6A A9         add al, $a9      ; generate rtc address to get to address a9 of clock
0222   0069 22 FF         mov ah, $ff    
0223   006B 3C            mov d, a        ; get to ffa9 + offset
0224   006C F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0225   0070 1E            mov al, [d]      ; get data
0226   0071 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset r bit
0227   0075 23            mov ah, al
0228   0076 E7            pop d
0229   0077 E8            pop al
0230   0078 06            sysret
0231   0079             rtc_set:
0232   0079 DD            push bl
0233   007A 99            mov bl, ah    ; set data aside
0234   007B 6A A2         add al, $a2    ; generate rtc address to get to address a9 of clock
0235   007D 22 FF         mov ah, $ff    
0236   007F 3C            mov d, a    ; get to ffa9 + offset
0237   0080 1B            mov al, bl    ; get data back
0238   0081 F2 A8 FF 80   mov byte[$ffa8], $80  ; set w bit to 1
0239   0085 3E            mov [d], al    ; set data
0240   0086 F2 A8 FF 00   mov byte[$ffa8], 0    ; reset write bit
0241   008A EA            pop bl
0242   008B E7            pop d
0243   008C E8            pop al
0244   008D 06            sysret
0245   008E             
0246   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0247   008E             ; int 4
0248   008E             ; uart services interrupt
0249   008E             ; al = option
0250   008E             ; ah = data
0251   008E             ; 0 = init, 1 = send, 2 = receive, 3 = receive with echo
0252   008E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0253   008E             uart_serv_tbl:
0254   008E 9A 00         .dw uart_init
0255   0090 B3 00         .dw uart_send
0256   0092 C0 00         .dw uart_receive
0257   0094 CD 00         .dw uart_receive_e
0258   0096             uart_services:
0259   0096 FD 0A 8E 00   jmp [uart_serv_tbl + al]
0260   009A             
0261   009A             uart_init:
0262   009A F2 83 FF 8F   mov byte[_uart0_lcr], %10001111      ; 8 data, 2 stop, odd parity, divisor latch = 1, uart address 3 = line control register
0263   009E F2 80 FF 03   mov byte[_uart0_dlab_0], 3      ; baud = 38400
0264   00A2 F2 81 FF 00   mov byte[_uart0_dlab_1], 0      ; divisor latch high byte = 0      
0265   00A6 F2 83 FF 0F   mov byte[_uart0_lcr], %00001111      ; divisor latch = 0, uart address 3 = line control register
0266   00AA F2 81 FF 00   mov byte[_uart0_ier], 0      ; disable all uart interrupts
0267   00AE F2 82 FF 00   mov byte[_uart0_fcr], 0      ; disable fifo
0268   00B2 06            sysret
0269   00B3             
0270   00B3             uart_send:
0271   00B3 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0272   00B6 93 20         test al, 20h          ; isolate transmitter empty
0273   00B8 C6 B3 00      jz uart_send    
0274   00BB 1A            mov al, ah
0275   00BC 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0276   00BF 06            sysret
0277   00C0             
0278   00C0             uart_receive:
0279   00C0 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0280   00C3 93 01         test al, 1          ; isolate data ready
0281   00C5 C6 C0 00      jz uart_receive
0282   00C8 1D 80 FF      mov al, [_uart0_data]      ; get character
0283   00CB 23            mov ah, al
0284   00CC 06            sysret
0285   00CD             
0286   00CD             uart_receive_e:
0287   00CD 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0288   00D0 93 01         test al, 1          ; isolate data ready
0289   00D2 C6 CD 00      jz uart_receive_e
0290   00D5 1D 80 FF      mov al, [_uart0_data]      ; get character
0291   00D8 23            mov ah, al
0292   00D9             uart_receive_e_loop:
0293   00D9 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0294   00DC 93 20         test al, 20h          ; isolate transmitter empty
0295   00DE C6 D9 00      jz uart_receive_e_loop
0296   00E1 1A            mov al, ah
0297   00E2 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0298   00E5 06            sysret
0299   00E6               
0300   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0301   00E6             ; ide services interrupt
0302   00E6             ; al = option
0303   00E6             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0304   00E6             ; ide read/write sector
0305   00E6             ; 512 bytes
0306   00E6             ; user buffer pointer in d
0307   00E6             ; kernel buffer pointer = ide_buffer
0308   00E6             ; ah = number of sectors
0309   00E6             ; cb = lba bytes 3..0
0310   00E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0311   00E6             ide_serv_tbl:
0312   00E6 F2 00         .dw ide_reset
0313   00E8 06 01         .dw ide_sleep
0314   00EA 15 01         .dw ide_read_sect
0315   00EC 36 01         .dw ide_write_sect
0316   00EE             ide_services:
0317   00EE FD 0A E6 00   jmp [ide_serv_tbl + al]  
0318   00F2             ide_reset:      
0319   00F2 F2 D7 FF 04   mov byte[_ide_r7], 4    ; reset ide
0320   00F6 07 87 01      call ide_wait        ; wait for ide ready             
0321   00F9 F2 D6 FF E0   mov byte[_ide_r6], $e0    ; lba3= 0, master, mode= lba        
0322   00FD F2 D1 FF 01   mov byte[_ide_r1], 1    ; 8-bit transfers      
0323   0101 F2 D7 FF EF   mov byte[_ide_r7], $ef    ; set feature command
0324   0105 06            sysret
0325   0106             ide_sleep:
0326   0106 07 87 01      call ide_wait          ; wait for ide ready             
0327   0109 F2 D6 FF 40   mov byte [_ide_r6], %01000000  ; lba[3:0](reserved), bit 6=1
0328   010D F2 D7 FF E6   mov byte [_ide_r7], $e6    ; sleep command
0329   0111 07 87 01      call ide_wait          ; wait for ide ready
0330   0114 06            sysret
0331   0115             ide_read_sect:
0332   0115 1A            mov al, ah
0333   0116 24            mov ah, bl
0334   0117 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0335   011A 1C            mov al, bh
0336   011B 3D D4 FF      mov [_ide_r4], al
0337   011E 12            mov a, c
0338   011F 3D D5 FF      mov [_ide_r5], al
0339   0122 1A            mov al, ah
0340   0123 87 0F         and al, %00001111
0341   0125 8B E0         or al, %11100000      ; mode lba, master
0342   0127 3D D6 FF      mov [_ide_r6], al
0343   012A 07 87 01      call ide_wait
0344   012D 19 20         mov al, 20h
0345   012F 3D D7 FF      mov [_ide_r7], al      ; read sector cmd
0346   0132 07 57 01      call ide_read  
0347   0135 06            sysret
0348   0136             ide_write_sect:
0349   0136 1A            mov al, ah
0350   0137 24            mov ah, bl
0351   0138 42 D2 FF      mov [_ide_r2], a      ; number of sectors (0..255)
0352   013B 1C            mov al, bh
0353   013C 3D D4 FF      mov [_ide_r4], al
0354   013F 12            mov a, c
0355   0140 3D D5 FF      mov [_ide_r5], al
0356   0143 1A            mov al, ah
0357   0144 87 0F         and al, %00001111
0358   0146 8B E0         or al, %11100000      ; mode lba, master
0359   0148 3D D6 FF      mov [_ide_r6], al
0360   014B 07 87 01      call ide_wait
0361   014E 19 30         mov al, 30h
0362   0150 3D D7 FF      mov [_ide_r7], al      ; write sector cmd
0363   0153 07 6F 01      call ide_write      
0364   0156 06            sysret
0365   0157             
0366   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0367   0157             ; read ide data
0368   0157             ; pointer in d
0369   0157             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0370   0157             ide_read:
0371   0157 DB            push al
0372   0158 DA            push d
0373   0159             ide_read_loop:
0374   0159 07 87 01      call ide_wait
0375   015C 1D D7 FF      mov al, [_ide_r7]
0376   015F 87 08         and al, %00001000      ; drq flag
0377   0161 C6 6C 01      jz ide_read_end
0378   0164 1D D0 FF      mov al, [_ide_r0]
0379   0167 3E            mov [d], al
0380   0168 79            inc d
0381   0169 0A 59 01      jmp ide_read_loop
0382   016C             ide_read_end:
0383   016C E7            pop d
0384   016D E8            pop al
0385   016E 09            ret
0386   016F             
0387   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0388   016F             ; write ide data
0389   016F             ; data pointer in d
0390   016F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0391   016F             ide_write:
0392   016F DB            push al
0393   0170 DA            push d
0394   0171             ide_write_loop:
0395   0171 07 87 01      call ide_wait
0396   0174 1D D7 FF      mov al, [_ide_r7]
0397   0177 87 08         and al, %00001000      ; drq flag
0398   0179 C6 84 01      jz ide_write_end
0399   017C 1E            mov al, [d]
0400   017D 3D D0 FF      mov [_ide_r0], al
0401   0180 79            inc d 
0402   0181 0A 71 01      jmp ide_write_loop
0403   0184             ide_write_end:
0404   0184 E7            pop d
0405   0185 E8            pop al
0406   0186 09            ret
0407   0187             
0408   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0409   0187             ; wait for ide to be ready
0410   0187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0411   0187             ide_wait:
0412   0187 1D D7 FF      mov al, [_ide_r7]  
0413   018A 87 80         and al, 80h        ; busy flag
0414   018C C7 87 01      jnz ide_wait
0415   018F 09            ret
0416   0190             
0417   0190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418   0190             ; bios entry point
0419   0190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0420   0190             bios_reset_vector:
0421   0190 19 00         mov al, %00000000        ; interrupts = off, mode = sup, paging = off, halt-flag = off, display_load = on
0422   0192 0D            stostat
0423   0193               
0424   0193 10 FF F7      mov a, _stack_begin
0425   0196 47            mov sp, a
0426   0197 49            mov bp, a      ; setup stack and frame
0427   0198             
0428   0198 19 00         mov al, 0
0429   019A 05 02         syscall bios_uart
0430   019C               
0431   019C 3B C5 03      mov d, s_welcome
0432   019F 07 52 02      call _puts          ; print welcome msg
0433   01A2             
0434   01A2 07 C2 01      call bios_peripherals_setup
0435   01A5               
0436   01A5 3B 18 04      mov d, s_boot1
0437   01A8 07 52 02      call _puts
0438   01AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0439   01AB 38 00 00      mov c, 0
0440   01AE 26 00 00      mov b, 0          ; start at disk sector 0
0441   01B1 3B 04 80      mov d, boot_origin    ; we read into the bios ide buffer
0442   01B4 10 02 02      mov a, $0202        ; disk read, 2 sectors
0443   01B7 05 03         syscall bios_ide      ; read sector  
0444   01B9               
0445   01B9 3B 2E 04      mov d, s_boot2
0446   01BC 07 52 02      call _puts
0447   01BF             
0448   01BF 0A 04 80      jmp boot_origin
0449   01C2             
0450   01C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0451   01C2             
0452   01C2             bios_peripherals_setup:
0453   01C2 3B 88 04      mov d, s_init
0454   01C5 07 52 02      call _puts
0455   01C8               
0456   01C8 3B 41 04      mov d, s_bios3
0457   01CB 07 52 02      call _puts
0458   01CE 19 00         mov al, 0            ; reset ide
0459   01D0 05 03         syscall bios_ide  
0460   01D2               
0461   01D2 3B 57 04      mov d, s_bios4
0462   01D5 07 52 02      call _puts
0463   01D8               
0464   01D8 19 30         mov al, %00110000          ; counter 0, load both bytes, mode 0, binary
0465   01DA 3D E3 FF      mov [_timer_ctrl], al
0466   01DD 19 FF         mov al, $ff
0467   01DF 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 low byte
0468   01E2 3D E0 FF      mov [_timer_c_0], al        ; load counter 0 high byte
0469   01E5               
0470   01E5 3B 6D 04      mov d, s_bios5
0471   01E8 07 52 02      call _puts
0472   01EB 19 80         mov al, $80
0473   01ED 3D B3 FF      mov [_bios_post_ctrl], al      ; set pio_a to output mode
0474   01F0 19 00         mov al, 0
0475   01F2 3D B0 FF      mov [_7seg_display], al      ; post code = 00
0476   01F5 09            ret
0477   01F6             
0478   01F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0479   01F6             ; print 16bit hex integer
0480   01F6             ; integer value in reg b
0481   01F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0482   01F6             print_u16x:
0483   01F6 E1            pushf
0484   01F7 D7            push a
0485   01F8 D8            push b
0486   01F9 DD            push bl
0487   01FA 30            mov bl, bh
0488   01FB 07 31 03      call _itoa        ; convert bh to char in a
0489   01FE 2F            mov bl, al        ; save al  
0490   01FF 19 01         mov al, 1
0491   0201 05 02         syscall bios_uart        ; display ah
0492   0203 24            mov ah, bl        ; retrieve al
0493   0204 19 01         mov al, 1
0494   0206 05 02         syscall bios_uart        ; display al
0495   0208             
0496   0208 EA            pop bl
0497   0209 07 31 03      call _itoa        ; convert bh to char in a
0498   020C 2F            mov bl, al        ; save al
0499   020D 19 01         mov al, 1
0500   020F 05 02         syscall bios_uart        ; display ah
0501   0211 24            mov ah, bl        ; retrieve al
0502   0212 19 01         mov al, 1
0503   0214 05 02         syscall bios_uart        ; display al
0504   0216             
0505   0216 E5            pop b
0506   0217 E4            pop a
0507   0218 EE            popf
0508   0219 09            ret
0509   021A             
0510   021A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0511   021A             ; input 16bit hex integer
0512   021A             ; read 16bit integer into a
0513   021A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0514   021A             scan_u16x:
0515   021A F8 10 00      enter 16
0516   021D E1            pushf
0517   021E D8            push b
0518   021F DA            push d
0519   0220             
0520   0220 FA F1 FF      lea d, [bp + -15]
0521   0223 07 C5 02      call _getse        ; get number
0522   0226             
0523   0226 32            mov bl, [d]
0524   0227 37            mov bh, bl
0525   0228 33 01 00      mov bl, [d + 1]
0526   022B 07 1F 03      call _atoi        ; convert to int in al
0527   022E 23            mov ah, al        ; move to ah
0528   022F               
0529   022F 33 02 00      mov bl, [d + 2]
0530   0232 37            mov bh, bl
0531   0233 33 03 00      mov bl, [d + 3]
0532   0236 07 1F 03      call _atoi        ; convert to int in al
0533   0239               
0534   0239 E7            pop d  
0535   023A E5            pop b
0536   023B EE            popf
0537   023C F9            leave
0538   023D 09            ret
0539   023E             
0540   023E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0541   023E             ; print 8bit hex integer
0542   023E             ; byte value in reg bl
0543   023E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0544   023E             xput_u8:
0545   023E D7            push a
0546   023F DD            push bl
0547   0240 E1            pushf
0548   0241             
0549   0241 07 31 03      call _itoa          ; convert bl to char in a
0550   0244 2F            mov bl, al          ; save al  
0551   0245 19 01         mov al, 1
0552   0247 05 02         syscall bios_uart        ; display ah
0553   0249 24            mov ah, bl          ; retrieve al
0554   024A 19 01         mov al, 1
0555   024C 05 02         syscall bios_uart        ; display al
0556   024E               
0557   024E EE            popf
0558   024F EA            pop bl
0559   0250 E4            pop a
0560   0251 09            ret
0561   0252             
0562   0252             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0563   0252             ; print null terminated string
0564   0252             ; pointer in d
0565   0252             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0566   0252             _puts:
0567   0252 D7            push a
0568   0253 DA            push d
0569   0254 E1            pushf
0570   0255             _puts_l1:
0571   0255 1E            mov al, [d]
0572   0256 B9 00         cmp al, 0
0573   0258 C6 6B 02      jz _puts_end
0574   025B             _puts_l2:
0575   025B 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0576   025E 93 20         test al, $20          ; isolate transmitter empty
0577   0260 C6 5B 02      jz _puts_l2    
0578   0263 1E            mov al, [d]
0579   0264 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0580   0267 79            inc d  
0581   0268 0A 55 02      jmp _puts_l1
0582   026B             _puts_end:
0583   026B EE            popf
0584   026C E7            pop d
0585   026D E4            pop a
0586   026E 09            ret
0587   026F             
0588   026F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0589   026F             ; _putchar
0590   026F             ; char in ah
0591   026F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0592   026F             _putchar:
0593   026F D7            push a
0594   0270 E1            pushf
0595   0271             _putchar_l1:
0596   0271 1D 85 FF      mov al, [_uart0_lsr]      ; read line status register
0597   0274 93 20         test al, 20h          ; isolate transmitter empty
0598   0276 C6 71 02      jz _putchar_l1    
0599   0279 1A            mov al, ah
0600   027A 3D 80 FF      mov [_uart0_data], al      ; write char to transmitter holding register
0601   027D EE            popf
0602   027E E4            pop a
0603   027F 09            ret
0604   0280               
0605   0280             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0606   0280             ;; input a string with no echo
0607   0280             ;; terminates with null
0608   0280             ;; pointer in d
0609   0280             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0610   0280             _gets:
0611   0280 E1            pushf
0612   0281 D7            push a
0613   0282 DA            push d
0614   0283             _gets_loop:
0615   0283 19 02         mov al, 2
0616   0285 05 02         syscall bios_uart      ; receive in ah
0617   0287 76 0A         cmp ah, 0ah        ; lf
0618   0289 C6 BE 02      je _gets_end
0619   028C 76 0D         cmp ah, 0dh        ; cr
0620   028E C6 BE 02      je _gets_end
0621   0291 76 5C         cmp ah, $5c        ; '\\'
0622   0293 C6 9C 02      je _gets_escape
0623   0296 1A            mov al, ah
0624   0297 3E            mov [d], al
0625   0298 79            inc d
0626   0299 0A 83 02      jmp _gets_loop
0627   029C             _gets_escape:
0628   029C 19 02         mov al, 2
0629   029E 05 02         syscall bios_uart      ; receive in ah
0630   02A0 76 6E         cmp ah, 'n'
0631   02A2 C6 B0 02      je _gets_lf
0632   02A5 76 72         cmp ah, 'r'
0633   02A7 C6 B7 02      je _gets_cr
0634   02AA 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0635   02AB 3E            mov [d], al
0636   02AC 79            inc d
0637   02AD 0A 83 02      jmp _gets_loop
0638   02B0             _gets_lf:
0639   02B0 19 0A         mov al, $0a
0640   02B2 3E            mov [d], al
0641   02B3 79            inc d
0642   02B4 0A 83 02      jmp _gets_loop
0643   02B7             _gets_cr:
0644   02B7 19 0D         mov al, $0d
0645   02B9 3E            mov [d], al
0646   02BA 79            inc d
0647   02BB 0A 83 02      jmp _gets_loop
0648   02BE             _gets_end:
0649   02BE 19 00         mov al, 0
0650   02C0 3E            mov [d], al        ; terminate string
0651   02C1 E7            pop d
0652   02C2 E4            pop a
0653   02C3 EE            popf
0654   02C4 09            ret
0655   02C5             
0656   02C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0657   02C5             ;; INPUT A STRING with echo
0658   02C5             ;; terminates with null
0659   02C5             ;; pointer in D
0660   02C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0661   02C5             _getse:
0662   02C5 E1            pushf
0663   02C6 D7            push a
0664   02C7 DA            push d
0665   02C8             _getse_loop:
0666   02C8 19 03         mov al, 3
0667   02CA 05 02         syscall bios_uart      ; receive in AH
0668   02CC 76 0A         cmp ah, 0Ah        ; LF
0669   02CE C6 03 03      je _getse_end
0670   02D1 76 0D         cmp ah, 0Dh        ; CR
0671   02D3 C6 03 03      je _getse_end
0672   02D6 76 5C         cmp ah, $5C        ; '\\'
0673   02D8 C6 E1 02      je _getse_escape
0674   02DB 1A            mov al, ah
0675   02DC 3E            mov [d], al
0676   02DD 79            inc d
0677   02DE 0A C8 02      jmp _getse_loop
0678   02E1             _getse_escape:
0679   02E1 19 03         mov al, 3
0680   02E3 05 02         syscall bios_uart      ; receive in AH
0681   02E5 76 6E         cmp ah, 'n'
0682   02E7 C6 F5 02      je _getse_LF
0683   02EA 76 72         cmp ah, 'r'
0684   02EC C6 FC 02      je _getse_CR
0685   02EF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0686   02F0 3E            mov [d], al
0687   02F1 79            inc d
0688   02F2 0A C8 02      jmp _getse_loop
0689   02F5             _getse_LF:
0690   02F5 19 0A         mov al, $0A
0691   02F7 3E            mov [d], al
0692   02F8 79            inc d
0693   02F9 0A C8 02      jmp _getse_loop
0694   02FC             _getse_CR:
0695   02FC 19 0D         mov al, $0D
0696   02FE 3E            mov [d], al
0697   02FF 79            inc d
0698   0300 0A C8 02      jmp _getse_loop
0699   0303             _getse_end:
0700   0303 19 00         mov al, 0
0701   0305 3E            mov [d], al        ; terminate string
0702   0306 E7            pop d
0703   0307 E4            pop a
0704   0308 EE            popf
0705   0309 09            ret
0706   030A             
0707   030A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0708   030A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0709   030A             ; ASCII in BL
0710   030A             ; result in AL
0711   030A             ; ascii for F = 0100 0110
0712   030A             ; ascii for 9 = 0011 1001
0713   030A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0714   030A             hex_ascii_encode:
0715   030A 1B            mov al, bl  
0716   030B 93 40         test al, 40h        ; test if letter or number
0717   030D C7 13 03      jnz hex_letter
0718   0310 87 0F         and al, 0Fh        ; get number
0719   0312 09            ret
0720   0313             hex_letter:
0721   0313 DC            push ah
0722   0314 24            mov ah, bl
0723   0315 07 6E 03      call _to_upper
0724   0318 1A            mov al, ah  
0725   0319 87 0F         and al, 0Fh        ; get letter
0726   031B 6A 09         add al, 9
0727   031D E9            pop ah
0728   031E 09            ret
0729   031F             
0730   031F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0731   031F             ; ATOI
0732   031F             ; 2 letter hex string in B
0733   031F             ; 8bit integer returned in AL
0734   031F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0735   031F             _atoi:
0736   031F E1            pushf
0737   0320 D8            push b
0738   0321                 
0739   0321 07 0A 03      call hex_ascii_encode      ; convert BL to 4bit code in AL
0740   0324 30            mov bl, bh
0741   0325 DB            push al          ; save a
0742   0326 07 0A 03      call hex_ascii_encode
0743   0329 EA            pop bl  
0744   032A FD 9E 04      shl al, 4
0745   032D 8C            or al, bl
0746   032E               
0747   032E E5            pop b
0748   032F EE            popf
0749   0330 09            ret  
0750   0331             
0751   0331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0752   0331             ; ITOA
0753   0331             ; 8bit value in BL
0754   0331             ; 2 byte ASCII result in A
0755   0331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0756   0331             _itoa:
0757   0331 E1            pushf
0758   0332 DA            push d
0759   0333 DE            push bh
0760   0334 DD            push bl
0761   0335             
0762   0335 A7 00         mov bh, 0
0763   0337               
0764   0337 FD 87 0F      and bl, $0F
0765   033A 3B 68 05      mov d, s_hex_digits
0766   033D 5A            add d, b
0767   033E 1E            mov al, [d]        ; get ASCII
0768   033F EA            pop bl
0769   0340 52 01 00      sub sp, 1        ; push bl back
0770   0343 DB            push al
0771   0344               
0772   0344 FD 87 F0      and bl, $F0
0773   0347 FD A4 04      shr bl, 4
0774   034A 3B 68 05      mov d, s_hex_digits
0775   034D 5A            add d, b
0776   034E 1E            mov al, [d]        ; get ASCII
0777   034F             
0778   034F 23            mov ah, al
0779   0350 E8            pop al  
0780   0351               
0781   0351 EA            pop bl
0782   0352 EB            pop bh
0783   0353 E7            pop d
0784   0354 EE            popf
0785   0355 09            ret
0786   0356             
0787   0356             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0788   0356             ; STRCMP
0789   0356             ; compare two strings
0790   0356             ; str1 in SI
0791   0356             ; str2 in DI
0792   0356             ; changes: AL SI DI
0793   0356             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0794   0356             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0795   0356             _strcmp:
0796   0356             _strcmp_loop:
0797   0356 F3            cmpsb          ; compare a byte of the strings
0798   0357 C7 63 03      jne _strcmp_ret
0799   035A FB FF FF      lea d, [si + -1]
0800   035D 1E            mov al, [d]
0801   035E B9 00         cmp al, 0        ; check if at end of string (null)
0802   0360 C7 56 03      jne _strcmp_loop        ; equal chars but not at end
0803   0363             _strcmp_ret:        
0804   0363 09            ret
0805   0364             
0806   0364             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0807   0364             ; TO LOWER
0808   0364             ; input in AL
0809   0364             ; output in AL
0810   0364             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0811   0364             _to_lower:
0812   0364 E1            pushf
0813   0365 B9 5A         cmp al, 'Z'
0814   0367 D1 6C 03      jgu _to_lower_ret
0815   036A 6A 20         add al, 20h        ; convert to lower case
0816   036C             _to_lower_ret:
0817   036C EE            popf
0818   036D 09            ret
0819   036E             
0820   036E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0821   036E             ; TO UPPER
0822   036E             ; input in AL
0823   036E             ; output in AL
0824   036E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0825   036E             _to_upper:
0826   036E E1            pushf
0827   036F B9 61         cmp al, 'a'
0828   0371 C8 76 03      jlu _to_upper_ret
0829   0374 6F 20         sub al, 20h        ; convert to upper case
0830   0376             _to_upper_ret:
0831   0376 EE            popf
0832   0377 09            ret
0833   0378             
0834   0378             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0835   0378             ; PRINT DECIMAL INTEGER
0836   0378             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0837   0378             print_decimal:
0838   0378 09            ret
0839   0379             
0840   0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0841   0379             ; print 16bit decimal number
0842   0379             ; input number in a
0843   0379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0844   0379             print_u16d:
0845   0379 D7            push a
0846   037A D8            push b
0847   037B FD D8         push g
0848   037D 26 10 27      mov b, 10000
0849   0380 AE            div a, b      ; get 10000's coeff.
0850   0381 07 A5 03      call print_number
0851   0384 11            mov a, b
0852   0385 26 E8 03      mov b, 1000
0853   0388 AE            div a, b      ; get 1000's coeff.
0854   0389 07 A5 03      call print_number
0855   038C 11            mov a, b
0856   038D 26 64 00      mov b, 100
0857   0390 AE            div a, b
0858   0391 07 A5 03      call print_number
0859   0394 11            mov a, b
0860   0395 26 0A 00      mov b, 10
0861   0398 AE            div a, b
0862   0399 07 A5 03      call print_number
0863   039C 1B            mov al, bl      ; 1's coeff in bl
0864   039D 07 A5 03      call print_number
0865   03A0 FD F1         pop g
0866   03A2 E5            pop b
0867   03A3 E4            pop a
0868   03A4 09            ret
0869   03A5             
0870   03A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0871   03A5             ; print al
0872   03A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0873   03A5             print_number:
0874   03A5 6A 30         add al, $30
0875   03A7 23            mov ah, al
0876   03A8 07 6F 02      call _putchar
0877   03AB 09            ret
0878   03AC             
0879   03AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0880   03AC             ; HEX STRING TO BINARY
0881   03AC             ; di = destination address
0882   03AC             ; si = source
0883   03AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0884   03AC             _hex_to_int:
0885   03AC             _hex_to_int_L1:
0886   03AC F6            lodsb          ; load from [SI] to AL
0887   03AD B9 00         cmp al, 0        ; check if ASCII 0
0888   03AF C6 BC 03      jz _hex_to_int_ret
0889   03B2 36            mov bh, al
0890   03B3 F6            lodsb
0891   03B4 2F            mov bl, al
0892   03B5 07 1F 03      call _atoi        ; convert ASCII byte in B to int (to AL)
0893   03B8 F7            stosb          ; store AL to [DI]
0894   03B9 0A AC 03      jmp _hex_to_int_L1
0895   03BC             _hex_to_int_ret:
0896   03BC 09            ret  
0897   03BD             
0898   03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0899   03BD             ; print new line
0900   03BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0901   03BD             printnl:
0902   03BD DB            push al
0903   03BE 22 0A         mov ah, $0A
0904   03C0 07 6F 02      call _putchar
0905   03C3 E8            pop al
0906   03C4 09            ret
0907   03C5             
0908   03C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0909   03C5             ; data block
0910   03C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0911   03C5 0A 0A 0D 53 s_welcome:      .db "\n\n\rSol-1 74HC HomebrewCPU MiniComputer\n"
0911   03C9 6F 6C 2D 31 
0911   03CD 20 37 34 48 
0911   03D1 43 20 48 6F 
0911   03D5 6D 65 62 72 
0911   03D9 65 77 43 50 
0911   03DD 55 20 4D 69 
0911   03E1 6E 69 43 6F 
0911   03E5 6D 70 75 74 
0911   03E9 65 72 0A 
0912   03EC 42 49 4F 53                 .db "BIOS Version 0.1\n\n\r"
0912   03F0 20 56 65 72 
0912   03F4 73 69 6F 6E 
0912   03F8 20 30 2E 31 
0912   03FC 0A 0A 0D 
0913   03FF 74 65 72 6D                 .db "terminal-1 initialized\n\r", 0
0913   0403 69 6E 61 6C 
0913   0407 2D 31 20 69 
0913   040B 6E 69 74 69 
0913   040F 61 6C 69 7A 
0913   0413 65 64 0A 0D 
0913   0417 00 
0914   0418                     
0915   0418 72 65 61 64 s_boot1:        .db "reading boot sector\n\r", 0
0915   041C 69 6E 67 20 
0915   0420 62 6F 6F 74 
0915   0424 20 73 65 63 
0915   0428 74 6F 72 0A 
0915   042C 0D 00 
0916   042E 62 6F 6F 74 s_boot2:        .db "boot-sector read\n\r", 0
0916   0432 2D 73 65 63 
0916   0436 74 6F 72 20 
0916   043A 72 65 61 64 
0916   043E 0A 0D 00 
0917   0441                     
0918   0441 72 65 73 65 s_bios3:        .db "resetting IDE-drive\n\r", 0
0918   0445 74 74 69 6E 
0918   0449 67 20 49 44 
0918   044D 45 2D 64 72 
0918   0451 69 76 65 0A 
0918   0455 0D 00 
0919   0457 63 6F 6E 66 s_bios4:        .db "configuring Timer-1\n\r", 0
0919   045B 69 67 75 72 
0919   045F 69 6E 67 20 
0919   0463 54 69 6D 65 
0919   0467 72 2D 31 0A 
0919   046B 0D 00 
0920   046D 50 49 4F 2D s_bios5:        .db "PIO-A set to output mode\n\r", 0
0920   0471 41 20 73 65 
0920   0475 74 20 74 6F 
0920   0479 20 6F 75 74 
0920   047D 70 75 74 20 
0920   0481 6D 6F 64 65 
0920   0485 0A 0D 00 
0921   0488             
0922   0488 65 6E 74 65 s_init:         .db "entering real-mode [supervisor on; paging off]\n\r"
0922   048C 72 69 6E 67 
0922   0490 20 72 65 61 
0922   0494 6C 2D 6D 6F 
0922   0498 64 65 20 5B 
0922   049C 73 75 70 65 
0922   04A0 72 76 69 73 
0922   04A4 6F 72 20 6F 
0922   04A8 6E 3B 20 70 
0922   04AC 61 67 69 6E 
0922   04B0 67 20 6F 66 
0922   04B4 66 5D 0A 0D 
0923   04B8 69 6E 74 65                 .db "interrupts disabled\n\r"
0923   04BC 72 72 75 70 
0923   04C0 74 73 20 64 
0923   04C4 69 73 61 62 
0923   04C8 6C 65 64 0A 
0923   04CC 0D 
0924   04CD 64 69 73 70                 .db "display register loading disabled\n\r", 0
0924   04D1 6C 61 79 20 
0924   04D5 72 65 67 69 
0924   04D9 73 74 65 72 
0924   04DD 20 6C 6F 61 
0924   04E1 64 69 6E 67 
0924   04E5 20 64 69 73 
0924   04E9 61 62 6C 65 
0924   04ED 64 0A 0D 00 
0925   04F1             
0926   04F1 0A          s_nl_2:         .db "\n"
0927   04F2 0A 0D 00    s_nl_1:         .db "\n\r", 0
0928   04F5             
0929   04F5 64 61 74 61 s_enter_prog:   .db "data: ", 0
0929   04F9 3A 20 00 
0930   04FC 6F 72 69 67 s_origin_addr:  .db "origin address: ", 0
0930   0500 69 6E 20 61 
0930   0504 64 64 72 65 
0930   0508 73 73 3A 20 
0930   050C 00 
0931   050D             
0932   050D 53 65 72 69 s_ide_serial:   .db "Serial: ", 0
0932   0511 61 6C 3A 20 
0932   0515 00 
0933   0516 46 69 72 6D s_ide_firm:     .db "Firmware: ", 0
0933   051A 77 61 72 65 
0933   051E 3A 20 00 
0934   0521 4D 6F 64 65 s_ide_model:    .db "Model: ", 0
0934   0525 6C 3A 20 00 
0935   0529 4E 75 6D 62 s_sectors:      .db "Number of sectors: ", 0
0935   052D 65 72 20 6F 
0935   0531 66 20 73 65 
0935   0535 63 74 6F 72 
0935   0539 73 3A 20 00 
0936   053D 4C 42 41 20 s_lba0:         .db "LBA 0: ", 0
0936   0541 30 3A 20 00 
0937   0545 4C 42 41 20 s_lba1:         .db "LBA 1: ", 0
0937   0549 31 3A 20 00 
0938   054D 4C 42 41 20 s_lba2:         .db "LBA 2: ", 0
0938   0551 32 3A 20 00 
0939   0555 4C 42 41 20 s_lba3:         .db "LBA 3: ", 0
0939   0559 33 3A 20 00 
0940   055D 0A 0D 45 72 s_error:        .db "\n\rError.\n\r", 0
0940   0561 72 6F 72 2E 
0940   0565 0A 0D 00 
0941   0568                             
0942   0568 30 31 32 33 s_hex_digits:   .db "0123456789ABCDEF"
0942   056C 34 35 36 37 
0942   0570 38 39 41 42 
0942   0574 43 44 45 46 
0943   0578 74 68 69 73 s_bkpt:         .db "this is the breakpoint.", 0
0943   057C 20 69 73 20 
0943   0580 74 68 65 20 
0943   0584 62 72 65 61 
0943   0588 6B 70 6F 69 
0943   058C 6E 74 2E 00 
0944   0590                             
0945   0590 0A 0A 0D 73 s_priv1:        .db "\n\n\rsoftware failure: privilege exception "
0945   0594 6F 66 74 77 
0945   0598 61 72 65 20 
0945   059C 66 61 69 6C 
0945   05A0 75 72 65 3A 
0945   05A4 20 70 72 69 
0945   05A8 76 69 6C 65 
0945   05AC 67 65 20 65 
0945   05B0 78 63 65 70 
0945   05B4 74 69 6F 6E 
0945   05B8 20 
0946   05B9 70 72 65 73                 .db "press any key to continue...\n\r", 0
0946   05BD 73 20 61 6E 
0946   05C1 79 20 6B 65 
0946   05C5 79 20 74 6F 
0946   05C9 20 63 6F 6E 
0946   05CD 74 69 6E 75 
0946   05D1 65 2E 2E 2E 
0946   05D5 0A 0D 00 
0947   05D8 0A 0D 65 78 s_divzero:      .db "\n\rexception: zero division\n\r", 0
0947   05DC 63 65 70 74 
0947   05E0 69 6F 6E 3A 
0947   05E4 20 7A 65 72 
0947   05E8 6F 20 64 69 
0947   05EC 76 69 73 69 
0947   05F0 6F 6E 0A 0D 
0947   05F4 00 
0948   05F5             
0949   05F5             .end
tasm: Number of errors = 0
