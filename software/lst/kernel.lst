0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff88         ; data
0042   0000             _uart1_dlab_0     .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff8A         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff8B         ; line control register
0047   0000             _uart1_lsr        .equ $ff8D         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _til311_display   .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             _stack_begin      .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size        .equ 4096
0080   0000             
0081   0000             _mbr                     .equ 446
0082   0000             _superblock              .equ 1024
0083   0000             _block_group_descriptor  .equ 2048
0084   0000             
0085   0000             text_org          .equ $400          ; code origin address for all user processes
0086   0000             
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; DISK LAYOUT:
0090   0000             ; | Metadata               | Size (bytes)    | Blocks (2048 bytes)              |
0091   0000             ; | ---------------------- | --------------- | -------------------------------- |
0092   0000             ; | Bootloader/MBR         | 512 bytes       | 0.25 (1 sector)                  |
0093   0000             ; | Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0094   0000             ; | Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0095   0000             ; | Block Bitmap           | 16,384 bytes    | 8 blocks                         |
0096   0000             ; | Inode Bitmap           | 2,048 bytes     | 1 block                          |
0097   0000             ; | Inode Table            | 2,097,152 bytes | 1024 blocks                      |
0098   0000             ; 
0099   0000             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0100   0000             ; up to 4 partitions, each 16 bytes long
0101   0000             ; MBR:
0102   0000             ; Byte | Description
0103   0000             ; -----|----------------------------
0104   0000             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0105   0000             ; 1-3  | Start CHS (head, sector, cylinder)
0106   0000             ; 4    | Partition type (filesystem ID)
0107   0000             ;   0x83 = Linux native (ext2/3/4)
0108   0000             ;   0x07 = NTFS/exFAT
0109   0000             ;   0x0B = FAT32 CHS
0110   0000             ;   0x0C = FAT32 LBA
0111   0000             ;   0x05 = Extended partition
0112   0000             ; 5-7  | End CHS
0113   0000             ; 8-11 | Start LBA (little endian)
0114   0000             ; 12-15| Size in sectors (little endian)
0115   0000             ; 
0116   0000             ; 
0117   0000             ; SUPERBLOCK:
0118   0000             ; | Field                 | Description                              | Typical Size (bytes) | Notes                           |
0119   0000             ; | --------------------- | ---------------------------------------- | -------------------- | ------------------------------- |
0120   0000             ; | `s_inodes_count`      | Total number of inodes in the filesystem | 4                    | 32-bit unsigned int             |
0121   0000             ; | `s_blocks_count`      | Total number of data blocks              | 4                    | 32-bit unsigned int             |
0122   0000             ; | `s_free_inodes_count` | Number of free inodes                    | 4                    | 32-bit unsigned int             |
0123   0000             ; | `s_free_blocks_count` | Number of free blocks                    | 4                    | 32-bit unsigned int             |
0124   0000             ; | `s_first_data_block`  | Block number of the first data block     | 4                    | 32-bit unsigned int             |
0125   0000             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`  | 4                    | 32-bit unsigned int             |
0126   0000             ; | `s_inode_size`        | Size of each inode (in bytes)            | 2                    | 16-bit unsigned int             |
0127   0000             ; | `s_magic`             | Filesystem signature (`0xEF53`)          | 2                    | 16-bit unsigned int             |
0128   0000             ; | `s_mtime`             | Last mount time                          | 4                    | 32-bit unsigned int (Unix time) |
0129   0000             ; | `s_wtime`             | Last write time                          | 4                    | 32-bit unsigned int (Unix time) |
0130   0000             ; | `s_uuid`              | Unique ID of the filesystem              | 16                   | 128-bit UUID                    |
0131   0000             ; | `s_volume_name`       | Label of the filesystem                  | 16                   | Usually ASCII, padded           |
0132   0000             ; | `s_feature_flags`     | Compatibility flags                      | 4                    | 32-bit unsigned int             |
0133   0000             
0134   0000             ; BLOCK GROUP DESCRIPTOR starts at 2048
0135   0000             ; | Offset | Size (bytes) | Field Name             | Description                               |
0136   0000             ; | ------ | ------------ | ---------------------- | ----------------------------------------- |
0137   0000             ; | 0x00   | 4            | `bg_block_bitmap`      | Block ID of the **block bitmap**          |
0138   0000             ; | 0x04   | 4            | `bg_inode_bitmap`      | Block ID of the **inode bitmap**          |
0139   0000             ; | 0x08   | 4            | `bg_inode_table`       | Starting block of **inode table**         |
0140   0000             ; | 0x0C   | 2            | `bg_free_blocks_count` | Free blocks in this group                 |
0141   0000             ; | 0x0E   | 2            | `bg_free_inodes_count` | Free inodes in this group                 |
0142   0000             ; | 0x10   | 2            | `bg_used_dirs_count`   | Number of inodes allocated to directories |
0143   0000             ; | 0x12   | 2            | (padding or reserved)  | Usually zero                              |
0144   0000             ; | 0x14   | 12           | Reserved / padding     | Reserved for future use                   |
0145   0000             
0146   0000             ; 
0147   0000             ; inode for root dir is #2, #0 and #1 not used
0148   0000             ; block size: 2048
0149   0000             
0150   0000             ; inode-table format:
0151   0000             ; | Field         | Size (bytes) | Description                                                                                  |
0152   0000             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0153   0000             ; | `mode`        | 2            | File type and permissions                                                                    |
0154   0000             ; | `uid`         | 2            | Owner user ID                                                                                |
0155   0000             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0156   0000             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0157   0000             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0158   0000             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0159   0000             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0160   0000             ; | `gid`         | 2            | Group ID                                                                                     |
0161   0000             ; | `links_count` | 2            | Number of hard links                                                                         |
0162   0000             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0163   0000             ; | `flags`       | 4            | File flags                                                                                   |
0164   0000             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0165   0000             
0166   0000             
0167   0000             ; file entry attributes
0168   0000             ; filename (24)
0169   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0170   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0171   0000             ; size (2)             : filesize
0172   0000             ; day (1)           
0173   0000             ; month (1)
0174   0000             ; year (1)
0175   0000             ; packet size = 32 bytes  : total packet size in bytes
0176   0000             
0177   0000             fst_entry_size      .equ 32  ; bytes
0178   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0179   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0180   0000             fst_nbr_directories .equ 64
0181   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0182   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0183   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0184   0000             fst_lba_start       .equ 32
0185   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0186   0000             
0187   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0188   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0189   0000                                         ; so that we know which blocks are free or taken
0190   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0191   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0192   0000             fs_lba_start        .equ (fst_lba_end + 1)
0193   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0194   0000             
0195   0000             root_id:            .equ fst_lba_start
0196   0000             
0197   0000             ; ------------------------------------------------------------------------------------------------------------------;
0198   0000             ; global system variables
0199   0000             ; ------------------------------------------------------------------------------------------------------------------;
0200   0000             
0201   0000             ; ------------------------------------------------------------------------------------------------------------------;
0202   0000             ; irq table
0203   0000             ; highest priority at lowest address
0204   0000             ; ------------------------------------------------------------------------------------------------------------------;
0205   0000 3C 00       .dw int_0_fdc
0206   0002 43 00       .dw int_1
0207   0004 44 00       .dw int_2
0208   0006 45 00       .dw int_3
0209   0008 46 00       .dw int_4
0210   000A 47 00       .dw int_5_uart1
0211   000C 73 00       .dw int_6_timer
0212   000E 74 00       .dw int_7_uart0
0213   0010             
0214   0010             ; ------------------------------------------------------------------------------------------------------------------;
0215   0010             ; kernel reset vector
0216   0010             ; ------------------------------------------------------------------------------------------------------------------;
0217   0010 5B 13       .dw kernel_reset_vector
0218   0012             
0219   0012             ; ------------------------------------------------------------------------------------------------------------------;
0220   0012             ; exception vector table
0221   0012             ; total of 7 entries, starting at address $0012
0222   0012             ; ------------------------------------------------------------------------------------------------------------------;
0223   0012 D9 05       .dw trap_privilege
0224   0014 F6 06       .dw trap_div_zero
0225   0016 03 07       .dw trap_undef_opcode
0226   0018 00 00       .dw 0
0227   001A 00 00       .dw 0
0228   001C 00 00       .dw 0
0229   001E 00 00       .dw 0
0230   0020             
0231   0020             ; ------------------------------------------------------------------------------------------------------------------;
0232   0020             ; system call vector table
0233   0020             ; starts at address $0020
0234   0020             ; ------------------------------------------------------------------------------------------------------------------;
0235   0020 E5 05       .dw syscall_break
0236   0022 04 07       .dw syscall_rtc
0237   0024 27 08       .dw syscall_ide
0238   0026 E7 08       .dw syscall_io
0239   0028 DC 09       .dw syscall_file_system
0240   002A A8 12       .dw syscall_create_proc
0241   002C 9E 05       .dw syscall_list_procs
0242   002E 36 07       .dw syscall_datetime
0243   0030 5A 05       .dw syscall_reboot
0244   0032 72 12       .dw syscall_pause_proc
0245   0034 66 05       .dw syscall_resume_proc
0246   0036 2F 12       .dw syscall_terminate_proc
0247   0038 26 05       .dw syscall_system
0248   003A 65 02       .dw syscall_fdc
0249   003C             
0250   003C             ; ------------------------------------------------------------------------------------------------------------------;
0251   003C             ; system call aliases
0252   003C             ; ------------------------------------------------------------------------------------------------------------------;
0253   003C             sys_break            .equ 0
0254   003C             sys_rtc              .equ 1
0255   003C             sys_ide              .equ 2
0256   003C             sys_io               .equ 3
0257   003C             sys_filesystem       .equ 4
0258   003C             sys_create_proc      .equ 5
0259   003C             sys_list_proc        .equ 6
0260   003C             sys_datetime         .equ 7
0261   003C             sys_reboot           .equ 8
0262   003C             sys_pause_proc       .equ 9
0263   003C             sys_resume_proc      .equ 10
0264   003C             sys_terminate_proc   .equ 11
0265   003C             sys_system           .equ 12
0266   003C             sys_fdc              .equ 13
0267   003C             
0268   003C             ; aliases for individual 'al' options for FDC system calls
0269   003C             fdc_al_restore      .equ 0
0270   003C             fdc_al_step         .equ 1
0271   003C             fdc_al_step_in      .equ 2
0272   003C             fdc_al_step_out     .equ 3
0273   003C             fdc_al_seek         .equ 4
0274   003C             fdc_al_format_128   .equ 5
0275   003C             fdc_al_formatdisk_128   .equ 6
0276   003C             fdc_al_format_512   .equ 7
0277   003C             fdc_al_formatdisk_512   .equ 8
0278   003C             fdc_al_read_addr    .equ 9
0279   003C             fdc_al_read_track   .equ 10
0280   003C             fdc_al_read_sect    .equ 11
0281   003C             fdc_al_write_sect   .equ 12
0282   003C             fdc_al_force_int    .equ 13
0283   003C             fdc_al_status0      .equ 14
0284   003C             fdc_al_status1      .equ 15
0285   003C             
0286   003C             ; ------------------------------------------------------------------------------------------------------------------;
0287   003C             ; alias exports
0288   003C             ; ------------------------------------------------------------------------------------------------------------------;
0289   003C             .export text_org
0290   003C             .export sys_break
0291   003C             .export sys_rtc
0292   003C             .export sys_ide
0293   003C             .export sys_io
0294   003C             .export sys_filesystem
0295   003C             .export sys_create_proc
0296   003C             .export sys_list_proc
0297   003C             .export sys_datetime
0298   003C             .export sys_reboot
0299   003C             .export sys_pause_proc
0300   003C             .export sys_resume_proc
0301   003C             .export sys_terminate_proc
0302   003C             .export sys_system
0303   003C             .export sys_fdc
0304   003C             
0305   003C             .export _til311_display
0306   003C             
0307   003C             .export _fdc_config        
0308   003C             .export _fdc_status_0      
0309   003C             .export _fdc_stat_cmd     
0310   003C             
0311   003C             ; exports of aliases for individual 'al' options for FDC system calls
0312   003C             .export fdc_al_restore
0313   003C             .export fdc_al_step
0314   003C             .export fdc_al_step_in
0315   003C             .export fdc_al_step_out
0316   003C             .export fdc_al_seek
0317   003C             .export fdc_al_format_128
0318   003C             .export fdc_al_formatdisk_128
0319   003C             .export fdc_al_format_512
0320   003C             .export fdc_al_formatdisk_512
0321   003C             .export fdc_al_read_addr
0322   003C             .export fdc_al_read_track
0323   003C             .export fdc_al_read_sect
0324   003C             .export fdc_al_write_sect
0325   003C             .export fdc_al_force_int
0326   003C             .export fdc_al_status0
0327   003C             .export fdc_al_status1
0328   003C             
0329   003C             ; ------------------------------------------------------------------------------------------------------------------;
0330   003C             ; irqs' code block
0331   003C             ; ------------------------------------------------------------------------------------------------------------------;
0332   003C             ; 5.25" floppy drive controller irq
0333   003C             int_0_fdc:
0334   003C 3B D7 1C      mov d, s_fdc_irq
0335   003F 07 B7 15      call _puts
0336   0042 06            sysret
0337   0043             int_1:
0338   0043 06            sysret
0339   0044             int_2:
0340   0044 06            sysret
0341   0045             int_3:
0342   0045 06            sysret
0343   0046             int_4:
0344   0046 06            sysret
0345   0047             
0346   0047             ; ------------------------------------------------------------------------------------------------------------------;
0347   0047             ; uart1 interrupt
0348   0047             ; ------------------------------------------------------------------------------------------------------------------;
0349   0047             int_5_uart1:
0350   0047 D7            push a
0351   0048 DA            push d
0352   0049 E1            pushf
0353   004A 1D 88 FF      mov al, [_uart1_data]       ; get character
0354   004D B9 03         cmp al, $03                 ; ctrl-c
0355   004F C6 A0 00      je ctrlc
0356   0052 B9 1A         cmp al, $1a                 ; ctrl-z
0357   0054 C6 A6 00      je ctrlz
0358   0057               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0359   0057 3B F2 1A      mov d, fifo_in
0360   005A FD 2A         mov d, [d]
0361   005C 3E            mov [d], al                 ; add to fifo
0362   005D 13            mov a, d
0363   005E 77            inc a
0364   005F AF F9 32      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0365   0062 C7 68 00      jne int_5_continue
0366   0065 10 F9 22      mov a, fifo  
0367   0068             int_5_continue:  
0368   0068 42 F2 1A      mov [fifo_in], a            ; update fifo pointer
0369   006B 1A            mov al, ah
0370   006C 3D B0 FF      mov [_til311_display], al
0371   006F EE            popf
0372   0070 E7            pop d
0373   0071 E4            pop a  
0374   0072 06            sysret
0375   0073             
0376   0073             ; ------------------------------------------------------------------------------------------------------------------;
0377   0073             ; timer irq
0378   0073             ; ------------------------------------------------------------------------------------------------------------------;
0379   0073             int_6_timer:  
0380   0073 06            sysret
0381   0074             
0382   0074             ; ------------------------------------------------------------------------------------------------------------------;
0383   0074             ; uart0 interrupt
0384   0074             ; ------------------------------------------------------------------------------------------------------------------;
0385   0074             int_7_uart0:
0386   0074 D7            push a
0387   0075 DA            push d
0388   0076 E1            pushf
0389   0077 1D 80 FF      mov al, [_uart0_data]       ; get character
0390   007A B9 03         cmp al, $03                 ; ctrl-c
0391   007C C6 A0 00      je ctrlc
0392   007F B9 1A         cmp al, $1a                 ; ctrl-z
0393   0081 C6 A6 00      je ctrlz
0394   0084               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0395   0084 3B F2 1A      mov d, fifo_in
0396   0087 FD 2A         mov d, [d]
0397   0089 3E            mov [d], al                 ; add to fifo
0398   008A 13            mov a, d
0399   008B 77            inc a
0400   008C AF F9 32      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0401   008F C7 95 00      jne int_7_continue
0402   0092 10 F9 22      mov a, fifo  
0403   0095             int_7_continue:  
0404   0095 42 F2 1A      mov [fifo_in], a            ; update fifo pointer
0405   0098 1A            mov al, ah
0406   0099 3D B0 FF      mov [_til311_display], al
0407   009C EE            popf
0408   009D E7            pop d
0409   009E E4            pop a  
0410   009F 06            sysret
0411   00A0             
0412   00A0             ctrlc:
0413   00A0 51 05 00      add sp, 5
0414   00A3 0A 2F 12      jmp syscall_terminate_proc
0415   00A6             ctrlz:
0416   00A6 51 05 00      add sp, 5
0417   00A9 0A 72 12      jmp syscall_pause_proc      ; pause current process and go back to the shell
0418   00AC             
0419   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0420   00AC             ; EXT2 FILE SYSTEM
0421   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0422   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0423   00AC             ; DISK LAYOUT:
0424   00AC             ; Metadata               | Size (bytes)    | Blocks (2048 bytes)              |Start Block |  Comment
0425   00AC             ; ---------------------- | --------------- | -------------------------------- |------------|-----------------------------------
0426   00AC             ; Bootloader/MBR         | 512 bytes       | 0.25 (1 sector)                  |  0         |
0427   00AC             ; Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |  0         |
0428   00AC             ; Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |  1         |
0429   00AC             ; Block Bitmap           | 16,384 bytes    | 8 blocks                         |  2         | 16384*8 = 131072 blocks.  131072*2048 bytes = 256MB of disk space
0430   00AC             ; Inode Bitmap           | 2,048 bytes     | 1 block                          |  10        | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is a standard default of 1 inode per 16KB of disk space
0431   00AC             ; Inode Table            | 2,097,152 bytes | 1024 blocks                      |  11        | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0432   00AC             ; 
0433   00AC             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0434   00AC             ; up to 4 partitions, each 16 bytes long
0435   00AC             ; MBR:
0436   00AC             ; Byte | Description
0437   00AC             ; -----|----------------------------
0438   00AC             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0439   00AC             ; 1-3  | Start CHS (head, sector, cylinder)
0440   00AC             ; 4    | Partition type (filesystem ID)
0441   00AC             ;   0x83 = Linux native (ext2/3/4)
0442   00AC             ;   0x07 = NTFS/exFAT
0443   00AC             ;   0x0B = FAT32 CHS
0444   00AC             ;   0x0C = FAT32 LBA
0445   00AC             ;   0x05 = Extended partition
0446   00AC             ; 5-7  | End CHS
0447   00AC             ; 8-11 | Start LBA (little endian)
0448   00AC             ; 12-15| Size in sectors (little endian)
0449   00AC             ; 
0450   00AC             ; SUPERBLOCK:
0451   00AC             ; | Field                 | Description                              | Typical Size (bytes) | Notes                           |
0452   00AC             ; | --------------------- | ---------------------------------------- | -------------------- | ------------------------------- |
0453   00AC             ; | `s_inodes_count`      | Total number of inodes in the filesystem | 4                    | 32-bit unsigned int             |
0454   00AC             ; | `s_blocks_count`      | Total number of data blocks              | 4                    | 32-bit unsigned int             |
0455   00AC             ; | `s_free_inodes_count` | Number of free inodes                    | 4                    | 32-bit unsigned int             |
0456   00AC             ; | `s_free_blocks_count` | Number of free blocks                    | 4                    | 32-bit unsigned int             |
0457   00AC             ; | `s_first_data_block`  | Block number of the first data block     | 4                    | 32-bit unsigned int             |
0458   00AC             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`  | 4                    | 32-bit unsigned int             |
0459   00AC             ; | `s_inode_size`        | Size of each inode (in bytes)            | 2                    | 16-bit unsigned int             |
0460   00AC             ; | `s_magic`             | Filesystem signature (`0xEF53`)          | 2                    | 16-bit unsigned int             |
0461   00AC             ; | `s_mtime`             | Last mount time                          | 4                    | 32-bit unsigned int (Unix time) |
0462   00AC             ; | `s_wtime`             | Last write time                          | 4                    | 32-bit unsigned int (Unix time) |
0463   00AC             ; | `s_uuid`              | Unique ID of the filesystem              | 16                   | 128-bit UUID                    |
0464   00AC             ; | `s_volume_name`       | Label of the filesystem                  | 16                   | Usually ASCII, padded           |
0465   00AC             ; | `s_feature_flags`     | Compatibility flags                      | 4                    | 32-bit unsigned int             |
0466   00AC             ; 
0467   00AC             ; BLOCK GROUP DESCRIPTOR starts at 2048
0468   00AC             ; | Offset | Size (bytes) | Field Name             | Description                               |
0469   00AC             ; | ------ | ------------ | ---------------------- | ----------------------------------------- |
0470   00AC             ; | 0x00   | 4            | `bg_block_bitmap`      | Block ID of the **block bitmap**          |
0471   00AC             ; | 0x04   | 4            | `bg_inode_bitmap`      | Block ID of the **inode bitmap**          |
0472   00AC             ; | 0x08   | 4            | `bg_inode_table`       | Starting block of **inode table**         |
0473   00AC             ; | 0x0C   | 2            | `bg_free_blocks_count` | Free blocks in this group                 |
0474   00AC             ; | 0x0E   | 2            | `bg_free_inodes_count` | Free inodes in this group                 |
0475   00AC             ; | 0x10   | 2            | `bg_used_dirs_count`   | Number of inodes allocated to directories |
0476   00AC             ; | 0x12   | 2            | (padding or reserved)  | Usually zero                              |
0477   00AC             ; | 0x14   | 12           | Reserved / padding     | Reserved for future use                   |
0478   00AC             ; 
0479   00AC             ; inode for root dir is #2, #0 and #1 not used
0480   00AC             ; block size: 2048
0481   00AC             
0482   00AC             ; inode-table format:
0483   00AC             ; entry size: 128 bytes per entry (default)
0484   00AC             ; | Field         | Size (bytes) | Description                                                                                  |
0485   00AC             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0486   00AC             ; | `mode`        | 2            | File type and permissions                                                                    |
0487   00AC             ; | `uid`         | 2            | Owner user ID                                                                                |
0488   00AC             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0489   00AC             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0490   00AC             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0491   00AC             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0492   00AC             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0493   00AC             ; | `gid`         | 2            | Group ID                                                                                     |
0494   00AC             ; | `links_count` | 2            | Number of hard links                                                                         |
0495   00AC             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0496   00AC             ; | `flags`       | 4            | File flags                                                                                   |
0497   00AC             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0498   00AC             ; | padding       | 32 bytes
0499   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0500   00AC             ; ext2 file system
0501   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0502   00AC             ; up to 4 partitions, each 16 bytes long
0503   00AC             ; MBR:
0504   00AC             ; Byte | Description
0505   00AC             ; -----|----------------------------
0506   00AC             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0507   00AC             ; 1-3  | Start CHS (head, sector, cylinder)
0508   00AC             ; 4    | Partition type (filesystem ID)
0509   00AC             ;   0x83 = Linux native (ext2/3/4)
0510   00AC             ;   0x07 = NTFS/exFAT
0511   00AC             ;   0x0B = FAT32 CHS
0512   00AC             ;   0x0C = FAT32 LBA
0513   00AC             ;   0x05 = Extended partition
0514   00AC             ; 5-7  | End CHS
0515   00AC             ; 8-11 | Start LBA (little endian)
0516   00AC             ; 12-15| Size in sectors (little endian)
0517   00AC             sys_mkfs:
0518   00AC             ; master boot record
0519   00AC             ; partition 0
0520   00AC F2 B7 36 80   mov byte[transient_area + _mbr + 0 +  0], $80      ; boot flag, 0x80 = active
0521   00B0 B8 B8 36 00   mov word[transient_area + _mbr + 0 +  1], $0000    ; start of CHS
0521   00B4 00 
0522   00B5 F2 BA 36 00   mov byte[transient_area + _mbr + 0 +  3], $00      ; start of CHS
0523   00B9 F2 BB 36 83   mov byte[transient_area + _mbr + 0 +  4], $83      ; artition type, 0x83 = linux/ext2
0524   00BD B8 BC 36 00   mov word[transient_area + _mbr + 0 +  5], $0000    ; end of CHS
0524   00C1 00 
0525   00C2 F2 BE 36 00   mov byte[transient_area + _mbr + 0 +  7], $00      ; end of CHS
0526   00C6 B8 BF 36 01   mov word[transient_area + _mbr + 0 +  8], $0001    ; start LBA of file system, at sector 1
0526   00CA 00 
0527   00CB B8 C1 36 00   mov word[transient_area + _mbr + 0 + 10], $0000    ; start LBA of file system, at sector 1
0527   00CF 00 
0528   00D0 B8 C3 36 00   mov word[transient_area + _mbr + 0 + 12], $0000    ; size of file system in sectors/lba, 256MB
0528   00D4 00 
0529   00D5 B8 C5 36 08   mov word[transient_area + _mbr + 0 + 14], $0008    ; 256MB = 524288 sectors
0529   00D9 00 
0530   00DA             ; partition 1             
0531   00DA F2 C7 36 00   mov byte[transient_area + _mbr + 16 +  0], $00      ; boot flag, 0x00 = inactive
0532   00DE B8 C8 36 00   mov word[transient_area + _mbr + 16 +  1], $0000    ; start of CHS
0532   00E2 00 
0533   00E3 F2 CA 36 00   mov byte[transient_area + _mbr + 16 +  3], $00      ; start of CHS
0534   00E7 F2 CB 36 83   mov byte[transient_area + _mbr + 16 +  4], $83      ; artition type, 0x83 = linux/ext2
0535   00EB B8 CC 36 00   mov word[transient_area + _mbr + 16 +  5], $0000    ; end of CHS
0535   00EF 00 
0536   00F0 F2 CE 36 00   mov byte[transient_area + _mbr + 16 +  7], $00      ; end of CHS
0537   00F4 B8 CF 36 00   mov word[transient_area + _mbr + 16 +  8], $0000    ; start LBA of file system, at sector 1
0537   00F8 00 
0538   00F9 B8 D1 36 00   mov word[transient_area + _mbr + 16 + 10], $0000    ; start LBA of file system, at sector 1
0538   00FD 00 
0539   00FE B8 D3 36 00   mov word[transient_area + _mbr + 16 + 12], $0000    ; size of file system in sectors/lba, 256MB
0539   0102 00 
0540   0103 B8 D5 36 00   mov word[transient_area + _mbr + 16 + 14], $0000    ; 256MB = 524288 sectors
0540   0107 00 
0541   0108             ; partition 2             
0542   0108 F2 D7 36 00   mov byte[transient_area + _mbr + 32 +  0], $00      ; boot flag, 0x00 = inactive
0543   010C B8 D8 36 00   mov word[transient_area + _mbr + 32 +  1], $0000    ; start of CHS
0543   0110 00 
0544   0111 F2 DA 36 00   mov byte[transient_area + _mbr + 32 +  3], $00      ; start of CHS
0545   0115 F2 DB 36 83   mov byte[transient_area + _mbr + 32 +  4], $83      ; artition type, 0x83 = linux/ext2
0546   0119 B8 DC 36 00   mov word[transient_area + _mbr + 32 +  5], $0000    ; end of CHS
0546   011D 00 
0547   011E F2 DE 36 00   mov byte[transient_area + _mbr + 32 +  7], $00      ; end of CHS
0548   0122 B8 DF 36 00   mov word[transient_area + _mbr + 32 +  8], $0000    ; start LBA of file system, at sector 1
0548   0126 00 
0549   0127 B8 E1 36 00   mov word[transient_area + _mbr + 32 + 10], $0000    ; start LBA of file system, at sector 1
0549   012B 00 
0550   012C B8 E3 36 00   mov word[transient_area + _mbr + 32 + 12], $0000    ; size of file system in sectors/lba, 256MB
0550   0130 00 
0551   0131 B8 E5 36 00   mov word[transient_area + _mbr + 32 + 14], $0000    ; 256MB = 524288 sectors
0551   0135 00 
0552   0136             ; partition 3             
0553   0136 F2 E7 36 00   mov byte[transient_area + _mbr + 48 +  0], $00      ; boot flag, 0x00 = inactive
0554   013A B8 E8 36 00   mov word[transient_area + _mbr + 48 +  1], $0000    ; start of CHS
0554   013E 00 
0555   013F F2 EA 36 00   mov byte[transient_area + _mbr + 48 +  3], $00      ; start of CHS
0556   0143 F2 EB 36 83   mov byte[transient_area + _mbr + 48 +  4], $83      ; artition type, 0x83 = linux/ext2
0557   0147 B8 EC 36 00   mov word[transient_area + _mbr + 48 +  5], $0000    ; end of CHS
0557   014B 00 
0558   014C F2 EE 36 00   mov byte[transient_area + _mbr + 48 +  7], $00      ; end of CHS
0559   0150 B8 EF 36 00   mov word[transient_area + _mbr + 48 +  8], $0000    ; start LBA of file system, at sector 1
0559   0154 00 
0560   0155 B8 F1 36 00   mov word[transient_area + _mbr + 48 + 10], $0000    ; start LBA of file system, at sector 1
0560   0159 00 
0561   015A B8 F3 36 00   mov word[transient_area + _mbr + 48 + 12], $0000    ; size of file system in sectors/lba, 256MB
0561   015E 00 
0562   015F B8 F5 36 00   mov word[transient_area + _mbr + 48 + 14], $0000    ; 256MB = 524288 sectors
0562   0163 00 
0563   0164             ; --- MBR signature ---
0564   0164 B8 FE 01 55   mov word [510], $AA55          ; Must be present for BIOS to boot
0564   0168 00 
0565   0169             
0566   0169             ; SUPERBLOCK:
0567   0169 B8 F9 38 00   mov word[transient_area + _superblock +  0], $4000  ;
0567   016D 00 
0568   016E B8 FB 38 00   mov word[transient_area + _superblock +  2], $0000  ; s_inodes_count = 16384
0568   0172 00 
0569   0173 B8 FD 38 00   mov word[transient_area + _superblock +  4], $0000  ;
0569   0177 00 
0570   0178 B8 FF 38 02   mov word[transient_area + _superblock +  6], $0002  ; s_blocks_count = 131072 blocks = $20000
0570   017C 00 
0571   017D B8 01 39 00   mov word[transient_area + _superblock +  8], $4000  ;
0571   0181 00 
0572   0182 B8 03 39 00   mov word[transient_area + _superblock + 10], $0000  ; s_free_inodes_count = 16384 inodes = $4000
0572   0186 00 
0573   0187 B8 05 39 00   mov word[transient_area + _superblock + 12], $0000  ;
0573   018B 00 
0574   018C B8 07 39 02   mov word[transient_area + _superblock + 14], $0002  ; s_free_blocks_count = 131072 blocks = $20000
0574   0190 00 
0575   0191 B8 09 39 00   mov word[transient_area + _superblock + 16], $0000  ;
0575   0195 00 
0576   0196 B8 0B 39 00   mov word[transient_area + _superblock + 18], $0000  ; s_first_data_block = 0 (because superblock is contained within first 2048 byte block)
0576   019A 00 
0577   019B B8 0D 39 01   mov word[transient_area + _superblock + 20], $0001  ;
0577   019F 00 
0578   01A0 B8 0F 39 00   mov word[transient_area + _superblock + 22], $0000  ; s_log_block_size = 1 (1024 << 1 == 2048)
0578   01A4 00 
0579   01A5 B8 11 39 80   mov word[transient_area + _superblock + 24], $0080  ; s_inode_size = 128
0579   01A9 00 
0580   01AA B8 13 39 53   mov word[transient_area + _superblock + 26], $EF53  ; s_magic = ef53
0580   01AE 00 
0581   01AF B8 15 39 00   mov word[transient_area + _superblock + 28], $0000  ; s_mtime
0581   01B3 00 
0582   01B4 B8 17 39 00   mov word[transient_area + _superblock + 30], $0000  ; s_wtime
0582   01B8 00 
0583   01B9 B8 19 39 00   mov word[transient_area + _superblock + 32], $0000  ; s_uuid
0583   01BD 00 
0584   01BE B8 1B 39 00   mov word[transient_area + _superblock + 34], $0000  ; s_uuid
0584   01C2 00 
0585   01C3 B8 1D 39 00   mov word[transient_area + _superblock + 36], $0000  ; s_uuid
0585   01C7 00 
0586   01C8 B8 1F 39 00   mov word[transient_area + _superblock + 38], $0000  ; s_uuid
0586   01CC 00 
0587   01CD B8 21 39 00   mov word[transient_area + _superblock + 40], $0000  ; s_uuid
0587   01D1 00 
0588   01D2 B8 23 39 00   mov word[transient_area + _superblock + 42], $0000  ; s_uuid
0588   01D6 00 
0589   01D7 B8 25 39 00   mov word[transient_area + _superblock + 44], $0000  ; s_uuid
0589   01DB 00 
0590   01DC B8 27 39 00   mov word[transient_area + _superblock + 46], $0000  ; s_uuid
0590   01E0 00 
0591   01E1 B8 29 39 00   mov word[transient_area + _superblock + 48], $0000  ; s_volume_name
0591   01E5 00 
0592   01E6 B8 2B 39 00   mov word[transient_area + _superblock + 50], $0000  ; s_volume_name
0592   01EA 00 
0593   01EB B8 2D 39 00   mov word[transient_area + _superblock + 52], $0000  ; s_volume_name
0593   01EF 00 
0594   01F0 B8 2F 39 00   mov word[transient_area + _superblock + 54], $0000  ; s_volume_name
0594   01F4 00 
0595   01F5 B8 31 39 00   mov word[transient_area + _superblock + 56], $0000  ; s_volume_name
0595   01F9 00 
0596   01FA B8 33 39 00   mov word[transient_area + _superblock + 58], $0000  ; s_volume_name
0596   01FE 00 
0597   01FF B8 35 39 00   mov word[transient_area + _superblock + 60], $0000  ; s_volume_name
0597   0203 00 
0598   0204 B8 37 39 00   mov word[transient_area + _superblock + 62], $0000  ; s_volume_name
0598   0208 00 
0599   0209 B8 37 39 00   mov word[transient_area + _superblock + 62], $0000  ;
0599   020D 00 
0600   020E B8 37 39 00   mov word[transient_area + _superblock + 62], $0000  ; s_feature_flags
0600   0212 00 
0601   0213             
0602   0213             ; BLOCK GROUP DESCRIPTOR starts at 2048
0603   0213 B8 F9 3C 02   mov word[transient_area + _block_group_descriptor +  0], $0002  ; bg_block_bitmap
0603   0217 00 
0604   0218 B8 FB 3C 00   mov word[transient_area + _block_group_descriptor +  2], $0000  ; bg_block_bitmap
0604   021C 00 
0605   021D B8 FD 3C 0A   mov word[transient_area + _block_group_descriptor +  4], $000A  ; bg_inode_bitmap
0605   0221 00 
0606   0222 B8 FF 3C 00   mov word[transient_area + _block_group_descriptor +  6], $0000  ; bg_inode_bitmap
0606   0226 00 
0607   0227 B8 01 3D 0B   mov word[transient_area + _block_group_descriptor +  8], $000B  ; bg_inode_table
0607   022B 00 
0608   022C B8 03 3D 00   mov word[transient_area + _block_group_descriptor + 10], $0000  ; bg_inode_table
0608   0230 00 
0609   0231 B8 05 3D 00   mov word[transient_area + _block_group_descriptor + 12], $0000  ; bg_free_blocks_count = 0x200_0000
0609   0235 00 
0610   0236 B8 07 3D 00   mov word[transient_area + _block_group_descriptor + 14], $0200  ; bg_free_inodes_count
0610   023A 00 
0611   023B B8 09 3D 00   mov word[transient_area + _block_group_descriptor + 16], $0000  ; bg_used_dirs_count
0611   023F 00 
0612   0240 B8 0B 3D 00   mov word[transient_area + _block_group_descriptor + 18], $0000  ; reserved
0612   0244 00 
0613   0245             
0614   0245             
0615   0245             
0616   0245             ; ------------------------------------------------------------------------------------------------------------------;
0617   0245             ; floppy drive syscalls
0618   0245             ; ------------------------------------------------------------------------------------------------------------------;
0619   0245             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0620   0245             ; fdc_40_ff:
0621   0245             ;   .fill 40,  $ff    ; or 00                                                                                
0622   0245             ; fdc_128_format_inner:
0623   0245             ;   .fill 6,   $00    ;                                                                            <--|        
0624   0245             ;   .fill 1,   $fe    ; id address mark                                                               |        
0625   0245             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0626   0245             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0627   0245             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0628   0245             ;   .fill 1,   $00    ; sector length                                                                 |                        
0629   0245             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0630   0245             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0631   0245             ;   .fill 6,   $00    ;                                                                               |                        
0632   0245             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0633   0245             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0634   0245             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0635   0245             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0636   0245             ; fdc_128_format_end:
0637   0245             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0638   0245             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0639   0245             fdc_jmptbl:
0640   0245 71 02         .dw syscall_fdc_restore
0641   0247 7D 02         .dw syscall_fdc_step
0642   0249 85 02         .dw syscall_fdc_step_in
0643   024B 8D 02         .dw syscall_fdc_step_out
0644   024D 95 02         .dw syscall_fdc_seek
0645   024F A3 02         .dw syscall_fdc_format_128
0646   0251 F7 02         .dw syscall_fdc_formatdisk_128
0647   0253 CD 02         .dw syscall_fdc_format_512
0648   0255 39 03         .dw syscall_fdc_formatdisk_512
0649   0257 A1 02         .dw syscall_fdc_read_addr
0650   0259 7B 03         .dw syscall_fdc_read_track
0651   025B AA 03         .dw syscall_fdc_read_sect
0652   025D E2 03         .dw syscall_fdc_write_sect
0653   025F A2 02         .dw syscall_fdc_force_int
0654   0261 69 02         .dw syscall_fdc_status0
0655   0263 6D 02         .dw syscall_fdc_status1
0656   0265             syscall_fdc:
0657   0265 FD 0A 45 02   jmp [fdc_jmptbl + al]
0658   0269             
0659   0269             syscall_fdc_status0:
0660   0269 1D C1 FF      mov al, [_fdc_status_0]
0661   026C 06            sysret
0662   026D             
0663   026D             syscall_fdc_status1:
0664   026D 1D C8 FF      mov al, [_fdc_stat_cmd]
0665   0270 06            sysret
0666   0271             
0667   0271             syscall_fdc_restore:
0668   0271 07 13 04      call fdc_wait_not_busy
0669   0274 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011
0670   0278 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0671   027C 06            sysret
0672   027D             
0673   027D             syscall_fdc_step:
0674   027D 07 13 04      call fdc_wait_not_busy
0675   0280 F2 C8 FF 3B   mov byte [_fdc_stat_cmd], %00111011
0676   0284 06            sysret
0677   0285             
0678   0285             syscall_fdc_step_in:
0679   0285 07 13 04      call fdc_wait_not_busy
0680   0288 F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011
0681   028C 06            sysret
0682   028D             
0683   028D             syscall_fdc_step_out:
0684   028D 07 13 04      call fdc_wait_not_busy
0685   0290 F2 C8 FF 7B   mov byte [_fdc_stat_cmd], %01111011
0686   0294 06            sysret
0687   0295             
0688   0295             ; bl: desired track
0689   0295             syscall_fdc_seek:
0690   0295 07 13 04      call fdc_wait_not_busy
0691   0298 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to bl
0692   029C F2 C8 FF 1B   mov byte [_fdc_stat_cmd], %00011011 ; seek command
0693   02A0 06            sysret
0694   02A1             
0695   02A1             syscall_fdc_read_addr:
0696   02A1 06            sysret
0697   02A2             
0698   02A2             syscall_fdc_force_int:
0699   02A2 06            sysret
0700   02A3             
0701   02A3             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0702   02A3             ; in the ram formatting block because they are all set as 00 right now
0703   02A3             ; bl: track number
0704   02A3             syscall_fdc_format_128:
0705   02A3 07 1E 04      call fdc_format_mem_128
0706   02A6 07 13 04      call fdc_wait_not_busy
0707   02A9 FD 3D C9 FF   mov [_fdc_track], bl
0708   02AD FD 4D F9 34   mov si, transient_area
0709   02B1 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0710   02B5 07 F4 04      call fdc_wait_64us
0711   02B8             fdc_format_drq_128:
0712   02B8 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0713   02BB 93 01         test al, $01                ; 4
0714   02BD C6 CC 02      jz fdc_format_end_128           ; 8
0715   02C0 93 02         test al, $02                ; 4
0716   02C2 C6 B8 02      jz fdc_format_drq_128           ; 8
0717   02C5 F6            lodsb                       ; 7
0718   02C6 3D CB FF      mov [_fdc_data], al         ; 10   
0719   02C9 0A B8 02      jmp fdc_format_drq_128
0720   02CC             fdc_format_end_128:
0721   02CC 06            sysret
0722   02CD             
0723   02CD             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0724   02CD             ; in the ram formatting block because they are all set as 00 right now
0725   02CD             ; bl: track number
0726   02CD             syscall_fdc_format_512:
0727   02CD 07 89 04      call fdc_format_mem_512
0728   02D0 07 13 04      call fdc_wait_not_busy
0729   02D3 FD 3D C9 FF   mov [_fdc_track], bl
0730   02D7 FD 4D F9 34   mov si, transient_area
0731   02DB F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0732   02DF 07 F4 04      call fdc_wait_64us
0733   02E2             fdc_format_drq_512:
0734   02E2 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0735   02E5 93 01         test al, $01                ; 4
0736   02E7 C6 F6 02      jz fdc_format_end_512           ; 8
0737   02EA 93 02         test al, $02                ; 4
0738   02EC C6 E2 02      jz fdc_format_drq_512           ; 8
0739   02EF F6            lodsb                       ; 7
0740   02F0 3D CB FF      mov [_fdc_data], al         ; 10   
0741   02F3 0A E2 02      jmp fdc_format_drq_512
0742   02F6             fdc_format_end_512:
0743   02F6 06            sysret
0744   02F7             
0745   02F7             syscall_fdc_formatdisk_128:
0746   02F7 2E 00         mov bl, 0
0747   02F9             fdc_formatdisk128_l0:
0748   02F9 07 1E 04      call fdc_format_mem_128
0749   02FC 07 13 04      call fdc_wait_not_busy
0750   02FF FD 3D C9 FF   mov [_fdc_track], bl
0751   0303 FD 4D F9 34   mov si, transient_area
0752   0307 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command
0753   030B 07 F4 04      call fdc_wait_64us
0754   030E             fdc_formatdisk_drq_128:
0755   030E 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0756   0311 93 01         test al, $01                ; 4
0757   0313 C6 22 03      jz fdc_formatdisk_end_128           ; 8
0758   0316 93 02         test al, $02                ; 4
0759   0318 C6 0E 03      jz fdc_formatdisk_drq_128           ; 8
0760   031B F6            lodsb                       ; 7
0761   031C 3D CB FF      mov [_fdc_data], al         ; 10   
0762   031F 0A 0E 03      jmp fdc_formatdisk_drq_128
0763   0322             fdc_formatdisk_end_128:
0764   0322 07 13 04      call fdc_wait_not_busy
0765   0325 D8            push b
0766   0326 26 08 00      mov b, 8
0767   0329 07 FB 04      call wait_xs
0768   032C F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011  ; step in
0769   0330 E5            pop b
0770   0331 6C 01         add bl, 1
0771   0333 C1 28         cmp bl, 40
0772   0335 C7 F9 02      jne fdc_formatdisk128_l0
0773   0338 06            sysret
0774   0339             
0775   0339             syscall_fdc_formatdisk_512:
0776   0339 2E 00         mov bl, 0
0777   033B             fdc_formatdisk512_l0:
0778   033B 07 89 04      call fdc_format_mem_512
0779   033E 07 13 04      call fdc_wait_not_busy
0780   0341 FD 3D C9 FF   mov [_fdc_track], bl
0781   0345 FD 4D F9 34   mov si, transient_area
0782   0349 F2 C8 FF F2   mov byte [_fdc_stat_cmd], %11110010 ; write track command
0783   034D 07 F4 04      call fdc_wait_64us
0784   0350             fdc_formatdisk_drq_512:
0785   0350 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0786   0353 93 01         test al, $01                ; 4
0787   0355 C6 64 03      jz fdc_formatdisk_end_512           ; 8
0788   0358 93 02         test al, $02                ; 4
0789   035A C6 50 03      jz fdc_formatdisk_drq_512           ; 8
0790   035D F6            lodsb                       ; 7
0791   035E 3D CB FF      mov [_fdc_data], al         ; 10   
0792   0361 0A 50 03      jmp fdc_formatdisk_drq_512
0793   0364             fdc_formatdisk_end_512:
0794   0364 07 13 04      call fdc_wait_not_busy
0795   0367 D8            push b
0796   0368 26 08 00      mov b, 8
0797   036B 07 FB 04      call wait_xs
0798   036E F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011   ; step in
0799   0372 E5            pop b
0800   0373 6C 01         add bl, 1
0801   0375 C1 28         cmp bl, 40
0802   0377 C7 3B 03      jne fdc_formatdisk512_l0
0803   037A 06            sysret
0804   037B             
0805   037B             ; di : destination in user space
0806   037B             ; a  : returns number of read bytes
0807   037B             syscall_fdc_read_track:
0808   037B 07 13 04      call fdc_wait_not_busy
0809   037E E3            push di
0810   037F FD 4F F9 34   mov di, transient_area
0811   0383 F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0812   0387 07 F4 04      call fdc_wait_64us
0813   038A             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0814   038A 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0815   038D 93 01         test al, $01                ; check busy bit
0816   038F C6 9E 03      jz fdc_read_track_end
0817   0392 93 02         test al, $02                ; check drq bit
0818   0394 C6 8A 03      jz fdc_read_track_l0
0819   0397 1D CB FF      mov al, [_fdc_data]     ; 
0820   039A F7            stosb
0821   039B 0A 8A 03      jmp fdc_read_track_l0
0822   039E             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0823   039E             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0824   039E             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0825   039E             fdc_read_track_end:
0826   039E 50            mov a, di
0827   039F 5F F9 34      sub a, transient_area
0828   03A2 F0            pop di
0829   03A3 FD 4D F9 34   mov si, transient_area
0830   03A7 39            mov c, a  ; copy track over to user space
0831   03A8 03            store
0832   03A9 06            sysret
0833   03AA             
0834   03AA             ; sector in bl
0835   03AA             ; track in bh
0836   03AA             ; di = user space destination
0837   03AA             syscall_fdc_read_sect:
0838   03AA 07 13 04      call fdc_wait_not_busy
0839   03AD E3            push di
0840   03AE FD 3D CA FF   mov [_fdc_sector], bl
0841   03B2 30            mov bl, bh
0842   03B3 FD 3D C9 FF   mov [_fdc_track], bl
0843   03B7 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0844   03BB 07 F4 04      call fdc_wait_64us
0845   03BE FD 4F F9 34   mov di, transient_area
0846   03C2             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0847   03C2 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0848   03C5 93 01         test al, $01                ; check drq bit
0849   03C7 C6 D6 03      jz fdc_read_sect_end
0850   03CA 93 02         test al, $02                ; check drq bit
0851   03CC C6 C2 03      jz fdc_read_sect_l0
0852   03CF 1D CB FF      mov al, [_fdc_data]     ; 
0853   03D2 F7            stosb
0854   03D3 0A C2 03      jmp fdc_read_sect_l0
0855   03D6             fdc_read_sect_end:
0856   03D6 50            mov a, di
0857   03D7 5F F9 34      sub a, transient_area
0858   03DA F0            pop di
0859   03DB FD 4D F9 34   mov si, transient_area
0860   03DF 39            mov c, a  ; copy sector over to user space
0861   03E0 03            store
0862   03E1 06            sysret
0863   03E2             
0864   03E2             ; sector size in c
0865   03E2             ; sector in bl
0866   03E2             ; track in bh
0867   03E2             ; data pointer in si
0868   03E2             syscall_fdc_write_sect:
0869   03E2 07 13 04      call fdc_wait_not_busy
0870   03E5 FD 3D CA FF   mov [_fdc_sector], bl
0871   03E9 30            mov bl, bh
0872   03EA FD 3D C9 FF   mov [_fdc_track], bl
0873   03EE FD 4F F9 34   mov di, transient_area    ; si = data source, di = destination 
0874   03F2 04            load                    ; transfer data to kernel space!
0875   03F3 FD 4D F9 34   mov si, transient_area
0876   03F7 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0877   03FB 07 F4 04      call fdc_wait_64us
0878   03FE             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0879   03FE 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0880   0401 93 01         test al, $01                    ; 4
0881   0403 C6 12 04      jz fdc_write_sect_end           ; 8
0882   0406 93 02         test al, $02                    ; 4
0883   0408 C6 FE 03      jz fdc_write_sect_l0            ; 8
0884   040B F6            lodsb                           ; 7
0885   040C 3D CB FF      mov [_fdc_data], al             ; 10   
0886   040F 0A FE 03      jmp fdc_write_sect_l0
0887   0412             fdc_write_sect_end:
0888   0412 06            sysret
0889   0413             
0890   0413             fdc_wait_not_busy:
0891   0413 DB            push al
0892   0414             fdc_wait_not_busy_l0:
0893   0414 1D C8 FF      mov al, [_fdc_stat_cmd]   
0894   0417 93 01         test al, $01               
0895   0419 C7 14 04      jnz fdc_wait_not_busy_l0          
0896   041C E8            pop al
0897   041D 09            ret
0898   041E             
0899   041E             ; track number in bl
0900   041E             fdc_format_mem_128:
0901   041E 3B 01 00      mov d, 1
0902   0421 FD 4F F9 34   mov di, transient_area
0903   0425             ; 40 * FF
0904   0425 38 28 00      mov c, 40
0905   0428 19 FF         mov al, $ff
0906   042A             fdc_l0: 
0907   042A F7            stosb
0908   042B 7E            dec c
0909   042C C7 2A 04      jnz fdc_l0
0910   042F             ; 6 * 00
0911   042F             fdc_inner_loop:
0912   042F 38 06 00      mov c, 6
0913   0432 19 00         mov al, $00
0914   0434             fdc_l1:
0915   0434 F7            stosb
0916   0435 7E            dec c
0917   0436 C7 34 04      jnz fdc_l1
0918   0439             ; FE address mark
0919   0439             fdc_l2:
0920   0439 19 FE         mov al, $fe
0921   043B F7            stosb
0922   043C             ; track number
0923   043C             fdc_l3:
0924   043C 1B            mov al, bl  ; track number in bl
0925   043D F7            stosb
0926   043E             ; side number
0927   043E             fdc_l4:
0928   043E 19 00         mov al, $00
0929   0440 F7            stosb
0930   0441             ; sector number
0931   0441             fdc_l5:
0932   0441 13            mov a, d
0933   0442 F7            stosb
0934   0443             ; sector length 128 bytes
0935   0443             fdc_l6:
0936   0443 19 00         mov al, $00
0937   0445 F7            stosb
0938   0446             ; 2 crc's
0939   0446             fdc_l7:
0940   0446 19 F7         mov al, $f7
0941   0448 F7            stosb
0942   0449             ; 11 times $ff
0943   0449 38 0B 00      mov c, 11
0944   044C 19 FF         mov al, $ff
0945   044E             fdc_l8:
0946   044E F7            stosb
0947   044F 7E            dec c
0948   0450 C7 4E 04      jnz fdc_l8
0949   0453             ; 6 times 00
0950   0453 38 06 00      mov c, 6
0951   0456 19 00         mov al, $00
0952   0458             fdc_l9:
0953   0458 F7            stosb
0954   0459 7E            dec c
0955   045A C7 58 04      jnz fdc_l9
0956   045D             ; FB data address mark
0957   045D 19 FB         mov al, $fb
0958   045F             fdc_l10:
0959   045F F7            stosb
0960   0460             ; 128 bytes sector data
0961   0460 38 80 00      mov c, 128
0962   0463 19 E5         mov al, $E5
0963   0465             fdc_l11:
0964   0465 F7            stosb
0965   0466 7E            dec c
0966   0467 C7 65 04      jnz fdc_l11
0967   046A             ; 2 crc's
0968   046A             fdc_l12:
0969   046A 19 F7         mov al, $f7
0970   046C F7            stosb
0971   046D             ; 10 * $FF
0972   046D 38 0A 00      mov c, 10
0973   0470 19 FF         mov al, $ff
0974   0472             fdc_l13:
0975   0472 F7            stosb
0976   0473 7E            dec c
0977   0474 C7 72 04      jnz fdc_l13
0978   0477             ; check whether we did this 16 times
0979   0477 79            inc d
0980   0478 C5 11 00      cmp d, 17
0981   047B C7 2F 04      jne fdc_inner_loop
0982   047E             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0983   047E 38 F4 01      mov c, 500
0984   0481 19 FF         mov al, $ff
0985   0483             fdc_format_footer:
0986   0483             fdc_footer_drq_loop:
0987   0483 F7            stosb
0988   0484 7E            dec c
0989   0485 C7 83 04      jnz fdc_footer_drq_loop
0990   0488 09            ret
0991   0489             
0992   0489             ; track number in bl
0993   0489             fdc_format_mem_512:
0994   0489 3B 01 00      mov d, 1
0995   048C FD 4F F9 34   mov di, transient_area
0996   0490             ; 40 * FF
0997   0490 38 28 00      mov c, 40
0998   0493 19 FF         mov al, $ff
0999   0495             fdc_512_l0: 
1000   0495 F7            stosb
1001   0496 7E            dec c
1002   0497 C7 95 04      jnz fdc_512_l0
1003   049A             ; 6 * 00
1004   049A             fdc_512_inner_loop:
1005   049A 38 06 00      mov c, 6
1006   049D 19 00         mov al, $00
1007   049F             fdc_512_l1:
1008   049F F7            stosb
1009   04A0 7E            dec c
1010   04A1 C7 9F 04      jnz fdc_512_l1
1011   04A4             ; FE address mark
1012   04A4             fdc_512_l2:
1013   04A4 19 FE         mov al, $fe
1014   04A6 F7            stosb
1015   04A7             ; track number
1016   04A7             fdc_512_l3:
1017   04A7 1B            mov al, bl ; track number was in bl
1018   04A8 F7            stosb
1019   04A9             ; side number
1020   04A9             fdc_512_l4:
1021   04A9 19 00         mov al, $00
1022   04AB F7            stosb
1023   04AC             ; sector number
1024   04AC             fdc_512_l5:
1025   04AC 13            mov a, d
1026   04AD F7            stosb
1027   04AE             ; sector length 512 bytes
1028   04AE             fdc_512_l6:
1029   04AE 19 02         mov al, $02
1030   04B0 F7            stosb
1031   04B1             ; 2 crc's
1032   04B1             fdc_512_l7:
1033   04B1 19 F7         mov al, $f7
1034   04B3 F7            stosb
1035   04B4             ; 11 times $ff
1036   04B4 38 0B 00      mov c, 11
1037   04B7 19 FF         mov al, $ff
1038   04B9             fdc_512_l8:
1039   04B9 F7            stosb
1040   04BA 7E            dec c
1041   04BB C7 B9 04      jnz fdc_512_l8
1042   04BE             ; 6 times 00
1043   04BE 38 06 00      mov c, 6
1044   04C1 19 00         mov al, $00
1045   04C3             fdc_512_l9:
1046   04C3 F7            stosb
1047   04C4 7E            dec c
1048   04C5 C7 C3 04      jnz fdc_512_l9
1049   04C8             ; FB data address mark
1050   04C8 19 FB         mov al, $fb
1051   04CA             fdc_512_l10:
1052   04CA F7            stosb
1053   04CB             ; 128 bytes sector data
1054   04CB 38 00 02      mov c, 512
1055   04CE 19 E5         mov al, $E5
1056   04D0             fdc_512_l11:
1057   04D0 F7            stosb
1058   04D1 7E            dec c
1059   04D2 C7 D0 04      jnz fdc_512_l11
1060   04D5             ; 2 crc's
1061   04D5             fdc_512_l12:
1062   04D5 19 F7         mov al, $f7
1063   04D7 F7            stosb
1064   04D8             ; 10 * $FF
1065   04D8 38 0A 00      mov c, 10
1066   04DB 19 FF         mov al, $ff
1067   04DD             fdc_512_l13:
1068   04DD F7            stosb
1069   04DE 7E            dec c
1070   04DF C7 DD 04      jnz fdc_512_l13
1071   04E2             ; check whether we did this 16 times
1072   04E2 79            inc d
1073   04E3 C5 06 00      cmp d, 6
1074   04E6 C7 9A 04      jne fdc_512_inner_loop
1075   04E9             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
1076   04E9 38 F4 01      mov c, 500
1077   04EC 19 FF         mov al, $ff
1078   04EE             fdc_512_format_footer:
1079   04EE             fdc_512_footer_drq_loop:
1080   04EE F7            stosb
1081   04EF 7E            dec c
1082   04F0 C7 EE 04      jnz fdc_512_footer_drq_loop
1083   04F3 09            ret
1084   04F4             
1085   04F4             ; fetch is 2 cycles long when 'display_reg_load' is false.
1086   04F4             ; 64us amounts to 160 cycles of the 2.5mhz clock
1087   04F4             ; call u16 is 14 cycles long
1088   04F4             ; 160 - 5 - 14 = 
1089   04F4             fdc_wait_64us:
1090   04F4 3A 0D         mov cl, 13                       ; 5 cycles
1091   04F6             fdc_wait_64_loop:
1092   04F6 81            dec cl                           ; 3 cycles
1093   04F7 C7 F6 04      jnz fdc_wait_64_loop             ; 8 cycles
1094   04FA 09            ret
1095   04FB             
1096   04FB             ; number of seconds in b
1097   04FB             wait_xs:
1098   04FB C0 00 00      cmp b, 0
1099   04FE C6 09 05      je wait_xs_end
1100   0501 07 0A 05      call wait_1s
1101   0504 FD 7D         dec b
1102   0506 0A FB 04      jmp wait_xs
1103   0509             wait_xs_end:
1104   0509 09            ret
1105   050A             
1106   050A             wait_1s:
1107   050A DB            push al
1108   050B D9            push c
1109   050C 19 03         mov al, 3
1110   050E             wait_1s_l0:
1111   050E 38 FF FF      mov c, 65535                       
1112   0511             wait_1s_l1:
1113   0511 7E            dec c        ; 4
1114   0512 C7 11 05      jnz wait_1s_l1   ; 8
1115   0515 80            dec al
1116   0516 C7 0E 05      jnz wait_1s_l0
1117   0519 E6            pop c
1118   051A E8            pop al
1119   051B 09            ret
1120   051C             
1121   051C             ; ------------------------------------------------------------------------------------------------------------------;
1122   051C             ; system syscalls
1123   051C             ; ------------------------------------------------------------------------------------------------------------------;
1124   051C             system_jmptbl:
1125   051C 52 05         .dw system_uname
1126   051E 59 05         .dw system_whoami
1127   0520 2C 05         .dw system_poke
1128   0522 2F 05         .dw system_bootloader_install
1129   0524 2A 05         .dw system_peek
1130   0526             syscall_system:
1131   0526 FD 0A 1C 05   jmp [system_jmptbl + al]
1132   052A             
1133   052A             ; param register address in register d
1134   052A             ; param value in register bl
1135   052A             system_peek:
1136   052A 32            mov bl, [d]
1137   052B 06            sysret
1138   052C             
1139   052C             ; param register address in register d
1140   052C             ; param value in register bl
1141   052C             system_poke:
1142   052C FD 3E         mov [d], bl
1143   052E 06            sysret
1144   052F             
1145   052F             ; kernel LBA address in 'b'
1146   052F             system_bootloader_install:
1147   052F D8            push b
1148   0530 26 00 00      mov b, 0
1149   0533 38 00 00      mov c, 0
1150   0536 22 01         mov ah, $01                 ; 1 sector
1151   0538 3B F9 34      mov d, transient_area
1152   053B 07 56 08      call ide_read_sect          ; read sector
1153   053E E5            pop b
1154   053F FD 44 FE 01   mov [d + 510], b            ; update LBA address
1155   0543 26 00 00      mov b, 0
1156   0546 38 00 00      mov c, 0
1157   0549 22 01         mov ah, $01                 ; 1 sector
1158   054B 3B F9 34      mov d, transient_area
1159   054E 07 7C 08      call ide_write_sect         ; write sector
1160   0551 06            sysret
1161   0552             
1162   0552             system_uname:
1163   0552 3B 03 1B      mov d, s_uname
1164   0555 07 B7 15      call _puts
1165   0558 06            sysret
1166   0559             
1167   0559             system_whoami:
1168   0559 06            sysret
1169   055A             
1170   055A             ; reboot system
1171   055A             syscall_reboot:
1172   055A FD D7 FF FF   push word $ffff 
1173   055E FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
1174   0561 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
1175   0565 06            sysret
1176   0566             
1177   0566             ;------------------------------------------------------------------------------------------------------;;
1178   0566             ; switch to another process
1179   0566             ; inputs:
1180   0566             ; al = new process number
1181   0566             ;------------------------------------------------------------------------------------------------------;;
1182   0566             syscall_resume_proc:
1183   0566 FD 78         mov g, a                            ; save the process number
1184   0568 4B            pusha                               ; save all registers into kernel stack
1185   0569 22 00         mov ah, 0
1186   056B 1D ED 1A      mov al, [active_proc_index]
1187   056E FD 99         shl a              ; x2
1188   0570 B7 25 13      mov a, [proc_table_convert + a]     ; get process state start index
1189   0573 4F            mov di, a
1190   0574 48            mov a, sp
1191   0575 77            inc a
1192   0576 4D            mov si, a
1193   0577 38 14 00      mov c, 20
1194   057A FD F5         rep movsb                           ; save process state!
1195   057C             ; restore kernel stack position to point before interrupt arrived
1196   057C 51 14 00      add sp, 20
1197   057F             ; now load the new process number!
1198   057F FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
1199   0581 3D ED 1A      mov [active_proc_index], al         ; set new active proc
1200   0584             ; calculate lut entry for next process
1201   0584 22 00         mov ah, 0
1202   0586 FD 99         shl a                               ; x2
1203   0588 B7 25 13      mov a, [proc_table_convert + a]     ; get process state start index  
1204   058B 4D            mov si, a                           ; source is proc state block
1205   058C 48            mov a, sp
1206   058D 5F 13 00      sub a, 19
1207   0590 4F            mov di, a                           ; destination is kernel stack
1208   0591             ; restore sp
1209   0591 7D            dec a
1210   0592 47            mov sp, a
1211   0593 38 14 00      mov c, 20
1212   0596 FD F5         rep movsb
1213   0598             ; set vm process
1214   0598 1D ED 1A      mov al, [active_proc_index]
1215   059B 01            setptb
1216   059C 4C            popa
1217   059D 06            sysret
1218   059E             
1219   059E             ;------------------------------------------------------------------------------------------------------;;
1220   059E             ; list processes
1221   059E             ;------------------------------------------------------------------------------------------------------;;
1222   059E             syscall_list_procs:
1223   059E 3B 24 1B      mov d, s_ps_header
1224   05A1 07 B7 15      call _puts
1225   05A4 3B 6A 1E      mov d, proc_availab_table + 1
1226   05A7 38 01 00      mov c, 1
1227   05AA             list_procs_l0:  
1228   05AA BD 01         cmp byte[d], 1
1229   05AC C7 D0 05      jne list_procs_next
1230   05AF 2D            mov b, d
1231   05B0 61 69 1E      sub b, proc_availab_table
1232   05B3 FD 9F 05      shl b, 5
1233   05B6 DA            push d
1234   05B7 D8            push b
1235   05B8 28            mov b, c
1236   05B9 07 57 16      call print_u8x
1237   05BC 22 20         mov ah, ' '
1238   05BE 07 8B 14      call _putchar
1239   05C1 07 8B 14      call _putchar
1240   05C4 E5            pop b
1241   05C5 74            mov d, b
1242   05C6 58 79 1E      add d, proc_names
1243   05C9 07 B7 15      call _puts
1244   05CC 07 64 15      call printnl
1245   05CF E7            pop d
1246   05D0             list_procs_next:
1247   05D0 79            inc d
1248   05D1 78            inc c
1249   05D2 C2 09 00      cmp c, 9
1250   05D5 C7 AA 05      jne list_procs_l0
1251   05D8             list_procs_end:
1252   05D8 06            sysret
1253   05D9             
1254   05D9             ; ------------------------------------------------------------------------------------------------------------------;
1255   05D9             ; exceptions code block
1256   05D9             ; ------------------------------------------------------------------------------------------------------------------;
1257   05D9             ; privilege exception
1258   05D9             ; ------------------------------------------------------------------------------------------------------------------;
1259   05D9             trap_privilege:
1260   05D9 0A 5A 05      jmp syscall_reboot
1261   05DC DA            push d
1262   05DD 3B 1A 1C      mov d, s_priviledge
1263   05E0 07 B7 15      call _puts
1264   05E3 E7            pop d
1265   05E4 06            sysret
1266   05E5             
1267   05E5             ; ------------------------------------------------------------------------------------------------------------------;
1268   05E5             ; breakpoint
1269   05E5             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
1270   05E5             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
1271   05E5             ; ------------------------------------------------------------------------------------------------------------------;
1272   05E5             syscall_break:
1273   05E5 4B            pusha
1274   05E6             syscall_break_prompt:
1275   05E6 3B A0 06      mov d, s_break1
1276   05E9 07 B7 15      call _puts
1277   05EC 07 64 15      call printnl
1278   05EF 07 B9 16      call scan_u16d
1279   05F2 AF 00 00      cmp a, 0
1280   05F5 C6 00 06      je syscall_break_regs
1281   05F8 AF 01 00      cmp a, 1
1282   05FB C6 23 06      je syscall_break_mem
1283   05FE             syscall_break_end:  
1284   05FE 4C            popa
1285   05FF 06            sysret
1286   0600             syscall_break_regs:
1287   0600 48            mov a, sp
1288   0601 53 0E 00      add a, 14               ; back-track 7 registers
1289   0604 3C            mov d, a
1290   0605 3A 07         mov cl, 7
1291   0607             syscall_regs_l0:
1292   0607 2A            mov b, [d]
1293   0608 FD AB         swp b
1294   060A 07 13 16      call print_u16x         ; print register value
1295   060D 07 64 15      call printnl
1296   0610 63 02 00      sub d, 2
1297   0613 71 01         sub cl, 1
1298   0615 C3 00         cmp cl, 0
1299   0617 C7 07 06      jne syscall_regs_l0
1300   061A 0A E6 05      jmp syscall_break_prompt
1301   061D 07 64 15      call printnl
1302   0620 0A E6 05      jmp syscall_break_prompt
1303   0623             syscall_break_mem:
1304   0623 07 64 15      call printnl
1305   0626 07 35 16      call scan_u16x
1306   0629 4D            mov si, a               ; data source from user space
1307   062A FD 4F F9 32   mov di, scrap_sector    ; destination in kernel space
1308   062E 38 00 02      mov c, 512
1309   0631 04            load                    ; transfer data to kernel space!
1310   0632 3B F9 32      mov d, scrap_sector     ; dump pointer in d
1311   0635 38 00 00      mov c, 0
1312   0638             dump_loop:
1313   0638 84            mov al, cl
1314   0639 87 0F         and al, $0f
1315   063B C6 89 06      jz print_base
1316   063E             back:
1317   063E 1E            mov al, [d]             ; read byte
1318   063F 2F            mov bl, al
1319   0640 07 57 16      call print_u8x
1320   0643 10 00 20      mov a, $2000
1321   0646 05 03         syscall sys_io          ; space
1322   0648 84            mov al, cl
1323   0649 87 0F         and al, $0f
1324   064B B9 0F         cmp al, $0f
1325   064D C6 5E 06      je print_ascii
1326   0650             back1:
1327   0650 79            inc d
1328   0651 78            inc c
1329   0652 C2 00 02      cmp c, 512
1330   0655 C7 38 06      jne dump_loop
1331   0658 07 64 15      call printnl
1332   065B 0A E6 05      jmp syscall_break_prompt  ; go to syscall_break return point
1333   065E             print_ascii:
1334   065E 10 00 20      mov a, $2000
1335   0661 05 03         syscall sys_io
1336   0663 63 10 00      sub d, 16
1337   0666 26 10 00      mov b, 16
1338   0669             print_ascii_l:
1339   0669 79            inc d
1340   066A 1E            mov al, [d]               ; read byte
1341   066B B9 20         cmp al, $20
1342   066D C8 75 06      jlu dot
1343   0670 B9 7E         cmp al, $7e
1344   0672 D0 7D 06      jleu ascii
1345   0675             dot:
1346   0675 10 00 2E      mov a, $2e00
1347   0678 05 03         syscall sys_io
1348   067A 0A 82 06      jmp ascii_continue
1349   067D             ascii:
1350   067D 23            mov ah, al
1351   067E 19 00         mov al, 0
1352   0680 05 03         syscall sys_io
1353   0682             ascii_continue:
1354   0682 FD A9 69 06   loopb print_ascii_l
1355   0686 0A 50 06      jmp back1
1356   0689             print_base:
1357   0689 07 64 15      call printnl
1358   068C 2D            mov b, d
1359   068D 61 F9 32      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
1360   0690 07 13 16      call print_u16x          ; display row
1361   0693 10 00 3A      mov a, $3a00
1362   0696 05 03         syscall sys_io
1363   0698 10 00 20      mov a, $2000
1364   069B 05 03         syscall sys_io
1365   069D 0A 3E 06      jmp back
1366   06A0             
1367   06A0             s_break1:  
1368   06A0 0A 64 65 62   .db "\ndebugger entry point.\n"
1368   06A4 75 67 67 65 
1368   06A8 72 20 65 6E 
1368   06AC 74 72 79 20 
1368   06B0 70 6F 69 6E 
1368   06B4 74 2E 0A 
1369   06B7 30 2E 20 73   .db "0. show registers\n"
1369   06BB 68 6F 77 20 
1369   06BF 72 65 67 69 
1369   06C3 73 74 65 72 
1369   06C7 73 0A 
1370   06C9 31 2E 20 73   .db "1. show 512b ram block\n"
1370   06CD 68 6F 77 20 
1370   06D1 35 31 32 62 
1370   06D5 20 72 61 6D 
1370   06D9 20 62 6C 6F 
1370   06DD 63 6B 0A 
1371   06E0 32 2E 20 63   .db "2. continue execution", 0
1371   06E4 6F 6E 74 69 
1371   06E8 6E 75 65 20 
1371   06EC 65 78 65 63 
1371   06F0 75 74 69 6F 
1371   06F4 6E 00 
1372   06F6             
1373   06F6             ; ------------------------------------------------------------------------------------------------------------------;
1374   06F6             ; divide by zero exception
1375   06F6             ; ------------------------------------------------------------------------------------------------------------------;
1376   06F6             trap_div_zero:
1377   06F6 D7            push a
1378   06F7 DA            push d
1379   06F8 E1            pushf
1380   06F9 3B 31 1C      mov d, s_divzero
1381   06FC 07 B7 15      call _puts
1382   06FF EE            popf
1383   0700 E7            pop d
1384   0701 E4            pop a
1385   0702 06            sysret ; enable interrupts
1386   0703             
1387   0703             ; ------------------------------------------------------------------------------------------------------------------;
1388   0703             ; undefined opcode exception
1389   0703             ; ------------------------------------------------------------------------------------------------------------------;
1390   0703             trap_undef_opcode:
1391   0703 06            sysret
1392   0704             
1393   0704             ; ------------------------------------------------------------------------------------------------------------------;
1394   0704             ; real-time clock services syscall
1395   0704             ; rtc i/o bank = ffa0 to ffaf
1396   0704             ; ffa0 to ffa7 is scratch ram
1397   0704             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
1398   0704             ; al = 0..6 -> get
1399   0704             ; al = 7..d -> set
1400   0704             ; ------------------------------------------------------------------------------------------------------------------;
1401   0704             syscall_rtc:
1402   0704 DB            push al
1403   0705 DA            push d
1404   0706 B9 06         cmp al, 6
1405   0708 D1 1D 07      jgu syscall_rtc_set
1406   070B             syscall_rtc_get:
1407   070B 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
1408   070D 22 FF         mov ah, $ff    
1409   070F 3C            mov d, a                ; get to ffa9 + offset
1410   0710 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
1411   0714 1E            mov al, [d]             ; get data
1412   0715 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
1413   0719 23            mov ah, al
1414   071A E7            pop d
1415   071B E8            pop al
1416   071C 06            sysret
1417   071D             syscall_rtc_set:
1418   071D DD            push bl
1419   071E 99            mov bl, ah              ; set data aside
1420   071F 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
1421   0721 22 FF         mov ah, $ff    
1422   0723 3C            mov d, a                ; get to ffa9 + offset
1423   0724 1B            mov al, bl              ; get data back
1424   0725 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
1425   0729 3E            mov [d], al             ; set data
1426   072A F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
1427   072E EA            pop bl
1428   072F E7            pop d
1429   0730 E8            pop al
1430   0731 06            sysret
1431   0732             
1432   0732             datetime_serv_tbl:
1433   0732 3A 07         .dw print_date
1434   0734 AE 07         .dw set_date
1435   0736             syscall_datetime:
1436   0736 FD 0A 32 07   jmp [datetime_serv_tbl + al]      
1437   073A             print_date:
1438   073A 10 00 0D      mov a, $0d00           ; print carriage return char
1439   073D 19 03         mov al, 3
1440   073F 05 01         syscall sys_rtc        ; get week
1441   0741 1A            mov al, ah
1442   0742 22 00         mov ah, 0
1443   0744 FD 9D 02      shl a, 2          
1444   0747 3B BB 1C      mov d, s_week
1445   074A 59            add d, a
1446   074B 07 B7 15      call _puts
1447   074E 10 00 20      mov a, $2000
1448   0751 05 03         syscall sys_io         ; display ' '
1449   0753 19 04         mov al, 4
1450   0755 05 01         syscall sys_rtc        ; get day
1451   0757 99            mov bl, ah
1452   0758 07 57 16      call print_u8x
1453   075B 10 00 20      mov a, $2000
1454   075E 05 03         syscall sys_io         ; display ' '
1455   0760             ; there is a problem with the month displaying
1456   0760             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
1457   0760             ; even though it is to be understood as bcd.
1458   0760             ; when retrieving the value and adding the string table address offset the value will go overboard!  
1459   0760 19 05         mov al, 05
1460   0762 05 01         syscall sys_rtc        ; get month
1461   0764 1A            mov al, ah
1462   0765 22 00         mov ah, 0
1463   0767 FD 9D 02      shl a, 2          
1464   076A 3B 87 1C      mov d, s_months
1465   076D 59            add d, a
1466   076E 07 B7 15      call _puts
1467   0771 10 00 20      mov a, $2000
1468   0774 05 03         syscall sys_io         ; display ' '
1469   0776 2E 20         mov bl, $20
1470   0778 07 57 16      call print_u8x         ; print 20 for year prefix
1471   077B 19 06         mov al, 06
1472   077D 05 01         syscall sys_rtc        ; get year
1473   077F 99            mov bl, ah
1474   0780 07 57 16      call print_u8x
1475   0783 10 00 20      mov a, $2000  
1476   0786 05 03         syscall sys_io         ; display ' '
1477   0788 19 02         mov al, 2
1478   078A 05 01         syscall sys_rtc        ; get hours
1479   078C 99            mov bl, ah
1480   078D 07 57 16      call print_u8x
1481   0790 10 00 3A      mov a, $3a00    
1482   0793 05 03         syscall sys_io         ; display ':'
1483   0795 19 01         mov al, 01
1484   0797 05 01         syscall sys_rtc        ; get minutes
1485   0799 99            mov bl, ah
1486   079A 07 57 16      call print_u8x
1487   079D 10 00 3A      mov a, $3a00  
1488   07A0 05 03         syscall sys_io         ; display ':'
1489   07A2 19 00         mov al, 0
1490   07A4 05 01         syscall sys_rtc        ; get seconds
1491   07A6 99            mov bl, ah
1492   07A7 07 57 16      call print_u8x
1493   07AA 07 64 15      call printnl
1494   07AD 06            sysret
1495   07AE             set_date:
1496   07AE 3B 4C 1C      mov d, s_set_year
1497   07B1 07 B7 15      call _puts
1498   07B4 07 A2 16      call scan_u8x          ; read integer into a
1499   07B7 FD 9D 08      shl a, 8               ; only al used, move to ah
1500   07BA 19 0D         mov al, 0dh            ; set rtc year
1501   07BC 05 01         syscall sys_rtc        ; set rtc
1502   07BE 3B 53 1C      mov d, s_set_month
1503   07C1 07 B7 15      call _puts
1504   07C4 07 A2 16      call scan_u8x          ; read integer into a
1505   07C7 FD 9D 08      shl a, 8               ; only al used, move to ah
1506   07CA 19 0C         mov al, 0ch            ; set rtc month
1507   07CC 05 01         syscall sys_rtc        ; set rtc
1508   07CE 3B 5B 1C      mov d, s_set_day
1509   07D1 07 B7 15      call _puts
1510   07D4 07 A2 16      call scan_u8x          ; read integer into a
1511   07D7 FD 9D 08      shl a, 8               ; only al used, move to ah
1512   07DA 19 0B         mov al, 0bh            ; set rtc month
1513   07DC 05 01         syscall sys_rtc        ; set rtc
1514   07DE 3B 61 1C      mov d, s_set_week
1515   07E1 07 B7 15      call _puts
1516   07E4 07 A2 16      call scan_u8x          ; read integer into a
1517   07E7 FD 9D 08      shl a, 8               ; only al used, move to ah
1518   07EA 19 0A         mov al, 0ah            ; set rtc month
1519   07EC 05 01         syscall sys_rtc        ; set rtc
1520   07EE 3B 6B 1C      mov d, s_set_hours
1521   07F1 07 B7 15      call _puts
1522   07F4 07 A2 16      call scan_u8x          ; read integer into a
1523   07F7 FD 9D 08      shl a, 8               ; only al used, move to ah
1524   07FA 19 09         mov al, 09h            ; set rtc month
1525   07FC 05 01         syscall sys_rtc        ; set rtc
1526   07FE 3B 73 1C      mov d, s_set_minutes
1527   0801 07 B7 15      call _puts
1528   0804 07 A2 16      call scan_u8x          ; read integer into a
1529   0807 FD 9D 08      shl a, 8               ; only al used, move to ah
1530   080A 19 08         mov al, 08h            ; set rtc month
1531   080C 05 01         syscall sys_rtc        ; set rtc
1532   080E 3B 7D 1C      mov d, s_set_seconds
1533   0811 07 B7 15      call _puts
1534   0814 07 A2 16      call scan_u8x          ; read integer into a
1535   0817 FD 9D 08      shl a, 8               ; only al used, move to ah
1536   081A 19 07         mov al, 07h            ; set rtc month
1537   081C 05 01         syscall sys_rtc        ; set rtc
1538   081E 06            sysret
1539   081F             
1540   081F             ; ------------------------------------------------------------------------------------------------------------------;
1541   081F             ; ide services syscall
1542   081F             ; al = option
1543   081F             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1544   081F             ; ide read/write sector
1545   081F             ; 512 bytes
1546   081F             ; user buffer pointer in d
1547   081F             ; ah = number of sectors
1548   081F             ; cb = lba bytes 3..0
1549   081F             ; ------------------------------------------------------------------------------------------------------------------;
1550   081F             ide_serv_tbl:
1551   081F 2B 08         .dw ide_reset
1552   0821 3F 08         .dw ide_sleep
1553   0823 4E 08         .dw ide_read_sect_wrapper
1554   0825 52 08         .dw ide_write_sect_wrapper
1555   0827             syscall_ide:
1556   0827 FD 0A 1F 08   jmp [ide_serv_tbl + al]    
1557   082B             
1558   082B             ide_reset:      
1559   082B F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1560   082F 07 D8 08      call ide_wait                   ; wait for ide ready             
1561   0832 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1562   0836 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1563   083A F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1564   083E 06            sysret
1565   083F             ide_sleep:
1566   083F 07 D8 08      call ide_wait                   ; wait for ide ready             
1567   0842 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1568   0846 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1569   084A 07 D8 08      call ide_wait                   ; wait for ide ready
1570   084D 06            sysret
1571   084E             ide_read_sect_wrapper:
1572   084E 07 56 08      call ide_read_sect
1573   0851 06            sysret
1574   0852             ide_write_sect_wrapper:
1575   0852 07 7C 08      call ide_write_sect
1576   0855 06            sysret
1577   0856             ide_read_sect:
1578   0856 1A            mov al, ah
1579   0857 24            mov ah, bl
1580   0858 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1581   085B 1C            mov al, bh
1582   085C 3D D4 FF      mov [_ide_r4], al
1583   085F 12            mov a, c
1584   0860 3D D5 FF      mov [_ide_r5], al
1585   0863 1A            mov al, ah
1586   0864 87 0F         and al, %00001111
1587   0866 8B E0         or al, %11100000                ; mode lba, master
1588   0868 3D D6 FF      mov [_ide_r6], al
1589   086B             ide_read_sect_wait:
1590   086B 1D D7 FF      mov al, [_ide_r7]  
1591   086E 87 80         and al, $80                     ; busy flag
1592   0870 C7 6B 08      jnz ide_read_sect_wait
1593   0873 19 20         mov al, $20
1594   0875 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1595   0878 07 A2 08      call ide_read  
1596   087B 09            ret
1597   087C             ide_write_sect:
1598   087C 1A            mov al, ah
1599   087D 24            mov ah, bl
1600   087E 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1601   0881 1C            mov al, bh
1602   0882 3D D4 FF      mov [_ide_r4], al
1603   0885 12            mov a, c
1604   0886 3D D5 FF      mov [_ide_r5], al
1605   0889 1A            mov al, ah
1606   088A 87 0F         and al, %00001111
1607   088C 8B E0         or al, %11100000                ; mode lba, master
1608   088E 3D D6 FF      mov [_ide_r6], al
1609   0891             ide_write_sect_wait:
1610   0891 1D D7 FF      mov al, [_ide_r7]  
1611   0894 87 80         and al, $80                     ; busy flag
1612   0896 C7 91 08      jnz ide_write_sect_wait
1613   0899 19 30         mov al, $30
1614   089B 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1615   089E 07 BD 08      call ide_write      
1616   08A1 09            ret
1617   08A2             
1618   08A2             ;----------------------------------------------------------------------------------------------------;
1619   08A2             ; read ide data
1620   08A2             ; pointer in d
1621   08A2             ;----------------------------------------------------------------------------------------------------;
1622   08A2             ide_read:
1623   08A2 DA            push d
1624   08A3             ide_read_loop:
1625   08A3 1D D7 FF      mov al, [_ide_r7]  
1626   08A6 87 80         and al, 80h                     ; busy flag
1627   08A8 C7 A3 08      jnz ide_read_loop               ; wait loop
1628   08AB 1D D7 FF      mov al, [_ide_r7]
1629   08AE 87 08         and al, %00001000               ; drq flag
1630   08B0 C6 BB 08      jz ide_read_end
1631   08B3 1D D0 FF      mov al, [_ide_r0]
1632   08B6 3E            mov [d], al
1633   08B7 79            inc d
1634   08B8 0A A3 08      jmp ide_read_loop
1635   08BB             ide_read_end:
1636   08BB E7            pop d
1637   08BC 09            ret
1638   08BD             
1639   08BD             ;----------------------------------------------------------------------------------------------------;
1640   08BD             ; write ide data
1641   08BD             ; data pointer in d
1642   08BD             ;----------------------------------------------------------------------------------------------------;
1643   08BD             ide_write:
1644   08BD DA            push d
1645   08BE             ide_write_loop:
1646   08BE 1D D7 FF      mov al, [_ide_r7]  
1647   08C1 87 80         and al, 80h             ; busy flag
1648   08C3 C7 BE 08      jnz ide_write_loop      ; wait loop
1649   08C6 1D D7 FF      mov al, [_ide_r7]
1650   08C9 87 08         and al, %00001000       ; drq flag
1651   08CB C6 D6 08      jz ide_write_end
1652   08CE 1E            mov al, [d]
1653   08CF 3D D0 FF      mov [_ide_r0], al
1654   08D2 79            inc d 
1655   08D3 0A BE 08      jmp ide_write_loop
1656   08D6             ide_write_end:
1657   08D6 E7            pop d
1658   08D7 09            ret
1659   08D8             
1660   08D8             ;----------------------------------------------------------------------------------------------------;
1661   08D8             ; wait for ide to be ready
1662   08D8             ;----------------------------------------------------------------------------------------------------;
1663   08D8             ide_wait:
1664   08D8 1D D7 FF      mov al, [_ide_r7]  
1665   08DB 87 80         and al, 80h        ; busy flag
1666   08DD C7 D8 08      jnz ide_wait
1667   08E0 09            ret
1668   08E1             
1669   08E1             ;----------------------------------------------------------------------------------------------------;
1670   08E1             ; io syscall
1671   08E1             ;----------------------------------------------------------------------------------------------------;
1672   08E1             ; baud  divisor
1673   08E1             ; 50    2304
1674   08E1             ; 110   1047
1675   08E1             ; 300    384
1676   08E1             ; 600    192
1677   08E1             ; 1200    96
1678   08E1             ; 9600    12
1679   08E1             ; 19200    6
1680   08E1             ; 38400    3
1681   08E1             syscall_io_jmp:
1682   08E1 3C 09         .dw syscall_io_putchar
1683   08E3 55 09         .dw syscall_io_getch
1684   08E5 EB 08         .dw syscall_io_uart_setup
1685   08E7             syscall_io:
1686   08E7 FD 0A E1 08   jmp [syscall_io_jmp + al]
1687   08EB             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1688   08EB             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1689   08EB             ; buffer, the transmitter holding register, or the interrupt enable register.
1690   08EB             syscall_io_uart_setup:
1691   08EB 1D E2 1A      mov al, [sys_uart0_lcr]
1692   08EE 8B 80         or al, $80                ; set dlab access bit
1693   08F0 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1694   08F3 1D E5 1A      mov al, [sys_uart0_div0]
1695   08F6 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1696   08F9 1D E6 1A      mov al, [sys_uart0_div1]
1697   08FC 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1698   08FF 1D E2 1A      mov al, [sys_uart0_lcr]
1699   0902 87 7F         and al, $7f               ; clear dlab access bit 
1700   0904 3D 83 FF      mov [_uart0_lcr], al
1701   0907 1D E3 1A      mov al, [sys_uart0_inten]
1702   090A 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1703   090D 1D E4 1A      mov al, [sys_uart0_fifoen]
1704   0910 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1705   0913             ; uart1:
1706   0913 1D E7 1A      mov al, [sys_uart1_lcr]
1707   0916 8B 80         or al, $80                ; set dlab access bit
1708   0918 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, no parity by default
1709   091B 1D EA 1A      mov al, [sys_uart1_div0]
1710   091E 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
1711   0921 1D EB 1A      mov al, [sys_uart1_div1]
1712   0924 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
1713   0927 1D E7 1A      mov al, [sys_uart1_lcr]
1714   092A 87 7F         and al, $7f               ; clear dlab access bit 
1715   092C 3D 8B FF      mov [_uart1_lcr], al
1716   092F 1D E8 1A      mov al, [sys_uart1_inten]
1717   0932 3D 89 FF      mov [_uart1_ier], al      ; interrupts
1718   0935 1D E9 1A      mov al, [sys_uart1_fifoen]
1719   0938 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
1720   093B 06            sysret
1721   093C             
1722   093C             ; char in ah
1723   093C             syscall_io_putchar:
1724   093C             syscall_io_putchar_l0:
1725   093C 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1726   093F 87 20         and al, $20
1727   0941 C6 3C 09      jz syscall_io_putchar_l0    
1728   0944 1A            mov al, ah
1729   0945 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1730   0948             ; write to uart1
1731   0948             syscall_io_putchar_l1:
1732   0948 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1733   094B 87 20         and al, $20
1734   094D C6 48 09      jz syscall_io_putchar_l1
1735   0950 1A            mov al, ah
1736   0951 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1737   0954 06            sysret
1738   0955             
1739   0955             ; char in ah
1740   0955             ; al = sucess code
1741   0955             syscall_io_getch:
1742   0955 D8            push b
1743   0956 DA            push d
1744   0957 FD 0C         sti
1745   0959             syscall_io_getch_l0:  
1746   0959 14 F4 1A      mov a, [fifo_out]
1747   095C 29 F2 1A      mov b, [fifo_in]
1748   095F B0            cmp a, b
1749   0960 C6 59 09      je syscall_io_getch_l0
1750   0963 3C            mov d, a
1751   0964 77            inc a
1752   0965 AF F9 32      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
1753   0968 C7 6E 09      jne syscall_io_getch_cont
1754   096B 10 F9 22      mov a, fifo  
1755   096E             syscall_io_getch_cont:  
1756   096E 42 F4 1A      mov [fifo_out], a             ; update fifo pointer
1757   0971 1E            mov al, [d]                   ; get char
1758   0972 23            mov ah, al
1759   0973             ; here we just echo the char back to the console
1760   0973             syscall_io_getch_echo_l0:
1761   0973 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1762   0976 87 20         and al, $20                 ; isolate transmitter empty
1763   0978 C6 73 09      jz syscall_io_getch_echo_l0
1764   097B 1A            mov al, ah
1765   097C 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1766   097F             syscall_io_getch_echo_l1:
1767   097F 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1768   0982 87 20         and al, $20                 ; isolate transmitter empty
1769   0984 C6 7F 09      jz syscall_io_getch_echo_l1
1770   0987 1A            mov al, ah
1771   0988 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1772   098B             syscall_io_getch_noecho:
1773   098B 19 01         mov al, 1                    ; al = 1 means a char successfully received
1774   098D E7            pop d
1775   098E E5            pop b
1776   098F 06            sysret
1777   0990             
1778   0990             ;------------------------------------------------------------------------------------------------------;
1779   0990             ; file system data
1780   0990             ;------------------------------------------------------------------------------------------------------;
1781   0990             ; infor for : ide services interrupt
1782   0990             ; ide read/write 512-byte sector
1783   0990             ; al = option
1784   0990             ; user buffer pointer in d
1785   0990             ; ah = number of sectors
1786   0990             ; cb = lba bytes 3..0  
1787   0990             ;------------------------------------------------------------------------------------------------------;
1788   0990             ; file system data structure
1789   0990             ;------------------------------------------------------------------------------------------------------;
1790   0990             ; for a directory we have the header first, followed by metadata
1791   0990             ; header 1 sector (512 bytes)
1792   0990             ; metadata 1 sector (512 bytes)
1793   0990             ; header entries:
1794   0990             ; filename (64)
1795   0990             ; parent dir lba (2) -  to be used for faster backwards navigation...
1796   0990             ;
1797   0990             ; metadata entries:
1798   0990             ; filename (24)
1799   0990             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1800   0990             ; lba (2)
1801   0990             ; size (2)
1802   0990             ; day (1)
1803   0990             ; month (1)
1804   0990             ; year (1)
1805   0990             ; packet size = 32 bytes
1806   0990             ;
1807   0990             ; first directory on disk is the root directory '/'
1808   0990             file_system_jmptbl:
1809   0990 00 00         .dw 0                         ; 0
1810   0992 00 00         .dw 0                         ; 1
1811   0994 5C 0A         .dw fs_mkdir                  ; 2
1812   0996 D5 0D         .dw fs_cd                     ; 3
1813   0998 DC 0D         .dw fs_ls                     ; 4
1814   099A C7 0E         .dw fs_mktxt                  ; 5
1815   099C 92 0F         .dw fs_mkbin                  ; 6
1816   099E 59 10         .dw fs_pwd                    ; 7
1817   09A0 76 10         .dw fs_cat                    ; 8
1818   09A2 D2 10         .dw fs_rmdir                  ; 9
1819   09A4 2E 11         .dw fs_rm                     ; 10
1820   09A6 00 00         .dw 0                         ; 11
1821   09A8 00 00         .dw 0                         ; 12
1822   09AA 00 00         .dw 0                         ; 13
1823   09AC 02 0A         .dw fs_chmod                  ; 14
1824   09AE 96 11         .dw fs_mv                     ; 15
1825   09B0 FB 09         .dw fs_cd_root                ; 16
1826   09B2 D1 0D         .dw fs_get_curr_dirid         ; 17
1827   09B4 AD 0B         .dw fs_dir_id_to_path         ; 18
1828   09B6 13 0C         .dw fs_path_to_dir_id_user    ; 19
1829   09B8 2D 0D         .dw fs_load_from_path_user    ; 20  
1830   09BA 9D 0C         .dw fs_filepath_exists_user   ; 21
1831   09BC             
1832   09BC 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1832   09C0 79 73 63 61 
1832   09C4 6C 6C 5F 66 
1832   09C8 69 6C 65 5F 
1832   09CC 73 79 73 74 
1832   09D0 65 6D 20 63 
1832   09D4 61 6C 6C 65 
1832   09D8 64 3A 20 00 
1833   09DC             syscall_file_system:
1834   09DC DD            push bl
1835   09DD 31 E0 1A      mov bl, [sys_debug_mode]
1836   09E0               ; debug block
1837   09E0 C1 00         cmp bl, 0
1838   09E2 EA            pop bl
1839   09E3 C6 F7 09      je syscall_filesystem_jmp
1840   09E6 DA            push d
1841   09E7 DD            push bl
1842   09E8 3B BC 09      mov d, s_syscall_fs_dbg0
1843   09EB 07 B7 15      call _puts
1844   09EE 2F            mov bl, al
1845   09EF 07 57 16      call print_u8x
1846   09F2 07 64 15      call printnl
1847   09F5 EA            pop bl
1848   09F6 E7            pop d
1849   09F7             syscall_filesystem_jmp:
1850   09F7 FD 0A 90 09   jmp [file_system_jmptbl + al]
1851   09FB               
1852   09FB             fs_cd_root:
1853   09FB 10 20 00      mov a, root_id
1854   09FE 42 F6 1A      mov [current_dir_id], a      ; set current directory lba to root
1855   0A01 06            sysret  
1856   0A02             
1857   0A02             ; filename in d (userspace data)
1858   0A02             ; permission in bl
1859   0A02             fs_chmod:
1860   0A02 DD            push bl
1861   0A03 FD 4E         mov si, d
1862   0A05 FD 4F F9 20   mov di, user_data
1863   0A09 38 80 00      mov c, 128
1864   0A0C 04            load                        ; load filename from user-space
1865   0A0D 14 F6 1A      mov a, [current_dir_id]
1866   0A10 77            inc a                       ; metadata sector
1867   0A11 27            mov b, a
1868   0A12 38 00 00      mov c, 0                    ; upper lba = 0
1869   0A15 22 01         mov ah, $01                  ; 1 sector
1870   0A17 3B F9 34      mov d, transient_area
1871   0A1A 07 56 08      call ide_read_sect          ; read directory
1872   0A1D FD 10         cla
1873   0A1F 42 EE 1A      mov [index], a              ; reset file counter
1874   0A22             fs_chmod_l1:
1875   0A22 FD 4E         mov si, d
1876   0A24 FD 4F F9 20   mov di, user_data
1877   0A28 07 FA 13      call _strcmp
1878   0A2B C6 42 0A      je fs_chmod_found_entry
1879   0A2E 58 20 00      add d, 32
1880   0A31 14 EE 1A      mov a, [index]
1881   0A34 77            inc a
1882   0A35 42 EE 1A      mov [index], a
1883   0A38 AF 10 00      cmp a, fst_files_per_dir
1884   0A3B C7 22 0A      jne fs_chmod_l1
1885   0A3E EA            pop bl
1886   0A3F 0A 5B 0A      jmp fs_chmod_not_found
1887   0A42             fs_chmod_found_entry:  
1888   0A42 FD 79         mov g, b                    ; save lba
1889   0A44 EA            pop bl                      ; retrieve saved permission value
1890   0A45 1F 18 00      mov al, [d + 24]            ; read file permissions
1891   0A48 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1892   0A4A 8C            or al, bl                   ; set new permissions
1893   0A4B 3F 18 00      mov [d + 24], al            ; write new permissions
1894   0A4E 38 00 00      mov c, 0
1895   0A51 3B F9 34      mov d, transient_area
1896   0A54 22 01         mov ah, $01                 ; disk write 1 sect
1897   0A56 FD 27         mov b, g                    ; retrieve lba
1898   0A58 07 7C 08      call ide_write_sect         ; write sector
1899   0A5B             fs_chmod_not_found:
1900   0A5B 06            sysret
1901   0A5C             
1902   0A5C             ;------------------------------------------------------------------------------------------------------;
1903   0A5C             ; create new directory
1904   0A5C             ;------------------------------------------------------------------------------------------------------;
1905   0A5C             ; search list for null name entry. add new directory to list
1906   0A5C             fs_mkdir:
1907   0A5C FD 4E         mov si, d
1908   0A5E FD 4F F9 20   mov di, user_data
1909   0A62 38 00 02      mov c, 512
1910   0A65 04            load                        ; load data from user-space
1911   0A66 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1912   0A69                                           ; when checking for null name, since root has a null name)
1913   0A69 38 00 00      mov c, 0                    ; upper lba = 0
1914   0A6C             fs_mkdir_l1:  
1915   0A6C 22 01         mov ah, $01                  ; 1 sector
1916   0A6E 3B F9 34      mov d, transient_area
1917   0A71 07 56 08      call ide_read_sect          ; read sector
1918   0A74 BD 00         cmp byte[d], 0              ; check for null
1919   0A76 C6 7F 0A      je fs_mkdir_found_null
1920   0A79 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1921   0A7C 0A 6C 0A      jmp fs_mkdir_l1
1922   0A7F             fs_mkdir_found_null:
1923   0A7F             ;create header file by grabbing dir name from parameter
1924   0A7F D8            push b                      ; save new directory's lba
1925   0A80 38 40 00      mov c, 64
1926   0A83 FD 4D F9 20   mov si, user_data
1927   0A87 FD 4F F9 34   mov di, transient_area
1928   0A8B FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1929   0A8D 14 F6 1A      mov a, [current_dir_id]
1930   0A90 42 39 35      mov [transient_area + 64], a    ; store parent directory lba
1931   0A93 19 00         mov al, 0
1932   0A95 FD 4F F9 36   mov di, transient_area + 512
1933   0A99 38 00 02      mov c, 512
1934   0A9C FD F7         rep stosb                       ; clean buffer
1935   0A9E 38 00 00      mov c, 0                        ; reset lba(c) to 0
1936   0AA1             ; write directory entry sectors
1937   0AA1 3B F9 34      mov d, transient_area
1938   0AA4 22 02         mov ah, $02                     ; disk write, 2 sectors
1939   0AA6 07 7C 08      call ide_write_sect             ; write sector
1940   0AA9             ; now we need to add the new directory to the list, inside the current directory
1941   0AA9 14 F6 1A      mov a, [current_dir_id]
1942   0AAC 53 01 00      add a, 1
1943   0AAF 27            mov b, a                        ; metadata sector
1944   0AB0 38 00 00      mov c, 0
1945   0AB3 FD 79         mov g, b                        ; save lba
1946   0AB5 3B F9 34      mov d, transient_area
1947   0AB8 22 01         mov ah, $01                  ; 1 sector
1948   0ABA 07 56 08      call ide_read_sect              ; read metadata sector
1949   0ABD             fs_mkdir_l2:
1950   0ABD BD 00         cmp byte[d], 0
1951   0ABF C6 C8 0A      je fs_mkdir_found_null2
1952   0AC2 58 20 00      add d, fst_entry_size
1953   0AC5 0A BD 0A      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1954   0AC8             fs_mkdir_found_null2:
1955   0AC8 FD 4D F9 20   mov si, user_data
1956   0ACC FD 50         mov di, d
1957   0ACE 07 0F 14      call _strcpy                    ; copy directory name
1958   0AD1 58 18 00      add d, 24                       ; goto attributes
1959   0AD4 19 0B         mov al, %00001011               ; directory, no execute, write, read
1960   0AD6 3E            mov [d], al      
1961   0AD7 79            inc d
1962   0AD8 E5            pop b
1963   0AD9 D8            push b                          ; push lba back
1964   0ADA FD 43         mov [d], b                      ; save lba
1965   0ADC             ; set file creation date  
1966   0ADC 58 04 00      add d, 4
1967   0ADF 19 04         mov al, 4
1968   0AE1 05 01         syscall sys_rtc
1969   0AE3 1A            mov al, ah
1970   0AE4 3E            mov [d], al                     ; set day
1971   0AE5 79            inc d
1972   0AE6 19 05         mov al, 5
1973   0AE8 05 01         syscall sys_rtc
1974   0AEA 1A            mov al, ah
1975   0AEB 3E            mov [d], al                     ; set month
1976   0AEC 79            inc d
1977   0AED 19 06         mov al, 6
1978   0AEF 05 01         syscall sys_rtc
1979   0AF1 1A            mov al, ah
1980   0AF2 3E            mov [d], al                     ; set year
1981   0AF3             ; write sector into disk for new directory entry
1982   0AF3 FD 27         mov b, g
1983   0AF5 38 00 00      mov c, 0
1984   0AF8 3B F9 34      mov d, transient_area
1985   0AFB 22 01         mov ah, $01                     ; disk write, 1 sector
1986   0AFD 07 7C 08      call ide_write_sect             ; write sector
1987   0B00             
1988   0B00             ; after adding the new directory's information to its parent directory's list
1989   0B00             ; we need to now enter the new directory, and to it add two new directories!
1990   0B00             ; which directories do we need to add ? '..' and '.' are the directories needed.
1991   0B00             ; importantly, note that these two new directories are only entries in the list
1992   0B00             ; and do not have actual physical entries in the disk as real directories.
1993   0B00             ; i.e. they only exist as list entries in the new directory created so that
1994   0B00             ; the new directory can reference its parent and itself.
1995   0B00             ; we need to add both '..' and '.'
1996   0B00             ; this first section is for '..' and on the section below we do the same for '.'
1997   0B00 E4            pop a                         ; retrieve the new directory's lba  
1998   0B01 D7            push a                        ; and save again
1999   0B02 53 01 00      add a, 1
2000   0B05 27            mov b, a                      ; metadata sector
2001   0B06 38 00 00      mov c, 0
2002   0B09 FD 79         mov g, b                      ; save lba
2003   0B0B 3B F9 34      mov d, transient_area
2004   0B0E 22 01         mov ah, $01                  ; 1 sector
2005   0B10 07 56 08      call ide_read_sect            ; read metadata sector
2006   0B13             fs_mkdir_l3:
2007   0B13 BD 00         cmp byte[d], 0
2008   0B15 C6 1E 0B      je fs_mkdir_found_null3
2009   0B18 58 20 00      add d, fst_entry_size
2010   0B1B 0A 13 0B      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2011   0B1E             fs_mkdir_found_null3:
2012   0B1E FD 4D 15 1B   mov si, s_parent_dir
2013   0B22 FD 50         mov di, d
2014   0B24 07 0F 14      call _strcpy                  ; copy directory name
2015   0B27 58 18 00      add d, 24                     ; goto attributes
2016   0B2A 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
2017   0B2C 3E            mov [d], al      
2018   0B2D 79            inc d
2019   0B2E 29 F6 1A      mov b, [current_dir_id]        ; retrieve the parent directorys lba
2020   0B31 FD 43         mov [d], b                    ; save lba
2021   0B33             ; set file creation date  
2022   0B33 58 04 00      add d, 4
2023   0B36 19 04         mov al, 4
2024   0B38 05 01         syscall sys_rtc
2025   0B3A 1A            mov al, ah
2026   0B3B 3E            mov [d], al                   ; set day
2027   0B3C 79            inc d
2028   0B3D 19 05         mov al, 5
2029   0B3F 05 01         syscall sys_rtc
2030   0B41 1A            mov al, ah
2031   0B42 3E            mov [d], al                   ; set month
2032   0B43 79            inc d
2033   0B44 19 06         mov al, 6
2034   0B46 05 01         syscall sys_rtc
2035   0B48 1A            mov al, ah
2036   0B49 3E            mov [d], al                   ; set year
2037   0B4A             ; write sector into disk for new directory entry
2038   0B4A FD 27         mov b, g
2039   0B4C 38 00 00      mov c, 0
2040   0B4F 3B F9 34      mov d, transient_area
2041   0B52 22 01         mov ah, $01                   ; disk write, 1 sector
2042   0B54 07 7C 08      call ide_write_sect           ; write sector
2043   0B57             ;;;;;;;;;;;;;
2044   0B57             ; like we did above for '..', we need to now add the '.' directory to the list.
2045   0B57             ;------------------------------------------------------------------------------------------------------;
2046   0B57 E4            pop a                         ; retrieve the new directory's lba  
2047   0B58 D7            push a
2048   0B59 53 01 00      add a, 1
2049   0B5C 27            mov b, a                      ; metadata sector
2050   0B5D 38 00 00      mov c, 0
2051   0B60 FD 79         mov g, b                      ; save lba
2052   0B62 3B F9 34      mov d, transient_area
2053   0B65 22 01         mov ah, $01                  ; 1 sector
2054   0B67 07 56 08      call ide_read_sect            ; read metadata sector
2055   0B6A             fs_mkdir_l4:
2056   0B6A BD 00         cmp byte[d], 0
2057   0B6C C6 75 0B      je fs_mkdir_found_null4
2058   0B6F 58 20 00      add d, fst_entry_size
2059   0B72 0A 6A 0B      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2060   0B75             fs_mkdir_found_null4:
2061   0B75 FD 4D 18 1B   mov si, s_current_dir
2062   0B79 FD 50         mov di, d
2063   0B7B 07 0F 14      call _strcpy                  ; copy directory name
2064   0B7E 58 18 00      add d, 24                     ; goto attributes
2065   0B81 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
2066   0B83 3E            mov [d], al      
2067   0B84 79            inc d
2068   0B85 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
2069   0B86 FD 43         mov [d], b                    ; save lba
2070   0B88             ; set file creation date  
2071   0B88 58 04 00      add d, 4
2072   0B8B 19 04         mov al, 4
2073   0B8D 05 01         syscall sys_rtc
2074   0B8F 1A            mov al, ah
2075   0B90 3E            mov [d], al                   ; set day
2076   0B91 79            inc d
2077   0B92 19 05         mov al, 5
2078   0B94 05 01         syscall sys_rtc
2079   0B96 1A            mov al, ah
2080   0B97 3E            mov [d], al                   ; set month
2081   0B98 79            inc d
2082   0B99 19 06         mov al, 6
2083   0B9B 05 01         syscall sys_rtc
2084   0B9D 1A            mov al, ah
2085   0B9E 3E            mov [d], al                   ; set year
2086   0B9F             ; write sector into disk for new directory entry
2087   0B9F FD 27         mov b, g
2088   0BA1 38 00 00      mov c, 0
2089   0BA4 3B F9 34      mov d, transient_area
2090   0BA7 22 01         mov ah, $01                   ; disk write, 1 sector
2091   0BA9 07 7C 08      call ide_write_sect           ; write sector
2092   0BAC             fs_mkdir_end:
2093   0BAC 06            sysret
2094   0BAD             
2095   0BAD             ;------------------------------------------------------------------------------------------------------;
2096   0BAD             ; get path from a given directory dirid
2097   0BAD             ; pseudo code:
2098   0BAD             ;  fs_dir_id_to_path(int dirid, char *d){
2099   0BAD             ;    if(dirid == 0){
2100   0BAD             ;      reverse path in d;
2101   0BAD             ;      return;
2102   0BAD             ;    }
2103   0BAD             ;    else{
2104   0BAD             ;      copy directory name to end of d;
2105   0BAD             ;      add '/' to end of d;
2106   0BAD             ;      parentid = get parent directory id;
2107   0BAD             ;      fs_dir_id_to_path(parentid, d);
2108   0BAD             ;    }
2109   0BAD             ;  }
2110   0BAD             ; a = dirid
2111   0BAD             ; d = generated path string pointer
2112   0BAD             ;------------------------------------------------------------------------------------------------------;
2113   0BAD             ; sample path: /usr/bin
2114   0BAD             fs_dir_id_to_path:
2115   0BAD 3B 79 20      mov d, filename
2116   0BB0 19 00         mov al, 0
2117   0BB2 3E            mov [d], al                     ; initialize path string 
2118   0BB3 14 F6 1A      mov a, [current_dir_id]
2119   0BB6 07 C3 0B      call fs_dir_id_to_path_e0
2120   0BB9 3B 79 20      mov d, filename
2121   0BBC 07 A3 13      call _strrev
2122   0BBF 07 B7 15      call _puts
2123   0BC2 06            sysret
2124   0BC3             fs_dir_id_to_path_e0:
2125   0BC3 07 E2 0B      call get_dirname_from_dirid
2126   0BC6 FD 4D 1A 1B   mov si, s_fslash
2127   0BCA FD 50         mov di, d
2128   0BCC 07 1D 14      call _strcat                    ; add '/' to end of path
2129   0BCF AF 20 00      cmp a, root_id               ; check if we are at the root directory
2130   0BD2 C6 E1 0B      je fs_dir_id_to_path_root
2131   0BD5 07 FF 0B      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
2132   0BD8 AF 20 00      cmp a, root_id               ; check if we are at the root directory
2133   0BDB C6 E1 0B      je fs_dir_id_to_path_root
2134   0BDE 07 C3 0B      call fs_dir_id_to_path_e0     ; recursively call itself
2135   0BE1             fs_dir_id_to_path_root:
2136   0BE1 09            ret
2137   0BE2             
2138   0BE2             ;------------------------------------------------------------------------------------------------------;
2139   0BE2             ; in_puts:
2140   0BE2             ; a = directory id
2141   0BE2             ; out_puts:
2142   0BE2             ; d = pointer to directory name string
2143   0BE2             ;------------------------------------------------------------------------------------------------------;
2144   0BE2             get_dirname_from_dirid:
2145   0BE2 D7            push a
2146   0BE3 D8            push b
2147   0BE4 DA            push d
2148   0BE5 27            mov b, a
2149   0BE6 38 00 00      mov c, 0                      ; upper lba = 0
2150   0BE9 22 01         mov ah, $01                  ; 1 sector
2151   0BEB 3B F9 32      mov d, transient_area - 512
2152   0BEE 07 56 08      call ide_read_sect            ; read directory
2153   0BF1 07 A3 13      call _strrev                  ; reverse dir name before copying
2154   0BF4 FD 4E         mov si, d
2155   0BF6 E7            pop d                         ; destination address = d value pushed at beginning
2156   0BF7 FD 50         mov di, d
2157   0BF9 07 1D 14      call _strcat                  ; copy filename to d
2158   0BFC E5            pop b
2159   0BFD E4            pop a
2160   0BFE 09            ret
2161   0BFF             
2162   0BFF             ;------------------------------------------------------------------------------------------------------;
2163   0BFF             ; in_puts:
2164   0BFF             ; a = directory id
2165   0BFF             ; out_puts:
2166   0BFF             ; a = parent directory id
2167   0BFF             ;------------------------------------------------------------------------------------------------------;
2168   0BFF             get_parentid_from_dirid:
2169   0BFF D8            push b
2170   0C00 DA            push d
2171   0C01 27            mov b, a
2172   0C02 38 00 00      mov c, 0                      ; upper lba = 0
2173   0C05 22 01         mov ah, $01                  ; 1 sector
2174   0C07 3B F9 32      mov d, transient_area - 512
2175   0C0A 07 56 08      call ide_read_sect            ; read directory
2176   0C0D 16 40 00      mov a, [d + 64]               ; copy parent id value to a
2177   0C10 E7            pop d
2178   0C11 E5            pop b
2179   0C12 09            ret
2180   0C13             
2181   0C13             ;------------------------------------------------------------------------------------------------------;
2182   0C13             ; get dirid from a given path string
2183   0C13             ; in_puts:
2184   0C13             ; d = path pointer 
2185   0C13             ; out_puts:
2186   0C13             ; a = dirid
2187   0C13             ; if dir non existent, a = ffff (fail code)
2188   0C13             ; /usr/local/bin    - absolute
2189   0C13             ; local/bin/games    - relative
2190   0C13             ;------------------------------------------------------------------------------------------------------;
2191   0C13             fs_path_to_dir_id_user:
2192   0C13 FD 4E         mov si, d
2193   0C15 FD 4F F9 20   mov di, user_data
2194   0C19 38 00 02      mov c, 512
2195   0C1C 04            load
2196   0C1D 07 21 0C      call get_dirid_from_path
2197   0C20 06            sysret
2198   0C21             get_dirid_from_path:
2199   0C21 26 F9 20      mov b, user_data
2200   0C24 FD 42 DC 19   mov [prog], b                  ; token pointer set to path string
2201   0C28 07 3D 18      call get_token
2202   0C2B 31 DF 19      mov bl, [tok]
2203   0C2E C1 01         cmp bl, tok_fslash
2204   0C30 C6 3C 0C      je get_dirid_from_path_abs 
2205   0C33 14 F6 1A      mov a, [current_dir_id]
2206   0C36 07 C3 19      call _putback
2207   0C39 0A 3F 0C      jmp get_dirid_from_path_e0
2208   0C3C             get_dirid_from_path_abs:
2209   0C3C 10 20 00      mov a, root_id
2210   0C3F             get_dirid_from_path_e0:
2211   0C3F 07 3D 18      call get_token
2212   0C42 31 DE 19      mov bl, [toktyp]
2213   0C45 C1 00         cmp bl, toktyp_identifier
2214   0C47 C7 98 0C      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2215   0C4A             
2216   0C4A FD 4D E0 19   mov si, tokstr
2217   0C4E FD 4F 79 20   mov di, filename
2218   0C52 07 0F 14      call _strcpy        
2219   0C55 77            inc a                         ; metadata sector
2220   0C56 27            mov b, a
2221   0C57 38 00 00      mov c, 0                      ; upper lba = 0
2222   0C5A 22 01         mov ah, $01                  ; 1 sector
2223   0C5C 3B F9 34      mov d, transient_area
2224   0C5F 07 56 08      call ide_read_sect            ; read directory
2225   0C62 FD 10         cla
2226   0C64 42 EE 1A      mov [index], a
2227   0C67             get_dirid_from_path_l1:
2228   0C67 FD 4E         mov si, d
2229   0C69 FD 4F 79 20   mov di, filename
2230   0C6D 07 FA 13      call _strcmp
2231   0C70 C6 86 0C      je get_dirid_from_path_name_equal  
2232   0C73 58 20 00      add d, 32
2233   0C76 14 EE 1A      mov a, [index]
2234   0C79 77            inc a
2235   0C7A 42 EE 1A      mov [index], a
2236   0C7D AF 10 00      cmp a, fst_files_per_dir
2237   0C80 C6 99 0C      je get_dirid_from_path_fail
2238   0C83 0A 67 0C      jmp get_dirid_from_path_l1
2239   0C86             get_dirid_from_path_name_equal:
2240   0C86 58 19 00      add d, 25           
2241   0C89 15            mov a, [d]                    ; set result register a = dirid
2242   0C8A 07 3D 18      call get_token
2243   0C8D 31 DF 19      mov bl, [tok]
2244   0C90 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
2245   0C92 C6 3F 0C      je get_dirid_from_path_e0
2246   0C95 07 C3 19      call _putback
2247   0C98             get_dirid_from_path_end:
2248   0C98 09            ret
2249   0C99             get_dirid_from_path_fail:
2250   0C99 10 FF FF      mov a, $ffff
2251   0C9C 09            ret
2252   0C9D             
2253   0C9D             
2254   0C9D             ;------------------------------------------------------------------------------------------------------;
2255   0C9D             ; check if file exists by a given path string
2256   0C9D             ; in_puts:
2257   0C9D             ; d = path pointer 
2258   0C9D             ; outputs:
2259   0C9D             ; a = success code, if file exists gives lba, else, give 0
2260   0C9D             ; /usr/local/bin/ed
2261   0C9D             ;------------------------------------------------------------------------------------------------------;
2262   0C9D             fs_filepath_exists_user:
2263   0C9D FD 4E         mov si, d
2264   0C9F FD 4F F9 20   mov di, user_data
2265   0CA3 38 00 02      mov c, 512
2266   0CA6 04            load
2267   0CA7 07 AB 0C      call file_exists_by_path
2268   0CAA 06            sysret
2269   0CAB             file_exists_by_path:
2270   0CAB 26 F9 20      mov b, user_data
2271   0CAE FD 42 DC 19   mov [prog], b                   ; token pointer set to path string
2272   0CB2 07 3D 18      call get_token
2273   0CB5 31 DF 19      mov bl, [tok]
2274   0CB8 C1 01         cmp bl, tok_fslash
2275   0CBA C6 C6 0C      je  file_exists_by_path_abs
2276   0CBD 14 F6 1A      mov a, [current_dir_id]
2277   0CC0 07 C3 19      call _putback
2278   0CC3 0A C9 0C      jmp file_exists_by_path_e0
2279   0CC6             file_exists_by_path_abs:
2280   0CC6 10 20 00      mov a, root_id
2281   0CC9             file_exists_by_path_e0:
2282   0CC9 07 3D 18      call get_token
2283   0CCC 31 DE 19      mov bl, [toktyp]
2284   0CCF C1 00         cmp bl, toktyp_identifier
2285   0CD1 C7 29 0D      jne file_exists_by_path_end     ; check if there are tokens after '/'
2286   0CD4 FD 4D E0 19   mov si, tokstr
2287   0CD8 FD 4F 79 20   mov di, filename
2288   0CDC 07 0F 14      call _strcpy        
2289   0CDF 77            inc a                           ; metadata sector
2290   0CE0 27            mov b, a
2291   0CE1 38 00 00      mov c, 0                        ; upper lba = 0
2292   0CE4 22 01         mov ah, $01                  ; 1 sector
2293   0CE6 3B F9 34      mov d, transient_area
2294   0CE9 07 56 08      call ide_read_sect              ; read directory
2295   0CEC FD 10         cla
2296   0CEE 42 EE 1A      mov [index], a
2297   0CF1             file_exists_by_path_l1:
2298   0CF1 FD 4E         mov si, d
2299   0CF3 FD 4F 79 20   mov di, filename
2300   0CF7 07 FA 13      call _strcmp
2301   0CFA C6 10 0D      je   file_exists_by_path_name_equal
2302   0CFD 58 20 00      add d, 32
2303   0D00 14 EE 1A      mov a, [index]
2304   0D03 77            inc a
2305   0D04 42 EE 1A      mov [index], a
2306   0D07 AF 10 00      cmp a, fst_files_per_dir
2307   0D0A C6 29 0D      je file_exists_by_path_end
2308   0D0D 0A F1 0C      jmp file_exists_by_path_l1
2309   0D10             file_exists_by_path_name_equal:
2310   0D10 33 18 00      mov bl, [d + 24]
2311   0D13 FD 87 38      and bl, %00111000               ; directory flag
2312   0D16 C1 08         cmp bl, %00001000               ; is dir?
2313   0D18 C6 1F 0D      je file_exists_by_path_isdir;
2314   0D1B             ; entry is a file
2315   0D1B 16 19 00      mov a, [d + 25]                 ; get and return lba of file
2316   0D1E 09            ret
2317   0D1F             file_exists_by_path_isdir:
2318   0D1F 58 19 00      add d, 25           
2319   0D22 15            mov a, [d]                      ; set result register a = dirid
2320   0D23 07 3D 18      call get_token
2321   0D26 0A C9 0C      jmp file_exists_by_path_e0
2322   0D29             file_exists_by_path_end:
2323   0D29 10 00 00      mov a, 0                        ; return 0 because file was not found
2324   0D2C 09            ret
2325   0D2D             
2326   0D2D             ;------------------------------------------------------------------------------------------------------;
2327   0D2D             ; load file data from a given path string
2328   0D2D             ; inputs:
2329   0D2D             ; d = path pointer 
2330   0D2D             ; di = userspace program data destination
2331   0D2D             ; /usr/local/bin/ed
2332   0D2D             ; ./ed
2333   0D2D             ;------------------------------------------------------------------------------------------------------;
2334   0D2D             fs_load_from_path_user:
2335   0D2D E3            push di
2336   0D2E FD 4E         mov si, d
2337   0D30 FD 4F F9 20   mov di, user_data
2338   0D34 38 00 02      mov c, 512
2339   0D37 04            load
2340   0D38 07 45 0D      call loadfile_from_path
2341   0D3B F0            pop di
2342   0D3C FD 4D F9 34   mov si, transient_area
2343   0D40 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
2344   0D43 03            store
2345   0D44 06            sysret
2346   0D45             loadfile_from_path:
2347   0D45 26 F9 20      mov b, user_data
2348   0D48 FD 42 DC 19   mov [prog], b                 ; token pointer set to path string
2349   0D4C 07 3D 18      call get_token
2350   0D4F 31 DF 19      mov bl, [tok]
2351   0D52 C1 01         cmp bl, tok_fslash
2352   0D54 C6 60 0D      je loadfile_from_path_abs 
2353   0D57 14 F6 1A      mov a, [current_dir_id]
2354   0D5A 07 C3 19      call _putback
2355   0D5D 0A 63 0D      jmp loadfile_from_path_e0
2356   0D60             loadfile_from_path_abs:
2357   0D60 10 20 00      mov a, root_id
2358   0D63             loadfile_from_path_e0:
2359   0D63 07 3D 18      call get_token
2360   0D66 31 DE 19      mov bl, [toktyp]
2361   0D69 C1 00         cmp bl, toktyp_identifier
2362   0D6B C7 D0 0D      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2363   0D6E FD 4D E0 19   mov si, tokstr
2364   0D72 FD 4F 79 20   mov di, filename
2365   0D76 07 0F 14      call _strcpy        
2366   0D79 77            inc a                         ; metadata sector
2367   0D7A 27            mov b, a
2368   0D7B 38 00 00      mov c, 0                      ; upper lba = 0
2369   0D7E 22 01         mov ah, $01                  ; 1 sector
2370   0D80 3B F9 34      mov d, transient_area
2371   0D83 07 56 08      call ide_read_sect            ; read directory
2372   0D86 FD 10         cla
2373   0D88 42 EE 1A      mov [index], a
2374   0D8B             loadfile_from_path_l1:
2375   0D8B FD 4E         mov si, d
2376   0D8D FD 4F 79 20   mov di, filename
2377   0D91 07 FA 13      call _strcmp
2378   0D94 C6 AA 0D      je loadfile_from_path_name_equal  
2379   0D97 58 20 00      add d, 32
2380   0D9A 14 EE 1A      mov a, [index]
2381   0D9D 77            inc a
2382   0D9E 42 EE 1A      mov [index], a
2383   0DA1 AF 10 00      cmp a, fst_files_per_dir
2384   0DA4 C6 D0 0D      je loadfile_from_path_end
2385   0DA7 0A 8B 0D      jmp loadfile_from_path_l1
2386   0DAA             loadfile_from_path_name_equal:
2387   0DAA 33 18 00      mov bl, [d + 24]
2388   0DAD FD 87 38      and bl, %00111000             ; directory flag
2389   0DB0 C1 08         cmp bl, %00001000             ; is dir?
2390   0DB2 C6 C6 0D      je loadfile_isdirectory  
2391   0DB5             ; entry is a file
2392   0DB5 2B 19 00      mov b, [d + 25]               ; get lba
2393   0DB8 FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
2394   0DBA 3B F9 34      mov d, transient_area
2395   0DBD 38 00 00      mov c, 0
2396   0DC0 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
2397   0DC2 07 56 08      call ide_read_sect            ; read sector
2398   0DC5 09            ret
2399   0DC6             loadfile_isdirectory:
2400   0DC6 58 19 00      add d, 25           
2401   0DC9 15            mov a, [d]                    ; set result register a = dirid
2402   0DCA 07 3D 18      call get_token
2403   0DCD 0A 63 0D      jmp loadfile_from_path_e0
2404   0DD0             loadfile_from_path_end:
2405   0DD0 09            ret
2406   0DD1             
2407   0DD1             ;------------------------------------------------------------------------------------------------------;
2408   0DD1             ; return the id of the current directory
2409   0DD1             ; id returned in b
2410   0DD1             ;------------------------------------------------------------------------------------------------------;
2411   0DD1             fs_get_curr_dirid:
2412   0DD1 29 F6 1A      mov b, [current_dir_id]
2413   0DD4 06            sysret
2414   0DD5             
2415   0DD5             ;------------------------------------------------------------------------------------------------------;
2416   0DD5             ; cd
2417   0DD5             ;------------------------------------------------------------------------------------------------------;
2418   0DD5             ; new dirid in b
2419   0DD5             fs_cd:
2420   0DD5 FD 42 F6 1A   mov [current_dir_id], b
2421   0DD9 06            sysret  
2422   0DDA             
2423   0DDA             ;------------------------------------------------------------------------------------------------------;
2424   0DDA             ; ls
2425   0DDA             ; dirid in b
2426   0DDA             ;------------------------------------------------------------------------------------------------------;
2427   0DDA 00 00       ls_count:       .dw 0
2428   0DDC             fs_ls:
2429   0DDC FD 77         inc b                        ; metadata sector
2430   0DDE 38 00 00      mov c, 0                     ; upper lba = 0
2431   0DE1 22 01         mov ah, $01                  ; 1 sector
2432   0DE3 3B F9 34      mov d, transient_area
2433   0DE6 07 56 08      call ide_read_sect           ; read directory
2434   0DE9 FD 10         cla
2435   0DEB 42 EE 1A      mov [index], a               ; reset entry index
2436   0DEE 3D DA 0D      mov [ls_count], al           ; reset item count
2437   0DF1             fs_ls_l1:
2438   0DF1 BD 00         cmp byte [d], 0              ; check for null
2439   0DF3 C6 8A 0E      je fs_ls_next
2440   0DF6             fs_ls_non_null:
2441   0DF6 1D DA 0D      mov al, [ls_count]
2442   0DF9 7A            inc al
2443   0DFA 3D DA 0D      mov [ls_count], al           ; increment item count
2444   0DFD 1F 18 00      mov al, [d + 24]
2445   0E00 87 38         and al, %00111000
2446   0E02 FD A2 03      shr al, 3
2447   0E05 22 00         mov ah, 0                    ; file type
2448   0E07 B7 21 1B      mov a, [a + file_type]      
2449   0E0A 23            mov ah, al
2450   0E0B 07 8B 14      call _putchar
2451   0E0E 1F 18 00      mov al, [d + 24]
2452   0E11 87 01         and al, %00000001
2453   0E13 22 00         mov ah, 0
2454   0E15 B7 1C 1B      mov a, [a + file_attrib]     ; read
2455   0E18 23            mov ah, al
2456   0E19 07 8B 14      call _putchar
2457   0E1C 1F 18 00      mov al, [d + 24]
2458   0E1F 87 02         and al, %00000010
2459   0E21 22 00         mov ah, 0
2460   0E23 B7 1C 1B      mov a, [a + file_attrib]     ; write
2461   0E26 23            mov ah, al
2462   0E27 07 8B 14      call _putchar
2463   0E2A 1F 18 00      mov al, [d + 24]
2464   0E2D 87 04         and al, %00000100
2465   0E2F 22 00         mov ah, 0
2466   0E31 B7 1C 1B      mov a, [a + file_attrib]     ; execute
2467   0E34 23            mov ah, al
2468   0E35 07 8B 14      call _putchar
2469   0E38 22 20         mov ah, $20
2470   0E3A 07 8B 14      call _putchar  
2471   0E3D 2B 1B 00      mov b, [d + 27]
2472   0E40 07 13 16      call print_u16x              ; filesize
2473   0E43 22 20         mov ah, $20
2474   0E45 07 8B 14      call _putchar  
2475   0E48 2B 19 00      mov b, [d + 25]
2476   0E4B 07 13 16      call print_u16x              ; dirid / lba
2477   0E4E 22 20         mov ah, $20
2478   0E50 07 8B 14      call _putchar
2479   0E53             ; print date
2480   0E53 33 1D 00      mov bl, [d + 29]             ; day
2481   0E56 07 57 16      call print_u8x
2482   0E59 22 20         mov ah, $20
2483   0E5B 07 8B 14      call _putchar  
2484   0E5E 1F 1E 00      mov al, [d + 30]             ; month
2485   0E61 FD 9E 02      shl al, 2
2486   0E64 DA            push d
2487   0E65 3B 87 1C      mov d, s_months
2488   0E68 22 00         mov ah, 0
2489   0E6A 59            add d, a
2490   0E6B 07 B7 15      call _puts
2491   0E6E E7            pop d
2492   0E6F 22 20         mov ah, $20
2493   0E71 07 8B 14      call _putchar
2494   0E74 2E 20         mov bl, $20
2495   0E76 07 57 16      call print_u8x
2496   0E79 33 1F 00      mov bl, [d + 31]             ; year
2497   0E7C 07 57 16      call print_u8x  
2498   0E7F 22 20         mov ah, $20
2499   0E81 07 8B 14      call _putchar  
2500   0E84 07 B7 15      call _puts                   ; print filename  
2501   0E87 07 64 15      call printnl
2502   0E8A             fs_ls_next:
2503   0E8A 14 EE 1A      mov a, [index]
2504   0E8D 77            inc a
2505   0E8E 42 EE 1A      mov [index], a
2506   0E91 AF 10 00      cmp a, fst_files_per_dir
2507   0E94 C6 9D 0E      je fs_ls_end
2508   0E97 58 20 00      add d, 32      
2509   0E9A 0A F1 0D      jmp fs_ls_l1  
2510   0E9D             fs_ls_end:
2511   0E9D 3B 31 1B      mov d, s_ls_total
2512   0EA0 07 B7 15      call _puts
2513   0EA3 1D DA 0D      mov al, [ls_count]
2514   0EA6 07 69 16      call print_u8d
2515   0EA9 07 64 15      call printnl
2516   0EAC 06            sysret
2517   0EAD             
2518   0EAD             ;------------------------------------------------------------------------------------------------------;
2519   0EAD             ; finds an empty data block
2520   0EAD             ; block lba returned in b
2521   0EAD             ;------------------------------------------------------------------------------------------------------;
2522   0EAD             fs_find_empty_block:
2523   0EAD 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2524   0EB0 38 00 00      mov c, 0                ; upper lba = 0
2525   0EB3             fs_find_empty_block_l1:  
2526   0EB3 22 01         mov ah, $01                  ; 1 sector
2527   0EB5 3B F9 32      mov d, transient_area - 512
2528   0EB8 07 56 08      call ide_read_sect      ; read sector
2529   0EBB BD 00         cmp byte [d], 0
2530   0EBD C6 C6 0E      je fs_find_empty_block_found_null
2531   0EC0 55 20 00      add b, fs_sectors_per_file
2532   0EC3 0A B3 0E      jmp fs_find_empty_block_l1
2533   0EC6             fs_find_empty_block_found_null:
2534   0EC6 09            ret
2535   0EC7             
2536   0EC7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2537   0EC7             ;; create new textfile
2538   0EC7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2539   0EC7             ; search for first null block
2540   0EC7             fs_mktxt:
2541   0EC7 FD 4E       	mov si, d
2542   0EC9 FD 4F F9 20 	mov di, user_data
2543   0ECD 38 00 01    	mov c, 256
2544   0ED0 04          	load					; load data from user-space
2545   0ED1             	
2546   0ED1 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2547   0ED4 38 00 00    	mov c, 0						; reset lba to 0
2548   0ED7             fs_mktxt_l1:	
2549   0ED7 10 02 01    	mov a, $0102			; disk read
2550   0EDA 3B F9 34    	mov d, transient_area
2551   0EDD 05 02       	syscall sys_ide ; read sector
2552   0EDF 1E          	mov al, [d]
2553   0EE0 B9 00       	cmp al, 0			; check for null
2554   0EE2 C6 EB 0E    	je fs_mktxt_found_null
2555   0EE5 55 20 00    	add b, fs_sectors_per_file
2556   0EE8 0A D7 0E    	jmp fs_mktxt_l1
2557   0EEB             fs_mktxt_found_null:
2558   0EEB D8          	push b				; save lba
2559   0EEC             ;create header file by grabbing file name from parameter	
2560   0EEC 3B 12 1B    	mov d, s_dataentry
2561   0EEF 07 B7 15    	call _puts
2562   0EF2 3B F9 36    	mov d, transient_area + 512			; pointer to file contents
2563   0EF5 07 1D 15    	call _gettxt
2564   0EF8 07 EA 13    	call _strlen						; get length of file
2565   0EFB D9          	push c							; save length
2566   0EFC 19 01       	mov al, 1
2567   0EFE 3D F9 34    	mov [transient_area], al					; mark sectors as used (not null)
2568   0F01 10 00 00    	mov a, 0
2569   0F04 42 EE 1A    	mov [index], a
2570   0F07 3B F9 34    	mov d, transient_area
2571   0F0A 13          	mov a, d
2572   0F0B 42 F0 1A    	mov [buffer_addr], a
2573   0F0E             fs_mktxt_l2:
2574   0F0E 38 00 00    	mov c, 0
2575   0F11 10 03 01    	mov a, $0103			; disk write, 1 sector
2576   0F14 05 02       	syscall sys_ide		; write sector
2577   0F16 14 EE 1A    	mov a, [index]
2578   0F19 77          	inc a
2579   0F1A 42 EE 1A    	mov [index], a
2580   0F1D AF 20 00    	cmp a, fs_sectors_per_file
2581   0F20 C6 32 0F    	je fs_mktxt_add_to_dir
2582   0F23 FD 77       	inc b
2583   0F25 14 F0 1A    	mov a, [buffer_addr]
2584   0F28 53 00 02    	add a, 512
2585   0F2B 42 F0 1A    	mov [buffer_addr], a
2586   0F2E 3C          	mov d, a
2587   0F2F 0A 0E 0F    	jmp fs_mktxt_l2
2588   0F32             ; now we add the file to the current directory!
2589   0F32             fs_mktxt_add_to_dir:	
2590   0F32 14 F6 1A    	mov a, [current_dir_id]
2591   0F35 77          	inc a
2592   0F36 27          	mov b, a					; metadata sector
2593   0F37 38 00 00    	mov c, 0
2594   0F3A FD 79       	mov g, b					; save lba
2595   0F3C 3B F9 34    	mov d, transient_area
2596   0F3F 10 02 01    	mov a, $0102			; disk read
2597   0F42 05 02       	syscall sys_ide		; read metadata sector
2598   0F44             fs_mktxt_add_to_dir_l2:
2599   0F44 1E          	mov al, [d]
2600   0F45 B9 00       	cmp al, 0
2601   0F47 C6 50 0F    	je fs_mktxt_add_to_dir_null
2602   0F4A 58 20 00    	add d, fst_entry_size
2603   0F4D 0A 44 0F    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2604   0F50             fs_mktxt_add_to_dir_null:
2605   0F50 FD 4D F9 20 	mov si, user_data
2606   0F54 FD 50       	mov di, d
2607   0F56 07 0F 14    	call _strcpy			; copy file name
2608   0F59 58 18 00    	add d, 24			; skip name
2609   0F5C 19 06       	mov al, %00000110		; no execute, write, read, not directory
2610   0F5E 3E          	mov [d], al			
2611   0F5F 58 03 00    	add d, 3
2612   0F62 E4          	pop a
2613   0F63 43          	mov [d], a
2614   0F64 63 02 00    	sub d, 2
2615   0F67 E5          	pop b				; get file lba
2616   0F68 FD 43       	mov [d], b			; save lba	
2617   0F6A             	
2618   0F6A             	; set file creation date	
2619   0F6A 58 04 00    	add d, 4
2620   0F6D 19 04       	mov al, 4
2621   0F6F 05 01       	syscall sys_rtc
2622   0F71 1A          	mov al, ah
2623   0F72 3E          	mov [d], al			; set day
2624   0F73             	
2625   0F73 79          	inc d
2626   0F74 19 05       	mov al, 5
2627   0F76 05 01       	syscall sys_rtc
2628   0F78 1A          	mov al, ah
2629   0F79 3E          	mov [d], al			; set month
2630   0F7A             	
2631   0F7A 79          	inc d
2632   0F7B 19 06       	mov al, 6
2633   0F7D 05 01       	syscall sys_rtc
2634   0F7F 1A          	mov al, ah
2635   0F80 3E          	mov [d], al			; set year
2636   0F81             	
2637   0F81             ; write sector into disk for new directory entry
2638   0F81 FD 27       	mov b, g
2639   0F83 38 00 00    	mov c, 0
2640   0F86 3B F9 34    	mov d, transient_area
2641   0F89 10 03 01    	mov a, $0103			; disk write, 1 sector
2642   0F8C 05 02       	syscall sys_ide		; write sector
2643   0F8E 07 64 15    	call printnl
2644   0F91 06          	sysret
2645   0F92             
2646   0F92             ;------------------------------------------------------------------------------------------------------;
2647   0F92             ; create new binary file
2648   0F92             ;------------------------------------------------------------------------------------------------------;
2649   0F92             ; search for first null block
2650   0F92             fs_mkbin:
2651   0F92 19 00         mov al, 0
2652   0F94 3D E1 1A      mov [sys_echo_on], al ; disable echo
2653   0F97 FD 4E         mov si, d
2654   0F99 FD 4F F9 20   mov di, user_data
2655   0F9D 38 00 02      mov c, 512
2656   0FA0 04            load                          ; load data from user-space
2657   0FA1 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2658   0FA4 38 00 00      mov c, 0                      ; upper lba = 0
2659   0FA7             fs_mkbin_l1:  
2660   0FA7 22 01         mov ah, $01                  ; 1 sector
2661   0FA9 3B F9 34      mov d, transient_area
2662   0FAC 07 56 08      call ide_read_sect            ; read sector
2663   0FAF BD 00         cmp byte[d], 0                ; check for null
2664   0FB1 C6 BA 0F      je fs_mkbin_found_null
2665   0FB4 55 20 00      add b, fs_sectors_per_file
2666   0FB7 0A A7 0F      jmp fs_mkbin_l1
2667   0FBA             fs_mkbin_found_null:
2668   0FBA D8            push b                        ; save lba
2669   0FBB             ;create header file by grabbing file name from parameter
2670   0FBB FD 4F F9 36   mov di, transient_area + 512  ; pointer to file contents
2671   0FBF 07 35 13      call _load_hex                ; load binary hex
2672   0FC2 D9            push c                        ; save size (nbr of bytes)
2673   0FC3 19 01         mov al, 1
2674   0FC5 3D F9 34      mov [transient_area], al      ; mark sectors as used (not null)
2675   0FC8 FD 10         cla
2676   0FCA 42 EE 1A      mov [index], a
2677   0FCD 3B F9 34      mov d, transient_area
2678   0FD0 13            mov a, d
2679   0FD1 42 F0 1A      mov [buffer_addr], a
2680   0FD4             fs_mkbin_l2:
2681   0FD4 38 00 00      mov c, 0
2682   0FD7 22 01         mov ah, $01                   ; disk write, 1 sector
2683   0FD9 07 7C 08      call ide_write_sect           ; write sector
2684   0FDC 14 EE 1A      mov a, [index]
2685   0FDF 77            inc a
2686   0FE0 42 EE 1A      mov [index], a
2687   0FE3 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2688   0FE6 C6 F8 0F      je fs_mkbin_add_to_dir
2689   0FE9 FD 77         inc b
2690   0FEB 14 F0 1A      mov a, [buffer_addr]
2691   0FEE 53 00 02      add a, 512
2692   0FF1 42 F0 1A      mov [buffer_addr], a
2693   0FF4 3C            mov d, a
2694   0FF5 0A D4 0F      jmp fs_mkbin_l2
2695   0FF8             ; now we add the file to the current directory!
2696   0FF8             fs_mkbin_add_to_dir:  
2697   0FF8 14 F6 1A      mov a, [current_dir_id]
2698   0FFB 77            inc a
2699   0FFC 27            mov b, a                      ; metadata sector
2700   0FFD 38 00 00      mov c, 0
2701   1000 FD 79         mov g, b                      ; save lba
2702   1002 3B F9 34      mov d, transient_area
2703   1005 22 01         mov ah, $01                  ; 1 sector
2704   1007 07 56 08      call ide_read_sect            ; read metadata sector
2705   100A             fs_mkbin_add_to_dir_l2:
2706   100A BD 00         cmp byte[d], 0
2707   100C C6 15 10      je fs_mkbin_add_to_dir_null
2708   100F 58 20 00      add d, fst_entry_size
2709   1012 0A 0A 10      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2710   1015             fs_mkbin_add_to_dir_null:
2711   1015 FD 4D F9 20   mov si, user_data
2712   1019 FD 50         mov di, d
2713   101B 07 0F 14      call _strcpy                  ; copy file name
2714   101E 58 18 00      add d, 24                     ; skip name
2715   1021 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2716   1023 3E            mov [d], al
2717   1024 58 03 00      add d, 3
2718   1027 E4            pop a
2719   1028 43            mov [d], a
2720   1029 63 02 00      sub d, 2
2721   102C E5            pop b                         ; get file lba
2722   102D FD 43         mov [d], b                    ; save lba
2723   102F               ; set file creation date  
2724   102F 58 04 00      add d, 4
2725   1032 19 04         mov al, 4
2726   1034 05 01         syscall sys_rtc
2727   1036 1A            mov al, ah
2728   1037 3E            mov [d], al                   ; set day
2729   1038 79            inc d
2730   1039 19 05         mov al, 5
2731   103B 05 01         syscall sys_rtc
2732   103D 1A            mov al, ah
2733   103E 3E            mov [d], al                   ; set month
2734   103F 79            inc d
2735   1040 19 06         mov al, 6
2736   1042 05 01         syscall sys_rtc
2737   1044 1A            mov al, ah
2738   1045 3E            mov [d], al                   ; set year
2739   1046             ; write sector into disk for new directory entry
2740   1046 FD 27         mov b, g
2741   1048 38 00 00      mov c, 0
2742   104B 3B F9 34      mov d, transient_area
2743   104E 22 01         mov ah, $01                   ; disk write, 1 sector
2744   1050 07 7C 08      call ide_write_sect           ; write sector
2745   1053 19 01         mov al, 1
2746   1055 3D E1 1A      mov [sys_echo_on], al ; enable echo
2747   1058 06            sysret
2748   1059             
2749   1059             ;------------------------------------------------------------------------------------------------------;
2750   1059             ; pwd - print working directory
2751   1059             ;------------------------------------------------------------------------------------------------------;    
2752   1059             fs_pwd:
2753   1059 3B 79 20      mov d, filename
2754   105C 19 00         mov al, 0
2755   105E 3E            mov [d], al                   ; initialize path string 
2756   105F 14 F6 1A      mov a, [current_dir_id]
2757   1062 07 C3 0B      call fs_dir_id_to_path_e0
2758   1065 3B 79 20      mov d, filename
2759   1068 07 A3 13      call _strrev
2760   106B 07 B7 15      call _puts
2761   106E 07 64 15      call printnl
2762   1071 06            sysret
2763   1072             
2764   1072             ;------------------------------------------------------------------------------------------------------;
2765   1072             ; get current directory lba
2766   1072             ; a: returned lba
2767   1072             ;------------------------------------------------------------------------------------------------------;
2768   1072             cmd_get_curr_dir_lba:
2769   1072 14 F6 1A      mov a, [current_dir_id]
2770   1075 06            sysret
2771   1076             
2772   1076             ;------------------------------------------------------------------------------------------------------;
2773   1076             ; cat
2774   1076             ; userspace destination data pointer in d
2775   1076             ; filename starts at d, but is overwritten after the read is made
2776   1076             ;------------------------------------------------------------------------------------------------------;:
2777   1076             fs_cat:
2778   1076 DA            push d                              ; save userspace file data destination
2779   1077 FD 4E         mov si, d
2780   1079 FD 4F F9 20   mov di, user_data
2781   107D 38 00 02      mov c, 512
2782   1080 04            load                                ; copy filename from user-space
2783   1081 29 F6 1A      mov b, [current_dir_id]
2784   1084 FD 77         inc b                               ; metadata sector
2785   1086 38 00 00      mov c, 0                            ; upper lba = 0
2786   1089 22 01         mov ah, $01                  ; 1 sector
2787   108B 3B F9 32      mov d, transient_area-512
2788   108E 07 56 08      call ide_read_sect                  ; read directory
2789   1091 FD 10         cla
2790   1093 42 EE 1A      mov [index], a                      ; reset file counter
2791   1096             fs_cat_l1:
2792   1096 FD 4E         mov si, d
2793   1098 FD 4F F9 20   mov di, user_data
2794   109C 07 FA 13      call _strcmp
2795   109F C6 B5 10      je fs_cat_found_entry
2796   10A2 58 20 00      add d, 32
2797   10A5 14 EE 1A      mov a, [index]
2798   10A8 77            inc a
2799   10A9 42 EE 1A      mov [index], a
2800   10AC AF 10 00      cmp a, fst_files_per_dir
2801   10AF C6 D0 10      je fs_cat_not_found
2802   10B2 0A 96 10      jmp fs_cat_l1
2803   10B5             fs_cat_found_entry:
2804   10B5 58 19 00      add d, 25                           ; get to dirid of file in disk
2805   10B8 2A            mov b, [d]                          ; get lba
2806   10B9 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2807   10BB 3B F9 34      mov d, transient_area  
2808   10BE 38 00 00      mov c, 0
2809   10C1 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2810   10C3 07 56 08      call ide_read_sect                  ; read sectors
2811   10C6 F0            pop di                              ; write userspace file data destination to di
2812   10C7 FD 4D F9 34   mov si, transient_area              ; data origin
2813   10CB 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2814   10CE 03            store
2815   10CF 06            sysret
2816   10D0             fs_cat_not_found:
2817   10D0 E7            pop d
2818   10D1 06            sysret
2819   10D2             
2820   10D2             ;------------------------------------------------------------------------------------------------------;
2821   10D2             ; rmdir - remove dir by dirid
2822   10D2             ;------------------------------------------------------------------------------------------------------;
2823   10D2             ; deletes a directory entry in the given directory's file list 
2824   10D2             ; also deletes the actual directory entry in the fst
2825   10D2             ; synopsis: rmdir /usr/local/testdir
2826   10D2             ; b = dirid
2827   10D2             fs_rmdir:
2828   10D2 FD 79         mov g, b
2829   10D4 11            mov a, b
2830   10D5 07 FF 0B      call get_parentid_from_dirid  ; now get the directory's parent, in a
2831   10D8 D7            push a                        ; save dirid
2832   10D9             ; search for directory's entry in the parent's directory then and delete it
2833   10D9 77            inc a                         ; metadata sector
2834   10DA 27            mov b, a
2835   10DB 38 00 00      mov c, 0                      ; upper lba = 0
2836   10DE 22 01         mov ah, $01          ;
2837   10E0 3B F9 34      mov d, transient_area
2838   10E3 07 56 08      call ide_read_sect            ; read directory
2839   10E6 FD 10         cla
2840   10E8 42 EE 1A      mov [index], a                ; reset file counter
2841   10EB FD 27         mov b, g                      ; retrieve directory's dirid
2842   10ED             fs_rmdir_l1:
2843   10ED 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2844   10F0 B0            cmp a, b                      ; compare dirid's to find the directory
2845   10F1 C6 07 11      je fs_rmdir_found_entry
2846   10F4 58 20 00      add d, 32
2847   10F7 14 EE 1A      mov a, [index]
2848   10FA 77            inc a
2849   10FB 42 EE 1A      mov [index], a
2850   10FE AF 10 00      cmp a, fst_files_per_dir
2851   1101 C6 2C 11      je fs_rmdir_not_found
2852   1104 0A ED 10      jmp fs_rmdir_l1
2853   1107             fs_rmdir_found_entry:
2854   1107 FD 10         cla
2855   1109 3E            mov [d], al                   ; make filename null
2856   110A 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2857   110D E5            pop b
2858   110E FD 77         inc b                         ; metadata sector
2859   1110 38 00 00      mov c, 0                      ; upper lba = 0
2860   1113 22 01         mov ah, $01          ; 
2861   1115 3B F9 34      mov d, transient_area
2862   1118 07 7C 08      call ide_write_sect           ; write sector and erase file's entry in the current dir
2863   111B             
2864   111B FD 27         mov b, g
2865   111D 3B F9 34      mov d, transient_area  
2866   1120 FD 10         cla
2867   1122 3E            mov [d], al                   ; make directory's name header null for re-use
2868   1123 38 00 00      mov c, 0
2869   1126 22 01         mov ah, $01                   ; disk write 1 sect
2870   1128 07 7C 08      call ide_write_sect           ; delete directory given by dirid in b
2871   112B 06            sysret
2872   112C             fs_rmdir_not_found:
2873   112C E5            pop b
2874   112D 06            sysret
2875   112E             
2876   112E             ;------------------------------------------------------------------------------------------------------;
2877   112E             ; rm - remove file
2878   112E             ;------------------------------------------------------------------------------------------------------;
2879   112E             ; frees up the data sectors for the file further down the disk
2880   112E             ; deletes file entry in the directory's file list 
2881   112E             fs_rm:
2882   112E FD 4E         mov si, d
2883   1130 FD 4F F9 20   mov di, user_data
2884   1134 38 00 02      mov c, 512
2885   1137 04            load                          ; load data from user-space
2886   1138 14 F6 1A      mov a, [current_dir_id]
2887   113B 77            inc a                         ; metadata sector
2888   113C 27            mov b, a
2889   113D 38 00 00      mov c, 0                      ; upper lba = 0
2890   1140 22 01         mov ah, $01                  ; 1 sector
2891   1142 3B F9 34      mov d, transient_area
2892   1145 07 56 08      call ide_read_sect            ; read directory
2893   1148 10 00 00      mov a, 0
2894   114B 42 EE 1A      mov [index], a                ; reset file counter
2895   114E             fs_rm_l1:
2896   114E FD 4E         mov si, d
2897   1150 FD 4F F9 20   mov di, user_data
2898   1154 07 FA 13      call _strcmp
2899   1157 C6 6D 11      je fs_rm_found_entry
2900   115A 58 20 00      add d, 32
2901   115D 14 EE 1A      mov a, [index]
2902   1160 77            inc a
2903   1161 42 EE 1A      mov [index], a
2904   1164 AF 10 00      cmp a, fst_files_per_dir
2905   1167 C6 95 11      je fs_rm_not_found
2906   116A 0A 4E 11      jmp fs_rm_l1
2907   116D             fs_rm_found_entry:
2908   116D 2B 19 00      mov b, [d + 25]               ; get lba
2909   1170 FD 79         mov g, b                      ; save lba
2910   1172 19 00         mov al, 0
2911   1174 3E            mov [d], al                   ; make file entry null
2912   1175 14 F6 1A      mov a, [current_dir_id]
2913   1178 77            inc a                         ; metadata sector
2914   1179 27            mov b, a
2915   117A 38 00 00      mov c, 0                      ; upper lba = 0
2916   117D 22 01         mov ah, $01                   ; disk write
2917   117F 3B F9 34      mov d, transient_area
2918   1182 07 7C 08      call ide_write_sect           ; write sector and erase file's entry in the current dir
2919   1185 3B F9 34      mov d, transient_area  
2920   1188 19 00         mov al, 0
2921   118A 3E            mov [d], al                   ; make file's data header null for re-use
2922   118B 38 00 00      mov c, 0
2923   118E FD 27         mov b, g                      ; get data header lba
2924   1190 22 01         mov ah, $01                   ; disk write 1 sect
2925   1192 07 7C 08      call ide_write_sect           ; write sector
2926   1195             fs_rm_not_found:  
2927   1195 06            sysret  
2928   1196             
2929   1196             ;------------------------------------------------------------------------------------------------------;
2930   1196             ; mv - move / change file name
2931   1196             ;------------------------------------------------------------------------------------------------------;
2932   1196             fs_mv:
2933   1196 FD 4E         mov si, d
2934   1198 FD 4F F9 20   mov di, user_data
2935   119C 38 00 02      mov c, 512
2936   119F 04            load                          ; load data from user-space
2937   11A0 14 F6 1A      mov a, [current_dir_id]
2938   11A3 77            inc a                         ; metadata sector
2939   11A4 27            mov b, a  
2940   11A5 38 00 00      mov c, 0                      ; upper lba = 0
2941   11A8 22 01         mov ah, $01                  ; 1 sector
2942   11AA 3B F9 34      mov d, transient_area
2943   11AD 07 56 08      call ide_read_sect            ; read directory
2944   11B0 FD 10         cla
2945   11B2 42 EE 1A      mov [index], a                ; reset file counter
2946   11B5             fs_mv_l1:
2947   11B5 FD 4E         mov si, d
2948   11B7 FD 4F F9 20   mov di, user_data
2949   11BB 07 FA 13      call _strcmp
2950   11BE C6 D4 11      je fs_mv_found_entry
2951   11C1 58 20 00      add d, 32
2952   11C4 14 EE 1A      mov a, [index]
2953   11C7 77            inc a
2954   11C8 42 EE 1A      mov [index], a
2955   11CB AF 10 00      cmp a, fst_files_per_dir
2956   11CE C6 06 12      je fs_mv_not_found
2957   11D1 0A B5 11      jmp fs_mv_l1
2958   11D4             fs_mv_found_entry:  
2959   11D4 DA            push d
2960   11D5 FD 4D 79 21   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2961   11D9 FD 50         mov di, d
2962   11DB 07 0F 14      call _strcpy  
2963   11DE 38 00 00      mov c, 0
2964   11E1 3B F9 34      mov d, transient_area
2965   11E4 22 01         mov ah, $01                   ; disk write 1 sect
2966   11E6 07 7C 08      call ide_write_sect           ; write sector
2967   11E9 E7            pop d
2968   11EA             ;; need to check whether its a dir or a file here ;;;
2969   11EA 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2970   11ED 22 01         mov ah, $01
2971   11EF 3B F9 34      mov d, transient_area
2972   11F2 38 00 00      mov c, 0
2973   11F5 07 56 08      call ide_read_sect            ; read directory entry
2974   11F8 FD 4D 79 21   mov si, user_data + 128
2975   11FC FD 50         mov di, d
2976   11FE 07 0F 14      call _strcpy                  ; change directory's name
2977   1201 22 01         mov ah, $01
2978   1203 07 7C 08      call ide_write_sect           ; rewrite directory back to disk
2979   1206             fs_mv_not_found:
2980   1206 06            sysret
2981   1207             
2982   1207             
2983   1207             ;----------------------------------------------------------------------------------------------------;
2984   1207             ; process index in a
2985   1207             ;----------------------------------------------------------------------------------------------------;
2986   1207             find_free_proc:
2987   1207 FD 4D 6A 1E   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2988   120B             find_free_proc_l0:
2989   120B F6            lodsb                               ; get process state
2990   120C B9 00         cmp al, 0
2991   120E C6 14 12      je find_free_proc_free              ; if free, jump
2992   1211 0A 0B 12      jmp find_free_proc_l0               ; else, goto next
2993   1214             find_free_proc_free:
2994   1214 4E            mov a, si
2995   1215 5F 6A 1E      sub a, 1 + proc_availab_table       ; get process index
2996   1218 09            ret
2997   1219               
2998   1219             
2999   1219             ;----------------------------------------------------------------------------------------------------;
3000   1219             ; process index in al
3001   1219             ;----------------------------------------------------------------------------------------------------;
3002   1219             proc_memory_map:
3003   1219 22 00         mov ah, 0
3004   121B 27            mov b, a                      ; page in bl, 0 in bh
3005   121C FD 9D 05      shl a, 5                      ; multiply by 32
3006   121F 39            mov c, a                      ; save in c
3007   1220 57 20 00      add c, 32
3008   1223             proc_memory_map_l0:
3009   1223 02            pagemap
3010   1224 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
3011   1227 53 01 00      add a, 1                      ; increase both 
3012   122A B1            cmp a, c                      ; check to see if we reached the end of memory
3013   122B C7 23 12      jne proc_memory_map_l0
3014   122E 09            ret
3015   122F               
3016   122F             
3017   122F             ;----------------------------------------------------------------------------------------------------;
3018   122F             ; terminate process
3019   122F             ;----------------------------------------------------------------------------------------------------;
3020   122F             syscall_terminate_proc:
3021   122F 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
3022   1232                                                    ; since they will not be used for anything here.
3023   1232 1D ED 1A      mov al, [active_proc_index]
3024   1235 22 00         mov ah, 0  
3025   1237 FD 9D 05      shl a, 5                             ; x32
3026   123A 53 79 1E      add a, proc_names
3027   123D 3C            mov d, a
3028   123E 19 00         mov al, 0
3029   1240 3E            mov [d], al                           ; nullify process name
3030   1241             
3031   1241 1D ED 1A      mov al, [active_proc_index]
3032   1244 22 00         mov ah, 0  
3033   1246 3C            mov d, a
3034   1247 19 00         mov al, 0
3035   1249 3F 69 1E      mov [d + proc_availab_table], al    ; make process empty again
3036   124C               
3037   124C 1D EC 1A      mov al, [nbr_active_procs]          ; decrease nbr of active processes
3038   124F 80            dec al
3039   1250 3D EC 1A      mov [nbr_active_procs], al
3040   1253             
3041   1253             ; now load the shell process again
3042   1253 19 02         mov al, 2                           ; next process = process 2 = shell
3043   1255 3D ED 1A      mov [active_proc_index], al         ; set next active proc
3044   1258             
3045   1258             ; calculate lut entry for next process
3046   1258 22 00         mov ah, 0
3047   125A FD 99         shl a                               ; x2
3048   125C B7 25 13      mov a, [proc_table_convert + a]     ; get process state start index  
3049   125F               
3050   125F 4D            mov si, a                           ; source is proc state block
3051   1260 48            mov a, sp
3052   1261 5F 13 00      sub a, 19
3053   1264 4F            mov di, a                           ; destination is kernel stack
3054   1265             ; restore sp
3055   1265 7D            dec a
3056   1266 47            mov sp, a
3057   1267 38 14 00      mov c, 20
3058   126A FD F5         rep movsb
3059   126C             ; set vm process
3060   126C 1D ED 1A      mov al, [active_proc_index]
3061   126F 01            setptb
3062   1270                 
3063   1270 4C            popa
3064   1271 06            sysret
3065   1272             
3066   1272             ;----------------------------------------------------------------------------------------------------;
3067   1272             ; pause process
3068   1272             ;----------------------------------------------------------------------------------------------------;
3069   1272             syscall_pause_proc:
3070   1272             ; save all registers into kernel stack
3071   1272 4B            pusha
3072   1273 22 00         mov ah, 0
3073   1275 1D ED 1A      mov al, [active_proc_index]
3074   1278 FD 99         shl a              ; x2
3075   127A B7 25 13      mov a, [proc_table_convert + a]   ; get process state start index
3076   127D                 
3077   127D 4F            mov di, a
3078   127E 48            mov a, sp
3079   127F 77            inc a
3080   1280 4D            mov si, a
3081   1281 38 14 00      mov c, 20
3082   1284 FD F5         rep movsb                         ; save process state!
3083   1286             ; restore kernel stack position to point before interrupt arrived
3084   1286 51 14 00      add sp, 20
3085   1289             ; now load the shell process again
3086   1289 19 02         mov al, 2                         ; next process = process 2 = shell
3087   128B 3D ED 1A      mov [active_proc_index], al       ; set next active proc
3088   128E             
3089   128E             ; calculate lut entry for next process
3090   128E 22 00         mov ah, 0
3091   1290 FD 99         shl a                             ; x2
3092   1292 B7 25 13      mov a, [proc_table_convert + a]   ; get process state start index  
3093   1295               
3094   1295 4D            mov si, a                         ; source is proc state block
3095   1296 48            mov a, sp
3096   1297 5F 13 00      sub a, 19
3097   129A 4F            mov di, a                         ; destination is kernel stack
3098   129B             ; restore sp
3099   129B 7D            dec a
3100   129C 47            mov sp, a
3101   129D 38 14 00      mov c, 20
3102   12A0 FD F5         rep movsb
3103   12A2             ; set vm process
3104   12A2 1D ED 1A      mov al, [active_proc_index]
3105   12A5 01            setptb
3106   12A6                 
3107   12A6 4C            popa
3108   12A7 06            sysret
3109   12A8             
3110   12A8             ;----------------------------------------------------------------------------------------------------;
3111   12A8             ; create a new process
3112   12A8             ; d = path of the process file to be createed
3113   12A8             ; b = arguments ptr
3114   12A8             ;----------------------------------------------------------------------------------------------------;
3115   12A8             syscall_create_proc:
3116   12A8             ; we save the active process first  
3117   12A8 4B            pusha
3118   12A9 22 00         mov ah, 0
3119   12AB 1D ED 1A      mov al, [active_proc_index]
3120   12AE FD 99         shl a              ; x2
3121   12B0 B7 25 13      mov a, [proc_table_convert + a]    ; get process state table's start index
3122   12B3               
3123   12B3 4F            mov di, a
3124   12B4 48            mov a, sp
3125   12B5 77            inc a
3126   12B6 4D            mov si, a
3127   12B7 38 14 00      mov c, 20
3128   12BA FD F5         rep movsb                          ; save process state!
3129   12BC             ; restore kernel stack position to point before interrupt arrived
3130   12BC 51 14 00      add sp, 20
3131   12BF               
3132   12BF FD 4E         mov si, d                          ; copy the file path
3133   12C1 FD 4F F9 20   mov di, user_data
3134   12C5 38 00 02      mov c, 512
3135   12C8 04            load
3136   12C9 11            mov a, b
3137   12CA 4D            mov si, a                          ; copy the arguments
3138   12CB FD 4F F9 32   mov di, scrap_sector
3139   12CF 38 00 02      mov c, 512
3140   12D2 04            load
3141   12D3 07 45 0D      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
3142   12D6                                                  ; the file data is loaded into transient_area
3143   12D6             ; now we allocate a new process  
3144   12D6 07 07 12      call find_free_proc                ; index in a
3145   12D9 01            setptb 
3146   12DA 07 19 12      call proc_memory_map               ; map process memory pages
3147   12DD             ; copy arguments into process's memory
3148   12DD FD 4D F9 32   mov si, scrap_sector
3149   12E1 FD 4F 00 00   mov di, 0
3150   12E5 38 00 02      mov c, 512
3151   12E8 03            store
3152   12E9             ; now copy process binary data into process's memory
3153   12E9 FD 4D F9 34   mov si, transient_area
3154   12ED FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
3155   12F1 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
3156   12F4 03            store                              ; copy process data
3157   12F5                 
3158   12F5 07 07 12      call find_free_proc                ; index in a
3159   12F8 3D ED 1A      mov [active_proc_index], al        ; set new active process
3160   12FB FD 9D 05      shl a, 5                           ; x32
3161   12FE 53 79 1E      add a, proc_names
3162   1301 4F            mov di, a
3163   1302 FD 4D F9 20   mov si, user_data                  ; copy and store process filename
3164   1306 07 0F 14      call _strcpy
3165   1309               
3166   1309 07 07 12      call find_free_proc                ; index in a
3167   130C 3C            mov d, a
3168   130D 19 01         mov al, 1
3169   130F 3F 69 1E      mov [d + proc_availab_table], al   ; make process busy
3170   1312               
3171   1312 1D EC 1A      mov al, [nbr_active_procs]         ; increase nbr of active processes
3172   1315 7A            inc al
3173   1316 3D EC 1A      mov [nbr_active_procs], al
3174   1319             ; launch process
3175   1319 FD D7 FF FF   push word $ffff 
3176   131D FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
3177   1320 FD D7 00 04   push word text_org
3178   1324 06            sysret
3179   1325             
3180   1325             proc_table_convert:
3181   1325 29 1D         .dw proc_state_table + 0
3182   1327 3D 1D         .dw proc_state_table + 20
3183   1329 51 1D         .dw proc_state_table + 40
3184   132B 65 1D         .dw proc_state_table + 60
3185   132D 79 1D         .dw proc_state_table + 80
3186   132F 8D 1D         .dw proc_state_table + 100
3187   1331 A1 1D         .dw proc_state_table + 120
3188   1333 B5 1D         .dw proc_state_table + 140
3189   1335               
3190   1335             ;----------------------------------------------------------------------------------------------;
3191   1335             ; get hex file
3192   1335             ; di = destination address
3193   1335             ; return length in bytes in c
3194   1335             ;----------------------------------------------------------------------------------------------;
3195   1335             _load_hex:
3196   1335 D7            push a
3197   1336 D8            push b
3198   1337 DA            push d
3199   1338 E2            push si
3200   1339 E3            push di
3201   133A 38 00 00      mov c, 0
3202   133D 50            mov a, di
3203   133E 3C            mov d, a          ; start of string data block
3204   133F 07 92 14      call _gets        ; get program string
3205   1342 4D            mov si, a
3206   1343             __load_hex_loop:
3207   1343 F6            lodsb             ; load from [si] to al
3208   1344 B9 00         cmp al, 0         ; check if ascii 0
3209   1346 C6 54 13      jz __load_hex_ret
3210   1349 36            mov bh, al
3211   134A F6            lodsb
3212   134B 2F            mov bl, al
3213   134C 07 48 14      call _atoi        ; convert ascii byte in b to int (to al)
3214   134F F7            stosb             ; store al to [di]
3215   1350 78            inc c
3216   1351 0A 43 13      jmp __load_hex_loop
3217   1354             __load_hex_ret:
3218   1354 F0            pop di
3219   1355 EF            pop si
3220   1356 E7            pop d
3221   1357 E5            pop b
3222   1358 E4            pop a
3223   1359 09            ret
3224   135A             
3225   135A             ; synopsis: look inside a certain directory for files/directories
3226   135A             ; before calling this function, cd into required directory
3227   135A             ; for each entry inside directory:
3228   135A             ;  if entry is a file:
3229   135A             ;    compare filename to searched filename
3230   135A             ;    if filenames are the same, print filename
3231   135A             ;  else if entry is a directory:
3232   135A             ;    cd to the given directory
3233   135A             ;    recursively call cmd_find
3234   135A             ;    cd outside previous directory
3235   135A             ;  if current entry == last entry, return
3236   135A             ; endfor
3237   135A             f_find:
3238   135A 09            ret
3239   135B             
3240   135B             
3241   135B             ; ---------------------------------------------------------------------
3242   135B             ; kernel reset vector
3243   135B             ; ---------------------------------------------------------------------
3244   135B             kernel_reset_vector:  
3245   135B FD 49 FF F7   mov bp, _stack_begin
3246   135F FD 47 FF F7   mov sp, _stack_begin
3247   1363               
3248   1363 19 A1         mov al, %10100001             ; mask out timer interrupt for now - enable uarts and fdc irqs 
3249   1365 FD 0F         stomsk                        
3250   1367 FD 0C         sti  
3251   1369             
3252   1369 0C            lodstat
3253   136A 87 DF         and al, %11011111             ; disable display register loading
3254   136C 0D            stostat
3255   136D               
3256   136D             ; reset fifo pointers
3257   136D 10 F9 22      mov a, fifo
3258   1370 3B F2 1A      mov d, fifo_in
3259   1373 43            mov [d], a
3260   1374 3B F4 1A      mov d, fifo_out
3261   1377 43            mov [d], a  
3262   1378 19 02         mov al, 2
3263   137A 05 03         syscall sys_io                ; enable uart in interrupt mode
3264   137C             
3265   137C 3B 47 1B      mov d, s_kernel_welcome
3266   137F 07 B7 15      call _puts
3267   1382             
3268   1382 3B E8 1C      mov d, s_fdc_config
3269   1385 07 B7 15      call _puts
3270   1388 F2 C0 FF 0D   mov byte [_fdc_config], %00001101  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
3271   138C F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011     ; leave this restore command in order to clear BUSY flag
3272   1390 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
3273   1394             
3274   1394 19 10         mov al, 16
3275   1396 05 04         syscall sys_filesystem        ; set root dirid
3276   1398             
3277   1398 3B 0B 1C      mov d, s_prompt_init
3278   139B 07 B7 15      call _puts
3279   139E 3B F8 1A      mov d, s_init_path
3280   13A1 05 05         syscall sys_create_proc       ; launch init as a new process
3281   13A3             
3282   13A3             ; file includes
3283   13A3             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  13A3             boot_origin      .EQU  $8004
0002+  13A3             bios_uart        .EQU  $0002
0003+  13A3             bios_ide         .EQU  $0003
0004+  13A3             bios_reset_vector .EQU  $01c0
0005+  13A3             ide_buffer       .EQU  $8204
3284   13A3             .include "lib/stdio.asm"
0001+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13A3             ; stdio.s
0003+  13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13A3             .include "lib/string.asm"
0001++ 13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 13A3             ; string.s
0003++ 13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 13A3             
0005++ 13A3             
0006++ 13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 13A3             ; _strrev
0008++ 13A3             ; reverse a string
0009++ 13A3             ; d = string address
0010++ 13A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 13A3             ; 01234
0012++ 13A3             _strrev:
0013++ 13A3 4B          	pusha
0014++ 13A4 07 EA 13    	call _strlen	; length in c
0015++ 13A7 12          	mov a, c
0016++ 13A8 AF 01 00    	cmp a, 1
0017++ 13AB D0 C5 13    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 13AE 7D          	dec a
0019++ 13AF FD 4E       	mov si, d	; beginning of string
0020++ 13B1 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 13B3 59          	add d, a	; end of string
0022++ 13B4 12          	mov a, c
0023++ 13B5 FD 9B       	shr a		; divide by 2
0024++ 13B7 39          	mov c, a	; c now counts the steps
0025++ 13B8             _strrev_l0:
0026++ 13B8 32          	mov bl, [d]	; save load right-side char into bl
0027++ 13B9 F6          	lodsb		; load left-side char into al; increase si
0028++ 13BA 3E          	mov [d], al	; store left char into right side
0029++ 13BB 1B          	mov al, bl
0030++ 13BC F7          	stosb		; store right-side char into left-side; increase di
0031++ 13BD 7E          	dec c
0032++ 13BE 7F          	dec d
0033++ 13BF C2 00 00    	cmp c, 0
0034++ 13C2 C7 B8 13    	jne _strrev_l0
0035++ 13C5             _strrev_end:
0036++ 13C5 4C          	popa
0037++ 13C6 09          	ret
0038++ 13C7             	
0039++ 13C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 13C7             ; _strchr
0041++ 13C7             ; search string in d for char in al
0042++ 13C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 13C7             _strchr:
0044++ 13C7             _strchr_l0:
0045++ 13C7 32          	mov bl, [d]
0046++ 13C8 C1 00       	cmp bl, 0
0047++ 13CA C6 D5 13    	je _strchr_end
0048++ 13CD BA          	cmp al, bl
0049++ 13CE C6 D5 13    	je _strchr_end
0050++ 13D1 79          	inc d
0051++ 13D2 0A C7 13    	jmp _strchr_l0
0052++ 13D5             _strchr_end:
0053++ 13D5 1B          	mov al, bl
0054++ 13D6 09          	ret
0055++ 13D7             
0056++ 13D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 13D7             ; _strstr
0058++ 13D7             ; find sub-string
0059++ 13D7             ; str1 in si
0060++ 13D7             ; str2 in di
0061++ 13D7             ; si points to end of source string
0062++ 13D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 13D7             _strstr:
0064++ 13D7 DB          	push al
0065++ 13D8 DA          	push d
0066++ 13D9 E3          	push di
0067++ 13DA             _strstr_loop:
0068++ 13DA F3          	cmpsb					; compare a byte of the strings
0069++ 13DB C7 E6 13    	jne _strstr_ret
0070++ 13DE FC 00 00    	lea d, [di + 0]
0071++ 13E1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 13E3 C7 DA 13    	jne _strstr_loop				; equal chars but not at end
0073++ 13E6             _strstr_ret:
0074++ 13E6 F0          	pop di
0075++ 13E7 E7          	pop d
0076++ 13E8 E8          	pop al
0077++ 13E9 09          	ret
0078++ 13EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 13EA             ; length of null terminated string
0080++ 13EA             ; result in c
0081++ 13EA             ; pointer in d
0082++ 13EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 13EA             _strlen:
0084++ 13EA DA          	push d
0085++ 13EB 38 00 00    	mov c, 0
0086++ 13EE             _strlen_l1:
0087++ 13EE BD 00       	cmp byte [d], 0
0088++ 13F0 C6 F8 13    	je _strlen_ret
0089++ 13F3 79          	inc d
0090++ 13F4 78          	inc c
0091++ 13F5 0A EE 13    	jmp _strlen_l1
0092++ 13F8             _strlen_ret:
0093++ 13F8 E7          	pop d
0094++ 13F9 09          	ret
0095++ 13FA             
0096++ 13FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 13FA             ; strcmp
0098++ 13FA             ; compare two strings
0099++ 13FA             ; str1 in si
0100++ 13FA             ; str2 in di
0101++ 13FA             ; create a string compairon instrucion ?????
0102++ 13FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 13FA             _strcmp:
0104++ 13FA DB          	push al
0105++ 13FB DA          	push d
0106++ 13FC E3          	push di
0107++ 13FD E2          	push si
0108++ 13FE             _strcmp_loop:
0109++ 13FE F3          	cmpsb					; compare a byte of the strings
0110++ 13FF C7 0A 14    	jne _strcmp_ret
0111++ 1402 FB FF FF    	lea d, [si +- 1]
0112++ 1405 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1407 C7 FE 13    	jne _strcmp_loop				; equal chars but not at end
0114++ 140A             _strcmp_ret:
0115++ 140A EF          	pop si
0116++ 140B F0          	pop di
0117++ 140C E7          	pop d
0118++ 140D E8          	pop al
0119++ 140E 09          	ret
0120++ 140F             
0121++ 140F             
0122++ 140F             ; strcpy
0123++ 140F             ; copy null terminated string from si to di
0124++ 140F             ; source in si
0125++ 140F             ; destination in di
0126++ 140F             _strcpy:
0127++ 140F E2          	push si
0128++ 1410 E3          	push di
0129++ 1411 DB          	push al
0130++ 1412             _strcpy_l1:
0131++ 1412 F6          	lodsb
0132++ 1413 F7          	stosb
0133++ 1414 B9 00       	cmp al, 0
0134++ 1416 C7 12 14    	jne _strcpy_l1
0135++ 1419             _strcpy_end:
0136++ 1419 E8          	pop al
0137++ 141A F0          	pop di
0138++ 141B EF          	pop si
0139++ 141C 09          	ret
0140++ 141D             
0141++ 141D             ; strcat
0142++ 141D             ; concatenate a null terminated string into string at di, from string at si
0143++ 141D             ; source in si
0144++ 141D             ; destination in di
0145++ 141D             _strcat:
0146++ 141D E2          	push si
0147++ 141E E3          	push di
0148++ 141F D7          	push a
0149++ 1420 DA          	push d
0150++ 1421 50          	mov a, di
0151++ 1422 3C          	mov d, a
0152++ 1423             _strcat_goto_end_l1:
0153++ 1423 BD 00       	cmp byte[d], 0
0154++ 1425 C6 2C 14    	je _strcat_start
0155++ 1428 79          	inc d
0156++ 1429 0A 23 14    	jmp _strcat_goto_end_l1
0157++ 142C             _strcat_start:
0158++ 142C FD 50       	mov di, d
0159++ 142E             _strcat_l1:
0160++ 142E F6          	lodsb
0161++ 142F F7          	stosb
0162++ 1430 B9 00       	cmp al, 0
0163++ 1432 C7 2E 14    	jne _strcat_l1
0164++ 1435             _strcat_end:
0165++ 1435 E7          	pop d
0166++ 1436 E4          	pop a
0167++ 1437 F0          	pop di
0168++ 1438 EF          	pop si
0169++ 1439 09          	ret
0170++ 143A             
0171++ 143A             
0005+  143A             
0006+  143A             
0007+  143A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  143A             ; convert ascii 'o'..'f' to integer 0..15
0009+  143A             ; ascii in bl
0010+  143A             ; result in al
0011+  143A             ; ascii for f = 0100 0110
0012+  143A             ; ascii for 9 = 0011 1001
0013+  143A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  143A             hex_ascii_encode:
0015+  143A 1B            mov al, bl
0016+  143B 93 40         test al, $40        ; test if letter or number
0017+  143D C7 43 14      jnz hex_letter
0018+  1440 87 0F         and al, $0f        ; get number
0019+  1442 09            ret
0020+  1443             hex_letter:
0021+  1443 87 0F         and al, $0f        ; get letter
0022+  1445 6A 09         add al, 9
0023+  1447 09            ret
0024+  1448             
0025+  1448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1448             ; atoi
0027+  1448             ; 2 letter hex string in b
0028+  1448             ; 8bit integer returned in al
0029+  1448             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1448             _atoi:
0031+  1448 D8            push b
0032+  1449 07 3A 14      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  144C 30            mov bl, bh
0034+  144D DB            push al          ; save a
0035+  144E 07 3A 14      call hex_ascii_encode
0036+  1451 EA            pop bl  
0037+  1452 FD 9E 04      shl al, 4
0038+  1455 8C            or al, bl
0039+  1456 E5            pop b
0040+  1457 09            ret  
0041+  1458             
0042+  1458             
0043+  1458             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1458             ; scanf
0045+  1458             ; no need for explanations!
0046+  1458             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1458             scanf:
0048+  1458 09            ret
0049+  1459             
0050+  1459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1459             ; itoa
0052+  1459             ; 8bit value in bl
0053+  1459             ; 2 byte ascii result in a
0054+  1459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1459             _itoa:
0056+  1459 DA            push d
0057+  145A D8            push b
0058+  145B A7 00         mov bh, 0
0059+  145D FD A4 04      shr bl, 4  
0060+  1460 74            mov d, b
0061+  1461 1F F3 16      mov al, [d + s_hex_digits]
0062+  1464 23            mov ah, al
0063+  1465               
0064+  1465 E5            pop b
0065+  1466 D8            push b
0066+  1467 A7 00         mov bh, 0
0067+  1469 FD 87 0F      and bl, $0f
0068+  146C 74            mov d, b
0069+  146D 1F F3 16      mov al, [d + s_hex_digits]
0070+  1470 E5            pop b
0071+  1471 E7            pop d
0072+  1472 09            ret
0073+  1473             
0074+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1473             ; hex string to binary
0076+  1473             ; di = destination address
0077+  1473             ; si = source
0078+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1473             _hex_to_int:
0080+  1473             _hex_to_int_l1:
0081+  1473 F6            lodsb          ; load from [si] to al
0082+  1474 B9 00         cmp al, 0        ; check if ascii 0
0083+  1476 C6 83 14      jz _hex_to_int_ret
0084+  1479 36            mov bh, al
0085+  147A F6            lodsb
0086+  147B 2F            mov bl, al
0087+  147C 07 48 14      call _atoi        ; convert ascii byte in b to int (to al)
0088+  147F F7            stosb          ; store al to [di]
0089+  1480 0A 73 14      jmp _hex_to_int_l1
0090+  1483             _hex_to_int_ret:
0091+  1483 09            ret    
0092+  1484             
0093+  1484             
0094+  1484             
0095+  1484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1484             ; getchar
0097+  1484             ; char in ah
0098+  1484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1484             getch:
0100+  1484 DB            push al
0101+  1485             getch_retry:
0102+  1485 19 01         mov al, 1
0103+  1487 05 03         syscall sys_io      ; receive in ah
0104+  1489 E8            pop al
0105+  148A 09            ret
0106+  148B             
0107+  148B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  148B             ; putchar
0109+  148B             ; char in ah
0110+  148B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  148B             _putchar:
0112+  148B DB            push al
0113+  148C 19 00         mov al, 0
0114+  148E 05 03         syscall sys_io      ; char in ah
0115+  1490 E8            pop al
0116+  1491 09            ret
0117+  1492             
0118+  1492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1492             ;; input a string
0120+  1492             ;; terminates with null
0121+  1492             ;; pointer in d
0122+  1492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1492             _gets:
0124+  1492 D7            push a
0125+  1493 DA            push d
0126+  1494             _gets_loop:
0127+  1494 19 01         mov al, 1
0128+  1496 05 03         syscall sys_io      ; receive in ah
0129+  1498 76 1B         cmp ah, 27
0130+  149A C6 BB 14      je _gets_ansi_esc
0131+  149D 76 0A         cmp ah, $0a        ; lf
0132+  149F C6 17 15      je _gets_end
0133+  14A2 76 0D         cmp ah, $0d        ; cr
0134+  14A4 C6 17 15      je _gets_end
0135+  14A7 76 5C         cmp ah, $5c        ; '\\'
0136+  14A9 C6 DD 14      je _gets_escape
0137+  14AC 76 08         cmp ah, $08      ; check for backspace
0138+  14AE C6 B7 14      je _gets_backspace
0139+  14B1 1A            mov al, ah
0140+  14B2 3E            mov [d], al
0141+  14B3 79            inc d
0142+  14B4 0A 94 14      jmp _gets_loop
0143+  14B7             _gets_backspace:
0144+  14B7 7F            dec d
0145+  14B8 0A 94 14      jmp _gets_loop
0146+  14BB             _gets_ansi_esc:
0147+  14BB 19 01         mov al, 1
0148+  14BD 05 03         syscall sys_io        ; receive in ah without echo
0149+  14BF 76 5B         cmp ah, '['
0150+  14C1 C7 94 14      jne _gets_loop
0151+  14C4 19 01         mov al, 1
0152+  14C6 05 03         syscall sys_io          ; receive in ah without echo
0153+  14C8 76 64         cmp ah, 'd'
0154+  14CA C6 D5 14      je _gets_left_arrow
0155+  14CD 76 63         cmp ah, 'c'
0156+  14CF C6 D9 14      je _gets_right_arrow
0157+  14D2 0A 94 14      jmp _gets_loop
0158+  14D5             _gets_left_arrow:
0159+  14D5 7F            dec d
0160+  14D6 0A 94 14      jmp _gets_loop
0161+  14D9             _gets_right_arrow:
0162+  14D9 79            inc d
0163+  14DA 0A 94 14      jmp _gets_loop
0164+  14DD             _gets_escape:
0165+  14DD 19 01         mov al, 1
0166+  14DF 05 03         syscall sys_io      ; receive in ah
0167+  14E1 76 6E         cmp ah, 'n'
0168+  14E3 C6 02 15      je _gets_lf
0169+  14E6 76 72         cmp ah, 'r'
0170+  14E8 C6 09 15      je _gets_cr
0171+  14EB 76 30         cmp ah, '0'
0172+  14ED C6 10 15      je _gets_null
0173+  14F0 76 5C         cmp ah, $5c  ; '\'
0174+  14F2 C6 FB 14      je _gets_slash
0175+  14F5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  14F6 3E            mov [d], al
0177+  14F7 79            inc d
0178+  14F8 0A 94 14      jmp _gets_loop
0179+  14FB             _gets_slash:
0180+  14FB 19 5C         mov al, $5c
0181+  14FD 3E            mov [d], al
0182+  14FE 79            inc d
0183+  14FF 0A 94 14      jmp _gets_loop
0184+  1502             _gets_lf:
0185+  1502 19 0A         mov al, $0a
0186+  1504 3E            mov [d], al
0187+  1505 79            inc d
0188+  1506 0A 94 14      jmp _gets_loop
0189+  1509             _gets_cr:
0190+  1509 19 0D         mov al, $0d
0191+  150B 3E            mov [d], al
0192+  150C 79            inc d
0193+  150D 0A 94 14      jmp _gets_loop
0194+  1510             _gets_null:
0195+  1510 19 00         mov al, $00
0196+  1512 3E            mov [d], al
0197+  1513 79            inc d
0198+  1514 0A 94 14      jmp _gets_loop
0199+  1517             _gets_end:
0200+  1517 19 00         mov al, 0
0201+  1519 3E            mov [d], al        ; terminate string
0202+  151A E7            pop d
0203+  151B E4            pop a
0204+  151C 09            ret
0205+  151D             
0206+  151D             
0207+  151D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  151D             ;; input text
0209+  151D             ;; terminated with ctrl+d
0210+  151D             ;; pointer in d
0211+  151D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  151D             _gettxt:
0213+  151D D7            push a
0214+  151E DA            push d
0215+  151F             _gettxt_loop:
0216+  151F 19 01         mov al, 1
0217+  1521 05 03         syscall sys_io      ; receive in ah
0218+  1523 76 04         cmp ah, 4      ; eot
0219+  1525 C6 5E 15      je _gettxt_end
0220+  1528 76 08         cmp ah, $08      ; check for backspace
0221+  152A C6 5A 15      je _gettxt_backspace
0222+  152D 76 5C         cmp ah, $5c        ; '\'
0223+  152F C6 38 15      je _gettxt_escape
0224+  1532 1A            mov al, ah
0225+  1533 3E            mov [d], al
0226+  1534 79            inc d
0227+  1535 0A 1F 15      jmp _gettxt_loop
0228+  1538             _gettxt_escape:
0229+  1538 19 01         mov al, 1
0230+  153A 05 03         syscall sys_io      ; receive in ah
0231+  153C 76 6E         cmp ah, 'n'
0232+  153E C6 4C 15      je _gettxt_lf
0233+  1541 76 72         cmp ah, 'r'
0234+  1543 C6 53 15      je _gettxt_cr
0235+  1546 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1547 3E            mov [d], al
0237+  1548 79            inc d
0238+  1549 0A 1F 15      jmp _gettxt_loop
0239+  154C             _gettxt_lf:
0240+  154C 19 0A         mov al, $0a
0241+  154E 3E            mov [d], al
0242+  154F 79            inc d
0243+  1550 0A 1F 15      jmp _gettxt_loop
0244+  1553             _gettxt_cr:
0245+  1553 19 0D         mov al, $0d
0246+  1555 3E            mov [d], al
0247+  1556 79            inc d
0248+  1557 0A 1F 15      jmp _gettxt_loop
0249+  155A             _gettxt_backspace:
0250+  155A 7F            dec d
0251+  155B 0A 1F 15      jmp _gettxt_loop
0252+  155E             _gettxt_end:
0253+  155E 19 00         mov al, 0
0254+  1560 3E            mov [d], al        ; terminate string
0255+  1561 E7            pop d
0256+  1562 E4            pop a
0257+  1563 09            ret
0258+  1564             
0259+  1564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1564             ; print new line
0261+  1564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1564             printnl:
0263+  1564 D7            push a
0264+  1565 10 00 0A      mov a, $0a00
0265+  1568 05 03         syscall sys_io
0266+  156A 10 00 0D      mov a, $0d00
0267+  156D 05 03         syscall sys_io
0268+  156F E4            pop a
0269+  1570 09            ret
0270+  1571             
0271+  1571             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1571             ; _strtoint
0273+  1571             ; 4 digit hex string number in d
0274+  1571             ; integer returned in a
0275+  1571             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1571             _strtointx:
0277+  1571 D8            push b
0278+  1572 32            mov bl, [d]
0279+  1573 37            mov bh, bl
0280+  1574 33 01 00      mov bl, [d + 1]
0281+  1577 07 48 14      call _atoi        ; convert to int in al
0282+  157A 23            mov ah, al        ; move to ah
0283+  157B 33 02 00      mov bl, [d + 2]
0284+  157E 37            mov bh, bl
0285+  157F 33 03 00      mov bl, [d + 3]
0286+  1582 07 48 14      call _atoi        ; convert to int in al
0287+  1585 E5            pop b
0288+  1586 09            ret
0289+  1587             
0290+  1587             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1587             ; _strtoint
0292+  1587             ; 5 digit base10 string number in d
0293+  1587             ; integer returned in a
0294+  1587             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1587             _strtoint:
0296+  1587 E2            push si
0297+  1588 D8            push b
0298+  1589 D9            push c
0299+  158A DA            push d
0300+  158B 07 EA 13      call _strlen      ; get string length in c
0301+  158E 7E            dec c
0302+  158F FD 4E         mov si, d
0303+  1591 12            mov a, c
0304+  1592 FD 99         shl a
0305+  1594 3B 0B 17      mov d, table_power
0306+  1597 59            add d, a
0307+  1598 38 00 00      mov c, 0
0308+  159B             _strtoint_l0:
0309+  159B F6            lodsb      ; load ascii to al
0310+  159C B9 00         cmp al, 0
0311+  159E C6 B1 15      je _strtoint_end
0312+  15A1 6F 30         sub al, $30    ; make into integer
0313+  15A3 22 00         mov ah, 0
0314+  15A5 2A            mov b, [d]
0315+  15A6 AC            mul a, b      ; result in b since it fits in 16bits
0316+  15A7 11            mov a, b
0317+  15A8 28            mov b, c
0318+  15A9 54            add a, b
0319+  15AA 39            mov c, a
0320+  15AB 63 02 00      sub d, 2
0321+  15AE 0A 9B 15      jmp _strtoint_l0
0322+  15B1             _strtoint_end:
0323+  15B1 12            mov a, c
0324+  15B2 E7            pop d
0325+  15B3 E6            pop c
0326+  15B4 E5            pop b
0327+  15B5 EF            pop si
0328+  15B6 09            ret
0329+  15B7             
0330+  15B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  15B7             ; print null terminated string
0332+  15B7             ; pointer in d
0333+  15B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  15B7             _puts:
0335+  15B7 D7            push a
0336+  15B8 DA            push d
0337+  15B9             _puts_l1:
0338+  15B9 1E            mov al, [d]
0339+  15BA B9 00         cmp al, 0
0340+  15BC C6 C8 15      jz _puts_end
0341+  15BF 23            mov ah, al
0342+  15C0 19 00         mov al, 0
0343+  15C2 05 03         syscall sys_io
0344+  15C4 79            inc d
0345+  15C5 0A B9 15      jmp _puts_l1
0346+  15C8             _puts_end:
0347+  15C8 E7            pop d
0348+  15C9 E4            pop a
0349+  15CA 09            ret
0350+  15CB             
0351+  15CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  15CB             ; print n size string
0353+  15CB             ; pointer in d
0354+  15CB             ; size in c
0355+  15CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  15CB             _putsn:
0357+  15CB DB            push al
0358+  15CC DA            push d
0359+  15CD D9            push c
0360+  15CE             _putsn_l0:
0361+  15CE 1E            mov al, [d]
0362+  15CF 23            mov ah, al
0363+  15D0 19 00         mov al, 0
0364+  15D2 05 03         syscall sys_io
0365+  15D4 79            inc d
0366+  15D5 7E            dec c  
0367+  15D6 C2 00 00      cmp c, 0
0368+  15D9 C7 CE 15      jne _putsn_l0
0369+  15DC             _putsn_end:
0370+  15DC E6            pop c
0371+  15DD E7            pop d
0372+  15DE E8            pop al
0373+  15DF 09            ret
0374+  15E0             
0375+  15E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  15E0             ; print 16bit decimal number
0377+  15E0             ; input number in a
0378+  15E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  15E0             print_u16d:
0380+  15E0 D7            push a
0381+  15E1 D8            push b
0382+  15E2 FD D8         push g
0383+  15E4 26 10 27      mov b, 10000
0384+  15E7 AE            div a, b      ; get 10000's coeff.
0385+  15E8 07 0C 16      call print_number
0386+  15EB 11            mov a, b
0387+  15EC 26 E8 03      mov b, 1000
0388+  15EF AE            div a, b      ; get 1000's coeff.
0389+  15F0 07 0C 16      call print_number
0390+  15F3 11            mov a, b
0391+  15F4 26 64 00      mov b, 100
0392+  15F7 AE            div a, b
0393+  15F8 07 0C 16      call print_number
0394+  15FB 11            mov a, b
0395+  15FC 26 0A 00      mov b, 10
0396+  15FF AE            div a, b
0397+  1600 07 0C 16      call print_number
0398+  1603 1B            mov al, bl      ; 1's coeff in bl
0399+  1604 07 0C 16      call print_number
0400+  1607 FD F1         pop g
0401+  1609 E5            pop b
0402+  160A E4            pop a
0403+  160B 09            ret
0404+  160C             
0405+  160C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  160C             ; print al
0407+  160C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  160C             print_number:
0409+  160C 6A 30         add al, $30
0410+  160E 23            mov ah, al
0411+  160F 07 8B 14      call _putchar
0412+  1612 09            ret
0413+  1613             
0414+  1613             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1613             ; print 16bit hex integer
0416+  1613             ; integer value in reg b
0417+  1613             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1613             print_u16x:
0419+  1613 D7            push a
0420+  1614 D8            push b
0421+  1615 DD            push bl
0422+  1616 30            mov bl, bh
0423+  1617 07 59 14      call _itoa        ; convert bh to char in a
0424+  161A 2F            mov bl, al        ; save al
0425+  161B 19 00         mov al, 0
0426+  161D 05 03         syscall sys_io        ; display ah
0427+  161F 24            mov ah, bl        ; retrieve al
0428+  1620 19 00         mov al, 0
0429+  1622 05 03         syscall sys_io        ; display al
0430+  1624             
0431+  1624 EA            pop bl
0432+  1625 07 59 14      call _itoa        ; convert bh to char in a
0433+  1628 2F            mov bl, al        ; save al
0434+  1629 19 00         mov al, 0
0435+  162B 05 03         syscall sys_io        ; display ah
0436+  162D 24            mov ah, bl        ; retrieve al
0437+  162E 19 00         mov al, 0
0438+  1630 05 03         syscall sys_io        ; display al
0439+  1632             
0440+  1632 E5            pop b
0441+  1633 E4            pop a
0442+  1634 09            ret
0443+  1635             
0444+  1635             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1635             ; input 16bit hex integer
0446+  1635             ; read 16bit integer into a
0447+  1635             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1635             scan_u16x:
0449+  1635 F8 10 00      enter 16
0450+  1638 D8            push b
0451+  1639 DA            push d
0452+  163A             
0453+  163A FA F1 FF      lea d, [bp + -15]
0454+  163D 07 92 14      call _gets        ; get number
0455+  1640             
0456+  1640 32            mov bl, [d]
0457+  1641 37            mov bh, bl
0458+  1642 33 01 00      mov bl, [d + 1]
0459+  1645 07 48 14      call _atoi        ; convert to int in al
0460+  1648 23            mov ah, al        ; move to ah
0461+  1649             
0462+  1649 33 02 00      mov bl, [d + 2]
0463+  164C 37            mov bh, bl
0464+  164D 33 03 00      mov bl, [d + 3]
0465+  1650 07 48 14      call _atoi        ; convert to int in al
0466+  1653             
0467+  1653 E7            pop d
0468+  1654 E5            pop b
0469+  1655 F9            leave
0470+  1656 09            ret
0471+  1657             
0472+  1657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1657             ; print 8bit hex integer
0474+  1657             ; integer value in reg bl
0475+  1657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1657             print_u8x:
0477+  1657 D7            push a
0478+  1658 DD            push bl
0479+  1659             
0480+  1659 07 59 14      call _itoa        ; convert bl to char in a
0481+  165C 2F            mov bl, al        ; save al
0482+  165D 19 00         mov al, 0
0483+  165F 05 03         syscall sys_io        ; display ah
0484+  1661 24            mov ah, bl        ; retrieve al
0485+  1662 19 00         mov al, 0
0486+  1664 05 03         syscall sys_io        ; display al
0487+  1666             
0488+  1666 EA            pop bl
0489+  1667 E4            pop a
0490+  1668 09            ret
0491+  1669             
0492+  1669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1669             ; print 8bit decimal unsigned number
0494+  1669             ; input number in al
0495+  1669             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1669             print_u8d:
0497+  1669 D7            push a
0498+  166A D8            push b
0499+  166B FD D8         push g
0500+  166D 22 00         mov ah, 0
0501+  166F 26 64 00      mov b, 100
0502+  1672 AE            div a, b
0503+  1673 D8            push b      ; save remainder
0504+  1674 B9 00         cmp al, 0
0505+  1676 C6 80 16      je skip100
0506+  1679 6A 30         add al, $30
0507+  167B 23            mov ah, al
0508+  167C 19 00         mov al, 0
0509+  167E 05 03         syscall sys_io  ; print coeff
0510+  1680             skip100:
0511+  1680 E4            pop a
0512+  1681 22 00         mov ah, 0
0513+  1683 26 0A 00      mov b, 10
0514+  1686 AE            div a, b
0515+  1687 D8            push b      ; save remainder
0516+  1688 B9 00         cmp al, 0
0517+  168A C6 94 16      je skip10
0518+  168D 6A 30         add al, $30
0519+  168F 23            mov ah, al
0520+  1690 19 00         mov al, 0
0521+  1692 05 03         syscall sys_io  ; print coeff
0522+  1694             skip10:
0523+  1694 E4            pop a
0524+  1695 1B            mov al, bl
0525+  1696 6A 30         add al, $30
0526+  1698 23            mov ah, al
0527+  1699 19 00         mov al, 0
0528+  169B 05 03         syscall sys_io  ; print coeff
0529+  169D FD F1         pop g
0530+  169F E5            pop b
0531+  16A0 E4            pop a
0532+  16A1 09            ret
0533+  16A2             
0534+  16A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  16A2             ; input 8bit hex integer
0536+  16A2             ; read 8bit integer into al
0537+  16A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  16A2             scan_u8x:
0539+  16A2 F8 04 00      enter 4
0540+  16A5 D8            push b
0541+  16A6 DA            push d
0542+  16A7             
0543+  16A7 FA FD FF      lea d, [bp + -3]
0544+  16AA 07 92 14      call _gets        ; get number
0545+  16AD             
0546+  16AD 32            mov bl, [d]
0547+  16AE 37            mov bh, bl
0548+  16AF 33 01 00      mov bl, [d + 1]
0549+  16B2 07 48 14      call _atoi        ; convert to int in al
0550+  16B5             
0551+  16B5 E7            pop d
0552+  16B6 E5            pop b
0553+  16B7 F9            leave
0554+  16B8 09            ret
0555+  16B9             
0556+  16B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  16B9             ; input decimal number
0558+  16B9             ; result in a
0559+  16B9             ; 655'\0'
0560+  16B9             ; low--------high
0561+  16B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  16B9             scan_u16d:
0563+  16B9 F8 08 00      enter 8
0564+  16BC E2            push si
0565+  16BD D8            push b
0566+  16BE D9            push c
0567+  16BF DA            push d
0568+  16C0 FA F9 FF      lea d, [bp +- 7]
0569+  16C3 07 92 14      call _gets
0570+  16C6 07 EA 13      call _strlen      ; get string length in c
0571+  16C9 7E            dec c
0572+  16CA FD 4E         mov si, d
0573+  16CC 12            mov a, c
0574+  16CD FD 99         shl a
0575+  16CF 3B 0B 17      mov d, table_power
0576+  16D2 59            add d, a
0577+  16D3 38 00 00      mov c, 0
0578+  16D6             mul_loop:
0579+  16D6 F6            lodsb      ; load ascii to al
0580+  16D7 B9 00         cmp al, 0
0581+  16D9 C6 EC 16      je mul_exit
0582+  16DC 6F 30         sub al, $30    ; make into integer
0583+  16DE 22 00         mov ah, 0
0584+  16E0 2A            mov b, [d]
0585+  16E1 AC            mul a, b      ; result in b since it fits in 16bits
0586+  16E2 11            mov a, b
0587+  16E3 28            mov b, c
0588+  16E4 54            add a, b
0589+  16E5 39            mov c, a
0590+  16E6 63 02 00      sub d, 2
0591+  16E9 0A D6 16      jmp mul_loop
0592+  16EC             mul_exit:
0593+  16EC 12            mov a, c
0594+  16ED E7            pop d
0595+  16EE E6            pop c
0596+  16EF E5            pop b
0597+  16F0 EF            pop si
0598+  16F1 F9            leave
0599+  16F2 09            ret
0600+  16F3             
0601+  16F3             
0602+  16F3 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  16F7 34 35 36 37 
0602+  16FB 38 39 61 62 
0602+  16FF 63 64 65 66 
0603+  1703 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  1707 1B 5B 68 00 
0604+  170B             
0605+  170B             table_power:
0606+  170B 01 00         .dw 1
0607+  170D 0A 00         .dw 10
0608+  170F 64 00         .dw 100
0609+  1711 E8 03         .dw 1000
0610+  1713 10 27         .dw 100003285   1715             .include "lib/ctype.asm"
0001+  1715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1715             ; ctype.s
0003+  1715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1715             
0005+  1715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1715             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  1715             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  1715             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  1715             ;; characters are supported.
0010+  1715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1715             ;; _isalnum 
0012+  1715             ;; _isalpha 
0013+  1715             ;; islower 
0014+  1715             ;; isupper 
0015+  1715             ;; _isdigit 
0016+  1715             ;; isxdigit
0017+  1715             ;; iscntrl 
0018+  1715             ;; isgraph 
0019+  1715             ;; _isspace 
0020+  1715             ;; isblank 
0021+  1715             ;; isprint 
0022+  1715             ;; ispunct 
0023+  1715             ;; tolower 
0024+  1715             ;; toupper
0025+  1715             
0026+  1715             
0027+  1715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1715             ;; is alphanumeric
0029+  1715             ;; sets zf according with result
0030+  1715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1715             _isalnum:
0032+  1715 07 32 17    	call _isalpha
0033+  1718 C6 1E 17    	je _isalnum_exit
0034+  171B 07 1F 17    	call _isdigit
0035+  171E             _isalnum_exit:
0036+  171E 09          	ret	
0037+  171F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  171F             ;; is digit
0039+  171F             ;; sets zf according with result
0040+  171F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  171F             _isdigit:
0042+  171F DB          	push al
0043+  1720 B9 30       	cmp al, '0'
0044+  1722 C8 2E 17    	jlu _isdigit_false
0045+  1725 B9 39       	cmp al, '9'
0046+  1727 D1 2E 17    	jgu _isdigit_false
0047+  172A 87 00       	and al, 0	; set zf
0048+  172C E8          	pop al
0049+  172D 09          	ret
0050+  172E             _isdigit_false:
0051+  172E 8B 01       	or al, 1	; clear zf
0052+  1730 E8          	pop al
0053+  1731 09          	ret	
0054+  1732             	
0055+  1732             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1732             ;; is alpha
0057+  1732             ;; sets zf according with result
0058+  1732             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1732             _isalpha:
0060+  1732 DB          	push al
0061+  1733 B9 5F       	cmp al, '_'
0062+  1735 C6 55 17    	je _isalpha_true
0063+  1738 B9 2E       	cmp al, '.'
0064+  173A C6 55 17    	je _isalpha_true
0065+  173D B9 61       	cmp al, 'a'
0066+  173F C8 51 17    	jlu _isalpha_false
0067+  1742 B9 7A       	cmp al, 'z'
0068+  1744 D1 51 17    	jgu _isalpha_false
0069+  1747 B9 7A       	cmp al, 'z'
0070+  1749 D0 55 17    	jleu _isalpha_true
0071+  174C B9 61       	cmp al, 'a'
0072+  174E C9 55 17    	jgeu _isalpha_true
0073+  1751             _isalpha_false:
0074+  1751 8B 01       	or al, 1	; clear zf
0075+  1753 E8          	pop al
0076+  1754 09          	ret
0077+  1755             _isalpha_true:
0078+  1755 87 00       	and al, 0	; set zf
0079+  1757 E8          	pop al
0080+  1758 09          	ret
0081+  1759             
0082+  1759             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1759             ;; is path-alpha
0084+  1759             ;; sets zf according with result
0085+  1759             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1759             ispath:
0087+  1759 DB          	push al
0088+  175A 07 1F 17    	call _isdigit
0089+  175D C6 87 17    	je ispath_true
0090+  1760 B9 5F       	cmp al, '_'
0091+  1762 C6 87 17    	je ispath_true
0092+  1765 B9 2F       	cmp al, '/'
0093+  1767 C6 87 17    	je ispath_true
0094+  176A B9 2E       	cmp al, '.'
0095+  176C C6 87 17    	je ispath_true
0096+  176F B9 61       	cmp al, 'a'
0097+  1771 C8 83 17    	jlu ispath_false
0098+  1774 B9 7A       	cmp al, 'z'
0099+  1776 D1 83 17    	jgu ispath_false
0100+  1779 B9 7A       	cmp al, 'z'
0101+  177B D0 87 17    	jleu ispath_true
0102+  177E B9 61       	cmp al, 'a'
0103+  1780 C9 87 17    	jgeu ispath_true
0104+  1783             ispath_false:
0105+  1783 8B 01       	or al, 1	; clear zf
0106+  1785 E8          	pop al
0107+  1786 09          	ret
0108+  1787             ispath_true:
0109+  1787 87 00       	and al, 0	; set zf
0110+  1789 E8          	pop al
0111+  178A 09          	ret
0112+  178B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  178B             ;; is space
0114+  178B             ;; sets zf according with result
0115+  178B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  178B             _isspace:
0117+  178B B9 20       	cmp al, $20		; ' '
0118+  178D C6 A1 17    	je _isspace_exit
0119+  1790 B9 09       	cmp al, $09		; '\t'
0120+  1792 C6 A1 17    	je _isspace_exit
0121+  1795 B9 0A       	cmp al, $0a		; '\n'
0122+  1797 C6 A1 17    	je _isspace_exit
0123+  179A B9 0D       	cmp al, $0d		; '\r'
0124+  179C C6 A1 17    	je _isspace_exit
0125+  179F B9 0B       	cmp al, $0b		; '\v'
0126+  17A1             _isspace_exit:
0127+  17A1 09          	ret	
0128+  17A2             
0129+  17A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  17A2             ; to lower
0131+  17A2             ; input in al
0132+  17A2             ; output in al
0133+  17A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  17A2             _to_lower:
0135+  17A2 B9 7A       	cmp al, 'z'
0136+  17A4 D1 A9 17    	jgu _to_lower_ret
0137+  17A7 6A 20       	add al, $20				; convert to lower case
0138+  17A9             _to_lower_ret:
0139+  17A9 09          	ret
0140+  17AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  17AA             ; to upper
0142+  17AA             ; input in al
0143+  17AA             ; output in al
0144+  17AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  17AA             _to_upper:
0146+  17AA B9 61       	cmp al, 'a'
0147+  17AC C8 B1 17    	jlu _to_upper_ret
0148+  17AF 6F 20       	sub al, $20			; convert to upper case
0149+  17B1             _to_upper_ret:
0150+  17B1 09          	ret
0151+  17B2             
3286   17B2             .include "lib/token.asm"
0001+  17B2             toktyp_identifier  .equ 0
0002+  17B2             toktyp_keyword     .equ 1
0003+  17B2             toktyp_delimiter   .equ 2
0004+  17B2             toktyp_string      .equ 3
0005+  17B2             toktyp_char        .equ 4
0006+  17B2             toktyp_numeric     .equ 5
0007+  17B2             toktyp_end         .equ 6
0008+  17B2             
0009+  17B2             tok_null           .equ 0
0010+  17B2             tok_fslash         .equ 1
0011+  17B2             tok_times          .equ 2
0012+  17B2             tok_plus           .equ 3
0013+  17B2             tok_minus          .equ 4
0014+  17B2             tok_dot            .equ 5
0015+  17B2             tok_semi           .equ 6
0016+  17B2             tok_angle          .equ 7
0017+  17B2             tok_tilde          .equ 8
0018+  17B2             tok_equal          .equ 9
0019+  17B2             tok_colon          .equ 10
0020+  17B2             tok_comma          .equ 11
0021+  17B2             
0022+  17B2             tok_end            .equ 20
0023+  17B2             
0024+  17B2             
0025+  17B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  17B2             ;; read a full command argment from shell input buffer
0027+  17B2             ;; argument is written into tokstr
0028+  17B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  17B2             get_arg:
0030+  17B2 D7            push a
0031+  17B3 E2            push si
0032+  17B4 E3            push di
0033+  17B5 19 00         mov al, 0
0034+  17B7 3D E0 19      mov [tokstr], al      ; nullify tokstr string
0035+  17BA 14 DC 19      mov a, [prog]
0036+  17BD 4D            mov si, a
0037+  17BE FD 4F E0 19   mov di, tokstr
0038+  17C2             get_arg_skip_spaces:
0039+  17C2 F6            lodsb
0040+  17C3 07 8B 17      call _isspace
0041+  17C6 C6 C2 17      je get_arg_skip_spaces
0042+  17C9             get_arg_l0:
0043+  17C9 B9 3B         cmp al, $3b        ; check if is ';'
0044+  17CB C6 D8 17      je get_arg_end
0045+  17CE B9 00         cmp al, 0
0046+  17D0 C6 D8 17      je get_arg_end      ; check if end of input
0047+  17D3 F7            stosb
0048+  17D4 F6            lodsb
0049+  17D5 0A C9 17      jmp get_arg_l0
0050+  17D8             get_arg_end:
0051+  17D8 19 00         mov al, 0
0052+  17DA F7            stosb
0053+  17DB D5 01 00      sub si, 1
0054+  17DE 4E            mov a, si
0055+  17DF 42 DC 19      mov [prog], a    ; update pointer
0056+  17E2 F0            pop di
0057+  17E3 EF            pop si
0058+  17E4 E4            pop a
0059+  17E5 09            ret
0060+  17E6             
0061+  17E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  17E6             ;; read a path formation from shell input buffer
0063+  17E6             ;; path is written into tokstr
0064+  17E6             ;; /usr/bin
0065+  17E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  17E6             get_path:
0067+  17E6 D7            push a
0068+  17E7 E2            push si
0069+  17E8 E3            push di
0070+  17E9 19 00         mov al, 0
0071+  17EB 3D E0 19      mov [tokstr], al      ; nullify tokstr string
0072+  17EE 14 DC 19      mov a, [prog]
0073+  17F1 4D            mov si, a
0074+  17F2 FD 4F E0 19   mov di, tokstr
0075+  17F6             get_path_skip_spaces:
0076+  17F6 F6            lodsb
0077+  17F7 07 8B 17      call _isspace
0078+  17FA C6 F6 17      je get_path_skip_spaces
0079+  17FD             get_path_is_pathchar:
0080+  17FD F7            stosb
0081+  17FE F6            lodsb
0082+  17FF 07 15 17      call _isalnum      ;check if is alphanumeric
0083+  1802 C6 FD 17      je get_path_is_pathchar
0084+  1805 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1807 C6 FD 17      je get_path_is_pathchar
0086+  180A 19 00         mov al, 0
0087+  180C F7            stosb
0088+  180D D5 01 00      sub si, 1
0089+  1810 4E            mov a, si
0090+  1811 42 DC 19      mov [prog], a    ; update pointer
0091+  1814             get_path_end:
0092+  1814 F0            pop di
0093+  1815 EF            pop si
0094+  1816 E4            pop a
0095+  1817 09            ret
0096+  1818             
0097+  1818             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1818             ;; read a line
0099+  1818             ;; line is written into tokstr
0100+  1818             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1818             get_line:
0102+  1818 D7            push a
0103+  1819 E2            push si
0104+  181A E3            push di
0105+  181B 19 00         mov al, 0
0106+  181D 3D E0 19      mov [tokstr], al      ; nullify tokstr string
0107+  1820 14 DC 19      mov a, [prog]
0108+  1823 4D            mov si, a
0109+  1824 FD 4F E0 19   mov di, tokstr
0110+  1828             get_line_l0:
0111+  1828 F6            lodsb
0112+  1829 B9 0A         cmp al, $0a    ; check for new line
0113+  182B C6 32 18      je get_line_exit
0114+  182E F7            stosb
0115+  182F 0A 28 18      jmp get_line_l0
0116+  1832             get_line_exit:
0117+  1832 19 00         mov al, 0
0118+  1834 F7            stosb
0119+  1835 4E            mov a, si
0120+  1836 42 DC 19      mov [prog], a    ; update pointer
0121+  1839 F0            pop di
0122+  183A EF            pop si
0123+  183B E4            pop a
0124+  183C 09            ret
0125+  183D             
0126+  183D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  183D             ;; token parser
0128+  183D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  183D             get_token:
0130+  183D D7            push a
0131+  183E DA            push d
0132+  183F E2            push si
0133+  1840 E3            push di
0134+  1841 19 00         mov al, 0
0135+  1843 3D E0 19      mov [tokstr], al      ; nullify tokstr string
0136+  1846 19 00         mov al, tok_null
0137+  1848 3D DF 19      mov [tok], al        ; nullify token
0138+  184B 14 DC 19      mov a, [prog]
0139+  184E 4D            mov si, a
0140+  184F FD 4F E0 19   mov di, tokstr
0141+  1853             get_tok_skip_spaces:
0142+  1853 F6            lodsb
0143+  1854 07 8B 17      call _isspace
0144+  1857 C6 53 18      je get_tok_skip_spaces
0145+  185A B9 00         cmp al, 0      ; check for end of input (null)
0146+  185C C6 41 19      je get_token_end
0147+  185F B9 23         cmp al, '#'      ; comments!
0148+  1861 C6 6F 19      je get_tok_comment
0149+  1864 07 15 17      call _isalnum
0150+  1867 C6 4E 19      jz is_alphanumeric
0151+  186A             ; other token types
0152+  186A             get_token_slash:
0153+  186A B9 2F         cmp al, '/'        ; check if '/'
0154+  186C C7 84 18      jne get_token_minus
0155+  186F F7            stosb          ; store '/' into token string
0156+  1870 19 00         mov al, 0
0157+  1872 F7            stosb          ; terminate token string
0158+  1873 19 01         mov al, tok_fslash
0159+  1875 3D DF 19      mov [tok], al      
0160+  1878 19 02         mov al, toktyp_delimiter
0161+  187A 3D DE 19      mov [toktyp], al
0162+  187D 4E            mov a, si
0163+  187E 42 DC 19      mov [prog], a    ; update pointer
0164+  1881 0A 6A 19      jmp get_token_return
0165+  1884             get_token_minus:
0166+  1884 B9 2D         cmp al, '-'        ; check if '-'
0167+  1886 C7 9E 18      jne get_token_comma
0168+  1889 F7            stosb          ; store '-' into token string
0169+  188A 19 00         mov al, 0
0170+  188C F7            stosb          ; terminate token string
0171+  188D 19 04         mov al, tok_minus
0172+  188F 3D DF 19      mov [tok], al      
0173+  1892 19 02         mov al, toktyp_delimiter
0174+  1894 3D DE 19      mov [toktyp], al
0175+  1897 4E            mov a, si
0176+  1898 42 DC 19      mov [prog], a    ; update pointer
0177+  189B 0A 6A 19      jmp get_token_return
0178+  189E             get_token_comma:
0179+  189E B9 2C         cmp al, ','        ; check if ','
0180+  18A0 C7 B8 18      jne get_token_semi
0181+  18A3 F7            stosb          ; store ',' into token string
0182+  18A4 19 00         mov al, 0
0183+  18A6 F7            stosb          ; terminate token string
0184+  18A7 19 0B         mov al, tok_comma
0185+  18A9 3D DF 19      mov [tok], al      
0186+  18AC 19 02         mov al, toktyp_delimiter
0187+  18AE 3D DE 19      mov [toktyp], al
0188+  18B1 4E            mov a, si
0189+  18B2 42 DC 19      mov [prog], a    ; update pointer
0190+  18B5 0A 6A 19      jmp get_token_return
0191+  18B8             get_token_semi:
0192+  18B8 B9 3B         cmp al, $3b        ; check if ';'
0193+  18BA C7 D2 18      jne get_token_colon
0194+  18BD F7            stosb          ; store ';' into token string
0195+  18BE 19 00         mov al, 0
0196+  18C0 F7            stosb          ; terminate token string
0197+  18C1 19 06         mov al, tok_semi
0198+  18C3 3D DF 19      mov [tok], al      
0199+  18C6 19 02         mov al, toktyp_delimiter
0200+  18C8 3D DE 19      mov [toktyp], al
0201+  18CB 4E            mov a, si
0202+  18CC 42 DC 19      mov [prog], a    ; update pointer
0203+  18CF 0A 6A 19      jmp get_token_return
0204+  18D2             get_token_colon:
0205+  18D2 B9 3A         cmp al, $3a        ; check if ':'
0206+  18D4 C7 EC 18      jne get_token_angle
0207+  18D7 F7            stosb          ; store ':' into token string
0208+  18D8 19 00         mov al, 0
0209+  18DA F7            stosb          ; terminate token string
0210+  18DB 19 0A         mov al, tok_colon
0211+  18DD 3D DF 19      mov [tok], al      
0212+  18E0 19 02         mov al, toktyp_delimiter
0213+  18E2 3D DE 19      mov [toktyp], al
0214+  18E5 4E            mov a, si
0215+  18E6 42 DC 19      mov [prog], a    ; update pointer
0216+  18E9 0A 6A 19      jmp get_token_return
0217+  18EC             get_token_angle:
0218+  18EC B9 3E         cmp al, $3e        ; check if '>'
0219+  18EE C7 06 19      jne get_token_tilde
0220+  18F1 F7            stosb          ; store '>' into token string
0221+  18F2 19 00         mov al, 0
0222+  18F4 F7            stosb          ; terminate token string
0223+  18F5 19 07         mov al, tok_angle
0224+  18F7 3D DF 19      mov [tok], al      
0225+  18FA 19 02         mov al, toktyp_delimiter
0226+  18FC 3D DE 19      mov [toktyp], al
0227+  18FF 4E            mov a, si
0228+  1900 42 DC 19      mov [prog], a    ; update pointer
0229+  1903 0A 6A 19      jmp get_token_return
0230+  1906             get_token_tilde:
0231+  1906 B9 7E         cmp al, '~'        ; check if '~'
0232+  1908 C7 20 19      jne get_token_equal
0233+  190B F7            stosb          ; store '~' into token string
0234+  190C 19 00         mov al, 0
0235+  190E F7            stosb          ; terminate token string
0236+  190F 19 08         mov al, tok_tilde
0237+  1911 3D DF 19      mov [tok], al      
0238+  1914 19 02         mov al, toktyp_delimiter
0239+  1916 3D DE 19      mov [toktyp], al
0240+  1919 4E            mov a, si
0241+  191A 42 DC 19      mov [prog], a    ; update pointer
0242+  191D 0A 6A 19      jmp get_token_return
0243+  1920             get_token_equal:
0244+  1920 B9 3D         cmp al, '='        ; check if '='
0245+  1922 C7 3A 19      jne get_token_skip
0246+  1925 F7            stosb          ; store '=' into token string
0247+  1926 19 00         mov al, 0
0248+  1928 F7            stosb          ; terminate token string
0249+  1929 19 09         mov al, tok_equal
0250+  192B 3D DF 19      mov [tok], al      
0251+  192E 19 02         mov al, toktyp_delimiter
0252+  1930 3D DE 19      mov [toktyp], al
0253+  1933 4E            mov a, si
0254+  1934 42 DC 19      mov [prog], a    ; update pointer
0255+  1937 0A 6A 19      jmp get_token_return
0256+  193A             get_token_skip:
0257+  193A 4E            mov a, si
0258+  193B 42 DC 19      mov [prog], a    ; update pointer
0259+  193E 0A 6A 19      jmp get_token_return
0260+  1941             get_token_end:        ; end of file token
0261+  1941 19 14         mov al, tok_end
0262+  1943 3D DF 19      mov [tok], al
0263+  1946 19 06         mov al, toktyp_end
0264+  1948 3D DE 19      mov [toktyp], al
0265+  194B 0A 6A 19      jmp get_token_return
0266+  194E             is_alphanumeric:
0267+  194E F7            stosb
0268+  194F F6            lodsb
0269+  1950 07 15 17      call _isalnum      ;check if is alphanumeric
0270+  1953 C6 4E 19      jz is_alphanumeric
0271+  1956 B9 2E         cmp al, $2e        ; check if is '.'
0272+  1958 C6 4E 19      je is_alphanumeric
0273+  195B 19 00         mov al, 0
0274+  195D F7            stosb
0275+  195E 19 00         mov al, toktyp_identifier
0276+  1960 3D DE 19      mov [toktyp], al
0277+  1963 D5 01 00      sub si, 1
0278+  1966 4E            mov a, si
0279+  1967 42 DC 19      mov [prog], a    ; update pointer
0280+  196A             get_token_return:
0281+  196A F0            pop di
0282+  196B EF            pop si
0283+  196C E7            pop d
0284+  196D E4            pop a
0285+  196E 09            ret
0286+  196F             get_tok_comment:
0287+  196F F6            lodsb
0288+  1970 B9 0A         cmp al, $0a      ; new line
0289+  1972 C7 6F 19      jne get_tok_comment
0290+  1975 0A 53 18      jmp get_tok_skip_spaces
0291+  1978             
0292+  1978             
0293+  1978             get_number:
0294+  1978 D7            push a
0295+  1979 DA            push d
0296+  197A E2            push si
0297+  197B E3            push di
0298+  197C 19 00         mov al, 0
0299+  197E 3D E0 19      mov [tokstr], al      ; nullify tokstr string
0300+  1981 19 00         mov al, tok_null
0301+  1983 3D DF 19      mov [tok], al        ; nullify token
0302+  1986 14 DC 19      mov a, [prog]
0303+  1989 4D            mov si, a
0304+  198A FD 4F E0 19   mov di, tokstr
0305+  198E             get_number_skip_spaces:
0306+  198E F6            lodsb
0307+  198F 07 8B 17      call _isspace
0308+  1992 C6 8E 19      je get_number_skip_spaces
0309+  1995 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1997 C7 A7 19      jne get_number_l0
0311+  199A 19 14         mov al, tok_end
0312+  199C 3D DF 19      mov [tok], al
0313+  199F 19 06         mov al, toktyp_end
0314+  19A1 3D DE 19      mov [toktyp], al
0315+  19A4 0A BE 19      jmp get_number_return
0316+  19A7             get_number_l0:
0317+  19A7 F7            stosb
0318+  19A8 F6            lodsb
0319+  19A9 07 1F 17      call _isdigit      ;check if is numeric
0320+  19AC C6 A7 19      jz get_number_l0
0321+  19AF 19 00         mov al, 0
0322+  19B1 F7            stosb
0323+  19B2 19 05         mov al, toktyp_numeric
0324+  19B4 3D DE 19      mov [toktyp], al
0325+  19B7 D5 01 00      sub si, 1
0326+  19BA 4E            mov a, si
0327+  19BB 42 DC 19      mov [prog], a    ; update pointer
0328+  19BE             get_number_return:
0329+  19BE F0            pop di
0330+  19BF EF            pop si
0331+  19C0 E7            pop d
0332+  19C1 E4            pop a
0333+  19C2 09            ret
0334+  19C3             
0335+  19C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  19C3             ;; put back token
0337+  19C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  19C3             _putback:
0339+  19C3 D7            push a
0340+  19C4 E2            push si
0341+  19C5 FD 4D E0 19   mov si, tokstr  
0342+  19C9             _putback_loop:
0343+  19C9 F6            lodsb
0344+  19CA B9 00         cmp al, 0
0345+  19CC C6 D9 19      je _putback_end
0346+  19CF 14 DC 19      mov a, [prog]
0347+  19D2 7D            dec a
0348+  19D3 42 DC 19      mov [prog], a      ; update pointer
0349+  19D6 0A C9 19      jmp _putback_loop
0350+  19D9             _putback_end:
0351+  19D9 EF            pop si
0352+  19DA E4            pop a
0353+  19DB 09            ret
0354+  19DC             
0355+  19DC             
0356+  19DC             
0357+  19DC             
0358+  19DC 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  19DE             
0360+  19DE 00          toktyp:    .db 0          ; token type symbol
0361+  19DF 00          tok:       .db 0          ; current token symbol
0362+  19E0 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  19E4 00 00 00 00 
0362+  19E8 00 00 00 00 
0362+  19EC 00 00 00 00 
0362+  19F0 00 00 00 00 
0362+  19F4 00 00 00 00 
0362+  19F8 00 00 00 00 
0362+  19FC 00 00 00 00 
0362+  1A00 00 00 00 00 
0362+  1A04 00 00 00 00 
0362+  1A08 00 00 00 00 
0362+  1A0C 00 00 00 00 
0362+  1A10 00 00 00 00 
0362+  1A14 00 00 00 00 
0362+  1A18 00 00 00 00 
0362+  1A1C 00 00 00 00 
0362+  1A20 00 00 00 00 
0362+  1A24 00 00 00 00 
0362+  1A28 00 00 00 00 
0362+  1A2C 00 00 00 00 
0362+  1A30 00 00 00 00 
0362+  1A34 00 00 00 00 
0362+  1A38 00 00 00 00 
0362+  1A3C 00 00 00 00 
0362+  1A40 00 00 00 00 
0362+  1A44 00 00 00 00 
0362+  1A48 00 00 00 00 
0362+  1A4C 00 00 00 00 
0362+  1A50 00 00 00 00 
0362+  1A54 00 00 00 00 
0362+  1A58 00 00 00 00 
0362+  1A5C 00 00 00 00 
0362+  1A60 00 00 00 00 
0362+  1A64 00 00 00 00 
0362+  1A68 00 00 00 00 
0362+  1A6C 00 00 00 00 
0362+  1A70 00 00 00 00 
0362+  1A74 00 00 00 00 
0362+  1A78 00 00 00 00 
0362+  1A7C 00 00 00 00 
0362+  1A80 00 00 00 00 
0362+  1A84 00 00 00 00 
0362+  1A88 00 00 00 00 
0362+  1A8C 00 00 00 00 
0362+  1A90 00 00 00 00 
0362+  1A94 00 00 00 00 
0362+  1A98 00 00 00 00 
0362+  1A9C 00 00 00 00 
0362+  1AA0 00 00 00 00 
0362+  1AA4 00 00 00 00 
0362+  1AA8 00 00 00 00 
0362+  1AAC 00 00 00 00 
0362+  1AB0 00 00 00 00 
0362+  1AB4 00 00 00 00 
0362+  1AB8 00 00 00 00 
0362+  1ABC 00 00 00 00 
0362+  1AC0 00 00 00 00 
0362+  1AC4 00 00 00 00 
0362+  1AC8 00 00 00 00 
0362+  1ACC 00 00 00 00 
0362+  1AD0 00 00 00 00 
0362+  1AD4 00 00 00 00 
0362+  1AD8 00 00 00 00 
0362+  1ADC 00 00 00 00 
3287   1AE0             
3288   1AE0             ; kernel parameters
3289   1AE0             sys_debug_mode:
3290   1AE0 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
3291   1AE1             sys_echo_on:
3292   1AE1 01            .db 1
3293   1AE2             sys_uart0_lcr:
3294   1AE2 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
3295   1AE3             sys_uart0_inten:
3296   1AE3 01            .db 1
3297   1AE4             sys_uart0_fifoen:
3298   1AE4 00            .db 0
3299   1AE5             sys_uart0_div0:
3300   1AE5 03            .db 3
3301   1AE6             sys_uart0_div1:
3302   1AE6 00            .db 0   ; default baud = 38400
3303   1AE7             ; baud  divisor
3304   1AE7             ; 50    2304
3305   1AE7             ; 110   1047
3306   1AE7             ; 300    384
3307   1AE7             ; 600    192
3308   1AE7             ; 1200    96
3309   1AE7             ; 9600    12
3310   1AE7             ; 19200    6
3311   1AE7             ; 38400    3
3312   1AE7             sys_uart1_lcr:
3313   1AE7 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
3314   1AE8             sys_uart1_inten:
3315   1AE8 01            .db 1
3316   1AE9             sys_uart1_fifoen:
3317   1AE9 00            .db 0
3318   1AEA             sys_uart1_div0:
3319   1AEA 03            .db 3
3320   1AEB             sys_uart1_div1:
3321   1AEB 00            .db 0   ; default baud = 38400
3322   1AEC             
3323   1AEC             nbr_active_procs:
3324   1AEC 00            .db 0
3325   1AED             active_proc_index:
3326   1AED 01            .db 1
3327   1AEE             
3328   1AEE             index:
3329   1AEE 00 00         .dw 0
3330   1AF0             buffer_addr:
3331   1AF0 00 00         .dw 0
3332   1AF2             
3333   1AF2             fifo_in:
3334   1AF2 F9 22         .dw fifo
3335   1AF4             fifo_out:
3336   1AF4 F9 22         .dw fifo
3337   1AF6             
3338   1AF6             ; file system variables
3339   1AF6             current_dir_id:
3340   1AF6 00 00         .dw 0     ; keep dirid of current directory
3341   1AF8             s_init_path:
3342   1AF8 2F 73 62 69   .db "/sbin/init", 0
3342   1AFC 6E 2F 69 6E 
3342   1B00 69 74 00 
3343   1B03             
3344   1B03             s_uname:
3345   1B03 73 6F 6C 61   .db "solarium v.1.0", 0
3345   1B07 72 69 75 6D 
3345   1B0B 20 76 2E 31 
3345   1B0F 2E 30 00 
3346   1B12             s_dataentry:
3347   1B12 3E 20 00      .db "> ", 0
3348   1B15             s_parent_dir:
3349   1B15 2E 2E 00      .db "..", 0
3350   1B18             s_current_dir:
3351   1B18 2E 00         .db ".", 0
3352   1B1A             s_fslash:
3353   1B1A 2F 00         .db "/", 0
3354   1B1C             file_attrib:
3355   1B1C 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
3355   1B20 78 
3356   1B21             file_type:
3357   1B21 2D 64 63      .db "-dc"
3358   1B24             s_ps_header:
3359   1B24 70 69 64 20   .db "pid command\n", 0
3359   1B28 63 6F 6D 6D 
3359   1B2C 61 6E 64 0A 
3359   1B30 00 
3360   1B31             s_ls_total:
3361   1B31 74 6F 74 61   .db "total: ", 0
3361   1B35 6C 3A 20 00 
3362   1B39             
3363   1B39             s_int_en:
3364   1B39 69 72 71 73   .db "irqs enabled\n", 0
3364   1B3D 20 65 6E 61 
3364   1B41 62 6C 65 64 
3364   1B45 0A 00 
3365   1B47             s_kernel_welcome:
3366   1B47 2A 2A 2A 2A   .db "************************************************\n"
3366   1B4B 2A 2A 2A 2A 
3366   1B4F 2A 2A 2A 2A 
3366   1B53 2A 2A 2A 2A 
3366   1B57 2A 2A 2A 2A 
3366   1B5B 2A 2A 2A 2A 
3366   1B5F 2A 2A 2A 2A 
3366   1B63 2A 2A 2A 2A 
3366   1B67 2A 2A 2A 2A 
3366   1B6B 2A 2A 2A 2A 
3366   1B6F 2A 2A 2A 2A 
3366   1B73 2A 2A 2A 2A 
3366   1B77 0A 
3367   1B78 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
3367   1B7C 57 65 6C 63 
3367   1B80 6F 6D 65 20 
3367   1B84 74 6F 20 53 
3367   1B88 6F 6C 61 72 
3367   1B8C 69 75 6D 20 
3367   1B90 4F 53 20 2D 
3367   1B94 20 4B 65 72 
3367   1B98 6E 65 6C 20 
3367   1B9C 76 65 72 2E 
3367   1BA0 20 31 2E 30 
3367   1BA4 20 2A 2A 2A 
3367   1BA8 0A 
3368   1BA9 2A 2A 2A 20   .db "*** type help for more information           ***\n"
3368   1BAD 74 79 70 65 
3368   1BB1 20 68 65 6C 
3368   1BB5 70 20 66 6F 
3368   1BB9 72 20 6D 6F 
3368   1BBD 72 65 20 69 
3368   1BC1 6E 66 6F 72 
3368   1BC5 6D 61 74 69 
3368   1BC9 6F 6E 20 20 
3368   1BCD 20 20 20 20 
3368   1BD1 20 20 20 20 
3368   1BD5 20 2A 2A 2A 
3368   1BD9 0A 
3369   1BDA 2A 2A 2A 2A   .db "************************************************\n"
3369   1BDE 2A 2A 2A 2A 
3369   1BE2 2A 2A 2A 2A 
3369   1BE6 2A 2A 2A 2A 
3369   1BEA 2A 2A 2A 2A 
3369   1BEE 2A 2A 2A 2A 
3369   1BF2 2A 2A 2A 2A 
3369   1BF6 2A 2A 2A 2A 
3369   1BFA 2A 2A 2A 2A 
3369   1BFE 2A 2A 2A 2A 
3369   1C02 2A 2A 2A 2A 
3369   1C06 2A 2A 2A 2A 
3369   1C0A 0A 
3370   1C0B             s_prompt_init:
3371   1C0B 73 74 61 72   .db "starting init\n", 0
3371   1C0F 74 69 6E 67 
3371   1C13 20 69 6E 69 
3371   1C17 74 0A 00 
3372   1C1A             s_priviledge:
3373   1C1A 0A 65 78 63   .db "\nexception: privilege\n", 0
3373   1C1E 65 70 74 69 
3373   1C22 6F 6E 3A 20 
3373   1C26 70 72 69 76 
3373   1C2A 69 6C 65 67 
3373   1C2E 65 0A 00 
3374   1C31             s_divzero:
3375   1C31 0A 65 78 63   .db "\nexception: zero division\n", 0
3375   1C35 65 70 74 69 
3375   1C39 6F 6E 3A 20 
3375   1C3D 7A 65 72 6F 
3375   1C41 20 64 69 76 
3375   1C45 69 73 69 6F 
3375   1C49 6E 0A 00 
3376   1C4C             
3377   1C4C             s_set_year:
3378   1C4C 79 65 61 72   .db "year: ", 0
3378   1C50 3A 20 00 
3379   1C53             s_set_month:
3380   1C53 6D 6F 6E 74   .db "month: ", 0
3380   1C57 68 3A 20 00 
3381   1C5B             s_set_day:
3382   1C5B 64 61 79 3A   .db "day: ", 0
3382   1C5F 20 00 
3383   1C61             s_set_week:
3384   1C61 77 65 65 6B   .db "weekday: ", 0
3384   1C65 64 61 79 3A 
3384   1C69 20 00 
3385   1C6B             s_set_hours:
3386   1C6B 68 6F 75 72   .db "hours: ", 0
3386   1C6F 73 3A 20 00 
3387   1C73             s_set_minutes:
3388   1C73 6D 69 6E 75   .db "minutes: ", 0
3388   1C77 74 65 73 3A 
3388   1C7B 20 00 
3389   1C7D             s_set_seconds:
3390   1C7D 73 65 63 6F   .db "seconds: ", 0
3390   1C81 6E 64 73 3A 
3390   1C85 20 00 
3391   1C87             s_months:      
3392   1C87 20 20 20 00   .db "   ", 0
3393   1C8B 6A 61 6E 00   .db "jan", 0
3394   1C8F 66 65 62 00   .db "feb", 0
3395   1C93 6D 61 72 00   .db "mar", 0
3396   1C97 61 70 72 00   .db "apr", 0
3397   1C9B 6D 61 79 00   .db "may", 0
3398   1C9F 6A 75 6E 00   .db "jun", 0
3399   1CA3 6A 75 6C 00   .db "jul", 0
3400   1CA7 61 75 67 00   .db "aug", 0
3401   1CAB 73 65 70 00   .db "sep", 0
3402   1CAF 6F 63 74 00   .db "oct", 0
3403   1CB3 6E 6F 76 00   .db "nov", 0
3404   1CB7 64 65 63 00   .db "dec", 0
3405   1CBB             
3406   1CBB             s_week:        
3407   1CBB 73 75 6E 00   .db "sun", 0 
3408   1CBF 6D 6F 6E 00   .db "mon", 0 
3409   1CC3 74 75 65 00   .db "tue", 0 
3410   1CC7 77 65 64 00   .db "wed", 0 
3411   1CCB 74 68 75 00   .db "thu", 0 
3412   1CCF 66 72 69 00   .db "fri", 0 
3413   1CD3 73 61 74 00   .db "sat", 0
3414   1CD7             
3415   1CD7 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
3415   1CDB 30 20 45 78 
3415   1CDF 65 63 75 74 
3415   1CE3 65 64 2E 0A 
3415   1CE7 00 
3416   1CE8             s_fdc_config:
3417   1CE8 73 65 6C 65   .db "selecting diskette drive 0, side 0, single density, head loaded\n", 0
3417   1CEC 63 74 69 6E 
3417   1CF0 67 20 64 69 
3417   1CF4 73 6B 65 74 
3417   1CF8 74 65 20 64 
3417   1CFC 72 69 76 65 
3417   1D00 20 30 2C 20 
3417   1D04 73 69 64 65 
3417   1D08 20 30 2C 20 
3417   1D0C 73 69 6E 67 
3417   1D10 6C 65 20 64 
3417   1D14 65 6E 73 69 
3417   1D18 74 79 2C 20 
3417   1D1C 68 65 61 64 
3417   1D20 20 6C 6F 61 
3417   1D24 64 65 64 0A 
3417   1D28 00 
3418   1D29             
3419   1D29             proc_state_table:   
3420   1D29 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
3420   1D2D 00 00 00 00 
3420   1D31 00 00 00 00 
3420   1D35 00 00 00 00 
3420   1D39 00 00 00 00 
3420   1D3D 00 00 00 00 
3420   1D41 00 00 00 00 
3420   1D45 00 00 00 00 
3420   1D49 00 00 00 00 
3420   1D4D 00 00 00 00 
3420   1D51 00 00 00 00 
3420   1D55 00 00 00 00 
3420   1D59 00 00 00 00 
3420   1D5D 00 00 00 00 
3420   1D61 00 00 00 00 
3420   1D65 00 00 00 00 
3420   1D69 00 00 00 00 
3420   1D6D 00 00 00 00 
3420   1D71 00 00 00 00 
3420   1D75 00 00 00 00 
3420   1D79 00 00 00 00 
3420   1D7D 00 00 00 00 
3420   1D81 00 00 00 00 
3420   1D85 00 00 00 00 
3420   1D89 00 00 00 00 
3420   1D8D 00 00 00 00 
3420   1D91 00 00 00 00 
3420   1D95 00 00 00 00 
3420   1D99 00 00 00 00 
3420   1D9D 00 00 00 00 
3420   1DA1 00 00 00 00 
3420   1DA5 00 00 00 00 
3420   1DA9 00 00 00 00 
3420   1DAD 00 00 00 00 
3420   1DB1 00 00 00 00 
3420   1DB5 00 00 00 00 
3420   1DB9 00 00 00 00 
3420   1DBD 00 00 00 00 
3420   1DC1 00 00 00 00 
3420   1DC5 00 00 00 00 
3420   1DC9 00 00 00 00 
3420   1DCD 00 00 00 00 
3420   1DD1 00 00 00 00 
3420   1DD5 00 00 00 00 
3420   1DD9 00 00 00 00 
3420   1DDD 00 00 00 00 
3420   1DE1 00 00 00 00 
3420   1DE5 00 00 00 00 
3420   1DE9 00 00 00 00 
3420   1DED 00 00 00 00 
3420   1DF1 00 00 00 00 
3420   1DF5 00 00 00 00 
3420   1DF9 00 00 00 00 
3420   1DFD 00 00 00 00 
3420   1E01 00 00 00 00 
3420   1E05 00 00 00 00 
3420   1E09 00 00 00 00 
3420   1E0D 00 00 00 00 
3420   1E11 00 00 00 00 
3420   1E15 00 00 00 00 
3420   1E19 00 00 00 00 
3420   1E1D 00 00 00 00 
3420   1E21 00 00 00 00 
3420   1E25 00 00 00 00 
3420   1E29 00 00 00 00 
3420   1E2D 00 00 00 00 
3420   1E31 00 00 00 00 
3420   1E35 00 00 00 00 
3420   1E39 00 00 00 00 
3420   1E3D 00 00 00 00 
3420   1E41 00 00 00 00 
3420   1E45 00 00 00 00 
3420   1E49 00 00 00 00 
3420   1E4D 00 00 00 00 
3420   1E51 00 00 00 00 
3420   1E55 00 00 00 00 
3420   1E59 00 00 00 00 
3420   1E5D 00 00 00 00 
3420   1E61 00 00 00 00 
3420   1E65 00 00 00 00 
3421   1E69             proc_availab_table: 
3422   1E69 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
3422   1E6D 00 00 00 00 
3422   1E71 00 00 00 00 
3422   1E75 00 00 00 00 
3423   1E79             proc_names:
3424   1E79 00 00 00 00   .fill 16 * 32, 0  ; process names
3424   1E7D 00 00 00 00 
3424   1E81 00 00 00 00 
3424   1E85 00 00 00 00 
3424   1E89 00 00 00 00 
3424   1E8D 00 00 00 00 
3424   1E91 00 00 00 00 
3424   1E95 00 00 00 00 
3424   1E99 00 00 00 00 
3424   1E9D 00 00 00 00 
3424   1EA1 00 00 00 00 
3424   1EA5 00 00 00 00 
3424   1EA9 00 00 00 00 
3424   1EAD 00 00 00 00 
3424   1EB1 00 00 00 00 
3424   1EB5 00 00 00 00 
3424   1EB9 00 00 00 00 
3424   1EBD 00 00 00 00 
3424   1EC1 00 00 00 00 
3424   1EC5 00 00 00 00 
3424   1EC9 00 00 00 00 
3424   1ECD 00 00 00 00 
3424   1ED1 00 00 00 00 
3424   1ED5 00 00 00 00 
3424   1ED9 00 00 00 00 
3424   1EDD 00 00 00 00 
3424   1EE1 00 00 00 00 
3424   1EE5 00 00 00 00 
3424   1EE9 00 00 00 00 
3424   1EED 00 00 00 00 
3424   1EF1 00 00 00 00 
3424   1EF5 00 00 00 00 
3424   1EF9 00 00 00 00 
3424   1EFD 00 00 00 00 
3424   1F01 00 00 00 00 
3424   1F05 00 00 00 00 
3424   1F09 00 00 00 00 
3424   1F0D 00 00 00 00 
3424   1F11 00 00 00 00 
3424   1F15 00 00 00 00 
3424   1F19 00 00 00 00 
3424   1F1D 00 00 00 00 
3424   1F21 00 00 00 00 
3424   1F25 00 00 00 00 
3424   1F29 00 00 00 00 
3424   1F2D 00 00 00 00 
3424   1F31 00 00 00 00 
3424   1F35 00 00 00 00 
3424   1F39 00 00 00 00 
3424   1F3D 00 00 00 00 
3424   1F41 00 00 00 00 
3424   1F45 00 00 00 00 
3424   1F49 00 00 00 00 
3424   1F4D 00 00 00 00 
3424   1F51 00 00 00 00 
3424   1F55 00 00 00 00 
3424   1F59 00 00 00 00 
3424   1F5D 00 00 00 00 
3424   1F61 00 00 00 00 
3424   1F65 00 00 00 00 
3424   1F69 00 00 00 00 
3424   1F6D 00 00 00 00 
3424   1F71 00 00 00 00 
3424   1F75 00 00 00 00 
3424   1F79 00 00 00 00 
3424   1F7D 00 00 00 00 
3424   1F81 00 00 00 00 
3424   1F85 00 00 00 00 
3424   1F89 00 00 00 00 
3424   1F8D 00 00 00 00 
3424   1F91 00 00 00 00 
3424   1F95 00 00 00 00 
3424   1F99 00 00 00 00 
3424   1F9D 00 00 00 00 
3424   1FA1 00 00 00 00 
3424   1FA5 00 00 00 00 
3424   1FA9 00 00 00 00 
3424   1FAD 00 00 00 00 
3424   1FB1 00 00 00 00 
3424   1FB5 00 00 00 00 
3424   1FB9 00 00 00 00 
3424   1FBD 00 00 00 00 
3424   1FC1 00 00 00 00 
3424   1FC5 00 00 00 00 
3424   1FC9 00 00 00 00 
3424   1FCD 00 00 00 00 
3424   1FD1 00 00 00 00 
3424   1FD5 00 00 00 00 
3424   1FD9 00 00 00 00 
3424   1FDD 00 00 00 00 
3424   1FE1 00 00 00 00 
3424   1FE5 00 00 00 00 
3424   1FE9 00 00 00 00 
3424   1FED 00 00 00 00 
3424   1FF1 00 00 00 00 
3424   1FF5 00 00 00 00 
3424   1FF9 00 00 00 00 
3424   1FFD 00 00 00 00 
3424   2001 00 00 00 00 
3424   2005 00 00 00 00 
3424   2009 00 00 00 00 
3424   200D 00 00 00 00 
3424   2011 00 00 00 00 
3424   2015 00 00 00 00 
3424   2019 00 00 00 00 
3424   201D 00 00 00 00 
3424   2021 00 00 00 00 
3424   2025 00 00 00 00 
3424   2029 00 00 00 00 
3424   202D 00 00 00 00 
3424   2031 00 00 00 00 
3424   2035 00 00 00 00 
3424   2039 00 00 00 00 
3424   203D 00 00 00 00 
3424   2041 00 00 00 00 
3424   2045 00 00 00 00 
3424   2049 00 00 00 00 
3424   204D 00 00 00 00 
3424   2051 00 00 00 00 
3424   2055 00 00 00 00 
3424   2059 00 00 00 00 
3424   205D 00 00 00 00 
3424   2061 00 00 00 00 
3424   2065 00 00 00 00 
3424   2069 00 00 00 00 
3424   206D 00 00 00 00 
3424   2071 00 00 00 00 
3424   2075 00 00 00 00 
3425   2079             filename:
3426   2079 00 00 00 00   .fill 128, 0      ; holds a path for file search
3426   207D 00 00 00 00 
3426   2081 00 00 00 00 
3426   2085 00 00 00 00 
3426   2089 00 00 00 00 
3426   208D 00 00 00 00 
3426   2091 00 00 00 00 
3426   2095 00 00 00 00 
3426   2099 00 00 00 00 
3426   209D 00 00 00 00 
3426   20A1 00 00 00 00 
3426   20A5 00 00 00 00 
3426   20A9 00 00 00 00 
3426   20AD 00 00 00 00 
3426   20B1 00 00 00 00 
3426   20B5 00 00 00 00 
3426   20B9 00 00 00 00 
3426   20BD 00 00 00 00 
3426   20C1 00 00 00 00 
3426   20C5 00 00 00 00 
3426   20C9 00 00 00 00 
3426   20CD 00 00 00 00 
3426   20D1 00 00 00 00 
3426   20D5 00 00 00 00 
3426   20D9 00 00 00 00 
3426   20DD 00 00 00 00 
3426   20E1 00 00 00 00 
3426   20E5 00 00 00 00 
3426   20E9 00 00 00 00 
3426   20ED 00 00 00 00 
3426   20F1 00 00 00 00 
3426   20F5 00 00 00 00 
3427   20F9             user_data:
3428   20F9 00 00 00 00   .fill 512, 0      ;  user space data
3428   20FD 00 00 00 00 
3428   2101 00 00 00 00 
3428   2105 00 00 00 00 
3428   2109 00 00 00 00 
3428   210D 00 00 00 00 
3428   2111 00 00 00 00 
3428   2115 00 00 00 00 
3428   2119 00 00 00 00 
3428   211D 00 00 00 00 
3428   2121 00 00 00 00 
3428   2125 00 00 00 00 
3428   2129 00 00 00 00 
3428   212D 00 00 00 00 
3428   2131 00 00 00 00 
3428   2135 00 00 00 00 
3428   2139 00 00 00 00 
3428   213D 00 00 00 00 
3428   2141 00 00 00 00 
3428   2145 00 00 00 00 
3428   2149 00 00 00 00 
3428   214D 00 00 00 00 
3428   2151 00 00 00 00 
3428   2155 00 00 00 00 
3428   2159 00 00 00 00 
3428   215D 00 00 00 00 
3428   2161 00 00 00 00 
3428   2165 00 00 00 00 
3428   2169 00 00 00 00 
3428   216D 00 00 00 00 
3428   2171 00 00 00 00 
3428   2175 00 00 00 00 
3428   2179 00 00 00 00 
3428   217D 00 00 00 00 
3428   2181 00 00 00 00 
3428   2185 00 00 00 00 
3428   2189 00 00 00 00 
3428   218D 00 00 00 00 
3428   2191 00 00 00 00 
3428   2195 00 00 00 00 
3428   2199 00 00 00 00 
3428   219D 00 00 00 00 
3428   21A1 00 00 00 00 
3428   21A5 00 00 00 00 
3428   21A9 00 00 00 00 
3428   21AD 00 00 00 00 
3428   21B1 00 00 00 00 
3428   21B5 00 00 00 00 
3428   21B9 00 00 00 00 
3428   21BD 00 00 00 00 
3428   21C1 00 00 00 00 
3428   21C5 00 00 00 00 
3428   21C9 00 00 00 00 
3428   21CD 00 00 00 00 
3428   21D1 00 00 00 00 
3428   21D5 00 00 00 00 
3428   21D9 00 00 00 00 
3428   21DD 00 00 00 00 
3428   21E1 00 00 00 00 
3428   21E5 00 00 00 00 
3428   21E9 00 00 00 00 
3428   21ED 00 00 00 00 
3428   21F1 00 00 00 00 
3428   21F5 00 00 00 00 
3428   21F9 00 00 00 00 
3428   21FD 00 00 00 00 
3428   2201 00 00 00 00 
3428   2205 00 00 00 00 
3428   2209 00 00 00 00 
3428   220D 00 00 00 00 
3428   2211 00 00 00 00 
3428   2215 00 00 00 00 
3428   2219 00 00 00 00 
3428   221D 00 00 00 00 
3428   2221 00 00 00 00 
3428   2225 00 00 00 00 
3428   2229 00 00 00 00 
3428   222D 00 00 00 00 
3428   2231 00 00 00 00 
3428   2235 00 00 00 00 
3428   2239 00 00 00 00 
3428   223D 00 00 00 00 
3428   2241 00 00 00 00 
3428   2245 00 00 00 00 
3428   2249 00 00 00 00 
3428   224D 00 00 00 00 
3428   2251 00 00 00 00 
3428   2255 00 00 00 00 
3428   2259 00 00 00 00 
3428   225D 00 00 00 00 
3428   2261 00 00 00 00 
3428   2265 00 00 00 00 
3428   2269 00 00 00 00 
3428   226D 00 00 00 00 
3428   2271 00 00 00 00 
3428   2275 00 00 00 00 
3428   2279 00 00 00 00 
3428   227D 00 00 00 00 
3428   2281 00 00 00 00 
3428   2285 00 00 00 00 
3428   2289 00 00 00 00 
3428   228D 00 00 00 00 
3428   2291 00 00 00 00 
3428   2295 00 00 00 00 
3428   2299 00 00 00 00 
3428   229D 00 00 00 00 
3428   22A1 00 00 00 00 
3428   22A5 00 00 00 00 
3428   22A9 00 00 00 00 
3428   22AD 00 00 00 00 
3428   22B1 00 00 00 00 
3428   22B5 00 00 00 00 
3428   22B9 00 00 00 00 
3428   22BD 00 00 00 00 
3428   22C1 00 00 00 00 
3428   22C5 00 00 00 00 
3428   22C9 00 00 00 00 
3428   22CD 00 00 00 00 
3428   22D1 00 00 00 00 
3428   22D5 00 00 00 00 
3428   22D9 00 00 00 00 
3428   22DD 00 00 00 00 
3428   22E1 00 00 00 00 
3428   22E5 00 00 00 00 
3428   22E9 00 00 00 00 
3428   22ED 00 00 00 00 
3428   22F1 00 00 00 00 
3428   22F5 00 00 00 00 
3429   22F9             fifo:
3430   22F9 FF FF FF FF   .fill _fifo_size
3430   22FD FF FF FF FF 
3430   2301 FF FF FF FF 
3430   2305 FF FF FF FF 
3430   2309 FF FF FF FF 
3430   230D FF FF FF FF 
3430   2311 FF FF FF FF 
3430   2315 FF FF FF FF 
3430   2319 FF FF FF FF 
3430   231D FF FF FF FF 
3430   2321 FF FF FF FF 
3430   2325 FF FF FF FF 
3430   2329 FF FF FF FF 
3430   232D FF FF FF FF 
3430   2331 FF FF FF FF 
3430   2335 FF FF FF FF 
3430   2339 FF FF FF FF 
3430   233D FF FF FF FF 
3430   2341 FF FF FF FF 
3430   2345 FF FF FF FF 
3430   2349 FF FF FF FF 
3430   234D FF FF FF FF 
3430   2351 FF FF FF FF 
3430   2355 FF FF FF FF 
3430   2359 FF FF FF FF 
3430   235D FF FF FF FF 
3430   2361 FF FF FF FF 
3430   2365 FF FF FF FF 
3430   2369 FF FF FF FF 
3430   236D FF FF FF FF 
3430   2371 FF FF FF FF 
3430   2375 FF FF FF FF 
3430   2379 FF FF FF FF 
3430   237D FF FF FF FF 
3430   2381 FF FF FF FF 
3430   2385 FF FF FF FF 
3430   2389 FF FF FF FF 
3430   238D FF FF FF FF 
3430   2391 FF FF FF FF 
3430   2395 FF FF FF FF 
3430   2399 FF FF FF FF 
3430   239D FF FF FF FF 
3430   23A1 FF FF FF FF 
3430   23A5 FF FF FF FF 
3430   23A9 FF FF FF FF 
3430   23AD FF FF FF FF 
3430   23B1 FF FF FF FF 
3430   23B5 FF FF FF FF 
3430   23B9 FF FF FF FF 
3430   23BD FF FF FF FF 
3430   23C1 FF FF FF FF 
3430   23C5 FF FF FF FF 
3430   23C9 FF FF FF FF 
3430   23CD FF FF FF FF 
3430   23D1 FF FF FF FF 
3430   23D5 FF FF FF FF 
3430   23D9 FF FF FF FF 
3430   23DD FF FF FF FF 
3430   23E1 FF FF FF FF 
3430   23E5 FF FF FF FF 
3430   23E9 FF FF FF FF 
3430   23ED FF FF FF FF 
3430   23F1 FF FF FF FF 
3430   23F5 FF FF FF FF 
3430   23F9 FF FF FF FF 
3430   23FD FF FF FF FF 
3430   2401 FF FF FF FF 
3430   2405 FF FF FF FF 
3430   2409 FF FF FF FF 
3430   240D FF FF FF FF 
3430   2411 FF FF FF FF 
3430   2415 FF FF FF FF 
3430   2419 FF FF FF FF 
3430   241D FF FF FF FF 
3430   2421 FF FF FF FF 
3430   2425 FF FF FF FF 
3430   2429 FF FF FF FF 
3430   242D FF FF FF FF 
3430   2431 FF FF FF FF 
3430   2435 FF FF FF FF 
3430   2439 FF FF FF FF 
3430   243D FF FF FF FF 
3430   2441 FF FF FF FF 
3430   2445 FF FF FF FF 
3430   2449 FF FF FF FF 
3430   244D FF FF FF FF 
3430   2451 FF FF FF FF 
3430   2455 FF FF FF FF 
3430   2459 FF FF FF FF 
3430   245D FF FF FF FF 
3430   2461 FF FF FF FF 
3430   2465 FF FF FF FF 
3430   2469 FF FF FF FF 
3430   246D FF FF FF FF 
3430   2471 FF FF FF FF 
3430   2475 FF FF FF FF 
3430   2479 FF FF FF FF 
3430   247D FF FF FF FF 
3430   2481 FF FF FF FF 
3430   2485 FF FF FF FF 
3430   2489 FF FF FF FF 
3430   248D FF FF FF FF 
3430   2491 FF FF FF FF 
3430   2495 FF FF FF FF 
3430   2499 FF FF FF FF 
3430   249D FF FF FF FF 
3430   24A1 FF FF FF FF 
3430   24A5 FF FF FF FF 
3430   24A9 FF FF FF FF 
3430   24AD FF FF FF FF 
3430   24B1 FF FF FF FF 
3430   24B5 FF FF FF FF 
3430   24B9 FF FF FF FF 
3430   24BD FF FF FF FF 
3430   24C1 FF FF FF FF 
3430   24C5 FF FF FF FF 
3430   24C9 FF FF FF FF 
3430   24CD FF FF FF FF 
3430   24D1 FF FF FF FF 
3430   24D5 FF FF FF FF 
3430   24D9 FF FF FF FF 
3430   24DD FF FF FF FF 
3430   24E1 FF FF FF FF 
3430   24E5 FF FF FF FF 
3430   24E9 FF FF FF FF 
3430   24ED FF FF FF FF 
3430   24F1 FF FF FF FF 
3430   24F5 FF FF FF FF 
3430   24F9 FF FF FF FF 
3430   24FD FF FF FF FF 
3430   2501 FF FF FF FF 
3430   2505 FF FF FF FF 
3430   2509 FF FF FF FF 
3430   250D FF FF FF FF 
3430   2511 FF FF FF FF 
3430   2515 FF FF FF FF 
3430   2519 FF FF FF FF 
3430   251D FF FF FF FF 
3430   2521 FF FF FF FF 
3430   2525 FF FF FF FF 
3430   2529 FF FF FF FF 
3430   252D FF FF FF FF 
3430   2531 FF FF FF FF 
3430   2535 FF FF FF FF 
3430   2539 FF FF FF FF 
3430   253D FF FF FF FF 
3430   2541 FF FF FF FF 
3430   2545 FF FF FF FF 
3430   2549 FF FF FF FF 
3430   254D FF FF FF FF 
3430   2551 FF FF FF FF 
3430   2555 FF FF FF FF 
3430   2559 FF FF FF FF 
3430   255D FF FF FF FF 
3430   2561 FF FF FF FF 
3430   2565 FF FF FF FF 
3430   2569 FF FF FF FF 
3430   256D FF FF FF FF 
3430   2571 FF FF FF FF 
3430   2575 FF FF FF FF 
3430   2579 FF FF FF FF 
3430   257D FF FF FF FF 
3430   2581 FF FF FF FF 
3430   2585 FF FF FF FF 
3430   2589 FF FF FF FF 
3430   258D FF FF FF FF 
3430   2591 FF FF FF FF 
3430   2595 FF FF FF FF 
3430   2599 FF FF FF FF 
3430   259D FF FF FF FF 
3430   25A1 FF FF FF FF 
3430   25A5 FF FF FF FF 
3430   25A9 FF FF FF FF 
3430   25AD FF FF FF FF 
3430   25B1 FF FF FF FF 
3430   25B5 FF FF FF FF 
3430   25B9 FF FF FF FF 
3430   25BD FF FF FF FF 
3430   25C1 FF FF FF FF 
3430   25C5 FF FF FF FF 
3430   25C9 FF FF FF FF 
3430   25CD FF FF FF FF 
3430   25D1 FF FF FF FF 
3430   25D5 FF FF FF FF 
3430   25D9 FF FF FF FF 
3430   25DD FF FF FF FF 
3430   25E1 FF FF FF FF 
3430   25E5 FF FF FF FF 
3430   25E9 FF FF FF FF 
3430   25ED FF FF FF FF 
3430   25F1 FF FF FF FF 
3430   25F5 FF FF FF FF 
3430   25F9 FF FF FF FF 
3430   25FD FF FF FF FF 
3430   2601 FF FF FF FF 
3430   2605 FF FF FF FF 
3430   2609 FF FF FF FF 
3430   260D FF FF FF FF 
3430   2611 FF FF FF FF 
3430   2615 FF FF FF FF 
3430   2619 FF FF FF FF 
3430   261D FF FF FF FF 
3430   2621 FF FF FF FF 
3430   2625 FF FF FF FF 
3430   2629 FF FF FF FF 
3430   262D FF FF FF FF 
3430   2631 FF FF FF FF 
3430   2635 FF FF FF FF 
3430   2639 FF FF FF FF 
3430   263D FF FF FF FF 
3430   2641 FF FF FF FF 
3430   2645 FF FF FF FF 
3430   2649 FF FF FF FF 
3430   264D FF FF FF FF 
3430   2651 FF FF FF FF 
3430   2655 FF FF FF FF 
3430   2659 FF FF FF FF 
3430   265D FF FF FF FF 
3430   2661 FF FF FF FF 
3430   2665 FF FF FF FF 
3430   2669 FF FF FF FF 
3430   266D FF FF FF FF 
3430   2671 FF FF FF FF 
3430   2675 FF FF FF FF 
3430   2679 FF FF FF FF 
3430   267D FF FF FF FF 
3430   2681 FF FF FF FF 
3430   2685 FF FF FF FF 
3430   2689 FF FF FF FF 
3430   268D FF FF FF FF 
3430   2691 FF FF FF FF 
3430   2695 FF FF FF FF 
3430   2699 FF FF FF FF 
3430   269D FF FF FF FF 
3430   26A1 FF FF FF FF 
3430   26A5 FF FF FF FF 
3430   26A9 FF FF FF FF 
3430   26AD FF FF FF FF 
3430   26B1 FF FF FF FF 
3430   26B5 FF FF FF FF 
3430   26B9 FF FF FF FF 
3430   26BD FF FF FF FF 
3430   26C1 FF FF FF FF 
3430   26C5 FF FF FF FF 
3430   26C9 FF FF FF FF 
3430   26CD FF FF FF FF 
3430   26D1 FF FF FF FF 
3430   26D5 FF FF FF FF 
3430   26D9 FF FF FF FF 
3430   26DD FF FF FF FF 
3430   26E1 FF FF FF FF 
3430   26E5 FF FF FF FF 
3430   26E9 FF FF FF FF 
3430   26ED FF FF FF FF 
3430   26F1 FF FF FF FF 
3430   26F5 FF FF FF FF 
3430   26F9 FF FF FF FF 
3430   26FD FF FF FF FF 
3430   2701 FF FF FF FF 
3430   2705 FF FF FF FF 
3430   2709 FF FF FF FF 
3430   270D FF FF FF FF 
3430   2711 FF FF FF FF 
3430   2715 FF FF FF FF 
3430   2719 FF FF FF FF 
3430   271D FF FF FF FF 
3430   2721 FF FF FF FF 
3430   2725 FF FF FF FF 
3430   2729 FF FF FF FF 
3430   272D FF FF FF FF 
3430   2731 FF FF FF FF 
3430   2735 FF FF FF FF 
3430   2739 FF FF FF FF 
3430   273D FF FF FF FF 
3430   2741 FF FF FF FF 
3430   2745 FF FF FF FF 
3430   2749 FF FF FF FF 
3430   274D FF FF FF FF 
3430   2751 FF FF FF FF 
3430   2755 FF FF FF FF 
3430   2759 FF FF FF FF 
3430   275D FF FF FF FF 
3430   2761 FF FF FF FF 
3430   2765 FF FF FF FF 
3430   2769 FF FF FF FF 
3430   276D FF FF FF FF 
3430   2771 FF FF FF FF 
3430   2775 FF FF FF FF 
3430   2779 FF FF FF FF 
3430   277D FF FF FF FF 
3430   2781 FF FF FF FF 
3430   2785 FF FF FF FF 
3430   2789 FF FF FF FF 
3430   278D FF FF FF FF 
3430   2791 FF FF FF FF 
3430   2795 FF FF FF FF 
3430   2799 FF FF FF FF 
3430   279D FF FF FF FF 
3430   27A1 FF FF FF FF 
3430   27A5 FF FF FF FF 
3430   27A9 FF FF FF FF 
3430   27AD FF FF FF FF 
3430   27B1 FF FF FF FF 
3430   27B5 FF FF FF FF 
3430   27B9 FF FF FF FF 
3430   27BD FF FF FF FF 
3430   27C1 FF FF FF FF 
3430   27C5 FF FF FF FF 
3430   27C9 FF FF FF FF 
3430   27CD FF FF FF FF 
3430   27D1 FF FF FF FF 
3430   27D5 FF FF FF FF 
3430   27D9 FF FF FF FF 
3430   27DD FF FF FF FF 
3430   27E1 FF FF FF FF 
3430   27E5 FF FF FF FF 
3430   27E9 FF FF FF FF 
3430   27ED FF FF FF FF 
3430   27F1 FF FF FF FF 
3430   27F5 FF FF FF FF 
3430   27F9 FF FF FF FF 
3430   27FD FF FF FF FF 
3430   2801 FF FF FF FF 
3430   2805 FF FF FF FF 
3430   2809 FF FF FF FF 
3430   280D FF FF FF FF 
3430   2811 FF FF FF FF 
3430   2815 FF FF FF FF 
3430   2819 FF FF FF FF 
3430   281D FF FF FF FF 
3430   2821 FF FF FF FF 
3430   2825 FF FF FF FF 
3430   2829 FF FF FF FF 
3430   282D FF FF FF FF 
3430   2831 FF FF FF FF 
3430   2835 FF FF FF FF 
3430   2839 FF FF FF FF 
3430   283D FF FF FF FF 
3430   2841 FF FF FF FF 
3430   2845 FF FF FF FF 
3430   2849 FF FF FF FF 
3430   284D FF FF FF FF 
3430   2851 FF FF FF FF 
3430   2855 FF FF FF FF 
3430   2859 FF FF FF FF 
3430   285D FF FF FF FF 
3430   2861 FF FF FF FF 
3430   2865 FF FF FF FF 
3430   2869 FF FF FF FF 
3430   286D FF FF FF FF 
3430   2871 FF FF FF FF 
3430   2875 FF FF FF FF 
3430   2879 FF FF FF FF 
3430   287D FF FF FF FF 
3430   2881 FF FF FF FF 
3430   2885 FF FF FF FF 
3430   2889 FF FF FF FF 
3430   288D FF FF FF FF 
3430   2891 FF FF FF FF 
3430   2895 FF FF FF FF 
3430   2899 FF FF FF FF 
3430   289D FF FF FF FF 
3430   28A1 FF FF FF FF 
3430   28A5 FF FF FF FF 
3430   28A9 FF FF FF FF 
3430   28AD FF FF FF FF 
3430   28B1 FF FF FF FF 
3430   28B5 FF FF FF FF 
3430   28B9 FF FF FF FF 
3430   28BD FF FF FF FF 
3430   28C1 FF FF FF FF 
3430   28C5 FF FF FF FF 
3430   28C9 FF FF FF FF 
3430   28CD FF FF FF FF 
3430   28D1 FF FF FF FF 
3430   28D5 FF FF FF FF 
3430   28D9 FF FF FF FF 
3430   28DD FF FF FF FF 
3430   28E1 FF FF FF FF 
3430   28E5 FF FF FF FF 
3430   28E9 FF FF FF FF 
3430   28ED FF FF FF FF 
3430   28F1 FF FF FF FF 
3430   28F5 FF FF FF FF 
3430   28F9 FF FF FF FF 
3430   28FD FF FF FF FF 
3430   2901 FF FF FF FF 
3430   2905 FF FF FF FF 
3430   2909 FF FF FF FF 
3430   290D FF FF FF FF 
3430   2911 FF FF FF FF 
3430   2915 FF FF FF FF 
3430   2919 FF FF FF FF 
3430   291D FF FF FF FF 
3430   2921 FF FF FF FF 
3430   2925 FF FF FF FF 
3430   2929 FF FF FF FF 
3430   292D FF FF FF FF 
3430   2931 FF FF FF FF 
3430   2935 FF FF FF FF 
3430   2939 FF FF FF FF 
3430   293D FF FF FF FF 
3430   2941 FF FF FF FF 
3430   2945 FF FF FF FF 
3430   2949 FF FF FF FF 
3430   294D FF FF FF FF 
3430   2951 FF FF FF FF 
3430   2955 FF FF FF FF 
3430   2959 FF FF FF FF 
3430   295D FF FF FF FF 
3430   2961 FF FF FF FF 
3430   2965 FF FF FF FF 
3430   2969 FF FF FF FF 
3430   296D FF FF FF FF 
3430   2971 FF FF FF FF 
3430   2975 FF FF FF FF 
3430   2979 FF FF FF FF 
3430   297D FF FF FF FF 
3430   2981 FF FF FF FF 
3430   2985 FF FF FF FF 
3430   2989 FF FF FF FF 
3430   298D FF FF FF FF 
3430   2991 FF FF FF FF 
3430   2995 FF FF FF FF 
3430   2999 FF FF FF FF 
3430   299D FF FF FF FF 
3430   29A1 FF FF FF FF 
3430   29A5 FF FF FF FF 
3430   29A9 FF FF FF FF 
3430   29AD FF FF FF FF 
3430   29B1 FF FF FF FF 
3430   29B5 FF FF FF FF 
3430   29B9 FF FF FF FF 
3430   29BD FF FF FF FF 
3430   29C1 FF FF FF FF 
3430   29C5 FF FF FF FF 
3430   29C9 FF FF FF FF 
3430   29CD FF FF FF FF 
3430   29D1 FF FF FF FF 
3430   29D5 FF FF FF FF 
3430   29D9 FF FF FF FF 
3430   29DD FF FF FF FF 
3430   29E1 FF FF FF FF 
3430   29E5 FF FF FF FF 
3430   29E9 FF FF FF FF 
3430   29ED FF FF FF FF 
3430   29F1 FF FF FF FF 
3430   29F5 FF FF FF FF 
3430   29F9 FF FF FF FF 
3430   29FD FF FF FF FF 
3430   2A01 FF FF FF FF 
3430   2A05 FF FF FF FF 
3430   2A09 FF FF FF FF 
3430   2A0D FF FF FF FF 
3430   2A11 FF FF FF FF 
3430   2A15 FF FF FF FF 
3430   2A19 FF FF FF FF 
3430   2A1D FF FF FF FF 
3430   2A21 FF FF FF FF 
3430   2A25 FF FF FF FF 
3430   2A29 FF FF FF FF 
3430   2A2D FF FF FF FF 
3430   2A31 FF FF FF FF 
3430   2A35 FF FF FF FF 
3430   2A39 FF FF FF FF 
3430   2A3D FF FF FF FF 
3430   2A41 FF FF FF FF 
3430   2A45 FF FF FF FF 
3430   2A49 FF FF FF FF 
3430   2A4D FF FF FF FF 
3430   2A51 FF FF FF FF 
3430   2A55 FF FF FF FF 
3430   2A59 FF FF FF FF 
3430   2A5D FF FF FF FF 
3430   2A61 FF FF FF FF 
3430   2A65 FF FF FF FF 
3430   2A69 FF FF FF FF 
3430   2A6D FF FF FF FF 
3430   2A71 FF FF FF FF 
3430   2A75 FF FF FF FF 
3430   2A79 FF FF FF FF 
3430   2A7D FF FF FF FF 
3430   2A81 FF FF FF FF 
3430   2A85 FF FF FF FF 
3430   2A89 FF FF FF FF 
3430   2A8D FF FF FF FF 
3430   2A91 FF FF FF FF 
3430   2A95 FF FF FF FF 
3430   2A99 FF FF FF FF 
3430   2A9D FF FF FF FF 
3430   2AA1 FF FF FF FF 
3430   2AA5 FF FF FF FF 
3430   2AA9 FF FF FF FF 
3430   2AAD FF FF FF FF 
3430   2AB1 FF FF FF FF 
3430   2AB5 FF FF FF FF 
3430   2AB9 FF FF FF FF 
3430   2ABD FF FF FF FF 
3430   2AC1 FF FF FF FF 
3430   2AC5 FF FF FF FF 
3430   2AC9 FF FF FF FF 
3430   2ACD FF FF FF FF 
3430   2AD1 FF FF FF FF 
3430   2AD5 FF FF FF FF 
3430   2AD9 FF FF FF FF 
3430   2ADD FF FF FF FF 
3430   2AE1 FF FF FF FF 
3430   2AE5 FF FF FF FF 
3430   2AE9 FF FF FF FF 
3430   2AED FF FF FF FF 
3430   2AF1 FF FF FF FF 
3430   2AF5 FF FF FF FF 
3430   2AF9 FF FF FF FF 
3430   2AFD FF FF FF FF 
3430   2B01 FF FF FF FF 
3430   2B05 FF FF FF FF 
3430   2B09 FF FF FF FF 
3430   2B0D FF FF FF FF 
3430   2B11 FF FF FF FF 
3430   2B15 FF FF FF FF 
3430   2B19 FF FF FF FF 
3430   2B1D FF FF FF FF 
3430   2B21 FF FF FF FF 
3430   2B25 FF FF FF FF 
3430   2B29 FF FF FF FF 
3430   2B2D FF FF FF FF 
3430   2B31 FF FF FF FF 
3430   2B35 FF FF FF FF 
3430   2B39 FF FF FF FF 
3430   2B3D FF FF FF FF 
3430   2B41 FF FF FF FF 
3430   2B45 FF FF FF FF 
3430   2B49 FF FF FF FF 
3430   2B4D FF FF FF FF 
3430   2B51 FF FF FF FF 
3430   2B55 FF FF FF FF 
3430   2B59 FF FF FF FF 
3430   2B5D FF FF FF FF 
3430   2B61 FF FF FF FF 
3430   2B65 FF FF FF FF 
3430   2B69 FF FF FF FF 
3430   2B6D FF FF FF FF 
3430   2B71 FF FF FF FF 
3430   2B75 FF FF FF FF 
3430   2B79 FF FF FF FF 
3430   2B7D FF FF FF FF 
3430   2B81 FF FF FF FF 
3430   2B85 FF FF FF FF 
3430   2B89 FF FF FF FF 
3430   2B8D FF FF FF FF 
3430   2B91 FF FF FF FF 
3430   2B95 FF FF FF FF 
3430   2B99 FF FF FF FF 
3430   2B9D FF FF FF FF 
3430   2BA1 FF FF FF FF 
3430   2BA5 FF FF FF FF 
3430   2BA9 FF FF FF FF 
3430   2BAD FF FF FF FF 
3430   2BB1 FF FF FF FF 
3430   2BB5 FF FF FF FF 
3430   2BB9 FF FF FF FF 
3430   2BBD FF FF FF FF 
3430   2BC1 FF FF FF FF 
3430   2BC5 FF FF FF FF 
3430   2BC9 FF FF FF FF 
3430   2BCD FF FF FF FF 
3430   2BD1 FF FF FF FF 
3430   2BD5 FF FF FF FF 
3430   2BD9 FF FF FF FF 
3430   2BDD FF FF FF FF 
3430   2BE1 FF FF FF FF 
3430   2BE5 FF FF FF FF 
3430   2BE9 FF FF FF FF 
3430   2BED FF FF FF FF 
3430   2BF1 FF FF FF FF 
3430   2BF5 FF FF FF FF 
3430   2BF9 FF FF FF FF 
3430   2BFD FF FF FF FF 
3430   2C01 FF FF FF FF 
3430   2C05 FF FF FF FF 
3430   2C09 FF FF FF FF 
3430   2C0D FF FF FF FF 
3430   2C11 FF FF FF FF 
3430   2C15 FF FF FF FF 
3430   2C19 FF FF FF FF 
3430   2C1D FF FF FF FF 
3430   2C21 FF FF FF FF 
3430   2C25 FF FF FF FF 
3430   2C29 FF FF FF FF 
3430   2C2D FF FF FF FF 
3430   2C31 FF FF FF FF 
3430   2C35 FF FF FF FF 
3430   2C39 FF FF FF FF 
3430   2C3D FF FF FF FF 
3430   2C41 FF FF FF FF 
3430   2C45 FF FF FF FF 
3430   2C49 FF FF FF FF 
3430   2C4D FF FF FF FF 
3430   2C51 FF FF FF FF 
3430   2C55 FF FF FF FF 
3430   2C59 FF FF FF FF 
3430   2C5D FF FF FF FF 
3430   2C61 FF FF FF FF 
3430   2C65 FF FF FF FF 
3430   2C69 FF FF FF FF 
3430   2C6D FF FF FF FF 
3430   2C71 FF FF FF FF 
3430   2C75 FF FF FF FF 
3430   2C79 FF FF FF FF 
3430   2C7D FF FF FF FF 
3430   2C81 FF FF FF FF 
3430   2C85 FF FF FF FF 
3430   2C89 FF FF FF FF 
3430   2C8D FF FF FF FF 
3430   2C91 FF FF FF FF 
3430   2C95 FF FF FF FF 
3430   2C99 FF FF FF FF 
3430   2C9D FF FF FF FF 
3430   2CA1 FF FF FF FF 
3430   2CA5 FF FF FF FF 
3430   2CA9 FF FF FF FF 
3430   2CAD FF FF FF FF 
3430   2CB1 FF FF FF FF 
3430   2CB5 FF FF FF FF 
3430   2CB9 FF FF FF FF 
3430   2CBD FF FF FF FF 
3430   2CC1 FF FF FF FF 
3430   2CC5 FF FF FF FF 
3430   2CC9 FF FF FF FF 
3430   2CCD FF FF FF FF 
3430   2CD1 FF FF FF FF 
3430   2CD5 FF FF FF FF 
3430   2CD9 FF FF FF FF 
3430   2CDD FF FF FF FF 
3430   2CE1 FF FF FF FF 
3430   2CE5 FF FF FF FF 
3430   2CE9 FF FF FF FF 
3430   2CED FF FF FF FF 
3430   2CF1 FF FF FF FF 
3430   2CF5 FF FF FF FF 
3430   2CF9 FF FF FF FF 
3430   2CFD FF FF FF FF 
3430   2D01 FF FF FF FF 
3430   2D05 FF FF FF FF 
3430   2D09 FF FF FF FF 
3430   2D0D FF FF FF FF 
3430   2D11 FF FF FF FF 
3430   2D15 FF FF FF FF 
3430   2D19 FF FF FF FF 
3430   2D1D FF FF FF FF 
3430   2D21 FF FF FF FF 
3430   2D25 FF FF FF FF 
3430   2D29 FF FF FF FF 
3430   2D2D FF FF FF FF 
3430   2D31 FF FF FF FF 
3430   2D35 FF FF FF FF 
3430   2D39 FF FF FF FF 
3430   2D3D FF FF FF FF 
3430   2D41 FF FF FF FF 
3430   2D45 FF FF FF FF 
3430   2D49 FF FF FF FF 
3430   2D4D FF FF FF FF 
3430   2D51 FF FF FF FF 
3430   2D55 FF FF FF FF 
3430   2D59 FF FF FF FF 
3430   2D5D FF FF FF FF 
3430   2D61 FF FF FF FF 
3430   2D65 FF FF FF FF 
3430   2D69 FF FF FF FF 
3430   2D6D FF FF FF FF 
3430   2D71 FF FF FF FF 
3430   2D75 FF FF FF FF 
3430   2D79 FF FF FF FF 
3430   2D7D FF FF FF FF 
3430   2D81 FF FF FF FF 
3430   2D85 FF FF FF FF 
3430   2D89 FF FF FF FF 
3430   2D8D FF FF FF FF 
3430   2D91 FF FF FF FF 
3430   2D95 FF FF FF FF 
3430   2D99 FF FF FF FF 
3430   2D9D FF FF FF FF 
3430   2DA1 FF FF FF FF 
3430   2DA5 FF FF FF FF 
3430   2DA9 FF FF FF FF 
3430   2DAD FF FF FF FF 
3430   2DB1 FF FF FF FF 
3430   2DB5 FF FF FF FF 
3430   2DB9 FF FF FF FF 
3430   2DBD FF FF FF FF 
3430   2DC1 FF FF FF FF 
3430   2DC5 FF FF FF FF 
3430   2DC9 FF FF FF FF 
3430   2DCD FF FF FF FF 
3430   2DD1 FF FF FF FF 
3430   2DD5 FF FF FF FF 
3430   2DD9 FF FF FF FF 
3430   2DDD FF FF FF FF 
3430   2DE1 FF FF FF FF 
3430   2DE5 FF FF FF FF 
3430   2DE9 FF FF FF FF 
3430   2DED FF FF FF FF 
3430   2DF1 FF FF FF FF 
3430   2DF5 FF FF FF FF 
3430   2DF9 FF FF FF FF 
3430   2DFD FF FF FF FF 
3430   2E01 FF FF FF FF 
3430   2E05 FF FF FF FF 
3430   2E09 FF FF FF FF 
3430   2E0D FF FF FF FF 
3430   2E11 FF FF FF FF 
3430   2E15 FF FF FF FF 
3430   2E19 FF FF FF FF 
3430   2E1D FF FF FF FF 
3430   2E21 FF FF FF FF 
3430   2E25 FF FF FF FF 
3430   2E29 FF FF FF FF 
3430   2E2D FF FF FF FF 
3430   2E31 FF FF FF FF 
3430   2E35 FF FF FF FF 
3430   2E39 FF FF FF FF 
3430   2E3D FF FF FF FF 
3430   2E41 FF FF FF FF 
3430   2E45 FF FF FF FF 
3430   2E49 FF FF FF FF 
3430   2E4D FF FF FF FF 
3430   2E51 FF FF FF FF 
3430   2E55 FF FF FF FF 
3430   2E59 FF FF FF FF 
3430   2E5D FF FF FF FF 
3430   2E61 FF FF FF FF 
3430   2E65 FF FF FF FF 
3430   2E69 FF FF FF FF 
3430   2E6D FF FF FF FF 
3430   2E71 FF FF FF FF 
3430   2E75 FF FF FF FF 
3430   2E79 FF FF FF FF 
3430   2E7D FF FF FF FF 
3430   2E81 FF FF FF FF 
3430   2E85 FF FF FF FF 
3430   2E89 FF FF FF FF 
3430   2E8D FF FF FF FF 
3430   2E91 FF FF FF FF 
3430   2E95 FF FF FF FF 
3430   2E99 FF FF FF FF 
3430   2E9D FF FF FF FF 
3430   2EA1 FF FF FF FF 
3430   2EA5 FF FF FF FF 
3430   2EA9 FF FF FF FF 
3430   2EAD FF FF FF FF 
3430   2EB1 FF FF FF FF 
3430   2EB5 FF FF FF FF 
3430   2EB9 FF FF FF FF 
3430   2EBD FF FF FF FF 
3430   2EC1 FF FF FF FF 
3430   2EC5 FF FF FF FF 
3430   2EC9 FF FF FF FF 
3430   2ECD FF FF FF FF 
3430   2ED1 FF FF FF FF 
3430   2ED5 FF FF FF FF 
3430   2ED9 FF FF FF FF 
3430   2EDD FF FF FF FF 
3430   2EE1 FF FF FF FF 
3430   2EE5 FF FF FF FF 
3430   2EE9 FF FF FF FF 
3430   2EED FF FF FF FF 
3430   2EF1 FF FF FF FF 
3430   2EF5 FF FF FF FF 
3430   2EF9 FF FF FF FF 
3430   2EFD FF FF FF FF 
3430   2F01 FF FF FF FF 
3430   2F05 FF FF FF FF 
3430   2F09 FF FF FF FF 
3430   2F0D FF FF FF FF 
3430   2F11 FF FF FF FF 
3430   2F15 FF FF FF FF 
3430   2F19 FF FF FF FF 
3430   2F1D FF FF FF FF 
3430   2F21 FF FF FF FF 
3430   2F25 FF FF FF FF 
3430   2F29 FF FF FF FF 
3430   2F2D FF FF FF FF 
3430   2F31 FF FF FF FF 
3430   2F35 FF FF FF FF 
3430   2F39 FF FF FF FF 
3430   2F3D FF FF FF FF 
3430   2F41 FF FF FF FF 
3430   2F45 FF FF FF FF 
3430   2F49 FF FF FF FF 
3430   2F4D FF FF FF FF 
3430   2F51 FF FF FF FF 
3430   2F55 FF FF FF FF 
3430   2F59 FF FF FF FF 
3430   2F5D FF FF FF FF 
3430   2F61 FF FF FF FF 
3430   2F65 FF FF FF FF 
3430   2F69 FF FF FF FF 
3430   2F6D FF FF FF FF 
3430   2F71 FF FF FF FF 
3430   2F75 FF FF FF FF 
3430   2F79 FF FF FF FF 
3430   2F7D FF FF FF FF 
3430   2F81 FF FF FF FF 
3430   2F85 FF FF FF FF 
3430   2F89 FF FF FF FF 
3430   2F8D FF FF FF FF 
3430   2F91 FF FF FF FF 
3430   2F95 FF FF FF FF 
3430   2F99 FF FF FF FF 
3430   2F9D FF FF FF FF 
3430   2FA1 FF FF FF FF 
3430   2FA5 FF FF FF FF 
3430   2FA9 FF FF FF FF 
3430   2FAD FF FF FF FF 
3430   2FB1 FF FF FF FF 
3430   2FB5 FF FF FF FF 
3430   2FB9 FF FF FF FF 
3430   2FBD FF FF FF FF 
3430   2FC1 FF FF FF FF 
3430   2FC5 FF FF FF FF 
3430   2FC9 FF FF FF FF 
3430   2FCD FF FF FF FF 
3430   2FD1 FF FF FF FF 
3430   2FD5 FF FF FF FF 
3430   2FD9 FF FF FF FF 
3430   2FDD FF FF FF FF 
3430   2FE1 FF FF FF FF 
3430   2FE5 FF FF FF FF 
3430   2FE9 FF FF FF FF 
3430   2FED FF FF FF FF 
3430   2FF1 FF FF FF FF 
3430   2FF5 FF FF FF FF 
3430   2FF9 FF FF FF FF 
3430   2FFD FF FF FF FF 
3430   3001 FF FF FF FF 
3430   3005 FF FF FF FF 
3430   3009 FF FF FF FF 
3430   300D FF FF FF FF 
3430   3011 FF FF FF FF 
3430   3015 FF FF FF FF 
3430   3019 FF FF FF FF 
3430   301D FF FF FF FF 
3430   3021 FF FF FF FF 
3430   3025 FF FF FF FF 
3430   3029 FF FF FF FF 
3430   302D FF FF FF FF 
3430   3031 FF FF FF FF 
3430   3035 FF FF FF FF 
3430   3039 FF FF FF FF 
3430   303D FF FF FF FF 
3430   3041 FF FF FF FF 
3430   3045 FF FF FF FF 
3430   3049 FF FF FF FF 
3430   304D FF FF FF FF 
3430   3051 FF FF FF FF 
3430   3055 FF FF FF FF 
3430   3059 FF FF FF FF 
3430   305D FF FF FF FF 
3430   3061 FF FF FF FF 
3430   3065 FF FF FF FF 
3430   3069 FF FF FF FF 
3430   306D FF FF FF FF 
3430   3071 FF FF FF FF 
3430   3075 FF FF FF FF 
3430   3079 FF FF FF FF 
3430   307D FF FF FF FF 
3430   3081 FF FF FF FF 
3430   3085 FF FF FF FF 
3430   3089 FF FF FF FF 
3430   308D FF FF FF FF 
3430   3091 FF FF FF FF 
3430   3095 FF FF FF FF 
3430   3099 FF FF FF FF 
3430   309D FF FF FF FF 
3430   30A1 FF FF FF FF 
3430   30A5 FF FF FF FF 
3430   30A9 FF FF FF FF 
3430   30AD FF FF FF FF 
3430   30B1 FF FF FF FF 
3430   30B5 FF FF FF FF 
3430   30B9 FF FF FF FF 
3430   30BD FF FF FF FF 
3430   30C1 FF FF FF FF 
3430   30C5 FF FF FF FF 
3430   30C9 FF FF FF FF 
3430   30CD FF FF FF FF 
3430   30D1 FF FF FF FF 
3430   30D5 FF FF FF FF 
3430   30D9 FF FF FF FF 
3430   30DD FF FF FF FF 
3430   30E1 FF FF FF FF 
3430   30E5 FF FF FF FF 
3430   30E9 FF FF FF FF 
3430   30ED FF FF FF FF 
3430   30F1 FF FF FF FF 
3430   30F5 FF FF FF FF 
3430   30F9 FF FF FF FF 
3430   30FD FF FF FF FF 
3430   3101 FF FF FF FF 
3430   3105 FF FF FF FF 
3430   3109 FF FF FF FF 
3430   310D FF FF FF FF 
3430   3111 FF FF FF FF 
3430   3115 FF FF FF FF 
3430   3119 FF FF FF FF 
3430   311D FF FF FF FF 
3430   3121 FF FF FF FF 
3430   3125 FF FF FF FF 
3430   3129 FF FF FF FF 
3430   312D FF FF FF FF 
3430   3131 FF FF FF FF 
3430   3135 FF FF FF FF 
3430   3139 FF FF FF FF 
3430   313D FF FF FF FF 
3430   3141 FF FF FF FF 
3430   3145 FF FF FF FF 
3430   3149 FF FF FF FF 
3430   314D FF FF FF FF 
3430   3151 FF FF FF FF 
3430   3155 FF FF FF FF 
3430   3159 FF FF FF FF 
3430   315D FF FF FF FF 
3430   3161 FF FF FF FF 
3430   3165 FF FF FF FF 
3430   3169 FF FF FF FF 
3430   316D FF FF FF FF 
3430   3171 FF FF FF FF 
3430   3175 FF FF FF FF 
3430   3179 FF FF FF FF 
3430   317D FF FF FF FF 
3430   3181 FF FF FF FF 
3430   3185 FF FF FF FF 
3430   3189 FF FF FF FF 
3430   318D FF FF FF FF 
3430   3191 FF FF FF FF 
3430   3195 FF FF FF FF 
3430   3199 FF FF FF FF 
3430   319D FF FF FF FF 
3430   31A1 FF FF FF FF 
3430   31A5 FF FF FF FF 
3430   31A9 FF FF FF FF 
3430   31AD FF FF FF FF 
3430   31B1 FF FF FF FF 
3430   31B5 FF FF FF FF 
3430   31B9 FF FF FF FF 
3430   31BD FF FF FF FF 
3430   31C1 FF FF FF FF 
3430   31C5 FF FF FF FF 
3430   31C9 FF FF FF FF 
3430   31CD FF FF FF FF 
3430   31D1 FF FF FF FF 
3430   31D5 FF FF FF FF 
3430   31D9 FF FF FF FF 
3430   31DD FF FF FF FF 
3430   31E1 FF FF FF FF 
3430   31E5 FF FF FF FF 
3430   31E9 FF FF FF FF 
3430   31ED FF FF FF FF 
3430   31F1 FF FF FF FF 
3430   31F5 FF FF FF FF 
3430   31F9 FF FF FF FF 
3430   31FD FF FF FF FF 
3430   3201 FF FF FF FF 
3430   3205 FF FF FF FF 
3430   3209 FF FF FF FF 
3430   320D FF FF FF FF 
3430   3211 FF FF FF FF 
3430   3215 FF FF FF FF 
3430   3219 FF FF FF FF 
3430   321D FF FF FF FF 
3430   3221 FF FF FF FF 
3430   3225 FF FF FF FF 
3430   3229 FF FF FF FF 
3430   322D FF FF FF FF 
3430   3231 FF FF FF FF 
3430   3235 FF FF FF FF 
3430   3239 FF FF FF FF 
3430   323D FF FF FF FF 
3430   3241 FF FF FF FF 
3430   3245 FF FF FF FF 
3430   3249 FF FF FF FF 
3430   324D FF FF FF FF 
3430   3251 FF FF FF FF 
3430   3255 FF FF FF FF 
3430   3259 FF FF FF FF 
3430   325D FF FF FF FF 
3430   3261 FF FF FF FF 
3430   3265 FF FF FF FF 
3430   3269 FF FF FF FF 
3430   326D FF FF FF FF 
3430   3271 FF FF FF FF 
3430   3275 FF FF FF FF 
3430   3279 FF FF FF FF 
3430   327D FF FF FF FF 
3430   3281 FF FF FF FF 
3430   3285 FF FF FF FF 
3430   3289 FF FF FF FF 
3430   328D FF FF FF FF 
3430   3291 FF FF FF FF 
3430   3295 FF FF FF FF 
3430   3299 FF FF FF FF 
3430   329D FF FF FF FF 
3430   32A1 FF FF FF FF 
3430   32A5 FF FF FF FF 
3430   32A9 FF FF FF FF 
3430   32AD FF FF FF FF 
3430   32B1 FF FF FF FF 
3430   32B5 FF FF FF FF 
3430   32B9 FF FF FF FF 
3430   32BD FF FF FF FF 
3430   32C1 FF FF FF FF 
3430   32C5 FF FF FF FF 
3430   32C9 FF FF FF FF 
3430   32CD FF FF FF FF 
3430   32D1 FF FF FF FF 
3430   32D5 FF FF FF FF 
3430   32D9 FF FF FF FF 
3430   32DD FF FF FF FF 
3430   32E1 FF FF FF FF 
3430   32E5 FF FF FF FF 
3430   32E9 FF FF FF FF 
3430   32ED FF FF FF FF 
3430   32F1 FF FF FF FF 
3430   32F5 FF FF FF FF 
3431   32F9             
3432   32F9             scrap_sector:
3433   32F9 FF FF FF FF   .fill 512         ; scrap sector
3433   32FD FF FF FF FF 
3433   3301 FF FF FF FF 
3433   3305 FF FF FF FF 
3433   3309 FF FF FF FF 
3433   330D FF FF FF FF 
3433   3311 FF FF FF FF 
3433   3315 FF FF FF FF 
3433   3319 FF FF FF FF 
3433   331D FF FF FF FF 
3433   3321 FF FF FF FF 
3433   3325 FF FF FF FF 
3433   3329 FF FF FF FF 
3433   332D FF FF FF FF 
3433   3331 FF FF FF FF 
3433   3335 FF FF FF FF 
3433   3339 FF FF FF FF 
3433   333D FF FF FF FF 
3433   3341 FF FF FF FF 
3433   3345 FF FF FF FF 
3433   3349 FF FF FF FF 
3433   334D FF FF FF FF 
3433   3351 FF FF FF FF 
3433   3355 FF FF FF FF 
3433   3359 FF FF FF FF 
3433   335D FF FF FF FF 
3433   3361 FF FF FF FF 
3433   3365 FF FF FF FF 
3433   3369 FF FF FF FF 
3433   336D FF FF FF FF 
3433   3371 FF FF FF FF 
3433   3375 FF FF FF FF 
3433   3379 FF FF FF FF 
3433   337D FF FF FF FF 
3433   3381 FF FF FF FF 
3433   3385 FF FF FF FF 
3433   3389 FF FF FF FF 
3433   338D FF FF FF FF 
3433   3391 FF FF FF FF 
3433   3395 FF FF FF FF 
3433   3399 FF FF FF FF 
3433   339D FF FF FF FF 
3433   33A1 FF FF FF FF 
3433   33A5 FF FF FF FF 
3433   33A9 FF FF FF FF 
3433   33AD FF FF FF FF 
3433   33B1 FF FF FF FF 
3433   33B5 FF FF FF FF 
3433   33B9 FF FF FF FF 
3433   33BD FF FF FF FF 
3433   33C1 FF FF FF FF 
3433   33C5 FF FF FF FF 
3433   33C9 FF FF FF FF 
3433   33CD FF FF FF FF 
3433   33D1 FF FF FF FF 
3433   33D5 FF FF FF FF 
3433   33D9 FF FF FF FF 
3433   33DD FF FF FF FF 
3433   33E1 FF FF FF FF 
3433   33E5 FF FF FF FF 
3433   33E9 FF FF FF FF 
3433   33ED FF FF FF FF 
3433   33F1 FF FF FF FF 
3433   33F5 FF FF FF FF 
3433   33F9 FF FF FF FF 
3433   33FD FF FF FF FF 
3433   3401 FF FF FF FF 
3433   3405 FF FF FF FF 
3433   3409 FF FF FF FF 
3433   340D FF FF FF FF 
3433   3411 FF FF FF FF 
3433   3415 FF FF FF FF 
3433   3419 FF FF FF FF 
3433   341D FF FF FF FF 
3433   3421 FF FF FF FF 
3433   3425 FF FF FF FF 
3433   3429 FF FF FF FF 
3433   342D FF FF FF FF 
3433   3431 FF FF FF FF 
3433   3435 FF FF FF FF 
3433   3439 FF FF FF FF 
3433   343D FF FF FF FF 
3433   3441 FF FF FF FF 
3433   3445 FF FF FF FF 
3433   3449 FF FF FF FF 
3433   344D FF FF FF FF 
3433   3451 FF FF FF FF 
3433   3455 FF FF FF FF 
3433   3459 FF FF FF FF 
3433   345D FF FF FF FF 
3433   3461 FF FF FF FF 
3433   3465 FF FF FF FF 
3433   3469 FF FF FF FF 
3433   346D FF FF FF FF 
3433   3471 FF FF FF FF 
3433   3475 FF FF FF FF 
3433   3479 FF FF FF FF 
3433   347D FF FF FF FF 
3433   3481 FF FF FF FF 
3433   3485 FF FF FF FF 
3433   3489 FF FF FF FF 
3433   348D FF FF FF FF 
3433   3491 FF FF FF FF 
3433   3495 FF FF FF FF 
3433   3499 FF FF FF FF 
3433   349D FF FF FF FF 
3433   34A1 FF FF FF FF 
3433   34A5 FF FF FF FF 
3433   34A9 FF FF FF FF 
3433   34AD FF FF FF FF 
3433   34B1 FF FF FF FF 
3433   34B5 FF FF FF FF 
3433   34B9 FF FF FF FF 
3433   34BD FF FF FF FF 
3433   34C1 FF FF FF FF 
3433   34C5 FF FF FF FF 
3433   34C9 FF FF FF FF 
3433   34CD FF FF FF FF 
3433   34D1 FF FF FF FF 
3433   34D5 FF FF FF FF 
3433   34D9 FF FF FF FF 
3433   34DD FF FF FF FF 
3433   34E1 FF FF FF FF 
3433   34E5 FF FF FF FF 
3433   34E9 FF FF FF FF 
3433   34ED FF FF FF FF 
3433   34F1 FF FF FF FF 
3433   34F5 FF FF FF FF 
3434   34F9             transient_area:
3435   34F9 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
3436   34FA             
3437   34FA             .end
tasm: Number of errors = 0
