0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             _stack_begin      .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size        .equ 4096
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; DISK LAYOUT:
0086   0000             ; | Metadata               | Size (bytes)    | Blocks (2048 bytes)              |
0087   0000             ; | ---------------------- | --------------- | -------------------------------- |
0088   0000             ; | Bootloader             | 512 bytes       | 0.25 (1 sector)                  |
0089   0000             ; | Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0090   0000             ; | Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0091   0000             ; | Block Bitmap           | 16,384 bytes    | 8 blocks                         |
0092   0000             ; | Inode Bitmap           | 2,048 bytes     | 1 block                          |
0093   0000             ; | Inode Table            | 2,097,152 bytes | 1024 blocks                      |
0094   0000             ; 
0095   0000             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0096   0000             ; up to 4 partitions, each 16 bytes long
0097   0000             ; MBR:
0098   0000             ; Byte | Description
0099   0000             ; -----|----------------------------
0100   0000             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0101   0000             ; 1-3  | Start CHS (head, sector, cylinder)
0102   0000             ; 4    | Partition type (filesystem ID)
0103   0000             ;   0x83 = Linux native (ext2/3/4)
0104   0000             ;   0x07 = NTFS/exFAT
0105   0000             ;   0x0B = FAT32 CHS
0106   0000             ;   0x0C = FAT32 LBA
0107   0000             ;   0x05 = Extended partition
0108   0000             ; 5-7  | End CHS
0109   0000             ; 8-11 | Start LBA (little endian)
0110   0000             ; 12-15| Size in sectors (little endian)
0111   0000             ; 
0112   0000             ; 
0113   0000             ; SUPERBLOCK:
0114   0000             ; | Field                 | Description                                  |
0115   0000             ; | --------------------- | -------------------------------------------- |
0116   0000             ; | `s_inodes_count`      | Total number of inodes in the filesystem     |
0117   0000             ; | `s_blocks_count`      | Total number of data blocks                  |
0118   0000             ; | `s_free_inodes_count` | Number of free inodes                        |
0119   0000             ; | `s_free_blocks_count` | Number of free blocks                        |
0120   0000             ; | `s_first_data_block`  | Block number of the first data block         |
0121   0000             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`      |
0122   0000             ; | `s_inode_size`        | Size of each inode (in bytes)                |
0123   0000             ; | `s_magic`             | Filesystem signature (`0xEF53` for ext2/3/4) |
0124   0000             ; | `s_mtime`             | Last mount time                              |
0125   0000             ; | `s_wtime`             | Last write time                              |
0126   0000             ; | `s_uuid`              | Unique ID of the filesystem                  |
0127   0000             ; | `s_volume_name`       | Label of the filesystem                      |
0128   0000             ; | `s_feature_flags`     | Compatibility flags                          |
0129   0000             ; 
0130   0000             ; 
0131   0000             ; 
0132   0000             ; inode for root dir is #2, #0 and #1 not used
0133   0000             ; block size: 2048
0134   0000             
0135   0000             ; inode-table format:
0136   0000             ; | Field         | Size (bytes) | Description                                                                                  |
0137   0000             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0138   0000             ; | `mode`        | 2            | File type and permissions                                                                    |
0139   0000             ; | `uid`         | 2            | Owner user ID                                                                                |
0140   0000             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0141   0000             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0142   0000             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0143   0000             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0144   0000             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0145   0000             ; | `gid`         | 2            | Group ID                                                                                     |
0146   0000             ; | `links_count` | 2            | Number of hard links                                                                         |
0147   0000             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0148   0000             ; | `flags`       | 4            | File flags                                                                                   |
0149   0000             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0150   0000             
0151   0000             
0152   0000             ; file entry attributes
0153   0000             ; filename (24)
0154   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0155   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0156   0000             ; size (2)             : filesize
0157   0000             ; day (1)           
0158   0000             ; month (1)
0159   0000             ; year (1)
0160   0000             ; packet size = 32 bytes  : total packet size in bytes
0161   0000             
0162   0000             fst_entry_size      .equ 32  ; bytes
0163   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0164   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0165   0000             fst_nbr_directories .equ 64
0166   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0167   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0168   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0169   0000             fst_lba_start       .equ 32
0170   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0171   0000             
0172   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0173   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0174   0000                                         ; so that we know which blocks are free or taken
0175   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0176   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0177   0000             fs_lba_start        .equ (fst_lba_end + 1)
0178   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0179   0000             
0180   0000             root_id:            .equ fst_lba_start
0181   0000             
0182   0000             ; ------------------------------------------------------------------------------------------------------------------;
0183   0000             ; global system variables
0184   0000             ; ------------------------------------------------------------------------------------------------------------------;
0185   0000             
0186   0000             ; ------------------------------------------------------------------------------------------------------------------;
0187   0000             ; irq table
0188   0000             ; highest priority at lowest address
0189   0000             ; ------------------------------------------------------------------------------------------------------------------;
0190   0000 3C 00       .dw int_0_fdc
0191   0002 3D 00       .dw int_1
0192   0004 3E 00       .dw int_2
0193   0006 3F 00       .dw int_3
0194   0008 40 00       .dw int_4
0195   000A 41 00       .dw int_5
0196   000C 42 00       .dw int_6
0197   000E 43 00       .dw int_7_uart0
0198   0010             
0199   0010             ; ------------------------------------------------------------------------------------------------------------------;
0200   0010             ; kernel reset vector
0201   0010             ; ------------------------------------------------------------------------------------------------------------------;
0202   0010 2B 11       .dw kernel_reset_vector
0203   0012             
0204   0012             ; ------------------------------------------------------------------------------------------------------------------;
0205   0012             ; exception vector table
0206   0012             ; total of 7 entries, starting at address $0012
0207   0012             ; ------------------------------------------------------------------------------------------------------------------;
0208   0012 E0 03       .dw trap_privilege
0209   0014 FD 04       .dw trap_div_zero
0210   0016 0A 05       .dw trap_undef_opcode
0211   0018 00 00       .dw 0
0212   001A 00 00       .dw 0
0213   001C 00 00       .dw 0
0214   001E 00 00       .dw 0
0215   0020             
0216   0020             ; ------------------------------------------------------------------------------------------------------------------;
0217   0020             ; system call vector table
0218   0020             ; starts at address $0020
0219   0020             ; ------------------------------------------------------------------------------------------------------------------;
0220   0020 EC 03       .dw syscall_break
0221   0022 0B 05       .dw syscall_rtc
0222   0024 2E 06       .dw syscall_ide
0223   0026 EE 06       .dw syscall_io
0224   0028 AB 07       .dw syscall_file_system
0225   002A 78 10       .dw syscall_create_proc
0226   002C A5 03       .dw syscall_list_procs
0227   002E 3D 05       .dw syscall_datetime
0228   0030 61 03       .dw syscall_reboot
0229   0032 42 10       .dw syscall_pause_proc
0230   0034 6D 03       .dw syscall_resume_proc
0231   0036 FF 0F       .dw syscall_terminate_proc
0232   0038 2D 03       .dw syscall_system
0233   003A 9D 00       .dw syscall_fdc
0234   003C             
0235   003C             ; ------------------------------------------------------------------------------------------------------------------;
0236   003C             ; system call aliases
0237   003C             ; ------------------------------------------------------------------------------------------------------------------;
0238   003C             sys_break            .equ 0
0239   003C             sys_rtc              .equ 1
0240   003C             sys_ide              .equ 2
0241   003C             sys_io               .equ 3
0242   003C             sys_filesystem       .equ 4
0243   003C             sys_create_proc      .equ 5
0244   003C             sys_list_proc        .equ 6
0245   003C             sys_datetime         .equ 7
0246   003C             sys_reboot           .equ 8
0247   003C             sys_pause_proc       .equ 9
0248   003C             sys_resume_proc      .equ 10
0249   003C             sys_terminate_proc   .equ 11
0250   003C             sys_system           .equ 12
0251   003C             sys_fdc              .equ 13
0252   003C             
0253   003C             ; aliases for individual 'al' options for FDC system calls
0254   003C             fdc_al_restore      .equ 0
0255   003C             fdc_al_step         .equ 1
0256   003C             fdc_al_step_in      .equ 2
0257   003C             fdc_al_step_out     .equ 3
0258   003C             fdc_al_seek         .equ 4
0259   003C             fdc_al_format_128   .equ 5
0260   003C             fdc_al_formatdisk_128   .equ 6
0261   003C             fdc_al_format_512   .equ 7
0262   003C             fdc_al_formatdisk_512   .equ 8
0263   003C             fdc_al_read_addr    .equ 9
0264   003C             fdc_al_read_track   .equ 10
0265   003C             fdc_al_read_sect    .equ 11
0266   003C             fdc_al_write_sect   .equ 12
0267   003C             fdc_al_force_int    .equ 13
0268   003C             fdc_al_status0      .equ 14
0269   003C             fdc_al_status1      .equ 15
0270   003C             
0271   003C             ; ------------------------------------------------------------------------------------------------------------------;
0272   003C             ; alias exports
0273   003C             ; ------------------------------------------------------------------------------------------------------------------;
0274   003C             .export text_org
0275   003C             .export sys_break
0276   003C             .export sys_rtc
0277   003C             .export sys_ide
0278   003C             .export sys_io
0279   003C             .export sys_filesystem
0280   003C             .export sys_create_proc
0281   003C             .export sys_list_proc
0282   003C             .export sys_datetime
0283   003C             .export sys_reboot
0284   003C             .export sys_pause_proc
0285   003C             .export sys_resume_proc
0286   003C             .export sys_terminate_proc
0287   003C             .export sys_system
0288   003C             .export sys_fdc
0289   003C             
0290   003C             .export _7seg_display
0291   003C             
0292   003C             .export _fdc_config        
0293   003C             .export _fdc_status_0      
0294   003C             .export _fdc_stat_cmd     
0295   003C             
0296   003C             ; exports of aliases for individual 'al' options for FDC system calls
0297   003C             .export fdc_al_restore
0298   003C             .export fdc_al_step
0299   003C             .export fdc_al_step_in
0300   003C             .export fdc_al_step_out
0301   003C             .export fdc_al_seek
0302   003C             .export fdc_al_format_128
0303   003C             .export fdc_al_formatdisk_128
0304   003C             .export fdc_al_format_512
0305   003C             .export fdc_al_formatdisk_512
0306   003C             .export fdc_al_read_addr
0307   003C             .export fdc_al_read_track
0308   003C             .export fdc_al_read_sect
0309   003C             .export fdc_al_write_sect
0310   003C             .export fdc_al_force_int
0311   003C             .export fdc_al_status0
0312   003C             .export fdc_al_status1
0313   003C             
0314   003C             ; ------------------------------------------------------------------------------------------------------------------;
0315   003C             ; irqs' code block
0316   003C             ; ------------------------------------------------------------------------------------------------------------------;
0317   003C             ; 5.25" floppy drive controller irq
0318   003C             int_0_fdc:
0319   003C 06            sysret
0320   003D             int_1:
0321   003D 06            sysret
0322   003E             int_2:
0323   003E 06            sysret
0324   003F             int_3:
0325   003F 06            sysret
0326   0040             int_4:
0327   0040 06            sysret
0328   0041             int_5:
0329   0041 06            sysret
0330   0042             
0331   0042             ; timer irq
0332   0042             int_6:  
0333   0042 06            sysret
0334   0043             
0335   0043             ; ------------------------------------------------------------------------------------------------------------------;
0336   0043             ; uart0 interrupt
0337   0043             ; ------------------------------------------------------------------------------------------------------------------;
0338   0043             int_7_uart0:
0339   0043 D7            push a
0340   0044 DA            push d
0341   0045 E1            pushf
0342   0046 14 BD 18      mov a, [fifo_in]
0343   0049 3C            mov d, a
0344   004A 1D 80 FF      mov al, [_uart0_data]       ; get character
0345   004D B9 03         cmp al, $03                 ; ctrl-c
0346   004F C6 71 00      je ctrlc
0347   0052 B9 1A         cmp al, $1a                 ; ctrl-z
0348   0054 C6 77 00      je ctrlz
0349   0057 3E            mov [d], al                 ; add to fifo
0350   0058 14 BD 18      mov a, [fifo_in]
0351   005B 77            inc a
0352   005C 99            mov bl, ah
0353   005D FD 3D B0 FF   mov [_7seg_display], bl
0354   0061 AF 1E 30      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0355   0064 C7 6A 00      jne int_7_continue
0356   0067 10 1E 20      mov a, fifo  
0357   006A             int_7_continue:  
0358   006A 42 BD 18      mov [fifo_in], a            ; update fifo pointer
0359   006D EE            popf
0360   006E E7            pop d
0361   006F E4            pop a  
0362   0070 06            sysret
0363   0071             ctrlc:
0364   0071 51 05 00      add sp, 5
0365   0074 0A FF 0F      jmp syscall_terminate_proc
0366   0077             ctrlz:
0367   0077 EE            popf
0368   0078 E7            pop d
0369   0079 E4            pop a
0370   007A 0A 42 10      jmp syscall_pause_proc      ; pause current process and go back to the shell
0371   007D             
0372   007D             ; ------------------------------------------------------------------------------------------------------------------;
0373   007D             ; floppy drive syscalls
0374   007D             ; ------------------------------------------------------------------------------------------------------------------;
0375   007D             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0376   007D             ; fdc_40_ff:
0377   007D             ;   .fill 40,  $ff    ; or 00                                                                                
0378   007D             ; fdc_128_format_inner:
0379   007D             ;   .fill 6,   $00    ;                                                                            <--|        
0380   007D             ;   .fill 1,   $fe    ; id address mark                                                               |        
0381   007D             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0382   007D             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0383   007D             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0384   007D             ;   .fill 1,   $00    ; sector length                                                                 |                        
0385   007D             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0386   007D             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0387   007D             ;   .fill 6,   $00    ;                                                                               |                        
0388   007D             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0389   007D             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0390   007D             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0391   007D             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0392   007D             ; fdc_128_format_end:
0393   007D             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0394   007D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0395   007D             fdc_jmptbl:
0396   007D A9 00         .dw syscall_fdc_restore
0397   007F B5 00         .dw syscall_fdc_step
0398   0081 BD 00         .dw syscall_fdc_step_in
0399   0083 C5 00         .dw syscall_fdc_step_out
0400   0085 CD 00         .dw syscall_fdc_seek
0401   0087 DB 00         .dw syscall_fdc_format_128
0402   0089 2F 01         .dw syscall_fdc_formatdisk_128
0403   008B 05 01         .dw syscall_fdc_format_512
0404   008D 69 01         .dw syscall_fdc_formatdisk_512
0405   008F D9 00         .dw syscall_fdc_read_addr
0406   0091 A3 01         .dw syscall_fdc_read_track
0407   0093 D2 01         .dw syscall_fdc_read_sect
0408   0095 0A 02         .dw syscall_fdc_write_sect
0409   0097 DA 00         .dw syscall_fdc_force_int
0410   0099 A1 00         .dw syscall_fdc_status0
0411   009B A5 00         .dw syscall_fdc_status1
0412   009D             syscall_fdc:
0413   009D FD 0A 7D 00   jmp [fdc_jmptbl + al]
0414   00A1             
0415   00A1             syscall_fdc_status0:
0416   00A1 1D C1 FF      mov al, [_fdc_status_0]
0417   00A4 06            sysret
0418   00A5             
0419   00A5             syscall_fdc_status1:
0420   00A5 1D C8 FF      mov al, [_fdc_stat_cmd]
0421   00A8 06            sysret
0422   00A9             
0423   00A9             syscall_fdc_restore:
0424   00A9 07 3B 02      call fdc_wait_not_busy
0425   00AC F2 C8 FF 0A   mov byte [_fdc_stat_cmd], %00001010
0426   00B0 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0427   00B4 06            sysret
0428   00B5             
0429   00B5             syscall_fdc_step:
0430   00B5 07 3B 02      call fdc_wait_not_busy
0431   00B8 F2 C8 FF 38   mov byte [_fdc_stat_cmd], %00111000
0432   00BC 06            sysret
0433   00BD             
0434   00BD             syscall_fdc_step_in:
0435   00BD 07 3B 02      call fdc_wait_not_busy
0436   00C0 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0437   00C4 06            sysret
0438   00C5             
0439   00C5             syscall_fdc_step_out:
0440   00C5 07 3B 02      call fdc_wait_not_busy
0441   00C8 F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0442   00CC 06            sysret
0443   00CD             
0444   00CD             ; bl: desired track
0445   00CD             syscall_fdc_seek:
0446   00CD 07 3B 02      call fdc_wait_not_busy
0447   00D0 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to bl
0448   00D4 F2 C8 FF 18   mov byte [_fdc_stat_cmd], %00011000 ; seek command
0449   00D8 06            sysret
0450   00D9             
0451   00D9             syscall_fdc_read_addr:
0452   00D9 06            sysret
0453   00DA             
0454   00DA             syscall_fdc_force_int:
0455   00DA 06            sysret
0456   00DB             
0457   00DB             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0458   00DB             ; in the ram formatting block because they are all set as 00 right now
0459   00DB             ; bl: track number
0460   00DB             syscall_fdc_format_128:
0461   00DB 07 46 02      call fdc_format_mem_128
0462   00DE 07 3B 02      call fdc_wait_not_busy
0463   00E1 FD 3D C9 FF   mov [_fdc_track], bl
0464   00E5 FD 4D 1E 32   mov si, transient_area
0465   00E9 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0466   00ED 07 1C 03      call fdc_wait_64us
0467   00F0             fdc_format_drq_128:
0468   00F0 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0469   00F3 93 01         test al, $01                ; 4
0470   00F5 C6 04 01      jz fdc_format_end_128           ; 8
0471   00F8 93 02         test al, $02                ; 4
0472   00FA C6 F0 00      jz fdc_format_drq_128           ; 8
0473   00FD F6            lodsb                       ; 7
0474   00FE 3D CB FF      mov [_fdc_data], al         ; 10   
0475   0101 0A F0 00      jmp fdc_format_drq_128
0476   0104             fdc_format_end_128:
0477   0104 06            sysret
0478   0105             
0479   0105             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0480   0105             ; in the ram formatting block because they are all set as 00 right now
0481   0105             ; bl: track number
0482   0105             syscall_fdc_format_512:
0483   0105 07 B1 02      call fdc_format_mem_512
0484   0108 07 3B 02      call fdc_wait_not_busy
0485   010B FD 3D C9 FF   mov [_fdc_track], bl
0486   010F FD 4D 1E 32   mov si, transient_area
0487   0113 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0488   0117 07 1C 03      call fdc_wait_64us
0489   011A             fdc_format_drq_512:
0490   011A 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0491   011D 93 01         test al, $01                ; 4
0492   011F C6 2E 01      jz fdc_format_end_512           ; 8
0493   0122 93 02         test al, $02                ; 4
0494   0124 C6 1A 01      jz fdc_format_drq_512           ; 8
0495   0127 F6            lodsb                       ; 7
0496   0128 3D CB FF      mov [_fdc_data], al         ; 10   
0497   012B 0A 1A 01      jmp fdc_format_drq_512
0498   012E             fdc_format_end_512:
0499   012E 06            sysret
0500   012F             
0501   012F             syscall_fdc_formatdisk_128:
0502   012F 2E 00         mov bl, 0
0503   0131             fdc_formatdisk128_l0:
0504   0131 07 46 02      call fdc_format_mem_128
0505   0134 07 3B 02      call fdc_wait_not_busy
0506   0137 FD 3D C9 FF   mov [_fdc_track], bl
0507   013B FD 4D 1E 32   mov si, transient_area
0508   013F F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0509   0143 07 1C 03      call fdc_wait_64us
0510   0146             fdc_formatdisk_drq_128:
0511   0146 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0512   0149 93 01         test al, $01                ; 4
0513   014B C6 5A 01      jz fdc_formatdisk_end_128           ; 8
0514   014E 93 02         test al, $02                ; 4
0515   0150 C6 46 01      jz fdc_formatdisk_drq_128           ; 8
0516   0153 F6            lodsb                       ; 7
0517   0154 3D CB FF      mov [_fdc_data], al         ; 10   
0518   0157 0A 46 01      jmp fdc_formatdisk_drq_128
0519   015A             fdc_formatdisk_end_128:
0520   015A 07 3B 02      call fdc_wait_not_busy
0521   015D F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000  ; step in
0522   0161 6C 01         add bl, 1
0523   0163 C1 28         cmp bl, 40
0524   0165 C7 31 01      jne fdc_formatdisk128_l0
0525   0168 06            sysret
0526   0169             
0527   0169             syscall_fdc_formatdisk_512:
0528   0169 2E 00         mov bl, 0
0529   016B             fdc_formatdisk512_l0:
0530   016B 07 B1 02      call fdc_format_mem_512
0531   016E 07 3B 02      call fdc_wait_not_busy
0532   0171 FD 3D C9 FF   mov [_fdc_track], bl
0533   0175 FD 4D 1E 32   mov si, transient_area
0534   0179 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0535   017D 07 1C 03      call fdc_wait_64us
0536   0180             fdc_formatdisk_drq_512:
0537   0180 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0538   0183 93 01         test al, $01                ; 4
0539   0185 C6 94 01      jz fdc_formatdisk_end_512           ; 8
0540   0188 93 02         test al, $02                ; 4
0541   018A C6 80 01      jz fdc_formatdisk_drq_512           ; 8
0542   018D F6            lodsb                       ; 7
0543   018E 3D CB FF      mov [_fdc_data], al         ; 10   
0544   0191 0A 80 01      jmp fdc_formatdisk_drq_512
0545   0194             fdc_formatdisk_end_512:
0546   0194 07 3B 02      call fdc_wait_not_busy
0547   0197 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000   ; step in
0548   019B 6C 01         add bl, 1
0549   019D C1 28         cmp bl, 40
0550   019F C7 6B 01      jne fdc_formatdisk512_l0
0551   01A2 06            sysret
0552   01A3             
0553   01A3             ; di : destination in user space
0554   01A3             ; a  : returns number of read bytes
0555   01A3             syscall_fdc_read_track:
0556   01A3 07 3B 02      call fdc_wait_not_busy
0557   01A6 E3            push di
0558   01A7 FD 4F 1E 32   mov di, transient_area
0559   01AB F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0560   01AF 07 1C 03      call fdc_wait_64us
0561   01B2             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0562   01B2 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0563   01B5 93 01         test al, $01                ; check busy bit
0564   01B7 C6 C6 01      jz fdc_read_track_end
0565   01BA 93 02         test al, $02                ; check drq bit
0566   01BC C6 B2 01      jz fdc_read_track_l0
0567   01BF 1D CB FF      mov al, [_fdc_data]     ; 
0568   01C2 F7            stosb
0569   01C3 0A B2 01      jmp fdc_read_track_l0
0570   01C6             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0571   01C6             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0572   01C6             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0573   01C6             fdc_read_track_end:
0574   01C6 50            mov a, di
0575   01C7 5F 1E 32      sub a, transient_area
0576   01CA F0            pop di
0577   01CB FD 4D 1E 32   mov si, transient_area
0578   01CF 39            mov c, a  ; copy track over to user space
0579   01D0 03            store
0580   01D1 06            sysret
0581   01D2             
0582   01D2             ; sector in bl
0583   01D2             ; track in bh
0584   01D2             ; di = user space destination
0585   01D2             syscall_fdc_read_sect:
0586   01D2 07 3B 02      call fdc_wait_not_busy
0587   01D5 E3            push di
0588   01D6 FD 3D CA FF   mov [_fdc_sector], bl
0589   01DA 30            mov bl, bh
0590   01DB FD 3D C9 FF   mov [_fdc_track], bl
0591   01DF F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0592   01E3 07 1C 03      call fdc_wait_64us
0593   01E6 FD 4F 1E 32   mov di, transient_area
0594   01EA             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0595   01EA 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0596   01ED 93 01         test al, $01                ; check drq bit
0597   01EF C6 FE 01      jz fdc_read_sect_end
0598   01F2 93 02         test al, $02                ; check drq bit
0599   01F4 C6 EA 01      jz fdc_read_sect_l0
0600   01F7 1D CB FF      mov al, [_fdc_data]     ; 
0601   01FA F7            stosb
0602   01FB 0A EA 01      jmp fdc_read_sect_l0
0603   01FE             fdc_read_sect_end:
0604   01FE 50            mov a, di
0605   01FF 5F 1E 32      sub a, transient_area
0606   0202 F0            pop di
0607   0203 FD 4D 1E 32   mov si, transient_area
0608   0207 39            mov c, a  ; copy sector over to user space
0609   0208 03            store
0610   0209 06            sysret
0611   020A             
0612   020A             ; sector size in c
0613   020A             ; sector in bl
0614   020A             ; track in bh
0615   020A             ; data pointer in si
0616   020A             syscall_fdc_write_sect:
0617   020A 07 3B 02      call fdc_wait_not_busy
0618   020D FD 3D CA FF   mov [_fdc_sector], bl
0619   0211 30            mov bl, bh
0620   0212 FD 3D C9 FF   mov [_fdc_track], bl
0621   0216 FD 4F 1E 32   mov di, transient_area    ; si = data source, di = destination 
0622   021A 04            load                    ; transfer data to kernel space!
0623   021B FD 4D 1E 32   mov si, transient_area
0624   021F F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0625   0223 07 1C 03      call fdc_wait_64us
0626   0226             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0627   0226 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0628   0229 93 01         test al, $01                    ; 4
0629   022B C6 3A 02      jz fdc_write_sect_end           ; 8
0630   022E 93 02         test al, $02                    ; 4
0631   0230 C6 26 02      jz fdc_write_sect_l0            ; 8
0632   0233 F6            lodsb                           ; 7
0633   0234 3D CB FF      mov [_fdc_data], al             ; 10   
0634   0237 0A 26 02      jmp fdc_write_sect_l0
0635   023A             fdc_write_sect_end:
0636   023A 06            sysret
0637   023B             
0638   023B             fdc_wait_not_busy:
0639   023B DB            push al
0640   023C 1D C8 FF      mov al, [_fdc_stat_cmd]   
0641   023F 93 01         test al, $01               
0642   0241 C7 3B 02      jnz fdc_wait_not_busy          
0643   0244 E8            pop al
0644   0245 09            ret
0645   0246             
0646   0246             ; track number in bl
0647   0246             fdc_format_mem_128:
0648   0246 3B 01 00      mov d, 1
0649   0249 FD 4F 1E 32   mov di, transient_area
0650   024D             ; 40 * FF
0651   024D 38 28 00      mov c, 40
0652   0250 19 FF         mov al, $ff
0653   0252             fdc_l0: 
0654   0252 F7            stosb
0655   0253 7E            dec c
0656   0254 C7 52 02      jnz fdc_l0
0657   0257             ; 6 * 00
0658   0257             fdc_inner_loop:
0659   0257 38 06 00      mov c, 6
0660   025A 19 00         mov al, $00
0661   025C             fdc_l1:
0662   025C F7            stosb
0663   025D 7E            dec c
0664   025E C7 5C 02      jnz fdc_l1
0665   0261             ; FE address mark
0666   0261             fdc_l2:
0667   0261 19 FE         mov al, $fe
0668   0263 F7            stosb
0669   0264             ; track number
0670   0264             fdc_l3:
0671   0264 1B            mov al, bl  ; track number in bl
0672   0265 F7            stosb
0673   0266             ; side number
0674   0266             fdc_l4:
0675   0266 19 00         mov al, $00
0676   0268 F7            stosb
0677   0269             ; sector number
0678   0269             fdc_l5:
0679   0269 13            mov a, d
0680   026A F7            stosb
0681   026B             ; sector length 128 bytes
0682   026B             fdc_l6:
0683   026B 19 00         mov al, $00
0684   026D F7            stosb
0685   026E             ; 2 crc's
0686   026E             fdc_l7:
0687   026E 19 F7         mov al, $f7
0688   0270 F7            stosb
0689   0271             ; 11 times $ff
0690   0271 38 0B 00      mov c, 11
0691   0274 19 FF         mov al, $ff
0692   0276             fdc_l8:
0693   0276 F7            stosb
0694   0277 7E            dec c
0695   0278 C7 76 02      jnz fdc_l8
0696   027B             ; 6 times 00
0697   027B 38 06 00      mov c, 6
0698   027E 19 00         mov al, $00
0699   0280             fdc_l9:
0700   0280 F7            stosb
0701   0281 7E            dec c
0702   0282 C7 80 02      jnz fdc_l9
0703   0285             ; FB data address mark
0704   0285 19 FB         mov al, $fb
0705   0287             fdc_l10:
0706   0287 F7            stosb
0707   0288             ; 128 bytes sector data
0708   0288 38 80 00      mov c, 128
0709   028B 19 E5         mov al, $E5
0710   028D             fdc_l11:
0711   028D F7            stosb
0712   028E 7E            dec c
0713   028F C7 8D 02      jnz fdc_l11
0714   0292             ; 2 crc's
0715   0292             fdc_l12:
0716   0292 19 F7         mov al, $f7
0717   0294 F7            stosb
0718   0295             ; 10 * $FF
0719   0295 38 0A 00      mov c, 10
0720   0298 19 FF         mov al, $ff
0721   029A             fdc_l13:
0722   029A F7            stosb
0723   029B 7E            dec c
0724   029C C7 9A 02      jnz fdc_l13
0725   029F             ; check whether we did this 16 times
0726   029F 79            inc d
0727   02A0 C5 11 00      cmp d, 17
0728   02A3 C7 57 02      jne fdc_inner_loop
0729   02A6             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0730   02A6 38 F4 01      mov c, 500
0731   02A9 19 FF         mov al, $ff
0732   02AB             fdc_format_footer:
0733   02AB             fdc_footer_drq_loop:
0734   02AB F7            stosb
0735   02AC 7E            dec c
0736   02AD C7 AB 02      jnz fdc_footer_drq_loop
0737   02B0 09            ret
0738   02B1             
0739   02B1             ; track number in bl
0740   02B1             fdc_format_mem_512:
0741   02B1 3B 01 00      mov d, 1
0742   02B4 FD 4F 1E 32   mov di, transient_area
0743   02B8             ; 40 * FF
0744   02B8 38 28 00      mov c, 40
0745   02BB 19 FF         mov al, $ff
0746   02BD             fdc_512_l0: 
0747   02BD F7            stosb
0748   02BE 7E            dec c
0749   02BF C7 BD 02      jnz fdc_512_l0
0750   02C2             ; 6 * 00
0751   02C2             fdc_512_inner_loop:
0752   02C2 38 06 00      mov c, 6
0753   02C5 19 00         mov al, $00
0754   02C7             fdc_512_l1:
0755   02C7 F7            stosb
0756   02C8 7E            dec c
0757   02C9 C7 C7 02      jnz fdc_512_l1
0758   02CC             ; FE address mark
0759   02CC             fdc_512_l2:
0760   02CC 19 FE         mov al, $fe
0761   02CE F7            stosb
0762   02CF             ; track number
0763   02CF             fdc_512_l3:
0764   02CF 1B            mov al, bl ; track number was in bl
0765   02D0 F7            stosb
0766   02D1             ; side number
0767   02D1             fdc_512_l4:
0768   02D1 19 00         mov al, $00
0769   02D3 F7            stosb
0770   02D4             ; sector number
0771   02D4             fdc_512_l5:
0772   02D4 13            mov a, d
0773   02D5 F7            stosb
0774   02D6             ; sector length 512 bytes
0775   02D6             fdc_512_l6:
0776   02D6 19 02         mov al, $02
0777   02D8 F7            stosb
0778   02D9             ; 2 crc's
0779   02D9             fdc_512_l7:
0780   02D9 19 F7         mov al, $f7
0781   02DB F7            stosb
0782   02DC             ; 11 times $ff
0783   02DC 38 0B 00      mov c, 11
0784   02DF 19 FF         mov al, $ff
0785   02E1             fdc_512_l8:
0786   02E1 F7            stosb
0787   02E2 7E            dec c
0788   02E3 C7 E1 02      jnz fdc_512_l8
0789   02E6             ; 6 times 00
0790   02E6 38 06 00      mov c, 6
0791   02E9 19 00         mov al, $00
0792   02EB             fdc_512_l9:
0793   02EB F7            stosb
0794   02EC 7E            dec c
0795   02ED C7 EB 02      jnz fdc_512_l9
0796   02F0             ; FB data address mark
0797   02F0 19 FB         mov al, $fb
0798   02F2             fdc_512_l10:
0799   02F2 F7            stosb
0800   02F3             ; 128 bytes sector data
0801   02F3 38 00 02      mov c, 512
0802   02F6 19 E5         mov al, $E5
0803   02F8             fdc_512_l11:
0804   02F8 F7            stosb
0805   02F9 7E            dec c
0806   02FA C7 F8 02      jnz fdc_512_l11
0807   02FD             ; 2 crc's
0808   02FD             fdc_512_l12:
0809   02FD 19 F7         mov al, $f7
0810   02FF F7            stosb
0811   0300             ; 10 * $FF
0812   0300 38 0A 00      mov c, 10
0813   0303 19 FF         mov al, $ff
0814   0305             fdc_512_l13:
0815   0305 F7            stosb
0816   0306 7E            dec c
0817   0307 C7 05 03      jnz fdc_512_l13
0818   030A             ; check whether we did this 16 times
0819   030A 79            inc d
0820   030B C5 06 00      cmp d, 6
0821   030E C7 C2 02      jne fdc_512_inner_loop
0822   0311             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0823   0311 38 F4 01      mov c, 500
0824   0314 19 FF         mov al, $ff
0825   0316             fdc_512_format_footer:
0826   0316             fdc_512_footer_drq_loop:
0827   0316 F7            stosb
0828   0317 7E            dec c
0829   0318 C7 16 03      jnz fdc_512_footer_drq_loop
0830   031B 09            ret
0831   031C             
0832   031C             ; fetch is 2 cycles long when 'display_reg_load' is false.
0833   031C             ; 64us amounts to 160 cycles of the 2.5mhz clock
0834   031C             ; call u16 is 14 cycles long
0835   031C             ; 160 - 5 - 14 = 
0836   031C             fdc_wait_64us:
0837   031C 3A 0D         mov cl, 13                       ; 5 cycles
0838   031E             fdc_wait_64_loop:
0839   031E 81            dec cl                           ; 3 cycles
0840   031F C7 1E 03      jnz fdc_wait_64_loop             ; 8 cycles
0841   0322 09            ret
0842   0323             
0843   0323             ; ------------------------------------------------------------------------------------------------------------------;
0844   0323             ; system syscalls
0845   0323             ; ------------------------------------------------------------------------------------------------------------------;
0846   0323             system_jmptbl:
0847   0323 59 03         .dw system_uname
0848   0325 60 03         .dw system_whoami
0849   0327 33 03         .dw system_poke
0850   0329 36 03         .dw system_bootloader_install
0851   032B 31 03         .dw system_peek
0852   032D             syscall_system:
0853   032D FD 0A 23 03   jmp [system_jmptbl + al]
0854   0331             
0855   0331             ; param register address in register d
0856   0331             ; param value in register bl
0857   0331             system_peek:
0858   0331 32            mov bl, [d]
0859   0332 06            sysret
0860   0333             
0861   0333             ; param register address in register d
0862   0333             ; param value in register bl
0863   0333             system_poke:
0864   0333 FD 3E         mov [d], bl
0865   0335 06            sysret
0866   0336             
0867   0336             ; kernel LBA address in 'b'
0868   0336             system_bootloader_install:
0869   0336 D8            push b
0870   0337 26 00 00      mov b, 0
0871   033A 38 00 00      mov c, 0
0872   033D 22 01         mov ah, $01                 ; 1 sector
0873   033F 3B 1E 32      mov d, transient_area
0874   0342 07 5D 06      call ide_read_sect          ; read sector
0875   0345 E5            pop b
0876   0346 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0877   034A 26 00 00      mov b, 0
0878   034D 38 00 00      mov c, 0
0879   0350 22 01         mov ah, $01                 ; 1 sector
0880   0352 3B 1E 32      mov d, transient_area
0881   0355 07 83 06      call ide_write_sect         ; write sector
0882   0358 06            sysret
0883   0359             
0884   0359             system_uname:
0885   0359 3B CE 18      mov d, s_uname
0886   035C 07 87 13      call _puts
0887   035F 06            sysret
0888   0360             
0889   0360             system_whoami:
0890   0360 06            sysret
0891   0361             
0892   0361             ; reboot system
0893   0361             syscall_reboot:
0894   0361 FD D7 FF FF   push word $ffff 
0895   0365 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0896   0368 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0897   036C 06            sysret
0898   036D             
0899   036D             ;------------------------------------------------------------------------------------------------------;;
0900   036D             ; switch to another process
0901   036D             ; inputs:
0902   036D             ; al = new process number
0903   036D             ;------------------------------------------------------------------------------------------------------;;
0904   036D             syscall_resume_proc:
0905   036D FD 78         mov g, a                            ; save the process number
0906   036F 4B            pusha                               ; save all registers into kernel stack
0907   0370 22 00         mov ah, 0
0908   0372 1D B8 18      mov al, [active_proc_index]
0909   0375 FD 99         shl a              ; x2
0910   0377 B7 F5 10      mov a, [proc_table_convert + a]     ; get process state start index
0911   037A 4F            mov di, a
0912   037B 48            mov a, sp
0913   037C 77            inc a
0914   037D 4D            mov si, a
0915   037E 38 14 00      mov c, 20
0916   0381 FD F5         rep movsb                           ; save process state!
0917   0383             ; restore kernel stack position to point before interrupt arrived
0918   0383 51 14 00      add sp, 20
0919   0386             ; now load the new process number!
0920   0386 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0921   0388 3D B8 18      mov [active_proc_index], al         ; set new active proc
0922   038B             ; calculate lut entry for next process
0923   038B 22 00         mov ah, 0
0924   038D FD 99         shl a                               ; x2
0925   038F B7 F5 10      mov a, [proc_table_convert + a]     ; get process state start index  
0926   0392 4D            mov si, a                           ; source is proc state block
0927   0393 48            mov a, sp
0928   0394 5F 13 00      sub a, 19
0929   0397 4F            mov di, a                           ; destination is kernel stack
0930   0398             ; restore sp
0931   0398 7D            dec a
0932   0399 47            mov sp, a
0933   039A 38 14 00      mov c, 20
0934   039D FD F5         rep movsb
0935   039F             ; set vm process
0936   039F 1D B8 18      mov al, [active_proc_index]
0937   03A2 01            setptb
0938   03A3 4C            popa
0939   03A4 06            sysret
0940   03A5             
0941   03A5             ;------------------------------------------------------------------------------------------------------;;
0942   03A5             ; list processes
0943   03A5             ;------------------------------------------------------------------------------------------------------;;
0944   03A5             syscall_list_procs:
0945   03A5 3B EF 18      mov d, s_ps_header
0946   03A8 07 87 13      call _puts
0947   03AB 3B 8F 1B      mov d, proc_availab_table + 1
0948   03AE 38 01 00      mov c, 1
0949   03B1             list_procs_l0:  
0950   03B1 BD 01         cmp byte[d], 1
0951   03B3 C7 D7 03      jne list_procs_next
0952   03B6 2D            mov b, d
0953   03B7 61 8E 1B      sub b, proc_availab_table
0954   03BA FD 9F 05      shl b, 5
0955   03BD DA            push d
0956   03BE D8            push b
0957   03BF 28            mov b, c
0958   03C0 07 27 14      call print_u8x
0959   03C3 22 20         mov ah, ' '
0960   03C5 07 5B 12      call _putchar
0961   03C8 07 5B 12      call _putchar
0962   03CB E5            pop b
0963   03CC 74            mov d, b
0964   03CD 58 9E 1B      add d, proc_names
0965   03D0 07 87 13      call _puts
0966   03D3 07 34 13      call printnl
0967   03D6 E7            pop d
0968   03D7             list_procs_next:
0969   03D7 79            inc d
0970   03D8 78            inc c
0971   03D9 C2 09 00      cmp c, 9
0972   03DC C7 B1 03      jne list_procs_l0
0973   03DF             list_procs_end:
0974   03DF 06            sysret
0975   03E0             
0976   03E0             ; ------------------------------------------------------------------------------------------------------------------;
0977   03E0             ; exceptions code block
0978   03E0             ; ------------------------------------------------------------------------------------------------------------------;
0979   03E0             ; privilege exception
0980   03E0             ; ------------------------------------------------------------------------------------------------------------------;
0981   03E0             trap_privilege:
0982   03E0 0A 61 03      jmp syscall_reboot
0983   03E3 DA            push d
0984   03E4 3B 3E 19      mov d, s_priviledge
0985   03E7 07 87 13      call _puts
0986   03EA E7            pop d
0987   03EB 06            sysret
0988   03EC             
0989   03EC             ; ------------------------------------------------------------------------------------------------------------------;
0990   03EC             ; breakpoint
0991   03EC             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0992   03EC             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0993   03EC             ; ------------------------------------------------------------------------------------------------------------------;
0994   03EC             syscall_break:
0995   03EC 4B            pusha
0996   03ED             syscall_break_prompt:
0997   03ED 3B A7 04      mov d, s_break1
0998   03F0 07 87 13      call _puts
0999   03F3 07 34 13      call printnl
1000   03F6 07 89 14      call scan_u16d
1001   03F9 AF 00 00      cmp a, 0
1002   03FC C6 07 04      je syscall_break_regs
1003   03FF AF 01 00      cmp a, 1
1004   0402 C6 2A 04      je syscall_break_mem
1005   0405             syscall_break_end:  
1006   0405 4C            popa
1007   0406 06            sysret
1008   0407             syscall_break_regs:
1009   0407 48            mov a, sp
1010   0408 53 0E 00      add a, 14               ; back-track 7 registers
1011   040B 3C            mov d, a
1012   040C 3A 07         mov cl, 7
1013   040E             syscall_regs_l0:
1014   040E 2A            mov b, [d]
1015   040F FD AB         swp b
1016   0411 07 E3 13      call print_u16x         ; print register value
1017   0414 07 34 13      call printnl
1018   0417 63 02 00      sub d, 2
1019   041A 71 01         sub cl, 1
1020   041C C3 00         cmp cl, 0
1021   041E C7 0E 04      jne syscall_regs_l0
1022   0421 0A ED 03      jmp syscall_break_prompt
1023   0424 07 34 13      call printnl
1024   0427 0A ED 03      jmp syscall_break_prompt
1025   042A             syscall_break_mem:
1026   042A 07 34 13      call printnl
1027   042D 07 05 14      call scan_u16x
1028   0430 4D            mov si, a               ; data source from user space
1029   0431 FD 4F 1E 30   mov di, scrap_sector    ; destination in kernel space
1030   0435 38 00 02      mov c, 512
1031   0438 04            load                    ; transfer data to kernel space!
1032   0439 3B 1E 30      mov d, scrap_sector     ; dump pointer in d
1033   043C 38 00 00      mov c, 0
1034   043F             dump_loop:
1035   043F 84            mov al, cl
1036   0440 87 0F         and al, $0f
1037   0442 C6 90 04      jz print_base
1038   0445             back:
1039   0445 1E            mov al, [d]             ; read byte
1040   0446 2F            mov bl, al
1041   0447 07 27 14      call print_u8x
1042   044A 10 00 20      mov a, $2000
1043   044D 05 03         syscall sys_io          ; space
1044   044F 84            mov al, cl
1045   0450 87 0F         and al, $0f
1046   0452 B9 0F         cmp al, $0f
1047   0454 C6 65 04      je print_ascii
1048   0457             back1:
1049   0457 79            inc d
1050   0458 78            inc c
1051   0459 C2 00 02      cmp c, 512
1052   045C C7 3F 04      jne dump_loop
1053   045F 07 34 13      call printnl
1054   0462 0A ED 03      jmp syscall_break_prompt  ; go to syscall_break return point
1055   0465             print_ascii:
1056   0465 10 00 20      mov a, $2000
1057   0468 05 03         syscall sys_io
1058   046A 63 10 00      sub d, 16
1059   046D 26 10 00      mov b, 16
1060   0470             print_ascii_l:
1061   0470 79            inc d
1062   0471 1E            mov al, [d]               ; read byte
1063   0472 B9 20         cmp al, $20
1064   0474 C8 7C 04      jlu dot
1065   0477 B9 7E         cmp al, $7e
1066   0479 D0 84 04      jleu ascii
1067   047C             dot:
1068   047C 10 00 2E      mov a, $2e00
1069   047F 05 03         syscall sys_io
1070   0481 0A 89 04      jmp ascii_continue
1071   0484             ascii:
1072   0484 23            mov ah, al
1073   0485 19 00         mov al, 0
1074   0487 05 03         syscall sys_io
1075   0489             ascii_continue:
1076   0489 FD A9 70 04   loopb print_ascii_l
1077   048D 0A 57 04      jmp back1
1078   0490             print_base:
1079   0490 07 34 13      call printnl
1080   0493 2D            mov b, d
1081   0494 61 1E 30      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
1082   0497 07 E3 13      call print_u16x          ; display row
1083   049A 10 00 3A      mov a, $3a00
1084   049D 05 03         syscall sys_io
1085   049F 10 00 20      mov a, $2000
1086   04A2 05 03         syscall sys_io
1087   04A4 0A 45 04      jmp back
1088   04A7             
1089   04A7             s_break1:  
1090   04A7 0A 64 65 62   .db "\ndebugger entry point.\n"
1090   04AB 75 67 67 65 
1090   04AF 72 20 65 6E 
1090   04B3 74 72 79 20 
1090   04B7 70 6F 69 6E 
1090   04BB 74 2E 0A 
1091   04BE 30 2E 20 73   .db "0. show registers\n"
1091   04C2 68 6F 77 20 
1091   04C6 72 65 67 69 
1091   04CA 73 74 65 72 
1091   04CE 73 0A 
1092   04D0 31 2E 20 73   .db "1. show 512b ram block\n"
1092   04D4 68 6F 77 20 
1092   04D8 35 31 32 62 
1092   04DC 20 72 61 6D 
1092   04E0 20 62 6C 6F 
1092   04E4 63 6B 0A 
1093   04E7 32 2E 20 63   .db "2. continue execution", 0
1093   04EB 6F 6E 74 69 
1093   04EF 6E 75 65 20 
1093   04F3 65 78 65 63 
1093   04F7 75 74 69 6F 
1093   04FB 6E 00 
1094   04FD             
1095   04FD             ; ------------------------------------------------------------------------------------------------------------------;
1096   04FD             ; divide by zero exception
1097   04FD             ; ------------------------------------------------------------------------------------------------------------------;
1098   04FD             trap_div_zero:
1099   04FD D7            push a
1100   04FE DA            push d
1101   04FF E1            pushf
1102   0500 3B 55 19      mov d, s_divzero
1103   0503 07 87 13      call _puts
1104   0506 EE            popf
1105   0507 E7            pop d
1106   0508 E4            pop a
1107   0509 06            sysret ; enable interrupts
1108   050A             
1109   050A             ; ------------------------------------------------------------------------------------------------------------------;
1110   050A             ; undefined opcode exception
1111   050A             ; ------------------------------------------------------------------------------------------------------------------;
1112   050A             trap_undef_opcode:
1113   050A 06            sysret
1114   050B             
1115   050B             ; ------------------------------------------------------------------------------------------------------------------;
1116   050B             ; real-time clock services syscall
1117   050B             ; rtc i/o bank = ffa0 to ffaf
1118   050B             ; ffa0 to ffa7 is scratch ram
1119   050B             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
1120   050B             ; al = 0..6 -> get
1121   050B             ; al = 7..d -> set
1122   050B             ; ------------------------------------------------------------------------------------------------------------------;
1123   050B             syscall_rtc:
1124   050B DB            push al
1125   050C DA            push d
1126   050D B9 06         cmp al, 6
1127   050F D1 24 05      jgu syscall_rtc_set
1128   0512             syscall_rtc_get:
1129   0512 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
1130   0514 22 FF         mov ah, $ff    
1131   0516 3C            mov d, a                ; get to ffa9 + offset
1132   0517 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
1133   051B 1E            mov al, [d]             ; get data
1134   051C F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
1135   0520 23            mov ah, al
1136   0521 E7            pop d
1137   0522 E8            pop al
1138   0523 06            sysret
1139   0524             syscall_rtc_set:
1140   0524 DD            push bl
1141   0525 99            mov bl, ah              ; set data aside
1142   0526 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
1143   0528 22 FF         mov ah, $ff    
1144   052A 3C            mov d, a                ; get to ffa9 + offset
1145   052B 1B            mov al, bl              ; get data back
1146   052C F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
1147   0530 3E            mov [d], al             ; set data
1148   0531 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
1149   0535 EA            pop bl
1150   0536 E7            pop d
1151   0537 E8            pop al
1152   0538 06            sysret
1153   0539             
1154   0539             datetime_serv_tbl:
1155   0539 41 05         .dw print_date
1156   053B B5 05         .dw set_date
1157   053D             syscall_datetime:
1158   053D FD 0A 39 05   jmp [datetime_serv_tbl + al]      
1159   0541             print_date:
1160   0541 10 00 0D      mov a, $0d00           ; print carriage return char
1161   0544 19 03         mov al, 3
1162   0546 05 01         syscall sys_rtc        ; get week
1163   0548 1A            mov al, ah
1164   0549 22 00         mov ah, 0
1165   054B FD 9D 02      shl a, 2          
1166   054E 3B DF 19      mov d, s_week
1167   0551 59            add d, a
1168   0552 07 87 13      call _puts
1169   0555 10 00 20      mov a, $2000
1170   0558 05 03         syscall sys_io         ; display ' '
1171   055A 19 04         mov al, 4
1172   055C 05 01         syscall sys_rtc        ; get day
1173   055E 99            mov bl, ah
1174   055F 07 27 14      call print_u8x
1175   0562 10 00 20      mov a, $2000
1176   0565 05 03         syscall sys_io         ; display ' '
1177   0567             ; there is a problem with the month displaying
1178   0567             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
1179   0567             ; even though it is to be understood as bcd.
1180   0567             ; when retrieving the value and adding the string table address offset the value will go overboard!  
1181   0567 19 05         mov al, 05
1182   0569 05 01         syscall sys_rtc        ; get month
1183   056B 1A            mov al, ah
1184   056C 22 00         mov ah, 0
1185   056E FD 9D 02      shl a, 2          
1186   0571 3B AB 19      mov d, s_months
1187   0574 59            add d, a
1188   0575 07 87 13      call _puts
1189   0578 10 00 20      mov a, $2000
1190   057B 05 03         syscall sys_io         ; display ' '
1191   057D 2E 20         mov bl, $20
1192   057F 07 27 14      call print_u8x         ; print 20 for year prefix
1193   0582 19 06         mov al, 06
1194   0584 05 01         syscall sys_rtc        ; get year
1195   0586 99            mov bl, ah
1196   0587 07 27 14      call print_u8x
1197   058A 10 00 20      mov a, $2000  
1198   058D 05 03         syscall sys_io         ; display ' '
1199   058F 19 02         mov al, 2
1200   0591 05 01         syscall sys_rtc        ; get hours
1201   0593 99            mov bl, ah
1202   0594 07 27 14      call print_u8x
1203   0597 10 00 3A      mov a, $3a00    
1204   059A 05 03         syscall sys_io         ; display ':'
1205   059C 19 01         mov al, 01
1206   059E 05 01         syscall sys_rtc        ; get minutes
1207   05A0 99            mov bl, ah
1208   05A1 07 27 14      call print_u8x
1209   05A4 10 00 3A      mov a, $3a00  
1210   05A7 05 03         syscall sys_io         ; display ':'
1211   05A9 19 00         mov al, 0
1212   05AB 05 01         syscall sys_rtc        ; get seconds
1213   05AD 99            mov bl, ah
1214   05AE 07 27 14      call print_u8x
1215   05B1 07 34 13      call printnl
1216   05B4 06            sysret
1217   05B5             set_date:
1218   05B5 3B 70 19      mov d, s_set_year
1219   05B8 07 87 13      call _puts
1220   05BB 07 72 14      call scan_u8x          ; read integer into a
1221   05BE FD 9D 08      shl a, 8               ; only al used, move to ah
1222   05C1 19 0D         mov al, 0dh            ; set rtc year
1223   05C3 05 01         syscall sys_rtc        ; set rtc
1224   05C5 3B 77 19      mov d, s_set_month
1225   05C8 07 87 13      call _puts
1226   05CB 07 72 14      call scan_u8x          ; read integer into a
1227   05CE FD 9D 08      shl a, 8               ; only al used, move to ah
1228   05D1 19 0C         mov al, 0ch            ; set rtc month
1229   05D3 05 01         syscall sys_rtc        ; set rtc
1230   05D5 3B 7F 19      mov d, s_set_day
1231   05D8 07 87 13      call _puts
1232   05DB 07 72 14      call scan_u8x          ; read integer into a
1233   05DE FD 9D 08      shl a, 8               ; only al used, move to ah
1234   05E1 19 0B         mov al, 0bh            ; set rtc month
1235   05E3 05 01         syscall sys_rtc        ; set rtc
1236   05E5 3B 85 19      mov d, s_set_week
1237   05E8 07 87 13      call _puts
1238   05EB 07 72 14      call scan_u8x          ; read integer into a
1239   05EE FD 9D 08      shl a, 8               ; only al used, move to ah
1240   05F1 19 0A         mov al, 0ah            ; set rtc month
1241   05F3 05 01         syscall sys_rtc        ; set rtc
1242   05F5 3B 8F 19      mov d, s_set_hours
1243   05F8 07 87 13      call _puts
1244   05FB 07 72 14      call scan_u8x          ; read integer into a
1245   05FE FD 9D 08      shl a, 8               ; only al used, move to ah
1246   0601 19 09         mov al, 09h            ; set rtc month
1247   0603 05 01         syscall sys_rtc        ; set rtc
1248   0605 3B 97 19      mov d, s_set_minutes
1249   0608 07 87 13      call _puts
1250   060B 07 72 14      call scan_u8x          ; read integer into a
1251   060E FD 9D 08      shl a, 8               ; only al used, move to ah
1252   0611 19 08         mov al, 08h            ; set rtc month
1253   0613 05 01         syscall sys_rtc        ; set rtc
1254   0615 3B A1 19      mov d, s_set_seconds
1255   0618 07 87 13      call _puts
1256   061B 07 72 14      call scan_u8x          ; read integer into a
1257   061E FD 9D 08      shl a, 8               ; only al used, move to ah
1258   0621 19 07         mov al, 07h            ; set rtc month
1259   0623 05 01         syscall sys_rtc        ; set rtc
1260   0625 06            sysret
1261   0626             
1262   0626             ; ------------------------------------------------------------------------------------------------------------------;
1263   0626             ; ide services syscall
1264   0626             ; al = option
1265   0626             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1266   0626             ; ide read/write sector
1267   0626             ; 512 bytes
1268   0626             ; user buffer pointer in d
1269   0626             ; ah = number of sectors
1270   0626             ; cb = lba bytes 3..0
1271   0626             ; ------------------------------------------------------------------------------------------------------------------;
1272   0626             ide_serv_tbl:
1273   0626 32 06         .dw ide_reset
1274   0628 46 06         .dw ide_sleep
1275   062A 55 06         .dw ide_read_sect_wrapper
1276   062C 59 06         .dw ide_write_sect_wrapper
1277   062E             syscall_ide:
1278   062E FD 0A 26 06   jmp [ide_serv_tbl + al]    
1279   0632             
1280   0632             ide_reset:      
1281   0632 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1282   0636 07 DF 06      call ide_wait                   ; wait for ide ready             
1283   0639 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1284   063D F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1285   0641 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1286   0645 06            sysret
1287   0646             ide_sleep:
1288   0646 07 DF 06      call ide_wait                   ; wait for ide ready             
1289   0649 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1290   064D F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1291   0651 07 DF 06      call ide_wait                   ; wait for ide ready
1292   0654 06            sysret
1293   0655             ide_read_sect_wrapper:
1294   0655 07 5D 06      call ide_read_sect
1295   0658 06            sysret
1296   0659             ide_write_sect_wrapper:
1297   0659 07 83 06      call ide_write_sect
1298   065C 06            sysret
1299   065D             ide_read_sect:
1300   065D 1A            mov al, ah
1301   065E 24            mov ah, bl
1302   065F 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1303   0662 1C            mov al, bh
1304   0663 3D D4 FF      mov [_ide_r4], al
1305   0666 12            mov a, c
1306   0667 3D D5 FF      mov [_ide_r5], al
1307   066A 1A            mov al, ah
1308   066B 87 0F         and al, %00001111
1309   066D 8B E0         or al, %11100000                ; mode lba, master
1310   066F 3D D6 FF      mov [_ide_r6], al
1311   0672             ide_read_sect_wait:
1312   0672 1D D7 FF      mov al, [_ide_r7]  
1313   0675 87 80         and al, $80                     ; busy flag
1314   0677 C7 72 06      jnz ide_read_sect_wait
1315   067A 19 20         mov al, $20
1316   067C 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1317   067F 07 A9 06      call ide_read  
1318   0682 09            ret
1319   0683             ide_write_sect:
1320   0683 1A            mov al, ah
1321   0684 24            mov ah, bl
1322   0685 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1323   0688 1C            mov al, bh
1324   0689 3D D4 FF      mov [_ide_r4], al
1325   068C 12            mov a, c
1326   068D 3D D5 FF      mov [_ide_r5], al
1327   0690 1A            mov al, ah
1328   0691 87 0F         and al, %00001111
1329   0693 8B E0         or al, %11100000                ; mode lba, master
1330   0695 3D D6 FF      mov [_ide_r6], al
1331   0698             ide_write_sect_wait:
1332   0698 1D D7 FF      mov al, [_ide_r7]  
1333   069B 87 80         and al, $80                     ; busy flag
1334   069D C7 98 06      jnz ide_write_sect_wait
1335   06A0 19 30         mov al, $30
1336   06A2 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1337   06A5 07 C4 06      call ide_write      
1338   06A8 09            ret
1339   06A9             
1340   06A9             ;----------------------------------------------------------------------------------------------------;
1341   06A9             ; read ide data
1342   06A9             ; pointer in d
1343   06A9             ;----------------------------------------------------------------------------------------------------;
1344   06A9             ide_read:
1345   06A9 DA            push d
1346   06AA             ide_read_loop:
1347   06AA 1D D7 FF      mov al, [_ide_r7]  
1348   06AD 87 80         and al, 80h                     ; busy flag
1349   06AF C7 AA 06      jnz ide_read_loop               ; wait loop
1350   06B2 1D D7 FF      mov al, [_ide_r7]
1351   06B5 87 08         and al, %00001000               ; drq flag
1352   06B7 C6 C2 06      jz ide_read_end
1353   06BA 1D D0 FF      mov al, [_ide_r0]
1354   06BD 3E            mov [d], al
1355   06BE 79            inc d
1356   06BF 0A AA 06      jmp ide_read_loop
1357   06C2             ide_read_end:
1358   06C2 E7            pop d
1359   06C3 09            ret
1360   06C4             
1361   06C4             ;----------------------------------------------------------------------------------------------------;
1362   06C4             ; write ide data
1363   06C4             ; data pointer in d
1364   06C4             ;----------------------------------------------------------------------------------------------------;
1365   06C4             ide_write:
1366   06C4 DA            push d
1367   06C5             ide_write_loop:
1368   06C5 1D D7 FF      mov al, [_ide_r7]  
1369   06C8 87 80         and al, 80h             ; busy flag
1370   06CA C7 C5 06      jnz ide_write_loop      ; wait loop
1371   06CD 1D D7 FF      mov al, [_ide_r7]
1372   06D0 87 08         and al, %00001000       ; drq flag
1373   06D2 C6 DD 06      jz ide_write_end
1374   06D5 1E            mov al, [d]
1375   06D6 3D D0 FF      mov [_ide_r0], al
1376   06D9 79            inc d 
1377   06DA 0A C5 06      jmp ide_write_loop
1378   06DD             ide_write_end:
1379   06DD E7            pop d
1380   06DE 09            ret
1381   06DF             
1382   06DF             ;----------------------------------------------------------------------------------------------------;
1383   06DF             ; wait for ide to be ready
1384   06DF             ;----------------------------------------------------------------------------------------------------;
1385   06DF             ide_wait:
1386   06DF 1D D7 FF      mov al, [_ide_r7]  
1387   06E2 87 80         and al, 80h        ; busy flag
1388   06E4 C7 DF 06      jnz ide_wait
1389   06E7 09            ret
1390   06E8             
1391   06E8             ;----------------------------------------------------------------------------------------------------;
1392   06E8             ; io syscall
1393   06E8             ;----------------------------------------------------------------------------------------------------;
1394   06E8             ; baud  divisor
1395   06E8             ; 50    2304
1396   06E8             ; 110   1047
1397   06E8             ; 300    384
1398   06E8             ; 600    192
1399   06E8             ; 1200    96
1400   06E8             ; 9600    12
1401   06E8             ; 19200    6
1402   06E8             ; 38400    3
1403   06E8             syscall_io_jmp:
1404   06E8 1B 07         .dw syscall_io_putchar
1405   06EA 28 07         .dw syscall_io_getch
1406   06EC F2 06         .dw syscall_io_uart_setup
1407   06EE             syscall_io:
1408   06EE FD 0A E8 06   jmp [syscall_io_jmp + al]
1409   06F2             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1410   06F2             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1411   06F2             ; buffer, the transmitter holding register, or the interrupt enable register.
1412   06F2             syscall_io_uart_setup:
1413   06F2 1D B2 18      mov al, [sys_uart0_lcr]
1414   06F5 8B 80         or al, $80                ; set dlab access bit
1415   06F7 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1416   06FA 1D B5 18      mov al, [sys_uart0_div0]
1417   06FD 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1418   0700 1D B6 18      mov al, [sys_uart0_div1]
1419   0703 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1420   0706             
1421   0706 1D B2 18      mov al, [sys_uart0_lcr]
1422   0709 87 7F         and al, $7f               ; clear dlab access bit 
1423   070B 3D 83 FF      mov [_uart0_lcr], al
1424   070E 1D B3 18      mov al, [sys_uart0_inten]
1425   0711 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1426   0714 1D B4 18      mov al, [sys_uart0_fifoen]
1427   0717 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1428   071A 06            sysret
1429   071B             
1430   071B             ; char in ah
1431   071B             syscall_io_putchar:
1432   071B             syscall_io_putchar_l0:
1433   071B 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1434   071E 87 20         and al, $20
1435   0720 C6 1B 07      jz syscall_io_putchar_l0    
1436   0723 1A            mov al, ah
1437   0724 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1438   0727 06            sysret
1439   0728             
1440   0728             ; char in ah
1441   0728             ; al = sucess code
1442   0728             syscall_io_getch:
1443   0728 D8            push b
1444   0729 DA            push d
1445   072A FD 0C         sti
1446   072C             syscall_io_getch_l0:  
1447   072C 14 BF 18      mov a, [fifo_out]
1448   072F 29 BD 18      mov b, [fifo_in]
1449   0732 B0            cmp a, b
1450   0733 C6 2C 07      je syscall_io_getch_l0
1451   0736 3C            mov d, a
1452   0737 77            inc a
1453   0738 AF 1E 30      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
1454   073B C7 41 07      jne syscall_io_getch_cont
1455   073E 10 1E 20      mov a, fifo  
1456   0741             syscall_io_getch_cont:  
1457   0741 42 BF 18      mov [fifo_out], a             ; update fifo pointer
1458   0744 1E            mov al, [d]                   ; get char
1459   0745 23            mov ah, al
1460   0746 1D B1 18      mov al, [sys_echo_on]
1461   0749 B9 01         cmp al, 1
1462   074B C7 5A 07      jne syscall_io_getch_noecho 
1463   074E             ; here we just echo the char back to the console
1464   074E             syscall_io_getch_echo_l0:
1465   074E 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1466   0751 87 20         and al, $20                 ; isolate transmitter empty
1467   0753 C6 4E 07      jz syscall_io_getch_echo_l0
1468   0756 1A            mov al, ah
1469   0757 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1470   075A             syscall_io_getch_noecho:
1471   075A 19 01         mov al, 1                    ; al = 1 means a char successfully received
1472   075C E7            pop d
1473   075D E5            pop b
1474   075E 06            sysret
1475   075F             
1476   075F             ;------------------------------------------------------------------------------------------------------;
1477   075F             ; file system data
1478   075F             ;------------------------------------------------------------------------------------------------------;
1479   075F             ; infor for : ide services interrupt
1480   075F             ; ide read/write 512-byte sector
1481   075F             ; al = option
1482   075F             ; user buffer pointer in d
1483   075F             ; ah = number of sectors
1484   075F             ; cb = lba bytes 3..0  
1485   075F             ;------------------------------------------------------------------------------------------------------;
1486   075F             ; file system data structure
1487   075F             ;------------------------------------------------------------------------------------------------------;
1488   075F             ; for a directory we have the header first, followed by metadata
1489   075F             ; header 1 sector (512 bytes)
1490   075F             ; metadata 1 sector (512 bytes)
1491   075F             ; header entries:
1492   075F             ; filename (64)
1493   075F             ; parent dir lba (2) -  to be used for faster backwards navigation...
1494   075F             ;
1495   075F             ; metadata entries:
1496   075F             ; filename (24)
1497   075F             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1498   075F             ; lba (2)
1499   075F             ; size (2)
1500   075F             ; day (1)
1501   075F             ; month (1)
1502   075F             ; year (1)
1503   075F             ; packet size = 32 bytes
1504   075F             ;
1505   075F             ; first directory on disk is the root directory '/'
1506   075F             file_system_jmptbl:
1507   075F CA 07         .dw fs_mkfs                   ; 0
1508   0761 00 00         .dw 0                         ; 1
1509   0763 2C 08         .dw fs_mkdir                  ; 2
1510   0765 A5 0B         .dw fs_cd                     ; 3
1511   0767 AC 0B         .dw fs_ls                     ; 4
1512   0769 97 0C         .dw fs_mktxt                  ; 5
1513   076B 62 0D         .dw fs_mkbin                  ; 6
1514   076D 29 0E         .dw fs_pwd                    ; 7
1515   076F 46 0E         .dw fs_cat                    ; 8
1516   0771 A2 0E         .dw fs_rmdir                  ; 9
1517   0773 FE 0E         .dw fs_rm                     ; 10
1518   0775 00 00         .dw 0                         ; 11
1519   0777 00 00         .dw 0                         ; 12
1520   0779 00 00         .dw 0                         ; 13
1521   077B D2 07         .dw fs_chmod                  ; 14
1522   077D 66 0F         .dw fs_mv                     ; 15
1523   077F CB 07         .dw fs_cd_root                ; 16
1524   0781 A1 0B         .dw fs_get_curr_dirid         ; 17
1525   0783 7D 09         .dw fs_dir_id_to_path         ; 18
1526   0785 E3 09         .dw fs_path_to_dir_id_user    ; 19
1527   0787 FD 0A         .dw fs_load_from_path_user    ; 20  
1528   0789 6D 0A         .dw fs_filepath_exists_user   ; 21
1529   078B             
1530   078B 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1530   078F 79 73 63 61 
1530   0793 6C 6C 5F 66 
1530   0797 69 6C 65 5F 
1530   079B 73 79 73 74 
1530   079F 65 6D 20 63 
1530   07A3 61 6C 6C 65 
1530   07A7 64 3A 20 00 
1531   07AB             syscall_file_system:
1532   07AB DD            push bl
1533   07AC 31 B0 18      mov bl, [sys_debug_mode]
1534   07AF               ; debug block
1535   07AF C1 00         cmp bl, 0
1536   07B1 EA            pop bl
1537   07B2 C6 C6 07      je syscall_filesystem_jmp
1538   07B5 DA            push d
1539   07B6 DD            push bl
1540   07B7 3B 8B 07      mov d, s_syscall_fs_dbg0
1541   07BA 07 87 13      call _puts
1542   07BD 2F            mov bl, al
1543   07BE 07 27 14      call print_u8x
1544   07C1 07 34 13      call printnl
1545   07C4 EA            pop bl
1546   07C5 E7            pop d
1547   07C6             syscall_filesystem_jmp:
1548   07C6 FD 0A 5F 07   jmp [file_system_jmptbl + al]
1549   07CA             
1550   07CA             fs_mkfs:  
1551   07CA 06            sysret  
1552   07CB               
1553   07CB             fs_cd_root:
1554   07CB 10 20 00      mov a, root_id
1555   07CE 42 C1 18      mov [current_dir_id], a      ; set current directory lba to root
1556   07D1 06            sysret  
1557   07D2             
1558   07D2             ; filename in d (userspace data)
1559   07D2             ; permission in bl
1560   07D2             fs_chmod:
1561   07D2 DD            push bl
1562   07D3 FD 4E         mov si, d
1563   07D5 FD 4F 1E 1E   mov di, user_data
1564   07D9 38 80 00      mov c, 128
1565   07DC 04            load                        ; load filename from user-space
1566   07DD 14 C1 18      mov a, [current_dir_id]
1567   07E0 77            inc a                       ; metadata sector
1568   07E1 27            mov b, a
1569   07E2 38 00 00      mov c, 0                    ; upper lba = 0
1570   07E5 22 01         mov ah, $01                  ; 1 sector
1571   07E7 3B 1E 32      mov d, transient_area
1572   07EA 07 5D 06      call ide_read_sect          ; read directory
1573   07ED FD 10         cla
1574   07EF 42 B9 18      mov [index], a              ; reset file counter
1575   07F2             fs_chmod_l1:
1576   07F2 FD 4E         mov si, d
1577   07F4 FD 4F 1E 1E   mov di, user_data
1578   07F8 07 CA 11      call _strcmp
1579   07FB C6 12 08      je fs_chmod_found_entry
1580   07FE 58 20 00      add d, 32
1581   0801 14 B9 18      mov a, [index]
1582   0804 77            inc a
1583   0805 42 B9 18      mov [index], a
1584   0808 AF 10 00      cmp a, fst_files_per_dir
1585   080B C7 F2 07      jne fs_chmod_l1
1586   080E EA            pop bl
1587   080F 0A 2B 08      jmp fs_chmod_not_found
1588   0812             fs_chmod_found_entry:  
1589   0812 FD 79         mov g, b                    ; save lba
1590   0814 EA            pop bl                      ; retrieve saved permission value
1591   0815 1F 18 00      mov al, [d + 24]            ; read file permissions
1592   0818 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1593   081A 8C            or al, bl                   ; set new permissions
1594   081B 3F 18 00      mov [d + 24], al            ; write new permissions
1595   081E 38 00 00      mov c, 0
1596   0821 3B 1E 32      mov d, transient_area
1597   0824 22 01         mov ah, $01                 ; disk write 1 sect
1598   0826 FD 27         mov b, g                    ; retrieve lba
1599   0828 07 83 06      call ide_write_sect         ; write sector
1600   082B             fs_chmod_not_found:
1601   082B 06            sysret
1602   082C             
1603   082C             ;------------------------------------------------------------------------------------------------------;
1604   082C             ; create new directory
1605   082C             ;------------------------------------------------------------------------------------------------------;
1606   082C             ; search list for null name entry. add new directory to list
1607   082C             fs_mkdir:
1608   082C FD 4E         mov si, d
1609   082E FD 4F 1E 1E   mov di, user_data
1610   0832 38 00 02      mov c, 512
1611   0835 04            load                        ; load data from user-space
1612   0836 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1613   0839                                           ; when checking for null name, since root has a null name)
1614   0839 38 00 00      mov c, 0                    ; upper lba = 0
1615   083C             fs_mkdir_l1:  
1616   083C 22 01         mov ah, $01                  ; 1 sector
1617   083E 3B 1E 32      mov d, transient_area
1618   0841 07 5D 06      call ide_read_sect          ; read sector
1619   0844 BD 00         cmp byte[d], 0              ; check for null
1620   0846 C6 4F 08      je fs_mkdir_found_null
1621   0849 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1622   084C 0A 3C 08      jmp fs_mkdir_l1
1623   084F             fs_mkdir_found_null:
1624   084F             ;create header file by grabbing dir name from parameter
1625   084F D8            push b                      ; save new directory's lba
1626   0850 38 40 00      mov c, 64
1627   0853 FD 4D 1E 1E   mov si, user_data
1628   0857 FD 4F 1E 32   mov di, transient_area
1629   085B FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1630   085D 14 C1 18      mov a, [current_dir_id]
1631   0860 42 5E 32      mov [transient_area + 64], a    ; store parent directory lba
1632   0863 19 00         mov al, 0
1633   0865 FD 4F 1E 34   mov di, transient_area + 512
1634   0869 38 00 02      mov c, 512
1635   086C FD F7         rep stosb                       ; clean buffer
1636   086E 38 00 00      mov c, 0                        ; reset lba(c) to 0
1637   0871             ; write directory entry sectors
1638   0871 3B 1E 32      mov d, transient_area
1639   0874 22 02         mov ah, $02                     ; disk write, 2 sectors
1640   0876 07 83 06      call ide_write_sect             ; write sector
1641   0879             ; now we need to add the new directory to the list, inside the current directory
1642   0879 14 C1 18      mov a, [current_dir_id]
1643   087C 53 01 00      add a, 1
1644   087F 27            mov b, a                        ; metadata sector
1645   0880 38 00 00      mov c, 0
1646   0883 FD 79         mov g, b                        ; save lba
1647   0885 3B 1E 32      mov d, transient_area
1648   0888 22 01         mov ah, $01                  ; 1 sector
1649   088A 07 5D 06      call ide_read_sect              ; read metadata sector
1650   088D             fs_mkdir_l2:
1651   088D BD 00         cmp byte[d], 0
1652   088F C6 98 08      je fs_mkdir_found_null2
1653   0892 58 20 00      add d, fst_entry_size
1654   0895 0A 8D 08      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1655   0898             fs_mkdir_found_null2:
1656   0898 FD 4D 1E 1E   mov si, user_data
1657   089C FD 50         mov di, d
1658   089E 07 DF 11      call _strcpy                    ; copy directory name
1659   08A1 58 18 00      add d, 24                       ; goto attributes
1660   08A4 19 0B         mov al, %00001011               ; directory, no execute, write, read
1661   08A6 3E            mov [d], al      
1662   08A7 79            inc d
1663   08A8 E5            pop b
1664   08A9 D8            push b                          ; push lba back
1665   08AA FD 43         mov [d], b                      ; save lba
1666   08AC             ; set file creation date  
1667   08AC 58 04 00      add d, 4
1668   08AF 19 04         mov al, 4
1669   08B1 05 01         syscall sys_rtc
1670   08B3 1A            mov al, ah
1671   08B4 3E            mov [d], al                     ; set day
1672   08B5 79            inc d
1673   08B6 19 05         mov al, 5
1674   08B8 05 01         syscall sys_rtc
1675   08BA 1A            mov al, ah
1676   08BB 3E            mov [d], al                     ; set month
1677   08BC 79            inc d
1678   08BD 19 06         mov al, 6
1679   08BF 05 01         syscall sys_rtc
1680   08C1 1A            mov al, ah
1681   08C2 3E            mov [d], al                     ; set year
1682   08C3             ; write sector into disk for new directory entry
1683   08C3 FD 27         mov b, g
1684   08C5 38 00 00      mov c, 0
1685   08C8 3B 1E 32      mov d, transient_area
1686   08CB 22 01         mov ah, $01                     ; disk write, 1 sector
1687   08CD 07 83 06      call ide_write_sect             ; write sector
1688   08D0             
1689   08D0             ; after adding the new directory's information to its parent directory's list
1690   08D0             ; we need to now enter the new directory, and to it add two new directories!
1691   08D0             ; which directories do we need to add ? '..' and '.' are the directories needed.
1692   08D0             ; importantly, note that these two new directories are only entries in the list
1693   08D0             ; and do not have actual physical entries in the disk as real directories.
1694   08D0             ; i.e. they only exist as list entries in the new directory created so that
1695   08D0             ; the new directory can reference its parent and itself.
1696   08D0             ; we need to add both '..' and '.'
1697   08D0             ; this first section is for '..' and on the section below we do the same for '.'
1698   08D0 E4            pop a                         ; retrieve the new directory's lba  
1699   08D1 D7            push a                        ; and save again
1700   08D2 53 01 00      add a, 1
1701   08D5 27            mov b, a                      ; metadata sector
1702   08D6 38 00 00      mov c, 0
1703   08D9 FD 79         mov g, b                      ; save lba
1704   08DB 3B 1E 32      mov d, transient_area
1705   08DE 22 01         mov ah, $01                  ; 1 sector
1706   08E0 07 5D 06      call ide_read_sect            ; read metadata sector
1707   08E3             fs_mkdir_l3:
1708   08E3 BD 00         cmp byte[d], 0
1709   08E5 C6 EE 08      je fs_mkdir_found_null3
1710   08E8 58 20 00      add d, fst_entry_size
1711   08EB 0A E3 08      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1712   08EE             fs_mkdir_found_null3:
1713   08EE FD 4D E0 18   mov si, s_parent_dir
1714   08F2 FD 50         mov di, d
1715   08F4 07 DF 11      call _strcpy                  ; copy directory name
1716   08F7 58 18 00      add d, 24                     ; goto attributes
1717   08FA 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1718   08FC 3E            mov [d], al      
1719   08FD 79            inc d
1720   08FE 29 C1 18      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1721   0901 FD 43         mov [d], b                    ; save lba
1722   0903             ; set file creation date  
1723   0903 58 04 00      add d, 4
1724   0906 19 04         mov al, 4
1725   0908 05 01         syscall sys_rtc
1726   090A 1A            mov al, ah
1727   090B 3E            mov [d], al                   ; set day
1728   090C 79            inc d
1729   090D 19 05         mov al, 5
1730   090F 05 01         syscall sys_rtc
1731   0911 1A            mov al, ah
1732   0912 3E            mov [d], al                   ; set month
1733   0913 79            inc d
1734   0914 19 06         mov al, 6
1735   0916 05 01         syscall sys_rtc
1736   0918 1A            mov al, ah
1737   0919 3E            mov [d], al                   ; set year
1738   091A             ; write sector into disk for new directory entry
1739   091A FD 27         mov b, g
1740   091C 38 00 00      mov c, 0
1741   091F 3B 1E 32      mov d, transient_area
1742   0922 22 01         mov ah, $01                   ; disk write, 1 sector
1743   0924 07 83 06      call ide_write_sect           ; write sector
1744   0927             ;;;;;;;;;;;;;
1745   0927             ; like we did above for '..', we need to now add the '.' directory to the list.
1746   0927             ;------------------------------------------------------------------------------------------------------;
1747   0927 E4            pop a                         ; retrieve the new directory's lba  
1748   0928 D7            push a
1749   0929 53 01 00      add a, 1
1750   092C 27            mov b, a                      ; metadata sector
1751   092D 38 00 00      mov c, 0
1752   0930 FD 79         mov g, b                      ; save lba
1753   0932 3B 1E 32      mov d, transient_area
1754   0935 22 01         mov ah, $01                  ; 1 sector
1755   0937 07 5D 06      call ide_read_sect            ; read metadata sector
1756   093A             fs_mkdir_l4:
1757   093A BD 00         cmp byte[d], 0
1758   093C C6 45 09      je fs_mkdir_found_null4
1759   093F 58 20 00      add d, fst_entry_size
1760   0942 0A 3A 09      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1761   0945             fs_mkdir_found_null4:
1762   0945 FD 4D E3 18   mov si, s_current_dir
1763   0949 FD 50         mov di, d
1764   094B 07 DF 11      call _strcpy                  ; copy directory name
1765   094E 58 18 00      add d, 24                     ; goto attributes
1766   0951 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1767   0953 3E            mov [d], al      
1768   0954 79            inc d
1769   0955 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1770   0956 FD 43         mov [d], b                    ; save lba
1771   0958             ; set file creation date  
1772   0958 58 04 00      add d, 4
1773   095B 19 04         mov al, 4
1774   095D 05 01         syscall sys_rtc
1775   095F 1A            mov al, ah
1776   0960 3E            mov [d], al                   ; set day
1777   0961 79            inc d
1778   0962 19 05         mov al, 5
1779   0964 05 01         syscall sys_rtc
1780   0966 1A            mov al, ah
1781   0967 3E            mov [d], al                   ; set month
1782   0968 79            inc d
1783   0969 19 06         mov al, 6
1784   096B 05 01         syscall sys_rtc
1785   096D 1A            mov al, ah
1786   096E 3E            mov [d], al                   ; set year
1787   096F             ; write sector into disk for new directory entry
1788   096F FD 27         mov b, g
1789   0971 38 00 00      mov c, 0
1790   0974 3B 1E 32      mov d, transient_area
1791   0977 22 01         mov ah, $01                   ; disk write, 1 sector
1792   0979 07 83 06      call ide_write_sect           ; write sector
1793   097C             fs_mkdir_end:
1794   097C 06            sysret
1795   097D             
1796   097D             ;------------------------------------------------------------------------------------------------------;
1797   097D             ; get path from a given directory dirid
1798   097D             ; pseudo code:
1799   097D             ;  fs_dir_id_to_path(int dirid, char *d){
1800   097D             ;    if(dirid == 0){
1801   097D             ;      reverse path in d;
1802   097D             ;      return;
1803   097D             ;    }
1804   097D             ;    else{
1805   097D             ;      copy directory name to end of d;
1806   097D             ;      add '/' to end of d;
1807   097D             ;      parentid = get parent directory id;
1808   097D             ;      fs_dir_id_to_path(parentid, d);
1809   097D             ;    }
1810   097D             ;  }
1811   097D             ; a = dirid
1812   097D             ; d = generated path string pointer
1813   097D             ;------------------------------------------------------------------------------------------------------;
1814   097D             ; sample path: /usr/bin
1815   097D             fs_dir_id_to_path:
1816   097D 3B 9E 1D      mov d, filename
1817   0980 19 00         mov al, 0
1818   0982 3E            mov [d], al                     ; initialize path string 
1819   0983 14 C1 18      mov a, [current_dir_id]
1820   0986 07 93 09      call fs_dir_id_to_path_e0
1821   0989 3B 9E 1D      mov d, filename
1822   098C 07 73 11      call _strrev
1823   098F 07 87 13      call _puts
1824   0992 06            sysret
1825   0993             fs_dir_id_to_path_e0:
1826   0993 07 B2 09      call get_dirname_from_dirid
1827   0996 FD 4D E5 18   mov si, s_fslash
1828   099A FD 50         mov di, d
1829   099C 07 ED 11      call _strcat                    ; add '/' to end of path
1830   099F AF 20 00      cmp a, root_id               ; check if we are at the root directory
1831   09A2 C6 B1 09      je fs_dir_id_to_path_root
1832   09A5 07 CF 09      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1833   09A8 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1834   09AB C6 B1 09      je fs_dir_id_to_path_root
1835   09AE 07 93 09      call fs_dir_id_to_path_e0     ; recursively call itself
1836   09B1             fs_dir_id_to_path_root:
1837   09B1 09            ret
1838   09B2             
1839   09B2             ;------------------------------------------------------------------------------------------------------;
1840   09B2             ; in_puts:
1841   09B2             ; a = directory id
1842   09B2             ; out_puts:
1843   09B2             ; d = pointer to directory name string
1844   09B2             ;------------------------------------------------------------------------------------------------------;
1845   09B2             get_dirname_from_dirid:
1846   09B2 D7            push a
1847   09B3 D8            push b
1848   09B4 DA            push d
1849   09B5 27            mov b, a
1850   09B6 38 00 00      mov c, 0                      ; upper lba = 0
1851   09B9 22 01         mov ah, $01                  ; 1 sector
1852   09BB 3B 1E 30      mov d, transient_area - 512
1853   09BE 07 5D 06      call ide_read_sect            ; read directory
1854   09C1 07 73 11      call _strrev                  ; reverse dir name before copying
1855   09C4 FD 4E         mov si, d
1856   09C6 E7            pop d                         ; destination address = d value pushed at beginning
1857   09C7 FD 50         mov di, d
1858   09C9 07 ED 11      call _strcat                  ; copy filename to d
1859   09CC E5            pop b
1860   09CD E4            pop a
1861   09CE 09            ret
1862   09CF             
1863   09CF             ;------------------------------------------------------------------------------------------------------;
1864   09CF             ; in_puts:
1865   09CF             ; a = directory id
1866   09CF             ; out_puts:
1867   09CF             ; a = parent directory id
1868   09CF             ;------------------------------------------------------------------------------------------------------;
1869   09CF             get_parentid_from_dirid:
1870   09CF D8            push b
1871   09D0 DA            push d
1872   09D1 27            mov b, a
1873   09D2 38 00 00      mov c, 0                      ; upper lba = 0
1874   09D5 22 01         mov ah, $01                  ; 1 sector
1875   09D7 3B 1E 30      mov d, transient_area - 512
1876   09DA 07 5D 06      call ide_read_sect            ; read directory
1877   09DD 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1878   09E0 E7            pop d
1879   09E1 E5            pop b
1880   09E2 09            ret
1881   09E3             
1882   09E3             ;------------------------------------------------------------------------------------------------------;
1883   09E3             ; get dirid from a given path string
1884   09E3             ; in_puts:
1885   09E3             ; d = path pointer 
1886   09E3             ; out_puts:
1887   09E3             ; a = dirid
1888   09E3             ; if dir non existent, a = ffff (fail code)
1889   09E3             ; /usr/local/bin    - absolute
1890   09E3             ; local/bin/games    - relative
1891   09E3             ;------------------------------------------------------------------------------------------------------;
1892   09E3             fs_path_to_dir_id_user:
1893   09E3 FD 4E         mov si, d
1894   09E5 FD 4F 1E 1E   mov di, user_data
1895   09E9 38 00 02      mov c, 512
1896   09EC 04            load
1897   09ED 07 F1 09      call get_dirid_from_path
1898   09F0 06            sysret
1899   09F1             get_dirid_from_path:
1900   09F1 26 1E 1E      mov b, user_data
1901   09F4 FD 42 AC 17   mov [prog], b                  ; token pointer set to path string
1902   09F8 07 0D 16      call get_token
1903   09FB 31 AF 17      mov bl, [tok]
1904   09FE C1 01         cmp bl, tok_fslash
1905   0A00 C6 0C 0A      je get_dirid_from_path_abs 
1906   0A03 14 C1 18      mov a, [current_dir_id]
1907   0A06 07 93 17      call _putback
1908   0A09 0A 0F 0A      jmp get_dirid_from_path_e0
1909   0A0C             get_dirid_from_path_abs:
1910   0A0C 10 20 00      mov a, root_id
1911   0A0F             get_dirid_from_path_e0:
1912   0A0F 07 0D 16      call get_token
1913   0A12 31 AE 17      mov bl, [toktyp]
1914   0A15 C1 00         cmp bl, toktyp_identifier
1915   0A17 C7 68 0A      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1916   0A1A             
1917   0A1A FD 4D B0 17   mov si, tokstr
1918   0A1E FD 4F 9E 1D   mov di, filename
1919   0A22 07 DF 11      call _strcpy        
1920   0A25 77            inc a                         ; metadata sector
1921   0A26 27            mov b, a
1922   0A27 38 00 00      mov c, 0                      ; upper lba = 0
1923   0A2A 22 01         mov ah, $01                  ; 1 sector
1924   0A2C 3B 1E 32      mov d, transient_area
1925   0A2F 07 5D 06      call ide_read_sect            ; read directory
1926   0A32 FD 10         cla
1927   0A34 42 B9 18      mov [index], a
1928   0A37             get_dirid_from_path_l1:
1929   0A37 FD 4E         mov si, d
1930   0A39 FD 4F 9E 1D   mov di, filename
1931   0A3D 07 CA 11      call _strcmp
1932   0A40 C6 56 0A      je get_dirid_from_path_name_equal  
1933   0A43 58 20 00      add d, 32
1934   0A46 14 B9 18      mov a, [index]
1935   0A49 77            inc a
1936   0A4A 42 B9 18      mov [index], a
1937   0A4D AF 10 00      cmp a, fst_files_per_dir
1938   0A50 C6 69 0A      je get_dirid_from_path_fail
1939   0A53 0A 37 0A      jmp get_dirid_from_path_l1
1940   0A56             get_dirid_from_path_name_equal:
1941   0A56 58 19 00      add d, 25           
1942   0A59 15            mov a, [d]                    ; set result register a = dirid
1943   0A5A 07 0D 16      call get_token
1944   0A5D 31 AF 17      mov bl, [tok]
1945   0A60 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1946   0A62 C6 0F 0A      je get_dirid_from_path_e0
1947   0A65 07 93 17      call _putback
1948   0A68             get_dirid_from_path_end:
1949   0A68 09            ret
1950   0A69             get_dirid_from_path_fail:
1951   0A69 10 FF FF      mov a, $ffff
1952   0A6C 09            ret
1953   0A6D             
1954   0A6D             
1955   0A6D             ;------------------------------------------------------------------------------------------------------;
1956   0A6D             ; check if file exists by a given path string
1957   0A6D             ; in_puts:
1958   0A6D             ; d = path pointer 
1959   0A6D             ; outputs:
1960   0A6D             ; a = success code, if file exists gives lba, else, give 0
1961   0A6D             ; /usr/local/bin/ed
1962   0A6D             ;------------------------------------------------------------------------------------------------------;
1963   0A6D             fs_filepath_exists_user:
1964   0A6D FD 4E         mov si, d
1965   0A6F FD 4F 1E 1E   mov di, user_data
1966   0A73 38 00 02      mov c, 512
1967   0A76 04            load
1968   0A77 07 7B 0A      call file_exists_by_path
1969   0A7A 06            sysret
1970   0A7B             file_exists_by_path:
1971   0A7B 26 1E 1E      mov b, user_data
1972   0A7E FD 42 AC 17   mov [prog], b                   ; token pointer set to path string
1973   0A82 07 0D 16      call get_token
1974   0A85 31 AF 17      mov bl, [tok]
1975   0A88 C1 01         cmp bl, tok_fslash
1976   0A8A C6 96 0A      je  file_exists_by_path_abs
1977   0A8D 14 C1 18      mov a, [current_dir_id]
1978   0A90 07 93 17      call _putback
1979   0A93 0A 99 0A      jmp file_exists_by_path_e0
1980   0A96             file_exists_by_path_abs:
1981   0A96 10 20 00      mov a, root_id
1982   0A99             file_exists_by_path_e0:
1983   0A99 07 0D 16      call get_token
1984   0A9C 31 AE 17      mov bl, [toktyp]
1985   0A9F C1 00         cmp bl, toktyp_identifier
1986   0AA1 C7 F9 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1987   0AA4 FD 4D B0 17   mov si, tokstr
1988   0AA8 FD 4F 9E 1D   mov di, filename
1989   0AAC 07 DF 11      call _strcpy        
1990   0AAF 77            inc a                           ; metadata sector
1991   0AB0 27            mov b, a
1992   0AB1 38 00 00      mov c, 0                        ; upper lba = 0
1993   0AB4 22 01         mov ah, $01                  ; 1 sector
1994   0AB6 3B 1E 32      mov d, transient_area
1995   0AB9 07 5D 06      call ide_read_sect              ; read directory
1996   0ABC FD 10         cla
1997   0ABE 42 B9 18      mov [index], a
1998   0AC1             file_exists_by_path_l1:
1999   0AC1 FD 4E         mov si, d
2000   0AC3 FD 4F 9E 1D   mov di, filename
2001   0AC7 07 CA 11      call _strcmp
2002   0ACA C6 E0 0A      je   file_exists_by_path_name_equal
2003   0ACD 58 20 00      add d, 32
2004   0AD0 14 B9 18      mov a, [index]
2005   0AD3 77            inc a
2006   0AD4 42 B9 18      mov [index], a
2007   0AD7 AF 10 00      cmp a, fst_files_per_dir
2008   0ADA C6 F9 0A      je file_exists_by_path_end
2009   0ADD 0A C1 0A      jmp file_exists_by_path_l1
2010   0AE0             file_exists_by_path_name_equal:
2011   0AE0 33 18 00      mov bl, [d + 24]
2012   0AE3 FD 87 38      and bl, %00111000               ; directory flag
2013   0AE6 C1 08         cmp bl, %00001000               ; is dir?
2014   0AE8 C6 EF 0A      je file_exists_by_path_isdir;
2015   0AEB             ; entry is a file
2016   0AEB 16 19 00      mov a, [d + 25]                 ; get and return lba of file
2017   0AEE 09            ret
2018   0AEF             file_exists_by_path_isdir:
2019   0AEF 58 19 00      add d, 25           
2020   0AF2 15            mov a, [d]                      ; set result register a = dirid
2021   0AF3 07 0D 16      call get_token
2022   0AF6 0A 99 0A      jmp file_exists_by_path_e0
2023   0AF9             file_exists_by_path_end:
2024   0AF9 10 00 00      mov a, 0                        ; return 0 because file was not found
2025   0AFC 09            ret
2026   0AFD             
2027   0AFD             ;------------------------------------------------------------------------------------------------------;
2028   0AFD             ; load file data from a given path string
2029   0AFD             ; inputs:
2030   0AFD             ; d = path pointer 
2031   0AFD             ; di = userspace program data destination
2032   0AFD             ; /usr/local/bin/ed
2033   0AFD             ; ./ed
2034   0AFD             ;------------------------------------------------------------------------------------------------------;
2035   0AFD             fs_load_from_path_user:
2036   0AFD E3            push di
2037   0AFE FD 4E         mov si, d
2038   0B00 FD 4F 1E 1E   mov di, user_data
2039   0B04 38 00 02      mov c, 512
2040   0B07 04            load
2041   0B08 07 15 0B      call loadfile_from_path
2042   0B0B F0            pop di
2043   0B0C FD 4D 1E 32   mov si, transient_area
2044   0B10 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
2045   0B13 03            store
2046   0B14 06            sysret
2047   0B15             loadfile_from_path:
2048   0B15 26 1E 1E      mov b, user_data
2049   0B18 FD 42 AC 17   mov [prog], b                 ; token pointer set to path string
2050   0B1C 07 0D 16      call get_token
2051   0B1F 31 AF 17      mov bl, [tok]
2052   0B22 C1 01         cmp bl, tok_fslash
2053   0B24 C6 30 0B      je loadfile_from_path_abs 
2054   0B27 14 C1 18      mov a, [current_dir_id]
2055   0B2A 07 93 17      call _putback
2056   0B2D 0A 33 0B      jmp loadfile_from_path_e0
2057   0B30             loadfile_from_path_abs:
2058   0B30 10 20 00      mov a, root_id
2059   0B33             loadfile_from_path_e0:
2060   0B33 07 0D 16      call get_token
2061   0B36 31 AE 17      mov bl, [toktyp]
2062   0B39 C1 00         cmp bl, toktyp_identifier
2063   0B3B C7 A0 0B      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2064   0B3E FD 4D B0 17   mov si, tokstr
2065   0B42 FD 4F 9E 1D   mov di, filename
2066   0B46 07 DF 11      call _strcpy        
2067   0B49 77            inc a                         ; metadata sector
2068   0B4A 27            mov b, a
2069   0B4B 38 00 00      mov c, 0                      ; upper lba = 0
2070   0B4E 22 01         mov ah, $01                  ; 1 sector
2071   0B50 3B 1E 32      mov d, transient_area
2072   0B53 07 5D 06      call ide_read_sect            ; read directory
2073   0B56 FD 10         cla
2074   0B58 42 B9 18      mov [index], a
2075   0B5B             loadfile_from_path_l1:
2076   0B5B FD 4E         mov si, d
2077   0B5D FD 4F 9E 1D   mov di, filename
2078   0B61 07 CA 11      call _strcmp
2079   0B64 C6 7A 0B      je loadfile_from_path_name_equal  
2080   0B67 58 20 00      add d, 32
2081   0B6A 14 B9 18      mov a, [index]
2082   0B6D 77            inc a
2083   0B6E 42 B9 18      mov [index], a
2084   0B71 AF 10 00      cmp a, fst_files_per_dir
2085   0B74 C6 A0 0B      je loadfile_from_path_end
2086   0B77 0A 5B 0B      jmp loadfile_from_path_l1
2087   0B7A             loadfile_from_path_name_equal:
2088   0B7A 33 18 00      mov bl, [d + 24]
2089   0B7D FD 87 38      and bl, %00111000             ; directory flag
2090   0B80 C1 08         cmp bl, %00001000             ; is dir?
2091   0B82 C6 96 0B      je loadfile_isdirectory  
2092   0B85             ; entry is a file
2093   0B85 2B 19 00      mov b, [d + 25]               ; get lba
2094   0B88 FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
2095   0B8A 3B 1E 32      mov d, transient_area
2096   0B8D 38 00 00      mov c, 0
2097   0B90 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
2098   0B92 07 5D 06      call ide_read_sect            ; read sector
2099   0B95 09            ret
2100   0B96             loadfile_isdirectory:
2101   0B96 58 19 00      add d, 25           
2102   0B99 15            mov a, [d]                    ; set result register a = dirid
2103   0B9A 07 0D 16      call get_token
2104   0B9D 0A 33 0B      jmp loadfile_from_path_e0
2105   0BA0             loadfile_from_path_end:
2106   0BA0 09            ret
2107   0BA1             
2108   0BA1             ;------------------------------------------------------------------------------------------------------;
2109   0BA1             ; return the id of the current directory
2110   0BA1             ; id returned in b
2111   0BA1             ;------------------------------------------------------------------------------------------------------;
2112   0BA1             fs_get_curr_dirid:
2113   0BA1 29 C1 18      mov b, [current_dir_id]
2114   0BA4 06            sysret
2115   0BA5             
2116   0BA5             ;------------------------------------------------------------------------------------------------------;
2117   0BA5             ; cd
2118   0BA5             ;------------------------------------------------------------------------------------------------------;
2119   0BA5             ; new dirid in b
2120   0BA5             fs_cd:
2121   0BA5 FD 42 C1 18   mov [current_dir_id], b
2122   0BA9 06            sysret  
2123   0BAA             
2124   0BAA             ;------------------------------------------------------------------------------------------------------;
2125   0BAA             ; ls
2126   0BAA             ; dirid in b
2127   0BAA             ;------------------------------------------------------------------------------------------------------;
2128   0BAA 00 00       ls_count:       .dw 0
2129   0BAC             fs_ls:
2130   0BAC FD 77         inc b                        ; metadata sector
2131   0BAE 38 00 00      mov c, 0                     ; upper lba = 0
2132   0BB1 22 01         mov ah, $01                  ; 1 sector
2133   0BB3 3B 1E 32      mov d, transient_area
2134   0BB6 07 5D 06      call ide_read_sect           ; read directory
2135   0BB9 FD 10         cla
2136   0BBB 42 B9 18      mov [index], a               ; reset entry index
2137   0BBE 3D AA 0B      mov [ls_count], al           ; reset item count
2138   0BC1             fs_ls_l1:
2139   0BC1 BD 00         cmp byte [d], 0              ; check for null
2140   0BC3 C6 5A 0C      je fs_ls_next
2141   0BC6             fs_ls_non_null:
2142   0BC6 1D AA 0B      mov al, [ls_count]
2143   0BC9 7A            inc al
2144   0BCA 3D AA 0B      mov [ls_count], al           ; increment item count
2145   0BCD 1F 18 00      mov al, [d + 24]
2146   0BD0 87 38         and al, %00111000
2147   0BD2 FD A2 03      shr al, 3
2148   0BD5 22 00         mov ah, 0                    ; file type
2149   0BD7 B7 EC 18      mov a, [a + file_type]      
2150   0BDA 23            mov ah, al
2151   0BDB 07 5B 12      call _putchar
2152   0BDE 1F 18 00      mov al, [d + 24]
2153   0BE1 87 01         and al, %00000001
2154   0BE3 22 00         mov ah, 0
2155   0BE5 B7 E7 18      mov a, [a + file_attrib]     ; read
2156   0BE8 23            mov ah, al
2157   0BE9 07 5B 12      call _putchar
2158   0BEC 1F 18 00      mov al, [d + 24]
2159   0BEF 87 02         and al, %00000010
2160   0BF1 22 00         mov ah, 0
2161   0BF3 B7 E7 18      mov a, [a + file_attrib]     ; write
2162   0BF6 23            mov ah, al
2163   0BF7 07 5B 12      call _putchar
2164   0BFA 1F 18 00      mov al, [d + 24]
2165   0BFD 87 04         and al, %00000100
2166   0BFF 22 00         mov ah, 0
2167   0C01 B7 E7 18      mov a, [a + file_attrib]     ; execute
2168   0C04 23            mov ah, al
2169   0C05 07 5B 12      call _putchar
2170   0C08 22 20         mov ah, $20
2171   0C0A 07 5B 12      call _putchar  
2172   0C0D 2B 1B 00      mov b, [d + 27]
2173   0C10 07 E3 13      call print_u16x              ; filesize
2174   0C13 22 20         mov ah, $20
2175   0C15 07 5B 12      call _putchar  
2176   0C18 2B 19 00      mov b, [d + 25]
2177   0C1B 07 E3 13      call print_u16x              ; dirid / lba
2178   0C1E 22 20         mov ah, $20
2179   0C20 07 5B 12      call _putchar
2180   0C23             ; print date
2181   0C23 33 1D 00      mov bl, [d + 29]             ; day
2182   0C26 07 27 14      call print_u8x
2183   0C29 22 20         mov ah, $20
2184   0C2B 07 5B 12      call _putchar  
2185   0C2E 1F 1E 00      mov al, [d + 30]             ; month
2186   0C31 FD 9E 02      shl al, 2
2187   0C34 DA            push d
2188   0C35 3B AB 19      mov d, s_months
2189   0C38 22 00         mov ah, 0
2190   0C3A 59            add d, a
2191   0C3B 07 87 13      call _puts
2192   0C3E E7            pop d
2193   0C3F 22 20         mov ah, $20
2194   0C41 07 5B 12      call _putchar
2195   0C44 2E 20         mov bl, $20
2196   0C46 07 27 14      call print_u8x
2197   0C49 33 1F 00      mov bl, [d + 31]             ; year
2198   0C4C 07 27 14      call print_u8x  
2199   0C4F 22 20         mov ah, $20
2200   0C51 07 5B 12      call _putchar  
2201   0C54 07 87 13      call _puts                   ; print filename  
2202   0C57 07 34 13      call printnl
2203   0C5A             fs_ls_next:
2204   0C5A 14 B9 18      mov a, [index]
2205   0C5D 77            inc a
2206   0C5E 42 B9 18      mov [index], a
2207   0C61 AF 10 00      cmp a, fst_files_per_dir
2208   0C64 C6 6D 0C      je fs_ls_end
2209   0C67 58 20 00      add d, 32      
2210   0C6A 0A C1 0B      jmp fs_ls_l1  
2211   0C6D             fs_ls_end:
2212   0C6D 3B FC 18      mov d, s_ls_total
2213   0C70 07 87 13      call _puts
2214   0C73 1D AA 0B      mov al, [ls_count]
2215   0C76 07 39 14      call print_u8d
2216   0C79 07 34 13      call printnl
2217   0C7C 06            sysret
2218   0C7D             
2219   0C7D             ;------------------------------------------------------------------------------------------------------;
2220   0C7D             ; finds an empty data block
2221   0C7D             ; block lba returned in b
2222   0C7D             ;------------------------------------------------------------------------------------------------------;
2223   0C7D             fs_find_empty_block:
2224   0C7D 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2225   0C80 38 00 00      mov c, 0                ; upper lba = 0
2226   0C83             fs_find_empty_block_l1:  
2227   0C83 22 01         mov ah, $01                  ; 1 sector
2228   0C85 3B 1E 30      mov d, transient_area - 512
2229   0C88 07 5D 06      call ide_read_sect      ; read sector
2230   0C8B BD 00         cmp byte [d], 0
2231   0C8D C6 96 0C      je fs_find_empty_block_found_null
2232   0C90 55 20 00      add b, fs_sectors_per_file
2233   0C93 0A 83 0C      jmp fs_find_empty_block_l1
2234   0C96             fs_find_empty_block_found_null:
2235   0C96 09            ret
2236   0C97             
2237   0C97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2238   0C97             ;; create new textfile
2239   0C97             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2240   0C97             ; search for first null block
2241   0C97             fs_mktxt:
2242   0C97 FD 4E       	mov si, d
2243   0C99 FD 4F 1E 1E 	mov di, user_data
2244   0C9D 38 00 01    	mov c, 256
2245   0CA0 04          	load					; load data from user-space
2246   0CA1             	
2247   0CA1 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2248   0CA4 38 00 00    	mov c, 0						; reset lba to 0
2249   0CA7             fs_mktxt_l1:	
2250   0CA7 10 02 01    	mov a, $0102			; disk read
2251   0CAA 3B 1E 32    	mov d, transient_area
2252   0CAD 05 02       	syscall sys_ide ; read sector
2253   0CAF 1E          	mov al, [d]
2254   0CB0 B9 00       	cmp al, 0			; check for null
2255   0CB2 C6 BB 0C    	je fs_mktxt_found_null
2256   0CB5 55 20 00    	add b, fs_sectors_per_file
2257   0CB8 0A A7 0C    	jmp fs_mktxt_l1
2258   0CBB             fs_mktxt_found_null:
2259   0CBB D8          	push b				; save lba
2260   0CBC             ;create header file by grabbing file name from parameter	
2261   0CBC 3B DD 18    	mov d, s_dataentry
2262   0CBF 07 87 13    	call _puts
2263   0CC2 3B 1E 34    	mov d, transient_area + 512			; pointer to file contents
2264   0CC5 07 ED 12    	call _gettxt
2265   0CC8 07 BA 11    	call _strlen						; get length of file
2266   0CCB D9          	push c							; save length
2267   0CCC 19 01       	mov al, 1
2268   0CCE 3D 1E 32    	mov [transient_area], al					; mark sectors as used (not null)
2269   0CD1 10 00 00    	mov a, 0
2270   0CD4 42 B9 18    	mov [index], a
2271   0CD7 3B 1E 32    	mov d, transient_area
2272   0CDA 13          	mov a, d
2273   0CDB 42 BB 18    	mov [buffer_addr], a
2274   0CDE             fs_mktxt_l2:
2275   0CDE 38 00 00    	mov c, 0
2276   0CE1 10 03 01    	mov a, $0103			; disk write, 1 sector
2277   0CE4 05 02       	syscall sys_ide		; write sector
2278   0CE6 14 B9 18    	mov a, [index]
2279   0CE9 77          	inc a
2280   0CEA 42 B9 18    	mov [index], a
2281   0CED AF 20 00    	cmp a, fs_sectors_per_file
2282   0CF0 C6 02 0D    	je fs_mktxt_add_to_dir
2283   0CF3 FD 77       	inc b
2284   0CF5 14 BB 18    	mov a, [buffer_addr]
2285   0CF8 53 00 02    	add a, 512
2286   0CFB 42 BB 18    	mov [buffer_addr], a
2287   0CFE 3C          	mov d, a
2288   0CFF 0A DE 0C    	jmp fs_mktxt_l2
2289   0D02             ; now we add the file to the current directory!
2290   0D02             fs_mktxt_add_to_dir:	
2291   0D02 14 C1 18    	mov a, [current_dir_id]
2292   0D05 77          	inc a
2293   0D06 27          	mov b, a					; metadata sector
2294   0D07 38 00 00    	mov c, 0
2295   0D0A FD 79       	mov g, b					; save lba
2296   0D0C 3B 1E 32    	mov d, transient_area
2297   0D0F 10 02 01    	mov a, $0102			; disk read
2298   0D12 05 02       	syscall sys_ide		; read metadata sector
2299   0D14             fs_mktxt_add_to_dir_l2:
2300   0D14 1E          	mov al, [d]
2301   0D15 B9 00       	cmp al, 0
2302   0D17 C6 20 0D    	je fs_mktxt_add_to_dir_null
2303   0D1A 58 20 00    	add d, fst_entry_size
2304   0D1D 0A 14 0D    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2305   0D20             fs_mktxt_add_to_dir_null:
2306   0D20 FD 4D 1E 1E 	mov si, user_data
2307   0D24 FD 50       	mov di, d
2308   0D26 07 DF 11    	call _strcpy			; copy file name
2309   0D29 58 18 00    	add d, 24			; skip name
2310   0D2C 19 06       	mov al, %00000110		; no execute, write, read, not directory
2311   0D2E 3E          	mov [d], al			
2312   0D2F 58 03 00    	add d, 3
2313   0D32 E4          	pop a
2314   0D33 43          	mov [d], a
2315   0D34 63 02 00    	sub d, 2
2316   0D37 E5          	pop b				; get file lba
2317   0D38 FD 43       	mov [d], b			; save lba	
2318   0D3A             	
2319   0D3A             	; set file creation date	
2320   0D3A 58 04 00    	add d, 4
2321   0D3D 19 04       	mov al, 4
2322   0D3F 05 01       	syscall sys_rtc
2323   0D41 1A          	mov al, ah
2324   0D42 3E          	mov [d], al			; set day
2325   0D43             	
2326   0D43 79          	inc d
2327   0D44 19 05       	mov al, 5
2328   0D46 05 01       	syscall sys_rtc
2329   0D48 1A          	mov al, ah
2330   0D49 3E          	mov [d], al			; set month
2331   0D4A             	
2332   0D4A 79          	inc d
2333   0D4B 19 06       	mov al, 6
2334   0D4D 05 01       	syscall sys_rtc
2335   0D4F 1A          	mov al, ah
2336   0D50 3E          	mov [d], al			; set year
2337   0D51             	
2338   0D51             ; write sector into disk for new directory entry
2339   0D51 FD 27       	mov b, g
2340   0D53 38 00 00    	mov c, 0
2341   0D56 3B 1E 32    	mov d, transient_area
2342   0D59 10 03 01    	mov a, $0103			; disk write, 1 sector
2343   0D5C 05 02       	syscall sys_ide		; write sector
2344   0D5E 07 34 13    	call printnl
2345   0D61 06          	sysret
2346   0D62             
2347   0D62             
2348   0D62             
2349   0D62             ;------------------------------------------------------------------------------------------------------;
2350   0D62             ; create new binary file
2351   0D62             ;------------------------------------------------------------------------------------------------------;
2352   0D62             ; search for first null block
2353   0D62             fs_mkbin:
2354   0D62 19 00         mov al, 0
2355   0D64 3D B1 18      mov [sys_echo_on], al ; disable echo
2356   0D67 FD 4E         mov si, d
2357   0D69 FD 4F 1E 1E   mov di, user_data
2358   0D6D 38 00 02      mov c, 512
2359   0D70 04            load                          ; load data from user-space
2360   0D71 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2361   0D74 38 00 00      mov c, 0                      ; upper lba = 0
2362   0D77             fs_mkbin_l1:  
2363   0D77 22 01         mov ah, $01                  ; 1 sector
2364   0D79 3B 1E 32      mov d, transient_area
2365   0D7C 07 5D 06      call ide_read_sect            ; read sector
2366   0D7F BD 00         cmp byte[d], 0                ; check for null
2367   0D81 C6 8A 0D      je fs_mkbin_found_null
2368   0D84 55 20 00      add b, fs_sectors_per_file
2369   0D87 0A 77 0D      jmp fs_mkbin_l1
2370   0D8A             fs_mkbin_found_null:
2371   0D8A D8            push b                        ; save lba
2372   0D8B             ;create header file by grabbing file name from parameter
2373   0D8B FD 4F 1E 34   mov di, transient_area + 512  ; pointer to file contents
2374   0D8F 07 05 11      call _load_hex                ; load binary hex
2375   0D92 D9            push c                        ; save size (nbr of bytes)
2376   0D93 19 01         mov al, 1
2377   0D95 3D 1E 32      mov [transient_area], al      ; mark sectors as used (not null)
2378   0D98 FD 10         cla
2379   0D9A 42 B9 18      mov [index], a
2380   0D9D 3B 1E 32      mov d, transient_area
2381   0DA0 13            mov a, d
2382   0DA1 42 BB 18      mov [buffer_addr], a
2383   0DA4             fs_mkbin_l2:
2384   0DA4 38 00 00      mov c, 0
2385   0DA7 22 01         mov ah, $01                   ; disk write, 1 sector
2386   0DA9 07 83 06      call ide_write_sect           ; write sector
2387   0DAC 14 B9 18      mov a, [index]
2388   0DAF 77            inc a
2389   0DB0 42 B9 18      mov [index], a
2390   0DB3 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2391   0DB6 C6 C8 0D      je fs_mkbin_add_to_dir
2392   0DB9 FD 77         inc b
2393   0DBB 14 BB 18      mov a, [buffer_addr]
2394   0DBE 53 00 02      add a, 512
2395   0DC1 42 BB 18      mov [buffer_addr], a
2396   0DC4 3C            mov d, a
2397   0DC5 0A A4 0D      jmp fs_mkbin_l2
2398   0DC8             ; now we add the file to the current directory!
2399   0DC8             fs_mkbin_add_to_dir:  
2400   0DC8 14 C1 18      mov a, [current_dir_id]
2401   0DCB 77            inc a
2402   0DCC 27            mov b, a                      ; metadata sector
2403   0DCD 38 00 00      mov c, 0
2404   0DD0 FD 79         mov g, b                      ; save lba
2405   0DD2 3B 1E 32      mov d, transient_area
2406   0DD5 22 01         mov ah, $01                  ; 1 sector
2407   0DD7 07 5D 06      call ide_read_sect            ; read metadata sector
2408   0DDA             fs_mkbin_add_to_dir_l2:
2409   0DDA BD 00         cmp byte[d], 0
2410   0DDC C6 E5 0D      je fs_mkbin_add_to_dir_null
2411   0DDF 58 20 00      add d, fst_entry_size
2412   0DE2 0A DA 0D      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2413   0DE5             fs_mkbin_add_to_dir_null:
2414   0DE5 FD 4D 1E 1E   mov si, user_data
2415   0DE9 FD 50         mov di, d
2416   0DEB 07 DF 11      call _strcpy                  ; copy file name
2417   0DEE 58 18 00      add d, 24                     ; skip name
2418   0DF1 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2419   0DF3 3E            mov [d], al
2420   0DF4 58 03 00      add d, 3
2421   0DF7 E4            pop a
2422   0DF8 43            mov [d], a
2423   0DF9 63 02 00      sub d, 2
2424   0DFC E5            pop b                         ; get file lba
2425   0DFD FD 43         mov [d], b                    ; save lba
2426   0DFF               ; set file creation date  
2427   0DFF 58 04 00      add d, 4
2428   0E02 19 04         mov al, 4
2429   0E04 05 01         syscall sys_rtc
2430   0E06 1A            mov al, ah
2431   0E07 3E            mov [d], al                   ; set day
2432   0E08 79            inc d
2433   0E09 19 05         mov al, 5
2434   0E0B 05 01         syscall sys_rtc
2435   0E0D 1A            mov al, ah
2436   0E0E 3E            mov [d], al                   ; set month
2437   0E0F 79            inc d
2438   0E10 19 06         mov al, 6
2439   0E12 05 01         syscall sys_rtc
2440   0E14 1A            mov al, ah
2441   0E15 3E            mov [d], al                   ; set year
2442   0E16             ; write sector into disk for new directory entry
2443   0E16 FD 27         mov b, g
2444   0E18 38 00 00      mov c, 0
2445   0E1B 3B 1E 32      mov d, transient_area
2446   0E1E 22 01         mov ah, $01                   ; disk write, 1 sector
2447   0E20 07 83 06      call ide_write_sect           ; write sector
2448   0E23 19 01         mov al, 1
2449   0E25 3D B1 18      mov [sys_echo_on], al ; enable echo
2450   0E28 06            sysret
2451   0E29             
2452   0E29             ;------------------------------------------------------------------------------------------------------;
2453   0E29             ; pwd - print working directory
2454   0E29             ;------------------------------------------------------------------------------------------------------;    
2455   0E29             fs_pwd:
2456   0E29 3B 9E 1D      mov d, filename
2457   0E2C 19 00         mov al, 0
2458   0E2E 3E            mov [d], al                   ; initialize path string 
2459   0E2F 14 C1 18      mov a, [current_dir_id]
2460   0E32 07 93 09      call fs_dir_id_to_path_e0
2461   0E35 3B 9E 1D      mov d, filename
2462   0E38 07 73 11      call _strrev
2463   0E3B 07 87 13      call _puts
2464   0E3E 07 34 13      call printnl
2465   0E41 06            sysret
2466   0E42             
2467   0E42             ;------------------------------------------------------------------------------------------------------;
2468   0E42             ; get current directory lba
2469   0E42             ; a: returned lba
2470   0E42             ;------------------------------------------------------------------------------------------------------;
2471   0E42             cmd_get_curr_dir_lba:
2472   0E42 14 C1 18      mov a, [current_dir_id]
2473   0E45 06            sysret
2474   0E46             
2475   0E46             ;------------------------------------------------------------------------------------------------------;
2476   0E46             ; cat
2477   0E46             ; userspace destination data pointer in d
2478   0E46             ; filename starts at d, but is overwritten after the read is made
2479   0E46             ;------------------------------------------------------------------------------------------------------;:
2480   0E46             fs_cat:
2481   0E46 DA            push d                              ; save userspace file data destination
2482   0E47 FD 4E         mov si, d
2483   0E49 FD 4F 1E 1E   mov di, user_data
2484   0E4D 38 00 02      mov c, 512
2485   0E50 04            load                                ; copy filename from user-space
2486   0E51 29 C1 18      mov b, [current_dir_id]
2487   0E54 FD 77         inc b                               ; metadata sector
2488   0E56 38 00 00      mov c, 0                            ; upper lba = 0
2489   0E59 22 01         mov ah, $01                  ; 1 sector
2490   0E5B 3B 1E 30      mov d, transient_area-512
2491   0E5E 07 5D 06      call ide_read_sect                  ; read directory
2492   0E61 FD 10         cla
2493   0E63 42 B9 18      mov [index], a                      ; reset file counter
2494   0E66             fs_cat_l1:
2495   0E66 FD 4E         mov si, d
2496   0E68 FD 4F 1E 1E   mov di, user_data
2497   0E6C 07 CA 11      call _strcmp
2498   0E6F C6 85 0E      je fs_cat_found_entry
2499   0E72 58 20 00      add d, 32
2500   0E75 14 B9 18      mov a, [index]
2501   0E78 77            inc a
2502   0E79 42 B9 18      mov [index], a
2503   0E7C AF 10 00      cmp a, fst_files_per_dir
2504   0E7F C6 A0 0E      je fs_cat_not_found
2505   0E82 0A 66 0E      jmp fs_cat_l1
2506   0E85             fs_cat_found_entry:
2507   0E85 58 19 00      add d, 25                           ; get to dirid of file in disk
2508   0E88 2A            mov b, [d]                          ; get lba
2509   0E89 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2510   0E8B 3B 1E 32      mov d, transient_area  
2511   0E8E 38 00 00      mov c, 0
2512   0E91 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2513   0E93 07 5D 06      call ide_read_sect                  ; read sectors
2514   0E96 F0            pop di                              ; write userspace file data destination to di
2515   0E97 FD 4D 1E 32   mov si, transient_area              ; data origin
2516   0E9B 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2517   0E9E 03            store
2518   0E9F 06            sysret
2519   0EA0             fs_cat_not_found:
2520   0EA0 E7            pop d
2521   0EA1 06            sysret
2522   0EA2             
2523   0EA2             ;------------------------------------------------------------------------------------------------------;
2524   0EA2             ; rmdir - remove dir by dirid
2525   0EA2             ;------------------------------------------------------------------------------------------------------;
2526   0EA2             ; deletes a directory entry in the given directory's file list 
2527   0EA2             ; also deletes the actual directory entry in the fst
2528   0EA2             ; synopsis: rmdir /usr/local/testdir
2529   0EA2             ; b = dirid
2530   0EA2             fs_rmdir:
2531   0EA2 FD 79         mov g, b
2532   0EA4 11            mov a, b
2533   0EA5 07 CF 09      call get_parentid_from_dirid  ; now get the directory's parent, in a
2534   0EA8 D7            push a                        ; save dirid
2535   0EA9             ; search for directory's entry in the parent's directory then and delete it
2536   0EA9 77            inc a                         ; metadata sector
2537   0EAA 27            mov b, a
2538   0EAB 38 00 00      mov c, 0                      ; upper lba = 0
2539   0EAE 22 01         mov ah, $01          ;
2540   0EB0 3B 1E 32      mov d, transient_area
2541   0EB3 07 5D 06      call ide_read_sect            ; read directory
2542   0EB6 FD 10         cla
2543   0EB8 42 B9 18      mov [index], a                ; reset file counter
2544   0EBB FD 27         mov b, g                      ; retrieve directory's dirid
2545   0EBD             fs_rmdir_l1:
2546   0EBD 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2547   0EC0 B0            cmp a, b                      ; compare dirid's to find the directory
2548   0EC1 C6 D7 0E      je fs_rmdir_found_entry
2549   0EC4 58 20 00      add d, 32
2550   0EC7 14 B9 18      mov a, [index]
2551   0ECA 77            inc a
2552   0ECB 42 B9 18      mov [index], a
2553   0ECE AF 10 00      cmp a, fst_files_per_dir
2554   0ED1 C6 FC 0E      je fs_rmdir_not_found
2555   0ED4 0A BD 0E      jmp fs_rmdir_l1
2556   0ED7             fs_rmdir_found_entry:
2557   0ED7 FD 10         cla
2558   0ED9 3E            mov [d], al                   ; make filename null
2559   0EDA 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2560   0EDD E5            pop b
2561   0EDE FD 77         inc b                         ; metadata sector
2562   0EE0 38 00 00      mov c, 0                      ; upper lba = 0
2563   0EE3 22 01         mov ah, $01          ; 
2564   0EE5 3B 1E 32      mov d, transient_area
2565   0EE8 07 83 06      call ide_write_sect           ; write sector and erase file's entry in the current dir
2566   0EEB             
2567   0EEB FD 27         mov b, g
2568   0EED 3B 1E 32      mov d, transient_area  
2569   0EF0 FD 10         cla
2570   0EF2 3E            mov [d], al                   ; make directory's name header null for re-use
2571   0EF3 38 00 00      mov c, 0
2572   0EF6 22 01         mov ah, $01                   ; disk write 1 sect
2573   0EF8 07 83 06      call ide_write_sect           ; delete directory given by dirid in b
2574   0EFB 06            sysret
2575   0EFC             fs_rmdir_not_found:
2576   0EFC E5            pop b
2577   0EFD 06            sysret
2578   0EFE             
2579   0EFE             ;------------------------------------------------------------------------------------------------------;
2580   0EFE             ; rm - remove file
2581   0EFE             ;------------------------------------------------------------------------------------------------------;
2582   0EFE             ; frees up the data sectors for the file further down the disk
2583   0EFE             ; deletes file entry in the directory's file list 
2584   0EFE             fs_rm:
2585   0EFE FD 4E         mov si, d
2586   0F00 FD 4F 1E 1E   mov di, user_data
2587   0F04 38 00 02      mov c, 512
2588   0F07 04            load                          ; load data from user-space
2589   0F08 14 C1 18      mov a, [current_dir_id]
2590   0F0B 77            inc a                         ; metadata sector
2591   0F0C 27            mov b, a
2592   0F0D 38 00 00      mov c, 0                      ; upper lba = 0
2593   0F10 22 01         mov ah, $01                  ; 1 sector
2594   0F12 3B 1E 32      mov d, transient_area
2595   0F15 07 5D 06      call ide_read_sect            ; read directory
2596   0F18 10 00 00      mov a, 0
2597   0F1B 42 B9 18      mov [index], a                ; reset file counter
2598   0F1E             fs_rm_l1:
2599   0F1E FD 4E         mov si, d
2600   0F20 FD 4F 1E 1E   mov di, user_data
2601   0F24 07 CA 11      call _strcmp
2602   0F27 C6 3D 0F      je fs_rm_found_entry
2603   0F2A 58 20 00      add d, 32
2604   0F2D 14 B9 18      mov a, [index]
2605   0F30 77            inc a
2606   0F31 42 B9 18      mov [index], a
2607   0F34 AF 10 00      cmp a, fst_files_per_dir
2608   0F37 C6 65 0F      je fs_rm_not_found
2609   0F3A 0A 1E 0F      jmp fs_rm_l1
2610   0F3D             fs_rm_found_entry:
2611   0F3D 2B 19 00      mov b, [d + 25]               ; get lba
2612   0F40 FD 79         mov g, b                      ; save lba
2613   0F42 19 00         mov al, 0
2614   0F44 3E            mov [d], al                   ; make file entry null
2615   0F45 14 C1 18      mov a, [current_dir_id]
2616   0F48 77            inc a                         ; metadata sector
2617   0F49 27            mov b, a
2618   0F4A 38 00 00      mov c, 0                      ; upper lba = 0
2619   0F4D 22 01         mov ah, $01                   ; disk write
2620   0F4F 3B 1E 32      mov d, transient_area
2621   0F52 07 83 06      call ide_write_sect           ; write sector and erase file's entry in the current dir
2622   0F55 3B 1E 32      mov d, transient_area  
2623   0F58 19 00         mov al, 0
2624   0F5A 3E            mov [d], al                   ; make file's data header null for re-use
2625   0F5B 38 00 00      mov c, 0
2626   0F5E FD 27         mov b, g                      ; get data header lba
2627   0F60 22 01         mov ah, $01                   ; disk write 1 sect
2628   0F62 07 83 06      call ide_write_sect           ; write sector
2629   0F65             fs_rm_not_found:  
2630   0F65 06            sysret  
2631   0F66             
2632   0F66             ;------------------------------------------------------------------------------------------------------;
2633   0F66             ; mv - move / change file name
2634   0F66             ;------------------------------------------------------------------------------------------------------;
2635   0F66             fs_mv:
2636   0F66 FD 4E         mov si, d
2637   0F68 FD 4F 1E 1E   mov di, user_data
2638   0F6C 38 00 02      mov c, 512
2639   0F6F 04            load                          ; load data from user-space
2640   0F70 14 C1 18      mov a, [current_dir_id]
2641   0F73 77            inc a                         ; metadata sector
2642   0F74 27            mov b, a  
2643   0F75 38 00 00      mov c, 0                      ; upper lba = 0
2644   0F78 22 01         mov ah, $01                  ; 1 sector
2645   0F7A 3B 1E 32      mov d, transient_area
2646   0F7D 07 5D 06      call ide_read_sect            ; read directory
2647   0F80 FD 10         cla
2648   0F82 42 B9 18      mov [index], a                ; reset file counter
2649   0F85             fs_mv_l1:
2650   0F85 FD 4E         mov si, d
2651   0F87 FD 4F 1E 1E   mov di, user_data
2652   0F8B 07 CA 11      call _strcmp
2653   0F8E C6 A4 0F      je fs_mv_found_entry
2654   0F91 58 20 00      add d, 32
2655   0F94 14 B9 18      mov a, [index]
2656   0F97 77            inc a
2657   0F98 42 B9 18      mov [index], a
2658   0F9B AF 10 00      cmp a, fst_files_per_dir
2659   0F9E C6 D6 0F      je fs_mv_not_found
2660   0FA1 0A 85 0F      jmp fs_mv_l1
2661   0FA4             fs_mv_found_entry:  
2662   0FA4 DA            push d
2663   0FA5 FD 4D 9E 1E   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2664   0FA9 FD 50         mov di, d
2665   0FAB 07 DF 11      call _strcpy  
2666   0FAE 38 00 00      mov c, 0
2667   0FB1 3B 1E 32      mov d, transient_area
2668   0FB4 22 01         mov ah, $01                   ; disk write 1 sect
2669   0FB6 07 83 06      call ide_write_sect           ; write sector
2670   0FB9 E7            pop d
2671   0FBA             ;; need to check whether its a dir or a file here ;;;
2672   0FBA 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2673   0FBD 22 01         mov ah, $01
2674   0FBF 3B 1E 32      mov d, transient_area
2675   0FC2 38 00 00      mov c, 0
2676   0FC5 07 5D 06      call ide_read_sect            ; read directory entry
2677   0FC8 FD 4D 9E 1E   mov si, user_data + 128
2678   0FCC FD 50         mov di, d
2679   0FCE 07 DF 11      call _strcpy                  ; change directory's name
2680   0FD1 22 01         mov ah, $01
2681   0FD3 07 83 06      call ide_write_sect           ; rewrite directory back to disk
2682   0FD6             fs_mv_not_found:
2683   0FD6 06            sysret
2684   0FD7             
2685   0FD7             
2686   0FD7             ;----------------------------------------------------------------------------------------------------;
2687   0FD7             ; process index in a
2688   0FD7             ;----------------------------------------------------------------------------------------------------;
2689   0FD7             find_free_proc:
2690   0FD7 FD 4D 8F 1B   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2691   0FDB             find_free_proc_l0:
2692   0FDB F6            lodsb                               ; get process state
2693   0FDC B9 00         cmp al, 0
2694   0FDE C6 E4 0F      je find_free_proc_free              ; if free, jump
2695   0FE1 0A DB 0F      jmp find_free_proc_l0               ; else, goto next
2696   0FE4             find_free_proc_free:
2697   0FE4 4E            mov a, si
2698   0FE5 5F 8F 1B      sub a, 1 + proc_availab_table       ; get process index
2699   0FE8 09            ret
2700   0FE9               
2701   0FE9             
2702   0FE9             ;----------------------------------------------------------------------------------------------------;
2703   0FE9             ; process index in al
2704   0FE9             ;----------------------------------------------------------------------------------------------------;
2705   0FE9             proc_memory_map:
2706   0FE9 22 00         mov ah, 0
2707   0FEB 27            mov b, a                      ; page in bl, 0 in bh
2708   0FEC FD 9D 05      shl a, 5                      ; multiply by 32
2709   0FEF 39            mov c, a                      ; save in c
2710   0FF0 57 20 00      add c, 32
2711   0FF3             proc_memory_map_l0:
2712   0FF3 02            pagemap
2713   0FF4 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2714   0FF7 53 01 00      add a, 1                      ; increase both 
2715   0FFA B1            cmp a, c                      ; check to see if we reached the end of memory
2716   0FFB C7 F3 0F      jne proc_memory_map_l0
2717   0FFE 09            ret
2718   0FFF               
2719   0FFF             
2720   0FFF             ;----------------------------------------------------------------------------------------------------;
2721   0FFF             ; terminate process
2722   0FFF             ;----------------------------------------------------------------------------------------------------;
2723   0FFF             syscall_terminate_proc:
2724   0FFF 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2725   1002                                                    ; since they will not be used for anything here.
2726   1002 1D B8 18      mov al, [active_proc_index]
2727   1005 22 00         mov ah, 0  
2728   1007 FD 9D 05      shl a, 5                             ; x32
2729   100A 53 9E 1B      add a, proc_names
2730   100D 3C            mov d, a
2731   100E 19 00         mov al, 0
2732   1010 3E            mov [d], al                           ; nullify process name
2733   1011             
2734   1011 1D B8 18      mov al, [active_proc_index]
2735   1014 22 00         mov ah, 0  
2736   1016 3C            mov d, a
2737   1017 19 00         mov al, 0
2738   1019 3F 8E 1B      mov [d + proc_availab_table], al    ; make process empty again
2739   101C               
2740   101C 1D B7 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2741   101F 80            dec al
2742   1020 3D B7 18      mov [nbr_active_procs], al
2743   1023             
2744   1023             ; now load the shell process again
2745   1023 19 02         mov al, 2                           ; next process = process 2 = shell
2746   1025 3D B8 18      mov [active_proc_index], al         ; set next active proc
2747   1028             
2748   1028             ; calculate lut entry for next process
2749   1028 22 00         mov ah, 0
2750   102A FD 99         shl a                               ; x2
2751   102C B7 F5 10      mov a, [proc_table_convert + a]     ; get process state start index  
2752   102F               
2753   102F 4D            mov si, a                           ; source is proc state block
2754   1030 48            mov a, sp
2755   1031 5F 13 00      sub a, 19
2756   1034 4F            mov di, a                           ; destination is kernel stack
2757   1035             ; restore sp
2758   1035 7D            dec a
2759   1036 47            mov sp, a
2760   1037 38 14 00      mov c, 20
2761   103A FD F5         rep movsb
2762   103C             ; set vm process
2763   103C 1D B8 18      mov al, [active_proc_index]
2764   103F 01            setptb
2765   1040                 
2766   1040 4C            popa
2767   1041 06            sysret
2768   1042             
2769   1042             ;----------------------------------------------------------------------------------------------------;
2770   1042             ; pause process
2771   1042             ;----------------------------------------------------------------------------------------------------;
2772   1042             syscall_pause_proc:
2773   1042             ; save all registers into kernel stack
2774   1042 4B            pusha
2775   1043 22 00         mov ah, 0
2776   1045 1D B8 18      mov al, [active_proc_index]
2777   1048 FD 99         shl a              ; x2
2778   104A B7 F5 10      mov a, [proc_table_convert + a]   ; get process state start index
2779   104D                 
2780   104D 4F            mov di, a
2781   104E 48            mov a, sp
2782   104F 77            inc a
2783   1050 4D            mov si, a
2784   1051 38 14 00      mov c, 20
2785   1054 FD F5         rep movsb                         ; save process state!
2786   1056             ; restore kernel stack position to point before interrupt arrived
2787   1056 51 14 00      add sp, 20
2788   1059             ; now load the shell process again
2789   1059 19 02         mov al, 2                         ; next process = process 2 = shell
2790   105B 3D B8 18      mov [active_proc_index], al       ; set next active proc
2791   105E             
2792   105E             ; calculate lut entry for next process
2793   105E 22 00         mov ah, 0
2794   1060 FD 99         shl a                             ; x2
2795   1062 B7 F5 10      mov a, [proc_table_convert + a]   ; get process state start index  
2796   1065               
2797   1065 4D            mov si, a                         ; source is proc state block
2798   1066 48            mov a, sp
2799   1067 5F 13 00      sub a, 19
2800   106A 4F            mov di, a                         ; destination is kernel stack
2801   106B             ; restore sp
2802   106B 7D            dec a
2803   106C 47            mov sp, a
2804   106D 38 14 00      mov c, 20
2805   1070 FD F5         rep movsb
2806   1072             ; set vm process
2807   1072 1D B8 18      mov al, [active_proc_index]
2808   1075 01            setptb
2809   1076                 
2810   1076 4C            popa
2811   1077 06            sysret
2812   1078             
2813   1078             ;----------------------------------------------------------------------------------------------------;
2814   1078             ; create a new process
2815   1078             ; d = path of the process file to be createed
2816   1078             ; b = arguments ptr
2817   1078             ;----------------------------------------------------------------------------------------------------;
2818   1078             syscall_create_proc:
2819   1078             ; we save the active process first  
2820   1078 4B            pusha
2821   1079 22 00         mov ah, 0
2822   107B 1D B8 18      mov al, [active_proc_index]
2823   107E FD 99         shl a              ; x2
2824   1080 B7 F5 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2825   1083               
2826   1083 4F            mov di, a
2827   1084 48            mov a, sp
2828   1085 77            inc a
2829   1086 4D            mov si, a
2830   1087 38 14 00      mov c, 20
2831   108A FD F5         rep movsb                          ; save process state!
2832   108C             ; restore kernel stack position to point before interrupt arrived
2833   108C 51 14 00      add sp, 20
2834   108F               
2835   108F FD 4E         mov si, d                          ; copy the file path
2836   1091 FD 4F 1E 1E   mov di, user_data
2837   1095 38 00 02      mov c, 512
2838   1098 04            load
2839   1099 11            mov a, b
2840   109A 4D            mov si, a                          ; copy the arguments
2841   109B FD 4F 1E 30   mov di, scrap_sector
2842   109F 38 00 02      mov c, 512
2843   10A2 04            load
2844   10A3 07 15 0B      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2845   10A6                                                  ; the file data is loaded into transient_area
2846   10A6             ; now we allocate a new process  
2847   10A6 07 D7 0F      call find_free_proc                ; index in a
2848   10A9 01            setptb 
2849   10AA 07 E9 0F      call proc_memory_map               ; map process memory pages
2850   10AD             ; copy arguments into process's memory
2851   10AD FD 4D 1E 30   mov si, scrap_sector
2852   10B1 FD 4F 00 00   mov di, 0
2853   10B5 38 00 02      mov c, 512
2854   10B8 03            store
2855   10B9             ; now copy process binary data into process's memory
2856   10B9 FD 4D 1E 32   mov si, transient_area
2857   10BD FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2858   10C1 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2859   10C4 03            store                              ; copy process data
2860   10C5                 
2861   10C5 07 D7 0F      call find_free_proc                ; index in a
2862   10C8 3D B8 18      mov [active_proc_index], al        ; set new active process
2863   10CB FD 9D 05      shl a, 5                           ; x32
2864   10CE 53 9E 1B      add a, proc_names
2865   10D1 4F            mov di, a
2866   10D2 FD 4D 1E 1E   mov si, user_data                  ; copy and store process filename
2867   10D6 07 DF 11      call _strcpy
2868   10D9               
2869   10D9 07 D7 0F      call find_free_proc                ; index in a
2870   10DC 3C            mov d, a
2871   10DD 19 01         mov al, 1
2872   10DF 3F 8E 1B      mov [d + proc_availab_table], al   ; make process busy
2873   10E2               
2874   10E2 1D B7 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2875   10E5 7A            inc al
2876   10E6 3D B7 18      mov [nbr_active_procs], al
2877   10E9             ; launch process
2878   10E9 FD D7 FF FF   push word $ffff 
2879   10ED FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2880   10F0 FD D7 00 04   push word text_org
2881   10F4 06            sysret
2882   10F5             
2883   10F5             proc_table_convert:
2884   10F5 4E 1A         .dw proc_state_table + 0
2885   10F7 62 1A         .dw proc_state_table + 20
2886   10F9 76 1A         .dw proc_state_table + 40
2887   10FB 8A 1A         .dw proc_state_table + 60
2888   10FD 9E 1A         .dw proc_state_table + 80
2889   10FF B2 1A         .dw proc_state_table + 100
2890   1101 C6 1A         .dw proc_state_table + 120
2891   1103 DA 1A         .dw proc_state_table + 140
2892   1105               
2893   1105             ;----------------------------------------------------------------------------------------------;
2894   1105             ; get hex file
2895   1105             ; di = destination address
2896   1105             ; return length in bytes in c
2897   1105             ;----------------------------------------------------------------------------------------------;
2898   1105             _load_hex:
2899   1105 D7            push a
2900   1106 D8            push b
2901   1107 DA            push d
2902   1108 E2            push si
2903   1109 E3            push di
2904   110A 38 00 00      mov c, 0
2905   110D 50            mov a, di
2906   110E 3C            mov d, a          ; start of string data block
2907   110F 07 62 12      call _gets        ; get program string
2908   1112 4D            mov si, a
2909   1113             __load_hex_loop:
2910   1113 F6            lodsb             ; load from [si] to al
2911   1114 B9 00         cmp al, 0         ; check if ascii 0
2912   1116 C6 24 11      jz __load_hex_ret
2913   1119 36            mov bh, al
2914   111A F6            lodsb
2915   111B 2F            mov bl, al
2916   111C 07 18 12      call _atoi        ; convert ascii byte in b to int (to al)
2917   111F F7            stosb             ; store al to [di]
2918   1120 78            inc c
2919   1121 0A 13 11      jmp __load_hex_loop
2920   1124             __load_hex_ret:
2921   1124 F0            pop di
2922   1125 EF            pop si
2923   1126 E7            pop d
2924   1127 E5            pop b
2925   1128 E4            pop a
2926   1129 09            ret
2927   112A             
2928   112A             ; synopsis: look inside a certain directory for files/directories
2929   112A             ; before calling this function, cd into required directory
2930   112A             ; for each entry inside directory:
2931   112A             ;  if entry is a file:
2932   112A             ;    compare filename to searched filename
2933   112A             ;    if filenames are the same, print filename
2934   112A             ;  else if entry is a directory:
2935   112A             ;    cd to the given directory
2936   112A             ;    recursively call cmd_find
2937   112A             ;    cd outside previous directory
2938   112A             ;  if current entry == last entry, return
2939   112A             ; endfor
2940   112A             f_find:
2941   112A 09            ret
2942   112B             
2943   112B             
2944   112B             ; ---------------------------------------------------------------------
2945   112B             ; kernel reset vector
2946   112B             ; ---------------------------------------------------------------------
2947   112B             kernel_reset_vector:  
2948   112B FD 49 FF F7   mov bp, _stack_begin
2949   112F FD 47 FF F7   mov sp, _stack_begin
2950   1133               
2951   1133 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2952   1135 FD 0F         stomsk                        
2953   1137 FD 0C         sti  
2954   1139             
2955   1139 0C            lodstat
2956   113A 87 DF         and al, %11011111             ; disable display register loading
2957   113C 0D            stostat
2958   113D               
2959   113D             ; reset fifo pointers
2960   113D 10 1E 20      mov a, fifo
2961   1140 3B BD 18      mov d, fifo_in
2962   1143 43            mov [d], a
2963   1144 3B BF 18      mov d, fifo_out
2964   1147 43            mov [d], a  
2965   1148 19 02         mov al, 2
2966   114A 05 03         syscall sys_io                ; enable uart in interrupt mode
2967   114C             
2968   114C 3B 12 19      mov d, s_kernel_started
2969   114F 07 87 13      call _puts
2970   1152             
2971   1152 3B 0C 1A      mov d, s_fdc_config
2972   1155 07 87 13      call _puts
2973   1158 F2 C0 FF 0E   mov byte [_fdc_config], %00001110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2974   115C F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000     ; leave this restore command in order to clear BUSY flag
2975   1160 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
2976   1164             
2977   1164 19 10         mov al, 16
2978   1166 05 04         syscall sys_filesystem        ; set root dirid
2979   1168             
2980   1168 3B 2F 19      mov d, s_prompt_init
2981   116B 07 87 13      call _puts
2982   116E 3B C3 18      mov d, s_init_path
2983   1171 05 05         syscall sys_create_proc       ; launch init as a new process
2984   1173             
2985   1173             
2986   1173             ; file includes
2987   1173             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1173             boot_origin      .EQU  $8004
0002+  1173             bios_uart        .EQU  $0002
0003+  1173             bios_ide         .EQU  $0003
0004+  1173             bios_reset_vector .EQU  $01c0
0005+  1173             ide_buffer       .EQU  $8204
2988   1173             .include "lib/stdio.asm"
0001+  1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1173             ; stdio.s
0003+  1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1173             .include "lib/string.asm"
0001++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1173             ; string.s
0003++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1173             
0005++ 1173             
0006++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1173             ; _strrev
0008++ 1173             ; reverse a string
0009++ 1173             ; d = string address
0010++ 1173             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1173             ; 01234
0012++ 1173             _strrev:
0013++ 1173 4B          	pusha
0014++ 1174 07 BA 11    	call _strlen	; length in c
0015++ 1177 12          	mov a, c
0016++ 1178 AF 01 00    	cmp a, 1
0017++ 117B D0 95 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 117E 7D          	dec a
0019++ 117F FD 4E       	mov si, d	; beginning of string
0020++ 1181 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1183 59          	add d, a	; end of string
0022++ 1184 12          	mov a, c
0023++ 1185 FD 9B       	shr a		; divide by 2
0024++ 1187 39          	mov c, a	; c now counts the steps
0025++ 1188             _strrev_l0:
0026++ 1188 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1189 F6          	lodsb		; load left-side char into al; increase si
0028++ 118A 3E          	mov [d], al	; store left char into right side
0029++ 118B 1B          	mov al, bl
0030++ 118C F7          	stosb		; store right-side char into left-side; increase di
0031++ 118D 7E          	dec c
0032++ 118E 7F          	dec d
0033++ 118F C2 00 00    	cmp c, 0
0034++ 1192 C7 88 11    	jne _strrev_l0
0035++ 1195             _strrev_end:
0036++ 1195 4C          	popa
0037++ 1196 09          	ret
0038++ 1197             	
0039++ 1197             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1197             ; _strchr
0041++ 1197             ; search string in d for char in al
0042++ 1197             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1197             _strchr:
0044++ 1197             _strchr_l0:
0045++ 1197 32          	mov bl, [d]
0046++ 1198 C1 00       	cmp bl, 0
0047++ 119A C6 A5 11    	je _strchr_end
0048++ 119D BA          	cmp al, bl
0049++ 119E C6 A5 11    	je _strchr_end
0050++ 11A1 79          	inc d
0051++ 11A2 0A 97 11    	jmp _strchr_l0
0052++ 11A5             _strchr_end:
0053++ 11A5 1B          	mov al, bl
0054++ 11A6 09          	ret
0055++ 11A7             
0056++ 11A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 11A7             ; _strstr
0058++ 11A7             ; find sub-string
0059++ 11A7             ; str1 in si
0060++ 11A7             ; str2 in di
0061++ 11A7             ; si points to end of source string
0062++ 11A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 11A7             _strstr:
0064++ 11A7 DB          	push al
0065++ 11A8 DA          	push d
0066++ 11A9 E3          	push di
0067++ 11AA             _strstr_loop:
0068++ 11AA F3          	cmpsb					; compare a byte of the strings
0069++ 11AB C7 B6 11    	jne _strstr_ret
0070++ 11AE FC 00 00    	lea d, [di + 0]
0071++ 11B1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 11B3 C7 AA 11    	jne _strstr_loop				; equal chars but not at end
0073++ 11B6             _strstr_ret:
0074++ 11B6 F0          	pop di
0075++ 11B7 E7          	pop d
0076++ 11B8 E8          	pop al
0077++ 11B9 09          	ret
0078++ 11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 11BA             ; length of null terminated string
0080++ 11BA             ; result in c
0081++ 11BA             ; pointer in d
0082++ 11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 11BA             _strlen:
0084++ 11BA DA          	push d
0085++ 11BB 38 00 00    	mov c, 0
0086++ 11BE             _strlen_l1:
0087++ 11BE BD 00       	cmp byte [d], 0
0088++ 11C0 C6 C8 11    	je _strlen_ret
0089++ 11C3 79          	inc d
0090++ 11C4 78          	inc c
0091++ 11C5 0A BE 11    	jmp _strlen_l1
0092++ 11C8             _strlen_ret:
0093++ 11C8 E7          	pop d
0094++ 11C9 09          	ret
0095++ 11CA             
0096++ 11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 11CA             ; strcmp
0098++ 11CA             ; compare two strings
0099++ 11CA             ; str1 in si
0100++ 11CA             ; str2 in di
0101++ 11CA             ; create a string compairon instrucion ?????
0102++ 11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 11CA             _strcmp:
0104++ 11CA DB          	push al
0105++ 11CB DA          	push d
0106++ 11CC E3          	push di
0107++ 11CD E2          	push si
0108++ 11CE             _strcmp_loop:
0109++ 11CE F3          	cmpsb					; compare a byte of the strings
0110++ 11CF C7 DA 11    	jne _strcmp_ret
0111++ 11D2 FB FF FF    	lea d, [si +- 1]
0112++ 11D5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 11D7 C7 CE 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 11DA             _strcmp_ret:
0115++ 11DA EF          	pop si
0116++ 11DB F0          	pop di
0117++ 11DC E7          	pop d
0118++ 11DD E8          	pop al
0119++ 11DE 09          	ret
0120++ 11DF             
0121++ 11DF             
0122++ 11DF             ; strcpy
0123++ 11DF             ; copy null terminated string from si to di
0124++ 11DF             ; source in si
0125++ 11DF             ; destination in di
0126++ 11DF             _strcpy:
0127++ 11DF E2          	push si
0128++ 11E0 E3          	push di
0129++ 11E1 DB          	push al
0130++ 11E2             _strcpy_l1:
0131++ 11E2 F6          	lodsb
0132++ 11E3 F7          	stosb
0133++ 11E4 B9 00       	cmp al, 0
0134++ 11E6 C7 E2 11    	jne _strcpy_l1
0135++ 11E9             _strcpy_end:
0136++ 11E9 E8          	pop al
0137++ 11EA F0          	pop di
0138++ 11EB EF          	pop si
0139++ 11EC 09          	ret
0140++ 11ED             
0141++ 11ED             ; strcat
0142++ 11ED             ; concatenate a null terminated string into string at di, from string at si
0143++ 11ED             ; source in si
0144++ 11ED             ; destination in di
0145++ 11ED             _strcat:
0146++ 11ED E2          	push si
0147++ 11EE E3          	push di
0148++ 11EF D7          	push a
0149++ 11F0 DA          	push d
0150++ 11F1 50          	mov a, di
0151++ 11F2 3C          	mov d, a
0152++ 11F3             _strcat_goto_end_l1:
0153++ 11F3 BD 00       	cmp byte[d], 0
0154++ 11F5 C6 FC 11    	je _strcat_start
0155++ 11F8 79          	inc d
0156++ 11F9 0A F3 11    	jmp _strcat_goto_end_l1
0157++ 11FC             _strcat_start:
0158++ 11FC FD 50       	mov di, d
0159++ 11FE             _strcat_l1:
0160++ 11FE F6          	lodsb
0161++ 11FF F7          	stosb
0162++ 1200 B9 00       	cmp al, 0
0163++ 1202 C7 FE 11    	jne _strcat_l1
0164++ 1205             _strcat_end:
0165++ 1205 E7          	pop d
0166++ 1206 E4          	pop a
0167++ 1207 F0          	pop di
0168++ 1208 EF          	pop si
0169++ 1209 09          	ret
0170++ 120A             
0171++ 120A             
0005+  120A             
0006+  120A             
0007+  120A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  120A             ; convert ascii 'o'..'f' to integer 0..15
0009+  120A             ; ascii in bl
0010+  120A             ; result in al
0011+  120A             ; ascii for f = 0100 0110
0012+  120A             ; ascii for 9 = 0011 1001
0013+  120A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  120A             hex_ascii_encode:
0015+  120A 1B            mov al, bl
0016+  120B 93 40         test al, $40        ; test if letter or number
0017+  120D C7 13 12      jnz hex_letter
0018+  1210 87 0F         and al, $0f        ; get number
0019+  1212 09            ret
0020+  1213             hex_letter:
0021+  1213 87 0F         and al, $0f        ; get letter
0022+  1215 6A 09         add al, 9
0023+  1217 09            ret
0024+  1218             
0025+  1218             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1218             ; atoi
0027+  1218             ; 2 letter hex string in b
0028+  1218             ; 8bit integer returned in al
0029+  1218             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1218             _atoi:
0031+  1218 D8            push b
0032+  1219 07 0A 12      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  121C 30            mov bl, bh
0034+  121D DB            push al          ; save a
0035+  121E 07 0A 12      call hex_ascii_encode
0036+  1221 EA            pop bl  
0037+  1222 FD 9E 04      shl al, 4
0038+  1225 8C            or al, bl
0039+  1226 E5            pop b
0040+  1227 09            ret  
0041+  1228             
0042+  1228             
0043+  1228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1228             ; scanf
0045+  1228             ; no need for explanations!
0046+  1228             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1228             scanf:
0048+  1228 09            ret
0049+  1229             
0050+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1229             ; itoa
0052+  1229             ; 8bit value in bl
0053+  1229             ; 2 byte ascii result in a
0054+  1229             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1229             _itoa:
0056+  1229 DA            push d
0057+  122A D8            push b
0058+  122B A7 00         mov bh, 0
0059+  122D FD A4 04      shr bl, 4  
0060+  1230 74            mov d, b
0061+  1231 1F C3 14      mov al, [d + s_hex_digits]
0062+  1234 23            mov ah, al
0063+  1235               
0064+  1235 E5            pop b
0065+  1236 D8            push b
0066+  1237 A7 00         mov bh, 0
0067+  1239 FD 87 0F      and bl, $0f
0068+  123C 74            mov d, b
0069+  123D 1F C3 14      mov al, [d + s_hex_digits]
0070+  1240 E5            pop b
0071+  1241 E7            pop d
0072+  1242 09            ret
0073+  1243             
0074+  1243             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1243             ; hex string to binary
0076+  1243             ; di = destination address
0077+  1243             ; si = source
0078+  1243             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1243             _hex_to_int:
0080+  1243             _hex_to_int_l1:
0081+  1243 F6            lodsb          ; load from [si] to al
0082+  1244 B9 00         cmp al, 0        ; check if ascii 0
0083+  1246 C6 53 12      jz _hex_to_int_ret
0084+  1249 36            mov bh, al
0085+  124A F6            lodsb
0086+  124B 2F            mov bl, al
0087+  124C 07 18 12      call _atoi        ; convert ascii byte in b to int (to al)
0088+  124F F7            stosb          ; store al to [di]
0089+  1250 0A 43 12      jmp _hex_to_int_l1
0090+  1253             _hex_to_int_ret:
0091+  1253 09            ret    
0092+  1254             
0093+  1254             
0094+  1254             
0095+  1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1254             ; getchar
0097+  1254             ; char in ah
0098+  1254             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1254             getch:
0100+  1254 DB            push al
0101+  1255             getch_retry:
0102+  1255 19 01         mov al, 1
0103+  1257 05 03         syscall sys_io      ; receive in ah
0104+  1259 E8            pop al
0105+  125A 09            ret
0106+  125B             
0107+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  125B             ; putchar
0109+  125B             ; char in ah
0110+  125B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  125B             _putchar:
0112+  125B DB            push al
0113+  125C 19 00         mov al, 0
0114+  125E 05 03         syscall sys_io      ; char in ah
0115+  1260 E8            pop al
0116+  1261 09            ret
0117+  1262             
0118+  1262             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1262             ;; input a string
0120+  1262             ;; terminates with null
0121+  1262             ;; pointer in d
0122+  1262             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1262             _gets:
0124+  1262 D7            push a
0125+  1263 DA            push d
0126+  1264             _gets_loop:
0127+  1264 19 01         mov al, 1
0128+  1266 05 03         syscall sys_io      ; receive in ah
0129+  1268 76 1B         cmp ah, 27
0130+  126A C6 8B 12      je _gets_ansi_esc
0131+  126D 76 0A         cmp ah, $0a        ; lf
0132+  126F C6 E7 12      je _gets_end
0133+  1272 76 0D         cmp ah, $0d        ; cr
0134+  1274 C6 E7 12      je _gets_end
0135+  1277 76 5C         cmp ah, $5c        ; '\\'
0136+  1279 C6 AD 12      je _gets_escape
0137+  127C 76 08         cmp ah, $08      ; check for backspace
0138+  127E C6 87 12      je _gets_backspace
0139+  1281 1A            mov al, ah
0140+  1282 3E            mov [d], al
0141+  1283 79            inc d
0142+  1284 0A 64 12      jmp _gets_loop
0143+  1287             _gets_backspace:
0144+  1287 7F            dec d
0145+  1288 0A 64 12      jmp _gets_loop
0146+  128B             _gets_ansi_esc:
0147+  128B 19 01         mov al, 1
0148+  128D 05 03         syscall sys_io        ; receive in ah without echo
0149+  128F 76 5B         cmp ah, '['
0150+  1291 C7 64 12      jne _gets_loop
0151+  1294 19 01         mov al, 1
0152+  1296 05 03         syscall sys_io          ; receive in ah without echo
0153+  1298 76 64         cmp ah, 'd'
0154+  129A C6 A5 12      je _gets_left_arrow
0155+  129D 76 63         cmp ah, 'c'
0156+  129F C6 A9 12      je _gets_right_arrow
0157+  12A2 0A 64 12      jmp _gets_loop
0158+  12A5             _gets_left_arrow:
0159+  12A5 7F            dec d
0160+  12A6 0A 64 12      jmp _gets_loop
0161+  12A9             _gets_right_arrow:
0162+  12A9 79            inc d
0163+  12AA 0A 64 12      jmp _gets_loop
0164+  12AD             _gets_escape:
0165+  12AD 19 01         mov al, 1
0166+  12AF 05 03         syscall sys_io      ; receive in ah
0167+  12B1 76 6E         cmp ah, 'n'
0168+  12B3 C6 D2 12      je _gets_lf
0169+  12B6 76 72         cmp ah, 'r'
0170+  12B8 C6 D9 12      je _gets_cr
0171+  12BB 76 30         cmp ah, '0'
0172+  12BD C6 E0 12      je _gets_null
0173+  12C0 76 5C         cmp ah, $5c  ; '\'
0174+  12C2 C6 CB 12      je _gets_slash
0175+  12C5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  12C6 3E            mov [d], al
0177+  12C7 79            inc d
0178+  12C8 0A 64 12      jmp _gets_loop
0179+  12CB             _gets_slash:
0180+  12CB 19 5C         mov al, $5c
0181+  12CD 3E            mov [d], al
0182+  12CE 79            inc d
0183+  12CF 0A 64 12      jmp _gets_loop
0184+  12D2             _gets_lf:
0185+  12D2 19 0A         mov al, $0a
0186+  12D4 3E            mov [d], al
0187+  12D5 79            inc d
0188+  12D6 0A 64 12      jmp _gets_loop
0189+  12D9             _gets_cr:
0190+  12D9 19 0D         mov al, $0d
0191+  12DB 3E            mov [d], al
0192+  12DC 79            inc d
0193+  12DD 0A 64 12      jmp _gets_loop
0194+  12E0             _gets_null:
0195+  12E0 19 00         mov al, $00
0196+  12E2 3E            mov [d], al
0197+  12E3 79            inc d
0198+  12E4 0A 64 12      jmp _gets_loop
0199+  12E7             _gets_end:
0200+  12E7 19 00         mov al, 0
0201+  12E9 3E            mov [d], al        ; terminate string
0202+  12EA E7            pop d
0203+  12EB E4            pop a
0204+  12EC 09            ret
0205+  12ED             
0206+  12ED             
0207+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  12ED             ;; input text
0209+  12ED             ;; terminated with ctrl+d
0210+  12ED             ;; pointer in d
0211+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  12ED             _gettxt:
0213+  12ED D7            push a
0214+  12EE DA            push d
0215+  12EF             _gettxt_loop:
0216+  12EF 19 01         mov al, 1
0217+  12F1 05 03         syscall sys_io      ; receive in ah
0218+  12F3 76 04         cmp ah, 4      ; eot
0219+  12F5 C6 2E 13      je _gettxt_end
0220+  12F8 76 08         cmp ah, $08      ; check for backspace
0221+  12FA C6 2A 13      je _gettxt_backspace
0222+  12FD 76 5C         cmp ah, $5c        ; '\'
0223+  12FF C6 08 13      je _gettxt_escape
0224+  1302 1A            mov al, ah
0225+  1303 3E            mov [d], al
0226+  1304 79            inc d
0227+  1305 0A EF 12      jmp _gettxt_loop
0228+  1308             _gettxt_escape:
0229+  1308 19 01         mov al, 1
0230+  130A 05 03         syscall sys_io      ; receive in ah
0231+  130C 76 6E         cmp ah, 'n'
0232+  130E C6 1C 13      je _gettxt_lf
0233+  1311 76 72         cmp ah, 'r'
0234+  1313 C6 23 13      je _gettxt_cr
0235+  1316 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1317 3E            mov [d], al
0237+  1318 79            inc d
0238+  1319 0A EF 12      jmp _gettxt_loop
0239+  131C             _gettxt_lf:
0240+  131C 19 0A         mov al, $0a
0241+  131E 3E            mov [d], al
0242+  131F 79            inc d
0243+  1320 0A EF 12      jmp _gettxt_loop
0244+  1323             _gettxt_cr:
0245+  1323 19 0D         mov al, $0d
0246+  1325 3E            mov [d], al
0247+  1326 79            inc d
0248+  1327 0A EF 12      jmp _gettxt_loop
0249+  132A             _gettxt_backspace:
0250+  132A 7F            dec d
0251+  132B 0A EF 12      jmp _gettxt_loop
0252+  132E             _gettxt_end:
0253+  132E 19 00         mov al, 0
0254+  1330 3E            mov [d], al        ; terminate string
0255+  1331 E7            pop d
0256+  1332 E4            pop a
0257+  1333 09            ret
0258+  1334             
0259+  1334             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1334             ; print new line
0261+  1334             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1334             printnl:
0263+  1334 D7            push a
0264+  1335 10 00 0A      mov a, $0a00
0265+  1338 05 03         syscall sys_io
0266+  133A 10 00 0D      mov a, $0d00
0267+  133D 05 03         syscall sys_io
0268+  133F E4            pop a
0269+  1340 09            ret
0270+  1341             
0271+  1341             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1341             ; _strtoint
0273+  1341             ; 4 digit hex string number in d
0274+  1341             ; integer returned in a
0275+  1341             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1341             _strtointx:
0277+  1341 D8            push b
0278+  1342 32            mov bl, [d]
0279+  1343 37            mov bh, bl
0280+  1344 33 01 00      mov bl, [d + 1]
0281+  1347 07 18 12      call _atoi        ; convert to int in al
0282+  134A 23            mov ah, al        ; move to ah
0283+  134B 33 02 00      mov bl, [d + 2]
0284+  134E 37            mov bh, bl
0285+  134F 33 03 00      mov bl, [d + 3]
0286+  1352 07 18 12      call _atoi        ; convert to int in al
0287+  1355 E5            pop b
0288+  1356 09            ret
0289+  1357             
0290+  1357             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1357             ; _strtoint
0292+  1357             ; 5 digit base10 string number in d
0293+  1357             ; integer returned in a
0294+  1357             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1357             _strtoint:
0296+  1357 E2            push si
0297+  1358 D8            push b
0298+  1359 D9            push c
0299+  135A DA            push d
0300+  135B 07 BA 11      call _strlen      ; get string length in c
0301+  135E 7E            dec c
0302+  135F FD 4E         mov si, d
0303+  1361 12            mov a, c
0304+  1362 FD 99         shl a
0305+  1364 3B DB 14      mov d, table_power
0306+  1367 59            add d, a
0307+  1368 38 00 00      mov c, 0
0308+  136B             _strtoint_l0:
0309+  136B F6            lodsb      ; load ascii to al
0310+  136C B9 00         cmp al, 0
0311+  136E C6 81 13      je _strtoint_end
0312+  1371 6F 30         sub al, $30    ; make into integer
0313+  1373 22 00         mov ah, 0
0314+  1375 2A            mov b, [d]
0315+  1376 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1377 11            mov a, b
0317+  1378 28            mov b, c
0318+  1379 54            add a, b
0319+  137A 39            mov c, a
0320+  137B 63 02 00      sub d, 2
0321+  137E 0A 6B 13      jmp _strtoint_l0
0322+  1381             _strtoint_end:
0323+  1381 12            mov a, c
0324+  1382 E7            pop d
0325+  1383 E6            pop c
0326+  1384 E5            pop b
0327+  1385 EF            pop si
0328+  1386 09            ret
0329+  1387             
0330+  1387             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1387             ; print null terminated string
0332+  1387             ; pointer in d
0333+  1387             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1387             _puts:
0335+  1387 D7            push a
0336+  1388 DA            push d
0337+  1389             _puts_l1:
0338+  1389 1E            mov al, [d]
0339+  138A B9 00         cmp al, 0
0340+  138C C6 98 13      jz _puts_end
0341+  138F 23            mov ah, al
0342+  1390 19 00         mov al, 0
0343+  1392 05 03         syscall sys_io
0344+  1394 79            inc d
0345+  1395 0A 89 13      jmp _puts_l1
0346+  1398             _puts_end:
0347+  1398 E7            pop d
0348+  1399 E4            pop a
0349+  139A 09            ret
0350+  139B             
0351+  139B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  139B             ; print n size string
0353+  139B             ; pointer in d
0354+  139B             ; size in c
0355+  139B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  139B             _putsn:
0357+  139B DB            push al
0358+  139C DA            push d
0359+  139D D9            push c
0360+  139E             _putsn_l0:
0361+  139E 1E            mov al, [d]
0362+  139F 23            mov ah, al
0363+  13A0 19 00         mov al, 0
0364+  13A2 05 03         syscall sys_io
0365+  13A4 79            inc d
0366+  13A5 7E            dec c  
0367+  13A6 C2 00 00      cmp c, 0
0368+  13A9 C7 9E 13      jne _putsn_l0
0369+  13AC             _putsn_end:
0370+  13AC E6            pop c
0371+  13AD E7            pop d
0372+  13AE E8            pop al
0373+  13AF 09            ret
0374+  13B0             
0375+  13B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  13B0             ; print 16bit decimal number
0377+  13B0             ; input number in a
0378+  13B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  13B0             print_u16d:
0380+  13B0 D7            push a
0381+  13B1 D8            push b
0382+  13B2 FD D8         push g
0383+  13B4 26 10 27      mov b, 10000
0384+  13B7 AE            div a, b      ; get 10000's coeff.
0385+  13B8 07 DC 13      call print_number
0386+  13BB 11            mov a, b
0387+  13BC 26 E8 03      mov b, 1000
0388+  13BF AE            div a, b      ; get 1000's coeff.
0389+  13C0 07 DC 13      call print_number
0390+  13C3 11            mov a, b
0391+  13C4 26 64 00      mov b, 100
0392+  13C7 AE            div a, b
0393+  13C8 07 DC 13      call print_number
0394+  13CB 11            mov a, b
0395+  13CC 26 0A 00      mov b, 10
0396+  13CF AE            div a, b
0397+  13D0 07 DC 13      call print_number
0398+  13D3 1B            mov al, bl      ; 1's coeff in bl
0399+  13D4 07 DC 13      call print_number
0400+  13D7 FD F1         pop g
0401+  13D9 E5            pop b
0402+  13DA E4            pop a
0403+  13DB 09            ret
0404+  13DC             
0405+  13DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  13DC             ; print al
0407+  13DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  13DC             print_number:
0409+  13DC 6A 30         add al, $30
0410+  13DE 23            mov ah, al
0411+  13DF 07 5B 12      call _putchar
0412+  13E2 09            ret
0413+  13E3             
0414+  13E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  13E3             ; print 16bit hex integer
0416+  13E3             ; integer value in reg b
0417+  13E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  13E3             print_u16x:
0419+  13E3 D7            push a
0420+  13E4 D8            push b
0421+  13E5 DD            push bl
0422+  13E6 30            mov bl, bh
0423+  13E7 07 29 12      call _itoa        ; convert bh to char in a
0424+  13EA 2F            mov bl, al        ; save al
0425+  13EB 19 00         mov al, 0
0426+  13ED 05 03         syscall sys_io        ; display ah
0427+  13EF 24            mov ah, bl        ; retrieve al
0428+  13F0 19 00         mov al, 0
0429+  13F2 05 03         syscall sys_io        ; display al
0430+  13F4             
0431+  13F4 EA            pop bl
0432+  13F5 07 29 12      call _itoa        ; convert bh to char in a
0433+  13F8 2F            mov bl, al        ; save al
0434+  13F9 19 00         mov al, 0
0435+  13FB 05 03         syscall sys_io        ; display ah
0436+  13FD 24            mov ah, bl        ; retrieve al
0437+  13FE 19 00         mov al, 0
0438+  1400 05 03         syscall sys_io        ; display al
0439+  1402             
0440+  1402 E5            pop b
0441+  1403 E4            pop a
0442+  1404 09            ret
0443+  1405             
0444+  1405             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1405             ; input 16bit hex integer
0446+  1405             ; read 16bit integer into a
0447+  1405             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1405             scan_u16x:
0449+  1405 F8 10 00      enter 16
0450+  1408 D8            push b
0451+  1409 DA            push d
0452+  140A             
0453+  140A FA F1 FF      lea d, [bp + -15]
0454+  140D 07 62 12      call _gets        ; get number
0455+  1410             
0456+  1410 32            mov bl, [d]
0457+  1411 37            mov bh, bl
0458+  1412 33 01 00      mov bl, [d + 1]
0459+  1415 07 18 12      call _atoi        ; convert to int in al
0460+  1418 23            mov ah, al        ; move to ah
0461+  1419             
0462+  1419 33 02 00      mov bl, [d + 2]
0463+  141C 37            mov bh, bl
0464+  141D 33 03 00      mov bl, [d + 3]
0465+  1420 07 18 12      call _atoi        ; convert to int in al
0466+  1423             
0467+  1423 E7            pop d
0468+  1424 E5            pop b
0469+  1425 F9            leave
0470+  1426 09            ret
0471+  1427             
0472+  1427             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1427             ; print 8bit hex integer
0474+  1427             ; integer value in reg bl
0475+  1427             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1427             print_u8x:
0477+  1427 D7            push a
0478+  1428 DD            push bl
0479+  1429             
0480+  1429 07 29 12      call _itoa        ; convert bl to char in a
0481+  142C 2F            mov bl, al        ; save al
0482+  142D 19 00         mov al, 0
0483+  142F 05 03         syscall sys_io        ; display ah
0484+  1431 24            mov ah, bl        ; retrieve al
0485+  1432 19 00         mov al, 0
0486+  1434 05 03         syscall sys_io        ; display al
0487+  1436             
0488+  1436 EA            pop bl
0489+  1437 E4            pop a
0490+  1438 09            ret
0491+  1439             
0492+  1439             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1439             ; print 8bit decimal unsigned number
0494+  1439             ; input number in al
0495+  1439             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1439             print_u8d:
0497+  1439 D7            push a
0498+  143A D8            push b
0499+  143B FD D8         push g
0500+  143D 22 00         mov ah, 0
0501+  143F 26 64 00      mov b, 100
0502+  1442 AE            div a, b
0503+  1443 D8            push b      ; save remainder
0504+  1444 B9 00         cmp al, 0
0505+  1446 C6 50 14      je skip100
0506+  1449 6A 30         add al, $30
0507+  144B 23            mov ah, al
0508+  144C 19 00         mov al, 0
0509+  144E 05 03         syscall sys_io  ; print coeff
0510+  1450             skip100:
0511+  1450 E4            pop a
0512+  1451 22 00         mov ah, 0
0513+  1453 26 0A 00      mov b, 10
0514+  1456 AE            div a, b
0515+  1457 D8            push b      ; save remainder
0516+  1458 B9 00         cmp al, 0
0517+  145A C6 64 14      je skip10
0518+  145D 6A 30         add al, $30
0519+  145F 23            mov ah, al
0520+  1460 19 00         mov al, 0
0521+  1462 05 03         syscall sys_io  ; print coeff
0522+  1464             skip10:
0523+  1464 E4            pop a
0524+  1465 1B            mov al, bl
0525+  1466 6A 30         add al, $30
0526+  1468 23            mov ah, al
0527+  1469 19 00         mov al, 0
0528+  146B 05 03         syscall sys_io  ; print coeff
0529+  146D FD F1         pop g
0530+  146F E5            pop b
0531+  1470 E4            pop a
0532+  1471 09            ret
0533+  1472             
0534+  1472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1472             ; input 8bit hex integer
0536+  1472             ; read 8bit integer into al
0537+  1472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1472             scan_u8x:
0539+  1472 F8 04 00      enter 4
0540+  1475 D8            push b
0541+  1476 DA            push d
0542+  1477             
0543+  1477 FA FD FF      lea d, [bp + -3]
0544+  147A 07 62 12      call _gets        ; get number
0545+  147D             
0546+  147D 32            mov bl, [d]
0547+  147E 37            mov bh, bl
0548+  147F 33 01 00      mov bl, [d + 1]
0549+  1482 07 18 12      call _atoi        ; convert to int in al
0550+  1485             
0551+  1485 E7            pop d
0552+  1486 E5            pop b
0553+  1487 F9            leave
0554+  1488 09            ret
0555+  1489             
0556+  1489             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1489             ; input decimal number
0558+  1489             ; result in a
0559+  1489             ; 655'\0'
0560+  1489             ; low--------high
0561+  1489             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1489             scan_u16d:
0563+  1489 F8 08 00      enter 8
0564+  148C E2            push si
0565+  148D D8            push b
0566+  148E D9            push c
0567+  148F DA            push d
0568+  1490 FA F9 FF      lea d, [bp +- 7]
0569+  1493 07 62 12      call _gets
0570+  1496 07 BA 11      call _strlen      ; get string length in c
0571+  1499 7E            dec c
0572+  149A FD 4E         mov si, d
0573+  149C 12            mov a, c
0574+  149D FD 99         shl a
0575+  149F 3B DB 14      mov d, table_power
0576+  14A2 59            add d, a
0577+  14A3 38 00 00      mov c, 0
0578+  14A6             mul_loop:
0579+  14A6 F6            lodsb      ; load ascii to al
0580+  14A7 B9 00         cmp al, 0
0581+  14A9 C6 BC 14      je mul_exit
0582+  14AC 6F 30         sub al, $30    ; make into integer
0583+  14AE 22 00         mov ah, 0
0584+  14B0 2A            mov b, [d]
0585+  14B1 AC            mul a, b      ; result in b since it fits in 16bits
0586+  14B2 11            mov a, b
0587+  14B3 28            mov b, c
0588+  14B4 54            add a, b
0589+  14B5 39            mov c, a
0590+  14B6 63 02 00      sub d, 2
0591+  14B9 0A A6 14      jmp mul_loop
0592+  14BC             mul_exit:
0593+  14BC 12            mov a, c
0594+  14BD E7            pop d
0595+  14BE E6            pop c
0596+  14BF E5            pop b
0597+  14C0 EF            pop si
0598+  14C1 F9            leave
0599+  14C2 09            ret
0600+  14C3             
0601+  14C3             
0602+  14C3 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  14C7 34 35 36 37 
0602+  14CB 38 39 61 62 
0602+  14CF 63 64 65 66 
0603+  14D3 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  14D7 1B 5B 68 00 
0604+  14DB             
0605+  14DB             table_power:
0606+  14DB 01 00         .dw 1
0607+  14DD 0A 00         .dw 10
0608+  14DF 64 00         .dw 100
0609+  14E1 E8 03         .dw 1000
0610+  14E3 10 27         .dw 100002989   14E5             .include "lib/ctype.asm"
0001+  14E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  14E5             ; ctype.s
0003+  14E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  14E5             
0005+  14E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  14E5             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  14E5             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  14E5             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  14E5             ;; characters are supported.
0010+  14E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  14E5             ;; _isalnum 
0012+  14E5             ;; _isalpha 
0013+  14E5             ;; islower 
0014+  14E5             ;; isupper 
0015+  14E5             ;; _isdigit 
0016+  14E5             ;; isxdigit
0017+  14E5             ;; iscntrl 
0018+  14E5             ;; isgraph 
0019+  14E5             ;; _isspace 
0020+  14E5             ;; isblank 
0021+  14E5             ;; isprint 
0022+  14E5             ;; ispunct 
0023+  14E5             ;; tolower 
0024+  14E5             ;; toupper
0025+  14E5             
0026+  14E5             
0027+  14E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  14E5             ;; is alphanumeric
0029+  14E5             ;; sets zf according with result
0030+  14E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  14E5             _isalnum:
0032+  14E5 07 02 15    	call _isalpha
0033+  14E8 C6 EE 14    	je _isalnum_exit
0034+  14EB 07 EF 14    	call _isdigit
0035+  14EE             _isalnum_exit:
0036+  14EE 09          	ret	
0037+  14EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  14EF             ;; is digit
0039+  14EF             ;; sets zf according with result
0040+  14EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  14EF             _isdigit:
0042+  14EF DB          	push al
0043+  14F0 B9 30       	cmp al, '0'
0044+  14F2 C8 FE 14    	jlu _isdigit_false
0045+  14F5 B9 39       	cmp al, '9'
0046+  14F7 D1 FE 14    	jgu _isdigit_false
0047+  14FA 87 00       	and al, 0	; set zf
0048+  14FC E8          	pop al
0049+  14FD 09          	ret
0050+  14FE             _isdigit_false:
0051+  14FE 8B 01       	or al, 1	; clear zf
0052+  1500 E8          	pop al
0053+  1501 09          	ret	
0054+  1502             	
0055+  1502             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1502             ;; is alpha
0057+  1502             ;; sets zf according with result
0058+  1502             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1502             _isalpha:
0060+  1502 DB          	push al
0061+  1503 B9 5F       	cmp al, '_'
0062+  1505 C6 25 15    	je _isalpha_true
0063+  1508 B9 2E       	cmp al, '.'
0064+  150A C6 25 15    	je _isalpha_true
0065+  150D B9 61       	cmp al, 'a'
0066+  150F C8 21 15    	jlu _isalpha_false
0067+  1512 B9 7A       	cmp al, 'z'
0068+  1514 D1 21 15    	jgu _isalpha_false
0069+  1517 B9 7A       	cmp al, 'z'
0070+  1519 D0 25 15    	jleu _isalpha_true
0071+  151C B9 61       	cmp al, 'a'
0072+  151E C9 25 15    	jgeu _isalpha_true
0073+  1521             _isalpha_false:
0074+  1521 8B 01       	or al, 1	; clear zf
0075+  1523 E8          	pop al
0076+  1524 09          	ret
0077+  1525             _isalpha_true:
0078+  1525 87 00       	and al, 0	; set zf
0079+  1527 E8          	pop al
0080+  1528 09          	ret
0081+  1529             
0082+  1529             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1529             ;; is path-alpha
0084+  1529             ;; sets zf according with result
0085+  1529             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1529             ispath:
0087+  1529 DB          	push al
0088+  152A 07 EF 14    	call _isdigit
0089+  152D C6 57 15    	je ispath_true
0090+  1530 B9 5F       	cmp al, '_'
0091+  1532 C6 57 15    	je ispath_true
0092+  1535 B9 2F       	cmp al, '/'
0093+  1537 C6 57 15    	je ispath_true
0094+  153A B9 2E       	cmp al, '.'
0095+  153C C6 57 15    	je ispath_true
0096+  153F B9 61       	cmp al, 'a'
0097+  1541 C8 53 15    	jlu ispath_false
0098+  1544 B9 7A       	cmp al, 'z'
0099+  1546 D1 53 15    	jgu ispath_false
0100+  1549 B9 7A       	cmp al, 'z'
0101+  154B D0 57 15    	jleu ispath_true
0102+  154E B9 61       	cmp al, 'a'
0103+  1550 C9 57 15    	jgeu ispath_true
0104+  1553             ispath_false:
0105+  1553 8B 01       	or al, 1	; clear zf
0106+  1555 E8          	pop al
0107+  1556 09          	ret
0108+  1557             ispath_true:
0109+  1557 87 00       	and al, 0	; set zf
0110+  1559 E8          	pop al
0111+  155A 09          	ret
0112+  155B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  155B             ;; is space
0114+  155B             ;; sets zf according with result
0115+  155B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  155B             _isspace:
0117+  155B B9 20       	cmp al, $20		; ' '
0118+  155D C6 71 15    	je _isspace_exit
0119+  1560 B9 09       	cmp al, $09		; '\t'
0120+  1562 C6 71 15    	je _isspace_exit
0121+  1565 B9 0A       	cmp al, $0a		; '\n'
0122+  1567 C6 71 15    	je _isspace_exit
0123+  156A B9 0D       	cmp al, $0d		; '\r'
0124+  156C C6 71 15    	je _isspace_exit
0125+  156F B9 0B       	cmp al, $0b		; '\v'
0126+  1571             _isspace_exit:
0127+  1571 09          	ret	
0128+  1572             
0129+  1572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1572             ; to lower
0131+  1572             ; input in al
0132+  1572             ; output in al
0133+  1572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1572             _to_lower:
0135+  1572 B9 7A       	cmp al, 'z'
0136+  1574 D1 79 15    	jgu _to_lower_ret
0137+  1577 6A 20       	add al, $20				; convert to lower case
0138+  1579             _to_lower_ret:
0139+  1579 09          	ret
0140+  157A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  157A             ; to upper
0142+  157A             ; input in al
0143+  157A             ; output in al
0144+  157A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  157A             _to_upper:
0146+  157A B9 61       	cmp al, 'a'
0147+  157C C8 81 15    	jlu _to_upper_ret
0148+  157F 6F 20       	sub al, $20			; convert to upper case
0149+  1581             _to_upper_ret:
0150+  1581 09          	ret
0151+  1582             
2990   1582             .include "lib/token.asm"
0001+  1582             toktyp_identifier  .equ 0
0002+  1582             toktyp_keyword     .equ 1
0003+  1582             toktyp_delimiter   .equ 2
0004+  1582             toktyp_string      .equ 3
0005+  1582             toktyp_char        .equ 4
0006+  1582             toktyp_numeric     .equ 5
0007+  1582             toktyp_end         .equ 6
0008+  1582             
0009+  1582             tok_null           .equ 0
0010+  1582             tok_fslash         .equ 1
0011+  1582             tok_times          .equ 2
0012+  1582             tok_plus           .equ 3
0013+  1582             tok_minus          .equ 4
0014+  1582             tok_dot            .equ 5
0015+  1582             tok_semi           .equ 6
0016+  1582             tok_angle          .equ 7
0017+  1582             tok_tilde          .equ 8
0018+  1582             tok_equal          .equ 9
0019+  1582             tok_colon          .equ 10
0020+  1582             tok_comma          .equ 11
0021+  1582             
0022+  1582             tok_end            .equ 20
0023+  1582             
0024+  1582             
0025+  1582             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1582             ;; read a full command argment from shell input buffer
0027+  1582             ;; argument is written into tokstr
0028+  1582             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1582             get_arg:
0030+  1582 D7            push a
0031+  1583 E2            push si
0032+  1584 E3            push di
0033+  1585 19 00         mov al, 0
0034+  1587 3D B0 17      mov [tokstr], al      ; nullify tokstr string
0035+  158A 14 AC 17      mov a, [prog]
0036+  158D 4D            mov si, a
0037+  158E FD 4F B0 17   mov di, tokstr
0038+  1592             get_arg_skip_spaces:
0039+  1592 F6            lodsb
0040+  1593 07 5B 15      call _isspace
0041+  1596 C6 92 15      je get_arg_skip_spaces
0042+  1599             get_arg_l0:
0043+  1599 B9 3B         cmp al, $3b        ; check if is ';'
0044+  159B C6 A8 15      je get_arg_end
0045+  159E B9 00         cmp al, 0
0046+  15A0 C6 A8 15      je get_arg_end      ; check if end of input
0047+  15A3 F7            stosb
0048+  15A4 F6            lodsb
0049+  15A5 0A 99 15      jmp get_arg_l0
0050+  15A8             get_arg_end:
0051+  15A8 19 00         mov al, 0
0052+  15AA F7            stosb
0053+  15AB D5 01 00      sub si, 1
0054+  15AE 4E            mov a, si
0055+  15AF 42 AC 17      mov [prog], a    ; update pointer
0056+  15B2 F0            pop di
0057+  15B3 EF            pop si
0058+  15B4 E4            pop a
0059+  15B5 09            ret
0060+  15B6             
0061+  15B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  15B6             ;; read a path formation from shell input buffer
0063+  15B6             ;; path is written into tokstr
0064+  15B6             ;; /usr/bin
0065+  15B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  15B6             get_path:
0067+  15B6 D7            push a
0068+  15B7 E2            push si
0069+  15B8 E3            push di
0070+  15B9 19 00         mov al, 0
0071+  15BB 3D B0 17      mov [tokstr], al      ; nullify tokstr string
0072+  15BE 14 AC 17      mov a, [prog]
0073+  15C1 4D            mov si, a
0074+  15C2 FD 4F B0 17   mov di, tokstr
0075+  15C6             get_path_skip_spaces:
0076+  15C6 F6            lodsb
0077+  15C7 07 5B 15      call _isspace
0078+  15CA C6 C6 15      je get_path_skip_spaces
0079+  15CD             get_path_is_pathchar:
0080+  15CD F7            stosb
0081+  15CE F6            lodsb
0082+  15CF 07 E5 14      call _isalnum      ;check if is alphanumeric
0083+  15D2 C6 CD 15      je get_path_is_pathchar
0084+  15D5 B9 2F         cmp al, '/'        ; check if is '/'
0085+  15D7 C6 CD 15      je get_path_is_pathchar
0086+  15DA 19 00         mov al, 0
0087+  15DC F7            stosb
0088+  15DD D5 01 00      sub si, 1
0089+  15E0 4E            mov a, si
0090+  15E1 42 AC 17      mov [prog], a    ; update pointer
0091+  15E4             get_path_end:
0092+  15E4 F0            pop di
0093+  15E5 EF            pop si
0094+  15E6 E4            pop a
0095+  15E7 09            ret
0096+  15E8             
0097+  15E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  15E8             ;; read a line
0099+  15E8             ;; line is written into tokstr
0100+  15E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  15E8             get_line:
0102+  15E8 D7            push a
0103+  15E9 E2            push si
0104+  15EA E3            push di
0105+  15EB 19 00         mov al, 0
0106+  15ED 3D B0 17      mov [tokstr], al      ; nullify tokstr string
0107+  15F0 14 AC 17      mov a, [prog]
0108+  15F3 4D            mov si, a
0109+  15F4 FD 4F B0 17   mov di, tokstr
0110+  15F8             get_line_l0:
0111+  15F8 F6            lodsb
0112+  15F9 B9 0A         cmp al, $0a    ; check for new line
0113+  15FB C6 02 16      je get_line_exit
0114+  15FE F7            stosb
0115+  15FF 0A F8 15      jmp get_line_l0
0116+  1602             get_line_exit:
0117+  1602 19 00         mov al, 0
0118+  1604 F7            stosb
0119+  1605 4E            mov a, si
0120+  1606 42 AC 17      mov [prog], a    ; update pointer
0121+  1609 F0            pop di
0122+  160A EF            pop si
0123+  160B E4            pop a
0124+  160C 09            ret
0125+  160D             
0126+  160D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  160D             ;; token parser
0128+  160D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  160D             get_token:
0130+  160D D7            push a
0131+  160E DA            push d
0132+  160F E2            push si
0133+  1610 E3            push di
0134+  1611 19 00         mov al, 0
0135+  1613 3D B0 17      mov [tokstr], al      ; nullify tokstr string
0136+  1616 19 00         mov al, tok_null
0137+  1618 3D AF 17      mov [tok], al        ; nullify token
0138+  161B 14 AC 17      mov a, [prog]
0139+  161E 4D            mov si, a
0140+  161F FD 4F B0 17   mov di, tokstr
0141+  1623             get_tok_skip_spaces:
0142+  1623 F6            lodsb
0143+  1624 07 5B 15      call _isspace
0144+  1627 C6 23 16      je get_tok_skip_spaces
0145+  162A B9 00         cmp al, 0      ; check for end of input (null)
0146+  162C C6 11 17      je get_token_end
0147+  162F B9 23         cmp al, '#'      ; comments!
0148+  1631 C6 3F 17      je get_tok_comment
0149+  1634 07 E5 14      call _isalnum
0150+  1637 C6 1E 17      jz is_alphanumeric
0151+  163A             ; other token types
0152+  163A             get_token_slash:
0153+  163A B9 2F         cmp al, '/'        ; check if '/'
0154+  163C C7 54 16      jne get_token_minus
0155+  163F F7            stosb          ; store '/' into token string
0156+  1640 19 00         mov al, 0
0157+  1642 F7            stosb          ; terminate token string
0158+  1643 19 01         mov al, tok_fslash
0159+  1645 3D AF 17      mov [tok], al      
0160+  1648 19 02         mov al, toktyp_delimiter
0161+  164A 3D AE 17      mov [toktyp], al
0162+  164D 4E            mov a, si
0163+  164E 42 AC 17      mov [prog], a    ; update pointer
0164+  1651 0A 3A 17      jmp get_token_return
0165+  1654             get_token_minus:
0166+  1654 B9 2D         cmp al, '-'        ; check if '-'
0167+  1656 C7 6E 16      jne get_token_comma
0168+  1659 F7            stosb          ; store '-' into token string
0169+  165A 19 00         mov al, 0
0170+  165C F7            stosb          ; terminate token string
0171+  165D 19 04         mov al, tok_minus
0172+  165F 3D AF 17      mov [tok], al      
0173+  1662 19 02         mov al, toktyp_delimiter
0174+  1664 3D AE 17      mov [toktyp], al
0175+  1667 4E            mov a, si
0176+  1668 42 AC 17      mov [prog], a    ; update pointer
0177+  166B 0A 3A 17      jmp get_token_return
0178+  166E             get_token_comma:
0179+  166E B9 2C         cmp al, ','        ; check if ','
0180+  1670 C7 88 16      jne get_token_semi
0181+  1673 F7            stosb          ; store ',' into token string
0182+  1674 19 00         mov al, 0
0183+  1676 F7            stosb          ; terminate token string
0184+  1677 19 0B         mov al, tok_comma
0185+  1679 3D AF 17      mov [tok], al      
0186+  167C 19 02         mov al, toktyp_delimiter
0187+  167E 3D AE 17      mov [toktyp], al
0188+  1681 4E            mov a, si
0189+  1682 42 AC 17      mov [prog], a    ; update pointer
0190+  1685 0A 3A 17      jmp get_token_return
0191+  1688             get_token_semi:
0192+  1688 B9 3B         cmp al, $3b        ; check if ';'
0193+  168A C7 A2 16      jne get_token_colon
0194+  168D F7            stosb          ; store ';' into token string
0195+  168E 19 00         mov al, 0
0196+  1690 F7            stosb          ; terminate token string
0197+  1691 19 06         mov al, tok_semi
0198+  1693 3D AF 17      mov [tok], al      
0199+  1696 19 02         mov al, toktyp_delimiter
0200+  1698 3D AE 17      mov [toktyp], al
0201+  169B 4E            mov a, si
0202+  169C 42 AC 17      mov [prog], a    ; update pointer
0203+  169F 0A 3A 17      jmp get_token_return
0204+  16A2             get_token_colon:
0205+  16A2 B9 3A         cmp al, $3a        ; check if ':'
0206+  16A4 C7 BC 16      jne get_token_angle
0207+  16A7 F7            stosb          ; store ':' into token string
0208+  16A8 19 00         mov al, 0
0209+  16AA F7            stosb          ; terminate token string
0210+  16AB 19 0A         mov al, tok_colon
0211+  16AD 3D AF 17      mov [tok], al      
0212+  16B0 19 02         mov al, toktyp_delimiter
0213+  16B2 3D AE 17      mov [toktyp], al
0214+  16B5 4E            mov a, si
0215+  16B6 42 AC 17      mov [prog], a    ; update pointer
0216+  16B9 0A 3A 17      jmp get_token_return
0217+  16BC             get_token_angle:
0218+  16BC B9 3E         cmp al, $3e        ; check if '>'
0219+  16BE C7 D6 16      jne get_token_tilde
0220+  16C1 F7            stosb          ; store '>' into token string
0221+  16C2 19 00         mov al, 0
0222+  16C4 F7            stosb          ; terminate token string
0223+  16C5 19 07         mov al, tok_angle
0224+  16C7 3D AF 17      mov [tok], al      
0225+  16CA 19 02         mov al, toktyp_delimiter
0226+  16CC 3D AE 17      mov [toktyp], al
0227+  16CF 4E            mov a, si
0228+  16D0 42 AC 17      mov [prog], a    ; update pointer
0229+  16D3 0A 3A 17      jmp get_token_return
0230+  16D6             get_token_tilde:
0231+  16D6 B9 7E         cmp al, '~'        ; check if '~'
0232+  16D8 C7 F0 16      jne get_token_equal
0233+  16DB F7            stosb          ; store '~' into token string
0234+  16DC 19 00         mov al, 0
0235+  16DE F7            stosb          ; terminate token string
0236+  16DF 19 08         mov al, tok_tilde
0237+  16E1 3D AF 17      mov [tok], al      
0238+  16E4 19 02         mov al, toktyp_delimiter
0239+  16E6 3D AE 17      mov [toktyp], al
0240+  16E9 4E            mov a, si
0241+  16EA 42 AC 17      mov [prog], a    ; update pointer
0242+  16ED 0A 3A 17      jmp get_token_return
0243+  16F0             get_token_equal:
0244+  16F0 B9 3D         cmp al, '='        ; check if '='
0245+  16F2 C7 0A 17      jne get_token_skip
0246+  16F5 F7            stosb          ; store '=' into token string
0247+  16F6 19 00         mov al, 0
0248+  16F8 F7            stosb          ; terminate token string
0249+  16F9 19 09         mov al, tok_equal
0250+  16FB 3D AF 17      mov [tok], al      
0251+  16FE 19 02         mov al, toktyp_delimiter
0252+  1700 3D AE 17      mov [toktyp], al
0253+  1703 4E            mov a, si
0254+  1704 42 AC 17      mov [prog], a    ; update pointer
0255+  1707 0A 3A 17      jmp get_token_return
0256+  170A             get_token_skip:
0257+  170A 4E            mov a, si
0258+  170B 42 AC 17      mov [prog], a    ; update pointer
0259+  170E 0A 3A 17      jmp get_token_return
0260+  1711             get_token_end:        ; end of file token
0261+  1711 19 14         mov al, tok_end
0262+  1713 3D AF 17      mov [tok], al
0263+  1716 19 06         mov al, toktyp_end
0264+  1718 3D AE 17      mov [toktyp], al
0265+  171B 0A 3A 17      jmp get_token_return
0266+  171E             is_alphanumeric:
0267+  171E F7            stosb
0268+  171F F6            lodsb
0269+  1720 07 E5 14      call _isalnum      ;check if is alphanumeric
0270+  1723 C6 1E 17      jz is_alphanumeric
0271+  1726 B9 2E         cmp al, $2e        ; check if is '.'
0272+  1728 C6 1E 17      je is_alphanumeric
0273+  172B 19 00         mov al, 0
0274+  172D F7            stosb
0275+  172E 19 00         mov al, toktyp_identifier
0276+  1730 3D AE 17      mov [toktyp], al
0277+  1733 D5 01 00      sub si, 1
0278+  1736 4E            mov a, si
0279+  1737 42 AC 17      mov [prog], a    ; update pointer
0280+  173A             get_token_return:
0281+  173A F0            pop di
0282+  173B EF            pop si
0283+  173C E7            pop d
0284+  173D E4            pop a
0285+  173E 09            ret
0286+  173F             get_tok_comment:
0287+  173F F6            lodsb
0288+  1740 B9 0A         cmp al, $0a      ; new line
0289+  1742 C7 3F 17      jne get_tok_comment
0290+  1745 0A 23 16      jmp get_tok_skip_spaces
0291+  1748             
0292+  1748             
0293+  1748             get_number:
0294+  1748 D7            push a
0295+  1749 DA            push d
0296+  174A E2            push si
0297+  174B E3            push di
0298+  174C 19 00         mov al, 0
0299+  174E 3D B0 17      mov [tokstr], al      ; nullify tokstr string
0300+  1751 19 00         mov al, tok_null
0301+  1753 3D AF 17      mov [tok], al        ; nullify token
0302+  1756 14 AC 17      mov a, [prog]
0303+  1759 4D            mov si, a
0304+  175A FD 4F B0 17   mov di, tokstr
0305+  175E             get_number_skip_spaces:
0306+  175E F6            lodsb
0307+  175F 07 5B 15      call _isspace
0308+  1762 C6 5E 17      je get_number_skip_spaces
0309+  1765 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1767 C7 77 17      jne get_number_l0
0311+  176A 19 14         mov al, tok_end
0312+  176C 3D AF 17      mov [tok], al
0313+  176F 19 06         mov al, toktyp_end
0314+  1771 3D AE 17      mov [toktyp], al
0315+  1774 0A 8E 17      jmp get_number_return
0316+  1777             get_number_l0:
0317+  1777 F7            stosb
0318+  1778 F6            lodsb
0319+  1779 07 EF 14      call _isdigit      ;check if is numeric
0320+  177C C6 77 17      jz get_number_l0
0321+  177F 19 00         mov al, 0
0322+  1781 F7            stosb
0323+  1782 19 05         mov al, toktyp_numeric
0324+  1784 3D AE 17      mov [toktyp], al
0325+  1787 D5 01 00      sub si, 1
0326+  178A 4E            mov a, si
0327+  178B 42 AC 17      mov [prog], a    ; update pointer
0328+  178E             get_number_return:
0329+  178E F0            pop di
0330+  178F EF            pop si
0331+  1790 E7            pop d
0332+  1791 E4            pop a
0333+  1792 09            ret
0334+  1793             
0335+  1793             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1793             ;; put back token
0337+  1793             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1793             _putback:
0339+  1793 D7            push a
0340+  1794 E2            push si
0341+  1795 FD 4D B0 17   mov si, tokstr  
0342+  1799             _putback_loop:
0343+  1799 F6            lodsb
0344+  179A B9 00         cmp al, 0
0345+  179C C6 A9 17      je _putback_end
0346+  179F 14 AC 17      mov a, [prog]
0347+  17A2 7D            dec a
0348+  17A3 42 AC 17      mov [prog], a      ; update pointer
0349+  17A6 0A 99 17      jmp _putback_loop
0350+  17A9             _putback_end:
0351+  17A9 EF            pop si
0352+  17AA E4            pop a
0353+  17AB 09            ret
0354+  17AC             
0355+  17AC             
0356+  17AC             
0357+  17AC             
0358+  17AC 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  17AE             
0360+  17AE 00          toktyp:    .db 0          ; token type symbol
0361+  17AF 00          tok:       .db 0          ; current token symbol
0362+  17B0 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  17B4 00 00 00 00 
0362+  17B8 00 00 00 00 
0362+  17BC 00 00 00 00 
0362+  17C0 00 00 00 00 
0362+  17C4 00 00 00 00 
0362+  17C8 00 00 00 00 
0362+  17CC 00 00 00 00 
0362+  17D0 00 00 00 00 
0362+  17D4 00 00 00 00 
0362+  17D8 00 00 00 00 
0362+  17DC 00 00 00 00 
0362+  17E0 00 00 00 00 
0362+  17E4 00 00 00 00 
0362+  17E8 00 00 00 00 
0362+  17EC 00 00 00 00 
0362+  17F0 00 00 00 00 
0362+  17F4 00 00 00 00 
0362+  17F8 00 00 00 00 
0362+  17FC 00 00 00 00 
0362+  1800 00 00 00 00 
0362+  1804 00 00 00 00 
0362+  1808 00 00 00 00 
0362+  180C 00 00 00 00 
0362+  1810 00 00 00 00 
0362+  1814 00 00 00 00 
0362+  1818 00 00 00 00 
0362+  181C 00 00 00 00 
0362+  1820 00 00 00 00 
0362+  1824 00 00 00 00 
0362+  1828 00 00 00 00 
0362+  182C 00 00 00 00 
0362+  1830 00 00 00 00 
0362+  1834 00 00 00 00 
0362+  1838 00 00 00 00 
0362+  183C 00 00 00 00 
0362+  1840 00 00 00 00 
0362+  1844 00 00 00 00 
0362+  1848 00 00 00 00 
0362+  184C 00 00 00 00 
0362+  1850 00 00 00 00 
0362+  1854 00 00 00 00 
0362+  1858 00 00 00 00 
0362+  185C 00 00 00 00 
0362+  1860 00 00 00 00 
0362+  1864 00 00 00 00 
0362+  1868 00 00 00 00 
0362+  186C 00 00 00 00 
0362+  1870 00 00 00 00 
0362+  1874 00 00 00 00 
0362+  1878 00 00 00 00 
0362+  187C 00 00 00 00 
0362+  1880 00 00 00 00 
0362+  1884 00 00 00 00 
0362+  1888 00 00 00 00 
0362+  188C 00 00 00 00 
0362+  1890 00 00 00 00 
0362+  1894 00 00 00 00 
0362+  1898 00 00 00 00 
0362+  189C 00 00 00 00 
0362+  18A0 00 00 00 00 
0362+  18A4 00 00 00 00 
0362+  18A8 00 00 00 00 
0362+  18AC 00 00 00 00 
2991   18B0             
2992   18B0             ; kernel parameters
2993   18B0             sys_debug_mode:
2994   18B0 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2995   18B1             sys_echo_on:
2996   18B1 01            .db 1
2997   18B2             sys_uart0_lcr:
2998   18B2 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2999   18B3             sys_uart0_inten:
3000   18B3 01            .db 1
3001   18B4             sys_uart0_fifoen:
3002   18B4 00            .db 0
3003   18B5             sys_uart0_div0:
3004   18B5 03            .db 3
3005   18B6             sys_uart0_div1:
3006   18B6 00            .db 0   ; default baud = 38400
3007   18B7             ; baud  divisor
3008   18B7             ; 50    2304
3009   18B7             ; 110   1047
3010   18B7             ; 300    384
3011   18B7             ; 600    192
3012   18B7             ; 1200    96
3013   18B7             ; 9600    12
3014   18B7             ; 19200    6
3015   18B7             ; 38400    3
3016   18B7             
3017   18B7             nbr_active_procs:
3018   18B7 00            .db 0
3019   18B8             active_proc_index:
3020   18B8 01            .db 1
3021   18B9             
3022   18B9             index:
3023   18B9 00 00         .dw 0
3024   18BB             buffer_addr:
3025   18BB 00 00         .dw 0
3026   18BD             
3027   18BD             fifo_in:
3028   18BD 1E 20         .dw fifo
3029   18BF             fifo_out:
3030   18BF 1E 20         .dw fifo
3031   18C1             
3032   18C1             ; file system variables
3033   18C1             current_dir_id:
3034   18C1 00 00         .dw 0     ; keep dirid of current directory
3035   18C3             s_init_path:
3036   18C3 2F 73 62 69   .db "/sbin/init", 0
3036   18C7 6E 2F 69 6E 
3036   18CB 69 74 00 
3037   18CE             
3038   18CE             s_uname:
3039   18CE 73 6F 6C 61   .db "solarium v.1.0", 0
3039   18D2 72 69 75 6D 
3039   18D6 20 76 2E 31 
3039   18DA 2E 30 00 
3040   18DD             s_dataentry:
3041   18DD 3E 20 00      .db "> ", 0
3042   18E0             s_parent_dir:
3043   18E0 2E 2E 00      .db "..", 0
3044   18E3             s_current_dir:
3045   18E3 2E 00         .db ".", 0
3046   18E5             s_fslash:
3047   18E5 2F 00         .db "/", 0
3048   18E7             file_attrib:
3049   18E7 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
3049   18EB 78 
3050   18EC             file_type:
3051   18EC 2D 64 63      .db "-dc"
3052   18EF             s_ps_header:
3053   18EF 70 69 64 20   .db "pid command\n", 0
3053   18F3 63 6F 6D 6D 
3053   18F7 61 6E 64 0A 
3053   18FB 00 
3054   18FC             s_ls_total:
3055   18FC 74 6F 74 61   .db "total: ", 0
3055   1900 6C 3A 20 00 
3056   1904             
3057   1904             s_int_en:
3058   1904 69 72 71 73   .db "irqs enabled\n", 0
3058   1908 20 65 6E 61 
3058   190C 62 6C 65 64 
3058   1910 0A 00 
3059   1912             s_kernel_started:
3060   1912 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
3060   1916 65 6C 20 73 
3060   191A 74 61 72 74 
3060   191E 65 64 28 76 
3060   1922 65 72 73 69 
3060   1926 6F 6E 20 31 
3060   192A 2E 30 29 0A 
3060   192E 00 
3061   192F             s_prompt_init:
3062   192F 73 74 61 72   .db "starting init\n", 0
3062   1933 74 69 6E 67 
3062   1937 20 69 6E 69 
3062   193B 74 0A 00 
3063   193E             s_priviledge:
3064   193E 0A 65 78 63   .db "\nexception: privilege\n", 0
3064   1942 65 70 74 69 
3064   1946 6F 6E 3A 20 
3064   194A 70 72 69 76 
3064   194E 69 6C 65 67 
3064   1952 65 0A 00 
3065   1955             s_divzero:
3066   1955 0A 65 78 63   .db "\nexception: zero division\n", 0
3066   1959 65 70 74 69 
3066   195D 6F 6E 3A 20 
3066   1961 7A 65 72 6F 
3066   1965 20 64 69 76 
3066   1969 69 73 69 6F 
3066   196D 6E 0A 00 
3067   1970             
3068   1970             s_set_year:
3069   1970 79 65 61 72   .db "year: ", 0
3069   1974 3A 20 00 
3070   1977             s_set_month:
3071   1977 6D 6F 6E 74   .db "month: ", 0
3071   197B 68 3A 20 00 
3072   197F             s_set_day:
3073   197F 64 61 79 3A   .db "day: ", 0
3073   1983 20 00 
3074   1985             s_set_week:
3075   1985 77 65 65 6B   .db "weekday: ", 0
3075   1989 64 61 79 3A 
3075   198D 20 00 
3076   198F             s_set_hours:
3077   198F 68 6F 75 72   .db "hours: ", 0
3077   1993 73 3A 20 00 
3078   1997             s_set_minutes:
3079   1997 6D 69 6E 75   .db "minutes: ", 0
3079   199B 74 65 73 3A 
3079   199F 20 00 
3080   19A1             s_set_seconds:
3081   19A1 73 65 63 6F   .db "seconds: ", 0
3081   19A5 6E 64 73 3A 
3081   19A9 20 00 
3082   19AB             s_months:      
3083   19AB 20 20 20 00   .db "   ", 0
3084   19AF 6A 61 6E 00   .db "jan", 0
3085   19B3 66 65 62 00   .db "feb", 0
3086   19B7 6D 61 72 00   .db "mar", 0
3087   19BB 61 70 72 00   .db "apr", 0
3088   19BF 6D 61 79 00   .db "may", 0
3089   19C3 6A 75 6E 00   .db "jun", 0
3090   19C7 6A 75 6C 00   .db "jul", 0
3091   19CB 61 75 67 00   .db "aug", 0
3092   19CF 73 65 70 00   .db "sep", 0
3093   19D3 6F 63 74 00   .db "oct", 0
3094   19D7 6E 6F 76 00   .db "nov", 0
3095   19DB 64 65 63 00   .db "dec", 0
3096   19DF             
3097   19DF             s_week:        
3098   19DF 73 75 6E 00   .db "sun", 0 
3099   19E3 6D 6F 6E 00   .db "mon", 0 
3100   19E7 74 75 65 00   .db "tue", 0 
3101   19EB 77 65 64 00   .db "wed", 0 
3102   19EF 74 68 75 00   .db "thu", 0 
3103   19F3 66 72 69 00   .db "fri", 0 
3104   19F7 73 61 74 00   .db "sat", 0
3105   19FB             
3106   19FB 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
3106   19FF 30 20 45 78 
3106   1A03 65 63 75 74 
3106   1A07 65 64 2E 0A 
3106   1A0B 00 
3107   1A0C             s_fdc_config:
3108   1A0C 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
3108   1A10 65 63 74 69 
3108   1A14 6E 67 20 64 
3108   1A18 69 73 6B 65 
3108   1A1C 74 74 65 20 
3108   1A20 64 72 69 76 
3108   1A24 65 20 30 2C 
3108   1A28 20 73 69 64 
3108   1A2C 65 20 30 2C 
3108   1A30 20 73 69 6E 
3108   1A34 67 6C 65 20 
3108   1A38 64 65 6E 73 
3108   1A3C 69 74 79 2C 
3108   1A40 20 68 65 61 
3108   1A44 64 20 6C 6F 
3108   1A48 61 64 65 64 
3108   1A4C 0A 00 
3109   1A4E             
3110   1A4E             proc_state_table:   
3111   1A4E 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
3111   1A52 00 00 00 00 
3111   1A56 00 00 00 00 
3111   1A5A 00 00 00 00 
3111   1A5E 00 00 00 00 
3111   1A62 00 00 00 00 
3111   1A66 00 00 00 00 
3111   1A6A 00 00 00 00 
3111   1A6E 00 00 00 00 
3111   1A72 00 00 00 00 
3111   1A76 00 00 00 00 
3111   1A7A 00 00 00 00 
3111   1A7E 00 00 00 00 
3111   1A82 00 00 00 00 
3111   1A86 00 00 00 00 
3111   1A8A 00 00 00 00 
3111   1A8E 00 00 00 00 
3111   1A92 00 00 00 00 
3111   1A96 00 00 00 00 
3111   1A9A 00 00 00 00 
3111   1A9E 00 00 00 00 
3111   1AA2 00 00 00 00 
3111   1AA6 00 00 00 00 
3111   1AAA 00 00 00 00 
3111   1AAE 00 00 00 00 
3111   1AB2 00 00 00 00 
3111   1AB6 00 00 00 00 
3111   1ABA 00 00 00 00 
3111   1ABE 00 00 00 00 
3111   1AC2 00 00 00 00 
3111   1AC6 00 00 00 00 
3111   1ACA 00 00 00 00 
3111   1ACE 00 00 00 00 
3111   1AD2 00 00 00 00 
3111   1AD6 00 00 00 00 
3111   1ADA 00 00 00 00 
3111   1ADE 00 00 00 00 
3111   1AE2 00 00 00 00 
3111   1AE6 00 00 00 00 
3111   1AEA 00 00 00 00 
3111   1AEE 00 00 00 00 
3111   1AF2 00 00 00 00 
3111   1AF6 00 00 00 00 
3111   1AFA 00 00 00 00 
3111   1AFE 00 00 00 00 
3111   1B02 00 00 00 00 
3111   1B06 00 00 00 00 
3111   1B0A 00 00 00 00 
3111   1B0E 00 00 00 00 
3111   1B12 00 00 00 00 
3111   1B16 00 00 00 00 
3111   1B1A 00 00 00 00 
3111   1B1E 00 00 00 00 
3111   1B22 00 00 00 00 
3111   1B26 00 00 00 00 
3111   1B2A 00 00 00 00 
3111   1B2E 00 00 00 00 
3111   1B32 00 00 00 00 
3111   1B36 00 00 00 00 
3111   1B3A 00 00 00 00 
3111   1B3E 00 00 00 00 
3111   1B42 00 00 00 00 
3111   1B46 00 00 00 00 
3111   1B4A 00 00 00 00 
3111   1B4E 00 00 00 00 
3111   1B52 00 00 00 00 
3111   1B56 00 00 00 00 
3111   1B5A 00 00 00 00 
3111   1B5E 00 00 00 00 
3111   1B62 00 00 00 00 
3111   1B66 00 00 00 00 
3111   1B6A 00 00 00 00 
3111   1B6E 00 00 00 00 
3111   1B72 00 00 00 00 
3111   1B76 00 00 00 00 
3111   1B7A 00 00 00 00 
3111   1B7E 00 00 00 00 
3111   1B82 00 00 00 00 
3111   1B86 00 00 00 00 
3111   1B8A 00 00 00 00 
3112   1B8E             proc_availab_table: 
3113   1B8E 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
3113   1B92 00 00 00 00 
3113   1B96 00 00 00 00 
3113   1B9A 00 00 00 00 
3114   1B9E             proc_names:
3115   1B9E 00 00 00 00   .fill 16 * 32, 0  ; process names
3115   1BA2 00 00 00 00 
3115   1BA6 00 00 00 00 
3115   1BAA 00 00 00 00 
3115   1BAE 00 00 00 00 
3115   1BB2 00 00 00 00 
3115   1BB6 00 00 00 00 
3115   1BBA 00 00 00 00 
3115   1BBE 00 00 00 00 
3115   1BC2 00 00 00 00 
3115   1BC6 00 00 00 00 
3115   1BCA 00 00 00 00 
3115   1BCE 00 00 00 00 
3115   1BD2 00 00 00 00 
3115   1BD6 00 00 00 00 
3115   1BDA 00 00 00 00 
3115   1BDE 00 00 00 00 
3115   1BE2 00 00 00 00 
3115   1BE6 00 00 00 00 
3115   1BEA 00 00 00 00 
3115   1BEE 00 00 00 00 
3115   1BF2 00 00 00 00 
3115   1BF6 00 00 00 00 
3115   1BFA 00 00 00 00 
3115   1BFE 00 00 00 00 
3115   1C02 00 00 00 00 
3115   1C06 00 00 00 00 
3115   1C0A 00 00 00 00 
3115   1C0E 00 00 00 00 
3115   1C12 00 00 00 00 
3115   1C16 00 00 00 00 
3115   1C1A 00 00 00 00 
3115   1C1E 00 00 00 00 
3115   1C22 00 00 00 00 
3115   1C26 00 00 00 00 
3115   1C2A 00 00 00 00 
3115   1C2E 00 00 00 00 
3115   1C32 00 00 00 00 
3115   1C36 00 00 00 00 
3115   1C3A 00 00 00 00 
3115   1C3E 00 00 00 00 
3115   1C42 00 00 00 00 
3115   1C46 00 00 00 00 
3115   1C4A 00 00 00 00 
3115   1C4E 00 00 00 00 
3115   1C52 00 00 00 00 
3115   1C56 00 00 00 00 
3115   1C5A 00 00 00 00 
3115   1C5E 00 00 00 00 
3115   1C62 00 00 00 00 
3115   1C66 00 00 00 00 
3115   1C6A 00 00 00 00 
3115   1C6E 00 00 00 00 
3115   1C72 00 00 00 00 
3115   1C76 00 00 00 00 
3115   1C7A 00 00 00 00 
3115   1C7E 00 00 00 00 
3115   1C82 00 00 00 00 
3115   1C86 00 00 00 00 
3115   1C8A 00 00 00 00 
3115   1C8E 00 00 00 00 
3115   1C92 00 00 00 00 
3115   1C96 00 00 00 00 
3115   1C9A 00 00 00 00 
3115   1C9E 00 00 00 00 
3115   1CA2 00 00 00 00 
3115   1CA6 00 00 00 00 
3115   1CAA 00 00 00 00 
3115   1CAE 00 00 00 00 
3115   1CB2 00 00 00 00 
3115   1CB6 00 00 00 00 
3115   1CBA 00 00 00 00 
3115   1CBE 00 00 00 00 
3115   1CC2 00 00 00 00 
3115   1CC6 00 00 00 00 
3115   1CCA 00 00 00 00 
3115   1CCE 00 00 00 00 
3115   1CD2 00 00 00 00 
3115   1CD6 00 00 00 00 
3115   1CDA 00 00 00 00 
3115   1CDE 00 00 00 00 
3115   1CE2 00 00 00 00 
3115   1CE6 00 00 00 00 
3115   1CEA 00 00 00 00 
3115   1CEE 00 00 00 00 
3115   1CF2 00 00 00 00 
3115   1CF6 00 00 00 00 
3115   1CFA 00 00 00 00 
3115   1CFE 00 00 00 00 
3115   1D02 00 00 00 00 
3115   1D06 00 00 00 00 
3115   1D0A 00 00 00 00 
3115   1D0E 00 00 00 00 
3115   1D12 00 00 00 00 
3115   1D16 00 00 00 00 
3115   1D1A 00 00 00 00 
3115   1D1E 00 00 00 00 
3115   1D22 00 00 00 00 
3115   1D26 00 00 00 00 
3115   1D2A 00 00 00 00 
3115   1D2E 00 00 00 00 
3115   1D32 00 00 00 00 
3115   1D36 00 00 00 00 
3115   1D3A 00 00 00 00 
3115   1D3E 00 00 00 00 
3115   1D42 00 00 00 00 
3115   1D46 00 00 00 00 
3115   1D4A 00 00 00 00 
3115   1D4E 00 00 00 00 
3115   1D52 00 00 00 00 
3115   1D56 00 00 00 00 
3115   1D5A 00 00 00 00 
3115   1D5E 00 00 00 00 
3115   1D62 00 00 00 00 
3115   1D66 00 00 00 00 
3115   1D6A 00 00 00 00 
3115   1D6E 00 00 00 00 
3115   1D72 00 00 00 00 
3115   1D76 00 00 00 00 
3115   1D7A 00 00 00 00 
3115   1D7E 00 00 00 00 
3115   1D82 00 00 00 00 
3115   1D86 00 00 00 00 
3115   1D8A 00 00 00 00 
3115   1D8E 00 00 00 00 
3115   1D92 00 00 00 00 
3115   1D96 00 00 00 00 
3115   1D9A 00 00 00 00 
3116   1D9E             filename:
3117   1D9E 00 00 00 00   .fill 128, 0      ; holds a path for file search
3117   1DA2 00 00 00 00 
3117   1DA6 00 00 00 00 
3117   1DAA 00 00 00 00 
3117   1DAE 00 00 00 00 
3117   1DB2 00 00 00 00 
3117   1DB6 00 00 00 00 
3117   1DBA 00 00 00 00 
3117   1DBE 00 00 00 00 
3117   1DC2 00 00 00 00 
3117   1DC6 00 00 00 00 
3117   1DCA 00 00 00 00 
3117   1DCE 00 00 00 00 
3117   1DD2 00 00 00 00 
3117   1DD6 00 00 00 00 
3117   1DDA 00 00 00 00 
3117   1DDE 00 00 00 00 
3117   1DE2 00 00 00 00 
3117   1DE6 00 00 00 00 
3117   1DEA 00 00 00 00 
3117   1DEE 00 00 00 00 
3117   1DF2 00 00 00 00 
3117   1DF6 00 00 00 00 
3117   1DFA 00 00 00 00 
3117   1DFE 00 00 00 00 
3117   1E02 00 00 00 00 
3117   1E06 00 00 00 00 
3117   1E0A 00 00 00 00 
3117   1E0E 00 00 00 00 
3117   1E12 00 00 00 00 
3117   1E16 00 00 00 00 
3117   1E1A 00 00 00 00 
3118   1E1E             user_data:
3119   1E1E 00 00 00 00   .fill 512, 0      ;  user space data
3119   1E22 00 00 00 00 
3119   1E26 00 00 00 00 
3119   1E2A 00 00 00 00 
3119   1E2E 00 00 00 00 
3119   1E32 00 00 00 00 
3119   1E36 00 00 00 00 
3119   1E3A 00 00 00 00 
3119   1E3E 00 00 00 00 
3119   1E42 00 00 00 00 
3119   1E46 00 00 00 00 
3119   1E4A 00 00 00 00 
3119   1E4E 00 00 00 00 
3119   1E52 00 00 00 00 
3119   1E56 00 00 00 00 
3119   1E5A 00 00 00 00 
3119   1E5E 00 00 00 00 
3119   1E62 00 00 00 00 
3119   1E66 00 00 00 00 
3119   1E6A 00 00 00 00 
3119   1E6E 00 00 00 00 
3119   1E72 00 00 00 00 
3119   1E76 00 00 00 00 
3119   1E7A 00 00 00 00 
3119   1E7E 00 00 00 00 
3119   1E82 00 00 00 00 
3119   1E86 00 00 00 00 
3119   1E8A 00 00 00 00 
3119   1E8E 00 00 00 00 
3119   1E92 00 00 00 00 
3119   1E96 00 00 00 00 
3119   1E9A 00 00 00 00 
3119   1E9E 00 00 00 00 
3119   1EA2 00 00 00 00 
3119   1EA6 00 00 00 00 
3119   1EAA 00 00 00 00 
3119   1EAE 00 00 00 00 
3119   1EB2 00 00 00 00 
3119   1EB6 00 00 00 00 
3119   1EBA 00 00 00 00 
3119   1EBE 00 00 00 00 
3119   1EC2 00 00 00 00 
3119   1EC6 00 00 00 00 
3119   1ECA 00 00 00 00 
3119   1ECE 00 00 00 00 
3119   1ED2 00 00 00 00 
3119   1ED6 00 00 00 00 
3119   1EDA 00 00 00 00 
3119   1EDE 00 00 00 00 
3119   1EE2 00 00 00 00 
3119   1EE6 00 00 00 00 
3119   1EEA 00 00 00 00 
3119   1EEE 00 00 00 00 
3119   1EF2 00 00 00 00 
3119   1EF6 00 00 00 00 
3119   1EFA 00 00 00 00 
3119   1EFE 00 00 00 00 
3119   1F02 00 00 00 00 
3119   1F06 00 00 00 00 
3119   1F0A 00 00 00 00 
3119   1F0E 00 00 00 00 
3119   1F12 00 00 00 00 
3119   1F16 00 00 00 00 
3119   1F1A 00 00 00 00 
3119   1F1E 00 00 00 00 
3119   1F22 00 00 00 00 
3119   1F26 00 00 00 00 
3119   1F2A 00 00 00 00 
3119   1F2E 00 00 00 00 
3119   1F32 00 00 00 00 
3119   1F36 00 00 00 00 
3119   1F3A 00 00 00 00 
3119   1F3E 00 00 00 00 
3119   1F42 00 00 00 00 
3119   1F46 00 00 00 00 
3119   1F4A 00 00 00 00 
3119   1F4E 00 00 00 00 
3119   1F52 00 00 00 00 
3119   1F56 00 00 00 00 
3119   1F5A 00 00 00 00 
3119   1F5E 00 00 00 00 
3119   1F62 00 00 00 00 
3119   1F66 00 00 00 00 
3119   1F6A 00 00 00 00 
3119   1F6E 00 00 00 00 
3119   1F72 00 00 00 00 
3119   1F76 00 00 00 00 
3119   1F7A 00 00 00 00 
3119   1F7E 00 00 00 00 
3119   1F82 00 00 00 00 
3119   1F86 00 00 00 00 
3119   1F8A 00 00 00 00 
3119   1F8E 00 00 00 00 
3119   1F92 00 00 00 00 
3119   1F96 00 00 00 00 
3119   1F9A 00 00 00 00 
3119   1F9E 00 00 00 00 
3119   1FA2 00 00 00 00 
3119   1FA6 00 00 00 00 
3119   1FAA 00 00 00 00 
3119   1FAE 00 00 00 00 
3119   1FB2 00 00 00 00 
3119   1FB6 00 00 00 00 
3119   1FBA 00 00 00 00 
3119   1FBE 00 00 00 00 
3119   1FC2 00 00 00 00 
3119   1FC6 00 00 00 00 
3119   1FCA 00 00 00 00 
3119   1FCE 00 00 00 00 
3119   1FD2 00 00 00 00 
3119   1FD6 00 00 00 00 
3119   1FDA 00 00 00 00 
3119   1FDE 00 00 00 00 
3119   1FE2 00 00 00 00 
3119   1FE6 00 00 00 00 
3119   1FEA 00 00 00 00 
3119   1FEE 00 00 00 00 
3119   1FF2 00 00 00 00 
3119   1FF6 00 00 00 00 
3119   1FFA 00 00 00 00 
3119   1FFE 00 00 00 00 
3119   2002 00 00 00 00 
3119   2006 00 00 00 00 
3119   200A 00 00 00 00 
3119   200E 00 00 00 00 
3119   2012 00 00 00 00 
3119   2016 00 00 00 00 
3119   201A 00 00 00 00 
3120   201E             fifo:
3121   201E FF FF FF FF   .fill _fifo_size
3121   2022 FF FF FF FF 
3121   2026 FF FF FF FF 
3121   202A FF FF FF FF 
3121   202E FF FF FF FF 
3121   2032 FF FF FF FF 
3121   2036 FF FF FF FF 
3121   203A FF FF FF FF 
3121   203E FF FF FF FF 
3121   2042 FF FF FF FF 
3121   2046 FF FF FF FF 
3121   204A FF FF FF FF 
3121   204E FF FF FF FF 
3121   2052 FF FF FF FF 
3121   2056 FF FF FF FF 
3121   205A FF FF FF FF 
3121   205E FF FF FF FF 
3121   2062 FF FF FF FF 
3121   2066 FF FF FF FF 
3121   206A FF FF FF FF 
3121   206E FF FF FF FF 
3121   2072 FF FF FF FF 
3121   2076 FF FF FF FF 
3121   207A FF FF FF FF 
3121   207E FF FF FF FF 
3121   2082 FF FF FF FF 
3121   2086 FF FF FF FF 
3121   208A FF FF FF FF 
3121   208E FF FF FF FF 
3121   2092 FF FF FF FF 
3121   2096 FF FF FF FF 
3121   209A FF FF FF FF 
3121   209E FF FF FF FF 
3121   20A2 FF FF FF FF 
3121   20A6 FF FF FF FF 
3121   20AA FF FF FF FF 
3121   20AE FF FF FF FF 
3121   20B2 FF FF FF FF 
3121   20B6 FF FF FF FF 
3121   20BA FF FF FF FF 
3121   20BE FF FF FF FF 
3121   20C2 FF FF FF FF 
3121   20C6 FF FF FF FF 
3121   20CA FF FF FF FF 
3121   20CE FF FF FF FF 
3121   20D2 FF FF FF FF 
3121   20D6 FF FF FF FF 
3121   20DA FF FF FF FF 
3121   20DE FF FF FF FF 
3121   20E2 FF FF FF FF 
3121   20E6 FF FF FF FF 
3121   20EA FF FF FF FF 
3121   20EE FF FF FF FF 
3121   20F2 FF FF FF FF 
3121   20F6 FF FF FF FF 
3121   20FA FF FF FF FF 
3121   20FE FF FF FF FF 
3121   2102 FF FF FF FF 
3121   2106 FF FF FF FF 
3121   210A FF FF FF FF 
3121   210E FF FF FF FF 
3121   2112 FF FF FF FF 
3121   2116 FF FF FF FF 
3121   211A FF FF FF FF 
3121   211E FF FF FF FF 
3121   2122 FF FF FF FF 
3121   2126 FF FF FF FF 
3121   212A FF FF FF FF 
3121   212E FF FF FF FF 
3121   2132 FF FF FF FF 
3121   2136 FF FF FF FF 
3121   213A FF FF FF FF 
3121   213E FF FF FF FF 
3121   2142 FF FF FF FF 
3121   2146 FF FF FF FF 
3121   214A FF FF FF FF 
3121   214E FF FF FF FF 
3121   2152 FF FF FF FF 
3121   2156 FF FF FF FF 
3121   215A FF FF FF FF 
3121   215E FF FF FF FF 
3121   2162 FF FF FF FF 
3121   2166 FF FF FF FF 
3121   216A FF FF FF FF 
3121   216E FF FF FF FF 
3121   2172 FF FF FF FF 
3121   2176 FF FF FF FF 
3121   217A FF FF FF FF 
3121   217E FF FF FF FF 
3121   2182 FF FF FF FF 
3121   2186 FF FF FF FF 
3121   218A FF FF FF FF 
3121   218E FF FF FF FF 
3121   2192 FF FF FF FF 
3121   2196 FF FF FF FF 
3121   219A FF FF FF FF 
3121   219E FF FF FF FF 
3121   21A2 FF FF FF FF 
3121   21A6 FF FF FF FF 
3121   21AA FF FF FF FF 
3121   21AE FF FF FF FF 
3121   21B2 FF FF FF FF 
3121   21B6 FF FF FF FF 
3121   21BA FF FF FF FF 
3121   21BE FF FF FF FF 
3121   21C2 FF FF FF FF 
3121   21C6 FF FF FF FF 
3121   21CA FF FF FF FF 
3121   21CE FF FF FF FF 
3121   21D2 FF FF FF FF 
3121   21D6 FF FF FF FF 
3121   21DA FF FF FF FF 
3121   21DE FF FF FF FF 
3121   21E2 FF FF FF FF 
3121   21E6 FF FF FF FF 
3121   21EA FF FF FF FF 
3121   21EE FF FF FF FF 
3121   21F2 FF FF FF FF 
3121   21F6 FF FF FF FF 
3121   21FA FF FF FF FF 
3121   21FE FF FF FF FF 
3121   2202 FF FF FF FF 
3121   2206 FF FF FF FF 
3121   220A FF FF FF FF 
3121   220E FF FF FF FF 
3121   2212 FF FF FF FF 
3121   2216 FF FF FF FF 
3121   221A FF FF FF FF 
3121   221E FF FF FF FF 
3121   2222 FF FF FF FF 
3121   2226 FF FF FF FF 
3121   222A FF FF FF FF 
3121   222E FF FF FF FF 
3121   2232 FF FF FF FF 
3121   2236 FF FF FF FF 
3121   223A FF FF FF FF 
3121   223E FF FF FF FF 
3121   2242 FF FF FF FF 
3121   2246 FF FF FF FF 
3121   224A FF FF FF FF 
3121   224E FF FF FF FF 
3121   2252 FF FF FF FF 
3121   2256 FF FF FF FF 
3121   225A FF FF FF FF 
3121   225E FF FF FF FF 
3121   2262 FF FF FF FF 
3121   2266 FF FF FF FF 
3121   226A FF FF FF FF 
3121   226E FF FF FF FF 
3121   2272 FF FF FF FF 
3121   2276 FF FF FF FF 
3121   227A FF FF FF FF 
3121   227E FF FF FF FF 
3121   2282 FF FF FF FF 
3121   2286 FF FF FF FF 
3121   228A FF FF FF FF 
3121   228E FF FF FF FF 
3121   2292 FF FF FF FF 
3121   2296 FF FF FF FF 
3121   229A FF FF FF FF 
3121   229E FF FF FF FF 
3121   22A2 FF FF FF FF 
3121   22A6 FF FF FF FF 
3121   22AA FF FF FF FF 
3121   22AE FF FF FF FF 
3121   22B2 FF FF FF FF 
3121   22B6 FF FF FF FF 
3121   22BA FF FF FF FF 
3121   22BE FF FF FF FF 
3121   22C2 FF FF FF FF 
3121   22C6 FF FF FF FF 
3121   22CA FF FF FF FF 
3121   22CE FF FF FF FF 
3121   22D2 FF FF FF FF 
3121   22D6 FF FF FF FF 
3121   22DA FF FF FF FF 
3121   22DE FF FF FF FF 
3121   22E2 FF FF FF FF 
3121   22E6 FF FF FF FF 
3121   22EA FF FF FF FF 
3121   22EE FF FF FF FF 
3121   22F2 FF FF FF FF 
3121   22F6 FF FF FF FF 
3121   22FA FF FF FF FF 
3121   22FE FF FF FF FF 
3121   2302 FF FF FF FF 
3121   2306 FF FF FF FF 
3121   230A FF FF FF FF 
3121   230E FF FF FF FF 
3121   2312 FF FF FF FF 
3121   2316 FF FF FF FF 
3121   231A FF FF FF FF 
3121   231E FF FF FF FF 
3121   2322 FF FF FF FF 
3121   2326 FF FF FF FF 
3121   232A FF FF FF FF 
3121   232E FF FF FF FF 
3121   2332 FF FF FF FF 
3121   2336 FF FF FF FF 
3121   233A FF FF FF FF 
3121   233E FF FF FF FF 
3121   2342 FF FF FF FF 
3121   2346 FF FF FF FF 
3121   234A FF FF FF FF 
3121   234E FF FF FF FF 
3121   2352 FF FF FF FF 
3121   2356 FF FF FF FF 
3121   235A FF FF FF FF 
3121   235E FF FF FF FF 
3121   2362 FF FF FF FF 
3121   2366 FF FF FF FF 
3121   236A FF FF FF FF 
3121   236E FF FF FF FF 
3121   2372 FF FF FF FF 
3121   2376 FF FF FF FF 
3121   237A FF FF FF FF 
3121   237E FF FF FF FF 
3121   2382 FF FF FF FF 
3121   2386 FF FF FF FF 
3121   238A FF FF FF FF 
3121   238E FF FF FF FF 
3121   2392 FF FF FF FF 
3121   2396 FF FF FF FF 
3121   239A FF FF FF FF 
3121   239E FF FF FF FF 
3121   23A2 FF FF FF FF 
3121   23A6 FF FF FF FF 
3121   23AA FF FF FF FF 
3121   23AE FF FF FF FF 
3121   23B2 FF FF FF FF 
3121   23B6 FF FF FF FF 
3121   23BA FF FF FF FF 
3121   23BE FF FF FF FF 
3121   23C2 FF FF FF FF 
3121   23C6 FF FF FF FF 
3121   23CA FF FF FF FF 
3121   23CE FF FF FF FF 
3121   23D2 FF FF FF FF 
3121   23D6 FF FF FF FF 
3121   23DA FF FF FF FF 
3121   23DE FF FF FF FF 
3121   23E2 FF FF FF FF 
3121   23E6 FF FF FF FF 
3121   23EA FF FF FF FF 
3121   23EE FF FF FF FF 
3121   23F2 FF FF FF FF 
3121   23F6 FF FF FF FF 
3121   23FA FF FF FF FF 
3121   23FE FF FF FF FF 
3121   2402 FF FF FF FF 
3121   2406 FF FF FF FF 
3121   240A FF FF FF FF 
3121   240E FF FF FF FF 
3121   2412 FF FF FF FF 
3121   2416 FF FF FF FF 
3121   241A FF FF FF FF 
3121   241E FF FF FF FF 
3121   2422 FF FF FF FF 
3121   2426 FF FF FF FF 
3121   242A FF FF FF FF 
3121   242E FF FF FF FF 
3121   2432 FF FF FF FF 
3121   2436 FF FF FF FF 
3121   243A FF FF FF FF 
3121   243E FF FF FF FF 
3121   2442 FF FF FF FF 
3121   2446 FF FF FF FF 
3121   244A FF FF FF FF 
3121   244E FF FF FF FF 
3121   2452 FF FF FF FF 
3121   2456 FF FF FF FF 
3121   245A FF FF FF FF 
3121   245E FF FF FF FF 
3121   2462 FF FF FF FF 
3121   2466 FF FF FF FF 
3121   246A FF FF FF FF 
3121   246E FF FF FF FF 
3121   2472 FF FF FF FF 
3121   2476 FF FF FF FF 
3121   247A FF FF FF FF 
3121   247E FF FF FF FF 
3121   2482 FF FF FF FF 
3121   2486 FF FF FF FF 
3121   248A FF FF FF FF 
3121   248E FF FF FF FF 
3121   2492 FF FF FF FF 
3121   2496 FF FF FF FF 
3121   249A FF FF FF FF 
3121   249E FF FF FF FF 
3121   24A2 FF FF FF FF 
3121   24A6 FF FF FF FF 
3121   24AA FF FF FF FF 
3121   24AE FF FF FF FF 
3121   24B2 FF FF FF FF 
3121   24B6 FF FF FF FF 
3121   24BA FF FF FF FF 
3121   24BE FF FF FF FF 
3121   24C2 FF FF FF FF 
3121   24C6 FF FF FF FF 
3121   24CA FF FF FF FF 
3121   24CE FF FF FF FF 
3121   24D2 FF FF FF FF 
3121   24D6 FF FF FF FF 
3121   24DA FF FF FF FF 
3121   24DE FF FF FF FF 
3121   24E2 FF FF FF FF 
3121   24E6 FF FF FF FF 
3121   24EA FF FF FF FF 
3121   24EE FF FF FF FF 
3121   24F2 FF FF FF FF 
3121   24F6 FF FF FF FF 
3121   24FA FF FF FF FF 
3121   24FE FF FF FF FF 
3121   2502 FF FF FF FF 
3121   2506 FF FF FF FF 
3121   250A FF FF FF FF 
3121   250E FF FF FF FF 
3121   2512 FF FF FF FF 
3121   2516 FF FF FF FF 
3121   251A FF FF FF FF 
3121   251E FF FF FF FF 
3121   2522 FF FF FF FF 
3121   2526 FF FF FF FF 
3121   252A FF FF FF FF 
3121   252E FF FF FF FF 
3121   2532 FF FF FF FF 
3121   2536 FF FF FF FF 
3121   253A FF FF FF FF 
3121   253E FF FF FF FF 
3121   2542 FF FF FF FF 
3121   2546 FF FF FF FF 
3121   254A FF FF FF FF 
3121   254E FF FF FF FF 
3121   2552 FF FF FF FF 
3121   2556 FF FF FF FF 
3121   255A FF FF FF FF 
3121   255E FF FF FF FF 
3121   2562 FF FF FF FF 
3121   2566 FF FF FF FF 
3121   256A FF FF FF FF 
3121   256E FF FF FF FF 
3121   2572 FF FF FF FF 
3121   2576 FF FF FF FF 
3121   257A FF FF FF FF 
3121   257E FF FF FF FF 
3121   2582 FF FF FF FF 
3121   2586 FF FF FF FF 
3121   258A FF FF FF FF 
3121   258E FF FF FF FF 
3121   2592 FF FF FF FF 
3121   2596 FF FF FF FF 
3121   259A FF FF FF FF 
3121   259E FF FF FF FF 
3121   25A2 FF FF FF FF 
3121   25A6 FF FF FF FF 
3121   25AA FF FF FF FF 
3121   25AE FF FF FF FF 
3121   25B2 FF FF FF FF 
3121   25B6 FF FF FF FF 
3121   25BA FF FF FF FF 
3121   25BE FF FF FF FF 
3121   25C2 FF FF FF FF 
3121   25C6 FF FF FF FF 
3121   25CA FF FF FF FF 
3121   25CE FF FF FF FF 
3121   25D2 FF FF FF FF 
3121   25D6 FF FF FF FF 
3121   25DA FF FF FF FF 
3121   25DE FF FF FF FF 
3121   25E2 FF FF FF FF 
3121   25E6 FF FF FF FF 
3121   25EA FF FF FF FF 
3121   25EE FF FF FF FF 
3121   25F2 FF FF FF FF 
3121   25F6 FF FF FF FF 
3121   25FA FF FF FF FF 
3121   25FE FF FF FF FF 
3121   2602 FF FF FF FF 
3121   2606 FF FF FF FF 
3121   260A FF FF FF FF 
3121   260E FF FF FF FF 
3121   2612 FF FF FF FF 
3121   2616 FF FF FF FF 
3121   261A FF FF FF FF 
3121   261E FF FF FF FF 
3121   2622 FF FF FF FF 
3121   2626 FF FF FF FF 
3121   262A FF FF FF FF 
3121   262E FF FF FF FF 
3121   2632 FF FF FF FF 
3121   2636 FF FF FF FF 
3121   263A FF FF FF FF 
3121   263E FF FF FF FF 
3121   2642 FF FF FF FF 
3121   2646 FF FF FF FF 
3121   264A FF FF FF FF 
3121   264E FF FF FF FF 
3121   2652 FF FF FF FF 
3121   2656 FF FF FF FF 
3121   265A FF FF FF FF 
3121   265E FF FF FF FF 
3121   2662 FF FF FF FF 
3121   2666 FF FF FF FF 
3121   266A FF FF FF FF 
3121   266E FF FF FF FF 
3121   2672 FF FF FF FF 
3121   2676 FF FF FF FF 
3121   267A FF FF FF FF 
3121   267E FF FF FF FF 
3121   2682 FF FF FF FF 
3121   2686 FF FF FF FF 
3121   268A FF FF FF FF 
3121   268E FF FF FF FF 
3121   2692 FF FF FF FF 
3121   2696 FF FF FF FF 
3121   269A FF FF FF FF 
3121   269E FF FF FF FF 
3121   26A2 FF FF FF FF 
3121   26A6 FF FF FF FF 
3121   26AA FF FF FF FF 
3121   26AE FF FF FF FF 
3121   26B2 FF FF FF FF 
3121   26B6 FF FF FF FF 
3121   26BA FF FF FF FF 
3121   26BE FF FF FF FF 
3121   26C2 FF FF FF FF 
3121   26C6 FF FF FF FF 
3121   26CA FF FF FF FF 
3121   26CE FF FF FF FF 
3121   26D2 FF FF FF FF 
3121   26D6 FF FF FF FF 
3121   26DA FF FF FF FF 
3121   26DE FF FF FF FF 
3121   26E2 FF FF FF FF 
3121   26E6 FF FF FF FF 
3121   26EA FF FF FF FF 
3121   26EE FF FF FF FF 
3121   26F2 FF FF FF FF 
3121   26F6 FF FF FF FF 
3121   26FA FF FF FF FF 
3121   26FE FF FF FF FF 
3121   2702 FF FF FF FF 
3121   2706 FF FF FF FF 
3121   270A FF FF FF FF 
3121   270E FF FF FF FF 
3121   2712 FF FF FF FF 
3121   2716 FF FF FF FF 
3121   271A FF FF FF FF 
3121   271E FF FF FF FF 
3121   2722 FF FF FF FF 
3121   2726 FF FF FF FF 
3121   272A FF FF FF FF 
3121   272E FF FF FF FF 
3121   2732 FF FF FF FF 
3121   2736 FF FF FF FF 
3121   273A FF FF FF FF 
3121   273E FF FF FF FF 
3121   2742 FF FF FF FF 
3121   2746 FF FF FF FF 
3121   274A FF FF FF FF 
3121   274E FF FF FF FF 
3121   2752 FF FF FF FF 
3121   2756 FF FF FF FF 
3121   275A FF FF FF FF 
3121   275E FF FF FF FF 
3121   2762 FF FF FF FF 
3121   2766 FF FF FF FF 
3121   276A FF FF FF FF 
3121   276E FF FF FF FF 
3121   2772 FF FF FF FF 
3121   2776 FF FF FF FF 
3121   277A FF FF FF FF 
3121   277E FF FF FF FF 
3121   2782 FF FF FF FF 
3121   2786 FF FF FF FF 
3121   278A FF FF FF FF 
3121   278E FF FF FF FF 
3121   2792 FF FF FF FF 
3121   2796 FF FF FF FF 
3121   279A FF FF FF FF 
3121   279E FF FF FF FF 
3121   27A2 FF FF FF FF 
3121   27A6 FF FF FF FF 
3121   27AA FF FF FF FF 
3121   27AE FF FF FF FF 
3121   27B2 FF FF FF FF 
3121   27B6 FF FF FF FF 
3121   27BA FF FF FF FF 
3121   27BE FF FF FF FF 
3121   27C2 FF FF FF FF 
3121   27C6 FF FF FF FF 
3121   27CA FF FF FF FF 
3121   27CE FF FF FF FF 
3121   27D2 FF FF FF FF 
3121   27D6 FF FF FF FF 
3121   27DA FF FF FF FF 
3121   27DE FF FF FF FF 
3121   27E2 FF FF FF FF 
3121   27E6 FF FF FF FF 
3121   27EA FF FF FF FF 
3121   27EE FF FF FF FF 
3121   27F2 FF FF FF FF 
3121   27F6 FF FF FF FF 
3121   27FA FF FF FF FF 
3121   27FE FF FF FF FF 
3121   2802 FF FF FF FF 
3121   2806 FF FF FF FF 
3121   280A FF FF FF FF 
3121   280E FF FF FF FF 
3121   2812 FF FF FF FF 
3121   2816 FF FF FF FF 
3121   281A FF FF FF FF 
3121   281E FF FF FF FF 
3121   2822 FF FF FF FF 
3121   2826 FF FF FF FF 
3121   282A FF FF FF FF 
3121   282E FF FF FF FF 
3121   2832 FF FF FF FF 
3121   2836 FF FF FF FF 
3121   283A FF FF FF FF 
3121   283E FF FF FF FF 
3121   2842 FF FF FF FF 
3121   2846 FF FF FF FF 
3121   284A FF FF FF FF 
3121   284E FF FF FF FF 
3121   2852 FF FF FF FF 
3121   2856 FF FF FF FF 
3121   285A FF FF FF FF 
3121   285E FF FF FF FF 
3121   2862 FF FF FF FF 
3121   2866 FF FF FF FF 
3121   286A FF FF FF FF 
3121   286E FF FF FF FF 
3121   2872 FF FF FF FF 
3121   2876 FF FF FF FF 
3121   287A FF FF FF FF 
3121   287E FF FF FF FF 
3121   2882 FF FF FF FF 
3121   2886 FF FF FF FF 
3121   288A FF FF FF FF 
3121   288E FF FF FF FF 
3121   2892 FF FF FF FF 
3121   2896 FF FF FF FF 
3121   289A FF FF FF FF 
3121   289E FF FF FF FF 
3121   28A2 FF FF FF FF 
3121   28A6 FF FF FF FF 
3121   28AA FF FF FF FF 
3121   28AE FF FF FF FF 
3121   28B2 FF FF FF FF 
3121   28B6 FF FF FF FF 
3121   28BA FF FF FF FF 
3121   28BE FF FF FF FF 
3121   28C2 FF FF FF FF 
3121   28C6 FF FF FF FF 
3121   28CA FF FF FF FF 
3121   28CE FF FF FF FF 
3121   28D2 FF FF FF FF 
3121   28D6 FF FF FF FF 
3121   28DA FF FF FF FF 
3121   28DE FF FF FF FF 
3121   28E2 FF FF FF FF 
3121   28E6 FF FF FF FF 
3121   28EA FF FF FF FF 
3121   28EE FF FF FF FF 
3121   28F2 FF FF FF FF 
3121   28F6 FF FF FF FF 
3121   28FA FF FF FF FF 
3121   28FE FF FF FF FF 
3121   2902 FF FF FF FF 
3121   2906 FF FF FF FF 
3121   290A FF FF FF FF 
3121   290E FF FF FF FF 
3121   2912 FF FF FF FF 
3121   2916 FF FF FF FF 
3121   291A FF FF FF FF 
3121   291E FF FF FF FF 
3121   2922 FF FF FF FF 
3121   2926 FF FF FF FF 
3121   292A FF FF FF FF 
3121   292E FF FF FF FF 
3121   2932 FF FF FF FF 
3121   2936 FF FF FF FF 
3121   293A FF FF FF FF 
3121   293E FF FF FF FF 
3121   2942 FF FF FF FF 
3121   2946 FF FF FF FF 
3121   294A FF FF FF FF 
3121   294E FF FF FF FF 
3121   2952 FF FF FF FF 
3121   2956 FF FF FF FF 
3121   295A FF FF FF FF 
3121   295E FF FF FF FF 
3121   2962 FF FF FF FF 
3121   2966 FF FF FF FF 
3121   296A FF FF FF FF 
3121   296E FF FF FF FF 
3121   2972 FF FF FF FF 
3121   2976 FF FF FF FF 
3121   297A FF FF FF FF 
3121   297E FF FF FF FF 
3121   2982 FF FF FF FF 
3121   2986 FF FF FF FF 
3121   298A FF FF FF FF 
3121   298E FF FF FF FF 
3121   2992 FF FF FF FF 
3121   2996 FF FF FF FF 
3121   299A FF FF FF FF 
3121   299E FF FF FF FF 
3121   29A2 FF FF FF FF 
3121   29A6 FF FF FF FF 
3121   29AA FF FF FF FF 
3121   29AE FF FF FF FF 
3121   29B2 FF FF FF FF 
3121   29B6 FF FF FF FF 
3121   29BA FF FF FF FF 
3121   29BE FF FF FF FF 
3121   29C2 FF FF FF FF 
3121   29C6 FF FF FF FF 
3121   29CA FF FF FF FF 
3121   29CE FF FF FF FF 
3121   29D2 FF FF FF FF 
3121   29D6 FF FF FF FF 
3121   29DA FF FF FF FF 
3121   29DE FF FF FF FF 
3121   29E2 FF FF FF FF 
3121   29E6 FF FF FF FF 
3121   29EA FF FF FF FF 
3121   29EE FF FF FF FF 
3121   29F2 FF FF FF FF 
3121   29F6 FF FF FF FF 
3121   29FA FF FF FF FF 
3121   29FE FF FF FF FF 
3121   2A02 FF FF FF FF 
3121   2A06 FF FF FF FF 
3121   2A0A FF FF FF FF 
3121   2A0E FF FF FF FF 
3121   2A12 FF FF FF FF 
3121   2A16 FF FF FF FF 
3121   2A1A FF FF FF FF 
3121   2A1E FF FF FF FF 
3121   2A22 FF FF FF FF 
3121   2A26 FF FF FF FF 
3121   2A2A FF FF FF FF 
3121   2A2E FF FF FF FF 
3121   2A32 FF FF FF FF 
3121   2A36 FF FF FF FF 
3121   2A3A FF FF FF FF 
3121   2A3E FF FF FF FF 
3121   2A42 FF FF FF FF 
3121   2A46 FF FF FF FF 
3121   2A4A FF FF FF FF 
3121   2A4E FF FF FF FF 
3121   2A52 FF FF FF FF 
3121   2A56 FF FF FF FF 
3121   2A5A FF FF FF FF 
3121   2A5E FF FF FF FF 
3121   2A62 FF FF FF FF 
3121   2A66 FF FF FF FF 
3121   2A6A FF FF FF FF 
3121   2A6E FF FF FF FF 
3121   2A72 FF FF FF FF 
3121   2A76 FF FF FF FF 
3121   2A7A FF FF FF FF 
3121   2A7E FF FF FF FF 
3121   2A82 FF FF FF FF 
3121   2A86 FF FF FF FF 
3121   2A8A FF FF FF FF 
3121   2A8E FF FF FF FF 
3121   2A92 FF FF FF FF 
3121   2A96 FF FF FF FF 
3121   2A9A FF FF FF FF 
3121   2A9E FF FF FF FF 
3121   2AA2 FF FF FF FF 
3121   2AA6 FF FF FF FF 
3121   2AAA FF FF FF FF 
3121   2AAE FF FF FF FF 
3121   2AB2 FF FF FF FF 
3121   2AB6 FF FF FF FF 
3121   2ABA FF FF FF FF 
3121   2ABE FF FF FF FF 
3121   2AC2 FF FF FF FF 
3121   2AC6 FF FF FF FF 
3121   2ACA FF FF FF FF 
3121   2ACE FF FF FF FF 
3121   2AD2 FF FF FF FF 
3121   2AD6 FF FF FF FF 
3121   2ADA FF FF FF FF 
3121   2ADE FF FF FF FF 
3121   2AE2 FF FF FF FF 
3121   2AE6 FF FF FF FF 
3121   2AEA FF FF FF FF 
3121   2AEE FF FF FF FF 
3121   2AF2 FF FF FF FF 
3121   2AF6 FF FF FF FF 
3121   2AFA FF FF FF FF 
3121   2AFE FF FF FF FF 
3121   2B02 FF FF FF FF 
3121   2B06 FF FF FF FF 
3121   2B0A FF FF FF FF 
3121   2B0E FF FF FF FF 
3121   2B12 FF FF FF FF 
3121   2B16 FF FF FF FF 
3121   2B1A FF FF FF FF 
3121   2B1E FF FF FF FF 
3121   2B22 FF FF FF FF 
3121   2B26 FF FF FF FF 
3121   2B2A FF FF FF FF 
3121   2B2E FF FF FF FF 
3121   2B32 FF FF FF FF 
3121   2B36 FF FF FF FF 
3121   2B3A FF FF FF FF 
3121   2B3E FF FF FF FF 
3121   2B42 FF FF FF FF 
3121   2B46 FF FF FF FF 
3121   2B4A FF FF FF FF 
3121   2B4E FF FF FF FF 
3121   2B52 FF FF FF FF 
3121   2B56 FF FF FF FF 
3121   2B5A FF FF FF FF 
3121   2B5E FF FF FF FF 
3121   2B62 FF FF FF FF 
3121   2B66 FF FF FF FF 
3121   2B6A FF FF FF FF 
3121   2B6E FF FF FF FF 
3121   2B72 FF FF FF FF 
3121   2B76 FF FF FF FF 
3121   2B7A FF FF FF FF 
3121   2B7E FF FF FF FF 
3121   2B82 FF FF FF FF 
3121   2B86 FF FF FF FF 
3121   2B8A FF FF FF FF 
3121   2B8E FF FF FF FF 
3121   2B92 FF FF FF FF 
3121   2B96 FF FF FF FF 
3121   2B9A FF FF FF FF 
3121   2B9E FF FF FF FF 
3121   2BA2 FF FF FF FF 
3121   2BA6 FF FF FF FF 
3121   2BAA FF FF FF FF 
3121   2BAE FF FF FF FF 
3121   2BB2 FF FF FF FF 
3121   2BB6 FF FF FF FF 
3121   2BBA FF FF FF FF 
3121   2BBE FF FF FF FF 
3121   2BC2 FF FF FF FF 
3121   2BC6 FF FF FF FF 
3121   2BCA FF FF FF FF 
3121   2BCE FF FF FF FF 
3121   2BD2 FF FF FF FF 
3121   2BD6 FF FF FF FF 
3121   2BDA FF FF FF FF 
3121   2BDE FF FF FF FF 
3121   2BE2 FF FF FF FF 
3121   2BE6 FF FF FF FF 
3121   2BEA FF FF FF FF 
3121   2BEE FF FF FF FF 
3121   2BF2 FF FF FF FF 
3121   2BF6 FF FF FF FF 
3121   2BFA FF FF FF FF 
3121   2BFE FF FF FF FF 
3121   2C02 FF FF FF FF 
3121   2C06 FF FF FF FF 
3121   2C0A FF FF FF FF 
3121   2C0E FF FF FF FF 
3121   2C12 FF FF FF FF 
3121   2C16 FF FF FF FF 
3121   2C1A FF FF FF FF 
3121   2C1E FF FF FF FF 
3121   2C22 FF FF FF FF 
3121   2C26 FF FF FF FF 
3121   2C2A FF FF FF FF 
3121   2C2E FF FF FF FF 
3121   2C32 FF FF FF FF 
3121   2C36 FF FF FF FF 
3121   2C3A FF FF FF FF 
3121   2C3E FF FF FF FF 
3121   2C42 FF FF FF FF 
3121   2C46 FF FF FF FF 
3121   2C4A FF FF FF FF 
3121   2C4E FF FF FF FF 
3121   2C52 FF FF FF FF 
3121   2C56 FF FF FF FF 
3121   2C5A FF FF FF FF 
3121   2C5E FF FF FF FF 
3121   2C62 FF FF FF FF 
3121   2C66 FF FF FF FF 
3121   2C6A FF FF FF FF 
3121   2C6E FF FF FF FF 
3121   2C72 FF FF FF FF 
3121   2C76 FF FF FF FF 
3121   2C7A FF FF FF FF 
3121   2C7E FF FF FF FF 
3121   2C82 FF FF FF FF 
3121   2C86 FF FF FF FF 
3121   2C8A FF FF FF FF 
3121   2C8E FF FF FF FF 
3121   2C92 FF FF FF FF 
3121   2C96 FF FF FF FF 
3121   2C9A FF FF FF FF 
3121   2C9E FF FF FF FF 
3121   2CA2 FF FF FF FF 
3121   2CA6 FF FF FF FF 
3121   2CAA FF FF FF FF 
3121   2CAE FF FF FF FF 
3121   2CB2 FF FF FF FF 
3121   2CB6 FF FF FF FF 
3121   2CBA FF FF FF FF 
3121   2CBE FF FF FF FF 
3121   2CC2 FF FF FF FF 
3121   2CC6 FF FF FF FF 
3121   2CCA FF FF FF FF 
3121   2CCE FF FF FF FF 
3121   2CD2 FF FF FF FF 
3121   2CD6 FF FF FF FF 
3121   2CDA FF FF FF FF 
3121   2CDE FF FF FF FF 
3121   2CE2 FF FF FF FF 
3121   2CE6 FF FF FF FF 
3121   2CEA FF FF FF FF 
3121   2CEE FF FF FF FF 
3121   2CF2 FF FF FF FF 
3121   2CF6 FF FF FF FF 
3121   2CFA FF FF FF FF 
3121   2CFE FF FF FF FF 
3121   2D02 FF FF FF FF 
3121   2D06 FF FF FF FF 
3121   2D0A FF FF FF FF 
3121   2D0E FF FF FF FF 
3121   2D12 FF FF FF FF 
3121   2D16 FF FF FF FF 
3121   2D1A FF FF FF FF 
3121   2D1E FF FF FF FF 
3121   2D22 FF FF FF FF 
3121   2D26 FF FF FF FF 
3121   2D2A FF FF FF FF 
3121   2D2E FF FF FF FF 
3121   2D32 FF FF FF FF 
3121   2D36 FF FF FF FF 
3121   2D3A FF FF FF FF 
3121   2D3E FF FF FF FF 
3121   2D42 FF FF FF FF 
3121   2D46 FF FF FF FF 
3121   2D4A FF FF FF FF 
3121   2D4E FF FF FF FF 
3121   2D52 FF FF FF FF 
3121   2D56 FF FF FF FF 
3121   2D5A FF FF FF FF 
3121   2D5E FF FF FF FF 
3121   2D62 FF FF FF FF 
3121   2D66 FF FF FF FF 
3121   2D6A FF FF FF FF 
3121   2D6E FF FF FF FF 
3121   2D72 FF FF FF FF 
3121   2D76 FF FF FF FF 
3121   2D7A FF FF FF FF 
3121   2D7E FF FF FF FF 
3121   2D82 FF FF FF FF 
3121   2D86 FF FF FF FF 
3121   2D8A FF FF FF FF 
3121   2D8E FF FF FF FF 
3121   2D92 FF FF FF FF 
3121   2D96 FF FF FF FF 
3121   2D9A FF FF FF FF 
3121   2D9E FF FF FF FF 
3121   2DA2 FF FF FF FF 
3121   2DA6 FF FF FF FF 
3121   2DAA FF FF FF FF 
3121   2DAE FF FF FF FF 
3121   2DB2 FF FF FF FF 
3121   2DB6 FF FF FF FF 
3121   2DBA FF FF FF FF 
3121   2DBE FF FF FF FF 
3121   2DC2 FF FF FF FF 
3121   2DC6 FF FF FF FF 
3121   2DCA FF FF FF FF 
3121   2DCE FF FF FF FF 
3121   2DD2 FF FF FF FF 
3121   2DD6 FF FF FF FF 
3121   2DDA FF FF FF FF 
3121   2DDE FF FF FF FF 
3121   2DE2 FF FF FF FF 
3121   2DE6 FF FF FF FF 
3121   2DEA FF FF FF FF 
3121   2DEE FF FF FF FF 
3121   2DF2 FF FF FF FF 
3121   2DF6 FF FF FF FF 
3121   2DFA FF FF FF FF 
3121   2DFE FF FF FF FF 
3121   2E02 FF FF FF FF 
3121   2E06 FF FF FF FF 
3121   2E0A FF FF FF FF 
3121   2E0E FF FF FF FF 
3121   2E12 FF FF FF FF 
3121   2E16 FF FF FF FF 
3121   2E1A FF FF FF FF 
3121   2E1E FF FF FF FF 
3121   2E22 FF FF FF FF 
3121   2E26 FF FF FF FF 
3121   2E2A FF FF FF FF 
3121   2E2E FF FF FF FF 
3121   2E32 FF FF FF FF 
3121   2E36 FF FF FF FF 
3121   2E3A FF FF FF FF 
3121   2E3E FF FF FF FF 
3121   2E42 FF FF FF FF 
3121   2E46 FF FF FF FF 
3121   2E4A FF FF FF FF 
3121   2E4E FF FF FF FF 
3121   2E52 FF FF FF FF 
3121   2E56 FF FF FF FF 
3121   2E5A FF FF FF FF 
3121   2E5E FF FF FF FF 
3121   2E62 FF FF FF FF 
3121   2E66 FF FF FF FF 
3121   2E6A FF FF FF FF 
3121   2E6E FF FF FF FF 
3121   2E72 FF FF FF FF 
3121   2E76 FF FF FF FF 
3121   2E7A FF FF FF FF 
3121   2E7E FF FF FF FF 
3121   2E82 FF FF FF FF 
3121   2E86 FF FF FF FF 
3121   2E8A FF FF FF FF 
3121   2E8E FF FF FF FF 
3121   2E92 FF FF FF FF 
3121   2E96 FF FF FF FF 
3121   2E9A FF FF FF FF 
3121   2E9E FF FF FF FF 
3121   2EA2 FF FF FF FF 
3121   2EA6 FF FF FF FF 
3121   2EAA FF FF FF FF 
3121   2EAE FF FF FF FF 
3121   2EB2 FF FF FF FF 
3121   2EB6 FF FF FF FF 
3121   2EBA FF FF FF FF 
3121   2EBE FF FF FF FF 
3121   2EC2 FF FF FF FF 
3121   2EC6 FF FF FF FF 
3121   2ECA FF FF FF FF 
3121   2ECE FF FF FF FF 
3121   2ED2 FF FF FF FF 
3121   2ED6 FF FF FF FF 
3121   2EDA FF FF FF FF 
3121   2EDE FF FF FF FF 
3121   2EE2 FF FF FF FF 
3121   2EE6 FF FF FF FF 
3121   2EEA FF FF FF FF 
3121   2EEE FF FF FF FF 
3121   2EF2 FF FF FF FF 
3121   2EF6 FF FF FF FF 
3121   2EFA FF FF FF FF 
3121   2EFE FF FF FF FF 
3121   2F02 FF FF FF FF 
3121   2F06 FF FF FF FF 
3121   2F0A FF FF FF FF 
3121   2F0E FF FF FF FF 
3121   2F12 FF FF FF FF 
3121   2F16 FF FF FF FF 
3121   2F1A FF FF FF FF 
3121   2F1E FF FF FF FF 
3121   2F22 FF FF FF FF 
3121   2F26 FF FF FF FF 
3121   2F2A FF FF FF FF 
3121   2F2E FF FF FF FF 
3121   2F32 FF FF FF FF 
3121   2F36 FF FF FF FF 
3121   2F3A FF FF FF FF 
3121   2F3E FF FF FF FF 
3121   2F42 FF FF FF FF 
3121   2F46 FF FF FF FF 
3121   2F4A FF FF FF FF 
3121   2F4E FF FF FF FF 
3121   2F52 FF FF FF FF 
3121   2F56 FF FF FF FF 
3121   2F5A FF FF FF FF 
3121   2F5E FF FF FF FF 
3121   2F62 FF FF FF FF 
3121   2F66 FF FF FF FF 
3121   2F6A FF FF FF FF 
3121   2F6E FF FF FF FF 
3121   2F72 FF FF FF FF 
3121   2F76 FF FF FF FF 
3121   2F7A FF FF FF FF 
3121   2F7E FF FF FF FF 
3121   2F82 FF FF FF FF 
3121   2F86 FF FF FF FF 
3121   2F8A FF FF FF FF 
3121   2F8E FF FF FF FF 
3121   2F92 FF FF FF FF 
3121   2F96 FF FF FF FF 
3121   2F9A FF FF FF FF 
3121   2F9E FF FF FF FF 
3121   2FA2 FF FF FF FF 
3121   2FA6 FF FF FF FF 
3121   2FAA FF FF FF FF 
3121   2FAE FF FF FF FF 
3121   2FB2 FF FF FF FF 
3121   2FB6 FF FF FF FF 
3121   2FBA FF FF FF FF 
3121   2FBE FF FF FF FF 
3121   2FC2 FF FF FF FF 
3121   2FC6 FF FF FF FF 
3121   2FCA FF FF FF FF 
3121   2FCE FF FF FF FF 
3121   2FD2 FF FF FF FF 
3121   2FD6 FF FF FF FF 
3121   2FDA FF FF FF FF 
3121   2FDE FF FF FF FF 
3121   2FE2 FF FF FF FF 
3121   2FE6 FF FF FF FF 
3121   2FEA FF FF FF FF 
3121   2FEE FF FF FF FF 
3121   2FF2 FF FF FF FF 
3121   2FF6 FF FF FF FF 
3121   2FFA FF FF FF FF 
3121   2FFE FF FF FF FF 
3121   3002 FF FF FF FF 
3121   3006 FF FF FF FF 
3121   300A FF FF FF FF 
3121   300E FF FF FF FF 
3121   3012 FF FF FF FF 
3121   3016 FF FF FF FF 
3121   301A FF FF FF FF 
3122   301E             
3123   301E             scrap_sector:
3124   301E FF FF FF FF   .fill 512         ; scrap sector
3124   3022 FF FF FF FF 
3124   3026 FF FF FF FF 
3124   302A FF FF FF FF 
3124   302E FF FF FF FF 
3124   3032 FF FF FF FF 
3124   3036 FF FF FF FF 
3124   303A FF FF FF FF 
3124   303E FF FF FF FF 
3124   3042 FF FF FF FF 
3124   3046 FF FF FF FF 
3124   304A FF FF FF FF 
3124   304E FF FF FF FF 
3124   3052 FF FF FF FF 
3124   3056 FF FF FF FF 
3124   305A FF FF FF FF 
3124   305E FF FF FF FF 
3124   3062 FF FF FF FF 
3124   3066 FF FF FF FF 
3124   306A FF FF FF FF 
3124   306E FF FF FF FF 
3124   3072 FF FF FF FF 
3124   3076 FF FF FF FF 
3124   307A FF FF FF FF 
3124   307E FF FF FF FF 
3124   3082 FF FF FF FF 
3124   3086 FF FF FF FF 
3124   308A FF FF FF FF 
3124   308E FF FF FF FF 
3124   3092 FF FF FF FF 
3124   3096 FF FF FF FF 
3124   309A FF FF FF FF 
3124   309E FF FF FF FF 
3124   30A2 FF FF FF FF 
3124   30A6 FF FF FF FF 
3124   30AA FF FF FF FF 
3124   30AE FF FF FF FF 
3124   30B2 FF FF FF FF 
3124   30B6 FF FF FF FF 
3124   30BA FF FF FF FF 
3124   30BE FF FF FF FF 
3124   30C2 FF FF FF FF 
3124   30C6 FF FF FF FF 
3124   30CA FF FF FF FF 
3124   30CE FF FF FF FF 
3124   30D2 FF FF FF FF 
3124   30D6 FF FF FF FF 
3124   30DA FF FF FF FF 
3124   30DE FF FF FF FF 
3124   30E2 FF FF FF FF 
3124   30E6 FF FF FF FF 
3124   30EA FF FF FF FF 
3124   30EE FF FF FF FF 
3124   30F2 FF FF FF FF 
3124   30F6 FF FF FF FF 
3124   30FA FF FF FF FF 
3124   30FE FF FF FF FF 
3124   3102 FF FF FF FF 
3124   3106 FF FF FF FF 
3124   310A FF FF FF FF 
3124   310E FF FF FF FF 
3124   3112 FF FF FF FF 
3124   3116 FF FF FF FF 
3124   311A FF FF FF FF 
3124   311E FF FF FF FF 
3124   3122 FF FF FF FF 
3124   3126 FF FF FF FF 
3124   312A FF FF FF FF 
3124   312E FF FF FF FF 
3124   3132 FF FF FF FF 
3124   3136 FF FF FF FF 
3124   313A FF FF FF FF 
3124   313E FF FF FF FF 
3124   3142 FF FF FF FF 
3124   3146 FF FF FF FF 
3124   314A FF FF FF FF 
3124   314E FF FF FF FF 
3124   3152 FF FF FF FF 
3124   3156 FF FF FF FF 
3124   315A FF FF FF FF 
3124   315E FF FF FF FF 
3124   3162 FF FF FF FF 
3124   3166 FF FF FF FF 
3124   316A FF FF FF FF 
3124   316E FF FF FF FF 
3124   3172 FF FF FF FF 
3124   3176 FF FF FF FF 
3124   317A FF FF FF FF 
3124   317E FF FF FF FF 
3124   3182 FF FF FF FF 
3124   3186 FF FF FF FF 
3124   318A FF FF FF FF 
3124   318E FF FF FF FF 
3124   3192 FF FF FF FF 
3124   3196 FF FF FF FF 
3124   319A FF FF FF FF 
3124   319E FF FF FF FF 
3124   31A2 FF FF FF FF 
3124   31A6 FF FF FF FF 
3124   31AA FF FF FF FF 
3124   31AE FF FF FF FF 
3124   31B2 FF FF FF FF 
3124   31B6 FF FF FF FF 
3124   31BA FF FF FF FF 
3124   31BE FF FF FF FF 
3124   31C2 FF FF FF FF 
3124   31C6 FF FF FF FF 
3124   31CA FF FF FF FF 
3124   31CE FF FF FF FF 
3124   31D2 FF FF FF FF 
3124   31D6 FF FF FF FF 
3124   31DA FF FF FF FF 
3124   31DE FF FF FF FF 
3124   31E2 FF FF FF FF 
3124   31E6 FF FF FF FF 
3124   31EA FF FF FF FF 
3124   31EE FF FF FF FF 
3124   31F2 FF FF FF FF 
3124   31F6 FF FF FF FF 
3124   31FA FF FF FF FF 
3124   31FE FF FF FF FF 
3124   3202 FF FF FF FF 
3124   3206 FF FF FF FF 
3124   320A FF FF FF FF 
3124   320E FF FF FF FF 
3124   3212 FF FF FF FF 
3124   3216 FF FF FF FF 
3124   321A FF FF FF FF 
3125   321E             transient_area:
3126   321E 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
3127   321F             
3128   321F             .end
tasm: Number of errors = 0
