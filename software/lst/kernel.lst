0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data             .equ $ff80         ; data
0034   0000             _uart0_dlab_0           .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1           .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier              .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr              .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr              .equ $ff83         ; line control register
0039   0000             _uart0_lsr              .equ $ff85         ; line status register
0040   0000                                   
0041   0000             _uart1_data             .equ $ff88         ; data
0042   0000             _uart1_dlab_0           .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1           .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier              .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr              .equ $ff8A         ; fifo control register
0046   0000             _uart1_lcr              .equ $ff8B         ; line control register
0047   0000             _uart1_lsr              .equ $ff8D         ; line status register
0048   0000                                   
0049   0000             _ide_base               .equ $ffd0         ; ide base
0050   0000             _ide_r0                 .equ _ide_base + 0 ; data port
0051   0000             _ide_r1                 .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2                 .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3                 .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4                 .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5                 .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6                 .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7                 .equ _ide_base + 7 ; read: status, write: command       
0058   0000                                   
0059   0000             _til311_display         .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl         .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a                  .equ $ffb0    
0062   0000             _pio_b                  .equ $ffb1
0063   0000             _pio_c                  .equ $ffb2
0064   0000             _pio_control            .equ $ffb3         ; pio control port
0065   0000                                   
0066   0000             _fdc_config             .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0           .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd           .equ $ffc8         ; status / command register
0069   0000             _fdc_track              .equ $ffc9         ; track register
0070   0000             _fdc_sector             .equ $ffca         ; sector register
0071   0000             _fdc_data               .equ $ffcb         ; data register
0072   0000                                   
0073   0000             _timer_c_0              .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1              .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2              .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl             .equ $ffe3         ; timer control register
0077   0000                                   
0078   0000             _stack_top              .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size              .equ 4096
0080   0000             _scrap_size             .equ 512
0081   0000             
0082   0000             _file_type_null         .equ 0
0083   0000             _file_type_reg          .equ 1
0084   0000             _file_type_chardev      .equ 2
0085   0000             _file_type_blockdev     .equ 3
0086   0000             
0087   0000             proc_unused             .equ 0  ; slot free
0088   0000             proc_runnable           .equ 1  ; ready to run
0089   0000             proc_running            .equ 2  ; currently on cpu
0090   0000             proc_sleeping           .equ 3  ; waiting for event
0091   0000             proc_zombie             .equ 4  ; exited, not reaped
0092   0000             
0093   0000             
0094   0000             _num_cpu_regs           .equ 21                                     ; A, B, C, D, G, PC, BP, SP, SI, DI, FLAGS
0095   0000             _max_user_proc          .equ 128                                    ; max number of concurrent user processes
0096   0000             _fd_per_proc            .equ 32                                     ; for kernel's file descriptor table per process
0097   0000             _num_file_objs          .equ 128                                    ; for the kernel's file object table
0098   0000             _size_file_obj_entry    .equ 1 + 2 + 1 + 2 + 2 + (4 * 2)            ; refcount, flags, type, target, offset, ops
0099   0000             _size_file_obj_table    .equ _num_file_objs * _size_file_obj_entry  ; kernel's file object table
0100   0000             
0101   0000             _size_proc_entry        .equ 1 + 1 + 1 + _fd_per_proc * 2 + 2 + _num_cpu_regs + 38 ; pid, parent_pid, state, fd_table, tty pointer, context (general regs + flags), 38 bytes padding to reach 128
0102   0000             _size_proc_table        .equ _size_proc_entry * _max_user_proc  ; 16k total
0103   0000             
0104   0000             
0105   0000             text_org                .equ $400          ; code origin address for all user processes
0106   0000             data_blocks_sect_start  .equ 4124
0107   0000             
0108   0000             ;  ------------------------------------------------------------------------------------------------------------------;
0109   0000             ;  DISK LAYOUT:
0110   0000             ;  Metadata               | Size (bytes)      | Blocks (2048 bytes)              |Start Block |  Comment
0111   0000             ;  ---------------------- | ----------------- | -------------------------------- |------------|-----------------------------------
0112   0000             ;  Bootloader/MBR         | 1024 bytes        | 0.5 (1 sector)                   |  0         |
0113   0000             ;  Superblock             | 1024 bytes        | 1 block (2048 bytes, must align) |  0         |
0114   0000             ;                         |                   | 1 block (2048 bytes)             |  1         | reserved
0115   0000             ;  Block Bitmap           | 8,192 bytes       | 4 blocks                         |  2         | 4*2048*8 = 4*16384 = 65536 raw data blocks.  65536*2048 bytes = 134217728 bytes of disk space = 128MB
0116   0000             ;  Inode Bitmap           | 2,048 bytes       | 1 block                          |  6         | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is 1 inode per 8KB of disk space
0117   0000             ;  Inode Table            | 2,097,152 bytes   | 1024 blocks                      |  7         | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0118   0000             ;  Data Blocks            | 134,217,728 bytes | 65528 blocks                     | 1031       | 65528 blocks = 134,201,344 bytes
0119   0000             ;  
0120   0000             ;  first 1024 bytes: bootloader from 0 to 959, MBR partition table from 960 (64 bytes)
0121   0000             ;  up to 4 partitions, each 16 bytes long
0122   0000             ;  MBR:
0123   0000             ;  Byte | Description
0124   0000             ;  -----|----------------------------
0125   0000             ;  0    | Boot flag (0x80 active, 0x00 inactive)
0126   0000             ;  1-3  | Start CHS (head, sector, cylinder)
0127   0000             ;  4    | Partition type (filesystem ID)
0128   0000             ;    0x83 = Linux native (ext2/3/4)
0129   0000             ;    0x07 = NTFS/exFAT
0130   0000             ;    0x0B = FAT32 CHS
0131   0000             ;    0x0C = FAT32 LBA
0132   0000             ;    0x05 = Extended partition
0133   0000             ;    0x86 = Sol-1 partition
0134   0000             ;  5-7  | End CHS
0135   0000             ;  8-11 | Start LBA (little endian)
0136   0000             ;  12-15| Size in sectors (little endian)
0137   0000             ;  
0138   0000             ;  
0139   0000             ;  the superblock describers the filesystem as a whole such as inode count, free inode count, location of the raw data bitmap, inode table, etc.  
0140   0000             ;  SUPERBLOCK:
0141   0000             ;  | Field               | Description                               | Typical Size (bytes) | Notes                           |
0142   0000             ;  | ------------------- | ----------------------------------------- | -------------------- | ------------------------------- |
0143   0000             ;  | inodes_count        | Total number of inodes in the filesystem  | 2                    | 16-bit unsigned int             |
0144   0000             ;  | blocks_count        | Total number of data blocks               | 2                    | 16-bit unsigned int             |
0145   0000             ;  | free_inodes_count   | Number of free inodes                     | 2                    | 16-bit unsigned int             |
0146   0000             ;  | free_blocks_count   | Number of free blocks                     | 2                    | 16-bit unsigned int             |
0147   0000             ;  | block_bitmap        | Block ID of the **block bitmap**          | 2                    | 16-bit unsigned int
0148   0000             ;  | inode_bitmap        | Block ID of the **inode bitmap**          | 2                    | 16-bit unsigned int
0149   0000             ;  | inode_table         | Starting block of **inode table**         | 2                    | 16-bit unsigned int
0150   0000             ;  | first_data_block    | Block number of the first data block      | 2                    | 16-bit unsigned int             |
0151   0000             ;  | used_dirs_count     | Number of inodes allocated to directories | 2
0152   0000             ;  | log_block_size      | Block size = 1024 << `s_log_block_size    | 2                    | 16-bit unsigned int             |
0153   0000             ;  | mtime               | Last mount time                           | 4                    | 32-bit unsigned int (Unix time) |
0154   0000             ;  | wtime               | Last write time                           | 4                    | 32-bit unsigned int (Unix time) |
0155   0000             ;  | uuid                | Unique ID of the filesystem               | 16                   | 128-bit UUID                    |
0156   0000             ;  | volume_name         | Label of the filesystem                   | 16                   | Usually ASCII, padded           |
0157   0000             ;  | feature_flags       | Compatibility flags                       | 4                    | 32-bit unsigned int             |
0158   0000             ;  
0159   0000             ;  inode for root dir is #2, #0 and #1 not used
0160   0000             ;  raw data block #0 is not used. because 0 as a block ID means not used
0161   0000             ;  block size: 2048
0162   0000             ;  inode-table format:
0163   0000             ;  | Field         | Size (bytes) | Description                                                                                  |
0164   0000             ;  | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0165   0000             ;  | `mode`        | 2            | File type and permissions                                                                    |
0166   0000             ;  | `uid`         | 2            | Owner user ID                                                                                |
0167   0000             ;  | `size`        | 4            | Size of the file in bytes                                                                    |
0168   0000             ;  | `atime`       | 4            | Last access time (timestamp)                                                                 |
0169   0000             ;  | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0170   0000             ;  | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0171   0000             ;  | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0172   0000             ;  | `gid`         | 2            | Group ID                                                                                     |
0173   0000             ;  | `links_count` | 2            | Number of hard links                                                                         |
0174   0000             ;  | `blocks`      | 2            | Number of 2048-byte blocks allocated                                                         |
0175   0000             ;  | `flags`       | 4            | File flags                                                                                   |
0176   0000             ;  | `block`       | 47 * 2 = 94  | Pointers to data blocks (47 direct only) 
0177   0000             ;
0178   0000             ;
0179   0000             ;  DIRECTORY ENTRY
0180   0000             ;  this is the structure for file entries inside a directory.
0181   0000             ;  2048 / 64 = 32 entries
0182   0000             ;
0183   0000             ;  each entry is 64 bytes wide
0184   0000             ;  uint16_t inode;      // Inode number (0 if entry is unused)
0185   0000             ;  char     name[62];   // File name (null terminated)
0186   0000             
0187   0000             ; ------------------------------------------------------------------------------------------------------------------;
0188   0000             ; global system variables
0189   0000             ; ------------------------------------------------------------------------------------------------------------------;
0190   0000             
0191   0000             ; ------------------------------------------------------------------------------------------------------------------;
0192   0000             ; irq table
0193   0000             ; highest priority at lowest address
0194   0000             ; ------------------------------------------------------------------------------------------------------------------;
0195   0000 32 00       .dw int_0_fdc
0196   0002 39 00       .dw int_1
0197   0004 3A 00       .dw int_2
0198   0006 3B 00       .dw int_3
0199   0008 3C 00       .dw int_4
0200   000A 3D 00       .dw int_5_uart1
0201   000C 5F 00       .dw int_6_timer
0202   000E 60 00       .dw int_7_uart0
0203   0010             
0204   0010             ; ------------------------------------------------------------------------------------------------------------------;
0205   0010             ; kernel reset vector
0206   0010             ; ------------------------------------------------------------------------------------------------------------------;
0207   0010 0F 05       .dw kernel_reset_vector
0208   0012             
0209   0012             ; ------------------------------------------------------------------------------------------------------------------;
0210   0012             ; exception vector table
0211   0012             ; total of 7 entries, starting at address $0012
0212   0012             ; ------------------------------------------------------------------------------------------------------------------;
0213   0012 71 01       .dw trap_privilege
0214   0014 37 02       .dw trap_div_zero
0215   0016 44 02       .dw trap_undef_opcode
0216   0018 00 00       .dw 0
0217   001A 00 00       .dw 0
0218   001C 00 00       .dw 0
0219   001E 00 00       .dw 0
0220   0020             
0221   0020             ; ------------------------------------------------------------------------------------------------------------------;
0222   0020             ; system call vector table
0223   0020             ; starts at address $0020
0224   0020             ; ------------------------------------------------------------------------------------------------------------------;
0225   0020 7C 01       .dw syscall_break
0226   0022 45 02       .dw syscall_rtc
0227   0024 68 03       .dw syscall_ide
0228   0026 28 04       .dw syscall_io
0229   0028 DF 04       .dw syscall_file
0230   002A 77 02       .dw syscall_datetime
0231   002C 65 01       .dw syscall_reboot
0232   002E 31 01       .dw syscall_system
0233   0030 85 00       .dw syscall_fork
0234   0032             
0235   0032             ; ------------------------------------------------------------------------------------------------------------------;
0236   0032             ; system call aliases
0237   0032             ; ------------------------------------------------------------------------------------------------------------------;
0238   0032             sys_break            .equ 0
0239   0032             sys_rtc              .equ 1
0240   0032             sys_ide              .equ 2
0241   0032             sys_io               .equ 3
0242   0032             sys_file             .equ 4
0243   0032             sys_datetime         .equ 5
0244   0032             sys_reboot           .equ 6
0245   0032             sys_system           .equ 7
0246   0032             sys_fork             .equ 8
0247   0032             
0248   0032             ; ------------------------------------------------------------------------------------------------------------------;
0249   0032             ; alias exports
0250   0032             ; ------------------------------------------------------------------------------------------------------------------;
0251   0032             .export text_org
0252   0032             .export sys_break
0253   0032             .export sys_rtc
0254   0032             .export sys_ide
0255   0032             .export sys_io
0256   0032             .export sys_file
0257   0032             .export sys_datetime
0258   0032             .export sys_reboot
0259   0032             .export sys_system
0260   0032             .export sys_fork
0261   0032             
0262   0032             .export _til311_display
0263   0032             
0264   0032             .export _fdc_config        
0265   0032             .export _fdc_status_0      
0266   0032             .export _fdc_stat_cmd     
0267   0032             
0268   0032             ; ------------------------------------------------------------------------------------------------------------------;
0269   0032             ; irqs' code block
0270   0032             ; ------------------------------------------------------------------------------------------------------------------;
0271   0032             ; 5.25" floppy drive controller irq
0272   0032             int_0_fdc:
0273   0032 3B E8 0E      mov d, s_fdc_irq
0274   0035 07 7B 07      call _puts
0275   0038 06            sysret
0276   0039             int_1:
0277   0039 06            sysret
0278   003A             int_2:
0279   003A 06            sysret
0280   003B             int_3:
0281   003B 06            sysret
0282   003C             int_4:
0283   003C 06            sysret
0284   003D             
0285   003D             ; ------------------------------------------------------------------------------------------------------------------;
0286   003D             ; uart1 interrupt
0287   003D             ; ------------------------------------------------------------------------------------------------------------------;
0288   003D             int_5_uart1:
0289   003D D7            push a
0290   003E DA            push d
0291   003F E1            pushf
0292   0040 1D 88 FF      mov al, [_uart1_data]       ; get character
0293   0043               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0294   0043 3B AE 0C      mov d, fifo_in
0295   0046 FD 2A         mov d, [d]
0296   0048 3E            mov [d], al                 ; add to fifo
0297   0049 13            mov a, d
0298   004A 77            inc a
0299   004B AF 13 20      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0300   004E C7 54 00      jne int_5_continue
0301   0051 10 13 10      mov a, fifo  
0302   0054             int_5_continue:  
0303   0054 42 AE 0C      mov [fifo_in], a            ; update fifo pointer
0304   0057 1A            mov al, ah
0305   0058 3D B0 FF      mov [_til311_display], al
0306   005B EE            popf
0307   005C E7            pop d
0308   005D E4            pop a  
0309   005E 06            sysret
0310   005F             
0311   005F             ; ------------------------------------------------------------------------------------------------------------------;
0312   005F             ; timer irq
0313   005F             ; ------------------------------------------------------------------------------------------------------------------;
0314   005F             int_6_timer:  
0315   005F 06            sysret
0316   0060             
0317   0060             ; ------------------------------------------------------------------------------------------------------------------;
0318   0060             ; uart0 interrupt
0319   0060             ; ------------------------------------------------------------------------------------------------------------------;
0320   0060             int_7_uart0:
0321   0060 D7            push a
0322   0061 DA            push d
0323   0062 E1            pushf
0324   0063 1D 80 FF      mov al, [_uart0_data]       ; get character
0325   0066               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0326   0066 3B AE 0C      mov d, fifo_in
0327   0069 FD 2A         mov d, [d]
0328   006B 3E            mov [d], al                 ; add to fifo
0329   006C 13            mov a, d
0330   006D 77            inc a
0331   006E AF 13 20      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0332   0071 C7 77 00      jne int_7_continue
0333   0074 10 13 10      mov a, fifo  
0334   0077             int_7_continue:  
0335   0077 42 AE 0C      mov [fifo_in], a            ; update fifo pointer
0336   007A 1A            mov al, ah
0337   007B 3D B0 FF      mov [_til311_display], al
0338   007E EE            popf
0339   007F E7            pop d
0340   0080 E4            pop a  
0341   0081 06            sysret
0342   0082             
0343   0082             sys_mkfs:
0344   0082 06            sysret
0345   0083             
0346   0083             ; ------------------------------------------------------------------------------------------------------------------;
0347   0083             ; process syscalls
0348   0083             ; ------------------------------------------------------------------------------------------------------------------;
0349   0083             ; look for empty process slot
0350   0083             ; initialize new process
0351   0083             ; copy old process kernel table entries
0352   0083             ; copy old process image into new one
0353   0083             fork_jmptbl:
0354   0083 89 00         .dw fork
0355   0085             syscall_fork:
0356   0085 FD 0A 83 00   jmp [fork_jmptbl + al]
0357   0089             
0358   0089             fork:
0359   0089 1D 82 0F      mov al, [curr_pid]
0360   008C 22 00         mov ah, 0
0361   008E FD 9D 07      shl a, 7          ; mul by 128
0362   0091 53 93 0F      add a, proc_table
0363   0094 4D            mov si, a
0364   0095 07 0E 01      call find_empty_proc_slot  ; result proc entry address in a
0365   0098 4F            mov di, a
0366   0099 38 80 00      mov c, 128
0367   009C FD F5         rep movsb  ; copy proc structure from old to new
0368   009E             
0369   009E               ; TODO: need to write better function to allocate new PIDs and check that they are not already used etc
0370   009E 3C            mov d, a  ; new process entry base
0371   009F 1D 80 0F      mov al, [pid_counter]
0372   00A2 3E            mov [d], al   ; set new PID
0373   00A3 DB            push al  ; save new process PID for using below
0374   00A4 7A            inc al
0375   00A5 3D 80 0F      mov [pid_counter], al ; update global pid counter
0376   00A8             
0377   00A8 1D 82 0F      mov al, [curr_pid]
0378   00AB 3F 01 00      mov [d + 1], al ; set parent pid
0379   00AE 19 01         mov al, proc_runnable
0380   00B0 3F 02 00      mov [d + 2], al ; set process as runnable
0381   00B3             
0382   00B3               ; the offset of the register context is 69
0383   00B3               ; for parent the return value in A is the child's PID
0384   00B3               ; and for the child the return value in A is 0
0385   00B3               ; so we need to place 0 in the A register in the new process' context block
0386   00B3 19 00         mov al, 0
0387   00B5 3F 45 00      mov [d + 69], al  ; child PID return value = 0
0388   00B8             
0389   00B8               ; obtain parent(current) process' entry offset again
0390   00B8 1D 82 0F      mov al, [curr_pid]
0391   00BB 22 00         mov ah, 0
0392   00BD FD 9D 07      shl a, 7  ; mul by 128
0393   00C0 53 93 0F      add a, proc_table
0394   00C3 3C            mov d, a
0395   00C4 E8            pop al   ; retrieve new child process PID that we obained before
0396   00C5 3F 45 00      mov [d + 69], al  ; and now copy that child PID into the parent's context's return value in A register
0397   00C8             
0398   00C8               ; now copy the entire parent's code image into the child's
0399   00C8 07 CC 00      call fork_image_copy
0400   00CB             
0401   00CB               ; now copy entire memory of old process into new process' memory
0402   00CB 06            sysret
0403   00CC             
0404   00CC             ; copy entire image from one process to another
0405   00CC             ; al: new proc PID
0406   00CC             ; curr_pid: origin process
0407   00CC             fork_image_copy:
0408   00CC B8 0C 01 00   mov word[tmp_si], 0
0408   00D0 00 
0409   00D1 B8 0A 01 00   mov word[tmp_di], 0
0409   00D5 00 
0410   00D6             
0411   00D6 DB            push al
0412   00D7             
0413   00D7 1D 82 0F      mov al, [curr_pid]
0414   00DA 01            setptb ; set page table base to curr_proc PID
0415   00DB 29 0C 01      mov b, [tmp_si]
0416   00DE FD 28         mov si, b
0417   00E0 FD 4F 13 22   mov di, transient_area
0418   00E4 38 00 08      mov c, 2048
0419   00E7 04            load    ; copy one page
0420   00E8 D3 00 08      add si, 2048
0421   00EB 4E            mov a, si
0422   00EC 42 0C 01      mov [tmp_si], a
0423   00EF             
0424   00EF E8            pop al
0425   00F0 01            setptb ; set page table base to new proc PID
0426   00F1 29 0C 01      mov b, [tmp_si]
0427   00F4 FD 28         mov si, b
0428   00F6 FD 4D 13 22   mov si, transient_area
0429   00FA 14 0A 01      mov a, [tmp_di]
0430   00FD 4F            mov di, a
0431   00FE 38 00 08      mov c, 2048
0432   0101 03            store
0433   0102 D4 00 08      add di, 2048
0434   0105 4E            mov a, si
0435   0106 42 0A 01      mov [tmp_di], a
0436   0109             
0437   0109 09            ret
0438   010A             
0439   010A 00 00       tmp_di: .dw 0
0440   010C 00 00       tmp_si: .dw 0
0441   010E             
0442   010E             ; pid, parent_pid, state, fd_table, tty pointer, context (general regs + flags), 38 bytes padding to reach 128
0443   010E             ; return index in b
0444   010E             ; address in a
0445   010E             find_empty_proc_slot:
0446   010E 3B 93 0F      mov d, proc_table
0447   0111 26 00 00      mov b, 0
0448   0114             find_empty_proc_slot_l0:
0449   0114 1E            mov al, [d]
0450   0115 B9 00         cmp al, 0
0451   0117 C6 25 01      je find_empty_proc_slot_ret
0452   011A 58 80 00      add d, 128
0453   011D FD 77         inc b
0454   011F C0 80 00      cmp b, _max_user_proc  ; if we go past _max_user_proc (128) that is considered an error
0455   0122 C7 14 01      jne find_empty_proc_slot_l0
0456   0125             find_empty_proc_slot_ret:
0457   0125 13            mov a, d
0458   0126 09            ret  ; return in 'bl'
0459   0127             
0460   0127             ; ------------------------------------------------------------------------------------------------------------------;
0461   0127             ; system syscalls
0462   0127             ; ------------------------------------------------------------------------------------------------------------------;
0463   0127             system_jmptbl:
0464   0127 5D 01         .dw system_uname
0465   0129 64 01         .dw system_whoami
0466   012B 37 01         .dw system_poke
0467   012D 3A 01         .dw system_bootloader_install
0468   012F 35 01         .dw system_peek
0469   0131             syscall_system:
0470   0131 FD 0A 27 01   jmp [system_jmptbl + al]
0471   0135             
0472   0135             ; param register address in register d
0473   0135             ; param value in register bl
0474   0135             system_peek:
0475   0135 32            mov bl, [d]
0476   0136 06            sysret
0477   0137             
0478   0137             ; param register address in register d
0479   0137             ; param value in register bl
0480   0137             system_poke:
0481   0137 FD 3E         mov [d], bl
0482   0139 06            sysret
0483   013A             
0484   013A             ; kernel LBA address in 'b'
0485   013A             system_bootloader_install:
0486   013A D8            push b
0487   013B 26 00 00      mov b, 0
0488   013E 38 00 00      mov c, 0
0489   0141 22 01         mov ah, $01                 ; 1 sector
0490   0143 3B 13 22      mov d, transient_area
0491   0146 07 97 03      call ide_read_sect          ; read sector
0492   0149 E5            pop b
0493   014A FD 44 FE 01   mov [d + 510], b            ; update LBA address
0494   014E 26 00 00      mov b, 0
0495   0151 38 00 00      mov c, 0
0496   0154 22 01         mov ah, $01                 ; 1 sector
0497   0156 3B 13 22      mov d, transient_area
0498   0159 07 BD 03      call ide_write_sect         ; write sector
0499   015C 06            sysret
0500   015D             
0501   015D             system_uname:
0502   015D 3B BD 0C      mov d, s_uname
0503   0160 07 7B 07      call _puts
0504   0163 06            sysret
0505   0164             
0506   0164             system_whoami:
0507   0164 06            sysret
0508   0165             
0509   0165             ; reboot system
0510   0165             syscall_reboot:
0511   0165 FD D7 FF FF   push word $ffff 
0512   0169 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0513   016C FD D7 90 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0514   0170 06            sysret
0515   0171             
0516   0171             
0517   0171             ; ------------------------------------------------------------------------------------------------------------------;
0518   0171             ; exceptions code block
0519   0171             ; ------------------------------------------------------------------------------------------------------------------;
0520   0171             ; privilege exception
0521   0171             ; ------------------------------------------------------------------------------------------------------------------;
0522   0171             trap_privilege:
0523   0171 DA            push d
0524   0172 3B D5 0D      mov d, s_priviledge
0525   0175 07 7B 07      call _puts
0526   0178 E7            pop d
0527   0179 0A 65 01      jmp syscall_reboot
0528   017C             
0529   017C             ; ------------------------------------------------------------------------------------------------------------------;
0530   017C             ; breakpoint
0531   017C             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0532   017C             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0533   017C             ; ------------------------------------------------------------------------------------------------------------------;
0534   017C             syscall_break:
0535   017C 4B            pusha
0536   017D             syscall_break_prompt:
0537   017D 3B 07 0E      mov d, s_break1
0538   0180 07 7B 07      call _puts
0539   0183 07 28 07      call printnl
0540   0186 07 7D 08      call scan_u16d
0541   0189 AF 00 00      cmp a, 0
0542   018C C6 97 01      je syscall_break_regs
0543   018F AF 01 00      cmp a, 1
0544   0192 C6 BA 01      je syscall_break_mem
0545   0195             syscall_break_end:  
0546   0195 4C            popa
0547   0196 06            sysret
0548   0197             syscall_break_regs:
0549   0197 48            mov a, sp
0550   0198 53 0E 00      add a, 14               ; back-track 7 registers
0551   019B 3C            mov d, a
0552   019C 3A 07         mov cl, 7
0553   019E             syscall_regs_l0:
0554   019E 2A            mov b, [d]
0555   019F FD AB         swp b
0556   01A1 07 D7 07      call print_u16x         ; print register value
0557   01A4 07 28 07      call printnl
0558   01A7 63 02 00      sub d, 2
0559   01AA 71 01         sub cl, 1
0560   01AC C3 00         cmp cl, 0
0561   01AE C7 9E 01      jne syscall_regs_l0
0562   01B1 0A 7D 01      jmp syscall_break_prompt
0563   01B4 07 28 07      call printnl
0564   01B7 0A 7D 01      jmp syscall_break_prompt
0565   01BA             syscall_break_mem:
0566   01BA 07 28 07      call printnl
0567   01BD 07 F9 07      call scan_u16x
0568   01C0 4D            mov si, a               ; data source from user space
0569   01C1 FD 4F 13 20   mov di, scrap_sector    ; destination in kernel space
0570   01C5 38 00 02      mov c, 512
0571   01C8 04            load                    ; transfer data to kernel space!
0572   01C9 3B 13 20      mov d, scrap_sector     ; dump pointer in d
0573   01CC 38 00 00      mov c, 0
0574   01CF             dump_loop:
0575   01CF 84            mov al, cl
0576   01D0 87 0F         and al, $0f
0577   01D2 C6 20 02      jz print_base
0578   01D5             back:
0579   01D5 1E            mov al, [d]             ; read byte
0580   01D6 2F            mov bl, al
0581   01D7 07 1B 08      call print_u8x
0582   01DA 10 00 20      mov a, $2000
0583   01DD 05 03         syscall sys_io          ; space
0584   01DF 84            mov al, cl
0585   01E0 87 0F         and al, $0f
0586   01E2 B9 0F         cmp al, $0f
0587   01E4 C6 F5 01      je print_ascii
0588   01E7             back1:
0589   01E7 79            inc d
0590   01E8 78            inc c
0591   01E9 C2 00 02      cmp c, 512
0592   01EC C7 CF 01      jne dump_loop
0593   01EF 07 28 07      call printnl
0594   01F2 0A 7D 01      jmp syscall_break_prompt  ; go to syscall_break return point
0595   01F5             print_ascii:
0596   01F5 10 00 20      mov a, $2000
0597   01F8 05 03         syscall sys_io
0598   01FA 63 10 00      sub d, 16
0599   01FD 26 10 00      mov b, 16
0600   0200             print_ascii_l:
0601   0200 79            inc d
0602   0201 1E            mov al, [d]               ; read byte
0603   0202 B9 20         cmp al, $20
0604   0204 C8 0C 02      jlu dot
0605   0207 B9 7E         cmp al, $7e
0606   0209 D0 14 02      jleu ascii
0607   020C             dot:
0608   020C 10 00 2E      mov a, $2e00
0609   020F 05 03         syscall sys_io
0610   0211 0A 19 02      jmp ascii_continue
0611   0214             ascii:
0612   0214 23            mov ah, al
0613   0215 19 00         mov al, 0
0614   0217 05 03         syscall sys_io
0615   0219             ascii_continue:
0616   0219 FD A9 00 02   loopb print_ascii_l
0617   021D 0A E7 01      jmp back1
0618   0220             print_base:
0619   0220 07 28 07      call printnl
0620   0223 2D            mov b, d
0621   0224 61 13 20      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0622   0227 07 D7 07      call print_u16x          ; display row
0623   022A 10 00 3A      mov a, $3a00
0624   022D 05 03         syscall sys_io
0625   022F 10 00 20      mov a, $2000
0626   0232 05 03         syscall sys_io
0627   0234 0A D5 01      jmp back
0628   0237             
0629   0237             ; ------------------------------------------------------------------------------------------------------------------;
0630   0237             ; divide by zero exception
0631   0237             ; ------------------------------------------------------------------------------------------------------------------;
0632   0237             trap_div_zero:
0633   0237 D7            push a
0634   0238 DA            push d
0635   0239 E1            pushf
0636   023A 3B EC 0D      mov d, s_divzero
0637   023D 07 7B 07      call _puts
0638   0240 EE            popf
0639   0241 E7            pop d
0640   0242 E4            pop a
0641   0243 06            sysret ; enable interrupts
0642   0244             
0643   0244             ; ------------------------------------------------------------------------------------------------------------------;
0644   0244             ; undefined opcode exception
0645   0244             ; ------------------------------------------------------------------------------------------------------------------;
0646   0244             trap_undef_opcode:
0647   0244 06            sysret
0648   0245             
0649   0245             ; ------------------------------------------------------------------------------------------------------------------;
0650   0245             ; real-time clock services syscall
0651   0245             ; rtc i/o bank = ffa0 to ffaf
0652   0245             ; ffa0 to ffa7 is scratch ram
0653   0245             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0654   0245             ; al = 0..6 -> get
0655   0245             ; al = 7..d -> set
0656   0245             ; ------------------------------------------------------------------------------------------------------------------;
0657   0245             syscall_rtc:
0658   0245 DB            push al
0659   0246 DA            push d
0660   0247 B9 06         cmp al, 6
0661   0249 D1 5E 02      jgu syscall_rtc_set
0662   024C             syscall_rtc_get:
0663   024C 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0664   024E 22 FF         mov ah, $ff    
0665   0250 3C            mov d, a                ; get to ffa9 + offset
0666   0251 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0667   0255 1E            mov al, [d]             ; get data
0668   0256 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0669   025A 23            mov ah, al
0670   025B E7            pop d
0671   025C E8            pop al
0672   025D 06            sysret
0673   025E             syscall_rtc_set:
0674   025E DD            push bl
0675   025F 99            mov bl, ah              ; set data aside
0676   0260 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0677   0262 22 FF         mov ah, $ff    
0678   0264 3C            mov d, a                ; get to ffa9 + offset
0679   0265 1B            mov al, bl              ; get data back
0680   0266 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0681   026A 3E            mov [d], al             ; set data
0682   026B F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0683   026F EA            pop bl
0684   0270 E7            pop d
0685   0271 E8            pop al
0686   0272 06            sysret
0687   0273             
0688   0273             datetime_serv_tbl:
0689   0273 7B 02         .dw print_date
0690   0275 EF 02         .dw set_date
0691   0277             syscall_datetime:
0692   0277 FD 0A 73 02   jmp [datetime_serv_tbl + al]      
0693   027B             print_date:
0694   027B 10 00 0D      mov a, $0d00           ; print carriage return char
0695   027E 19 03         mov al, 3
0696   0280 05 01         syscall sys_rtc        ; get week
0697   0282 1A            mov al, ah
0698   0283 22 00         mov ah, 0
0699   0285 FD 9D 02      shl a, 2          
0700   0288 3B CC 0E      mov d, s_week
0701   028B 59            add d, a
0702   028C 07 7B 07      call _puts
0703   028F 10 00 20      mov a, $2000
0704   0292 05 03         syscall sys_io         ; display ' '
0705   0294 19 04         mov al, 4
0706   0296 05 01         syscall sys_rtc        ; get day
0707   0298 99            mov bl, ah
0708   0299 07 1B 08      call print_u8x
0709   029C 10 00 20      mov a, $2000
0710   029F 05 03         syscall sys_io         ; display ' '
0711   02A1             ; there is a problem with the month displaying
0712   02A1             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0713   02A1             ; even though it is to be understood as bcd.
0714   02A1             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0715   02A1 19 05         mov al, 05
0716   02A3 05 01         syscall sys_rtc        ; get month
0717   02A5 1A            mov al, ah
0718   02A6 22 00         mov ah, 0
0719   02A8 FD 9D 02      shl a, 2          
0720   02AB 3B 98 0E      mov d, s_months
0721   02AE 59            add d, a
0722   02AF 07 7B 07      call _puts
0723   02B2 10 00 20      mov a, $2000
0724   02B5 05 03         syscall sys_io         ; display ' '
0725   02B7 2E 20         mov bl, $20
0726   02B9 07 1B 08      call print_u8x         ; print 20 for year prefix
0727   02BC 19 06         mov al, 06
0728   02BE 05 01         syscall sys_rtc        ; get year
0729   02C0 99            mov bl, ah
0730   02C1 07 1B 08      call print_u8x
0731   02C4 10 00 20      mov a, $2000  
0732   02C7 05 03         syscall sys_io         ; display ' '
0733   02C9 19 02         mov al, 2
0734   02CB 05 01         syscall sys_rtc        ; get hours
0735   02CD 99            mov bl, ah
0736   02CE 07 1B 08      call print_u8x
0737   02D1 10 00 3A      mov a, $3a00    
0738   02D4 05 03         syscall sys_io         ; display ':'
0739   02D6 19 01         mov al, 01
0740   02D8 05 01         syscall sys_rtc        ; get minutes
0741   02DA 99            mov bl, ah
0742   02DB 07 1B 08      call print_u8x
0743   02DE 10 00 3A      mov a, $3a00  
0744   02E1 05 03         syscall sys_io         ; display ':'
0745   02E3 19 00         mov al, 0
0746   02E5 05 01         syscall sys_rtc        ; get seconds
0747   02E7 99            mov bl, ah
0748   02E8 07 1B 08      call print_u8x
0749   02EB 07 28 07      call printnl
0750   02EE 06            sysret
0751   02EF             set_date:
0752   02EF 3B 5D 0E      mov d, s_set_year
0753   02F2 07 7B 07      call _puts
0754   02F5 07 66 08      call scan_u8x          ; read integer into a
0755   02F8 FD 9D 08      shl a, 8               ; only al used, move to ah
0756   02FB 19 0D         mov al, 0dh            ; set rtc year
0757   02FD 05 01         syscall sys_rtc        ; set rtc
0758   02FF 3B 64 0E      mov d, s_set_month
0759   0302 07 7B 07      call _puts
0760   0305 07 66 08      call scan_u8x          ; read integer into a
0761   0308 FD 9D 08      shl a, 8               ; only al used, move to ah
0762   030B 19 0C         mov al, 0ch            ; set rtc month
0763   030D 05 01         syscall sys_rtc        ; set rtc
0764   030F 3B 6C 0E      mov d, s_set_day
0765   0312 07 7B 07      call _puts
0766   0315 07 66 08      call scan_u8x          ; read integer into a
0767   0318 FD 9D 08      shl a, 8               ; only al used, move to ah
0768   031B 19 0B         mov al, 0bh            ; set rtc month
0769   031D 05 01         syscall sys_rtc        ; set rtc
0770   031F 3B 72 0E      mov d, s_set_week
0771   0322 07 7B 07      call _puts
0772   0325 07 66 08      call scan_u8x          ; read integer into a
0773   0328 FD 9D 08      shl a, 8               ; only al used, move to ah
0774   032B 19 0A         mov al, 0ah            ; set rtc month
0775   032D 05 01         syscall sys_rtc        ; set rtc
0776   032F 3B 7C 0E      mov d, s_set_hours
0777   0332 07 7B 07      call _puts
0778   0335 07 66 08      call scan_u8x          ; read integer into a
0779   0338 FD 9D 08      shl a, 8               ; only al used, move to ah
0780   033B 19 09         mov al, 09h            ; set rtc month
0781   033D 05 01         syscall sys_rtc        ; set rtc
0782   033F 3B 84 0E      mov d, s_set_minutes
0783   0342 07 7B 07      call _puts
0784   0345 07 66 08      call scan_u8x          ; read integer into a
0785   0348 FD 9D 08      shl a, 8               ; only al used, move to ah
0786   034B 19 08         mov al, 08h            ; set rtc month
0787   034D 05 01         syscall sys_rtc        ; set rtc
0788   034F 3B 8E 0E      mov d, s_set_seconds
0789   0352 07 7B 07      call _puts
0790   0355 07 66 08      call scan_u8x          ; read integer into a
0791   0358 FD 9D 08      shl a, 8               ; only al used, move to ah
0792   035B 19 07         mov al, 07h            ; set rtc month
0793   035D 05 01         syscall sys_rtc        ; set rtc
0794   035F 06            sysret
0795   0360             
0796   0360             ; ------------------------------------------------------------------------------------------------------------------;
0797   0360             ; ide services syscall
0798   0360             ; al = option
0799   0360             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0800   0360             ; ide read/write sector
0801   0360             ; 512 bytes
0802   0360             ; user buffer pointer in d
0803   0360             ; ah = number of sectors
0804   0360             ; cb = lba bytes 3..0
0805   0360             ; ------------------------------------------------------------------------------------------------------------------;
0806   0360             ide_serv_tbl:
0807   0360 6C 03         .dw ide_reset
0808   0362 80 03         .dw ide_sleep
0809   0364 8F 03         .dw ide_read_sect_wrapper
0810   0366 93 03         .dw ide_write_sect_wrapper
0811   0368             syscall_ide:
0812   0368 FD 0A 60 03   jmp [ide_serv_tbl + al]    
0813   036C             
0814   036C             ide_reset:      
0815   036C F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
0816   0370 07 19 04      call ide_wait                   ; wait for ide ready             
0817   0373 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
0818   0377 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
0819   037B F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
0820   037F 06            sysret
0821   0380             ide_sleep:
0822   0380 07 19 04      call ide_wait                   ; wait for ide ready             
0823   0383 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
0824   0387 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
0825   038B 07 19 04      call ide_wait                   ; wait for ide ready
0826   038E 06            sysret
0827   038F             ide_read_sect_wrapper:
0828   038F 07 97 03      call ide_read_sect
0829   0392 06            sysret
0830   0393             ide_write_sect_wrapper:
0831   0393 07 BD 03      call ide_write_sect
0832   0396 06            sysret
0833   0397             ide_read_sect:
0834   0397 1A            mov al, ah
0835   0398 24            mov ah, bl
0836   0399 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0837   039C 1C            mov al, bh
0838   039D 3D D4 FF      mov [_ide_r4], al
0839   03A0 12            mov a, c
0840   03A1 3D D5 FF      mov [_ide_r5], al
0841   03A4 1A            mov al, ah
0842   03A5 87 0F         and al, %00001111
0843   03A7 8B E0         or al, %11100000                ; mode lba, master
0844   03A9 3D D6 FF      mov [_ide_r6], al
0845   03AC             ide_read_sect_wait:
0846   03AC 1D D7 FF      mov al, [_ide_r7]  
0847   03AF 87 80         and al, $80                     ; busy flag
0848   03B1 C7 AC 03      jnz ide_read_sect_wait
0849   03B4 19 20         mov al, $20
0850   03B6 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
0851   03B9 07 E3 03      call ide_read  
0852   03BC 09            ret
0853   03BD             ide_write_sect:
0854   03BD 1A            mov al, ah
0855   03BE 24            mov ah, bl
0856   03BF 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0857   03C2 1C            mov al, bh
0858   03C3 3D D4 FF      mov [_ide_r4], al
0859   03C6 12            mov a, c
0860   03C7 3D D5 FF      mov [_ide_r5], al
0861   03CA 1A            mov al, ah
0862   03CB 87 0F         and al, %00001111
0863   03CD 8B E0         or al, %11100000                ; mode lba, master
0864   03CF 3D D6 FF      mov [_ide_r6], al
0865   03D2             ide_write_sect_wait:
0866   03D2 1D D7 FF      mov al, [_ide_r7]  
0867   03D5 87 80         and al, $80                     ; busy flag
0868   03D7 C7 D2 03      jnz ide_write_sect_wait
0869   03DA 19 30         mov al, $30
0870   03DC 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
0871   03DF 07 FE 03      call ide_write      
0872   03E2 09            ret
0873   03E3             
0874   03E3             ;----------------------------------------------------------------------------------------------------;
0875   03E3             ; read ide data
0876   03E3             ; pointer in d
0877   03E3             ;----------------------------------------------------------------------------------------------------;
0878   03E3             ide_read:
0879   03E3 DA            push d
0880   03E4             ide_read_loop:
0881   03E4 1D D7 FF      mov al, [_ide_r7]  
0882   03E7 87 80         and al, 80h                     ; busy flag
0883   03E9 C7 E4 03      jnz ide_read_loop               ; wait loop
0884   03EC 1D D7 FF      mov al, [_ide_r7]
0885   03EF 87 08         and al, %00001000               ; drq flag
0886   03F1 C6 FC 03      jz ide_read_end
0887   03F4 1D D0 FF      mov al, [_ide_r0]
0888   03F7 3E            mov [d], al
0889   03F8 79            inc d
0890   03F9 0A E4 03      jmp ide_read_loop
0891   03FC             ide_read_end:
0892   03FC E7            pop d
0893   03FD 09            ret
0894   03FE             
0895   03FE             ;----------------------------------------------------------------------------------------------------;
0896   03FE             ; write ide data
0897   03FE             ; data pointer in d
0898   03FE             ;----------------------------------------------------------------------------------------------------;
0899   03FE             ide_write:
0900   03FE DA            push d
0901   03FF             ide_write_loop:
0902   03FF 1D D7 FF      mov al, [_ide_r7]  
0903   0402 87 80         and al, 80h             ; busy flag
0904   0404 C7 FF 03      jnz ide_write_loop      ; wait loop
0905   0407 1D D7 FF      mov al, [_ide_r7]
0906   040A 87 08         and al, %00001000       ; drq flag
0907   040C C6 17 04      jz ide_write_end
0908   040F 1E            mov al, [d]
0909   0410 3D D0 FF      mov [_ide_r0], al
0910   0413 79            inc d 
0911   0414 0A FF 03      jmp ide_write_loop
0912   0417             ide_write_end:
0913   0417 E7            pop d
0914   0418 09            ret
0915   0419             
0916   0419             ;----------------------------------------------------------------------------------------------------;
0917   0419             ; wait for ide to be ready
0918   0419             ;----------------------------------------------------------------------------------------------------;
0919   0419             ide_wait:
0920   0419 1D D7 FF      mov al, [_ide_r7]  
0921   041C 87 80         and al, 80h        ; busy flag
0922   041E C7 19 04      jnz ide_wait
0923   0421 09            ret
0924   0422             
0925   0422             ;----------------------------------------------------------------------------------------------------;
0926   0422             ; io syscall
0927   0422             ;----------------------------------------------------------------------------------------------------;
0928   0422             ; baud  divisor
0929   0422             ; 50    2304
0930   0422             ; 110   1047
0931   0422             ; 300    384
0932   0422             ; 600    192
0933   0422             ; 1200    96
0934   0422             ; 9600    12
0935   0422             ; 19200    6
0936   0422             ; 38400    3
0937   0422             syscall_io_jmp:
0938   0422 7D 04         .dw syscall_io_putchar
0939   0424 96 04         .dw syscall_io_getch
0940   0426 2C 04         .dw syscall_io_uart_setup
0941   0428             syscall_io:
0942   0428 FD 0A 22 04   jmp [syscall_io_jmp + al]
0943   042C             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
0944   042C             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
0945   042C             ; buffer, the transmitter holding register, or the interrupt enable register.
0946   042C             syscall_io_uart_setup:
0947   042C 1D A4 0C      mov al, [sys_uart0_lcr]
0948   042F 8B 80         or al, $80                ; set dlab access bit
0949   0431 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, even parity 
0950   0434 1D A7 0C      mov al, [sys_uart0_div0]
0951   0437 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
0952   043A 1D A8 0C      mov al, [sys_uart0_div1]
0953   043D 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
0954   0440 1D A4 0C      mov al, [sys_uart0_lcr]
0955   0443 87 7F         and al, $7f               ; clear dlab access bit 
0956   0445 3D 83 FF      mov [_uart0_lcr], al
0957   0448 1D A5 0C      mov al, [sys_uart0_inten]
0958   044B 3D 81 FF      mov [_uart0_ier], al      ; interrupts
0959   044E 1D A6 0C      mov al, [sys_uart0_fifoen]
0960   0451 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
0961   0454             
0962   0454             ; uart1:
0963   0454 1D A9 0C      mov al, [sys_uart1_lcr]
0964   0457 8B 80         or al, $80                ; set dlab access bit
0965   0459 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, even parity 
0966   045C 1D AC 0C      mov al, [sys_uart1_div0]
0967   045F 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
0968   0462 1D AD 0C      mov al, [sys_uart1_div1]
0969   0465 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
0970   0468 1D A9 0C      mov al, [sys_uart1_lcr]
0971   046B 87 7F         and al, $7f               ; clear dlab access bit 
0972   046D 3D 8B FF      mov [_uart1_lcr], al
0973   0470 1D AA 0C      mov al, [sys_uart1_inten]
0974   0473 3D 89 FF      mov [_uart1_ier], al      ; interrupts
0975   0476 1D AB 0C      mov al, [sys_uart1_fifoen]
0976   0479 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
0977   047C 06            sysret
0978   047D             
0979   047D             ; char in ah
0980   047D             syscall_io_putchar:
0981   047D             syscall_io_putchar_l0:
0982   047D 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0983   0480 93 20         test al, $20
0984   0482 C6 7D 04      jz syscall_io_putchar_l0    
0985   0485 1A            mov al, ah
0986   0486 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0987   0489             ; uart1
0988   0489             syscall_io_putchar_l1:
0989   0489 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0990   048C 93 20         test al, $20
0991   048E C6 89 04      jz syscall_io_putchar_l1    
0992   0491 1A            mov al, ah
0993   0492 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0994   0495 06            sysret
0995   0496             
0996   0496             ; char in ah
0997   0496             ; al = sucess code
0998   0496             syscall_io_getch:
0999   0496 D8            push b
1000   0497 DA            push d
1001   0498 FD 0C         sti
1002   049A             syscall_io_getch_l0:  
1003   049A 14 B0 0C      mov a, [fifo_out]
1004   049D 29 AE 0C      mov b, [fifo_in]
1005   04A0 B0            cmp a, b
1006   04A1 C6 9A 04      je syscall_io_getch_l0
1007   04A4 3C            mov d, a
1008   04A5 77            inc a
1009   04A6 AF 13 20      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
1010   04A9 C7 AF 04      jne syscall_io_getch_cont
1011   04AC 10 13 10      mov a, fifo  
1012   04AF             syscall_io_getch_cont:  
1013   04AF 42 B0 0C      mov [fifo_out], a             ; update fifo pointer
1014   04B2 1E            mov al, [d]                   ; get char
1015   04B3 23            mov ah, al
1016   04B4             ; here we just echo the char back to the console
1017   04B4             syscall_io_getch_echo_l0:
1018   04B4 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1019   04B7 87 20         and al, $20                 ; isolate transmitter empty
1020   04B9 C6 B4 04      jz syscall_io_getch_echo_l0
1021   04BC 1A            mov al, ah
1022   04BD 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1023   04C0             syscall_io_getch_echo_l1:
1024   04C0 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1025   04C3 87 20         and al, $20                 ; isolate transmitter empty
1026   04C5 C6 C0 04      jz syscall_io_getch_echo_l1
1027   04C8 1A            mov al, ah
1028   04C9 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1029   04CC             syscall_io_getch_noecho:
1030   04CC 19 01         mov al, 1                    ; al = 1 means a char successfully received
1031   04CE E7            pop d
1032   04CF E5            pop b
1033   04D0 06            sysret
1034   04D1             
1035   04D1             ;------------------------------------------------------------------------------------------------------;
1036   04D1             ; file system data
1037   04D1             ;------------------------------------------------------------------------------------------------------;
1038   04D1             ; infor for : ide services interrupt
1039   04D1             ; ide read/write 512-byte sector
1040   04D1             ; al = option
1041   04D1             ; user buffer pointer in d
1042   04D1             ; ah = number of sectors
1043   04D1             ; cb = lba bytes 3..0  
1044   04D1             ;------------------------------------------------------------------------------------------------------;
1045   04D1             ; file system data structure
1046   04D1             ;------------------------------------------------------------------------------------------------------;
1047   04D1             ; first directory on disk is the root directory '/'
1048   04D1             file_system_jmptbl:
1049   04D1 E4 04         .dw fs_cd                     
1050   04D3 E5 04         .dw fs_ls                     
1051   04D5 E6 04         .dw fs_pwd                    
1052   04D7 E7 04         .dw fs_rmdir                  
1053   04D9 E3 04         .dw fs_mkdir
1054   04DB E8 04         .dw fs_rm                     
1055   04DD E9 04         .dw fs_mv                     
1056   04DF             
1057   04DF             syscall_file:
1058   04DF FD 0A D1 04   jmp [file_system_jmptbl + al]
1059   04E3             
1060   04E3             ;------------------------------------------------------------------------------------------------------;
1061   04E3             ; create new directory
1062   04E3             ;------------------------------------------------------------------------------------------------------;
1063   04E3             ; search list for null name entry. add new directory to list
1064   04E3             fs_mkdir:
1065   04E3 06            sysret
1066   04E4             
1067   04E4             ;------------------------------------------------------------------------------------------------------;
1068   04E4             ; cd
1069   04E4             ;------------------------------------------------------------------------------------------------------;
1070   04E4             fs_cd:
1071   04E4 06            sysret  
1072   04E5             
1073   04E5             ;------------------------------------------------------------------------------------------------------;
1074   04E5             ; ls
1075   04E5             ;------------------------------------------------------------------------------------------------------;
1076   04E5             ; inode in a
1077   04E5             fs_ls:
1078   04E5             
1079   04E5 06            sysret
1080   04E6             
1081   04E6             ;------------------------------------------------------------------------------------------------------;
1082   04E6             ; pwd - print working directory
1083   04E6             ;------------------------------------------------------------------------------------------------------;    
1084   04E6             fs_pwd:
1085   04E6 06            sysret
1086   04E7             
1087   04E7             ;------------------------------------------------------------------------------------------------------;
1088   04E7             ; rmdir - remove dir by dirid
1089   04E7             ;------------------------------------------------------------------------------------------------------;
1090   04E7             fs_rmdir:
1091   04E7 06            sysret
1092   04E8             
1093   04E8             ;------------------------------------------------------------------------------------------------------;
1094   04E8             ; rm - remove file
1095   04E8             ;------------------------------------------------------------------------------------------------------;
1096   04E8             fs_rm:
1097   04E8 06            sysret  
1098   04E9             
1099   04E9             ;------------------------------------------------------------------------------------------------------;
1100   04E9             ; mv - move / change file name
1101   04E9             ;------------------------------------------------------------------------------------------------------;
1102   04E9             fs_mv:
1103   04E9 06            sysret
1104   04EA             
1105   04EA             
1106   04EA             ;----------------------------------------------------------------------------------------------;
1107   04EA             ; get hex file
1108   04EA             ; di = destination address
1109   04EA             ; return length in bytes in c
1110   04EA             ;----------------------------------------------------------------------------------------------;
1111   04EA             _load_hex:
1112   04EA D7            push a
1113   04EB D8            push b
1114   04EC DA            push d
1115   04ED E2            push si
1116   04EE E3            push di
1117   04EF 38 00 00      mov c, 0
1118   04F2 50            mov a, di
1119   04F3 3C            mov d, a          ; start of string data block
1120   04F4 07 56 06      call _gets        ; get program string
1121   04F7 4D            mov si, a
1122   04F8             __load_hex_loop:
1123   04F8 F6            lodsb             ; load from [si] to al
1124   04F9 B9 00         cmp al, 0         ; check if ascii 0
1125   04FB C6 09 05      jz __load_hex_ret
1126   04FE 36            mov bh, al
1127   04FF F6            lodsb
1128   0500 2F            mov bl, al
1129   0501 07 0C 06      call _atoi        ; convert ascii byte in b to int (to al)
1130   0504 F7            stosb             ; store al to [di]
1131   0505 78            inc c
1132   0506 0A F8 04      jmp __load_hex_loop
1133   0509             __load_hex_ret:
1134   0509 F0            pop di
1135   050A EF            pop si
1136   050B E7            pop d
1137   050C E5            pop b
1138   050D E4            pop a
1139   050E 09            ret
1140   050F             
1141   050F             ; ---------------------------------------------------------------------
1142   050F             ; kernel reset vector
1143   050F             ; ---------------------------------------------------------------------
1144   050F             kernel_reset_vector:  
1145   050F FD 49 FF F7   mov bp, _stack_top
1146   0513 FD 47 FF F7   mov sp, _stack_top
1147   0517               
1148   0517 0C            lodstat
1149   0518 87 DF         and al, %11011111             ; disable display register loading
1150   051A 0D            stostat
1151   051B             
1152   051B             ; reset fifo pointers
1153   051B 10 13 10      mov a, fifo
1154   051E 3B AE 0C      mov d, fifo_in
1155   0521 43            mov [d], a
1156   0522 3B B0 0C      mov d, fifo_out
1157   0525 43            mov [d], a  
1158   0526 19 02         mov al, 2
1159   0528 05 03         syscall sys_io                ; enable uart in interrupt mode
1160   052A             
1161   052A 19 A0         mov al, %10100000             ; uart0 | timer | uart1 | 0 | 0 | 0 | 0| fdc
1162   052C FD 0F         stomsk                        
1163   052E FD 0C         sti  
1164   0530             
1165   0530 3B 01 0D      mov d, s_kernel_welcome
1166   0533 07 7B 07      call _puts
1167   0536             
1168   0536 3B F9 0E      mov d, s_fdc_config
1169   0539 07 7B 07      call _puts
1170   053C             
1171   053C F2 C0 FF 0D   mov byte [_fdc_config], %00001101   ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
1172   0540 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011 ; leave this restore command in order to clear BUSY flag
1173   0544 F2 C9 FF 00   mov byte [_fdc_track], $00          ; reset track
1174   0548             
1175   0548             
1176   0548 3B 64 0F      mov d, s_reset_proc_tbl 
1177   054B 07 7B 07      call _puts
1178   054E 3B 93 0F      mov d, proc_table
1179   0551 19 00         mov al, 0
1180   0553             reset_proc_table_l0:
1181   0553 3E            mov [d], al
1182   0554 58 80 00      add d, 128
1183   0557 C5 93 4F      cmp d, proc_table + 16384
1184   055A C7 53 05      jne reset_proc_table_l0
1185   055D             
1186   055D             
1187   055D 10 00 00      mov a, 0
1188   0560             ker_loop:
1189   0560 77            inc a
1190   0561 3D B0 FF      mov [_til311_display], al
1191   0564 0A 60 05      jmp ker_loop
1192   0567             
1193   0567             
1194   0567             ; file includes
1195   0567             .include "lib/bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  0567             boot_origin      .EQU  $8004
0002+  0567             bios_uart        .EQU  $0002
0003+  0567             bios_ide         .EQU  $0003
0004+  0567             bios_reset_vector .EQU  $0190
0005+  0567             ide_buffer       .EQU  $8404
0006+  0567             inode_buffer     .EQU  $8c04
0007+  0567             noname.__print_u16x .EQU  $01f6
0008+  0567             noname.__xput_u8 .EQU  $023e
0009+  0567             noname.__puts    .EQU  $0252
0010+  0567             noname.__print_u16d .EQU  $0379
1196   0567             .include "lib/stdio.asm"
0001+  0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0567             ; stdio.s
0003+  0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0567             .include "lib/string.asm"
0001++ 0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0567             ; string.s
0003++ 0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0567             
0005++ 0567             
0006++ 0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0567             ; _strrev
0008++ 0567             ; reverse a string
0009++ 0567             ; d = string address
0010++ 0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0567             ; 01234
0012++ 0567             _strrev:
0013++ 0567 4B          	pusha
0014++ 0568 07 AE 05    	call _strlen	; length in c
0015++ 056B 12          	mov a, c
0016++ 056C AF 01 00    	cmp a, 1
0017++ 056F D0 89 05    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0572 7D          	dec a
0019++ 0573 FD 4E       	mov si, d	; beginning of string
0020++ 0575 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0577 59          	add d, a	; end of string
0022++ 0578 12          	mov a, c
0023++ 0579 FD 9B       	shr a		; divide by 2
0024++ 057B 39          	mov c, a	; c now counts the steps
0025++ 057C             _strrev_l0:
0026++ 057C 32          	mov bl, [d]	; save load right-side char into bl
0027++ 057D F6          	lodsb		; load left-side char into al; increase si
0028++ 057E 3E          	mov [d], al	; store left char into right side
0029++ 057F 1B          	mov al, bl
0030++ 0580 F7          	stosb		; store right-side char into left-side; increase di
0031++ 0581 7E          	dec c
0032++ 0582 7F          	dec d
0033++ 0583 C2 00 00    	cmp c, 0
0034++ 0586 C7 7C 05    	jne _strrev_l0
0035++ 0589             _strrev_end:
0036++ 0589 4C          	popa
0037++ 058A 09          	ret
0038++ 058B             	
0039++ 058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 058B             ; _strchr
0041++ 058B             ; search string in d for char in al
0042++ 058B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 058B             _strchr:
0044++ 058B             _strchr_l0:
0045++ 058B 32          	mov bl, [d]
0046++ 058C C1 00       	cmp bl, 0
0047++ 058E C6 99 05    	je _strchr_end
0048++ 0591 BA          	cmp al, bl
0049++ 0592 C6 99 05    	je _strchr_end
0050++ 0595 79          	inc d
0051++ 0596 0A 8B 05    	jmp _strchr_l0
0052++ 0599             _strchr_end:
0053++ 0599 1B          	mov al, bl
0054++ 059A 09          	ret
0055++ 059B             
0056++ 059B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 059B             ; _strstr
0058++ 059B             ; find sub-string
0059++ 059B             ; str1 in si
0060++ 059B             ; str2 in di
0061++ 059B             ; si points to end of source string
0062++ 059B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 059B             _strstr:
0064++ 059B DB          	push al
0065++ 059C DA          	push d
0066++ 059D E3          	push di
0067++ 059E             _strstr_loop:
0068++ 059E F3          	cmpsb					; compare a byte of the strings
0069++ 059F C7 AA 05    	jne _strstr_ret
0070++ 05A2 FC 00 00    	lea d, [di + 0]
0071++ 05A5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05A7 C7 9E 05    	jne _strstr_loop				; equal chars but not at end
0073++ 05AA             _strstr_ret:
0074++ 05AA F0          	pop di
0075++ 05AB E7          	pop d
0076++ 05AC E8          	pop al
0077++ 05AD 09          	ret
0078++ 05AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05AE             ; length of null terminated string
0080++ 05AE             ; result in c
0081++ 05AE             ; pointer in d
0082++ 05AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05AE             _strlen:
0084++ 05AE DA          	push d
0085++ 05AF 38 00 00    	mov c, 0
0086++ 05B2             _strlen_l1:
0087++ 05B2 BD 00       	cmp byte [d], 0
0088++ 05B4 C6 BC 05    	je _strlen_ret
0089++ 05B7 79          	inc d
0090++ 05B8 78          	inc c
0091++ 05B9 0A B2 05    	jmp _strlen_l1
0092++ 05BC             _strlen_ret:
0093++ 05BC E7          	pop d
0094++ 05BD 09          	ret
0095++ 05BE             
0096++ 05BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05BE             ; strcmp
0098++ 05BE             ; compare two strings
0099++ 05BE             ; str1 in si
0100++ 05BE             ; str2 in di
0101++ 05BE             ; create a string compairon instrucion ?????
0102++ 05BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05BE             _strcmp:
0104++ 05BE DB          	push al
0105++ 05BF DA          	push d
0106++ 05C0 E3          	push di
0107++ 05C1 E2          	push si
0108++ 05C2             _strcmp_loop:
0109++ 05C2 F3          	cmpsb					; compare a byte of the strings
0110++ 05C3 C7 CE 05    	jne _strcmp_ret
0111++ 05C6 FB FF FF    	lea d, [si +- 1]
0112++ 05C9 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05CB C7 C2 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 05CE             _strcmp_ret:
0115++ 05CE EF          	pop si
0116++ 05CF F0          	pop di
0117++ 05D0 E7          	pop d
0118++ 05D1 E8          	pop al
0119++ 05D2 09          	ret
0120++ 05D3             
0121++ 05D3             
0122++ 05D3             ; strcpy
0123++ 05D3             ; copy null terminated string from si to di
0124++ 05D3             ; source in si
0125++ 05D3             ; destination in di
0126++ 05D3             _strcpy:
0127++ 05D3 E2          	push si
0128++ 05D4 E3          	push di
0129++ 05D5 DB          	push al
0130++ 05D6             _strcpy_l1:
0131++ 05D6 F6          	lodsb
0132++ 05D7 F7          	stosb
0133++ 05D8 B9 00       	cmp al, 0
0134++ 05DA C7 D6 05    	jne _strcpy_l1
0135++ 05DD             _strcpy_end:
0136++ 05DD E8          	pop al
0137++ 05DE F0          	pop di
0138++ 05DF EF          	pop si
0139++ 05E0 09          	ret
0140++ 05E1             
0141++ 05E1             ; strcat
0142++ 05E1             ; concatenate a null terminated string into string at di, from string at si
0143++ 05E1             ; source in si
0144++ 05E1             ; destination in di
0145++ 05E1             _strcat:
0146++ 05E1 E2          	push si
0147++ 05E2 E3          	push di
0148++ 05E3 D7          	push a
0149++ 05E4 DA          	push d
0150++ 05E5 50          	mov a, di
0151++ 05E6 3C          	mov d, a
0152++ 05E7             _strcat_goto_end_l1:
0153++ 05E7 BD 00       	cmp byte[d], 0
0154++ 05E9 C6 F0 05    	je _strcat_start
0155++ 05EC 79          	inc d
0156++ 05ED 0A E7 05    	jmp _strcat_goto_end_l1
0157++ 05F0             _strcat_start:
0158++ 05F0 FD 50       	mov di, d
0159++ 05F2             _strcat_l1:
0160++ 05F2 F6          	lodsb
0161++ 05F3 F7          	stosb
0162++ 05F4 B9 00       	cmp al, 0
0163++ 05F6 C7 F2 05    	jne _strcat_l1
0164++ 05F9             _strcat_end:
0165++ 05F9 E7          	pop d
0166++ 05FA E4          	pop a
0167++ 05FB F0          	pop di
0168++ 05FC EF          	pop si
0169++ 05FD 09          	ret
0170++ 05FE             
0171++ 05FE             
0005+  05FE             
0006+  05FE             
0007+  05FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  05FE             ; convert ascii 'o'..'f' to integer 0..15
0009+  05FE             ; ascii in bl
0010+  05FE             ; result in al
0011+  05FE             ; ascii for f = 0100 0110
0012+  05FE             ; ascii for 9 = 0011 1001
0013+  05FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  05FE             hex_ascii_encode:
0015+  05FE 1B            mov al, bl
0016+  05FF 93 40         test al, $40        ; test if letter or number
0017+  0601 C7 07 06      jnz hex_letter
0018+  0604 87 0F         and al, $0f        ; get number
0019+  0606 09            ret
0020+  0607             hex_letter:
0021+  0607 87 0F         and al, $0f        ; get letter
0022+  0609 6A 09         add al, 9
0023+  060B 09            ret
0024+  060C             
0025+  060C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  060C             ; atoi
0027+  060C             ; 2 letter hex string in b
0028+  060C             ; 8bit integer returned in al
0029+  060C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  060C             _atoi:
0031+  060C D8            push b
0032+  060D 07 FE 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0610 30            mov bl, bh
0034+  0611 DB            push al          ; save a
0035+  0612 07 FE 05      call hex_ascii_encode
0036+  0615 EA            pop bl  
0037+  0616 FD 9E 04      shl al, 4
0038+  0619 8C            or al, bl
0039+  061A E5            pop b
0040+  061B 09            ret  
0041+  061C             
0042+  061C             
0043+  061C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  061C             ; scanf
0045+  061C             ; no need for explanations!
0046+  061C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  061C             scanf:
0048+  061C 09            ret
0049+  061D             
0050+  061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  061D             ; itoa
0052+  061D             ; 8bit value in bl
0053+  061D             ; 2 byte ascii result in a
0054+  061D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  061D             _itoa:
0056+  061D DA            push d
0057+  061E D8            push b
0058+  061F A7 00         mov bh, 0
0059+  0621 FD A4 04      shr bl, 4  
0060+  0624 74            mov d, b
0061+  0625 1F B7 08      mov al, [d + s_hex_digits]
0062+  0628 23            mov ah, al
0063+  0629               
0064+  0629 E5            pop b
0065+  062A D8            push b
0066+  062B A7 00         mov bh, 0
0067+  062D FD 87 0F      and bl, $0f
0068+  0630 74            mov d, b
0069+  0631 1F B7 08      mov al, [d + s_hex_digits]
0070+  0634 E5            pop b
0071+  0635 E7            pop d
0072+  0636 09            ret
0073+  0637             
0074+  0637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0637             ; hex string to binary
0076+  0637             ; di = destination address
0077+  0637             ; si = source
0078+  0637             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0637             _hex_to_int:
0080+  0637             _hex_to_int_l1:
0081+  0637 F6            lodsb          ; load from [si] to al
0082+  0638 B9 00         cmp al, 0        ; check if ascii 0
0083+  063A C6 47 06      jz _hex_to_int_ret
0084+  063D 36            mov bh, al
0085+  063E F6            lodsb
0086+  063F 2F            mov bl, al
0087+  0640 07 0C 06      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0643 F7            stosb          ; store al to [di]
0089+  0644 0A 37 06      jmp _hex_to_int_l1
0090+  0647             _hex_to_int_ret:
0091+  0647 09            ret    
0092+  0648             
0093+  0648             
0094+  0648             
0095+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0648             ; getchar
0097+  0648             ; char in ah
0098+  0648             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0648             getch:
0100+  0648 DB            push al
0101+  0649             getch_retry:
0102+  0649 19 01         mov al, 1
0103+  064B 05 03         syscall sys_io      ; receive in ah
0104+  064D E8            pop al
0105+  064E 09            ret
0106+  064F             
0107+  064F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  064F             ; putchar
0109+  064F             ; char in ah
0110+  064F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  064F             _putchar:
0112+  064F DB            push al
0113+  0650 19 00         mov al, 0
0114+  0652 05 03         syscall sys_io      ; char in ah
0115+  0654 E8            pop al
0116+  0655 09            ret
0117+  0656             
0118+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0656             ;; input a string
0120+  0656             ;; terminates with null
0121+  0656             ;; pointer in d
0122+  0656             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0656             _gets:
0124+  0656 D7            push a
0125+  0657 DA            push d
0126+  0658             _gets_loop:
0127+  0658 19 01         mov al, 1
0128+  065A 05 03         syscall sys_io      ; receive in ah
0129+  065C 76 1B         cmp ah, 27
0130+  065E C6 7F 06      je _gets_ansi_esc
0131+  0661 76 0A         cmp ah, $0a        ; lf
0132+  0663 C6 DB 06      je _gets_end
0133+  0666 76 0D         cmp ah, $0d        ; cr
0134+  0668 C6 DB 06      je _gets_end
0135+  066B 76 5C         cmp ah, $5c        ; '\\'
0136+  066D C6 A1 06      je _gets_escape
0137+  0670 76 08         cmp ah, $08      ; check for backspace
0138+  0672 C6 7B 06      je _gets_backspace
0139+  0675 1A            mov al, ah
0140+  0676 3E            mov [d], al
0141+  0677 79            inc d
0142+  0678 0A 58 06      jmp _gets_loop
0143+  067B             _gets_backspace:
0144+  067B 7F            dec d
0145+  067C 0A 58 06      jmp _gets_loop
0146+  067F             _gets_ansi_esc:
0147+  067F 19 01         mov al, 1
0148+  0681 05 03         syscall sys_io        ; receive in ah without echo
0149+  0683 76 5B         cmp ah, '['
0150+  0685 C7 58 06      jne _gets_loop
0151+  0688 19 01         mov al, 1
0152+  068A 05 03         syscall sys_io          ; receive in ah without echo
0153+  068C 76 64         cmp ah, 'd'
0154+  068E C6 99 06      je _gets_left_arrow
0155+  0691 76 63         cmp ah, 'c'
0156+  0693 C6 9D 06      je _gets_right_arrow
0157+  0696 0A 58 06      jmp _gets_loop
0158+  0699             _gets_left_arrow:
0159+  0699 7F            dec d
0160+  069A 0A 58 06      jmp _gets_loop
0161+  069D             _gets_right_arrow:
0162+  069D 79            inc d
0163+  069E 0A 58 06      jmp _gets_loop
0164+  06A1             _gets_escape:
0165+  06A1 19 01         mov al, 1
0166+  06A3 05 03         syscall sys_io      ; receive in ah
0167+  06A5 76 6E         cmp ah, 'n'
0168+  06A7 C6 C6 06      je _gets_lf
0169+  06AA 76 72         cmp ah, 'r'
0170+  06AC C6 CD 06      je _gets_cr
0171+  06AF 76 30         cmp ah, '0'
0172+  06B1 C6 D4 06      je _gets_null
0173+  06B4 76 5C         cmp ah, $5c  ; '\'
0174+  06B6 C6 BF 06      je _gets_slash
0175+  06B9 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  06BA 3E            mov [d], al
0177+  06BB 79            inc d
0178+  06BC 0A 58 06      jmp _gets_loop
0179+  06BF             _gets_slash:
0180+  06BF 19 5C         mov al, $5c
0181+  06C1 3E            mov [d], al
0182+  06C2 79            inc d
0183+  06C3 0A 58 06      jmp _gets_loop
0184+  06C6             _gets_lf:
0185+  06C6 19 0A         mov al, $0a
0186+  06C8 3E            mov [d], al
0187+  06C9 79            inc d
0188+  06CA 0A 58 06      jmp _gets_loop
0189+  06CD             _gets_cr:
0190+  06CD 19 0D         mov al, $0d
0191+  06CF 3E            mov [d], al
0192+  06D0 79            inc d
0193+  06D1 0A 58 06      jmp _gets_loop
0194+  06D4             _gets_null:
0195+  06D4 19 00         mov al, $00
0196+  06D6 3E            mov [d], al
0197+  06D7 79            inc d
0198+  06D8 0A 58 06      jmp _gets_loop
0199+  06DB             _gets_end:
0200+  06DB 19 00         mov al, 0
0201+  06DD 3E            mov [d], al        ; terminate string
0202+  06DE E7            pop d
0203+  06DF E4            pop a
0204+  06E0 09            ret
0205+  06E1             
0206+  06E1             
0207+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  06E1             ;; input text
0209+  06E1             ;; terminated with ctrl+d
0210+  06E1             ;; pointer in d
0211+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  06E1             _gettxt:
0213+  06E1 D7            push a
0214+  06E2 DA            push d
0215+  06E3             _gettxt_loop:
0216+  06E3 19 01         mov al, 1
0217+  06E5 05 03         syscall sys_io      ; receive in ah
0218+  06E7 76 04         cmp ah, 4      ; eot
0219+  06E9 C6 22 07      je _gettxt_end
0220+  06EC 76 08         cmp ah, $08      ; check for backspace
0221+  06EE C6 1E 07      je _gettxt_backspace
0222+  06F1 76 5C         cmp ah, $5c        ; '\'
0223+  06F3 C6 FC 06      je _gettxt_escape
0224+  06F6 1A            mov al, ah
0225+  06F7 3E            mov [d], al
0226+  06F8 79            inc d
0227+  06F9 0A E3 06      jmp _gettxt_loop
0228+  06FC             _gettxt_escape:
0229+  06FC 19 01         mov al, 1
0230+  06FE 05 03         syscall sys_io      ; receive in ah
0231+  0700 76 6E         cmp ah, 'n'
0232+  0702 C6 10 07      je _gettxt_lf
0233+  0705 76 72         cmp ah, 'r'
0234+  0707 C6 17 07      je _gettxt_cr
0235+  070A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  070B 3E            mov [d], al
0237+  070C 79            inc d
0238+  070D 0A E3 06      jmp _gettxt_loop
0239+  0710             _gettxt_lf:
0240+  0710 19 0A         mov al, $0a
0241+  0712 3E            mov [d], al
0242+  0713 79            inc d
0243+  0714 0A E3 06      jmp _gettxt_loop
0244+  0717             _gettxt_cr:
0245+  0717 19 0D         mov al, $0d
0246+  0719 3E            mov [d], al
0247+  071A 79            inc d
0248+  071B 0A E3 06      jmp _gettxt_loop
0249+  071E             _gettxt_backspace:
0250+  071E 7F            dec d
0251+  071F 0A E3 06      jmp _gettxt_loop
0252+  0722             _gettxt_end:
0253+  0722 19 00         mov al, 0
0254+  0724 3E            mov [d], al        ; terminate string
0255+  0725 E7            pop d
0256+  0726 E4            pop a
0257+  0727 09            ret
0258+  0728             
0259+  0728             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0728             ; print new line
0261+  0728             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0728             printnl:
0263+  0728 D7            push a
0264+  0729 10 00 0A      mov a, $0a00
0265+  072C 05 03         syscall sys_io
0266+  072E 10 00 0D      mov a, $0d00
0267+  0731 05 03         syscall sys_io
0268+  0733 E4            pop a
0269+  0734 09            ret
0270+  0735             
0271+  0735             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0735             ; _strtoint
0273+  0735             ; 4 digit hex string number in d
0274+  0735             ; integer returned in a
0275+  0735             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0735             _strtointx:
0277+  0735 D8            push b
0278+  0736 32            mov bl, [d]
0279+  0737 37            mov bh, bl
0280+  0738 33 01 00      mov bl, [d + 1]
0281+  073B 07 0C 06      call _atoi        ; convert to int in al
0282+  073E 23            mov ah, al        ; move to ah
0283+  073F 33 02 00      mov bl, [d + 2]
0284+  0742 37            mov bh, bl
0285+  0743 33 03 00      mov bl, [d + 3]
0286+  0746 07 0C 06      call _atoi        ; convert to int in al
0287+  0749 E5            pop b
0288+  074A 09            ret
0289+  074B             
0290+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  074B             ; _strtoint
0292+  074B             ; 5 digit base10 string number in d
0293+  074B             ; integer returned in a
0294+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  074B             _strtoint:
0296+  074B E2            push si
0297+  074C D8            push b
0298+  074D D9            push c
0299+  074E DA            push d
0300+  074F 07 AE 05      call _strlen      ; get string length in c
0301+  0752 7E            dec c
0302+  0753 FD 4E         mov si, d
0303+  0755 12            mov a, c
0304+  0756 FD 99         shl a
0305+  0758 3B CF 08      mov d, table_power
0306+  075B 59            add d, a
0307+  075C 38 00 00      mov c, 0
0308+  075F             _strtoint_l0:
0309+  075F F6            lodsb      ; load ascii to al
0310+  0760 B9 00         cmp al, 0
0311+  0762 C6 75 07      je _strtoint_end
0312+  0765 6F 30         sub al, $30    ; make into integer
0313+  0767 22 00         mov ah, 0
0314+  0769 2A            mov b, [d]
0315+  076A AC            mul a, b      ; result in b since it fits in 16bits
0316+  076B 11            mov a, b
0317+  076C 28            mov b, c
0318+  076D 54            add a, b
0319+  076E 39            mov c, a
0320+  076F 63 02 00      sub d, 2
0321+  0772 0A 5F 07      jmp _strtoint_l0
0322+  0775             _strtoint_end:
0323+  0775 12            mov a, c
0324+  0776 E7            pop d
0325+  0777 E6            pop c
0326+  0778 E5            pop b
0327+  0779 EF            pop si
0328+  077A 09            ret
0329+  077B             
0330+  077B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  077B             ; print null terminated string
0332+  077B             ; pointer in d
0333+  077B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  077B             _puts:
0335+  077B D7            push a
0336+  077C DA            push d
0337+  077D             _puts_l1:
0338+  077D 1E            mov al, [d]
0339+  077E B9 00         cmp al, 0
0340+  0780 C6 8C 07      jz _puts_end
0341+  0783 23            mov ah, al
0342+  0784 19 00         mov al, 0
0343+  0786 05 03         syscall sys_io
0344+  0788 79            inc d
0345+  0789 0A 7D 07      jmp _puts_l1
0346+  078C             _puts_end:
0347+  078C E7            pop d
0348+  078D E4            pop a
0349+  078E 09            ret
0350+  078F             
0351+  078F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  078F             ; print n size string
0353+  078F             ; pointer in d
0354+  078F             ; size in c
0355+  078F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  078F             _putsn:
0357+  078F DB            push al
0358+  0790 DA            push d
0359+  0791 D9            push c
0360+  0792             _putsn_l0:
0361+  0792 1E            mov al, [d]
0362+  0793 23            mov ah, al
0363+  0794 19 00         mov al, 0
0364+  0796 05 03         syscall sys_io
0365+  0798 79            inc d
0366+  0799 7E            dec c  
0367+  079A C2 00 00      cmp c, 0
0368+  079D C7 92 07      jne _putsn_l0
0369+  07A0             _putsn_end:
0370+  07A0 E6            pop c
0371+  07A1 E7            pop d
0372+  07A2 E8            pop al
0373+  07A3 09            ret
0374+  07A4             
0375+  07A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  07A4             ; print 16bit decimal number
0377+  07A4             ; input number in a
0378+  07A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  07A4             print_u16d:
0380+  07A4 D7            push a
0381+  07A5 D8            push b
0382+  07A6 FD D8         push g
0383+  07A8 26 10 27      mov b, 10000
0384+  07AB AE            div a, b      ; get 10000's coeff.
0385+  07AC 07 D0 07      call print_number
0386+  07AF 11            mov a, b
0387+  07B0 26 E8 03      mov b, 1000
0388+  07B3 AE            div a, b      ; get 1000's coeff.
0389+  07B4 07 D0 07      call print_number
0390+  07B7 11            mov a, b
0391+  07B8 26 64 00      mov b, 100
0392+  07BB AE            div a, b
0393+  07BC 07 D0 07      call print_number
0394+  07BF 11            mov a, b
0395+  07C0 26 0A 00      mov b, 10
0396+  07C3 AE            div a, b
0397+  07C4 07 D0 07      call print_number
0398+  07C7 1B            mov al, bl      ; 1's coeff in bl
0399+  07C8 07 D0 07      call print_number
0400+  07CB FD F1         pop g
0401+  07CD E5            pop b
0402+  07CE E4            pop a
0403+  07CF 09            ret
0404+  07D0             
0405+  07D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07D0             ; print al
0407+  07D0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  07D0             print_number:
0409+  07D0 6A 30         add al, $30
0410+  07D2 23            mov ah, al
0411+  07D3 07 4F 06      call _putchar
0412+  07D6 09            ret
0413+  07D7             
0414+  07D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  07D7             ; print 16bit hex integer
0416+  07D7             ; integer value in reg b
0417+  07D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  07D7             print_u16x:
0419+  07D7 D7            push a
0420+  07D8 D8            push b
0421+  07D9 DD            push bl
0422+  07DA 30            mov bl, bh
0423+  07DB 07 1D 06      call _itoa        ; convert bh to char in a
0424+  07DE 2F            mov bl, al        ; save al
0425+  07DF 19 00         mov al, 0
0426+  07E1 05 03         syscall sys_io        ; display ah
0427+  07E3 24            mov ah, bl        ; retrieve al
0428+  07E4 19 00         mov al, 0
0429+  07E6 05 03         syscall sys_io        ; display al
0430+  07E8             
0431+  07E8 EA            pop bl
0432+  07E9 07 1D 06      call _itoa        ; convert bh to char in a
0433+  07EC 2F            mov bl, al        ; save al
0434+  07ED 19 00         mov al, 0
0435+  07EF 05 03         syscall sys_io        ; display ah
0436+  07F1 24            mov ah, bl        ; retrieve al
0437+  07F2 19 00         mov al, 0
0438+  07F4 05 03         syscall sys_io        ; display al
0439+  07F6             
0440+  07F6 E5            pop b
0441+  07F7 E4            pop a
0442+  07F8 09            ret
0443+  07F9             
0444+  07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  07F9             ; input 16bit hex integer
0446+  07F9             ; read 16bit integer into a
0447+  07F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  07F9             scan_u16x:
0449+  07F9 F8 10 00      enter 16
0450+  07FC D8            push b
0451+  07FD DA            push d
0452+  07FE             
0453+  07FE FA F1 FF      lea d, [bp + -15]
0454+  0801 07 56 06      call _gets        ; get number
0455+  0804             
0456+  0804 32            mov bl, [d]
0457+  0805 37            mov bh, bl
0458+  0806 33 01 00      mov bl, [d + 1]
0459+  0809 07 0C 06      call _atoi        ; convert to int in al
0460+  080C 23            mov ah, al        ; move to ah
0461+  080D             
0462+  080D 33 02 00      mov bl, [d + 2]
0463+  0810 37            mov bh, bl
0464+  0811 33 03 00      mov bl, [d + 3]
0465+  0814 07 0C 06      call _atoi        ; convert to int in al
0466+  0817             
0467+  0817 E7            pop d
0468+  0818 E5            pop b
0469+  0819 F9            leave
0470+  081A 09            ret
0471+  081B             
0472+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  081B             ; print 8bit hex integer
0474+  081B             ; integer value in reg bl
0475+  081B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  081B             print_u8x:
0477+  081B D7            push a
0478+  081C DD            push bl
0479+  081D             
0480+  081D 07 1D 06      call _itoa        ; convert bl to char in a
0481+  0820 2F            mov bl, al        ; save al
0482+  0821 19 00         mov al, 0
0483+  0823 05 03         syscall sys_io        ; display ah
0484+  0825 24            mov ah, bl        ; retrieve al
0485+  0826 19 00         mov al, 0
0486+  0828 05 03         syscall sys_io        ; display al
0487+  082A             
0488+  082A EA            pop bl
0489+  082B E4            pop a
0490+  082C 09            ret
0491+  082D             
0492+  082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  082D             ; print 8bit decimal unsigned number
0494+  082D             ; input number in al
0495+  082D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  082D             print_u8d:
0497+  082D D7            push a
0498+  082E D8            push b
0499+  082F FD D8         push g
0500+  0831 22 00         mov ah, 0
0501+  0833 26 64 00      mov b, 100
0502+  0836 AE            div a, b
0503+  0837 D8            push b      ; save remainder
0504+  0838 B9 00         cmp al, 0
0505+  083A C6 44 08      je skip100
0506+  083D 6A 30         add al, $30
0507+  083F 23            mov ah, al
0508+  0840 19 00         mov al, 0
0509+  0842 05 03         syscall sys_io  ; print coeff
0510+  0844             skip100:
0511+  0844 E4            pop a
0512+  0845 22 00         mov ah, 0
0513+  0847 26 0A 00      mov b, 10
0514+  084A AE            div a, b
0515+  084B D8            push b      ; save remainder
0516+  084C B9 00         cmp al, 0
0517+  084E C6 58 08      je skip10
0518+  0851 6A 30         add al, $30
0519+  0853 23            mov ah, al
0520+  0854 19 00         mov al, 0
0521+  0856 05 03         syscall sys_io  ; print coeff
0522+  0858             skip10:
0523+  0858 E4            pop a
0524+  0859 1B            mov al, bl
0525+  085A 6A 30         add al, $30
0526+  085C 23            mov ah, al
0527+  085D 19 00         mov al, 0
0528+  085F 05 03         syscall sys_io  ; print coeff
0529+  0861 FD F1         pop g
0530+  0863 E5            pop b
0531+  0864 E4            pop a
0532+  0865 09            ret
0533+  0866             
0534+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0866             ; input 8bit hex integer
0536+  0866             ; read 8bit integer into al
0537+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0866             scan_u8x:
0539+  0866 F8 04 00      enter 4
0540+  0869 D8            push b
0541+  086A DA            push d
0542+  086B             
0543+  086B FA FD FF      lea d, [bp + -3]
0544+  086E 07 56 06      call _gets        ; get number
0545+  0871             
0546+  0871 32            mov bl, [d]
0547+  0872 37            mov bh, bl
0548+  0873 33 01 00      mov bl, [d + 1]
0549+  0876 07 0C 06      call _atoi        ; convert to int in al
0550+  0879             
0551+  0879 E7            pop d
0552+  087A E5            pop b
0553+  087B F9            leave
0554+  087C 09            ret
0555+  087D             
0556+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  087D             ; input decimal number
0558+  087D             ; result in a
0559+  087D             ; 655'\0'
0560+  087D             ; low--------high
0561+  087D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  087D             scan_u16d:
0563+  087D F8 08 00      enter 8
0564+  0880 E2            push si
0565+  0881 D8            push b
0566+  0882 D9            push c
0567+  0883 DA            push d
0568+  0884 FA F9 FF      lea d, [bp +- 7]
0569+  0887 07 56 06      call _gets
0570+  088A 07 AE 05      call _strlen      ; get string length in c
0571+  088D 7E            dec c
0572+  088E FD 4E         mov si, d
0573+  0890 12            mov a, c
0574+  0891 FD 99         shl a
0575+  0893 3B CF 08      mov d, table_power
0576+  0896 59            add d, a
0577+  0897 38 00 00      mov c, 0
0578+  089A             mul_loop:
0579+  089A F6            lodsb      ; load ascii to al
0580+  089B B9 00         cmp al, 0
0581+  089D C6 B0 08      je mul_exit
0582+  08A0 6F 30         sub al, $30    ; make into integer
0583+  08A2 22 00         mov ah, 0
0584+  08A4 2A            mov b, [d]
0585+  08A5 AC            mul a, b      ; result in b since it fits in 16bits
0586+  08A6 11            mov a, b
0587+  08A7 28            mov b, c
0588+  08A8 54            add a, b
0589+  08A9 39            mov c, a
0590+  08AA 63 02 00      sub d, 2
0591+  08AD 0A 9A 08      jmp mul_loop
0592+  08B0             mul_exit:
0593+  08B0 12            mov a, c
0594+  08B1 E7            pop d
0595+  08B2 E6            pop c
0596+  08B3 E5            pop b
0597+  08B4 EF            pop si
0598+  08B5 F9            leave
0599+  08B6 09            ret
0600+  08B7             
0601+  08B7             
0602+  08B7 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  08BB 34 35 36 37 
0602+  08BF 38 39 61 62 
0602+  08C3 63 64 65 66 
0603+  08C7 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  08CB 1B 5B 68 00 
0604+  08CF             
0605+  08CF             table_power:
0606+  08CF 01 00         .dw 1
0607+  08D1 0A 00         .dw 10
0608+  08D3 64 00         .dw 100
0609+  08D5 E8 03         .dw 1000
0610+  08D7 10 27         .dw 100001197   08D9             .include "lib/ctype.asm"
0001+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  08D9             ; ctype.s
0003+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  08D9             
0005+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  08D9             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  08D9             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  08D9             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  08D9             ;; characters are supported.
0010+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  08D9             ;; _isalnum 
0012+  08D9             ;; _isalpha 
0013+  08D9             ;; islower 
0014+  08D9             ;; isupper 
0015+  08D9             ;; _isdigit 
0016+  08D9             ;; isxdigit
0017+  08D9             ;; iscntrl 
0018+  08D9             ;; isgraph 
0019+  08D9             ;; _isspace 
0020+  08D9             ;; isblank 
0021+  08D9             ;; isprint 
0022+  08D9             ;; ispunct 
0023+  08D9             ;; tolower 
0024+  08D9             ;; toupper
0025+  08D9             
0026+  08D9             
0027+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  08D9             ;; is alphanumeric
0029+  08D9             ;; sets zf according with result
0030+  08D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  08D9             _isalnum:
0032+  08D9 07 F6 08    	call _isalpha
0033+  08DC C6 E2 08    	je _isalnum_exit
0034+  08DF 07 E3 08    	call _isdigit
0035+  08E2             _isalnum_exit:
0036+  08E2 09          	ret	
0037+  08E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  08E3             ;; is digit
0039+  08E3             ;; sets zf according with result
0040+  08E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  08E3             _isdigit:
0042+  08E3 DB          	push al
0043+  08E4 B9 30       	cmp al, '0'
0044+  08E6 C8 F2 08    	jlu _isdigit_false
0045+  08E9 B9 39       	cmp al, '9'
0046+  08EB D1 F2 08    	jgu _isdigit_false
0047+  08EE 87 00       	and al, 0	; set zf
0048+  08F0 E8          	pop al
0049+  08F1 09          	ret
0050+  08F2             _isdigit_false:
0051+  08F2 8B 01       	or al, 1	; clear zf
0052+  08F4 E8          	pop al
0053+  08F5 09          	ret	
0054+  08F6             	
0055+  08F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  08F6             ;; is alpha
0057+  08F6             ;; sets zf according with result
0058+  08F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08F6             _isalpha:
0060+  08F6 DB          	push al
0061+  08F7 B9 5F       	cmp al, '_'
0062+  08F9 C6 19 09    	je _isalpha_true
0063+  08FC B9 2E       	cmp al, '.'
0064+  08FE C6 19 09    	je _isalpha_true
0065+  0901 B9 61       	cmp al, 'a'
0066+  0903 C8 15 09    	jlu _isalpha_false
0067+  0906 B9 7A       	cmp al, 'z'
0068+  0908 D1 15 09    	jgu _isalpha_false
0069+  090B B9 7A       	cmp al, 'z'
0070+  090D D0 19 09    	jleu _isalpha_true
0071+  0910 B9 61       	cmp al, 'a'
0072+  0912 C9 19 09    	jgeu _isalpha_true
0073+  0915             _isalpha_false:
0074+  0915 8B 01       	or al, 1	; clear zf
0075+  0917 E8          	pop al
0076+  0918 09          	ret
0077+  0919             _isalpha_true:
0078+  0919 87 00       	and al, 0	; set zf
0079+  091B E8          	pop al
0080+  091C 09          	ret
0081+  091D             
0082+  091D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  091D             ;; is path-alpha
0084+  091D             ;; sets zf according with result
0085+  091D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  091D             ispath:
0087+  091D DB          	push al
0088+  091E 07 E3 08    	call _isdigit
0089+  0921 C6 4B 09    	je ispath_true
0090+  0924 B9 5F       	cmp al, '_'
0091+  0926 C6 4B 09    	je ispath_true
0092+  0929 B9 2F       	cmp al, '/'
0093+  092B C6 4B 09    	je ispath_true
0094+  092E B9 2E       	cmp al, '.'
0095+  0930 C6 4B 09    	je ispath_true
0096+  0933 B9 61       	cmp al, 'a'
0097+  0935 C8 47 09    	jlu ispath_false
0098+  0938 B9 7A       	cmp al, 'z'
0099+  093A D1 47 09    	jgu ispath_false
0100+  093D B9 7A       	cmp al, 'z'
0101+  093F D0 4B 09    	jleu ispath_true
0102+  0942 B9 61       	cmp al, 'a'
0103+  0944 C9 4B 09    	jgeu ispath_true
0104+  0947             ispath_false:
0105+  0947 8B 01       	or al, 1	; clear zf
0106+  0949 E8          	pop al
0107+  094A 09          	ret
0108+  094B             ispath_true:
0109+  094B 87 00       	and al, 0	; set zf
0110+  094D E8          	pop al
0111+  094E 09          	ret
0112+  094F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  094F             ;; is space
0114+  094F             ;; sets zf according with result
0115+  094F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  094F             _isspace:
0117+  094F B9 20       	cmp al, $20		; ' '
0118+  0951 C6 65 09    	je _isspace_exit
0119+  0954 B9 09       	cmp al, $09		; '\t'
0120+  0956 C6 65 09    	je _isspace_exit
0121+  0959 B9 0A       	cmp al, $0a		; '\n'
0122+  095B C6 65 09    	je _isspace_exit
0123+  095E B9 0D       	cmp al, $0d		; '\r'
0124+  0960 C6 65 09    	je _isspace_exit
0125+  0963 B9 0B       	cmp al, $0b		; '\v'
0126+  0965             _isspace_exit:
0127+  0965 09          	ret	
0128+  0966             
0129+  0966             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0966             ; to lower
0131+  0966             ; input in al
0132+  0966             ; output in al
0133+  0966             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0966             _to_lower:
0135+  0966 B9 7A       	cmp al, 'z'
0136+  0968 D1 6D 09    	jgu _to_lower_ret
0137+  096B 6A 20       	add al, $20				; convert to lower case
0138+  096D             _to_lower_ret:
0139+  096D 09          	ret
0140+  096E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  096E             ; to upper
0142+  096E             ; input in al
0143+  096E             ; output in al
0144+  096E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  096E             _to_upper:
0146+  096E B9 61       	cmp al, 'a'
0147+  0970 C8 75 09    	jlu _to_upper_ret
0148+  0973 6F 20       	sub al, $20			; convert to upper case
0149+  0975             _to_upper_ret:
0150+  0975 09          	ret
0151+  0976             
1198   0976             .include "lib/token.asm"
0001+  0976             toktyp_identifier  .equ 0
0002+  0976             toktyp_keyword     .equ 1
0003+  0976             toktyp_delimiter   .equ 2
0004+  0976             toktyp_string      .equ 3
0005+  0976             toktyp_char        .equ 4
0006+  0976             toktyp_numeric     .equ 5
0007+  0976             toktyp_end         .equ 6
0008+  0976             
0009+  0976             tok_null           .equ 0
0010+  0976             tok_fslash         .equ 1
0011+  0976             tok_times          .equ 2
0012+  0976             tok_plus           .equ 3
0013+  0976             tok_minus          .equ 4
0014+  0976             tok_dot            .equ 5
0015+  0976             tok_semi           .equ 6
0016+  0976             tok_angle          .equ 7
0017+  0976             tok_tilde          .equ 8
0018+  0976             tok_equal          .equ 9
0019+  0976             tok_colon          .equ 10
0020+  0976             tok_comma          .equ 11
0021+  0976             
0022+  0976             tok_end            .equ 20
0023+  0976             
0024+  0976             
0025+  0976             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0976             ;; read a full command argment from shell input buffer
0027+  0976             ;; argument is written into tokstr
0028+  0976             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  0976             get_arg:
0030+  0976 D7            push a
0031+  0977 E2            push si
0032+  0978 E3            push di
0033+  0979 19 00         mov al, 0
0034+  097B 3D A4 0B      mov [tokstr], al      ; nullify tokstr string
0035+  097E 14 A0 0B      mov a, [prog]
0036+  0981 4D            mov si, a
0037+  0982 FD 4F A4 0B   mov di, tokstr
0038+  0986             get_arg_skip_spaces:
0039+  0986 F6            lodsb
0040+  0987 07 4F 09      call _isspace
0041+  098A C6 86 09      je get_arg_skip_spaces
0042+  098D             get_arg_l0:
0043+  098D B9 3B         cmp al, $3b        ; check if is ';'
0044+  098F C6 9C 09      je get_arg_end
0045+  0992 B9 00         cmp al, 0
0046+  0994 C6 9C 09      je get_arg_end      ; check if end of input
0047+  0997 F7            stosb
0048+  0998 F6            lodsb
0049+  0999 0A 8D 09      jmp get_arg_l0
0050+  099C             get_arg_end:
0051+  099C 19 00         mov al, 0
0052+  099E F7            stosb
0053+  099F D5 01 00      sub si, 1
0054+  09A2 4E            mov a, si
0055+  09A3 42 A0 0B      mov [prog], a    ; update pointer
0056+  09A6 F0            pop di
0057+  09A7 EF            pop si
0058+  09A8 E4            pop a
0059+  09A9 09            ret
0060+  09AA             
0061+  09AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  09AA             ;; read a path formation from shell input buffer
0063+  09AA             ;; path is written into tokstr
0064+  09AA             ;; /usr/bin
0065+  09AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  09AA             get_path:
0067+  09AA D7            push a
0068+  09AB E2            push si
0069+  09AC E3            push di
0070+  09AD 19 00         mov al, 0
0071+  09AF 3D A4 0B      mov [tokstr], al      ; nullify tokstr string
0072+  09B2 14 A0 0B      mov a, [prog]
0073+  09B5 4D            mov si, a
0074+  09B6 FD 4F A4 0B   mov di, tokstr
0075+  09BA             get_path_skip_spaces:
0076+  09BA F6            lodsb
0077+  09BB 07 4F 09      call _isspace
0078+  09BE C6 BA 09      je get_path_skip_spaces
0079+  09C1             get_path_is_pathchar:
0080+  09C1 F7            stosb
0081+  09C2 F6            lodsb
0082+  09C3 07 D9 08      call _isalnum      ;check if is alphanumeric
0083+  09C6 C6 C1 09      je get_path_is_pathchar
0084+  09C9 B9 2F         cmp al, '/'        ; check if is '/'
0085+  09CB C6 C1 09      je get_path_is_pathchar
0086+  09CE 19 00         mov al, 0
0087+  09D0 F7            stosb
0088+  09D1 D5 01 00      sub si, 1
0089+  09D4 4E            mov a, si
0090+  09D5 42 A0 0B      mov [prog], a    ; update pointer
0091+  09D8             get_path_end:
0092+  09D8 F0            pop di
0093+  09D9 EF            pop si
0094+  09DA E4            pop a
0095+  09DB 09            ret
0096+  09DC             
0097+  09DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  09DC             ;; read a line
0099+  09DC             ;; line is written into tokstr
0100+  09DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  09DC             get_line:
0102+  09DC D7            push a
0103+  09DD E2            push si
0104+  09DE E3            push di
0105+  09DF 19 00         mov al, 0
0106+  09E1 3D A4 0B      mov [tokstr], al      ; nullify tokstr string
0107+  09E4 14 A0 0B      mov a, [prog]
0108+  09E7 4D            mov si, a
0109+  09E8 FD 4F A4 0B   mov di, tokstr
0110+  09EC             get_line_l0:
0111+  09EC F6            lodsb
0112+  09ED B9 0A         cmp al, $0a    ; check for new line
0113+  09EF C6 F6 09      je get_line_exit
0114+  09F2 F7            stosb
0115+  09F3 0A EC 09      jmp get_line_l0
0116+  09F6             get_line_exit:
0117+  09F6 19 00         mov al, 0
0118+  09F8 F7            stosb
0119+  09F9 4E            mov a, si
0120+  09FA 42 A0 0B      mov [prog], a    ; update pointer
0121+  09FD F0            pop di
0122+  09FE EF            pop si
0123+  09FF E4            pop a
0124+  0A00 09            ret
0125+  0A01             
0126+  0A01             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0A01             ;; token parser
0128+  0A01             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0A01             get_token:
0130+  0A01 D7            push a
0131+  0A02 DA            push d
0132+  0A03 E2            push si
0133+  0A04 E3            push di
0134+  0A05 19 00         mov al, 0
0135+  0A07 3D A4 0B      mov [tokstr], al      ; nullify tokstr string
0136+  0A0A 19 00         mov al, tok_null
0137+  0A0C 3D A3 0B      mov [tok], al        ; nullify token
0138+  0A0F 14 A0 0B      mov a, [prog]
0139+  0A12 4D            mov si, a
0140+  0A13 FD 4F A4 0B   mov di, tokstr
0141+  0A17             get_tok_skip_spaces:
0142+  0A17 F6            lodsb
0143+  0A18 07 4F 09      call _isspace
0144+  0A1B C6 17 0A      je get_tok_skip_spaces
0145+  0A1E B9 00         cmp al, 0      ; check for end of input (null)
0146+  0A20 C6 05 0B      je get_token_end
0147+  0A23 B9 23         cmp al, '#'      ; comments!
0148+  0A25 C6 33 0B      je get_tok_comment
0149+  0A28 07 D9 08      call _isalnum
0150+  0A2B C6 12 0B      jz is_alphanumeric
0151+  0A2E             ; other token types
0152+  0A2E             get_token_slash:
0153+  0A2E B9 2F         cmp al, '/'        ; check if '/'
0154+  0A30 C7 48 0A      jne get_token_minus
0155+  0A33 F7            stosb          ; store '/' into token string
0156+  0A34 19 00         mov al, 0
0157+  0A36 F7            stosb          ; terminate token string
0158+  0A37 19 01         mov al, tok_fslash
0159+  0A39 3D A3 0B      mov [tok], al      
0160+  0A3C 19 02         mov al, toktyp_delimiter
0161+  0A3E 3D A2 0B      mov [toktyp], al
0162+  0A41 4E            mov a, si
0163+  0A42 42 A0 0B      mov [prog], a    ; update pointer
0164+  0A45 0A 2E 0B      jmp get_token_return
0165+  0A48             get_token_minus:
0166+  0A48 B9 2D         cmp al, '-'        ; check if '-'
0167+  0A4A C7 62 0A      jne get_token_comma
0168+  0A4D F7            stosb          ; store '-' into token string
0169+  0A4E 19 00         mov al, 0
0170+  0A50 F7            stosb          ; terminate token string
0171+  0A51 19 04         mov al, tok_minus
0172+  0A53 3D A3 0B      mov [tok], al      
0173+  0A56 19 02         mov al, toktyp_delimiter
0174+  0A58 3D A2 0B      mov [toktyp], al
0175+  0A5B 4E            mov a, si
0176+  0A5C 42 A0 0B      mov [prog], a    ; update pointer
0177+  0A5F 0A 2E 0B      jmp get_token_return
0178+  0A62             get_token_comma:
0179+  0A62 B9 2C         cmp al, ','        ; check if ','
0180+  0A64 C7 7C 0A      jne get_token_semi
0181+  0A67 F7            stosb          ; store ',' into token string
0182+  0A68 19 00         mov al, 0
0183+  0A6A F7            stosb          ; terminate token string
0184+  0A6B 19 0B         mov al, tok_comma
0185+  0A6D 3D A3 0B      mov [tok], al      
0186+  0A70 19 02         mov al, toktyp_delimiter
0187+  0A72 3D A2 0B      mov [toktyp], al
0188+  0A75 4E            mov a, si
0189+  0A76 42 A0 0B      mov [prog], a    ; update pointer
0190+  0A79 0A 2E 0B      jmp get_token_return
0191+  0A7C             get_token_semi:
0192+  0A7C B9 3B         cmp al, $3b        ; check if ';'
0193+  0A7E C7 96 0A      jne get_token_colon
0194+  0A81 F7            stosb          ; store ';' into token string
0195+  0A82 19 00         mov al, 0
0196+  0A84 F7            stosb          ; terminate token string
0197+  0A85 19 06         mov al, tok_semi
0198+  0A87 3D A3 0B      mov [tok], al      
0199+  0A8A 19 02         mov al, toktyp_delimiter
0200+  0A8C 3D A2 0B      mov [toktyp], al
0201+  0A8F 4E            mov a, si
0202+  0A90 42 A0 0B      mov [prog], a    ; update pointer
0203+  0A93 0A 2E 0B      jmp get_token_return
0204+  0A96             get_token_colon:
0205+  0A96 B9 3A         cmp al, $3a        ; check if ':'
0206+  0A98 C7 B0 0A      jne get_token_angle
0207+  0A9B F7            stosb          ; store ':' into token string
0208+  0A9C 19 00         mov al, 0
0209+  0A9E F7            stosb          ; terminate token string
0210+  0A9F 19 0A         mov al, tok_colon
0211+  0AA1 3D A3 0B      mov [tok], al      
0212+  0AA4 19 02         mov al, toktyp_delimiter
0213+  0AA6 3D A2 0B      mov [toktyp], al
0214+  0AA9 4E            mov a, si
0215+  0AAA 42 A0 0B      mov [prog], a    ; update pointer
0216+  0AAD 0A 2E 0B      jmp get_token_return
0217+  0AB0             get_token_angle:
0218+  0AB0 B9 3E         cmp al, $3e        ; check if '>'
0219+  0AB2 C7 CA 0A      jne get_token_tilde
0220+  0AB5 F7            stosb          ; store '>' into token string
0221+  0AB6 19 00         mov al, 0
0222+  0AB8 F7            stosb          ; terminate token string
0223+  0AB9 19 07         mov al, tok_angle
0224+  0ABB 3D A3 0B      mov [tok], al      
0225+  0ABE 19 02         mov al, toktyp_delimiter
0226+  0AC0 3D A2 0B      mov [toktyp], al
0227+  0AC3 4E            mov a, si
0228+  0AC4 42 A0 0B      mov [prog], a    ; update pointer
0229+  0AC7 0A 2E 0B      jmp get_token_return
0230+  0ACA             get_token_tilde:
0231+  0ACA B9 7E         cmp al, '~'        ; check if '~'
0232+  0ACC C7 E4 0A      jne get_token_equal
0233+  0ACF F7            stosb          ; store '~' into token string
0234+  0AD0 19 00         mov al, 0
0235+  0AD2 F7            stosb          ; terminate token string
0236+  0AD3 19 08         mov al, tok_tilde
0237+  0AD5 3D A3 0B      mov [tok], al      
0238+  0AD8 19 02         mov al, toktyp_delimiter
0239+  0ADA 3D A2 0B      mov [toktyp], al
0240+  0ADD 4E            mov a, si
0241+  0ADE 42 A0 0B      mov [prog], a    ; update pointer
0242+  0AE1 0A 2E 0B      jmp get_token_return
0243+  0AE4             get_token_equal:
0244+  0AE4 B9 3D         cmp al, '='        ; check if '='
0245+  0AE6 C7 FE 0A      jne get_token_skip
0246+  0AE9 F7            stosb          ; store '=' into token string
0247+  0AEA 19 00         mov al, 0
0248+  0AEC F7            stosb          ; terminate token string
0249+  0AED 19 09         mov al, tok_equal
0250+  0AEF 3D A3 0B      mov [tok], al      
0251+  0AF2 19 02         mov al, toktyp_delimiter
0252+  0AF4 3D A2 0B      mov [toktyp], al
0253+  0AF7 4E            mov a, si
0254+  0AF8 42 A0 0B      mov [prog], a    ; update pointer
0255+  0AFB 0A 2E 0B      jmp get_token_return
0256+  0AFE             get_token_skip:
0257+  0AFE 4E            mov a, si
0258+  0AFF 42 A0 0B      mov [prog], a    ; update pointer
0259+  0B02 0A 2E 0B      jmp get_token_return
0260+  0B05             get_token_end:        ; end of file token
0261+  0B05 19 14         mov al, tok_end
0262+  0B07 3D A3 0B      mov [tok], al
0263+  0B0A 19 06         mov al, toktyp_end
0264+  0B0C 3D A2 0B      mov [toktyp], al
0265+  0B0F 0A 2E 0B      jmp get_token_return
0266+  0B12             is_alphanumeric:
0267+  0B12 F7            stosb
0268+  0B13 F6            lodsb
0269+  0B14 07 D9 08      call _isalnum      ;check if is alphanumeric
0270+  0B17 C6 12 0B      jz is_alphanumeric
0271+  0B1A B9 2E         cmp al, $2e        ; check if is '.'
0272+  0B1C C6 12 0B      je is_alphanumeric
0273+  0B1F 19 00         mov al, 0
0274+  0B21 F7            stosb
0275+  0B22 19 00         mov al, toktyp_identifier
0276+  0B24 3D A2 0B      mov [toktyp], al
0277+  0B27 D5 01 00      sub si, 1
0278+  0B2A 4E            mov a, si
0279+  0B2B 42 A0 0B      mov [prog], a    ; update pointer
0280+  0B2E             get_token_return:
0281+  0B2E F0            pop di
0282+  0B2F EF            pop si
0283+  0B30 E7            pop d
0284+  0B31 E4            pop a
0285+  0B32 09            ret
0286+  0B33             get_tok_comment:
0287+  0B33 F6            lodsb
0288+  0B34 B9 0A         cmp al, $0a      ; new line
0289+  0B36 C7 33 0B      jne get_tok_comment
0290+  0B39 0A 17 0A      jmp get_tok_skip_spaces
0291+  0B3C             
0292+  0B3C             
0293+  0B3C             get_number:
0294+  0B3C D7            push a
0295+  0B3D DA            push d
0296+  0B3E E2            push si
0297+  0B3F E3            push di
0298+  0B40 19 00         mov al, 0
0299+  0B42 3D A4 0B      mov [tokstr], al      ; nullify tokstr string
0300+  0B45 19 00         mov al, tok_null
0301+  0B47 3D A3 0B      mov [tok], al        ; nullify token
0302+  0B4A 14 A0 0B      mov a, [prog]
0303+  0B4D 4D            mov si, a
0304+  0B4E FD 4F A4 0B   mov di, tokstr
0305+  0B52             get_number_skip_spaces:
0306+  0B52 F6            lodsb
0307+  0B53 07 4F 09      call _isspace
0308+  0B56 C6 52 0B      je get_number_skip_spaces
0309+  0B59 B9 00         cmp al, 0      ; check for end of input (null)
0310+  0B5B C7 6B 0B      jne get_number_l0
0311+  0B5E 19 14         mov al, tok_end
0312+  0B60 3D A3 0B      mov [tok], al
0313+  0B63 19 06         mov al, toktyp_end
0314+  0B65 3D A2 0B      mov [toktyp], al
0315+  0B68 0A 82 0B      jmp get_number_return
0316+  0B6B             get_number_l0:
0317+  0B6B F7            stosb
0318+  0B6C F6            lodsb
0319+  0B6D 07 E3 08      call _isdigit      ;check if is numeric
0320+  0B70 C6 6B 0B      jz get_number_l0
0321+  0B73 19 00         mov al, 0
0322+  0B75 F7            stosb
0323+  0B76 19 05         mov al, toktyp_numeric
0324+  0B78 3D A2 0B      mov [toktyp], al
0325+  0B7B D5 01 00      sub si, 1
0326+  0B7E 4E            mov a, si
0327+  0B7F 42 A0 0B      mov [prog], a    ; update pointer
0328+  0B82             get_number_return:
0329+  0B82 F0            pop di
0330+  0B83 EF            pop si
0331+  0B84 E7            pop d
0332+  0B85 E4            pop a
0333+  0B86 09            ret
0334+  0B87             
0335+  0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0B87             ;; put back token
0337+  0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  0B87             _putback:
0339+  0B87 D7            push a
0340+  0B88 E2            push si
0341+  0B89 FD 4D A4 0B   mov si, tokstr  
0342+  0B8D             _putback_loop:
0343+  0B8D F6            lodsb
0344+  0B8E B9 00         cmp al, 0
0345+  0B90 C6 9D 0B      je _putback_end
0346+  0B93 14 A0 0B      mov a, [prog]
0347+  0B96 7D            dec a
0348+  0B97 42 A0 0B      mov [prog], a      ; update pointer
0349+  0B9A 0A 8D 0B      jmp _putback_loop
0350+  0B9D             _putback_end:
0351+  0B9D EF            pop si
0352+  0B9E E4            pop a
0353+  0B9F 09            ret
0354+  0BA0             
0355+  0BA0             
0356+  0BA0             
0357+  0BA0             
0358+  0BA0 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  0BA2             
0360+  0BA2 00          toktyp:    .db 0          ; token type symbol
0361+  0BA3 00          tok:       .db 0          ; current token symbol
0362+  0BA4 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  0BA8 00 00 00 00 
0362+  0BAC 00 00 00 00 
0362+  0BB0 00 00 00 00 
0362+  0BB4 00 00 00 00 
0362+  0BB8 00 00 00 00 
0362+  0BBC 00 00 00 00 
0362+  0BC0 00 00 00 00 
0362+  0BC4 00 00 00 00 
0362+  0BC8 00 00 00 00 
0362+  0BCC 00 00 00 00 
0362+  0BD0 00 00 00 00 
0362+  0BD4 00 00 00 00 
0362+  0BD8 00 00 00 00 
0362+  0BDC 00 00 00 00 
0362+  0BE0 00 00 00 00 
0362+  0BE4 00 00 00 00 
0362+  0BE8 00 00 00 00 
0362+  0BEC 00 00 00 00 
0362+  0BF0 00 00 00 00 
0362+  0BF4 00 00 00 00 
0362+  0BF8 00 00 00 00 
0362+  0BFC 00 00 00 00 
0362+  0C00 00 00 00 00 
0362+  0C04 00 00 00 00 
0362+  0C08 00 00 00 00 
0362+  0C0C 00 00 00 00 
0362+  0C10 00 00 00 00 
0362+  0C14 00 00 00 00 
0362+  0C18 00 00 00 00 
0362+  0C1C 00 00 00 00 
0362+  0C20 00 00 00 00 
0362+  0C24 00 00 00 00 
0362+  0C28 00 00 00 00 
0362+  0C2C 00 00 00 00 
0362+  0C30 00 00 00 00 
0362+  0C34 00 00 00 00 
0362+  0C38 00 00 00 00 
0362+  0C3C 00 00 00 00 
0362+  0C40 00 00 00 00 
0362+  0C44 00 00 00 00 
0362+  0C48 00 00 00 00 
0362+  0C4C 00 00 00 00 
0362+  0C50 00 00 00 00 
0362+  0C54 00 00 00 00 
0362+  0C58 00 00 00 00 
0362+  0C5C 00 00 00 00 
0362+  0C60 00 00 00 00 
0362+  0C64 00 00 00 00 
0362+  0C68 00 00 00 00 
0362+  0C6C 00 00 00 00 
0362+  0C70 00 00 00 00 
0362+  0C74 00 00 00 00 
0362+  0C78 00 00 00 00 
0362+  0C7C 00 00 00 00 
0362+  0C80 00 00 00 00 
0362+  0C84 00 00 00 00 
0362+  0C88 00 00 00 00 
0362+  0C8C 00 00 00 00 
0362+  0C90 00 00 00 00 
0362+  0C94 00 00 00 00 
0362+  0C98 00 00 00 00 
0362+  0C9C 00 00 00 00 
0362+  0CA0 00 00 00 00 
1199   0CA4             
1200   0CA4             
1201   0CA4             ; kernel parameters
1202   0CA4             ; baud  divisor
1203   0CA4             ; 50    2304
1204   0CA4             ; 110   1047
1205   0CA4             ; 300    384
1206   0CA4             ; 600    192
1207   0CA4             ; 1200    96
1208   0CA4             ; 9600    12
1209   0CA4             ; 19200    6
1210   0CA4             ; 38400    3
1211   0CA4             sys_uart0_lcr:
1212   0CA4 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1213   0CA5             sys_uart0_inten:
1214   0CA5 01            .db 1
1215   0CA6             sys_uart0_fifoen:
1216   0CA6 00            .db 0
1217   0CA7             sys_uart0_div0:
1218   0CA7 03            .db 3
1219   0CA8             sys_uart0_div1:
1220   0CA8 00            .db 0   ; default baud = 38400
1221   0CA9             
1222   0CA9             sys_uart1_lcr:
1223   0CA9 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1224   0CAA             sys_uart1_inten:
1225   0CAA 01            .db 1
1226   0CAB             sys_uart1_fifoen:
1227   0CAB 00            .db 0
1228   0CAC             sys_uart1_div0:
1229   0CAC 03            .db 3
1230   0CAD             sys_uart1_div1:
1231   0CAD 00            .db 0   ; default baud = 38400
1232   0CAE             
1233   0CAE             fifo_in:
1234   0CAE 13 10         .dw fifo
1235   0CB0             fifo_out:
1236   0CB0 13 10         .dw fifo
1237   0CB2             
1238   0CB2             
1239   0CB2             s_init_path:
1240   0CB2 2F 73 62 69   .db "/sbin/init", 0
1240   0CB6 6E 2F 69 6E 
1240   0CBA 69 74 00 
1241   0CBD             s_uname:
1242   0CBD 73 6F 6C 61   .db "solarium v.1.0", 0
1242   0CC1 72 69 75 6D 
1242   0CC5 20 76 2E 31 
1242   0CC9 2E 30 00 
1243   0CCC             s_dataentry:
1244   0CCC 3E 20 00      .db "> ", 0
1245   0CCF             s_parent_dir:
1246   0CCF 2E 2E 00      .db "..", 0
1247   0CD2             s_current_dir:
1248   0CD2 2E 00         .db ".", 0
1249   0CD4             s_fslash:
1250   0CD4 2F 00         .db "/", 0
1251   0CD6             file_attrib:
1252   0CD6 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
1252   0CDA 78 
1253   0CDB             file_type:
1254   0CDB 2D 64 63      .db "-dc"
1255   0CDE             s_ps_header:
1256   0CDE 70 69 64 20   .db "pid command\n", 0
1256   0CE2 63 6F 6D 6D 
1256   0CE6 61 6E 64 0A 
1256   0CEA 00 
1257   0CEB             s_ls_total:
1258   0CEB 74 6F 74 61   .db "total: ", 0
1258   0CEF 6C 3A 20 00 
1259   0CF3             
1260   0CF3             s_int_en:
1261   0CF3 69 72 71 73   .db "irqs enabled\n", 0
1261   0CF7 20 65 6E 61 
1261   0CFB 62 6C 65 64 
1261   0CFF 0A 00 
1262   0D01             s_kernel_welcome:
1263   0D01 2A 2A 2A 2A   .db "************************************************\n"
1263   0D05 2A 2A 2A 2A 
1263   0D09 2A 2A 2A 2A 
1263   0D0D 2A 2A 2A 2A 
1263   0D11 2A 2A 2A 2A 
1263   0D15 2A 2A 2A 2A 
1263   0D19 2A 2A 2A 2A 
1263   0D1D 2A 2A 2A 2A 
1263   0D21 2A 2A 2A 2A 
1263   0D25 2A 2A 2A 2A 
1263   0D29 2A 2A 2A 2A 
1263   0D2D 2A 2A 2A 2A 
1263   0D31 0A 
1264   0D32 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
1264   0D36 57 65 6C 63 
1264   0D3A 6F 6D 65 20 
1264   0D3E 74 6F 20 53 
1264   0D42 6F 6C 61 72 
1264   0D46 69 75 6D 20 
1264   0D4A 4F 53 20 2D 
1264   0D4E 20 4B 65 72 
1264   0D52 6E 65 6C 20 
1264   0D56 76 65 72 2E 
1264   0D5A 20 31 2E 30 
1264   0D5E 20 2A 2A 2A 
1264   0D62 0A 
1265   0D63 2A 2A 2A 20   .db "*** type help for more information           ***\n"
1265   0D67 74 79 70 65 
1265   0D6B 20 68 65 6C 
1265   0D6F 70 20 66 6F 
1265   0D73 72 20 6D 6F 
1265   0D77 72 65 20 69 
1265   0D7B 6E 66 6F 72 
1265   0D7F 6D 61 74 69 
1265   0D83 6F 6E 20 20 
1265   0D87 20 20 20 20 
1265   0D8B 20 20 20 20 
1265   0D8F 20 2A 2A 2A 
1265   0D93 0A 
1266   0D94 2A 2A 2A 2A   .db "************************************************\n", 0
1266   0D98 2A 2A 2A 2A 
1266   0D9C 2A 2A 2A 2A 
1266   0DA0 2A 2A 2A 2A 
1266   0DA4 2A 2A 2A 2A 
1266   0DA8 2A 2A 2A 2A 
1266   0DAC 2A 2A 2A 2A 
1266   0DB0 2A 2A 2A 2A 
1266   0DB4 2A 2A 2A 2A 
1266   0DB8 2A 2A 2A 2A 
1266   0DBC 2A 2A 2A 2A 
1266   0DC0 2A 2A 2A 2A 
1266   0DC4 0A 00 
1267   0DC6             s_prompt_init:
1268   0DC6 73 74 61 72   .db "starting init\n", 0
1268   0DCA 74 69 6E 67 
1268   0DCE 20 69 6E 69 
1268   0DD2 74 0A 00 
1269   0DD5             s_priviledge:
1270   0DD5 0A 65 78 63   .db "\nexception: privilege\n", 0
1270   0DD9 65 70 74 69 
1270   0DDD 6F 6E 3A 20 
1270   0DE1 70 72 69 76 
1270   0DE5 69 6C 65 67 
1270   0DE9 65 0A 00 
1271   0DEC             s_divzero:
1272   0DEC 0A 65 78 63   .db "\nexception: zero division\n", 0
1272   0DF0 65 70 74 69 
1272   0DF4 6F 6E 3A 20 
1272   0DF8 7A 65 72 6F 
1272   0DFC 20 64 69 76 
1272   0E00 69 73 69 6F 
1272   0E04 6E 0A 00 
1273   0E07             
1274   0E07             s_break1:  
1275   0E07 0A 64 65 62   .db "\ndebugger entry point.\n"
1275   0E0B 75 67 67 65 
1275   0E0F 72 20 65 6E 
1275   0E13 74 72 79 20 
1275   0E17 70 6F 69 6E 
1275   0E1B 74 2E 0A 
1276   0E1E 30 2E 20 73   .db "0. show registers\n"
1276   0E22 68 6F 77 20 
1276   0E26 72 65 67 69 
1276   0E2A 73 74 65 72 
1276   0E2E 73 0A 
1277   0E30 31 2E 20 73   .db "1. show 512b ram block\n"
1277   0E34 68 6F 77 20 
1277   0E38 35 31 32 62 
1277   0E3C 20 72 61 6D 
1277   0E40 20 62 6C 6F 
1277   0E44 63 6B 0A 
1278   0E47 32 2E 20 63   .db "2. continue execution", 0
1278   0E4B 6F 6E 74 69 
1278   0E4F 6E 75 65 20 
1278   0E53 65 78 65 63 
1278   0E57 75 74 69 6F 
1278   0E5B 6E 00 
1279   0E5D             
1280   0E5D             s_set_year:
1281   0E5D 79 65 61 72   .db "year: ", 0
1281   0E61 3A 20 00 
1282   0E64             s_set_month:
1283   0E64 6D 6F 6E 74   .db "month: ", 0
1283   0E68 68 3A 20 00 
1284   0E6C             s_set_day:
1285   0E6C 64 61 79 3A   .db "day: ", 0
1285   0E70 20 00 
1286   0E72             s_set_week:
1287   0E72 77 65 65 6B   .db "weekday: ", 0
1287   0E76 64 61 79 3A 
1287   0E7A 20 00 
1288   0E7C             s_set_hours:
1289   0E7C 68 6F 75 72   .db "hours: ", 0
1289   0E80 73 3A 20 00 
1290   0E84             s_set_minutes:
1291   0E84 6D 69 6E 75   .db "minutes: ", 0
1291   0E88 74 65 73 3A 
1291   0E8C 20 00 
1292   0E8E             s_set_seconds:
1293   0E8E 73 65 63 6F   .db "seconds: ", 0
1293   0E92 6E 64 73 3A 
1293   0E96 20 00 
1294   0E98             s_months:      
1295   0E98 20 20 20 00   .db "   ", 0
1296   0E9C 6A 61 6E 00   .db "jan", 0
1297   0EA0 66 65 62 00   .db "feb", 0
1298   0EA4 6D 61 72 00   .db "mar", 0
1299   0EA8 61 70 72 00   .db "apr", 0
1300   0EAC 6D 61 79 00   .db "may", 0
1301   0EB0 6A 75 6E 00   .db "jun", 0
1302   0EB4 6A 75 6C 00   .db "jul", 0
1303   0EB8 61 75 67 00   .db "aug", 0
1304   0EBC 73 65 70 00   .db "sep", 0
1305   0EC0 6F 63 74 00   .db "oct", 0
1306   0EC4 6E 6F 76 00   .db "nov", 0
1307   0EC8 64 65 63 00   .db "dec", 0
1308   0ECC             
1309   0ECC             s_week:        
1310   0ECC 73 75 6E 00   .db "sun", 0 
1311   0ED0 6D 6F 6E 00   .db "mon", 0 
1312   0ED4 74 75 65 00   .db "tue", 0 
1313   0ED8 77 65 64 00   .db "wed", 0 
1314   0EDC 74 68 75 00   .db "thu", 0 
1315   0EE0 66 72 69 00   .db "fri", 0 
1316   0EE4 73 61 74 00   .db "sat", 0
1317   0EE8             
1318   0EE8 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
1318   0EEC 30 20 45 78 
1318   0EF0 65 63 75 74 
1318   0EF4 65 64 2E 0A 
1318   0EF8 00 
1319   0EF9             s_fdc_config:
1320   0EF9 66 6C 6F 70   .db "floppy drive configuration:\n" 
1320   0EFD 70 79 20 64 
1320   0F01 72 69 76 65 
1320   0F05 20 63 6F 6E 
1320   0F09 66 69 67 75 
1320   0F0D 72 61 74 69 
1320   0F11 6F 6E 3A 0A 
1321   0F15 20 20 64 72   .db "  drive:     0\n"
1321   0F19 69 76 65 3A 
1321   0F1D 20 20 20 20 
1321   0F21 20 30 0A 
1322   0F24 20 20 73 69   .db "  side:      0\n"
1322   0F28 64 65 3A 20 
1322   0F2C 20 20 20 20 
1322   0F30 20 30 0A 
1323   0F33 20 20 64 65   .db "  density:   single density\n"
1323   0F37 6E 73 69 74 
1323   0F3B 79 3A 20 20 
1323   0F3F 20 73 69 6E 
1323   0F43 67 6C 65 20 
1323   0F47 64 65 6E 73 
1323   0F4B 69 74 79 0A 
1324   0F4F 20 20 68 65   .db "  head load: loaded\n", 0
1324   0F53 61 64 20 6C 
1324   0F57 6F 61 64 3A 
1324   0F5B 20 6C 6F 61 
1324   0F5F 64 65 64 0A 
1324   0F63 00 
1325   0F64             
1326   0F64 72 65 73 65 s_reset_proc_tbl: .db "resetting process table...\n", 0
1326   0F68 74 74 69 6E 
1326   0F6C 67 20 70 72 
1326   0F70 6F 63 65 73 
1326   0F74 73 20 74 61 
1326   0F78 62 6C 65 2E 
1326   0F7C 2E 2E 0A 00 
1327   0F80             
1328   0F80 01 00       pid_counter:      .dw 1
1329   0F82 00          curr_pid:         .db 0  ; current process pid
1330   0F83             
1331   0F83             file_obj_table:   .equ $
1332   0F83             proc_table:       .equ $ + _size_file_obj_table
1333   0F83             
1334   0F83             
1335   0F83             ; here we define areas that keep transient data
1336   0F83             ; we use '$' which is the assembler's current address pointer so that these areas are defined to be exactly
1337   0F83             ; after all the static data has been declared
1338   0F83             fifo:           .equ $ + _size_file_obj_table + _size_proc_table
1339   0F83             scrap_sector:   .equ $ + _size_file_obj_table + _size_proc_table + _fifo_size
1340   0F83             transient_area: .equ $ + _size_file_obj_table + _size_proc_table + _fifo_size + _scrap_size
1341   0F83             
1342   0F83             
1343   0F83             
1344   0F83             .end
tasm: Number of errors = 0
