0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 48 00       .dw int_6
0141   000E 49 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 EE 0F       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 A3 02       .dw trap_privilege
0153   0014 C0 03       .dw trap_div_zero
0154   0016 CD 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 AF 02       .dw syscall_break
0165   0022 CE 03       .dw syscall_rtc
0166   0024 F1 04       .dw syscall_ide
0167   0026 B1 05       .dw syscall_io
0168   0028 6E 06       .dw syscall_file_system
0169   002A 3B 0F       .dw syscall_create_proc
0170   002C 68 02       .dw syscall_list_procs
0171   002E 00 04       .dw syscall_datetime
0172   0030 24 02       .dw syscall_reboot
0173   0032 05 0F       .dw syscall_pause_proc
0174   0034 30 02       .dw syscall_resume_proc
0175   0036 C2 0E       .dw syscall_terminate_proc
0176   0038 F0 01       .dw syscall_system
0177   003A 98 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; aliases for individual 'al' options for FDC system calls
0198   003C             sys_fdc_restore      .equ 0
0199   003C             sys_fdc_step         .equ 1
0200   003C             sys_fdc_step_in      .equ 2
0201   003C             sys_fdc_step_out     .equ 3
0202   003C             sys_fdc_seek         .equ 4
0203   003C             sys_fdc_format       .equ 5
0204   003C             sys_fdc_read_addr    .equ 6
0205   003C             sys_fdc_read_track   .equ 7
0206   003C             sys_fdc_read_sect    .equ 8
0207   003C             sys_fdc_write_sect   .equ 9
0208   003C             sys_fdc_force_int    .equ 10
0209   003C             sys_fdc_status0      .equ 11
0210   003C             sys_fdc_status1      .equ 12
0211   003C             
0212   003C             ; ------------------------------------------------------------------------------------------------------------------;
0213   003C             ; alias exports
0214   003C             ; ------------------------------------------------------------------------------------------------------------------;
0215   003C             .export text_org
0216   003C             .export sys_break
0217   003C             .export sys_rtc
0218   003C             .export sys_ide
0219   003C             .export sys_io
0220   003C             .export sys_filesystem
0221   003C             .export sys_create_proc
0222   003C             .export sys_list_proc
0223   003C             .export sys_datetime
0224   003C             .export sys_reboot
0225   003C             .export sys_pause_proc
0226   003C             .export sys_resume_proc
0227   003C             .export sys_terminate_proc
0228   003C             .export sys_system
0229   003C             .export sys_fdc
0230   003C             
0231   003C             ; exports of aliases for individual 'al' options for FDC system calls
0232   003C             .export sys_fdc_restore
0233   003C             .export sys_fdc_step
0234   003C             .export sys_fdc_step_in
0235   003C             .export sys_fdc_step_out
0236   003C             .export sys_fdc_seek
0237   003C             .export sys_fdc_format
0238   003C             .export sys_fdc_read_addr
0239   003C             .export sys_fdc_read_track
0240   003C             .export sys_fdc_read_sect
0241   003C             .export sys_fdc_write_sect
0242   003C             .export sys_fdc_force_int
0243   003C             .export sys_fdc_status0
0244   003C             .export sys_fdc_status1
0245   003C             ; ------------------------------------------------------------------------------------------------------------------;
0246   003C             ; irqs' code block
0247   003C             ; ------------------------------------------------------------------------------------------------------------------;
0248   003C             ; 5.25" floppy drive controller irq
0249   003C             int_0_fdc:
0250   003C 3B B6 18      mov d, s_fdc_irq
0251   003F 07 42 12      call _puts
0252   0042 06            sysret
0253   0043             int_1:
0254   0043 06            sysret
0255   0044             int_2:
0256   0044 06            sysret
0257   0045             int_3:
0258   0045 06            sysret
0259   0046             int_4:
0260   0046 06            sysret
0261   0047             int_5:
0262   0047 06            sysret
0263   0048             
0264   0048             ; timer irq
0265   0048             int_6:  
0266   0048 06            sysret
0267   0049             
0268   0049             ; ------------------------------------------------------------------------------------------------------------------;
0269   0049             ; uart0 interrupt
0270   0049             ; ------------------------------------------------------------------------------------------------------------------;
0271   0049             int_7_uart0:
0272   0049 D7            push a
0273   004A DA            push d
0274   004B E1            pushf
0275   004C 14 78 17      mov a, [fifo_in]
0276   004F 3C            mov d, a
0277   0050 1D 80 FF      mov al, [_uart0_data]       ; get character
0278   0053 B9 03         cmp al, $03                 ; ctrl-c
0279   0055 C6 72 00      je ctrlc
0280   0058 B9 1A         cmp al, $1a                 ; ctrl-z
0281   005A C6 78 00      je ctrlz
0282   005D 3E            mov [d], al                 ; add to fifo
0283   005E 14 78 17      mov a, [fifo_in]
0284   0061 77            inc a
0285   0062 AF D9 22      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0286   0065 C7 6B 00      jne int_7_continue
0287   0068 10 D9 1E      mov a, fifo  
0288   006B             int_7_continue:  
0289   006B 42 78 17      mov [fifo_in], a            ; update fifo pointer
0290   006E EE            popf
0291   006F E7            pop d
0292   0070 E4            pop a  
0293   0071 06            sysret
0294   0072             ctrlc:
0295   0072 51 05 00      add sp, 5
0296   0075 0A C2 0E      jmp syscall_terminate_proc
0297   0078             ctrlz:
0298   0078 EE            popf
0299   0079 E7            pop d
0300   007A E4            pop a
0301   007B 0A 05 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0302   007E             
0303   007E             ; ------------------------------------------------------------------------------------------------------------------;
0304   007E             ; floppy drive syscalls
0305   007E             ; ------------------------------------------------------------------------------------------------------------------;
0306   007E             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0307   007E             ; fdc_40_ff:
0308   007E             ;   .fill 40,  $ff    ; or 00                                                                                
0309   007E             ; fdc_128_format_inner:
0310   007E             ;   .fill 6,   $00    ;                                                                            <--|        
0311   007E             ;   .fill 1,   $fe    ; id address mark                                                               |        
0312   007E             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0313   007E             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0314   007E             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0315   007E             ;   .fill 1,   $00    ; sector length                                                                 |                        
0316   007E             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0317   007E             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0318   007E             ;   .fill 6,   $00    ;                                                                               |                        
0319   007E             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0320   007E             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0321   007E             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0322   007E             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0323   007E             ; fdc_128_format_end:
0324   007E             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0325   007E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0326   007E             fdc_jmptbl:
0327   007E A4 00         .dw syscall_fdc_restore
0328   0080 A9 00         .dw syscall_fdc_step
0329   0082 AA 00         .dw syscall_fdc_step_in
0330   0084 AF 00         .dw syscall_fdc_step_out
0331   0086 B4 00         .dw syscall_fdc_seek
0332   0088 B7 00         .dw syscall_fdc_format
0333   008A B5 00         .dw syscall_fdc_read_addr
0334   008C DF 00         .dw syscall_fdc_read_track
0335   008E 0D 01         .dw syscall_fdc_read_sect
0336   0090 43 01         .dw syscall_fdc_write_sect
0337   0092 B6 00         .dw syscall_fdc_force_int
0338   0094 9C 00         .dw syscall_fdc_status0
0339   0096 A0 00         .dw syscall_fdc_status1
0340   0098             syscall_fdc:
0341   0098 FD 0A 7E 00   jmp [fdc_jmptbl + al]
0342   009C             
0343   009C             syscall_fdc_status0:
0344   009C 1D C1 FF      mov al, [_fdc_status_0]
0345   009F 06            sysret
0346   00A0             syscall_fdc_status1:
0347   00A0 1D C8 FF      mov al, [_fdc_stat_cmd]
0348   00A3 06            sysret
0349   00A4             syscall_fdc_restore:
0350   00A4 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0351   00A8 06            sysret
0352   00A9             
0353   00A9             syscall_fdc_step:
0354   00A9 06            sysret
0355   00AA             
0356   00AA             syscall_fdc_step_in:
0357   00AA F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0358   00AE 06            sysret
0359   00AF             
0360   00AF             syscall_fdc_step_out:
0361   00AF F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0362   00B3 06            sysret
0363   00B4             
0364   00B4             syscall_fdc_seek:
0365   00B4 06            sysret
0366   00B5             
0367   00B5             syscall_fdc_read_addr:
0368   00B5 06            sysret
0369   00B6             
0370   00B6             syscall_fdc_force_int:
0371   00B6 06            sysret
0372   00B7             
0373   00B7             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0374   00B7             ; in the ram formatting block because they are all set as 00 right now
0375   00B7             ; bl: track number
0376   00B7             syscall_fdc_format:
0377   00B7 FD 3D C9 FF   mov [_fdc_track], bl
0378   00BB F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0379   00BF FD 4D D9 24   mov si, transient_area
0380   00C3 F6            lodsb
0381   00C4 3D CB FF      mov [_fdc_data], al      ; 10   
0382   00C7 07 DF 01      call fdc_wait_64us
0383   00CA             fdc_format_drq:
0384   00CA 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0385   00CD 93 01         test al, $01                ; 4
0386   00CF C6 DE 00      jz fdc_format_end           ; 8
0387   00D2 93 02         test al, $02                ; 4
0388   00D4 C6 CA 00      jz fdc_format_drq           ; 8
0389   00D7 F6            lodsb                       ; 7
0390   00D8 3D CB FF      mov [_fdc_data], al         ; 10   
0391   00DB 0A CA 00      jmp fdc_format_drq
0392   00DE             fdc_format_end:
0393   00DE 06            sysret
0394   00DF             
0395   00DF             ; di = destination in user space
0396   00DF             syscall_fdc_read_track:
0397   00DF F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0398   00E3 07 DF 01      call fdc_wait_64us
0399   00E6 E3            push di
0400   00E7 FD 4F D9 24   mov di, transient_area
0401   00EB             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0402   00EB 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0403   00EE 93 01         test al, $01                ; check busy bit
0404   00F0 C6 FF 00      jz fdc_read_track_end
0405   00F3 93 02         test al, $02                ; check drq bit
0406   00F5 C6 EB 00      jz fdc_read_track_l0
0407   00F8 1D CB FF      mov al, [_fdc_data]     ; 
0408   00FB F7            stosb
0409   00FC 0A EB 00      jmp fdc_read_track_l0
0410   00FF             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0411   00FF             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0412   00FF             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0413   00FF             fdc_read_track_end:
0414   00FF 50            mov a, di
0415   0100 5F D9 24      sub a, transient_area
0416   0103 F0            pop di
0417   0104 FD 4D D9 24   mov si, transient_area
0418   0108 38 D2 0E      mov c, 40 + 169 * 16 + 450  ; copy track over to user space
0419   010B 03            store
0420   010C 06            sysret
0421   010D             
0422   010D             ; sector in bl
0423   010D             ; track in bh
0424   010D             ; di = user space destination
0425   010D             syscall_fdc_read_sect:
0426   010D 11            mov a, b
0427   010E 3D CA FF      mov [_fdc_sector], al
0428   0111 1A            mov al, ah
0429   0112 3D C9 FF      mov [_fdc_track], al
0430   0115 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0431   0119 07 DF 01      call fdc_wait_64us
0432   011C E3            push di
0433   011D FD 4F D9 24   mov di, transient_area
0434   0121             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0435   0121 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0436   0124 93 01         test al, $01                ; check drq bit
0437   0126 C6 35 01      jz fdc_read_sect_end
0438   0129 93 02         test al, $02                ; check drq bit
0439   012B C6 21 01      jz fdc_read_sect_l0
0440   012E 1D CB FF      mov al, [_fdc_data]     ; 
0441   0131 F7            stosb
0442   0132 0A 21 01      jmp fdc_read_sect_l0
0443   0135             fdc_read_sect_end:
0444   0135 50            mov a, di
0445   0136 5F D9 24      sub a, transient_area
0446   0139 F0            pop di
0447   013A FD 4D D9 24   mov si, transient_area
0448   013E 38 80 00      mov c, 128  ; copy sector over to user space
0449   0141 03            store
0450   0142 06            sysret
0451   0143             
0452   0143             ; sector in al
0453   0143             ; track in ah
0454   0143             ; data pointer in si
0455   0143             syscall_fdc_write_sect:
0456   0143 11            mov a, b
0457   0144 3D CA FF      mov [_fdc_sector], al
0458   0147 1A            mov al, ah
0459   0148 3D C9 FF      mov [_fdc_track], al
0460   014B FD 4F D9 24   mov di, transient_area    ; si = data source, di = destination 
0461   014F 38 80 00      mov c, 128
0462   0152 04            load                    ; transfer data to kernel space!
0463   0153 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0464   0157 F6            lodsb                      
0465   0158 3D CB FF      mov [_fdc_data], al      
0466   015B 07 DF 01      call fdc_wait_64us
0467   015E             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0468   015E 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0469   0161 93 01         test al, $01                    ; 4
0470   0163 C6 72 01      jz fdc_write_sect_end           ; 8
0471   0166 93 02         test al, $02                    ; 4
0472   0168 C6 5E 01      jz fdc_write_sect_l0            ; 8
0473   016B F6            lodsb                           ; 7
0474   016C 3D CB FF      mov [_fdc_data], al             ; 10   
0475   016F 0A 5E 01      jmp fdc_write_sect_l0
0476   0172             fdc_write_sect_end:
0477   0172 06            sysret
0478   0173             
0479   0173             fdc_format_mem:
0480   0173 3B 01 00      mov d, 1
0481   0176 FD 4F D9 24   mov di, transient_area
0482   017A             ; 40 * FF
0483   017A 38 28 00      mov c, 40
0484   017D 19 FF         mov al, $ff
0485   017F             fdc_l0: 
0486   017F F7            stosb
0487   0180 7E            dec c
0488   0181 C7 7F 01      jnz fdc_l0
0489   0184             ; 6 * 00
0490   0184             fdc_inner_loop:
0491   0184 38 06 00      mov c, 6
0492   0187 19 00         mov al, $00
0493   0189             fdc_l1:
0494   0189 F7            stosb
0495   018A 7E            dec c
0496   018B C7 89 01      jnz fdc_l1
0497   018E             ; FE address mark
0498   018E             fdc_l2:
0499   018E 19 FE         mov al, $fe
0500   0190 F7            stosb
0501   0191             ; track number
0502   0191             fdc_l3:
0503   0191 19 00         mov al, $00
0504   0193 F7            stosb
0505   0194             ; side number
0506   0194             fdc_l4:
0507   0194 19 00         mov al, $00
0508   0196 F7            stosb
0509   0197             ; sector number
0510   0197             fdc_l5:
0511   0197 13            mov a, d
0512   0198 F7            stosb
0513   0199             ; sector length 128 bytes
0514   0199             fdc_l6:
0515   0199 19 00         mov al, $00
0516   019B F7            stosb
0517   019C             ; 2 crc's
0518   019C             fdc_l7:
0519   019C 19 F7         mov al, $f7
0520   019E F7            stosb
0521   019F             ; 11 times $ff
0522   019F 38 0B 00      mov c, 11
0523   01A2 19 FF         mov al, $ff
0524   01A4             fdc_l8:
0525   01A4 F7            stosb
0526   01A5 7E            dec c
0527   01A6 C7 A4 01      jnz fdc_l8
0528   01A9             ; 6 times 00
0529   01A9 38 06 00      mov c, 6
0530   01AC 19 00         mov al, $00
0531   01AE             fdc_l9:
0532   01AE F7            stosb
0533   01AF 7E            dec c
0534   01B0 C7 AE 01      jnz fdc_l9
0535   01B3             ; FB data address mark
0536   01B3 19 FB         mov al, $fb
0537   01B5             fdc_l10:
0538   01B5 F7            stosb
0539   01B6             ; 128 bytes sector data
0540   01B6 38 80 00      mov c, 128
0541   01B9 19 E5         mov al, $E5
0542   01BB             fdc_l11:
0543   01BB F7            stosb
0544   01BC 7E            dec c
0545   01BD C7 BB 01      jnz fdc_l11
0546   01C0             ; 2 crc's
0547   01C0             fdc_l12:
0548   01C0 19 F7         mov al, $f7
0549   01C2 F7            stosb
0550   01C3             ; 10 * $FF
0551   01C3 38 0A 00      mov c, 10
0552   01C6 19 FF         mov al, $ff
0553   01C8             fdc_l13:
0554   01C8 F7            stosb
0555   01C9 7E            dec c
0556   01CA C7 C8 01      jnz fdc_l13
0557   01CD             ; check whether we did this 16 times
0558   01CD 79            inc d
0559   01CE C5 11 00      cmp d, 17
0560   01D1 C7 84 01      jne fdc_inner_loop
0561   01D4             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0562   01D4 38 F4 01      mov c, 500
0563   01D7 19 FF         mov al, $ff
0564   01D9             fdc_format_footer:
0565   01D9             fdc_footer_drq_loop:
0566   01D9 F7            stosb
0567   01DA 7E            dec c
0568   01DB C7 D9 01      jnz fdc_footer_drq_loop
0569   01DE 09            ret
0570   01DF             
0571   01DF             ; fetch is 2 cycles long when 'display_reg_load' is false.
0572   01DF             ; 64us amounts to 160 cycles of the 2.5mhz clock
0573   01DF             ; call u16 is 14 cycles long
0574   01DF             ; 160 - 5 - 14 = 
0575   01DF             fdc_wait_64us:
0576   01DF 3A 0D         mov cl, 13                       ; 5 cycles
0577   01E1             fdc_wait_64_loop:
0578   01E1 81            dec cl                           ; 3 cycles
0579   01E2 C7 E1 01      jnz fdc_wait_64_loop             ; 8 cycles
0580   01E5 09            ret
0581   01E6             
0582   01E6             ; ------------------------------------------------------------------------------------------------------------------;
0583   01E6             ; system syscalls
0584   01E6             ; ------------------------------------------------------------------------------------------------------------------;
0585   01E6             system_jmptbl:
0586   01E6 1C 02         .dw system_uname
0587   01E8 23 02         .dw system_whoami
0588   01EA F6 01         .dw system_setparam
0589   01EC F9 01         .dw system_bootloader_install
0590   01EE F4 01         .dw system_getparam
0591   01F0             syscall_system:
0592   01F0 FD 0A E6 01   jmp [system_jmptbl + al]
0593   01F4             
0594   01F4             ; param register address in register d
0595   01F4             ; param value in register bl
0596   01F4             system_getparam:
0597   01F4 32            mov bl, [d]
0598   01F5 06            sysret
0599   01F6             
0600   01F6             ; param register address in register d
0601   01F6             ; param value in register bl
0602   01F6             system_setparam:
0603   01F6 FD 3E         mov [d], bl
0604   01F8 06            sysret
0605   01F9             
0606   01F9             ; kernel LBA address in 'b'
0607   01F9             system_bootloader_install:
0608   01F9 D8            push b
0609   01FA 26 00 00      mov b, 0
0610   01FD 38 00 00      mov c, 0
0611   0200 22 01         mov ah, $01                 ; 1 sector
0612   0202 3B D9 24      mov d, transient_area
0613   0205 07 20 05      call ide_read_sect          ; read sector
0614   0208 E5            pop b
0615   0209 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0616   020D 26 00 00      mov b, 0
0617   0210 38 00 00      mov c, 0
0618   0213 22 01         mov ah, $01                 ; 1 sector
0619   0215 3B D9 24      mov d, transient_area
0620   0218 07 46 05      call ide_write_sect         ; write sector
0621   021B 06            sysret
0622   021C             
0623   021C             system_uname:
0624   021C 3B 89 17      mov d, s_uname
0625   021F 07 42 12      call _puts
0626   0222 06            sysret
0627   0223             
0628   0223             system_whoami:
0629   0223 06            sysret
0630   0224             
0631   0224             ; reboot system
0632   0224             syscall_reboot:
0633   0224 FD D7 FF FF   push word $ffff 
0634   0228 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0635   022B FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0636   022F 06            sysret
0637   0230             
0638   0230             ;------------------------------------------------------------------------------------------------------;;
0639   0230             ; switch to another process
0640   0230             ; inputs:
0641   0230             ; al = new process number
0642   0230             ;------------------------------------------------------------------------------------------------------;;
0643   0230             syscall_resume_proc:
0644   0230 FD 78         mov g, a                            ; save the process number
0645   0232 4B            pusha                               ; save all registers into kernel stack
0646   0233 22 00         mov ah, 0
0647   0235 1D 73 17      mov al, [active_proc_index]
0648   0238 FD 99         shl a              ; x2
0649   023A B7 B8 0F      mov a, [proc_table_convert + a]     ; get process state start index
0650   023D 4F            mov di, a
0651   023E 48            mov a, sp
0652   023F 77            inc a
0653   0240 4D            mov si, a
0654   0241 38 14 00      mov c, 20
0655   0244 FD F5         rep movsb                           ; save process state!
0656   0246             ; restore kernel stack position to point before interrupt arrived
0657   0246 51 14 00      add sp, 20
0658   0249             ; now load the new process number!
0659   0249 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0660   024B 3D 73 17      mov [active_proc_index], al         ; set new active proc
0661   024E             ; calculate lut entry for next process
0662   024E 22 00         mov ah, 0
0663   0250 FD 99         shl a                               ; x2
0664   0252 B7 B8 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0665   0255 4D            mov si, a                           ; source is proc state block
0666   0256 48            mov a, sp
0667   0257 5F 13 00      sub a, 19
0668   025A 4F            mov di, a                           ; destination is kernel stack
0669   025B             ; restore sp
0670   025B 7D            dec a
0671   025C 47            mov sp, a
0672   025D 38 14 00      mov c, 20
0673   0260 FD F5         rep movsb
0674   0262             ; set vm process
0675   0262 1D 73 17      mov al, [active_proc_index]
0676   0265 01            setptb
0677   0266 4C            popa
0678   0267 06            sysret
0679   0268             
0680   0268             ;------------------------------------------------------------------------------------------------------;;
0681   0268             ; list processes
0682   0268             ;------------------------------------------------------------------------------------------------------;;
0683   0268             syscall_list_procs:
0684   0268 3B AA 17      mov d, s_ps_header
0685   026B 07 42 12      call _puts
0686   026E 3B 4A 1A      mov d, proc_availab_table + 1
0687   0271 38 01 00      mov c, 1
0688   0274             list_procs_l0:  
0689   0274 BD 01         cmp byte[d], 1
0690   0276 C7 9A 02      jne list_procs_next
0691   0279 2D            mov b, d
0692   027A 61 49 1A      sub b, proc_availab_table
0693   027D FD 9F 05      shl b, 5
0694   0280 DA            push d
0695   0281 D8            push b
0696   0282 28            mov b, c
0697   0283 07 E2 12      call print_u8x
0698   0286 22 20         mov ah, ' '
0699   0288 07 16 11      call _putchar
0700   028B 07 16 11      call _putchar
0701   028E E5            pop b
0702   028F 74            mov d, b
0703   0290 58 59 1A      add d, proc_names
0704   0293 07 42 12      call _puts
0705   0296 07 EF 11      call printnl
0706   0299 E7            pop d
0707   029A             list_procs_next:
0708   029A 79            inc d
0709   029B 78            inc c
0710   029C C2 09 00      cmp c, 9
0711   029F C7 74 02      jne list_procs_l0
0712   02A2             list_procs_end:
0713   02A2 06            sysret
0714   02A3             
0715   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0716   02A3             ; exceptions code block
0717   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0718   02A3             ; privilege exception
0719   02A3             ; ------------------------------------------------------------------------------------------------------------------;
0720   02A3             trap_privilege:
0721   02A3 0A 24 02      jmp syscall_reboot
0722   02A6 DA            push d
0723   02A7 3B F9 17      mov d, s_priviledge
0724   02AA 07 42 12      call _puts
0725   02AD E7            pop d
0726   02AE 06            sysret
0727   02AF             
0728   02AF             ; ------------------------------------------------------------------------------------------------------------------;
0729   02AF             ; breakpoint
0730   02AF             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0731   02AF             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0732   02AF             ; ------------------------------------------------------------------------------------------------------------------;
0733   02AF             syscall_break:
0734   02AF 4B            pusha
0735   02B0             syscall_break_prompt:
0736   02B0 3B 6A 03      mov d, s_break1
0737   02B3 07 42 12      call _puts
0738   02B6 07 EF 11      call printnl
0739   02B9 07 44 13      call scan_u16d
0740   02BC AF 00 00      cmp a, 0
0741   02BF C6 CA 02      je syscall_break_regs
0742   02C2 AF 01 00      cmp a, 1
0743   02C5 C6 ED 02      je syscall_break_mem
0744   02C8             syscall_break_end:  
0745   02C8 4C            popa
0746   02C9 06            sysret
0747   02CA             syscall_break_regs:
0748   02CA 48            mov a, sp
0749   02CB 53 0E 00      add a, 14               ; back-track 7 registers
0750   02CE 3C            mov d, a
0751   02CF 3A 07         mov cl, 7
0752   02D1             syscall_regs_l0:
0753   02D1 2A            mov b, [d]
0754   02D2 FD AB         swp b
0755   02D4 07 9E 12      call print_u16x         ; print register value
0756   02D7 07 EF 11      call printnl
0757   02DA 63 02 00      sub d, 2
0758   02DD 71 01         sub cl, 1
0759   02DF C3 00         cmp cl, 0
0760   02E1 C7 D1 02      jne syscall_regs_l0
0761   02E4 0A B0 02      jmp syscall_break_prompt
0762   02E7 07 EF 11      call printnl
0763   02EA 0A B0 02      jmp syscall_break_prompt
0764   02ED             syscall_break_mem:
0765   02ED 07 EF 11      call printnl
0766   02F0 07 C0 12      call scan_u16x
0767   02F3 4D            mov si, a               ; data source from user space
0768   02F4 FD 4F D9 22   mov di, scrap_sector    ; destination in kernel space
0769   02F8 38 00 02      mov c, 512
0770   02FB 04            load                    ; transfer data to kernel space!
0771   02FC 3B D9 22      mov d, scrap_sector     ; dump pointer in d
0772   02FF 38 00 00      mov c, 0
0773   0302             dump_loop:
0774   0302 84            mov al, cl
0775   0303 87 0F         and al, $0f
0776   0305 C6 53 03      jz print_base
0777   0308             back:
0778   0308 1E            mov al, [d]             ; read byte
0779   0309 2F            mov bl, al
0780   030A 07 E2 12      call print_u8x
0781   030D 10 00 20      mov a, $2000
0782   0310 05 03         syscall sys_io          ; space
0783   0312 84            mov al, cl
0784   0313 87 0F         and al, $0f
0785   0315 B9 0F         cmp al, $0f
0786   0317 C6 28 03      je print_ascii
0787   031A             back1:
0788   031A 79            inc d
0789   031B 78            inc c
0790   031C C2 00 02      cmp c, 512
0791   031F C7 02 03      jne dump_loop
0792   0322 07 EF 11      call printnl
0793   0325 0A B0 02      jmp syscall_break_prompt  ; go to syscall_break return point
0794   0328             print_ascii:
0795   0328 10 00 20      mov a, $2000
0796   032B 05 03         syscall sys_io
0797   032D 63 10 00      sub d, 16
0798   0330 26 10 00      mov b, 16
0799   0333             print_ascii_l:
0800   0333 79            inc d
0801   0334 1E            mov al, [d]               ; read byte
0802   0335 B9 20         cmp al, $20
0803   0337 C8 3F 03      jlu dot
0804   033A B9 7E         cmp al, $7e
0805   033C D0 47 03      jleu ascii
0806   033F             dot:
0807   033F 10 00 2E      mov a, $2e00
0808   0342 05 03         syscall sys_io
0809   0344 0A 4C 03      jmp ascii_continue
0810   0347             ascii:
0811   0347 23            mov ah, al
0812   0348 19 00         mov al, 0
0813   034A 05 03         syscall sys_io
0814   034C             ascii_continue:
0815   034C FD A9 33 03   loopb print_ascii_l
0816   0350 0A 1A 03      jmp back1
0817   0353             print_base:
0818   0353 07 EF 11      call printnl
0819   0356 2D            mov b, d
0820   0357 61 D9 22      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0821   035A 07 9E 12      call print_u16x          ; display row
0822   035D 10 00 3A      mov a, $3a00
0823   0360 05 03         syscall sys_io
0824   0362 10 00 20      mov a, $2000
0825   0365 05 03         syscall sys_io
0826   0367 0A 08 03      jmp back
0827   036A             
0828   036A             s_break1:  
0829   036A 0A 64 65 62   .db "\ndebugger entry point.\n"
0829   036E 75 67 67 65 
0829   0372 72 20 65 6E 
0829   0376 74 72 79 20 
0829   037A 70 6F 69 6E 
0829   037E 74 2E 0A 
0830   0381 30 2E 20 73   .db "0. show registers\n"
0830   0385 68 6F 77 20 
0830   0389 72 65 67 69 
0830   038D 73 74 65 72 
0830   0391 73 0A 
0831   0393 31 2E 20 73   .db "1. show 512b ram block\n"
0831   0397 68 6F 77 20 
0831   039B 35 31 32 62 
0831   039F 20 72 61 6D 
0831   03A3 20 62 6C 6F 
0831   03A7 63 6B 0A 
0832   03AA 32 2E 20 63   .db "2. continue execution", 0
0832   03AE 6F 6E 74 69 
0832   03B2 6E 75 65 20 
0832   03B6 65 78 65 63 
0832   03BA 75 74 69 6F 
0832   03BE 6E 00 
0833   03C0             
0834   03C0             ; ------------------------------------------------------------------------------------------------------------------;
0835   03C0             ; divide by zero exception
0836   03C0             ; ------------------------------------------------------------------------------------------------------------------;
0837   03C0             trap_div_zero:
0838   03C0 D7            push a
0839   03C1 DA            push d
0840   03C2 E1            pushf
0841   03C3 3B 10 18      mov d, s_divzero
0842   03C6 07 42 12      call _puts
0843   03C9 EE            popf
0844   03CA E7            pop d
0845   03CB E4            pop a
0846   03CC 06            sysret ; enable interrupts
0847   03CD             
0848   03CD             ; ------------------------------------------------------------------------------------------------------------------;
0849   03CD             ; undefined opcode exception
0850   03CD             ; ------------------------------------------------------------------------------------------------------------------;
0851   03CD             trap_undef_opcode:
0852   03CD 06            sysret
0853   03CE             
0854   03CE             ; ------------------------------------------------------------------------------------------------------------------;
0855   03CE             ; real-time clock services syscall
0856   03CE             ; rtc i/o bank = ffa0 to ffaf
0857   03CE             ; ffa0 to ffa7 is scratch ram
0858   03CE             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0859   03CE             ; al = 0..6 -> get
0860   03CE             ; al = 7..d -> set
0861   03CE             ; ------------------------------------------------------------------------------------------------------------------;
0862   03CE             syscall_rtc:
0863   03CE DB            push al
0864   03CF DA            push d
0865   03D0 B9 06         cmp al, 6
0866   03D2 D1 E7 03      jgu syscall_rtc_set
0867   03D5             syscall_rtc_get:
0868   03D5 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0869   03D7 22 FF         mov ah, $ff    
0870   03D9 3C            mov d, a                ; get to ffa9 + offset
0871   03DA F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0872   03DE 1E            mov al, [d]             ; get data
0873   03DF F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0874   03E3 23            mov ah, al
0875   03E4 E7            pop d
0876   03E5 E8            pop al
0877   03E6 06            sysret
0878   03E7             syscall_rtc_set:
0879   03E7 DD            push bl
0880   03E8 99            mov bl, ah              ; set data aside
0881   03E9 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0882   03EB 22 FF         mov ah, $ff    
0883   03ED 3C            mov d, a                ; get to ffa9 + offset
0884   03EE 1B            mov al, bl              ; get data back
0885   03EF F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0886   03F3 3E            mov [d], al             ; set data
0887   03F4 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0888   03F8 EA            pop bl
0889   03F9 E7            pop d
0890   03FA E8            pop al
0891   03FB 06            sysret
0892   03FC             
0893   03FC             datetime_serv_tbl:
0894   03FC 04 04         .dw print_date
0895   03FE 78 04         .dw set_date
0896   0400             syscall_datetime:
0897   0400 FD 0A FC 03   jmp [datetime_serv_tbl + al]      
0898   0404             print_date:
0899   0404 10 00 0D      mov a, $0d00           ; print carriage return char
0900   0407 19 03         mov al, 3
0901   0409 05 01         syscall sys_rtc        ; get week
0902   040B 1A            mov al, ah
0903   040C 22 00         mov ah, 0
0904   040E FD 9D 02      shl a, 2          
0905   0411 3B 9A 18      mov d, s_week
0906   0414 59            add d, a
0907   0415 07 42 12      call _puts
0908   0418 10 00 20      mov a, $2000
0909   041B 05 03         syscall sys_io         ; display ' '
0910   041D 19 04         mov al, 4
0911   041F 05 01         syscall sys_rtc        ; get day
0912   0421 99            mov bl, ah
0913   0422 07 E2 12      call print_u8x
0914   0425 10 00 20      mov a, $2000
0915   0428 05 03         syscall sys_io         ; display ' '
0916   042A             ; there is a problem with the month displaying
0917   042A             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0918   042A             ; even though it is to be understood as bcd.
0919   042A             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0920   042A 19 05         mov al, 05
0921   042C 05 01         syscall sys_rtc        ; get month
0922   042E 1A            mov al, ah
0923   042F 22 00         mov ah, 0
0924   0431 FD 9D 02      shl a, 2          
0925   0434 3B 66 18      mov d, s_months
0926   0437 59            add d, a
0927   0438 07 42 12      call _puts
0928   043B 10 00 20      mov a, $2000
0929   043E 05 03         syscall sys_io         ; display ' '
0930   0440 2E 20         mov bl, $20
0931   0442 07 E2 12      call print_u8x         ; print 20 for year prefix
0932   0445 19 06         mov al, 06
0933   0447 05 01         syscall sys_rtc        ; get year
0934   0449 99            mov bl, ah
0935   044A 07 E2 12      call print_u8x
0936   044D 10 00 20      mov a, $2000  
0937   0450 05 03         syscall sys_io         ; display ' '
0938   0452 19 02         mov al, 2
0939   0454 05 01         syscall sys_rtc        ; get hours
0940   0456 99            mov bl, ah
0941   0457 07 E2 12      call print_u8x
0942   045A 10 00 3A      mov a, $3a00    
0943   045D 05 03         syscall sys_io         ; display ':'
0944   045F 19 01         mov al, 01
0945   0461 05 01         syscall sys_rtc        ; get minutes
0946   0463 99            mov bl, ah
0947   0464 07 E2 12      call print_u8x
0948   0467 10 00 3A      mov a, $3a00  
0949   046A 05 03         syscall sys_io         ; display ':'
0950   046C 19 00         mov al, 0
0951   046E 05 01         syscall sys_rtc        ; get seconds
0952   0470 99            mov bl, ah
0953   0471 07 E2 12      call print_u8x
0954   0474 07 EF 11      call printnl
0955   0477 06            sysret
0956   0478             set_date:
0957   0478 3B 2B 18      mov d, s_set_year
0958   047B 07 42 12      call _puts
0959   047E 07 2D 13      call scan_u8x          ; read integer into a
0960   0481 FD 9D 08      shl a, 8               ; only al used, move to ah
0961   0484 19 0D         mov al, 0dh            ; set rtc year
0962   0486 05 01         syscall sys_rtc        ; set rtc
0963   0488 3B 32 18      mov d, s_set_month
0964   048B 07 42 12      call _puts
0965   048E 07 2D 13      call scan_u8x          ; read integer into a
0966   0491 FD 9D 08      shl a, 8               ; only al used, move to ah
0967   0494 19 0C         mov al, 0ch            ; set rtc month
0968   0496 05 01         syscall sys_rtc        ; set rtc
0969   0498 3B 3A 18      mov d, s_set_day
0970   049B 07 42 12      call _puts
0971   049E 07 2D 13      call scan_u8x          ; read integer into a
0972   04A1 FD 9D 08      shl a, 8               ; only al used, move to ah
0973   04A4 19 0B         mov al, 0bh            ; set rtc month
0974   04A6 05 01         syscall sys_rtc        ; set rtc
0975   04A8 3B 40 18      mov d, s_set_week
0976   04AB 07 42 12      call _puts
0977   04AE 07 2D 13      call scan_u8x          ; read integer into a
0978   04B1 FD 9D 08      shl a, 8               ; only al used, move to ah
0979   04B4 19 0A         mov al, 0ah            ; set rtc month
0980   04B6 05 01         syscall sys_rtc        ; set rtc
0981   04B8 3B 4A 18      mov d, s_set_hours
0982   04BB 07 42 12      call _puts
0983   04BE 07 2D 13      call scan_u8x          ; read integer into a
0984   04C1 FD 9D 08      shl a, 8               ; only al used, move to ah
0985   04C4 19 09         mov al, 09h            ; set rtc month
0986   04C6 05 01         syscall sys_rtc        ; set rtc
0987   04C8 3B 52 18      mov d, s_set_minutes
0988   04CB 07 42 12      call _puts
0989   04CE 07 2D 13      call scan_u8x          ; read integer into a
0990   04D1 FD 9D 08      shl a, 8               ; only al used, move to ah
0991   04D4 19 08         mov al, 08h            ; set rtc month
0992   04D6 05 01         syscall sys_rtc        ; set rtc
0993   04D8 3B 5C 18      mov d, s_set_seconds
0994   04DB 07 42 12      call _puts
0995   04DE 07 2D 13      call scan_u8x          ; read integer into a
0996   04E1 FD 9D 08      shl a, 8               ; only al used, move to ah
0997   04E4 19 07         mov al, 07h            ; set rtc month
0998   04E6 05 01         syscall sys_rtc        ; set rtc
0999   04E8 06            sysret
1000   04E9             
1001   04E9             ; ------------------------------------------------------------------------------------------------------------------;
1002   04E9             ; ide services syscall
1003   04E9             ; al = option
1004   04E9             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1005   04E9             ; ide read/write sector
1006   04E9             ; 512 bytes
1007   04E9             ; user buffer pointer in d
1008   04E9             ; ah = number of sectors
1009   04E9             ; cb = lba bytes 3..0
1010   04E9             ; ------------------------------------------------------------------------------------------------------------------;
1011   04E9             ide_serv_tbl:
1012   04E9 F5 04         .dw ide_reset
1013   04EB 09 05         .dw ide_sleep
1014   04ED 18 05         .dw ide_read_sect_wrapper
1015   04EF 1C 05         .dw ide_write_sect_wrapper
1016   04F1             syscall_ide:
1017   04F1 FD 0A E9 04   jmp [ide_serv_tbl + al]    
1018   04F5             
1019   04F5             ide_reset:      
1020   04F5 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1021   04F9 07 A2 05      call ide_wait                   ; wait for ide ready             
1022   04FC F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1023   0500 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1024   0504 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1025   0508 06            sysret
1026   0509             ide_sleep:
1027   0509 07 A2 05      call ide_wait                   ; wait for ide ready             
1028   050C F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1029   0510 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1030   0514 07 A2 05      call ide_wait                   ; wait for ide ready
1031   0517 06            sysret
1032   0518             ide_read_sect_wrapper:
1033   0518 07 20 05      call ide_read_sect
1034   051B 06            sysret
1035   051C             ide_write_sect_wrapper:
1036   051C 07 46 05      call ide_write_sect
1037   051F 06            sysret
1038   0520             ide_read_sect:
1039   0520 1A            mov al, ah
1040   0521 24            mov ah, bl
1041   0522 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1042   0525 1C            mov al, bh
1043   0526 3D D4 FF      mov [_ide_r4], al
1044   0529 12            mov a, c
1045   052A 3D D5 FF      mov [_ide_r5], al
1046   052D 1A            mov al, ah
1047   052E 87 0F         and al, %00001111
1048   0530 8B E0         or al, %11100000                ; mode lba, master
1049   0532 3D D6 FF      mov [_ide_r6], al
1050   0535             ide_read_sect_wait:
1051   0535 1D D7 FF      mov al, [_ide_r7]  
1052   0538 87 80         and al, $80                     ; busy flag
1053   053A C7 35 05      jnz ide_read_sect_wait
1054   053D 19 20         mov al, $20
1055   053F 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1056   0542 07 6C 05      call ide_read  
1057   0545 09            ret
1058   0546             ide_write_sect:
1059   0546 1A            mov al, ah
1060   0547 24            mov ah, bl
1061   0548 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1062   054B 1C            mov al, bh
1063   054C 3D D4 FF      mov [_ide_r4], al
1064   054F 12            mov a, c
1065   0550 3D D5 FF      mov [_ide_r5], al
1066   0553 1A            mov al, ah
1067   0554 87 0F         and al, %00001111
1068   0556 8B E0         or al, %11100000                ; mode lba, master
1069   0558 3D D6 FF      mov [_ide_r6], al
1070   055B             ide_write_sect_wait:
1071   055B 1D D7 FF      mov al, [_ide_r7]  
1072   055E 87 80         and al, $80                     ; busy flag
1073   0560 C7 5B 05      jnz ide_write_sect_wait
1074   0563 19 30         mov al, $30
1075   0565 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1076   0568 07 87 05      call ide_write      
1077   056B 09            ret
1078   056C             
1079   056C             ;----------------------------------------------------------------------------------------------------;
1080   056C             ; read ide data
1081   056C             ; pointer in d
1082   056C             ;----------------------------------------------------------------------------------------------------;
1083   056C             ide_read:
1084   056C DA            push d
1085   056D             ide_read_loop:
1086   056D 1D D7 FF      mov al, [_ide_r7]  
1087   0570 87 80         and al, 80h                     ; busy flag
1088   0572 C7 6D 05      jnz ide_read_loop               ; wait loop
1089   0575 1D D7 FF      mov al, [_ide_r7]
1090   0578 87 08         and al, %00001000               ; drq flag
1091   057A C6 85 05      jz ide_read_end
1092   057D 1D D0 FF      mov al, [_ide_r0]
1093   0580 3E            mov [d], al
1094   0581 79            inc d
1095   0582 0A 6D 05      jmp ide_read_loop
1096   0585             ide_read_end:
1097   0585 E7            pop d
1098   0586 09            ret
1099   0587             
1100   0587             ;----------------------------------------------------------------------------------------------------;
1101   0587             ; write ide data
1102   0587             ; data pointer in d
1103   0587             ;----------------------------------------------------------------------------------------------------;
1104   0587             ide_write:
1105   0587 DA            push d
1106   0588             ide_write_loop:
1107   0588 1D D7 FF      mov al, [_ide_r7]  
1108   058B 87 80         and al, 80h             ; busy flag
1109   058D C7 88 05      jnz ide_write_loop      ; wait loop
1110   0590 1D D7 FF      mov al, [_ide_r7]
1111   0593 87 08         and al, %00001000       ; drq flag
1112   0595 C6 A0 05      jz ide_write_end
1113   0598 1E            mov al, [d]
1114   0599 3D D0 FF      mov [_ide_r0], al
1115   059C 79            inc d 
1116   059D 0A 88 05      jmp ide_write_loop
1117   05A0             ide_write_end:
1118   05A0 E7            pop d
1119   05A1 09            ret
1120   05A2             
1121   05A2             ;----------------------------------------------------------------------------------------------------;
1122   05A2             ; wait for ide to be ready
1123   05A2             ;----------------------------------------------------------------------------------------------------;
1124   05A2             ide_wait:
1125   05A2 1D D7 FF      mov al, [_ide_r7]  
1126   05A5 87 80         and al, 80h        ; busy flag
1127   05A7 C7 A2 05      jnz ide_wait
1128   05AA 09            ret
1129   05AB             
1130   05AB             ;----------------------------------------------------------------------------------------------------;
1131   05AB             ; io syscall
1132   05AB             ;----------------------------------------------------------------------------------------------------;
1133   05AB             ; baud  divisor
1134   05AB             ; 50    2304
1135   05AB             ; 110   1047
1136   05AB             ; 300    384
1137   05AB             ; 600    192
1138   05AB             ; 1200    96
1139   05AB             ; 9600    12
1140   05AB             ; 19200    6
1141   05AB             ; 38400    3
1142   05AB             syscall_io_jmp:
1143   05AB DE 05         .dw syscall_io_putchar
1144   05AD EB 05         .dw syscall_io_getch
1145   05AF B5 05         .dw syscall_io_uart_setup
1146   05B1             syscall_io:
1147   05B1 FD 0A AB 05   jmp [syscall_io_jmp + al]
1148   05B5             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1149   05B5             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1150   05B5             ; buffer, the transmitter holding register, or the interrupt enable register.
1151   05B5             syscall_io_uart_setup:
1152   05B5 1D 6D 17      mov al, [sys_uart0_lcr]
1153   05B8 8B 80         or al, $80                ; set dlab access bit
1154   05BA 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1155   05BD 1D 70 17      mov al, [sys_uart0_div0]
1156   05C0 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1157   05C3 1D 71 17      mov al, [sys_uart0_div1]
1158   05C6 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1159   05C9             
1160   05C9 1D 6D 17      mov al, [sys_uart0_lcr]
1161   05CC 87 7F         and al, $7f               ; clear dlab access bit 
1162   05CE 3D 83 FF      mov [_uart0_lcr], al
1163   05D1 1D 6E 17      mov al, [sys_uart0_inten]
1164   05D4 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1165   05D7 1D 6F 17      mov al, [sys_uart0_fifoen]
1166   05DA 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1167   05DD 06            sysret
1168   05DE             
1169   05DE             ; char in ah
1170   05DE             syscall_io_putchar:
1171   05DE             syscall_io_putchar_l0:
1172   05DE 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1173   05E1 87 20         and al, $20
1174   05E3 C6 DE 05      jz syscall_io_putchar_l0    
1175   05E6 1A            mov al, ah
1176   05E7 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1177   05EA 06            sysret
1178   05EB             
1179   05EB             ; char in ah
1180   05EB             ; al = sucess code
1181   05EB             syscall_io_getch:
1182   05EB D8            push b
1183   05EC DA            push d
1184   05ED FD 0C         sti
1185   05EF             syscall_io_getch_l0:  
1186   05EF 14 7A 17      mov a, [fifo_out]
1187   05F2 29 78 17      mov b, [fifo_in]
1188   05F5 B0            cmp a, b
1189   05F6 C6 EF 05      je syscall_io_getch_l0
1190   05F9 3C            mov d, a
1191   05FA 77            inc a
1192   05FB AF D9 22      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1193   05FE C7 04 06      jne syscall_io_getch_cont
1194   0601 10 D9 1E      mov a, fifo  
1195   0604             syscall_io_getch_cont:  
1196   0604 42 7A 17      mov [fifo_out], a             ; update fifo pointer
1197   0607 1E            mov al, [d]                   ; get char
1198   0608 23            mov ah, al
1199   0609 1D 6C 17      mov al, [sys_echo_on]
1200   060C B9 01         cmp al, 1
1201   060E C7 1D 06      jne syscall_io_getch_noecho 
1202   0611             ; here we just echo the char back to the console
1203   0611             syscall_io_getch_echo_l0:
1204   0611 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1205   0614 87 20         and al, $20                 ; isolate transmitter empty
1206   0616 C6 11 06      jz syscall_io_getch_echo_l0
1207   0619 1A            mov al, ah
1208   061A 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1209   061D             syscall_io_getch_noecho:
1210   061D 19 01         mov al, 1                    ; al = 1 means a char successfully received
1211   061F E7            pop d
1212   0620 E5            pop b
1213   0621 06            sysret
1214   0622             
1215   0622             ;------------------------------------------------------------------------------------------------------;
1216   0622             ; file system data
1217   0622             ;------------------------------------------------------------------------------------------------------;
1218   0622             ; infor for : ide services interrupt
1219   0622             ; ide read/write 512-byte sector
1220   0622             ; al = option
1221   0622             ; user buffer pointer in d
1222   0622             ; ah = number of sectors
1223   0622             ; cb = lba bytes 3..0  
1224   0622             ;------------------------------------------------------------------------------------------------------;
1225   0622             ; file system data structure
1226   0622             ;------------------------------------------------------------------------------------------------------;
1227   0622             ; for a directory we have the header first, followed by metadata
1228   0622             ; header 1 sector (512 bytes)
1229   0622             ; metadata 1 sector (512 bytes)
1230   0622             ; header entries:
1231   0622             ; filename (64)
1232   0622             ; parent dir lba (2) -  to be used for faster backwards navigation...
1233   0622             ;
1234   0622             ; metadata entries:
1235   0622             ; filename (24)
1236   0622             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1237   0622             ; lba (2)
1238   0622             ; size (2)
1239   0622             ; day (1)
1240   0622             ; month (1)
1241   0622             ; year (1)
1242   0622             ; packet size = 32 bytes
1243   0622             ;
1244   0622             ; first directory on disk is the root directory '/'
1245   0622             file_system_jmptbl:
1246   0622 8D 06         .dw fs_mkfs                   ; 0
1247   0624 00 00         .dw 0                         ; 1
1248   0626 EF 06         .dw fs_mkdir                  ; 2
1249   0628 68 0A         .dw fs_cd                     ; 3
1250   062A 6F 0A         .dw fs_ls                     ; 4
1251   062C 5A 0B         .dw fs_mktxt                  ; 5
1252   062E 25 0C         .dw fs_mkbin                  ; 6
1253   0630 EC 0C         .dw fs_pwd                    ; 7
1254   0632 09 0D         .dw fs_cat                    ; 8
1255   0634 65 0D         .dw fs_rmdir                  ; 9
1256   0636 C1 0D         .dw fs_rm                     ; 10
1257   0638 00 00         .dw 0                         ; 11
1258   063A 00 00         .dw 0                         ; 12
1259   063C 00 00         .dw 0                         ; 13
1260   063E 95 06         .dw fs_chmod                  ; 14
1261   0640 29 0E         .dw fs_mv                     ; 15
1262   0642 8E 06         .dw fs_cd_root                ; 16
1263   0644 64 0A         .dw fs_get_curr_dirid         ; 17
1264   0646 40 08         .dw fs_dir_id_to_path         ; 18
1265   0648 A6 08         .dw fs_path_to_dir_id_user    ; 19
1266   064A C0 09         .dw fs_load_from_path_user    ; 20  
1267   064C 30 09         .dw fs_filepath_exists_user   ; 21
1268   064E             
1269   064E 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1269   0652 79 73 63 61 
1269   0656 6C 6C 5F 66 
1269   065A 69 6C 65 5F 
1269   065E 73 79 73 74 
1269   0662 65 6D 20 63 
1269   0666 61 6C 6C 65 
1269   066A 64 3A 20 00 
1270   066E             syscall_file_system:
1271   066E DD            push bl
1272   066F 31 6B 17      mov bl, [sys_debug_mode]
1273   0672               ; debug block
1274   0672 C1 00         cmp bl, 0
1275   0674 EA            pop bl
1276   0675 C6 89 06      je syscall_filesystem_jmp
1277   0678 DA            push d
1278   0679 DD            push bl
1279   067A 3B 4E 06      mov d, s_syscall_fs_dbg0
1280   067D 07 42 12      call _puts
1281   0680 2F            mov bl, al
1282   0681 07 E2 12      call print_u8x
1283   0684 07 EF 11      call printnl
1284   0687 EA            pop bl
1285   0688 E7            pop d
1286   0689             syscall_filesystem_jmp:
1287   0689 FD 0A 22 06   jmp [file_system_jmptbl + al]
1288   068D             
1289   068D             fs_mkfs:  
1290   068D 06            sysret  
1291   068E               
1292   068E             fs_cd_root:
1293   068E 10 20 00      mov a, root_id
1294   0691 42 7C 17      mov [current_dir_id], a      ; set current directory lba to root
1295   0694 06            sysret  
1296   0695             
1297   0695             ; filename in d (userspace data)
1298   0695             ; permission in bl
1299   0695             fs_chmod:
1300   0695 DD            push bl
1301   0696 FD 4E         mov si, d
1302   0698 FD 4F D9 1C   mov di, user_data
1303   069C 38 80 00      mov c, 128
1304   069F 04            load                        ; load filename from user-space
1305   06A0 14 7C 17      mov a, [current_dir_id]
1306   06A3 77            inc a                       ; metadata sector
1307   06A4 27            mov b, a
1308   06A5 38 00 00      mov c, 0                    ; upper lba = 0
1309   06A8 22 01         mov ah, $01                  ; 1 sector
1310   06AA 3B D9 24      mov d, transient_area
1311   06AD 07 20 05      call ide_read_sect          ; read directory
1312   06B0 FD 10         cla
1313   06B2 42 74 17      mov [index], a              ; reset file counter
1314   06B5             fs_chmod_l1:
1315   06B5 FD 4E         mov si, d
1316   06B7 FD 4F D9 1C   mov di, user_data
1317   06BB 07 85 10      call _strcmp
1318   06BE C6 D5 06      je fs_chmod_found_entry
1319   06C1 58 20 00      add d, 32
1320   06C4 14 74 17      mov a, [index]
1321   06C7 77            inc a
1322   06C8 42 74 17      mov [index], a
1323   06CB AF 10 00      cmp a, fst_files_per_dir
1324   06CE C7 B5 06      jne fs_chmod_l1
1325   06D1 EA            pop bl
1326   06D2 0A EE 06      jmp fs_chmod_not_found
1327   06D5             fs_chmod_found_entry:  
1328   06D5 FD 79         mov g, b                    ; save lba
1329   06D7 EA            pop bl                      ; retrieve saved permission value
1330   06D8 1F 18 00      mov al, [d + 24]            ; read file permissions
1331   06DB 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1332   06DD 8C            or al, bl                   ; set new permissions
1333   06DE 3F 18 00      mov [d + 24], al            ; write new permissions
1334   06E1 38 00 00      mov c, 0
1335   06E4 3B D9 24      mov d, transient_area
1336   06E7 22 01         mov ah, $01                 ; disk write 1 sect
1337   06E9 FD 27         mov b, g                    ; retrieve lba
1338   06EB 07 46 05      call ide_write_sect         ; write sector
1339   06EE             fs_chmod_not_found:
1340   06EE 06            sysret
1341   06EF             
1342   06EF             ;------------------------------------------------------------------------------------------------------;
1343   06EF             ; create new directory
1344   06EF             ;------------------------------------------------------------------------------------------------------;
1345   06EF             ; search list for null name entry. add new directory to list
1346   06EF             fs_mkdir:
1347   06EF FD 4E         mov si, d
1348   06F1 FD 4F D9 1C   mov di, user_data
1349   06F5 38 00 02      mov c, 512
1350   06F8 04            load                        ; load data from user-space
1351   06F9 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1352   06FC                                           ; when checking for null name, since root has a null name)
1353   06FC 38 00 00      mov c, 0                    ; upper lba = 0
1354   06FF             fs_mkdir_l1:  
1355   06FF 22 01         mov ah, $01                  ; 1 sector
1356   0701 3B D9 24      mov d, transient_area
1357   0704 07 20 05      call ide_read_sect          ; read sector
1358   0707 BD 00         cmp byte[d], 0              ; check for null
1359   0709 C6 12 07      je fs_mkdir_found_null
1360   070C 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1361   070F 0A FF 06      jmp fs_mkdir_l1
1362   0712             fs_mkdir_found_null:
1363   0712             ;create header file by grabbing dir name from parameter
1364   0712 D8            push b                      ; save new directory's lba
1365   0713 38 40 00      mov c, 64
1366   0716 FD 4D D9 1C   mov si, user_data
1367   071A FD 4F D9 24   mov di, transient_area
1368   071E FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1369   0720 14 7C 17      mov a, [current_dir_id]
1370   0723 42 19 25      mov [transient_area + 64], a    ; store parent directory lba
1371   0726 19 00         mov al, 0
1372   0728 FD 4F D9 26   mov di, transient_area + 512
1373   072C 38 00 02      mov c, 512
1374   072F FD F7         rep stosb                       ; clean buffer
1375   0731 38 00 00      mov c, 0                        ; reset lba(c) to 0
1376   0734             ; write directory entry sectors
1377   0734 3B D9 24      mov d, transient_area
1378   0737 22 02         mov ah, $02                     ; disk write, 2 sectors
1379   0739 07 46 05      call ide_write_sect             ; write sector
1380   073C             ; now we need to add the new directory to the list, inside the current directory
1381   073C 14 7C 17      mov a, [current_dir_id]
1382   073F 53 01 00      add a, 1
1383   0742 27            mov b, a                        ; metadata sector
1384   0743 38 00 00      mov c, 0
1385   0746 FD 79         mov g, b                        ; save lba
1386   0748 3B D9 24      mov d, transient_area
1387   074B 22 01         mov ah, $01                  ; 1 sector
1388   074D 07 20 05      call ide_read_sect              ; read metadata sector
1389   0750             fs_mkdir_l2:
1390   0750 BD 00         cmp byte[d], 0
1391   0752 C6 5B 07      je fs_mkdir_found_null2
1392   0755 58 20 00      add d, fst_entry_size
1393   0758 0A 50 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1394   075B             fs_mkdir_found_null2:
1395   075B FD 4D D9 1C   mov si, user_data
1396   075F FD 50         mov di, d
1397   0761 07 9A 10      call _strcpy                    ; copy directory name
1398   0764 58 18 00      add d, 24                       ; goto attributes
1399   0767 19 0B         mov al, %00001011               ; directory, no execute, write, read
1400   0769 3E            mov [d], al      
1401   076A 79            inc d
1402   076B E5            pop b
1403   076C D8            push b                          ; push lba back
1404   076D FD 43         mov [d], b                      ; save lba
1405   076F             ; set file creation date  
1406   076F 58 04 00      add d, 4
1407   0772 19 04         mov al, 4
1408   0774 05 01         syscall sys_rtc
1409   0776 1A            mov al, ah
1410   0777 3E            mov [d], al                     ; set day
1411   0778 79            inc d
1412   0779 19 05         mov al, 5
1413   077B 05 01         syscall sys_rtc
1414   077D 1A            mov al, ah
1415   077E 3E            mov [d], al                     ; set month
1416   077F 79            inc d
1417   0780 19 06         mov al, 6
1418   0782 05 01         syscall sys_rtc
1419   0784 1A            mov al, ah
1420   0785 3E            mov [d], al                     ; set year
1421   0786             ; write sector into disk for new directory entry
1422   0786 FD 27         mov b, g
1423   0788 38 00 00      mov c, 0
1424   078B 3B D9 24      mov d, transient_area
1425   078E 22 01         mov ah, $01                     ; disk write, 1 sector
1426   0790 07 46 05      call ide_write_sect             ; write sector
1427   0793             
1428   0793             ; after adding the new directory's information to its parent directory's list
1429   0793             ; we need to now enter the new directory, and to it add two new directories!
1430   0793             ; which directories do we need to add ? '..' and '.' are the directories needed.
1431   0793             ; importantly, note that these two new directories are only entries in the list
1432   0793             ; and do not have actual physical entries in the disk as real directories.
1433   0793             ; i.e. they only exist as list entries in the new directory created so that
1434   0793             ; the new directory can reference its parent and itself.
1435   0793             ; we need to add both '..' and '.'
1436   0793             ; this first section is for '..' and on the section below we do the same for '.'
1437   0793 E4            pop a                         ; retrieve the new directory's lba  
1438   0794 D7            push a                        ; and save again
1439   0795 53 01 00      add a, 1
1440   0798 27            mov b, a                      ; metadata sector
1441   0799 38 00 00      mov c, 0
1442   079C FD 79         mov g, b                      ; save lba
1443   079E 3B D9 24      mov d, transient_area
1444   07A1 22 01         mov ah, $01                  ; 1 sector
1445   07A3 07 20 05      call ide_read_sect            ; read metadata sector
1446   07A6             fs_mkdir_l3:
1447   07A6 BD 00         cmp byte[d], 0
1448   07A8 C6 B1 07      je fs_mkdir_found_null3
1449   07AB 58 20 00      add d, fst_entry_size
1450   07AE 0A A6 07      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1451   07B1             fs_mkdir_found_null3:
1452   07B1 FD 4D 9B 17   mov si, s_parent_dir
1453   07B5 FD 50         mov di, d
1454   07B7 07 9A 10      call _strcpy                  ; copy directory name
1455   07BA 58 18 00      add d, 24                     ; goto attributes
1456   07BD 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1457   07BF 3E            mov [d], al      
1458   07C0 79            inc d
1459   07C1 29 7C 17      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1460   07C4 FD 43         mov [d], b                    ; save lba
1461   07C6             ; set file creation date  
1462   07C6 58 04 00      add d, 4
1463   07C9 19 04         mov al, 4
1464   07CB 05 01         syscall sys_rtc
1465   07CD 1A            mov al, ah
1466   07CE 3E            mov [d], al                   ; set day
1467   07CF 79            inc d
1468   07D0 19 05         mov al, 5
1469   07D2 05 01         syscall sys_rtc
1470   07D4 1A            mov al, ah
1471   07D5 3E            mov [d], al                   ; set month
1472   07D6 79            inc d
1473   07D7 19 06         mov al, 6
1474   07D9 05 01         syscall sys_rtc
1475   07DB 1A            mov al, ah
1476   07DC 3E            mov [d], al                   ; set year
1477   07DD             ; write sector into disk for new directory entry
1478   07DD FD 27         mov b, g
1479   07DF 38 00 00      mov c, 0
1480   07E2 3B D9 24      mov d, transient_area
1481   07E5 22 01         mov ah, $01                   ; disk write, 1 sector
1482   07E7 07 46 05      call ide_write_sect           ; write sector
1483   07EA             ;;;;;;;;;;;;;
1484   07EA             ; like we did above for '..', we need to now add the '.' directory to the list.
1485   07EA             ;------------------------------------------------------------------------------------------------------;
1486   07EA E4            pop a                         ; retrieve the new directory's lba  
1487   07EB D7            push a
1488   07EC 53 01 00      add a, 1
1489   07EF 27            mov b, a                      ; metadata sector
1490   07F0 38 00 00      mov c, 0
1491   07F3 FD 79         mov g, b                      ; save lba
1492   07F5 3B D9 24      mov d, transient_area
1493   07F8 22 01         mov ah, $01                  ; 1 sector
1494   07FA 07 20 05      call ide_read_sect            ; read metadata sector
1495   07FD             fs_mkdir_l4:
1496   07FD BD 00         cmp byte[d], 0
1497   07FF C6 08 08      je fs_mkdir_found_null4
1498   0802 58 20 00      add d, fst_entry_size
1499   0805 0A FD 07      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1500   0808             fs_mkdir_found_null4:
1501   0808 FD 4D 9E 17   mov si, s_current_dir
1502   080C FD 50         mov di, d
1503   080E 07 9A 10      call _strcpy                  ; copy directory name
1504   0811 58 18 00      add d, 24                     ; goto attributes
1505   0814 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1506   0816 3E            mov [d], al      
1507   0817 79            inc d
1508   0818 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1509   0819 FD 43         mov [d], b                    ; save lba
1510   081B             ; set file creation date  
1511   081B 58 04 00      add d, 4
1512   081E 19 04         mov al, 4
1513   0820 05 01         syscall sys_rtc
1514   0822 1A            mov al, ah
1515   0823 3E            mov [d], al                   ; set day
1516   0824 79            inc d
1517   0825 19 05         mov al, 5
1518   0827 05 01         syscall sys_rtc
1519   0829 1A            mov al, ah
1520   082A 3E            mov [d], al                   ; set month
1521   082B 79            inc d
1522   082C 19 06         mov al, 6
1523   082E 05 01         syscall sys_rtc
1524   0830 1A            mov al, ah
1525   0831 3E            mov [d], al                   ; set year
1526   0832             ; write sector into disk for new directory entry
1527   0832 FD 27         mov b, g
1528   0834 38 00 00      mov c, 0
1529   0837 3B D9 24      mov d, transient_area
1530   083A 22 01         mov ah, $01                   ; disk write, 1 sector
1531   083C 07 46 05      call ide_write_sect           ; write sector
1532   083F             fs_mkdir_end:
1533   083F 06            sysret
1534   0840             
1535   0840             ;------------------------------------------------------------------------------------------------------;
1536   0840             ; get path from a given directory dirid
1537   0840             ; pseudo code:
1538   0840             ;  fs_dir_id_to_path(int dirid, char *d){
1539   0840             ;    if(dirid == 0){
1540   0840             ;      reverse path in d;
1541   0840             ;      return;
1542   0840             ;    }
1543   0840             ;    else{
1544   0840             ;      copy directory name to end of d;
1545   0840             ;      add '/' to end of d;
1546   0840             ;      parentid = get parent directory id;
1547   0840             ;      fs_dir_id_to_path(parentid, d);
1548   0840             ;    }
1549   0840             ;  }
1550   0840             ; a = dirid
1551   0840             ; d = generated path string pointer
1552   0840             ;------------------------------------------------------------------------------------------------------;
1553   0840             ; sample path: /usr/bin
1554   0840             fs_dir_id_to_path:
1555   0840 3B 59 1C      mov d, filename
1556   0843 19 00         mov al, 0
1557   0845 3E            mov [d], al                     ; initialize path string 
1558   0846 14 7C 17      mov a, [current_dir_id]
1559   0849 07 56 08      call fs_dir_id_to_path_e0
1560   084C 3B 59 1C      mov d, filename
1561   084F 07 2E 10      call _strrev
1562   0852 07 42 12      call _puts
1563   0855 06            sysret
1564   0856             fs_dir_id_to_path_e0:
1565   0856 07 75 08      call get_dirname_from_dirid
1566   0859 FD 4D A0 17   mov si, s_fslash
1567   085D FD 50         mov di, d
1568   085F 07 A8 10      call _strcat                    ; add '/' to end of path
1569   0862 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1570   0865 C6 74 08      je fs_dir_id_to_path_root
1571   0868 07 92 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1572   086B AF 20 00      cmp a, root_id               ; check if we are at the root directory
1573   086E C6 74 08      je fs_dir_id_to_path_root
1574   0871 07 56 08      call fs_dir_id_to_path_e0     ; recursively call itself
1575   0874             fs_dir_id_to_path_root:
1576   0874 09            ret
1577   0875             
1578   0875             ;------------------------------------------------------------------------------------------------------;
1579   0875             ; in_puts:
1580   0875             ; a = directory id
1581   0875             ; out_puts:
1582   0875             ; d = pointer to directory name string
1583   0875             ;------------------------------------------------------------------------------------------------------;
1584   0875             get_dirname_from_dirid:
1585   0875 D7            push a
1586   0876 D8            push b
1587   0877 DA            push d
1588   0878 27            mov b, a
1589   0879 38 00 00      mov c, 0                      ; upper lba = 0
1590   087C 22 01         mov ah, $01                  ; 1 sector
1591   087E 3B D9 22      mov d, transient_area - 512
1592   0881 07 20 05      call ide_read_sect            ; read directory
1593   0884 07 2E 10      call _strrev                  ; reverse dir name before copying
1594   0887 FD 4E         mov si, d
1595   0889 E7            pop d                         ; destination address = d value pushed at beginning
1596   088A FD 50         mov di, d
1597   088C 07 A8 10      call _strcat                  ; copy filename to d
1598   088F E5            pop b
1599   0890 E4            pop a
1600   0891 09            ret
1601   0892             
1602   0892             ;------------------------------------------------------------------------------------------------------;
1603   0892             ; in_puts:
1604   0892             ; a = directory id
1605   0892             ; out_puts:
1606   0892             ; a = parent directory id
1607   0892             ;------------------------------------------------------------------------------------------------------;
1608   0892             get_parentid_from_dirid:
1609   0892 D8            push b
1610   0893 DA            push d
1611   0894 27            mov b, a
1612   0895 38 00 00      mov c, 0                      ; upper lba = 0
1613   0898 22 01         mov ah, $01                  ; 1 sector
1614   089A 3B D9 22      mov d, transient_area - 512
1615   089D 07 20 05      call ide_read_sect            ; read directory
1616   08A0 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1617   08A3 E7            pop d
1618   08A4 E5            pop b
1619   08A5 09            ret
1620   08A6             
1621   08A6             ;------------------------------------------------------------------------------------------------------;
1622   08A6             ; get dirid from a given path string
1623   08A6             ; in_puts:
1624   08A6             ; d = path pointer 
1625   08A6             ; out_puts:
1626   08A6             ; a = dirid
1627   08A6             ; if dir non existent, a = ffff (fail code)
1628   08A6             ; /usr/local/bin    - absolute
1629   08A6             ; local/bin/games    - relative
1630   08A6             ;------------------------------------------------------------------------------------------------------;
1631   08A6             fs_path_to_dir_id_user:
1632   08A6 FD 4E         mov si, d
1633   08A8 FD 4F D9 1C   mov di, user_data
1634   08AC 38 00 02      mov c, 512
1635   08AF 04            load
1636   08B0 07 B4 08      call get_dirid_from_path
1637   08B3 06            sysret
1638   08B4             get_dirid_from_path:
1639   08B4 26 D9 1C      mov b, user_data
1640   08B7 FD 42 67 16   mov [prog], b                  ; token pointer set to path string
1641   08BB 07 C8 14      call get_token
1642   08BE 31 6A 16      mov bl, [tok]
1643   08C1 C1 01         cmp bl, tok_fslash
1644   08C3 C6 CF 08      je get_dirid_from_path_abs 
1645   08C6 14 7C 17      mov a, [current_dir_id]
1646   08C9 07 4E 16      call _putback
1647   08CC 0A D2 08      jmp get_dirid_from_path_e0
1648   08CF             get_dirid_from_path_abs:
1649   08CF 10 20 00      mov a, root_id
1650   08D2             get_dirid_from_path_e0:
1651   08D2 07 C8 14      call get_token
1652   08D5 31 69 16      mov bl, [toktyp]
1653   08D8 C1 00         cmp bl, toktyp_identifier
1654   08DA C7 2B 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1655   08DD             
1656   08DD FD 4D 6B 16   mov si, tokstr
1657   08E1 FD 4F 59 1C   mov di, filename
1658   08E5 07 9A 10      call _strcpy        
1659   08E8 77            inc a                         ; metadata sector
1660   08E9 27            mov b, a
1661   08EA 38 00 00      mov c, 0                      ; upper lba = 0
1662   08ED 22 01         mov ah, $01                  ; 1 sector
1663   08EF 3B D9 24      mov d, transient_area
1664   08F2 07 20 05      call ide_read_sect            ; read directory
1665   08F5 FD 10         cla
1666   08F7 42 74 17      mov [index], a
1667   08FA             get_dirid_from_path_l1:
1668   08FA FD 4E         mov si, d
1669   08FC FD 4F 59 1C   mov di, filename
1670   0900 07 85 10      call _strcmp
1671   0903 C6 19 09      je get_dirid_from_path_name_equal  
1672   0906 58 20 00      add d, 32
1673   0909 14 74 17      mov a, [index]
1674   090C 77            inc a
1675   090D 42 74 17      mov [index], a
1676   0910 AF 10 00      cmp a, fst_files_per_dir
1677   0913 C6 2C 09      je get_dirid_from_path_fail
1678   0916 0A FA 08      jmp get_dirid_from_path_l1
1679   0919             get_dirid_from_path_name_equal:
1680   0919 58 19 00      add d, 25           
1681   091C 15            mov a, [d]                    ; set result register a = dirid
1682   091D 07 C8 14      call get_token
1683   0920 31 6A 16      mov bl, [tok]
1684   0923 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1685   0925 C6 D2 08      je get_dirid_from_path_e0
1686   0928 07 4E 16      call _putback
1687   092B             get_dirid_from_path_end:
1688   092B 09            ret
1689   092C             get_dirid_from_path_fail:
1690   092C 10 FF FF      mov a, $ffff
1691   092F 09            ret
1692   0930             
1693   0930             
1694   0930             ;------------------------------------------------------------------------------------------------------;
1695   0930             ; check if file exists by a given path string
1696   0930             ; in_puts:
1697   0930             ; d = path pointer 
1698   0930             ; outputs:
1699   0930             ; a = success code, if file exists gives lba, else, give 0
1700   0930             ; /usr/local/bin/ed
1701   0930             ;------------------------------------------------------------------------------------------------------;
1702   0930             fs_filepath_exists_user:
1703   0930 FD 4E         mov si, d
1704   0932 FD 4F D9 1C   mov di, user_data
1705   0936 38 00 02      mov c, 512
1706   0939 04            load
1707   093A 07 3E 09      call file_exists_by_path
1708   093D 06            sysret
1709   093E             file_exists_by_path:
1710   093E 26 D9 1C      mov b, user_data
1711   0941 FD 42 67 16   mov [prog], b                   ; token pointer set to path string
1712   0945 07 C8 14      call get_token
1713   0948 31 6A 16      mov bl, [tok]
1714   094B C1 01         cmp bl, tok_fslash
1715   094D C6 59 09      je  file_exists_by_path_abs
1716   0950 14 7C 17      mov a, [current_dir_id]
1717   0953 07 4E 16      call _putback
1718   0956 0A 5C 09      jmp file_exists_by_path_e0
1719   0959             file_exists_by_path_abs:
1720   0959 10 20 00      mov a, root_id
1721   095C             file_exists_by_path_e0:
1722   095C 07 C8 14      call get_token
1723   095F 31 69 16      mov bl, [toktyp]
1724   0962 C1 00         cmp bl, toktyp_identifier
1725   0964 C7 BC 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1726   0967 FD 4D 6B 16   mov si, tokstr
1727   096B FD 4F 59 1C   mov di, filename
1728   096F 07 9A 10      call _strcpy        
1729   0972 77            inc a                           ; metadata sector
1730   0973 27            mov b, a
1731   0974 38 00 00      mov c, 0                        ; upper lba = 0
1732   0977 22 01         mov ah, $01                  ; 1 sector
1733   0979 3B D9 24      mov d, transient_area
1734   097C 07 20 05      call ide_read_sect              ; read directory
1735   097F FD 10         cla
1736   0981 42 74 17      mov [index], a
1737   0984             file_exists_by_path_l1:
1738   0984 FD 4E         mov si, d
1739   0986 FD 4F 59 1C   mov di, filename
1740   098A 07 85 10      call _strcmp
1741   098D C6 A3 09      je   file_exists_by_path_name_equal
1742   0990 58 20 00      add d, 32
1743   0993 14 74 17      mov a, [index]
1744   0996 77            inc a
1745   0997 42 74 17      mov [index], a
1746   099A AF 10 00      cmp a, fst_files_per_dir
1747   099D C6 BC 09      je file_exists_by_path_end
1748   09A0 0A 84 09      jmp file_exists_by_path_l1
1749   09A3             file_exists_by_path_name_equal:
1750   09A3 33 18 00      mov bl, [d + 24]
1751   09A6 FD 87 38      and bl, %00111000               ; directory flag
1752   09A9 C1 08         cmp bl, %00001000               ; is dir?
1753   09AB C6 B2 09      je file_exists_by_path_isdir;
1754   09AE             ; entry is a file
1755   09AE 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1756   09B1 09            ret
1757   09B2             file_exists_by_path_isdir:
1758   09B2 58 19 00      add d, 25           
1759   09B5 15            mov a, [d]                      ; set result register a = dirid
1760   09B6 07 C8 14      call get_token
1761   09B9 0A 5C 09      jmp file_exists_by_path_e0
1762   09BC             file_exists_by_path_end:
1763   09BC 10 00 00      mov a, 0                        ; return 0 because file was not found
1764   09BF 09            ret
1765   09C0             
1766   09C0             ;------------------------------------------------------------------------------------------------------;
1767   09C0             ; load file data from a given path string
1768   09C0             ; inputs:
1769   09C0             ; d = path pointer 
1770   09C0             ; di = userspace program data destination
1771   09C0             ; /usr/local/bin/ed
1772   09C0             ; ./ed
1773   09C0             ;------------------------------------------------------------------------------------------------------;
1774   09C0             fs_load_from_path_user:
1775   09C0 E3            push di
1776   09C1 FD 4E         mov si, d
1777   09C3 FD 4F D9 1C   mov di, user_data
1778   09C7 38 00 02      mov c, 512
1779   09CA 04            load
1780   09CB 07 D8 09      call loadfile_from_path
1781   09CE F0            pop di
1782   09CF FD 4D D9 24   mov si, transient_area
1783   09D3 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1784   09D6 03            store
1785   09D7 06            sysret
1786   09D8             loadfile_from_path:
1787   09D8 26 D9 1C      mov b, user_data
1788   09DB FD 42 67 16   mov [prog], b                 ; token pointer set to path string
1789   09DF 07 C8 14      call get_token
1790   09E2 31 6A 16      mov bl, [tok]
1791   09E5 C1 01         cmp bl, tok_fslash
1792   09E7 C6 F3 09      je loadfile_from_path_abs 
1793   09EA 14 7C 17      mov a, [current_dir_id]
1794   09ED 07 4E 16      call _putback
1795   09F0 0A F6 09      jmp loadfile_from_path_e0
1796   09F3             loadfile_from_path_abs:
1797   09F3 10 20 00      mov a, root_id
1798   09F6             loadfile_from_path_e0:
1799   09F6 07 C8 14      call get_token
1800   09F9 31 69 16      mov bl, [toktyp]
1801   09FC C1 00         cmp bl, toktyp_identifier
1802   09FE C7 63 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1803   0A01 FD 4D 6B 16   mov si, tokstr
1804   0A05 FD 4F 59 1C   mov di, filename
1805   0A09 07 9A 10      call _strcpy        
1806   0A0C 77            inc a                         ; metadata sector
1807   0A0D 27            mov b, a
1808   0A0E 38 00 00      mov c, 0                      ; upper lba = 0
1809   0A11 22 01         mov ah, $01                  ; 1 sector
1810   0A13 3B D9 24      mov d, transient_area
1811   0A16 07 20 05      call ide_read_sect            ; read directory
1812   0A19 FD 10         cla
1813   0A1B 42 74 17      mov [index], a
1814   0A1E             loadfile_from_path_l1:
1815   0A1E FD 4E         mov si, d
1816   0A20 FD 4F 59 1C   mov di, filename
1817   0A24 07 85 10      call _strcmp
1818   0A27 C6 3D 0A      je loadfile_from_path_name_equal  
1819   0A2A 58 20 00      add d, 32
1820   0A2D 14 74 17      mov a, [index]
1821   0A30 77            inc a
1822   0A31 42 74 17      mov [index], a
1823   0A34 AF 10 00      cmp a, fst_files_per_dir
1824   0A37 C6 63 0A      je loadfile_from_path_end
1825   0A3A 0A 1E 0A      jmp loadfile_from_path_l1
1826   0A3D             loadfile_from_path_name_equal:
1827   0A3D 33 18 00      mov bl, [d + 24]
1828   0A40 FD 87 38      and bl, %00111000             ; directory flag
1829   0A43 C1 08         cmp bl, %00001000             ; is dir?
1830   0A45 C6 59 0A      je loadfile_isdirectory  
1831   0A48             ; entry is a file
1832   0A48 2B 19 00      mov b, [d + 25]               ; get lba
1833   0A4B FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1834   0A4D 3B D9 24      mov d, transient_area
1835   0A50 38 00 00      mov c, 0
1836   0A53 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1837   0A55 07 20 05      call ide_read_sect            ; read sector
1838   0A58 09            ret
1839   0A59             loadfile_isdirectory:
1840   0A59 58 19 00      add d, 25           
1841   0A5C 15            mov a, [d]                    ; set result register a = dirid
1842   0A5D 07 C8 14      call get_token
1843   0A60 0A F6 09      jmp loadfile_from_path_e0
1844   0A63             loadfile_from_path_end:
1845   0A63 09            ret
1846   0A64             
1847   0A64             ;------------------------------------------------------------------------------------------------------;
1848   0A64             ; return the id of the current directory
1849   0A64             ; id returned in b
1850   0A64             ;------------------------------------------------------------------------------------------------------;
1851   0A64             fs_get_curr_dirid:
1852   0A64 29 7C 17      mov b, [current_dir_id]
1853   0A67 06            sysret
1854   0A68             
1855   0A68             ;------------------------------------------------------------------------------------------------------;
1856   0A68             ; cd
1857   0A68             ;------------------------------------------------------------------------------------------------------;
1858   0A68             ; new dirid in b
1859   0A68             fs_cd:
1860   0A68 FD 42 7C 17   mov [current_dir_id], b
1861   0A6C 06            sysret  
1862   0A6D             
1863   0A6D             ;------------------------------------------------------------------------------------------------------;
1864   0A6D             ; ls
1865   0A6D             ; dirid in b
1866   0A6D             ;------------------------------------------------------------------------------------------------------;
1867   0A6D 00 00       ls_count:       .dw 0
1868   0A6F             fs_ls:
1869   0A6F FD 77         inc b                        ; metadata sector
1870   0A71 38 00 00      mov c, 0                     ; upper lba = 0
1871   0A74 22 01         mov ah, $01                  ; 1 sector
1872   0A76 3B D9 24      mov d, transient_area
1873   0A79 07 20 05      call ide_read_sect           ; read directory
1874   0A7C FD 10         cla
1875   0A7E 42 74 17      mov [index], a               ; reset entry index
1876   0A81 3D 6D 0A      mov [ls_count], al           ; reset item count
1877   0A84             fs_ls_l1:
1878   0A84 BD 00         cmp byte [d], 0              ; check for null
1879   0A86 C6 1D 0B      je fs_ls_next
1880   0A89             fs_ls_non_null:
1881   0A89 1D 6D 0A      mov al, [ls_count]
1882   0A8C 7A            inc al
1883   0A8D 3D 6D 0A      mov [ls_count], al           ; increment item count
1884   0A90 1F 18 00      mov al, [d + 24]
1885   0A93 87 38         and al, %00111000
1886   0A95 FD A2 03      shr al, 3
1887   0A98 22 00         mov ah, 0                    ; file type
1888   0A9A B7 A7 17      mov a, [a + file_type]      
1889   0A9D 23            mov ah, al
1890   0A9E 07 16 11      call _putchar
1891   0AA1 1F 18 00      mov al, [d + 24]
1892   0AA4 87 01         and al, %00000001
1893   0AA6 22 00         mov ah, 0
1894   0AA8 B7 A2 17      mov a, [a + file_attrib]     ; read
1895   0AAB 23            mov ah, al
1896   0AAC 07 16 11      call _putchar
1897   0AAF 1F 18 00      mov al, [d + 24]
1898   0AB2 87 02         and al, %00000010
1899   0AB4 22 00         mov ah, 0
1900   0AB6 B7 A2 17      mov a, [a + file_attrib]     ; write
1901   0AB9 23            mov ah, al
1902   0ABA 07 16 11      call _putchar
1903   0ABD 1F 18 00      mov al, [d + 24]
1904   0AC0 87 04         and al, %00000100
1905   0AC2 22 00         mov ah, 0
1906   0AC4 B7 A2 17      mov a, [a + file_attrib]     ; execute
1907   0AC7 23            mov ah, al
1908   0AC8 07 16 11      call _putchar
1909   0ACB 22 20         mov ah, $20
1910   0ACD 07 16 11      call _putchar  
1911   0AD0 2B 1B 00      mov b, [d + 27]
1912   0AD3 07 9E 12      call print_u16x              ; filesize
1913   0AD6 22 20         mov ah, $20
1914   0AD8 07 16 11      call _putchar  
1915   0ADB 2B 19 00      mov b, [d + 25]
1916   0ADE 07 9E 12      call print_u16x              ; dirid / lba
1917   0AE1 22 20         mov ah, $20
1918   0AE3 07 16 11      call _putchar
1919   0AE6             ; print date
1920   0AE6 33 1D 00      mov bl, [d + 29]             ; day
1921   0AE9 07 E2 12      call print_u8x
1922   0AEC 22 20         mov ah, $20
1923   0AEE 07 16 11      call _putchar  
1924   0AF1 1F 1E 00      mov al, [d + 30]             ; month
1925   0AF4 FD 9E 02      shl al, 2
1926   0AF7 DA            push d
1927   0AF8 3B 66 18      mov d, s_months
1928   0AFB 22 00         mov ah, 0
1929   0AFD 59            add d, a
1930   0AFE 07 42 12      call _puts
1931   0B01 E7            pop d
1932   0B02 22 20         mov ah, $20
1933   0B04 07 16 11      call _putchar
1934   0B07 2E 20         mov bl, $20
1935   0B09 07 E2 12      call print_u8x
1936   0B0C 33 1F 00      mov bl, [d + 31]             ; year
1937   0B0F 07 E2 12      call print_u8x  
1938   0B12 22 20         mov ah, $20
1939   0B14 07 16 11      call _putchar  
1940   0B17 07 42 12      call _puts                   ; print filename  
1941   0B1A 07 EF 11      call printnl
1942   0B1D             fs_ls_next:
1943   0B1D 14 74 17      mov a, [index]
1944   0B20 77            inc a
1945   0B21 42 74 17      mov [index], a
1946   0B24 AF 10 00      cmp a, fst_files_per_dir
1947   0B27 C6 30 0B      je fs_ls_end
1948   0B2A 58 20 00      add d, 32      
1949   0B2D 0A 84 0A      jmp fs_ls_l1  
1950   0B30             fs_ls_end:
1951   0B30 3B B7 17      mov d, s_ls_total
1952   0B33 07 42 12      call _puts
1953   0B36 1D 6D 0A      mov al, [ls_count]
1954   0B39 07 F4 12      call print_u8d
1955   0B3C 07 EF 11      call printnl
1956   0B3F 06            sysret
1957   0B40             
1958   0B40             ;------------------------------------------------------------------------------------------------------;
1959   0B40             ; finds an empty data block
1960   0B40             ; block lba returned in b
1961   0B40             ;------------------------------------------------------------------------------------------------------;
1962   0B40             fs_find_empty_block:
1963   0B40 26 A0 00      mov b, fs_lba_start     ; raw files starting block
1964   0B43 38 00 00      mov c, 0                ; upper lba = 0
1965   0B46             fs_find_empty_block_l1:  
1966   0B46 22 01         mov ah, $01                  ; 1 sector
1967   0B48 3B D9 22      mov d, transient_area - 512
1968   0B4B 07 20 05      call ide_read_sect      ; read sector
1969   0B4E BD 00         cmp byte [d], 0
1970   0B50 C6 59 0B      je fs_find_empty_block_found_null
1971   0B53 55 20 00      add b, fs_sectors_per_file
1972   0B56 0A 46 0B      jmp fs_find_empty_block_l1
1973   0B59             fs_find_empty_block_found_null:
1974   0B59 09            ret
1975   0B5A             
1976   0B5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1977   0B5A             ;; create new textfile
1978   0B5A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1979   0B5A             ; search for first null block
1980   0B5A             fs_mktxt:
1981   0B5A FD 4E       	mov si, d
1982   0B5C FD 4F D9 1C 	mov di, user_data
1983   0B60 38 00 01    	mov c, 256
1984   0B63 04          	load					; load data from user-space
1985   0B64             	
1986   0B64 26 A0 00    	mov b, fs_lba_start		; raw files starting block
1987   0B67 38 00 00    	mov c, 0						; reset lba to 0
1988   0B6A             fs_mktxt_l1:	
1989   0B6A 10 02 01    	mov a, $0102			; disk read
1990   0B6D 3B D9 24    	mov d, transient_area
1991   0B70 05 02       	syscall sys_ide ; read sector
1992   0B72 1E          	mov al, [d]
1993   0B73 B9 00       	cmp al, 0			; check for null
1994   0B75 C6 7E 0B    	je fs_mktxt_found_null
1995   0B78 55 20 00    	add b, fs_sectors_per_file
1996   0B7B 0A 6A 0B    	jmp fs_mktxt_l1
1997   0B7E             fs_mktxt_found_null:
1998   0B7E D8          	push b				; save lba
1999   0B7F             ;create header file by grabbing file name from parameter	
2000   0B7F 3B 98 17    	mov d, s_dataentry
2001   0B82 07 42 12    	call _puts
2002   0B85 3B D9 26    	mov d, transient_area + 512			; pointer to file contents
2003   0B88 07 A8 11    	call _gettxt
2004   0B8B 07 75 10    	call _strlen						; get length of file
2005   0B8E D9          	push c							; save length
2006   0B8F 19 01       	mov al, 1
2007   0B91 3D D9 24    	mov [transient_area], al					; mark sectors as used (not null)
2008   0B94 10 00 00    	mov a, 0
2009   0B97 42 74 17    	mov [index], a
2010   0B9A 3B D9 24    	mov d, transient_area
2011   0B9D 13          	mov a, d
2012   0B9E 42 76 17    	mov [buffer_addr], a
2013   0BA1             fs_mktxt_l2:
2014   0BA1 38 00 00    	mov c, 0
2015   0BA4 10 03 01    	mov a, $0103			; disk write, 1 sector
2016   0BA7 05 02       	syscall sys_ide		; write sector
2017   0BA9 14 74 17    	mov a, [index]
2018   0BAC 77          	inc a
2019   0BAD 42 74 17    	mov [index], a
2020   0BB0 AF 20 00    	cmp a, fs_sectors_per_file
2021   0BB3 C6 C5 0B    	je fs_mktxt_add_to_dir
2022   0BB6 FD 77       	inc b
2023   0BB8 14 76 17    	mov a, [buffer_addr]
2024   0BBB 53 00 02    	add a, 512
2025   0BBE 42 76 17    	mov [buffer_addr], a
2026   0BC1 3C          	mov d, a
2027   0BC2 0A A1 0B    	jmp fs_mktxt_l2
2028   0BC5             ; now we add the file to the current directory!
2029   0BC5             fs_mktxt_add_to_dir:	
2030   0BC5 14 7C 17    	mov a, [current_dir_id]
2031   0BC8 77          	inc a
2032   0BC9 27          	mov b, a					; metadata sector
2033   0BCA 38 00 00    	mov c, 0
2034   0BCD FD 79       	mov g, b					; save lba
2035   0BCF 3B D9 24    	mov d, transient_area
2036   0BD2 10 02 01    	mov a, $0102			; disk read
2037   0BD5 05 02       	syscall sys_ide		; read metadata sector
2038   0BD7             fs_mktxt_add_to_dir_l2:
2039   0BD7 1E          	mov al, [d]
2040   0BD8 B9 00       	cmp al, 0
2041   0BDA C6 E3 0B    	je fs_mktxt_add_to_dir_null
2042   0BDD 58 20 00    	add d, fst_entry_size
2043   0BE0 0A D7 0B    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2044   0BE3             fs_mktxt_add_to_dir_null:
2045   0BE3 FD 4D D9 1C 	mov si, user_data
2046   0BE7 FD 50       	mov di, d
2047   0BE9 07 9A 10    	call _strcpy			; copy file name
2048   0BEC 58 18 00    	add d, 24			; skip name
2049   0BEF 19 06       	mov al, %00000110		; no execute, write, read, not directory
2050   0BF1 3E          	mov [d], al			
2051   0BF2 58 03 00    	add d, 3
2052   0BF5 E4          	pop a
2053   0BF6 43          	mov [d], a
2054   0BF7 63 02 00    	sub d, 2
2055   0BFA E5          	pop b				; get file lba
2056   0BFB FD 43       	mov [d], b			; save lba	
2057   0BFD             	
2058   0BFD             	; set file creation date	
2059   0BFD 58 04 00    	add d, 4
2060   0C00 19 04       	mov al, 4
2061   0C02 05 01       	syscall sys_rtc
2062   0C04 1A          	mov al, ah
2063   0C05 3E          	mov [d], al			; set day
2064   0C06             	
2065   0C06 79          	inc d
2066   0C07 19 05       	mov al, 5
2067   0C09 05 01       	syscall sys_rtc
2068   0C0B 1A          	mov al, ah
2069   0C0C 3E          	mov [d], al			; set month
2070   0C0D             	
2071   0C0D 79          	inc d
2072   0C0E 19 06       	mov al, 6
2073   0C10 05 01       	syscall sys_rtc
2074   0C12 1A          	mov al, ah
2075   0C13 3E          	mov [d], al			; set year
2076   0C14             	
2077   0C14             ; write sector into disk for new directory entry
2078   0C14 FD 27       	mov b, g
2079   0C16 38 00 00    	mov c, 0
2080   0C19 3B D9 24    	mov d, transient_area
2081   0C1C 10 03 01    	mov a, $0103			; disk write, 1 sector
2082   0C1F 05 02       	syscall sys_ide		; write sector
2083   0C21 07 EF 11    	call printnl
2084   0C24 06          	sysret
2085   0C25             
2086   0C25             
2087   0C25             
2088   0C25             ;------------------------------------------------------------------------------------------------------;
2089   0C25             ; create new binary file
2090   0C25             ;------------------------------------------------------------------------------------------------------;
2091   0C25             ; search for first null block
2092   0C25             fs_mkbin:
2093   0C25 19 00         mov al, 0
2094   0C27 3D 6C 17      mov [sys_echo_on], al ; disable echo
2095   0C2A FD 4E         mov si, d
2096   0C2C FD 4F D9 1C   mov di, user_data
2097   0C30 38 00 02      mov c, 512
2098   0C33 04            load                          ; load data from user-space
2099   0C34 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2100   0C37 38 00 00      mov c, 0                      ; upper lba = 0
2101   0C3A             fs_mkbin_l1:  
2102   0C3A 22 01         mov ah, $01                  ; 1 sector
2103   0C3C 3B D9 24      mov d, transient_area
2104   0C3F 07 20 05      call ide_read_sect            ; read sector
2105   0C42 BD 00         cmp byte[d], 0                ; check for null
2106   0C44 C6 4D 0C      je fs_mkbin_found_null
2107   0C47 55 20 00      add b, fs_sectors_per_file
2108   0C4A 0A 3A 0C      jmp fs_mkbin_l1
2109   0C4D             fs_mkbin_found_null:
2110   0C4D D8            push b                        ; save lba
2111   0C4E             ;create header file by grabbing file name from parameter
2112   0C4E FD 4F D9 26   mov di, transient_area + 512  ; pointer to file contents
2113   0C52 07 C8 0F      call _load_hex                ; load binary hex
2114   0C55 D9            push c                        ; save size (nbr of bytes)
2115   0C56 19 01         mov al, 1
2116   0C58 3D D9 24      mov [transient_area], al      ; mark sectors as used (not null)
2117   0C5B FD 10         cla
2118   0C5D 42 74 17      mov [index], a
2119   0C60 3B D9 24      mov d, transient_area
2120   0C63 13            mov a, d
2121   0C64 42 76 17      mov [buffer_addr], a
2122   0C67             fs_mkbin_l2:
2123   0C67 38 00 00      mov c, 0
2124   0C6A 22 01         mov ah, $01                   ; disk write, 1 sector
2125   0C6C 07 46 05      call ide_write_sect           ; write sector
2126   0C6F 14 74 17      mov a, [index]
2127   0C72 77            inc a
2128   0C73 42 74 17      mov [index], a
2129   0C76 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2130   0C79 C6 8B 0C      je fs_mkbin_add_to_dir
2131   0C7C FD 77         inc b
2132   0C7E 14 76 17      mov a, [buffer_addr]
2133   0C81 53 00 02      add a, 512
2134   0C84 42 76 17      mov [buffer_addr], a
2135   0C87 3C            mov d, a
2136   0C88 0A 67 0C      jmp fs_mkbin_l2
2137   0C8B             ; now we add the file to the current directory!
2138   0C8B             fs_mkbin_add_to_dir:  
2139   0C8B 14 7C 17      mov a, [current_dir_id]
2140   0C8E 77            inc a
2141   0C8F 27            mov b, a                      ; metadata sector
2142   0C90 38 00 00      mov c, 0
2143   0C93 FD 79         mov g, b                      ; save lba
2144   0C95 3B D9 24      mov d, transient_area
2145   0C98 22 01         mov ah, $01                  ; 1 sector
2146   0C9A 07 20 05      call ide_read_sect            ; read metadata sector
2147   0C9D             fs_mkbin_add_to_dir_l2:
2148   0C9D BD 00         cmp byte[d], 0
2149   0C9F C6 A8 0C      je fs_mkbin_add_to_dir_null
2150   0CA2 58 20 00      add d, fst_entry_size
2151   0CA5 0A 9D 0C      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2152   0CA8             fs_mkbin_add_to_dir_null:
2153   0CA8 FD 4D D9 1C   mov si, user_data
2154   0CAC FD 50         mov di, d
2155   0CAE 07 9A 10      call _strcpy                  ; copy file name
2156   0CB1 58 18 00      add d, 24                     ; skip name
2157   0CB4 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2158   0CB6 3E            mov [d], al
2159   0CB7 58 03 00      add d, 3
2160   0CBA E4            pop a
2161   0CBB 43            mov [d], a
2162   0CBC 63 02 00      sub d, 2
2163   0CBF E5            pop b                         ; get file lba
2164   0CC0 FD 43         mov [d], b                    ; save lba
2165   0CC2               ; set file creation date  
2166   0CC2 58 04 00      add d, 4
2167   0CC5 19 04         mov al, 4
2168   0CC7 05 01         syscall sys_rtc
2169   0CC9 1A            mov al, ah
2170   0CCA 3E            mov [d], al                   ; set day
2171   0CCB 79            inc d
2172   0CCC 19 05         mov al, 5
2173   0CCE 05 01         syscall sys_rtc
2174   0CD0 1A            mov al, ah
2175   0CD1 3E            mov [d], al                   ; set month
2176   0CD2 79            inc d
2177   0CD3 19 06         mov al, 6
2178   0CD5 05 01         syscall sys_rtc
2179   0CD7 1A            mov al, ah
2180   0CD8 3E            mov [d], al                   ; set year
2181   0CD9             ; write sector into disk for new directory entry
2182   0CD9 FD 27         mov b, g
2183   0CDB 38 00 00      mov c, 0
2184   0CDE 3B D9 24      mov d, transient_area
2185   0CE1 22 01         mov ah, $01                   ; disk write, 1 sector
2186   0CE3 07 46 05      call ide_write_sect           ; write sector
2187   0CE6 19 01         mov al, 1
2188   0CE8 3D 6C 17      mov [sys_echo_on], al ; enable echo
2189   0CEB 06            sysret
2190   0CEC             
2191   0CEC             ;------------------------------------------------------------------------------------------------------;
2192   0CEC             ; pwd - print working directory
2193   0CEC             ;------------------------------------------------------------------------------------------------------;    
2194   0CEC             fs_pwd:
2195   0CEC 3B 59 1C      mov d, filename
2196   0CEF 19 00         mov al, 0
2197   0CF1 3E            mov [d], al                   ; initialize path string 
2198   0CF2 14 7C 17      mov a, [current_dir_id]
2199   0CF5 07 56 08      call fs_dir_id_to_path_e0
2200   0CF8 3B 59 1C      mov d, filename
2201   0CFB 07 2E 10      call _strrev
2202   0CFE 07 42 12      call _puts
2203   0D01 07 EF 11      call printnl
2204   0D04 06            sysret
2205   0D05             
2206   0D05             ;------------------------------------------------------------------------------------------------------;
2207   0D05             ; get current directory lba
2208   0D05             ; a: returned lba
2209   0D05             ;------------------------------------------------------------------------------------------------------;
2210   0D05             cmd_get_curr_dir_lba:
2211   0D05 14 7C 17      mov a, [current_dir_id]
2212   0D08 06            sysret
2213   0D09             
2214   0D09             ;------------------------------------------------------------------------------------------------------;
2215   0D09             ; cat
2216   0D09             ; userspace destination data pointer in d
2217   0D09             ; filename starts at d, but is overwritten after the read is made
2218   0D09             ;------------------------------------------------------------------------------------------------------;:
2219   0D09             fs_cat:
2220   0D09 DA            push d                              ; save userspace file data destination
2221   0D0A FD 4E         mov si, d
2222   0D0C FD 4F D9 1C   mov di, user_data
2223   0D10 38 00 02      mov c, 512
2224   0D13 04            load                                ; copy filename from user-space
2225   0D14 29 7C 17      mov b, [current_dir_id]
2226   0D17 FD 77         inc b                               ; metadata sector
2227   0D19 38 00 00      mov c, 0                            ; upper lba = 0
2228   0D1C 22 01         mov ah, $01                  ; 1 sector
2229   0D1E 3B D9 22      mov d, transient_area-512
2230   0D21 07 20 05      call ide_read_sect                  ; read directory
2231   0D24 FD 10         cla
2232   0D26 42 74 17      mov [index], a                      ; reset file counter
2233   0D29             fs_cat_l1:
2234   0D29 FD 4E         mov si, d
2235   0D2B FD 4F D9 1C   mov di, user_data
2236   0D2F 07 85 10      call _strcmp
2237   0D32 C6 48 0D      je fs_cat_found_entry
2238   0D35 58 20 00      add d, 32
2239   0D38 14 74 17      mov a, [index]
2240   0D3B 77            inc a
2241   0D3C 42 74 17      mov [index], a
2242   0D3F AF 10 00      cmp a, fst_files_per_dir
2243   0D42 C6 63 0D      je fs_cat_not_found
2244   0D45 0A 29 0D      jmp fs_cat_l1
2245   0D48             fs_cat_found_entry:
2246   0D48 58 19 00      add d, 25                           ; get to dirid of file in disk
2247   0D4B 2A            mov b, [d]                          ; get lba
2248   0D4C FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2249   0D4E 3B D9 24      mov d, transient_area  
2250   0D51 38 00 00      mov c, 0
2251   0D54 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2252   0D56 07 20 05      call ide_read_sect                  ; read sectors
2253   0D59 F0            pop di                              ; write userspace file data destination to di
2254   0D5A FD 4D D9 24   mov si, transient_area              ; data origin
2255   0D5E 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2256   0D61 03            store
2257   0D62 06            sysret
2258   0D63             fs_cat_not_found:
2259   0D63 E7            pop d
2260   0D64 06            sysret
2261   0D65             
2262   0D65             ;------------------------------------------------------------------------------------------------------;
2263   0D65             ; rmdir - remove dir by dirid
2264   0D65             ;------------------------------------------------------------------------------------------------------;
2265   0D65             ; deletes a directory entry in the given directory's file list 
2266   0D65             ; also deletes the actual directory entry in the fst
2267   0D65             ; synopsis: rmdir /usr/local/testdir
2268   0D65             ; b = dirid
2269   0D65             fs_rmdir:
2270   0D65 FD 79         mov g, b
2271   0D67 11            mov a, b
2272   0D68 07 92 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2273   0D6B D7            push a                        ; save dirid
2274   0D6C             ; search for directory's entry in the parent's directory then and delete it
2275   0D6C 77            inc a                         ; metadata sector
2276   0D6D 27            mov b, a
2277   0D6E 38 00 00      mov c, 0                      ; upper lba = 0
2278   0D71 22 01         mov ah, $01          ;
2279   0D73 3B D9 24      mov d, transient_area
2280   0D76 07 20 05      call ide_read_sect            ; read directory
2281   0D79 FD 10         cla
2282   0D7B 42 74 17      mov [index], a                ; reset file counter
2283   0D7E FD 27         mov b, g                      ; retrieve directory's dirid
2284   0D80             fs_rmdir_l1:
2285   0D80 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2286   0D83 B0            cmp a, b                      ; compare dirid's to find the directory
2287   0D84 C6 9A 0D      je fs_rmdir_found_entry
2288   0D87 58 20 00      add d, 32
2289   0D8A 14 74 17      mov a, [index]
2290   0D8D 77            inc a
2291   0D8E 42 74 17      mov [index], a
2292   0D91 AF 10 00      cmp a, fst_files_per_dir
2293   0D94 C6 BF 0D      je fs_rmdir_not_found
2294   0D97 0A 80 0D      jmp fs_rmdir_l1
2295   0D9A             fs_rmdir_found_entry:
2296   0D9A FD 10         cla
2297   0D9C 3E            mov [d], al                   ; make filename null
2298   0D9D 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2299   0DA0 E5            pop b
2300   0DA1 FD 77         inc b                         ; metadata sector
2301   0DA3 38 00 00      mov c, 0                      ; upper lba = 0
2302   0DA6 22 01         mov ah, $01          ; 
2303   0DA8 3B D9 24      mov d, transient_area
2304   0DAB 07 46 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2305   0DAE             
2306   0DAE FD 27         mov b, g
2307   0DB0 3B D9 24      mov d, transient_area  
2308   0DB3 FD 10         cla
2309   0DB5 3E            mov [d], al                   ; make directory's name header null for re-use
2310   0DB6 38 00 00      mov c, 0
2311   0DB9 22 01         mov ah, $01                   ; disk write 1 sect
2312   0DBB 07 46 05      call ide_write_sect           ; delete directory given by dirid in b
2313   0DBE 06            sysret
2314   0DBF             fs_rmdir_not_found:
2315   0DBF E5            pop b
2316   0DC0 06            sysret
2317   0DC1             
2318   0DC1             ;------------------------------------------------------------------------------------------------------;
2319   0DC1             ; rm - remove file
2320   0DC1             ;------------------------------------------------------------------------------------------------------;
2321   0DC1             ; frees up the data sectors for the file further down the disk
2322   0DC1             ; deletes file entry in the directory's file list 
2323   0DC1             fs_rm:
2324   0DC1 FD 4E         mov si, d
2325   0DC3 FD 4F D9 1C   mov di, user_data
2326   0DC7 38 00 02      mov c, 512
2327   0DCA 04            load                          ; load data from user-space
2328   0DCB 14 7C 17      mov a, [current_dir_id]
2329   0DCE 77            inc a                         ; metadata sector
2330   0DCF 27            mov b, a
2331   0DD0 38 00 00      mov c, 0                      ; upper lba = 0
2332   0DD3 22 01         mov ah, $01                  ; 1 sector
2333   0DD5 3B D9 24      mov d, transient_area
2334   0DD8 07 20 05      call ide_read_sect            ; read directory
2335   0DDB 10 00 00      mov a, 0
2336   0DDE 42 74 17      mov [index], a                ; reset file counter
2337   0DE1             fs_rm_l1:
2338   0DE1 FD 4E         mov si, d
2339   0DE3 FD 4F D9 1C   mov di, user_data
2340   0DE7 07 85 10      call _strcmp
2341   0DEA C6 00 0E      je fs_rm_found_entry
2342   0DED 58 20 00      add d, 32
2343   0DF0 14 74 17      mov a, [index]
2344   0DF3 77            inc a
2345   0DF4 42 74 17      mov [index], a
2346   0DF7 AF 10 00      cmp a, fst_files_per_dir
2347   0DFA C6 28 0E      je fs_rm_not_found
2348   0DFD 0A E1 0D      jmp fs_rm_l1
2349   0E00             fs_rm_found_entry:
2350   0E00 2B 19 00      mov b, [d + 25]               ; get lba
2351   0E03 FD 79         mov g, b                      ; save lba
2352   0E05 19 00         mov al, 0
2353   0E07 3E            mov [d], al                   ; make file entry null
2354   0E08 14 7C 17      mov a, [current_dir_id]
2355   0E0B 77            inc a                         ; metadata sector
2356   0E0C 27            mov b, a
2357   0E0D 38 00 00      mov c, 0                      ; upper lba = 0
2358   0E10 22 01         mov ah, $01                   ; disk write
2359   0E12 3B D9 24      mov d, transient_area
2360   0E15 07 46 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2361   0E18 3B D9 24      mov d, transient_area  
2362   0E1B 19 00         mov al, 0
2363   0E1D 3E            mov [d], al                   ; make file's data header null for re-use
2364   0E1E 38 00 00      mov c, 0
2365   0E21 FD 27         mov b, g                      ; get data header lba
2366   0E23 22 01         mov ah, $01                   ; disk write 1 sect
2367   0E25 07 46 05      call ide_write_sect           ; write sector
2368   0E28             fs_rm_not_found:  
2369   0E28 06            sysret  
2370   0E29             
2371   0E29             ;------------------------------------------------------------------------------------------------------;
2372   0E29             ; mv - move / change file name
2373   0E29             ;------------------------------------------------------------------------------------------------------;
2374   0E29             fs_mv:
2375   0E29 FD 4E         mov si, d
2376   0E2B FD 4F D9 1C   mov di, user_data
2377   0E2F 38 00 02      mov c, 512
2378   0E32 04            load                          ; load data from user-space
2379   0E33 14 7C 17      mov a, [current_dir_id]
2380   0E36 77            inc a                         ; metadata sector
2381   0E37 27            mov b, a  
2382   0E38 38 00 00      mov c, 0                      ; upper lba = 0
2383   0E3B 22 01         mov ah, $01                  ; 1 sector
2384   0E3D 3B D9 24      mov d, transient_area
2385   0E40 07 20 05      call ide_read_sect            ; read directory
2386   0E43 FD 10         cla
2387   0E45 42 74 17      mov [index], a                ; reset file counter
2388   0E48             fs_mv_l1:
2389   0E48 FD 4E         mov si, d
2390   0E4A FD 4F D9 1C   mov di, user_data
2391   0E4E 07 85 10      call _strcmp
2392   0E51 C6 67 0E      je fs_mv_found_entry
2393   0E54 58 20 00      add d, 32
2394   0E57 14 74 17      mov a, [index]
2395   0E5A 77            inc a
2396   0E5B 42 74 17      mov [index], a
2397   0E5E AF 10 00      cmp a, fst_files_per_dir
2398   0E61 C6 99 0E      je fs_mv_not_found
2399   0E64 0A 48 0E      jmp fs_mv_l1
2400   0E67             fs_mv_found_entry:  
2401   0E67 DA            push d
2402   0E68 FD 4D 59 1D   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2403   0E6C FD 50         mov di, d
2404   0E6E 07 9A 10      call _strcpy  
2405   0E71 38 00 00      mov c, 0
2406   0E74 3B D9 24      mov d, transient_area
2407   0E77 22 01         mov ah, $01                   ; disk write 1 sect
2408   0E79 07 46 05      call ide_write_sect           ; write sector
2409   0E7C E7            pop d
2410   0E7D             ;; need to check whether its a dir or a file here ;;;
2411   0E7D 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2412   0E80 22 01         mov ah, $01
2413   0E82 3B D9 24      mov d, transient_area
2414   0E85 38 00 00      mov c, 0
2415   0E88 07 20 05      call ide_read_sect            ; read directory entry
2416   0E8B FD 4D 59 1D   mov si, user_data + 128
2417   0E8F FD 50         mov di, d
2418   0E91 07 9A 10      call _strcpy                  ; change directory's name
2419   0E94 22 01         mov ah, $01
2420   0E96 07 46 05      call ide_write_sect           ; rewrite directory back to disk
2421   0E99             fs_mv_not_found:
2422   0E99 06            sysret
2423   0E9A             
2424   0E9A             
2425   0E9A             ;----------------------------------------------------------------------------------------------------;
2426   0E9A             ; process index in a
2427   0E9A             ;----------------------------------------------------------------------------------------------------;
2428   0E9A             find_free_proc:
2429   0E9A FD 4D 4A 1A   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2430   0E9E             find_free_proc_l0:
2431   0E9E F6            lodsb                               ; get process state
2432   0E9F B9 00         cmp al, 0
2433   0EA1 C6 A7 0E      je find_free_proc_free              ; if free, jump
2434   0EA4 0A 9E 0E      jmp find_free_proc_l0               ; else, goto next
2435   0EA7             find_free_proc_free:
2436   0EA7 4E            mov a, si
2437   0EA8 5F 4A 1A      sub a, 1 + proc_availab_table       ; get process index
2438   0EAB 09            ret
2439   0EAC               
2440   0EAC             
2441   0EAC             ;----------------------------------------------------------------------------------------------------;
2442   0EAC             ; process index in al
2443   0EAC             ;----------------------------------------------------------------------------------------------------;
2444   0EAC             proc_memory_map:
2445   0EAC 22 00         mov ah, 0
2446   0EAE 27            mov b, a                      ; page in bl, 0 in bh
2447   0EAF FD 9D 05      shl a, 5                      ; multiply by 32
2448   0EB2 39            mov c, a                      ; save in c
2449   0EB3 57 20 00      add c, 32
2450   0EB6             proc_memory_map_l0:
2451   0EB6 02            pagemap
2452   0EB7 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2453   0EBA 53 01 00      add a, 1                      ; increase both 
2454   0EBD B1            cmp a, c                      ; check to see if we reached the end of memory
2455   0EBE C7 B6 0E      jne proc_memory_map_l0
2456   0EC1 09            ret
2457   0EC2               
2458   0EC2             
2459   0EC2             ;----------------------------------------------------------------------------------------------------;
2460   0EC2             ; terminate process
2461   0EC2             ;----------------------------------------------------------------------------------------------------;
2462   0EC2             syscall_terminate_proc:
2463   0EC2 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2464   0EC5                                                    ; since they will not be used for anything here.
2465   0EC5 1D 73 17      mov al, [active_proc_index]
2466   0EC8 22 00         mov ah, 0  
2467   0ECA FD 9D 05      shl a, 5                             ; x32
2468   0ECD 53 59 1A      add a, proc_names
2469   0ED0 3C            mov d, a
2470   0ED1 19 00         mov al, 0
2471   0ED3 3E            mov [d], al                           ; nullify process name
2472   0ED4             
2473   0ED4 1D 73 17      mov al, [active_proc_index]
2474   0ED7 22 00         mov ah, 0  
2475   0ED9 3C            mov d, a
2476   0EDA 19 00         mov al, 0
2477   0EDC 3F 49 1A      mov [d + proc_availab_table], al    ; make process empty again
2478   0EDF               
2479   0EDF 1D 72 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2480   0EE2 80            dec al
2481   0EE3 3D 72 17      mov [nbr_active_procs], al
2482   0EE6             
2483   0EE6             ; now load the shell process again
2484   0EE6 19 02         mov al, 2                           ; next process = process 2 = shell
2485   0EE8 3D 73 17      mov [active_proc_index], al         ; set next active proc
2486   0EEB             
2487   0EEB             ; calculate lut entry for next process
2488   0EEB 22 00         mov ah, 0
2489   0EED FD 99         shl a                               ; x2
2490   0EEF B7 B8 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2491   0EF2               
2492   0EF2 4D            mov si, a                           ; source is proc state block
2493   0EF3 48            mov a, sp
2494   0EF4 5F 13 00      sub a, 19
2495   0EF7 4F            mov di, a                           ; destination is kernel stack
2496   0EF8             ; restore sp
2497   0EF8 7D            dec a
2498   0EF9 47            mov sp, a
2499   0EFA 38 14 00      mov c, 20
2500   0EFD FD F5         rep movsb
2501   0EFF             ; set vm process
2502   0EFF 1D 73 17      mov al, [active_proc_index]
2503   0F02 01            setptb
2504   0F03                 
2505   0F03 4C            popa
2506   0F04 06            sysret
2507   0F05             
2508   0F05             ;----------------------------------------------------------------------------------------------------;
2509   0F05             ; pause process
2510   0F05             ;----------------------------------------------------------------------------------------------------;
2511   0F05             syscall_pause_proc:
2512   0F05             ; save all registers into kernel stack
2513   0F05 4B            pusha
2514   0F06 22 00         mov ah, 0
2515   0F08 1D 73 17      mov al, [active_proc_index]
2516   0F0B FD 99         shl a              ; x2
2517   0F0D B7 B8 0F      mov a, [proc_table_convert + a]   ; get process state start index
2518   0F10                 
2519   0F10 4F            mov di, a
2520   0F11 48            mov a, sp
2521   0F12 77            inc a
2522   0F13 4D            mov si, a
2523   0F14 38 14 00      mov c, 20
2524   0F17 FD F5         rep movsb                         ; save process state!
2525   0F19             ; restore kernel stack position to point before interrupt arrived
2526   0F19 51 14 00      add sp, 20
2527   0F1C             ; now load the shell process again
2528   0F1C 19 02         mov al, 2                         ; next process = process 2 = shell
2529   0F1E 3D 73 17      mov [active_proc_index], al       ; set next active proc
2530   0F21             
2531   0F21             ; calculate lut entry for next process
2532   0F21 22 00         mov ah, 0
2533   0F23 FD 99         shl a                             ; x2
2534   0F25 B7 B8 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2535   0F28               
2536   0F28 4D            mov si, a                         ; source is proc state block
2537   0F29 48            mov a, sp
2538   0F2A 5F 13 00      sub a, 19
2539   0F2D 4F            mov di, a                         ; destination is kernel stack
2540   0F2E             ; restore sp
2541   0F2E 7D            dec a
2542   0F2F 47            mov sp, a
2543   0F30 38 14 00      mov c, 20
2544   0F33 FD F5         rep movsb
2545   0F35             ; set vm process
2546   0F35 1D 73 17      mov al, [active_proc_index]
2547   0F38 01            setptb
2548   0F39                 
2549   0F39 4C            popa
2550   0F3A 06            sysret
2551   0F3B             
2552   0F3B             ;----------------------------------------------------------------------------------------------------;
2553   0F3B             ; create a new process
2554   0F3B             ; d = path of the process file to be createed
2555   0F3B             ; b = arguments ptr
2556   0F3B             ;----------------------------------------------------------------------------------------------------;
2557   0F3B             syscall_create_proc:
2558   0F3B             ; we save the active process first  
2559   0F3B 4B            pusha
2560   0F3C 22 00         mov ah, 0
2561   0F3E 1D 73 17      mov al, [active_proc_index]
2562   0F41 FD 99         shl a              ; x2
2563   0F43 B7 B8 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2564   0F46               
2565   0F46 4F            mov di, a
2566   0F47 48            mov a, sp
2567   0F48 77            inc a
2568   0F49 4D            mov si, a
2569   0F4A 38 14 00      mov c, 20
2570   0F4D FD F5         rep movsb                          ; save process state!
2571   0F4F             ; restore kernel stack position to point before interrupt arrived
2572   0F4F 51 14 00      add sp, 20
2573   0F52               
2574   0F52 FD 4E         mov si, d                          ; copy the file path
2575   0F54 FD 4F D9 1C   mov di, user_data
2576   0F58 38 00 02      mov c, 512
2577   0F5B 04            load
2578   0F5C 11            mov a, b
2579   0F5D 4D            mov si, a                          ; copy the arguments
2580   0F5E FD 4F D9 22   mov di, scrap_sector
2581   0F62 38 00 02      mov c, 512
2582   0F65 04            load
2583   0F66 07 D8 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2584   0F69                                                  ; the file data is loaded into transient_area
2585   0F69             ; now we allocate a new process  
2586   0F69 07 9A 0E      call find_free_proc                ; index in a
2587   0F6C 01            setptb 
2588   0F6D 07 AC 0E      call proc_memory_map               ; map process memory pages
2589   0F70             ; copy arguments into process's memory
2590   0F70 FD 4D D9 22   mov si, scrap_sector
2591   0F74 FD 4F 00 00   mov di, 0
2592   0F78 38 00 02      mov c, 512
2593   0F7B 03            store
2594   0F7C             ; now copy process binary data into process's memory
2595   0F7C FD 4D D9 24   mov si, transient_area
2596   0F80 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2597   0F84 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2598   0F87 03            store                              ; copy process data
2599   0F88                 
2600   0F88 07 9A 0E      call find_free_proc                ; index in a
2601   0F8B 3D 73 17      mov [active_proc_index], al        ; set new active process
2602   0F8E FD 9D 05      shl a, 5                           ; x32
2603   0F91 53 59 1A      add a, proc_names
2604   0F94 4F            mov di, a
2605   0F95 FD 4D D9 1C   mov si, user_data                  ; copy and store process filename
2606   0F99 07 9A 10      call _strcpy
2607   0F9C               
2608   0F9C 07 9A 0E      call find_free_proc                ; index in a
2609   0F9F 3C            mov d, a
2610   0FA0 19 01         mov al, 1
2611   0FA2 3F 49 1A      mov [d + proc_availab_table], al   ; make process busy
2612   0FA5               
2613   0FA5 1D 72 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2614   0FA8 7A            inc al
2615   0FA9 3D 72 17      mov [nbr_active_procs], al
2616   0FAC             ; launch process
2617   0FAC FD D7 FF FF   push word $ffff 
2618   0FB0 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2619   0FB3 FD D7 00 04   push word text_org
2620   0FB7 06            sysret
2621   0FB8             
2622   0FB8             proc_table_convert:
2623   0FB8 09 19         .dw proc_state_table + 0
2624   0FBA 1D 19         .dw proc_state_table + 20
2625   0FBC 31 19         .dw proc_state_table + 40
2626   0FBE 45 19         .dw proc_state_table + 60
2627   0FC0 59 19         .dw proc_state_table + 80
2628   0FC2 6D 19         .dw proc_state_table + 100
2629   0FC4 81 19         .dw proc_state_table + 120
2630   0FC6 95 19         .dw proc_state_table + 140
2631   0FC8               
2632   0FC8             ;----------------------------------------------------------------------------------------------;
2633   0FC8             ; get hex file
2634   0FC8             ; di = destination address
2635   0FC8             ; return length in bytes in c
2636   0FC8             ;----------------------------------------------------------------------------------------------;
2637   0FC8             _load_hex:
2638   0FC8 D7            push a
2639   0FC9 D8            push b
2640   0FCA DA            push d
2641   0FCB E2            push si
2642   0FCC E3            push di
2643   0FCD 38 00 00      mov c, 0
2644   0FD0 50            mov a, di
2645   0FD1 3C            mov d, a          ; start of string data block
2646   0FD2 07 1D 11      call _gets        ; get program string
2647   0FD5 4D            mov si, a
2648   0FD6             __load_hex_loop:
2649   0FD6 F6            lodsb             ; load from [si] to al
2650   0FD7 B9 00         cmp al, 0         ; check if ascii 0
2651   0FD9 C6 E7 0F      jz __load_hex_ret
2652   0FDC 36            mov bh, al
2653   0FDD F6            lodsb
2654   0FDE 2F            mov bl, al
2655   0FDF 07 D3 10      call _atoi        ; convert ascii byte in b to int (to al)
2656   0FE2 F7            stosb             ; store al to [di]
2657   0FE3 78            inc c
2658   0FE4 0A D6 0F      jmp __load_hex_loop
2659   0FE7             __load_hex_ret:
2660   0FE7 F0            pop di
2661   0FE8 EF            pop si
2662   0FE9 E7            pop d
2663   0FEA E5            pop b
2664   0FEB E4            pop a
2665   0FEC 09            ret
2666   0FED             
2667   0FED             ; synopsis: look inside a certain directory for files/directories
2668   0FED             ; before calling this function, cd into required directory
2669   0FED             ; for each entry inside directory:
2670   0FED             ;  if entry is a file:
2671   0FED             ;    compare filename to searched filename
2672   0FED             ;    if filenames are the same, print filename
2673   0FED             ;  else if entry is a directory:
2674   0FED             ;    cd to the given directory
2675   0FED             ;    recursively call cmd_find
2676   0FED             ;    cd outside previous directory
2677   0FED             ;  if current entry == last entry, return
2678   0FED             ; endfor
2679   0FED             f_find:
2680   0FED 09            ret
2681   0FEE             
2682   0FEE             
2683   0FEE             ; ---------------------------------------------------------------------
2684   0FEE             ; kernel reset vector
2685   0FEE             ; ---------------------------------------------------------------------
2686   0FEE             kernel_reset_vector:  
2687   0FEE FD 49 FF F7   mov bp, stack_begin
2688   0FF2 FD 47 FF F7   mov sp, stack_begin
2689   0FF6               
2690   0FF6 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2691   0FF8 FD 0F         stomsk                        
2692   0FFA FD 0C         sti  
2693   0FFC             
2694   0FFC 0C            lodstat
2695   0FFD 87 DF         and al, %11011111             ; disable display register loading
2696   0FFF 0D            stostat
2697   1000               
2698   1000             ; reset fifo pointers
2699   1000 10 D9 1E      mov a, fifo
2700   1003 3B 78 17      mov d, fifo_in
2701   1006 43            mov [d], a
2702   1007 3B 7A 17      mov d, fifo_out
2703   100A 43            mov [d], a  
2704   100B 19 02         mov al, 2
2705   100D 05 03         syscall sys_io                ; enable uart in interrupt mode
2706   100F             
2707   100F 3B C7 18      mov d, s_fdc_config
2708   1012 07 42 12      call _puts
2709   1015 F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2710   1019               
2711   1019 3B CD 17      mov d, s_kernel_started
2712   101C 07 42 12      call _puts
2713   101F             
2714   101F 19 10         mov al, 16
2715   1021 05 04         syscall sys_filesystem        ; set root dirid
2716   1023             
2717   1023 3B EA 17      mov d, s_prompt_init
2718   1026 07 42 12      call _puts
2719   1029 3B 7E 17      mov d, s_init_path
2720   102C 05 05         syscall sys_create_proc       ; launch init as a new process
2721   102E             
2722   102E             
2723   102E             ; file includes
2724   102E             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  102E             boot_origin      .EQU  $8004
0002+  102E             bios_uart        .EQU  $0002
0003+  102E             bios_ide         .EQU  $0003
0004+  102E             bios_reset_vector .EQU  $01c0
0005+  102E             ide_buffer       .EQU  $8204
2725   102E             .include "lib/stdio.asm"
0001+  102E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  102E             ; stdio.s
0003+  102E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  102E             .include "lib/string.asm"
0001++ 102E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 102E             ; string.s
0003++ 102E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 102E             
0005++ 102E             
0006++ 102E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 102E             ; _strrev
0008++ 102E             ; reverse a string
0009++ 102E             ; d = string address
0010++ 102E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 102E             ; 01234
0012++ 102E             _strrev:
0013++ 102E 4B          	pusha
0014++ 102F 07 75 10    	call _strlen	; length in c
0015++ 1032 12          	mov a, c
0016++ 1033 AF 01 00    	cmp a, 1
0017++ 1036 D0 50 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1039 7D          	dec a
0019++ 103A FD 4E       	mov si, d	; beginning of string
0020++ 103C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 103E 59          	add d, a	; end of string
0022++ 103F 12          	mov a, c
0023++ 1040 FD 9B       	shr a		; divide by 2
0024++ 1042 39          	mov c, a	; c now counts the steps
0025++ 1043             _strrev_l0:
0026++ 1043 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1044 F6          	lodsb		; load left-side char into al; increase si
0028++ 1045 3E          	mov [d], al	; store left char into right side
0029++ 1046 1B          	mov al, bl
0030++ 1047 F7          	stosb		; store right-side char into left-side; increase di
0031++ 1048 7E          	dec c
0032++ 1049 7F          	dec d
0033++ 104A C2 00 00    	cmp c, 0
0034++ 104D C7 43 10    	jne _strrev_l0
0035++ 1050             _strrev_end:
0036++ 1050 4C          	popa
0037++ 1051 09          	ret
0038++ 1052             	
0039++ 1052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1052             ; _strchr
0041++ 1052             ; search string in d for char in al
0042++ 1052             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1052             _strchr:
0044++ 1052             _strchr_l0:
0045++ 1052 32          	mov bl, [d]
0046++ 1053 C1 00       	cmp bl, 0
0047++ 1055 C6 60 10    	je _strchr_end
0048++ 1058 BA          	cmp al, bl
0049++ 1059 C6 60 10    	je _strchr_end
0050++ 105C 79          	inc d
0051++ 105D 0A 52 10    	jmp _strchr_l0
0052++ 1060             _strchr_end:
0053++ 1060 1B          	mov al, bl
0054++ 1061 09          	ret
0055++ 1062             
0056++ 1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1062             ; _strstr
0058++ 1062             ; find sub-string
0059++ 1062             ; str1 in si
0060++ 1062             ; str2 in di
0061++ 1062             ; si points to end of source string
0062++ 1062             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1062             _strstr:
0064++ 1062 DB          	push al
0065++ 1063 DA          	push d
0066++ 1064 E3          	push di
0067++ 1065             _strstr_loop:
0068++ 1065 F3          	cmpsb					; compare a byte of the strings
0069++ 1066 C7 71 10    	jne _strstr_ret
0070++ 1069 FC 00 00    	lea d, [di + 0]
0071++ 106C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 106E C7 65 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1071             _strstr_ret:
0074++ 1071 F0          	pop di
0075++ 1072 E7          	pop d
0076++ 1073 E8          	pop al
0077++ 1074 09          	ret
0078++ 1075             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1075             ; length of null terminated string
0080++ 1075             ; result in c
0081++ 1075             ; pointer in d
0082++ 1075             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1075             _strlen:
0084++ 1075 DA          	push d
0085++ 1076 38 00 00    	mov c, 0
0086++ 1079             _strlen_l1:
0087++ 1079 BD 00       	cmp byte [d], 0
0088++ 107B C6 83 10    	je _strlen_ret
0089++ 107E 79          	inc d
0090++ 107F 78          	inc c
0091++ 1080 0A 79 10    	jmp _strlen_l1
0092++ 1083             _strlen_ret:
0093++ 1083 E7          	pop d
0094++ 1084 09          	ret
0095++ 1085             
0096++ 1085             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1085             ; strcmp
0098++ 1085             ; compare two strings
0099++ 1085             ; str1 in si
0100++ 1085             ; str2 in di
0101++ 1085             ; create a string compairon instrucion ?????
0102++ 1085             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1085             _strcmp:
0104++ 1085 DB          	push al
0105++ 1086 DA          	push d
0106++ 1087 E3          	push di
0107++ 1088 E2          	push si
0108++ 1089             _strcmp_loop:
0109++ 1089 F3          	cmpsb					; compare a byte of the strings
0110++ 108A C7 95 10    	jne _strcmp_ret
0111++ 108D FB FF FF    	lea d, [si +- 1]
0112++ 1090 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1092 C7 89 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1095             _strcmp_ret:
0115++ 1095 EF          	pop si
0116++ 1096 F0          	pop di
0117++ 1097 E7          	pop d
0118++ 1098 E8          	pop al
0119++ 1099 09          	ret
0120++ 109A             
0121++ 109A             
0122++ 109A             ; strcpy
0123++ 109A             ; copy null terminated string from si to di
0124++ 109A             ; source in si
0125++ 109A             ; destination in di
0126++ 109A             _strcpy:
0127++ 109A E2          	push si
0128++ 109B E3          	push di
0129++ 109C DB          	push al
0130++ 109D             _strcpy_l1:
0131++ 109D F6          	lodsb
0132++ 109E F7          	stosb
0133++ 109F B9 00       	cmp al, 0
0134++ 10A1 C7 9D 10    	jne _strcpy_l1
0135++ 10A4             _strcpy_end:
0136++ 10A4 E8          	pop al
0137++ 10A5 F0          	pop di
0138++ 10A6 EF          	pop si
0139++ 10A7 09          	ret
0140++ 10A8             
0141++ 10A8             ; strcat
0142++ 10A8             ; concatenate a null terminated string into string at di, from string at si
0143++ 10A8             ; source in si
0144++ 10A8             ; destination in di
0145++ 10A8             _strcat:
0146++ 10A8 E2          	push si
0147++ 10A9 E3          	push di
0148++ 10AA D7          	push a
0149++ 10AB DA          	push d
0150++ 10AC 50          	mov a, di
0151++ 10AD 3C          	mov d, a
0152++ 10AE             _strcat_goto_end_l1:
0153++ 10AE BD 00       	cmp byte[d], 0
0154++ 10B0 C6 B7 10    	je _strcat_start
0155++ 10B3 79          	inc d
0156++ 10B4 0A AE 10    	jmp _strcat_goto_end_l1
0157++ 10B7             _strcat_start:
0158++ 10B7 FD 50       	mov di, d
0159++ 10B9             _strcat_l1:
0160++ 10B9 F6          	lodsb
0161++ 10BA F7          	stosb
0162++ 10BB B9 00       	cmp al, 0
0163++ 10BD C7 B9 10    	jne _strcat_l1
0164++ 10C0             _strcat_end:
0165++ 10C0 E7          	pop d
0166++ 10C1 E4          	pop a
0167++ 10C2 F0          	pop di
0168++ 10C3 EF          	pop si
0169++ 10C4 09          	ret
0170++ 10C5             
0171++ 10C5             
0005+  10C5             
0006+  10C5             
0007+  10C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10C5             ; convert ascii 'o'..'f' to integer 0..15
0009+  10C5             ; ascii in bl
0010+  10C5             ; result in al
0011+  10C5             ; ascii for f = 0100 0110
0012+  10C5             ; ascii for 9 = 0011 1001
0013+  10C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10C5             hex_ascii_encode:
0015+  10C5 1B            mov al, bl
0016+  10C6 93 40         test al, $40        ; test if letter or number
0017+  10C8 C7 CE 10      jnz hex_letter
0018+  10CB 87 0F         and al, $0f        ; get number
0019+  10CD 09            ret
0020+  10CE             hex_letter:
0021+  10CE 87 0F         and al, $0f        ; get letter
0022+  10D0 6A 09         add al, 9
0023+  10D2 09            ret
0024+  10D3             
0025+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10D3             ; atoi
0027+  10D3             ; 2 letter hex string in b
0028+  10D3             ; 8bit integer returned in al
0029+  10D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10D3             _atoi:
0031+  10D3 D8            push b
0032+  10D4 07 C5 10      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  10D7 30            mov bl, bh
0034+  10D8 DB            push al          ; save a
0035+  10D9 07 C5 10      call hex_ascii_encode
0036+  10DC EA            pop bl  
0037+  10DD FD 9E 04      shl al, 4
0038+  10E0 8C            or al, bl
0039+  10E1 E5            pop b
0040+  10E2 09            ret  
0041+  10E3             
0042+  10E3             
0043+  10E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10E3             ; scanf
0045+  10E3             ; no need for explanations!
0046+  10E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10E3             scanf:
0048+  10E3 09            ret
0049+  10E4             
0050+  10E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10E4             ; itoa
0052+  10E4             ; 8bit value in bl
0053+  10E4             ; 2 byte ascii result in a
0054+  10E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10E4             _itoa:
0056+  10E4 DA            push d
0057+  10E5 D8            push b
0058+  10E6 A7 00         mov bh, 0
0059+  10E8 FD A4 04      shr bl, 4  
0060+  10EB 74            mov d, b
0061+  10EC 1F 7E 13      mov al, [d + s_hex_digits]
0062+  10EF 23            mov ah, al
0063+  10F0               
0064+  10F0 E5            pop b
0065+  10F1 D8            push b
0066+  10F2 A7 00         mov bh, 0
0067+  10F4 FD 87 0F      and bl, $0f
0068+  10F7 74            mov d, b
0069+  10F8 1F 7E 13      mov al, [d + s_hex_digits]
0070+  10FB E5            pop b
0071+  10FC E7            pop d
0072+  10FD 09            ret
0073+  10FE             
0074+  10FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  10FE             ; hex string to binary
0076+  10FE             ; di = destination address
0077+  10FE             ; si = source
0078+  10FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  10FE             _hex_to_int:
0080+  10FE             _hex_to_int_l1:
0081+  10FE F6            lodsb          ; load from [si] to al
0082+  10FF B9 00         cmp al, 0        ; check if ascii 0
0083+  1101 C6 0E 11      jz _hex_to_int_ret
0084+  1104 36            mov bh, al
0085+  1105 F6            lodsb
0086+  1106 2F            mov bl, al
0087+  1107 07 D3 10      call _atoi        ; convert ascii byte in b to int (to al)
0088+  110A F7            stosb          ; store al to [di]
0089+  110B 0A FE 10      jmp _hex_to_int_l1
0090+  110E             _hex_to_int_ret:
0091+  110E 09            ret    
0092+  110F             
0093+  110F             
0094+  110F             
0095+  110F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  110F             ; getchar
0097+  110F             ; char in ah
0098+  110F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  110F             getch:
0100+  110F DB            push al
0101+  1110             getch_retry:
0102+  1110 19 01         mov al, 1
0103+  1112 05 03         syscall sys_io      ; receive in ah
0104+  1114 E8            pop al
0105+  1115 09            ret
0106+  1116             
0107+  1116             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1116             ; putchar
0109+  1116             ; char in ah
0110+  1116             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1116             _putchar:
0112+  1116 DB            push al
0113+  1117 19 00         mov al, 0
0114+  1119 05 03         syscall sys_io      ; char in ah
0115+  111B E8            pop al
0116+  111C 09            ret
0117+  111D             
0118+  111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  111D             ;; input a string
0120+  111D             ;; terminates with null
0121+  111D             ;; pointer in d
0122+  111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  111D             _gets:
0124+  111D D7            push a
0125+  111E DA            push d
0126+  111F             _gets_loop:
0127+  111F 19 01         mov al, 1
0128+  1121 05 03         syscall sys_io      ; receive in ah
0129+  1123 76 1B         cmp ah, 27
0130+  1125 C6 46 11      je _gets_ansi_esc
0131+  1128 76 0A         cmp ah, $0a        ; lf
0132+  112A C6 A2 11      je _gets_end
0133+  112D 76 0D         cmp ah, $0d        ; cr
0134+  112F C6 A2 11      je _gets_end
0135+  1132 76 5C         cmp ah, $5c        ; '\\'
0136+  1134 C6 68 11      je _gets_escape
0137+  1137 76 08         cmp ah, $08      ; check for backspace
0138+  1139 C6 42 11      je _gets_backspace
0139+  113C 1A            mov al, ah
0140+  113D 3E            mov [d], al
0141+  113E 79            inc d
0142+  113F 0A 1F 11      jmp _gets_loop
0143+  1142             _gets_backspace:
0144+  1142 7F            dec d
0145+  1143 0A 1F 11      jmp _gets_loop
0146+  1146             _gets_ansi_esc:
0147+  1146 19 01         mov al, 1
0148+  1148 05 03         syscall sys_io        ; receive in ah without echo
0149+  114A 76 5B         cmp ah, '['
0150+  114C C7 1F 11      jne _gets_loop
0151+  114F 19 01         mov al, 1
0152+  1151 05 03         syscall sys_io          ; receive in ah without echo
0153+  1153 76 64         cmp ah, 'd'
0154+  1155 C6 60 11      je _gets_left_arrow
0155+  1158 76 63         cmp ah, 'c'
0156+  115A C6 64 11      je _gets_right_arrow
0157+  115D 0A 1F 11      jmp _gets_loop
0158+  1160             _gets_left_arrow:
0159+  1160 7F            dec d
0160+  1161 0A 1F 11      jmp _gets_loop
0161+  1164             _gets_right_arrow:
0162+  1164 79            inc d
0163+  1165 0A 1F 11      jmp _gets_loop
0164+  1168             _gets_escape:
0165+  1168 19 01         mov al, 1
0166+  116A 05 03         syscall sys_io      ; receive in ah
0167+  116C 76 6E         cmp ah, 'n'
0168+  116E C6 8D 11      je _gets_lf
0169+  1171 76 72         cmp ah, 'r'
0170+  1173 C6 94 11      je _gets_cr
0171+  1176 76 30         cmp ah, '0'
0172+  1178 C6 9B 11      je _gets_null
0173+  117B 76 5C         cmp ah, $5c  ; '\'
0174+  117D C6 86 11      je _gets_slash
0175+  1180 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1181 3E            mov [d], al
0177+  1182 79            inc d
0178+  1183 0A 1F 11      jmp _gets_loop
0179+  1186             _gets_slash:
0180+  1186 19 5C         mov al, $5c
0181+  1188 3E            mov [d], al
0182+  1189 79            inc d
0183+  118A 0A 1F 11      jmp _gets_loop
0184+  118D             _gets_lf:
0185+  118D 19 0A         mov al, $0a
0186+  118F 3E            mov [d], al
0187+  1190 79            inc d
0188+  1191 0A 1F 11      jmp _gets_loop
0189+  1194             _gets_cr:
0190+  1194 19 0D         mov al, $0d
0191+  1196 3E            mov [d], al
0192+  1197 79            inc d
0193+  1198 0A 1F 11      jmp _gets_loop
0194+  119B             _gets_null:
0195+  119B 19 00         mov al, $00
0196+  119D 3E            mov [d], al
0197+  119E 79            inc d
0198+  119F 0A 1F 11      jmp _gets_loop
0199+  11A2             _gets_end:
0200+  11A2 19 00         mov al, 0
0201+  11A4 3E            mov [d], al        ; terminate string
0202+  11A5 E7            pop d
0203+  11A6 E4            pop a
0204+  11A7 09            ret
0205+  11A8             
0206+  11A8             
0207+  11A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11A8             ;; input text
0209+  11A8             ;; terminated with ctrl+d
0210+  11A8             ;; pointer in d
0211+  11A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11A8             _gettxt:
0213+  11A8 D7            push a
0214+  11A9 DA            push d
0215+  11AA             _gettxt_loop:
0216+  11AA 19 01         mov al, 1
0217+  11AC 05 03         syscall sys_io      ; receive in ah
0218+  11AE 76 04         cmp ah, 4      ; eot
0219+  11B0 C6 E9 11      je _gettxt_end
0220+  11B3 76 08         cmp ah, $08      ; check for backspace
0221+  11B5 C6 E5 11      je _gettxt_backspace
0222+  11B8 76 5C         cmp ah, $5c        ; '\'
0223+  11BA C6 C3 11      je _gettxt_escape
0224+  11BD 1A            mov al, ah
0225+  11BE 3E            mov [d], al
0226+  11BF 79            inc d
0227+  11C0 0A AA 11      jmp _gettxt_loop
0228+  11C3             _gettxt_escape:
0229+  11C3 19 01         mov al, 1
0230+  11C5 05 03         syscall sys_io      ; receive in ah
0231+  11C7 76 6E         cmp ah, 'n'
0232+  11C9 C6 D7 11      je _gettxt_lf
0233+  11CC 76 72         cmp ah, 'r'
0234+  11CE C6 DE 11      je _gettxt_cr
0235+  11D1 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11D2 3E            mov [d], al
0237+  11D3 79            inc d
0238+  11D4 0A AA 11      jmp _gettxt_loop
0239+  11D7             _gettxt_lf:
0240+  11D7 19 0A         mov al, $0a
0241+  11D9 3E            mov [d], al
0242+  11DA 79            inc d
0243+  11DB 0A AA 11      jmp _gettxt_loop
0244+  11DE             _gettxt_cr:
0245+  11DE 19 0D         mov al, $0d
0246+  11E0 3E            mov [d], al
0247+  11E1 79            inc d
0248+  11E2 0A AA 11      jmp _gettxt_loop
0249+  11E5             _gettxt_backspace:
0250+  11E5 7F            dec d
0251+  11E6 0A AA 11      jmp _gettxt_loop
0252+  11E9             _gettxt_end:
0253+  11E9 19 00         mov al, 0
0254+  11EB 3E            mov [d], al        ; terminate string
0255+  11EC E7            pop d
0256+  11ED E4            pop a
0257+  11EE 09            ret
0258+  11EF             
0259+  11EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11EF             ; print new line
0261+  11EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11EF             printnl:
0263+  11EF D7            push a
0264+  11F0 10 00 0A      mov a, $0a00
0265+  11F3 05 03         syscall sys_io
0266+  11F5 10 00 0D      mov a, $0d00
0267+  11F8 05 03         syscall sys_io
0268+  11FA E4            pop a
0269+  11FB 09            ret
0270+  11FC             
0271+  11FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  11FC             ; _strtoint
0273+  11FC             ; 4 digit hex string number in d
0274+  11FC             ; integer returned in a
0275+  11FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11FC             _strtointx:
0277+  11FC D8            push b
0278+  11FD 32            mov bl, [d]
0279+  11FE 37            mov bh, bl
0280+  11FF 33 01 00      mov bl, [d + 1]
0281+  1202 07 D3 10      call _atoi        ; convert to int in al
0282+  1205 23            mov ah, al        ; move to ah
0283+  1206 33 02 00      mov bl, [d + 2]
0284+  1209 37            mov bh, bl
0285+  120A 33 03 00      mov bl, [d + 3]
0286+  120D 07 D3 10      call _atoi        ; convert to int in al
0287+  1210 E5            pop b
0288+  1211 09            ret
0289+  1212             
0290+  1212             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1212             ; _strtoint
0292+  1212             ; 5 digit base10 string number in d
0293+  1212             ; integer returned in a
0294+  1212             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1212             _strtoint:
0296+  1212 E2            push si
0297+  1213 D8            push b
0298+  1214 D9            push c
0299+  1215 DA            push d
0300+  1216 07 75 10      call _strlen      ; get string length in c
0301+  1219 7E            dec c
0302+  121A FD 4E         mov si, d
0303+  121C 12            mov a, c
0304+  121D FD 99         shl a
0305+  121F 3B 96 13      mov d, table_power
0306+  1222 59            add d, a
0307+  1223 38 00 00      mov c, 0
0308+  1226             _strtoint_l0:
0309+  1226 F6            lodsb      ; load ascii to al
0310+  1227 B9 00         cmp al, 0
0311+  1229 C6 3C 12      je _strtoint_end
0312+  122C 6F 30         sub al, $30    ; make into integer
0313+  122E 22 00         mov ah, 0
0314+  1230 2A            mov b, [d]
0315+  1231 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1232 11            mov a, b
0317+  1233 28            mov b, c
0318+  1234 54            add a, b
0319+  1235 39            mov c, a
0320+  1236 63 02 00      sub d, 2
0321+  1239 0A 26 12      jmp _strtoint_l0
0322+  123C             _strtoint_end:
0323+  123C 12            mov a, c
0324+  123D E7            pop d
0325+  123E E6            pop c
0326+  123F E5            pop b
0327+  1240 EF            pop si
0328+  1241 09            ret
0329+  1242             
0330+  1242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1242             ; print null terminated string
0332+  1242             ; pointer in d
0333+  1242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1242             _puts:
0335+  1242 D7            push a
0336+  1243 DA            push d
0337+  1244             _puts_l1:
0338+  1244 1E            mov al, [d]
0339+  1245 B9 00         cmp al, 0
0340+  1247 C6 53 12      jz _puts_end
0341+  124A 23            mov ah, al
0342+  124B 19 00         mov al, 0
0343+  124D 05 03         syscall sys_io
0344+  124F 79            inc d
0345+  1250 0A 44 12      jmp _puts_l1
0346+  1253             _puts_end:
0347+  1253 E7            pop d
0348+  1254 E4            pop a
0349+  1255 09            ret
0350+  1256             
0351+  1256             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1256             ; print n size string
0353+  1256             ; pointer in d
0354+  1256             ; size in c
0355+  1256             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1256             _putsn:
0357+  1256 DB            push al
0358+  1257 DA            push d
0359+  1258 D9            push c
0360+  1259             _putsn_l0:
0361+  1259 1E            mov al, [d]
0362+  125A 23            mov ah, al
0363+  125B 19 00         mov al, 0
0364+  125D 05 03         syscall sys_io
0365+  125F 79            inc d
0366+  1260 7E            dec c  
0367+  1261 C2 00 00      cmp c, 0
0368+  1264 C7 59 12      jne _putsn_l0
0369+  1267             _putsn_end:
0370+  1267 E6            pop c
0371+  1268 E7            pop d
0372+  1269 E8            pop al
0373+  126A 09            ret
0374+  126B             
0375+  126B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  126B             ; print 16bit decimal number
0377+  126B             ; input number in a
0378+  126B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  126B             print_u16d:
0380+  126B D7            push a
0381+  126C D8            push b
0382+  126D FD D8         push g
0383+  126F 26 10 27      mov b, 10000
0384+  1272 AE            div a, b      ; get 10000's coeff.
0385+  1273 07 97 12      call print_number
0386+  1276 11            mov a, b
0387+  1277 26 E8 03      mov b, 1000
0388+  127A AE            div a, b      ; get 1000's coeff.
0389+  127B 07 97 12      call print_number
0390+  127E 11            mov a, b
0391+  127F 26 64 00      mov b, 100
0392+  1282 AE            div a, b
0393+  1283 07 97 12      call print_number
0394+  1286 11            mov a, b
0395+  1287 26 0A 00      mov b, 10
0396+  128A AE            div a, b
0397+  128B 07 97 12      call print_number
0398+  128E 1B            mov al, bl      ; 1's coeff in bl
0399+  128F 07 97 12      call print_number
0400+  1292 FD F1         pop g
0401+  1294 E5            pop b
0402+  1295 E4            pop a
0403+  1296 09            ret
0404+  1297             
0405+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1297             ; print al
0407+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1297             print_number:
0409+  1297 6A 30         add al, $30
0410+  1299 23            mov ah, al
0411+  129A 07 16 11      call _putchar
0412+  129D 09            ret
0413+  129E             
0414+  129E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  129E             ; print 16bit hex integer
0416+  129E             ; integer value in reg b
0417+  129E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  129E             print_u16x:
0419+  129E D7            push a
0420+  129F D8            push b
0421+  12A0 DD            push bl
0422+  12A1 30            mov bl, bh
0423+  12A2 07 E4 10      call _itoa        ; convert bh to char in a
0424+  12A5 2F            mov bl, al        ; save al
0425+  12A6 19 00         mov al, 0
0426+  12A8 05 03         syscall sys_io        ; display ah
0427+  12AA 24            mov ah, bl        ; retrieve al
0428+  12AB 19 00         mov al, 0
0429+  12AD 05 03         syscall sys_io        ; display al
0430+  12AF             
0431+  12AF EA            pop bl
0432+  12B0 07 E4 10      call _itoa        ; convert bh to char in a
0433+  12B3 2F            mov bl, al        ; save al
0434+  12B4 19 00         mov al, 0
0435+  12B6 05 03         syscall sys_io        ; display ah
0436+  12B8 24            mov ah, bl        ; retrieve al
0437+  12B9 19 00         mov al, 0
0438+  12BB 05 03         syscall sys_io        ; display al
0439+  12BD             
0440+  12BD E5            pop b
0441+  12BE E4            pop a
0442+  12BF 09            ret
0443+  12C0             
0444+  12C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12C0             ; input 16bit hex integer
0446+  12C0             ; read 16bit integer into a
0447+  12C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12C0             scan_u16x:
0449+  12C0 F8 10 00      enter 16
0450+  12C3 D8            push b
0451+  12C4 DA            push d
0452+  12C5             
0453+  12C5 FA F1 FF      lea d, [bp + -15]
0454+  12C8 07 1D 11      call _gets        ; get number
0455+  12CB             
0456+  12CB 32            mov bl, [d]
0457+  12CC 37            mov bh, bl
0458+  12CD 33 01 00      mov bl, [d + 1]
0459+  12D0 07 D3 10      call _atoi        ; convert to int in al
0460+  12D3 23            mov ah, al        ; move to ah
0461+  12D4             
0462+  12D4 33 02 00      mov bl, [d + 2]
0463+  12D7 37            mov bh, bl
0464+  12D8 33 03 00      mov bl, [d + 3]
0465+  12DB 07 D3 10      call _atoi        ; convert to int in al
0466+  12DE             
0467+  12DE E7            pop d
0468+  12DF E5            pop b
0469+  12E0 F9            leave
0470+  12E1 09            ret
0471+  12E2             
0472+  12E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12E2             ; print 8bit hex integer
0474+  12E2             ; integer value in reg bl
0475+  12E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12E2             print_u8x:
0477+  12E2 D7            push a
0478+  12E3 DD            push bl
0479+  12E4             
0480+  12E4 07 E4 10      call _itoa        ; convert bl to char in a
0481+  12E7 2F            mov bl, al        ; save al
0482+  12E8 19 00         mov al, 0
0483+  12EA 05 03         syscall sys_io        ; display ah
0484+  12EC 24            mov ah, bl        ; retrieve al
0485+  12ED 19 00         mov al, 0
0486+  12EF 05 03         syscall sys_io        ; display al
0487+  12F1             
0488+  12F1 EA            pop bl
0489+  12F2 E4            pop a
0490+  12F3 09            ret
0491+  12F4             
0492+  12F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12F4             ; print 8bit decimal unsigned number
0494+  12F4             ; input number in al
0495+  12F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12F4             print_u8d:
0497+  12F4 D7            push a
0498+  12F5 D8            push b
0499+  12F6 FD D8         push g
0500+  12F8 22 00         mov ah, 0
0501+  12FA 26 64 00      mov b, 100
0502+  12FD AE            div a, b
0503+  12FE D8            push b      ; save remainder
0504+  12FF B9 00         cmp al, 0
0505+  1301 C6 0B 13      je skip100
0506+  1304 6A 30         add al, $30
0507+  1306 23            mov ah, al
0508+  1307 19 00         mov al, 0
0509+  1309 05 03         syscall sys_io  ; print coeff
0510+  130B             skip100:
0511+  130B E4            pop a
0512+  130C 22 00         mov ah, 0
0513+  130E 26 0A 00      mov b, 10
0514+  1311 AE            div a, b
0515+  1312 D8            push b      ; save remainder
0516+  1313 B9 00         cmp al, 0
0517+  1315 C6 1F 13      je skip10
0518+  1318 6A 30         add al, $30
0519+  131A 23            mov ah, al
0520+  131B 19 00         mov al, 0
0521+  131D 05 03         syscall sys_io  ; print coeff
0522+  131F             skip10:
0523+  131F E4            pop a
0524+  1320 1B            mov al, bl
0525+  1321 6A 30         add al, $30
0526+  1323 23            mov ah, al
0527+  1324 19 00         mov al, 0
0528+  1326 05 03         syscall sys_io  ; print coeff
0529+  1328 FD F1         pop g
0530+  132A E5            pop b
0531+  132B E4            pop a
0532+  132C 09            ret
0533+  132D             
0534+  132D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  132D             ; input 8bit hex integer
0536+  132D             ; read 8bit integer into al
0537+  132D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  132D             scan_u8x:
0539+  132D F8 04 00      enter 4
0540+  1330 D8            push b
0541+  1331 DA            push d
0542+  1332             
0543+  1332 FA FD FF      lea d, [bp + -3]
0544+  1335 07 1D 11      call _gets        ; get number
0545+  1338             
0546+  1338 32            mov bl, [d]
0547+  1339 37            mov bh, bl
0548+  133A 33 01 00      mov bl, [d + 1]
0549+  133D 07 D3 10      call _atoi        ; convert to int in al
0550+  1340             
0551+  1340 E7            pop d
0552+  1341 E5            pop b
0553+  1342 F9            leave
0554+  1343 09            ret
0555+  1344             
0556+  1344             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1344             ; input decimal number
0558+  1344             ; result in a
0559+  1344             ; 655'\0'
0560+  1344             ; low--------high
0561+  1344             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1344             scan_u16d:
0563+  1344 F8 08 00      enter 8
0564+  1347 E2            push si
0565+  1348 D8            push b
0566+  1349 D9            push c
0567+  134A DA            push d
0568+  134B FA F9 FF      lea d, [bp +- 7]
0569+  134E 07 1D 11      call _gets
0570+  1351 07 75 10      call _strlen      ; get string length in c
0571+  1354 7E            dec c
0572+  1355 FD 4E         mov si, d
0573+  1357 12            mov a, c
0574+  1358 FD 99         shl a
0575+  135A 3B 96 13      mov d, table_power
0576+  135D 59            add d, a
0577+  135E 38 00 00      mov c, 0
0578+  1361             mul_loop:
0579+  1361 F6            lodsb      ; load ascii to al
0580+  1362 B9 00         cmp al, 0
0581+  1364 C6 77 13      je mul_exit
0582+  1367 6F 30         sub al, $30    ; make into integer
0583+  1369 22 00         mov ah, 0
0584+  136B 2A            mov b, [d]
0585+  136C AC            mul a, b      ; result in b since it fits in 16bits
0586+  136D 11            mov a, b
0587+  136E 28            mov b, c
0588+  136F 54            add a, b
0589+  1370 39            mov c, a
0590+  1371 63 02 00      sub d, 2
0591+  1374 0A 61 13      jmp mul_loop
0592+  1377             mul_exit:
0593+  1377 12            mov a, c
0594+  1378 E7            pop d
0595+  1379 E6            pop c
0596+  137A E5            pop b
0597+  137B EF            pop si
0598+  137C F9            leave
0599+  137D 09            ret
0600+  137E             
0601+  137E             
0602+  137E 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  1382 34 35 36 37 
0602+  1386 38 39 61 62 
0602+  138A 63 64 65 66 
0603+  138E 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  1392 1B 5B 68 00 
0604+  1396             
0605+  1396             table_power:
0606+  1396 01 00         .dw 1
0607+  1398 0A 00         .dw 10
0608+  139A 64 00         .dw 100
0609+  139C E8 03         .dw 1000
0610+  139E 10 27         .dw 100002726   13A0             .include "lib/ctype.asm"
0001+  13A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13A0             ; ctype.s
0003+  13A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13A0             
0005+  13A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13A0             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  13A0             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  13A0             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  13A0             ;; characters are supported.
0010+  13A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13A0             ;; _isalnum 
0012+  13A0             ;; _isalpha 
0013+  13A0             ;; islower 
0014+  13A0             ;; isupper 
0015+  13A0             ;; _isdigit 
0016+  13A0             ;; isxdigit
0017+  13A0             ;; iscntrl 
0018+  13A0             ;; isgraph 
0019+  13A0             ;; _isspace 
0020+  13A0             ;; isblank 
0021+  13A0             ;; isprint 
0022+  13A0             ;; ispunct 
0023+  13A0             ;; tolower 
0024+  13A0             ;; toupper
0025+  13A0             
0026+  13A0             
0027+  13A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13A0             ;; is alphanumeric
0029+  13A0             ;; sets zf according with result
0030+  13A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13A0             _isalnum:
0032+  13A0 07 BD 13    	call _isalpha
0033+  13A3 C6 A9 13    	je _isalnum_exit
0034+  13A6 07 AA 13    	call _isdigit
0035+  13A9             _isalnum_exit:
0036+  13A9 09          	ret	
0037+  13AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13AA             ;; is digit
0039+  13AA             ;; sets zf according with result
0040+  13AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13AA             _isdigit:
0042+  13AA DB          	push al
0043+  13AB B9 30       	cmp al, '0'
0044+  13AD C8 B9 13    	jlu _isdigit_false
0045+  13B0 B9 39       	cmp al, '9'
0046+  13B2 D1 B9 13    	jgu _isdigit_false
0047+  13B5 87 00       	and al, 0	; set zf
0048+  13B7 E8          	pop al
0049+  13B8 09          	ret
0050+  13B9             _isdigit_false:
0051+  13B9 8B 01       	or al, 1	; clear zf
0052+  13BB E8          	pop al
0053+  13BC 09          	ret	
0054+  13BD             	
0055+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13BD             ;; is alpha
0057+  13BD             ;; sets zf according with result
0058+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13BD             _isalpha:
0060+  13BD DB          	push al
0061+  13BE B9 5F       	cmp al, '_'
0062+  13C0 C6 E0 13    	je _isalpha_true
0063+  13C3 B9 2E       	cmp al, '.'
0064+  13C5 C6 E0 13    	je _isalpha_true
0065+  13C8 B9 61       	cmp al, 'a'
0066+  13CA C8 DC 13    	jlu _isalpha_false
0067+  13CD B9 7A       	cmp al, 'z'
0068+  13CF D1 DC 13    	jgu _isalpha_false
0069+  13D2 B9 7A       	cmp al, 'z'
0070+  13D4 D0 E0 13    	jleu _isalpha_true
0071+  13D7 B9 61       	cmp al, 'a'
0072+  13D9 C9 E0 13    	jgeu _isalpha_true
0073+  13DC             _isalpha_false:
0074+  13DC 8B 01       	or al, 1	; clear zf
0075+  13DE E8          	pop al
0076+  13DF 09          	ret
0077+  13E0             _isalpha_true:
0078+  13E0 87 00       	and al, 0	; set zf
0079+  13E2 E8          	pop al
0080+  13E3 09          	ret
0081+  13E4             
0082+  13E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13E4             ;; is path-alpha
0084+  13E4             ;; sets zf according with result
0085+  13E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13E4             ispath:
0087+  13E4 DB          	push al
0088+  13E5 07 AA 13    	call _isdigit
0089+  13E8 C6 12 14    	je ispath_true
0090+  13EB B9 5F       	cmp al, '_'
0091+  13ED C6 12 14    	je ispath_true
0092+  13F0 B9 2F       	cmp al, '/'
0093+  13F2 C6 12 14    	je ispath_true
0094+  13F5 B9 2E       	cmp al, '.'
0095+  13F7 C6 12 14    	je ispath_true
0096+  13FA B9 61       	cmp al, 'a'
0097+  13FC C8 0E 14    	jlu ispath_false
0098+  13FF B9 7A       	cmp al, 'z'
0099+  1401 D1 0E 14    	jgu ispath_false
0100+  1404 B9 7A       	cmp al, 'z'
0101+  1406 D0 12 14    	jleu ispath_true
0102+  1409 B9 61       	cmp al, 'a'
0103+  140B C9 12 14    	jgeu ispath_true
0104+  140E             ispath_false:
0105+  140E 8B 01       	or al, 1	; clear zf
0106+  1410 E8          	pop al
0107+  1411 09          	ret
0108+  1412             ispath_true:
0109+  1412 87 00       	and al, 0	; set zf
0110+  1414 E8          	pop al
0111+  1415 09          	ret
0112+  1416             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1416             ;; is space
0114+  1416             ;; sets zf according with result
0115+  1416             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1416             _isspace:
0117+  1416 B9 20       	cmp al, $20		; ' '
0118+  1418 C6 2C 14    	je _isspace_exit
0119+  141B B9 09       	cmp al, $09		; '\t'
0120+  141D C6 2C 14    	je _isspace_exit
0121+  1420 B9 0A       	cmp al, $0a		; '\n'
0122+  1422 C6 2C 14    	je _isspace_exit
0123+  1425 B9 0D       	cmp al, $0d		; '\r'
0124+  1427 C6 2C 14    	je _isspace_exit
0125+  142A B9 0B       	cmp al, $0b		; '\v'
0126+  142C             _isspace_exit:
0127+  142C 09          	ret	
0128+  142D             
0129+  142D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  142D             ; to lower
0131+  142D             ; input in al
0132+  142D             ; output in al
0133+  142D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  142D             _to_lower:
0135+  142D B9 7A       	cmp al, 'z'
0136+  142F D1 34 14    	jgu _to_lower_ret
0137+  1432 6A 20       	add al, $20				; convert to lower case
0138+  1434             _to_lower_ret:
0139+  1434 09          	ret
0140+  1435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1435             ; to upper
0142+  1435             ; input in al
0143+  1435             ; output in al
0144+  1435             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1435             _to_upper:
0146+  1435 B9 61       	cmp al, 'a'
0147+  1437 C8 3C 14    	jlu _to_upper_ret
0148+  143A 6F 20       	sub al, $20			; convert to upper case
0149+  143C             _to_upper_ret:
0150+  143C 09          	ret
0151+  143D             
2727   143D             .include "lib/token.asm"
0001+  143D             toktyp_identifier  .equ 0
0002+  143D             toktyp_keyword     .equ 1
0003+  143D             toktyp_delimiter   .equ 2
0004+  143D             toktyp_string      .equ 3
0005+  143D             toktyp_char        .equ 4
0006+  143D             toktyp_numeric     .equ 5
0007+  143D             toktyp_end         .equ 6
0008+  143D             
0009+  143D             tok_null           .equ 0
0010+  143D             tok_fslash         .equ 1
0011+  143D             tok_times          .equ 2
0012+  143D             tok_plus           .equ 3
0013+  143D             tok_minus          .equ 4
0014+  143D             tok_dot            .equ 5
0015+  143D             tok_semi           .equ 6
0016+  143D             tok_angle          .equ 7
0017+  143D             tok_tilde          .equ 8
0018+  143D             tok_equal          .equ 9
0019+  143D             tok_colon          .equ 10
0020+  143D             tok_comma          .equ 11
0021+  143D             
0022+  143D             tok_end            .equ 20
0023+  143D             
0024+  143D             
0025+  143D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  143D             ;; read a full command argment from shell input buffer
0027+  143D             ;; argument is written into tokstr
0028+  143D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  143D             get_arg:
0030+  143D D7            push a
0031+  143E E2            push si
0032+  143F E3            push di
0033+  1440 19 00         mov al, 0
0034+  1442 3D 6B 16      mov [tokstr], al      ; nullify tokstr string
0035+  1445 14 67 16      mov a, [prog]
0036+  1448 4D            mov si, a
0037+  1449 FD 4F 6B 16   mov di, tokstr
0038+  144D             get_arg_skip_spaces:
0039+  144D F6            lodsb
0040+  144E 07 16 14      call _isspace
0041+  1451 C6 4D 14      je get_arg_skip_spaces
0042+  1454             get_arg_l0:
0043+  1454 B9 3B         cmp al, $3b        ; check if is ';'
0044+  1456 C6 63 14      je get_arg_end
0045+  1459 B9 00         cmp al, 0
0046+  145B C6 63 14      je get_arg_end      ; check if end of input
0047+  145E F7            stosb
0048+  145F F6            lodsb
0049+  1460 0A 54 14      jmp get_arg_l0
0050+  1463             get_arg_end:
0051+  1463 19 00         mov al, 0
0052+  1465 F7            stosb
0053+  1466 D5 01 00      sub si, 1
0054+  1469 4E            mov a, si
0055+  146A 42 67 16      mov [prog], a    ; update pointer
0056+  146D F0            pop di
0057+  146E EF            pop si
0058+  146F E4            pop a
0059+  1470 09            ret
0060+  1471             
0061+  1471             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1471             ;; read a path formation from shell input buffer
0063+  1471             ;; path is written into tokstr
0064+  1471             ;; /usr/bin
0065+  1471             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1471             get_path:
0067+  1471 D7            push a
0068+  1472 E2            push si
0069+  1473 E3            push di
0070+  1474 19 00         mov al, 0
0071+  1476 3D 6B 16      mov [tokstr], al      ; nullify tokstr string
0072+  1479 14 67 16      mov a, [prog]
0073+  147C 4D            mov si, a
0074+  147D FD 4F 6B 16   mov di, tokstr
0075+  1481             get_path_skip_spaces:
0076+  1481 F6            lodsb
0077+  1482 07 16 14      call _isspace
0078+  1485 C6 81 14      je get_path_skip_spaces
0079+  1488             get_path_is_pathchar:
0080+  1488 F7            stosb
0081+  1489 F6            lodsb
0082+  148A 07 A0 13      call _isalnum      ;check if is alphanumeric
0083+  148D C6 88 14      je get_path_is_pathchar
0084+  1490 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1492 C6 88 14      je get_path_is_pathchar
0086+  1495 19 00         mov al, 0
0087+  1497 F7            stosb
0088+  1498 D5 01 00      sub si, 1
0089+  149B 4E            mov a, si
0090+  149C 42 67 16      mov [prog], a    ; update pointer
0091+  149F             get_path_end:
0092+  149F F0            pop di
0093+  14A0 EF            pop si
0094+  14A1 E4            pop a
0095+  14A2 09            ret
0096+  14A3             
0097+  14A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14A3             ;; read a line
0099+  14A3             ;; line is written into tokstr
0100+  14A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14A3             get_line:
0102+  14A3 D7            push a
0103+  14A4 E2            push si
0104+  14A5 E3            push di
0105+  14A6 19 00         mov al, 0
0106+  14A8 3D 6B 16      mov [tokstr], al      ; nullify tokstr string
0107+  14AB 14 67 16      mov a, [prog]
0108+  14AE 4D            mov si, a
0109+  14AF FD 4F 6B 16   mov di, tokstr
0110+  14B3             get_line_l0:
0111+  14B3 F6            lodsb
0112+  14B4 B9 0A         cmp al, $0a    ; check for new line
0113+  14B6 C6 BD 14      je get_line_exit
0114+  14B9 F7            stosb
0115+  14BA 0A B3 14      jmp get_line_l0
0116+  14BD             get_line_exit:
0117+  14BD 19 00         mov al, 0
0118+  14BF F7            stosb
0119+  14C0 4E            mov a, si
0120+  14C1 42 67 16      mov [prog], a    ; update pointer
0121+  14C4 F0            pop di
0122+  14C5 EF            pop si
0123+  14C6 E4            pop a
0124+  14C7 09            ret
0125+  14C8             
0126+  14C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14C8             ;; token parser
0128+  14C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14C8             get_token:
0130+  14C8 D7            push a
0131+  14C9 DA            push d
0132+  14CA E2            push si
0133+  14CB E3            push di
0134+  14CC 19 00         mov al, 0
0135+  14CE 3D 6B 16      mov [tokstr], al      ; nullify tokstr string
0136+  14D1 19 00         mov al, tok_null
0137+  14D3 3D 6A 16      mov [tok], al        ; nullify token
0138+  14D6 14 67 16      mov a, [prog]
0139+  14D9 4D            mov si, a
0140+  14DA FD 4F 6B 16   mov di, tokstr
0141+  14DE             get_tok_skip_spaces:
0142+  14DE F6            lodsb
0143+  14DF 07 16 14      call _isspace
0144+  14E2 C6 DE 14      je get_tok_skip_spaces
0145+  14E5 B9 00         cmp al, 0      ; check for end of input (null)
0146+  14E7 C6 CC 15      je get_token_end
0147+  14EA B9 23         cmp al, '#'      ; comments!
0148+  14EC C6 FA 15      je get_tok_comment
0149+  14EF 07 A0 13      call _isalnum
0150+  14F2 C6 D9 15      jz is_alphanumeric
0151+  14F5             ; other token types
0152+  14F5             get_token_slash:
0153+  14F5 B9 2F         cmp al, '/'        ; check if '/'
0154+  14F7 C7 0F 15      jne get_token_minus
0155+  14FA F7            stosb          ; store '/' into token string
0156+  14FB 19 00         mov al, 0
0157+  14FD F7            stosb          ; terminate token string
0158+  14FE 19 01         mov al, tok_fslash
0159+  1500 3D 6A 16      mov [tok], al      
0160+  1503 19 02         mov al, toktyp_delimiter
0161+  1505 3D 69 16      mov [toktyp], al
0162+  1508 4E            mov a, si
0163+  1509 42 67 16      mov [prog], a    ; update pointer
0164+  150C 0A F5 15      jmp get_token_return
0165+  150F             get_token_minus:
0166+  150F B9 2D         cmp al, '-'        ; check if '-'
0167+  1511 C7 29 15      jne get_token_comma
0168+  1514 F7            stosb          ; store '-' into token string
0169+  1515 19 00         mov al, 0
0170+  1517 F7            stosb          ; terminate token string
0171+  1518 19 04         mov al, tok_minus
0172+  151A 3D 6A 16      mov [tok], al      
0173+  151D 19 02         mov al, toktyp_delimiter
0174+  151F 3D 69 16      mov [toktyp], al
0175+  1522 4E            mov a, si
0176+  1523 42 67 16      mov [prog], a    ; update pointer
0177+  1526 0A F5 15      jmp get_token_return
0178+  1529             get_token_comma:
0179+  1529 B9 2C         cmp al, ','        ; check if ','
0180+  152B C7 43 15      jne get_token_semi
0181+  152E F7            stosb          ; store ',' into token string
0182+  152F 19 00         mov al, 0
0183+  1531 F7            stosb          ; terminate token string
0184+  1532 19 0B         mov al, tok_comma
0185+  1534 3D 6A 16      mov [tok], al      
0186+  1537 19 02         mov al, toktyp_delimiter
0187+  1539 3D 69 16      mov [toktyp], al
0188+  153C 4E            mov a, si
0189+  153D 42 67 16      mov [prog], a    ; update pointer
0190+  1540 0A F5 15      jmp get_token_return
0191+  1543             get_token_semi:
0192+  1543 B9 3B         cmp al, $3b        ; check if ';'
0193+  1545 C7 5D 15      jne get_token_colon
0194+  1548 F7            stosb          ; store ';' into token string
0195+  1549 19 00         mov al, 0
0196+  154B F7            stosb          ; terminate token string
0197+  154C 19 06         mov al, tok_semi
0198+  154E 3D 6A 16      mov [tok], al      
0199+  1551 19 02         mov al, toktyp_delimiter
0200+  1553 3D 69 16      mov [toktyp], al
0201+  1556 4E            mov a, si
0202+  1557 42 67 16      mov [prog], a    ; update pointer
0203+  155A 0A F5 15      jmp get_token_return
0204+  155D             get_token_colon:
0205+  155D B9 3A         cmp al, $3a        ; check if ':'
0206+  155F C7 77 15      jne get_token_angle
0207+  1562 F7            stosb          ; store ':' into token string
0208+  1563 19 00         mov al, 0
0209+  1565 F7            stosb          ; terminate token string
0210+  1566 19 0A         mov al, tok_colon
0211+  1568 3D 6A 16      mov [tok], al      
0212+  156B 19 02         mov al, toktyp_delimiter
0213+  156D 3D 69 16      mov [toktyp], al
0214+  1570 4E            mov a, si
0215+  1571 42 67 16      mov [prog], a    ; update pointer
0216+  1574 0A F5 15      jmp get_token_return
0217+  1577             get_token_angle:
0218+  1577 B9 3E         cmp al, $3e        ; check if '>'
0219+  1579 C7 91 15      jne get_token_tilde
0220+  157C F7            stosb          ; store '>' into token string
0221+  157D 19 00         mov al, 0
0222+  157F F7            stosb          ; terminate token string
0223+  1580 19 07         mov al, tok_angle
0224+  1582 3D 6A 16      mov [tok], al      
0225+  1585 19 02         mov al, toktyp_delimiter
0226+  1587 3D 69 16      mov [toktyp], al
0227+  158A 4E            mov a, si
0228+  158B 42 67 16      mov [prog], a    ; update pointer
0229+  158E 0A F5 15      jmp get_token_return
0230+  1591             get_token_tilde:
0231+  1591 B9 7E         cmp al, '~'        ; check if '~'
0232+  1593 C7 AB 15      jne get_token_equal
0233+  1596 F7            stosb          ; store '~' into token string
0234+  1597 19 00         mov al, 0
0235+  1599 F7            stosb          ; terminate token string
0236+  159A 19 08         mov al, tok_tilde
0237+  159C 3D 6A 16      mov [tok], al      
0238+  159F 19 02         mov al, toktyp_delimiter
0239+  15A1 3D 69 16      mov [toktyp], al
0240+  15A4 4E            mov a, si
0241+  15A5 42 67 16      mov [prog], a    ; update pointer
0242+  15A8 0A F5 15      jmp get_token_return
0243+  15AB             get_token_equal:
0244+  15AB B9 3D         cmp al, '='        ; check if '='
0245+  15AD C7 C5 15      jne get_token_skip
0246+  15B0 F7            stosb          ; store '=' into token string
0247+  15B1 19 00         mov al, 0
0248+  15B3 F7            stosb          ; terminate token string
0249+  15B4 19 09         mov al, tok_equal
0250+  15B6 3D 6A 16      mov [tok], al      
0251+  15B9 19 02         mov al, toktyp_delimiter
0252+  15BB 3D 69 16      mov [toktyp], al
0253+  15BE 4E            mov a, si
0254+  15BF 42 67 16      mov [prog], a    ; update pointer
0255+  15C2 0A F5 15      jmp get_token_return
0256+  15C5             get_token_skip:
0257+  15C5 4E            mov a, si
0258+  15C6 42 67 16      mov [prog], a    ; update pointer
0259+  15C9 0A F5 15      jmp get_token_return
0260+  15CC             get_token_end:        ; end of file token
0261+  15CC 19 14         mov al, tok_end
0262+  15CE 3D 6A 16      mov [tok], al
0263+  15D1 19 06         mov al, toktyp_end
0264+  15D3 3D 69 16      mov [toktyp], al
0265+  15D6 0A F5 15      jmp get_token_return
0266+  15D9             is_alphanumeric:
0267+  15D9 F7            stosb
0268+  15DA F6            lodsb
0269+  15DB 07 A0 13      call _isalnum      ;check if is alphanumeric
0270+  15DE C6 D9 15      jz is_alphanumeric
0271+  15E1 B9 2E         cmp al, $2e        ; check if is '.'
0272+  15E3 C6 D9 15      je is_alphanumeric
0273+  15E6 19 00         mov al, 0
0274+  15E8 F7            stosb
0275+  15E9 19 00         mov al, toktyp_identifier
0276+  15EB 3D 69 16      mov [toktyp], al
0277+  15EE D5 01 00      sub si, 1
0278+  15F1 4E            mov a, si
0279+  15F2 42 67 16      mov [prog], a    ; update pointer
0280+  15F5             get_token_return:
0281+  15F5 F0            pop di
0282+  15F6 EF            pop si
0283+  15F7 E7            pop d
0284+  15F8 E4            pop a
0285+  15F9 09            ret
0286+  15FA             get_tok_comment:
0287+  15FA F6            lodsb
0288+  15FB B9 0A         cmp al, $0a      ; new line
0289+  15FD C7 FA 15      jne get_tok_comment
0290+  1600 0A DE 14      jmp get_tok_skip_spaces
0291+  1603             
0292+  1603             
0293+  1603             get_number:
0294+  1603 D7            push a
0295+  1604 DA            push d
0296+  1605 E2            push si
0297+  1606 E3            push di
0298+  1607 19 00         mov al, 0
0299+  1609 3D 6B 16      mov [tokstr], al      ; nullify tokstr string
0300+  160C 19 00         mov al, tok_null
0301+  160E 3D 6A 16      mov [tok], al        ; nullify token
0302+  1611 14 67 16      mov a, [prog]
0303+  1614 4D            mov si, a
0304+  1615 FD 4F 6B 16   mov di, tokstr
0305+  1619             get_number_skip_spaces:
0306+  1619 F6            lodsb
0307+  161A 07 16 14      call _isspace
0308+  161D C6 19 16      je get_number_skip_spaces
0309+  1620 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1622 C7 32 16      jne get_number_l0
0311+  1625 19 14         mov al, tok_end
0312+  1627 3D 6A 16      mov [tok], al
0313+  162A 19 06         mov al, toktyp_end
0314+  162C 3D 69 16      mov [toktyp], al
0315+  162F 0A 49 16      jmp get_number_return
0316+  1632             get_number_l0:
0317+  1632 F7            stosb
0318+  1633 F6            lodsb
0319+  1634 07 AA 13      call _isdigit      ;check if is numeric
0320+  1637 C6 32 16      jz get_number_l0
0321+  163A 19 00         mov al, 0
0322+  163C F7            stosb
0323+  163D 19 05         mov al, toktyp_numeric
0324+  163F 3D 69 16      mov [toktyp], al
0325+  1642 D5 01 00      sub si, 1
0326+  1645 4E            mov a, si
0327+  1646 42 67 16      mov [prog], a    ; update pointer
0328+  1649             get_number_return:
0329+  1649 F0            pop di
0330+  164A EF            pop si
0331+  164B E7            pop d
0332+  164C E4            pop a
0333+  164D 09            ret
0334+  164E             
0335+  164E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  164E             ;; put back token
0337+  164E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  164E             _putback:
0339+  164E D7            push a
0340+  164F E2            push si
0341+  1650 FD 4D 6B 16   mov si, tokstr  
0342+  1654             _putback_loop:
0343+  1654 F6            lodsb
0344+  1655 B9 00         cmp al, 0
0345+  1657 C6 64 16      je _putback_end
0346+  165A 14 67 16      mov a, [prog]
0347+  165D 7D            dec a
0348+  165E 42 67 16      mov [prog], a      ; update pointer
0349+  1661 0A 54 16      jmp _putback_loop
0350+  1664             _putback_end:
0351+  1664 EF            pop si
0352+  1665 E4            pop a
0353+  1666 09            ret
0354+  1667             
0355+  1667             
0356+  1667             
0357+  1667             
0358+  1667 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1669             
0360+  1669 00          toktyp:    .db 0          ; token type symbol
0361+  166A 00          tok:       .db 0          ; current token symbol
0362+  166B 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  166F 00 00 00 00 
0362+  1673 00 00 00 00 
0362+  1677 00 00 00 00 
0362+  167B 00 00 00 00 
0362+  167F 00 00 00 00 
0362+  1683 00 00 00 00 
0362+  1687 00 00 00 00 
0362+  168B 00 00 00 00 
0362+  168F 00 00 00 00 
0362+  1693 00 00 00 00 
0362+  1697 00 00 00 00 
0362+  169B 00 00 00 00 
0362+  169F 00 00 00 00 
0362+  16A3 00 00 00 00 
0362+  16A7 00 00 00 00 
0362+  16AB 00 00 00 00 
0362+  16AF 00 00 00 00 
0362+  16B3 00 00 00 00 
0362+  16B7 00 00 00 00 
0362+  16BB 00 00 00 00 
0362+  16BF 00 00 00 00 
0362+  16C3 00 00 00 00 
0362+  16C7 00 00 00 00 
0362+  16CB 00 00 00 00 
0362+  16CF 00 00 00 00 
0362+  16D3 00 00 00 00 
0362+  16D7 00 00 00 00 
0362+  16DB 00 00 00 00 
0362+  16DF 00 00 00 00 
0362+  16E3 00 00 00 00 
0362+  16E7 00 00 00 00 
0362+  16EB 00 00 00 00 
0362+  16EF 00 00 00 00 
0362+  16F3 00 00 00 00 
0362+  16F7 00 00 00 00 
0362+  16FB 00 00 00 00 
0362+  16FF 00 00 00 00 
0362+  1703 00 00 00 00 
0362+  1707 00 00 00 00 
0362+  170B 00 00 00 00 
0362+  170F 00 00 00 00 
0362+  1713 00 00 00 00 
0362+  1717 00 00 00 00 
0362+  171B 00 00 00 00 
0362+  171F 00 00 00 00 
0362+  1723 00 00 00 00 
0362+  1727 00 00 00 00 
0362+  172B 00 00 00 00 
0362+  172F 00 00 00 00 
0362+  1733 00 00 00 00 
0362+  1737 00 00 00 00 
0362+  173B 00 00 00 00 
0362+  173F 00 00 00 00 
0362+  1743 00 00 00 00 
0362+  1747 00 00 00 00 
0362+  174B 00 00 00 00 
0362+  174F 00 00 00 00 
0362+  1753 00 00 00 00 
0362+  1757 00 00 00 00 
0362+  175B 00 00 00 00 
0362+  175F 00 00 00 00 
0362+  1763 00 00 00 00 
0362+  1767 00 00 00 00 
2728   176B             
2729   176B             ; kernel parameters
2730   176B             sys_debug_mode:
2731   176B 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2732   176C             sys_echo_on:
2733   176C 01            .db 1
2734   176D             sys_uart0_lcr:
2735   176D 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2736   176E             sys_uart0_inten:
2737   176E 01            .db 1
2738   176F             sys_uart0_fifoen:
2739   176F 00            .db 0
2740   1770             sys_uart0_div0:
2741   1770 03            .db 3
2742   1771             sys_uart0_div1:
2743   1771 00            .db 0   ; default baud = 38400
2744   1772             ; baud  divisor
2745   1772             ; 50    2304
2746   1772             ; 110   1047
2747   1772             ; 300    384
2748   1772             ; 600    192
2749   1772             ; 1200    96
2750   1772             ; 9600    12
2751   1772             ; 19200    6
2752   1772             ; 38400    3
2753   1772             
2754   1772             nbr_active_procs:
2755   1772 00            .db 0
2756   1773             active_proc_index:
2757   1773 01            .db 1
2758   1774             
2759   1774             index:
2760   1774 00 00         .dw 0
2761   1776             buffer_addr:
2762   1776 00 00         .dw 0
2763   1778             
2764   1778             fifo_in:
2765   1778 D9 1E         .dw fifo
2766   177A             fifo_out:
2767   177A D9 1E         .dw fifo
2768   177C             
2769   177C             ; file system variables
2770   177C             current_dir_id:
2771   177C 00 00         .dw 0     ; keep dirid of current directory
2772   177E             s_init_path:
2773   177E 2F 73 62 69   .db "/sbin/init", 0
2773   1782 6E 2F 69 6E 
2773   1786 69 74 00 
2774   1789             
2775   1789             s_uname:
2776   1789 73 6F 6C 61   .db "solarium v.1.0", 0
2776   178D 72 69 75 6D 
2776   1791 20 76 2E 31 
2776   1795 2E 30 00 
2777   1798             s_dataentry:
2778   1798 3E 20 00      .db "> ", 0
2779   179B             s_parent_dir:
2780   179B 2E 2E 00      .db "..", 0
2781   179E             s_current_dir:
2782   179E 2E 00         .db ".", 0
2783   17A0             s_fslash:
2784   17A0 2F 00         .db "/", 0
2785   17A2             file_attrib:
2786   17A2 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2786   17A6 78 
2787   17A7             file_type:
2788   17A7 2D 64 63      .db "-dc"
2789   17AA             s_ps_header:
2790   17AA 70 69 64 20   .db "pid command\n", 0
2790   17AE 63 6F 6D 6D 
2790   17B2 61 6E 64 0A 
2790   17B6 00 
2791   17B7             s_ls_total:
2792   17B7 74 6F 74 61   .db "total: ", 0
2792   17BB 6C 3A 20 00 
2793   17BF             
2794   17BF             s_int_en:
2795   17BF 69 72 71 73   .db "irqs enabled\n", 0
2795   17C3 20 65 6E 61 
2795   17C7 62 6C 65 64 
2795   17CB 0A 00 
2796   17CD             s_kernel_started:
2797   17CD 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2797   17D1 65 6C 20 73 
2797   17D5 74 61 72 74 
2797   17D9 65 64 28 76 
2797   17DD 65 72 73 69 
2797   17E1 6F 6E 20 31 
2797   17E5 2E 30 29 0A 
2797   17E9 00 
2798   17EA             s_prompt_init:
2799   17EA 73 74 61 72   .db "starting init\n", 0
2799   17EE 74 69 6E 67 
2799   17F2 20 69 6E 69 
2799   17F6 74 0A 00 
2800   17F9             s_priviledge:
2801   17F9 0A 65 78 63   .db "\nexception: privilege\n", 0
2801   17FD 65 70 74 69 
2801   1801 6F 6E 3A 20 
2801   1805 70 72 69 76 
2801   1809 69 6C 65 67 
2801   180D 65 0A 00 
2802   1810             s_divzero:
2803   1810 0A 65 78 63   .db "\nexception: zero division\n", 0
2803   1814 65 70 74 69 
2803   1818 6F 6E 3A 20 
2803   181C 7A 65 72 6F 
2803   1820 20 64 69 76 
2803   1824 69 73 69 6F 
2803   1828 6E 0A 00 
2804   182B             
2805   182B             s_set_year:
2806   182B 79 65 61 72   .db "year: ", 0
2806   182F 3A 20 00 
2807   1832             s_set_month:
2808   1832 6D 6F 6E 74   .db "month: ", 0
2808   1836 68 3A 20 00 
2809   183A             s_set_day:
2810   183A 64 61 79 3A   .db "day: ", 0
2810   183E 20 00 
2811   1840             s_set_week:
2812   1840 77 65 65 6B   .db "weekday: ", 0
2812   1844 64 61 79 3A 
2812   1848 20 00 
2813   184A             s_set_hours:
2814   184A 68 6F 75 72   .db "hours: ", 0
2814   184E 73 3A 20 00 
2815   1852             s_set_minutes:
2816   1852 6D 69 6E 75   .db "minutes: ", 0
2816   1856 74 65 73 3A 
2816   185A 20 00 
2817   185C             s_set_seconds:
2818   185C 73 65 63 6F   .db "seconds: ", 0
2818   1860 6E 64 73 3A 
2818   1864 20 00 
2819   1866             s_months:      
2820   1866 20 20 20 00   .db "   ", 0
2821   186A 6A 61 6E 00   .db "jan", 0
2822   186E 66 65 62 00   .db "feb", 0
2823   1872 6D 61 72 00   .db "mar", 0
2824   1876 61 70 72 00   .db "apr", 0
2825   187A 6D 61 79 00   .db "may", 0
2826   187E 6A 75 6E 00   .db "jun", 0
2827   1882 6A 75 6C 00   .db "jul", 0
2828   1886 61 75 67 00   .db "aug", 0
2829   188A 73 65 70 00   .db "sep", 0
2830   188E 6F 63 74 00   .db "oct", 0
2831   1892 6E 6F 76 00   .db "nov", 0
2832   1896 64 65 63 00   .db "dec", 0
2833   189A             
2834   189A             s_week:        
2835   189A 73 75 6E 00   .db "sun", 0 
2836   189E 6D 6F 6E 00   .db "mon", 0 
2837   18A2 74 75 65 00   .db "tue", 0 
2838   18A6 77 65 64 00   .db "wed", 0 
2839   18AA 74 68 75 00   .db "thu", 0 
2840   18AE 66 72 69 00   .db "fri", 0 
2841   18B2 73 61 74 00   .db "sat", 0
2842   18B6             
2843   18B6 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2843   18BA 30 20 45 78 
2843   18BE 65 63 75 74 
2843   18C2 65 64 2E 0A 
2843   18C6 00 
2844   18C7             s_fdc_config:
2845   18C7 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2845   18CB 65 63 74 69 
2845   18CF 6E 67 20 64 
2845   18D3 69 73 6B 65 
2845   18D7 74 74 65 20 
2845   18DB 64 72 69 76 
2845   18DF 65 20 30 2C 
2845   18E3 20 73 69 64 
2845   18E7 65 20 30 2C 
2845   18EB 20 73 69 6E 
2845   18EF 67 6C 65 20 
2845   18F3 64 65 6E 73 
2845   18F7 69 74 79 2C 
2845   18FB 20 68 65 61 
2845   18FF 64 20 6C 6F 
2845   1903 61 64 65 64 
2845   1907 0A 00 
2846   1909             
2847   1909             proc_state_table:   
2848   1909 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2848   190D 00 00 00 00 
2848   1911 00 00 00 00 
2848   1915 00 00 00 00 
2848   1919 00 00 00 00 
2848   191D 00 00 00 00 
2848   1921 00 00 00 00 
2848   1925 00 00 00 00 
2848   1929 00 00 00 00 
2848   192D 00 00 00 00 
2848   1931 00 00 00 00 
2848   1935 00 00 00 00 
2848   1939 00 00 00 00 
2848   193D 00 00 00 00 
2848   1941 00 00 00 00 
2848   1945 00 00 00 00 
2848   1949 00 00 00 00 
2848   194D 00 00 00 00 
2848   1951 00 00 00 00 
2848   1955 00 00 00 00 
2848   1959 00 00 00 00 
2848   195D 00 00 00 00 
2848   1961 00 00 00 00 
2848   1965 00 00 00 00 
2848   1969 00 00 00 00 
2848   196D 00 00 00 00 
2848   1971 00 00 00 00 
2848   1975 00 00 00 00 
2848   1979 00 00 00 00 
2848   197D 00 00 00 00 
2848   1981 00 00 00 00 
2848   1985 00 00 00 00 
2848   1989 00 00 00 00 
2848   198D 00 00 00 00 
2848   1991 00 00 00 00 
2848   1995 00 00 00 00 
2848   1999 00 00 00 00 
2848   199D 00 00 00 00 
2848   19A1 00 00 00 00 
2848   19A5 00 00 00 00 
2848   19A9 00 00 00 00 
2848   19AD 00 00 00 00 
2848   19B1 00 00 00 00 
2848   19B5 00 00 00 00 
2848   19B9 00 00 00 00 
2848   19BD 00 00 00 00 
2848   19C1 00 00 00 00 
2848   19C5 00 00 00 00 
2848   19C9 00 00 00 00 
2848   19CD 00 00 00 00 
2848   19D1 00 00 00 00 
2848   19D5 00 00 00 00 
2848   19D9 00 00 00 00 
2848   19DD 00 00 00 00 
2848   19E1 00 00 00 00 
2848   19E5 00 00 00 00 
2848   19E9 00 00 00 00 
2848   19ED 00 00 00 00 
2848   19F1 00 00 00 00 
2848   19F5 00 00 00 00 
2848   19F9 00 00 00 00 
2848   19FD 00 00 00 00 
2848   1A01 00 00 00 00 
2848   1A05 00 00 00 00 
2848   1A09 00 00 00 00 
2848   1A0D 00 00 00 00 
2848   1A11 00 00 00 00 
2848   1A15 00 00 00 00 
2848   1A19 00 00 00 00 
2848   1A1D 00 00 00 00 
2848   1A21 00 00 00 00 
2848   1A25 00 00 00 00 
2848   1A29 00 00 00 00 
2848   1A2D 00 00 00 00 
2848   1A31 00 00 00 00 
2848   1A35 00 00 00 00 
2848   1A39 00 00 00 00 
2848   1A3D 00 00 00 00 
2848   1A41 00 00 00 00 
2848   1A45 00 00 00 00 
2849   1A49             proc_availab_table: 
2850   1A49 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2850   1A4D 00 00 00 00 
2850   1A51 00 00 00 00 
2850   1A55 00 00 00 00 
2851   1A59             proc_names:
2852   1A59 00 00 00 00   .fill 16 * 32, 0  ; process names
2852   1A5D 00 00 00 00 
2852   1A61 00 00 00 00 
2852   1A65 00 00 00 00 
2852   1A69 00 00 00 00 
2852   1A6D 00 00 00 00 
2852   1A71 00 00 00 00 
2852   1A75 00 00 00 00 
2852   1A79 00 00 00 00 
2852   1A7D 00 00 00 00 
2852   1A81 00 00 00 00 
2852   1A85 00 00 00 00 
2852   1A89 00 00 00 00 
2852   1A8D 00 00 00 00 
2852   1A91 00 00 00 00 
2852   1A95 00 00 00 00 
2852   1A99 00 00 00 00 
2852   1A9D 00 00 00 00 
2852   1AA1 00 00 00 00 
2852   1AA5 00 00 00 00 
2852   1AA9 00 00 00 00 
2852   1AAD 00 00 00 00 
2852   1AB1 00 00 00 00 
2852   1AB5 00 00 00 00 
2852   1AB9 00 00 00 00 
2852   1ABD 00 00 00 00 
2852   1AC1 00 00 00 00 
2852   1AC5 00 00 00 00 
2852   1AC9 00 00 00 00 
2852   1ACD 00 00 00 00 
2852   1AD1 00 00 00 00 
2852   1AD5 00 00 00 00 
2852   1AD9 00 00 00 00 
2852   1ADD 00 00 00 00 
2852   1AE1 00 00 00 00 
2852   1AE5 00 00 00 00 
2852   1AE9 00 00 00 00 
2852   1AED 00 00 00 00 
2852   1AF1 00 00 00 00 
2852   1AF5 00 00 00 00 
2852   1AF9 00 00 00 00 
2852   1AFD 00 00 00 00 
2852   1B01 00 00 00 00 
2852   1B05 00 00 00 00 
2852   1B09 00 00 00 00 
2852   1B0D 00 00 00 00 
2852   1B11 00 00 00 00 
2852   1B15 00 00 00 00 
2852   1B19 00 00 00 00 
2852   1B1D 00 00 00 00 
2852   1B21 00 00 00 00 
2852   1B25 00 00 00 00 
2852   1B29 00 00 00 00 
2852   1B2D 00 00 00 00 
2852   1B31 00 00 00 00 
2852   1B35 00 00 00 00 
2852   1B39 00 00 00 00 
2852   1B3D 00 00 00 00 
2852   1B41 00 00 00 00 
2852   1B45 00 00 00 00 
2852   1B49 00 00 00 00 
2852   1B4D 00 00 00 00 
2852   1B51 00 00 00 00 
2852   1B55 00 00 00 00 
2852   1B59 00 00 00 00 
2852   1B5D 00 00 00 00 
2852   1B61 00 00 00 00 
2852   1B65 00 00 00 00 
2852   1B69 00 00 00 00 
2852   1B6D 00 00 00 00 
2852   1B71 00 00 00 00 
2852   1B75 00 00 00 00 
2852   1B79 00 00 00 00 
2852   1B7D 00 00 00 00 
2852   1B81 00 00 00 00 
2852   1B85 00 00 00 00 
2852   1B89 00 00 00 00 
2852   1B8D 00 00 00 00 
2852   1B91 00 00 00 00 
2852   1B95 00 00 00 00 
2852   1B99 00 00 00 00 
2852   1B9D 00 00 00 00 
2852   1BA1 00 00 00 00 
2852   1BA5 00 00 00 00 
2852   1BA9 00 00 00 00 
2852   1BAD 00 00 00 00 
2852   1BB1 00 00 00 00 
2852   1BB5 00 00 00 00 
2852   1BB9 00 00 00 00 
2852   1BBD 00 00 00 00 
2852   1BC1 00 00 00 00 
2852   1BC5 00 00 00 00 
2852   1BC9 00 00 00 00 
2852   1BCD 00 00 00 00 
2852   1BD1 00 00 00 00 
2852   1BD5 00 00 00 00 
2852   1BD9 00 00 00 00 
2852   1BDD 00 00 00 00 
2852   1BE1 00 00 00 00 
2852   1BE5 00 00 00 00 
2852   1BE9 00 00 00 00 
2852   1BED 00 00 00 00 
2852   1BF1 00 00 00 00 
2852   1BF5 00 00 00 00 
2852   1BF9 00 00 00 00 
2852   1BFD 00 00 00 00 
2852   1C01 00 00 00 00 
2852   1C05 00 00 00 00 
2852   1C09 00 00 00 00 
2852   1C0D 00 00 00 00 
2852   1C11 00 00 00 00 
2852   1C15 00 00 00 00 
2852   1C19 00 00 00 00 
2852   1C1D 00 00 00 00 
2852   1C21 00 00 00 00 
2852   1C25 00 00 00 00 
2852   1C29 00 00 00 00 
2852   1C2D 00 00 00 00 
2852   1C31 00 00 00 00 
2852   1C35 00 00 00 00 
2852   1C39 00 00 00 00 
2852   1C3D 00 00 00 00 
2852   1C41 00 00 00 00 
2852   1C45 00 00 00 00 
2852   1C49 00 00 00 00 
2852   1C4D 00 00 00 00 
2852   1C51 00 00 00 00 
2852   1C55 00 00 00 00 
2853   1C59             filename:
2854   1C59 00 00 00 00   .fill 128, 0      ; holds a path for file search
2854   1C5D 00 00 00 00 
2854   1C61 00 00 00 00 
2854   1C65 00 00 00 00 
2854   1C69 00 00 00 00 
2854   1C6D 00 00 00 00 
2854   1C71 00 00 00 00 
2854   1C75 00 00 00 00 
2854   1C79 00 00 00 00 
2854   1C7D 00 00 00 00 
2854   1C81 00 00 00 00 
2854   1C85 00 00 00 00 
2854   1C89 00 00 00 00 
2854   1C8D 00 00 00 00 
2854   1C91 00 00 00 00 
2854   1C95 00 00 00 00 
2854   1C99 00 00 00 00 
2854   1C9D 00 00 00 00 
2854   1CA1 00 00 00 00 
2854   1CA5 00 00 00 00 
2854   1CA9 00 00 00 00 
2854   1CAD 00 00 00 00 
2854   1CB1 00 00 00 00 
2854   1CB5 00 00 00 00 
2854   1CB9 00 00 00 00 
2854   1CBD 00 00 00 00 
2854   1CC1 00 00 00 00 
2854   1CC5 00 00 00 00 
2854   1CC9 00 00 00 00 
2854   1CCD 00 00 00 00 
2854   1CD1 00 00 00 00 
2854   1CD5 00 00 00 00 
2855   1CD9             user_data:
2856   1CD9 00 00 00 00   .fill 512, 0      ;  user space data
2856   1CDD 00 00 00 00 
2856   1CE1 00 00 00 00 
2856   1CE5 00 00 00 00 
2856   1CE9 00 00 00 00 
2856   1CED 00 00 00 00 
2856   1CF1 00 00 00 00 
2856   1CF5 00 00 00 00 
2856   1CF9 00 00 00 00 
2856   1CFD 00 00 00 00 
2856   1D01 00 00 00 00 
2856   1D05 00 00 00 00 
2856   1D09 00 00 00 00 
2856   1D0D 00 00 00 00 
2856   1D11 00 00 00 00 
2856   1D15 00 00 00 00 
2856   1D19 00 00 00 00 
2856   1D1D 00 00 00 00 
2856   1D21 00 00 00 00 
2856   1D25 00 00 00 00 
2856   1D29 00 00 00 00 
2856   1D2D 00 00 00 00 
2856   1D31 00 00 00 00 
2856   1D35 00 00 00 00 
2856   1D39 00 00 00 00 
2856   1D3D 00 00 00 00 
2856   1D41 00 00 00 00 
2856   1D45 00 00 00 00 
2856   1D49 00 00 00 00 
2856   1D4D 00 00 00 00 
2856   1D51 00 00 00 00 
2856   1D55 00 00 00 00 
2856   1D59 00 00 00 00 
2856   1D5D 00 00 00 00 
2856   1D61 00 00 00 00 
2856   1D65 00 00 00 00 
2856   1D69 00 00 00 00 
2856   1D6D 00 00 00 00 
2856   1D71 00 00 00 00 
2856   1D75 00 00 00 00 
2856   1D79 00 00 00 00 
2856   1D7D 00 00 00 00 
2856   1D81 00 00 00 00 
2856   1D85 00 00 00 00 
2856   1D89 00 00 00 00 
2856   1D8D 00 00 00 00 
2856   1D91 00 00 00 00 
2856   1D95 00 00 00 00 
2856   1D99 00 00 00 00 
2856   1D9D 00 00 00 00 
2856   1DA1 00 00 00 00 
2856   1DA5 00 00 00 00 
2856   1DA9 00 00 00 00 
2856   1DAD 00 00 00 00 
2856   1DB1 00 00 00 00 
2856   1DB5 00 00 00 00 
2856   1DB9 00 00 00 00 
2856   1DBD 00 00 00 00 
2856   1DC1 00 00 00 00 
2856   1DC5 00 00 00 00 
2856   1DC9 00 00 00 00 
2856   1DCD 00 00 00 00 
2856   1DD1 00 00 00 00 
2856   1DD5 00 00 00 00 
2856   1DD9 00 00 00 00 
2856   1DDD 00 00 00 00 
2856   1DE1 00 00 00 00 
2856   1DE5 00 00 00 00 
2856   1DE9 00 00 00 00 
2856   1DED 00 00 00 00 
2856   1DF1 00 00 00 00 
2856   1DF5 00 00 00 00 
2856   1DF9 00 00 00 00 
2856   1DFD 00 00 00 00 
2856   1E01 00 00 00 00 
2856   1E05 00 00 00 00 
2856   1E09 00 00 00 00 
2856   1E0D 00 00 00 00 
2856   1E11 00 00 00 00 
2856   1E15 00 00 00 00 
2856   1E19 00 00 00 00 
2856   1E1D 00 00 00 00 
2856   1E21 00 00 00 00 
2856   1E25 00 00 00 00 
2856   1E29 00 00 00 00 
2856   1E2D 00 00 00 00 
2856   1E31 00 00 00 00 
2856   1E35 00 00 00 00 
2856   1E39 00 00 00 00 
2856   1E3D 00 00 00 00 
2856   1E41 00 00 00 00 
2856   1E45 00 00 00 00 
2856   1E49 00 00 00 00 
2856   1E4D 00 00 00 00 
2856   1E51 00 00 00 00 
2856   1E55 00 00 00 00 
2856   1E59 00 00 00 00 
2856   1E5D 00 00 00 00 
2856   1E61 00 00 00 00 
2856   1E65 00 00 00 00 
2856   1E69 00 00 00 00 
2856   1E6D 00 00 00 00 
2856   1E71 00 00 00 00 
2856   1E75 00 00 00 00 
2856   1E79 00 00 00 00 
2856   1E7D 00 00 00 00 
2856   1E81 00 00 00 00 
2856   1E85 00 00 00 00 
2856   1E89 00 00 00 00 
2856   1E8D 00 00 00 00 
2856   1E91 00 00 00 00 
2856   1E95 00 00 00 00 
2856   1E99 00 00 00 00 
2856   1E9D 00 00 00 00 
2856   1EA1 00 00 00 00 
2856   1EA5 00 00 00 00 
2856   1EA9 00 00 00 00 
2856   1EAD 00 00 00 00 
2856   1EB1 00 00 00 00 
2856   1EB5 00 00 00 00 
2856   1EB9 00 00 00 00 
2856   1EBD 00 00 00 00 
2856   1EC1 00 00 00 00 
2856   1EC5 00 00 00 00 
2856   1EC9 00 00 00 00 
2856   1ECD 00 00 00 00 
2856   1ED1 00 00 00 00 
2856   1ED5 00 00 00 00 
2857   1ED9             fifo:
2858   1ED9 FF FF FF FF   .fill fifo_size
2858   1EDD FF FF FF FF 
2858   1EE1 FF FF FF FF 
2858   1EE5 FF FF FF FF 
2858   1EE9 FF FF FF FF 
2858   1EED FF FF FF FF 
2858   1EF1 FF FF FF FF 
2858   1EF5 FF FF FF FF 
2858   1EF9 FF FF FF FF 
2858   1EFD FF FF FF FF 
2858   1F01 FF FF FF FF 
2858   1F05 FF FF FF FF 
2858   1F09 FF FF FF FF 
2858   1F0D FF FF FF FF 
2858   1F11 FF FF FF FF 
2858   1F15 FF FF FF FF 
2858   1F19 FF FF FF FF 
2858   1F1D FF FF FF FF 
2858   1F21 FF FF FF FF 
2858   1F25 FF FF FF FF 
2858   1F29 FF FF FF FF 
2858   1F2D FF FF FF FF 
2858   1F31 FF FF FF FF 
2858   1F35 FF FF FF FF 
2858   1F39 FF FF FF FF 
2858   1F3D FF FF FF FF 
2858   1F41 FF FF FF FF 
2858   1F45 FF FF FF FF 
2858   1F49 FF FF FF FF 
2858   1F4D FF FF FF FF 
2858   1F51 FF FF FF FF 
2858   1F55 FF FF FF FF 
2858   1F59 FF FF FF FF 
2858   1F5D FF FF FF FF 
2858   1F61 FF FF FF FF 
2858   1F65 FF FF FF FF 
2858   1F69 FF FF FF FF 
2858   1F6D FF FF FF FF 
2858   1F71 FF FF FF FF 
2858   1F75 FF FF FF FF 
2858   1F79 FF FF FF FF 
2858   1F7D FF FF FF FF 
2858   1F81 FF FF FF FF 
2858   1F85 FF FF FF FF 
2858   1F89 FF FF FF FF 
2858   1F8D FF FF FF FF 
2858   1F91 FF FF FF FF 
2858   1F95 FF FF FF FF 
2858   1F99 FF FF FF FF 
2858   1F9D FF FF FF FF 
2858   1FA1 FF FF FF FF 
2858   1FA5 FF FF FF FF 
2858   1FA9 FF FF FF FF 
2858   1FAD FF FF FF FF 
2858   1FB1 FF FF FF FF 
2858   1FB5 FF FF FF FF 
2858   1FB9 FF FF FF FF 
2858   1FBD FF FF FF FF 
2858   1FC1 FF FF FF FF 
2858   1FC5 FF FF FF FF 
2858   1FC9 FF FF FF FF 
2858   1FCD FF FF FF FF 
2858   1FD1 FF FF FF FF 
2858   1FD5 FF FF FF FF 
2858   1FD9 FF FF FF FF 
2858   1FDD FF FF FF FF 
2858   1FE1 FF FF FF FF 
2858   1FE5 FF FF FF FF 
2858   1FE9 FF FF FF FF 
2858   1FED FF FF FF FF 
2858   1FF1 FF FF FF FF 
2858   1FF5 FF FF FF FF 
2858   1FF9 FF FF FF FF 
2858   1FFD FF FF FF FF 
2858   2001 FF FF FF FF 
2858   2005 FF FF FF FF 
2858   2009 FF FF FF FF 
2858   200D FF FF FF FF 
2858   2011 FF FF FF FF 
2858   2015 FF FF FF FF 
2858   2019 FF FF FF FF 
2858   201D FF FF FF FF 
2858   2021 FF FF FF FF 
2858   2025 FF FF FF FF 
2858   2029 FF FF FF FF 
2858   202D FF FF FF FF 
2858   2031 FF FF FF FF 
2858   2035 FF FF FF FF 
2858   2039 FF FF FF FF 
2858   203D FF FF FF FF 
2858   2041 FF FF FF FF 
2858   2045 FF FF FF FF 
2858   2049 FF FF FF FF 
2858   204D FF FF FF FF 
2858   2051 FF FF FF FF 
2858   2055 FF FF FF FF 
2858   2059 FF FF FF FF 
2858   205D FF FF FF FF 
2858   2061 FF FF FF FF 
2858   2065 FF FF FF FF 
2858   2069 FF FF FF FF 
2858   206D FF FF FF FF 
2858   2071 FF FF FF FF 
2858   2075 FF FF FF FF 
2858   2079 FF FF FF FF 
2858   207D FF FF FF FF 
2858   2081 FF FF FF FF 
2858   2085 FF FF FF FF 
2858   2089 FF FF FF FF 
2858   208D FF FF FF FF 
2858   2091 FF FF FF FF 
2858   2095 FF FF FF FF 
2858   2099 FF FF FF FF 
2858   209D FF FF FF FF 
2858   20A1 FF FF FF FF 
2858   20A5 FF FF FF FF 
2858   20A9 FF FF FF FF 
2858   20AD FF FF FF FF 
2858   20B1 FF FF FF FF 
2858   20B5 FF FF FF FF 
2858   20B9 FF FF FF FF 
2858   20BD FF FF FF FF 
2858   20C1 FF FF FF FF 
2858   20C5 FF FF FF FF 
2858   20C9 FF FF FF FF 
2858   20CD FF FF FF FF 
2858   20D1 FF FF FF FF 
2858   20D5 FF FF FF FF 
2858   20D9 FF FF FF FF 
2858   20DD FF FF FF FF 
2858   20E1 FF FF FF FF 
2858   20E5 FF FF FF FF 
2858   20E9 FF FF FF FF 
2858   20ED FF FF FF FF 
2858   20F1 FF FF FF FF 
2858   20F5 FF FF FF FF 
2858   20F9 FF FF FF FF 
2858   20FD FF FF FF FF 
2858   2101 FF FF FF FF 
2858   2105 FF FF FF FF 
2858   2109 FF FF FF FF 
2858   210D FF FF FF FF 
2858   2111 FF FF FF FF 
2858   2115 FF FF FF FF 
2858   2119 FF FF FF FF 
2858   211D FF FF FF FF 
2858   2121 FF FF FF FF 
2858   2125 FF FF FF FF 
2858   2129 FF FF FF FF 
2858   212D FF FF FF FF 
2858   2131 FF FF FF FF 
2858   2135 FF FF FF FF 
2858   2139 FF FF FF FF 
2858   213D FF FF FF FF 
2858   2141 FF FF FF FF 
2858   2145 FF FF FF FF 
2858   2149 FF FF FF FF 
2858   214D FF FF FF FF 
2858   2151 FF FF FF FF 
2858   2155 FF FF FF FF 
2858   2159 FF FF FF FF 
2858   215D FF FF FF FF 
2858   2161 FF FF FF FF 
2858   2165 FF FF FF FF 
2858   2169 FF FF FF FF 
2858   216D FF FF FF FF 
2858   2171 FF FF FF FF 
2858   2175 FF FF FF FF 
2858   2179 FF FF FF FF 
2858   217D FF FF FF FF 
2858   2181 FF FF FF FF 
2858   2185 FF FF FF FF 
2858   2189 FF FF FF FF 
2858   218D FF FF FF FF 
2858   2191 FF FF FF FF 
2858   2195 FF FF FF FF 
2858   2199 FF FF FF FF 
2858   219D FF FF FF FF 
2858   21A1 FF FF FF FF 
2858   21A5 FF FF FF FF 
2858   21A9 FF FF FF FF 
2858   21AD FF FF FF FF 
2858   21B1 FF FF FF FF 
2858   21B5 FF FF FF FF 
2858   21B9 FF FF FF FF 
2858   21BD FF FF FF FF 
2858   21C1 FF FF FF FF 
2858   21C5 FF FF FF FF 
2858   21C9 FF FF FF FF 
2858   21CD FF FF FF FF 
2858   21D1 FF FF FF FF 
2858   21D5 FF FF FF FF 
2858   21D9 FF FF FF FF 
2858   21DD FF FF FF FF 
2858   21E1 FF FF FF FF 
2858   21E5 FF FF FF FF 
2858   21E9 FF FF FF FF 
2858   21ED FF FF FF FF 
2858   21F1 FF FF FF FF 
2858   21F5 FF FF FF FF 
2858   21F9 FF FF FF FF 
2858   21FD FF FF FF FF 
2858   2201 FF FF FF FF 
2858   2205 FF FF FF FF 
2858   2209 FF FF FF FF 
2858   220D FF FF FF FF 
2858   2211 FF FF FF FF 
2858   2215 FF FF FF FF 
2858   2219 FF FF FF FF 
2858   221D FF FF FF FF 
2858   2221 FF FF FF FF 
2858   2225 FF FF FF FF 
2858   2229 FF FF FF FF 
2858   222D FF FF FF FF 
2858   2231 FF FF FF FF 
2858   2235 FF FF FF FF 
2858   2239 FF FF FF FF 
2858   223D FF FF FF FF 
2858   2241 FF FF FF FF 
2858   2245 FF FF FF FF 
2858   2249 FF FF FF FF 
2858   224D FF FF FF FF 
2858   2251 FF FF FF FF 
2858   2255 FF FF FF FF 
2858   2259 FF FF FF FF 
2858   225D FF FF FF FF 
2858   2261 FF FF FF FF 
2858   2265 FF FF FF FF 
2858   2269 FF FF FF FF 
2858   226D FF FF FF FF 
2858   2271 FF FF FF FF 
2858   2275 FF FF FF FF 
2858   2279 FF FF FF FF 
2858   227D FF FF FF FF 
2858   2281 FF FF FF FF 
2858   2285 FF FF FF FF 
2858   2289 FF FF FF FF 
2858   228D FF FF FF FF 
2858   2291 FF FF FF FF 
2858   2295 FF FF FF FF 
2858   2299 FF FF FF FF 
2858   229D FF FF FF FF 
2858   22A1 FF FF FF FF 
2858   22A5 FF FF FF FF 
2858   22A9 FF FF FF FF 
2858   22AD FF FF FF FF 
2858   22B1 FF FF FF FF 
2858   22B5 FF FF FF FF 
2858   22B9 FF FF FF FF 
2858   22BD FF FF FF FF 
2858   22C1 FF FF FF FF 
2858   22C5 FF FF FF FF 
2858   22C9 FF FF FF FF 
2858   22CD FF FF FF FF 
2858   22D1 FF FF FF FF 
2858   22D5 FF FF FF FF 
2859   22D9             
2860   22D9             scrap_sector:
2861   22D9 FF FF FF FF   .fill 512         ; scrap sector
2861   22DD FF FF FF FF 
2861   22E1 FF FF FF FF 
2861   22E5 FF FF FF FF 
2861   22E9 FF FF FF FF 
2861   22ED FF FF FF FF 
2861   22F1 FF FF FF FF 
2861   22F5 FF FF FF FF 
2861   22F9 FF FF FF FF 
2861   22FD FF FF FF FF 
2861   2301 FF FF FF FF 
2861   2305 FF FF FF FF 
2861   2309 FF FF FF FF 
2861   230D FF FF FF FF 
2861   2311 FF FF FF FF 
2861   2315 FF FF FF FF 
2861   2319 FF FF FF FF 
2861   231D FF FF FF FF 
2861   2321 FF FF FF FF 
2861   2325 FF FF FF FF 
2861   2329 FF FF FF FF 
2861   232D FF FF FF FF 
2861   2331 FF FF FF FF 
2861   2335 FF FF FF FF 
2861   2339 FF FF FF FF 
2861   233D FF FF FF FF 
2861   2341 FF FF FF FF 
2861   2345 FF FF FF FF 
2861   2349 FF FF FF FF 
2861   234D FF FF FF FF 
2861   2351 FF FF FF FF 
2861   2355 FF FF FF FF 
2861   2359 FF FF FF FF 
2861   235D FF FF FF FF 
2861   2361 FF FF FF FF 
2861   2365 FF FF FF FF 
2861   2369 FF FF FF FF 
2861   236D FF FF FF FF 
2861   2371 FF FF FF FF 
2861   2375 FF FF FF FF 
2861   2379 FF FF FF FF 
2861   237D FF FF FF FF 
2861   2381 FF FF FF FF 
2861   2385 FF FF FF FF 
2861   2389 FF FF FF FF 
2861   238D FF FF FF FF 
2861   2391 FF FF FF FF 
2861   2395 FF FF FF FF 
2861   2399 FF FF FF FF 
2861   239D FF FF FF FF 
2861   23A1 FF FF FF FF 
2861   23A5 FF FF FF FF 
2861   23A9 FF FF FF FF 
2861   23AD FF FF FF FF 
2861   23B1 FF FF FF FF 
2861   23B5 FF FF FF FF 
2861   23B9 FF FF FF FF 
2861   23BD FF FF FF FF 
2861   23C1 FF FF FF FF 
2861   23C5 FF FF FF FF 
2861   23C9 FF FF FF FF 
2861   23CD FF FF FF FF 
2861   23D1 FF FF FF FF 
2861   23D5 FF FF FF FF 
2861   23D9 FF FF FF FF 
2861   23DD FF FF FF FF 
2861   23E1 FF FF FF FF 
2861   23E5 FF FF FF FF 
2861   23E9 FF FF FF FF 
2861   23ED FF FF FF FF 
2861   23F1 FF FF FF FF 
2861   23F5 FF FF FF FF 
2861   23F9 FF FF FF FF 
2861   23FD FF FF FF FF 
2861   2401 FF FF FF FF 
2861   2405 FF FF FF FF 
2861   2409 FF FF FF FF 
2861   240D FF FF FF FF 
2861   2411 FF FF FF FF 
2861   2415 FF FF FF FF 
2861   2419 FF FF FF FF 
2861   241D FF FF FF FF 
2861   2421 FF FF FF FF 
2861   2425 FF FF FF FF 
2861   2429 FF FF FF FF 
2861   242D FF FF FF FF 
2861   2431 FF FF FF FF 
2861   2435 FF FF FF FF 
2861   2439 FF FF FF FF 
2861   243D FF FF FF FF 
2861   2441 FF FF FF FF 
2861   2445 FF FF FF FF 
2861   2449 FF FF FF FF 
2861   244D FF FF FF FF 
2861   2451 FF FF FF FF 
2861   2455 FF FF FF FF 
2861   2459 FF FF FF FF 
2861   245D FF FF FF FF 
2861   2461 FF FF FF FF 
2861   2465 FF FF FF FF 
2861   2469 FF FF FF FF 
2861   246D FF FF FF FF 
2861   2471 FF FF FF FF 
2861   2475 FF FF FF FF 
2861   2479 FF FF FF FF 
2861   247D FF FF FF FF 
2861   2481 FF FF FF FF 
2861   2485 FF FF FF FF 
2861   2489 FF FF FF FF 
2861   248D FF FF FF FF 
2861   2491 FF FF FF FF 
2861   2495 FF FF FF FF 
2861   2499 FF FF FF FF 
2861   249D FF FF FF FF 
2861   24A1 FF FF FF FF 
2861   24A5 FF FF FF FF 
2861   24A9 FF FF FF FF 
2861   24AD FF FF FF FF 
2861   24B1 FF FF FF FF 
2861   24B5 FF FF FF FF 
2861   24B9 FF FF FF FF 
2861   24BD FF FF FF FF 
2861   24C1 FF FF FF FF 
2861   24C5 FF FF FF FF 
2861   24C9 FF FF FF FF 
2861   24CD FF FF FF FF 
2861   24D1 FF FF FF FF 
2861   24D5 FF FF FF FF 
2862   24D9             transient_area:
2863   24D9 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2864   24DA             
2865   24DA             .end
tasm: Number of errors = 0
