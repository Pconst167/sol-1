0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff88         ; data
0042   0000             _uart1_dlab_0     .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff8A         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff8B         ; line control register
0047   0000             _uart1_lsr        .equ $ff8D         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _til311_display   .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             _stack_top        .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size        .equ 4096
0080   0000             _scrap_size       .equ 512
0081   0000             
0082   0000             text_org                .equ $400          ; code origin address for all user processes
0083   0000             
0084   0000             block_bitmap_start      .equ 2048 * 2
0085   0000             block_bitmap_sec_start  .equ 8
0086   0000             inode_bitmap_start      .equ 2048 * 6
0087   0000             inode_bitmap_sect_start .equ 24
0088   0000             inode_table_start       .equ 2048 * 7
0089   0000             inode_table_sect_start  .equ 28 ; inode table starts at sector 28
0090   0000             data_blocks_start       .equ 2111488
0091   0000             data_blocks_sect_start  .equ 4124
0092   0000             
0093   0000             ;  ------------------------------------------------------------------------------------------------------------------;
0094   0000             ;  DISK LAYOUT:
0095   0000             ;  Metadata               | Size (bytes)      | Blocks (2048 bytes)              |Start Block |  Comment
0096   0000             ;  ---------------------- | ----------------- | -------------------------------- |------------|-----------------------------------
0097   0000             ;  Bootloader/MBR         | 1024 bytes        | 0.5 (1 sector)                   |  0         |
0098   0000             ;  Superblock             | 1024 bytes        | 1 block (2048 bytes, must align) |  0         |
0099   0000             ;                         |                   | 1 block (2048 bytes)             |  1         | reserved
0100   0000             ;  Block Bitmap           | 8,192 bytes       | 4 blocks                         |  2         | 4*2048*8 = 4*16384 = 65536 raw data blocks.  65536*2048 bytes = 134217728 bytes of disk space = 128MB
0101   0000             ;  Inode Bitmap           | 2,048 bytes       | 1 block                          |  6         | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is 1 inode per 8KB of disk space
0102   0000             ;  Inode Table            | 2,097,152 bytes   | 1024 blocks                      |  7         | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0103   0000             ;  Data Blocks            | 134,217,728 bytes | 65528 blocks                     | 1031       | 65528 blocks = 134,201,344 bytes
0104   0000             ;  
0105   0000             ;  first 1024 bytes: bootloader from 0 to 959, MBR partition table from 960 (64 bytes)
0106   0000             ;  up to 4 partitions, each 16 bytes long
0107   0000             ;  MBR:
0108   0000             ;  Byte | Description
0109   0000             ;  -----|----------------------------
0110   0000             ;  0    | Boot flag (0x80 active, 0x00 inactive)
0111   0000             ;  1-3  | Start CHS (head, sector, cylinder)
0112   0000             ;  4    | Partition type (filesystem ID)
0113   0000             ;    0x83 = Linux native (ext2/3/4)
0114   0000             ;    0x07 = NTFS/exFAT
0115   0000             ;    0x0B = FAT32 CHS
0116   0000             ;    0x0C = FAT32 LBA
0117   0000             ;    0x05 = Extended partition
0118   0000             ;    0x86 = Sol-1 partition
0119   0000             ;  5-7  | End CHS
0120   0000             ;  8-11 | Start LBA (little endian)
0121   0000             ;  12-15| Size in sectors (little endian)
0122   0000             ;  
0123   0000             ;  
0124   0000             ;  the superblock describers the filesystem as a whole such as inode count, free inode count, location of the raw data bitmap, inode table, etc.  
0125   0000             ;  SUPERBLOCK:
0126   0000             ;  | Field               | Description                               | Typical Size (bytes) | Notes                           |
0127   0000             ;  | ------------------- | ----------------------------------------- | -------------------- | ------------------------------- |
0128   0000             ;  | inodes_count        | Total number of inodes in the filesystem  | 2                    | 16-bit unsigned int             |
0129   0000             ;  | blocks_count        | Total number of data blocks               | 2                    | 16-bit unsigned int             |
0130   0000             ;  | free_inodes_count   | Number of free inodes                     | 2                    | 16-bit unsigned int             |
0131   0000             ;  | free_blocks_count   | Number of free blocks                     | 2                    | 16-bit unsigned int             |
0132   0000             ;  | block_bitmap        | Block ID of the **block bitmap**          | 2                    | 16-bit unsigned int
0133   0000             ;  | inode_bitmap        | Block ID of the **inode bitmap**          | 2                    | 16-bit unsigned int
0134   0000             ;  | inode_table         | Starting block of **inode table**         | 2                    | 16-bit unsigned int
0135   0000             ;  | first_data_block    | Block number of the first data block      | 2                    | 16-bit unsigned int             |
0136   0000             ;  | used_dirs_count     | Number of inodes allocated to directories | 2
0137   0000             ;  | log_block_size      | Block size = 1024 << `s_log_block_size    | 2                    | 16-bit unsigned int             |
0138   0000             ;  | mtime               | Last mount time                           | 4                    | 32-bit unsigned int (Unix time) |
0139   0000             ;  | wtime               | Last write time                           | 4                    | 32-bit unsigned int (Unix time) |
0140   0000             ;  | uuid                | Unique ID of the filesystem               | 16                   | 128-bit UUID                    |
0141   0000             ;  | volume_name         | Label of the filesystem                   | 16                   | Usually ASCII, padded           |
0142   0000             ;  | feature_flags       | Compatibility flags                       | 4                    | 32-bit unsigned int             |
0143   0000             ;  
0144   0000             ;  inode for root dir is #2, #0 and #1 not used
0145   0000             ;  raw data block #0 is not used. because 0 as a block ID means not used
0146   0000             ;  block size: 2048
0147   0000             ;  inode-table format:
0148   0000             ;  | Field         | Size (bytes) | Description                                                                                  |
0149   0000             ;  | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0150   0000             ;  | `mode`        | 2            | File type and permissions                                                                    |
0151   0000             ;  | `uid`         | 2            | Owner user ID                                                                                |
0152   0000             ;  | `size`        | 4            | Size of the file in bytes                                                                    |
0153   0000             ;  | `atime`       | 4            | Last access time (timestamp)                                                                 |
0154   0000             ;  | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0155   0000             ;  | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0156   0000             ;  | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0157   0000             ;  | `gid`         | 2            | Group ID                                                                                     |
0158   0000             ;  | `links_count` | 2            | Number of hard links                                                                         |
0159   0000             ;  | `blocks`      | 2            | Number of 2048-byte blocks allocated                                                         |
0160   0000             ;  | `flags`       | 4            | File flags                                                                                   |
0161   0000             ;  | `block`       | 47 * 2 = 94  | Pointers to data blocks (47 direct only) 
0162   0000             ;
0163   0000             ;
0164   0000             ;  DIRECTORY ENTRY
0165   0000             ;  this is the structure for file entries inside a directory.
0166   0000             ;  2048 / 64 = 32 entries
0167   0000             ;
0168   0000             ;  each entry is 64 bytes wide
0169   0000             ;  uint16_t inode;      // Inode number (0 if entry is unused)
0170   0000             ;  char     name[62];   // File name (null terminated)
0171   0000             
0172   0000             ; ------------------------------------------------------------------------------------------------------------------;
0173   0000             ; global system variables
0174   0000             ; ------------------------------------------------------------------------------------------------------------------;
0175   0000             
0176   0000             ; ------------------------------------------------------------------------------------------------------------------;
0177   0000             ; irq table
0178   0000             ; highest priority at lowest address
0179   0000             ; ------------------------------------------------------------------------------------------------------------------;
0180   0000 30 00       .dw int_0_fdc
0181   0002 37 00       .dw int_1
0182   0004 38 00       .dw int_2
0183   0006 39 00       .dw int_3
0184   0008 3A 00       .dw int_4
0185   000A 3B 00       .dw int_5_uart1
0186   000C 5D 00       .dw int_6_timer
0187   000E 5E 00       .dw int_7_uart0
0188   0010             
0189   0010             ; ------------------------------------------------------------------------------------------------------------------;
0190   0010             ; kernel reset vector
0191   0010             ; ------------------------------------------------------------------------------------------------------------------;
0192   0010 6D 04       .dw kernel_reset_vector
0193   0012             
0194   0012             ; ------------------------------------------------------------------------------------------------------------------;
0195   0012             ; exception vector table
0196   0012             ; total of 7 entries, starting at address $0012
0197   0012             ; ------------------------------------------------------------------------------------------------------------------;
0198   0012 CB 00       .dw trap_privilege
0199   0014 92 01       .dw trap_div_zero
0200   0016 9F 01       .dw trap_undef_opcode
0201   0018 00 00       .dw 0
0202   001A 00 00       .dw 0
0203   001C 00 00       .dw 0
0204   001E 00 00       .dw 0
0205   0020             
0206   0020             ; ------------------------------------------------------------------------------------------------------------------;
0207   0020             ; system call vector table
0208   0020             ; starts at address $0020
0209   0020             ; ------------------------------------------------------------------------------------------------------------------;
0210   0020 D7 00       .dw syscall_break
0211   0022 A0 01       .dw syscall_rtc
0212   0024 C3 02       .dw syscall_ide
0213   0026 83 03       .dw syscall_io
0214   0028 3A 04       .dw syscall_file_system
0215   002A D2 01       .dw syscall_datetime
0216   002C BF 00       .dw syscall_reboot
0217   002E 8B 00       .dw syscall_system
0218   0030             
0219   0030             ; ------------------------------------------------------------------------------------------------------------------;
0220   0030             ; system call aliases
0221   0030             ; ------------------------------------------------------------------------------------------------------------------;
0222   0030             sys_break            .equ 0
0223   0030             sys_rtc              .equ 1
0224   0030             sys_ide              .equ 2
0225   0030             sys_io               .equ 3
0226   0030             sys_filesystem       .equ 4
0227   0030             sys_datetime         .equ 5
0228   0030             sys_reboot           .equ 6
0229   0030             sys_system           .equ 7
0230   0030             sys_fdc              .equ 8
0231   0030             
0232   0030             ; ------------------------------------------------------------------------------------------------------------------;
0233   0030             ; alias exports
0234   0030             ; ------------------------------------------------------------------------------------------------------------------;
0235   0030             .export text_org
0236   0030             .export sys_break
0237   0030             .export sys_rtc
0238   0030             .export sys_ide
0239   0030             .export sys_io
0240   0030             .export sys_filesystem
0241   0030             .export sys_datetime
0242   0030             .export sys_reboot
0243   0030             .export sys_system
0244   0030             .export sys_fdc
0245   0030             
0246   0030             .export _til311_display
0247   0030             
0248   0030             .export _fdc_config        
0249   0030             .export _fdc_status_0      
0250   0030             .export _fdc_stat_cmd     
0251   0030             
0252   0030             ; ------------------------------------------------------------------------------------------------------------------;
0253   0030             ; irqs' code block
0254   0030             ; ------------------------------------------------------------------------------------------------------------------;
0255   0030             ; 5.25" floppy drive controller irq
0256   0030             int_0_fdc:
0257   0030 3B 33 0E      mov d, s_fdc_irq
0258   0033 07 C4 06      call _puts
0259   0036 06            sysret
0260   0037             int_1:
0261   0037 06            sysret
0262   0038             int_2:
0263   0038 06            sysret
0264   0039             int_3:
0265   0039 06            sysret
0266   003A             int_4:
0267   003A 06            sysret
0268   003B             
0269   003B             ; ------------------------------------------------------------------------------------------------------------------;
0270   003B             ; uart1 interrupt
0271   003B             ; ------------------------------------------------------------------------------------------------------------------;
0272   003B             int_5_uart1:
0273   003B D7            push a
0274   003C DA            push d
0275   003D E1            pushf
0276   003E 1D 88 FF      mov al, [_uart1_data]       ; get character
0277   0041               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0278   0041 3B F7 0B      mov d, fifo_in
0279   0044 FD 2A         mov d, [d]
0280   0046 3E            mov [d], al                 ; add to fifo
0281   0047 13            mov a, d
0282   0048 77            inc a
0283   0049 AF 85 1E      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0284   004C C7 52 00      jne int_5_continue
0285   004F 10 85 0E      mov a, fifo  
0286   0052             int_5_continue:  
0287   0052 42 F7 0B      mov [fifo_in], a            ; update fifo pointer
0288   0055 1A            mov al, ah
0289   0056 3D B0 FF      mov [_til311_display], al
0290   0059 EE            popf
0291   005A E7            pop d
0292   005B E4            pop a  
0293   005C 06            sysret
0294   005D             
0295   005D             ; ------------------------------------------------------------------------------------------------------------------;
0296   005D             ; timer irq
0297   005D             ; ------------------------------------------------------------------------------------------------------------------;
0298   005D             int_6_timer:  
0299   005D 06            sysret
0300   005E             
0301   005E             ; ------------------------------------------------------------------------------------------------------------------;
0302   005E             ; uart0 interrupt
0303   005E             ; ------------------------------------------------------------------------------------------------------------------;
0304   005E             int_7_uart0:
0305   005E D7            push a
0306   005F DA            push d
0307   0060 E1            pushf
0308   0061 1D 80 FF      mov al, [_uart0_data]       ; get character
0309   0064               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0310   0064 3B F7 0B      mov d, fifo_in
0311   0067 FD 2A         mov d, [d]
0312   0069 3E            mov [d], al                 ; add to fifo
0313   006A 13            mov a, d
0314   006B 77            inc a
0315   006C AF 85 1E      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0316   006F C7 75 00      jne int_7_continue
0317   0072 10 85 0E      mov a, fifo  
0318   0075             int_7_continue:  
0319   0075 42 F7 0B      mov [fifo_in], a            ; update fifo pointer
0320   0078 1A            mov al, ah
0321   0079 3D B0 FF      mov [_til311_display], al
0322   007C EE            popf
0323   007D E7            pop d
0324   007E E4            pop a  
0325   007F 06            sysret
0326   0080             
0327   0080             sys_mkfs:
0328   0080 06            sysret
0329   0081             
0330   0081             ; ------------------------------------------------------------------------------------------------------------------;
0331   0081             ; system syscalls
0332   0081             ; ------------------------------------------------------------------------------------------------------------------;
0333   0081             system_jmptbl:
0334   0081 B7 00         .dw system_uname
0335   0083 BE 00         .dw system_whoami
0336   0085 91 00         .dw system_poke
0337   0087 94 00         .dw system_bootloader_install
0338   0089 8F 00         .dw system_peek
0339   008B             syscall_system:
0340   008B FD 0A 81 00   jmp [system_jmptbl + al]
0341   008F             
0342   008F             ; param register address in register d
0343   008F             ; param value in register bl
0344   008F             system_peek:
0345   008F 32            mov bl, [d]
0346   0090 06            sysret
0347   0091             
0348   0091             ; param register address in register d
0349   0091             ; param value in register bl
0350   0091             system_poke:
0351   0091 FD 3E         mov [d], bl
0352   0093 06            sysret
0353   0094             
0354   0094             ; kernel LBA address in 'b'
0355   0094             system_bootloader_install:
0356   0094 D8            push b
0357   0095 26 00 00      mov b, 0
0358   0098 38 00 00      mov c, 0
0359   009B 22 01         mov ah, $01                 ; 1 sector
0360   009D 3B 85 20      mov d, transient_area
0361   00A0 07 F2 02      call ide_read_sect          ; read sector
0362   00A3 E5            pop b
0363   00A4 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0364   00A8 26 00 00      mov b, 0
0365   00AB 38 00 00      mov c, 0
0366   00AE 22 01         mov ah, $01                 ; 1 sector
0367   00B0 3B 85 20      mov d, transient_area
0368   00B3 07 18 03      call ide_write_sect         ; write sector
0369   00B6 06            sysret
0370   00B7             
0371   00B7             system_uname:
0372   00B7 3B 08 0C      mov d, s_uname
0373   00BA 07 C4 06      call _puts
0374   00BD 06            sysret
0375   00BE             
0376   00BE             system_whoami:
0377   00BE 06            sysret
0378   00BF             
0379   00BF             ; reboot system
0380   00BF             syscall_reboot:
0381   00BF FD D7 FF FF   push word $ffff 
0382   00C3 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0383   00C6 FD D7 90 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0384   00CA 06            sysret
0385   00CB             
0386   00CB             
0387   00CB             ; ------------------------------------------------------------------------------------------------------------------;
0388   00CB             ; exceptions code block
0389   00CB             ; ------------------------------------------------------------------------------------------------------------------;
0390   00CB             ; privilege exception
0391   00CB             ; ------------------------------------------------------------------------------------------------------------------;
0392   00CB             trap_privilege:
0393   00CB 0A BF 00      jmp syscall_reboot
0394   00CE DA            push d
0395   00CF 3B 20 0D      mov d, s_priviledge
0396   00D2 07 C4 06      call _puts
0397   00D5 E7            pop d
0398   00D6 06            sysret
0399   00D7             
0400   00D7             ; ------------------------------------------------------------------------------------------------------------------;
0401   00D7             ; breakpoint
0402   00D7             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0403   00D7             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0404   00D7             ; ------------------------------------------------------------------------------------------------------------------;
0405   00D7             syscall_break:
0406   00D7 4B            pusha
0407   00D8             syscall_break_prompt:
0408   00D8 3B 52 0D      mov d, s_break1
0409   00DB 07 C4 06      call _puts
0410   00DE 07 71 06      call printnl
0411   00E1 07 C6 07      call scan_u16d
0412   00E4 AF 00 00      cmp a, 0
0413   00E7 C6 F2 00      je syscall_break_regs
0414   00EA AF 01 00      cmp a, 1
0415   00ED C6 15 01      je syscall_break_mem
0416   00F0             syscall_break_end:  
0417   00F0 4C            popa
0418   00F1 06            sysret
0419   00F2             syscall_break_regs:
0420   00F2 48            mov a, sp
0421   00F3 53 0E 00      add a, 14               ; back-track 7 registers
0422   00F6 3C            mov d, a
0423   00F7 3A 07         mov cl, 7
0424   00F9             syscall_regs_l0:
0425   00F9 2A            mov b, [d]
0426   00FA FD AB         swp b
0427   00FC 07 20 07      call print_u16x         ; print register value
0428   00FF 07 71 06      call printnl
0429   0102 63 02 00      sub d, 2
0430   0105 71 01         sub cl, 1
0431   0107 C3 00         cmp cl, 0
0432   0109 C7 F9 00      jne syscall_regs_l0
0433   010C 0A D8 00      jmp syscall_break_prompt
0434   010F 07 71 06      call printnl
0435   0112 0A D8 00      jmp syscall_break_prompt
0436   0115             syscall_break_mem:
0437   0115 07 71 06      call printnl
0438   0118 07 42 07      call scan_u16x
0439   011B 4D            mov si, a               ; data source from user space
0440   011C FD 4F 85 1E   mov di, scrap_sector    ; destination in kernel space
0441   0120 38 00 02      mov c, 512
0442   0123 04            load                    ; transfer data to kernel space!
0443   0124 3B 85 1E      mov d, scrap_sector     ; dump pointer in d
0444   0127 38 00 00      mov c, 0
0445   012A             dump_loop:
0446   012A 84            mov al, cl
0447   012B 87 0F         and al, $0f
0448   012D C6 7B 01      jz print_base
0449   0130             back:
0450   0130 1E            mov al, [d]             ; read byte
0451   0131 2F            mov bl, al
0452   0132 07 64 07      call print_u8x
0453   0135 10 00 20      mov a, $2000
0454   0138 05 03         syscall sys_io          ; space
0455   013A 84            mov al, cl
0456   013B 87 0F         and al, $0f
0457   013D B9 0F         cmp al, $0f
0458   013F C6 50 01      je print_ascii
0459   0142             back1:
0460   0142 79            inc d
0461   0143 78            inc c
0462   0144 C2 00 02      cmp c, 512
0463   0147 C7 2A 01      jne dump_loop
0464   014A 07 71 06      call printnl
0465   014D 0A D8 00      jmp syscall_break_prompt  ; go to syscall_break return point
0466   0150             print_ascii:
0467   0150 10 00 20      mov a, $2000
0468   0153 05 03         syscall sys_io
0469   0155 63 10 00      sub d, 16
0470   0158 26 10 00      mov b, 16
0471   015B             print_ascii_l:
0472   015B 79            inc d
0473   015C 1E            mov al, [d]               ; read byte
0474   015D B9 20         cmp al, $20
0475   015F C8 67 01      jlu dot
0476   0162 B9 7E         cmp al, $7e
0477   0164 D0 6F 01      jleu ascii
0478   0167             dot:
0479   0167 10 00 2E      mov a, $2e00
0480   016A 05 03         syscall sys_io
0481   016C 0A 74 01      jmp ascii_continue
0482   016F             ascii:
0483   016F 23            mov ah, al
0484   0170 19 00         mov al, 0
0485   0172 05 03         syscall sys_io
0486   0174             ascii_continue:
0487   0174 FD A9 5B 01   loopb print_ascii_l
0488   0178 0A 42 01      jmp back1
0489   017B             print_base:
0490   017B 07 71 06      call printnl
0491   017E 2D            mov b, d
0492   017F 61 85 1E      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0493   0182 07 20 07      call print_u16x          ; display row
0494   0185 10 00 3A      mov a, $3a00
0495   0188 05 03         syscall sys_io
0496   018A 10 00 20      mov a, $2000
0497   018D 05 03         syscall sys_io
0498   018F 0A 30 01      jmp back
0499   0192             
0500   0192             ; ------------------------------------------------------------------------------------------------------------------;
0501   0192             ; divide by zero exception
0502   0192             ; ------------------------------------------------------------------------------------------------------------------;
0503   0192             trap_div_zero:
0504   0192 D7            push a
0505   0193 DA            push d
0506   0194 E1            pushf
0507   0195 3B 37 0D      mov d, s_divzero
0508   0198 07 C4 06      call _puts
0509   019B EE            popf
0510   019C E7            pop d
0511   019D E4            pop a
0512   019E 06            sysret ; enable interrupts
0513   019F             
0514   019F             ; ------------------------------------------------------------------------------------------------------------------;
0515   019F             ; undefined opcode exception
0516   019F             ; ------------------------------------------------------------------------------------------------------------------;
0517   019F             trap_undef_opcode:
0518   019F 06            sysret
0519   01A0             
0520   01A0             ; ------------------------------------------------------------------------------------------------------------------;
0521   01A0             ; real-time clock services syscall
0522   01A0             ; rtc i/o bank = ffa0 to ffaf
0523   01A0             ; ffa0 to ffa7 is scratch ram
0524   01A0             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0525   01A0             ; al = 0..6 -> get
0526   01A0             ; al = 7..d -> set
0527   01A0             ; ------------------------------------------------------------------------------------------------------------------;
0528   01A0             syscall_rtc:
0529   01A0 DB            push al
0530   01A1 DA            push d
0531   01A2 B9 06         cmp al, 6
0532   01A4 D1 B9 01      jgu syscall_rtc_set
0533   01A7             syscall_rtc_get:
0534   01A7 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0535   01A9 22 FF         mov ah, $ff    
0536   01AB 3C            mov d, a                ; get to ffa9 + offset
0537   01AC F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0538   01B0 1E            mov al, [d]             ; get data
0539   01B1 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0540   01B5 23            mov ah, al
0541   01B6 E7            pop d
0542   01B7 E8            pop al
0543   01B8 06            sysret
0544   01B9             syscall_rtc_set:
0545   01B9 DD            push bl
0546   01BA 99            mov bl, ah              ; set data aside
0547   01BB 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0548   01BD 22 FF         mov ah, $ff    
0549   01BF 3C            mov d, a                ; get to ffa9 + offset
0550   01C0 1B            mov al, bl              ; get data back
0551   01C1 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0552   01C5 3E            mov [d], al             ; set data
0553   01C6 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0554   01CA EA            pop bl
0555   01CB E7            pop d
0556   01CC E8            pop al
0557   01CD 06            sysret
0558   01CE             
0559   01CE             datetime_serv_tbl:
0560   01CE D6 01         .dw print_date
0561   01D0 4A 02         .dw set_date
0562   01D2             syscall_datetime:
0563   01D2 FD 0A CE 01   jmp [datetime_serv_tbl + al]      
0564   01D6             print_date:
0565   01D6 10 00 0D      mov a, $0d00           ; print carriage return char
0566   01D9 19 03         mov al, 3
0567   01DB 05 01         syscall sys_rtc        ; get week
0568   01DD 1A            mov al, ah
0569   01DE 22 00         mov ah, 0
0570   01E0 FD 9D 02      shl a, 2          
0571   01E3 3B 17 0E      mov d, s_week
0572   01E6 59            add d, a
0573   01E7 07 C4 06      call _puts
0574   01EA 10 00 20      mov a, $2000
0575   01ED 05 03         syscall sys_io         ; display ' '
0576   01EF 19 04         mov al, 4
0577   01F1 05 01         syscall sys_rtc        ; get day
0578   01F3 99            mov bl, ah
0579   01F4 07 64 07      call print_u8x
0580   01F7 10 00 20      mov a, $2000
0581   01FA 05 03         syscall sys_io         ; display ' '
0582   01FC             ; there is a problem with the month displaying
0583   01FC             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0584   01FC             ; even though it is to be understood as bcd.
0585   01FC             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0586   01FC 19 05         mov al, 05
0587   01FE 05 01         syscall sys_rtc        ; get month
0588   0200 1A            mov al, ah
0589   0201 22 00         mov ah, 0
0590   0203 FD 9D 02      shl a, 2          
0591   0206 3B E3 0D      mov d, s_months
0592   0209 59            add d, a
0593   020A 07 C4 06      call _puts
0594   020D 10 00 20      mov a, $2000
0595   0210 05 03         syscall sys_io         ; display ' '
0596   0212 2E 20         mov bl, $20
0597   0214 07 64 07      call print_u8x         ; print 20 for year prefix
0598   0217 19 06         mov al, 06
0599   0219 05 01         syscall sys_rtc        ; get year
0600   021B 99            mov bl, ah
0601   021C 07 64 07      call print_u8x
0602   021F 10 00 20      mov a, $2000  
0603   0222 05 03         syscall sys_io         ; display ' '
0604   0224 19 02         mov al, 2
0605   0226 05 01         syscall sys_rtc        ; get hours
0606   0228 99            mov bl, ah
0607   0229 07 64 07      call print_u8x
0608   022C 10 00 3A      mov a, $3a00    
0609   022F 05 03         syscall sys_io         ; display ':'
0610   0231 19 01         mov al, 01
0611   0233 05 01         syscall sys_rtc        ; get minutes
0612   0235 99            mov bl, ah
0613   0236 07 64 07      call print_u8x
0614   0239 10 00 3A      mov a, $3a00  
0615   023C 05 03         syscall sys_io         ; display ':'
0616   023E 19 00         mov al, 0
0617   0240 05 01         syscall sys_rtc        ; get seconds
0618   0242 99            mov bl, ah
0619   0243 07 64 07      call print_u8x
0620   0246 07 71 06      call printnl
0621   0249 06            sysret
0622   024A             set_date:
0623   024A 3B A8 0D      mov d, s_set_year
0624   024D 07 C4 06      call _puts
0625   0250 07 AF 07      call scan_u8x          ; read integer into a
0626   0253 FD 9D 08      shl a, 8               ; only al used, move to ah
0627   0256 19 0D         mov al, 0dh            ; set rtc year
0628   0258 05 01         syscall sys_rtc        ; set rtc
0629   025A 3B AF 0D      mov d, s_set_month
0630   025D 07 C4 06      call _puts
0631   0260 07 AF 07      call scan_u8x          ; read integer into a
0632   0263 FD 9D 08      shl a, 8               ; only al used, move to ah
0633   0266 19 0C         mov al, 0ch            ; set rtc month
0634   0268 05 01         syscall sys_rtc        ; set rtc
0635   026A 3B B7 0D      mov d, s_set_day
0636   026D 07 C4 06      call _puts
0637   0270 07 AF 07      call scan_u8x          ; read integer into a
0638   0273 FD 9D 08      shl a, 8               ; only al used, move to ah
0639   0276 19 0B         mov al, 0bh            ; set rtc month
0640   0278 05 01         syscall sys_rtc        ; set rtc
0641   027A 3B BD 0D      mov d, s_set_week
0642   027D 07 C4 06      call _puts
0643   0280 07 AF 07      call scan_u8x          ; read integer into a
0644   0283 FD 9D 08      shl a, 8               ; only al used, move to ah
0645   0286 19 0A         mov al, 0ah            ; set rtc month
0646   0288 05 01         syscall sys_rtc        ; set rtc
0647   028A 3B C7 0D      mov d, s_set_hours
0648   028D 07 C4 06      call _puts
0649   0290 07 AF 07      call scan_u8x          ; read integer into a
0650   0293 FD 9D 08      shl a, 8               ; only al used, move to ah
0651   0296 19 09         mov al, 09h            ; set rtc month
0652   0298 05 01         syscall sys_rtc        ; set rtc
0653   029A 3B CF 0D      mov d, s_set_minutes
0654   029D 07 C4 06      call _puts
0655   02A0 07 AF 07      call scan_u8x          ; read integer into a
0656   02A3 FD 9D 08      shl a, 8               ; only al used, move to ah
0657   02A6 19 08         mov al, 08h            ; set rtc month
0658   02A8 05 01         syscall sys_rtc        ; set rtc
0659   02AA 3B D9 0D      mov d, s_set_seconds
0660   02AD 07 C4 06      call _puts
0661   02B0 07 AF 07      call scan_u8x          ; read integer into a
0662   02B3 FD 9D 08      shl a, 8               ; only al used, move to ah
0663   02B6 19 07         mov al, 07h            ; set rtc month
0664   02B8 05 01         syscall sys_rtc        ; set rtc
0665   02BA 06            sysret
0666   02BB             
0667   02BB             ; ------------------------------------------------------------------------------------------------------------------;
0668   02BB             ; ide services syscall
0669   02BB             ; al = option
0670   02BB             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0671   02BB             ; ide read/write sector
0672   02BB             ; 512 bytes
0673   02BB             ; user buffer pointer in d
0674   02BB             ; ah = number of sectors
0675   02BB             ; cb = lba bytes 3..0
0676   02BB             ; ------------------------------------------------------------------------------------------------------------------;
0677   02BB             ide_serv_tbl:
0678   02BB C7 02         .dw ide_reset
0679   02BD DB 02         .dw ide_sleep
0680   02BF EA 02         .dw ide_read_sect_wrapper
0681   02C1 EE 02         .dw ide_write_sect_wrapper
0682   02C3             syscall_ide:
0683   02C3 FD 0A BB 02   jmp [ide_serv_tbl + al]    
0684   02C7             
0685   02C7             ide_reset:      
0686   02C7 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
0687   02CB 07 74 03      call ide_wait                   ; wait for ide ready             
0688   02CE F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
0689   02D2 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
0690   02D6 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
0691   02DA 06            sysret
0692   02DB             ide_sleep:
0693   02DB 07 74 03      call ide_wait                   ; wait for ide ready             
0694   02DE F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
0695   02E2 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
0696   02E6 07 74 03      call ide_wait                   ; wait for ide ready
0697   02E9 06            sysret
0698   02EA             ide_read_sect_wrapper:
0699   02EA 07 F2 02      call ide_read_sect
0700   02ED 06            sysret
0701   02EE             ide_write_sect_wrapper:
0702   02EE 07 18 03      call ide_write_sect
0703   02F1 06            sysret
0704   02F2             ide_read_sect:
0705   02F2 1A            mov al, ah
0706   02F3 24            mov ah, bl
0707   02F4 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0708   02F7 1C            mov al, bh
0709   02F8 3D D4 FF      mov [_ide_r4], al
0710   02FB 12            mov a, c
0711   02FC 3D D5 FF      mov [_ide_r5], al
0712   02FF 1A            mov al, ah
0713   0300 87 0F         and al, %00001111
0714   0302 8B E0         or al, %11100000                ; mode lba, master
0715   0304 3D D6 FF      mov [_ide_r6], al
0716   0307             ide_read_sect_wait:
0717   0307 1D D7 FF      mov al, [_ide_r7]  
0718   030A 87 80         and al, $80                     ; busy flag
0719   030C C7 07 03      jnz ide_read_sect_wait
0720   030F 19 20         mov al, $20
0721   0311 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
0722   0314 07 3E 03      call ide_read  
0723   0317 09            ret
0724   0318             ide_write_sect:
0725   0318 1A            mov al, ah
0726   0319 24            mov ah, bl
0727   031A 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0728   031D 1C            mov al, bh
0729   031E 3D D4 FF      mov [_ide_r4], al
0730   0321 12            mov a, c
0731   0322 3D D5 FF      mov [_ide_r5], al
0732   0325 1A            mov al, ah
0733   0326 87 0F         and al, %00001111
0734   0328 8B E0         or al, %11100000                ; mode lba, master
0735   032A 3D D6 FF      mov [_ide_r6], al
0736   032D             ide_write_sect_wait:
0737   032D 1D D7 FF      mov al, [_ide_r7]  
0738   0330 87 80         and al, $80                     ; busy flag
0739   0332 C7 2D 03      jnz ide_write_sect_wait
0740   0335 19 30         mov al, $30
0741   0337 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
0742   033A 07 59 03      call ide_write      
0743   033D 09            ret
0744   033E             
0745   033E             ;----------------------------------------------------------------------------------------------------;
0746   033E             ; read ide data
0747   033E             ; pointer in d
0748   033E             ;----------------------------------------------------------------------------------------------------;
0749   033E             ide_read:
0750   033E DA            push d
0751   033F             ide_read_loop:
0752   033F 1D D7 FF      mov al, [_ide_r7]  
0753   0342 87 80         and al, 80h                     ; busy flag
0754   0344 C7 3F 03      jnz ide_read_loop               ; wait loop
0755   0347 1D D7 FF      mov al, [_ide_r7]
0756   034A 87 08         and al, %00001000               ; drq flag
0757   034C C6 57 03      jz ide_read_end
0758   034F 1D D0 FF      mov al, [_ide_r0]
0759   0352 3E            mov [d], al
0760   0353 79            inc d
0761   0354 0A 3F 03      jmp ide_read_loop
0762   0357             ide_read_end:
0763   0357 E7            pop d
0764   0358 09            ret
0765   0359             
0766   0359             ;----------------------------------------------------------------------------------------------------;
0767   0359             ; write ide data
0768   0359             ; data pointer in d
0769   0359             ;----------------------------------------------------------------------------------------------------;
0770   0359             ide_write:
0771   0359 DA            push d
0772   035A             ide_write_loop:
0773   035A 1D D7 FF      mov al, [_ide_r7]  
0774   035D 87 80         and al, 80h             ; busy flag
0775   035F C7 5A 03      jnz ide_write_loop      ; wait loop
0776   0362 1D D7 FF      mov al, [_ide_r7]
0777   0365 87 08         and al, %00001000       ; drq flag
0778   0367 C6 72 03      jz ide_write_end
0779   036A 1E            mov al, [d]
0780   036B 3D D0 FF      mov [_ide_r0], al
0781   036E 79            inc d 
0782   036F 0A 5A 03      jmp ide_write_loop
0783   0372             ide_write_end:
0784   0372 E7            pop d
0785   0373 09            ret
0786   0374             
0787   0374             ;----------------------------------------------------------------------------------------------------;
0788   0374             ; wait for ide to be ready
0789   0374             ;----------------------------------------------------------------------------------------------------;
0790   0374             ide_wait:
0791   0374 1D D7 FF      mov al, [_ide_r7]  
0792   0377 87 80         and al, 80h        ; busy flag
0793   0379 C7 74 03      jnz ide_wait
0794   037C 09            ret
0795   037D             
0796   037D             ;----------------------------------------------------------------------------------------------------;
0797   037D             ; io syscall
0798   037D             ;----------------------------------------------------------------------------------------------------;
0799   037D             ; baud  divisor
0800   037D             ; 50    2304
0801   037D             ; 110   1047
0802   037D             ; 300    384
0803   037D             ; 600    192
0804   037D             ; 1200    96
0805   037D             ; 9600    12
0806   037D             ; 19200    6
0807   037D             ; 38400    3
0808   037D             syscall_io_jmp:
0809   037D D8 03         .dw syscall_io_putchar
0810   037F F1 03         .dw syscall_io_getch
0811   0381 87 03         .dw syscall_io_uart_setup
0812   0383             syscall_io:
0813   0383 FD 0A 7D 03   jmp [syscall_io_jmp + al]
0814   0387             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
0815   0387             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
0816   0387             ; buffer, the transmitter holding register, or the interrupt enable register.
0817   0387             syscall_io_uart_setup:
0818   0387 1D ED 0B      mov al, [sys_uart0_lcr]
0819   038A 8B 80         or al, $80                ; set dlab access bit
0820   038C 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, even parity 
0821   038F 1D F0 0B      mov al, [sys_uart0_div0]
0822   0392 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
0823   0395 1D F1 0B      mov al, [sys_uart0_div1]
0824   0398 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
0825   039B 1D ED 0B      mov al, [sys_uart0_lcr]
0826   039E 87 7F         and al, $7f               ; clear dlab access bit 
0827   03A0 3D 83 FF      mov [_uart0_lcr], al
0828   03A3 1D EE 0B      mov al, [sys_uart0_inten]
0829   03A6 3D 81 FF      mov [_uart0_ier], al      ; interrupts
0830   03A9 1D EF 0B      mov al, [sys_uart0_fifoen]
0831   03AC 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
0832   03AF             
0833   03AF             ; uart1:
0834   03AF 1D F2 0B      mov al, [sys_uart1_lcr]
0835   03B2 8B 80         or al, $80                ; set dlab access bit
0836   03B4 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, even parity 
0837   03B7 1D F5 0B      mov al, [sys_uart1_div0]
0838   03BA 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
0839   03BD 1D F6 0B      mov al, [sys_uart1_div1]
0840   03C0 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
0841   03C3 1D F2 0B      mov al, [sys_uart1_lcr]
0842   03C6 87 7F         and al, $7f               ; clear dlab access bit 
0843   03C8 3D 8B FF      mov [_uart1_lcr], al
0844   03CB 1D F3 0B      mov al, [sys_uart1_inten]
0845   03CE 3D 89 FF      mov [_uart1_ier], al      ; interrupts
0846   03D1 1D F4 0B      mov al, [sys_uart1_fifoen]
0847   03D4 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
0848   03D7 06            sysret
0849   03D8             
0850   03D8             ; char in ah
0851   03D8             syscall_io_putchar:
0852   03D8             syscall_io_putchar_l0:
0853   03D8 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0854   03DB 93 20         test al, $20
0855   03DD C6 D8 03      jz syscall_io_putchar_l0    
0856   03E0 1A            mov al, ah
0857   03E1 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0858   03E4             ; uart1
0859   03E4             syscall_io_putchar_l1:
0860   03E4 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0861   03E7 93 20         test al, $20
0862   03E9 C6 E4 03      jz syscall_io_putchar_l1    
0863   03EC 1A            mov al, ah
0864   03ED 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0865   03F0 06            sysret
0866   03F1             
0867   03F1             ; char in ah
0868   03F1             ; al = sucess code
0869   03F1             syscall_io_getch:
0870   03F1 D8            push b
0871   03F2 DA            push d
0872   03F3 FD 0C         sti
0873   03F5             syscall_io_getch_l0:  
0874   03F5 14 F9 0B      mov a, [fifo_out]
0875   03F8 29 F7 0B      mov b, [fifo_in]
0876   03FB B0            cmp a, b
0877   03FC C6 F5 03      je syscall_io_getch_l0
0878   03FF 3C            mov d, a
0879   0400 77            inc a
0880   0401 AF 85 1E      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
0881   0404 C7 0A 04      jne syscall_io_getch_cont
0882   0407 10 85 0E      mov a, fifo  
0883   040A             syscall_io_getch_cont:  
0884   040A 42 F9 0B      mov [fifo_out], a             ; update fifo pointer
0885   040D 1E            mov al, [d]                   ; get char
0886   040E 23            mov ah, al
0887   040F             ; here we just echo the char back to the console
0888   040F             syscall_io_getch_echo_l0:
0889   040F 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0890   0412 87 20         and al, $20                 ; isolate transmitter empty
0891   0414 C6 0F 04      jz syscall_io_getch_echo_l0
0892   0417 1A            mov al, ah
0893   0418 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0894   041B             syscall_io_getch_echo_l1:
0895   041B 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0896   041E 87 20         and al, $20                 ; isolate transmitter empty
0897   0420 C6 1B 04      jz syscall_io_getch_echo_l1
0898   0423 1A            mov al, ah
0899   0424 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0900   0427             syscall_io_getch_noecho:
0901   0427 19 01         mov al, 1                    ; al = 1 means a char successfully received
0902   0429 E7            pop d
0903   042A E5            pop b
0904   042B 06            sysret
0905   042C             
0906   042C             ;------------------------------------------------------------------------------------------------------;
0907   042C             ; file system data
0908   042C             ;------------------------------------------------------------------------------------------------------;
0909   042C             ; infor for : ide services interrupt
0910   042C             ; ide read/write 512-byte sector
0911   042C             ; al = option
0912   042C             ; user buffer pointer in d
0913   042C             ; ah = number of sectors
0914   042C             ; cb = lba bytes 3..0  
0915   042C             ;------------------------------------------------------------------------------------------------------;
0916   042C             ; file system data structure
0917   042C             ;------------------------------------------------------------------------------------------------------;
0918   042C             ; first directory on disk is the root directory '/'
0919   042C             file_system_jmptbl:
0920   042C 3F 04         .dw fs_cd                     
0921   042E 40 04         .dw fs_ls                     
0922   0430 44 04         .dw fs_pwd                    
0923   0432 45 04         .dw fs_rmdir                  
0924   0434 3E 04         .dw fs_mkdir
0925   0436 46 04         .dw fs_rm                     
0926   0438 47 04         .dw fs_mv                     
0927   043A             
0928   043A             syscall_file_system:
0929   043A FD 0A 2C 04   jmp [file_system_jmptbl + al]
0930   043E             
0931   043E             ;------------------------------------------------------------------------------------------------------;
0932   043E             ; create new directory
0933   043E             ;------------------------------------------------------------------------------------------------------;
0934   043E             ; search list for null name entry. add new directory to list
0935   043E             fs_mkdir:
0936   043E 06            sysret
0937   043F             
0938   043F             ;------------------------------------------------------------------------------------------------------;
0939   043F             ; cd
0940   043F             ;------------------------------------------------------------------------------------------------------;
0941   043F             fs_cd:
0942   043F 06            sysret  
0943   0440             
0944   0440             ;------------------------------------------------------------------------------------------------------;
0945   0440             ; ls
0946   0440             ;------------------------------------------------------------------------------------------------------;
0947   0440             ; inode in a
0948   0440             fs_ls:
0949   0440 3B 1C 00      mov d, inode_table_sect_start
0950   0443             
0951   0443 06            sysret
0952   0444             
0953   0444             ;------------------------------------------------------------------------------------------------------;
0954   0444             ; pwd - print working directory
0955   0444             ;------------------------------------------------------------------------------------------------------;    
0956   0444             fs_pwd:
0957   0444 06            sysret
0958   0445             
0959   0445             ;------------------------------------------------------------------------------------------------------;
0960   0445             ; rmdir - remove dir by dirid
0961   0445             ;------------------------------------------------------------------------------------------------------;
0962   0445             fs_rmdir:
0963   0445 06            sysret
0964   0446             
0965   0446             ;------------------------------------------------------------------------------------------------------;
0966   0446             ; rm - remove file
0967   0446             ;------------------------------------------------------------------------------------------------------;
0968   0446             fs_rm:
0969   0446 06            sysret  
0970   0447             
0971   0447             ;------------------------------------------------------------------------------------------------------;
0972   0447             ; mv - move / change file name
0973   0447             ;------------------------------------------------------------------------------------------------------;
0974   0447             fs_mv:
0975   0447 06            sysret
0976   0448             
0977   0448             
0978   0448             ;----------------------------------------------------------------------------------------------;
0979   0448             ; get hex file
0980   0448             ; di = destination address
0981   0448             ; return length in bytes in c
0982   0448             ;----------------------------------------------------------------------------------------------;
0983   0448             _load_hex:
0984   0448 D7            push a
0985   0449 D8            push b
0986   044A DA            push d
0987   044B E2            push si
0988   044C E3            push di
0989   044D 38 00 00      mov c, 0
0990   0450 50            mov a, di
0991   0451 3C            mov d, a          ; start of string data block
0992   0452 07 9F 05      call _gets        ; get program string
0993   0455 4D            mov si, a
0994   0456             __load_hex_loop:
0995   0456 F6            lodsb             ; load from [si] to al
0996   0457 B9 00         cmp al, 0         ; check if ascii 0
0997   0459 C6 67 04      jz __load_hex_ret
0998   045C 36            mov bh, al
0999   045D F6            lodsb
1000   045E 2F            mov bl, al
1001   045F 07 55 05      call _atoi        ; convert ascii byte in b to int (to al)
1002   0462 F7            stosb             ; store al to [di]
1003   0463 78            inc c
1004   0464 0A 56 04      jmp __load_hex_loop
1005   0467             __load_hex_ret:
1006   0467 F0            pop di
1007   0468 EF            pop si
1008   0469 E7            pop d
1009   046A E5            pop b
1010   046B E4            pop a
1011   046C 09            ret
1012   046D             
1013   046D             ; ---------------------------------------------------------------------
1014   046D             ; kernel reset vector
1015   046D             ; ---------------------------------------------------------------------
1016   046D             kernel_reset_vector:  
1017   046D FD 49 FF F7   mov bp, _stack_top
1018   0471 FD 47 FF F7   mov sp, _stack_top
1019   0475               
1020   0475 0C            lodstat
1021   0476 87 DF         and al, %11011111             ; disable display register loading
1022   0478 0D            stostat
1023   0479             
1024   0479             ; reset fifo pointers
1025   0479 10 85 0E      mov a, fifo
1026   047C 3B F7 0B      mov d, fifo_in
1027   047F 43            mov [d], a
1028   0480 3B F9 0B      mov d, fifo_out
1029   0483 43            mov [d], a  
1030   0484 19 02         mov al, 2
1031   0486 05 03         syscall sys_io                ; enable uart in interrupt mode
1032   0488             
1033   0488 19 A0         mov al, %10100000             ; uart0 | timer | uart1 | 0 | 0 | 0 | 0| fdc
1034   048A FD 0F         stomsk                        
1035   048C FD 0C         sti  
1036   048E             
1037   048E 3B 4C 0C      mov d, s_kernel_welcome
1038   0491 07 C4 06      call _puts
1039   0494             
1040   0494 3B 44 0E      mov d, s_fdc_config
1041   0497 07 C4 06      call _puts
1042   049A             
1043   049A F2 C0 FF 0D   mov byte [_fdc_config], %00001101   ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
1044   049E F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011 ; leave this restore command in order to clear BUSY flag
1045   04A2 F2 C9 FF 00   mov byte [_fdc_track], $00          ; reset track
1046   04A6             
1047   04A6             
1048   04A6 10 00 00      mov a, 0
1049   04A9             ker_loop:
1050   04A9 77            inc a
1051   04AA 3D B0 FF      mov [_til311_display], al
1052   04AD 0A A9 04      jmp ker_loop
1053   04B0             
1054   04B0             
1055   04B0             ; file includes
1056   04B0             .include "lib/bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  04B0             boot_origin      .EQU  $8004
0002+  04B0             bios_uart        .EQU  $0002
0003+  04B0             bios_ide         .EQU  $0003
0004+  04B0             bios_reset_vector .EQU  $0190
0005+  04B0             ide_buffer       .EQU  $8404
0006+  04B0             inode_buffer     .EQU  $8c04
0007+  04B0             noname.__print_u16x .EQU  $01f6
0008+  04B0             noname.__xput_u8 .EQU  $023e
0009+  04B0             noname.__puts    .EQU  $0252
0010+  04B0             noname.__print_u16d .EQU  $0379
1057   04B0             .include "lib/stdio.asm"
0001+  04B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04B0             ; stdio.s
0003+  04B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04B0             .include "lib/string.asm"
0001++ 04B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04B0             ; string.s
0003++ 04B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04B0             
0005++ 04B0             
0006++ 04B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04B0             ; _strrev
0008++ 04B0             ; reverse a string
0009++ 04B0             ; d = string address
0010++ 04B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04B0             ; 01234
0012++ 04B0             _strrev:
0013++ 04B0 4B          	pusha
0014++ 04B1 07 F7 04    	call _strlen	; length in c
0015++ 04B4 12          	mov a, c
0016++ 04B5 AF 01 00    	cmp a, 1
0017++ 04B8 D0 D2 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04BB 7D          	dec a
0019++ 04BC FD 4E       	mov si, d	; beginning of string
0020++ 04BE FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04C0 59          	add d, a	; end of string
0022++ 04C1 12          	mov a, c
0023++ 04C2 FD 9B       	shr a		; divide by 2
0024++ 04C4 39          	mov c, a	; c now counts the steps
0025++ 04C5             _strrev_l0:
0026++ 04C5 32          	mov bl, [d]	; save load right-side char into bl
0027++ 04C6 F6          	lodsb		; load left-side char into al; increase si
0028++ 04C7 3E          	mov [d], al	; store left char into right side
0029++ 04C8 1B          	mov al, bl
0030++ 04C9 F7          	stosb		; store right-side char into left-side; increase di
0031++ 04CA 7E          	dec c
0032++ 04CB 7F          	dec d
0033++ 04CC C2 00 00    	cmp c, 0
0034++ 04CF C7 C5 04    	jne _strrev_l0
0035++ 04D2             _strrev_end:
0036++ 04D2 4C          	popa
0037++ 04D3 09          	ret
0038++ 04D4             	
0039++ 04D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04D4             ; _strchr
0041++ 04D4             ; search string in d for char in al
0042++ 04D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04D4             _strchr:
0044++ 04D4             _strchr_l0:
0045++ 04D4 32          	mov bl, [d]
0046++ 04D5 C1 00       	cmp bl, 0
0047++ 04D7 C6 E2 04    	je _strchr_end
0048++ 04DA BA          	cmp al, bl
0049++ 04DB C6 E2 04    	je _strchr_end
0050++ 04DE 79          	inc d
0051++ 04DF 0A D4 04    	jmp _strchr_l0
0052++ 04E2             _strchr_end:
0053++ 04E2 1B          	mov al, bl
0054++ 04E3 09          	ret
0055++ 04E4             
0056++ 04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04E4             ; _strstr
0058++ 04E4             ; find sub-string
0059++ 04E4             ; str1 in si
0060++ 04E4             ; str2 in di
0061++ 04E4             ; si points to end of source string
0062++ 04E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04E4             _strstr:
0064++ 04E4 DB          	push al
0065++ 04E5 DA          	push d
0066++ 04E6 E3          	push di
0067++ 04E7             _strstr_loop:
0068++ 04E7 F3          	cmpsb					; compare a byte of the strings
0069++ 04E8 C7 F3 04    	jne _strstr_ret
0070++ 04EB FC 00 00    	lea d, [di + 0]
0071++ 04EE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04F0 C7 E7 04    	jne _strstr_loop				; equal chars but not at end
0073++ 04F3             _strstr_ret:
0074++ 04F3 F0          	pop di
0075++ 04F4 E7          	pop d
0076++ 04F5 E8          	pop al
0077++ 04F6 09          	ret
0078++ 04F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04F7             ; length of null terminated string
0080++ 04F7             ; result in c
0081++ 04F7             ; pointer in d
0082++ 04F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04F7             _strlen:
0084++ 04F7 DA          	push d
0085++ 04F8 38 00 00    	mov c, 0
0086++ 04FB             _strlen_l1:
0087++ 04FB BD 00       	cmp byte [d], 0
0088++ 04FD C6 05 05    	je _strlen_ret
0089++ 0500 79          	inc d
0090++ 0501 78          	inc c
0091++ 0502 0A FB 04    	jmp _strlen_l1
0092++ 0505             _strlen_ret:
0093++ 0505 E7          	pop d
0094++ 0506 09          	ret
0095++ 0507             
0096++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0507             ; strcmp
0098++ 0507             ; compare two strings
0099++ 0507             ; str1 in si
0100++ 0507             ; str2 in di
0101++ 0507             ; create a string compairon instrucion ?????
0102++ 0507             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0507             _strcmp:
0104++ 0507 DB          	push al
0105++ 0508 DA          	push d
0106++ 0509 E3          	push di
0107++ 050A E2          	push si
0108++ 050B             _strcmp_loop:
0109++ 050B F3          	cmpsb					; compare a byte of the strings
0110++ 050C C7 17 05    	jne _strcmp_ret
0111++ 050F FB FF FF    	lea d, [si +- 1]
0112++ 0512 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0514 C7 0B 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 0517             _strcmp_ret:
0115++ 0517 EF          	pop si
0116++ 0518 F0          	pop di
0117++ 0519 E7          	pop d
0118++ 051A E8          	pop al
0119++ 051B 09          	ret
0120++ 051C             
0121++ 051C             
0122++ 051C             ; strcpy
0123++ 051C             ; copy null terminated string from si to di
0124++ 051C             ; source in si
0125++ 051C             ; destination in di
0126++ 051C             _strcpy:
0127++ 051C E2          	push si
0128++ 051D E3          	push di
0129++ 051E DB          	push al
0130++ 051F             _strcpy_l1:
0131++ 051F F6          	lodsb
0132++ 0520 F7          	stosb
0133++ 0521 B9 00       	cmp al, 0
0134++ 0523 C7 1F 05    	jne _strcpy_l1
0135++ 0526             _strcpy_end:
0136++ 0526 E8          	pop al
0137++ 0527 F0          	pop di
0138++ 0528 EF          	pop si
0139++ 0529 09          	ret
0140++ 052A             
0141++ 052A             ; strcat
0142++ 052A             ; concatenate a null terminated string into string at di, from string at si
0143++ 052A             ; source in si
0144++ 052A             ; destination in di
0145++ 052A             _strcat:
0146++ 052A E2          	push si
0147++ 052B E3          	push di
0148++ 052C D7          	push a
0149++ 052D DA          	push d
0150++ 052E 50          	mov a, di
0151++ 052F 3C          	mov d, a
0152++ 0530             _strcat_goto_end_l1:
0153++ 0530 BD 00       	cmp byte[d], 0
0154++ 0532 C6 39 05    	je _strcat_start
0155++ 0535 79          	inc d
0156++ 0536 0A 30 05    	jmp _strcat_goto_end_l1
0157++ 0539             _strcat_start:
0158++ 0539 FD 50       	mov di, d
0159++ 053B             _strcat_l1:
0160++ 053B F6          	lodsb
0161++ 053C F7          	stosb
0162++ 053D B9 00       	cmp al, 0
0163++ 053F C7 3B 05    	jne _strcat_l1
0164++ 0542             _strcat_end:
0165++ 0542 E7          	pop d
0166++ 0543 E4          	pop a
0167++ 0544 F0          	pop di
0168++ 0545 EF          	pop si
0169++ 0546 09          	ret
0170++ 0547             
0171++ 0547             
0005+  0547             
0006+  0547             
0007+  0547             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0547             ; convert ascii 'o'..'f' to integer 0..15
0009+  0547             ; ascii in bl
0010+  0547             ; result in al
0011+  0547             ; ascii for f = 0100 0110
0012+  0547             ; ascii for 9 = 0011 1001
0013+  0547             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0547             hex_ascii_encode:
0015+  0547 1B            mov al, bl
0016+  0548 93 40         test al, $40        ; test if letter or number
0017+  054A C7 50 05      jnz hex_letter
0018+  054D 87 0F         and al, $0f        ; get number
0019+  054F 09            ret
0020+  0550             hex_letter:
0021+  0550 87 0F         and al, $0f        ; get letter
0022+  0552 6A 09         add al, 9
0023+  0554 09            ret
0024+  0555             
0025+  0555             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0555             ; atoi
0027+  0555             ; 2 letter hex string in b
0028+  0555             ; 8bit integer returned in al
0029+  0555             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0555             _atoi:
0031+  0555 D8            push b
0032+  0556 07 47 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0559 30            mov bl, bh
0034+  055A DB            push al          ; save a
0035+  055B 07 47 05      call hex_ascii_encode
0036+  055E EA            pop bl  
0037+  055F FD 9E 04      shl al, 4
0038+  0562 8C            or al, bl
0039+  0563 E5            pop b
0040+  0564 09            ret  
0041+  0565             
0042+  0565             
0043+  0565             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0565             ; scanf
0045+  0565             ; no need for explanations!
0046+  0565             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0565             scanf:
0048+  0565 09            ret
0049+  0566             
0050+  0566             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0566             ; itoa
0052+  0566             ; 8bit value in bl
0053+  0566             ; 2 byte ascii result in a
0054+  0566             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0566             _itoa:
0056+  0566 DA            push d
0057+  0567 D8            push b
0058+  0568 A7 00         mov bh, 0
0059+  056A FD A4 04      shr bl, 4  
0060+  056D 74            mov d, b
0061+  056E 1F 00 08      mov al, [d + s_hex_digits]
0062+  0571 23            mov ah, al
0063+  0572               
0064+  0572 E5            pop b
0065+  0573 D8            push b
0066+  0574 A7 00         mov bh, 0
0067+  0576 FD 87 0F      and bl, $0f
0068+  0579 74            mov d, b
0069+  057A 1F 00 08      mov al, [d + s_hex_digits]
0070+  057D E5            pop b
0071+  057E E7            pop d
0072+  057F 09            ret
0073+  0580             
0074+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0580             ; hex string to binary
0076+  0580             ; di = destination address
0077+  0580             ; si = source
0078+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0580             _hex_to_int:
0080+  0580             _hex_to_int_l1:
0081+  0580 F6            lodsb          ; load from [si] to al
0082+  0581 B9 00         cmp al, 0        ; check if ascii 0
0083+  0583 C6 90 05      jz _hex_to_int_ret
0084+  0586 36            mov bh, al
0085+  0587 F6            lodsb
0086+  0588 2F            mov bl, al
0087+  0589 07 55 05      call _atoi        ; convert ascii byte in b to int (to al)
0088+  058C F7            stosb          ; store al to [di]
0089+  058D 0A 80 05      jmp _hex_to_int_l1
0090+  0590             _hex_to_int_ret:
0091+  0590 09            ret    
0092+  0591             
0093+  0591             
0094+  0591             
0095+  0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0591             ; getchar
0097+  0591             ; char in ah
0098+  0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0591             getch:
0100+  0591 DB            push al
0101+  0592             getch_retry:
0102+  0592 19 01         mov al, 1
0103+  0594 05 03         syscall sys_io      ; receive in ah
0104+  0596 E8            pop al
0105+  0597 09            ret
0106+  0598             
0107+  0598             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0598             ; putchar
0109+  0598             ; char in ah
0110+  0598             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0598             _putchar:
0112+  0598 DB            push al
0113+  0599 19 00         mov al, 0
0114+  059B 05 03         syscall sys_io      ; char in ah
0115+  059D E8            pop al
0116+  059E 09            ret
0117+  059F             
0118+  059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  059F             ;; input a string
0120+  059F             ;; terminates with null
0121+  059F             ;; pointer in d
0122+  059F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  059F             _gets:
0124+  059F D7            push a
0125+  05A0 DA            push d
0126+  05A1             _gets_loop:
0127+  05A1 19 01         mov al, 1
0128+  05A3 05 03         syscall sys_io      ; receive in ah
0129+  05A5 76 1B         cmp ah, 27
0130+  05A7 C6 C8 05      je _gets_ansi_esc
0131+  05AA 76 0A         cmp ah, $0a        ; lf
0132+  05AC C6 24 06      je _gets_end
0133+  05AF 76 0D         cmp ah, $0d        ; cr
0134+  05B1 C6 24 06      je _gets_end
0135+  05B4 76 5C         cmp ah, $5c        ; '\\'
0136+  05B6 C6 EA 05      je _gets_escape
0137+  05B9 76 08         cmp ah, $08      ; check for backspace
0138+  05BB C6 C4 05      je _gets_backspace
0139+  05BE 1A            mov al, ah
0140+  05BF 3E            mov [d], al
0141+  05C0 79            inc d
0142+  05C1 0A A1 05      jmp _gets_loop
0143+  05C4             _gets_backspace:
0144+  05C4 7F            dec d
0145+  05C5 0A A1 05      jmp _gets_loop
0146+  05C8             _gets_ansi_esc:
0147+  05C8 19 01         mov al, 1
0148+  05CA 05 03         syscall sys_io        ; receive in ah without echo
0149+  05CC 76 5B         cmp ah, '['
0150+  05CE C7 A1 05      jne _gets_loop
0151+  05D1 19 01         mov al, 1
0152+  05D3 05 03         syscall sys_io          ; receive in ah without echo
0153+  05D5 76 64         cmp ah, 'd'
0154+  05D7 C6 E2 05      je _gets_left_arrow
0155+  05DA 76 63         cmp ah, 'c'
0156+  05DC C6 E6 05      je _gets_right_arrow
0157+  05DF 0A A1 05      jmp _gets_loop
0158+  05E2             _gets_left_arrow:
0159+  05E2 7F            dec d
0160+  05E3 0A A1 05      jmp _gets_loop
0161+  05E6             _gets_right_arrow:
0162+  05E6 79            inc d
0163+  05E7 0A A1 05      jmp _gets_loop
0164+  05EA             _gets_escape:
0165+  05EA 19 01         mov al, 1
0166+  05EC 05 03         syscall sys_io      ; receive in ah
0167+  05EE 76 6E         cmp ah, 'n'
0168+  05F0 C6 0F 06      je _gets_lf
0169+  05F3 76 72         cmp ah, 'r'
0170+  05F5 C6 16 06      je _gets_cr
0171+  05F8 76 30         cmp ah, '0'
0172+  05FA C6 1D 06      je _gets_null
0173+  05FD 76 5C         cmp ah, $5c  ; '\'
0174+  05FF C6 08 06      je _gets_slash
0175+  0602 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0603 3E            mov [d], al
0177+  0604 79            inc d
0178+  0605 0A A1 05      jmp _gets_loop
0179+  0608             _gets_slash:
0180+  0608 19 5C         mov al, $5c
0181+  060A 3E            mov [d], al
0182+  060B 79            inc d
0183+  060C 0A A1 05      jmp _gets_loop
0184+  060F             _gets_lf:
0185+  060F 19 0A         mov al, $0a
0186+  0611 3E            mov [d], al
0187+  0612 79            inc d
0188+  0613 0A A1 05      jmp _gets_loop
0189+  0616             _gets_cr:
0190+  0616 19 0D         mov al, $0d
0191+  0618 3E            mov [d], al
0192+  0619 79            inc d
0193+  061A 0A A1 05      jmp _gets_loop
0194+  061D             _gets_null:
0195+  061D 19 00         mov al, $00
0196+  061F 3E            mov [d], al
0197+  0620 79            inc d
0198+  0621 0A A1 05      jmp _gets_loop
0199+  0624             _gets_end:
0200+  0624 19 00         mov al, 0
0201+  0626 3E            mov [d], al        ; terminate string
0202+  0627 E7            pop d
0203+  0628 E4            pop a
0204+  0629 09            ret
0205+  062A             
0206+  062A             
0207+  062A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  062A             ;; input text
0209+  062A             ;; terminated with ctrl+d
0210+  062A             ;; pointer in d
0211+  062A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  062A             _gettxt:
0213+  062A D7            push a
0214+  062B DA            push d
0215+  062C             _gettxt_loop:
0216+  062C 19 01         mov al, 1
0217+  062E 05 03         syscall sys_io      ; receive in ah
0218+  0630 76 04         cmp ah, 4      ; eot
0219+  0632 C6 6B 06      je _gettxt_end
0220+  0635 76 08         cmp ah, $08      ; check for backspace
0221+  0637 C6 67 06      je _gettxt_backspace
0222+  063A 76 5C         cmp ah, $5c        ; '\'
0223+  063C C6 45 06      je _gettxt_escape
0224+  063F 1A            mov al, ah
0225+  0640 3E            mov [d], al
0226+  0641 79            inc d
0227+  0642 0A 2C 06      jmp _gettxt_loop
0228+  0645             _gettxt_escape:
0229+  0645 19 01         mov al, 1
0230+  0647 05 03         syscall sys_io      ; receive in ah
0231+  0649 76 6E         cmp ah, 'n'
0232+  064B C6 59 06      je _gettxt_lf
0233+  064E 76 72         cmp ah, 'r'
0234+  0650 C6 60 06      je _gettxt_cr
0235+  0653 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0654 3E            mov [d], al
0237+  0655 79            inc d
0238+  0656 0A 2C 06      jmp _gettxt_loop
0239+  0659             _gettxt_lf:
0240+  0659 19 0A         mov al, $0a
0241+  065B 3E            mov [d], al
0242+  065C 79            inc d
0243+  065D 0A 2C 06      jmp _gettxt_loop
0244+  0660             _gettxt_cr:
0245+  0660 19 0D         mov al, $0d
0246+  0662 3E            mov [d], al
0247+  0663 79            inc d
0248+  0664 0A 2C 06      jmp _gettxt_loop
0249+  0667             _gettxt_backspace:
0250+  0667 7F            dec d
0251+  0668 0A 2C 06      jmp _gettxt_loop
0252+  066B             _gettxt_end:
0253+  066B 19 00         mov al, 0
0254+  066D 3E            mov [d], al        ; terminate string
0255+  066E E7            pop d
0256+  066F E4            pop a
0257+  0670 09            ret
0258+  0671             
0259+  0671             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0671             ; print new line
0261+  0671             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0671             printnl:
0263+  0671 D7            push a
0264+  0672 10 00 0A      mov a, $0a00
0265+  0675 05 03         syscall sys_io
0266+  0677 10 00 0D      mov a, $0d00
0267+  067A 05 03         syscall sys_io
0268+  067C E4            pop a
0269+  067D 09            ret
0270+  067E             
0271+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  067E             ; _strtoint
0273+  067E             ; 4 digit hex string number in d
0274+  067E             ; integer returned in a
0275+  067E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  067E             _strtointx:
0277+  067E D8            push b
0278+  067F 32            mov bl, [d]
0279+  0680 37            mov bh, bl
0280+  0681 33 01 00      mov bl, [d + 1]
0281+  0684 07 55 05      call _atoi        ; convert to int in al
0282+  0687 23            mov ah, al        ; move to ah
0283+  0688 33 02 00      mov bl, [d + 2]
0284+  068B 37            mov bh, bl
0285+  068C 33 03 00      mov bl, [d + 3]
0286+  068F 07 55 05      call _atoi        ; convert to int in al
0287+  0692 E5            pop b
0288+  0693 09            ret
0289+  0694             
0290+  0694             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0694             ; _strtoint
0292+  0694             ; 5 digit base10 string number in d
0293+  0694             ; integer returned in a
0294+  0694             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0694             _strtoint:
0296+  0694 E2            push si
0297+  0695 D8            push b
0298+  0696 D9            push c
0299+  0697 DA            push d
0300+  0698 07 F7 04      call _strlen      ; get string length in c
0301+  069B 7E            dec c
0302+  069C FD 4E         mov si, d
0303+  069E 12            mov a, c
0304+  069F FD 99         shl a
0305+  06A1 3B 18 08      mov d, table_power
0306+  06A4 59            add d, a
0307+  06A5 38 00 00      mov c, 0
0308+  06A8             _strtoint_l0:
0309+  06A8 F6            lodsb      ; load ascii to al
0310+  06A9 B9 00         cmp al, 0
0311+  06AB C6 BE 06      je _strtoint_end
0312+  06AE 6F 30         sub al, $30    ; make into integer
0313+  06B0 22 00         mov ah, 0
0314+  06B2 2A            mov b, [d]
0315+  06B3 AC            mul a, b      ; result in b since it fits in 16bits
0316+  06B4 11            mov a, b
0317+  06B5 28            mov b, c
0318+  06B6 54            add a, b
0319+  06B7 39            mov c, a
0320+  06B8 63 02 00      sub d, 2
0321+  06BB 0A A8 06      jmp _strtoint_l0
0322+  06BE             _strtoint_end:
0323+  06BE 12            mov a, c
0324+  06BF E7            pop d
0325+  06C0 E6            pop c
0326+  06C1 E5            pop b
0327+  06C2 EF            pop si
0328+  06C3 09            ret
0329+  06C4             
0330+  06C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  06C4             ; print null terminated string
0332+  06C4             ; pointer in d
0333+  06C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  06C4             _puts:
0335+  06C4 D7            push a
0336+  06C5 DA            push d
0337+  06C6             _puts_l1:
0338+  06C6 1E            mov al, [d]
0339+  06C7 B9 00         cmp al, 0
0340+  06C9 C6 D5 06      jz _puts_end
0341+  06CC 23            mov ah, al
0342+  06CD 19 00         mov al, 0
0343+  06CF 05 03         syscall sys_io
0344+  06D1 79            inc d
0345+  06D2 0A C6 06      jmp _puts_l1
0346+  06D5             _puts_end:
0347+  06D5 E7            pop d
0348+  06D6 E4            pop a
0349+  06D7 09            ret
0350+  06D8             
0351+  06D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  06D8             ; print n size string
0353+  06D8             ; pointer in d
0354+  06D8             ; size in c
0355+  06D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  06D8             _putsn:
0357+  06D8 DB            push al
0358+  06D9 DA            push d
0359+  06DA D9            push c
0360+  06DB             _putsn_l0:
0361+  06DB 1E            mov al, [d]
0362+  06DC 23            mov ah, al
0363+  06DD 19 00         mov al, 0
0364+  06DF 05 03         syscall sys_io
0365+  06E1 79            inc d
0366+  06E2 7E            dec c  
0367+  06E3 C2 00 00      cmp c, 0
0368+  06E6 C7 DB 06      jne _putsn_l0
0369+  06E9             _putsn_end:
0370+  06E9 E6            pop c
0371+  06EA E7            pop d
0372+  06EB E8            pop al
0373+  06EC 09            ret
0374+  06ED             
0375+  06ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  06ED             ; print 16bit decimal number
0377+  06ED             ; input number in a
0378+  06ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06ED             print_u16d:
0380+  06ED D7            push a
0381+  06EE D8            push b
0382+  06EF FD D8         push g
0383+  06F1 26 10 27      mov b, 10000
0384+  06F4 AE            div a, b      ; get 10000's coeff.
0385+  06F5 07 19 07      call print_number
0386+  06F8 11            mov a, b
0387+  06F9 26 E8 03      mov b, 1000
0388+  06FC AE            div a, b      ; get 1000's coeff.
0389+  06FD 07 19 07      call print_number
0390+  0700 11            mov a, b
0391+  0701 26 64 00      mov b, 100
0392+  0704 AE            div a, b
0393+  0705 07 19 07      call print_number
0394+  0708 11            mov a, b
0395+  0709 26 0A 00      mov b, 10
0396+  070C AE            div a, b
0397+  070D 07 19 07      call print_number
0398+  0710 1B            mov al, bl      ; 1's coeff in bl
0399+  0711 07 19 07      call print_number
0400+  0714 FD F1         pop g
0401+  0716 E5            pop b
0402+  0717 E4            pop a
0403+  0718 09            ret
0404+  0719             
0405+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0719             ; print al
0407+  0719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0719             print_number:
0409+  0719 6A 30         add al, $30
0410+  071B 23            mov ah, al
0411+  071C 07 98 05      call _putchar
0412+  071F 09            ret
0413+  0720             
0414+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0720             ; print 16bit hex integer
0416+  0720             ; integer value in reg b
0417+  0720             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0720             print_u16x:
0419+  0720 D7            push a
0420+  0721 D8            push b
0421+  0722 DD            push bl
0422+  0723 30            mov bl, bh
0423+  0724 07 66 05      call _itoa        ; convert bh to char in a
0424+  0727 2F            mov bl, al        ; save al
0425+  0728 19 00         mov al, 0
0426+  072A 05 03         syscall sys_io        ; display ah
0427+  072C 24            mov ah, bl        ; retrieve al
0428+  072D 19 00         mov al, 0
0429+  072F 05 03         syscall sys_io        ; display al
0430+  0731             
0431+  0731 EA            pop bl
0432+  0732 07 66 05      call _itoa        ; convert bh to char in a
0433+  0735 2F            mov bl, al        ; save al
0434+  0736 19 00         mov al, 0
0435+  0738 05 03         syscall sys_io        ; display ah
0436+  073A 24            mov ah, bl        ; retrieve al
0437+  073B 19 00         mov al, 0
0438+  073D 05 03         syscall sys_io        ; display al
0439+  073F             
0440+  073F E5            pop b
0441+  0740 E4            pop a
0442+  0741 09            ret
0443+  0742             
0444+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0742             ; input 16bit hex integer
0446+  0742             ; read 16bit integer into a
0447+  0742             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0742             scan_u16x:
0449+  0742 F8 10 00      enter 16
0450+  0745 D8            push b
0451+  0746 DA            push d
0452+  0747             
0453+  0747 FA F1 FF      lea d, [bp + -15]
0454+  074A 07 9F 05      call _gets        ; get number
0455+  074D             
0456+  074D 32            mov bl, [d]
0457+  074E 37            mov bh, bl
0458+  074F 33 01 00      mov bl, [d + 1]
0459+  0752 07 55 05      call _atoi        ; convert to int in al
0460+  0755 23            mov ah, al        ; move to ah
0461+  0756             
0462+  0756 33 02 00      mov bl, [d + 2]
0463+  0759 37            mov bh, bl
0464+  075A 33 03 00      mov bl, [d + 3]
0465+  075D 07 55 05      call _atoi        ; convert to int in al
0466+  0760             
0467+  0760 E7            pop d
0468+  0761 E5            pop b
0469+  0762 F9            leave
0470+  0763 09            ret
0471+  0764             
0472+  0764             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0764             ; print 8bit hex integer
0474+  0764             ; integer value in reg bl
0475+  0764             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0764             print_u8x:
0477+  0764 D7            push a
0478+  0765 DD            push bl
0479+  0766             
0480+  0766 07 66 05      call _itoa        ; convert bl to char in a
0481+  0769 2F            mov bl, al        ; save al
0482+  076A 19 00         mov al, 0
0483+  076C 05 03         syscall sys_io        ; display ah
0484+  076E 24            mov ah, bl        ; retrieve al
0485+  076F 19 00         mov al, 0
0486+  0771 05 03         syscall sys_io        ; display al
0487+  0773             
0488+  0773 EA            pop bl
0489+  0774 E4            pop a
0490+  0775 09            ret
0491+  0776             
0492+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0776             ; print 8bit decimal unsigned number
0494+  0776             ; input number in al
0495+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0776             print_u8d:
0497+  0776 D7            push a
0498+  0777 D8            push b
0499+  0778 FD D8         push g
0500+  077A 22 00         mov ah, 0
0501+  077C 26 64 00      mov b, 100
0502+  077F AE            div a, b
0503+  0780 D8            push b      ; save remainder
0504+  0781 B9 00         cmp al, 0
0505+  0783 C6 8D 07      je skip100
0506+  0786 6A 30         add al, $30
0507+  0788 23            mov ah, al
0508+  0789 19 00         mov al, 0
0509+  078B 05 03         syscall sys_io  ; print coeff
0510+  078D             skip100:
0511+  078D E4            pop a
0512+  078E 22 00         mov ah, 0
0513+  0790 26 0A 00      mov b, 10
0514+  0793 AE            div a, b
0515+  0794 D8            push b      ; save remainder
0516+  0795 B9 00         cmp al, 0
0517+  0797 C6 A1 07      je skip10
0518+  079A 6A 30         add al, $30
0519+  079C 23            mov ah, al
0520+  079D 19 00         mov al, 0
0521+  079F 05 03         syscall sys_io  ; print coeff
0522+  07A1             skip10:
0523+  07A1 E4            pop a
0524+  07A2 1B            mov al, bl
0525+  07A3 6A 30         add al, $30
0526+  07A5 23            mov ah, al
0527+  07A6 19 00         mov al, 0
0528+  07A8 05 03         syscall sys_io  ; print coeff
0529+  07AA FD F1         pop g
0530+  07AC E5            pop b
0531+  07AD E4            pop a
0532+  07AE 09            ret
0533+  07AF             
0534+  07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  07AF             ; input 8bit hex integer
0536+  07AF             ; read 8bit integer into al
0537+  07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  07AF             scan_u8x:
0539+  07AF F8 04 00      enter 4
0540+  07B2 D8            push b
0541+  07B3 DA            push d
0542+  07B4             
0543+  07B4 FA FD FF      lea d, [bp + -3]
0544+  07B7 07 9F 05      call _gets        ; get number
0545+  07BA             
0546+  07BA 32            mov bl, [d]
0547+  07BB 37            mov bh, bl
0548+  07BC 33 01 00      mov bl, [d + 1]
0549+  07BF 07 55 05      call _atoi        ; convert to int in al
0550+  07C2             
0551+  07C2 E7            pop d
0552+  07C3 E5            pop b
0553+  07C4 F9            leave
0554+  07C5 09            ret
0555+  07C6             
0556+  07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  07C6             ; input decimal number
0558+  07C6             ; result in a
0559+  07C6             ; 655'\0'
0560+  07C6             ; low--------high
0561+  07C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  07C6             scan_u16d:
0563+  07C6 F8 08 00      enter 8
0564+  07C9 E2            push si
0565+  07CA D8            push b
0566+  07CB D9            push c
0567+  07CC DA            push d
0568+  07CD FA F9 FF      lea d, [bp +- 7]
0569+  07D0 07 9F 05      call _gets
0570+  07D3 07 F7 04      call _strlen      ; get string length in c
0571+  07D6 7E            dec c
0572+  07D7 FD 4E         mov si, d
0573+  07D9 12            mov a, c
0574+  07DA FD 99         shl a
0575+  07DC 3B 18 08      mov d, table_power
0576+  07DF 59            add d, a
0577+  07E0 38 00 00      mov c, 0
0578+  07E3             mul_loop:
0579+  07E3 F6            lodsb      ; load ascii to al
0580+  07E4 B9 00         cmp al, 0
0581+  07E6 C6 F9 07      je mul_exit
0582+  07E9 6F 30         sub al, $30    ; make into integer
0583+  07EB 22 00         mov ah, 0
0584+  07ED 2A            mov b, [d]
0585+  07EE AC            mul a, b      ; result in b since it fits in 16bits
0586+  07EF 11            mov a, b
0587+  07F0 28            mov b, c
0588+  07F1 54            add a, b
0589+  07F2 39            mov c, a
0590+  07F3 63 02 00      sub d, 2
0591+  07F6 0A E3 07      jmp mul_loop
0592+  07F9             mul_exit:
0593+  07F9 12            mov a, c
0594+  07FA E7            pop d
0595+  07FB E6            pop c
0596+  07FC E5            pop b
0597+  07FD EF            pop si
0598+  07FE F9            leave
0599+  07FF 09            ret
0600+  0800             
0601+  0800             
0602+  0800 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  0804 34 35 36 37 
0602+  0808 38 39 61 62 
0602+  080C 63 64 65 66 
0603+  0810 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  0814 1B 5B 68 00 
0604+  0818             
0605+  0818             table_power:
0606+  0818 01 00         .dw 1
0607+  081A 0A 00         .dw 10
0608+  081C 64 00         .dw 100
0609+  081E E8 03         .dw 1000
0610+  0820 10 27         .dw 100001058   0822             .include "lib/ctype.asm"
0001+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0822             ; ctype.s
0003+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0822             
0005+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0822             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  0822             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  0822             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  0822             ;; characters are supported.
0010+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0822             ;; _isalnum 
0012+  0822             ;; _isalpha 
0013+  0822             ;; islower 
0014+  0822             ;; isupper 
0015+  0822             ;; _isdigit 
0016+  0822             ;; isxdigit
0017+  0822             ;; iscntrl 
0018+  0822             ;; isgraph 
0019+  0822             ;; _isspace 
0020+  0822             ;; isblank 
0021+  0822             ;; isprint 
0022+  0822             ;; ispunct 
0023+  0822             ;; tolower 
0024+  0822             ;; toupper
0025+  0822             
0026+  0822             
0027+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0822             ;; is alphanumeric
0029+  0822             ;; sets zf according with result
0030+  0822             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0822             _isalnum:
0032+  0822 07 3F 08    	call _isalpha
0033+  0825 C6 2B 08    	je _isalnum_exit
0034+  0828 07 2C 08    	call _isdigit
0035+  082B             _isalnum_exit:
0036+  082B 09          	ret	
0037+  082C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  082C             ;; is digit
0039+  082C             ;; sets zf according with result
0040+  082C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  082C             _isdigit:
0042+  082C DB          	push al
0043+  082D B9 30       	cmp al, '0'
0044+  082F C8 3B 08    	jlu _isdigit_false
0045+  0832 B9 39       	cmp al, '9'
0046+  0834 D1 3B 08    	jgu _isdigit_false
0047+  0837 87 00       	and al, 0	; set zf
0048+  0839 E8          	pop al
0049+  083A 09          	ret
0050+  083B             _isdigit_false:
0051+  083B 8B 01       	or al, 1	; clear zf
0052+  083D E8          	pop al
0053+  083E 09          	ret	
0054+  083F             	
0055+  083F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  083F             ;; is alpha
0057+  083F             ;; sets zf according with result
0058+  083F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  083F             _isalpha:
0060+  083F DB          	push al
0061+  0840 B9 5F       	cmp al, '_'
0062+  0842 C6 62 08    	je _isalpha_true
0063+  0845 B9 2E       	cmp al, '.'
0064+  0847 C6 62 08    	je _isalpha_true
0065+  084A B9 61       	cmp al, 'a'
0066+  084C C8 5E 08    	jlu _isalpha_false
0067+  084F B9 7A       	cmp al, 'z'
0068+  0851 D1 5E 08    	jgu _isalpha_false
0069+  0854 B9 7A       	cmp al, 'z'
0070+  0856 D0 62 08    	jleu _isalpha_true
0071+  0859 B9 61       	cmp al, 'a'
0072+  085B C9 62 08    	jgeu _isalpha_true
0073+  085E             _isalpha_false:
0074+  085E 8B 01       	or al, 1	; clear zf
0075+  0860 E8          	pop al
0076+  0861 09          	ret
0077+  0862             _isalpha_true:
0078+  0862 87 00       	and al, 0	; set zf
0079+  0864 E8          	pop al
0080+  0865 09          	ret
0081+  0866             
0082+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0866             ;; is path-alpha
0084+  0866             ;; sets zf according with result
0085+  0866             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0866             ispath:
0087+  0866 DB          	push al
0088+  0867 07 2C 08    	call _isdigit
0089+  086A C6 94 08    	je ispath_true
0090+  086D B9 5F       	cmp al, '_'
0091+  086F C6 94 08    	je ispath_true
0092+  0872 B9 2F       	cmp al, '/'
0093+  0874 C6 94 08    	je ispath_true
0094+  0877 B9 2E       	cmp al, '.'
0095+  0879 C6 94 08    	je ispath_true
0096+  087C B9 61       	cmp al, 'a'
0097+  087E C8 90 08    	jlu ispath_false
0098+  0881 B9 7A       	cmp al, 'z'
0099+  0883 D1 90 08    	jgu ispath_false
0100+  0886 B9 7A       	cmp al, 'z'
0101+  0888 D0 94 08    	jleu ispath_true
0102+  088B B9 61       	cmp al, 'a'
0103+  088D C9 94 08    	jgeu ispath_true
0104+  0890             ispath_false:
0105+  0890 8B 01       	or al, 1	; clear zf
0106+  0892 E8          	pop al
0107+  0893 09          	ret
0108+  0894             ispath_true:
0109+  0894 87 00       	and al, 0	; set zf
0110+  0896 E8          	pop al
0111+  0897 09          	ret
0112+  0898             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0898             ;; is space
0114+  0898             ;; sets zf according with result
0115+  0898             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0898             _isspace:
0117+  0898 B9 20       	cmp al, $20		; ' '
0118+  089A C6 AE 08    	je _isspace_exit
0119+  089D B9 09       	cmp al, $09		; '\t'
0120+  089F C6 AE 08    	je _isspace_exit
0121+  08A2 B9 0A       	cmp al, $0a		; '\n'
0122+  08A4 C6 AE 08    	je _isspace_exit
0123+  08A7 B9 0D       	cmp al, $0d		; '\r'
0124+  08A9 C6 AE 08    	je _isspace_exit
0125+  08AC B9 0B       	cmp al, $0b		; '\v'
0126+  08AE             _isspace_exit:
0127+  08AE 09          	ret	
0128+  08AF             
0129+  08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08AF             ; to lower
0131+  08AF             ; input in al
0132+  08AF             ; output in al
0133+  08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  08AF             _to_lower:
0135+  08AF B9 7A       	cmp al, 'z'
0136+  08B1 D1 B6 08    	jgu _to_lower_ret
0137+  08B4 6A 20       	add al, $20				; convert to lower case
0138+  08B6             _to_lower_ret:
0139+  08B6 09          	ret
0140+  08B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  08B7             ; to upper
0142+  08B7             ; input in al
0143+  08B7             ; output in al
0144+  08B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  08B7             _to_upper:
0146+  08B7 B9 61       	cmp al, 'a'
0147+  08B9 C8 BE 08    	jlu _to_upper_ret
0148+  08BC 6F 20       	sub al, $20			; convert to upper case
0149+  08BE             _to_upper_ret:
0150+  08BE 09          	ret
0151+  08BF             
1059   08BF             .include "lib/token.asm"
0001+  08BF             toktyp_identifier  .equ 0
0002+  08BF             toktyp_keyword     .equ 1
0003+  08BF             toktyp_delimiter   .equ 2
0004+  08BF             toktyp_string      .equ 3
0005+  08BF             toktyp_char        .equ 4
0006+  08BF             toktyp_numeric     .equ 5
0007+  08BF             toktyp_end         .equ 6
0008+  08BF             
0009+  08BF             tok_null           .equ 0
0010+  08BF             tok_fslash         .equ 1
0011+  08BF             tok_times          .equ 2
0012+  08BF             tok_plus           .equ 3
0013+  08BF             tok_minus          .equ 4
0014+  08BF             tok_dot            .equ 5
0015+  08BF             tok_semi           .equ 6
0016+  08BF             tok_angle          .equ 7
0017+  08BF             tok_tilde          .equ 8
0018+  08BF             tok_equal          .equ 9
0019+  08BF             tok_colon          .equ 10
0020+  08BF             tok_comma          .equ 11
0021+  08BF             
0022+  08BF             tok_end            .equ 20
0023+  08BF             
0024+  08BF             
0025+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  08BF             ;; read a full command argment from shell input buffer
0027+  08BF             ;; argument is written into tokstr
0028+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  08BF             get_arg:
0030+  08BF D7            push a
0031+  08C0 E2            push si
0032+  08C1 E3            push di
0033+  08C2 19 00         mov al, 0
0034+  08C4 3D ED 0A      mov [tokstr], al      ; nullify tokstr string
0035+  08C7 14 E9 0A      mov a, [prog]
0036+  08CA 4D            mov si, a
0037+  08CB FD 4F ED 0A   mov di, tokstr
0038+  08CF             get_arg_skip_spaces:
0039+  08CF F6            lodsb
0040+  08D0 07 98 08      call _isspace
0041+  08D3 C6 CF 08      je get_arg_skip_spaces
0042+  08D6             get_arg_l0:
0043+  08D6 B9 3B         cmp al, $3b        ; check if is ';'
0044+  08D8 C6 E5 08      je get_arg_end
0045+  08DB B9 00         cmp al, 0
0046+  08DD C6 E5 08      je get_arg_end      ; check if end of input
0047+  08E0 F7            stosb
0048+  08E1 F6            lodsb
0049+  08E2 0A D6 08      jmp get_arg_l0
0050+  08E5             get_arg_end:
0051+  08E5 19 00         mov al, 0
0052+  08E7 F7            stosb
0053+  08E8 D5 01 00      sub si, 1
0054+  08EB 4E            mov a, si
0055+  08EC 42 E9 0A      mov [prog], a    ; update pointer
0056+  08EF F0            pop di
0057+  08F0 EF            pop si
0058+  08F1 E4            pop a
0059+  08F2 09            ret
0060+  08F3             
0061+  08F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08F3             ;; read a path formation from shell input buffer
0063+  08F3             ;; path is written into tokstr
0064+  08F3             ;; /usr/bin
0065+  08F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08F3             get_path:
0067+  08F3 D7            push a
0068+  08F4 E2            push si
0069+  08F5 E3            push di
0070+  08F6 19 00         mov al, 0
0071+  08F8 3D ED 0A      mov [tokstr], al      ; nullify tokstr string
0072+  08FB 14 E9 0A      mov a, [prog]
0073+  08FE 4D            mov si, a
0074+  08FF FD 4F ED 0A   mov di, tokstr
0075+  0903             get_path_skip_spaces:
0076+  0903 F6            lodsb
0077+  0904 07 98 08      call _isspace
0078+  0907 C6 03 09      je get_path_skip_spaces
0079+  090A             get_path_is_pathchar:
0080+  090A F7            stosb
0081+  090B F6            lodsb
0082+  090C 07 22 08      call _isalnum      ;check if is alphanumeric
0083+  090F C6 0A 09      je get_path_is_pathchar
0084+  0912 B9 2F         cmp al, '/'        ; check if is '/'
0085+  0914 C6 0A 09      je get_path_is_pathchar
0086+  0917 19 00         mov al, 0
0087+  0919 F7            stosb
0088+  091A D5 01 00      sub si, 1
0089+  091D 4E            mov a, si
0090+  091E 42 E9 0A      mov [prog], a    ; update pointer
0091+  0921             get_path_end:
0092+  0921 F0            pop di
0093+  0922 EF            pop si
0094+  0923 E4            pop a
0095+  0924 09            ret
0096+  0925             
0097+  0925             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0925             ;; read a line
0099+  0925             ;; line is written into tokstr
0100+  0925             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0925             get_line:
0102+  0925 D7            push a
0103+  0926 E2            push si
0104+  0927 E3            push di
0105+  0928 19 00         mov al, 0
0106+  092A 3D ED 0A      mov [tokstr], al      ; nullify tokstr string
0107+  092D 14 E9 0A      mov a, [prog]
0108+  0930 4D            mov si, a
0109+  0931 FD 4F ED 0A   mov di, tokstr
0110+  0935             get_line_l0:
0111+  0935 F6            lodsb
0112+  0936 B9 0A         cmp al, $0a    ; check for new line
0113+  0938 C6 3F 09      je get_line_exit
0114+  093B F7            stosb
0115+  093C 0A 35 09      jmp get_line_l0
0116+  093F             get_line_exit:
0117+  093F 19 00         mov al, 0
0118+  0941 F7            stosb
0119+  0942 4E            mov a, si
0120+  0943 42 E9 0A      mov [prog], a    ; update pointer
0121+  0946 F0            pop di
0122+  0947 EF            pop si
0123+  0948 E4            pop a
0124+  0949 09            ret
0125+  094A             
0126+  094A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  094A             ;; token parser
0128+  094A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  094A             get_token:
0130+  094A D7            push a
0131+  094B DA            push d
0132+  094C E2            push si
0133+  094D E3            push di
0134+  094E 19 00         mov al, 0
0135+  0950 3D ED 0A      mov [tokstr], al      ; nullify tokstr string
0136+  0953 19 00         mov al, tok_null
0137+  0955 3D EC 0A      mov [tok], al        ; nullify token
0138+  0958 14 E9 0A      mov a, [prog]
0139+  095B 4D            mov si, a
0140+  095C FD 4F ED 0A   mov di, tokstr
0141+  0960             get_tok_skip_spaces:
0142+  0960 F6            lodsb
0143+  0961 07 98 08      call _isspace
0144+  0964 C6 60 09      je get_tok_skip_spaces
0145+  0967 B9 00         cmp al, 0      ; check for end of input (null)
0146+  0969 C6 4E 0A      je get_token_end
0147+  096C B9 23         cmp al, '#'      ; comments!
0148+  096E C6 7C 0A      je get_tok_comment
0149+  0971 07 22 08      call _isalnum
0150+  0974 C6 5B 0A      jz is_alphanumeric
0151+  0977             ; other token types
0152+  0977             get_token_slash:
0153+  0977 B9 2F         cmp al, '/'        ; check if '/'
0154+  0979 C7 91 09      jne get_token_minus
0155+  097C F7            stosb          ; store '/' into token string
0156+  097D 19 00         mov al, 0
0157+  097F F7            stosb          ; terminate token string
0158+  0980 19 01         mov al, tok_fslash
0159+  0982 3D EC 0A      mov [tok], al      
0160+  0985 19 02         mov al, toktyp_delimiter
0161+  0987 3D EB 0A      mov [toktyp], al
0162+  098A 4E            mov a, si
0163+  098B 42 E9 0A      mov [prog], a    ; update pointer
0164+  098E 0A 77 0A      jmp get_token_return
0165+  0991             get_token_minus:
0166+  0991 B9 2D         cmp al, '-'        ; check if '-'
0167+  0993 C7 AB 09      jne get_token_comma
0168+  0996 F7            stosb          ; store '-' into token string
0169+  0997 19 00         mov al, 0
0170+  0999 F7            stosb          ; terminate token string
0171+  099A 19 04         mov al, tok_minus
0172+  099C 3D EC 0A      mov [tok], al      
0173+  099F 19 02         mov al, toktyp_delimiter
0174+  09A1 3D EB 0A      mov [toktyp], al
0175+  09A4 4E            mov a, si
0176+  09A5 42 E9 0A      mov [prog], a    ; update pointer
0177+  09A8 0A 77 0A      jmp get_token_return
0178+  09AB             get_token_comma:
0179+  09AB B9 2C         cmp al, ','        ; check if ','
0180+  09AD C7 C5 09      jne get_token_semi
0181+  09B0 F7            stosb          ; store ',' into token string
0182+  09B1 19 00         mov al, 0
0183+  09B3 F7            stosb          ; terminate token string
0184+  09B4 19 0B         mov al, tok_comma
0185+  09B6 3D EC 0A      mov [tok], al      
0186+  09B9 19 02         mov al, toktyp_delimiter
0187+  09BB 3D EB 0A      mov [toktyp], al
0188+  09BE 4E            mov a, si
0189+  09BF 42 E9 0A      mov [prog], a    ; update pointer
0190+  09C2 0A 77 0A      jmp get_token_return
0191+  09C5             get_token_semi:
0192+  09C5 B9 3B         cmp al, $3b        ; check if ';'
0193+  09C7 C7 DF 09      jne get_token_colon
0194+  09CA F7            stosb          ; store ';' into token string
0195+  09CB 19 00         mov al, 0
0196+  09CD F7            stosb          ; terminate token string
0197+  09CE 19 06         mov al, tok_semi
0198+  09D0 3D EC 0A      mov [tok], al      
0199+  09D3 19 02         mov al, toktyp_delimiter
0200+  09D5 3D EB 0A      mov [toktyp], al
0201+  09D8 4E            mov a, si
0202+  09D9 42 E9 0A      mov [prog], a    ; update pointer
0203+  09DC 0A 77 0A      jmp get_token_return
0204+  09DF             get_token_colon:
0205+  09DF B9 3A         cmp al, $3a        ; check if ':'
0206+  09E1 C7 F9 09      jne get_token_angle
0207+  09E4 F7            stosb          ; store ':' into token string
0208+  09E5 19 00         mov al, 0
0209+  09E7 F7            stosb          ; terminate token string
0210+  09E8 19 0A         mov al, tok_colon
0211+  09EA 3D EC 0A      mov [tok], al      
0212+  09ED 19 02         mov al, toktyp_delimiter
0213+  09EF 3D EB 0A      mov [toktyp], al
0214+  09F2 4E            mov a, si
0215+  09F3 42 E9 0A      mov [prog], a    ; update pointer
0216+  09F6 0A 77 0A      jmp get_token_return
0217+  09F9             get_token_angle:
0218+  09F9 B9 3E         cmp al, $3e        ; check if '>'
0219+  09FB C7 13 0A      jne get_token_tilde
0220+  09FE F7            stosb          ; store '>' into token string
0221+  09FF 19 00         mov al, 0
0222+  0A01 F7            stosb          ; terminate token string
0223+  0A02 19 07         mov al, tok_angle
0224+  0A04 3D EC 0A      mov [tok], al      
0225+  0A07 19 02         mov al, toktyp_delimiter
0226+  0A09 3D EB 0A      mov [toktyp], al
0227+  0A0C 4E            mov a, si
0228+  0A0D 42 E9 0A      mov [prog], a    ; update pointer
0229+  0A10 0A 77 0A      jmp get_token_return
0230+  0A13             get_token_tilde:
0231+  0A13 B9 7E         cmp al, '~'        ; check if '~'
0232+  0A15 C7 2D 0A      jne get_token_equal
0233+  0A18 F7            stosb          ; store '~' into token string
0234+  0A19 19 00         mov al, 0
0235+  0A1B F7            stosb          ; terminate token string
0236+  0A1C 19 08         mov al, tok_tilde
0237+  0A1E 3D EC 0A      mov [tok], al      
0238+  0A21 19 02         mov al, toktyp_delimiter
0239+  0A23 3D EB 0A      mov [toktyp], al
0240+  0A26 4E            mov a, si
0241+  0A27 42 E9 0A      mov [prog], a    ; update pointer
0242+  0A2A 0A 77 0A      jmp get_token_return
0243+  0A2D             get_token_equal:
0244+  0A2D B9 3D         cmp al, '='        ; check if '='
0245+  0A2F C7 47 0A      jne get_token_skip
0246+  0A32 F7            stosb          ; store '=' into token string
0247+  0A33 19 00         mov al, 0
0248+  0A35 F7            stosb          ; terminate token string
0249+  0A36 19 09         mov al, tok_equal
0250+  0A38 3D EC 0A      mov [tok], al      
0251+  0A3B 19 02         mov al, toktyp_delimiter
0252+  0A3D 3D EB 0A      mov [toktyp], al
0253+  0A40 4E            mov a, si
0254+  0A41 42 E9 0A      mov [prog], a    ; update pointer
0255+  0A44 0A 77 0A      jmp get_token_return
0256+  0A47             get_token_skip:
0257+  0A47 4E            mov a, si
0258+  0A48 42 E9 0A      mov [prog], a    ; update pointer
0259+  0A4B 0A 77 0A      jmp get_token_return
0260+  0A4E             get_token_end:        ; end of file token
0261+  0A4E 19 14         mov al, tok_end
0262+  0A50 3D EC 0A      mov [tok], al
0263+  0A53 19 06         mov al, toktyp_end
0264+  0A55 3D EB 0A      mov [toktyp], al
0265+  0A58 0A 77 0A      jmp get_token_return
0266+  0A5B             is_alphanumeric:
0267+  0A5B F7            stosb
0268+  0A5C F6            lodsb
0269+  0A5D 07 22 08      call _isalnum      ;check if is alphanumeric
0270+  0A60 C6 5B 0A      jz is_alphanumeric
0271+  0A63 B9 2E         cmp al, $2e        ; check if is '.'
0272+  0A65 C6 5B 0A      je is_alphanumeric
0273+  0A68 19 00         mov al, 0
0274+  0A6A F7            stosb
0275+  0A6B 19 00         mov al, toktyp_identifier
0276+  0A6D 3D EB 0A      mov [toktyp], al
0277+  0A70 D5 01 00      sub si, 1
0278+  0A73 4E            mov a, si
0279+  0A74 42 E9 0A      mov [prog], a    ; update pointer
0280+  0A77             get_token_return:
0281+  0A77 F0            pop di
0282+  0A78 EF            pop si
0283+  0A79 E7            pop d
0284+  0A7A E4            pop a
0285+  0A7B 09            ret
0286+  0A7C             get_tok_comment:
0287+  0A7C F6            lodsb
0288+  0A7D B9 0A         cmp al, $0a      ; new line
0289+  0A7F C7 7C 0A      jne get_tok_comment
0290+  0A82 0A 60 09      jmp get_tok_skip_spaces
0291+  0A85             
0292+  0A85             
0293+  0A85             get_number:
0294+  0A85 D7            push a
0295+  0A86 DA            push d
0296+  0A87 E2            push si
0297+  0A88 E3            push di
0298+  0A89 19 00         mov al, 0
0299+  0A8B 3D ED 0A      mov [tokstr], al      ; nullify tokstr string
0300+  0A8E 19 00         mov al, tok_null
0301+  0A90 3D EC 0A      mov [tok], al        ; nullify token
0302+  0A93 14 E9 0A      mov a, [prog]
0303+  0A96 4D            mov si, a
0304+  0A97 FD 4F ED 0A   mov di, tokstr
0305+  0A9B             get_number_skip_spaces:
0306+  0A9B F6            lodsb
0307+  0A9C 07 98 08      call _isspace
0308+  0A9F C6 9B 0A      je get_number_skip_spaces
0309+  0AA2 B9 00         cmp al, 0      ; check for end of input (null)
0310+  0AA4 C7 B4 0A      jne get_number_l0
0311+  0AA7 19 14         mov al, tok_end
0312+  0AA9 3D EC 0A      mov [tok], al
0313+  0AAC 19 06         mov al, toktyp_end
0314+  0AAE 3D EB 0A      mov [toktyp], al
0315+  0AB1 0A CB 0A      jmp get_number_return
0316+  0AB4             get_number_l0:
0317+  0AB4 F7            stosb
0318+  0AB5 F6            lodsb
0319+  0AB6 07 2C 08      call _isdigit      ;check if is numeric
0320+  0AB9 C6 B4 0A      jz get_number_l0
0321+  0ABC 19 00         mov al, 0
0322+  0ABE F7            stosb
0323+  0ABF 19 05         mov al, toktyp_numeric
0324+  0AC1 3D EB 0A      mov [toktyp], al
0325+  0AC4 D5 01 00      sub si, 1
0326+  0AC7 4E            mov a, si
0327+  0AC8 42 E9 0A      mov [prog], a    ; update pointer
0328+  0ACB             get_number_return:
0329+  0ACB F0            pop di
0330+  0ACC EF            pop si
0331+  0ACD E7            pop d
0332+  0ACE E4            pop a
0333+  0ACF 09            ret
0334+  0AD0             
0335+  0AD0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0AD0             ;; put back token
0337+  0AD0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  0AD0             _putback:
0339+  0AD0 D7            push a
0340+  0AD1 E2            push si
0341+  0AD2 FD 4D ED 0A   mov si, tokstr  
0342+  0AD6             _putback_loop:
0343+  0AD6 F6            lodsb
0344+  0AD7 B9 00         cmp al, 0
0345+  0AD9 C6 E6 0A      je _putback_end
0346+  0ADC 14 E9 0A      mov a, [prog]
0347+  0ADF 7D            dec a
0348+  0AE0 42 E9 0A      mov [prog], a      ; update pointer
0349+  0AE3 0A D6 0A      jmp _putback_loop
0350+  0AE6             _putback_end:
0351+  0AE6 EF            pop si
0352+  0AE7 E4            pop a
0353+  0AE8 09            ret
0354+  0AE9             
0355+  0AE9             
0356+  0AE9             
0357+  0AE9             
0358+  0AE9 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  0AEB             
0360+  0AEB 00          toktyp:    .db 0          ; token type symbol
0361+  0AEC 00          tok:       .db 0          ; current token symbol
0362+  0AED 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  0AF1 00 00 00 00 
0362+  0AF5 00 00 00 00 
0362+  0AF9 00 00 00 00 
0362+  0AFD 00 00 00 00 
0362+  0B01 00 00 00 00 
0362+  0B05 00 00 00 00 
0362+  0B09 00 00 00 00 
0362+  0B0D 00 00 00 00 
0362+  0B11 00 00 00 00 
0362+  0B15 00 00 00 00 
0362+  0B19 00 00 00 00 
0362+  0B1D 00 00 00 00 
0362+  0B21 00 00 00 00 
0362+  0B25 00 00 00 00 
0362+  0B29 00 00 00 00 
0362+  0B2D 00 00 00 00 
0362+  0B31 00 00 00 00 
0362+  0B35 00 00 00 00 
0362+  0B39 00 00 00 00 
0362+  0B3D 00 00 00 00 
0362+  0B41 00 00 00 00 
0362+  0B45 00 00 00 00 
0362+  0B49 00 00 00 00 
0362+  0B4D 00 00 00 00 
0362+  0B51 00 00 00 00 
0362+  0B55 00 00 00 00 
0362+  0B59 00 00 00 00 
0362+  0B5D 00 00 00 00 
0362+  0B61 00 00 00 00 
0362+  0B65 00 00 00 00 
0362+  0B69 00 00 00 00 
0362+  0B6D 00 00 00 00 
0362+  0B71 00 00 00 00 
0362+  0B75 00 00 00 00 
0362+  0B79 00 00 00 00 
0362+  0B7D 00 00 00 00 
0362+  0B81 00 00 00 00 
0362+  0B85 00 00 00 00 
0362+  0B89 00 00 00 00 
0362+  0B8D 00 00 00 00 
0362+  0B91 00 00 00 00 
0362+  0B95 00 00 00 00 
0362+  0B99 00 00 00 00 
0362+  0B9D 00 00 00 00 
0362+  0BA1 00 00 00 00 
0362+  0BA5 00 00 00 00 
0362+  0BA9 00 00 00 00 
0362+  0BAD 00 00 00 00 
0362+  0BB1 00 00 00 00 
0362+  0BB5 00 00 00 00 
0362+  0BB9 00 00 00 00 
0362+  0BBD 00 00 00 00 
0362+  0BC1 00 00 00 00 
0362+  0BC5 00 00 00 00 
0362+  0BC9 00 00 00 00 
0362+  0BCD 00 00 00 00 
0362+  0BD1 00 00 00 00 
0362+  0BD5 00 00 00 00 
0362+  0BD9 00 00 00 00 
0362+  0BDD 00 00 00 00 
0362+  0BE1 00 00 00 00 
0362+  0BE5 00 00 00 00 
0362+  0BE9 00 00 00 00 
1060   0BED             
1061   0BED             
1062   0BED             ; kernel parameters
1063   0BED             ; baud  divisor
1064   0BED             ; 50    2304
1065   0BED             ; 110   1047
1066   0BED             ; 300    384
1067   0BED             ; 600    192
1068   0BED             ; 1200    96
1069   0BED             ; 9600    12
1070   0BED             ; 19200    6
1071   0BED             ; 38400    3
1072   0BED             sys_uart0_lcr:
1073   0BED 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1074   0BEE             sys_uart0_inten:
1075   0BEE 01            .db 1
1076   0BEF             sys_uart0_fifoen:
1077   0BEF 00            .db 0
1078   0BF0             sys_uart0_div0:
1079   0BF0 03            .db 3
1080   0BF1             sys_uart0_div1:
1081   0BF1 00            .db 0   ; default baud = 38400
1082   0BF2             
1083   0BF2             sys_uart1_lcr:
1084   0BF2 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1085   0BF3             sys_uart1_inten:
1086   0BF3 01            .db 1
1087   0BF4             sys_uart1_fifoen:
1088   0BF4 00            .db 0
1089   0BF5             sys_uart1_div0:
1090   0BF5 03            .db 3
1091   0BF6             sys_uart1_div1:
1092   0BF6 00            .db 0   ; default baud = 38400
1093   0BF7             
1094   0BF7             fifo_in:
1095   0BF7 85 0E         .dw fifo
1096   0BF9             fifo_out:
1097   0BF9 85 0E         .dw fifo
1098   0BFB             
1099   0BFB             ; file system variables
1100   0BFB             current_dir_id:
1101   0BFB 00 00         .dw 0     ; keep dirid of current directory
1102   0BFD             s_init_path:
1103   0BFD 2F 73 62 69   .db "/sbin/init", 0
1103   0C01 6E 2F 69 6E 
1103   0C05 69 74 00 
1104   0C08             
1105   0C08             s_uname:
1106   0C08 73 6F 6C 61   .db "solarium v.1.0", 0
1106   0C0C 72 69 75 6D 
1106   0C10 20 76 2E 31 
1106   0C14 2E 30 00 
1107   0C17             s_dataentry:
1108   0C17 3E 20 00      .db "> ", 0
1109   0C1A             s_parent_dir:
1110   0C1A 2E 2E 00      .db "..", 0
1111   0C1D             s_current_dir:
1112   0C1D 2E 00         .db ".", 0
1113   0C1F             s_fslash:
1114   0C1F 2F 00         .db "/", 0
1115   0C21             file_attrib:
1116   0C21 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
1116   0C25 78 
1117   0C26             file_type:
1118   0C26 2D 64 63      .db "-dc"
1119   0C29             s_ps_header:
1120   0C29 70 69 64 20   .db "pid command\n", 0
1120   0C2D 63 6F 6D 6D 
1120   0C31 61 6E 64 0A 
1120   0C35 00 
1121   0C36             s_ls_total:
1122   0C36 74 6F 74 61   .db "total: ", 0
1122   0C3A 6C 3A 20 00 
1123   0C3E             
1124   0C3E             s_int_en:
1125   0C3E 69 72 71 73   .db "irqs enabled\n", 0
1125   0C42 20 65 6E 61 
1125   0C46 62 6C 65 64 
1125   0C4A 0A 00 
1126   0C4C             s_kernel_welcome:
1127   0C4C 2A 2A 2A 2A   .db "************************************************\n"
1127   0C50 2A 2A 2A 2A 
1127   0C54 2A 2A 2A 2A 
1127   0C58 2A 2A 2A 2A 
1127   0C5C 2A 2A 2A 2A 
1127   0C60 2A 2A 2A 2A 
1127   0C64 2A 2A 2A 2A 
1127   0C68 2A 2A 2A 2A 
1127   0C6C 2A 2A 2A 2A 
1127   0C70 2A 2A 2A 2A 
1127   0C74 2A 2A 2A 2A 
1127   0C78 2A 2A 2A 2A 
1127   0C7C 0A 
1128   0C7D 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
1128   0C81 57 65 6C 63 
1128   0C85 6F 6D 65 20 
1128   0C89 74 6F 20 53 
1128   0C8D 6F 6C 61 72 
1128   0C91 69 75 6D 20 
1128   0C95 4F 53 20 2D 
1128   0C99 20 4B 65 72 
1128   0C9D 6E 65 6C 20 
1128   0CA1 76 65 72 2E 
1128   0CA5 20 31 2E 30 
1128   0CA9 20 2A 2A 2A 
1128   0CAD 0A 
1129   0CAE 2A 2A 2A 20   .db "*** type help for more information           ***\n"
1129   0CB2 74 79 70 65 
1129   0CB6 20 68 65 6C 
1129   0CBA 70 20 66 6F 
1129   0CBE 72 20 6D 6F 
1129   0CC2 72 65 20 69 
1129   0CC6 6E 66 6F 72 
1129   0CCA 6D 61 74 69 
1129   0CCE 6F 6E 20 20 
1129   0CD2 20 20 20 20 
1129   0CD6 20 20 20 20 
1129   0CDA 20 2A 2A 2A 
1129   0CDE 0A 
1130   0CDF 2A 2A 2A 2A   .db "************************************************\n", 0
1130   0CE3 2A 2A 2A 2A 
1130   0CE7 2A 2A 2A 2A 
1130   0CEB 2A 2A 2A 2A 
1130   0CEF 2A 2A 2A 2A 
1130   0CF3 2A 2A 2A 2A 
1130   0CF7 2A 2A 2A 2A 
1130   0CFB 2A 2A 2A 2A 
1130   0CFF 2A 2A 2A 2A 
1130   0D03 2A 2A 2A 2A 
1130   0D07 2A 2A 2A 2A 
1130   0D0B 2A 2A 2A 2A 
1130   0D0F 0A 00 
1131   0D11             s_prompt_init:
1132   0D11 73 74 61 72   .db "starting init\n", 0
1132   0D15 74 69 6E 67 
1132   0D19 20 69 6E 69 
1132   0D1D 74 0A 00 
1133   0D20             s_priviledge:
1134   0D20 0A 65 78 63   .db "\nexception: privilege\n", 0
1134   0D24 65 70 74 69 
1134   0D28 6F 6E 3A 20 
1134   0D2C 70 72 69 76 
1134   0D30 69 6C 65 67 
1134   0D34 65 0A 00 
1135   0D37             s_divzero:
1136   0D37 0A 65 78 63   .db "\nexception: zero division\n", 0
1136   0D3B 65 70 74 69 
1136   0D3F 6F 6E 3A 20 
1136   0D43 7A 65 72 6F 
1136   0D47 20 64 69 76 
1136   0D4B 69 73 69 6F 
1136   0D4F 6E 0A 00 
1137   0D52             
1138   0D52             s_break1:  
1139   0D52 0A 64 65 62   .db "\ndebugger entry point.\n"
1139   0D56 75 67 67 65 
1139   0D5A 72 20 65 6E 
1139   0D5E 74 72 79 20 
1139   0D62 70 6F 69 6E 
1139   0D66 74 2E 0A 
1140   0D69 30 2E 20 73   .db "0. show registers\n"
1140   0D6D 68 6F 77 20 
1140   0D71 72 65 67 69 
1140   0D75 73 74 65 72 
1140   0D79 73 0A 
1141   0D7B 31 2E 20 73   .db "1. show 512b ram block\n"
1141   0D7F 68 6F 77 20 
1141   0D83 35 31 32 62 
1141   0D87 20 72 61 6D 
1141   0D8B 20 62 6C 6F 
1141   0D8F 63 6B 0A 
1142   0D92 32 2E 20 63   .db "2. continue execution", 0
1142   0D96 6F 6E 74 69 
1142   0D9A 6E 75 65 20 
1142   0D9E 65 78 65 63 
1142   0DA2 75 74 69 6F 
1142   0DA6 6E 00 
1143   0DA8             
1144   0DA8             s_set_year:
1145   0DA8 79 65 61 72   .db "year: ", 0
1145   0DAC 3A 20 00 
1146   0DAF             s_set_month:
1147   0DAF 6D 6F 6E 74   .db "month: ", 0
1147   0DB3 68 3A 20 00 
1148   0DB7             s_set_day:
1149   0DB7 64 61 79 3A   .db "day: ", 0
1149   0DBB 20 00 
1150   0DBD             s_set_week:
1151   0DBD 77 65 65 6B   .db "weekday: ", 0
1151   0DC1 64 61 79 3A 
1151   0DC5 20 00 
1152   0DC7             s_set_hours:
1153   0DC7 68 6F 75 72   .db "hours: ", 0
1153   0DCB 73 3A 20 00 
1154   0DCF             s_set_minutes:
1155   0DCF 6D 69 6E 75   .db "minutes: ", 0
1155   0DD3 74 65 73 3A 
1155   0DD7 20 00 
1156   0DD9             s_set_seconds:
1157   0DD9 73 65 63 6F   .db "seconds: ", 0
1157   0DDD 6E 64 73 3A 
1157   0DE1 20 00 
1158   0DE3             s_months:      
1159   0DE3 20 20 20 00   .db "   ", 0
1160   0DE7 6A 61 6E 00   .db "jan", 0
1161   0DEB 66 65 62 00   .db "feb", 0
1162   0DEF 6D 61 72 00   .db "mar", 0
1163   0DF3 61 70 72 00   .db "apr", 0
1164   0DF7 6D 61 79 00   .db "may", 0
1165   0DFB 6A 75 6E 00   .db "jun", 0
1166   0DFF 6A 75 6C 00   .db "jul", 0
1167   0E03 61 75 67 00   .db "aug", 0
1168   0E07 73 65 70 00   .db "sep", 0
1169   0E0B 6F 63 74 00   .db "oct", 0
1170   0E0F 6E 6F 76 00   .db "nov", 0
1171   0E13 64 65 63 00   .db "dec", 0
1172   0E17             
1173   0E17             s_week:        
1174   0E17 73 75 6E 00   .db "sun", 0 
1175   0E1B 6D 6F 6E 00   .db "mon", 0 
1176   0E1F 74 75 65 00   .db "tue", 0 
1177   0E23 77 65 64 00   .db "wed", 0 
1178   0E27 74 68 75 00   .db "thu", 0 
1179   0E2B 66 72 69 00   .db "fri", 0 
1180   0E2F 73 61 74 00   .db "sat", 0
1181   0E33             
1182   0E33 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
1182   0E37 30 20 45 78 
1182   0E3B 65 63 75 74 
1182   0E3F 65 64 2E 0A 
1182   0E43 00 
1183   0E44             s_fdc_config:
1184   0E44 73 65 6C 65   .db "selecting diskette drive 0, side 0, single density, head loaded\n", 0
1184   0E48 63 74 69 6E 
1184   0E4C 67 20 64 69 
1184   0E50 73 6B 65 74 
1184   0E54 74 65 20 64 
1184   0E58 72 69 76 65 
1184   0E5C 20 30 2C 20 
1184   0E60 73 69 64 65 
1184   0E64 20 30 2C 20 
1184   0E68 73 69 6E 67 
1184   0E6C 6C 65 20 64 
1184   0E70 65 6E 73 69 
1184   0E74 74 79 2C 20 
1184   0E78 68 65 61 64 
1184   0E7C 20 6C 6F 61 
1184   0E80 64 65 64 0A 
1184   0E84 00 
1185   0E85             
1186   0E85             ; here we define areas that keep transient data
1187   0E85             ; we use '$' which is the assembler's current address pointer so that these areas are defined to be exactly
1188   0E85             ; after all the static data has been declared
1189   0E85             fifo:           .equ $   
1190   0E85             scrap_sector:   .equ $ + _fifo_size
1191   0E85             transient_area: .equ $ + _fifo_size + _scrap_size
1192   0E85             
1193   0E85             
1194   0E85             
1195   0E85             .end
tasm: Number of errors = 0
