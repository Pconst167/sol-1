0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_1     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 48 00       .dw int_6
0141   000E 94 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 41 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 C4 02       .dw trap_privilege
0153   0014 E1 03       .dw trap_div_zero
0154   0016 EE 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 D0 02       .dw syscall_break
0165   0022 EF 03       .dw syscall_rtc
0166   0024 29 05       .dw syscall_ide
0167   0026 04 06       .dw syscall_io
0168   0028 C1 06       .dw syscall_file_system
0169   002A 8E 0F       .dw syscall_create_proc
0170   002C 89 02       .dw syscall_list_procs
0171   002E 21 04       .dw syscall_datetime
0172   0030 45 02       .dw syscall_reboot
0173   0032 58 0F       .dw syscall_pause_proc
0174   0034 51 02       .dw syscall_resume_proc
0175   0036 15 0F       .dw syscall_terminate_proc
0176   0038 11 02       .dw syscall_system
0177   003A DF 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; irqs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" floppy drive controller irq
0220   003C             int_0_fdc:
0221   003C 3B 09 19      mov d, s_fdc_irq
0222   003F 07 95 12      call _puts
0223   0042 06            sysret
0224   0043             int_1:
0225   0043 06            sysret
0226   0044             int_2:
0227   0044 06            sysret
0228   0045             int_3:
0229   0045 06            sysret
0230   0046             int_4:
0231   0046 06            sysret
0232   0047             int_5:
0233   0047 06            sysret
0234   0048             
0235   0048             ; ------------------------------------------------------------------------------------------------------------------;
0236   0048             ; process swapping
0237   0048             ; ------------------------------------------------------------------------------------------------------------------;
0238   0048             int_6:  
0239   0048 4B            pusha                             ; save all registers into kernel stack
0240   0049 22 00         mov ah, 0
0241   004B 1D C6 17      mov al, [active_proc_index]
0242   004E FD 99         shl a                             ; x2
0243   0050 B7 0B 10      mov a, [proc_table_convert + a]   ; get process state start index
0244   0053 4F            mov di, a
0245   0054 48            mov a, sp
0246   0055 77            inc a
0247   0056 4D            mov si, a
0248   0057 38 14 00      mov c, 20
0249   005A FD F5         rep movsb                         ; save process state!
0250   005C             ; restore kernel stack position to point before interrupt arrived
0251   005C 51 14 00      add sp, 20
0252   005F             ; now load next process in queue
0253   005F 1D C6 17      mov al, [active_proc_index]
0254   0062 31 C5 17      mov bl, [nbr_active_procs]
0255   0065 BA            cmp al, bl
0256   0066 C6 6D 00      je int6_cycle_back
0257   0069 7A            inc al                            ; next process is next in the series
0258   006A 0A 6F 00      jmp int6_continue
0259   006D             int6_cycle_back:
0260   006D 19 01         mov al, 1                         ; next process = process 1
0261   006F             int6_continue:
0262   006F 3D C6 17      mov [active_proc_index], al       ; set next active proc
0263   0072             
0264   0072             ; calculate LUT entry for next process
0265   0072 22 00         mov ah, 0
0266   0074 FD 99         shl a                             ; x2
0267   0076 B7 0B 10      mov a, [proc_table_convert + a]   ; get process state start index  
0268   0079               
0269   0079 4D            mov si, a                         ; source is proc state block
0270   007A 48            mov a, sp
0271   007B 5F 13 00      sub a, 19
0272   007E 4F            mov di, a                         ; destination is kernel stack
0273   007F             ; restore SP
0274   007F 7D            dec a
0275   0080 47            mov sp, a
0276   0081 38 14 00      mov c, 20
0277   0084 FD F5         rep movsb
0278   0086             ; set vm process
0279   0086 1D C6 17      mov al, [active_proc_index]
0280   0089 01            setptb
0281   008A F2 E0 FF 00   mov byte[_timer_c_0], 0           ; load counter 0 low byte
0282   008E F2 E0 FF 10   mov byte[_timer_c_0], $10         ; load counter 0 high byte
0283   0092 4C            popa
0284   0093 06            sysret
0285   0094             
0286   0094             ; ------------------------------------------------------------------------------------------------------------------;
0287   0094             ; uart0 interrupt
0288   0094             ; ------------------------------------------------------------------------------------------------------------------;
0289   0094             int_7_uart0:
0290   0094 D7            push a
0291   0095 DA            push d
0292   0096 E1            pushf
0293   0097 14 CB 17      mov a, [fifo_in]
0294   009A 3C            mov d, a
0295   009B 1D 80 FF      mov al, [_uart0_data]       ; get character
0296   009E B9 03         cmp al, $03                 ; ctrl-c
0297   00A0 C6 BD 00      je ctrlc
0298   00A3 B9 1A         cmp al, $1a                 ; ctrl-z
0299   00A5 C6 C3 00      je ctrlz
0300   00A8 3E            mov [d], al                 ; add to fifo
0301   00A9 14 CB 17      mov a, [fifo_in]
0302   00AC 77            inc a
0303   00AD AF 2C 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0304   00B0 C7 B6 00      jne int_7_continue
0305   00B3 10 2C 1F      mov a, fifo  
0306   00B6             int_7_continue:  
0307   00B6 42 CB 17      mov [fifo_in], a            ; update fifo pointer
0308   00B9 EE            popf
0309   00BA E7            pop d
0310   00BB E4            pop a  
0311   00BC 06            sysret
0312   00BD             ctrlc:
0313   00BD 51 05 00      add sp, 5
0314   00C0 0A 15 0F      jmp syscall_terminate_proc
0315   00C3             ctrlz:
0316   00C3 EE            popf
0317   00C4 E7            pop d
0318   00C5 E4            pop a
0319   00C6 0A 58 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0320   00C9             
0321   00C9             ; ------------------------------------------------------------------------------------------------------------------;
0322   00C9             ; floppy drive syscalls
0323   00C9             ; ------------------------------------------------------------------------------------------------------------------;
0324   00C9             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0325   00C9             ; fdc_40_ff:
0326   00C9             ;   .fill 40,  $ff    ; or 00                                                                                
0327   00C9             ; fdc_128_format_inner:
0328   00C9             ;   .fill 6,   $00    ;                                                                            <--|        
0329   00C9             ;   .fill 1,   $fe    ; id address mark                                                               |        
0330   00C9             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0331   00C9             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0332   00C9             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0333   00C9             ;   .fill 1,   $00    ; sector length                                                                 |                        
0334   00C9             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0335   00C9             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0336   00C9             ;   .fill 6,   $00    ;                                                                               |                        
0337   00C9             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0338   00C9             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0339   00C9             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0340   00C9             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0341   00C9             ; fdc_128_format_end:
0342   00C9             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0343   00C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0344   00C9             fdc_jmptbl:
0345   00C9 E3 00         .dw syscall_fdc_restore
0346   00CB E8 00         .dw syscall_fdc_step
0347   00CD E9 00         .dw syscall_fdc_step_in
0348   00CF EE 00         .dw syscall_fdc_step_out
0349   00D1 F3 00         .dw syscall_fdc_seek
0350   00D3 F6 00         .dw syscall_fdc_format
0351   00D5 F4 00         .dw syscall_fdc_read_addr
0352   00D7 1E 01         .dw syscall_fdc_read_track
0353   00D9 42 01         .dw syscall_fdc_read_sect
0354   00DB 6D 01         .dw syscall_fdc_write_sect
0355   00DD F5 00         .dw syscall_fdc_force_int
0356   00DF             syscall_fdc:
0357   00DF FD 0A C9 00   jmp [fdc_jmptbl + al]
0358   00E3             
0359   00E3             syscall_fdc_restore:
0360   00E3 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0361   00E7 06            sysret
0362   00E8             
0363   00E8             syscall_fdc_step:
0364   00E8 06            sysret
0365   00E9             
0366   00E9             syscall_fdc_step_in:
0367   00E9 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0368   00ED 06            sysret
0369   00EE             
0370   00EE             syscall_fdc_step_out:
0371   00EE F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0372   00F2 06            sysret
0373   00F3             
0374   00F3             syscall_fdc_seek:
0375   00F3 06            sysret
0376   00F4             
0377   00F4             syscall_fdc_read_addr:
0378   00F4 06            sysret
0379   00F5             
0380   00F5             syscall_fdc_force_int:
0381   00F5 06            sysret
0382   00F6             
0383   00F6             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0384   00F6             ; in the ram formatting block because they are all set as 00 right now
0385   00F6             ; bl: track number
0386   00F6             syscall_fdc_format:
0387   00F6 FD 3D C9 FF   mov [_fdc_track], bl
0388   00FA F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0389   00FE             ;fdc_wait_busy_high:
0390   00FE             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0391   00FE             ;  test al, $01                ; 
0392   00FE             ;  jz fdc_wait_busy_high
0393   00FE FD 4D 2C 25   mov si, transient_area
0394   0102 F6            lodsb
0395   0103 3D CB FF      mov [_fdc_data], al      ; 10   
0396   0106 07 00 02      call fdc_wait_64us
0397   0109             fdc_format_drq:
0398   0109 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0399   010C 93 01         test al, $01                ; 4
0400   010E C6 1D 01      jz fdc_format_end           ; 8
0401   0111 93 02         test al, $02                ; 4
0402   0113 C6 09 01      jz fdc_format_drq           ; 8
0403   0116 F6            lodsb                       ; 7
0404   0117 3D CB FF      mov [_fdc_data], al      ; 10   
0405   011A 0A 09 01      jmp fdc_format_drq
0406   011D             fdc_format_end:
0407   011D 06            sysret
0408   011E             
0409   011E             syscall_fdc_read_track:
0410   011E F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0411   0122 07 00 02      call fdc_wait_64us
0412   0125             ;fdc_wait_busy_high1:
0413   0125             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0414   0125             ;  test al, $01                    ; 
0415   0125             ;  jz fdc_wait_busy_high1
0416   0125 FD 4F 2C 25   mov di, transient_area
0417   0129             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0418   0129 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0419   012C 93 01         test al, $01                ; check busy bit
0420   012E C6 3D 01      jz fdc_read_track_end
0421   0131 93 02         test al, $02                ; check drq bit
0422   0133 C6 29 01      jz fdc_read_track_l0
0423   0136 1D CB FF      mov al, [_fdc_data]     ; 
0424   0139 F7            stosb
0425   013A 0A 29 01      jmp fdc_read_track_l0
0426   013D             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0427   013D             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0428   013D             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0429   013D             fdc_read_track_end:
0430   013D 50            mov a, di
0431   013E 5F 2C 25      sub a, transient_area
0432   0141 06            sysret
0433   0142             
0434   0142             ; sector in al
0435   0142             ; track in ah
0436   0142             syscall_fdc_read_sect:
0437   0142 3D CA FF      mov [_fdc_sector], al
0438   0145 1A            mov al, ah
0439   0146 3D C9 FF      mov [_fdc_track], al
0440   0149 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0441   014D 07 00 02      call fdc_wait_64us
0442   0150             ;fdc_wait_busy_high2:
0443   0150             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0444   0150             ;  test al, $01                ; 
0445   0150             ;  jz fdc_wait_busy_high2
0446   0150 FD 4F 2C 25   mov di, transient_area
0447   0154             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0448   0154 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0449   0157 93 01         test al, $01                ; check drq bit
0450   0159 C6 68 01      jz fdc_read_sect_end
0451   015C 93 02         test al, $02                ; check drq bit
0452   015E C6 54 01      jz fdc_read_sect_l0
0453   0161 1D CB FF      mov al, [_fdc_data]     ; 
0454   0164 F7            stosb
0455   0165 0A 54 01      jmp fdc_read_sect_l0
0456   0168             fdc_read_sect_end:
0457   0168 50            mov a, di
0458   0169 5F 2C 25      sub a, transient_area
0459   016C 06            sysret
0460   016D             
0461   016D             ; sector in al
0462   016D             ; track in ah
0463   016D             ; data pointer in si
0464   016D             syscall_fdc_write_sect:
0465   016D 3D CA FF      mov [_fdc_sector], al
0466   0170 1A            mov al, ah
0467   0171 3D C9 FF      mov [_fdc_track], al
0468   0174 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0469   0178             ;fdc_wait_busy_high2:
0470   0178             ;  mov al, [_fdc_wd_stat_cmd]    
0471   0178             ;  test al, $01                
0472   0178             ;  jz fdc_wait_busy_high2
0473   0178 F6            lodsb                      
0474   0179 3D CB FF      mov [_fdc_data], al      
0475   017C 07 00 02      call fdc_wait_64us
0476   017F             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0477   017F 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0478   0182 93 01         test al, $01                ; 4
0479   0184 C6 93 01      jz fdc_write_sect_end           ; 8
0480   0187 93 02         test al, $02                ; 4
0481   0189 C6 7F 01      jz fdc_write_sect_l0           ; 8
0482   018C F6            lodsb                       ; 7
0483   018D 3D CB FF      mov [_fdc_data], al      ; 10   
0484   0190 0A 7F 01      jmp fdc_write_sect_l0
0485   0193             fdc_write_sect_end:
0486   0193 06            sysret
0487   0194             
0488   0194             fdc_format_mem:
0489   0194 3B 01 00      mov d, 1
0490   0197 FD 4F 2C 25   mov di, transient_area
0491   019B             ; 40 * FF
0492   019B 38 28 00      mov c, 40
0493   019E 19 FF         mov al, $ff
0494   01A0             fdc_l0: 
0495   01A0 F7            stosb
0496   01A1 7E            dec c
0497   01A2 C7 A0 01      jnz fdc_l0
0498   01A5             ; 6 * 00
0499   01A5             fdc_inner_loop:
0500   01A5 38 06 00      mov c, 6
0501   01A8 19 00         mov al, $00
0502   01AA             fdc_l1:
0503   01AA F7            stosb
0504   01AB 7E            dec c
0505   01AC C7 AA 01      jnz fdc_l1
0506   01AF             ; FE address mark
0507   01AF             fdc_l2:
0508   01AF 19 FE         mov al, $fe
0509   01B1 F7            stosb
0510   01B2             ; track number
0511   01B2             fdc_l3:
0512   01B2 19 00         mov al, $00
0513   01B4 F7            stosb
0514   01B5             ; side number
0515   01B5             fdc_l4:
0516   01B5 19 00         mov al, $00
0517   01B7 F7            stosb
0518   01B8             ; sector number
0519   01B8             fdc_l5:
0520   01B8 13            mov a, d
0521   01B9 F7            stosb
0522   01BA             ; sector length 128 bytes
0523   01BA             fdc_l6:
0524   01BA 19 00         mov al, $00
0525   01BC F7            stosb
0526   01BD             ; 2 crc's
0527   01BD             fdc_l7:
0528   01BD 19 F7         mov al, $f7
0529   01BF F7            stosb
0530   01C0             ; 11 times $ff
0531   01C0 38 0B 00      mov c, 11
0532   01C3 19 FF         mov al, $ff
0533   01C5             fdc_l8:
0534   01C5 F7            stosb
0535   01C6 7E            dec c
0536   01C7 C7 C5 01      jnz fdc_l8
0537   01CA             ; 6 times 00
0538   01CA 38 06 00      mov c, 6
0539   01CD 19 00         mov al, $00
0540   01CF             fdc_l9:
0541   01CF F7            stosb
0542   01D0 7E            dec c
0543   01D1 C7 CF 01      jnz fdc_l9
0544   01D4             ; FB data address mark
0545   01D4 19 FB         mov al, $fb
0546   01D6             fdc_l10:
0547   01D6 F7            stosb
0548   01D7             ; 128 bytes sector data
0549   01D7 38 80 00      mov c, 128
0550   01DA 19 E5         mov al, $E5
0551   01DC             fdc_l11:
0552   01DC F7            stosb
0553   01DD 7E            dec c
0554   01DE C7 DC 01      jnz fdc_l11
0555   01E1             ; 2 crc's
0556   01E1             fdc_l12:
0557   01E1 19 F7         mov al, $f7
0558   01E3 F7            stosb
0559   01E4             ; 10 * $FF
0560   01E4 38 0A 00      mov c, 10
0561   01E7 19 FF         mov al, $ff
0562   01E9             fdc_l13:
0563   01E9 F7            stosb
0564   01EA 7E            dec c
0565   01EB C7 E9 01      jnz fdc_l13
0566   01EE             ; check whether we did this 16 times
0567   01EE 79            inc d
0568   01EF C5 11 00      cmp d, 17
0569   01F2 C7 A5 01      jne fdc_inner_loop
0570   01F5             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0571   01F5 38 F4 01      mov c, 500
0572   01F8 19 FF         mov al, $ff
0573   01FA             fdc_format_footer:
0574   01FA             fdc_footer_drq_loop:
0575   01FA F7            stosb
0576   01FB 7E            dec c
0577   01FC C7 FA 01      jnz fdc_footer_drq_loop
0578   01FF 09            ret
0579   0200             
0580   0200             ; fetch is 2 cycles long when 'display_reg_load' is false.
0581   0200             ; 64us amounts to 160 cycles of the 2.5mhz clock
0582   0200             ; call u16 is 14 cycles long
0583   0200             ; 160 - 5 - 14 = 
0584   0200             fdc_wait_64us:
0585   0200 3A 0D         mov cl, 13                       ; 5 cycles
0586   0202             fdc_wait_64_loop:
0587   0202 81            dec cl                           ; 3 cycles
0588   0203 C7 02 02      jnz fdc_wait_64_loop             ; 8 cycles
0589   0206 09            ret
0590   0207             
0591   0207             ; ------------------------------------------------------------------------------------------------------------------;
0592   0207             ; system syscalls
0593   0207             ; ------------------------------------------------------------------------------------------------------------------;
0594   0207             system_jmptbl:
0595   0207 3D 02         .dw system_uname
0596   0209 44 02         .dw system_whoami
0597   020B 17 02         .dw system_setparam
0598   020D 1A 02         .dw system_bootloader_install
0599   020F 15 02         .dw system_getparam
0600   0211             syscall_system:
0601   0211 FD 0A 07 02   jmp [system_jmptbl + al]
0602   0215             
0603   0215             ; param register address in register d
0604   0215             ; param value in register bl
0605   0215             system_getparam:
0606   0215 32            mov bl, [d]
0607   0216 06            sysret
0608   0217             
0609   0217             ; param register address in register d
0610   0217             ; param value in register bl
0611   0217             system_setparam:
0612   0217 FD 3E         mov [d], bl
0613   0219 06            sysret
0614   021A             
0615   021A             ; kernel LBA address in 'b'
0616   021A             system_bootloader_install:
0617   021A D8            push b
0618   021B 26 00 00      mov b, 0
0619   021E 38 00 00      mov c, 0
0620   0221 22 01         mov ah, $01                 ; 1 sector
0621   0223 3B 2C 25      mov d, transient_area
0622   0226 07 73 05      call ide_read_sect          ; read sector
0623   0229 E5            pop b
0624   022A FD 44 FE 01   mov [d + 510], b            ; update LBA address
0625   022E 26 00 00      mov b, 0
0626   0231 38 00 00      mov c, 0
0627   0234 22 01         mov ah, $01                 ; 1 sector
0628   0236 3B 2C 25      mov d, transient_area
0629   0239 07 99 05      call ide_write_sect         ; write sector
0630   023C 06            sysret
0631   023D             
0632   023D             system_uname:
0633   023D 3B DC 17      mov d, s_uname
0634   0240 07 95 12      call _puts
0635   0243 06            sysret
0636   0244             
0637   0244             system_whoami:
0638   0244 06            sysret
0639   0245             
0640   0245             ; reboot system
0641   0245             syscall_reboot:
0642   0245 FD D7 FF FF   push word $ffff 
0643   0249 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0644   024C FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0645   0250 06            sysret
0646   0251             
0647   0251             ;------------------------------------------------------------------------------------------------------;;
0648   0251             ; switch to another process
0649   0251             ; inputs:
0650   0251             ; al = new process number
0651   0251             ;------------------------------------------------------------------------------------------------------;;
0652   0251             syscall_resume_proc:
0653   0251 FD 78         mov g, a                            ; save the process number
0654   0253 4B            pusha                               ; save all registers into kernel stack
0655   0254 22 00         mov ah, 0
0656   0256 1D C6 17      mov al, [active_proc_index]
0657   0259 FD 99         shl a              ; x2
0658   025B B7 0B 10      mov a, [proc_table_convert + a]     ; get process state start index
0659   025E 4F            mov di, a
0660   025F 48            mov a, sp
0661   0260 77            inc a
0662   0261 4D            mov si, a
0663   0262 38 14 00      mov c, 20
0664   0265 FD F5         rep movsb                           ; save process state!
0665   0267             ; restore kernel stack position to point before interrupt arrived
0666   0267 51 14 00      add sp, 20
0667   026A             ; now load the new process number!
0668   026A FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0669   026C 3D C6 17      mov [active_proc_index], al         ; set new active proc
0670   026F             ; calculate lut entry for next process
0671   026F 22 00         mov ah, 0
0672   0271 FD 99         shl a                               ; x2
0673   0273 B7 0B 10      mov a, [proc_table_convert + a]     ; get process state start index  
0674   0276 4D            mov si, a                           ; source is proc state block
0675   0277 48            mov a, sp
0676   0278 5F 13 00      sub a, 19
0677   027B 4F            mov di, a                           ; destination is kernel stack
0678   027C             ; restore sp
0679   027C 7D            dec a
0680   027D 47            mov sp, a
0681   027E 38 14 00      mov c, 20
0682   0281 FD F5         rep movsb
0683   0283             ; set vm process
0684   0283 1D C6 17      mov al, [active_proc_index]
0685   0286 01            setptb
0686   0287 4C            popa
0687   0288 06            sysret
0688   0289             
0689   0289             ;------------------------------------------------------------------------------------------------------;;
0690   0289             ; list processes
0691   0289             ;------------------------------------------------------------------------------------------------------;;
0692   0289             syscall_list_procs:
0693   0289 3B FD 17      mov d, s_ps_header
0694   028C 07 95 12      call _puts
0695   028F 3B 9D 1A      mov d, proc_availab_table + 1
0696   0292 38 01 00      mov c, 1
0697   0295             list_procs_l0:  
0698   0295 BD 01         cmp byte[d], 1
0699   0297 C7 BB 02      jne list_procs_next
0700   029A 2D            mov b, d
0701   029B 61 9C 1A      sub b, proc_availab_table
0702   029E FD 9F 05      shl b, 5
0703   02A1 DA            push d
0704   02A2 D8            push b
0705   02A3 28            mov b, c
0706   02A4 07 35 13      call print_u8x
0707   02A7 22 20         mov ah, ' '
0708   02A9 07 69 11      call _putchar
0709   02AC 07 69 11      call _putchar
0710   02AF E5            pop b
0711   02B0 74            mov d, b
0712   02B1 58 AC 1A      add d, proc_names
0713   02B4 07 95 12      call _puts
0714   02B7 07 42 12      call printnl
0715   02BA E7            pop d
0716   02BB             list_procs_next:
0717   02BB 79            inc d
0718   02BC 78            inc c
0719   02BD C2 09 00      cmp c, 9
0720   02C0 C7 95 02      jne list_procs_l0
0721   02C3             list_procs_end:
0722   02C3 06            sysret
0723   02C4             
0724   02C4             ; ------------------------------------------------------------------------------------------------------------------;
0725   02C4             ; exceptions code block
0726   02C4             ; ------------------------------------------------------------------------------------------------------------------;
0727   02C4             ; privilege exception
0728   02C4             ; ------------------------------------------------------------------------------------------------------------------;
0729   02C4             trap_privilege:
0730   02C4 0A 45 02      jmp syscall_reboot
0731   02C7 DA            push d
0732   02C8 3B 4C 18      mov d, s_priviledge
0733   02CB 07 95 12      call _puts
0734   02CE E7            pop d
0735   02CF 06            sysret
0736   02D0             
0737   02D0             ; ------------------------------------------------------------------------------------------------------------------;
0738   02D0             ; breakpoint
0739   02D0             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0740   02D0             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0741   02D0             ; ------------------------------------------------------------------------------------------------------------------;
0742   02D0             syscall_break:
0743   02D0 4B            pusha
0744   02D1             syscall_break_prompt:
0745   02D1 3B 8B 03      mov d, s_break1
0746   02D4 07 95 12      call _puts
0747   02D7 07 42 12      call printnl
0748   02DA 07 97 13      call scan_u16d
0749   02DD AF 00 00      cmp a, 0
0750   02E0 C6 EB 02      je syscall_break_regs
0751   02E3 AF 01 00      cmp a, 1
0752   02E6 C6 0E 03      je syscall_break_mem
0753   02E9             syscall_break_end:  
0754   02E9 4C            popa
0755   02EA 06            sysret
0756   02EB             syscall_break_regs:
0757   02EB 48            mov a, sp
0758   02EC 53 0E 00      add a, 14               ; back-track 7 registers
0759   02EF 3C            mov d, a
0760   02F0 3A 07         mov cl, 7
0761   02F2             syscall_regs_l0:
0762   02F2 2A            mov b, [d]
0763   02F3 FD AB         swp b
0764   02F5 07 F1 12      call print_u16x         ; print register value
0765   02F8 07 42 12      call printnl
0766   02FB 63 02 00      sub d, 2
0767   02FE 71 01         sub cl, 1
0768   0300 C3 00         cmp cl, 0
0769   0302 C7 F2 02      jne syscall_regs_l0
0770   0305 0A D1 02      jmp syscall_break_prompt
0771   0308 07 42 12      call printnl
0772   030B 0A D1 02      jmp syscall_break_prompt
0773   030E             syscall_break_mem:
0774   030E 07 42 12      call printnl
0775   0311 07 13 13      call scan_u16x
0776   0314 4D            mov si, a               ; data source from user space
0777   0315 FD 4F 2C 23   mov di, scrap_sector    ; destination in kernel space
0778   0319 38 00 02      mov c, 512
0779   031C 04            load                    ; transfer data to kernel space!
0780   031D 3B 2C 23      mov d, scrap_sector     ; dump pointer in d
0781   0320 38 00 00      mov c, 0
0782   0323             dump_loop:
0783   0323 84            mov al, cl
0784   0324 87 0F         and al, $0f
0785   0326 C6 74 03      jz print_base
0786   0329             back:
0787   0329 1E            mov al, [d]             ; read byte
0788   032A 2F            mov bl, al
0789   032B 07 35 13      call print_u8x
0790   032E 10 00 20      mov a, $2000
0791   0331 05 03         syscall sys_io          ; space
0792   0333 84            mov al, cl
0793   0334 87 0F         and al, $0f
0794   0336 B9 0F         cmp al, $0f
0795   0338 C6 49 03      je print_ascii
0796   033B             back1:
0797   033B 79            inc d
0798   033C 78            inc c
0799   033D C2 00 02      cmp c, 512
0800   0340 C7 23 03      jne dump_loop
0801   0343 07 42 12      call printnl
0802   0346 0A D1 02      jmp syscall_break_prompt  ; go to syscall_break return point
0803   0349             print_ascii:
0804   0349 10 00 20      mov a, $2000
0805   034C 05 03         syscall sys_io
0806   034E 63 10 00      sub d, 16
0807   0351 26 10 00      mov b, 16
0808   0354             print_ascii_l:
0809   0354 79            inc d
0810   0355 1E            mov al, [d]               ; read byte
0811   0356 B9 20         cmp al, $20
0812   0358 C8 60 03      jlu dot
0813   035B B9 7E         cmp al, $7e
0814   035D D0 68 03      jleu ascii
0815   0360             dot:
0816   0360 10 00 2E      mov a, $2e00
0817   0363 05 03         syscall sys_io
0818   0365 0A 6D 03      jmp ascii_continue
0819   0368             ascii:
0820   0368 23            mov ah, al
0821   0369 19 00         mov al, 0
0822   036B 05 03         syscall sys_io
0823   036D             ascii_continue:
0824   036D FD A9 54 03   loopb print_ascii_l
0825   0371 0A 3B 03      jmp back1
0826   0374             print_base:
0827   0374 07 42 12      call printnl
0828   0377 2D            mov b, d
0829   0378 61 2C 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0830   037B 07 F1 12      call print_u16x          ; display row
0831   037E 10 00 3A      mov a, $3a00
0832   0381 05 03         syscall sys_io
0833   0383 10 00 20      mov a, $2000
0834   0386 05 03         syscall sys_io
0835   0388 0A 29 03      jmp back
0836   038B             
0837   038B             s_break1:  
0838   038B 0A 64 65 62   .db "\ndebugger entry point.\n"
0838   038F 75 67 67 65 
0838   0393 72 20 65 6E 
0838   0397 74 72 79 20 
0838   039B 70 6F 69 6E 
0838   039F 74 2E 0A 
0839   03A2 30 2E 20 73   .db "0. show registers\n"
0839   03A6 68 6F 77 20 
0839   03AA 72 65 67 69 
0839   03AE 73 74 65 72 
0839   03B2 73 0A 
0840   03B4 31 2E 20 73   .db "1. show 512b ram block\n"
0840   03B8 68 6F 77 20 
0840   03BC 35 31 32 62 
0840   03C0 20 72 61 6D 
0840   03C4 20 62 6C 6F 
0840   03C8 63 6B 0A 
0841   03CB 32 2E 20 63   .db "2. continue execution", 0
0841   03CF 6F 6E 74 69 
0841   03D3 6E 75 65 20 
0841   03D7 65 78 65 63 
0841   03DB 75 74 69 6F 
0841   03DF 6E 00 
0842   03E1             
0843   03E1             ; ------------------------------------------------------------------------------------------------------------------;
0844   03E1             ; divide by zero exception
0845   03E1             ; ------------------------------------------------------------------------------------------------------------------;
0846   03E1             trap_div_zero:
0847   03E1 D7            push a
0848   03E2 DA            push d
0849   03E3 E1            pushf
0850   03E4 3B 63 18      mov d, s_divzero
0851   03E7 07 95 12      call _puts
0852   03EA EE            popf
0853   03EB E7            pop d
0854   03EC E4            pop a
0855   03ED 06            sysret ; enable interrupts
0856   03EE             
0857   03EE             ; ------------------------------------------------------------------------------------------------------------------;
0858   03EE             ; undefined opcode exception
0859   03EE             ; ------------------------------------------------------------------------------------------------------------------;
0860   03EE             trap_undef_opcode:
0861   03EE 06            sysret
0862   03EF             
0863   03EF             ; ------------------------------------------------------------------------------------------------------------------;
0864   03EF             ; real-time clock services syscall
0865   03EF             ; rtc i/o bank = ffa0 to ffaf
0866   03EF             ; ffa0 to ffa7 is scratch ram
0867   03EF             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0868   03EF             ; al = 0..6 -> get
0869   03EF             ; al = 7..d -> set
0870   03EF             ; ------------------------------------------------------------------------------------------------------------------;
0871   03EF             syscall_rtc:
0872   03EF DB            push al
0873   03F0 DA            push d
0874   03F1 B9 06         cmp al, 6
0875   03F3 D1 08 04      jgu syscall_rtc_set
0876   03F6             syscall_rtc_get:
0877   03F6 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0878   03F8 22 FF         mov ah, $ff    
0879   03FA 3C            mov d, a                ; get to ffa9 + offset
0880   03FB F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0881   03FF 1E            mov al, [d]             ; get data
0882   0400 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0883   0404 23            mov ah, al
0884   0405 E7            pop d
0885   0406 E8            pop al
0886   0407 06            sysret
0887   0408             syscall_rtc_set:
0888   0408 DD            push bl
0889   0409 99            mov bl, ah              ; set data aside
0890   040A 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0891   040C 22 FF         mov ah, $ff    
0892   040E 3C            mov d, a                ; get to ffa9 + offset
0893   040F 1B            mov al, bl              ; get data back
0894   0410 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0895   0414 3E            mov [d], al             ; set data
0896   0415 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0897   0419 EA            pop bl
0898   041A E7            pop d
0899   041B E8            pop al
0900   041C 06            sysret
0901   041D             
0902   041D             datetime_serv_tbl:
0903   041D 25 04         .dw print_date
0904   041F 99 04         .dw set_date
0905   0421             syscall_datetime:
0906   0421 FD 0A 1D 04   jmp [datetime_serv_tbl + al]      
0907   0425             print_date:
0908   0425 10 00 0D      mov a, $0d00           ; print carriage return char
0909   0428 19 03         mov al, 3
0910   042A 05 01         syscall sys_rtc        ; get week
0911   042C 1A            mov al, ah
0912   042D 22 00         mov ah, 0
0913   042F FD 9D 02      shl a, 2          
0914   0432 3B ED 18      mov d, s_week
0915   0435 59            add d, a
0916   0436 07 95 12      call _puts
0917   0439 10 00 20      mov a, $2000
0918   043C 05 03         syscall sys_io         ; display ' '
0919   043E 19 04         mov al, 4
0920   0440 05 01         syscall sys_rtc        ; get day
0921   0442 99            mov bl, ah
0922   0443 07 35 13      call print_u8x
0923   0446 10 00 20      mov a, $2000
0924   0449 05 03         syscall sys_io         ; display ' '
0925   044B             ; there is a problem with the month displaying
0926   044B             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0927   044B             ; even though it is to be understood as bcd.
0928   044B             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0929   044B 19 05         mov al, 05
0930   044D 05 01         syscall sys_rtc        ; get month
0931   044F 1A            mov al, ah
0932   0450 22 00         mov ah, 0
0933   0452 FD 9D 02      shl a, 2          
0934   0455 3B B9 18      mov d, s_months
0935   0458 59            add d, a
0936   0459 07 95 12      call _puts
0937   045C 10 00 20      mov a, $2000
0938   045F 05 03         syscall sys_io         ; display ' '
0939   0461 2E 20         mov bl, $20
0940   0463 07 35 13      call print_u8x         ; print 20 for year prefix
0941   0466 19 06         mov al, 06
0942   0468 05 01         syscall sys_rtc        ; get year
0943   046A 99            mov bl, ah
0944   046B 07 35 13      call print_u8x
0945   046E 10 00 20      mov a, $2000  
0946   0471 05 03         syscall sys_io         ; display ' '
0947   0473 19 02         mov al, 2
0948   0475 05 01         syscall sys_rtc        ; get hours
0949   0477 99            mov bl, ah
0950   0478 07 35 13      call print_u8x
0951   047B 10 00 3A      mov a, $3a00    
0952   047E 05 03         syscall sys_io         ; display ':'
0953   0480 19 01         mov al, 01
0954   0482 05 01         syscall sys_rtc        ; get minutes
0955   0484 99            mov bl, ah
0956   0485 07 35 13      call print_u8x
0957   0488 10 00 3A      mov a, $3a00  
0958   048B 05 03         syscall sys_io         ; display ':'
0959   048D 19 00         mov al, 0
0960   048F 05 01         syscall sys_rtc        ; get seconds
0961   0491 99            mov bl, ah
0962   0492 07 35 13      call print_u8x
0963   0495 07 42 12      call printnl
0964   0498 06            sysret
0965   0499             set_date:
0966   0499 3B 7E 18      mov d, s_set_year
0967   049C 07 95 12      call _puts
0968   049F 07 80 13      call scan_u8x          ; read integer into a
0969   04A2 FD 9D 08      shl a, 8               ; only al used, move to ah
0970   04A5 19 0D         mov al, 0dh            ; set rtc year
0971   04A7 05 01         syscall sys_rtc        ; set rtc
0972   04A9 3B 85 18      mov d, s_set_month
0973   04AC 07 95 12      call _puts
0974   04AF 07 80 13      call scan_u8x          ; read integer into a
0975   04B2 FD 9D 08      shl a, 8               ; only al used, move to ah
0976   04B5 19 0C         mov al, 0ch            ; set rtc month
0977   04B7 05 01         syscall sys_rtc        ; set rtc
0978   04B9 3B 8D 18      mov d, s_set_day
0979   04BC 07 95 12      call _puts
0980   04BF 07 80 13      call scan_u8x          ; read integer into a
0981   04C2 FD 9D 08      shl a, 8               ; only al used, move to ah
0982   04C5 19 0B         mov al, 0bh            ; set rtc month
0983   04C7 05 01         syscall sys_rtc        ; set rtc
0984   04C9 3B 93 18      mov d, s_set_week
0985   04CC 07 95 12      call _puts
0986   04CF 07 80 13      call scan_u8x          ; read integer into a
0987   04D2 FD 9D 08      shl a, 8               ; only al used, move to ah
0988   04D5 19 0A         mov al, 0ah            ; set rtc month
0989   04D7 05 01         syscall sys_rtc        ; set rtc
0990   04D9 3B 9D 18      mov d, s_set_hours
0991   04DC 07 95 12      call _puts
0992   04DF 07 80 13      call scan_u8x          ; read integer into a
0993   04E2 FD 9D 08      shl a, 8               ; only al used, move to ah
0994   04E5 19 09         mov al, 09h            ; set rtc month
0995   04E7 05 01         syscall sys_rtc        ; set rtc
0996   04E9 3B A5 18      mov d, s_set_minutes
0997   04EC 07 95 12      call _puts
0998   04EF 07 80 13      call scan_u8x          ; read integer into a
0999   04F2 FD 9D 08      shl a, 8               ; only al used, move to ah
1000   04F5 19 08         mov al, 08h            ; set rtc month
1001   04F7 05 01         syscall sys_rtc        ; set rtc
1002   04F9 3B AF 18      mov d, s_set_seconds
1003   04FC 07 95 12      call _puts
1004   04FF 07 80 13      call scan_u8x          ; read integer into a
1005   0502 FD 9D 08      shl a, 8               ; only al used, move to ah
1006   0505 19 07         mov al, 07h            ; set rtc month
1007   0507 05 01         syscall sys_rtc        ; set rtc
1008   0509 06            sysret
1009   050A             
1010   050A             ; ------------------------------------------------------------------------------------------------------------------;
1011   050A             ; ide services syscall
1012   050A             ; al = option
1013   050A             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1014   050A             ; ide read/write sector
1015   050A             ; 512 bytes
1016   050A             ; user buffer pointer in d
1017   050A             ; ah = number of sectors
1018   050A             ; cb = lba bytes 3..0
1019   050A             ; ------------------------------------------------------------------------------------------------------------------;
1020   050A 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
1020   050E 73 63 61 6C 
1020   0512 6C 5F 69 64 
1020   0516 65 20 63 61 
1020   051A 6C 6C 65 64 
1020   051E 3A 20 00 
1021   0521             ide_serv_tbl:
1022   0521 48 05         .dw ide_reset
1023   0523 5C 05         .dw ide_sleep
1024   0525 6B 05         .dw ide_read_sect_wrapper
1025   0527 6F 05         .dw ide_write_sect_wrapper
1026   0529             syscall_ide:
1027   0529 DD            push bl
1028   052A 31 BE 17      mov bl, [sys_debug_mode]
1029   052D               ; debug block
1030   052D C1 00         cmp bl, 0
1031   052F EA            pop bl
1032   0530 C6 44 05      je syscall_ide_jmp
1033   0533 DA            push d
1034   0534 DD            push bl
1035   0535 3B 0A 05      mov d, s_syscall_ide_dbg0
1036   0538 07 95 12      call _puts
1037   053B 2F            mov bl, al
1038   053C 07 35 13      call print_u8x
1039   053F 07 42 12      call printnl
1040   0542 EA            pop bl
1041   0543 E7            pop d
1042   0544             syscall_ide_jmp:
1043   0544 FD 0A 21 05   jmp [ide_serv_tbl + al]    
1044   0548               
1045   0548             ide_reset:      
1046   0548 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1047   054C 07 F5 05      call ide_wait                   ; wait for ide ready             
1048   054F F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1049   0553 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1050   0557 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1051   055B 06            sysret
1052   055C             ide_sleep:
1053   055C 07 F5 05      call ide_wait                   ; wait for ide ready             
1054   055F F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1055   0563 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1056   0567 07 F5 05      call ide_wait                   ; wait for ide ready
1057   056A 06            sysret
1058   056B             ide_read_sect_wrapper:
1059   056B 07 73 05      call ide_read_sect
1060   056E 06            sysret
1061   056F             ide_write_sect_wrapper:
1062   056F 07 99 05      call ide_write_sect
1063   0572 06            sysret
1064   0573             ide_read_sect:
1065   0573 1A            mov al, ah
1066   0574 24            mov ah, bl
1067   0575 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1068   0578 1C            mov al, bh
1069   0579 3D D4 FF      mov [_ide_r4], al
1070   057C 12            mov a, c
1071   057D 3D D5 FF      mov [_ide_r5], al
1072   0580 1A            mov al, ah
1073   0581 87 0F         and al, %00001111
1074   0583 8B E0         or al, %11100000                ; mode lba, master
1075   0585 3D D6 FF      mov [_ide_r6], al
1076   0588             ide_read_sect_wait:
1077   0588 1D D7 FF      mov al, [_ide_r7]  
1078   058B 87 80         and al, $80                     ; busy flag
1079   058D C7 88 05      jnz ide_read_sect_wait
1080   0590 19 20         mov al, $20
1081   0592 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1082   0595 07 BF 05      call ide_read  
1083   0598 09            ret
1084   0599             ide_write_sect:
1085   0599 1A            mov al, ah
1086   059A 24            mov ah, bl
1087   059B 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1088   059E 1C            mov al, bh
1089   059F 3D D4 FF      mov [_ide_r4], al
1090   05A2 12            mov a, c
1091   05A3 3D D5 FF      mov [_ide_r5], al
1092   05A6 1A            mov al, ah
1093   05A7 87 0F         and al, %00001111
1094   05A9 8B E0         or al, %11100000                ; mode lba, master
1095   05AB 3D D6 FF      mov [_ide_r6], al
1096   05AE             ide_write_sect_wait:
1097   05AE 1D D7 FF      mov al, [_ide_r7]  
1098   05B1 87 80         and al, $80                     ; busy flag
1099   05B3 C7 AE 05      jnz ide_write_sect_wait
1100   05B6 19 30         mov al, $30
1101   05B8 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1102   05BB 07 DA 05      call ide_write      
1103   05BE 09            ret
1104   05BF             
1105   05BF             ;----------------------------------------------------------------------------------------------------;
1106   05BF             ; read ide data
1107   05BF             ; pointer in d
1108   05BF             ;----------------------------------------------------------------------------------------------------;
1109   05BF             ide_read:
1110   05BF DA            push d
1111   05C0             ide_read_loop:
1112   05C0 1D D7 FF      mov al, [_ide_r7]  
1113   05C3 87 80         and al, 80h                     ; busy flag
1114   05C5 C7 C0 05      jnz ide_read_loop               ; wait loop
1115   05C8 1D D7 FF      mov al, [_ide_r7]
1116   05CB 87 08         and al, %00001000               ; drq flag
1117   05CD C6 D8 05      jz ide_read_end
1118   05D0 1D D0 FF      mov al, [_ide_r0]
1119   05D3 3E            mov [d], al
1120   05D4 79            inc d
1121   05D5 0A C0 05      jmp ide_read_loop
1122   05D8             ide_read_end:
1123   05D8 E7            pop d
1124   05D9 09            ret
1125   05DA             
1126   05DA             ;----------------------------------------------------------------------------------------------------;
1127   05DA             ; write ide data
1128   05DA             ; data pointer in d
1129   05DA             ;----------------------------------------------------------------------------------------------------;
1130   05DA             ide_write:
1131   05DA DA            push d
1132   05DB             ide_write_loop:
1133   05DB 1D D7 FF      mov al, [_ide_r7]  
1134   05DE 87 80         and al, 80h             ; busy flag
1135   05E0 C7 DB 05      jnz ide_write_loop      ; wait loop
1136   05E3 1D D7 FF      mov al, [_ide_r7]
1137   05E6 87 08         and al, %00001000       ; drq flag
1138   05E8 C6 F3 05      jz ide_write_end
1139   05EB 1E            mov al, [d]
1140   05EC 3D D0 FF      mov [_ide_r0], al
1141   05EF 79            inc d 
1142   05F0 0A DB 05      jmp ide_write_loop
1143   05F3             ide_write_end:
1144   05F3 E7            pop d
1145   05F4 09            ret
1146   05F5             
1147   05F5             ;----------------------------------------------------------------------------------------------------;
1148   05F5             ; wait for ide to be ready
1149   05F5             ;----------------------------------------------------------------------------------------------------;
1150   05F5             ide_wait:
1151   05F5 1D D7 FF      mov al, [_ide_r7]  
1152   05F8 87 80         and al, 80h        ; busy flag
1153   05FA C7 F5 05      jnz ide_wait
1154   05FD 09            ret
1155   05FE             
1156   05FE             ;----------------------------------------------------------------------------------------------------;
1157   05FE             ; io syscall
1158   05FE             ;----------------------------------------------------------------------------------------------------;
1159   05FE             ; baud  divisor
1160   05FE             ; 50    2304
1161   05FE             ; 110   1047
1162   05FE             ; 300    384
1163   05FE             ; 600    192
1164   05FE             ; 1200    96
1165   05FE             ; 9600    12
1166   05FE             ; 19200    6
1167   05FE             ; 38400    3
1168   05FE             syscall_io_jmp:
1169   05FE 31 06         .dw syscall_io_putchar
1170   0600 3E 06         .dw syscall_io_getch
1171   0602 08 06         .dw syscall_io_uart_setup
1172   0604             syscall_io:
1173   0604 FD 0A FE 05   jmp [syscall_io_jmp + al]
1174   0608             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1175   0608             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1176   0608             ; buffer, the transmitter holding register, or the interrupt enable register.
1177   0608             syscall_io_uart_setup:
1178   0608 1D C0 17      mov al, [sys_uart0_lcr]
1179   060B 8B 80         or al, $80                ; set dlab access bit
1180   060D 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1181   0610 1D C3 17      mov al, [sys_uart0_div0]
1182   0613 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1183   0616 1D C4 17      mov al, [sys_uart0_div1]
1184   0619 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1185   061C             
1186   061C 1D C0 17      mov al, [sys_uart0_lcr]
1187   061F 87 7F         and al, $7f               ; clear dlab access bit 
1188   0621 3D 83 FF      mov [_uart0_lcr], al
1189   0624 1D C1 17      mov al, [sys_uart0_inten]
1190   0627 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1191   062A 1D C2 17      mov al, [sys_uart0_fifoen]
1192   062D 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1193   0630 06            sysret
1194   0631             
1195   0631             ; char in ah
1196   0631             syscall_io_putchar:
1197   0631             syscall_io_putchar_l0:
1198   0631 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1199   0634 87 20         and al, $20
1200   0636 C6 31 06      jz syscall_io_putchar_l0    
1201   0639 1A            mov al, ah
1202   063A 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1203   063D 06            sysret
1204   063E             
1205   063E             ; char in ah
1206   063E             ; al = sucess code
1207   063E             syscall_io_getch:
1208   063E D8            push b
1209   063F DA            push d
1210   0640 FD 0C         sti
1211   0642             syscall_io_getch_l0:  
1212   0642 14 CD 17      mov a, [fifo_out]
1213   0645 29 CB 17      mov b, [fifo_in]
1214   0648 B0            cmp a, b
1215   0649 C6 42 06      je syscall_io_getch_l0
1216   064C 3C            mov d, a
1217   064D 77            inc a
1218   064E AF 2C 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1219   0651 C7 57 06      jne syscall_io_getch_cont
1220   0654 10 2C 1F      mov a, fifo  
1221   0657             syscall_io_getch_cont:  
1222   0657 42 CD 17      mov [fifo_out], a             ; update fifo pointer
1223   065A 1E            mov al, [d]                   ; get char
1224   065B 23            mov ah, al
1225   065C 1D BF 17      mov al, [sys_echo_on]
1226   065F B9 01         cmp al, 1
1227   0661 C7 70 06      jne syscall_io_getch_noecho 
1228   0664             ; here we just echo the char back to the console
1229   0664             syscall_io_getch_echo_l0:
1230   0664 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1231   0667 87 20         and al, $20                 ; isolate transmitter empty
1232   0669 C6 64 06      jz syscall_io_getch_echo_l0
1233   066C 1A            mov al, ah
1234   066D 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1235   0670             syscall_io_getch_noecho:
1236   0670 19 01         mov al, 1                    ; al = 1 means a char successfully received
1237   0672 E7            pop d
1238   0673 E5            pop b
1239   0674 06            sysret
1240   0675             
1241   0675             ;------------------------------------------------------------------------------------------------------;
1242   0675             ; file system data
1243   0675             ;------------------------------------------------------------------------------------------------------;
1244   0675             ; infor for : ide services interrupt
1245   0675             ; ide read/write 512-byte sector
1246   0675             ; al = option
1247   0675             ; user buffer pointer in d
1248   0675             ; ah = number of sectors
1249   0675             ; cb = lba bytes 3..0  
1250   0675             ;------------------------------------------------------------------------------------------------------;
1251   0675             ; file system data structure
1252   0675             ;------------------------------------------------------------------------------------------------------;
1253   0675             ; for a directory we have the header first, followed by metadata
1254   0675             ; header 1 sector (512 bytes)
1255   0675             ; metadata 1 sector (512 bytes)
1256   0675             ; header entries:
1257   0675             ; filename (64)
1258   0675             ; parent dir lba (2) -  to be used for faster backwards navigation...
1259   0675             ;
1260   0675             ; metadata entries:
1261   0675             ; filename (24)
1262   0675             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1263   0675             ; lba (2)
1264   0675             ; size (2)
1265   0675             ; day (1)
1266   0675             ; month (1)
1267   0675             ; year (1)
1268   0675             ; packet size = 32 bytes
1269   0675             ;
1270   0675             ; first directory on disk is the root directory '/'
1271   0675             file_system_jmptbl:
1272   0675 E0 06         .dw fs_mkfs                   ; 0
1273   0677 00 00         .dw 0                         ; 1
1274   0679 42 07         .dw fs_mkdir                  ; 2
1275   067B BB 0A         .dw fs_cd                     ; 3
1276   067D C2 0A         .dw fs_ls                     ; 4
1277   067F AD 0B         .dw fs_mktxt                  ; 5
1278   0681 78 0C         .dw fs_mkbin                  ; 6
1279   0683 3F 0D         .dw fs_pwd                    ; 7
1280   0685 5C 0D         .dw fs_cat                    ; 8
1281   0687 B8 0D         .dw fs_rmdir                  ; 9
1282   0689 14 0E         .dw fs_rm                     ; 10
1283   068B 00 00         .dw 0                         ; 11
1284   068D 00 00         .dw 0                         ; 12
1285   068F 00 00         .dw 0                         ; 13
1286   0691 E8 06         .dw fs_chmod                  ; 14
1287   0693 7C 0E         .dw fs_mv                     ; 15
1288   0695 E1 06         .dw fs_cd_root                ; 16
1289   0697 B7 0A         .dw fs_get_curr_dirid         ; 17
1290   0699 93 08         .dw fs_dir_id_to_path         ; 18
1291   069B F9 08         .dw fs_path_to_dir_id_user    ; 19
1292   069D 13 0A         .dw fs_load_from_path_user    ; 20  
1293   069F 83 09         .dw fs_filepath_exists_user   ; 21
1294   06A1             
1295   06A1 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1295   06A5 79 73 63 61 
1295   06A9 6C 6C 5F 66 
1295   06AD 69 6C 65 5F 
1295   06B1 73 79 73 74 
1295   06B5 65 6D 20 63 
1295   06B9 61 6C 6C 65 
1295   06BD 64 3A 20 00 
1296   06C1             syscall_file_system:
1297   06C1 DD            push bl
1298   06C2 31 BE 17      mov bl, [sys_debug_mode]
1299   06C5               ; debug block
1300   06C5 C1 00         cmp bl, 0
1301   06C7 EA            pop bl
1302   06C8 C6 DC 06      je syscall_filesystem_jmp
1303   06CB DA            push d
1304   06CC DD            push bl
1305   06CD 3B A1 06      mov d, s_syscall_fs_dbg0
1306   06D0 07 95 12      call _puts
1307   06D3 2F            mov bl, al
1308   06D4 07 35 13      call print_u8x
1309   06D7 07 42 12      call printnl
1310   06DA EA            pop bl
1311   06DB E7            pop d
1312   06DC             syscall_filesystem_jmp:
1313   06DC FD 0A 75 06   jmp [file_system_jmptbl + al]
1314   06E0             
1315   06E0             fs_mkfs:  
1316   06E0 06            sysret  
1317   06E1               
1318   06E1             fs_cd_root:
1319   06E1 10 20 00      mov a, root_id
1320   06E4 42 CF 17      mov [current_dir_id], a      ; set current directory lba to root
1321   06E7 06            sysret  
1322   06E8             
1323   06E8             ; filename in d (userspace data)
1324   06E8             ; permission in bl
1325   06E8             fs_chmod:
1326   06E8 DD            push bl
1327   06E9 FD 4E         mov si, d
1328   06EB FD 4F 2C 1D   mov di, user_data
1329   06EF 38 80 00      mov c, 128
1330   06F2 04            load                        ; load filename from user-space
1331   06F3 14 CF 17      mov a, [current_dir_id]
1332   06F6 77            inc a                       ; metadata sector
1333   06F7 27            mov b, a
1334   06F8 38 00 00      mov c, 0                    ; upper lba = 0
1335   06FB 22 01         mov ah, $01                  ; 1 sector
1336   06FD 3B 2C 25      mov d, transient_area
1337   0700 07 73 05      call ide_read_sect          ; read directory
1338   0703 FD 10         cla
1339   0705 42 C7 17      mov [index], a              ; reset file counter
1340   0708             fs_chmod_l1:
1341   0708 FD 4E         mov si, d
1342   070A FD 4F 2C 1D   mov di, user_data
1343   070E 07 D8 10      call _strcmp
1344   0711 C6 28 07      je fs_chmod_found_entry
1345   0714 58 20 00      add d, 32
1346   0717 14 C7 17      mov a, [index]
1347   071A 77            inc a
1348   071B 42 C7 17      mov [index], a
1349   071E AF 10 00      cmp a, fst_files_per_dir
1350   0721 C7 08 07      jne fs_chmod_l1
1351   0724 EA            pop bl
1352   0725 0A 41 07      jmp fs_chmod_not_found
1353   0728             fs_chmod_found_entry:  
1354   0728 FD 79         mov g, b                    ; save lba
1355   072A EA            pop bl                      ; retrieve saved permission value
1356   072B 1F 18 00      mov al, [d + 24]            ; read file permissions
1357   072E 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1358   0730 8C            or al, bl                   ; set new permissions
1359   0731 3F 18 00      mov [d + 24], al            ; write new permissions
1360   0734 38 00 00      mov c, 0
1361   0737 3B 2C 25      mov d, transient_area
1362   073A 22 01         mov ah, $01                 ; disk write 1 sect
1363   073C FD 27         mov b, g                    ; retrieve lba
1364   073E 07 99 05      call ide_write_sect         ; write sector
1365   0741             fs_chmod_not_found:
1366   0741 06            sysret
1367   0742             
1368   0742             ;------------------------------------------------------------------------------------------------------;
1369   0742             ; create new directory
1370   0742             ;------------------------------------------------------------------------------------------------------;
1371   0742             ; search list for null name entry. add new directory to list
1372   0742             fs_mkdir:
1373   0742 FD 4E         mov si, d
1374   0744 FD 4F 2C 1D   mov di, user_data
1375   0748 38 00 02      mov c, 512
1376   074B 04            load                        ; load data from user-space
1377   074C 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1378   074F                                           ; when checking for null name, since root has a null name)
1379   074F 38 00 00      mov c, 0                    ; upper lba = 0
1380   0752             fs_mkdir_l1:  
1381   0752 22 01         mov ah, $01                  ; 1 sector
1382   0754 3B 2C 25      mov d, transient_area
1383   0757 07 73 05      call ide_read_sect          ; read sector
1384   075A BD 00         cmp byte[d], 0              ; check for null
1385   075C C6 65 07      je fs_mkdir_found_null
1386   075F 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1387   0762 0A 52 07      jmp fs_mkdir_l1
1388   0765             fs_mkdir_found_null:
1389   0765             ;create header file by grabbing dir name from parameter
1390   0765 D8            push b                      ; save new directory's lba
1391   0766 38 40 00      mov c, 64
1392   0769 FD 4D 2C 1D   mov si, user_data
1393   076D FD 4F 2C 25   mov di, transient_area
1394   0771 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1395   0773 14 CF 17      mov a, [current_dir_id]
1396   0776 42 6C 25      mov [transient_area + 64], a    ; store parent directory lba
1397   0779 19 00         mov al, 0
1398   077B FD 4F 2C 27   mov di, transient_area + 512
1399   077F 38 00 02      mov c, 512
1400   0782 FD F7         rep stosb                       ; clean buffer
1401   0784 38 00 00      mov c, 0                        ; reset lba(c) to 0
1402   0787             ; write directory entry sectors
1403   0787 3B 2C 25      mov d, transient_area
1404   078A 22 02         mov ah, $02                     ; disk write, 2 sectors
1405   078C 07 99 05      call ide_write_sect             ; write sector
1406   078F             ; now we need to add the new directory to the list, inside the current directory
1407   078F 14 CF 17      mov a, [current_dir_id]
1408   0792 53 01 00      add a, 1
1409   0795 27            mov b, a                        ; metadata sector
1410   0796 38 00 00      mov c, 0
1411   0799 FD 79         mov g, b                        ; save lba
1412   079B 3B 2C 25      mov d, transient_area
1413   079E 22 01         mov ah, $01                  ; 1 sector
1414   07A0 07 73 05      call ide_read_sect              ; read metadata sector
1415   07A3             fs_mkdir_l2:
1416   07A3 BD 00         cmp byte[d], 0
1417   07A5 C6 AE 07      je fs_mkdir_found_null2
1418   07A8 58 20 00      add d, fst_entry_size
1419   07AB 0A A3 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1420   07AE             fs_mkdir_found_null2:
1421   07AE FD 4D 2C 1D   mov si, user_data
1422   07B2 FD 50         mov di, d
1423   07B4 07 ED 10      call _strcpy                    ; copy directory name
1424   07B7 58 18 00      add d, 24                       ; goto attributes
1425   07BA 19 0B         mov al, %00001011               ; directory, no execute, write, read
1426   07BC 3E            mov [d], al      
1427   07BD 79            inc d
1428   07BE E5            pop b
1429   07BF D8            push b                          ; push lba back
1430   07C0 FD 43         mov [d], b                      ; save lba
1431   07C2             ; set file creation date  
1432   07C2 58 04 00      add d, 4
1433   07C5 19 04         mov al, 4
1434   07C7 05 01         syscall sys_rtc
1435   07C9 1A            mov al, ah
1436   07CA 3E            mov [d], al                     ; set day
1437   07CB 79            inc d
1438   07CC 19 05         mov al, 5
1439   07CE 05 01         syscall sys_rtc
1440   07D0 1A            mov al, ah
1441   07D1 3E            mov [d], al                     ; set month
1442   07D2 79            inc d
1443   07D3 19 06         mov al, 6
1444   07D5 05 01         syscall sys_rtc
1445   07D7 1A            mov al, ah
1446   07D8 3E            mov [d], al                     ; set year
1447   07D9             ; write sector into disk for new directory entry
1448   07D9 FD 27         mov b, g
1449   07DB 38 00 00      mov c, 0
1450   07DE 3B 2C 25      mov d, transient_area
1451   07E1 22 01         mov ah, $01                     ; disk write, 1 sector
1452   07E3 07 99 05      call ide_write_sect             ; write sector
1453   07E6             
1454   07E6             ; after adding the new directory's information to its parent directory's list
1455   07E6             ; we need to now enter the new directory, and to it add two new directories!
1456   07E6             ; which directories do we need to add ? '..' and '.' are the directories needed.
1457   07E6             ; importantly, note that these two new directories are only entries in the list
1458   07E6             ; and do not have actual physical entries in the disk as real directories.
1459   07E6             ; i.e. they only exist as list entries in the new directory created so that
1460   07E6             ; the new directory can reference its parent and itself.
1461   07E6             ; we need to add both '..' and '.'
1462   07E6             ; this first section is for '..' and on the section below we do the same for '.'
1463   07E6 E4            pop a                         ; retrieve the new directory's lba  
1464   07E7 D7            push a                        ; and save again
1465   07E8 53 01 00      add a, 1
1466   07EB 27            mov b, a                      ; metadata sector
1467   07EC 38 00 00      mov c, 0
1468   07EF FD 79         mov g, b                      ; save lba
1469   07F1 3B 2C 25      mov d, transient_area
1470   07F4 22 01         mov ah, $01                  ; 1 sector
1471   07F6 07 73 05      call ide_read_sect            ; read metadata sector
1472   07F9             fs_mkdir_l3:
1473   07F9 BD 00         cmp byte[d], 0
1474   07FB C6 04 08      je fs_mkdir_found_null3
1475   07FE 58 20 00      add d, fst_entry_size
1476   0801 0A F9 07      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1477   0804             fs_mkdir_found_null3:
1478   0804 FD 4D EE 17   mov si, s_parent_dir
1479   0808 FD 50         mov di, d
1480   080A 07 ED 10      call _strcpy                  ; copy directory name
1481   080D 58 18 00      add d, 24                     ; goto attributes
1482   0810 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1483   0812 3E            mov [d], al      
1484   0813 79            inc d
1485   0814 29 CF 17      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1486   0817 FD 43         mov [d], b                    ; save lba
1487   0819             ; set file creation date  
1488   0819 58 04 00      add d, 4
1489   081C 19 04         mov al, 4
1490   081E 05 01         syscall sys_rtc
1491   0820 1A            mov al, ah
1492   0821 3E            mov [d], al                   ; set day
1493   0822 79            inc d
1494   0823 19 05         mov al, 5
1495   0825 05 01         syscall sys_rtc
1496   0827 1A            mov al, ah
1497   0828 3E            mov [d], al                   ; set month
1498   0829 79            inc d
1499   082A 19 06         mov al, 6
1500   082C 05 01         syscall sys_rtc
1501   082E 1A            mov al, ah
1502   082F 3E            mov [d], al                   ; set year
1503   0830             ; write sector into disk for new directory entry
1504   0830 FD 27         mov b, g
1505   0832 38 00 00      mov c, 0
1506   0835 3B 2C 25      mov d, transient_area
1507   0838 22 01         mov ah, $01                   ; disk write, 1 sector
1508   083A 07 99 05      call ide_write_sect           ; write sector
1509   083D             ;;;;;;;;;;;;;
1510   083D             ; like we did above for '..', we need to now add the '.' directory to the list.
1511   083D             ;------------------------------------------------------------------------------------------------------;
1512   083D E4            pop a                         ; retrieve the new directory's lba  
1513   083E D7            push a
1514   083F 53 01 00      add a, 1
1515   0842 27            mov b, a                      ; metadata sector
1516   0843 38 00 00      mov c, 0
1517   0846 FD 79         mov g, b                      ; save lba
1518   0848 3B 2C 25      mov d, transient_area
1519   084B 22 01         mov ah, $01                  ; 1 sector
1520   084D 07 73 05      call ide_read_sect            ; read metadata sector
1521   0850             fs_mkdir_l4:
1522   0850 BD 00         cmp byte[d], 0
1523   0852 C6 5B 08      je fs_mkdir_found_null4
1524   0855 58 20 00      add d, fst_entry_size
1525   0858 0A 50 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1526   085B             fs_mkdir_found_null4:
1527   085B FD 4D F1 17   mov si, s_current_dir
1528   085F FD 50         mov di, d
1529   0861 07 ED 10      call _strcpy                  ; copy directory name
1530   0864 58 18 00      add d, 24                     ; goto attributes
1531   0867 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1532   0869 3E            mov [d], al      
1533   086A 79            inc d
1534   086B E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1535   086C FD 43         mov [d], b                    ; save lba
1536   086E             ; set file creation date  
1537   086E 58 04 00      add d, 4
1538   0871 19 04         mov al, 4
1539   0873 05 01         syscall sys_rtc
1540   0875 1A            mov al, ah
1541   0876 3E            mov [d], al                   ; set day
1542   0877 79            inc d
1543   0878 19 05         mov al, 5
1544   087A 05 01         syscall sys_rtc
1545   087C 1A            mov al, ah
1546   087D 3E            mov [d], al                   ; set month
1547   087E 79            inc d
1548   087F 19 06         mov al, 6
1549   0881 05 01         syscall sys_rtc
1550   0883 1A            mov al, ah
1551   0884 3E            mov [d], al                   ; set year
1552   0885             ; write sector into disk for new directory entry
1553   0885 FD 27         mov b, g
1554   0887 38 00 00      mov c, 0
1555   088A 3B 2C 25      mov d, transient_area
1556   088D 22 01         mov ah, $01                   ; disk write, 1 sector
1557   088F 07 99 05      call ide_write_sect           ; write sector
1558   0892             fs_mkdir_end:
1559   0892 06            sysret
1560   0893             
1561   0893             ;------------------------------------------------------------------------------------------------------;
1562   0893             ; get path from a given directory dirid
1563   0893             ; pseudo code:
1564   0893             ;  fs_dir_id_to_path(int dirid, char *d){
1565   0893             ;    if(dirid == 0){
1566   0893             ;      reverse path in d;
1567   0893             ;      return;
1568   0893             ;    }
1569   0893             ;    else{
1570   0893             ;      copy directory name to end of d;
1571   0893             ;      add '/' to end of d;
1572   0893             ;      parentid = get parent directory id;
1573   0893             ;      fs_dir_id_to_path(parentid, d);
1574   0893             ;    }
1575   0893             ;  }
1576   0893             ; a = dirid
1577   0893             ; d = generated path string pointer
1578   0893             ;------------------------------------------------------------------------------------------------------;
1579   0893             ; sample path: /usr/bin
1580   0893             fs_dir_id_to_path:
1581   0893 3B AC 1C      mov d, filename
1582   0896 19 00         mov al, 0
1583   0898 3E            mov [d], al                     ; initialize path string 
1584   0899 14 CF 17      mov a, [current_dir_id]
1585   089C 07 A9 08      call fs_dir_id_to_path_e0
1586   089F 3B AC 1C      mov d, filename
1587   08A2 07 81 10      call _strrev
1588   08A5 07 95 12      call _puts
1589   08A8 06            sysret
1590   08A9             fs_dir_id_to_path_e0:
1591   08A9 07 C8 08      call get_dirname_from_dirid
1592   08AC FD 4D F3 17   mov si, s_fslash
1593   08B0 FD 50         mov di, d
1594   08B2 07 FB 10      call _strcat                    ; add '/' to end of path
1595   08B5 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1596   08B8 C6 C7 08      je fs_dir_id_to_path_root
1597   08BB 07 E5 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1598   08BE AF 20 00      cmp a, root_id               ; check if we are at the root directory
1599   08C1 C6 C7 08      je fs_dir_id_to_path_root
1600   08C4 07 A9 08      call fs_dir_id_to_path_e0     ; recursively call itself
1601   08C7             fs_dir_id_to_path_root:
1602   08C7 09            ret
1603   08C8             
1604   08C8             ;------------------------------------------------------------------------------------------------------;
1605   08C8             ; in_puts:
1606   08C8             ; a = directory id
1607   08C8             ; out_puts:
1608   08C8             ; d = pointer to directory name string
1609   08C8             ;------------------------------------------------------------------------------------------------------;
1610   08C8             get_dirname_from_dirid:
1611   08C8 D7            push a
1612   08C9 D8            push b
1613   08CA DA            push d
1614   08CB 27            mov b, a
1615   08CC 38 00 00      mov c, 0                      ; upper lba = 0
1616   08CF 22 01         mov ah, $01                  ; 1 sector
1617   08D1 3B 2C 23      mov d, transient_area - 512
1618   08D4 07 73 05      call ide_read_sect            ; read directory
1619   08D7 07 81 10      call _strrev                  ; reverse dir name before copying
1620   08DA FD 4E         mov si, d
1621   08DC E7            pop d                         ; destination address = d value pushed at beginning
1622   08DD FD 50         mov di, d
1623   08DF 07 FB 10      call _strcat                  ; copy filename to d
1624   08E2 E5            pop b
1625   08E3 E4            pop a
1626   08E4 09            ret
1627   08E5             
1628   08E5             ;------------------------------------------------------------------------------------------------------;
1629   08E5             ; in_puts:
1630   08E5             ; a = directory id
1631   08E5             ; out_puts:
1632   08E5             ; a = parent directory id
1633   08E5             ;------------------------------------------------------------------------------------------------------;
1634   08E5             get_parentid_from_dirid:
1635   08E5 D8            push b
1636   08E6 DA            push d
1637   08E7 27            mov b, a
1638   08E8 38 00 00      mov c, 0                      ; upper lba = 0
1639   08EB 22 01         mov ah, $01                  ; 1 sector
1640   08ED 3B 2C 23      mov d, transient_area - 512
1641   08F0 07 73 05      call ide_read_sect            ; read directory
1642   08F3 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1643   08F6 E7            pop d
1644   08F7 E5            pop b
1645   08F8 09            ret
1646   08F9             
1647   08F9             ;------------------------------------------------------------------------------------------------------;
1648   08F9             ; get dirid from a given path string
1649   08F9             ; in_puts:
1650   08F9             ; d = path pointer 
1651   08F9             ; out_puts:
1652   08F9             ; a = dirid
1653   08F9             ; if dir non existent, a = ffff (fail code)
1654   08F9             ; /usr/local/bin    - absolute
1655   08F9             ; local/bin/games    - relative
1656   08F9             ;------------------------------------------------------------------------------------------------------;
1657   08F9             fs_path_to_dir_id_user:
1658   08F9 FD 4E         mov si, d
1659   08FB FD 4F 2C 1D   mov di, user_data
1660   08FF 38 00 02      mov c, 512
1661   0902 04            load
1662   0903 07 07 09      call get_dirid_from_path
1663   0906 06            sysret
1664   0907             get_dirid_from_path:
1665   0907 26 2C 1D      mov b, user_data
1666   090A FD 42 BA 16   mov [prog], b                  ; token pointer set to path string
1667   090E 07 1B 15      call get_token
1668   0911 31 BD 16      mov bl, [tok]
1669   0914 C1 01         cmp bl, tok_fslash
1670   0916 C6 22 09      je get_dirid_from_path_abs 
1671   0919 14 CF 17      mov a, [current_dir_id]
1672   091C 07 A1 16      call _putback
1673   091F 0A 25 09      jmp get_dirid_from_path_e0
1674   0922             get_dirid_from_path_abs:
1675   0922 10 20 00      mov a, root_id
1676   0925             get_dirid_from_path_e0:
1677   0925 07 1B 15      call get_token
1678   0928 31 BC 16      mov bl, [toktyp]
1679   092B C1 00         cmp bl, toktyp_identifier
1680   092D C7 7E 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1681   0930             
1682   0930 FD 4D BE 16   mov si, tokstr
1683   0934 FD 4F AC 1C   mov di, filename
1684   0938 07 ED 10      call _strcpy        
1685   093B 77            inc a                         ; metadata sector
1686   093C 27            mov b, a
1687   093D 38 00 00      mov c, 0                      ; upper lba = 0
1688   0940 22 01         mov ah, $01                  ; 1 sector
1689   0942 3B 2C 25      mov d, transient_area
1690   0945 07 73 05      call ide_read_sect            ; read directory
1691   0948 FD 10         cla
1692   094A 42 C7 17      mov [index], a
1693   094D             get_dirid_from_path_l1:
1694   094D FD 4E         mov si, d
1695   094F FD 4F AC 1C   mov di, filename
1696   0953 07 D8 10      call _strcmp
1697   0956 C6 6C 09      je get_dirid_from_path_name_equal  
1698   0959 58 20 00      add d, 32
1699   095C 14 C7 17      mov a, [index]
1700   095F 77            inc a
1701   0960 42 C7 17      mov [index], a
1702   0963 AF 10 00      cmp a, fst_files_per_dir
1703   0966 C6 7F 09      je get_dirid_from_path_fail
1704   0969 0A 4D 09      jmp get_dirid_from_path_l1
1705   096C             get_dirid_from_path_name_equal:
1706   096C 58 19 00      add d, 25           
1707   096F 15            mov a, [d]                    ; set result register a = dirid
1708   0970 07 1B 15      call get_token
1709   0973 31 BD 16      mov bl, [tok]
1710   0976 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1711   0978 C6 25 09      je get_dirid_from_path_e0
1712   097B 07 A1 16      call _putback
1713   097E             get_dirid_from_path_end:
1714   097E 09            ret
1715   097F             get_dirid_from_path_fail:
1716   097F 10 FF FF      mov a, $ffff
1717   0982 09            ret
1718   0983             
1719   0983             
1720   0983             ;------------------------------------------------------------------------------------------------------;
1721   0983             ; check if file exists by a given path string
1722   0983             ; in_puts:
1723   0983             ; d = path pointer 
1724   0983             ; outputs:
1725   0983             ; a = success code, if file exists gives lba, else, give 0
1726   0983             ; /usr/local/bin/ed
1727   0983             ;------------------------------------------------------------------------------------------------------;
1728   0983             fs_filepath_exists_user:
1729   0983 FD 4E         mov si, d
1730   0985 FD 4F 2C 1D   mov di, user_data
1731   0989 38 00 02      mov c, 512
1732   098C 04            load
1733   098D 07 91 09      call file_exists_by_path
1734   0990 06            sysret
1735   0991             file_exists_by_path:
1736   0991 26 2C 1D      mov b, user_data
1737   0994 FD 42 BA 16   mov [prog], b                   ; token pointer set to path string
1738   0998 07 1B 15      call get_token
1739   099B 31 BD 16      mov bl, [tok]
1740   099E C1 01         cmp bl, tok_fslash
1741   09A0 C6 AC 09      je  file_exists_by_path_abs
1742   09A3 14 CF 17      mov a, [current_dir_id]
1743   09A6 07 A1 16      call _putback
1744   09A9 0A AF 09      jmp file_exists_by_path_e0
1745   09AC             file_exists_by_path_abs:
1746   09AC 10 20 00      mov a, root_id
1747   09AF             file_exists_by_path_e0:
1748   09AF 07 1B 15      call get_token
1749   09B2 31 BC 16      mov bl, [toktyp]
1750   09B5 C1 00         cmp bl, toktyp_identifier
1751   09B7 C7 0F 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1752   09BA FD 4D BE 16   mov si, tokstr
1753   09BE FD 4F AC 1C   mov di, filename
1754   09C2 07 ED 10      call _strcpy        
1755   09C5 77            inc a                           ; metadata sector
1756   09C6 27            mov b, a
1757   09C7 38 00 00      mov c, 0                        ; upper lba = 0
1758   09CA 22 01         mov ah, $01                  ; 1 sector
1759   09CC 3B 2C 25      mov d, transient_area
1760   09CF 07 73 05      call ide_read_sect              ; read directory
1761   09D2 FD 10         cla
1762   09D4 42 C7 17      mov [index], a
1763   09D7             file_exists_by_path_l1:
1764   09D7 FD 4E         mov si, d
1765   09D9 FD 4F AC 1C   mov di, filename
1766   09DD 07 D8 10      call _strcmp
1767   09E0 C6 F6 09      je   file_exists_by_path_name_equal
1768   09E3 58 20 00      add d, 32
1769   09E6 14 C7 17      mov a, [index]
1770   09E9 77            inc a
1771   09EA 42 C7 17      mov [index], a
1772   09ED AF 10 00      cmp a, fst_files_per_dir
1773   09F0 C6 0F 0A      je file_exists_by_path_end
1774   09F3 0A D7 09      jmp file_exists_by_path_l1
1775   09F6             file_exists_by_path_name_equal:
1776   09F6 33 18 00      mov bl, [d + 24]
1777   09F9 FD 87 38      and bl, %00111000               ; directory flag
1778   09FC C1 08         cmp bl, %00001000               ; is dir?
1779   09FE C6 05 0A      je file_exists_by_path_isdir;
1780   0A01             ; entry is a file
1781   0A01 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1782   0A04 09            ret
1783   0A05             file_exists_by_path_isdir:
1784   0A05 58 19 00      add d, 25           
1785   0A08 15            mov a, [d]                      ; set result register a = dirid
1786   0A09 07 1B 15      call get_token
1787   0A0C 0A AF 09      jmp file_exists_by_path_e0
1788   0A0F             file_exists_by_path_end:
1789   0A0F 10 00 00      mov a, 0                        ; return 0 because file was not found
1790   0A12 09            ret
1791   0A13             
1792   0A13             ;------------------------------------------------------------------------------------------------------;
1793   0A13             ; load file data from a given path string
1794   0A13             ; inputs:
1795   0A13             ; d = path pointer 
1796   0A13             ; di = userspace program data destination
1797   0A13             ; /usr/local/bin/ed
1798   0A13             ; ./ed
1799   0A13             ;------------------------------------------------------------------------------------------------------;
1800   0A13             fs_load_from_path_user:
1801   0A13 E3            push di
1802   0A14 FD 4E         mov si, d
1803   0A16 FD 4F 2C 1D   mov di, user_data
1804   0A1A 38 00 02      mov c, 512
1805   0A1D 04            load
1806   0A1E 07 2B 0A      call loadfile_from_path
1807   0A21 F0            pop di
1808   0A22 FD 4D 2C 25   mov si, transient_area
1809   0A26 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1810   0A29 03            store
1811   0A2A 06            sysret
1812   0A2B             loadfile_from_path:
1813   0A2B 26 2C 1D      mov b, user_data
1814   0A2E FD 42 BA 16   mov [prog], b                 ; token pointer set to path string
1815   0A32 07 1B 15      call get_token
1816   0A35 31 BD 16      mov bl, [tok]
1817   0A38 C1 01         cmp bl, tok_fslash
1818   0A3A C6 46 0A      je loadfile_from_path_abs 
1819   0A3D 14 CF 17      mov a, [current_dir_id]
1820   0A40 07 A1 16      call _putback
1821   0A43 0A 49 0A      jmp loadfile_from_path_e0
1822   0A46             loadfile_from_path_abs:
1823   0A46 10 20 00      mov a, root_id
1824   0A49             loadfile_from_path_e0:
1825   0A49 07 1B 15      call get_token
1826   0A4C 31 BC 16      mov bl, [toktyp]
1827   0A4F C1 00         cmp bl, toktyp_identifier
1828   0A51 C7 B6 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1829   0A54 FD 4D BE 16   mov si, tokstr
1830   0A58 FD 4F AC 1C   mov di, filename
1831   0A5C 07 ED 10      call _strcpy        
1832   0A5F 77            inc a                         ; metadata sector
1833   0A60 27            mov b, a
1834   0A61 38 00 00      mov c, 0                      ; upper lba = 0
1835   0A64 22 01         mov ah, $01                  ; 1 sector
1836   0A66 3B 2C 25      mov d, transient_area
1837   0A69 07 73 05      call ide_read_sect            ; read directory
1838   0A6C FD 10         cla
1839   0A6E 42 C7 17      mov [index], a
1840   0A71             loadfile_from_path_l1:
1841   0A71 FD 4E         mov si, d
1842   0A73 FD 4F AC 1C   mov di, filename
1843   0A77 07 D8 10      call _strcmp
1844   0A7A C6 90 0A      je loadfile_from_path_name_equal  
1845   0A7D 58 20 00      add d, 32
1846   0A80 14 C7 17      mov a, [index]
1847   0A83 77            inc a
1848   0A84 42 C7 17      mov [index], a
1849   0A87 AF 10 00      cmp a, fst_files_per_dir
1850   0A8A C6 B6 0A      je loadfile_from_path_end
1851   0A8D 0A 71 0A      jmp loadfile_from_path_l1
1852   0A90             loadfile_from_path_name_equal:
1853   0A90 33 18 00      mov bl, [d + 24]
1854   0A93 FD 87 38      and bl, %00111000             ; directory flag
1855   0A96 C1 08         cmp bl, %00001000             ; is dir?
1856   0A98 C6 AC 0A      je loadfile_isdirectory  
1857   0A9B             ; entry is a file
1858   0A9B 2B 19 00      mov b, [d + 25]               ; get lba
1859   0A9E FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1860   0AA0 3B 2C 25      mov d, transient_area
1861   0AA3 38 00 00      mov c, 0
1862   0AA6 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1863   0AA8 07 73 05      call ide_read_sect            ; read sector
1864   0AAB 09            ret
1865   0AAC             loadfile_isdirectory:
1866   0AAC 58 19 00      add d, 25           
1867   0AAF 15            mov a, [d]                    ; set result register a = dirid
1868   0AB0 07 1B 15      call get_token
1869   0AB3 0A 49 0A      jmp loadfile_from_path_e0
1870   0AB6             loadfile_from_path_end:
1871   0AB6 09            ret
1872   0AB7             
1873   0AB7             ;------------------------------------------------------------------------------------------------------;
1874   0AB7             ; return the id of the current directory
1875   0AB7             ; id returned in b
1876   0AB7             ;------------------------------------------------------------------------------------------------------;
1877   0AB7             fs_get_curr_dirid:
1878   0AB7 29 CF 17      mov b, [current_dir_id]
1879   0ABA 06            sysret
1880   0ABB             
1881   0ABB             ;------------------------------------------------------------------------------------------------------;
1882   0ABB             ; cd
1883   0ABB             ;------------------------------------------------------------------------------------------------------;
1884   0ABB             ; new dirid in b
1885   0ABB             fs_cd:
1886   0ABB FD 42 CF 17   mov [current_dir_id], b
1887   0ABF 06            sysret  
1888   0AC0             
1889   0AC0             ;------------------------------------------------------------------------------------------------------;
1890   0AC0             ; ls
1891   0AC0             ; dirid in b
1892   0AC0             ;------------------------------------------------------------------------------------------------------;
1893   0AC0 00 00       ls_count:       .dw 0
1894   0AC2             fs_ls:
1895   0AC2 FD 77         inc b                        ; metadata sector
1896   0AC4 38 00 00      mov c, 0                     ; upper lba = 0
1897   0AC7 22 01         mov ah, $01                  ; 1 sector
1898   0AC9 3B 2C 25      mov d, transient_area
1899   0ACC 07 73 05      call ide_read_sect           ; read directory
1900   0ACF FD 10         cla
1901   0AD1 42 C7 17      mov [index], a               ; reset entry index
1902   0AD4 3D C0 0A      mov [ls_count], al           ; reset item count
1903   0AD7             fs_ls_l1:
1904   0AD7 BD 00         cmp byte [d], 0              ; check for null
1905   0AD9 C6 70 0B      je fs_ls_next
1906   0ADC             fs_ls_non_null:
1907   0ADC 1D C0 0A      mov al, [ls_count]
1908   0ADF 7A            inc al
1909   0AE0 3D C0 0A      mov [ls_count], al           ; increment item count
1910   0AE3 1F 18 00      mov al, [d + 24]
1911   0AE6 87 38         and al, %00111000
1912   0AE8 FD A2 03      shr al, 3
1913   0AEB 22 00         mov ah, 0                    ; file type
1914   0AED B7 FA 17      mov a, [a + file_type]      
1915   0AF0 23            mov ah, al
1916   0AF1 07 69 11      call _putchar
1917   0AF4 1F 18 00      mov al, [d + 24]
1918   0AF7 87 01         and al, %00000001
1919   0AF9 22 00         mov ah, 0
1920   0AFB B7 F5 17      mov a, [a + file_attrib]     ; read
1921   0AFE 23            mov ah, al
1922   0AFF 07 69 11      call _putchar
1923   0B02 1F 18 00      mov al, [d + 24]
1924   0B05 87 02         and al, %00000010
1925   0B07 22 00         mov ah, 0
1926   0B09 B7 F5 17      mov a, [a + file_attrib]     ; write
1927   0B0C 23            mov ah, al
1928   0B0D 07 69 11      call _putchar
1929   0B10 1F 18 00      mov al, [d + 24]
1930   0B13 87 04         and al, %00000100
1931   0B15 22 00         mov ah, 0
1932   0B17 B7 F5 17      mov a, [a + file_attrib]     ; execute
1933   0B1A 23            mov ah, al
1934   0B1B 07 69 11      call _putchar
1935   0B1E 22 20         mov ah, $20
1936   0B20 07 69 11      call _putchar  
1937   0B23 2B 1B 00      mov b, [d + 27]
1938   0B26 07 F1 12      call print_u16x              ; filesize
1939   0B29 22 20         mov ah, $20
1940   0B2B 07 69 11      call _putchar  
1941   0B2E 2B 19 00      mov b, [d + 25]
1942   0B31 07 F1 12      call print_u16x              ; dirid / lba
1943   0B34 22 20         mov ah, $20
1944   0B36 07 69 11      call _putchar
1945   0B39             ; print date
1946   0B39 33 1D 00      mov bl, [d + 29]             ; day
1947   0B3C 07 35 13      call print_u8x
1948   0B3F 22 20         mov ah, $20
1949   0B41 07 69 11      call _putchar  
1950   0B44 1F 1E 00      mov al, [d + 30]             ; month
1951   0B47 FD 9E 02      shl al, 2
1952   0B4A DA            push d
1953   0B4B 3B B9 18      mov d, s_months
1954   0B4E 22 00         mov ah, 0
1955   0B50 59            add d, a
1956   0B51 07 95 12      call _puts
1957   0B54 E7            pop d
1958   0B55 22 20         mov ah, $20
1959   0B57 07 69 11      call _putchar
1960   0B5A 2E 20         mov bl, $20
1961   0B5C 07 35 13      call print_u8x
1962   0B5F 33 1F 00      mov bl, [d + 31]             ; year
1963   0B62 07 35 13      call print_u8x  
1964   0B65 22 20         mov ah, $20
1965   0B67 07 69 11      call _putchar  
1966   0B6A 07 95 12      call _puts                   ; print filename  
1967   0B6D 07 42 12      call printnl
1968   0B70             fs_ls_next:
1969   0B70 14 C7 17      mov a, [index]
1970   0B73 77            inc a
1971   0B74 42 C7 17      mov [index], a
1972   0B77 AF 10 00      cmp a, fst_files_per_dir
1973   0B7A C6 83 0B      je fs_ls_end
1974   0B7D 58 20 00      add d, 32      
1975   0B80 0A D7 0A      jmp fs_ls_l1  
1976   0B83             fs_ls_end:
1977   0B83 3B 0A 18      mov d, s_ls_total
1978   0B86 07 95 12      call _puts
1979   0B89 1D C0 0A      mov al, [ls_count]
1980   0B8C 07 47 13      call print_u8d
1981   0B8F 07 42 12      call printnl
1982   0B92 06            sysret
1983   0B93             
1984   0B93             ;------------------------------------------------------------------------------------------------------;
1985   0B93             ; finds an empty data block
1986   0B93             ; block lba returned in b
1987   0B93             ;------------------------------------------------------------------------------------------------------;
1988   0B93             fs_find_empty_block:
1989   0B93 26 A0 00      mov b, fs_lba_start     ; raw files starting block
1990   0B96 38 00 00      mov c, 0                ; upper lba = 0
1991   0B99             fs_find_empty_block_l1:  
1992   0B99 22 01         mov ah, $01                  ; 1 sector
1993   0B9B 3B 2C 23      mov d, transient_area - 512
1994   0B9E 07 73 05      call ide_read_sect      ; read sector
1995   0BA1 BD 00         cmp byte [d], 0
1996   0BA3 C6 AC 0B      je fs_find_empty_block_found_null
1997   0BA6 55 20 00      add b, fs_sectors_per_file
1998   0BA9 0A 99 0B      jmp fs_find_empty_block_l1
1999   0BAC             fs_find_empty_block_found_null:
2000   0BAC 09            ret
2001   0BAD             
2002   0BAD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2003   0BAD             ;; create new textfile
2004   0BAD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2005   0BAD             ; search for first null block
2006   0BAD             fs_mktxt:
2007   0BAD FD 4E       	mov si, d
2008   0BAF FD 4F 2C 1D 	mov di, user_data
2009   0BB3 38 00 01    	mov c, 256
2010   0BB6 04          	load					; load data from user-space
2011   0BB7             	
2012   0BB7 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2013   0BBA 38 00 00    	mov c, 0						; reset lba to 0
2014   0BBD             fs_mktxt_l1:	
2015   0BBD 10 02 01    	mov a, $0102			; disk read
2016   0BC0 3B 2C 25    	mov d, transient_area
2017   0BC3 05 02       	syscall sys_ide ; read sector
2018   0BC5 1E          	mov al, [d]
2019   0BC6 B9 00       	cmp al, 0			; check for null
2020   0BC8 C6 D1 0B    	je fs_mktxt_found_null
2021   0BCB 55 20 00    	add b, fs_sectors_per_file
2022   0BCE 0A BD 0B    	jmp fs_mktxt_l1
2023   0BD1             fs_mktxt_found_null:
2024   0BD1 D8          	push b				; save lba
2025   0BD2             ;create header file by grabbing file name from parameter	
2026   0BD2 3B EB 17    	mov d, s_dataentry
2027   0BD5 07 95 12    	call _puts
2028   0BD8 3B 2C 27    	mov d, transient_area + 512			; pointer to file contents
2029   0BDB 07 FB 11    	call _gettxt
2030   0BDE 07 C8 10    	call _strlen						; get length of file
2031   0BE1 D9          	push c							; save length
2032   0BE2 19 01       	mov al, 1
2033   0BE4 3D 2C 25    	mov [transient_area], al					; mark sectors as used (not null)
2034   0BE7 10 00 00    	mov a, 0
2035   0BEA 42 C7 17    	mov [index], a
2036   0BED 3B 2C 25    	mov d, transient_area
2037   0BF0 13          	mov a, d
2038   0BF1 42 C9 17    	mov [buffer_addr], a
2039   0BF4             fs_mktxt_l2:
2040   0BF4 38 00 00    	mov c, 0
2041   0BF7 10 03 01    	mov a, $0103			; disk write, 1 sector
2042   0BFA 05 02       	syscall sys_ide		; write sector
2043   0BFC 14 C7 17    	mov a, [index]
2044   0BFF 77          	inc a
2045   0C00 42 C7 17    	mov [index], a
2046   0C03 AF 20 00    	cmp a, fs_sectors_per_file
2047   0C06 C6 18 0C    	je fs_mktxt_add_to_dir
2048   0C09 FD 77       	inc b
2049   0C0B 14 C9 17    	mov a, [buffer_addr]
2050   0C0E 53 00 02    	add a, 512
2051   0C11 42 C9 17    	mov [buffer_addr], a
2052   0C14 3C          	mov d, a
2053   0C15 0A F4 0B    	jmp fs_mktxt_l2
2054   0C18             ; now we add the file to the current directory!
2055   0C18             fs_mktxt_add_to_dir:	
2056   0C18 14 CF 17    	mov a, [current_dir_id]
2057   0C1B 77          	inc a
2058   0C1C 27          	mov b, a					; metadata sector
2059   0C1D 38 00 00    	mov c, 0
2060   0C20 FD 79       	mov g, b					; save lba
2061   0C22 3B 2C 25    	mov d, transient_area
2062   0C25 10 02 01    	mov a, $0102			; disk read
2063   0C28 05 02       	syscall sys_ide		; read metadata sector
2064   0C2A             fs_mktxt_add_to_dir_l2:
2065   0C2A 1E          	mov al, [d]
2066   0C2B B9 00       	cmp al, 0
2067   0C2D C6 36 0C    	je fs_mktxt_add_to_dir_null
2068   0C30 58 20 00    	add d, fst_entry_size
2069   0C33 0A 2A 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2070   0C36             fs_mktxt_add_to_dir_null:
2071   0C36 FD 4D 2C 1D 	mov si, user_data
2072   0C3A FD 50       	mov di, d
2073   0C3C 07 ED 10    	call _strcpy			; copy file name
2074   0C3F 58 18 00    	add d, 24			; skip name
2075   0C42 19 06       	mov al, %00000110		; no execute, write, read, not directory
2076   0C44 3E          	mov [d], al			
2077   0C45 58 03 00    	add d, 3
2078   0C48 E4          	pop a
2079   0C49 43          	mov [d], a
2080   0C4A 63 02 00    	sub d, 2
2081   0C4D E5          	pop b				; get file lba
2082   0C4E FD 43       	mov [d], b			; save lba	
2083   0C50             	
2084   0C50             	; set file creation date	
2085   0C50 58 04 00    	add d, 4
2086   0C53 19 04       	mov al, 4
2087   0C55 05 01       	syscall sys_rtc
2088   0C57 1A          	mov al, ah
2089   0C58 3E          	mov [d], al			; set day
2090   0C59             	
2091   0C59 79          	inc d
2092   0C5A 19 05       	mov al, 5
2093   0C5C 05 01       	syscall sys_rtc
2094   0C5E 1A          	mov al, ah
2095   0C5F 3E          	mov [d], al			; set month
2096   0C60             	
2097   0C60 79          	inc d
2098   0C61 19 06       	mov al, 6
2099   0C63 05 01       	syscall sys_rtc
2100   0C65 1A          	mov al, ah
2101   0C66 3E          	mov [d], al			; set year
2102   0C67             	
2103   0C67             ; write sector into disk for new directory entry
2104   0C67 FD 27       	mov b, g
2105   0C69 38 00 00    	mov c, 0
2106   0C6C 3B 2C 25    	mov d, transient_area
2107   0C6F 10 03 01    	mov a, $0103			; disk write, 1 sector
2108   0C72 05 02       	syscall sys_ide		; write sector
2109   0C74 07 42 12    	call printnl
2110   0C77 06          	sysret
2111   0C78             
2112   0C78             
2113   0C78             
2114   0C78             ;------------------------------------------------------------------------------------------------------;
2115   0C78             ; create new binary file
2116   0C78             ;------------------------------------------------------------------------------------------------------;
2117   0C78             ; search for first null block
2118   0C78             fs_mkbin:
2119   0C78 19 00         mov al, 0
2120   0C7A 3D BF 17      mov [sys_echo_on], al ; disable echo
2121   0C7D FD 4E         mov si, d
2122   0C7F FD 4F 2C 1D   mov di, user_data
2123   0C83 38 00 02      mov c, 512
2124   0C86 04            load                          ; load data from user-space
2125   0C87 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2126   0C8A 38 00 00      mov c, 0                      ; upper lba = 0
2127   0C8D             fs_mkbin_l1:  
2128   0C8D 22 01         mov ah, $01                  ; 1 sector
2129   0C8F 3B 2C 25      mov d, transient_area
2130   0C92 07 73 05      call ide_read_sect            ; read sector
2131   0C95 BD 00         cmp byte[d], 0                ; check for null
2132   0C97 C6 A0 0C      je fs_mkbin_found_null
2133   0C9A 55 20 00      add b, fs_sectors_per_file
2134   0C9D 0A 8D 0C      jmp fs_mkbin_l1
2135   0CA0             fs_mkbin_found_null:
2136   0CA0 D8            push b                        ; save lba
2137   0CA1             ;create header file by grabbing file name from parameter
2138   0CA1 FD 4F 2C 27   mov di, transient_area + 512  ; pointer to file contents
2139   0CA5 07 1B 10      call _load_hex                ; load binary hex
2140   0CA8 D9            push c                        ; save size (nbr of bytes)
2141   0CA9 19 01         mov al, 1
2142   0CAB 3D 2C 25      mov [transient_area], al      ; mark sectors as used (not null)
2143   0CAE FD 10         cla
2144   0CB0 42 C7 17      mov [index], a
2145   0CB3 3B 2C 25      mov d, transient_area
2146   0CB6 13            mov a, d
2147   0CB7 42 C9 17      mov [buffer_addr], a
2148   0CBA             fs_mkbin_l2:
2149   0CBA 38 00 00      mov c, 0
2150   0CBD 22 01         mov ah, $01                   ; disk write, 1 sector
2151   0CBF 07 99 05      call ide_write_sect           ; write sector
2152   0CC2 14 C7 17      mov a, [index]
2153   0CC5 77            inc a
2154   0CC6 42 C7 17      mov [index], a
2155   0CC9 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2156   0CCC C6 DE 0C      je fs_mkbin_add_to_dir
2157   0CCF FD 77         inc b
2158   0CD1 14 C9 17      mov a, [buffer_addr]
2159   0CD4 53 00 02      add a, 512
2160   0CD7 42 C9 17      mov [buffer_addr], a
2161   0CDA 3C            mov d, a
2162   0CDB 0A BA 0C      jmp fs_mkbin_l2
2163   0CDE             ; now we add the file to the current directory!
2164   0CDE             fs_mkbin_add_to_dir:  
2165   0CDE 14 CF 17      mov a, [current_dir_id]
2166   0CE1 77            inc a
2167   0CE2 27            mov b, a                      ; metadata sector
2168   0CE3 38 00 00      mov c, 0
2169   0CE6 FD 79         mov g, b                      ; save lba
2170   0CE8 3B 2C 25      mov d, transient_area
2171   0CEB 22 01         mov ah, $01                  ; 1 sector
2172   0CED 07 73 05      call ide_read_sect            ; read metadata sector
2173   0CF0             fs_mkbin_add_to_dir_l2:
2174   0CF0 BD 00         cmp byte[d], 0
2175   0CF2 C6 FB 0C      je fs_mkbin_add_to_dir_null
2176   0CF5 58 20 00      add d, fst_entry_size
2177   0CF8 0A F0 0C      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2178   0CFB             fs_mkbin_add_to_dir_null:
2179   0CFB FD 4D 2C 1D   mov si, user_data
2180   0CFF FD 50         mov di, d
2181   0D01 07 ED 10      call _strcpy                  ; copy file name
2182   0D04 58 18 00      add d, 24                     ; skip name
2183   0D07 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2184   0D09 3E            mov [d], al
2185   0D0A 58 03 00      add d, 3
2186   0D0D E4            pop a
2187   0D0E 43            mov [d], a
2188   0D0F 63 02 00      sub d, 2
2189   0D12 E5            pop b                         ; get file lba
2190   0D13 FD 43         mov [d], b                    ; save lba
2191   0D15               ; set file creation date  
2192   0D15 58 04 00      add d, 4
2193   0D18 19 04         mov al, 4
2194   0D1A 05 01         syscall sys_rtc
2195   0D1C 1A            mov al, ah
2196   0D1D 3E            mov [d], al                   ; set day
2197   0D1E 79            inc d
2198   0D1F 19 05         mov al, 5
2199   0D21 05 01         syscall sys_rtc
2200   0D23 1A            mov al, ah
2201   0D24 3E            mov [d], al                   ; set month
2202   0D25 79            inc d
2203   0D26 19 06         mov al, 6
2204   0D28 05 01         syscall sys_rtc
2205   0D2A 1A            mov al, ah
2206   0D2B 3E            mov [d], al                   ; set year
2207   0D2C             ; write sector into disk for new directory entry
2208   0D2C FD 27         mov b, g
2209   0D2E 38 00 00      mov c, 0
2210   0D31 3B 2C 25      mov d, transient_area
2211   0D34 22 01         mov ah, $01                   ; disk write, 1 sector
2212   0D36 07 99 05      call ide_write_sect           ; write sector
2213   0D39 19 01         mov al, 1
2214   0D3B 3D BF 17      mov [sys_echo_on], al ; enable echo
2215   0D3E 06            sysret
2216   0D3F             
2217   0D3F             ;------------------------------------------------------------------------------------------------------;
2218   0D3F             ; pwd - print working directory
2219   0D3F             ;------------------------------------------------------------------------------------------------------;    
2220   0D3F             fs_pwd:
2221   0D3F 3B AC 1C      mov d, filename
2222   0D42 19 00         mov al, 0
2223   0D44 3E            mov [d], al                   ; initialize path string 
2224   0D45 14 CF 17      mov a, [current_dir_id]
2225   0D48 07 A9 08      call fs_dir_id_to_path_e0
2226   0D4B 3B AC 1C      mov d, filename
2227   0D4E 07 81 10      call _strrev
2228   0D51 07 95 12      call _puts
2229   0D54 07 42 12      call printnl
2230   0D57 06            sysret
2231   0D58             
2232   0D58             ;------------------------------------------------------------------------------------------------------;
2233   0D58             ; get current directory lba
2234   0D58             ; a: returned lba
2235   0D58             ;------------------------------------------------------------------------------------------------------;
2236   0D58             cmd_get_curr_dir_lba:
2237   0D58 14 CF 17      mov a, [current_dir_id]
2238   0D5B 06            sysret
2239   0D5C             
2240   0D5C             ;------------------------------------------------------------------------------------------------------;
2241   0D5C             ; cat
2242   0D5C             ; userspace destination data pointer in d
2243   0D5C             ; filename starts at d, but is overwritten after the read is made
2244   0D5C             ;------------------------------------------------------------------------------------------------------;:
2245   0D5C             fs_cat:
2246   0D5C DA            push d                              ; save userspace file data destination
2247   0D5D FD 4E         mov si, d
2248   0D5F FD 4F 2C 1D   mov di, user_data
2249   0D63 38 00 02      mov c, 512
2250   0D66 04            load                                ; copy filename from user-space
2251   0D67 29 CF 17      mov b, [current_dir_id]
2252   0D6A FD 77         inc b                               ; metadata sector
2253   0D6C 38 00 00      mov c, 0                            ; upper lba = 0
2254   0D6F 22 01         mov ah, $01                  ; 1 sector
2255   0D71 3B 2C 23      mov d, transient_area-512
2256   0D74 07 73 05      call ide_read_sect                  ; read directory
2257   0D77 FD 10         cla
2258   0D79 42 C7 17      mov [index], a                      ; reset file counter
2259   0D7C             fs_cat_l1:
2260   0D7C FD 4E         mov si, d
2261   0D7E FD 4F 2C 1D   mov di, user_data
2262   0D82 07 D8 10      call _strcmp
2263   0D85 C6 9B 0D      je fs_cat_found_entry
2264   0D88 58 20 00      add d, 32
2265   0D8B 14 C7 17      mov a, [index]
2266   0D8E 77            inc a
2267   0D8F 42 C7 17      mov [index], a
2268   0D92 AF 10 00      cmp a, fst_files_per_dir
2269   0D95 C6 B6 0D      je fs_cat_not_found
2270   0D98 0A 7C 0D      jmp fs_cat_l1
2271   0D9B             fs_cat_found_entry:
2272   0D9B 58 19 00      add d, 25                           ; get to dirid of file in disk
2273   0D9E 2A            mov b, [d]                          ; get lba
2274   0D9F FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2275   0DA1 3B 2C 25      mov d, transient_area  
2276   0DA4 38 00 00      mov c, 0
2277   0DA7 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2278   0DA9 07 73 05      call ide_read_sect                  ; read sectors
2279   0DAC F0            pop di                              ; write userspace file data destination to di
2280   0DAD FD 4D 2C 25   mov si, transient_area              ; data origin
2281   0DB1 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2282   0DB4 03            store
2283   0DB5 06            sysret
2284   0DB6             fs_cat_not_found:
2285   0DB6 E7            pop d
2286   0DB7 06            sysret
2287   0DB8             
2288   0DB8             ;------------------------------------------------------------------------------------------------------;
2289   0DB8             ; rmdir - remove dir by dirid
2290   0DB8             ;------------------------------------------------------------------------------------------------------;
2291   0DB8             ; deletes a directory entry in the given directory's file list 
2292   0DB8             ; also deletes the actual directory entry in the fst
2293   0DB8             ; synopsis: rmdir /usr/local/testdir
2294   0DB8             ; b = dirid
2295   0DB8             fs_rmdir:
2296   0DB8 FD 79         mov g, b
2297   0DBA 11            mov a, b
2298   0DBB 07 E5 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2299   0DBE D7            push a                        ; save dirid
2300   0DBF             ; search for directory's entry in the parent's directory then and delete it
2301   0DBF 77            inc a                         ; metadata sector
2302   0DC0 27            mov b, a
2303   0DC1 38 00 00      mov c, 0                      ; upper lba = 0
2304   0DC4 22 01         mov ah, $01          ;
2305   0DC6 3B 2C 25      mov d, transient_area
2306   0DC9 07 73 05      call ide_read_sect            ; read directory
2307   0DCC FD 10         cla
2308   0DCE 42 C7 17      mov [index], a                ; reset file counter
2309   0DD1 FD 27         mov b, g                      ; retrieve directory's dirid
2310   0DD3             fs_rmdir_l1:
2311   0DD3 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2312   0DD6 B0            cmp a, b                      ; compare dirid's to find the directory
2313   0DD7 C6 ED 0D      je fs_rmdir_found_entry
2314   0DDA 58 20 00      add d, 32
2315   0DDD 14 C7 17      mov a, [index]
2316   0DE0 77            inc a
2317   0DE1 42 C7 17      mov [index], a
2318   0DE4 AF 10 00      cmp a, fst_files_per_dir
2319   0DE7 C6 12 0E      je fs_rmdir_not_found
2320   0DEA 0A D3 0D      jmp fs_rmdir_l1
2321   0DED             fs_rmdir_found_entry:
2322   0DED FD 10         cla
2323   0DEF 3E            mov [d], al                   ; make filename null
2324   0DF0 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2325   0DF3 E5            pop b
2326   0DF4 FD 77         inc b                         ; metadata sector
2327   0DF6 38 00 00      mov c, 0                      ; upper lba = 0
2328   0DF9 22 01         mov ah, $01          ; 
2329   0DFB 3B 2C 25      mov d, transient_area
2330   0DFE 07 99 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2331   0E01             
2332   0E01 FD 27         mov b, g
2333   0E03 3B 2C 25      mov d, transient_area  
2334   0E06 FD 10         cla
2335   0E08 3E            mov [d], al                   ; make directory's name header null for re-use
2336   0E09 38 00 00      mov c, 0
2337   0E0C 22 01         mov ah, $01                   ; disk write 1 sect
2338   0E0E 07 99 05      call ide_write_sect           ; delete directory given by dirid in b
2339   0E11 06            sysret
2340   0E12             fs_rmdir_not_found:
2341   0E12 E5            pop b
2342   0E13 06            sysret
2343   0E14             
2344   0E14             ;------------------------------------------------------------------------------------------------------;
2345   0E14             ; rm - remove file
2346   0E14             ;------------------------------------------------------------------------------------------------------;
2347   0E14             ; frees up the data sectors for the file further down the disk
2348   0E14             ; deletes file entry in the directory's file list 
2349   0E14             fs_rm:
2350   0E14 FD 4E         mov si, d
2351   0E16 FD 4F 2C 1D   mov di, user_data
2352   0E1A 38 00 02      mov c, 512
2353   0E1D 04            load                          ; load data from user-space
2354   0E1E 14 CF 17      mov a, [current_dir_id]
2355   0E21 77            inc a                         ; metadata sector
2356   0E22 27            mov b, a
2357   0E23 38 00 00      mov c, 0                      ; upper lba = 0
2358   0E26 22 01         mov ah, $01                  ; 1 sector
2359   0E28 3B 2C 25      mov d, transient_area
2360   0E2B 07 73 05      call ide_read_sect            ; read directory
2361   0E2E 10 00 00      mov a, 0
2362   0E31 42 C7 17      mov [index], a                ; reset file counter
2363   0E34             fs_rm_l1:
2364   0E34 FD 4E         mov si, d
2365   0E36 FD 4F 2C 1D   mov di, user_data
2366   0E3A 07 D8 10      call _strcmp
2367   0E3D C6 53 0E      je fs_rm_found_entry
2368   0E40 58 20 00      add d, 32
2369   0E43 14 C7 17      mov a, [index]
2370   0E46 77            inc a
2371   0E47 42 C7 17      mov [index], a
2372   0E4A AF 10 00      cmp a, fst_files_per_dir
2373   0E4D C6 7B 0E      je fs_rm_not_found
2374   0E50 0A 34 0E      jmp fs_rm_l1
2375   0E53             fs_rm_found_entry:
2376   0E53 2B 19 00      mov b, [d + 25]               ; get lba
2377   0E56 FD 79         mov g, b                      ; save lba
2378   0E58 19 00         mov al, 0
2379   0E5A 3E            mov [d], al                   ; make file entry null
2380   0E5B 14 CF 17      mov a, [current_dir_id]
2381   0E5E 77            inc a                         ; metadata sector
2382   0E5F 27            mov b, a
2383   0E60 38 00 00      mov c, 0                      ; upper lba = 0
2384   0E63 22 01         mov ah, $01                   ; disk write
2385   0E65 3B 2C 25      mov d, transient_area
2386   0E68 07 99 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2387   0E6B 3B 2C 25      mov d, transient_area  
2388   0E6E 19 00         mov al, 0
2389   0E70 3E            mov [d], al                   ; make file's data header null for re-use
2390   0E71 38 00 00      mov c, 0
2391   0E74 FD 27         mov b, g                      ; get data header lba
2392   0E76 22 01         mov ah, $01                   ; disk write 1 sect
2393   0E78 07 99 05      call ide_write_sect           ; write sector
2394   0E7B             fs_rm_not_found:  
2395   0E7B 06            sysret  
2396   0E7C             
2397   0E7C             ;------------------------------------------------------------------------------------------------------;
2398   0E7C             ; mv - move / change file name
2399   0E7C             ;------------------------------------------------------------------------------------------------------;
2400   0E7C             fs_mv:
2401   0E7C FD 4E         mov si, d
2402   0E7E FD 4F 2C 1D   mov di, user_data
2403   0E82 38 00 02      mov c, 512
2404   0E85 04            load                          ; load data from user-space
2405   0E86 14 CF 17      mov a, [current_dir_id]
2406   0E89 77            inc a                         ; metadata sector
2407   0E8A 27            mov b, a  
2408   0E8B 38 00 00      mov c, 0                      ; upper lba = 0
2409   0E8E 22 01         mov ah, $01                  ; 1 sector
2410   0E90 3B 2C 25      mov d, transient_area
2411   0E93 07 73 05      call ide_read_sect            ; read directory
2412   0E96 FD 10         cla
2413   0E98 42 C7 17      mov [index], a                ; reset file counter
2414   0E9B             fs_mv_l1:
2415   0E9B FD 4E         mov si, d
2416   0E9D FD 4F 2C 1D   mov di, user_data
2417   0EA1 07 D8 10      call _strcmp
2418   0EA4 C6 BA 0E      je fs_mv_found_entry
2419   0EA7 58 20 00      add d, 32
2420   0EAA 14 C7 17      mov a, [index]
2421   0EAD 77            inc a
2422   0EAE 42 C7 17      mov [index], a
2423   0EB1 AF 10 00      cmp a, fst_files_per_dir
2424   0EB4 C6 EC 0E      je fs_mv_not_found
2425   0EB7 0A 9B 0E      jmp fs_mv_l1
2426   0EBA             fs_mv_found_entry:  
2427   0EBA DA            push d
2428   0EBB FD 4D AC 1D   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2429   0EBF FD 50         mov di, d
2430   0EC1 07 ED 10      call _strcpy  
2431   0EC4 38 00 00      mov c, 0
2432   0EC7 3B 2C 25      mov d, transient_area
2433   0ECA 22 01         mov ah, $01                   ; disk write 1 sect
2434   0ECC 07 99 05      call ide_write_sect           ; write sector
2435   0ECF E7            pop d
2436   0ED0             ;; need to check whether its a dir or a file here ;;;
2437   0ED0 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2438   0ED3 22 01         mov ah, $01
2439   0ED5 3B 2C 25      mov d, transient_area
2440   0ED8 38 00 00      mov c, 0
2441   0EDB 07 73 05      call ide_read_sect            ; read directory entry
2442   0EDE FD 4D AC 1D   mov si, user_data + 128
2443   0EE2 FD 50         mov di, d
2444   0EE4 07 ED 10      call _strcpy                  ; change directory's name
2445   0EE7 22 01         mov ah, $01
2446   0EE9 07 99 05      call ide_write_sect           ; rewrite directory back to disk
2447   0EEC             fs_mv_not_found:
2448   0EEC 06            sysret
2449   0EED             
2450   0EED             
2451   0EED             ;----------------------------------------------------------------------------------------------------;
2452   0EED             ; process index in a
2453   0EED             ;----------------------------------------------------------------------------------------------------;
2454   0EED             find_free_proc:
2455   0EED FD 4D 9D 1A   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2456   0EF1             find_free_proc_l0:
2457   0EF1 F6            lodsb                               ; get process state
2458   0EF2 B9 00         cmp al, 0
2459   0EF4 C6 FA 0E      je find_free_proc_free              ; if free, jump
2460   0EF7 0A F1 0E      jmp find_free_proc_l0               ; else, goto next
2461   0EFA             find_free_proc_free:
2462   0EFA 4E            mov a, si
2463   0EFB 5F 9D 1A      sub a, 1 + proc_availab_table       ; get process index
2464   0EFE 09            ret
2465   0EFF               
2466   0EFF             
2467   0EFF             ;----------------------------------------------------------------------------------------------------;
2468   0EFF             ; process index in al
2469   0EFF             ;----------------------------------------------------------------------------------------------------;
2470   0EFF             proc_memory_map:
2471   0EFF 22 00         mov ah, 0
2472   0F01 27            mov b, a                      ; page in bl, 0 in bh
2473   0F02 FD 9D 05      shl a, 5                      ; multiply by 32
2474   0F05 39            mov c, a                      ; save in c
2475   0F06 57 20 00      add c, 32
2476   0F09             proc_memory_map_l0:
2477   0F09 02            pagemap
2478   0F0A 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2479   0F0D 53 01 00      add a, 1                      ; increase both 
2480   0F10 B1            cmp a, c                      ; check to see if we reached the end of memory
2481   0F11 C7 09 0F      jne proc_memory_map_l0
2482   0F14 09            ret
2483   0F15               
2484   0F15             
2485   0F15             ;----------------------------------------------------------------------------------------------------;
2486   0F15             ; terminate process
2487   0F15             ;----------------------------------------------------------------------------------------------------;
2488   0F15             syscall_terminate_proc:
2489   0F15 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2490   0F18                                                    ; since they will not be used for anything here.
2491   0F18 1D C6 17      mov al, [active_proc_index]
2492   0F1B 22 00         mov ah, 0  
2493   0F1D FD 9D 05      shl a, 5                             ; x32
2494   0F20 53 AC 1A      add a, proc_names
2495   0F23 3C            mov d, a
2496   0F24 19 00         mov al, 0
2497   0F26 3E            mov [d], al                           ; nullify process name
2498   0F27             
2499   0F27 1D C6 17      mov al, [active_proc_index]
2500   0F2A 22 00         mov ah, 0  
2501   0F2C 3C            mov d, a
2502   0F2D 19 00         mov al, 0
2503   0F2F 3F 9C 1A      mov [d + proc_availab_table], al    ; make process empty again
2504   0F32               
2505   0F32 1D C5 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2506   0F35 80            dec al
2507   0F36 3D C5 17      mov [nbr_active_procs], al
2508   0F39             
2509   0F39             ; now load the shell process again
2510   0F39 19 02         mov al, 2                           ; next process = process 2 = shell
2511   0F3B 3D C6 17      mov [active_proc_index], al         ; set next active proc
2512   0F3E             
2513   0F3E             ; calculate lut entry for next process
2514   0F3E 22 00         mov ah, 0
2515   0F40 FD 99         shl a                               ; x2
2516   0F42 B7 0B 10      mov a, [proc_table_convert + a]     ; get process state start index  
2517   0F45               
2518   0F45 4D            mov si, a                           ; source is proc state block
2519   0F46 48            mov a, sp
2520   0F47 5F 13 00      sub a, 19
2521   0F4A 4F            mov di, a                           ; destination is kernel stack
2522   0F4B             ; restore sp
2523   0F4B 7D            dec a
2524   0F4C 47            mov sp, a
2525   0F4D 38 14 00      mov c, 20
2526   0F50 FD F5         rep movsb
2527   0F52             ; set vm process
2528   0F52 1D C6 17      mov al, [active_proc_index]
2529   0F55 01            setptb
2530   0F56                 
2531   0F56 4C            popa
2532   0F57 06            sysret
2533   0F58             
2534   0F58             ;----------------------------------------------------------------------------------------------------;
2535   0F58             ; pause process
2536   0F58             ;----------------------------------------------------------------------------------------------------;
2537   0F58             syscall_pause_proc:
2538   0F58             ; save all registers into kernel stack
2539   0F58 4B            pusha
2540   0F59 22 00         mov ah, 0
2541   0F5B 1D C6 17      mov al, [active_proc_index]
2542   0F5E FD 99         shl a              ; x2
2543   0F60 B7 0B 10      mov a, [proc_table_convert + a]   ; get process state start index
2544   0F63                 
2545   0F63 4F            mov di, a
2546   0F64 48            mov a, sp
2547   0F65 77            inc a
2548   0F66 4D            mov si, a
2549   0F67 38 14 00      mov c, 20
2550   0F6A FD F5         rep movsb                         ; save process state!
2551   0F6C             ; restore kernel stack position to point before interrupt arrived
2552   0F6C 51 14 00      add sp, 20
2553   0F6F             ; now load the shell process again
2554   0F6F 19 02         mov al, 2                         ; next process = process 2 = shell
2555   0F71 3D C6 17      mov [active_proc_index], al       ; set next active proc
2556   0F74             
2557   0F74             ; calculate lut entry for next process
2558   0F74 22 00         mov ah, 0
2559   0F76 FD 99         shl a                             ; x2
2560   0F78 B7 0B 10      mov a, [proc_table_convert + a]   ; get process state start index  
2561   0F7B               
2562   0F7B 4D            mov si, a                         ; source is proc state block
2563   0F7C 48            mov a, sp
2564   0F7D 5F 13 00      sub a, 19
2565   0F80 4F            mov di, a                         ; destination is kernel stack
2566   0F81             ; restore sp
2567   0F81 7D            dec a
2568   0F82 47            mov sp, a
2569   0F83 38 14 00      mov c, 20
2570   0F86 FD F5         rep movsb
2571   0F88             ; set vm process
2572   0F88 1D C6 17      mov al, [active_proc_index]
2573   0F8B 01            setptb
2574   0F8C                 
2575   0F8C 4C            popa
2576   0F8D 06            sysret
2577   0F8E             
2578   0F8E             ;----------------------------------------------------------------------------------------------------;
2579   0F8E             ; create a new process
2580   0F8E             ; d = path of the process file to be createed
2581   0F8E             ; b = arguments ptr
2582   0F8E             ;----------------------------------------------------------------------------------------------------;
2583   0F8E             syscall_create_proc:
2584   0F8E             ; we save the active process first  
2585   0F8E 4B            pusha
2586   0F8F 22 00         mov ah, 0
2587   0F91 1D C6 17      mov al, [active_proc_index]
2588   0F94 FD 99         shl a              ; x2
2589   0F96 B7 0B 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2590   0F99               
2591   0F99 4F            mov di, a
2592   0F9A 48            mov a, sp
2593   0F9B 77            inc a
2594   0F9C 4D            mov si, a
2595   0F9D 38 14 00      mov c, 20
2596   0FA0 FD F5         rep movsb                          ; save process state!
2597   0FA2             ; restore kernel stack position to point before interrupt arrived
2598   0FA2 51 14 00      add sp, 20
2599   0FA5               
2600   0FA5 FD 4E         mov si, d                          ; copy the file path
2601   0FA7 FD 4F 2C 1D   mov di, user_data
2602   0FAB 38 00 02      mov c, 512
2603   0FAE 04            load
2604   0FAF 11            mov a, b
2605   0FB0 4D            mov si, a                          ; copy the arguments
2606   0FB1 FD 4F 2C 23   mov di, scrap_sector
2607   0FB5 38 00 02      mov c, 512
2608   0FB8 04            load
2609   0FB9 07 2B 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2610   0FBC                                                  ; the file data is loaded into transient_area
2611   0FBC             ; now we allocate a new process  
2612   0FBC 07 ED 0E      call find_free_proc                ; index in a
2613   0FBF 01            setptb 
2614   0FC0 07 FF 0E      call proc_memory_map               ; map process memory pages
2615   0FC3             ; copy arguments into process's memory
2616   0FC3 FD 4D 2C 23   mov si, scrap_sector
2617   0FC7 FD 4F 00 00   mov di, 0
2618   0FCB 38 00 02      mov c, 512
2619   0FCE 03            store
2620   0FCF             ; now copy process binary data into process's memory
2621   0FCF FD 4D 2C 25   mov si, transient_area
2622   0FD3 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2623   0FD7 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2624   0FDA 03            store                              ; copy process data
2625   0FDB                 
2626   0FDB 07 ED 0E      call find_free_proc                ; index in a
2627   0FDE 3D C6 17      mov [active_proc_index], al        ; set new active process
2628   0FE1 FD 9D 05      shl a, 5                           ; x32
2629   0FE4 53 AC 1A      add a, proc_names
2630   0FE7 4F            mov di, a
2631   0FE8 FD 4D 2C 1D   mov si, user_data                  ; copy and store process filename
2632   0FEC 07 ED 10      call _strcpy
2633   0FEF               
2634   0FEF 07 ED 0E      call find_free_proc                ; index in a
2635   0FF2 3C            mov d, a
2636   0FF3 19 01         mov al, 1
2637   0FF5 3F 9C 1A      mov [d + proc_availab_table], al   ; make process busy
2638   0FF8               
2639   0FF8 1D C5 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2640   0FFB 7A            inc al
2641   0FFC 3D C5 17      mov [nbr_active_procs], al
2642   0FFF             ; launch process
2643   0FFF FD D7 FF FF   push word $ffff 
2644   1003 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2645   1006 FD D7 00 04   push word text_org
2646   100A 06            sysret
2647   100B             
2648   100B             proc_table_convert:
2649   100B 5C 19         .dw proc_state_table + 0
2650   100D 70 19         .dw proc_state_table + 20
2651   100F 84 19         .dw proc_state_table + 40
2652   1011 98 19         .dw proc_state_table + 60
2653   1013 AC 19         .dw proc_state_table + 80
2654   1015 C0 19         .dw proc_state_table + 100
2655   1017 D4 19         .dw proc_state_table + 120
2656   1019 E8 19         .dw proc_state_table + 140
2657   101B               
2658   101B             ;----------------------------------------------------------------------------------------------;
2659   101B             ; get hex file
2660   101B             ; di = destination address
2661   101B             ; return length in bytes in c
2662   101B             ;----------------------------------------------------------------------------------------------;
2663   101B             _load_hex:
2664   101B D7            push a
2665   101C D8            push b
2666   101D DA            push d
2667   101E E2            push si
2668   101F E3            push di
2669   1020 38 00 00      mov c, 0
2670   1023 50            mov a, di
2671   1024 3C            mov d, a          ; start of string data block
2672   1025 07 70 11      call _gets        ; get program string
2673   1028 4D            mov si, a
2674   1029             __load_hex_loop:
2675   1029 F6            lodsb             ; load from [si] to al
2676   102A B9 00         cmp al, 0         ; check if ascii 0
2677   102C C6 3A 10      jz __load_hex_ret
2678   102F 36            mov bh, al
2679   1030 F6            lodsb
2680   1031 2F            mov bl, al
2681   1032 07 26 11      call _atoi        ; convert ascii byte in b to int (to al)
2682   1035 F7            stosb             ; store al to [di]
2683   1036 78            inc c
2684   1037 0A 29 10      jmp __load_hex_loop
2685   103A             __load_hex_ret:
2686   103A F0            pop di
2687   103B EF            pop si
2688   103C E7            pop d
2689   103D E5            pop b
2690   103E E4            pop a
2691   103F 09            ret
2692   1040             
2693   1040             ; synopsis: look inside a certain directory for files/directories
2694   1040             ; before calling this function, cd into required directory
2695   1040             ; for each entry inside directory:
2696   1040             ;  if entry is a file:
2697   1040             ;    compare filename to searched filename
2698   1040             ;    if filenames are the same, print filename
2699   1040             ;  else if entry is a directory:
2700   1040             ;    cd to the given directory
2701   1040             ;    recursively call cmd_find
2702   1040             ;    cd outside previous directory
2703   1040             ;  if current entry == last entry, return
2704   1040             ; endfor
2705   1040             f_find:
2706   1040 09            ret
2707   1041             
2708   1041             
2709   1041             ; ---------------------------------------------------------------------
2710   1041             ; kernel reset vector
2711   1041             ; ---------------------------------------------------------------------
2712   1041             kernel_reset_vector:  
2713   1041 FD 49 FF F7   mov bp, stack_begin
2714   1045 FD 47 FF F7   mov sp, stack_begin
2715   1049               
2716   1049 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2717   104B FD 0F         stomsk                        
2718   104D FD 0C         sti  
2719   104F             
2720   104F 0C            lodstat
2721   1050 87 DF         and al, %11011111             ; disable display register loading
2722   1052 0D            stostat
2723   1053               
2724   1053             ; reset fifo pointers
2725   1053 10 2C 1F      mov a, fifo
2726   1056 3B CB 17      mov d, fifo_in
2727   1059 43            mov [d], a
2728   105A 3B CD 17      mov d, fifo_out
2729   105D 43            mov [d], a  
2730   105E 19 02         mov al, 2
2731   1060 05 03         syscall sys_io                ; enable uart in interrupt mode
2732   1062             
2733   1062 3B 1A 19      mov d, s_fdc_config
2734   1065 07 95 12      call _puts
2735   1068 F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2736   106C               
2737   106C 3B 20 18      mov d, s_kernel_started
2738   106F 07 95 12      call _puts
2739   1072             
2740   1072 19 10         mov al, 16
2741   1074 05 04         syscall sys_filesystem        ; set root dirid
2742   1076             
2743   1076 3B 3D 18      mov d, s_prompt_init
2744   1079 07 95 12      call _puts
2745   107C 3B D1 17      mov d, s_init_path
2746   107F 05 05         syscall sys_create_proc       ; launch init as a new process
2747   1081             
2748   1081             
2749   1081             ; file includes
2750   1081             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1081             boot_origin      .EQU  $8004
0002+  1081             bios_uart        .EQU  $0002
0003+  1081             bios_ide         .EQU  $0003
0004+  1081             bios_reset_vector .EQU  $01c0
0005+  1081             ide_buffer       .EQU  $8204
2751   1081             .include "lib/stdio.asm"
0001+  1081             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1081             ; stdio.s
0003+  1081             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1081             .include "lib/string.asm"
0001++ 1081             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1081             ; string.s
0003++ 1081             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1081             
0005++ 1081             
0006++ 1081             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1081             ; _strrev
0008++ 1081             ; reverse a string
0009++ 1081             ; d = string address
0010++ 1081             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1081             ; 01234
0012++ 1081             _strrev:
0013++ 1081 4B          	pusha
0014++ 1082 07 C8 10    	call _strlen	; length in c
0015++ 1085 12          	mov a, c
0016++ 1086 AF 01 00    	cmp a, 1
0017++ 1089 D0 A3 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 108C 7D          	dec a
0019++ 108D FD 4E       	mov si, d	; beginning of string
0020++ 108F FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1091 59          	add d, a	; end of string
0022++ 1092 12          	mov a, c
0023++ 1093 FD 9B       	shr a		; divide by 2
0024++ 1095 39          	mov c, a	; c now counts the steps
0025++ 1096             _strrev_l0:
0026++ 1096 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1097 F6          	lodsb		; load left-side char into al; increase si
0028++ 1098 3E          	mov [d], al	; store left char into right side
0029++ 1099 1B          	mov al, bl
0030++ 109A F7          	stosb		; store right-side char into left-side; increase di
0031++ 109B 7E          	dec c
0032++ 109C 7F          	dec d
0033++ 109D C2 00 00    	cmp c, 0
0034++ 10A0 C7 96 10    	jne _strrev_l0
0035++ 10A3             _strrev_end:
0036++ 10A3 4C          	popa
0037++ 10A4 09          	ret
0038++ 10A5             	
0039++ 10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10A5             ; _strchr
0041++ 10A5             ; search string in d for char in al
0042++ 10A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10A5             _strchr:
0044++ 10A5             _strchr_l0:
0045++ 10A5 32          	mov bl, [d]
0046++ 10A6 C1 00       	cmp bl, 0
0047++ 10A8 C6 B3 10    	je _strchr_end
0048++ 10AB BA          	cmp al, bl
0049++ 10AC C6 B3 10    	je _strchr_end
0050++ 10AF 79          	inc d
0051++ 10B0 0A A5 10    	jmp _strchr_l0
0052++ 10B3             _strchr_end:
0053++ 10B3 1B          	mov al, bl
0054++ 10B4 09          	ret
0055++ 10B5             
0056++ 10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10B5             ; _strstr
0058++ 10B5             ; find sub-string
0059++ 10B5             ; str1 in si
0060++ 10B5             ; str2 in di
0061++ 10B5             ; si points to end of source string
0062++ 10B5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10B5             _strstr:
0064++ 10B5 DB          	push al
0065++ 10B6 DA          	push d
0066++ 10B7 E3          	push di
0067++ 10B8             _strstr_loop:
0068++ 10B8 F3          	cmpsb					; compare a byte of the strings
0069++ 10B9 C7 C4 10    	jne _strstr_ret
0070++ 10BC FC 00 00    	lea d, [di + 0]
0071++ 10BF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10C1 C7 B8 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10C4             _strstr_ret:
0074++ 10C4 F0          	pop di
0075++ 10C5 E7          	pop d
0076++ 10C6 E8          	pop al
0077++ 10C7 09          	ret
0078++ 10C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10C8             ; length of null terminated string
0080++ 10C8             ; result in c
0081++ 10C8             ; pointer in d
0082++ 10C8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10C8             _strlen:
0084++ 10C8 DA          	push d
0085++ 10C9 38 00 00    	mov c, 0
0086++ 10CC             _strlen_l1:
0087++ 10CC BD 00       	cmp byte [d], 0
0088++ 10CE C6 D6 10    	je _strlen_ret
0089++ 10D1 79          	inc d
0090++ 10D2 78          	inc c
0091++ 10D3 0A CC 10    	jmp _strlen_l1
0092++ 10D6             _strlen_ret:
0093++ 10D6 E7          	pop d
0094++ 10D7 09          	ret
0095++ 10D8             
0096++ 10D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10D8             ; strcmp
0098++ 10D8             ; compare two strings
0099++ 10D8             ; str1 in si
0100++ 10D8             ; str2 in di
0101++ 10D8             ; create a string compairon instrucion ?????
0102++ 10D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10D8             _strcmp:
0104++ 10D8 DB          	push al
0105++ 10D9 DA          	push d
0106++ 10DA E3          	push di
0107++ 10DB E2          	push si
0108++ 10DC             _strcmp_loop:
0109++ 10DC F3          	cmpsb					; compare a byte of the strings
0110++ 10DD C7 E8 10    	jne _strcmp_ret
0111++ 10E0 FB FF FF    	lea d, [si +- 1]
0112++ 10E3 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10E5 C7 DC 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10E8             _strcmp_ret:
0115++ 10E8 EF          	pop si
0116++ 10E9 F0          	pop di
0117++ 10EA E7          	pop d
0118++ 10EB E8          	pop al
0119++ 10EC 09          	ret
0120++ 10ED             
0121++ 10ED             
0122++ 10ED             ; strcpy
0123++ 10ED             ; copy null terminated string from si to di
0124++ 10ED             ; source in si
0125++ 10ED             ; destination in di
0126++ 10ED             _strcpy:
0127++ 10ED E2          	push si
0128++ 10EE E3          	push di
0129++ 10EF DB          	push al
0130++ 10F0             _strcpy_l1:
0131++ 10F0 F6          	lodsb
0132++ 10F1 F7          	stosb
0133++ 10F2 B9 00       	cmp al, 0
0134++ 10F4 C7 F0 10    	jne _strcpy_l1
0135++ 10F7             _strcpy_end:
0136++ 10F7 E8          	pop al
0137++ 10F8 F0          	pop di
0138++ 10F9 EF          	pop si
0139++ 10FA 09          	ret
0140++ 10FB             
0141++ 10FB             ; strcat
0142++ 10FB             ; concatenate a null terminated string into string at di, from string at si
0143++ 10FB             ; source in si
0144++ 10FB             ; destination in di
0145++ 10FB             _strcat:
0146++ 10FB E2          	push si
0147++ 10FC E3          	push di
0148++ 10FD D7          	push a
0149++ 10FE DA          	push d
0150++ 10FF 50          	mov a, di
0151++ 1100 3C          	mov d, a
0152++ 1101             _strcat_goto_end_l1:
0153++ 1101 BD 00       	cmp byte[d], 0
0154++ 1103 C6 0A 11    	je _strcat_start
0155++ 1106 79          	inc d
0156++ 1107 0A 01 11    	jmp _strcat_goto_end_l1
0157++ 110A             _strcat_start:
0158++ 110A FD 50       	mov di, d
0159++ 110C             _strcat_l1:
0160++ 110C F6          	lodsb
0161++ 110D F7          	stosb
0162++ 110E B9 00       	cmp al, 0
0163++ 1110 C7 0C 11    	jne _strcat_l1
0164++ 1113             _strcat_end:
0165++ 1113 E7          	pop d
0166++ 1114 E4          	pop a
0167++ 1115 F0          	pop di
0168++ 1116 EF          	pop si
0169++ 1117 09          	ret
0170++ 1118             
0171++ 1118             
0005+  1118             
0006+  1118             
0007+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1118             ; convert ascii 'o'..'f' to integer 0..15
0009+  1118             ; ascii in bl
0010+  1118             ; result in al
0011+  1118             ; ascii for f = 0100 0110
0012+  1118             ; ascii for 9 = 0011 1001
0013+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1118             hex_ascii_encode:
0015+  1118 1B            mov al, bl
0016+  1119 93 40         test al, $40        ; test if letter or number
0017+  111B C7 21 11      jnz hex_letter
0018+  111E 87 0F         and al, $0f        ; get number
0019+  1120 09            ret
0020+  1121             hex_letter:
0021+  1121 87 0F         and al, $0f        ; get letter
0022+  1123 6A 09         add al, 9
0023+  1125 09            ret
0024+  1126             
0025+  1126             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1126             ; atoi
0027+  1126             ; 2 letter hex string in b
0028+  1126             ; 8bit integer returned in al
0029+  1126             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1126             _atoi:
0031+  1126 D8            push b
0032+  1127 07 18 11      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  112A 30            mov bl, bh
0034+  112B DB            push al          ; save a
0035+  112C 07 18 11      call hex_ascii_encode
0036+  112F EA            pop bl  
0037+  1130 FD 9E 04      shl al, 4
0038+  1133 8C            or al, bl
0039+  1134 E5            pop b
0040+  1135 09            ret  
0041+  1136             
0042+  1136             
0043+  1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1136             ; scanf
0045+  1136             ; no need for explanations!
0046+  1136             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1136             scanf:
0048+  1136 09            ret
0049+  1137             
0050+  1137             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1137             ; itoa
0052+  1137             ; 8bit value in bl
0053+  1137             ; 2 byte ascii result in a
0054+  1137             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1137             _itoa:
0056+  1137 DA            push d
0057+  1138 D8            push b
0058+  1139 A7 00         mov bh, 0
0059+  113B FD A4 04      shr bl, 4  
0060+  113E 74            mov d, b
0061+  113F 1F D1 13      mov al, [d + s_hex_digits]
0062+  1142 23            mov ah, al
0063+  1143               
0064+  1143 E5            pop b
0065+  1144 D8            push b
0066+  1145 A7 00         mov bh, 0
0067+  1147 FD 87 0F      and bl, $0f
0068+  114A 74            mov d, b
0069+  114B 1F D1 13      mov al, [d + s_hex_digits]
0070+  114E E5            pop b
0071+  114F E7            pop d
0072+  1150 09            ret
0073+  1151             
0074+  1151             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1151             ; hex string to binary
0076+  1151             ; di = destination address
0077+  1151             ; si = source
0078+  1151             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1151             _hex_to_int:
0080+  1151             _hex_to_int_l1:
0081+  1151 F6            lodsb          ; load from [si] to al
0082+  1152 B9 00         cmp al, 0        ; check if ascii 0
0083+  1154 C6 61 11      jz _hex_to_int_ret
0084+  1157 36            mov bh, al
0085+  1158 F6            lodsb
0086+  1159 2F            mov bl, al
0087+  115A 07 26 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  115D F7            stosb          ; store al to [di]
0089+  115E 0A 51 11      jmp _hex_to_int_l1
0090+  1161             _hex_to_int_ret:
0091+  1161 09            ret    
0092+  1162             
0093+  1162             
0094+  1162             
0095+  1162             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1162             ; getchar
0097+  1162             ; char in ah
0098+  1162             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1162             getch:
0100+  1162 DB            push al
0101+  1163             getch_retry:
0102+  1163 19 01         mov al, 1
0103+  1165 05 03         syscall sys_io      ; receive in ah
0104+  1167 E8            pop al
0105+  1168 09            ret
0106+  1169             
0107+  1169             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1169             ; putchar
0109+  1169             ; char in ah
0110+  1169             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1169             _putchar:
0112+  1169 DB            push al
0113+  116A 19 00         mov al, 0
0114+  116C 05 03         syscall sys_io      ; char in ah
0115+  116E E8            pop al
0116+  116F 09            ret
0117+  1170             
0118+  1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1170             ;; input a string
0120+  1170             ;; terminates with null
0121+  1170             ;; pointer in d
0122+  1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1170             _gets:
0124+  1170 D7            push a
0125+  1171 DA            push d
0126+  1172             _gets_loop:
0127+  1172 19 01         mov al, 1
0128+  1174 05 03         syscall sys_io      ; receive in ah
0129+  1176 76 1B         cmp ah, 27
0130+  1178 C6 99 11      je _gets_ansi_esc
0131+  117B 76 0A         cmp ah, $0a        ; lf
0132+  117D C6 F5 11      je _gets_end
0133+  1180 76 0D         cmp ah, $0d        ; cr
0134+  1182 C6 F5 11      je _gets_end
0135+  1185 76 5C         cmp ah, $5c        ; '\\'
0136+  1187 C6 BB 11      je _gets_escape
0137+  118A 76 08         cmp ah, $08      ; check for backspace
0138+  118C C6 95 11      je _gets_backspace
0139+  118F 1A            mov al, ah
0140+  1190 3E            mov [d], al
0141+  1191 79            inc d
0142+  1192 0A 72 11      jmp _gets_loop
0143+  1195             _gets_backspace:
0144+  1195 7F            dec d
0145+  1196 0A 72 11      jmp _gets_loop
0146+  1199             _gets_ansi_esc:
0147+  1199 19 01         mov al, 1
0148+  119B 05 03         syscall sys_io        ; receive in ah without echo
0149+  119D 76 5B         cmp ah, '['
0150+  119F C7 72 11      jne _gets_loop
0151+  11A2 19 01         mov al, 1
0152+  11A4 05 03         syscall sys_io          ; receive in ah without echo
0153+  11A6 76 64         cmp ah, 'd'
0154+  11A8 C6 B3 11      je _gets_left_arrow
0155+  11AB 76 63         cmp ah, 'c'
0156+  11AD C6 B7 11      je _gets_right_arrow
0157+  11B0 0A 72 11      jmp _gets_loop
0158+  11B3             _gets_left_arrow:
0159+  11B3 7F            dec d
0160+  11B4 0A 72 11      jmp _gets_loop
0161+  11B7             _gets_right_arrow:
0162+  11B7 79            inc d
0163+  11B8 0A 72 11      jmp _gets_loop
0164+  11BB             _gets_escape:
0165+  11BB 19 01         mov al, 1
0166+  11BD 05 03         syscall sys_io      ; receive in ah
0167+  11BF 76 6E         cmp ah, 'n'
0168+  11C1 C6 E0 11      je _gets_lf
0169+  11C4 76 72         cmp ah, 'r'
0170+  11C6 C6 E7 11      je _gets_cr
0171+  11C9 76 30         cmp ah, '0'
0172+  11CB C6 EE 11      je _gets_null
0173+  11CE 76 5C         cmp ah, $5c  ; '\'
0174+  11D0 C6 D9 11      je _gets_slash
0175+  11D3 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  11D4 3E            mov [d], al
0177+  11D5 79            inc d
0178+  11D6 0A 72 11      jmp _gets_loop
0179+  11D9             _gets_slash:
0180+  11D9 19 5C         mov al, $5c
0181+  11DB 3E            mov [d], al
0182+  11DC 79            inc d
0183+  11DD 0A 72 11      jmp _gets_loop
0184+  11E0             _gets_lf:
0185+  11E0 19 0A         mov al, $0a
0186+  11E2 3E            mov [d], al
0187+  11E3 79            inc d
0188+  11E4 0A 72 11      jmp _gets_loop
0189+  11E7             _gets_cr:
0190+  11E7 19 0D         mov al, $0d
0191+  11E9 3E            mov [d], al
0192+  11EA 79            inc d
0193+  11EB 0A 72 11      jmp _gets_loop
0194+  11EE             _gets_null:
0195+  11EE 19 00         mov al, $00
0196+  11F0 3E            mov [d], al
0197+  11F1 79            inc d
0198+  11F2 0A 72 11      jmp _gets_loop
0199+  11F5             _gets_end:
0200+  11F5 19 00         mov al, 0
0201+  11F7 3E            mov [d], al        ; terminate string
0202+  11F8 E7            pop d
0203+  11F9 E4            pop a
0204+  11FA 09            ret
0205+  11FB             
0206+  11FB             
0207+  11FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11FB             ;; input text
0209+  11FB             ;; terminated with ctrl+d
0210+  11FB             ;; pointer in d
0211+  11FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11FB             _gettxt:
0213+  11FB D7            push a
0214+  11FC DA            push d
0215+  11FD             _gettxt_loop:
0216+  11FD 19 01         mov al, 1
0217+  11FF 05 03         syscall sys_io      ; receive in ah
0218+  1201 76 04         cmp ah, 4      ; eot
0219+  1203 C6 3C 12      je _gettxt_end
0220+  1206 76 08         cmp ah, $08      ; check for backspace
0221+  1208 C6 38 12      je _gettxt_backspace
0222+  120B 76 5C         cmp ah, $5c        ; '\'
0223+  120D C6 16 12      je _gettxt_escape
0224+  1210 1A            mov al, ah
0225+  1211 3E            mov [d], al
0226+  1212 79            inc d
0227+  1213 0A FD 11      jmp _gettxt_loop
0228+  1216             _gettxt_escape:
0229+  1216 19 01         mov al, 1
0230+  1218 05 03         syscall sys_io      ; receive in ah
0231+  121A 76 6E         cmp ah, 'n'
0232+  121C C6 2A 12      je _gettxt_lf
0233+  121F 76 72         cmp ah, 'r'
0234+  1221 C6 31 12      je _gettxt_cr
0235+  1224 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1225 3E            mov [d], al
0237+  1226 79            inc d
0238+  1227 0A FD 11      jmp _gettxt_loop
0239+  122A             _gettxt_lf:
0240+  122A 19 0A         mov al, $0a
0241+  122C 3E            mov [d], al
0242+  122D 79            inc d
0243+  122E 0A FD 11      jmp _gettxt_loop
0244+  1231             _gettxt_cr:
0245+  1231 19 0D         mov al, $0d
0246+  1233 3E            mov [d], al
0247+  1234 79            inc d
0248+  1235 0A FD 11      jmp _gettxt_loop
0249+  1238             _gettxt_backspace:
0250+  1238 7F            dec d
0251+  1239 0A FD 11      jmp _gettxt_loop
0252+  123C             _gettxt_end:
0253+  123C 19 00         mov al, 0
0254+  123E 3E            mov [d], al        ; terminate string
0255+  123F E7            pop d
0256+  1240 E4            pop a
0257+  1241 09            ret
0258+  1242             
0259+  1242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1242             ; print new line
0261+  1242             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1242             printnl:
0263+  1242 D7            push a
0264+  1243 10 00 0A      mov a, $0a00
0265+  1246 05 03         syscall sys_io
0266+  1248 10 00 0D      mov a, $0d00
0267+  124B 05 03         syscall sys_io
0268+  124D E4            pop a
0269+  124E 09            ret
0270+  124F             
0271+  124F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  124F             ; _strtoint
0273+  124F             ; 4 digit hex string number in d
0274+  124F             ; integer returned in a
0275+  124F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  124F             _strtointx:
0277+  124F D8            push b
0278+  1250 32            mov bl, [d]
0279+  1251 37            mov bh, bl
0280+  1252 33 01 00      mov bl, [d + 1]
0281+  1255 07 26 11      call _atoi        ; convert to int in al
0282+  1258 23            mov ah, al        ; move to ah
0283+  1259 33 02 00      mov bl, [d + 2]
0284+  125C 37            mov bh, bl
0285+  125D 33 03 00      mov bl, [d + 3]
0286+  1260 07 26 11      call _atoi        ; convert to int in al
0287+  1263 E5            pop b
0288+  1264 09            ret
0289+  1265             
0290+  1265             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1265             ; _strtoint
0292+  1265             ; 5 digit base10 string number in d
0293+  1265             ; integer returned in a
0294+  1265             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1265             _strtoint:
0296+  1265 E2            push si
0297+  1266 D8            push b
0298+  1267 D9            push c
0299+  1268 DA            push d
0300+  1269 07 C8 10      call _strlen      ; get string length in c
0301+  126C 7E            dec c
0302+  126D FD 4E         mov si, d
0303+  126F 12            mov a, c
0304+  1270 FD 99         shl a
0305+  1272 3B E9 13      mov d, table_power
0306+  1275 59            add d, a
0307+  1276 38 00 00      mov c, 0
0308+  1279             _strtoint_l0:
0309+  1279 F6            lodsb      ; load ascii to al
0310+  127A B9 00         cmp al, 0
0311+  127C C6 8F 12      je _strtoint_end
0312+  127F 6F 30         sub al, $30    ; make into integer
0313+  1281 22 00         mov ah, 0
0314+  1283 2A            mov b, [d]
0315+  1284 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1285 11            mov a, b
0317+  1286 28            mov b, c
0318+  1287 54            add a, b
0319+  1288 39            mov c, a
0320+  1289 63 02 00      sub d, 2
0321+  128C 0A 79 12      jmp _strtoint_l0
0322+  128F             _strtoint_end:
0323+  128F 12            mov a, c
0324+  1290 E7            pop d
0325+  1291 E6            pop c
0326+  1292 E5            pop b
0327+  1293 EF            pop si
0328+  1294 09            ret
0329+  1295             
0330+  1295             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1295             ; print null terminated string
0332+  1295             ; pointer in d
0333+  1295             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1295             _puts:
0335+  1295 D7            push a
0336+  1296 DA            push d
0337+  1297             _puts_l1:
0338+  1297 1E            mov al, [d]
0339+  1298 B9 00         cmp al, 0
0340+  129A C6 A6 12      jz _puts_end
0341+  129D 23            mov ah, al
0342+  129E 19 00         mov al, 0
0343+  12A0 05 03         syscall sys_io
0344+  12A2 79            inc d
0345+  12A3 0A 97 12      jmp _puts_l1
0346+  12A6             _puts_end:
0347+  12A6 E7            pop d
0348+  12A7 E4            pop a
0349+  12A8 09            ret
0350+  12A9             
0351+  12A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12A9             ; print n size string
0353+  12A9             ; pointer in d
0354+  12A9             ; size in c
0355+  12A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12A9             _putsn:
0357+  12A9 DB            push al
0358+  12AA DA            push d
0359+  12AB D9            push c
0360+  12AC             _putsn_l0:
0361+  12AC 1E            mov al, [d]
0362+  12AD 23            mov ah, al
0363+  12AE 19 00         mov al, 0
0364+  12B0 05 03         syscall sys_io
0365+  12B2 79            inc d
0366+  12B3 7E            dec c  
0367+  12B4 C2 00 00      cmp c, 0
0368+  12B7 C7 AC 12      jne _putsn_l0
0369+  12BA             _putsn_end:
0370+  12BA E6            pop c
0371+  12BB E7            pop d
0372+  12BC E8            pop al
0373+  12BD 09            ret
0374+  12BE             
0375+  12BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  12BE             ; print 16bit decimal number
0377+  12BE             ; input number in a
0378+  12BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  12BE             print_u16d:
0380+  12BE D7            push a
0381+  12BF D8            push b
0382+  12C0 FD D8         push g
0383+  12C2 26 10 27      mov b, 10000
0384+  12C5 AE            div a, b      ; get 10000's coeff.
0385+  12C6 07 EA 12      call print_number
0386+  12C9 11            mov a, b
0387+  12CA 26 E8 03      mov b, 1000
0388+  12CD AE            div a, b      ; get 1000's coeff.
0389+  12CE 07 EA 12      call print_number
0390+  12D1 11            mov a, b
0391+  12D2 26 64 00      mov b, 100
0392+  12D5 AE            div a, b
0393+  12D6 07 EA 12      call print_number
0394+  12D9 11            mov a, b
0395+  12DA 26 0A 00      mov b, 10
0396+  12DD AE            div a, b
0397+  12DE 07 EA 12      call print_number
0398+  12E1 1B            mov al, bl      ; 1's coeff in bl
0399+  12E2 07 EA 12      call print_number
0400+  12E5 FD F1         pop g
0401+  12E7 E5            pop b
0402+  12E8 E4            pop a
0403+  12E9 09            ret
0404+  12EA             
0405+  12EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12EA             ; print al
0407+  12EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12EA             print_number:
0409+  12EA 6A 30         add al, $30
0410+  12EC 23            mov ah, al
0411+  12ED 07 69 11      call _putchar
0412+  12F0 09            ret
0413+  12F1             
0414+  12F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12F1             ; print 16bit hex integer
0416+  12F1             ; integer value in reg b
0417+  12F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12F1             print_u16x:
0419+  12F1 D7            push a
0420+  12F2 D8            push b
0421+  12F3 DD            push bl
0422+  12F4 30            mov bl, bh
0423+  12F5 07 37 11      call _itoa        ; convert bh to char in a
0424+  12F8 2F            mov bl, al        ; save al
0425+  12F9 19 00         mov al, 0
0426+  12FB 05 03         syscall sys_io        ; display ah
0427+  12FD 24            mov ah, bl        ; retrieve al
0428+  12FE 19 00         mov al, 0
0429+  1300 05 03         syscall sys_io        ; display al
0430+  1302             
0431+  1302 EA            pop bl
0432+  1303 07 37 11      call _itoa        ; convert bh to char in a
0433+  1306 2F            mov bl, al        ; save al
0434+  1307 19 00         mov al, 0
0435+  1309 05 03         syscall sys_io        ; display ah
0436+  130B 24            mov ah, bl        ; retrieve al
0437+  130C 19 00         mov al, 0
0438+  130E 05 03         syscall sys_io        ; display al
0439+  1310             
0440+  1310 E5            pop b
0441+  1311 E4            pop a
0442+  1312 09            ret
0443+  1313             
0444+  1313             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1313             ; input 16bit hex integer
0446+  1313             ; read 16bit integer into a
0447+  1313             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1313             scan_u16x:
0449+  1313 F8 10 00      enter 16
0450+  1316 D8            push b
0451+  1317 DA            push d
0452+  1318             
0453+  1318 FA F1 FF      lea d, [bp + -15]
0454+  131B 07 70 11      call _gets        ; get number
0455+  131E             
0456+  131E 32            mov bl, [d]
0457+  131F 37            mov bh, bl
0458+  1320 33 01 00      mov bl, [d + 1]
0459+  1323 07 26 11      call _atoi        ; convert to int in al
0460+  1326 23            mov ah, al        ; move to ah
0461+  1327             
0462+  1327 33 02 00      mov bl, [d + 2]
0463+  132A 37            mov bh, bl
0464+  132B 33 03 00      mov bl, [d + 3]
0465+  132E 07 26 11      call _atoi        ; convert to int in al
0466+  1331             
0467+  1331 E7            pop d
0468+  1332 E5            pop b
0469+  1333 F9            leave
0470+  1334 09            ret
0471+  1335             
0472+  1335             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1335             ; print 8bit hex integer
0474+  1335             ; integer value in reg bl
0475+  1335             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1335             print_u8x:
0477+  1335 D7            push a
0478+  1336 DD            push bl
0479+  1337             
0480+  1337 07 37 11      call _itoa        ; convert bl to char in a
0481+  133A 2F            mov bl, al        ; save al
0482+  133B 19 00         mov al, 0
0483+  133D 05 03         syscall sys_io        ; display ah
0484+  133F 24            mov ah, bl        ; retrieve al
0485+  1340 19 00         mov al, 0
0486+  1342 05 03         syscall sys_io        ; display al
0487+  1344             
0488+  1344 EA            pop bl
0489+  1345 E4            pop a
0490+  1346 09            ret
0491+  1347             
0492+  1347             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1347             ; print 8bit decimal unsigned number
0494+  1347             ; input number in al
0495+  1347             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1347             print_u8d:
0497+  1347 D7            push a
0498+  1348 D8            push b
0499+  1349 FD D8         push g
0500+  134B 22 00         mov ah, 0
0501+  134D 26 64 00      mov b, 100
0502+  1350 AE            div a, b
0503+  1351 D8            push b      ; save remainder
0504+  1352 B9 00         cmp al, 0
0505+  1354 C6 5E 13      je skip100
0506+  1357 6A 30         add al, $30
0507+  1359 23            mov ah, al
0508+  135A 19 00         mov al, 0
0509+  135C 05 03         syscall sys_io  ; print coeff
0510+  135E             skip100:
0511+  135E E4            pop a
0512+  135F 22 00         mov ah, 0
0513+  1361 26 0A 00      mov b, 10
0514+  1364 AE            div a, b
0515+  1365 D8            push b      ; save remainder
0516+  1366 B9 00         cmp al, 0
0517+  1368 C6 72 13      je skip10
0518+  136B 6A 30         add al, $30
0519+  136D 23            mov ah, al
0520+  136E 19 00         mov al, 0
0521+  1370 05 03         syscall sys_io  ; print coeff
0522+  1372             skip10:
0523+  1372 E4            pop a
0524+  1373 1B            mov al, bl
0525+  1374 6A 30         add al, $30
0526+  1376 23            mov ah, al
0527+  1377 19 00         mov al, 0
0528+  1379 05 03         syscall sys_io  ; print coeff
0529+  137B FD F1         pop g
0530+  137D E5            pop b
0531+  137E E4            pop a
0532+  137F 09            ret
0533+  1380             
0534+  1380             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1380             ; input 8bit hex integer
0536+  1380             ; read 8bit integer into al
0537+  1380             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1380             scan_u8x:
0539+  1380 F8 04 00      enter 4
0540+  1383 D8            push b
0541+  1384 DA            push d
0542+  1385             
0543+  1385 FA FD FF      lea d, [bp + -3]
0544+  1388 07 70 11      call _gets        ; get number
0545+  138B             
0546+  138B 32            mov bl, [d]
0547+  138C 37            mov bh, bl
0548+  138D 33 01 00      mov bl, [d + 1]
0549+  1390 07 26 11      call _atoi        ; convert to int in al
0550+  1393             
0551+  1393 E7            pop d
0552+  1394 E5            pop b
0553+  1395 F9            leave
0554+  1396 09            ret
0555+  1397             
0556+  1397             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1397             ; input decimal number
0558+  1397             ; result in a
0559+  1397             ; 655'\0'
0560+  1397             ; low--------high
0561+  1397             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1397             scan_u16d:
0563+  1397 F8 08 00      enter 8
0564+  139A E2            push si
0565+  139B D8            push b
0566+  139C D9            push c
0567+  139D DA            push d
0568+  139E FA F9 FF      lea d, [bp +- 7]
0569+  13A1 07 70 11      call _gets
0570+  13A4 07 C8 10      call _strlen      ; get string length in c
0571+  13A7 7E            dec c
0572+  13A8 FD 4E         mov si, d
0573+  13AA 12            mov a, c
0574+  13AB FD 99         shl a
0575+  13AD 3B E9 13      mov d, table_power
0576+  13B0 59            add d, a
0577+  13B1 38 00 00      mov c, 0
0578+  13B4             mul_loop:
0579+  13B4 F6            lodsb      ; load ascii to al
0580+  13B5 B9 00         cmp al, 0
0581+  13B7 C6 CA 13      je mul_exit
0582+  13BA 6F 30         sub al, $30    ; make into integer
0583+  13BC 22 00         mov ah, 0
0584+  13BE 2A            mov b, [d]
0585+  13BF AC            mul a, b      ; result in b since it fits in 16bits
0586+  13C0 11            mov a, b
0587+  13C1 28            mov b, c
0588+  13C2 54            add a, b
0589+  13C3 39            mov c, a
0590+  13C4 63 02 00      sub d, 2
0591+  13C7 0A B4 13      jmp mul_loop
0592+  13CA             mul_exit:
0593+  13CA 12            mov a, c
0594+  13CB E7            pop d
0595+  13CC E6            pop c
0596+  13CD E5            pop b
0597+  13CE EF            pop si
0598+  13CF F9            leave
0599+  13D0 09            ret
0600+  13D1             
0601+  13D1             
0602+  13D1 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  13D5 34 35 36 37 
0602+  13D9 38 39 61 62 
0602+  13DD 63 64 65 66 
0603+  13E1 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  13E5 1B 5B 68 00 
0604+  13E9             
0605+  13E9             table_power:
0606+  13E9 01 00         .dw 1
0607+  13EB 0A 00         .dw 10
0608+  13ED 64 00         .dw 100
0609+  13EF E8 03         .dw 1000
0610+  13F1 10 27         .dw 100002752   13F3             .include "lib/ctype.asm"
0001+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13F3             ; ctype.s
0003+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13F3             
0005+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13F3             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  13F3             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  13F3             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  13F3             ;; characters are supported.
0010+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13F3             ;; _isalnum 
0012+  13F3             ;; _isalpha 
0013+  13F3             ;; islower 
0014+  13F3             ;; isupper 
0015+  13F3             ;; _isdigit 
0016+  13F3             ;; isxdigit
0017+  13F3             ;; iscntrl 
0018+  13F3             ;; isgraph 
0019+  13F3             ;; _isspace 
0020+  13F3             ;; isblank 
0021+  13F3             ;; isprint 
0022+  13F3             ;; ispunct 
0023+  13F3             ;; tolower 
0024+  13F3             ;; toupper
0025+  13F3             
0026+  13F3             
0027+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13F3             ;; is alphanumeric
0029+  13F3             ;; sets zf according with result
0030+  13F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13F3             _isalnum:
0032+  13F3 07 10 14    	call _isalpha
0033+  13F6 C6 FC 13    	je _isalnum_exit
0034+  13F9 07 FD 13    	call _isdigit
0035+  13FC             _isalnum_exit:
0036+  13FC 09          	ret	
0037+  13FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13FD             ;; is digit
0039+  13FD             ;; sets zf according with result
0040+  13FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13FD             _isdigit:
0042+  13FD DB          	push al
0043+  13FE B9 30       	cmp al, '0'
0044+  1400 C8 0C 14    	jlu _isdigit_false
0045+  1403 B9 39       	cmp al, '9'
0046+  1405 D1 0C 14    	jgu _isdigit_false
0047+  1408 87 00       	and al, 0	; set zf
0048+  140A E8          	pop al
0049+  140B 09          	ret
0050+  140C             _isdigit_false:
0051+  140C 8B 01       	or al, 1	; clear zf
0052+  140E E8          	pop al
0053+  140F 09          	ret	
0054+  1410             	
0055+  1410             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1410             ;; is alpha
0057+  1410             ;; sets zf according with result
0058+  1410             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1410             _isalpha:
0060+  1410 DB          	push al
0061+  1411 B9 5F       	cmp al, '_'
0062+  1413 C6 33 14    	je _isalpha_true
0063+  1416 B9 2E       	cmp al, '.'
0064+  1418 C6 33 14    	je _isalpha_true
0065+  141B B9 61       	cmp al, 'a'
0066+  141D C8 2F 14    	jlu _isalpha_false
0067+  1420 B9 7A       	cmp al, 'z'
0068+  1422 D1 2F 14    	jgu _isalpha_false
0069+  1425 B9 7A       	cmp al, 'z'
0070+  1427 D0 33 14    	jleu _isalpha_true
0071+  142A B9 61       	cmp al, 'a'
0072+  142C C9 33 14    	jgeu _isalpha_true
0073+  142F             _isalpha_false:
0074+  142F 8B 01       	or al, 1	; clear zf
0075+  1431 E8          	pop al
0076+  1432 09          	ret
0077+  1433             _isalpha_true:
0078+  1433 87 00       	and al, 0	; set zf
0079+  1435 E8          	pop al
0080+  1436 09          	ret
0081+  1437             
0082+  1437             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1437             ;; is path-alpha
0084+  1437             ;; sets zf according with result
0085+  1437             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1437             ispath:
0087+  1437 DB          	push al
0088+  1438 07 FD 13    	call _isdigit
0089+  143B C6 65 14    	je ispath_true
0090+  143E B9 5F       	cmp al, '_'
0091+  1440 C6 65 14    	je ispath_true
0092+  1443 B9 2F       	cmp al, '/'
0093+  1445 C6 65 14    	je ispath_true
0094+  1448 B9 2E       	cmp al, '.'
0095+  144A C6 65 14    	je ispath_true
0096+  144D B9 61       	cmp al, 'a'
0097+  144F C8 61 14    	jlu ispath_false
0098+  1452 B9 7A       	cmp al, 'z'
0099+  1454 D1 61 14    	jgu ispath_false
0100+  1457 B9 7A       	cmp al, 'z'
0101+  1459 D0 65 14    	jleu ispath_true
0102+  145C B9 61       	cmp al, 'a'
0103+  145E C9 65 14    	jgeu ispath_true
0104+  1461             ispath_false:
0105+  1461 8B 01       	or al, 1	; clear zf
0106+  1463 E8          	pop al
0107+  1464 09          	ret
0108+  1465             ispath_true:
0109+  1465 87 00       	and al, 0	; set zf
0110+  1467 E8          	pop al
0111+  1468 09          	ret
0112+  1469             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1469             ;; is space
0114+  1469             ;; sets zf according with result
0115+  1469             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1469             _isspace:
0117+  1469 B9 20       	cmp al, $20		; ' '
0118+  146B C6 7F 14    	je _isspace_exit
0119+  146E B9 09       	cmp al, $09		; '\t'
0120+  1470 C6 7F 14    	je _isspace_exit
0121+  1473 B9 0A       	cmp al, $0a		; '\n'
0122+  1475 C6 7F 14    	je _isspace_exit
0123+  1478 B9 0D       	cmp al, $0d		; '\r'
0124+  147A C6 7F 14    	je _isspace_exit
0125+  147D B9 0B       	cmp al, $0b		; '\v'
0126+  147F             _isspace_exit:
0127+  147F 09          	ret	
0128+  1480             
0129+  1480             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1480             ; to lower
0131+  1480             ; input in al
0132+  1480             ; output in al
0133+  1480             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1480             _to_lower:
0135+  1480 B9 7A       	cmp al, 'z'
0136+  1482 D1 87 14    	jgu _to_lower_ret
0137+  1485 6A 20       	add al, $20				; convert to lower case
0138+  1487             _to_lower_ret:
0139+  1487 09          	ret
0140+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1488             ; to upper
0142+  1488             ; input in al
0143+  1488             ; output in al
0144+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1488             _to_upper:
0146+  1488 B9 61       	cmp al, 'a'
0147+  148A C8 8F 14    	jlu _to_upper_ret
0148+  148D 6F 20       	sub al, $20			; convert to upper case
0149+  148F             _to_upper_ret:
0150+  148F 09          	ret
0151+  1490             
2753   1490             .include "lib/token.asm"
0001+  1490             toktyp_identifier  .equ 0
0002+  1490             toktyp_keyword     .equ 1
0003+  1490             toktyp_delimiter   .equ 2
0004+  1490             toktyp_string      .equ 3
0005+  1490             toktyp_char        .equ 4
0006+  1490             toktyp_numeric     .equ 5
0007+  1490             toktyp_end         .equ 6
0008+  1490             
0009+  1490             tok_null           .equ 0
0010+  1490             tok_fslash         .equ 1
0011+  1490             tok_times          .equ 2
0012+  1490             tok_plus           .equ 3
0013+  1490             tok_minus          .equ 4
0014+  1490             tok_dot            .equ 5
0015+  1490             tok_semi           .equ 6
0016+  1490             tok_angle          .equ 7
0017+  1490             tok_tilde          .equ 8
0018+  1490             tok_equal          .equ 9
0019+  1490             tok_colon          .equ 10
0020+  1490             tok_comma          .equ 11
0021+  1490             
0022+  1490             tok_end            .equ 20
0023+  1490             
0024+  1490             
0025+  1490             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1490             ;; read a full command argment from shell input buffer
0027+  1490             ;; argument is written into tokstr
0028+  1490             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1490             get_arg:
0030+  1490 D7            push a
0031+  1491 E2            push si
0032+  1492 E3            push di
0033+  1493 19 00         mov al, 0
0034+  1495 3D BE 16      mov [tokstr], al      ; nullify tokstr string
0035+  1498 14 BA 16      mov a, [prog]
0036+  149B 4D            mov si, a
0037+  149C FD 4F BE 16   mov di, tokstr
0038+  14A0             get_arg_skip_spaces:
0039+  14A0 F6            lodsb
0040+  14A1 07 69 14      call _isspace
0041+  14A4 C6 A0 14      je get_arg_skip_spaces
0042+  14A7             get_arg_l0:
0043+  14A7 B9 3B         cmp al, $3b        ; check if is ';'
0044+  14A9 C6 B6 14      je get_arg_end
0045+  14AC B9 00         cmp al, 0
0046+  14AE C6 B6 14      je get_arg_end      ; check if end of input
0047+  14B1 F7            stosb
0048+  14B2 F6            lodsb
0049+  14B3 0A A7 14      jmp get_arg_l0
0050+  14B6             get_arg_end:
0051+  14B6 19 00         mov al, 0
0052+  14B8 F7            stosb
0053+  14B9 D5 01 00      sub si, 1
0054+  14BC 4E            mov a, si
0055+  14BD 42 BA 16      mov [prog], a    ; update pointer
0056+  14C0 F0            pop di
0057+  14C1 EF            pop si
0058+  14C2 E4            pop a
0059+  14C3 09            ret
0060+  14C4             
0061+  14C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  14C4             ;; read a path formation from shell input buffer
0063+  14C4             ;; path is written into tokstr
0064+  14C4             ;; /usr/bin
0065+  14C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  14C4             get_path:
0067+  14C4 D7            push a
0068+  14C5 E2            push si
0069+  14C6 E3            push di
0070+  14C7 19 00         mov al, 0
0071+  14C9 3D BE 16      mov [tokstr], al      ; nullify tokstr string
0072+  14CC 14 BA 16      mov a, [prog]
0073+  14CF 4D            mov si, a
0074+  14D0 FD 4F BE 16   mov di, tokstr
0075+  14D4             get_path_skip_spaces:
0076+  14D4 F6            lodsb
0077+  14D5 07 69 14      call _isspace
0078+  14D8 C6 D4 14      je get_path_skip_spaces
0079+  14DB             get_path_is_pathchar:
0080+  14DB F7            stosb
0081+  14DC F6            lodsb
0082+  14DD 07 F3 13      call _isalnum      ;check if is alphanumeric
0083+  14E0 C6 DB 14      je get_path_is_pathchar
0084+  14E3 B9 2F         cmp al, '/'        ; check if is '/'
0085+  14E5 C6 DB 14      je get_path_is_pathchar
0086+  14E8 19 00         mov al, 0
0087+  14EA F7            stosb
0088+  14EB D5 01 00      sub si, 1
0089+  14EE 4E            mov a, si
0090+  14EF 42 BA 16      mov [prog], a    ; update pointer
0091+  14F2             get_path_end:
0092+  14F2 F0            pop di
0093+  14F3 EF            pop si
0094+  14F4 E4            pop a
0095+  14F5 09            ret
0096+  14F6             
0097+  14F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14F6             ;; read a line
0099+  14F6             ;; line is written into tokstr
0100+  14F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14F6             get_line:
0102+  14F6 D7            push a
0103+  14F7 E2            push si
0104+  14F8 E3            push di
0105+  14F9 19 00         mov al, 0
0106+  14FB 3D BE 16      mov [tokstr], al      ; nullify tokstr string
0107+  14FE 14 BA 16      mov a, [prog]
0108+  1501 4D            mov si, a
0109+  1502 FD 4F BE 16   mov di, tokstr
0110+  1506             get_line_l0:
0111+  1506 F6            lodsb
0112+  1507 B9 0A         cmp al, $0a    ; check for new line
0113+  1509 C6 10 15      je get_line_exit
0114+  150C F7            stosb
0115+  150D 0A 06 15      jmp get_line_l0
0116+  1510             get_line_exit:
0117+  1510 19 00         mov al, 0
0118+  1512 F7            stosb
0119+  1513 4E            mov a, si
0120+  1514 42 BA 16      mov [prog], a    ; update pointer
0121+  1517 F0            pop di
0122+  1518 EF            pop si
0123+  1519 E4            pop a
0124+  151A 09            ret
0125+  151B             
0126+  151B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  151B             ;; token parser
0128+  151B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  151B             get_token:
0130+  151B D7            push a
0131+  151C DA            push d
0132+  151D E2            push si
0133+  151E E3            push di
0134+  151F 19 00         mov al, 0
0135+  1521 3D BE 16      mov [tokstr], al      ; nullify tokstr string
0136+  1524 19 00         mov al, tok_null
0137+  1526 3D BD 16      mov [tok], al        ; nullify token
0138+  1529 14 BA 16      mov a, [prog]
0139+  152C 4D            mov si, a
0140+  152D FD 4F BE 16   mov di, tokstr
0141+  1531             get_tok_skip_spaces:
0142+  1531 F6            lodsb
0143+  1532 07 69 14      call _isspace
0144+  1535 C6 31 15      je get_tok_skip_spaces
0145+  1538 B9 00         cmp al, 0      ; check for end of input (null)
0146+  153A C6 1F 16      je get_token_end
0147+  153D B9 23         cmp al, '#'      ; comments!
0148+  153F C6 4D 16      je get_tok_comment
0149+  1542 07 F3 13      call _isalnum
0150+  1545 C6 2C 16      jz is_alphanumeric
0151+  1548             ; other token types
0152+  1548             get_token_slash:
0153+  1548 B9 2F         cmp al, '/'        ; check if '/'
0154+  154A C7 62 15      jne get_token_minus
0155+  154D F7            stosb          ; store '/' into token string
0156+  154E 19 00         mov al, 0
0157+  1550 F7            stosb          ; terminate token string
0158+  1551 19 01         mov al, tok_fslash
0159+  1553 3D BD 16      mov [tok], al      
0160+  1556 19 02         mov al, toktyp_delimiter
0161+  1558 3D BC 16      mov [toktyp], al
0162+  155B 4E            mov a, si
0163+  155C 42 BA 16      mov [prog], a    ; update pointer
0164+  155F 0A 48 16      jmp get_token_return
0165+  1562             get_token_minus:
0166+  1562 B9 2D         cmp al, '-'        ; check if '-'
0167+  1564 C7 7C 15      jne get_token_comma
0168+  1567 F7            stosb          ; store '-' into token string
0169+  1568 19 00         mov al, 0
0170+  156A F7            stosb          ; terminate token string
0171+  156B 19 04         mov al, tok_minus
0172+  156D 3D BD 16      mov [tok], al      
0173+  1570 19 02         mov al, toktyp_delimiter
0174+  1572 3D BC 16      mov [toktyp], al
0175+  1575 4E            mov a, si
0176+  1576 42 BA 16      mov [prog], a    ; update pointer
0177+  1579 0A 48 16      jmp get_token_return
0178+  157C             get_token_comma:
0179+  157C B9 2C         cmp al, ','        ; check if ','
0180+  157E C7 96 15      jne get_token_semi
0181+  1581 F7            stosb          ; store ',' into token string
0182+  1582 19 00         mov al, 0
0183+  1584 F7            stosb          ; terminate token string
0184+  1585 19 0B         mov al, tok_comma
0185+  1587 3D BD 16      mov [tok], al      
0186+  158A 19 02         mov al, toktyp_delimiter
0187+  158C 3D BC 16      mov [toktyp], al
0188+  158F 4E            mov a, si
0189+  1590 42 BA 16      mov [prog], a    ; update pointer
0190+  1593 0A 48 16      jmp get_token_return
0191+  1596             get_token_semi:
0192+  1596 B9 3B         cmp al, $3b        ; check if ';'
0193+  1598 C7 B0 15      jne get_token_colon
0194+  159B F7            stosb          ; store ';' into token string
0195+  159C 19 00         mov al, 0
0196+  159E F7            stosb          ; terminate token string
0197+  159F 19 06         mov al, tok_semi
0198+  15A1 3D BD 16      mov [tok], al      
0199+  15A4 19 02         mov al, toktyp_delimiter
0200+  15A6 3D BC 16      mov [toktyp], al
0201+  15A9 4E            mov a, si
0202+  15AA 42 BA 16      mov [prog], a    ; update pointer
0203+  15AD 0A 48 16      jmp get_token_return
0204+  15B0             get_token_colon:
0205+  15B0 B9 3A         cmp al, $3a        ; check if ':'
0206+  15B2 C7 CA 15      jne get_token_angle
0207+  15B5 F7            stosb          ; store ':' into token string
0208+  15B6 19 00         mov al, 0
0209+  15B8 F7            stosb          ; terminate token string
0210+  15B9 19 0A         mov al, tok_colon
0211+  15BB 3D BD 16      mov [tok], al      
0212+  15BE 19 02         mov al, toktyp_delimiter
0213+  15C0 3D BC 16      mov [toktyp], al
0214+  15C3 4E            mov a, si
0215+  15C4 42 BA 16      mov [prog], a    ; update pointer
0216+  15C7 0A 48 16      jmp get_token_return
0217+  15CA             get_token_angle:
0218+  15CA B9 3E         cmp al, $3e        ; check if '>'
0219+  15CC C7 E4 15      jne get_token_tilde
0220+  15CF F7            stosb          ; store '>' into token string
0221+  15D0 19 00         mov al, 0
0222+  15D2 F7            stosb          ; terminate token string
0223+  15D3 19 07         mov al, tok_angle
0224+  15D5 3D BD 16      mov [tok], al      
0225+  15D8 19 02         mov al, toktyp_delimiter
0226+  15DA 3D BC 16      mov [toktyp], al
0227+  15DD 4E            mov a, si
0228+  15DE 42 BA 16      mov [prog], a    ; update pointer
0229+  15E1 0A 48 16      jmp get_token_return
0230+  15E4             get_token_tilde:
0231+  15E4 B9 7E         cmp al, '~'        ; check if '~'
0232+  15E6 C7 FE 15      jne get_token_equal
0233+  15E9 F7            stosb          ; store '~' into token string
0234+  15EA 19 00         mov al, 0
0235+  15EC F7            stosb          ; terminate token string
0236+  15ED 19 08         mov al, tok_tilde
0237+  15EF 3D BD 16      mov [tok], al      
0238+  15F2 19 02         mov al, toktyp_delimiter
0239+  15F4 3D BC 16      mov [toktyp], al
0240+  15F7 4E            mov a, si
0241+  15F8 42 BA 16      mov [prog], a    ; update pointer
0242+  15FB 0A 48 16      jmp get_token_return
0243+  15FE             get_token_equal:
0244+  15FE B9 3D         cmp al, '='        ; check if '='
0245+  1600 C7 18 16      jne get_token_skip
0246+  1603 F7            stosb          ; store '=' into token string
0247+  1604 19 00         mov al, 0
0248+  1606 F7            stosb          ; terminate token string
0249+  1607 19 09         mov al, tok_equal
0250+  1609 3D BD 16      mov [tok], al      
0251+  160C 19 02         mov al, toktyp_delimiter
0252+  160E 3D BC 16      mov [toktyp], al
0253+  1611 4E            mov a, si
0254+  1612 42 BA 16      mov [prog], a    ; update pointer
0255+  1615 0A 48 16      jmp get_token_return
0256+  1618             get_token_skip:
0257+  1618 4E            mov a, si
0258+  1619 42 BA 16      mov [prog], a    ; update pointer
0259+  161C 0A 48 16      jmp get_token_return
0260+  161F             get_token_end:        ; end of file token
0261+  161F 19 14         mov al, tok_end
0262+  1621 3D BD 16      mov [tok], al
0263+  1624 19 06         mov al, toktyp_end
0264+  1626 3D BC 16      mov [toktyp], al
0265+  1629 0A 48 16      jmp get_token_return
0266+  162C             is_alphanumeric:
0267+  162C F7            stosb
0268+  162D F6            lodsb
0269+  162E 07 F3 13      call _isalnum      ;check if is alphanumeric
0270+  1631 C6 2C 16      jz is_alphanumeric
0271+  1634 B9 2E         cmp al, $2e        ; check if is '.'
0272+  1636 C6 2C 16      je is_alphanumeric
0273+  1639 19 00         mov al, 0
0274+  163B F7            stosb
0275+  163C 19 00         mov al, toktyp_identifier
0276+  163E 3D BC 16      mov [toktyp], al
0277+  1641 D5 01 00      sub si, 1
0278+  1644 4E            mov a, si
0279+  1645 42 BA 16      mov [prog], a    ; update pointer
0280+  1648             get_token_return:
0281+  1648 F0            pop di
0282+  1649 EF            pop si
0283+  164A E7            pop d
0284+  164B E4            pop a
0285+  164C 09            ret
0286+  164D             get_tok_comment:
0287+  164D F6            lodsb
0288+  164E B9 0A         cmp al, $0a      ; new line
0289+  1650 C7 4D 16      jne get_tok_comment
0290+  1653 0A 31 15      jmp get_tok_skip_spaces
0291+  1656             
0292+  1656             
0293+  1656             get_number:
0294+  1656 D7            push a
0295+  1657 DA            push d
0296+  1658 E2            push si
0297+  1659 E3            push di
0298+  165A 19 00         mov al, 0
0299+  165C 3D BE 16      mov [tokstr], al      ; nullify tokstr string
0300+  165F 19 00         mov al, tok_null
0301+  1661 3D BD 16      mov [tok], al        ; nullify token
0302+  1664 14 BA 16      mov a, [prog]
0303+  1667 4D            mov si, a
0304+  1668 FD 4F BE 16   mov di, tokstr
0305+  166C             get_number_skip_spaces:
0306+  166C F6            lodsb
0307+  166D 07 69 14      call _isspace
0308+  1670 C6 6C 16      je get_number_skip_spaces
0309+  1673 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1675 C7 85 16      jne get_number_l0
0311+  1678 19 14         mov al, tok_end
0312+  167A 3D BD 16      mov [tok], al
0313+  167D 19 06         mov al, toktyp_end
0314+  167F 3D BC 16      mov [toktyp], al
0315+  1682 0A 9C 16      jmp get_number_return
0316+  1685             get_number_l0:
0317+  1685 F7            stosb
0318+  1686 F6            lodsb
0319+  1687 07 FD 13      call _isdigit      ;check if is numeric
0320+  168A C6 85 16      jz get_number_l0
0321+  168D 19 00         mov al, 0
0322+  168F F7            stosb
0323+  1690 19 05         mov al, toktyp_numeric
0324+  1692 3D BC 16      mov [toktyp], al
0325+  1695 D5 01 00      sub si, 1
0326+  1698 4E            mov a, si
0327+  1699 42 BA 16      mov [prog], a    ; update pointer
0328+  169C             get_number_return:
0329+  169C F0            pop di
0330+  169D EF            pop si
0331+  169E E7            pop d
0332+  169F E4            pop a
0333+  16A0 09            ret
0334+  16A1             
0335+  16A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  16A1             ;; put back token
0337+  16A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  16A1             _putback:
0339+  16A1 D7            push a
0340+  16A2 E2            push si
0341+  16A3 FD 4D BE 16   mov si, tokstr  
0342+  16A7             _putback_loop:
0343+  16A7 F6            lodsb
0344+  16A8 B9 00         cmp al, 0
0345+  16AA C6 B7 16      je _putback_end
0346+  16AD 14 BA 16      mov a, [prog]
0347+  16B0 7D            dec a
0348+  16B1 42 BA 16      mov [prog], a      ; update pointer
0349+  16B4 0A A7 16      jmp _putback_loop
0350+  16B7             _putback_end:
0351+  16B7 EF            pop si
0352+  16B8 E4            pop a
0353+  16B9 09            ret
0354+  16BA             
0355+  16BA             
0356+  16BA             
0357+  16BA             
0358+  16BA 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  16BC             
0360+  16BC 00          toktyp:    .db 0          ; token type symbol
0361+  16BD 00          tok:       .db 0          ; current token symbol
0362+  16BE 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  16C2 00 00 00 00 
0362+  16C6 00 00 00 00 
0362+  16CA 00 00 00 00 
0362+  16CE 00 00 00 00 
0362+  16D2 00 00 00 00 
0362+  16D6 00 00 00 00 
0362+  16DA 00 00 00 00 
0362+  16DE 00 00 00 00 
0362+  16E2 00 00 00 00 
0362+  16E6 00 00 00 00 
0362+  16EA 00 00 00 00 
0362+  16EE 00 00 00 00 
0362+  16F2 00 00 00 00 
0362+  16F6 00 00 00 00 
0362+  16FA 00 00 00 00 
0362+  16FE 00 00 00 00 
0362+  1702 00 00 00 00 
0362+  1706 00 00 00 00 
0362+  170A 00 00 00 00 
0362+  170E 00 00 00 00 
0362+  1712 00 00 00 00 
0362+  1716 00 00 00 00 
0362+  171A 00 00 00 00 
0362+  171E 00 00 00 00 
0362+  1722 00 00 00 00 
0362+  1726 00 00 00 00 
0362+  172A 00 00 00 00 
0362+  172E 00 00 00 00 
0362+  1732 00 00 00 00 
0362+  1736 00 00 00 00 
0362+  173A 00 00 00 00 
0362+  173E 00 00 00 00 
0362+  1742 00 00 00 00 
0362+  1746 00 00 00 00 
0362+  174A 00 00 00 00 
0362+  174E 00 00 00 00 
0362+  1752 00 00 00 00 
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
0362+  176E 00 00 00 00 
0362+  1772 00 00 00 00 
0362+  1776 00 00 00 00 
0362+  177A 00 00 00 00 
0362+  177E 00 00 00 00 
0362+  1782 00 00 00 00 
0362+  1786 00 00 00 00 
0362+  178A 00 00 00 00 
0362+  178E 00 00 00 00 
0362+  1792 00 00 00 00 
0362+  1796 00 00 00 00 
0362+  179A 00 00 00 00 
0362+  179E 00 00 00 00 
0362+  17A2 00 00 00 00 
0362+  17A6 00 00 00 00 
0362+  17AA 00 00 00 00 
0362+  17AE 00 00 00 00 
0362+  17B2 00 00 00 00 
0362+  17B6 00 00 00 00 
0362+  17BA 00 00 00 00 
2754   17BE             
2755   17BE             ; kernel parameters
2756   17BE             sys_debug_mode:
2757   17BE 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2758   17BF             sys_echo_on:
2759   17BF 01            .db 1
2760   17C0             sys_uart0_lcr:
2761   17C0 07            .db $07 ; 8 data bits, 2 stop bit, no parity
2762   17C1             sys_uart0_inten:
2763   17C1 01            .db 1
2764   17C2             sys_uart0_fifoen:
2765   17C2 00            .db 0
2766   17C3             sys_uart0_div0:
2767   17C3 0C            .db 12  ;
2768   17C4             sys_uart0_div1:
2769   17C4 00            .db 0   ; default baud = 9600
2770   17C5             ; baud  divisor
2771   17C5             ; 50    2304
2772   17C5             ; 110   1047
2773   17C5             ; 300    384
2774   17C5             ; 600    192
2775   17C5             ; 1200    96
2776   17C5             ; 9600    12
2777   17C5             ; 19200    6
2778   17C5             ; 38400    3
2779   17C5             
2780   17C5             nbr_active_procs:
2781   17C5 00            .db 0
2782   17C6             active_proc_index:
2783   17C6 01            .db 1
2784   17C7             
2785   17C7             index:
2786   17C7 00 00         .dw 0
2787   17C9             buffer_addr:
2788   17C9 00 00         .dw 0
2789   17CB             
2790   17CB             fifo_in:
2791   17CB 2C 1F         .dw fifo
2792   17CD             fifo_out:
2793   17CD 2C 1F         .dw fifo
2794   17CF             
2795   17CF             ; file system variables
2796   17CF             current_dir_id:
2797   17CF 00 00         .dw 0     ; keep dirid of current directory
2798   17D1             s_init_path:
2799   17D1 2F 73 62 69   .db "/sbin/init", 0
2799   17D5 6E 2F 69 6E 
2799   17D9 69 74 00 
2800   17DC             
2801   17DC             s_uname:
2802   17DC 73 6F 6C 61   .db "solarium v.1.0", 0
2802   17E0 72 69 75 6D 
2802   17E4 20 76 2E 31 
2802   17E8 2E 30 00 
2803   17EB             s_dataentry:
2804   17EB 3E 20 00      .db "> ", 0
2805   17EE             s_parent_dir:
2806   17EE 2E 2E 00      .db "..", 0
2807   17F1             s_current_dir:
2808   17F1 2E 00         .db ".", 0
2809   17F3             s_fslash:
2810   17F3 2F 00         .db "/", 0
2811   17F5             file_attrib:
2812   17F5 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2812   17F9 78 
2813   17FA             file_type:
2814   17FA 2D 64 63      .db "-dc"
2815   17FD             s_ps_header:
2816   17FD 70 69 64 20   .db "pid command\n", 0
2816   1801 63 6F 6D 6D 
2816   1805 61 6E 64 0A 
2816   1809 00 
2817   180A             s_ls_total:
2818   180A 74 6F 74 61   .db "total: ", 0
2818   180E 6C 3A 20 00 
2819   1812             
2820   1812             s_int_en:
2821   1812 69 72 71 73   .db "irqs enabled\n", 0
2821   1816 20 65 6E 61 
2821   181A 62 6C 65 64 
2821   181E 0A 00 
2822   1820             s_kernel_started:
2823   1820 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2823   1824 65 6C 20 73 
2823   1828 74 61 72 74 
2823   182C 65 64 28 76 
2823   1830 65 72 73 69 
2823   1834 6F 6E 20 31 
2823   1838 2E 30 29 0A 
2823   183C 00 
2824   183D             s_prompt_init:
2825   183D 73 74 61 72   .db "starting init\n", 0
2825   1841 74 69 6E 67 
2825   1845 20 69 6E 69 
2825   1849 74 0A 00 
2826   184C             s_priviledge:
2827   184C 0A 65 78 63   .db "\nexception: privilege\n", 0
2827   1850 65 70 74 69 
2827   1854 6F 6E 3A 20 
2827   1858 70 72 69 76 
2827   185C 69 6C 65 67 
2827   1860 65 0A 00 
2828   1863             s_divzero:
2829   1863 0A 65 78 63   .db "\nexception: zero division\n", 0
2829   1867 65 70 74 69 
2829   186B 6F 6E 3A 20 
2829   186F 7A 65 72 6F 
2829   1873 20 64 69 76 
2829   1877 69 73 69 6F 
2829   187B 6E 0A 00 
2830   187E             
2831   187E             s_set_year:
2832   187E 79 65 61 72   .db "year: ", 0
2832   1882 3A 20 00 
2833   1885             s_set_month:
2834   1885 6D 6F 6E 74   .db "month: ", 0
2834   1889 68 3A 20 00 
2835   188D             s_set_day:
2836   188D 64 61 79 3A   .db "day: ", 0
2836   1891 20 00 
2837   1893             s_set_week:
2838   1893 77 65 65 6B   .db "weekday: ", 0
2838   1897 64 61 79 3A 
2838   189B 20 00 
2839   189D             s_set_hours:
2840   189D 68 6F 75 72   .db "hours: ", 0
2840   18A1 73 3A 20 00 
2841   18A5             s_set_minutes:
2842   18A5 6D 69 6E 75   .db "minutes: ", 0
2842   18A9 74 65 73 3A 
2842   18AD 20 00 
2843   18AF             s_set_seconds:
2844   18AF 73 65 63 6F   .db "seconds: ", 0
2844   18B3 6E 64 73 3A 
2844   18B7 20 00 
2845   18B9             s_months:      
2846   18B9 20 20 20 00   .db "   ", 0
2847   18BD 6A 61 6E 00   .db "jan", 0
2848   18C1 66 65 62 00   .db "feb", 0
2849   18C5 6D 61 72 00   .db "mar", 0
2850   18C9 61 70 72 00   .db "apr", 0
2851   18CD 6D 61 79 00   .db "may", 0
2852   18D1 6A 75 6E 00   .db "jun", 0
2853   18D5 6A 75 6C 00   .db "jul", 0
2854   18D9 61 75 67 00   .db "aug", 0
2855   18DD 73 65 70 00   .db "sep", 0
2856   18E1 6F 63 74 00   .db "oct", 0
2857   18E5 6E 6F 76 00   .db "nov", 0
2858   18E9 64 65 63 00   .db "dec", 0
2859   18ED             
2860   18ED             s_week:        
2861   18ED 73 75 6E 00   .db "sun", 0 
2862   18F1 6D 6F 6E 00   .db "mon", 0 
2863   18F5 74 75 65 00   .db "tue", 0 
2864   18F9 77 65 64 00   .db "wed", 0 
2865   18FD 74 68 75 00   .db "thu", 0 
2866   1901 66 72 69 00   .db "fri", 0 
2867   1905 73 61 74 00   .db "sat", 0
2868   1909             
2869   1909 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2869   190D 30 20 45 78 
2869   1911 65 63 75 74 
2869   1915 65 64 2E 0A 
2869   1919 00 
2870   191A             s_fdc_config:
2871   191A 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2871   191E 65 63 74 69 
2871   1922 6E 67 20 64 
2871   1926 69 73 6B 65 
2871   192A 74 74 65 20 
2871   192E 64 72 69 76 
2871   1932 65 20 30 2C 
2871   1936 20 73 69 64 
2871   193A 65 20 30 2C 
2871   193E 20 73 69 6E 
2871   1942 67 6C 65 20 
2871   1946 64 65 6E 73 
2871   194A 69 74 79 2C 
2871   194E 20 68 65 61 
2871   1952 64 20 6C 6F 
2871   1956 61 64 65 64 
2871   195A 0A 00 
2872   195C             
2873   195C             proc_state_table:   
2874   195C 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2874   1960 00 00 00 00 
2874   1964 00 00 00 00 
2874   1968 00 00 00 00 
2874   196C 00 00 00 00 
2874   1970 00 00 00 00 
2874   1974 00 00 00 00 
2874   1978 00 00 00 00 
2874   197C 00 00 00 00 
2874   1980 00 00 00 00 
2874   1984 00 00 00 00 
2874   1988 00 00 00 00 
2874   198C 00 00 00 00 
2874   1990 00 00 00 00 
2874   1994 00 00 00 00 
2874   1998 00 00 00 00 
2874   199C 00 00 00 00 
2874   19A0 00 00 00 00 
2874   19A4 00 00 00 00 
2874   19A8 00 00 00 00 
2874   19AC 00 00 00 00 
2874   19B0 00 00 00 00 
2874   19B4 00 00 00 00 
2874   19B8 00 00 00 00 
2874   19BC 00 00 00 00 
2874   19C0 00 00 00 00 
2874   19C4 00 00 00 00 
2874   19C8 00 00 00 00 
2874   19CC 00 00 00 00 
2874   19D0 00 00 00 00 
2874   19D4 00 00 00 00 
2874   19D8 00 00 00 00 
2874   19DC 00 00 00 00 
2874   19E0 00 00 00 00 
2874   19E4 00 00 00 00 
2874   19E8 00 00 00 00 
2874   19EC 00 00 00 00 
2874   19F0 00 00 00 00 
2874   19F4 00 00 00 00 
2874   19F8 00 00 00 00 
2874   19FC 00 00 00 00 
2874   1A00 00 00 00 00 
2874   1A04 00 00 00 00 
2874   1A08 00 00 00 00 
2874   1A0C 00 00 00 00 
2874   1A10 00 00 00 00 
2874   1A14 00 00 00 00 
2874   1A18 00 00 00 00 
2874   1A1C 00 00 00 00 
2874   1A20 00 00 00 00 
2874   1A24 00 00 00 00 
2874   1A28 00 00 00 00 
2874   1A2C 00 00 00 00 
2874   1A30 00 00 00 00 
2874   1A34 00 00 00 00 
2874   1A38 00 00 00 00 
2874   1A3C 00 00 00 00 
2874   1A40 00 00 00 00 
2874   1A44 00 00 00 00 
2874   1A48 00 00 00 00 
2874   1A4C 00 00 00 00 
2874   1A50 00 00 00 00 
2874   1A54 00 00 00 00 
2874   1A58 00 00 00 00 
2874   1A5C 00 00 00 00 
2874   1A60 00 00 00 00 
2874   1A64 00 00 00 00 
2874   1A68 00 00 00 00 
2874   1A6C 00 00 00 00 
2874   1A70 00 00 00 00 
2874   1A74 00 00 00 00 
2874   1A78 00 00 00 00 
2874   1A7C 00 00 00 00 
2874   1A80 00 00 00 00 
2874   1A84 00 00 00 00 
2874   1A88 00 00 00 00 
2874   1A8C 00 00 00 00 
2874   1A90 00 00 00 00 
2874   1A94 00 00 00 00 
2874   1A98 00 00 00 00 
2875   1A9C             proc_availab_table: 
2876   1A9C 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2876   1AA0 00 00 00 00 
2876   1AA4 00 00 00 00 
2876   1AA8 00 00 00 00 
2877   1AAC             proc_names:
2878   1AAC 00 00 00 00   .fill 16 * 32, 0  ; process names
2878   1AB0 00 00 00 00 
2878   1AB4 00 00 00 00 
2878   1AB8 00 00 00 00 
2878   1ABC 00 00 00 00 
2878   1AC0 00 00 00 00 
2878   1AC4 00 00 00 00 
2878   1AC8 00 00 00 00 
2878   1ACC 00 00 00 00 
2878   1AD0 00 00 00 00 
2878   1AD4 00 00 00 00 
2878   1AD8 00 00 00 00 
2878   1ADC 00 00 00 00 
2878   1AE0 00 00 00 00 
2878   1AE4 00 00 00 00 
2878   1AE8 00 00 00 00 
2878   1AEC 00 00 00 00 
2878   1AF0 00 00 00 00 
2878   1AF4 00 00 00 00 
2878   1AF8 00 00 00 00 
2878   1AFC 00 00 00 00 
2878   1B00 00 00 00 00 
2878   1B04 00 00 00 00 
2878   1B08 00 00 00 00 
2878   1B0C 00 00 00 00 
2878   1B10 00 00 00 00 
2878   1B14 00 00 00 00 
2878   1B18 00 00 00 00 
2878   1B1C 00 00 00 00 
2878   1B20 00 00 00 00 
2878   1B24 00 00 00 00 
2878   1B28 00 00 00 00 
2878   1B2C 00 00 00 00 
2878   1B30 00 00 00 00 
2878   1B34 00 00 00 00 
2878   1B38 00 00 00 00 
2878   1B3C 00 00 00 00 
2878   1B40 00 00 00 00 
2878   1B44 00 00 00 00 
2878   1B48 00 00 00 00 
2878   1B4C 00 00 00 00 
2878   1B50 00 00 00 00 
2878   1B54 00 00 00 00 
2878   1B58 00 00 00 00 
2878   1B5C 00 00 00 00 
2878   1B60 00 00 00 00 
2878   1B64 00 00 00 00 
2878   1B68 00 00 00 00 
2878   1B6C 00 00 00 00 
2878   1B70 00 00 00 00 
2878   1B74 00 00 00 00 
2878   1B78 00 00 00 00 
2878   1B7C 00 00 00 00 
2878   1B80 00 00 00 00 
2878   1B84 00 00 00 00 
2878   1B88 00 00 00 00 
2878   1B8C 00 00 00 00 
2878   1B90 00 00 00 00 
2878   1B94 00 00 00 00 
2878   1B98 00 00 00 00 
2878   1B9C 00 00 00 00 
2878   1BA0 00 00 00 00 
2878   1BA4 00 00 00 00 
2878   1BA8 00 00 00 00 
2878   1BAC 00 00 00 00 
2878   1BB0 00 00 00 00 
2878   1BB4 00 00 00 00 
2878   1BB8 00 00 00 00 
2878   1BBC 00 00 00 00 
2878   1BC0 00 00 00 00 
2878   1BC4 00 00 00 00 
2878   1BC8 00 00 00 00 
2878   1BCC 00 00 00 00 
2878   1BD0 00 00 00 00 
2878   1BD4 00 00 00 00 
2878   1BD8 00 00 00 00 
2878   1BDC 00 00 00 00 
2878   1BE0 00 00 00 00 
2878   1BE4 00 00 00 00 
2878   1BE8 00 00 00 00 
2878   1BEC 00 00 00 00 
2878   1BF0 00 00 00 00 
2878   1BF4 00 00 00 00 
2878   1BF8 00 00 00 00 
2878   1BFC 00 00 00 00 
2878   1C00 00 00 00 00 
2878   1C04 00 00 00 00 
2878   1C08 00 00 00 00 
2878   1C0C 00 00 00 00 
2878   1C10 00 00 00 00 
2878   1C14 00 00 00 00 
2878   1C18 00 00 00 00 
2878   1C1C 00 00 00 00 
2878   1C20 00 00 00 00 
2878   1C24 00 00 00 00 
2878   1C28 00 00 00 00 
2878   1C2C 00 00 00 00 
2878   1C30 00 00 00 00 
2878   1C34 00 00 00 00 
2878   1C38 00 00 00 00 
2878   1C3C 00 00 00 00 
2878   1C40 00 00 00 00 
2878   1C44 00 00 00 00 
2878   1C48 00 00 00 00 
2878   1C4C 00 00 00 00 
2878   1C50 00 00 00 00 
2878   1C54 00 00 00 00 
2878   1C58 00 00 00 00 
2878   1C5C 00 00 00 00 
2878   1C60 00 00 00 00 
2878   1C64 00 00 00 00 
2878   1C68 00 00 00 00 
2878   1C6C 00 00 00 00 
2878   1C70 00 00 00 00 
2878   1C74 00 00 00 00 
2878   1C78 00 00 00 00 
2878   1C7C 00 00 00 00 
2878   1C80 00 00 00 00 
2878   1C84 00 00 00 00 
2878   1C88 00 00 00 00 
2878   1C8C 00 00 00 00 
2878   1C90 00 00 00 00 
2878   1C94 00 00 00 00 
2878   1C98 00 00 00 00 
2878   1C9C 00 00 00 00 
2878   1CA0 00 00 00 00 
2878   1CA4 00 00 00 00 
2878   1CA8 00 00 00 00 
2879   1CAC             filename:
2880   1CAC 00 00 00 00   .fill 128, 0      ; holds a path for file search
2880   1CB0 00 00 00 00 
2880   1CB4 00 00 00 00 
2880   1CB8 00 00 00 00 
2880   1CBC 00 00 00 00 
2880   1CC0 00 00 00 00 
2880   1CC4 00 00 00 00 
2880   1CC8 00 00 00 00 
2880   1CCC 00 00 00 00 
2880   1CD0 00 00 00 00 
2880   1CD4 00 00 00 00 
2880   1CD8 00 00 00 00 
2880   1CDC 00 00 00 00 
2880   1CE0 00 00 00 00 
2880   1CE4 00 00 00 00 
2880   1CE8 00 00 00 00 
2880   1CEC 00 00 00 00 
2880   1CF0 00 00 00 00 
2880   1CF4 00 00 00 00 
2880   1CF8 00 00 00 00 
2880   1CFC 00 00 00 00 
2880   1D00 00 00 00 00 
2880   1D04 00 00 00 00 
2880   1D08 00 00 00 00 
2880   1D0C 00 00 00 00 
2880   1D10 00 00 00 00 
2880   1D14 00 00 00 00 
2880   1D18 00 00 00 00 
2880   1D1C 00 00 00 00 
2880   1D20 00 00 00 00 
2880   1D24 00 00 00 00 
2880   1D28 00 00 00 00 
2881   1D2C             user_data:
2882   1D2C 00 00 00 00   .fill 512, 0      ;  user space data
2882   1D30 00 00 00 00 
2882   1D34 00 00 00 00 
2882   1D38 00 00 00 00 
2882   1D3C 00 00 00 00 
2882   1D40 00 00 00 00 
2882   1D44 00 00 00 00 
2882   1D48 00 00 00 00 
2882   1D4C 00 00 00 00 
2882   1D50 00 00 00 00 
2882   1D54 00 00 00 00 
2882   1D58 00 00 00 00 
2882   1D5C 00 00 00 00 
2882   1D60 00 00 00 00 
2882   1D64 00 00 00 00 
2882   1D68 00 00 00 00 
2882   1D6C 00 00 00 00 
2882   1D70 00 00 00 00 
2882   1D74 00 00 00 00 
2882   1D78 00 00 00 00 
2882   1D7C 00 00 00 00 
2882   1D80 00 00 00 00 
2882   1D84 00 00 00 00 
2882   1D88 00 00 00 00 
2882   1D8C 00 00 00 00 
2882   1D90 00 00 00 00 
2882   1D94 00 00 00 00 
2882   1D98 00 00 00 00 
2882   1D9C 00 00 00 00 
2882   1DA0 00 00 00 00 
2882   1DA4 00 00 00 00 
2882   1DA8 00 00 00 00 
2882   1DAC 00 00 00 00 
2882   1DB0 00 00 00 00 
2882   1DB4 00 00 00 00 
2882   1DB8 00 00 00 00 
2882   1DBC 00 00 00 00 
2882   1DC0 00 00 00 00 
2882   1DC4 00 00 00 00 
2882   1DC8 00 00 00 00 
2882   1DCC 00 00 00 00 
2882   1DD0 00 00 00 00 
2882   1DD4 00 00 00 00 
2882   1DD8 00 00 00 00 
2882   1DDC 00 00 00 00 
2882   1DE0 00 00 00 00 
2882   1DE4 00 00 00 00 
2882   1DE8 00 00 00 00 
2882   1DEC 00 00 00 00 
2882   1DF0 00 00 00 00 
2882   1DF4 00 00 00 00 
2882   1DF8 00 00 00 00 
2882   1DFC 00 00 00 00 
2882   1E00 00 00 00 00 
2882   1E04 00 00 00 00 
2882   1E08 00 00 00 00 
2882   1E0C 00 00 00 00 
2882   1E10 00 00 00 00 
2882   1E14 00 00 00 00 
2882   1E18 00 00 00 00 
2882   1E1C 00 00 00 00 
2882   1E20 00 00 00 00 
2882   1E24 00 00 00 00 
2882   1E28 00 00 00 00 
2882   1E2C 00 00 00 00 
2882   1E30 00 00 00 00 
2882   1E34 00 00 00 00 
2882   1E38 00 00 00 00 
2882   1E3C 00 00 00 00 
2882   1E40 00 00 00 00 
2882   1E44 00 00 00 00 
2882   1E48 00 00 00 00 
2882   1E4C 00 00 00 00 
2882   1E50 00 00 00 00 
2882   1E54 00 00 00 00 
2882   1E58 00 00 00 00 
2882   1E5C 00 00 00 00 
2882   1E60 00 00 00 00 
2882   1E64 00 00 00 00 
2882   1E68 00 00 00 00 
2882   1E6C 00 00 00 00 
2882   1E70 00 00 00 00 
2882   1E74 00 00 00 00 
2882   1E78 00 00 00 00 
2882   1E7C 00 00 00 00 
2882   1E80 00 00 00 00 
2882   1E84 00 00 00 00 
2882   1E88 00 00 00 00 
2882   1E8C 00 00 00 00 
2882   1E90 00 00 00 00 
2882   1E94 00 00 00 00 
2882   1E98 00 00 00 00 
2882   1E9C 00 00 00 00 
2882   1EA0 00 00 00 00 
2882   1EA4 00 00 00 00 
2882   1EA8 00 00 00 00 
2882   1EAC 00 00 00 00 
2882   1EB0 00 00 00 00 
2882   1EB4 00 00 00 00 
2882   1EB8 00 00 00 00 
2882   1EBC 00 00 00 00 
2882   1EC0 00 00 00 00 
2882   1EC4 00 00 00 00 
2882   1EC8 00 00 00 00 
2882   1ECC 00 00 00 00 
2882   1ED0 00 00 00 00 
2882   1ED4 00 00 00 00 
2882   1ED8 00 00 00 00 
2882   1EDC 00 00 00 00 
2882   1EE0 00 00 00 00 
2882   1EE4 00 00 00 00 
2882   1EE8 00 00 00 00 
2882   1EEC 00 00 00 00 
2882   1EF0 00 00 00 00 
2882   1EF4 00 00 00 00 
2882   1EF8 00 00 00 00 
2882   1EFC 00 00 00 00 
2882   1F00 00 00 00 00 
2882   1F04 00 00 00 00 
2882   1F08 00 00 00 00 
2882   1F0C 00 00 00 00 
2882   1F10 00 00 00 00 
2882   1F14 00 00 00 00 
2882   1F18 00 00 00 00 
2882   1F1C 00 00 00 00 
2882   1F20 00 00 00 00 
2882   1F24 00 00 00 00 
2882   1F28 00 00 00 00 
2883   1F2C             fifo:
2884   1F2C FF FF FF FF   .fill fifo_size
2884   1F30 FF FF FF FF 
2884   1F34 FF FF FF FF 
2884   1F38 FF FF FF FF 
2884   1F3C FF FF FF FF 
2884   1F40 FF FF FF FF 
2884   1F44 FF FF FF FF 
2884   1F48 FF FF FF FF 
2884   1F4C FF FF FF FF 
2884   1F50 FF FF FF FF 
2884   1F54 FF FF FF FF 
2884   1F58 FF FF FF FF 
2884   1F5C FF FF FF FF 
2884   1F60 FF FF FF FF 
2884   1F64 FF FF FF FF 
2884   1F68 FF FF FF FF 
2884   1F6C FF FF FF FF 
2884   1F70 FF FF FF FF 
2884   1F74 FF FF FF FF 
2884   1F78 FF FF FF FF 
2884   1F7C FF FF FF FF 
2884   1F80 FF FF FF FF 
2884   1F84 FF FF FF FF 
2884   1F88 FF FF FF FF 
2884   1F8C FF FF FF FF 
2884   1F90 FF FF FF FF 
2884   1F94 FF FF FF FF 
2884   1F98 FF FF FF FF 
2884   1F9C FF FF FF FF 
2884   1FA0 FF FF FF FF 
2884   1FA4 FF FF FF FF 
2884   1FA8 FF FF FF FF 
2884   1FAC FF FF FF FF 
2884   1FB0 FF FF FF FF 
2884   1FB4 FF FF FF FF 
2884   1FB8 FF FF FF FF 
2884   1FBC FF FF FF FF 
2884   1FC0 FF FF FF FF 
2884   1FC4 FF FF FF FF 
2884   1FC8 FF FF FF FF 
2884   1FCC FF FF FF FF 
2884   1FD0 FF FF FF FF 
2884   1FD4 FF FF FF FF 
2884   1FD8 FF FF FF FF 
2884   1FDC FF FF FF FF 
2884   1FE0 FF FF FF FF 
2884   1FE4 FF FF FF FF 
2884   1FE8 FF FF FF FF 
2884   1FEC FF FF FF FF 
2884   1FF0 FF FF FF FF 
2884   1FF4 FF FF FF FF 
2884   1FF8 FF FF FF FF 
2884   1FFC FF FF FF FF 
2884   2000 FF FF FF FF 
2884   2004 FF FF FF FF 
2884   2008 FF FF FF FF 
2884   200C FF FF FF FF 
2884   2010 FF FF FF FF 
2884   2014 FF FF FF FF 
2884   2018 FF FF FF FF 
2884   201C FF FF FF FF 
2884   2020 FF FF FF FF 
2884   2024 FF FF FF FF 
2884   2028 FF FF FF FF 
2884   202C FF FF FF FF 
2884   2030 FF FF FF FF 
2884   2034 FF FF FF FF 
2884   2038 FF FF FF FF 
2884   203C FF FF FF FF 
2884   2040 FF FF FF FF 
2884   2044 FF FF FF FF 
2884   2048 FF FF FF FF 
2884   204C FF FF FF FF 
2884   2050 FF FF FF FF 
2884   2054 FF FF FF FF 
2884   2058 FF FF FF FF 
2884   205C FF FF FF FF 
2884   2060 FF FF FF FF 
2884   2064 FF FF FF FF 
2884   2068 FF FF FF FF 
2884   206C FF FF FF FF 
2884   2070 FF FF FF FF 
2884   2074 FF FF FF FF 
2884   2078 FF FF FF FF 
2884   207C FF FF FF FF 
2884   2080 FF FF FF FF 
2884   2084 FF FF FF FF 
2884   2088 FF FF FF FF 
2884   208C FF FF FF FF 
2884   2090 FF FF FF FF 
2884   2094 FF FF FF FF 
2884   2098 FF FF FF FF 
2884   209C FF FF FF FF 
2884   20A0 FF FF FF FF 
2884   20A4 FF FF FF FF 
2884   20A8 FF FF FF FF 
2884   20AC FF FF FF FF 
2884   20B0 FF FF FF FF 
2884   20B4 FF FF FF FF 
2884   20B8 FF FF FF FF 
2884   20BC FF FF FF FF 
2884   20C0 FF FF FF FF 
2884   20C4 FF FF FF FF 
2884   20C8 FF FF FF FF 
2884   20CC FF FF FF FF 
2884   20D0 FF FF FF FF 
2884   20D4 FF FF FF FF 
2884   20D8 FF FF FF FF 
2884   20DC FF FF FF FF 
2884   20E0 FF FF FF FF 
2884   20E4 FF FF FF FF 
2884   20E8 FF FF FF FF 
2884   20EC FF FF FF FF 
2884   20F0 FF FF FF FF 
2884   20F4 FF FF FF FF 
2884   20F8 FF FF FF FF 
2884   20FC FF FF FF FF 
2884   2100 FF FF FF FF 
2884   2104 FF FF FF FF 
2884   2108 FF FF FF FF 
2884   210C FF FF FF FF 
2884   2110 FF FF FF FF 
2884   2114 FF FF FF FF 
2884   2118 FF FF FF FF 
2884   211C FF FF FF FF 
2884   2120 FF FF FF FF 
2884   2124 FF FF FF FF 
2884   2128 FF FF FF FF 
2884   212C FF FF FF FF 
2884   2130 FF FF FF FF 
2884   2134 FF FF FF FF 
2884   2138 FF FF FF FF 
2884   213C FF FF FF FF 
2884   2140 FF FF FF FF 
2884   2144 FF FF FF FF 
2884   2148 FF FF FF FF 
2884   214C FF FF FF FF 
2884   2150 FF FF FF FF 
2884   2154 FF FF FF FF 
2884   2158 FF FF FF FF 
2884   215C FF FF FF FF 
2884   2160 FF FF FF FF 
2884   2164 FF FF FF FF 
2884   2168 FF FF FF FF 
2884   216C FF FF FF FF 
2884   2170 FF FF FF FF 
2884   2174 FF FF FF FF 
2884   2178 FF FF FF FF 
2884   217C FF FF FF FF 
2884   2180 FF FF FF FF 
2884   2184 FF FF FF FF 
2884   2188 FF FF FF FF 
2884   218C FF FF FF FF 
2884   2190 FF FF FF FF 
2884   2194 FF FF FF FF 
2884   2198 FF FF FF FF 
2884   219C FF FF FF FF 
2884   21A0 FF FF FF FF 
2884   21A4 FF FF FF FF 
2884   21A8 FF FF FF FF 
2884   21AC FF FF FF FF 
2884   21B0 FF FF FF FF 
2884   21B4 FF FF FF FF 
2884   21B8 FF FF FF FF 
2884   21BC FF FF FF FF 
2884   21C0 FF FF FF FF 
2884   21C4 FF FF FF FF 
2884   21C8 FF FF FF FF 
2884   21CC FF FF FF FF 
2884   21D0 FF FF FF FF 
2884   21D4 FF FF FF FF 
2884   21D8 FF FF FF FF 
2884   21DC FF FF FF FF 
2884   21E0 FF FF FF FF 
2884   21E4 FF FF FF FF 
2884   21E8 FF FF FF FF 
2884   21EC FF FF FF FF 
2884   21F0 FF FF FF FF 
2884   21F4 FF FF FF FF 
2884   21F8 FF FF FF FF 
2884   21FC FF FF FF FF 
2884   2200 FF FF FF FF 
2884   2204 FF FF FF FF 
2884   2208 FF FF FF FF 
2884   220C FF FF FF FF 
2884   2210 FF FF FF FF 
2884   2214 FF FF FF FF 
2884   2218 FF FF FF FF 
2884   221C FF FF FF FF 
2884   2220 FF FF FF FF 
2884   2224 FF FF FF FF 
2884   2228 FF FF FF FF 
2884   222C FF FF FF FF 
2884   2230 FF FF FF FF 
2884   2234 FF FF FF FF 
2884   2238 FF FF FF FF 
2884   223C FF FF FF FF 
2884   2240 FF FF FF FF 
2884   2244 FF FF FF FF 
2884   2248 FF FF FF FF 
2884   224C FF FF FF FF 
2884   2250 FF FF FF FF 
2884   2254 FF FF FF FF 
2884   2258 FF FF FF FF 
2884   225C FF FF FF FF 
2884   2260 FF FF FF FF 
2884   2264 FF FF FF FF 
2884   2268 FF FF FF FF 
2884   226C FF FF FF FF 
2884   2270 FF FF FF FF 
2884   2274 FF FF FF FF 
2884   2278 FF FF FF FF 
2884   227C FF FF FF FF 
2884   2280 FF FF FF FF 
2884   2284 FF FF FF FF 
2884   2288 FF FF FF FF 
2884   228C FF FF FF FF 
2884   2290 FF FF FF FF 
2884   2294 FF FF FF FF 
2884   2298 FF FF FF FF 
2884   229C FF FF FF FF 
2884   22A0 FF FF FF FF 
2884   22A4 FF FF FF FF 
2884   22A8 FF FF FF FF 
2884   22AC FF FF FF FF 
2884   22B0 FF FF FF FF 
2884   22B4 FF FF FF FF 
2884   22B8 FF FF FF FF 
2884   22BC FF FF FF FF 
2884   22C0 FF FF FF FF 
2884   22C4 FF FF FF FF 
2884   22C8 FF FF FF FF 
2884   22CC FF FF FF FF 
2884   22D0 FF FF FF FF 
2884   22D4 FF FF FF FF 
2884   22D8 FF FF FF FF 
2884   22DC FF FF FF FF 
2884   22E0 FF FF FF FF 
2884   22E4 FF FF FF FF 
2884   22E8 FF FF FF FF 
2884   22EC FF FF FF FF 
2884   22F0 FF FF FF FF 
2884   22F4 FF FF FF FF 
2884   22F8 FF FF FF FF 
2884   22FC FF FF FF FF 
2884   2300 FF FF FF FF 
2884   2304 FF FF FF FF 
2884   2308 FF FF FF FF 
2884   230C FF FF FF FF 
2884   2310 FF FF FF FF 
2884   2314 FF FF FF FF 
2884   2318 FF FF FF FF 
2884   231C FF FF FF FF 
2884   2320 FF FF FF FF 
2884   2324 FF FF FF FF 
2884   2328 FF FF FF FF 
2885   232C             
2886   232C             scrap_sector:
2887   232C FF FF FF FF   .fill 512         ; scrap sector
2887   2330 FF FF FF FF 
2887   2334 FF FF FF FF 
2887   2338 FF FF FF FF 
2887   233C FF FF FF FF 
2887   2340 FF FF FF FF 
2887   2344 FF FF FF FF 
2887   2348 FF FF FF FF 
2887   234C FF FF FF FF 
2887   2350 FF FF FF FF 
2887   2354 FF FF FF FF 
2887   2358 FF FF FF FF 
2887   235C FF FF FF FF 
2887   2360 FF FF FF FF 
2887   2364 FF FF FF FF 
2887   2368 FF FF FF FF 
2887   236C FF FF FF FF 
2887   2370 FF FF FF FF 
2887   2374 FF FF FF FF 
2887   2378 FF FF FF FF 
2887   237C FF FF FF FF 
2887   2380 FF FF FF FF 
2887   2384 FF FF FF FF 
2887   2388 FF FF FF FF 
2887   238C FF FF FF FF 
2887   2390 FF FF FF FF 
2887   2394 FF FF FF FF 
2887   2398 FF FF FF FF 
2887   239C FF FF FF FF 
2887   23A0 FF FF FF FF 
2887   23A4 FF FF FF FF 
2887   23A8 FF FF FF FF 
2887   23AC FF FF FF FF 
2887   23B0 FF FF FF FF 
2887   23B4 FF FF FF FF 
2887   23B8 FF FF FF FF 
2887   23BC FF FF FF FF 
2887   23C0 FF FF FF FF 
2887   23C4 FF FF FF FF 
2887   23C8 FF FF FF FF 
2887   23CC FF FF FF FF 
2887   23D0 FF FF FF FF 
2887   23D4 FF FF FF FF 
2887   23D8 FF FF FF FF 
2887   23DC FF FF FF FF 
2887   23E0 FF FF FF FF 
2887   23E4 FF FF FF FF 
2887   23E8 FF FF FF FF 
2887   23EC FF FF FF FF 
2887   23F0 FF FF FF FF 
2887   23F4 FF FF FF FF 
2887   23F8 FF FF FF FF 
2887   23FC FF FF FF FF 
2887   2400 FF FF FF FF 
2887   2404 FF FF FF FF 
2887   2408 FF FF FF FF 
2887   240C FF FF FF FF 
2887   2410 FF FF FF FF 
2887   2414 FF FF FF FF 
2887   2418 FF FF FF FF 
2887   241C FF FF FF FF 
2887   2420 FF FF FF FF 
2887   2424 FF FF FF FF 
2887   2428 FF FF FF FF 
2887   242C FF FF FF FF 
2887   2430 FF FF FF FF 
2887   2434 FF FF FF FF 
2887   2438 FF FF FF FF 
2887   243C FF FF FF FF 
2887   2440 FF FF FF FF 
2887   2444 FF FF FF FF 
2887   2448 FF FF FF FF 
2887   244C FF FF FF FF 
2887   2450 FF FF FF FF 
2887   2454 FF FF FF FF 
2887   2458 FF FF FF FF 
2887   245C FF FF FF FF 
2887   2460 FF FF FF FF 
2887   2464 FF FF FF FF 
2887   2468 FF FF FF FF 
2887   246C FF FF FF FF 
2887   2470 FF FF FF FF 
2887   2474 FF FF FF FF 
2887   2478 FF FF FF FF 
2887   247C FF FF FF FF 
2887   2480 FF FF FF FF 
2887   2484 FF FF FF FF 
2887   2488 FF FF FF FF 
2887   248C FF FF FF FF 
2887   2490 FF FF FF FF 
2887   2494 FF FF FF FF 
2887   2498 FF FF FF FF 
2887   249C FF FF FF FF 
2887   24A0 FF FF FF FF 
2887   24A4 FF FF FF FF 
2887   24A8 FF FF FF FF 
2887   24AC FF FF FF FF 
2887   24B0 FF FF FF FF 
2887   24B4 FF FF FF FF 
2887   24B8 FF FF FF FF 
2887   24BC FF FF FF FF 
2887   24C0 FF FF FF FF 
2887   24C4 FF FF FF FF 
2887   24C8 FF FF FF FF 
2887   24CC FF FF FF FF 
2887   24D0 FF FF FF FF 
2887   24D4 FF FF FF FF 
2887   24D8 FF FF FF FF 
2887   24DC FF FF FF FF 
2887   24E0 FF FF FF FF 
2887   24E4 FF FF FF FF 
2887   24E8 FF FF FF FF 
2887   24EC FF FF FF FF 
2887   24F0 FF FF FF FF 
2887   24F4 FF FF FF FF 
2887   24F8 FF FF FF FF 
2887   24FC FF FF FF FF 
2887   2500 FF FF FF FF 
2887   2504 FF FF FF FF 
2887   2508 FF FF FF FF 
2887   250C FF FF FF FF 
2887   2510 FF FF FF FF 
2887   2514 FF FF FF FF 
2887   2518 FF FF FF FF 
2887   251C FF FF FF FF 
2887   2520 FF FF FF FF 
2887   2524 FF FF FF FF 
2887   2528 FF FF FF FF 
2888   252C             transient_area:
2889   252C 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2890   252D             
2891   252D             .end
tasm: Number of errors = 0
