0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 48 00       .dw int_6
0141   000E 49 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 F0 0F       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 A5 02       .dw trap_privilege
0153   0014 C2 03       .dw trap_div_zero
0154   0016 CF 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 B1 02       .dw syscall_break
0165   0022 D0 03       .dw syscall_rtc
0166   0024 F3 04       .dw syscall_ide
0167   0026 B3 05       .dw syscall_io
0168   0028 70 06       .dw syscall_file_system
0169   002A 3D 0F       .dw syscall_create_proc
0170   002C 6A 02       .dw syscall_list_procs
0171   002E 02 04       .dw syscall_datetime
0172   0030 26 02       .dw syscall_reboot
0173   0032 07 0F       .dw syscall_pause_proc
0174   0034 32 02       .dw syscall_resume_proc
0175   0036 C4 0E       .dw syscall_terminate_proc
0176   0038 F2 01       .dw syscall_system
0177   003A 98 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; aliases for individual 'al' options for FDC system calls
0198   003C             sys_fdc_restore      .equ 0
0199   003C             sys_fdc_step         .equ 1
0200   003C             sys_fdc_step_in      .equ 2
0201   003C             sys_fdc_step_out     .equ 3
0202   003C             sys_fdc_seek         .equ 4
0203   003C             sys_fdc_format       .equ 5
0204   003C             sys_fdc_read_addr    .equ 6
0205   003C             sys_fdc_read_track   .equ 7
0206   003C             sys_fdc_read_sect    .equ 8
0207   003C             sys_fdc_write_sect   .equ 9
0208   003C             sys_fdc_force_int    .equ 10
0209   003C             sys_fdc_status0      .equ 11
0210   003C             sys_fdc_status1      .equ 12
0211   003C             
0212   003C             ; ------------------------------------------------------------------------------------------------------------------;
0213   003C             ; alias exports
0214   003C             ; ------------------------------------------------------------------------------------------------------------------;
0215   003C             .export text_org
0216   003C             .export sys_break
0217   003C             .export sys_rtc
0218   003C             .export sys_ide
0219   003C             .export sys_io
0220   003C             .export sys_filesystem
0221   003C             .export sys_create_proc
0222   003C             .export sys_list_proc
0223   003C             .export sys_datetime
0224   003C             .export sys_reboot
0225   003C             .export sys_pause_proc
0226   003C             .export sys_resume_proc
0227   003C             .export sys_terminate_proc
0228   003C             .export sys_system
0229   003C             .export sys_fdc
0230   003C             
0231   003C             ; exports of aliases for individual 'al' options for FDC system calls
0232   003C             .export sys_fdc_restore
0233   003C             .export sys_fdc_step
0234   003C             .export sys_fdc_step_in
0235   003C             .export sys_fdc_step_out
0236   003C             .export sys_fdc_seek
0237   003C             .export sys_fdc_format
0238   003C             .export sys_fdc_read_addr
0239   003C             .export sys_fdc_read_track
0240   003C             .export sys_fdc_read_sect
0241   003C             .export sys_fdc_write_sect
0242   003C             .export sys_fdc_force_int
0243   003C             .export sys_fdc_status0
0244   003C             .export sys_fdc_status1
0245   003C             ; ------------------------------------------------------------------------------------------------------------------;
0246   003C             ; irqs' code block
0247   003C             ; ------------------------------------------------------------------------------------------------------------------;
0248   003C             ; 5.25" floppy drive controller irq
0249   003C             int_0_fdc:
0250   003C 3B B8 18      mov d, s_fdc_irq
0251   003F 07 44 12      call _puts
0252   0042 06            sysret
0253   0043             int_1:
0254   0043 06            sysret
0255   0044             int_2:
0256   0044 06            sysret
0257   0045             int_3:
0258   0045 06            sysret
0259   0046             int_4:
0260   0046 06            sysret
0261   0047             int_5:
0262   0047 06            sysret
0263   0048             
0264   0048             ; timer irq
0265   0048             int_6:  
0266   0048 06            sysret
0267   0049             
0268   0049             ; ------------------------------------------------------------------------------------------------------------------;
0269   0049             ; uart0 interrupt
0270   0049             ; ------------------------------------------------------------------------------------------------------------------;
0271   0049             int_7_uart0:
0272   0049 D7            push a
0273   004A DA            push d
0274   004B E1            pushf
0275   004C 14 7A 17      mov a, [fifo_in]
0276   004F 3C            mov d, a
0277   0050 1D 80 FF      mov al, [_uart0_data]       ; get character
0278   0053 B9 03         cmp al, $03                 ; ctrl-c
0279   0055 C6 72 00      je ctrlc
0280   0058 B9 1A         cmp al, $1a                 ; ctrl-z
0281   005A C6 78 00      je ctrlz
0282   005D 3E            mov [d], al                 ; add to fifo
0283   005E 14 7A 17      mov a, [fifo_in]
0284   0061 77            inc a
0285   0062 AF DB 22      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0286   0065 C7 6B 00      jne int_7_continue
0287   0068 10 DB 1E      mov a, fifo  
0288   006B             int_7_continue:  
0289   006B 42 7A 17      mov [fifo_in], a            ; update fifo pointer
0290   006E EE            popf
0291   006F E7            pop d
0292   0070 E4            pop a  
0293   0071 06            sysret
0294   0072             ctrlc:
0295   0072 51 05 00      add sp, 5
0296   0075 0A C4 0E      jmp syscall_terminate_proc
0297   0078             ctrlz:
0298   0078 EE            popf
0299   0079 E7            pop d
0300   007A E4            pop a
0301   007B 0A 07 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0302   007E             
0303   007E             ; ------------------------------------------------------------------------------------------------------------------;
0304   007E             ; floppy drive syscalls
0305   007E             ; ------------------------------------------------------------------------------------------------------------------;
0306   007E             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0307   007E             ; fdc_40_ff:
0308   007E             ;   .fill 40,  $ff    ; or 00                                                                                
0309   007E             ; fdc_128_format_inner:
0310   007E             ;   .fill 6,   $00    ;                                                                            <--|        
0311   007E             ;   .fill 1,   $fe    ; id address mark                                                               |        
0312   007E             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0313   007E             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0314   007E             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0315   007E             ;   .fill 1,   $00    ; sector length                                                                 |                        
0316   007E             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0317   007E             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0318   007E             ;   .fill 6,   $00    ;                                                                               |                        
0319   007E             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0320   007E             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0321   007E             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0322   007E             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0323   007E             ; fdc_128_format_end:
0324   007E             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0325   007E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0326   007E             fdc_jmptbl:
0327   007E A4 00         .dw syscall_fdc_restore
0328   0080 A9 00         .dw syscall_fdc_step
0329   0082 AA 00         .dw syscall_fdc_step_in
0330   0084 AF 00         .dw syscall_fdc_step_out
0331   0086 B4 00         .dw syscall_fdc_seek
0332   0088 B7 00         .dw syscall_fdc_format
0333   008A B5 00         .dw syscall_fdc_read_addr
0334   008C DF 00         .dw syscall_fdc_read_track
0335   008E 0D 01         .dw syscall_fdc_read_sect
0336   0090 44 01         .dw syscall_fdc_write_sect
0337   0092 B6 00         .dw syscall_fdc_force_int
0338   0094 9C 00         .dw syscall_fdc_status0
0339   0096 A0 00         .dw syscall_fdc_status1
0340   0098             syscall_fdc:
0341   0098 FD 0A 7E 00   jmp [fdc_jmptbl + al]
0342   009C             
0343   009C             syscall_fdc_status0:
0344   009C 1D C1 FF      mov al, [_fdc_status_0]
0345   009F 06            sysret
0346   00A0             syscall_fdc_status1:
0347   00A0 1D C8 FF      mov al, [_fdc_stat_cmd]
0348   00A3 06            sysret
0349   00A4             syscall_fdc_restore:
0350   00A4 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0351   00A8 06            sysret
0352   00A9             
0353   00A9             syscall_fdc_step:
0354   00A9 06            sysret
0355   00AA             
0356   00AA             syscall_fdc_step_in:
0357   00AA F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0358   00AE 06            sysret
0359   00AF             
0360   00AF             syscall_fdc_step_out:
0361   00AF F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0362   00B3 06            sysret
0363   00B4             
0364   00B4             syscall_fdc_seek:
0365   00B4 06            sysret
0366   00B5             
0367   00B5             syscall_fdc_read_addr:
0368   00B5 06            sysret
0369   00B6             
0370   00B6             syscall_fdc_force_int:
0371   00B6 06            sysret
0372   00B7             
0373   00B7             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0374   00B7             ; in the ram formatting block because they are all set as 00 right now
0375   00B7             ; bl: track number
0376   00B7             syscall_fdc_format:
0377   00B7 FD 3D C9 FF   mov [_fdc_track], bl
0378   00BB F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0379   00BF FD 4D DB 24   mov si, transient_area
0380   00C3 F6            lodsb
0381   00C4 3D CB FF      mov [_fdc_data], al      ; 10   
0382   00C7 07 E1 01      call fdc_wait_64us
0383   00CA             fdc_format_drq:
0384   00CA 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0385   00CD 93 01         test al, $01                ; 4
0386   00CF C6 DE 00      jz fdc_format_end           ; 8
0387   00D2 93 02         test al, $02                ; 4
0388   00D4 C6 CA 00      jz fdc_format_drq           ; 8
0389   00D7 F6            lodsb                       ; 7
0390   00D8 3D CB FF      mov [_fdc_data], al         ; 10   
0391   00DB 0A CA 00      jmp fdc_format_drq
0392   00DE             fdc_format_end:
0393   00DE 06            sysret
0394   00DF             
0395   00DF             ; di = destination in user space
0396   00DF             syscall_fdc_read_track:
0397   00DF F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0398   00E3 07 E1 01      call fdc_wait_64us
0399   00E6 E3            push di
0400   00E7 FD 4F DB 24   mov di, transient_area
0401   00EB             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0402   00EB 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0403   00EE 93 01         test al, $01                ; check busy bit
0404   00F0 C6 FF 00      jz fdc_read_track_end
0405   00F3 93 02         test al, $02                ; check drq bit
0406   00F5 C6 EB 00      jz fdc_read_track_l0
0407   00F8 1D CB FF      mov al, [_fdc_data]     ; 
0408   00FB F7            stosb
0409   00FC 0A EB 00      jmp fdc_read_track_l0
0410   00FF             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0411   00FF             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0412   00FF             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0413   00FF             fdc_read_track_end:
0414   00FF 50            mov a, di
0415   0100 5F DB 24      sub a, transient_area
0416   0103 F0            pop di
0417   0104 FD 4D DB 24   mov si, transient_area
0418   0108 38 D2 0E      mov c, 40 + 169 * 16 + 450  ; copy track over to user space
0419   010B 03            store
0420   010C 06            sysret
0421   010D             
0422   010D             ; sector in bl
0423   010D             ; track in bh
0424   010D             ; di = user space destination
0425   010D             syscall_fdc_read_sect:
0426   010D FD 3D CA FF   mov [_fdc_sector], bl
0427   0111 30            mov bl, bh
0428   0112 FD 3D C9 FF   mov [_fdc_track], bl
0429   0116 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0430   011A 07 E1 01      call fdc_wait_64us
0431   011D E3            push di
0432   011E FD 4F DB 24   mov di, transient_area
0433   0122             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0434   0122 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0435   0125 93 01         test al, $01                ; check drq bit
0436   0127 C6 36 01      jz fdc_read_sect_end
0437   012A 93 02         test al, $02                ; check drq bit
0438   012C C6 22 01      jz fdc_read_sect_l0
0439   012F 1D CB FF      mov al, [_fdc_data]     ; 
0440   0132 F7            stosb
0441   0133 0A 22 01      jmp fdc_read_sect_l0
0442   0136             fdc_read_sect_end:
0443   0136 50            mov a, di
0444   0137 5F DB 24      sub a, transient_area
0445   013A F0            pop di
0446   013B FD 4D DB 24   mov si, transient_area
0447   013F 38 80 00      mov c, 128  ; copy sector over to user space
0448   0142 03            store
0449   0143 06            sysret
0450   0144             
0451   0144             ; sector in al
0452   0144             ; track in ah
0453   0144             ; data pointer in si
0454   0144             syscall_fdc_write_sect:
0455   0144 FD 3D CA FF   mov [_fdc_sector], bl
0456   0148 30            mov bl, bh
0457   0149 FD 3D C9 FF   mov [_fdc_track], bl
0458   014D FD 4F DB 24   mov di, transient_area    ; si = data source, di = destination 
0459   0151 38 80 00      mov c, 128
0460   0154 04            load                    ; transfer data to kernel space!
0461   0155 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0462   0159 F6            lodsb                      
0463   015A 3D CB FF      mov [_fdc_data], al      
0464   015D 07 E1 01      call fdc_wait_64us
0465   0160             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0466   0160 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0467   0163 93 01         test al, $01                    ; 4
0468   0165 C6 74 01      jz fdc_write_sect_end           ; 8
0469   0168 93 02         test al, $02                    ; 4
0470   016A C6 60 01      jz fdc_write_sect_l0            ; 8
0471   016D F6            lodsb                           ; 7
0472   016E 3D CB FF      mov [_fdc_data], al             ; 10   
0473   0171 0A 60 01      jmp fdc_write_sect_l0
0474   0174             fdc_write_sect_end:
0475   0174 06            sysret
0476   0175             
0477   0175             fdc_format_mem:
0478   0175 3B 01 00      mov d, 1
0479   0178 FD 4F DB 24   mov di, transient_area
0480   017C             ; 40 * FF
0481   017C 38 28 00      mov c, 40
0482   017F 19 FF         mov al, $ff
0483   0181             fdc_l0: 
0484   0181 F7            stosb
0485   0182 7E            dec c
0486   0183 C7 81 01      jnz fdc_l0
0487   0186             ; 6 * 00
0488   0186             fdc_inner_loop:
0489   0186 38 06 00      mov c, 6
0490   0189 19 00         mov al, $00
0491   018B             fdc_l1:
0492   018B F7            stosb
0493   018C 7E            dec c
0494   018D C7 8B 01      jnz fdc_l1
0495   0190             ; FE address mark
0496   0190             fdc_l2:
0497   0190 19 FE         mov al, $fe
0498   0192 F7            stosb
0499   0193             ; track number
0500   0193             fdc_l3:
0501   0193 19 00         mov al, $00
0502   0195 F7            stosb
0503   0196             ; side number
0504   0196             fdc_l4:
0505   0196 19 00         mov al, $00
0506   0198 F7            stosb
0507   0199             ; sector number
0508   0199             fdc_l5:
0509   0199 13            mov a, d
0510   019A F7            stosb
0511   019B             ; sector length 128 bytes
0512   019B             fdc_l6:
0513   019B 19 00         mov al, $00
0514   019D F7            stosb
0515   019E             ; 2 crc's
0516   019E             fdc_l7:
0517   019E 19 F7         mov al, $f7
0518   01A0 F7            stosb
0519   01A1             ; 11 times $ff
0520   01A1 38 0B 00      mov c, 11
0521   01A4 19 FF         mov al, $ff
0522   01A6             fdc_l8:
0523   01A6 F7            stosb
0524   01A7 7E            dec c
0525   01A8 C7 A6 01      jnz fdc_l8
0526   01AB             ; 6 times 00
0527   01AB 38 06 00      mov c, 6
0528   01AE 19 00         mov al, $00
0529   01B0             fdc_l9:
0530   01B0 F7            stosb
0531   01B1 7E            dec c
0532   01B2 C7 B0 01      jnz fdc_l9
0533   01B5             ; FB data address mark
0534   01B5 19 FB         mov al, $fb
0535   01B7             fdc_l10:
0536   01B7 F7            stosb
0537   01B8             ; 128 bytes sector data
0538   01B8 38 80 00      mov c, 128
0539   01BB 19 E5         mov al, $E5
0540   01BD             fdc_l11:
0541   01BD F7            stosb
0542   01BE 7E            dec c
0543   01BF C7 BD 01      jnz fdc_l11
0544   01C2             ; 2 crc's
0545   01C2             fdc_l12:
0546   01C2 19 F7         mov al, $f7
0547   01C4 F7            stosb
0548   01C5             ; 10 * $FF
0549   01C5 38 0A 00      mov c, 10
0550   01C8 19 FF         mov al, $ff
0551   01CA             fdc_l13:
0552   01CA F7            stosb
0553   01CB 7E            dec c
0554   01CC C7 CA 01      jnz fdc_l13
0555   01CF             ; check whether we did this 16 times
0556   01CF 79            inc d
0557   01D0 C5 11 00      cmp d, 17
0558   01D3 C7 86 01      jne fdc_inner_loop
0559   01D6             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0560   01D6 38 F4 01      mov c, 500
0561   01D9 19 FF         mov al, $ff
0562   01DB             fdc_format_footer:
0563   01DB             fdc_footer_drq_loop:
0564   01DB F7            stosb
0565   01DC 7E            dec c
0566   01DD C7 DB 01      jnz fdc_footer_drq_loop
0567   01E0 09            ret
0568   01E1             
0569   01E1             ; fetch is 2 cycles long when 'display_reg_load' is false.
0570   01E1             ; 64us amounts to 160 cycles of the 2.5mhz clock
0571   01E1             ; call u16 is 14 cycles long
0572   01E1             ; 160 - 5 - 14 = 
0573   01E1             fdc_wait_64us:
0574   01E1 3A 0D         mov cl, 13                       ; 5 cycles
0575   01E3             fdc_wait_64_loop:
0576   01E3 81            dec cl                           ; 3 cycles
0577   01E4 C7 E3 01      jnz fdc_wait_64_loop             ; 8 cycles
0578   01E7 09            ret
0579   01E8             
0580   01E8             ; ------------------------------------------------------------------------------------------------------------------;
0581   01E8             ; system syscalls
0582   01E8             ; ------------------------------------------------------------------------------------------------------------------;
0583   01E8             system_jmptbl:
0584   01E8 1E 02         .dw system_uname
0585   01EA 25 02         .dw system_whoami
0586   01EC F8 01         .dw system_setparam
0587   01EE FB 01         .dw system_bootloader_install
0588   01F0 F6 01         .dw system_getparam
0589   01F2             syscall_system:
0590   01F2 FD 0A E8 01   jmp [system_jmptbl + al]
0591   01F6             
0592   01F6             ; param register address in register d
0593   01F6             ; param value in register bl
0594   01F6             system_getparam:
0595   01F6 32            mov bl, [d]
0596   01F7 06            sysret
0597   01F8             
0598   01F8             ; param register address in register d
0599   01F8             ; param value in register bl
0600   01F8             system_setparam:
0601   01F8 FD 3E         mov [d], bl
0602   01FA 06            sysret
0603   01FB             
0604   01FB             ; kernel LBA address in 'b'
0605   01FB             system_bootloader_install:
0606   01FB D8            push b
0607   01FC 26 00 00      mov b, 0
0608   01FF 38 00 00      mov c, 0
0609   0202 22 01         mov ah, $01                 ; 1 sector
0610   0204 3B DB 24      mov d, transient_area
0611   0207 07 22 05      call ide_read_sect          ; read sector
0612   020A E5            pop b
0613   020B FD 44 FE 01   mov [d + 510], b            ; update LBA address
0614   020F 26 00 00      mov b, 0
0615   0212 38 00 00      mov c, 0
0616   0215 22 01         mov ah, $01                 ; 1 sector
0617   0217 3B DB 24      mov d, transient_area
0618   021A 07 48 05      call ide_write_sect         ; write sector
0619   021D 06            sysret
0620   021E             
0621   021E             system_uname:
0622   021E 3B 8B 17      mov d, s_uname
0623   0221 07 44 12      call _puts
0624   0224 06            sysret
0625   0225             
0626   0225             system_whoami:
0627   0225 06            sysret
0628   0226             
0629   0226             ; reboot system
0630   0226             syscall_reboot:
0631   0226 FD D7 FF FF   push word $ffff 
0632   022A FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0633   022D FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0634   0231 06            sysret
0635   0232             
0636   0232             ;------------------------------------------------------------------------------------------------------;;
0637   0232             ; switch to another process
0638   0232             ; inputs:
0639   0232             ; al = new process number
0640   0232             ;------------------------------------------------------------------------------------------------------;;
0641   0232             syscall_resume_proc:
0642   0232 FD 78         mov g, a                            ; save the process number
0643   0234 4B            pusha                               ; save all registers into kernel stack
0644   0235 22 00         mov ah, 0
0645   0237 1D 75 17      mov al, [active_proc_index]
0646   023A FD 99         shl a              ; x2
0647   023C B7 BA 0F      mov a, [proc_table_convert + a]     ; get process state start index
0648   023F 4F            mov di, a
0649   0240 48            mov a, sp
0650   0241 77            inc a
0651   0242 4D            mov si, a
0652   0243 38 14 00      mov c, 20
0653   0246 FD F5         rep movsb                           ; save process state!
0654   0248             ; restore kernel stack position to point before interrupt arrived
0655   0248 51 14 00      add sp, 20
0656   024B             ; now load the new process number!
0657   024B FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0658   024D 3D 75 17      mov [active_proc_index], al         ; set new active proc
0659   0250             ; calculate lut entry for next process
0660   0250 22 00         mov ah, 0
0661   0252 FD 99         shl a                               ; x2
0662   0254 B7 BA 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0663   0257 4D            mov si, a                           ; source is proc state block
0664   0258 48            mov a, sp
0665   0259 5F 13 00      sub a, 19
0666   025C 4F            mov di, a                           ; destination is kernel stack
0667   025D             ; restore sp
0668   025D 7D            dec a
0669   025E 47            mov sp, a
0670   025F 38 14 00      mov c, 20
0671   0262 FD F5         rep movsb
0672   0264             ; set vm process
0673   0264 1D 75 17      mov al, [active_proc_index]
0674   0267 01            setptb
0675   0268 4C            popa
0676   0269 06            sysret
0677   026A             
0678   026A             ;------------------------------------------------------------------------------------------------------;;
0679   026A             ; list processes
0680   026A             ;------------------------------------------------------------------------------------------------------;;
0681   026A             syscall_list_procs:
0682   026A 3B AC 17      mov d, s_ps_header
0683   026D 07 44 12      call _puts
0684   0270 3B 4C 1A      mov d, proc_availab_table + 1
0685   0273 38 01 00      mov c, 1
0686   0276             list_procs_l0:  
0687   0276 BD 01         cmp byte[d], 1
0688   0278 C7 9C 02      jne list_procs_next
0689   027B 2D            mov b, d
0690   027C 61 4B 1A      sub b, proc_availab_table
0691   027F FD 9F 05      shl b, 5
0692   0282 DA            push d
0693   0283 D8            push b
0694   0284 28            mov b, c
0695   0285 07 E4 12      call print_u8x
0696   0288 22 20         mov ah, ' '
0697   028A 07 18 11      call _putchar
0698   028D 07 18 11      call _putchar
0699   0290 E5            pop b
0700   0291 74            mov d, b
0701   0292 58 5B 1A      add d, proc_names
0702   0295 07 44 12      call _puts
0703   0298 07 F1 11      call printnl
0704   029B E7            pop d
0705   029C             list_procs_next:
0706   029C 79            inc d
0707   029D 78            inc c
0708   029E C2 09 00      cmp c, 9
0709   02A1 C7 76 02      jne list_procs_l0
0710   02A4             list_procs_end:
0711   02A4 06            sysret
0712   02A5             
0713   02A5             ; ------------------------------------------------------------------------------------------------------------------;
0714   02A5             ; exceptions code block
0715   02A5             ; ------------------------------------------------------------------------------------------------------------------;
0716   02A5             ; privilege exception
0717   02A5             ; ------------------------------------------------------------------------------------------------------------------;
0718   02A5             trap_privilege:
0719   02A5 0A 26 02      jmp syscall_reboot
0720   02A8 DA            push d
0721   02A9 3B FB 17      mov d, s_priviledge
0722   02AC 07 44 12      call _puts
0723   02AF E7            pop d
0724   02B0 06            sysret
0725   02B1             
0726   02B1             ; ------------------------------------------------------------------------------------------------------------------;
0727   02B1             ; breakpoint
0728   02B1             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0729   02B1             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0730   02B1             ; ------------------------------------------------------------------------------------------------------------------;
0731   02B1             syscall_break:
0732   02B1 4B            pusha
0733   02B2             syscall_break_prompt:
0734   02B2 3B 6C 03      mov d, s_break1
0735   02B5 07 44 12      call _puts
0736   02B8 07 F1 11      call printnl
0737   02BB 07 46 13      call scan_u16d
0738   02BE AF 00 00      cmp a, 0
0739   02C1 C6 CC 02      je syscall_break_regs
0740   02C4 AF 01 00      cmp a, 1
0741   02C7 C6 EF 02      je syscall_break_mem
0742   02CA             syscall_break_end:  
0743   02CA 4C            popa
0744   02CB 06            sysret
0745   02CC             syscall_break_regs:
0746   02CC 48            mov a, sp
0747   02CD 53 0E 00      add a, 14               ; back-track 7 registers
0748   02D0 3C            mov d, a
0749   02D1 3A 07         mov cl, 7
0750   02D3             syscall_regs_l0:
0751   02D3 2A            mov b, [d]
0752   02D4 FD AB         swp b
0753   02D6 07 A0 12      call print_u16x         ; print register value
0754   02D9 07 F1 11      call printnl
0755   02DC 63 02 00      sub d, 2
0756   02DF 71 01         sub cl, 1
0757   02E1 C3 00         cmp cl, 0
0758   02E3 C7 D3 02      jne syscall_regs_l0
0759   02E6 0A B2 02      jmp syscall_break_prompt
0760   02E9 07 F1 11      call printnl
0761   02EC 0A B2 02      jmp syscall_break_prompt
0762   02EF             syscall_break_mem:
0763   02EF 07 F1 11      call printnl
0764   02F2 07 C2 12      call scan_u16x
0765   02F5 4D            mov si, a               ; data source from user space
0766   02F6 FD 4F DB 22   mov di, scrap_sector    ; destination in kernel space
0767   02FA 38 00 02      mov c, 512
0768   02FD 04            load                    ; transfer data to kernel space!
0769   02FE 3B DB 22      mov d, scrap_sector     ; dump pointer in d
0770   0301 38 00 00      mov c, 0
0771   0304             dump_loop:
0772   0304 84            mov al, cl
0773   0305 87 0F         and al, $0f
0774   0307 C6 55 03      jz print_base
0775   030A             back:
0776   030A 1E            mov al, [d]             ; read byte
0777   030B 2F            mov bl, al
0778   030C 07 E4 12      call print_u8x
0779   030F 10 00 20      mov a, $2000
0780   0312 05 03         syscall sys_io          ; space
0781   0314 84            mov al, cl
0782   0315 87 0F         and al, $0f
0783   0317 B9 0F         cmp al, $0f
0784   0319 C6 2A 03      je print_ascii
0785   031C             back1:
0786   031C 79            inc d
0787   031D 78            inc c
0788   031E C2 00 02      cmp c, 512
0789   0321 C7 04 03      jne dump_loop
0790   0324 07 F1 11      call printnl
0791   0327 0A B2 02      jmp syscall_break_prompt  ; go to syscall_break return point
0792   032A             print_ascii:
0793   032A 10 00 20      mov a, $2000
0794   032D 05 03         syscall sys_io
0795   032F 63 10 00      sub d, 16
0796   0332 26 10 00      mov b, 16
0797   0335             print_ascii_l:
0798   0335 79            inc d
0799   0336 1E            mov al, [d]               ; read byte
0800   0337 B9 20         cmp al, $20
0801   0339 C8 41 03      jlu dot
0802   033C B9 7E         cmp al, $7e
0803   033E D0 49 03      jleu ascii
0804   0341             dot:
0805   0341 10 00 2E      mov a, $2e00
0806   0344 05 03         syscall sys_io
0807   0346 0A 4E 03      jmp ascii_continue
0808   0349             ascii:
0809   0349 23            mov ah, al
0810   034A 19 00         mov al, 0
0811   034C 05 03         syscall sys_io
0812   034E             ascii_continue:
0813   034E FD A9 35 03   loopb print_ascii_l
0814   0352 0A 1C 03      jmp back1
0815   0355             print_base:
0816   0355 07 F1 11      call printnl
0817   0358 2D            mov b, d
0818   0359 61 DB 22      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0819   035C 07 A0 12      call print_u16x          ; display row
0820   035F 10 00 3A      mov a, $3a00
0821   0362 05 03         syscall sys_io
0822   0364 10 00 20      mov a, $2000
0823   0367 05 03         syscall sys_io
0824   0369 0A 0A 03      jmp back
0825   036C             
0826   036C             s_break1:  
0827   036C 0A 64 65 62   .db "\ndebugger entry point.\n"
0827   0370 75 67 67 65 
0827   0374 72 20 65 6E 
0827   0378 74 72 79 20 
0827   037C 70 6F 69 6E 
0827   0380 74 2E 0A 
0828   0383 30 2E 20 73   .db "0. show registers\n"
0828   0387 68 6F 77 20 
0828   038B 72 65 67 69 
0828   038F 73 74 65 72 
0828   0393 73 0A 
0829   0395 31 2E 20 73   .db "1. show 512b ram block\n"
0829   0399 68 6F 77 20 
0829   039D 35 31 32 62 
0829   03A1 20 72 61 6D 
0829   03A5 20 62 6C 6F 
0829   03A9 63 6B 0A 
0830   03AC 32 2E 20 63   .db "2. continue execution", 0
0830   03B0 6F 6E 74 69 
0830   03B4 6E 75 65 20 
0830   03B8 65 78 65 63 
0830   03BC 75 74 69 6F 
0830   03C0 6E 00 
0831   03C2             
0832   03C2             ; ------------------------------------------------------------------------------------------------------------------;
0833   03C2             ; divide by zero exception
0834   03C2             ; ------------------------------------------------------------------------------------------------------------------;
0835   03C2             trap_div_zero:
0836   03C2 D7            push a
0837   03C3 DA            push d
0838   03C4 E1            pushf
0839   03C5 3B 12 18      mov d, s_divzero
0840   03C8 07 44 12      call _puts
0841   03CB EE            popf
0842   03CC E7            pop d
0843   03CD E4            pop a
0844   03CE 06            sysret ; enable interrupts
0845   03CF             
0846   03CF             ; ------------------------------------------------------------------------------------------------------------------;
0847   03CF             ; undefined opcode exception
0848   03CF             ; ------------------------------------------------------------------------------------------------------------------;
0849   03CF             trap_undef_opcode:
0850   03CF 06            sysret
0851   03D0             
0852   03D0             ; ------------------------------------------------------------------------------------------------------------------;
0853   03D0             ; real-time clock services syscall
0854   03D0             ; rtc i/o bank = ffa0 to ffaf
0855   03D0             ; ffa0 to ffa7 is scratch ram
0856   03D0             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0857   03D0             ; al = 0..6 -> get
0858   03D0             ; al = 7..d -> set
0859   03D0             ; ------------------------------------------------------------------------------------------------------------------;
0860   03D0             syscall_rtc:
0861   03D0 DB            push al
0862   03D1 DA            push d
0863   03D2 B9 06         cmp al, 6
0864   03D4 D1 E9 03      jgu syscall_rtc_set
0865   03D7             syscall_rtc_get:
0866   03D7 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0867   03D9 22 FF         mov ah, $ff    
0868   03DB 3C            mov d, a                ; get to ffa9 + offset
0869   03DC F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0870   03E0 1E            mov al, [d]             ; get data
0871   03E1 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0872   03E5 23            mov ah, al
0873   03E6 E7            pop d
0874   03E7 E8            pop al
0875   03E8 06            sysret
0876   03E9             syscall_rtc_set:
0877   03E9 DD            push bl
0878   03EA 99            mov bl, ah              ; set data aside
0879   03EB 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0880   03ED 22 FF         mov ah, $ff    
0881   03EF 3C            mov d, a                ; get to ffa9 + offset
0882   03F0 1B            mov al, bl              ; get data back
0883   03F1 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0884   03F5 3E            mov [d], al             ; set data
0885   03F6 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0886   03FA EA            pop bl
0887   03FB E7            pop d
0888   03FC E8            pop al
0889   03FD 06            sysret
0890   03FE             
0891   03FE             datetime_serv_tbl:
0892   03FE 06 04         .dw print_date
0893   0400 7A 04         .dw set_date
0894   0402             syscall_datetime:
0895   0402 FD 0A FE 03   jmp [datetime_serv_tbl + al]      
0896   0406             print_date:
0897   0406 10 00 0D      mov a, $0d00           ; print carriage return char
0898   0409 19 03         mov al, 3
0899   040B 05 01         syscall sys_rtc        ; get week
0900   040D 1A            mov al, ah
0901   040E 22 00         mov ah, 0
0902   0410 FD 9D 02      shl a, 2          
0903   0413 3B 9C 18      mov d, s_week
0904   0416 59            add d, a
0905   0417 07 44 12      call _puts
0906   041A 10 00 20      mov a, $2000
0907   041D 05 03         syscall sys_io         ; display ' '
0908   041F 19 04         mov al, 4
0909   0421 05 01         syscall sys_rtc        ; get day
0910   0423 99            mov bl, ah
0911   0424 07 E4 12      call print_u8x
0912   0427 10 00 20      mov a, $2000
0913   042A 05 03         syscall sys_io         ; display ' '
0914   042C             ; there is a problem with the month displaying
0915   042C             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0916   042C             ; even though it is to be understood as bcd.
0917   042C             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0918   042C 19 05         mov al, 05
0919   042E 05 01         syscall sys_rtc        ; get month
0920   0430 1A            mov al, ah
0921   0431 22 00         mov ah, 0
0922   0433 FD 9D 02      shl a, 2          
0923   0436 3B 68 18      mov d, s_months
0924   0439 59            add d, a
0925   043A 07 44 12      call _puts
0926   043D 10 00 20      mov a, $2000
0927   0440 05 03         syscall sys_io         ; display ' '
0928   0442 2E 20         mov bl, $20
0929   0444 07 E4 12      call print_u8x         ; print 20 for year prefix
0930   0447 19 06         mov al, 06
0931   0449 05 01         syscall sys_rtc        ; get year
0932   044B 99            mov bl, ah
0933   044C 07 E4 12      call print_u8x
0934   044F 10 00 20      mov a, $2000  
0935   0452 05 03         syscall sys_io         ; display ' '
0936   0454 19 02         mov al, 2
0937   0456 05 01         syscall sys_rtc        ; get hours
0938   0458 99            mov bl, ah
0939   0459 07 E4 12      call print_u8x
0940   045C 10 00 3A      mov a, $3a00    
0941   045F 05 03         syscall sys_io         ; display ':'
0942   0461 19 01         mov al, 01
0943   0463 05 01         syscall sys_rtc        ; get minutes
0944   0465 99            mov bl, ah
0945   0466 07 E4 12      call print_u8x
0946   0469 10 00 3A      mov a, $3a00  
0947   046C 05 03         syscall sys_io         ; display ':'
0948   046E 19 00         mov al, 0
0949   0470 05 01         syscall sys_rtc        ; get seconds
0950   0472 99            mov bl, ah
0951   0473 07 E4 12      call print_u8x
0952   0476 07 F1 11      call printnl
0953   0479 06            sysret
0954   047A             set_date:
0955   047A 3B 2D 18      mov d, s_set_year
0956   047D 07 44 12      call _puts
0957   0480 07 2F 13      call scan_u8x          ; read integer into a
0958   0483 FD 9D 08      shl a, 8               ; only al used, move to ah
0959   0486 19 0D         mov al, 0dh            ; set rtc year
0960   0488 05 01         syscall sys_rtc        ; set rtc
0961   048A 3B 34 18      mov d, s_set_month
0962   048D 07 44 12      call _puts
0963   0490 07 2F 13      call scan_u8x          ; read integer into a
0964   0493 FD 9D 08      shl a, 8               ; only al used, move to ah
0965   0496 19 0C         mov al, 0ch            ; set rtc month
0966   0498 05 01         syscall sys_rtc        ; set rtc
0967   049A 3B 3C 18      mov d, s_set_day
0968   049D 07 44 12      call _puts
0969   04A0 07 2F 13      call scan_u8x          ; read integer into a
0970   04A3 FD 9D 08      shl a, 8               ; only al used, move to ah
0971   04A6 19 0B         mov al, 0bh            ; set rtc month
0972   04A8 05 01         syscall sys_rtc        ; set rtc
0973   04AA 3B 42 18      mov d, s_set_week
0974   04AD 07 44 12      call _puts
0975   04B0 07 2F 13      call scan_u8x          ; read integer into a
0976   04B3 FD 9D 08      shl a, 8               ; only al used, move to ah
0977   04B6 19 0A         mov al, 0ah            ; set rtc month
0978   04B8 05 01         syscall sys_rtc        ; set rtc
0979   04BA 3B 4C 18      mov d, s_set_hours
0980   04BD 07 44 12      call _puts
0981   04C0 07 2F 13      call scan_u8x          ; read integer into a
0982   04C3 FD 9D 08      shl a, 8               ; only al used, move to ah
0983   04C6 19 09         mov al, 09h            ; set rtc month
0984   04C8 05 01         syscall sys_rtc        ; set rtc
0985   04CA 3B 54 18      mov d, s_set_minutes
0986   04CD 07 44 12      call _puts
0987   04D0 07 2F 13      call scan_u8x          ; read integer into a
0988   04D3 FD 9D 08      shl a, 8               ; only al used, move to ah
0989   04D6 19 08         mov al, 08h            ; set rtc month
0990   04D8 05 01         syscall sys_rtc        ; set rtc
0991   04DA 3B 5E 18      mov d, s_set_seconds
0992   04DD 07 44 12      call _puts
0993   04E0 07 2F 13      call scan_u8x          ; read integer into a
0994   04E3 FD 9D 08      shl a, 8               ; only al used, move to ah
0995   04E6 19 07         mov al, 07h            ; set rtc month
0996   04E8 05 01         syscall sys_rtc        ; set rtc
0997   04EA 06            sysret
0998   04EB             
0999   04EB             ; ------------------------------------------------------------------------------------------------------------------;
1000   04EB             ; ide services syscall
1001   04EB             ; al = option
1002   04EB             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1003   04EB             ; ide read/write sector
1004   04EB             ; 512 bytes
1005   04EB             ; user buffer pointer in d
1006   04EB             ; ah = number of sectors
1007   04EB             ; cb = lba bytes 3..0
1008   04EB             ; ------------------------------------------------------------------------------------------------------------------;
1009   04EB             ide_serv_tbl:
1010   04EB F7 04         .dw ide_reset
1011   04ED 0B 05         .dw ide_sleep
1012   04EF 1A 05         .dw ide_read_sect_wrapper
1013   04F1 1E 05         .dw ide_write_sect_wrapper
1014   04F3             syscall_ide:
1015   04F3 FD 0A EB 04   jmp [ide_serv_tbl + al]    
1016   04F7             
1017   04F7             ide_reset:      
1018   04F7 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1019   04FB 07 A4 05      call ide_wait                   ; wait for ide ready             
1020   04FE F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1021   0502 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1022   0506 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1023   050A 06            sysret
1024   050B             ide_sleep:
1025   050B 07 A4 05      call ide_wait                   ; wait for ide ready             
1026   050E F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1027   0512 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1028   0516 07 A4 05      call ide_wait                   ; wait for ide ready
1029   0519 06            sysret
1030   051A             ide_read_sect_wrapper:
1031   051A 07 22 05      call ide_read_sect
1032   051D 06            sysret
1033   051E             ide_write_sect_wrapper:
1034   051E 07 48 05      call ide_write_sect
1035   0521 06            sysret
1036   0522             ide_read_sect:
1037   0522 1A            mov al, ah
1038   0523 24            mov ah, bl
1039   0524 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1040   0527 1C            mov al, bh
1041   0528 3D D4 FF      mov [_ide_r4], al
1042   052B 12            mov a, c
1043   052C 3D D5 FF      mov [_ide_r5], al
1044   052F 1A            mov al, ah
1045   0530 87 0F         and al, %00001111
1046   0532 8B E0         or al, %11100000                ; mode lba, master
1047   0534 3D D6 FF      mov [_ide_r6], al
1048   0537             ide_read_sect_wait:
1049   0537 1D D7 FF      mov al, [_ide_r7]  
1050   053A 87 80         and al, $80                     ; busy flag
1051   053C C7 37 05      jnz ide_read_sect_wait
1052   053F 19 20         mov al, $20
1053   0541 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1054   0544 07 6E 05      call ide_read  
1055   0547 09            ret
1056   0548             ide_write_sect:
1057   0548 1A            mov al, ah
1058   0549 24            mov ah, bl
1059   054A 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1060   054D 1C            mov al, bh
1061   054E 3D D4 FF      mov [_ide_r4], al
1062   0551 12            mov a, c
1063   0552 3D D5 FF      mov [_ide_r5], al
1064   0555 1A            mov al, ah
1065   0556 87 0F         and al, %00001111
1066   0558 8B E0         or al, %11100000                ; mode lba, master
1067   055A 3D D6 FF      mov [_ide_r6], al
1068   055D             ide_write_sect_wait:
1069   055D 1D D7 FF      mov al, [_ide_r7]  
1070   0560 87 80         and al, $80                     ; busy flag
1071   0562 C7 5D 05      jnz ide_write_sect_wait
1072   0565 19 30         mov al, $30
1073   0567 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1074   056A 07 89 05      call ide_write      
1075   056D 09            ret
1076   056E             
1077   056E             ;----------------------------------------------------------------------------------------------------;
1078   056E             ; read ide data
1079   056E             ; pointer in d
1080   056E             ;----------------------------------------------------------------------------------------------------;
1081   056E             ide_read:
1082   056E DA            push d
1083   056F             ide_read_loop:
1084   056F 1D D7 FF      mov al, [_ide_r7]  
1085   0572 87 80         and al, 80h                     ; busy flag
1086   0574 C7 6F 05      jnz ide_read_loop               ; wait loop
1087   0577 1D D7 FF      mov al, [_ide_r7]
1088   057A 87 08         and al, %00001000               ; drq flag
1089   057C C6 87 05      jz ide_read_end
1090   057F 1D D0 FF      mov al, [_ide_r0]
1091   0582 3E            mov [d], al
1092   0583 79            inc d
1093   0584 0A 6F 05      jmp ide_read_loop
1094   0587             ide_read_end:
1095   0587 E7            pop d
1096   0588 09            ret
1097   0589             
1098   0589             ;----------------------------------------------------------------------------------------------------;
1099   0589             ; write ide data
1100   0589             ; data pointer in d
1101   0589             ;----------------------------------------------------------------------------------------------------;
1102   0589             ide_write:
1103   0589 DA            push d
1104   058A             ide_write_loop:
1105   058A 1D D7 FF      mov al, [_ide_r7]  
1106   058D 87 80         and al, 80h             ; busy flag
1107   058F C7 8A 05      jnz ide_write_loop      ; wait loop
1108   0592 1D D7 FF      mov al, [_ide_r7]
1109   0595 87 08         and al, %00001000       ; drq flag
1110   0597 C6 A2 05      jz ide_write_end
1111   059A 1E            mov al, [d]
1112   059B 3D D0 FF      mov [_ide_r0], al
1113   059E 79            inc d 
1114   059F 0A 8A 05      jmp ide_write_loop
1115   05A2             ide_write_end:
1116   05A2 E7            pop d
1117   05A3 09            ret
1118   05A4             
1119   05A4             ;----------------------------------------------------------------------------------------------------;
1120   05A4             ; wait for ide to be ready
1121   05A4             ;----------------------------------------------------------------------------------------------------;
1122   05A4             ide_wait:
1123   05A4 1D D7 FF      mov al, [_ide_r7]  
1124   05A7 87 80         and al, 80h        ; busy flag
1125   05A9 C7 A4 05      jnz ide_wait
1126   05AC 09            ret
1127   05AD             
1128   05AD             ;----------------------------------------------------------------------------------------------------;
1129   05AD             ; io syscall
1130   05AD             ;----------------------------------------------------------------------------------------------------;
1131   05AD             ; baud  divisor
1132   05AD             ; 50    2304
1133   05AD             ; 110   1047
1134   05AD             ; 300    384
1135   05AD             ; 600    192
1136   05AD             ; 1200    96
1137   05AD             ; 9600    12
1138   05AD             ; 19200    6
1139   05AD             ; 38400    3
1140   05AD             syscall_io_jmp:
1141   05AD E0 05         .dw syscall_io_putchar
1142   05AF ED 05         .dw syscall_io_getch
1143   05B1 B7 05         .dw syscall_io_uart_setup
1144   05B3             syscall_io:
1145   05B3 FD 0A AD 05   jmp [syscall_io_jmp + al]
1146   05B7             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1147   05B7             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1148   05B7             ; buffer, the transmitter holding register, or the interrupt enable register.
1149   05B7             syscall_io_uart_setup:
1150   05B7 1D 6F 17      mov al, [sys_uart0_lcr]
1151   05BA 8B 80         or al, $80                ; set dlab access bit
1152   05BC 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1153   05BF 1D 72 17      mov al, [sys_uart0_div0]
1154   05C2 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1155   05C5 1D 73 17      mov al, [sys_uart0_div1]
1156   05C8 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1157   05CB             
1158   05CB 1D 6F 17      mov al, [sys_uart0_lcr]
1159   05CE 87 7F         and al, $7f               ; clear dlab access bit 
1160   05D0 3D 83 FF      mov [_uart0_lcr], al
1161   05D3 1D 70 17      mov al, [sys_uart0_inten]
1162   05D6 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1163   05D9 1D 71 17      mov al, [sys_uart0_fifoen]
1164   05DC 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1165   05DF 06            sysret
1166   05E0             
1167   05E0             ; char in ah
1168   05E0             syscall_io_putchar:
1169   05E0             syscall_io_putchar_l0:
1170   05E0 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1171   05E3 87 20         and al, $20
1172   05E5 C6 E0 05      jz syscall_io_putchar_l0    
1173   05E8 1A            mov al, ah
1174   05E9 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1175   05EC 06            sysret
1176   05ED             
1177   05ED             ; char in ah
1178   05ED             ; al = sucess code
1179   05ED             syscall_io_getch:
1180   05ED D8            push b
1181   05EE DA            push d
1182   05EF FD 0C         sti
1183   05F1             syscall_io_getch_l0:  
1184   05F1 14 7C 17      mov a, [fifo_out]
1185   05F4 29 7A 17      mov b, [fifo_in]
1186   05F7 B0            cmp a, b
1187   05F8 C6 F1 05      je syscall_io_getch_l0
1188   05FB 3C            mov d, a
1189   05FC 77            inc a
1190   05FD AF DB 22      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1191   0600 C7 06 06      jne syscall_io_getch_cont
1192   0603 10 DB 1E      mov a, fifo  
1193   0606             syscall_io_getch_cont:  
1194   0606 42 7C 17      mov [fifo_out], a             ; update fifo pointer
1195   0609 1E            mov al, [d]                   ; get char
1196   060A 23            mov ah, al
1197   060B 1D 6E 17      mov al, [sys_echo_on]
1198   060E B9 01         cmp al, 1
1199   0610 C7 1F 06      jne syscall_io_getch_noecho 
1200   0613             ; here we just echo the char back to the console
1201   0613             syscall_io_getch_echo_l0:
1202   0613 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1203   0616 87 20         and al, $20                 ; isolate transmitter empty
1204   0618 C6 13 06      jz syscall_io_getch_echo_l0
1205   061B 1A            mov al, ah
1206   061C 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1207   061F             syscall_io_getch_noecho:
1208   061F 19 01         mov al, 1                    ; al = 1 means a char successfully received
1209   0621 E7            pop d
1210   0622 E5            pop b
1211   0623 06            sysret
1212   0624             
1213   0624             ;------------------------------------------------------------------------------------------------------;
1214   0624             ; file system data
1215   0624             ;------------------------------------------------------------------------------------------------------;
1216   0624             ; infor for : ide services interrupt
1217   0624             ; ide read/write 512-byte sector
1218   0624             ; al = option
1219   0624             ; user buffer pointer in d
1220   0624             ; ah = number of sectors
1221   0624             ; cb = lba bytes 3..0  
1222   0624             ;------------------------------------------------------------------------------------------------------;
1223   0624             ; file system data structure
1224   0624             ;------------------------------------------------------------------------------------------------------;
1225   0624             ; for a directory we have the header first, followed by metadata
1226   0624             ; header 1 sector (512 bytes)
1227   0624             ; metadata 1 sector (512 bytes)
1228   0624             ; header entries:
1229   0624             ; filename (64)
1230   0624             ; parent dir lba (2) -  to be used for faster backwards navigation...
1231   0624             ;
1232   0624             ; metadata entries:
1233   0624             ; filename (24)
1234   0624             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1235   0624             ; lba (2)
1236   0624             ; size (2)
1237   0624             ; day (1)
1238   0624             ; month (1)
1239   0624             ; year (1)
1240   0624             ; packet size = 32 bytes
1241   0624             ;
1242   0624             ; first directory on disk is the root directory '/'
1243   0624             file_system_jmptbl:
1244   0624 8F 06         .dw fs_mkfs                   ; 0
1245   0626 00 00         .dw 0                         ; 1
1246   0628 F1 06         .dw fs_mkdir                  ; 2
1247   062A 6A 0A         .dw fs_cd                     ; 3
1248   062C 71 0A         .dw fs_ls                     ; 4
1249   062E 5C 0B         .dw fs_mktxt                  ; 5
1250   0630 27 0C         .dw fs_mkbin                  ; 6
1251   0632 EE 0C         .dw fs_pwd                    ; 7
1252   0634 0B 0D         .dw fs_cat                    ; 8
1253   0636 67 0D         .dw fs_rmdir                  ; 9
1254   0638 C3 0D         .dw fs_rm                     ; 10
1255   063A 00 00         .dw 0                         ; 11
1256   063C 00 00         .dw 0                         ; 12
1257   063E 00 00         .dw 0                         ; 13
1258   0640 97 06         .dw fs_chmod                  ; 14
1259   0642 2B 0E         .dw fs_mv                     ; 15
1260   0644 90 06         .dw fs_cd_root                ; 16
1261   0646 66 0A         .dw fs_get_curr_dirid         ; 17
1262   0648 42 08         .dw fs_dir_id_to_path         ; 18
1263   064A A8 08         .dw fs_path_to_dir_id_user    ; 19
1264   064C C2 09         .dw fs_load_from_path_user    ; 20  
1265   064E 32 09         .dw fs_filepath_exists_user   ; 21
1266   0650             
1267   0650 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1267   0654 79 73 63 61 
1267   0658 6C 6C 5F 66 
1267   065C 69 6C 65 5F 
1267   0660 73 79 73 74 
1267   0664 65 6D 20 63 
1267   0668 61 6C 6C 65 
1267   066C 64 3A 20 00 
1268   0670             syscall_file_system:
1269   0670 DD            push bl
1270   0671 31 6D 17      mov bl, [sys_debug_mode]
1271   0674               ; debug block
1272   0674 C1 00         cmp bl, 0
1273   0676 EA            pop bl
1274   0677 C6 8B 06      je syscall_filesystem_jmp
1275   067A DA            push d
1276   067B DD            push bl
1277   067C 3B 50 06      mov d, s_syscall_fs_dbg0
1278   067F 07 44 12      call _puts
1279   0682 2F            mov bl, al
1280   0683 07 E4 12      call print_u8x
1281   0686 07 F1 11      call printnl
1282   0689 EA            pop bl
1283   068A E7            pop d
1284   068B             syscall_filesystem_jmp:
1285   068B FD 0A 24 06   jmp [file_system_jmptbl + al]
1286   068F             
1287   068F             fs_mkfs:  
1288   068F 06            sysret  
1289   0690               
1290   0690             fs_cd_root:
1291   0690 10 20 00      mov a, root_id
1292   0693 42 7E 17      mov [current_dir_id], a      ; set current directory lba to root
1293   0696 06            sysret  
1294   0697             
1295   0697             ; filename in d (userspace data)
1296   0697             ; permission in bl
1297   0697             fs_chmod:
1298   0697 DD            push bl
1299   0698 FD 4E         mov si, d
1300   069A FD 4F DB 1C   mov di, user_data
1301   069E 38 80 00      mov c, 128
1302   06A1 04            load                        ; load filename from user-space
1303   06A2 14 7E 17      mov a, [current_dir_id]
1304   06A5 77            inc a                       ; metadata sector
1305   06A6 27            mov b, a
1306   06A7 38 00 00      mov c, 0                    ; upper lba = 0
1307   06AA 22 01         mov ah, $01                  ; 1 sector
1308   06AC 3B DB 24      mov d, transient_area
1309   06AF 07 22 05      call ide_read_sect          ; read directory
1310   06B2 FD 10         cla
1311   06B4 42 76 17      mov [index], a              ; reset file counter
1312   06B7             fs_chmod_l1:
1313   06B7 FD 4E         mov si, d
1314   06B9 FD 4F DB 1C   mov di, user_data
1315   06BD 07 87 10      call _strcmp
1316   06C0 C6 D7 06      je fs_chmod_found_entry
1317   06C3 58 20 00      add d, 32
1318   06C6 14 76 17      mov a, [index]
1319   06C9 77            inc a
1320   06CA 42 76 17      mov [index], a
1321   06CD AF 10 00      cmp a, fst_files_per_dir
1322   06D0 C7 B7 06      jne fs_chmod_l1
1323   06D3 EA            pop bl
1324   06D4 0A F0 06      jmp fs_chmod_not_found
1325   06D7             fs_chmod_found_entry:  
1326   06D7 FD 79         mov g, b                    ; save lba
1327   06D9 EA            pop bl                      ; retrieve saved permission value
1328   06DA 1F 18 00      mov al, [d + 24]            ; read file permissions
1329   06DD 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1330   06DF 8C            or al, bl                   ; set new permissions
1331   06E0 3F 18 00      mov [d + 24], al            ; write new permissions
1332   06E3 38 00 00      mov c, 0
1333   06E6 3B DB 24      mov d, transient_area
1334   06E9 22 01         mov ah, $01                 ; disk write 1 sect
1335   06EB FD 27         mov b, g                    ; retrieve lba
1336   06ED 07 48 05      call ide_write_sect         ; write sector
1337   06F0             fs_chmod_not_found:
1338   06F0 06            sysret
1339   06F1             
1340   06F1             ;------------------------------------------------------------------------------------------------------;
1341   06F1             ; create new directory
1342   06F1             ;------------------------------------------------------------------------------------------------------;
1343   06F1             ; search list for null name entry. add new directory to list
1344   06F1             fs_mkdir:
1345   06F1 FD 4E         mov si, d
1346   06F3 FD 4F DB 1C   mov di, user_data
1347   06F7 38 00 02      mov c, 512
1348   06FA 04            load                        ; load data from user-space
1349   06FB 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1350   06FE                                           ; when checking for null name, since root has a null name)
1351   06FE 38 00 00      mov c, 0                    ; upper lba = 0
1352   0701             fs_mkdir_l1:  
1353   0701 22 01         mov ah, $01                  ; 1 sector
1354   0703 3B DB 24      mov d, transient_area
1355   0706 07 22 05      call ide_read_sect          ; read sector
1356   0709 BD 00         cmp byte[d], 0              ; check for null
1357   070B C6 14 07      je fs_mkdir_found_null
1358   070E 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1359   0711 0A 01 07      jmp fs_mkdir_l1
1360   0714             fs_mkdir_found_null:
1361   0714             ;create header file by grabbing dir name from parameter
1362   0714 D8            push b                      ; save new directory's lba
1363   0715 38 40 00      mov c, 64
1364   0718 FD 4D DB 1C   mov si, user_data
1365   071C FD 4F DB 24   mov di, transient_area
1366   0720 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1367   0722 14 7E 17      mov a, [current_dir_id]
1368   0725 42 1B 25      mov [transient_area + 64], a    ; store parent directory lba
1369   0728 19 00         mov al, 0
1370   072A FD 4F DB 26   mov di, transient_area + 512
1371   072E 38 00 02      mov c, 512
1372   0731 FD F7         rep stosb                       ; clean buffer
1373   0733 38 00 00      mov c, 0                        ; reset lba(c) to 0
1374   0736             ; write directory entry sectors
1375   0736 3B DB 24      mov d, transient_area
1376   0739 22 02         mov ah, $02                     ; disk write, 2 sectors
1377   073B 07 48 05      call ide_write_sect             ; write sector
1378   073E             ; now we need to add the new directory to the list, inside the current directory
1379   073E 14 7E 17      mov a, [current_dir_id]
1380   0741 53 01 00      add a, 1
1381   0744 27            mov b, a                        ; metadata sector
1382   0745 38 00 00      mov c, 0
1383   0748 FD 79         mov g, b                        ; save lba
1384   074A 3B DB 24      mov d, transient_area
1385   074D 22 01         mov ah, $01                  ; 1 sector
1386   074F 07 22 05      call ide_read_sect              ; read metadata sector
1387   0752             fs_mkdir_l2:
1388   0752 BD 00         cmp byte[d], 0
1389   0754 C6 5D 07      je fs_mkdir_found_null2
1390   0757 58 20 00      add d, fst_entry_size
1391   075A 0A 52 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1392   075D             fs_mkdir_found_null2:
1393   075D FD 4D DB 1C   mov si, user_data
1394   0761 FD 50         mov di, d
1395   0763 07 9C 10      call _strcpy                    ; copy directory name
1396   0766 58 18 00      add d, 24                       ; goto attributes
1397   0769 19 0B         mov al, %00001011               ; directory, no execute, write, read
1398   076B 3E            mov [d], al      
1399   076C 79            inc d
1400   076D E5            pop b
1401   076E D8            push b                          ; push lba back
1402   076F FD 43         mov [d], b                      ; save lba
1403   0771             ; set file creation date  
1404   0771 58 04 00      add d, 4
1405   0774 19 04         mov al, 4
1406   0776 05 01         syscall sys_rtc
1407   0778 1A            mov al, ah
1408   0779 3E            mov [d], al                     ; set day
1409   077A 79            inc d
1410   077B 19 05         mov al, 5
1411   077D 05 01         syscall sys_rtc
1412   077F 1A            mov al, ah
1413   0780 3E            mov [d], al                     ; set month
1414   0781 79            inc d
1415   0782 19 06         mov al, 6
1416   0784 05 01         syscall sys_rtc
1417   0786 1A            mov al, ah
1418   0787 3E            mov [d], al                     ; set year
1419   0788             ; write sector into disk for new directory entry
1420   0788 FD 27         mov b, g
1421   078A 38 00 00      mov c, 0
1422   078D 3B DB 24      mov d, transient_area
1423   0790 22 01         mov ah, $01                     ; disk write, 1 sector
1424   0792 07 48 05      call ide_write_sect             ; write sector
1425   0795             
1426   0795             ; after adding the new directory's information to its parent directory's list
1427   0795             ; we need to now enter the new directory, and to it add two new directories!
1428   0795             ; which directories do we need to add ? '..' and '.' are the directories needed.
1429   0795             ; importantly, note that these two new directories are only entries in the list
1430   0795             ; and do not have actual physical entries in the disk as real directories.
1431   0795             ; i.e. they only exist as list entries in the new directory created so that
1432   0795             ; the new directory can reference its parent and itself.
1433   0795             ; we need to add both '..' and '.'
1434   0795             ; this first section is for '..' and on the section below we do the same for '.'
1435   0795 E4            pop a                         ; retrieve the new directory's lba  
1436   0796 D7            push a                        ; and save again
1437   0797 53 01 00      add a, 1
1438   079A 27            mov b, a                      ; metadata sector
1439   079B 38 00 00      mov c, 0
1440   079E FD 79         mov g, b                      ; save lba
1441   07A0 3B DB 24      mov d, transient_area
1442   07A3 22 01         mov ah, $01                  ; 1 sector
1443   07A5 07 22 05      call ide_read_sect            ; read metadata sector
1444   07A8             fs_mkdir_l3:
1445   07A8 BD 00         cmp byte[d], 0
1446   07AA C6 B3 07      je fs_mkdir_found_null3
1447   07AD 58 20 00      add d, fst_entry_size
1448   07B0 0A A8 07      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1449   07B3             fs_mkdir_found_null3:
1450   07B3 FD 4D 9D 17   mov si, s_parent_dir
1451   07B7 FD 50         mov di, d
1452   07B9 07 9C 10      call _strcpy                  ; copy directory name
1453   07BC 58 18 00      add d, 24                     ; goto attributes
1454   07BF 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1455   07C1 3E            mov [d], al      
1456   07C2 79            inc d
1457   07C3 29 7E 17      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1458   07C6 FD 43         mov [d], b                    ; save lba
1459   07C8             ; set file creation date  
1460   07C8 58 04 00      add d, 4
1461   07CB 19 04         mov al, 4
1462   07CD 05 01         syscall sys_rtc
1463   07CF 1A            mov al, ah
1464   07D0 3E            mov [d], al                   ; set day
1465   07D1 79            inc d
1466   07D2 19 05         mov al, 5
1467   07D4 05 01         syscall sys_rtc
1468   07D6 1A            mov al, ah
1469   07D7 3E            mov [d], al                   ; set month
1470   07D8 79            inc d
1471   07D9 19 06         mov al, 6
1472   07DB 05 01         syscall sys_rtc
1473   07DD 1A            mov al, ah
1474   07DE 3E            mov [d], al                   ; set year
1475   07DF             ; write sector into disk for new directory entry
1476   07DF FD 27         mov b, g
1477   07E1 38 00 00      mov c, 0
1478   07E4 3B DB 24      mov d, transient_area
1479   07E7 22 01         mov ah, $01                   ; disk write, 1 sector
1480   07E9 07 48 05      call ide_write_sect           ; write sector
1481   07EC             ;;;;;;;;;;;;;
1482   07EC             ; like we did above for '..', we need to now add the '.' directory to the list.
1483   07EC             ;------------------------------------------------------------------------------------------------------;
1484   07EC E4            pop a                         ; retrieve the new directory's lba  
1485   07ED D7            push a
1486   07EE 53 01 00      add a, 1
1487   07F1 27            mov b, a                      ; metadata sector
1488   07F2 38 00 00      mov c, 0
1489   07F5 FD 79         mov g, b                      ; save lba
1490   07F7 3B DB 24      mov d, transient_area
1491   07FA 22 01         mov ah, $01                  ; 1 sector
1492   07FC 07 22 05      call ide_read_sect            ; read metadata sector
1493   07FF             fs_mkdir_l4:
1494   07FF BD 00         cmp byte[d], 0
1495   0801 C6 0A 08      je fs_mkdir_found_null4
1496   0804 58 20 00      add d, fst_entry_size
1497   0807 0A FF 07      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1498   080A             fs_mkdir_found_null4:
1499   080A FD 4D A0 17   mov si, s_current_dir
1500   080E FD 50         mov di, d
1501   0810 07 9C 10      call _strcpy                  ; copy directory name
1502   0813 58 18 00      add d, 24                     ; goto attributes
1503   0816 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1504   0818 3E            mov [d], al      
1505   0819 79            inc d
1506   081A E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1507   081B FD 43         mov [d], b                    ; save lba
1508   081D             ; set file creation date  
1509   081D 58 04 00      add d, 4
1510   0820 19 04         mov al, 4
1511   0822 05 01         syscall sys_rtc
1512   0824 1A            mov al, ah
1513   0825 3E            mov [d], al                   ; set day
1514   0826 79            inc d
1515   0827 19 05         mov al, 5
1516   0829 05 01         syscall sys_rtc
1517   082B 1A            mov al, ah
1518   082C 3E            mov [d], al                   ; set month
1519   082D 79            inc d
1520   082E 19 06         mov al, 6
1521   0830 05 01         syscall sys_rtc
1522   0832 1A            mov al, ah
1523   0833 3E            mov [d], al                   ; set year
1524   0834             ; write sector into disk for new directory entry
1525   0834 FD 27         mov b, g
1526   0836 38 00 00      mov c, 0
1527   0839 3B DB 24      mov d, transient_area
1528   083C 22 01         mov ah, $01                   ; disk write, 1 sector
1529   083E 07 48 05      call ide_write_sect           ; write sector
1530   0841             fs_mkdir_end:
1531   0841 06            sysret
1532   0842             
1533   0842             ;------------------------------------------------------------------------------------------------------;
1534   0842             ; get path from a given directory dirid
1535   0842             ; pseudo code:
1536   0842             ;  fs_dir_id_to_path(int dirid, char *d){
1537   0842             ;    if(dirid == 0){
1538   0842             ;      reverse path in d;
1539   0842             ;      return;
1540   0842             ;    }
1541   0842             ;    else{
1542   0842             ;      copy directory name to end of d;
1543   0842             ;      add '/' to end of d;
1544   0842             ;      parentid = get parent directory id;
1545   0842             ;      fs_dir_id_to_path(parentid, d);
1546   0842             ;    }
1547   0842             ;  }
1548   0842             ; a = dirid
1549   0842             ; d = generated path string pointer
1550   0842             ;------------------------------------------------------------------------------------------------------;
1551   0842             ; sample path: /usr/bin
1552   0842             fs_dir_id_to_path:
1553   0842 3B 5B 1C      mov d, filename
1554   0845 19 00         mov al, 0
1555   0847 3E            mov [d], al                     ; initialize path string 
1556   0848 14 7E 17      mov a, [current_dir_id]
1557   084B 07 58 08      call fs_dir_id_to_path_e0
1558   084E 3B 5B 1C      mov d, filename
1559   0851 07 30 10      call _strrev
1560   0854 07 44 12      call _puts
1561   0857 06            sysret
1562   0858             fs_dir_id_to_path_e0:
1563   0858 07 77 08      call get_dirname_from_dirid
1564   085B FD 4D A2 17   mov si, s_fslash
1565   085F FD 50         mov di, d
1566   0861 07 AA 10      call _strcat                    ; add '/' to end of path
1567   0864 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1568   0867 C6 76 08      je fs_dir_id_to_path_root
1569   086A 07 94 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1570   086D AF 20 00      cmp a, root_id               ; check if we are at the root directory
1571   0870 C6 76 08      je fs_dir_id_to_path_root
1572   0873 07 58 08      call fs_dir_id_to_path_e0     ; recursively call itself
1573   0876             fs_dir_id_to_path_root:
1574   0876 09            ret
1575   0877             
1576   0877             ;------------------------------------------------------------------------------------------------------;
1577   0877             ; in_puts:
1578   0877             ; a = directory id
1579   0877             ; out_puts:
1580   0877             ; d = pointer to directory name string
1581   0877             ;------------------------------------------------------------------------------------------------------;
1582   0877             get_dirname_from_dirid:
1583   0877 D7            push a
1584   0878 D8            push b
1585   0879 DA            push d
1586   087A 27            mov b, a
1587   087B 38 00 00      mov c, 0                      ; upper lba = 0
1588   087E 22 01         mov ah, $01                  ; 1 sector
1589   0880 3B DB 22      mov d, transient_area - 512
1590   0883 07 22 05      call ide_read_sect            ; read directory
1591   0886 07 30 10      call _strrev                  ; reverse dir name before copying
1592   0889 FD 4E         mov si, d
1593   088B E7            pop d                         ; destination address = d value pushed at beginning
1594   088C FD 50         mov di, d
1595   088E 07 AA 10      call _strcat                  ; copy filename to d
1596   0891 E5            pop b
1597   0892 E4            pop a
1598   0893 09            ret
1599   0894             
1600   0894             ;------------------------------------------------------------------------------------------------------;
1601   0894             ; in_puts:
1602   0894             ; a = directory id
1603   0894             ; out_puts:
1604   0894             ; a = parent directory id
1605   0894             ;------------------------------------------------------------------------------------------------------;
1606   0894             get_parentid_from_dirid:
1607   0894 D8            push b
1608   0895 DA            push d
1609   0896 27            mov b, a
1610   0897 38 00 00      mov c, 0                      ; upper lba = 0
1611   089A 22 01         mov ah, $01                  ; 1 sector
1612   089C 3B DB 22      mov d, transient_area - 512
1613   089F 07 22 05      call ide_read_sect            ; read directory
1614   08A2 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1615   08A5 E7            pop d
1616   08A6 E5            pop b
1617   08A7 09            ret
1618   08A8             
1619   08A8             ;------------------------------------------------------------------------------------------------------;
1620   08A8             ; get dirid from a given path string
1621   08A8             ; in_puts:
1622   08A8             ; d = path pointer 
1623   08A8             ; out_puts:
1624   08A8             ; a = dirid
1625   08A8             ; if dir non existent, a = ffff (fail code)
1626   08A8             ; /usr/local/bin    - absolute
1627   08A8             ; local/bin/games    - relative
1628   08A8             ;------------------------------------------------------------------------------------------------------;
1629   08A8             fs_path_to_dir_id_user:
1630   08A8 FD 4E         mov si, d
1631   08AA FD 4F DB 1C   mov di, user_data
1632   08AE 38 00 02      mov c, 512
1633   08B1 04            load
1634   08B2 07 B6 08      call get_dirid_from_path
1635   08B5 06            sysret
1636   08B6             get_dirid_from_path:
1637   08B6 26 DB 1C      mov b, user_data
1638   08B9 FD 42 69 16   mov [prog], b                  ; token pointer set to path string
1639   08BD 07 CA 14      call get_token
1640   08C0 31 6C 16      mov bl, [tok]
1641   08C3 C1 01         cmp bl, tok_fslash
1642   08C5 C6 D1 08      je get_dirid_from_path_abs 
1643   08C8 14 7E 17      mov a, [current_dir_id]
1644   08CB 07 50 16      call _putback
1645   08CE 0A D4 08      jmp get_dirid_from_path_e0
1646   08D1             get_dirid_from_path_abs:
1647   08D1 10 20 00      mov a, root_id
1648   08D4             get_dirid_from_path_e0:
1649   08D4 07 CA 14      call get_token
1650   08D7 31 6B 16      mov bl, [toktyp]
1651   08DA C1 00         cmp bl, toktyp_identifier
1652   08DC C7 2D 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1653   08DF             
1654   08DF FD 4D 6D 16   mov si, tokstr
1655   08E3 FD 4F 5B 1C   mov di, filename
1656   08E7 07 9C 10      call _strcpy        
1657   08EA 77            inc a                         ; metadata sector
1658   08EB 27            mov b, a
1659   08EC 38 00 00      mov c, 0                      ; upper lba = 0
1660   08EF 22 01         mov ah, $01                  ; 1 sector
1661   08F1 3B DB 24      mov d, transient_area
1662   08F4 07 22 05      call ide_read_sect            ; read directory
1663   08F7 FD 10         cla
1664   08F9 42 76 17      mov [index], a
1665   08FC             get_dirid_from_path_l1:
1666   08FC FD 4E         mov si, d
1667   08FE FD 4F 5B 1C   mov di, filename
1668   0902 07 87 10      call _strcmp
1669   0905 C6 1B 09      je get_dirid_from_path_name_equal  
1670   0908 58 20 00      add d, 32
1671   090B 14 76 17      mov a, [index]
1672   090E 77            inc a
1673   090F 42 76 17      mov [index], a
1674   0912 AF 10 00      cmp a, fst_files_per_dir
1675   0915 C6 2E 09      je get_dirid_from_path_fail
1676   0918 0A FC 08      jmp get_dirid_from_path_l1
1677   091B             get_dirid_from_path_name_equal:
1678   091B 58 19 00      add d, 25           
1679   091E 15            mov a, [d]                    ; set result register a = dirid
1680   091F 07 CA 14      call get_token
1681   0922 31 6C 16      mov bl, [tok]
1682   0925 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1683   0927 C6 D4 08      je get_dirid_from_path_e0
1684   092A 07 50 16      call _putback
1685   092D             get_dirid_from_path_end:
1686   092D 09            ret
1687   092E             get_dirid_from_path_fail:
1688   092E 10 FF FF      mov a, $ffff
1689   0931 09            ret
1690   0932             
1691   0932             
1692   0932             ;------------------------------------------------------------------------------------------------------;
1693   0932             ; check if file exists by a given path string
1694   0932             ; in_puts:
1695   0932             ; d = path pointer 
1696   0932             ; outputs:
1697   0932             ; a = success code, if file exists gives lba, else, give 0
1698   0932             ; /usr/local/bin/ed
1699   0932             ;------------------------------------------------------------------------------------------------------;
1700   0932             fs_filepath_exists_user:
1701   0932 FD 4E         mov si, d
1702   0934 FD 4F DB 1C   mov di, user_data
1703   0938 38 00 02      mov c, 512
1704   093B 04            load
1705   093C 07 40 09      call file_exists_by_path
1706   093F 06            sysret
1707   0940             file_exists_by_path:
1708   0940 26 DB 1C      mov b, user_data
1709   0943 FD 42 69 16   mov [prog], b                   ; token pointer set to path string
1710   0947 07 CA 14      call get_token
1711   094A 31 6C 16      mov bl, [tok]
1712   094D C1 01         cmp bl, tok_fslash
1713   094F C6 5B 09      je  file_exists_by_path_abs
1714   0952 14 7E 17      mov a, [current_dir_id]
1715   0955 07 50 16      call _putback
1716   0958 0A 5E 09      jmp file_exists_by_path_e0
1717   095B             file_exists_by_path_abs:
1718   095B 10 20 00      mov a, root_id
1719   095E             file_exists_by_path_e0:
1720   095E 07 CA 14      call get_token
1721   0961 31 6B 16      mov bl, [toktyp]
1722   0964 C1 00         cmp bl, toktyp_identifier
1723   0966 C7 BE 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1724   0969 FD 4D 6D 16   mov si, tokstr
1725   096D FD 4F 5B 1C   mov di, filename
1726   0971 07 9C 10      call _strcpy        
1727   0974 77            inc a                           ; metadata sector
1728   0975 27            mov b, a
1729   0976 38 00 00      mov c, 0                        ; upper lba = 0
1730   0979 22 01         mov ah, $01                  ; 1 sector
1731   097B 3B DB 24      mov d, transient_area
1732   097E 07 22 05      call ide_read_sect              ; read directory
1733   0981 FD 10         cla
1734   0983 42 76 17      mov [index], a
1735   0986             file_exists_by_path_l1:
1736   0986 FD 4E         mov si, d
1737   0988 FD 4F 5B 1C   mov di, filename
1738   098C 07 87 10      call _strcmp
1739   098F C6 A5 09      je   file_exists_by_path_name_equal
1740   0992 58 20 00      add d, 32
1741   0995 14 76 17      mov a, [index]
1742   0998 77            inc a
1743   0999 42 76 17      mov [index], a
1744   099C AF 10 00      cmp a, fst_files_per_dir
1745   099F C6 BE 09      je file_exists_by_path_end
1746   09A2 0A 86 09      jmp file_exists_by_path_l1
1747   09A5             file_exists_by_path_name_equal:
1748   09A5 33 18 00      mov bl, [d + 24]
1749   09A8 FD 87 38      and bl, %00111000               ; directory flag
1750   09AB C1 08         cmp bl, %00001000               ; is dir?
1751   09AD C6 B4 09      je file_exists_by_path_isdir;
1752   09B0             ; entry is a file
1753   09B0 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1754   09B3 09            ret
1755   09B4             file_exists_by_path_isdir:
1756   09B4 58 19 00      add d, 25           
1757   09B7 15            mov a, [d]                      ; set result register a = dirid
1758   09B8 07 CA 14      call get_token
1759   09BB 0A 5E 09      jmp file_exists_by_path_e0
1760   09BE             file_exists_by_path_end:
1761   09BE 10 00 00      mov a, 0                        ; return 0 because file was not found
1762   09C1 09            ret
1763   09C2             
1764   09C2             ;------------------------------------------------------------------------------------------------------;
1765   09C2             ; load file data from a given path string
1766   09C2             ; inputs:
1767   09C2             ; d = path pointer 
1768   09C2             ; di = userspace program data destination
1769   09C2             ; /usr/local/bin/ed
1770   09C2             ; ./ed
1771   09C2             ;------------------------------------------------------------------------------------------------------;
1772   09C2             fs_load_from_path_user:
1773   09C2 E3            push di
1774   09C3 FD 4E         mov si, d
1775   09C5 FD 4F DB 1C   mov di, user_data
1776   09C9 38 00 02      mov c, 512
1777   09CC 04            load
1778   09CD 07 DA 09      call loadfile_from_path
1779   09D0 F0            pop di
1780   09D1 FD 4D DB 24   mov si, transient_area
1781   09D5 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1782   09D8 03            store
1783   09D9 06            sysret
1784   09DA             loadfile_from_path:
1785   09DA 26 DB 1C      mov b, user_data
1786   09DD FD 42 69 16   mov [prog], b                 ; token pointer set to path string
1787   09E1 07 CA 14      call get_token
1788   09E4 31 6C 16      mov bl, [tok]
1789   09E7 C1 01         cmp bl, tok_fslash
1790   09E9 C6 F5 09      je loadfile_from_path_abs 
1791   09EC 14 7E 17      mov a, [current_dir_id]
1792   09EF 07 50 16      call _putback
1793   09F2 0A F8 09      jmp loadfile_from_path_e0
1794   09F5             loadfile_from_path_abs:
1795   09F5 10 20 00      mov a, root_id
1796   09F8             loadfile_from_path_e0:
1797   09F8 07 CA 14      call get_token
1798   09FB 31 6B 16      mov bl, [toktyp]
1799   09FE C1 00         cmp bl, toktyp_identifier
1800   0A00 C7 65 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1801   0A03 FD 4D 6D 16   mov si, tokstr
1802   0A07 FD 4F 5B 1C   mov di, filename
1803   0A0B 07 9C 10      call _strcpy        
1804   0A0E 77            inc a                         ; metadata sector
1805   0A0F 27            mov b, a
1806   0A10 38 00 00      mov c, 0                      ; upper lba = 0
1807   0A13 22 01         mov ah, $01                  ; 1 sector
1808   0A15 3B DB 24      mov d, transient_area
1809   0A18 07 22 05      call ide_read_sect            ; read directory
1810   0A1B FD 10         cla
1811   0A1D 42 76 17      mov [index], a
1812   0A20             loadfile_from_path_l1:
1813   0A20 FD 4E         mov si, d
1814   0A22 FD 4F 5B 1C   mov di, filename
1815   0A26 07 87 10      call _strcmp
1816   0A29 C6 3F 0A      je loadfile_from_path_name_equal  
1817   0A2C 58 20 00      add d, 32
1818   0A2F 14 76 17      mov a, [index]
1819   0A32 77            inc a
1820   0A33 42 76 17      mov [index], a
1821   0A36 AF 10 00      cmp a, fst_files_per_dir
1822   0A39 C6 65 0A      je loadfile_from_path_end
1823   0A3C 0A 20 0A      jmp loadfile_from_path_l1
1824   0A3F             loadfile_from_path_name_equal:
1825   0A3F 33 18 00      mov bl, [d + 24]
1826   0A42 FD 87 38      and bl, %00111000             ; directory flag
1827   0A45 C1 08         cmp bl, %00001000             ; is dir?
1828   0A47 C6 5B 0A      je loadfile_isdirectory  
1829   0A4A             ; entry is a file
1830   0A4A 2B 19 00      mov b, [d + 25]               ; get lba
1831   0A4D FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1832   0A4F 3B DB 24      mov d, transient_area
1833   0A52 38 00 00      mov c, 0
1834   0A55 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1835   0A57 07 22 05      call ide_read_sect            ; read sector
1836   0A5A 09            ret
1837   0A5B             loadfile_isdirectory:
1838   0A5B 58 19 00      add d, 25           
1839   0A5E 15            mov a, [d]                    ; set result register a = dirid
1840   0A5F 07 CA 14      call get_token
1841   0A62 0A F8 09      jmp loadfile_from_path_e0
1842   0A65             loadfile_from_path_end:
1843   0A65 09            ret
1844   0A66             
1845   0A66             ;------------------------------------------------------------------------------------------------------;
1846   0A66             ; return the id of the current directory
1847   0A66             ; id returned in b
1848   0A66             ;------------------------------------------------------------------------------------------------------;
1849   0A66             fs_get_curr_dirid:
1850   0A66 29 7E 17      mov b, [current_dir_id]
1851   0A69 06            sysret
1852   0A6A             
1853   0A6A             ;------------------------------------------------------------------------------------------------------;
1854   0A6A             ; cd
1855   0A6A             ;------------------------------------------------------------------------------------------------------;
1856   0A6A             ; new dirid in b
1857   0A6A             fs_cd:
1858   0A6A FD 42 7E 17   mov [current_dir_id], b
1859   0A6E 06            sysret  
1860   0A6F             
1861   0A6F             ;------------------------------------------------------------------------------------------------------;
1862   0A6F             ; ls
1863   0A6F             ; dirid in b
1864   0A6F             ;------------------------------------------------------------------------------------------------------;
1865   0A6F 00 00       ls_count:       .dw 0
1866   0A71             fs_ls:
1867   0A71 FD 77         inc b                        ; metadata sector
1868   0A73 38 00 00      mov c, 0                     ; upper lba = 0
1869   0A76 22 01         mov ah, $01                  ; 1 sector
1870   0A78 3B DB 24      mov d, transient_area
1871   0A7B 07 22 05      call ide_read_sect           ; read directory
1872   0A7E FD 10         cla
1873   0A80 42 76 17      mov [index], a               ; reset entry index
1874   0A83 3D 6F 0A      mov [ls_count], al           ; reset item count
1875   0A86             fs_ls_l1:
1876   0A86 BD 00         cmp byte [d], 0              ; check for null
1877   0A88 C6 1F 0B      je fs_ls_next
1878   0A8B             fs_ls_non_null:
1879   0A8B 1D 6F 0A      mov al, [ls_count]
1880   0A8E 7A            inc al
1881   0A8F 3D 6F 0A      mov [ls_count], al           ; increment item count
1882   0A92 1F 18 00      mov al, [d + 24]
1883   0A95 87 38         and al, %00111000
1884   0A97 FD A2 03      shr al, 3
1885   0A9A 22 00         mov ah, 0                    ; file type
1886   0A9C B7 A9 17      mov a, [a + file_type]      
1887   0A9F 23            mov ah, al
1888   0AA0 07 18 11      call _putchar
1889   0AA3 1F 18 00      mov al, [d + 24]
1890   0AA6 87 01         and al, %00000001
1891   0AA8 22 00         mov ah, 0
1892   0AAA B7 A4 17      mov a, [a + file_attrib]     ; read
1893   0AAD 23            mov ah, al
1894   0AAE 07 18 11      call _putchar
1895   0AB1 1F 18 00      mov al, [d + 24]
1896   0AB4 87 02         and al, %00000010
1897   0AB6 22 00         mov ah, 0
1898   0AB8 B7 A4 17      mov a, [a + file_attrib]     ; write
1899   0ABB 23            mov ah, al
1900   0ABC 07 18 11      call _putchar
1901   0ABF 1F 18 00      mov al, [d + 24]
1902   0AC2 87 04         and al, %00000100
1903   0AC4 22 00         mov ah, 0
1904   0AC6 B7 A4 17      mov a, [a + file_attrib]     ; execute
1905   0AC9 23            mov ah, al
1906   0ACA 07 18 11      call _putchar
1907   0ACD 22 20         mov ah, $20
1908   0ACF 07 18 11      call _putchar  
1909   0AD2 2B 1B 00      mov b, [d + 27]
1910   0AD5 07 A0 12      call print_u16x              ; filesize
1911   0AD8 22 20         mov ah, $20
1912   0ADA 07 18 11      call _putchar  
1913   0ADD 2B 19 00      mov b, [d + 25]
1914   0AE0 07 A0 12      call print_u16x              ; dirid / lba
1915   0AE3 22 20         mov ah, $20
1916   0AE5 07 18 11      call _putchar
1917   0AE8             ; print date
1918   0AE8 33 1D 00      mov bl, [d + 29]             ; day
1919   0AEB 07 E4 12      call print_u8x
1920   0AEE 22 20         mov ah, $20
1921   0AF0 07 18 11      call _putchar  
1922   0AF3 1F 1E 00      mov al, [d + 30]             ; month
1923   0AF6 FD 9E 02      shl al, 2
1924   0AF9 DA            push d
1925   0AFA 3B 68 18      mov d, s_months
1926   0AFD 22 00         mov ah, 0
1927   0AFF 59            add d, a
1928   0B00 07 44 12      call _puts
1929   0B03 E7            pop d
1930   0B04 22 20         mov ah, $20
1931   0B06 07 18 11      call _putchar
1932   0B09 2E 20         mov bl, $20
1933   0B0B 07 E4 12      call print_u8x
1934   0B0E 33 1F 00      mov bl, [d + 31]             ; year
1935   0B11 07 E4 12      call print_u8x  
1936   0B14 22 20         mov ah, $20
1937   0B16 07 18 11      call _putchar  
1938   0B19 07 44 12      call _puts                   ; print filename  
1939   0B1C 07 F1 11      call printnl
1940   0B1F             fs_ls_next:
1941   0B1F 14 76 17      mov a, [index]
1942   0B22 77            inc a
1943   0B23 42 76 17      mov [index], a
1944   0B26 AF 10 00      cmp a, fst_files_per_dir
1945   0B29 C6 32 0B      je fs_ls_end
1946   0B2C 58 20 00      add d, 32      
1947   0B2F 0A 86 0A      jmp fs_ls_l1  
1948   0B32             fs_ls_end:
1949   0B32 3B B9 17      mov d, s_ls_total
1950   0B35 07 44 12      call _puts
1951   0B38 1D 6F 0A      mov al, [ls_count]
1952   0B3B 07 F6 12      call print_u8d
1953   0B3E 07 F1 11      call printnl
1954   0B41 06            sysret
1955   0B42             
1956   0B42             ;------------------------------------------------------------------------------------------------------;
1957   0B42             ; finds an empty data block
1958   0B42             ; block lba returned in b
1959   0B42             ;------------------------------------------------------------------------------------------------------;
1960   0B42             fs_find_empty_block:
1961   0B42 26 A0 00      mov b, fs_lba_start     ; raw files starting block
1962   0B45 38 00 00      mov c, 0                ; upper lba = 0
1963   0B48             fs_find_empty_block_l1:  
1964   0B48 22 01         mov ah, $01                  ; 1 sector
1965   0B4A 3B DB 22      mov d, transient_area - 512
1966   0B4D 07 22 05      call ide_read_sect      ; read sector
1967   0B50 BD 00         cmp byte [d], 0
1968   0B52 C6 5B 0B      je fs_find_empty_block_found_null
1969   0B55 55 20 00      add b, fs_sectors_per_file
1970   0B58 0A 48 0B      jmp fs_find_empty_block_l1
1971   0B5B             fs_find_empty_block_found_null:
1972   0B5B 09            ret
1973   0B5C             
1974   0B5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1975   0B5C             ;; create new textfile
1976   0B5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1977   0B5C             ; search for first null block
1978   0B5C             fs_mktxt:
1979   0B5C FD 4E       	mov si, d
1980   0B5E FD 4F DB 1C 	mov di, user_data
1981   0B62 38 00 01    	mov c, 256
1982   0B65 04          	load					; load data from user-space
1983   0B66             	
1984   0B66 26 A0 00    	mov b, fs_lba_start		; raw files starting block
1985   0B69 38 00 00    	mov c, 0						; reset lba to 0
1986   0B6C             fs_mktxt_l1:	
1987   0B6C 10 02 01    	mov a, $0102			; disk read
1988   0B6F 3B DB 24    	mov d, transient_area
1989   0B72 05 02       	syscall sys_ide ; read sector
1990   0B74 1E          	mov al, [d]
1991   0B75 B9 00       	cmp al, 0			; check for null
1992   0B77 C6 80 0B    	je fs_mktxt_found_null
1993   0B7A 55 20 00    	add b, fs_sectors_per_file
1994   0B7D 0A 6C 0B    	jmp fs_mktxt_l1
1995   0B80             fs_mktxt_found_null:
1996   0B80 D8          	push b				; save lba
1997   0B81             ;create header file by grabbing file name from parameter	
1998   0B81 3B 9A 17    	mov d, s_dataentry
1999   0B84 07 44 12    	call _puts
2000   0B87 3B DB 26    	mov d, transient_area + 512			; pointer to file contents
2001   0B8A 07 AA 11    	call _gettxt
2002   0B8D 07 77 10    	call _strlen						; get length of file
2003   0B90 D9          	push c							; save length
2004   0B91 19 01       	mov al, 1
2005   0B93 3D DB 24    	mov [transient_area], al					; mark sectors as used (not null)
2006   0B96 10 00 00    	mov a, 0
2007   0B99 42 76 17    	mov [index], a
2008   0B9C 3B DB 24    	mov d, transient_area
2009   0B9F 13          	mov a, d
2010   0BA0 42 78 17    	mov [buffer_addr], a
2011   0BA3             fs_mktxt_l2:
2012   0BA3 38 00 00    	mov c, 0
2013   0BA6 10 03 01    	mov a, $0103			; disk write, 1 sector
2014   0BA9 05 02       	syscall sys_ide		; write sector
2015   0BAB 14 76 17    	mov a, [index]
2016   0BAE 77          	inc a
2017   0BAF 42 76 17    	mov [index], a
2018   0BB2 AF 20 00    	cmp a, fs_sectors_per_file
2019   0BB5 C6 C7 0B    	je fs_mktxt_add_to_dir
2020   0BB8 FD 77       	inc b
2021   0BBA 14 78 17    	mov a, [buffer_addr]
2022   0BBD 53 00 02    	add a, 512
2023   0BC0 42 78 17    	mov [buffer_addr], a
2024   0BC3 3C          	mov d, a
2025   0BC4 0A A3 0B    	jmp fs_mktxt_l2
2026   0BC7             ; now we add the file to the current directory!
2027   0BC7             fs_mktxt_add_to_dir:	
2028   0BC7 14 7E 17    	mov a, [current_dir_id]
2029   0BCA 77          	inc a
2030   0BCB 27          	mov b, a					; metadata sector
2031   0BCC 38 00 00    	mov c, 0
2032   0BCF FD 79       	mov g, b					; save lba
2033   0BD1 3B DB 24    	mov d, transient_area
2034   0BD4 10 02 01    	mov a, $0102			; disk read
2035   0BD7 05 02       	syscall sys_ide		; read metadata sector
2036   0BD9             fs_mktxt_add_to_dir_l2:
2037   0BD9 1E          	mov al, [d]
2038   0BDA B9 00       	cmp al, 0
2039   0BDC C6 E5 0B    	je fs_mktxt_add_to_dir_null
2040   0BDF 58 20 00    	add d, fst_entry_size
2041   0BE2 0A D9 0B    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2042   0BE5             fs_mktxt_add_to_dir_null:
2043   0BE5 FD 4D DB 1C 	mov si, user_data
2044   0BE9 FD 50       	mov di, d
2045   0BEB 07 9C 10    	call _strcpy			; copy file name
2046   0BEE 58 18 00    	add d, 24			; skip name
2047   0BF1 19 06       	mov al, %00000110		; no execute, write, read, not directory
2048   0BF3 3E          	mov [d], al			
2049   0BF4 58 03 00    	add d, 3
2050   0BF7 E4          	pop a
2051   0BF8 43          	mov [d], a
2052   0BF9 63 02 00    	sub d, 2
2053   0BFC E5          	pop b				; get file lba
2054   0BFD FD 43       	mov [d], b			; save lba	
2055   0BFF             	
2056   0BFF             	; set file creation date	
2057   0BFF 58 04 00    	add d, 4
2058   0C02 19 04       	mov al, 4
2059   0C04 05 01       	syscall sys_rtc
2060   0C06 1A          	mov al, ah
2061   0C07 3E          	mov [d], al			; set day
2062   0C08             	
2063   0C08 79          	inc d
2064   0C09 19 05       	mov al, 5
2065   0C0B 05 01       	syscall sys_rtc
2066   0C0D 1A          	mov al, ah
2067   0C0E 3E          	mov [d], al			; set month
2068   0C0F             	
2069   0C0F 79          	inc d
2070   0C10 19 06       	mov al, 6
2071   0C12 05 01       	syscall sys_rtc
2072   0C14 1A          	mov al, ah
2073   0C15 3E          	mov [d], al			; set year
2074   0C16             	
2075   0C16             ; write sector into disk for new directory entry
2076   0C16 FD 27       	mov b, g
2077   0C18 38 00 00    	mov c, 0
2078   0C1B 3B DB 24    	mov d, transient_area
2079   0C1E 10 03 01    	mov a, $0103			; disk write, 1 sector
2080   0C21 05 02       	syscall sys_ide		; write sector
2081   0C23 07 F1 11    	call printnl
2082   0C26 06          	sysret
2083   0C27             
2084   0C27             
2085   0C27             
2086   0C27             ;------------------------------------------------------------------------------------------------------;
2087   0C27             ; create new binary file
2088   0C27             ;------------------------------------------------------------------------------------------------------;
2089   0C27             ; search for first null block
2090   0C27             fs_mkbin:
2091   0C27 19 00         mov al, 0
2092   0C29 3D 6E 17      mov [sys_echo_on], al ; disable echo
2093   0C2C FD 4E         mov si, d
2094   0C2E FD 4F DB 1C   mov di, user_data
2095   0C32 38 00 02      mov c, 512
2096   0C35 04            load                          ; load data from user-space
2097   0C36 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2098   0C39 38 00 00      mov c, 0                      ; upper lba = 0
2099   0C3C             fs_mkbin_l1:  
2100   0C3C 22 01         mov ah, $01                  ; 1 sector
2101   0C3E 3B DB 24      mov d, transient_area
2102   0C41 07 22 05      call ide_read_sect            ; read sector
2103   0C44 BD 00         cmp byte[d], 0                ; check for null
2104   0C46 C6 4F 0C      je fs_mkbin_found_null
2105   0C49 55 20 00      add b, fs_sectors_per_file
2106   0C4C 0A 3C 0C      jmp fs_mkbin_l1
2107   0C4F             fs_mkbin_found_null:
2108   0C4F D8            push b                        ; save lba
2109   0C50             ;create header file by grabbing file name from parameter
2110   0C50 FD 4F DB 26   mov di, transient_area + 512  ; pointer to file contents
2111   0C54 07 CA 0F      call _load_hex                ; load binary hex
2112   0C57 D9            push c                        ; save size (nbr of bytes)
2113   0C58 19 01         mov al, 1
2114   0C5A 3D DB 24      mov [transient_area], al      ; mark sectors as used (not null)
2115   0C5D FD 10         cla
2116   0C5F 42 76 17      mov [index], a
2117   0C62 3B DB 24      mov d, transient_area
2118   0C65 13            mov a, d
2119   0C66 42 78 17      mov [buffer_addr], a
2120   0C69             fs_mkbin_l2:
2121   0C69 38 00 00      mov c, 0
2122   0C6C 22 01         mov ah, $01                   ; disk write, 1 sector
2123   0C6E 07 48 05      call ide_write_sect           ; write sector
2124   0C71 14 76 17      mov a, [index]
2125   0C74 77            inc a
2126   0C75 42 76 17      mov [index], a
2127   0C78 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2128   0C7B C6 8D 0C      je fs_mkbin_add_to_dir
2129   0C7E FD 77         inc b
2130   0C80 14 78 17      mov a, [buffer_addr]
2131   0C83 53 00 02      add a, 512
2132   0C86 42 78 17      mov [buffer_addr], a
2133   0C89 3C            mov d, a
2134   0C8A 0A 69 0C      jmp fs_mkbin_l2
2135   0C8D             ; now we add the file to the current directory!
2136   0C8D             fs_mkbin_add_to_dir:  
2137   0C8D 14 7E 17      mov a, [current_dir_id]
2138   0C90 77            inc a
2139   0C91 27            mov b, a                      ; metadata sector
2140   0C92 38 00 00      mov c, 0
2141   0C95 FD 79         mov g, b                      ; save lba
2142   0C97 3B DB 24      mov d, transient_area
2143   0C9A 22 01         mov ah, $01                  ; 1 sector
2144   0C9C 07 22 05      call ide_read_sect            ; read metadata sector
2145   0C9F             fs_mkbin_add_to_dir_l2:
2146   0C9F BD 00         cmp byte[d], 0
2147   0CA1 C6 AA 0C      je fs_mkbin_add_to_dir_null
2148   0CA4 58 20 00      add d, fst_entry_size
2149   0CA7 0A 9F 0C      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2150   0CAA             fs_mkbin_add_to_dir_null:
2151   0CAA FD 4D DB 1C   mov si, user_data
2152   0CAE FD 50         mov di, d
2153   0CB0 07 9C 10      call _strcpy                  ; copy file name
2154   0CB3 58 18 00      add d, 24                     ; skip name
2155   0CB6 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2156   0CB8 3E            mov [d], al
2157   0CB9 58 03 00      add d, 3
2158   0CBC E4            pop a
2159   0CBD 43            mov [d], a
2160   0CBE 63 02 00      sub d, 2
2161   0CC1 E5            pop b                         ; get file lba
2162   0CC2 FD 43         mov [d], b                    ; save lba
2163   0CC4               ; set file creation date  
2164   0CC4 58 04 00      add d, 4
2165   0CC7 19 04         mov al, 4
2166   0CC9 05 01         syscall sys_rtc
2167   0CCB 1A            mov al, ah
2168   0CCC 3E            mov [d], al                   ; set day
2169   0CCD 79            inc d
2170   0CCE 19 05         mov al, 5
2171   0CD0 05 01         syscall sys_rtc
2172   0CD2 1A            mov al, ah
2173   0CD3 3E            mov [d], al                   ; set month
2174   0CD4 79            inc d
2175   0CD5 19 06         mov al, 6
2176   0CD7 05 01         syscall sys_rtc
2177   0CD9 1A            mov al, ah
2178   0CDA 3E            mov [d], al                   ; set year
2179   0CDB             ; write sector into disk for new directory entry
2180   0CDB FD 27         mov b, g
2181   0CDD 38 00 00      mov c, 0
2182   0CE0 3B DB 24      mov d, transient_area
2183   0CE3 22 01         mov ah, $01                   ; disk write, 1 sector
2184   0CE5 07 48 05      call ide_write_sect           ; write sector
2185   0CE8 19 01         mov al, 1
2186   0CEA 3D 6E 17      mov [sys_echo_on], al ; enable echo
2187   0CED 06            sysret
2188   0CEE             
2189   0CEE             ;------------------------------------------------------------------------------------------------------;
2190   0CEE             ; pwd - print working directory
2191   0CEE             ;------------------------------------------------------------------------------------------------------;    
2192   0CEE             fs_pwd:
2193   0CEE 3B 5B 1C      mov d, filename
2194   0CF1 19 00         mov al, 0
2195   0CF3 3E            mov [d], al                   ; initialize path string 
2196   0CF4 14 7E 17      mov a, [current_dir_id]
2197   0CF7 07 58 08      call fs_dir_id_to_path_e0
2198   0CFA 3B 5B 1C      mov d, filename
2199   0CFD 07 30 10      call _strrev
2200   0D00 07 44 12      call _puts
2201   0D03 07 F1 11      call printnl
2202   0D06 06            sysret
2203   0D07             
2204   0D07             ;------------------------------------------------------------------------------------------------------;
2205   0D07             ; get current directory lba
2206   0D07             ; a: returned lba
2207   0D07             ;------------------------------------------------------------------------------------------------------;
2208   0D07             cmd_get_curr_dir_lba:
2209   0D07 14 7E 17      mov a, [current_dir_id]
2210   0D0A 06            sysret
2211   0D0B             
2212   0D0B             ;------------------------------------------------------------------------------------------------------;
2213   0D0B             ; cat
2214   0D0B             ; userspace destination data pointer in d
2215   0D0B             ; filename starts at d, but is overwritten after the read is made
2216   0D0B             ;------------------------------------------------------------------------------------------------------;:
2217   0D0B             fs_cat:
2218   0D0B DA            push d                              ; save userspace file data destination
2219   0D0C FD 4E         mov si, d
2220   0D0E FD 4F DB 1C   mov di, user_data
2221   0D12 38 00 02      mov c, 512
2222   0D15 04            load                                ; copy filename from user-space
2223   0D16 29 7E 17      mov b, [current_dir_id]
2224   0D19 FD 77         inc b                               ; metadata sector
2225   0D1B 38 00 00      mov c, 0                            ; upper lba = 0
2226   0D1E 22 01         mov ah, $01                  ; 1 sector
2227   0D20 3B DB 22      mov d, transient_area-512
2228   0D23 07 22 05      call ide_read_sect                  ; read directory
2229   0D26 FD 10         cla
2230   0D28 42 76 17      mov [index], a                      ; reset file counter
2231   0D2B             fs_cat_l1:
2232   0D2B FD 4E         mov si, d
2233   0D2D FD 4F DB 1C   mov di, user_data
2234   0D31 07 87 10      call _strcmp
2235   0D34 C6 4A 0D      je fs_cat_found_entry
2236   0D37 58 20 00      add d, 32
2237   0D3A 14 76 17      mov a, [index]
2238   0D3D 77            inc a
2239   0D3E 42 76 17      mov [index], a
2240   0D41 AF 10 00      cmp a, fst_files_per_dir
2241   0D44 C6 65 0D      je fs_cat_not_found
2242   0D47 0A 2B 0D      jmp fs_cat_l1
2243   0D4A             fs_cat_found_entry:
2244   0D4A 58 19 00      add d, 25                           ; get to dirid of file in disk
2245   0D4D 2A            mov b, [d]                          ; get lba
2246   0D4E FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2247   0D50 3B DB 24      mov d, transient_area  
2248   0D53 38 00 00      mov c, 0
2249   0D56 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2250   0D58 07 22 05      call ide_read_sect                  ; read sectors
2251   0D5B F0            pop di                              ; write userspace file data destination to di
2252   0D5C FD 4D DB 24   mov si, transient_area              ; data origin
2253   0D60 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2254   0D63 03            store
2255   0D64 06            sysret
2256   0D65             fs_cat_not_found:
2257   0D65 E7            pop d
2258   0D66 06            sysret
2259   0D67             
2260   0D67             ;------------------------------------------------------------------------------------------------------;
2261   0D67             ; rmdir - remove dir by dirid
2262   0D67             ;------------------------------------------------------------------------------------------------------;
2263   0D67             ; deletes a directory entry in the given directory's file list 
2264   0D67             ; also deletes the actual directory entry in the fst
2265   0D67             ; synopsis: rmdir /usr/local/testdir
2266   0D67             ; b = dirid
2267   0D67             fs_rmdir:
2268   0D67 FD 79         mov g, b
2269   0D69 11            mov a, b
2270   0D6A 07 94 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2271   0D6D D7            push a                        ; save dirid
2272   0D6E             ; search for directory's entry in the parent's directory then and delete it
2273   0D6E 77            inc a                         ; metadata sector
2274   0D6F 27            mov b, a
2275   0D70 38 00 00      mov c, 0                      ; upper lba = 0
2276   0D73 22 01         mov ah, $01          ;
2277   0D75 3B DB 24      mov d, transient_area
2278   0D78 07 22 05      call ide_read_sect            ; read directory
2279   0D7B FD 10         cla
2280   0D7D 42 76 17      mov [index], a                ; reset file counter
2281   0D80 FD 27         mov b, g                      ; retrieve directory's dirid
2282   0D82             fs_rmdir_l1:
2283   0D82 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2284   0D85 B0            cmp a, b                      ; compare dirid's to find the directory
2285   0D86 C6 9C 0D      je fs_rmdir_found_entry
2286   0D89 58 20 00      add d, 32
2287   0D8C 14 76 17      mov a, [index]
2288   0D8F 77            inc a
2289   0D90 42 76 17      mov [index], a
2290   0D93 AF 10 00      cmp a, fst_files_per_dir
2291   0D96 C6 C1 0D      je fs_rmdir_not_found
2292   0D99 0A 82 0D      jmp fs_rmdir_l1
2293   0D9C             fs_rmdir_found_entry:
2294   0D9C FD 10         cla
2295   0D9E 3E            mov [d], al                   ; make filename null
2296   0D9F 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2297   0DA2 E5            pop b
2298   0DA3 FD 77         inc b                         ; metadata sector
2299   0DA5 38 00 00      mov c, 0                      ; upper lba = 0
2300   0DA8 22 01         mov ah, $01          ; 
2301   0DAA 3B DB 24      mov d, transient_area
2302   0DAD 07 48 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2303   0DB0             
2304   0DB0 FD 27         mov b, g
2305   0DB2 3B DB 24      mov d, transient_area  
2306   0DB5 FD 10         cla
2307   0DB7 3E            mov [d], al                   ; make directory's name header null for re-use
2308   0DB8 38 00 00      mov c, 0
2309   0DBB 22 01         mov ah, $01                   ; disk write 1 sect
2310   0DBD 07 48 05      call ide_write_sect           ; delete directory given by dirid in b
2311   0DC0 06            sysret
2312   0DC1             fs_rmdir_not_found:
2313   0DC1 E5            pop b
2314   0DC2 06            sysret
2315   0DC3             
2316   0DC3             ;------------------------------------------------------------------------------------------------------;
2317   0DC3             ; rm - remove file
2318   0DC3             ;------------------------------------------------------------------------------------------------------;
2319   0DC3             ; frees up the data sectors for the file further down the disk
2320   0DC3             ; deletes file entry in the directory's file list 
2321   0DC3             fs_rm:
2322   0DC3 FD 4E         mov si, d
2323   0DC5 FD 4F DB 1C   mov di, user_data
2324   0DC9 38 00 02      mov c, 512
2325   0DCC 04            load                          ; load data from user-space
2326   0DCD 14 7E 17      mov a, [current_dir_id]
2327   0DD0 77            inc a                         ; metadata sector
2328   0DD1 27            mov b, a
2329   0DD2 38 00 00      mov c, 0                      ; upper lba = 0
2330   0DD5 22 01         mov ah, $01                  ; 1 sector
2331   0DD7 3B DB 24      mov d, transient_area
2332   0DDA 07 22 05      call ide_read_sect            ; read directory
2333   0DDD 10 00 00      mov a, 0
2334   0DE0 42 76 17      mov [index], a                ; reset file counter
2335   0DE3             fs_rm_l1:
2336   0DE3 FD 4E         mov si, d
2337   0DE5 FD 4F DB 1C   mov di, user_data
2338   0DE9 07 87 10      call _strcmp
2339   0DEC C6 02 0E      je fs_rm_found_entry
2340   0DEF 58 20 00      add d, 32
2341   0DF2 14 76 17      mov a, [index]
2342   0DF5 77            inc a
2343   0DF6 42 76 17      mov [index], a
2344   0DF9 AF 10 00      cmp a, fst_files_per_dir
2345   0DFC C6 2A 0E      je fs_rm_not_found
2346   0DFF 0A E3 0D      jmp fs_rm_l1
2347   0E02             fs_rm_found_entry:
2348   0E02 2B 19 00      mov b, [d + 25]               ; get lba
2349   0E05 FD 79         mov g, b                      ; save lba
2350   0E07 19 00         mov al, 0
2351   0E09 3E            mov [d], al                   ; make file entry null
2352   0E0A 14 7E 17      mov a, [current_dir_id]
2353   0E0D 77            inc a                         ; metadata sector
2354   0E0E 27            mov b, a
2355   0E0F 38 00 00      mov c, 0                      ; upper lba = 0
2356   0E12 22 01         mov ah, $01                   ; disk write
2357   0E14 3B DB 24      mov d, transient_area
2358   0E17 07 48 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2359   0E1A 3B DB 24      mov d, transient_area  
2360   0E1D 19 00         mov al, 0
2361   0E1F 3E            mov [d], al                   ; make file's data header null for re-use
2362   0E20 38 00 00      mov c, 0
2363   0E23 FD 27         mov b, g                      ; get data header lba
2364   0E25 22 01         mov ah, $01                   ; disk write 1 sect
2365   0E27 07 48 05      call ide_write_sect           ; write sector
2366   0E2A             fs_rm_not_found:  
2367   0E2A 06            sysret  
2368   0E2B             
2369   0E2B             ;------------------------------------------------------------------------------------------------------;
2370   0E2B             ; mv - move / change file name
2371   0E2B             ;------------------------------------------------------------------------------------------------------;
2372   0E2B             fs_mv:
2373   0E2B FD 4E         mov si, d
2374   0E2D FD 4F DB 1C   mov di, user_data
2375   0E31 38 00 02      mov c, 512
2376   0E34 04            load                          ; load data from user-space
2377   0E35 14 7E 17      mov a, [current_dir_id]
2378   0E38 77            inc a                         ; metadata sector
2379   0E39 27            mov b, a  
2380   0E3A 38 00 00      mov c, 0                      ; upper lba = 0
2381   0E3D 22 01         mov ah, $01                  ; 1 sector
2382   0E3F 3B DB 24      mov d, transient_area
2383   0E42 07 22 05      call ide_read_sect            ; read directory
2384   0E45 FD 10         cla
2385   0E47 42 76 17      mov [index], a                ; reset file counter
2386   0E4A             fs_mv_l1:
2387   0E4A FD 4E         mov si, d
2388   0E4C FD 4F DB 1C   mov di, user_data
2389   0E50 07 87 10      call _strcmp
2390   0E53 C6 69 0E      je fs_mv_found_entry
2391   0E56 58 20 00      add d, 32
2392   0E59 14 76 17      mov a, [index]
2393   0E5C 77            inc a
2394   0E5D 42 76 17      mov [index], a
2395   0E60 AF 10 00      cmp a, fst_files_per_dir
2396   0E63 C6 9B 0E      je fs_mv_not_found
2397   0E66 0A 4A 0E      jmp fs_mv_l1
2398   0E69             fs_mv_found_entry:  
2399   0E69 DA            push d
2400   0E6A FD 4D 5B 1D   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2401   0E6E FD 50         mov di, d
2402   0E70 07 9C 10      call _strcpy  
2403   0E73 38 00 00      mov c, 0
2404   0E76 3B DB 24      mov d, transient_area
2405   0E79 22 01         mov ah, $01                   ; disk write 1 sect
2406   0E7B 07 48 05      call ide_write_sect           ; write sector
2407   0E7E E7            pop d
2408   0E7F             ;; need to check whether its a dir or a file here ;;;
2409   0E7F 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2410   0E82 22 01         mov ah, $01
2411   0E84 3B DB 24      mov d, transient_area
2412   0E87 38 00 00      mov c, 0
2413   0E8A 07 22 05      call ide_read_sect            ; read directory entry
2414   0E8D FD 4D 5B 1D   mov si, user_data + 128
2415   0E91 FD 50         mov di, d
2416   0E93 07 9C 10      call _strcpy                  ; change directory's name
2417   0E96 22 01         mov ah, $01
2418   0E98 07 48 05      call ide_write_sect           ; rewrite directory back to disk
2419   0E9B             fs_mv_not_found:
2420   0E9B 06            sysret
2421   0E9C             
2422   0E9C             
2423   0E9C             ;----------------------------------------------------------------------------------------------------;
2424   0E9C             ; process index in a
2425   0E9C             ;----------------------------------------------------------------------------------------------------;
2426   0E9C             find_free_proc:
2427   0E9C FD 4D 4C 1A   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2428   0EA0             find_free_proc_l0:
2429   0EA0 F6            lodsb                               ; get process state
2430   0EA1 B9 00         cmp al, 0
2431   0EA3 C6 A9 0E      je find_free_proc_free              ; if free, jump
2432   0EA6 0A A0 0E      jmp find_free_proc_l0               ; else, goto next
2433   0EA9             find_free_proc_free:
2434   0EA9 4E            mov a, si
2435   0EAA 5F 4C 1A      sub a, 1 + proc_availab_table       ; get process index
2436   0EAD 09            ret
2437   0EAE               
2438   0EAE             
2439   0EAE             ;----------------------------------------------------------------------------------------------------;
2440   0EAE             ; process index in al
2441   0EAE             ;----------------------------------------------------------------------------------------------------;
2442   0EAE             proc_memory_map:
2443   0EAE 22 00         mov ah, 0
2444   0EB0 27            mov b, a                      ; page in bl, 0 in bh
2445   0EB1 FD 9D 05      shl a, 5                      ; multiply by 32
2446   0EB4 39            mov c, a                      ; save in c
2447   0EB5 57 20 00      add c, 32
2448   0EB8             proc_memory_map_l0:
2449   0EB8 02            pagemap
2450   0EB9 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2451   0EBC 53 01 00      add a, 1                      ; increase both 
2452   0EBF B1            cmp a, c                      ; check to see if we reached the end of memory
2453   0EC0 C7 B8 0E      jne proc_memory_map_l0
2454   0EC3 09            ret
2455   0EC4               
2456   0EC4             
2457   0EC4             ;----------------------------------------------------------------------------------------------------;
2458   0EC4             ; terminate process
2459   0EC4             ;----------------------------------------------------------------------------------------------------;
2460   0EC4             syscall_terminate_proc:
2461   0EC4 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2462   0EC7                                                    ; since they will not be used for anything here.
2463   0EC7 1D 75 17      mov al, [active_proc_index]
2464   0ECA 22 00         mov ah, 0  
2465   0ECC FD 9D 05      shl a, 5                             ; x32
2466   0ECF 53 5B 1A      add a, proc_names
2467   0ED2 3C            mov d, a
2468   0ED3 19 00         mov al, 0
2469   0ED5 3E            mov [d], al                           ; nullify process name
2470   0ED6             
2471   0ED6 1D 75 17      mov al, [active_proc_index]
2472   0ED9 22 00         mov ah, 0  
2473   0EDB 3C            mov d, a
2474   0EDC 19 00         mov al, 0
2475   0EDE 3F 4B 1A      mov [d + proc_availab_table], al    ; make process empty again
2476   0EE1               
2477   0EE1 1D 74 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2478   0EE4 80            dec al
2479   0EE5 3D 74 17      mov [nbr_active_procs], al
2480   0EE8             
2481   0EE8             ; now load the shell process again
2482   0EE8 19 02         mov al, 2                           ; next process = process 2 = shell
2483   0EEA 3D 75 17      mov [active_proc_index], al         ; set next active proc
2484   0EED             
2485   0EED             ; calculate lut entry for next process
2486   0EED 22 00         mov ah, 0
2487   0EEF FD 99         shl a                               ; x2
2488   0EF1 B7 BA 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2489   0EF4               
2490   0EF4 4D            mov si, a                           ; source is proc state block
2491   0EF5 48            mov a, sp
2492   0EF6 5F 13 00      sub a, 19
2493   0EF9 4F            mov di, a                           ; destination is kernel stack
2494   0EFA             ; restore sp
2495   0EFA 7D            dec a
2496   0EFB 47            mov sp, a
2497   0EFC 38 14 00      mov c, 20
2498   0EFF FD F5         rep movsb
2499   0F01             ; set vm process
2500   0F01 1D 75 17      mov al, [active_proc_index]
2501   0F04 01            setptb
2502   0F05                 
2503   0F05 4C            popa
2504   0F06 06            sysret
2505   0F07             
2506   0F07             ;----------------------------------------------------------------------------------------------------;
2507   0F07             ; pause process
2508   0F07             ;----------------------------------------------------------------------------------------------------;
2509   0F07             syscall_pause_proc:
2510   0F07             ; save all registers into kernel stack
2511   0F07 4B            pusha
2512   0F08 22 00         mov ah, 0
2513   0F0A 1D 75 17      mov al, [active_proc_index]
2514   0F0D FD 99         shl a              ; x2
2515   0F0F B7 BA 0F      mov a, [proc_table_convert + a]   ; get process state start index
2516   0F12                 
2517   0F12 4F            mov di, a
2518   0F13 48            mov a, sp
2519   0F14 77            inc a
2520   0F15 4D            mov si, a
2521   0F16 38 14 00      mov c, 20
2522   0F19 FD F5         rep movsb                         ; save process state!
2523   0F1B             ; restore kernel stack position to point before interrupt arrived
2524   0F1B 51 14 00      add sp, 20
2525   0F1E             ; now load the shell process again
2526   0F1E 19 02         mov al, 2                         ; next process = process 2 = shell
2527   0F20 3D 75 17      mov [active_proc_index], al       ; set next active proc
2528   0F23             
2529   0F23             ; calculate lut entry for next process
2530   0F23 22 00         mov ah, 0
2531   0F25 FD 99         shl a                             ; x2
2532   0F27 B7 BA 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2533   0F2A               
2534   0F2A 4D            mov si, a                         ; source is proc state block
2535   0F2B 48            mov a, sp
2536   0F2C 5F 13 00      sub a, 19
2537   0F2F 4F            mov di, a                         ; destination is kernel stack
2538   0F30             ; restore sp
2539   0F30 7D            dec a
2540   0F31 47            mov sp, a
2541   0F32 38 14 00      mov c, 20
2542   0F35 FD F5         rep movsb
2543   0F37             ; set vm process
2544   0F37 1D 75 17      mov al, [active_proc_index]
2545   0F3A 01            setptb
2546   0F3B                 
2547   0F3B 4C            popa
2548   0F3C 06            sysret
2549   0F3D             
2550   0F3D             ;----------------------------------------------------------------------------------------------------;
2551   0F3D             ; create a new process
2552   0F3D             ; d = path of the process file to be createed
2553   0F3D             ; b = arguments ptr
2554   0F3D             ;----------------------------------------------------------------------------------------------------;
2555   0F3D             syscall_create_proc:
2556   0F3D             ; we save the active process first  
2557   0F3D 4B            pusha
2558   0F3E 22 00         mov ah, 0
2559   0F40 1D 75 17      mov al, [active_proc_index]
2560   0F43 FD 99         shl a              ; x2
2561   0F45 B7 BA 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2562   0F48               
2563   0F48 4F            mov di, a
2564   0F49 48            mov a, sp
2565   0F4A 77            inc a
2566   0F4B 4D            mov si, a
2567   0F4C 38 14 00      mov c, 20
2568   0F4F FD F5         rep movsb                          ; save process state!
2569   0F51             ; restore kernel stack position to point before interrupt arrived
2570   0F51 51 14 00      add sp, 20
2571   0F54               
2572   0F54 FD 4E         mov si, d                          ; copy the file path
2573   0F56 FD 4F DB 1C   mov di, user_data
2574   0F5A 38 00 02      mov c, 512
2575   0F5D 04            load
2576   0F5E 11            mov a, b
2577   0F5F 4D            mov si, a                          ; copy the arguments
2578   0F60 FD 4F DB 22   mov di, scrap_sector
2579   0F64 38 00 02      mov c, 512
2580   0F67 04            load
2581   0F68 07 DA 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2582   0F6B                                                  ; the file data is loaded into transient_area
2583   0F6B             ; now we allocate a new process  
2584   0F6B 07 9C 0E      call find_free_proc                ; index in a
2585   0F6E 01            setptb 
2586   0F6F 07 AE 0E      call proc_memory_map               ; map process memory pages
2587   0F72             ; copy arguments into process's memory
2588   0F72 FD 4D DB 22   mov si, scrap_sector
2589   0F76 FD 4F 00 00   mov di, 0
2590   0F7A 38 00 02      mov c, 512
2591   0F7D 03            store
2592   0F7E             ; now copy process binary data into process's memory
2593   0F7E FD 4D DB 24   mov si, transient_area
2594   0F82 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2595   0F86 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2596   0F89 03            store                              ; copy process data
2597   0F8A                 
2598   0F8A 07 9C 0E      call find_free_proc                ; index in a
2599   0F8D 3D 75 17      mov [active_proc_index], al        ; set new active process
2600   0F90 FD 9D 05      shl a, 5                           ; x32
2601   0F93 53 5B 1A      add a, proc_names
2602   0F96 4F            mov di, a
2603   0F97 FD 4D DB 1C   mov si, user_data                  ; copy and store process filename
2604   0F9B 07 9C 10      call _strcpy
2605   0F9E               
2606   0F9E 07 9C 0E      call find_free_proc                ; index in a
2607   0FA1 3C            mov d, a
2608   0FA2 19 01         mov al, 1
2609   0FA4 3F 4B 1A      mov [d + proc_availab_table], al   ; make process busy
2610   0FA7               
2611   0FA7 1D 74 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2612   0FAA 7A            inc al
2613   0FAB 3D 74 17      mov [nbr_active_procs], al
2614   0FAE             ; launch process
2615   0FAE FD D7 FF FF   push word $ffff 
2616   0FB2 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2617   0FB5 FD D7 00 04   push word text_org
2618   0FB9 06            sysret
2619   0FBA             
2620   0FBA             proc_table_convert:
2621   0FBA 0B 19         .dw proc_state_table + 0
2622   0FBC 1F 19         .dw proc_state_table + 20
2623   0FBE 33 19         .dw proc_state_table + 40
2624   0FC0 47 19         .dw proc_state_table + 60
2625   0FC2 5B 19         .dw proc_state_table + 80
2626   0FC4 6F 19         .dw proc_state_table + 100
2627   0FC6 83 19         .dw proc_state_table + 120
2628   0FC8 97 19         .dw proc_state_table + 140
2629   0FCA               
2630   0FCA             ;----------------------------------------------------------------------------------------------;
2631   0FCA             ; get hex file
2632   0FCA             ; di = destination address
2633   0FCA             ; return length in bytes in c
2634   0FCA             ;----------------------------------------------------------------------------------------------;
2635   0FCA             _load_hex:
2636   0FCA D7            push a
2637   0FCB D8            push b
2638   0FCC DA            push d
2639   0FCD E2            push si
2640   0FCE E3            push di
2641   0FCF 38 00 00      mov c, 0
2642   0FD2 50            mov a, di
2643   0FD3 3C            mov d, a          ; start of string data block
2644   0FD4 07 1F 11      call _gets        ; get program string
2645   0FD7 4D            mov si, a
2646   0FD8             __load_hex_loop:
2647   0FD8 F6            lodsb             ; load from [si] to al
2648   0FD9 B9 00         cmp al, 0         ; check if ascii 0
2649   0FDB C6 E9 0F      jz __load_hex_ret
2650   0FDE 36            mov bh, al
2651   0FDF F6            lodsb
2652   0FE0 2F            mov bl, al
2653   0FE1 07 D5 10      call _atoi        ; convert ascii byte in b to int (to al)
2654   0FE4 F7            stosb             ; store al to [di]
2655   0FE5 78            inc c
2656   0FE6 0A D8 0F      jmp __load_hex_loop
2657   0FE9             __load_hex_ret:
2658   0FE9 F0            pop di
2659   0FEA EF            pop si
2660   0FEB E7            pop d
2661   0FEC E5            pop b
2662   0FED E4            pop a
2663   0FEE 09            ret
2664   0FEF             
2665   0FEF             ; synopsis: look inside a certain directory for files/directories
2666   0FEF             ; before calling this function, cd into required directory
2667   0FEF             ; for each entry inside directory:
2668   0FEF             ;  if entry is a file:
2669   0FEF             ;    compare filename to searched filename
2670   0FEF             ;    if filenames are the same, print filename
2671   0FEF             ;  else if entry is a directory:
2672   0FEF             ;    cd to the given directory
2673   0FEF             ;    recursively call cmd_find
2674   0FEF             ;    cd outside previous directory
2675   0FEF             ;  if current entry == last entry, return
2676   0FEF             ; endfor
2677   0FEF             f_find:
2678   0FEF 09            ret
2679   0FF0             
2680   0FF0             
2681   0FF0             ; ---------------------------------------------------------------------
2682   0FF0             ; kernel reset vector
2683   0FF0             ; ---------------------------------------------------------------------
2684   0FF0             kernel_reset_vector:  
2685   0FF0 FD 49 FF F7   mov bp, stack_begin
2686   0FF4 FD 47 FF F7   mov sp, stack_begin
2687   0FF8               
2688   0FF8 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2689   0FFA FD 0F         stomsk                        
2690   0FFC FD 0C         sti  
2691   0FFE             
2692   0FFE 0C            lodstat
2693   0FFF 87 DF         and al, %11011111             ; disable display register loading
2694   1001 0D            stostat
2695   1002               
2696   1002             ; reset fifo pointers
2697   1002 10 DB 1E      mov a, fifo
2698   1005 3B 7A 17      mov d, fifo_in
2699   1008 43            mov [d], a
2700   1009 3B 7C 17      mov d, fifo_out
2701   100C 43            mov [d], a  
2702   100D 19 02         mov al, 2
2703   100F 05 03         syscall sys_io                ; enable uart in interrupt mode
2704   1011             
2705   1011 3B C9 18      mov d, s_fdc_config
2706   1014 07 44 12      call _puts
2707   1017 F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2708   101B               
2709   101B 3B CF 17      mov d, s_kernel_started
2710   101E 07 44 12      call _puts
2711   1021             
2712   1021 19 10         mov al, 16
2713   1023 05 04         syscall sys_filesystem        ; set root dirid
2714   1025             
2715   1025 3B EC 17      mov d, s_prompt_init
2716   1028 07 44 12      call _puts
2717   102B 3B 80 17      mov d, s_init_path
2718   102E 05 05         syscall sys_create_proc       ; launch init as a new process
2719   1030             
2720   1030             
2721   1030             ; file includes
2722   1030             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1030             boot_origin      .EQU  $8004
0002+  1030             bios_uart        .EQU  $0002
0003+  1030             bios_ide         .EQU  $0003
0004+  1030             bios_reset_vector .EQU  $01c0
0005+  1030             ide_buffer       .EQU  $8204
2723   1030             .include "lib/stdio.asm"
0001+  1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1030             ; stdio.s
0003+  1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1030             .include "lib/string.asm"
0001++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1030             ; string.s
0003++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1030             
0005++ 1030             
0006++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1030             ; _strrev
0008++ 1030             ; reverse a string
0009++ 1030             ; d = string address
0010++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1030             ; 01234
0012++ 1030             _strrev:
0013++ 1030 4B          	pusha
0014++ 1031 07 77 10    	call _strlen	; length in c
0015++ 1034 12          	mov a, c
0016++ 1035 AF 01 00    	cmp a, 1
0017++ 1038 D0 52 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 103B 7D          	dec a
0019++ 103C FD 4E       	mov si, d	; beginning of string
0020++ 103E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1040 59          	add d, a	; end of string
0022++ 1041 12          	mov a, c
0023++ 1042 FD 9B       	shr a		; divide by 2
0024++ 1044 39          	mov c, a	; c now counts the steps
0025++ 1045             _strrev_l0:
0026++ 1045 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1046 F6          	lodsb		; load left-side char into al; increase si
0028++ 1047 3E          	mov [d], al	; store left char into right side
0029++ 1048 1B          	mov al, bl
0030++ 1049 F7          	stosb		; store right-side char into left-side; increase di
0031++ 104A 7E          	dec c
0032++ 104B 7F          	dec d
0033++ 104C C2 00 00    	cmp c, 0
0034++ 104F C7 45 10    	jne _strrev_l0
0035++ 1052             _strrev_end:
0036++ 1052 4C          	popa
0037++ 1053 09          	ret
0038++ 1054             	
0039++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1054             ; _strchr
0041++ 1054             ; search string in d for char in al
0042++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1054             _strchr:
0044++ 1054             _strchr_l0:
0045++ 1054 32          	mov bl, [d]
0046++ 1055 C1 00       	cmp bl, 0
0047++ 1057 C6 62 10    	je _strchr_end
0048++ 105A BA          	cmp al, bl
0049++ 105B C6 62 10    	je _strchr_end
0050++ 105E 79          	inc d
0051++ 105F 0A 54 10    	jmp _strchr_l0
0052++ 1062             _strchr_end:
0053++ 1062 1B          	mov al, bl
0054++ 1063 09          	ret
0055++ 1064             
0056++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1064             ; _strstr
0058++ 1064             ; find sub-string
0059++ 1064             ; str1 in si
0060++ 1064             ; str2 in di
0061++ 1064             ; si points to end of source string
0062++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1064             _strstr:
0064++ 1064 DB          	push al
0065++ 1065 DA          	push d
0066++ 1066 E3          	push di
0067++ 1067             _strstr_loop:
0068++ 1067 F3          	cmpsb					; compare a byte of the strings
0069++ 1068 C7 73 10    	jne _strstr_ret
0070++ 106B FC 00 00    	lea d, [di + 0]
0071++ 106E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1070 C7 67 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1073             _strstr_ret:
0074++ 1073 F0          	pop di
0075++ 1074 E7          	pop d
0076++ 1075 E8          	pop al
0077++ 1076 09          	ret
0078++ 1077             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1077             ; length of null terminated string
0080++ 1077             ; result in c
0081++ 1077             ; pointer in d
0082++ 1077             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1077             _strlen:
0084++ 1077 DA          	push d
0085++ 1078 38 00 00    	mov c, 0
0086++ 107B             _strlen_l1:
0087++ 107B BD 00       	cmp byte [d], 0
0088++ 107D C6 85 10    	je _strlen_ret
0089++ 1080 79          	inc d
0090++ 1081 78          	inc c
0091++ 1082 0A 7B 10    	jmp _strlen_l1
0092++ 1085             _strlen_ret:
0093++ 1085 E7          	pop d
0094++ 1086 09          	ret
0095++ 1087             
0096++ 1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1087             ; strcmp
0098++ 1087             ; compare two strings
0099++ 1087             ; str1 in si
0100++ 1087             ; str2 in di
0101++ 1087             ; create a string compairon instrucion ?????
0102++ 1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1087             _strcmp:
0104++ 1087 DB          	push al
0105++ 1088 DA          	push d
0106++ 1089 E3          	push di
0107++ 108A E2          	push si
0108++ 108B             _strcmp_loop:
0109++ 108B F3          	cmpsb					; compare a byte of the strings
0110++ 108C C7 97 10    	jne _strcmp_ret
0111++ 108F FB FF FF    	lea d, [si +- 1]
0112++ 1092 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1094 C7 8B 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1097             _strcmp_ret:
0115++ 1097 EF          	pop si
0116++ 1098 F0          	pop di
0117++ 1099 E7          	pop d
0118++ 109A E8          	pop al
0119++ 109B 09          	ret
0120++ 109C             
0121++ 109C             
0122++ 109C             ; strcpy
0123++ 109C             ; copy null terminated string from si to di
0124++ 109C             ; source in si
0125++ 109C             ; destination in di
0126++ 109C             _strcpy:
0127++ 109C E2          	push si
0128++ 109D E3          	push di
0129++ 109E DB          	push al
0130++ 109F             _strcpy_l1:
0131++ 109F F6          	lodsb
0132++ 10A0 F7          	stosb
0133++ 10A1 B9 00       	cmp al, 0
0134++ 10A3 C7 9F 10    	jne _strcpy_l1
0135++ 10A6             _strcpy_end:
0136++ 10A6 E8          	pop al
0137++ 10A7 F0          	pop di
0138++ 10A8 EF          	pop si
0139++ 10A9 09          	ret
0140++ 10AA             
0141++ 10AA             ; strcat
0142++ 10AA             ; concatenate a null terminated string into string at di, from string at si
0143++ 10AA             ; source in si
0144++ 10AA             ; destination in di
0145++ 10AA             _strcat:
0146++ 10AA E2          	push si
0147++ 10AB E3          	push di
0148++ 10AC D7          	push a
0149++ 10AD DA          	push d
0150++ 10AE 50          	mov a, di
0151++ 10AF 3C          	mov d, a
0152++ 10B0             _strcat_goto_end_l1:
0153++ 10B0 BD 00       	cmp byte[d], 0
0154++ 10B2 C6 B9 10    	je _strcat_start
0155++ 10B5 79          	inc d
0156++ 10B6 0A B0 10    	jmp _strcat_goto_end_l1
0157++ 10B9             _strcat_start:
0158++ 10B9 FD 50       	mov di, d
0159++ 10BB             _strcat_l1:
0160++ 10BB F6          	lodsb
0161++ 10BC F7          	stosb
0162++ 10BD B9 00       	cmp al, 0
0163++ 10BF C7 BB 10    	jne _strcat_l1
0164++ 10C2             _strcat_end:
0165++ 10C2 E7          	pop d
0166++ 10C3 E4          	pop a
0167++ 10C4 F0          	pop di
0168++ 10C5 EF          	pop si
0169++ 10C6 09          	ret
0170++ 10C7             
0171++ 10C7             
0005+  10C7             
0006+  10C7             
0007+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10C7             ; convert ascii 'o'..'f' to integer 0..15
0009+  10C7             ; ascii in bl
0010+  10C7             ; result in al
0011+  10C7             ; ascii for f = 0100 0110
0012+  10C7             ; ascii for 9 = 0011 1001
0013+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10C7             hex_ascii_encode:
0015+  10C7 1B            mov al, bl
0016+  10C8 93 40         test al, $40        ; test if letter or number
0017+  10CA C7 D0 10      jnz hex_letter
0018+  10CD 87 0F         and al, $0f        ; get number
0019+  10CF 09            ret
0020+  10D0             hex_letter:
0021+  10D0 87 0F         and al, $0f        ; get letter
0022+  10D2 6A 09         add al, 9
0023+  10D4 09            ret
0024+  10D5             
0025+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10D5             ; atoi
0027+  10D5             ; 2 letter hex string in b
0028+  10D5             ; 8bit integer returned in al
0029+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10D5             _atoi:
0031+  10D5 D8            push b
0032+  10D6 07 C7 10      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  10D9 30            mov bl, bh
0034+  10DA DB            push al          ; save a
0035+  10DB 07 C7 10      call hex_ascii_encode
0036+  10DE EA            pop bl  
0037+  10DF FD 9E 04      shl al, 4
0038+  10E2 8C            or al, bl
0039+  10E3 E5            pop b
0040+  10E4 09            ret  
0041+  10E5             
0042+  10E5             
0043+  10E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10E5             ; scanf
0045+  10E5             ; no need for explanations!
0046+  10E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10E5             scanf:
0048+  10E5 09            ret
0049+  10E6             
0050+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10E6             ; itoa
0052+  10E6             ; 8bit value in bl
0053+  10E6             ; 2 byte ascii result in a
0054+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10E6             _itoa:
0056+  10E6 DA            push d
0057+  10E7 D8            push b
0058+  10E8 A7 00         mov bh, 0
0059+  10EA FD A4 04      shr bl, 4  
0060+  10ED 74            mov d, b
0061+  10EE 1F 80 13      mov al, [d + s_hex_digits]
0062+  10F1 23            mov ah, al
0063+  10F2               
0064+  10F2 E5            pop b
0065+  10F3 D8            push b
0066+  10F4 A7 00         mov bh, 0
0067+  10F6 FD 87 0F      and bl, $0f
0068+  10F9 74            mov d, b
0069+  10FA 1F 80 13      mov al, [d + s_hex_digits]
0070+  10FD E5            pop b
0071+  10FE E7            pop d
0072+  10FF 09            ret
0073+  1100             
0074+  1100             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1100             ; hex string to binary
0076+  1100             ; di = destination address
0077+  1100             ; si = source
0078+  1100             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1100             _hex_to_int:
0080+  1100             _hex_to_int_l1:
0081+  1100 F6            lodsb          ; load from [si] to al
0082+  1101 B9 00         cmp al, 0        ; check if ascii 0
0083+  1103 C6 10 11      jz _hex_to_int_ret
0084+  1106 36            mov bh, al
0085+  1107 F6            lodsb
0086+  1108 2F            mov bl, al
0087+  1109 07 D5 10      call _atoi        ; convert ascii byte in b to int (to al)
0088+  110C F7            stosb          ; store al to [di]
0089+  110D 0A 00 11      jmp _hex_to_int_l1
0090+  1110             _hex_to_int_ret:
0091+  1110 09            ret    
0092+  1111             
0093+  1111             
0094+  1111             
0095+  1111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1111             ; getchar
0097+  1111             ; char in ah
0098+  1111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1111             getch:
0100+  1111 DB            push al
0101+  1112             getch_retry:
0102+  1112 19 01         mov al, 1
0103+  1114 05 03         syscall sys_io      ; receive in ah
0104+  1116 E8            pop al
0105+  1117 09            ret
0106+  1118             
0107+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1118             ; putchar
0109+  1118             ; char in ah
0110+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1118             _putchar:
0112+  1118 DB            push al
0113+  1119 19 00         mov al, 0
0114+  111B 05 03         syscall sys_io      ; char in ah
0115+  111D E8            pop al
0116+  111E 09            ret
0117+  111F             
0118+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  111F             ;; input a string
0120+  111F             ;; terminates with null
0121+  111F             ;; pointer in d
0122+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  111F             _gets:
0124+  111F D7            push a
0125+  1120 DA            push d
0126+  1121             _gets_loop:
0127+  1121 19 01         mov al, 1
0128+  1123 05 03         syscall sys_io      ; receive in ah
0129+  1125 76 1B         cmp ah, 27
0130+  1127 C6 48 11      je _gets_ansi_esc
0131+  112A 76 0A         cmp ah, $0a        ; lf
0132+  112C C6 A4 11      je _gets_end
0133+  112F 76 0D         cmp ah, $0d        ; cr
0134+  1131 C6 A4 11      je _gets_end
0135+  1134 76 5C         cmp ah, $5c        ; '\\'
0136+  1136 C6 6A 11      je _gets_escape
0137+  1139 76 08         cmp ah, $08      ; check for backspace
0138+  113B C6 44 11      je _gets_backspace
0139+  113E 1A            mov al, ah
0140+  113F 3E            mov [d], al
0141+  1140 79            inc d
0142+  1141 0A 21 11      jmp _gets_loop
0143+  1144             _gets_backspace:
0144+  1144 7F            dec d
0145+  1145 0A 21 11      jmp _gets_loop
0146+  1148             _gets_ansi_esc:
0147+  1148 19 01         mov al, 1
0148+  114A 05 03         syscall sys_io        ; receive in ah without echo
0149+  114C 76 5B         cmp ah, '['
0150+  114E C7 21 11      jne _gets_loop
0151+  1151 19 01         mov al, 1
0152+  1153 05 03         syscall sys_io          ; receive in ah without echo
0153+  1155 76 64         cmp ah, 'd'
0154+  1157 C6 62 11      je _gets_left_arrow
0155+  115A 76 63         cmp ah, 'c'
0156+  115C C6 66 11      je _gets_right_arrow
0157+  115F 0A 21 11      jmp _gets_loop
0158+  1162             _gets_left_arrow:
0159+  1162 7F            dec d
0160+  1163 0A 21 11      jmp _gets_loop
0161+  1166             _gets_right_arrow:
0162+  1166 79            inc d
0163+  1167 0A 21 11      jmp _gets_loop
0164+  116A             _gets_escape:
0165+  116A 19 01         mov al, 1
0166+  116C 05 03         syscall sys_io      ; receive in ah
0167+  116E 76 6E         cmp ah, 'n'
0168+  1170 C6 8F 11      je _gets_lf
0169+  1173 76 72         cmp ah, 'r'
0170+  1175 C6 96 11      je _gets_cr
0171+  1178 76 30         cmp ah, '0'
0172+  117A C6 9D 11      je _gets_null
0173+  117D 76 5C         cmp ah, $5c  ; '\'
0174+  117F C6 88 11      je _gets_slash
0175+  1182 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1183 3E            mov [d], al
0177+  1184 79            inc d
0178+  1185 0A 21 11      jmp _gets_loop
0179+  1188             _gets_slash:
0180+  1188 19 5C         mov al, $5c
0181+  118A 3E            mov [d], al
0182+  118B 79            inc d
0183+  118C 0A 21 11      jmp _gets_loop
0184+  118F             _gets_lf:
0185+  118F 19 0A         mov al, $0a
0186+  1191 3E            mov [d], al
0187+  1192 79            inc d
0188+  1193 0A 21 11      jmp _gets_loop
0189+  1196             _gets_cr:
0190+  1196 19 0D         mov al, $0d
0191+  1198 3E            mov [d], al
0192+  1199 79            inc d
0193+  119A 0A 21 11      jmp _gets_loop
0194+  119D             _gets_null:
0195+  119D 19 00         mov al, $00
0196+  119F 3E            mov [d], al
0197+  11A0 79            inc d
0198+  11A1 0A 21 11      jmp _gets_loop
0199+  11A4             _gets_end:
0200+  11A4 19 00         mov al, 0
0201+  11A6 3E            mov [d], al        ; terminate string
0202+  11A7 E7            pop d
0203+  11A8 E4            pop a
0204+  11A9 09            ret
0205+  11AA             
0206+  11AA             
0207+  11AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11AA             ;; input text
0209+  11AA             ;; terminated with ctrl+d
0210+  11AA             ;; pointer in d
0211+  11AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11AA             _gettxt:
0213+  11AA D7            push a
0214+  11AB DA            push d
0215+  11AC             _gettxt_loop:
0216+  11AC 19 01         mov al, 1
0217+  11AE 05 03         syscall sys_io      ; receive in ah
0218+  11B0 76 04         cmp ah, 4      ; eot
0219+  11B2 C6 EB 11      je _gettxt_end
0220+  11B5 76 08         cmp ah, $08      ; check for backspace
0221+  11B7 C6 E7 11      je _gettxt_backspace
0222+  11BA 76 5C         cmp ah, $5c        ; '\'
0223+  11BC C6 C5 11      je _gettxt_escape
0224+  11BF 1A            mov al, ah
0225+  11C0 3E            mov [d], al
0226+  11C1 79            inc d
0227+  11C2 0A AC 11      jmp _gettxt_loop
0228+  11C5             _gettxt_escape:
0229+  11C5 19 01         mov al, 1
0230+  11C7 05 03         syscall sys_io      ; receive in ah
0231+  11C9 76 6E         cmp ah, 'n'
0232+  11CB C6 D9 11      je _gettxt_lf
0233+  11CE 76 72         cmp ah, 'r'
0234+  11D0 C6 E0 11      je _gettxt_cr
0235+  11D3 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11D4 3E            mov [d], al
0237+  11D5 79            inc d
0238+  11D6 0A AC 11      jmp _gettxt_loop
0239+  11D9             _gettxt_lf:
0240+  11D9 19 0A         mov al, $0a
0241+  11DB 3E            mov [d], al
0242+  11DC 79            inc d
0243+  11DD 0A AC 11      jmp _gettxt_loop
0244+  11E0             _gettxt_cr:
0245+  11E0 19 0D         mov al, $0d
0246+  11E2 3E            mov [d], al
0247+  11E3 79            inc d
0248+  11E4 0A AC 11      jmp _gettxt_loop
0249+  11E7             _gettxt_backspace:
0250+  11E7 7F            dec d
0251+  11E8 0A AC 11      jmp _gettxt_loop
0252+  11EB             _gettxt_end:
0253+  11EB 19 00         mov al, 0
0254+  11ED 3E            mov [d], al        ; terminate string
0255+  11EE E7            pop d
0256+  11EF E4            pop a
0257+  11F0 09            ret
0258+  11F1             
0259+  11F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11F1             ; print new line
0261+  11F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11F1             printnl:
0263+  11F1 D7            push a
0264+  11F2 10 00 0A      mov a, $0a00
0265+  11F5 05 03         syscall sys_io
0266+  11F7 10 00 0D      mov a, $0d00
0267+  11FA 05 03         syscall sys_io
0268+  11FC E4            pop a
0269+  11FD 09            ret
0270+  11FE             
0271+  11FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  11FE             ; _strtoint
0273+  11FE             ; 4 digit hex string number in d
0274+  11FE             ; integer returned in a
0275+  11FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11FE             _strtointx:
0277+  11FE D8            push b
0278+  11FF 32            mov bl, [d]
0279+  1200 37            mov bh, bl
0280+  1201 33 01 00      mov bl, [d + 1]
0281+  1204 07 D5 10      call _atoi        ; convert to int in al
0282+  1207 23            mov ah, al        ; move to ah
0283+  1208 33 02 00      mov bl, [d + 2]
0284+  120B 37            mov bh, bl
0285+  120C 33 03 00      mov bl, [d + 3]
0286+  120F 07 D5 10      call _atoi        ; convert to int in al
0287+  1212 E5            pop b
0288+  1213 09            ret
0289+  1214             
0290+  1214             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1214             ; _strtoint
0292+  1214             ; 5 digit base10 string number in d
0293+  1214             ; integer returned in a
0294+  1214             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1214             _strtoint:
0296+  1214 E2            push si
0297+  1215 D8            push b
0298+  1216 D9            push c
0299+  1217 DA            push d
0300+  1218 07 77 10      call _strlen      ; get string length in c
0301+  121B 7E            dec c
0302+  121C FD 4E         mov si, d
0303+  121E 12            mov a, c
0304+  121F FD 99         shl a
0305+  1221 3B 98 13      mov d, table_power
0306+  1224 59            add d, a
0307+  1225 38 00 00      mov c, 0
0308+  1228             _strtoint_l0:
0309+  1228 F6            lodsb      ; load ascii to al
0310+  1229 B9 00         cmp al, 0
0311+  122B C6 3E 12      je _strtoint_end
0312+  122E 6F 30         sub al, $30    ; make into integer
0313+  1230 22 00         mov ah, 0
0314+  1232 2A            mov b, [d]
0315+  1233 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1234 11            mov a, b
0317+  1235 28            mov b, c
0318+  1236 54            add a, b
0319+  1237 39            mov c, a
0320+  1238 63 02 00      sub d, 2
0321+  123B 0A 28 12      jmp _strtoint_l0
0322+  123E             _strtoint_end:
0323+  123E 12            mov a, c
0324+  123F E7            pop d
0325+  1240 E6            pop c
0326+  1241 E5            pop b
0327+  1242 EF            pop si
0328+  1243 09            ret
0329+  1244             
0330+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1244             ; print null terminated string
0332+  1244             ; pointer in d
0333+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1244             _puts:
0335+  1244 D7            push a
0336+  1245 DA            push d
0337+  1246             _puts_l1:
0338+  1246 1E            mov al, [d]
0339+  1247 B9 00         cmp al, 0
0340+  1249 C6 55 12      jz _puts_end
0341+  124C 23            mov ah, al
0342+  124D 19 00         mov al, 0
0343+  124F 05 03         syscall sys_io
0344+  1251 79            inc d
0345+  1252 0A 46 12      jmp _puts_l1
0346+  1255             _puts_end:
0347+  1255 E7            pop d
0348+  1256 E4            pop a
0349+  1257 09            ret
0350+  1258             
0351+  1258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1258             ; print n size string
0353+  1258             ; pointer in d
0354+  1258             ; size in c
0355+  1258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1258             _putsn:
0357+  1258 DB            push al
0358+  1259 DA            push d
0359+  125A D9            push c
0360+  125B             _putsn_l0:
0361+  125B 1E            mov al, [d]
0362+  125C 23            mov ah, al
0363+  125D 19 00         mov al, 0
0364+  125F 05 03         syscall sys_io
0365+  1261 79            inc d
0366+  1262 7E            dec c  
0367+  1263 C2 00 00      cmp c, 0
0368+  1266 C7 5B 12      jne _putsn_l0
0369+  1269             _putsn_end:
0370+  1269 E6            pop c
0371+  126A E7            pop d
0372+  126B E8            pop al
0373+  126C 09            ret
0374+  126D             
0375+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  126D             ; print 16bit decimal number
0377+  126D             ; input number in a
0378+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  126D             print_u16d:
0380+  126D D7            push a
0381+  126E D8            push b
0382+  126F FD D8         push g
0383+  1271 26 10 27      mov b, 10000
0384+  1274 AE            div a, b      ; get 10000's coeff.
0385+  1275 07 99 12      call print_number
0386+  1278 11            mov a, b
0387+  1279 26 E8 03      mov b, 1000
0388+  127C AE            div a, b      ; get 1000's coeff.
0389+  127D 07 99 12      call print_number
0390+  1280 11            mov a, b
0391+  1281 26 64 00      mov b, 100
0392+  1284 AE            div a, b
0393+  1285 07 99 12      call print_number
0394+  1288 11            mov a, b
0395+  1289 26 0A 00      mov b, 10
0396+  128C AE            div a, b
0397+  128D 07 99 12      call print_number
0398+  1290 1B            mov al, bl      ; 1's coeff in bl
0399+  1291 07 99 12      call print_number
0400+  1294 FD F1         pop g
0401+  1296 E5            pop b
0402+  1297 E4            pop a
0403+  1298 09            ret
0404+  1299             
0405+  1299             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1299             ; print al
0407+  1299             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1299             print_number:
0409+  1299 6A 30         add al, $30
0410+  129B 23            mov ah, al
0411+  129C 07 18 11      call _putchar
0412+  129F 09            ret
0413+  12A0             
0414+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12A0             ; print 16bit hex integer
0416+  12A0             ; integer value in reg b
0417+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12A0             print_u16x:
0419+  12A0 D7            push a
0420+  12A1 D8            push b
0421+  12A2 DD            push bl
0422+  12A3 30            mov bl, bh
0423+  12A4 07 E6 10      call _itoa        ; convert bh to char in a
0424+  12A7 2F            mov bl, al        ; save al
0425+  12A8 19 00         mov al, 0
0426+  12AA 05 03         syscall sys_io        ; display ah
0427+  12AC 24            mov ah, bl        ; retrieve al
0428+  12AD 19 00         mov al, 0
0429+  12AF 05 03         syscall sys_io        ; display al
0430+  12B1             
0431+  12B1 EA            pop bl
0432+  12B2 07 E6 10      call _itoa        ; convert bh to char in a
0433+  12B5 2F            mov bl, al        ; save al
0434+  12B6 19 00         mov al, 0
0435+  12B8 05 03         syscall sys_io        ; display ah
0436+  12BA 24            mov ah, bl        ; retrieve al
0437+  12BB 19 00         mov al, 0
0438+  12BD 05 03         syscall sys_io        ; display al
0439+  12BF             
0440+  12BF E5            pop b
0441+  12C0 E4            pop a
0442+  12C1 09            ret
0443+  12C2             
0444+  12C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12C2             ; input 16bit hex integer
0446+  12C2             ; read 16bit integer into a
0447+  12C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12C2             scan_u16x:
0449+  12C2 F8 10 00      enter 16
0450+  12C5 D8            push b
0451+  12C6 DA            push d
0452+  12C7             
0453+  12C7 FA F1 FF      lea d, [bp + -15]
0454+  12CA 07 1F 11      call _gets        ; get number
0455+  12CD             
0456+  12CD 32            mov bl, [d]
0457+  12CE 37            mov bh, bl
0458+  12CF 33 01 00      mov bl, [d + 1]
0459+  12D2 07 D5 10      call _atoi        ; convert to int in al
0460+  12D5 23            mov ah, al        ; move to ah
0461+  12D6             
0462+  12D6 33 02 00      mov bl, [d + 2]
0463+  12D9 37            mov bh, bl
0464+  12DA 33 03 00      mov bl, [d + 3]
0465+  12DD 07 D5 10      call _atoi        ; convert to int in al
0466+  12E0             
0467+  12E0 E7            pop d
0468+  12E1 E5            pop b
0469+  12E2 F9            leave
0470+  12E3 09            ret
0471+  12E4             
0472+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12E4             ; print 8bit hex integer
0474+  12E4             ; integer value in reg bl
0475+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12E4             print_u8x:
0477+  12E4 D7            push a
0478+  12E5 DD            push bl
0479+  12E6             
0480+  12E6 07 E6 10      call _itoa        ; convert bl to char in a
0481+  12E9 2F            mov bl, al        ; save al
0482+  12EA 19 00         mov al, 0
0483+  12EC 05 03         syscall sys_io        ; display ah
0484+  12EE 24            mov ah, bl        ; retrieve al
0485+  12EF 19 00         mov al, 0
0486+  12F1 05 03         syscall sys_io        ; display al
0487+  12F3             
0488+  12F3 EA            pop bl
0489+  12F4 E4            pop a
0490+  12F5 09            ret
0491+  12F6             
0492+  12F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12F6             ; print 8bit decimal unsigned number
0494+  12F6             ; input number in al
0495+  12F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12F6             print_u8d:
0497+  12F6 D7            push a
0498+  12F7 D8            push b
0499+  12F8 FD D8         push g
0500+  12FA 22 00         mov ah, 0
0501+  12FC 26 64 00      mov b, 100
0502+  12FF AE            div a, b
0503+  1300 D8            push b      ; save remainder
0504+  1301 B9 00         cmp al, 0
0505+  1303 C6 0D 13      je skip100
0506+  1306 6A 30         add al, $30
0507+  1308 23            mov ah, al
0508+  1309 19 00         mov al, 0
0509+  130B 05 03         syscall sys_io  ; print coeff
0510+  130D             skip100:
0511+  130D E4            pop a
0512+  130E 22 00         mov ah, 0
0513+  1310 26 0A 00      mov b, 10
0514+  1313 AE            div a, b
0515+  1314 D8            push b      ; save remainder
0516+  1315 B9 00         cmp al, 0
0517+  1317 C6 21 13      je skip10
0518+  131A 6A 30         add al, $30
0519+  131C 23            mov ah, al
0520+  131D 19 00         mov al, 0
0521+  131F 05 03         syscall sys_io  ; print coeff
0522+  1321             skip10:
0523+  1321 E4            pop a
0524+  1322 1B            mov al, bl
0525+  1323 6A 30         add al, $30
0526+  1325 23            mov ah, al
0527+  1326 19 00         mov al, 0
0528+  1328 05 03         syscall sys_io  ; print coeff
0529+  132A FD F1         pop g
0530+  132C E5            pop b
0531+  132D E4            pop a
0532+  132E 09            ret
0533+  132F             
0534+  132F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  132F             ; input 8bit hex integer
0536+  132F             ; read 8bit integer into al
0537+  132F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  132F             scan_u8x:
0539+  132F F8 04 00      enter 4
0540+  1332 D8            push b
0541+  1333 DA            push d
0542+  1334             
0543+  1334 FA FD FF      lea d, [bp + -3]
0544+  1337 07 1F 11      call _gets        ; get number
0545+  133A             
0546+  133A 32            mov bl, [d]
0547+  133B 37            mov bh, bl
0548+  133C 33 01 00      mov bl, [d + 1]
0549+  133F 07 D5 10      call _atoi        ; convert to int in al
0550+  1342             
0551+  1342 E7            pop d
0552+  1343 E5            pop b
0553+  1344 F9            leave
0554+  1345 09            ret
0555+  1346             
0556+  1346             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1346             ; input decimal number
0558+  1346             ; result in a
0559+  1346             ; 655'\0'
0560+  1346             ; low--------high
0561+  1346             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1346             scan_u16d:
0563+  1346 F8 08 00      enter 8
0564+  1349 E2            push si
0565+  134A D8            push b
0566+  134B D9            push c
0567+  134C DA            push d
0568+  134D FA F9 FF      lea d, [bp +- 7]
0569+  1350 07 1F 11      call _gets
0570+  1353 07 77 10      call _strlen      ; get string length in c
0571+  1356 7E            dec c
0572+  1357 FD 4E         mov si, d
0573+  1359 12            mov a, c
0574+  135A FD 99         shl a
0575+  135C 3B 98 13      mov d, table_power
0576+  135F 59            add d, a
0577+  1360 38 00 00      mov c, 0
0578+  1363             mul_loop:
0579+  1363 F6            lodsb      ; load ascii to al
0580+  1364 B9 00         cmp al, 0
0581+  1366 C6 79 13      je mul_exit
0582+  1369 6F 30         sub al, $30    ; make into integer
0583+  136B 22 00         mov ah, 0
0584+  136D 2A            mov b, [d]
0585+  136E AC            mul a, b      ; result in b since it fits in 16bits
0586+  136F 11            mov a, b
0587+  1370 28            mov b, c
0588+  1371 54            add a, b
0589+  1372 39            mov c, a
0590+  1373 63 02 00      sub d, 2
0591+  1376 0A 63 13      jmp mul_loop
0592+  1379             mul_exit:
0593+  1379 12            mov a, c
0594+  137A E7            pop d
0595+  137B E6            pop c
0596+  137C E5            pop b
0597+  137D EF            pop si
0598+  137E F9            leave
0599+  137F 09            ret
0600+  1380             
0601+  1380             
0602+  1380 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  1384 34 35 36 37 
0602+  1388 38 39 61 62 
0602+  138C 63 64 65 66 
0603+  1390 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  1394 1B 5B 68 00 
0604+  1398             
0605+  1398             table_power:
0606+  1398 01 00         .dw 1
0607+  139A 0A 00         .dw 10
0608+  139C 64 00         .dw 100
0609+  139E E8 03         .dw 1000
0610+  13A0 10 27         .dw 100002724   13A2             .include "lib/ctype.asm"
0001+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13A2             ; ctype.s
0003+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13A2             
0005+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13A2             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  13A2             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  13A2             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  13A2             ;; characters are supported.
0010+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13A2             ;; _isalnum 
0012+  13A2             ;; _isalpha 
0013+  13A2             ;; islower 
0014+  13A2             ;; isupper 
0015+  13A2             ;; _isdigit 
0016+  13A2             ;; isxdigit
0017+  13A2             ;; iscntrl 
0018+  13A2             ;; isgraph 
0019+  13A2             ;; _isspace 
0020+  13A2             ;; isblank 
0021+  13A2             ;; isprint 
0022+  13A2             ;; ispunct 
0023+  13A2             ;; tolower 
0024+  13A2             ;; toupper
0025+  13A2             
0026+  13A2             
0027+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13A2             ;; is alphanumeric
0029+  13A2             ;; sets zf according with result
0030+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13A2             _isalnum:
0032+  13A2 07 BF 13    	call _isalpha
0033+  13A5 C6 AB 13    	je _isalnum_exit
0034+  13A8 07 AC 13    	call _isdigit
0035+  13AB             _isalnum_exit:
0036+  13AB 09          	ret	
0037+  13AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13AC             ;; is digit
0039+  13AC             ;; sets zf according with result
0040+  13AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13AC             _isdigit:
0042+  13AC DB          	push al
0043+  13AD B9 30       	cmp al, '0'
0044+  13AF C8 BB 13    	jlu _isdigit_false
0045+  13B2 B9 39       	cmp al, '9'
0046+  13B4 D1 BB 13    	jgu _isdigit_false
0047+  13B7 87 00       	and al, 0	; set zf
0048+  13B9 E8          	pop al
0049+  13BA 09          	ret
0050+  13BB             _isdigit_false:
0051+  13BB 8B 01       	or al, 1	; clear zf
0052+  13BD E8          	pop al
0053+  13BE 09          	ret	
0054+  13BF             	
0055+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13BF             ;; is alpha
0057+  13BF             ;; sets zf according with result
0058+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13BF             _isalpha:
0060+  13BF DB          	push al
0061+  13C0 B9 5F       	cmp al, '_'
0062+  13C2 C6 E2 13    	je _isalpha_true
0063+  13C5 B9 2E       	cmp al, '.'
0064+  13C7 C6 E2 13    	je _isalpha_true
0065+  13CA B9 61       	cmp al, 'a'
0066+  13CC C8 DE 13    	jlu _isalpha_false
0067+  13CF B9 7A       	cmp al, 'z'
0068+  13D1 D1 DE 13    	jgu _isalpha_false
0069+  13D4 B9 7A       	cmp al, 'z'
0070+  13D6 D0 E2 13    	jleu _isalpha_true
0071+  13D9 B9 61       	cmp al, 'a'
0072+  13DB C9 E2 13    	jgeu _isalpha_true
0073+  13DE             _isalpha_false:
0074+  13DE 8B 01       	or al, 1	; clear zf
0075+  13E0 E8          	pop al
0076+  13E1 09          	ret
0077+  13E2             _isalpha_true:
0078+  13E2 87 00       	and al, 0	; set zf
0079+  13E4 E8          	pop al
0080+  13E5 09          	ret
0081+  13E6             
0082+  13E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13E6             ;; is path-alpha
0084+  13E6             ;; sets zf according with result
0085+  13E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13E6             ispath:
0087+  13E6 DB          	push al
0088+  13E7 07 AC 13    	call _isdigit
0089+  13EA C6 14 14    	je ispath_true
0090+  13ED B9 5F       	cmp al, '_'
0091+  13EF C6 14 14    	je ispath_true
0092+  13F2 B9 2F       	cmp al, '/'
0093+  13F4 C6 14 14    	je ispath_true
0094+  13F7 B9 2E       	cmp al, '.'
0095+  13F9 C6 14 14    	je ispath_true
0096+  13FC B9 61       	cmp al, 'a'
0097+  13FE C8 10 14    	jlu ispath_false
0098+  1401 B9 7A       	cmp al, 'z'
0099+  1403 D1 10 14    	jgu ispath_false
0100+  1406 B9 7A       	cmp al, 'z'
0101+  1408 D0 14 14    	jleu ispath_true
0102+  140B B9 61       	cmp al, 'a'
0103+  140D C9 14 14    	jgeu ispath_true
0104+  1410             ispath_false:
0105+  1410 8B 01       	or al, 1	; clear zf
0106+  1412 E8          	pop al
0107+  1413 09          	ret
0108+  1414             ispath_true:
0109+  1414 87 00       	and al, 0	; set zf
0110+  1416 E8          	pop al
0111+  1417 09          	ret
0112+  1418             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1418             ;; is space
0114+  1418             ;; sets zf according with result
0115+  1418             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1418             _isspace:
0117+  1418 B9 20       	cmp al, $20		; ' '
0118+  141A C6 2E 14    	je _isspace_exit
0119+  141D B9 09       	cmp al, $09		; '\t'
0120+  141F C6 2E 14    	je _isspace_exit
0121+  1422 B9 0A       	cmp al, $0a		; '\n'
0122+  1424 C6 2E 14    	je _isspace_exit
0123+  1427 B9 0D       	cmp al, $0d		; '\r'
0124+  1429 C6 2E 14    	je _isspace_exit
0125+  142C B9 0B       	cmp al, $0b		; '\v'
0126+  142E             _isspace_exit:
0127+  142E 09          	ret	
0128+  142F             
0129+  142F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  142F             ; to lower
0131+  142F             ; input in al
0132+  142F             ; output in al
0133+  142F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  142F             _to_lower:
0135+  142F B9 7A       	cmp al, 'z'
0136+  1431 D1 36 14    	jgu _to_lower_ret
0137+  1434 6A 20       	add al, $20				; convert to lower case
0138+  1436             _to_lower_ret:
0139+  1436 09          	ret
0140+  1437             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1437             ; to upper
0142+  1437             ; input in al
0143+  1437             ; output in al
0144+  1437             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1437             _to_upper:
0146+  1437 B9 61       	cmp al, 'a'
0147+  1439 C8 3E 14    	jlu _to_upper_ret
0148+  143C 6F 20       	sub al, $20			; convert to upper case
0149+  143E             _to_upper_ret:
0150+  143E 09          	ret
0151+  143F             
2725   143F             .include "lib/token.asm"
0001+  143F             toktyp_identifier  .equ 0
0002+  143F             toktyp_keyword     .equ 1
0003+  143F             toktyp_delimiter   .equ 2
0004+  143F             toktyp_string      .equ 3
0005+  143F             toktyp_char        .equ 4
0006+  143F             toktyp_numeric     .equ 5
0007+  143F             toktyp_end         .equ 6
0008+  143F             
0009+  143F             tok_null           .equ 0
0010+  143F             tok_fslash         .equ 1
0011+  143F             tok_times          .equ 2
0012+  143F             tok_plus           .equ 3
0013+  143F             tok_minus          .equ 4
0014+  143F             tok_dot            .equ 5
0015+  143F             tok_semi           .equ 6
0016+  143F             tok_angle          .equ 7
0017+  143F             tok_tilde          .equ 8
0018+  143F             tok_equal          .equ 9
0019+  143F             tok_colon          .equ 10
0020+  143F             tok_comma          .equ 11
0021+  143F             
0022+  143F             tok_end            .equ 20
0023+  143F             
0024+  143F             
0025+  143F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  143F             ;; read a full command argment from shell input buffer
0027+  143F             ;; argument is written into tokstr
0028+  143F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  143F             get_arg:
0030+  143F D7            push a
0031+  1440 E2            push si
0032+  1441 E3            push di
0033+  1442 19 00         mov al, 0
0034+  1444 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0035+  1447 14 69 16      mov a, [prog]
0036+  144A 4D            mov si, a
0037+  144B FD 4F 6D 16   mov di, tokstr
0038+  144F             get_arg_skip_spaces:
0039+  144F F6            lodsb
0040+  1450 07 18 14      call _isspace
0041+  1453 C6 4F 14      je get_arg_skip_spaces
0042+  1456             get_arg_l0:
0043+  1456 B9 3B         cmp al, $3b        ; check if is ';'
0044+  1458 C6 65 14      je get_arg_end
0045+  145B B9 00         cmp al, 0
0046+  145D C6 65 14      je get_arg_end      ; check if end of input
0047+  1460 F7            stosb
0048+  1461 F6            lodsb
0049+  1462 0A 56 14      jmp get_arg_l0
0050+  1465             get_arg_end:
0051+  1465 19 00         mov al, 0
0052+  1467 F7            stosb
0053+  1468 D5 01 00      sub si, 1
0054+  146B 4E            mov a, si
0055+  146C 42 69 16      mov [prog], a    ; update pointer
0056+  146F F0            pop di
0057+  1470 EF            pop si
0058+  1471 E4            pop a
0059+  1472 09            ret
0060+  1473             
0061+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1473             ;; read a path formation from shell input buffer
0063+  1473             ;; path is written into tokstr
0064+  1473             ;; /usr/bin
0065+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1473             get_path:
0067+  1473 D7            push a
0068+  1474 E2            push si
0069+  1475 E3            push di
0070+  1476 19 00         mov al, 0
0071+  1478 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0072+  147B 14 69 16      mov a, [prog]
0073+  147E 4D            mov si, a
0074+  147F FD 4F 6D 16   mov di, tokstr
0075+  1483             get_path_skip_spaces:
0076+  1483 F6            lodsb
0077+  1484 07 18 14      call _isspace
0078+  1487 C6 83 14      je get_path_skip_spaces
0079+  148A             get_path_is_pathchar:
0080+  148A F7            stosb
0081+  148B F6            lodsb
0082+  148C 07 A2 13      call _isalnum      ;check if is alphanumeric
0083+  148F C6 8A 14      je get_path_is_pathchar
0084+  1492 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1494 C6 8A 14      je get_path_is_pathchar
0086+  1497 19 00         mov al, 0
0087+  1499 F7            stosb
0088+  149A D5 01 00      sub si, 1
0089+  149D 4E            mov a, si
0090+  149E 42 69 16      mov [prog], a    ; update pointer
0091+  14A1             get_path_end:
0092+  14A1 F0            pop di
0093+  14A2 EF            pop si
0094+  14A3 E4            pop a
0095+  14A4 09            ret
0096+  14A5             
0097+  14A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14A5             ;; read a line
0099+  14A5             ;; line is written into tokstr
0100+  14A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14A5             get_line:
0102+  14A5 D7            push a
0103+  14A6 E2            push si
0104+  14A7 E3            push di
0105+  14A8 19 00         mov al, 0
0106+  14AA 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0107+  14AD 14 69 16      mov a, [prog]
0108+  14B0 4D            mov si, a
0109+  14B1 FD 4F 6D 16   mov di, tokstr
0110+  14B5             get_line_l0:
0111+  14B5 F6            lodsb
0112+  14B6 B9 0A         cmp al, $0a    ; check for new line
0113+  14B8 C6 BF 14      je get_line_exit
0114+  14BB F7            stosb
0115+  14BC 0A B5 14      jmp get_line_l0
0116+  14BF             get_line_exit:
0117+  14BF 19 00         mov al, 0
0118+  14C1 F7            stosb
0119+  14C2 4E            mov a, si
0120+  14C3 42 69 16      mov [prog], a    ; update pointer
0121+  14C6 F0            pop di
0122+  14C7 EF            pop si
0123+  14C8 E4            pop a
0124+  14C9 09            ret
0125+  14CA             
0126+  14CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14CA             ;; token parser
0128+  14CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14CA             get_token:
0130+  14CA D7            push a
0131+  14CB DA            push d
0132+  14CC E2            push si
0133+  14CD E3            push di
0134+  14CE 19 00         mov al, 0
0135+  14D0 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0136+  14D3 19 00         mov al, tok_null
0137+  14D5 3D 6C 16      mov [tok], al        ; nullify token
0138+  14D8 14 69 16      mov a, [prog]
0139+  14DB 4D            mov si, a
0140+  14DC FD 4F 6D 16   mov di, tokstr
0141+  14E0             get_tok_skip_spaces:
0142+  14E0 F6            lodsb
0143+  14E1 07 18 14      call _isspace
0144+  14E4 C6 E0 14      je get_tok_skip_spaces
0145+  14E7 B9 00         cmp al, 0      ; check for end of input (null)
0146+  14E9 C6 CE 15      je get_token_end
0147+  14EC B9 23         cmp al, '#'      ; comments!
0148+  14EE C6 FC 15      je get_tok_comment
0149+  14F1 07 A2 13      call _isalnum
0150+  14F4 C6 DB 15      jz is_alphanumeric
0151+  14F7             ; other token types
0152+  14F7             get_token_slash:
0153+  14F7 B9 2F         cmp al, '/'        ; check if '/'
0154+  14F9 C7 11 15      jne get_token_minus
0155+  14FC F7            stosb          ; store '/' into token string
0156+  14FD 19 00         mov al, 0
0157+  14FF F7            stosb          ; terminate token string
0158+  1500 19 01         mov al, tok_fslash
0159+  1502 3D 6C 16      mov [tok], al      
0160+  1505 19 02         mov al, toktyp_delimiter
0161+  1507 3D 6B 16      mov [toktyp], al
0162+  150A 4E            mov a, si
0163+  150B 42 69 16      mov [prog], a    ; update pointer
0164+  150E 0A F7 15      jmp get_token_return
0165+  1511             get_token_minus:
0166+  1511 B9 2D         cmp al, '-'        ; check if '-'
0167+  1513 C7 2B 15      jne get_token_comma
0168+  1516 F7            stosb          ; store '-' into token string
0169+  1517 19 00         mov al, 0
0170+  1519 F7            stosb          ; terminate token string
0171+  151A 19 04         mov al, tok_minus
0172+  151C 3D 6C 16      mov [tok], al      
0173+  151F 19 02         mov al, toktyp_delimiter
0174+  1521 3D 6B 16      mov [toktyp], al
0175+  1524 4E            mov a, si
0176+  1525 42 69 16      mov [prog], a    ; update pointer
0177+  1528 0A F7 15      jmp get_token_return
0178+  152B             get_token_comma:
0179+  152B B9 2C         cmp al, ','        ; check if ','
0180+  152D C7 45 15      jne get_token_semi
0181+  1530 F7            stosb          ; store ',' into token string
0182+  1531 19 00         mov al, 0
0183+  1533 F7            stosb          ; terminate token string
0184+  1534 19 0B         mov al, tok_comma
0185+  1536 3D 6C 16      mov [tok], al      
0186+  1539 19 02         mov al, toktyp_delimiter
0187+  153B 3D 6B 16      mov [toktyp], al
0188+  153E 4E            mov a, si
0189+  153F 42 69 16      mov [prog], a    ; update pointer
0190+  1542 0A F7 15      jmp get_token_return
0191+  1545             get_token_semi:
0192+  1545 B9 3B         cmp al, $3b        ; check if ';'
0193+  1547 C7 5F 15      jne get_token_colon
0194+  154A F7            stosb          ; store ';' into token string
0195+  154B 19 00         mov al, 0
0196+  154D F7            stosb          ; terminate token string
0197+  154E 19 06         mov al, tok_semi
0198+  1550 3D 6C 16      mov [tok], al      
0199+  1553 19 02         mov al, toktyp_delimiter
0200+  1555 3D 6B 16      mov [toktyp], al
0201+  1558 4E            mov a, si
0202+  1559 42 69 16      mov [prog], a    ; update pointer
0203+  155C 0A F7 15      jmp get_token_return
0204+  155F             get_token_colon:
0205+  155F B9 3A         cmp al, $3a        ; check if ':'
0206+  1561 C7 79 15      jne get_token_angle
0207+  1564 F7            stosb          ; store ':' into token string
0208+  1565 19 00         mov al, 0
0209+  1567 F7            stosb          ; terminate token string
0210+  1568 19 0A         mov al, tok_colon
0211+  156A 3D 6C 16      mov [tok], al      
0212+  156D 19 02         mov al, toktyp_delimiter
0213+  156F 3D 6B 16      mov [toktyp], al
0214+  1572 4E            mov a, si
0215+  1573 42 69 16      mov [prog], a    ; update pointer
0216+  1576 0A F7 15      jmp get_token_return
0217+  1579             get_token_angle:
0218+  1579 B9 3E         cmp al, $3e        ; check if '>'
0219+  157B C7 93 15      jne get_token_tilde
0220+  157E F7            stosb          ; store '>' into token string
0221+  157F 19 00         mov al, 0
0222+  1581 F7            stosb          ; terminate token string
0223+  1582 19 07         mov al, tok_angle
0224+  1584 3D 6C 16      mov [tok], al      
0225+  1587 19 02         mov al, toktyp_delimiter
0226+  1589 3D 6B 16      mov [toktyp], al
0227+  158C 4E            mov a, si
0228+  158D 42 69 16      mov [prog], a    ; update pointer
0229+  1590 0A F7 15      jmp get_token_return
0230+  1593             get_token_tilde:
0231+  1593 B9 7E         cmp al, '~'        ; check if '~'
0232+  1595 C7 AD 15      jne get_token_equal
0233+  1598 F7            stosb          ; store '~' into token string
0234+  1599 19 00         mov al, 0
0235+  159B F7            stosb          ; terminate token string
0236+  159C 19 08         mov al, tok_tilde
0237+  159E 3D 6C 16      mov [tok], al      
0238+  15A1 19 02         mov al, toktyp_delimiter
0239+  15A3 3D 6B 16      mov [toktyp], al
0240+  15A6 4E            mov a, si
0241+  15A7 42 69 16      mov [prog], a    ; update pointer
0242+  15AA 0A F7 15      jmp get_token_return
0243+  15AD             get_token_equal:
0244+  15AD B9 3D         cmp al, '='        ; check if '='
0245+  15AF C7 C7 15      jne get_token_skip
0246+  15B2 F7            stosb          ; store '=' into token string
0247+  15B3 19 00         mov al, 0
0248+  15B5 F7            stosb          ; terminate token string
0249+  15B6 19 09         mov al, tok_equal
0250+  15B8 3D 6C 16      mov [tok], al      
0251+  15BB 19 02         mov al, toktyp_delimiter
0252+  15BD 3D 6B 16      mov [toktyp], al
0253+  15C0 4E            mov a, si
0254+  15C1 42 69 16      mov [prog], a    ; update pointer
0255+  15C4 0A F7 15      jmp get_token_return
0256+  15C7             get_token_skip:
0257+  15C7 4E            mov a, si
0258+  15C8 42 69 16      mov [prog], a    ; update pointer
0259+  15CB 0A F7 15      jmp get_token_return
0260+  15CE             get_token_end:        ; end of file token
0261+  15CE 19 14         mov al, tok_end
0262+  15D0 3D 6C 16      mov [tok], al
0263+  15D3 19 06         mov al, toktyp_end
0264+  15D5 3D 6B 16      mov [toktyp], al
0265+  15D8 0A F7 15      jmp get_token_return
0266+  15DB             is_alphanumeric:
0267+  15DB F7            stosb
0268+  15DC F6            lodsb
0269+  15DD 07 A2 13      call _isalnum      ;check if is alphanumeric
0270+  15E0 C6 DB 15      jz is_alphanumeric
0271+  15E3 B9 2E         cmp al, $2e        ; check if is '.'
0272+  15E5 C6 DB 15      je is_alphanumeric
0273+  15E8 19 00         mov al, 0
0274+  15EA F7            stosb
0275+  15EB 19 00         mov al, toktyp_identifier
0276+  15ED 3D 6B 16      mov [toktyp], al
0277+  15F0 D5 01 00      sub si, 1
0278+  15F3 4E            mov a, si
0279+  15F4 42 69 16      mov [prog], a    ; update pointer
0280+  15F7             get_token_return:
0281+  15F7 F0            pop di
0282+  15F8 EF            pop si
0283+  15F9 E7            pop d
0284+  15FA E4            pop a
0285+  15FB 09            ret
0286+  15FC             get_tok_comment:
0287+  15FC F6            lodsb
0288+  15FD B9 0A         cmp al, $0a      ; new line
0289+  15FF C7 FC 15      jne get_tok_comment
0290+  1602 0A E0 14      jmp get_tok_skip_spaces
0291+  1605             
0292+  1605             
0293+  1605             get_number:
0294+  1605 D7            push a
0295+  1606 DA            push d
0296+  1607 E2            push si
0297+  1608 E3            push di
0298+  1609 19 00         mov al, 0
0299+  160B 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0300+  160E 19 00         mov al, tok_null
0301+  1610 3D 6C 16      mov [tok], al        ; nullify token
0302+  1613 14 69 16      mov a, [prog]
0303+  1616 4D            mov si, a
0304+  1617 FD 4F 6D 16   mov di, tokstr
0305+  161B             get_number_skip_spaces:
0306+  161B F6            lodsb
0307+  161C 07 18 14      call _isspace
0308+  161F C6 1B 16      je get_number_skip_spaces
0309+  1622 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1624 C7 34 16      jne get_number_l0
0311+  1627 19 14         mov al, tok_end
0312+  1629 3D 6C 16      mov [tok], al
0313+  162C 19 06         mov al, toktyp_end
0314+  162E 3D 6B 16      mov [toktyp], al
0315+  1631 0A 4B 16      jmp get_number_return
0316+  1634             get_number_l0:
0317+  1634 F7            stosb
0318+  1635 F6            lodsb
0319+  1636 07 AC 13      call _isdigit      ;check if is numeric
0320+  1639 C6 34 16      jz get_number_l0
0321+  163C 19 00         mov al, 0
0322+  163E F7            stosb
0323+  163F 19 05         mov al, toktyp_numeric
0324+  1641 3D 6B 16      mov [toktyp], al
0325+  1644 D5 01 00      sub si, 1
0326+  1647 4E            mov a, si
0327+  1648 42 69 16      mov [prog], a    ; update pointer
0328+  164B             get_number_return:
0329+  164B F0            pop di
0330+  164C EF            pop si
0331+  164D E7            pop d
0332+  164E E4            pop a
0333+  164F 09            ret
0334+  1650             
0335+  1650             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1650             ;; put back token
0337+  1650             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1650             _putback:
0339+  1650 D7            push a
0340+  1651 E2            push si
0341+  1652 FD 4D 6D 16   mov si, tokstr  
0342+  1656             _putback_loop:
0343+  1656 F6            lodsb
0344+  1657 B9 00         cmp al, 0
0345+  1659 C6 66 16      je _putback_end
0346+  165C 14 69 16      mov a, [prog]
0347+  165F 7D            dec a
0348+  1660 42 69 16      mov [prog], a      ; update pointer
0349+  1663 0A 56 16      jmp _putback_loop
0350+  1666             _putback_end:
0351+  1666 EF            pop si
0352+  1667 E4            pop a
0353+  1668 09            ret
0354+  1669             
0355+  1669             
0356+  1669             
0357+  1669             
0358+  1669 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  166B             
0360+  166B 00          toktyp:    .db 0          ; token type symbol
0361+  166C 00          tok:       .db 0          ; current token symbol
0362+  166D 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1671 00 00 00 00 
0362+  1675 00 00 00 00 
0362+  1679 00 00 00 00 
0362+  167D 00 00 00 00 
0362+  1681 00 00 00 00 
0362+  1685 00 00 00 00 
0362+  1689 00 00 00 00 
0362+  168D 00 00 00 00 
0362+  1691 00 00 00 00 
0362+  1695 00 00 00 00 
0362+  1699 00 00 00 00 
0362+  169D 00 00 00 00 
0362+  16A1 00 00 00 00 
0362+  16A5 00 00 00 00 
0362+  16A9 00 00 00 00 
0362+  16AD 00 00 00 00 
0362+  16B1 00 00 00 00 
0362+  16B5 00 00 00 00 
0362+  16B9 00 00 00 00 
0362+  16BD 00 00 00 00 
0362+  16C1 00 00 00 00 
0362+  16C5 00 00 00 00 
0362+  16C9 00 00 00 00 
0362+  16CD 00 00 00 00 
0362+  16D1 00 00 00 00 
0362+  16D5 00 00 00 00 
0362+  16D9 00 00 00 00 
0362+  16DD 00 00 00 00 
0362+  16E1 00 00 00 00 
0362+  16E5 00 00 00 00 
0362+  16E9 00 00 00 00 
0362+  16ED 00 00 00 00 
0362+  16F1 00 00 00 00 
0362+  16F5 00 00 00 00 
0362+  16F9 00 00 00 00 
0362+  16FD 00 00 00 00 
0362+  1701 00 00 00 00 
0362+  1705 00 00 00 00 
0362+  1709 00 00 00 00 
0362+  170D 00 00 00 00 
0362+  1711 00 00 00 00 
0362+  1715 00 00 00 00 
0362+  1719 00 00 00 00 
0362+  171D 00 00 00 00 
0362+  1721 00 00 00 00 
0362+  1725 00 00 00 00 
0362+  1729 00 00 00 00 
0362+  172D 00 00 00 00 
0362+  1731 00 00 00 00 
0362+  1735 00 00 00 00 
0362+  1739 00 00 00 00 
0362+  173D 00 00 00 00 
0362+  1741 00 00 00 00 
0362+  1745 00 00 00 00 
0362+  1749 00 00 00 00 
0362+  174D 00 00 00 00 
0362+  1751 00 00 00 00 
0362+  1755 00 00 00 00 
0362+  1759 00 00 00 00 
0362+  175D 00 00 00 00 
0362+  1761 00 00 00 00 
0362+  1765 00 00 00 00 
0362+  1769 00 00 00 00 
2726   176D             
2727   176D             ; kernel parameters
2728   176D             sys_debug_mode:
2729   176D 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2730   176E             sys_echo_on:
2731   176E 01            .db 1
2732   176F             sys_uart0_lcr:
2733   176F 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2734   1770             sys_uart0_inten:
2735   1770 01            .db 1
2736   1771             sys_uart0_fifoen:
2737   1771 00            .db 0
2738   1772             sys_uart0_div0:
2739   1772 03            .db 3
2740   1773             sys_uart0_div1:
2741   1773 00            .db 0   ; default baud = 38400
2742   1774             ; baud  divisor
2743   1774             ; 50    2304
2744   1774             ; 110   1047
2745   1774             ; 300    384
2746   1774             ; 600    192
2747   1774             ; 1200    96
2748   1774             ; 9600    12
2749   1774             ; 19200    6
2750   1774             ; 38400    3
2751   1774             
2752   1774             nbr_active_procs:
2753   1774 00            .db 0
2754   1775             active_proc_index:
2755   1775 01            .db 1
2756   1776             
2757   1776             index:
2758   1776 00 00         .dw 0
2759   1778             buffer_addr:
2760   1778 00 00         .dw 0
2761   177A             
2762   177A             fifo_in:
2763   177A DB 1E         .dw fifo
2764   177C             fifo_out:
2765   177C DB 1E         .dw fifo
2766   177E             
2767   177E             ; file system variables
2768   177E             current_dir_id:
2769   177E 00 00         .dw 0     ; keep dirid of current directory
2770   1780             s_init_path:
2771   1780 2F 73 62 69   .db "/sbin/init", 0
2771   1784 6E 2F 69 6E 
2771   1788 69 74 00 
2772   178B             
2773   178B             s_uname:
2774   178B 73 6F 6C 61   .db "solarium v.1.0", 0
2774   178F 72 69 75 6D 
2774   1793 20 76 2E 31 
2774   1797 2E 30 00 
2775   179A             s_dataentry:
2776   179A 3E 20 00      .db "> ", 0
2777   179D             s_parent_dir:
2778   179D 2E 2E 00      .db "..", 0
2779   17A0             s_current_dir:
2780   17A0 2E 00         .db ".", 0
2781   17A2             s_fslash:
2782   17A2 2F 00         .db "/", 0
2783   17A4             file_attrib:
2784   17A4 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2784   17A8 78 
2785   17A9             file_type:
2786   17A9 2D 64 63      .db "-dc"
2787   17AC             s_ps_header:
2788   17AC 70 69 64 20   .db "pid command\n", 0
2788   17B0 63 6F 6D 6D 
2788   17B4 61 6E 64 0A 
2788   17B8 00 
2789   17B9             s_ls_total:
2790   17B9 74 6F 74 61   .db "total: ", 0
2790   17BD 6C 3A 20 00 
2791   17C1             
2792   17C1             s_int_en:
2793   17C1 69 72 71 73   .db "irqs enabled\n", 0
2793   17C5 20 65 6E 61 
2793   17C9 62 6C 65 64 
2793   17CD 0A 00 
2794   17CF             s_kernel_started:
2795   17CF 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2795   17D3 65 6C 20 73 
2795   17D7 74 61 72 74 
2795   17DB 65 64 28 76 
2795   17DF 65 72 73 69 
2795   17E3 6F 6E 20 31 
2795   17E7 2E 30 29 0A 
2795   17EB 00 
2796   17EC             s_prompt_init:
2797   17EC 73 74 61 72   .db "starting init\n", 0
2797   17F0 74 69 6E 67 
2797   17F4 20 69 6E 69 
2797   17F8 74 0A 00 
2798   17FB             s_priviledge:
2799   17FB 0A 65 78 63   .db "\nexception: privilege\n", 0
2799   17FF 65 70 74 69 
2799   1803 6F 6E 3A 20 
2799   1807 70 72 69 76 
2799   180B 69 6C 65 67 
2799   180F 65 0A 00 
2800   1812             s_divzero:
2801   1812 0A 65 78 63   .db "\nexception: zero division\n", 0
2801   1816 65 70 74 69 
2801   181A 6F 6E 3A 20 
2801   181E 7A 65 72 6F 
2801   1822 20 64 69 76 
2801   1826 69 73 69 6F 
2801   182A 6E 0A 00 
2802   182D             
2803   182D             s_set_year:
2804   182D 79 65 61 72   .db "year: ", 0
2804   1831 3A 20 00 
2805   1834             s_set_month:
2806   1834 6D 6F 6E 74   .db "month: ", 0
2806   1838 68 3A 20 00 
2807   183C             s_set_day:
2808   183C 64 61 79 3A   .db "day: ", 0
2808   1840 20 00 
2809   1842             s_set_week:
2810   1842 77 65 65 6B   .db "weekday: ", 0
2810   1846 64 61 79 3A 
2810   184A 20 00 
2811   184C             s_set_hours:
2812   184C 68 6F 75 72   .db "hours: ", 0
2812   1850 73 3A 20 00 
2813   1854             s_set_minutes:
2814   1854 6D 69 6E 75   .db "minutes: ", 0
2814   1858 74 65 73 3A 
2814   185C 20 00 
2815   185E             s_set_seconds:
2816   185E 73 65 63 6F   .db "seconds: ", 0
2816   1862 6E 64 73 3A 
2816   1866 20 00 
2817   1868             s_months:      
2818   1868 20 20 20 00   .db "   ", 0
2819   186C 6A 61 6E 00   .db "jan", 0
2820   1870 66 65 62 00   .db "feb", 0
2821   1874 6D 61 72 00   .db "mar", 0
2822   1878 61 70 72 00   .db "apr", 0
2823   187C 6D 61 79 00   .db "may", 0
2824   1880 6A 75 6E 00   .db "jun", 0
2825   1884 6A 75 6C 00   .db "jul", 0
2826   1888 61 75 67 00   .db "aug", 0
2827   188C 73 65 70 00   .db "sep", 0
2828   1890 6F 63 74 00   .db "oct", 0
2829   1894 6E 6F 76 00   .db "nov", 0
2830   1898 64 65 63 00   .db "dec", 0
2831   189C             
2832   189C             s_week:        
2833   189C 73 75 6E 00   .db "sun", 0 
2834   18A0 6D 6F 6E 00   .db "mon", 0 
2835   18A4 74 75 65 00   .db "tue", 0 
2836   18A8 77 65 64 00   .db "wed", 0 
2837   18AC 74 68 75 00   .db "thu", 0 
2838   18B0 66 72 69 00   .db "fri", 0 
2839   18B4 73 61 74 00   .db "sat", 0
2840   18B8             
2841   18B8 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2841   18BC 30 20 45 78 
2841   18C0 65 63 75 74 
2841   18C4 65 64 2E 0A 
2841   18C8 00 
2842   18C9             s_fdc_config:
2843   18C9 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2843   18CD 65 63 74 69 
2843   18D1 6E 67 20 64 
2843   18D5 69 73 6B 65 
2843   18D9 74 74 65 20 
2843   18DD 64 72 69 76 
2843   18E1 65 20 30 2C 
2843   18E5 20 73 69 64 
2843   18E9 65 20 30 2C 
2843   18ED 20 73 69 6E 
2843   18F1 67 6C 65 20 
2843   18F5 64 65 6E 73 
2843   18F9 69 74 79 2C 
2843   18FD 20 68 65 61 
2843   1901 64 20 6C 6F 
2843   1905 61 64 65 64 
2843   1909 0A 00 
2844   190B             
2845   190B             proc_state_table:   
2846   190B 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2846   190F 00 00 00 00 
2846   1913 00 00 00 00 
2846   1917 00 00 00 00 
2846   191B 00 00 00 00 
2846   191F 00 00 00 00 
2846   1923 00 00 00 00 
2846   1927 00 00 00 00 
2846   192B 00 00 00 00 
2846   192F 00 00 00 00 
2846   1933 00 00 00 00 
2846   1937 00 00 00 00 
2846   193B 00 00 00 00 
2846   193F 00 00 00 00 
2846   1943 00 00 00 00 
2846   1947 00 00 00 00 
2846   194B 00 00 00 00 
2846   194F 00 00 00 00 
2846   1953 00 00 00 00 
2846   1957 00 00 00 00 
2846   195B 00 00 00 00 
2846   195F 00 00 00 00 
2846   1963 00 00 00 00 
2846   1967 00 00 00 00 
2846   196B 00 00 00 00 
2846   196F 00 00 00 00 
2846   1973 00 00 00 00 
2846   1977 00 00 00 00 
2846   197B 00 00 00 00 
2846   197F 00 00 00 00 
2846   1983 00 00 00 00 
2846   1987 00 00 00 00 
2846   198B 00 00 00 00 
2846   198F 00 00 00 00 
2846   1993 00 00 00 00 
2846   1997 00 00 00 00 
2846   199B 00 00 00 00 
2846   199F 00 00 00 00 
2846   19A3 00 00 00 00 
2846   19A7 00 00 00 00 
2846   19AB 00 00 00 00 
2846   19AF 00 00 00 00 
2846   19B3 00 00 00 00 
2846   19B7 00 00 00 00 
2846   19BB 00 00 00 00 
2846   19BF 00 00 00 00 
2846   19C3 00 00 00 00 
2846   19C7 00 00 00 00 
2846   19CB 00 00 00 00 
2846   19CF 00 00 00 00 
2846   19D3 00 00 00 00 
2846   19D7 00 00 00 00 
2846   19DB 00 00 00 00 
2846   19DF 00 00 00 00 
2846   19E3 00 00 00 00 
2846   19E7 00 00 00 00 
2846   19EB 00 00 00 00 
2846   19EF 00 00 00 00 
2846   19F3 00 00 00 00 
2846   19F7 00 00 00 00 
2846   19FB 00 00 00 00 
2846   19FF 00 00 00 00 
2846   1A03 00 00 00 00 
2846   1A07 00 00 00 00 
2846   1A0B 00 00 00 00 
2846   1A0F 00 00 00 00 
2846   1A13 00 00 00 00 
2846   1A17 00 00 00 00 
2846   1A1B 00 00 00 00 
2846   1A1F 00 00 00 00 
2846   1A23 00 00 00 00 
2846   1A27 00 00 00 00 
2846   1A2B 00 00 00 00 
2846   1A2F 00 00 00 00 
2846   1A33 00 00 00 00 
2846   1A37 00 00 00 00 
2846   1A3B 00 00 00 00 
2846   1A3F 00 00 00 00 
2846   1A43 00 00 00 00 
2846   1A47 00 00 00 00 
2847   1A4B             proc_availab_table: 
2848   1A4B 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2848   1A4F 00 00 00 00 
2848   1A53 00 00 00 00 
2848   1A57 00 00 00 00 
2849   1A5B             proc_names:
2850   1A5B 00 00 00 00   .fill 16 * 32, 0  ; process names
2850   1A5F 00 00 00 00 
2850   1A63 00 00 00 00 
2850   1A67 00 00 00 00 
2850   1A6B 00 00 00 00 
2850   1A6F 00 00 00 00 
2850   1A73 00 00 00 00 
2850   1A77 00 00 00 00 
2850   1A7B 00 00 00 00 
2850   1A7F 00 00 00 00 
2850   1A83 00 00 00 00 
2850   1A87 00 00 00 00 
2850   1A8B 00 00 00 00 
2850   1A8F 00 00 00 00 
2850   1A93 00 00 00 00 
2850   1A97 00 00 00 00 
2850   1A9B 00 00 00 00 
2850   1A9F 00 00 00 00 
2850   1AA3 00 00 00 00 
2850   1AA7 00 00 00 00 
2850   1AAB 00 00 00 00 
2850   1AAF 00 00 00 00 
2850   1AB3 00 00 00 00 
2850   1AB7 00 00 00 00 
2850   1ABB 00 00 00 00 
2850   1ABF 00 00 00 00 
2850   1AC3 00 00 00 00 
2850   1AC7 00 00 00 00 
2850   1ACB 00 00 00 00 
2850   1ACF 00 00 00 00 
2850   1AD3 00 00 00 00 
2850   1AD7 00 00 00 00 
2850   1ADB 00 00 00 00 
2850   1ADF 00 00 00 00 
2850   1AE3 00 00 00 00 
2850   1AE7 00 00 00 00 
2850   1AEB 00 00 00 00 
2850   1AEF 00 00 00 00 
2850   1AF3 00 00 00 00 
2850   1AF7 00 00 00 00 
2850   1AFB 00 00 00 00 
2850   1AFF 00 00 00 00 
2850   1B03 00 00 00 00 
2850   1B07 00 00 00 00 
2850   1B0B 00 00 00 00 
2850   1B0F 00 00 00 00 
2850   1B13 00 00 00 00 
2850   1B17 00 00 00 00 
2850   1B1B 00 00 00 00 
2850   1B1F 00 00 00 00 
2850   1B23 00 00 00 00 
2850   1B27 00 00 00 00 
2850   1B2B 00 00 00 00 
2850   1B2F 00 00 00 00 
2850   1B33 00 00 00 00 
2850   1B37 00 00 00 00 
2850   1B3B 00 00 00 00 
2850   1B3F 00 00 00 00 
2850   1B43 00 00 00 00 
2850   1B47 00 00 00 00 
2850   1B4B 00 00 00 00 
2850   1B4F 00 00 00 00 
2850   1B53 00 00 00 00 
2850   1B57 00 00 00 00 
2850   1B5B 00 00 00 00 
2850   1B5F 00 00 00 00 
2850   1B63 00 00 00 00 
2850   1B67 00 00 00 00 
2850   1B6B 00 00 00 00 
2850   1B6F 00 00 00 00 
2850   1B73 00 00 00 00 
2850   1B77 00 00 00 00 
2850   1B7B 00 00 00 00 
2850   1B7F 00 00 00 00 
2850   1B83 00 00 00 00 
2850   1B87 00 00 00 00 
2850   1B8B 00 00 00 00 
2850   1B8F 00 00 00 00 
2850   1B93 00 00 00 00 
2850   1B97 00 00 00 00 
2850   1B9B 00 00 00 00 
2850   1B9F 00 00 00 00 
2850   1BA3 00 00 00 00 
2850   1BA7 00 00 00 00 
2850   1BAB 00 00 00 00 
2850   1BAF 00 00 00 00 
2850   1BB3 00 00 00 00 
2850   1BB7 00 00 00 00 
2850   1BBB 00 00 00 00 
2850   1BBF 00 00 00 00 
2850   1BC3 00 00 00 00 
2850   1BC7 00 00 00 00 
2850   1BCB 00 00 00 00 
2850   1BCF 00 00 00 00 
2850   1BD3 00 00 00 00 
2850   1BD7 00 00 00 00 
2850   1BDB 00 00 00 00 
2850   1BDF 00 00 00 00 
2850   1BE3 00 00 00 00 
2850   1BE7 00 00 00 00 
2850   1BEB 00 00 00 00 
2850   1BEF 00 00 00 00 
2850   1BF3 00 00 00 00 
2850   1BF7 00 00 00 00 
2850   1BFB 00 00 00 00 
2850   1BFF 00 00 00 00 
2850   1C03 00 00 00 00 
2850   1C07 00 00 00 00 
2850   1C0B 00 00 00 00 
2850   1C0F 00 00 00 00 
2850   1C13 00 00 00 00 
2850   1C17 00 00 00 00 
2850   1C1B 00 00 00 00 
2850   1C1F 00 00 00 00 
2850   1C23 00 00 00 00 
2850   1C27 00 00 00 00 
2850   1C2B 00 00 00 00 
2850   1C2F 00 00 00 00 
2850   1C33 00 00 00 00 
2850   1C37 00 00 00 00 
2850   1C3B 00 00 00 00 
2850   1C3F 00 00 00 00 
2850   1C43 00 00 00 00 
2850   1C47 00 00 00 00 
2850   1C4B 00 00 00 00 
2850   1C4F 00 00 00 00 
2850   1C53 00 00 00 00 
2850   1C57 00 00 00 00 
2851   1C5B             filename:
2852   1C5B 00 00 00 00   .fill 128, 0      ; holds a path for file search
2852   1C5F 00 00 00 00 
2852   1C63 00 00 00 00 
2852   1C67 00 00 00 00 
2852   1C6B 00 00 00 00 
2852   1C6F 00 00 00 00 
2852   1C73 00 00 00 00 
2852   1C77 00 00 00 00 
2852   1C7B 00 00 00 00 
2852   1C7F 00 00 00 00 
2852   1C83 00 00 00 00 
2852   1C87 00 00 00 00 
2852   1C8B 00 00 00 00 
2852   1C8F 00 00 00 00 
2852   1C93 00 00 00 00 
2852   1C97 00 00 00 00 
2852   1C9B 00 00 00 00 
2852   1C9F 00 00 00 00 
2852   1CA3 00 00 00 00 
2852   1CA7 00 00 00 00 
2852   1CAB 00 00 00 00 
2852   1CAF 00 00 00 00 
2852   1CB3 00 00 00 00 
2852   1CB7 00 00 00 00 
2852   1CBB 00 00 00 00 
2852   1CBF 00 00 00 00 
2852   1CC3 00 00 00 00 
2852   1CC7 00 00 00 00 
2852   1CCB 00 00 00 00 
2852   1CCF 00 00 00 00 
2852   1CD3 00 00 00 00 
2852   1CD7 00 00 00 00 
2853   1CDB             user_data:
2854   1CDB 00 00 00 00   .fill 512, 0      ;  user space data
2854   1CDF 00 00 00 00 
2854   1CE3 00 00 00 00 
2854   1CE7 00 00 00 00 
2854   1CEB 00 00 00 00 
2854   1CEF 00 00 00 00 
2854   1CF3 00 00 00 00 
2854   1CF7 00 00 00 00 
2854   1CFB 00 00 00 00 
2854   1CFF 00 00 00 00 
2854   1D03 00 00 00 00 
2854   1D07 00 00 00 00 
2854   1D0B 00 00 00 00 
2854   1D0F 00 00 00 00 
2854   1D13 00 00 00 00 
2854   1D17 00 00 00 00 
2854   1D1B 00 00 00 00 
2854   1D1F 00 00 00 00 
2854   1D23 00 00 00 00 
2854   1D27 00 00 00 00 
2854   1D2B 00 00 00 00 
2854   1D2F 00 00 00 00 
2854   1D33 00 00 00 00 
2854   1D37 00 00 00 00 
2854   1D3B 00 00 00 00 
2854   1D3F 00 00 00 00 
2854   1D43 00 00 00 00 
2854   1D47 00 00 00 00 
2854   1D4B 00 00 00 00 
2854   1D4F 00 00 00 00 
2854   1D53 00 00 00 00 
2854   1D57 00 00 00 00 
2854   1D5B 00 00 00 00 
2854   1D5F 00 00 00 00 
2854   1D63 00 00 00 00 
2854   1D67 00 00 00 00 
2854   1D6B 00 00 00 00 
2854   1D6F 00 00 00 00 
2854   1D73 00 00 00 00 
2854   1D77 00 00 00 00 
2854   1D7B 00 00 00 00 
2854   1D7F 00 00 00 00 
2854   1D83 00 00 00 00 
2854   1D87 00 00 00 00 
2854   1D8B 00 00 00 00 
2854   1D8F 00 00 00 00 
2854   1D93 00 00 00 00 
2854   1D97 00 00 00 00 
2854   1D9B 00 00 00 00 
2854   1D9F 00 00 00 00 
2854   1DA3 00 00 00 00 
2854   1DA7 00 00 00 00 
2854   1DAB 00 00 00 00 
2854   1DAF 00 00 00 00 
2854   1DB3 00 00 00 00 
2854   1DB7 00 00 00 00 
2854   1DBB 00 00 00 00 
2854   1DBF 00 00 00 00 
2854   1DC3 00 00 00 00 
2854   1DC7 00 00 00 00 
2854   1DCB 00 00 00 00 
2854   1DCF 00 00 00 00 
2854   1DD3 00 00 00 00 
2854   1DD7 00 00 00 00 
2854   1DDB 00 00 00 00 
2854   1DDF 00 00 00 00 
2854   1DE3 00 00 00 00 
2854   1DE7 00 00 00 00 
2854   1DEB 00 00 00 00 
2854   1DEF 00 00 00 00 
2854   1DF3 00 00 00 00 
2854   1DF7 00 00 00 00 
2854   1DFB 00 00 00 00 
2854   1DFF 00 00 00 00 
2854   1E03 00 00 00 00 
2854   1E07 00 00 00 00 
2854   1E0B 00 00 00 00 
2854   1E0F 00 00 00 00 
2854   1E13 00 00 00 00 
2854   1E17 00 00 00 00 
2854   1E1B 00 00 00 00 
2854   1E1F 00 00 00 00 
2854   1E23 00 00 00 00 
2854   1E27 00 00 00 00 
2854   1E2B 00 00 00 00 
2854   1E2F 00 00 00 00 
2854   1E33 00 00 00 00 
2854   1E37 00 00 00 00 
2854   1E3B 00 00 00 00 
2854   1E3F 00 00 00 00 
2854   1E43 00 00 00 00 
2854   1E47 00 00 00 00 
2854   1E4B 00 00 00 00 
2854   1E4F 00 00 00 00 
2854   1E53 00 00 00 00 
2854   1E57 00 00 00 00 
2854   1E5B 00 00 00 00 
2854   1E5F 00 00 00 00 
2854   1E63 00 00 00 00 
2854   1E67 00 00 00 00 
2854   1E6B 00 00 00 00 
2854   1E6F 00 00 00 00 
2854   1E73 00 00 00 00 
2854   1E77 00 00 00 00 
2854   1E7B 00 00 00 00 
2854   1E7F 00 00 00 00 
2854   1E83 00 00 00 00 
2854   1E87 00 00 00 00 
2854   1E8B 00 00 00 00 
2854   1E8F 00 00 00 00 
2854   1E93 00 00 00 00 
2854   1E97 00 00 00 00 
2854   1E9B 00 00 00 00 
2854   1E9F 00 00 00 00 
2854   1EA3 00 00 00 00 
2854   1EA7 00 00 00 00 
2854   1EAB 00 00 00 00 
2854   1EAF 00 00 00 00 
2854   1EB3 00 00 00 00 
2854   1EB7 00 00 00 00 
2854   1EBB 00 00 00 00 
2854   1EBF 00 00 00 00 
2854   1EC3 00 00 00 00 
2854   1EC7 00 00 00 00 
2854   1ECB 00 00 00 00 
2854   1ECF 00 00 00 00 
2854   1ED3 00 00 00 00 
2854   1ED7 00 00 00 00 
2855   1EDB             fifo:
2856   1EDB FF FF FF FF   .fill fifo_size
2856   1EDF FF FF FF FF 
2856   1EE3 FF FF FF FF 
2856   1EE7 FF FF FF FF 
2856   1EEB FF FF FF FF 
2856   1EEF FF FF FF FF 
2856   1EF3 FF FF FF FF 
2856   1EF7 FF FF FF FF 
2856   1EFB FF FF FF FF 
2856   1EFF FF FF FF FF 
2856   1F03 FF FF FF FF 
2856   1F07 FF FF FF FF 
2856   1F0B FF FF FF FF 
2856   1F0F FF FF FF FF 
2856   1F13 FF FF FF FF 
2856   1F17 FF FF FF FF 
2856   1F1B FF FF FF FF 
2856   1F1F FF FF FF FF 
2856   1F23 FF FF FF FF 
2856   1F27 FF FF FF FF 
2856   1F2B FF FF FF FF 
2856   1F2F FF FF FF FF 
2856   1F33 FF FF FF FF 
2856   1F37 FF FF FF FF 
2856   1F3B FF FF FF FF 
2856   1F3F FF FF FF FF 
2856   1F43 FF FF FF FF 
2856   1F47 FF FF FF FF 
2856   1F4B FF FF FF FF 
2856   1F4F FF FF FF FF 
2856   1F53 FF FF FF FF 
2856   1F57 FF FF FF FF 
2856   1F5B FF FF FF FF 
2856   1F5F FF FF FF FF 
2856   1F63 FF FF FF FF 
2856   1F67 FF FF FF FF 
2856   1F6B FF FF FF FF 
2856   1F6F FF FF FF FF 
2856   1F73 FF FF FF FF 
2856   1F77 FF FF FF FF 
2856   1F7B FF FF FF FF 
2856   1F7F FF FF FF FF 
2856   1F83 FF FF FF FF 
2856   1F87 FF FF FF FF 
2856   1F8B FF FF FF FF 
2856   1F8F FF FF FF FF 
2856   1F93 FF FF FF FF 
2856   1F97 FF FF FF FF 
2856   1F9B FF FF FF FF 
2856   1F9F FF FF FF FF 
2856   1FA3 FF FF FF FF 
2856   1FA7 FF FF FF FF 
2856   1FAB FF FF FF FF 
2856   1FAF FF FF FF FF 
2856   1FB3 FF FF FF FF 
2856   1FB7 FF FF FF FF 
2856   1FBB FF FF FF FF 
2856   1FBF FF FF FF FF 
2856   1FC3 FF FF FF FF 
2856   1FC7 FF FF FF FF 
2856   1FCB FF FF FF FF 
2856   1FCF FF FF FF FF 
2856   1FD3 FF FF FF FF 
2856   1FD7 FF FF FF FF 
2856   1FDB FF FF FF FF 
2856   1FDF FF FF FF FF 
2856   1FE3 FF FF FF FF 
2856   1FE7 FF FF FF FF 
2856   1FEB FF FF FF FF 
2856   1FEF FF FF FF FF 
2856   1FF3 FF FF FF FF 
2856   1FF7 FF FF FF FF 
2856   1FFB FF FF FF FF 
2856   1FFF FF FF FF FF 
2856   2003 FF FF FF FF 
2856   2007 FF FF FF FF 
2856   200B FF FF FF FF 
2856   200F FF FF FF FF 
2856   2013 FF FF FF FF 
2856   2017 FF FF FF FF 
2856   201B FF FF FF FF 
2856   201F FF FF FF FF 
2856   2023 FF FF FF FF 
2856   2027 FF FF FF FF 
2856   202B FF FF FF FF 
2856   202F FF FF FF FF 
2856   2033 FF FF FF FF 
2856   2037 FF FF FF FF 
2856   203B FF FF FF FF 
2856   203F FF FF FF FF 
2856   2043 FF FF FF FF 
2856   2047 FF FF FF FF 
2856   204B FF FF FF FF 
2856   204F FF FF FF FF 
2856   2053 FF FF FF FF 
2856   2057 FF FF FF FF 
2856   205B FF FF FF FF 
2856   205F FF FF FF FF 
2856   2063 FF FF FF FF 
2856   2067 FF FF FF FF 
2856   206B FF FF FF FF 
2856   206F FF FF FF FF 
2856   2073 FF FF FF FF 
2856   2077 FF FF FF FF 
2856   207B FF FF FF FF 
2856   207F FF FF FF FF 
2856   2083 FF FF FF FF 
2856   2087 FF FF FF FF 
2856   208B FF FF FF FF 
2856   208F FF FF FF FF 
2856   2093 FF FF FF FF 
2856   2097 FF FF FF FF 
2856   209B FF FF FF FF 
2856   209F FF FF FF FF 
2856   20A3 FF FF FF FF 
2856   20A7 FF FF FF FF 
2856   20AB FF FF FF FF 
2856   20AF FF FF FF FF 
2856   20B3 FF FF FF FF 
2856   20B7 FF FF FF FF 
2856   20BB FF FF FF FF 
2856   20BF FF FF FF FF 
2856   20C3 FF FF FF FF 
2856   20C7 FF FF FF FF 
2856   20CB FF FF FF FF 
2856   20CF FF FF FF FF 
2856   20D3 FF FF FF FF 
2856   20D7 FF FF FF FF 
2856   20DB FF FF FF FF 
2856   20DF FF FF FF FF 
2856   20E3 FF FF FF FF 
2856   20E7 FF FF FF FF 
2856   20EB FF FF FF FF 
2856   20EF FF FF FF FF 
2856   20F3 FF FF FF FF 
2856   20F7 FF FF FF FF 
2856   20FB FF FF FF FF 
2856   20FF FF FF FF FF 
2856   2103 FF FF FF FF 
2856   2107 FF FF FF FF 
2856   210B FF FF FF FF 
2856   210F FF FF FF FF 
2856   2113 FF FF FF FF 
2856   2117 FF FF FF FF 
2856   211B FF FF FF FF 
2856   211F FF FF FF FF 
2856   2123 FF FF FF FF 
2856   2127 FF FF FF FF 
2856   212B FF FF FF FF 
2856   212F FF FF FF FF 
2856   2133 FF FF FF FF 
2856   2137 FF FF FF FF 
2856   213B FF FF FF FF 
2856   213F FF FF FF FF 
2856   2143 FF FF FF FF 
2856   2147 FF FF FF FF 
2856   214B FF FF FF FF 
2856   214F FF FF FF FF 
2856   2153 FF FF FF FF 
2856   2157 FF FF FF FF 
2856   215B FF FF FF FF 
2856   215F FF FF FF FF 
2856   2163 FF FF FF FF 
2856   2167 FF FF FF FF 
2856   216B FF FF FF FF 
2856   216F FF FF FF FF 
2856   2173 FF FF FF FF 
2856   2177 FF FF FF FF 
2856   217B FF FF FF FF 
2856   217F FF FF FF FF 
2856   2183 FF FF FF FF 
2856   2187 FF FF FF FF 
2856   218B FF FF FF FF 
2856   218F FF FF FF FF 
2856   2193 FF FF FF FF 
2856   2197 FF FF FF FF 
2856   219B FF FF FF FF 
2856   219F FF FF FF FF 
2856   21A3 FF FF FF FF 
2856   21A7 FF FF FF FF 
2856   21AB FF FF FF FF 
2856   21AF FF FF FF FF 
2856   21B3 FF FF FF FF 
2856   21B7 FF FF FF FF 
2856   21BB FF FF FF FF 
2856   21BF FF FF FF FF 
2856   21C3 FF FF FF FF 
2856   21C7 FF FF FF FF 
2856   21CB FF FF FF FF 
2856   21CF FF FF FF FF 
2856   21D3 FF FF FF FF 
2856   21D7 FF FF FF FF 
2856   21DB FF FF FF FF 
2856   21DF FF FF FF FF 
2856   21E3 FF FF FF FF 
2856   21E7 FF FF FF FF 
2856   21EB FF FF FF FF 
2856   21EF FF FF FF FF 
2856   21F3 FF FF FF FF 
2856   21F7 FF FF FF FF 
2856   21FB FF FF FF FF 
2856   21FF FF FF FF FF 
2856   2203 FF FF FF FF 
2856   2207 FF FF FF FF 
2856   220B FF FF FF FF 
2856   220F FF FF FF FF 
2856   2213 FF FF FF FF 
2856   2217 FF FF FF FF 
2856   221B FF FF FF FF 
2856   221F FF FF FF FF 
2856   2223 FF FF FF FF 
2856   2227 FF FF FF FF 
2856   222B FF FF FF FF 
2856   222F FF FF FF FF 
2856   2233 FF FF FF FF 
2856   2237 FF FF FF FF 
2856   223B FF FF FF FF 
2856   223F FF FF FF FF 
2856   2243 FF FF FF FF 
2856   2247 FF FF FF FF 
2856   224B FF FF FF FF 
2856   224F FF FF FF FF 
2856   2253 FF FF FF FF 
2856   2257 FF FF FF FF 
2856   225B FF FF FF FF 
2856   225F FF FF FF FF 
2856   2263 FF FF FF FF 
2856   2267 FF FF FF FF 
2856   226B FF FF FF FF 
2856   226F FF FF FF FF 
2856   2273 FF FF FF FF 
2856   2277 FF FF FF FF 
2856   227B FF FF FF FF 
2856   227F FF FF FF FF 
2856   2283 FF FF FF FF 
2856   2287 FF FF FF FF 
2856   228B FF FF FF FF 
2856   228F FF FF FF FF 
2856   2293 FF FF FF FF 
2856   2297 FF FF FF FF 
2856   229B FF FF FF FF 
2856   229F FF FF FF FF 
2856   22A3 FF FF FF FF 
2856   22A7 FF FF FF FF 
2856   22AB FF FF FF FF 
2856   22AF FF FF FF FF 
2856   22B3 FF FF FF FF 
2856   22B7 FF FF FF FF 
2856   22BB FF FF FF FF 
2856   22BF FF FF FF FF 
2856   22C3 FF FF FF FF 
2856   22C7 FF FF FF FF 
2856   22CB FF FF FF FF 
2856   22CF FF FF FF FF 
2856   22D3 FF FF FF FF 
2856   22D7 FF FF FF FF 
2857   22DB             
2858   22DB             scrap_sector:
2859   22DB FF FF FF FF   .fill 512         ; scrap sector
2859   22DF FF FF FF FF 
2859   22E3 FF FF FF FF 
2859   22E7 FF FF FF FF 
2859   22EB FF FF FF FF 
2859   22EF FF FF FF FF 
2859   22F3 FF FF FF FF 
2859   22F7 FF FF FF FF 
2859   22FB FF FF FF FF 
2859   22FF FF FF FF FF 
2859   2303 FF FF FF FF 
2859   2307 FF FF FF FF 
2859   230B FF FF FF FF 
2859   230F FF FF FF FF 
2859   2313 FF FF FF FF 
2859   2317 FF FF FF FF 
2859   231B FF FF FF FF 
2859   231F FF FF FF FF 
2859   2323 FF FF FF FF 
2859   2327 FF FF FF FF 
2859   232B FF FF FF FF 
2859   232F FF FF FF FF 
2859   2333 FF FF FF FF 
2859   2337 FF FF FF FF 
2859   233B FF FF FF FF 
2859   233F FF FF FF FF 
2859   2343 FF FF FF FF 
2859   2347 FF FF FF FF 
2859   234B FF FF FF FF 
2859   234F FF FF FF FF 
2859   2353 FF FF FF FF 
2859   2357 FF FF FF FF 
2859   235B FF FF FF FF 
2859   235F FF FF FF FF 
2859   2363 FF FF FF FF 
2859   2367 FF FF FF FF 
2859   236B FF FF FF FF 
2859   236F FF FF FF FF 
2859   2373 FF FF FF FF 
2859   2377 FF FF FF FF 
2859   237B FF FF FF FF 
2859   237F FF FF FF FF 
2859   2383 FF FF FF FF 
2859   2387 FF FF FF FF 
2859   238B FF FF FF FF 
2859   238F FF FF FF FF 
2859   2393 FF FF FF FF 
2859   2397 FF FF FF FF 
2859   239B FF FF FF FF 
2859   239F FF FF FF FF 
2859   23A3 FF FF FF FF 
2859   23A7 FF FF FF FF 
2859   23AB FF FF FF FF 
2859   23AF FF FF FF FF 
2859   23B3 FF FF FF FF 
2859   23B7 FF FF FF FF 
2859   23BB FF FF FF FF 
2859   23BF FF FF FF FF 
2859   23C3 FF FF FF FF 
2859   23C7 FF FF FF FF 
2859   23CB FF FF FF FF 
2859   23CF FF FF FF FF 
2859   23D3 FF FF FF FF 
2859   23D7 FF FF FF FF 
2859   23DB FF FF FF FF 
2859   23DF FF FF FF FF 
2859   23E3 FF FF FF FF 
2859   23E7 FF FF FF FF 
2859   23EB FF FF FF FF 
2859   23EF FF FF FF FF 
2859   23F3 FF FF FF FF 
2859   23F7 FF FF FF FF 
2859   23FB FF FF FF FF 
2859   23FF FF FF FF FF 
2859   2403 FF FF FF FF 
2859   2407 FF FF FF FF 
2859   240B FF FF FF FF 
2859   240F FF FF FF FF 
2859   2413 FF FF FF FF 
2859   2417 FF FF FF FF 
2859   241B FF FF FF FF 
2859   241F FF FF FF FF 
2859   2423 FF FF FF FF 
2859   2427 FF FF FF FF 
2859   242B FF FF FF FF 
2859   242F FF FF FF FF 
2859   2433 FF FF FF FF 
2859   2437 FF FF FF FF 
2859   243B FF FF FF FF 
2859   243F FF FF FF FF 
2859   2443 FF FF FF FF 
2859   2447 FF FF FF FF 
2859   244B FF FF FF FF 
2859   244F FF FF FF FF 
2859   2453 FF FF FF FF 
2859   2457 FF FF FF FF 
2859   245B FF FF FF FF 
2859   245F FF FF FF FF 
2859   2463 FF FF FF FF 
2859   2467 FF FF FF FF 
2859   246B FF FF FF FF 
2859   246F FF FF FF FF 
2859   2473 FF FF FF FF 
2859   2477 FF FF FF FF 
2859   247B FF FF FF FF 
2859   247F FF FF FF FF 
2859   2483 FF FF FF FF 
2859   2487 FF FF FF FF 
2859   248B FF FF FF FF 
2859   248F FF FF FF FF 
2859   2493 FF FF FF FF 
2859   2497 FF FF FF FF 
2859   249B FF FF FF FF 
2859   249F FF FF FF FF 
2859   24A3 FF FF FF FF 
2859   24A7 FF FF FF FF 
2859   24AB FF FF FF FF 
2859   24AF FF FF FF FF 
2859   24B3 FF FF FF FF 
2859   24B7 FF FF FF FF 
2859   24BB FF FF FF FF 
2859   24BF FF FF FF FF 
2859   24C3 FF FF FF FF 
2859   24C7 FF FF FF FF 
2859   24CB FF FF FF FF 
2859   24CF FF FF FF FF 
2859   24D3 FF FF FF FF 
2859   24D7 FF FF FF FF 
2860   24DB             transient_area:
2861   24DB 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2862   24DC             
2863   24DC             .end
tasm: Number of errors = 0
