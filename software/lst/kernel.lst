0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data             .equ $ff80         ; data
0034   0000             _uart0_dlab_0           .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1           .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier              .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr              .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr              .equ $ff83         ; line control register
0039   0000             _uart0_lsr              .equ $ff85         ; line status register
0040   0000                                   
0041   0000             _uart1_data             .equ $ff88         ; data
0042   0000             _uart1_dlab_0           .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1           .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier              .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr              .equ $ff8A         ; fifo control register
0046   0000             _uart1_lcr              .equ $ff8B         ; line control register
0047   0000             _uart1_lsr              .equ $ff8D         ; line status register
0048   0000                                   
0049   0000             _ide_base               .equ $ffd0         ; ide base
0050   0000             _ide_r0                 .equ _ide_base + 0 ; data port
0051   0000             _ide_r1                 .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2                 .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3                 .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4                 .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5                 .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6                 .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7                 .equ _ide_base + 7 ; read: status, write: command       
0058   0000                                   
0059   0000             _til311_display         .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl         .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a                  .equ $ffb0    
0062   0000             _pio_b                  .equ $ffb1
0063   0000             _pio_c                  .equ $ffb2
0064   0000             _pio_control            .equ $ffb3         ; pio control port
0065   0000                                   
0066   0000             _fdc_config             .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0           .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd           .equ $ffc8         ; status / command register
0069   0000             _fdc_track              .equ $ffc9         ; track register
0070   0000             _fdc_sector             .equ $ffca         ; sector register
0071   0000             _fdc_data               .equ $ffcb         ; data register
0072   0000                                   
0073   0000             _timer_c_0              .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1              .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2              .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl             .equ $ffe3         ; timer control register
0077   0000                                   
0078   0000             _stack_top              .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size              .equ 4096
0080   0000             _scrap_size             .equ 512
0081   0000             
0082   0000             _file_type_null         .equ 0
0083   0000             _file_type_reg          .equ 1
0084   0000             _file_type_chardev      .equ 2
0085   0000             _file_type_blockdev     .equ 3
0086   0000             
0087   0000             proc_unused             .equ 0  ; slot free
0088   0000             proc_runnable           .equ 1  ; ready to run
0089   0000             proc_running            .equ 2  ; currently on cpu
0090   0000             proc_sleeping           .equ 3  ; waiting for event
0091   0000             proc_zombie             .equ 4  ; exited, not reaped
0092   0000             
0093   0000             
0094   0000             _num_cpu_regs           .equ 10                                     ; A, B, C, D, G, PC, BP, SP, SI, DI
0095   0000             _max_user_proc          .equ 128                                    ; max number of concurrent user processes
0096   0000             _fd_per_proc            .equ 32                                     ; for kernel's file descriptor table per process
0097   0000             _num_file_objs          .equ 128                                    ; for the kernel's file object table
0098   0000             _size_file_obj_entry    .equ 1 + 2 + 1 + 2 + 2 + (4 * 2)            ; refcount, flags, type, target, offset, ops
0099   0000             _size_file_obj_table    .equ _num_file_objs * _size_file_obj_entry  ; kernel's file object table
0100   0000             
0101   0000             _size_proc_entry        .equ 1 + 1 + _fd_per_proc * 2 + 2 + _num_cpu_regs * 2 + 1 + 39 ; pid, state, fd_table, tty pointer, context (general regs + flags), 39 bytes padding to reach 128
0102   0000             _size_proc_table        .equ _size_proc_entry * _max_user_proc  ; 16k total
0103   0000             
0104   0000             
0105   0000             text_org                .equ $400          ; code origin address for all user processes
0106   0000             data_blocks_sect_start  .equ 4124
0107   0000             
0108   0000             ;  ------------------------------------------------------------------------------------------------------------------;
0109   0000             ;  DISK LAYOUT:
0110   0000             ;  Metadata               | Size (bytes)      | Blocks (2048 bytes)              |Start Block |  Comment
0111   0000             ;  ---------------------- | ----------------- | -------------------------------- |------------|-----------------------------------
0112   0000             ;  Bootloader/MBR         | 1024 bytes        | 0.5 (1 sector)                   |  0         |
0113   0000             ;  Superblock             | 1024 bytes        | 1 block (2048 bytes, must align) |  0         |
0114   0000             ;                         |                   | 1 block (2048 bytes)             |  1         | reserved
0115   0000             ;  Block Bitmap           | 8,192 bytes       | 4 blocks                         |  2         | 4*2048*8 = 4*16384 = 65536 raw data blocks.  65536*2048 bytes = 134217728 bytes of disk space = 128MB
0116   0000             ;  Inode Bitmap           | 2,048 bytes       | 1 block                          |  6         | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is 1 inode per 8KB of disk space
0117   0000             ;  Inode Table            | 2,097,152 bytes   | 1024 blocks                      |  7         | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0118   0000             ;  Data Blocks            | 134,217,728 bytes | 65528 blocks                     | 1031       | 65528 blocks = 134,201,344 bytes
0119   0000             ;  
0120   0000             ;  first 1024 bytes: bootloader from 0 to 959, MBR partition table from 960 (64 bytes)
0121   0000             ;  up to 4 partitions, each 16 bytes long
0122   0000             ;  MBR:
0123   0000             ;  Byte | Description
0124   0000             ;  -----|----------------------------
0125   0000             ;  0    | Boot flag (0x80 active, 0x00 inactive)
0126   0000             ;  1-3  | Start CHS (head, sector, cylinder)
0127   0000             ;  4    | Partition type (filesystem ID)
0128   0000             ;    0x83 = Linux native (ext2/3/4)
0129   0000             ;    0x07 = NTFS/exFAT
0130   0000             ;    0x0B = FAT32 CHS
0131   0000             ;    0x0C = FAT32 LBA
0132   0000             ;    0x05 = Extended partition
0133   0000             ;    0x86 = Sol-1 partition
0134   0000             ;  5-7  | End CHS
0135   0000             ;  8-11 | Start LBA (little endian)
0136   0000             ;  12-15| Size in sectors (little endian)
0137   0000             ;  
0138   0000             ;  
0139   0000             ;  the superblock describers the filesystem as a whole such as inode count, free inode count, location of the raw data bitmap, inode table, etc.  
0140   0000             ;  SUPERBLOCK:
0141   0000             ;  | Field               | Description                               | Typical Size (bytes) | Notes                           |
0142   0000             ;  | ------------------- | ----------------------------------------- | -------------------- | ------------------------------- |
0143   0000             ;  | inodes_count        | Total number of inodes in the filesystem  | 2                    | 16-bit unsigned int             |
0144   0000             ;  | blocks_count        | Total number of data blocks               | 2                    | 16-bit unsigned int             |
0145   0000             ;  | free_inodes_count   | Number of free inodes                     | 2                    | 16-bit unsigned int             |
0146   0000             ;  | free_blocks_count   | Number of free blocks                     | 2                    | 16-bit unsigned int             |
0147   0000             ;  | block_bitmap        | Block ID of the **block bitmap**          | 2                    | 16-bit unsigned int
0148   0000             ;  | inode_bitmap        | Block ID of the **inode bitmap**          | 2                    | 16-bit unsigned int
0149   0000             ;  | inode_table         | Starting block of **inode table**         | 2                    | 16-bit unsigned int
0150   0000             ;  | first_data_block    | Block number of the first data block      | 2                    | 16-bit unsigned int             |
0151   0000             ;  | used_dirs_count     | Number of inodes allocated to directories | 2
0152   0000             ;  | log_block_size      | Block size = 1024 << `s_log_block_size    | 2                    | 16-bit unsigned int             |
0153   0000             ;  | mtime               | Last mount time                           | 4                    | 32-bit unsigned int (Unix time) |
0154   0000             ;  | wtime               | Last write time                           | 4                    | 32-bit unsigned int (Unix time) |
0155   0000             ;  | uuid                | Unique ID of the filesystem               | 16                   | 128-bit UUID                    |
0156   0000             ;  | volume_name         | Label of the filesystem                   | 16                   | Usually ASCII, padded           |
0157   0000             ;  | feature_flags       | Compatibility flags                       | 4                    | 32-bit unsigned int             |
0158   0000             ;  
0159   0000             ;  inode for root dir is #2, #0 and #1 not used
0160   0000             ;  raw data block #0 is not used. because 0 as a block ID means not used
0161   0000             ;  block size: 2048
0162   0000             ;  inode-table format:
0163   0000             ;  | Field         | Size (bytes) | Description                                                                                  |
0164   0000             ;  | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0165   0000             ;  | `mode`        | 2            | File type and permissions                                                                    |
0166   0000             ;  | `uid`         | 2            | Owner user ID                                                                                |
0167   0000             ;  | `size`        | 4            | Size of the file in bytes                                                                    |
0168   0000             ;  | `atime`       | 4            | Last access time (timestamp)                                                                 |
0169   0000             ;  | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0170   0000             ;  | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0171   0000             ;  | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0172   0000             ;  | `gid`         | 2            | Group ID                                                                                     |
0173   0000             ;  | `links_count` | 2            | Number of hard links                                                                         |
0174   0000             ;  | `blocks`      | 2            | Number of 2048-byte blocks allocated                                                         |
0175   0000             ;  | `flags`       | 4            | File flags                                                                                   |
0176   0000             ;  | `block`       | 47 * 2 = 94  | Pointers to data blocks (47 direct only) 
0177   0000             ;
0178   0000             ;
0179   0000             ;  DIRECTORY ENTRY
0180   0000             ;  this is the structure for file entries inside a directory.
0181   0000             ;  2048 / 64 = 32 entries
0182   0000             ;
0183   0000             ;  each entry is 64 bytes wide
0184   0000             ;  uint16_t inode;      // Inode number (0 if entry is unused)
0185   0000             ;  char     name[62];   // File name (null terminated)
0186   0000             
0187   0000             ; ------------------------------------------------------------------------------------------------------------------;
0188   0000             ; global system variables
0189   0000             ; ------------------------------------------------------------------------------------------------------------------;
0190   0000             
0191   0000             ; ------------------------------------------------------------------------------------------------------------------;
0192   0000             ; irq table
0193   0000             ; highest priority at lowest address
0194   0000             ; ------------------------------------------------------------------------------------------------------------------;
0195   0000 32 00       .dw int_0_fdc
0196   0002 39 00       .dw int_1
0197   0004 3A 00       .dw int_2
0198   0006 3B 00       .dw int_3
0199   0008 3C 00       .dw int_4
0200   000A 3D 00       .dw int_5_uart1
0201   000C 5F 00       .dw int_6_timer
0202   000E 60 00       .dw int_7_uart0
0203   0010             
0204   0010             ; ------------------------------------------------------------------------------------------------------------------;
0205   0010             ; kernel reset vector
0206   0010             ; ------------------------------------------------------------------------------------------------------------------;
0207   0010 A6 04       .dw kernel_reset_vector
0208   0012             
0209   0012             ; ------------------------------------------------------------------------------------------------------------------;
0210   0012             ; exception vector table
0211   0012             ; total of 7 entries, starting at address $0012
0212   0012             ; ------------------------------------------------------------------------------------------------------------------;
0213   0012 08 01       .dw trap_privilege
0214   0014 CE 01       .dw trap_div_zero
0215   0016 DB 01       .dw trap_undef_opcode
0216   0018 00 00       .dw 0
0217   001A 00 00       .dw 0
0218   001C 00 00       .dw 0
0219   001E 00 00       .dw 0
0220   0020             
0221   0020             ; ------------------------------------------------------------------------------------------------------------------;
0222   0020             ; system call vector table
0223   0020             ; starts at address $0020
0224   0020             ; ------------------------------------------------------------------------------------------------------------------;
0225   0020 13 01       .dw syscall_break
0226   0022 DC 01       .dw syscall_rtc
0227   0024 FF 02       .dw syscall_ide
0228   0026 BF 03       .dw syscall_io
0229   0028 76 04       .dw syscall_file
0230   002A 0E 02       .dw syscall_datetime
0231   002C FC 00       .dw syscall_reboot
0232   002E C8 00       .dw syscall_system
0233   0030 85 00       .dw syscall_fork
0234   0032             
0235   0032             ; ------------------------------------------------------------------------------------------------------------------;
0236   0032             ; system call aliases
0237   0032             ; ------------------------------------------------------------------------------------------------------------------;
0238   0032             sys_break            .equ 0
0239   0032             sys_rtc              .equ 1
0240   0032             sys_ide              .equ 2
0241   0032             sys_io               .equ 3
0242   0032             sys_file             .equ 4
0243   0032             sys_datetime         .equ 5
0244   0032             sys_reboot           .equ 6
0245   0032             sys_system           .equ 7
0246   0032             sys_fork             .equ 8
0247   0032             
0248   0032             ; ------------------------------------------------------------------------------------------------------------------;
0249   0032             ; alias exports
0250   0032             ; ------------------------------------------------------------------------------------------------------------------;
0251   0032             .export text_org
0252   0032             .export sys_break
0253   0032             .export sys_rtc
0254   0032             .export sys_ide
0255   0032             .export sys_io
0256   0032             .export sys_file
0257   0032             .export sys_datetime
0258   0032             .export sys_reboot
0259   0032             .export sys_system
0260   0032             .export sys_fork
0261   0032             
0262   0032             .export _til311_display
0263   0032             
0264   0032             .export _fdc_config        
0265   0032             .export _fdc_status_0      
0266   0032             .export _fdc_stat_cmd     
0267   0032             
0268   0032             ; ------------------------------------------------------------------------------------------------------------------;
0269   0032             ; irqs' code block
0270   0032             ; ------------------------------------------------------------------------------------------------------------------;
0271   0032             ; 5.25" floppy drive controller irq
0272   0032             int_0_fdc:
0273   0032 3B 7F 0E      mov d, s_fdc_irq
0274   0035 07 12 07      call _puts
0275   0038 06            sysret
0276   0039             int_1:
0277   0039 06            sysret
0278   003A             int_2:
0279   003A 06            sysret
0280   003B             int_3:
0281   003B 06            sysret
0282   003C             int_4:
0283   003C 06            sysret
0284   003D             
0285   003D             ; ------------------------------------------------------------------------------------------------------------------;
0286   003D             ; uart1 interrupt
0287   003D             ; ------------------------------------------------------------------------------------------------------------------;
0288   003D             int_5_uart1:
0289   003D D7            push a
0290   003E DA            push d
0291   003F E1            pushf
0292   0040 1D 88 FF      mov al, [_uart1_data]       ; get character
0293   0043               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0294   0043 3B 45 0C      mov d, fifo_in
0295   0046 FD 2A         mov d, [d]
0296   0048 3E            mov [d], al                 ; add to fifo
0297   0049 13            mov a, d
0298   004A 77            inc a
0299   004B AF AB 1F      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0300   004E C7 54 00      jne int_5_continue
0301   0051 10 AB 0F      mov a, fifo  
0302   0054             int_5_continue:  
0303   0054 42 45 0C      mov [fifo_in], a            ; update fifo pointer
0304   0057 1A            mov al, ah
0305   0058 3D B0 FF      mov [_til311_display], al
0306   005B EE            popf
0307   005C E7            pop d
0308   005D E4            pop a  
0309   005E 06            sysret
0310   005F             
0311   005F             ; ------------------------------------------------------------------------------------------------------------------;
0312   005F             ; timer irq
0313   005F             ; ------------------------------------------------------------------------------------------------------------------;
0314   005F             int_6_timer:  
0315   005F 06            sysret
0316   0060             
0317   0060             ; ------------------------------------------------------------------------------------------------------------------;
0318   0060             ; uart0 interrupt
0319   0060             ; ------------------------------------------------------------------------------------------------------------------;
0320   0060             int_7_uart0:
0321   0060 D7            push a
0322   0061 DA            push d
0323   0062 E1            pushf
0324   0063 1D 80 FF      mov al, [_uart0_data]       ; get character
0325   0066               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0326   0066 3B 45 0C      mov d, fifo_in
0327   0069 FD 2A         mov d, [d]
0328   006B 3E            mov [d], al                 ; add to fifo
0329   006C 13            mov a, d
0330   006D 77            inc a
0331   006E AF AB 1F      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0332   0071 C7 77 00      jne int_7_continue
0333   0074 10 AB 0F      mov a, fifo  
0334   0077             int_7_continue:  
0335   0077 42 45 0C      mov [fifo_in], a            ; update fifo pointer
0336   007A 1A            mov al, ah
0337   007B 3D B0 FF      mov [_til311_display], al
0338   007E EE            popf
0339   007F E7            pop d
0340   0080 E4            pop a  
0341   0081 06            sysret
0342   0082             
0343   0082             sys_mkfs:
0344   0082 06            sysret
0345   0083             
0346   0083             ; ------------------------------------------------------------------------------------------------------------------;
0347   0083             ; process syscalls
0348   0083             ; ------------------------------------------------------------------------------------------------------------------;
0349   0083             ; look for empty process slot
0350   0083             ; initialize new process
0351   0083             ; copy old process kernel table entries
0352   0083             ; copy old process image into new one
0353   0083             fork_jmptbl:
0354   0083 89 00         .dw fork
0355   0085             syscall_fork:
0356   0085 FD 0A 83 00   jmp [fork_jmptbl + al]
0357   0089             
0358   0089             fork:
0359   0089 10 19 0F      mov a, curr_pid
0360   008C FD 9D 07      shl a, 7          ; mul by 128
0361   008F 53 2B 0F      add a, proc_table
0362   0092 4D            mov si, a
0363   0093 07 A5 00      call find_empty_proc_slot  ; result proc address in a
0364   0096 4F            mov di, a
0365   0097 38 80 00      mov c, 128
0366   009A FD F5         rep movsb  ; copy proc structure from old to new
0367   009C             
0368   009C 3C            mov d, a  ; new process entry base
0369   009D FD 3E         mov [d], bl   ; set new PID
0370   009F             
0371   009F 19 01         mov al, proc_runnable
0372   00A1 3F 01 00      mov [d + 1], al               ; set process as runnable
0373   00A4             
0374   00A4               ; now copy entire memory of old process into new process' memory
0375   00A4 06            sysret
0376   00A5             
0377   00A5             ; pid, state, fd_table, tty pointer, context (general regs + flags), 39 bytes padding to reach 128
0378   00A5             ; return index in b
0379   00A5             ; address in a
0380   00A5             find_empty_proc_slot:
0381   00A5 3B 2B 0F      mov d, proc_table
0382   00A8 26 00 00      mov b, 0
0383   00AB             find_empty_proc_slot_l0:
0384   00AB 1E            mov al, [d]
0385   00AC B9 00         cmp al, 0
0386   00AE C6 BC 00      je find_empty_proc_slot_ret
0387   00B1 58 80 00      add d, 128
0388   00B4 FD 77         inc b
0389   00B6 C0 80 00      cmp b, _max_user_proc  ; if we go past _max_user_proc (128) that is considered an error
0390   00B9 C7 AB 00      jne find_empty_proc_slot_l0
0391   00BC             find_empty_proc_slot_ret:
0392   00BC 13            mov a, d
0393   00BD 09            ret  ; return in 'bl'
0394   00BE             
0395   00BE             ; ------------------------------------------------------------------------------------------------------------------;
0396   00BE             ; system syscalls
0397   00BE             ; ------------------------------------------------------------------------------------------------------------------;
0398   00BE             system_jmptbl:
0399   00BE F4 00         .dw system_uname
0400   00C0 FB 00         .dw system_whoami
0401   00C2 CE 00         .dw system_poke
0402   00C4 D1 00         .dw system_bootloader_install
0403   00C6 CC 00         .dw system_peek
0404   00C8             syscall_system:
0405   00C8 FD 0A BE 00   jmp [system_jmptbl + al]
0406   00CC             
0407   00CC             ; param register address in register d
0408   00CC             ; param value in register bl
0409   00CC             system_peek:
0410   00CC 32            mov bl, [d]
0411   00CD 06            sysret
0412   00CE             
0413   00CE             ; param register address in register d
0414   00CE             ; param value in register bl
0415   00CE             system_poke:
0416   00CE FD 3E         mov [d], bl
0417   00D0 06            sysret
0418   00D1             
0419   00D1             ; kernel LBA address in 'b'
0420   00D1             system_bootloader_install:
0421   00D1 D8            push b
0422   00D2 26 00 00      mov b, 0
0423   00D5 38 00 00      mov c, 0
0424   00D8 22 01         mov ah, $01                 ; 1 sector
0425   00DA 3B AB 21      mov d, transient_area
0426   00DD 07 2E 03      call ide_read_sect          ; read sector
0427   00E0 E5            pop b
0428   00E1 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0429   00E5 26 00 00      mov b, 0
0430   00E8 38 00 00      mov c, 0
0431   00EB 22 01         mov ah, $01                 ; 1 sector
0432   00ED 3B AB 21      mov d, transient_area
0433   00F0 07 54 03      call ide_write_sect         ; write sector
0434   00F3 06            sysret
0435   00F4             
0436   00F4             system_uname:
0437   00F4 3B 54 0C      mov d, s_uname
0438   00F7 07 12 07      call _puts
0439   00FA 06            sysret
0440   00FB             
0441   00FB             system_whoami:
0442   00FB 06            sysret
0443   00FC             
0444   00FC             ; reboot system
0445   00FC             syscall_reboot:
0446   00FC FD D7 FF FF   push word $ffff 
0447   0100 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0448   0103 FD D7 90 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0449   0107 06            sysret
0450   0108             
0451   0108             
0452   0108             ; ------------------------------------------------------------------------------------------------------------------;
0453   0108             ; exceptions code block
0454   0108             ; ------------------------------------------------------------------------------------------------------------------;
0455   0108             ; privilege exception
0456   0108             ; ------------------------------------------------------------------------------------------------------------------;
0457   0108             trap_privilege:
0458   0108 DA            push d
0459   0109 3B 6C 0D      mov d, s_priviledge
0460   010C 07 12 07      call _puts
0461   010F E7            pop d
0462   0110 0A FC 00      jmp syscall_reboot
0463   0113             
0464   0113             ; ------------------------------------------------------------------------------------------------------------------;
0465   0113             ; breakpoint
0466   0113             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0467   0113             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0468   0113             ; ------------------------------------------------------------------------------------------------------------------;
0469   0113             syscall_break:
0470   0113 4B            pusha
0471   0114             syscall_break_prompt:
0472   0114 3B 9E 0D      mov d, s_break1
0473   0117 07 12 07      call _puts
0474   011A 07 BF 06      call printnl
0475   011D 07 14 08      call scan_u16d
0476   0120 AF 00 00      cmp a, 0
0477   0123 C6 2E 01      je syscall_break_regs
0478   0126 AF 01 00      cmp a, 1
0479   0129 C6 51 01      je syscall_break_mem
0480   012C             syscall_break_end:  
0481   012C 4C            popa
0482   012D 06            sysret
0483   012E             syscall_break_regs:
0484   012E 48            mov a, sp
0485   012F 53 0E 00      add a, 14               ; back-track 7 registers
0486   0132 3C            mov d, a
0487   0133 3A 07         mov cl, 7
0488   0135             syscall_regs_l0:
0489   0135 2A            mov b, [d]
0490   0136 FD AB         swp b
0491   0138 07 6E 07      call print_u16x         ; print register value
0492   013B 07 BF 06      call printnl
0493   013E 63 02 00      sub d, 2
0494   0141 71 01         sub cl, 1
0495   0143 C3 00         cmp cl, 0
0496   0145 C7 35 01      jne syscall_regs_l0
0497   0148 0A 14 01      jmp syscall_break_prompt
0498   014B 07 BF 06      call printnl
0499   014E 0A 14 01      jmp syscall_break_prompt
0500   0151             syscall_break_mem:
0501   0151 07 BF 06      call printnl
0502   0154 07 90 07      call scan_u16x
0503   0157 4D            mov si, a               ; data source from user space
0504   0158 FD 4F AB 1F   mov di, scrap_sector    ; destination in kernel space
0505   015C 38 00 02      mov c, 512
0506   015F 04            load                    ; transfer data to kernel space!
0507   0160 3B AB 1F      mov d, scrap_sector     ; dump pointer in d
0508   0163 38 00 00      mov c, 0
0509   0166             dump_loop:
0510   0166 84            mov al, cl
0511   0167 87 0F         and al, $0f
0512   0169 C6 B7 01      jz print_base
0513   016C             back:
0514   016C 1E            mov al, [d]             ; read byte
0515   016D 2F            mov bl, al
0516   016E 07 B2 07      call print_u8x
0517   0171 10 00 20      mov a, $2000
0518   0174 05 03         syscall sys_io          ; space
0519   0176 84            mov al, cl
0520   0177 87 0F         and al, $0f
0521   0179 B9 0F         cmp al, $0f
0522   017B C6 8C 01      je print_ascii
0523   017E             back1:
0524   017E 79            inc d
0525   017F 78            inc c
0526   0180 C2 00 02      cmp c, 512
0527   0183 C7 66 01      jne dump_loop
0528   0186 07 BF 06      call printnl
0529   0189 0A 14 01      jmp syscall_break_prompt  ; go to syscall_break return point
0530   018C             print_ascii:
0531   018C 10 00 20      mov a, $2000
0532   018F 05 03         syscall sys_io
0533   0191 63 10 00      sub d, 16
0534   0194 26 10 00      mov b, 16
0535   0197             print_ascii_l:
0536   0197 79            inc d
0537   0198 1E            mov al, [d]               ; read byte
0538   0199 B9 20         cmp al, $20
0539   019B C8 A3 01      jlu dot
0540   019E B9 7E         cmp al, $7e
0541   01A0 D0 AB 01      jleu ascii
0542   01A3             dot:
0543   01A3 10 00 2E      mov a, $2e00
0544   01A6 05 03         syscall sys_io
0545   01A8 0A B0 01      jmp ascii_continue
0546   01AB             ascii:
0547   01AB 23            mov ah, al
0548   01AC 19 00         mov al, 0
0549   01AE 05 03         syscall sys_io
0550   01B0             ascii_continue:
0551   01B0 FD A9 97 01   loopb print_ascii_l
0552   01B4 0A 7E 01      jmp back1
0553   01B7             print_base:
0554   01B7 07 BF 06      call printnl
0555   01BA 2D            mov b, d
0556   01BB 61 AB 1F      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0557   01BE 07 6E 07      call print_u16x          ; display row
0558   01C1 10 00 3A      mov a, $3a00
0559   01C4 05 03         syscall sys_io
0560   01C6 10 00 20      mov a, $2000
0561   01C9 05 03         syscall sys_io
0562   01CB 0A 6C 01      jmp back
0563   01CE             
0564   01CE             ; ------------------------------------------------------------------------------------------------------------------;
0565   01CE             ; divide by zero exception
0566   01CE             ; ------------------------------------------------------------------------------------------------------------------;
0567   01CE             trap_div_zero:
0568   01CE D7            push a
0569   01CF DA            push d
0570   01D0 E1            pushf
0571   01D1 3B 83 0D      mov d, s_divzero
0572   01D4 07 12 07      call _puts
0573   01D7 EE            popf
0574   01D8 E7            pop d
0575   01D9 E4            pop a
0576   01DA 06            sysret ; enable interrupts
0577   01DB             
0578   01DB             ; ------------------------------------------------------------------------------------------------------------------;
0579   01DB             ; undefined opcode exception
0580   01DB             ; ------------------------------------------------------------------------------------------------------------------;
0581   01DB             trap_undef_opcode:
0582   01DB 06            sysret
0583   01DC             
0584   01DC             ; ------------------------------------------------------------------------------------------------------------------;
0585   01DC             ; real-time clock services syscall
0586   01DC             ; rtc i/o bank = ffa0 to ffaf
0587   01DC             ; ffa0 to ffa7 is scratch ram
0588   01DC             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0589   01DC             ; al = 0..6 -> get
0590   01DC             ; al = 7..d -> set
0591   01DC             ; ------------------------------------------------------------------------------------------------------------------;
0592   01DC             syscall_rtc:
0593   01DC DB            push al
0594   01DD DA            push d
0595   01DE B9 06         cmp al, 6
0596   01E0 D1 F5 01      jgu syscall_rtc_set
0597   01E3             syscall_rtc_get:
0598   01E3 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0599   01E5 22 FF         mov ah, $ff    
0600   01E7 3C            mov d, a                ; get to ffa9 + offset
0601   01E8 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0602   01EC 1E            mov al, [d]             ; get data
0603   01ED F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0604   01F1 23            mov ah, al
0605   01F2 E7            pop d
0606   01F3 E8            pop al
0607   01F4 06            sysret
0608   01F5             syscall_rtc_set:
0609   01F5 DD            push bl
0610   01F6 99            mov bl, ah              ; set data aside
0611   01F7 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0612   01F9 22 FF         mov ah, $ff    
0613   01FB 3C            mov d, a                ; get to ffa9 + offset
0614   01FC 1B            mov al, bl              ; get data back
0615   01FD F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0616   0201 3E            mov [d], al             ; set data
0617   0202 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0618   0206 EA            pop bl
0619   0207 E7            pop d
0620   0208 E8            pop al
0621   0209 06            sysret
0622   020A             
0623   020A             datetime_serv_tbl:
0624   020A 12 02         .dw print_date
0625   020C 86 02         .dw set_date
0626   020E             syscall_datetime:
0627   020E FD 0A 0A 02   jmp [datetime_serv_tbl + al]      
0628   0212             print_date:
0629   0212 10 00 0D      mov a, $0d00           ; print carriage return char
0630   0215 19 03         mov al, 3
0631   0217 05 01         syscall sys_rtc        ; get week
0632   0219 1A            mov al, ah
0633   021A 22 00         mov ah, 0
0634   021C FD 9D 02      shl a, 2          
0635   021F 3B 63 0E      mov d, s_week
0636   0222 59            add d, a
0637   0223 07 12 07      call _puts
0638   0226 10 00 20      mov a, $2000
0639   0229 05 03         syscall sys_io         ; display ' '
0640   022B 19 04         mov al, 4
0641   022D 05 01         syscall sys_rtc        ; get day
0642   022F 99            mov bl, ah
0643   0230 07 B2 07      call print_u8x
0644   0233 10 00 20      mov a, $2000
0645   0236 05 03         syscall sys_io         ; display ' '
0646   0238             ; there is a problem with the month displaying
0647   0238             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0648   0238             ; even though it is to be understood as bcd.
0649   0238             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0650   0238 19 05         mov al, 05
0651   023A 05 01         syscall sys_rtc        ; get month
0652   023C 1A            mov al, ah
0653   023D 22 00         mov ah, 0
0654   023F FD 9D 02      shl a, 2          
0655   0242 3B 2F 0E      mov d, s_months
0656   0245 59            add d, a
0657   0246 07 12 07      call _puts
0658   0249 10 00 20      mov a, $2000
0659   024C 05 03         syscall sys_io         ; display ' '
0660   024E 2E 20         mov bl, $20
0661   0250 07 B2 07      call print_u8x         ; print 20 for year prefix
0662   0253 19 06         mov al, 06
0663   0255 05 01         syscall sys_rtc        ; get year
0664   0257 99            mov bl, ah
0665   0258 07 B2 07      call print_u8x
0666   025B 10 00 20      mov a, $2000  
0667   025E 05 03         syscall sys_io         ; display ' '
0668   0260 19 02         mov al, 2
0669   0262 05 01         syscall sys_rtc        ; get hours
0670   0264 99            mov bl, ah
0671   0265 07 B2 07      call print_u8x
0672   0268 10 00 3A      mov a, $3a00    
0673   026B 05 03         syscall sys_io         ; display ':'
0674   026D 19 01         mov al, 01
0675   026F 05 01         syscall sys_rtc        ; get minutes
0676   0271 99            mov bl, ah
0677   0272 07 B2 07      call print_u8x
0678   0275 10 00 3A      mov a, $3a00  
0679   0278 05 03         syscall sys_io         ; display ':'
0680   027A 19 00         mov al, 0
0681   027C 05 01         syscall sys_rtc        ; get seconds
0682   027E 99            mov bl, ah
0683   027F 07 B2 07      call print_u8x
0684   0282 07 BF 06      call printnl
0685   0285 06            sysret
0686   0286             set_date:
0687   0286 3B F4 0D      mov d, s_set_year
0688   0289 07 12 07      call _puts
0689   028C 07 FD 07      call scan_u8x          ; read integer into a
0690   028F FD 9D 08      shl a, 8               ; only al used, move to ah
0691   0292 19 0D         mov al, 0dh            ; set rtc year
0692   0294 05 01         syscall sys_rtc        ; set rtc
0693   0296 3B FB 0D      mov d, s_set_month
0694   0299 07 12 07      call _puts
0695   029C 07 FD 07      call scan_u8x          ; read integer into a
0696   029F FD 9D 08      shl a, 8               ; only al used, move to ah
0697   02A2 19 0C         mov al, 0ch            ; set rtc month
0698   02A4 05 01         syscall sys_rtc        ; set rtc
0699   02A6 3B 03 0E      mov d, s_set_day
0700   02A9 07 12 07      call _puts
0701   02AC 07 FD 07      call scan_u8x          ; read integer into a
0702   02AF FD 9D 08      shl a, 8               ; only al used, move to ah
0703   02B2 19 0B         mov al, 0bh            ; set rtc month
0704   02B4 05 01         syscall sys_rtc        ; set rtc
0705   02B6 3B 09 0E      mov d, s_set_week
0706   02B9 07 12 07      call _puts
0707   02BC 07 FD 07      call scan_u8x          ; read integer into a
0708   02BF FD 9D 08      shl a, 8               ; only al used, move to ah
0709   02C2 19 0A         mov al, 0ah            ; set rtc month
0710   02C4 05 01         syscall sys_rtc        ; set rtc
0711   02C6 3B 13 0E      mov d, s_set_hours
0712   02C9 07 12 07      call _puts
0713   02CC 07 FD 07      call scan_u8x          ; read integer into a
0714   02CF FD 9D 08      shl a, 8               ; only al used, move to ah
0715   02D2 19 09         mov al, 09h            ; set rtc month
0716   02D4 05 01         syscall sys_rtc        ; set rtc
0717   02D6 3B 1B 0E      mov d, s_set_minutes
0718   02D9 07 12 07      call _puts
0719   02DC 07 FD 07      call scan_u8x          ; read integer into a
0720   02DF FD 9D 08      shl a, 8               ; only al used, move to ah
0721   02E2 19 08         mov al, 08h            ; set rtc month
0722   02E4 05 01         syscall sys_rtc        ; set rtc
0723   02E6 3B 25 0E      mov d, s_set_seconds
0724   02E9 07 12 07      call _puts
0725   02EC 07 FD 07      call scan_u8x          ; read integer into a
0726   02EF FD 9D 08      shl a, 8               ; only al used, move to ah
0727   02F2 19 07         mov al, 07h            ; set rtc month
0728   02F4 05 01         syscall sys_rtc        ; set rtc
0729   02F6 06            sysret
0730   02F7             
0731   02F7             ; ------------------------------------------------------------------------------------------------------------------;
0732   02F7             ; ide services syscall
0733   02F7             ; al = option
0734   02F7             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0735   02F7             ; ide read/write sector
0736   02F7             ; 512 bytes
0737   02F7             ; user buffer pointer in d
0738   02F7             ; ah = number of sectors
0739   02F7             ; cb = lba bytes 3..0
0740   02F7             ; ------------------------------------------------------------------------------------------------------------------;
0741   02F7             ide_serv_tbl:
0742   02F7 03 03         .dw ide_reset
0743   02F9 17 03         .dw ide_sleep
0744   02FB 26 03         .dw ide_read_sect_wrapper
0745   02FD 2A 03         .dw ide_write_sect_wrapper
0746   02FF             syscall_ide:
0747   02FF FD 0A F7 02   jmp [ide_serv_tbl + al]    
0748   0303             
0749   0303             ide_reset:      
0750   0303 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
0751   0307 07 B0 03      call ide_wait                   ; wait for ide ready             
0752   030A F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
0753   030E F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
0754   0312 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
0755   0316 06            sysret
0756   0317             ide_sleep:
0757   0317 07 B0 03      call ide_wait                   ; wait for ide ready             
0758   031A F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
0759   031E F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
0760   0322 07 B0 03      call ide_wait                   ; wait for ide ready
0761   0325 06            sysret
0762   0326             ide_read_sect_wrapper:
0763   0326 07 2E 03      call ide_read_sect
0764   0329 06            sysret
0765   032A             ide_write_sect_wrapper:
0766   032A 07 54 03      call ide_write_sect
0767   032D 06            sysret
0768   032E             ide_read_sect:
0769   032E 1A            mov al, ah
0770   032F 24            mov ah, bl
0771   0330 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0772   0333 1C            mov al, bh
0773   0334 3D D4 FF      mov [_ide_r4], al
0774   0337 12            mov a, c
0775   0338 3D D5 FF      mov [_ide_r5], al
0776   033B 1A            mov al, ah
0777   033C 87 0F         and al, %00001111
0778   033E 8B E0         or al, %11100000                ; mode lba, master
0779   0340 3D D6 FF      mov [_ide_r6], al
0780   0343             ide_read_sect_wait:
0781   0343 1D D7 FF      mov al, [_ide_r7]  
0782   0346 87 80         and al, $80                     ; busy flag
0783   0348 C7 43 03      jnz ide_read_sect_wait
0784   034B 19 20         mov al, $20
0785   034D 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
0786   0350 07 7A 03      call ide_read  
0787   0353 09            ret
0788   0354             ide_write_sect:
0789   0354 1A            mov al, ah
0790   0355 24            mov ah, bl
0791   0356 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0792   0359 1C            mov al, bh
0793   035A 3D D4 FF      mov [_ide_r4], al
0794   035D 12            mov a, c
0795   035E 3D D5 FF      mov [_ide_r5], al
0796   0361 1A            mov al, ah
0797   0362 87 0F         and al, %00001111
0798   0364 8B E0         or al, %11100000                ; mode lba, master
0799   0366 3D D6 FF      mov [_ide_r6], al
0800   0369             ide_write_sect_wait:
0801   0369 1D D7 FF      mov al, [_ide_r7]  
0802   036C 87 80         and al, $80                     ; busy flag
0803   036E C7 69 03      jnz ide_write_sect_wait
0804   0371 19 30         mov al, $30
0805   0373 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
0806   0376 07 95 03      call ide_write      
0807   0379 09            ret
0808   037A             
0809   037A             ;----------------------------------------------------------------------------------------------------;
0810   037A             ; read ide data
0811   037A             ; pointer in d
0812   037A             ;----------------------------------------------------------------------------------------------------;
0813   037A             ide_read:
0814   037A DA            push d
0815   037B             ide_read_loop:
0816   037B 1D D7 FF      mov al, [_ide_r7]  
0817   037E 87 80         and al, 80h                     ; busy flag
0818   0380 C7 7B 03      jnz ide_read_loop               ; wait loop
0819   0383 1D D7 FF      mov al, [_ide_r7]
0820   0386 87 08         and al, %00001000               ; drq flag
0821   0388 C6 93 03      jz ide_read_end
0822   038B 1D D0 FF      mov al, [_ide_r0]
0823   038E 3E            mov [d], al
0824   038F 79            inc d
0825   0390 0A 7B 03      jmp ide_read_loop
0826   0393             ide_read_end:
0827   0393 E7            pop d
0828   0394 09            ret
0829   0395             
0830   0395             ;----------------------------------------------------------------------------------------------------;
0831   0395             ; write ide data
0832   0395             ; data pointer in d
0833   0395             ;----------------------------------------------------------------------------------------------------;
0834   0395             ide_write:
0835   0395 DA            push d
0836   0396             ide_write_loop:
0837   0396 1D D7 FF      mov al, [_ide_r7]  
0838   0399 87 80         and al, 80h             ; busy flag
0839   039B C7 96 03      jnz ide_write_loop      ; wait loop
0840   039E 1D D7 FF      mov al, [_ide_r7]
0841   03A1 87 08         and al, %00001000       ; drq flag
0842   03A3 C6 AE 03      jz ide_write_end
0843   03A6 1E            mov al, [d]
0844   03A7 3D D0 FF      mov [_ide_r0], al
0845   03AA 79            inc d 
0846   03AB 0A 96 03      jmp ide_write_loop
0847   03AE             ide_write_end:
0848   03AE E7            pop d
0849   03AF 09            ret
0850   03B0             
0851   03B0             ;----------------------------------------------------------------------------------------------------;
0852   03B0             ; wait for ide to be ready
0853   03B0             ;----------------------------------------------------------------------------------------------------;
0854   03B0             ide_wait:
0855   03B0 1D D7 FF      mov al, [_ide_r7]  
0856   03B3 87 80         and al, 80h        ; busy flag
0857   03B5 C7 B0 03      jnz ide_wait
0858   03B8 09            ret
0859   03B9             
0860   03B9             ;----------------------------------------------------------------------------------------------------;
0861   03B9             ; io syscall
0862   03B9             ;----------------------------------------------------------------------------------------------------;
0863   03B9             ; baud  divisor
0864   03B9             ; 50    2304
0865   03B9             ; 110   1047
0866   03B9             ; 300    384
0867   03B9             ; 600    192
0868   03B9             ; 1200    96
0869   03B9             ; 9600    12
0870   03B9             ; 19200    6
0871   03B9             ; 38400    3
0872   03B9             syscall_io_jmp:
0873   03B9 14 04         .dw syscall_io_putchar
0874   03BB 2D 04         .dw syscall_io_getch
0875   03BD C3 03         .dw syscall_io_uart_setup
0876   03BF             syscall_io:
0877   03BF FD 0A B9 03   jmp [syscall_io_jmp + al]
0878   03C3             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
0879   03C3             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
0880   03C3             ; buffer, the transmitter holding register, or the interrupt enable register.
0881   03C3             syscall_io_uart_setup:
0882   03C3 1D 3B 0C      mov al, [sys_uart0_lcr]
0883   03C6 8B 80         or al, $80                ; set dlab access bit
0884   03C8 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, even parity 
0885   03CB 1D 3E 0C      mov al, [sys_uart0_div0]
0886   03CE 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
0887   03D1 1D 3F 0C      mov al, [sys_uart0_div1]
0888   03D4 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
0889   03D7 1D 3B 0C      mov al, [sys_uart0_lcr]
0890   03DA 87 7F         and al, $7f               ; clear dlab access bit 
0891   03DC 3D 83 FF      mov [_uart0_lcr], al
0892   03DF 1D 3C 0C      mov al, [sys_uart0_inten]
0893   03E2 3D 81 FF      mov [_uart0_ier], al      ; interrupts
0894   03E5 1D 3D 0C      mov al, [sys_uart0_fifoen]
0895   03E8 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
0896   03EB             
0897   03EB             ; uart1:
0898   03EB 1D 40 0C      mov al, [sys_uart1_lcr]
0899   03EE 8B 80         or al, $80                ; set dlab access bit
0900   03F0 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, even parity 
0901   03F3 1D 43 0C      mov al, [sys_uart1_div0]
0902   03F6 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
0903   03F9 1D 44 0C      mov al, [sys_uart1_div1]
0904   03FC 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
0905   03FF 1D 40 0C      mov al, [sys_uart1_lcr]
0906   0402 87 7F         and al, $7f               ; clear dlab access bit 
0907   0404 3D 8B FF      mov [_uart1_lcr], al
0908   0407 1D 41 0C      mov al, [sys_uart1_inten]
0909   040A 3D 89 FF      mov [_uart1_ier], al      ; interrupts
0910   040D 1D 42 0C      mov al, [sys_uart1_fifoen]
0911   0410 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
0912   0413 06            sysret
0913   0414             
0914   0414             ; char in ah
0915   0414             syscall_io_putchar:
0916   0414             syscall_io_putchar_l0:
0917   0414 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0918   0417 93 20         test al, $20
0919   0419 C6 14 04      jz syscall_io_putchar_l0    
0920   041C 1A            mov al, ah
0921   041D 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0922   0420             ; uart1
0923   0420             syscall_io_putchar_l1:
0924   0420 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0925   0423 93 20         test al, $20
0926   0425 C6 20 04      jz syscall_io_putchar_l1    
0927   0428 1A            mov al, ah
0928   0429 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0929   042C 06            sysret
0930   042D             
0931   042D             ; char in ah
0932   042D             ; al = sucess code
0933   042D             syscall_io_getch:
0934   042D D8            push b
0935   042E DA            push d
0936   042F FD 0C         sti
0937   0431             syscall_io_getch_l0:  
0938   0431 14 47 0C      mov a, [fifo_out]
0939   0434 29 45 0C      mov b, [fifo_in]
0940   0437 B0            cmp a, b
0941   0438 C6 31 04      je syscall_io_getch_l0
0942   043B 3C            mov d, a
0943   043C 77            inc a
0944   043D AF AB 1F      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
0945   0440 C7 46 04      jne syscall_io_getch_cont
0946   0443 10 AB 0F      mov a, fifo  
0947   0446             syscall_io_getch_cont:  
0948   0446 42 47 0C      mov [fifo_out], a             ; update fifo pointer
0949   0449 1E            mov al, [d]                   ; get char
0950   044A 23            mov ah, al
0951   044B             ; here we just echo the char back to the console
0952   044B             syscall_io_getch_echo_l0:
0953   044B 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0954   044E 87 20         and al, $20                 ; isolate transmitter empty
0955   0450 C6 4B 04      jz syscall_io_getch_echo_l0
0956   0453 1A            mov al, ah
0957   0454 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0958   0457             syscall_io_getch_echo_l1:
0959   0457 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0960   045A 87 20         and al, $20                 ; isolate transmitter empty
0961   045C C6 57 04      jz syscall_io_getch_echo_l1
0962   045F 1A            mov al, ah
0963   0460 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0964   0463             syscall_io_getch_noecho:
0965   0463 19 01         mov al, 1                    ; al = 1 means a char successfully received
0966   0465 E7            pop d
0967   0466 E5            pop b
0968   0467 06            sysret
0969   0468             
0970   0468             ;------------------------------------------------------------------------------------------------------;
0971   0468             ; file system data
0972   0468             ;------------------------------------------------------------------------------------------------------;
0973   0468             ; infor for : ide services interrupt
0974   0468             ; ide read/write 512-byte sector
0975   0468             ; al = option
0976   0468             ; user buffer pointer in d
0977   0468             ; ah = number of sectors
0978   0468             ; cb = lba bytes 3..0  
0979   0468             ;------------------------------------------------------------------------------------------------------;
0980   0468             ; file system data structure
0981   0468             ;------------------------------------------------------------------------------------------------------;
0982   0468             ; first directory on disk is the root directory '/'
0983   0468             file_system_jmptbl:
0984   0468 7B 04         .dw fs_cd                     
0985   046A 7C 04         .dw fs_ls                     
0986   046C 7D 04         .dw fs_pwd                    
0987   046E 7E 04         .dw fs_rmdir                  
0988   0470 7A 04         .dw fs_mkdir
0989   0472 7F 04         .dw fs_rm                     
0990   0474 80 04         .dw fs_mv                     
0991   0476             
0992   0476             syscall_file:
0993   0476 FD 0A 68 04   jmp [file_system_jmptbl + al]
0994   047A             
0995   047A             ;------------------------------------------------------------------------------------------------------;
0996   047A             ; create new directory
0997   047A             ;------------------------------------------------------------------------------------------------------;
0998   047A             ; search list for null name entry. add new directory to list
0999   047A             fs_mkdir:
1000   047A 06            sysret
1001   047B             
1002   047B             ;------------------------------------------------------------------------------------------------------;
1003   047B             ; cd
1004   047B             ;------------------------------------------------------------------------------------------------------;
1005   047B             fs_cd:
1006   047B 06            sysret  
1007   047C             
1008   047C             ;------------------------------------------------------------------------------------------------------;
1009   047C             ; ls
1010   047C             ;------------------------------------------------------------------------------------------------------;
1011   047C             ; inode in a
1012   047C             fs_ls:
1013   047C             
1014   047C 06            sysret
1015   047D             
1016   047D             ;------------------------------------------------------------------------------------------------------;
1017   047D             ; pwd - print working directory
1018   047D             ;------------------------------------------------------------------------------------------------------;    
1019   047D             fs_pwd:
1020   047D 06            sysret
1021   047E             
1022   047E             ;------------------------------------------------------------------------------------------------------;
1023   047E             ; rmdir - remove dir by dirid
1024   047E             ;------------------------------------------------------------------------------------------------------;
1025   047E             fs_rmdir:
1026   047E 06            sysret
1027   047F             
1028   047F             ;------------------------------------------------------------------------------------------------------;
1029   047F             ; rm - remove file
1030   047F             ;------------------------------------------------------------------------------------------------------;
1031   047F             fs_rm:
1032   047F 06            sysret  
1033   0480             
1034   0480             ;------------------------------------------------------------------------------------------------------;
1035   0480             ; mv - move / change file name
1036   0480             ;------------------------------------------------------------------------------------------------------;
1037   0480             fs_mv:
1038   0480 06            sysret
1039   0481             
1040   0481             
1041   0481             ;----------------------------------------------------------------------------------------------;
1042   0481             ; get hex file
1043   0481             ; di = destination address
1044   0481             ; return length in bytes in c
1045   0481             ;----------------------------------------------------------------------------------------------;
1046   0481             _load_hex:
1047   0481 D7            push a
1048   0482 D8            push b
1049   0483 DA            push d
1050   0484 E2            push si
1051   0485 E3            push di
1052   0486 38 00 00      mov c, 0
1053   0489 50            mov a, di
1054   048A 3C            mov d, a          ; start of string data block
1055   048B 07 ED 05      call _gets        ; get program string
1056   048E 4D            mov si, a
1057   048F             __load_hex_loop:
1058   048F F6            lodsb             ; load from [si] to al
1059   0490 B9 00         cmp al, 0         ; check if ascii 0
1060   0492 C6 A0 04      jz __load_hex_ret
1061   0495 36            mov bh, al
1062   0496 F6            lodsb
1063   0497 2F            mov bl, al
1064   0498 07 A3 05      call _atoi        ; convert ascii byte in b to int (to al)
1065   049B F7            stosb             ; store al to [di]
1066   049C 78            inc c
1067   049D 0A 8F 04      jmp __load_hex_loop
1068   04A0             __load_hex_ret:
1069   04A0 F0            pop di
1070   04A1 EF            pop si
1071   04A2 E7            pop d
1072   04A3 E5            pop b
1073   04A4 E4            pop a
1074   04A5 09            ret
1075   04A6             
1076   04A6             ; ---------------------------------------------------------------------
1077   04A6             ; kernel reset vector
1078   04A6             ; ---------------------------------------------------------------------
1079   04A6             kernel_reset_vector:  
1080   04A6 FD 49 FF F7   mov bp, _stack_top
1081   04AA FD 47 FF F7   mov sp, _stack_top
1082   04AE               
1083   04AE 0C            lodstat
1084   04AF 87 DF         and al, %11011111             ; disable display register loading
1085   04B1 0D            stostat
1086   04B2             
1087   04B2             ; reset fifo pointers
1088   04B2 10 AB 0F      mov a, fifo
1089   04B5 3B 45 0C      mov d, fifo_in
1090   04B8 43            mov [d], a
1091   04B9 3B 47 0C      mov d, fifo_out
1092   04BC 43            mov [d], a  
1093   04BD 19 02         mov al, 2
1094   04BF 05 03         syscall sys_io                ; enable uart in interrupt mode
1095   04C1             
1096   04C1 19 A0         mov al, %10100000             ; uart0 | timer | uart1 | 0 | 0 | 0 | 0| fdc
1097   04C3 FD 0F         stomsk                        
1098   04C5 FD 0C         sti  
1099   04C7             
1100   04C7 3B 98 0C      mov d, s_kernel_welcome
1101   04CA 07 12 07      call _puts
1102   04CD             
1103   04CD 3B 90 0E      mov d, s_fdc_config
1104   04D0 07 12 07      call _puts
1105   04D3             
1106   04D3 F2 C0 FF 0D   mov byte [_fdc_config], %00001101   ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
1107   04D7 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011 ; leave this restore command in order to clear BUSY flag
1108   04DB F2 C9 FF 00   mov byte [_fdc_track], $00          ; reset track
1109   04DF             
1110   04DF             
1111   04DF 3B FB 0E      mov d, s_reset_proc_tbl 
1112   04E2 07 12 07      call _puts
1113   04E5 3B 2B 0F      mov d, proc_table
1114   04E8 19 00         mov al, 0
1115   04EA             reset_proc_table_l0:
1116   04EA 3E            mov [d], al
1117   04EB 58 80 00      add d, 128
1118   04EE C5 2B 4F      cmp d, proc_table + 16384
1119   04F1 C7 EA 04      jne reset_proc_table_l0
1120   04F4             
1121   04F4             
1122   04F4 10 00 00      mov a, 0
1123   04F7             ker_loop:
1124   04F7 77            inc a
1125   04F8 3D B0 FF      mov [_til311_display], al
1126   04FB 0A F7 04      jmp ker_loop
1127   04FE             
1128   04FE             
1129   04FE             ; file includes
1130   04FE             .include "lib/bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  04FE             boot_origin      .EQU  $8004
0002+  04FE             bios_uart        .EQU  $0002
0003+  04FE             bios_ide         .EQU  $0003
0004+  04FE             bios_reset_vector .EQU  $0190
0005+  04FE             ide_buffer       .EQU  $8404
0006+  04FE             inode_buffer     .EQU  $8c04
0007+  04FE             noname.__print_u16x .EQU  $01f6
0008+  04FE             noname.__xput_u8 .EQU  $023e
0009+  04FE             noname.__puts    .EQU  $0252
0010+  04FE             noname.__print_u16d .EQU  $0379
1131   04FE             .include "lib/stdio.asm"
0001+  04FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04FE             ; stdio.s
0003+  04FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04FE             .include "lib/string.asm"
0001++ 04FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04FE             ; string.s
0003++ 04FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04FE             
0005++ 04FE             
0006++ 04FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04FE             ; _strrev
0008++ 04FE             ; reverse a string
0009++ 04FE             ; d = string address
0010++ 04FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04FE             ; 01234
0012++ 04FE             _strrev:
0013++ 04FE 4B          	pusha
0014++ 04FF 07 45 05    	call _strlen	; length in c
0015++ 0502 12          	mov a, c
0016++ 0503 AF 01 00    	cmp a, 1
0017++ 0506 D0 20 05    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0509 7D          	dec a
0019++ 050A FD 4E       	mov si, d	; beginning of string
0020++ 050C FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 050E 59          	add d, a	; end of string
0022++ 050F 12          	mov a, c
0023++ 0510 FD 9B       	shr a		; divide by 2
0024++ 0512 39          	mov c, a	; c now counts the steps
0025++ 0513             _strrev_l0:
0026++ 0513 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0514 F6          	lodsb		; load left-side char into al; increase si
0028++ 0515 3E          	mov [d], al	; store left char into right side
0029++ 0516 1B          	mov al, bl
0030++ 0517 F7          	stosb		; store right-side char into left-side; increase di
0031++ 0518 7E          	dec c
0032++ 0519 7F          	dec d
0033++ 051A C2 00 00    	cmp c, 0
0034++ 051D C7 13 05    	jne _strrev_l0
0035++ 0520             _strrev_end:
0036++ 0520 4C          	popa
0037++ 0521 09          	ret
0038++ 0522             	
0039++ 0522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0522             ; _strchr
0041++ 0522             ; search string in d for char in al
0042++ 0522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0522             _strchr:
0044++ 0522             _strchr_l0:
0045++ 0522 32          	mov bl, [d]
0046++ 0523 C1 00       	cmp bl, 0
0047++ 0525 C6 30 05    	je _strchr_end
0048++ 0528 BA          	cmp al, bl
0049++ 0529 C6 30 05    	je _strchr_end
0050++ 052C 79          	inc d
0051++ 052D 0A 22 05    	jmp _strchr_l0
0052++ 0530             _strchr_end:
0053++ 0530 1B          	mov al, bl
0054++ 0531 09          	ret
0055++ 0532             
0056++ 0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0532             ; _strstr
0058++ 0532             ; find sub-string
0059++ 0532             ; str1 in si
0060++ 0532             ; str2 in di
0061++ 0532             ; si points to end of source string
0062++ 0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0532             _strstr:
0064++ 0532 DB          	push al
0065++ 0533 DA          	push d
0066++ 0534 E3          	push di
0067++ 0535             _strstr_loop:
0068++ 0535 F3          	cmpsb					; compare a byte of the strings
0069++ 0536 C7 41 05    	jne _strstr_ret
0070++ 0539 FC 00 00    	lea d, [di + 0]
0071++ 053C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 053E C7 35 05    	jne _strstr_loop				; equal chars but not at end
0073++ 0541             _strstr_ret:
0074++ 0541 F0          	pop di
0075++ 0542 E7          	pop d
0076++ 0543 E8          	pop al
0077++ 0544 09          	ret
0078++ 0545             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0545             ; length of null terminated string
0080++ 0545             ; result in c
0081++ 0545             ; pointer in d
0082++ 0545             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0545             _strlen:
0084++ 0545 DA          	push d
0085++ 0546 38 00 00    	mov c, 0
0086++ 0549             _strlen_l1:
0087++ 0549 BD 00       	cmp byte [d], 0
0088++ 054B C6 53 05    	je _strlen_ret
0089++ 054E 79          	inc d
0090++ 054F 78          	inc c
0091++ 0550 0A 49 05    	jmp _strlen_l1
0092++ 0553             _strlen_ret:
0093++ 0553 E7          	pop d
0094++ 0554 09          	ret
0095++ 0555             
0096++ 0555             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0555             ; strcmp
0098++ 0555             ; compare two strings
0099++ 0555             ; str1 in si
0100++ 0555             ; str2 in di
0101++ 0555             ; create a string compairon instrucion ?????
0102++ 0555             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0555             _strcmp:
0104++ 0555 DB          	push al
0105++ 0556 DA          	push d
0106++ 0557 E3          	push di
0107++ 0558 E2          	push si
0108++ 0559             _strcmp_loop:
0109++ 0559 F3          	cmpsb					; compare a byte of the strings
0110++ 055A C7 65 05    	jne _strcmp_ret
0111++ 055D FB FF FF    	lea d, [si +- 1]
0112++ 0560 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0562 C7 59 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 0565             _strcmp_ret:
0115++ 0565 EF          	pop si
0116++ 0566 F0          	pop di
0117++ 0567 E7          	pop d
0118++ 0568 E8          	pop al
0119++ 0569 09          	ret
0120++ 056A             
0121++ 056A             
0122++ 056A             ; strcpy
0123++ 056A             ; copy null terminated string from si to di
0124++ 056A             ; source in si
0125++ 056A             ; destination in di
0126++ 056A             _strcpy:
0127++ 056A E2          	push si
0128++ 056B E3          	push di
0129++ 056C DB          	push al
0130++ 056D             _strcpy_l1:
0131++ 056D F6          	lodsb
0132++ 056E F7          	stosb
0133++ 056F B9 00       	cmp al, 0
0134++ 0571 C7 6D 05    	jne _strcpy_l1
0135++ 0574             _strcpy_end:
0136++ 0574 E8          	pop al
0137++ 0575 F0          	pop di
0138++ 0576 EF          	pop si
0139++ 0577 09          	ret
0140++ 0578             
0141++ 0578             ; strcat
0142++ 0578             ; concatenate a null terminated string into string at di, from string at si
0143++ 0578             ; source in si
0144++ 0578             ; destination in di
0145++ 0578             _strcat:
0146++ 0578 E2          	push si
0147++ 0579 E3          	push di
0148++ 057A D7          	push a
0149++ 057B DA          	push d
0150++ 057C 50          	mov a, di
0151++ 057D 3C          	mov d, a
0152++ 057E             _strcat_goto_end_l1:
0153++ 057E BD 00       	cmp byte[d], 0
0154++ 0580 C6 87 05    	je _strcat_start
0155++ 0583 79          	inc d
0156++ 0584 0A 7E 05    	jmp _strcat_goto_end_l1
0157++ 0587             _strcat_start:
0158++ 0587 FD 50       	mov di, d
0159++ 0589             _strcat_l1:
0160++ 0589 F6          	lodsb
0161++ 058A F7          	stosb
0162++ 058B B9 00       	cmp al, 0
0163++ 058D C7 89 05    	jne _strcat_l1
0164++ 0590             _strcat_end:
0165++ 0590 E7          	pop d
0166++ 0591 E4          	pop a
0167++ 0592 F0          	pop di
0168++ 0593 EF          	pop si
0169++ 0594 09          	ret
0170++ 0595             
0171++ 0595             
0005+  0595             
0006+  0595             
0007+  0595             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0595             ; convert ascii 'o'..'f' to integer 0..15
0009+  0595             ; ascii in bl
0010+  0595             ; result in al
0011+  0595             ; ascii for f = 0100 0110
0012+  0595             ; ascii for 9 = 0011 1001
0013+  0595             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0595             hex_ascii_encode:
0015+  0595 1B            mov al, bl
0016+  0596 93 40         test al, $40        ; test if letter or number
0017+  0598 C7 9E 05      jnz hex_letter
0018+  059B 87 0F         and al, $0f        ; get number
0019+  059D 09            ret
0020+  059E             hex_letter:
0021+  059E 87 0F         and al, $0f        ; get letter
0022+  05A0 6A 09         add al, 9
0023+  05A2 09            ret
0024+  05A3             
0025+  05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  05A3             ; atoi
0027+  05A3             ; 2 letter hex string in b
0028+  05A3             ; 8bit integer returned in al
0029+  05A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  05A3             _atoi:
0031+  05A3 D8            push b
0032+  05A4 07 95 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  05A7 30            mov bl, bh
0034+  05A8 DB            push al          ; save a
0035+  05A9 07 95 05      call hex_ascii_encode
0036+  05AC EA            pop bl  
0037+  05AD FD 9E 04      shl al, 4
0038+  05B0 8C            or al, bl
0039+  05B1 E5            pop b
0040+  05B2 09            ret  
0041+  05B3             
0042+  05B3             
0043+  05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  05B3             ; scanf
0045+  05B3             ; no need for explanations!
0046+  05B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  05B3             scanf:
0048+  05B3 09            ret
0049+  05B4             
0050+  05B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  05B4             ; itoa
0052+  05B4             ; 8bit value in bl
0053+  05B4             ; 2 byte ascii result in a
0054+  05B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  05B4             _itoa:
0056+  05B4 DA            push d
0057+  05B5 D8            push b
0058+  05B6 A7 00         mov bh, 0
0059+  05B8 FD A4 04      shr bl, 4  
0060+  05BB 74            mov d, b
0061+  05BC 1F 4E 08      mov al, [d + s_hex_digits]
0062+  05BF 23            mov ah, al
0063+  05C0               
0064+  05C0 E5            pop b
0065+  05C1 D8            push b
0066+  05C2 A7 00         mov bh, 0
0067+  05C4 FD 87 0F      and bl, $0f
0068+  05C7 74            mov d, b
0069+  05C8 1F 4E 08      mov al, [d + s_hex_digits]
0070+  05CB E5            pop b
0071+  05CC E7            pop d
0072+  05CD 09            ret
0073+  05CE             
0074+  05CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  05CE             ; hex string to binary
0076+  05CE             ; di = destination address
0077+  05CE             ; si = source
0078+  05CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  05CE             _hex_to_int:
0080+  05CE             _hex_to_int_l1:
0081+  05CE F6            lodsb          ; load from [si] to al
0082+  05CF B9 00         cmp al, 0        ; check if ascii 0
0083+  05D1 C6 DE 05      jz _hex_to_int_ret
0084+  05D4 36            mov bh, al
0085+  05D5 F6            lodsb
0086+  05D6 2F            mov bl, al
0087+  05D7 07 A3 05      call _atoi        ; convert ascii byte in b to int (to al)
0088+  05DA F7            stosb          ; store al to [di]
0089+  05DB 0A CE 05      jmp _hex_to_int_l1
0090+  05DE             _hex_to_int_ret:
0091+  05DE 09            ret    
0092+  05DF             
0093+  05DF             
0094+  05DF             
0095+  05DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  05DF             ; getchar
0097+  05DF             ; char in ah
0098+  05DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  05DF             getch:
0100+  05DF DB            push al
0101+  05E0             getch_retry:
0102+  05E0 19 01         mov al, 1
0103+  05E2 05 03         syscall sys_io      ; receive in ah
0104+  05E4 E8            pop al
0105+  05E5 09            ret
0106+  05E6             
0107+  05E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  05E6             ; putchar
0109+  05E6             ; char in ah
0110+  05E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05E6             _putchar:
0112+  05E6 DB            push al
0113+  05E7 19 00         mov al, 0
0114+  05E9 05 03         syscall sys_io      ; char in ah
0115+  05EB E8            pop al
0116+  05EC 09            ret
0117+  05ED             
0118+  05ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  05ED             ;; input a string
0120+  05ED             ;; terminates with null
0121+  05ED             ;; pointer in d
0122+  05ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  05ED             _gets:
0124+  05ED D7            push a
0125+  05EE DA            push d
0126+  05EF             _gets_loop:
0127+  05EF 19 01         mov al, 1
0128+  05F1 05 03         syscall sys_io      ; receive in ah
0129+  05F3 76 1B         cmp ah, 27
0130+  05F5 C6 16 06      je _gets_ansi_esc
0131+  05F8 76 0A         cmp ah, $0a        ; lf
0132+  05FA C6 72 06      je _gets_end
0133+  05FD 76 0D         cmp ah, $0d        ; cr
0134+  05FF C6 72 06      je _gets_end
0135+  0602 76 5C         cmp ah, $5c        ; '\\'
0136+  0604 C6 38 06      je _gets_escape
0137+  0607 76 08         cmp ah, $08      ; check for backspace
0138+  0609 C6 12 06      je _gets_backspace
0139+  060C 1A            mov al, ah
0140+  060D 3E            mov [d], al
0141+  060E 79            inc d
0142+  060F 0A EF 05      jmp _gets_loop
0143+  0612             _gets_backspace:
0144+  0612 7F            dec d
0145+  0613 0A EF 05      jmp _gets_loop
0146+  0616             _gets_ansi_esc:
0147+  0616 19 01         mov al, 1
0148+  0618 05 03         syscall sys_io        ; receive in ah without echo
0149+  061A 76 5B         cmp ah, '['
0150+  061C C7 EF 05      jne _gets_loop
0151+  061F 19 01         mov al, 1
0152+  0621 05 03         syscall sys_io          ; receive in ah without echo
0153+  0623 76 64         cmp ah, 'd'
0154+  0625 C6 30 06      je _gets_left_arrow
0155+  0628 76 63         cmp ah, 'c'
0156+  062A C6 34 06      je _gets_right_arrow
0157+  062D 0A EF 05      jmp _gets_loop
0158+  0630             _gets_left_arrow:
0159+  0630 7F            dec d
0160+  0631 0A EF 05      jmp _gets_loop
0161+  0634             _gets_right_arrow:
0162+  0634 79            inc d
0163+  0635 0A EF 05      jmp _gets_loop
0164+  0638             _gets_escape:
0165+  0638 19 01         mov al, 1
0166+  063A 05 03         syscall sys_io      ; receive in ah
0167+  063C 76 6E         cmp ah, 'n'
0168+  063E C6 5D 06      je _gets_lf
0169+  0641 76 72         cmp ah, 'r'
0170+  0643 C6 64 06      je _gets_cr
0171+  0646 76 30         cmp ah, '0'
0172+  0648 C6 6B 06      je _gets_null
0173+  064B 76 5C         cmp ah, $5c  ; '\'
0174+  064D C6 56 06      je _gets_slash
0175+  0650 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0651 3E            mov [d], al
0177+  0652 79            inc d
0178+  0653 0A EF 05      jmp _gets_loop
0179+  0656             _gets_slash:
0180+  0656 19 5C         mov al, $5c
0181+  0658 3E            mov [d], al
0182+  0659 79            inc d
0183+  065A 0A EF 05      jmp _gets_loop
0184+  065D             _gets_lf:
0185+  065D 19 0A         mov al, $0a
0186+  065F 3E            mov [d], al
0187+  0660 79            inc d
0188+  0661 0A EF 05      jmp _gets_loop
0189+  0664             _gets_cr:
0190+  0664 19 0D         mov al, $0d
0191+  0666 3E            mov [d], al
0192+  0667 79            inc d
0193+  0668 0A EF 05      jmp _gets_loop
0194+  066B             _gets_null:
0195+  066B 19 00         mov al, $00
0196+  066D 3E            mov [d], al
0197+  066E 79            inc d
0198+  066F 0A EF 05      jmp _gets_loop
0199+  0672             _gets_end:
0200+  0672 19 00         mov al, 0
0201+  0674 3E            mov [d], al        ; terminate string
0202+  0675 E7            pop d
0203+  0676 E4            pop a
0204+  0677 09            ret
0205+  0678             
0206+  0678             
0207+  0678             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0678             ;; input text
0209+  0678             ;; terminated with ctrl+d
0210+  0678             ;; pointer in d
0211+  0678             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0678             _gettxt:
0213+  0678 D7            push a
0214+  0679 DA            push d
0215+  067A             _gettxt_loop:
0216+  067A 19 01         mov al, 1
0217+  067C 05 03         syscall sys_io      ; receive in ah
0218+  067E 76 04         cmp ah, 4      ; eot
0219+  0680 C6 B9 06      je _gettxt_end
0220+  0683 76 08         cmp ah, $08      ; check for backspace
0221+  0685 C6 B5 06      je _gettxt_backspace
0222+  0688 76 5C         cmp ah, $5c        ; '\'
0223+  068A C6 93 06      je _gettxt_escape
0224+  068D 1A            mov al, ah
0225+  068E 3E            mov [d], al
0226+  068F 79            inc d
0227+  0690 0A 7A 06      jmp _gettxt_loop
0228+  0693             _gettxt_escape:
0229+  0693 19 01         mov al, 1
0230+  0695 05 03         syscall sys_io      ; receive in ah
0231+  0697 76 6E         cmp ah, 'n'
0232+  0699 C6 A7 06      je _gettxt_lf
0233+  069C 76 72         cmp ah, 'r'
0234+  069E C6 AE 06      je _gettxt_cr
0235+  06A1 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  06A2 3E            mov [d], al
0237+  06A3 79            inc d
0238+  06A4 0A 7A 06      jmp _gettxt_loop
0239+  06A7             _gettxt_lf:
0240+  06A7 19 0A         mov al, $0a
0241+  06A9 3E            mov [d], al
0242+  06AA 79            inc d
0243+  06AB 0A 7A 06      jmp _gettxt_loop
0244+  06AE             _gettxt_cr:
0245+  06AE 19 0D         mov al, $0d
0246+  06B0 3E            mov [d], al
0247+  06B1 79            inc d
0248+  06B2 0A 7A 06      jmp _gettxt_loop
0249+  06B5             _gettxt_backspace:
0250+  06B5 7F            dec d
0251+  06B6 0A 7A 06      jmp _gettxt_loop
0252+  06B9             _gettxt_end:
0253+  06B9 19 00         mov al, 0
0254+  06BB 3E            mov [d], al        ; terminate string
0255+  06BC E7            pop d
0256+  06BD E4            pop a
0257+  06BE 09            ret
0258+  06BF             
0259+  06BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  06BF             ; print new line
0261+  06BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  06BF             printnl:
0263+  06BF D7            push a
0264+  06C0 10 00 0A      mov a, $0a00
0265+  06C3 05 03         syscall sys_io
0266+  06C5 10 00 0D      mov a, $0d00
0267+  06C8 05 03         syscall sys_io
0268+  06CA E4            pop a
0269+  06CB 09            ret
0270+  06CC             
0271+  06CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  06CC             ; _strtoint
0273+  06CC             ; 4 digit hex string number in d
0274+  06CC             ; integer returned in a
0275+  06CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  06CC             _strtointx:
0277+  06CC D8            push b
0278+  06CD 32            mov bl, [d]
0279+  06CE 37            mov bh, bl
0280+  06CF 33 01 00      mov bl, [d + 1]
0281+  06D2 07 A3 05      call _atoi        ; convert to int in al
0282+  06D5 23            mov ah, al        ; move to ah
0283+  06D6 33 02 00      mov bl, [d + 2]
0284+  06D9 37            mov bh, bl
0285+  06DA 33 03 00      mov bl, [d + 3]
0286+  06DD 07 A3 05      call _atoi        ; convert to int in al
0287+  06E0 E5            pop b
0288+  06E1 09            ret
0289+  06E2             
0290+  06E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  06E2             ; _strtoint
0292+  06E2             ; 5 digit base10 string number in d
0293+  06E2             ; integer returned in a
0294+  06E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  06E2             _strtoint:
0296+  06E2 E2            push si
0297+  06E3 D8            push b
0298+  06E4 D9            push c
0299+  06E5 DA            push d
0300+  06E6 07 45 05      call _strlen      ; get string length in c
0301+  06E9 7E            dec c
0302+  06EA FD 4E         mov si, d
0303+  06EC 12            mov a, c
0304+  06ED FD 99         shl a
0305+  06EF 3B 66 08      mov d, table_power
0306+  06F2 59            add d, a
0307+  06F3 38 00 00      mov c, 0
0308+  06F6             _strtoint_l0:
0309+  06F6 F6            lodsb      ; load ascii to al
0310+  06F7 B9 00         cmp al, 0
0311+  06F9 C6 0C 07      je _strtoint_end
0312+  06FC 6F 30         sub al, $30    ; make into integer
0313+  06FE 22 00         mov ah, 0
0314+  0700 2A            mov b, [d]
0315+  0701 AC            mul a, b      ; result in b since it fits in 16bits
0316+  0702 11            mov a, b
0317+  0703 28            mov b, c
0318+  0704 54            add a, b
0319+  0705 39            mov c, a
0320+  0706 63 02 00      sub d, 2
0321+  0709 0A F6 06      jmp _strtoint_l0
0322+  070C             _strtoint_end:
0323+  070C 12            mov a, c
0324+  070D E7            pop d
0325+  070E E6            pop c
0326+  070F E5            pop b
0327+  0710 EF            pop si
0328+  0711 09            ret
0329+  0712             
0330+  0712             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0712             ; print null terminated string
0332+  0712             ; pointer in d
0333+  0712             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0712             _puts:
0335+  0712 D7            push a
0336+  0713 DA            push d
0337+  0714             _puts_l1:
0338+  0714 1E            mov al, [d]
0339+  0715 B9 00         cmp al, 0
0340+  0717 C6 23 07      jz _puts_end
0341+  071A 23            mov ah, al
0342+  071B 19 00         mov al, 0
0343+  071D 05 03         syscall sys_io
0344+  071F 79            inc d
0345+  0720 0A 14 07      jmp _puts_l1
0346+  0723             _puts_end:
0347+  0723 E7            pop d
0348+  0724 E4            pop a
0349+  0725 09            ret
0350+  0726             
0351+  0726             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0726             ; print n size string
0353+  0726             ; pointer in d
0354+  0726             ; size in c
0355+  0726             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0726             _putsn:
0357+  0726 DB            push al
0358+  0727 DA            push d
0359+  0728 D9            push c
0360+  0729             _putsn_l0:
0361+  0729 1E            mov al, [d]
0362+  072A 23            mov ah, al
0363+  072B 19 00         mov al, 0
0364+  072D 05 03         syscall sys_io
0365+  072F 79            inc d
0366+  0730 7E            dec c  
0367+  0731 C2 00 00      cmp c, 0
0368+  0734 C7 29 07      jne _putsn_l0
0369+  0737             _putsn_end:
0370+  0737 E6            pop c
0371+  0738 E7            pop d
0372+  0739 E8            pop al
0373+  073A 09            ret
0374+  073B             
0375+  073B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  073B             ; print 16bit decimal number
0377+  073B             ; input number in a
0378+  073B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  073B             print_u16d:
0380+  073B D7            push a
0381+  073C D8            push b
0382+  073D FD D8         push g
0383+  073F 26 10 27      mov b, 10000
0384+  0742 AE            div a, b      ; get 10000's coeff.
0385+  0743 07 67 07      call print_number
0386+  0746 11            mov a, b
0387+  0747 26 E8 03      mov b, 1000
0388+  074A AE            div a, b      ; get 1000's coeff.
0389+  074B 07 67 07      call print_number
0390+  074E 11            mov a, b
0391+  074F 26 64 00      mov b, 100
0392+  0752 AE            div a, b
0393+  0753 07 67 07      call print_number
0394+  0756 11            mov a, b
0395+  0757 26 0A 00      mov b, 10
0396+  075A AE            div a, b
0397+  075B 07 67 07      call print_number
0398+  075E 1B            mov al, bl      ; 1's coeff in bl
0399+  075F 07 67 07      call print_number
0400+  0762 FD F1         pop g
0401+  0764 E5            pop b
0402+  0765 E4            pop a
0403+  0766 09            ret
0404+  0767             
0405+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0767             ; print al
0407+  0767             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0767             print_number:
0409+  0767 6A 30         add al, $30
0410+  0769 23            mov ah, al
0411+  076A 07 E6 05      call _putchar
0412+  076D 09            ret
0413+  076E             
0414+  076E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  076E             ; print 16bit hex integer
0416+  076E             ; integer value in reg b
0417+  076E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  076E             print_u16x:
0419+  076E D7            push a
0420+  076F D8            push b
0421+  0770 DD            push bl
0422+  0771 30            mov bl, bh
0423+  0772 07 B4 05      call _itoa        ; convert bh to char in a
0424+  0775 2F            mov bl, al        ; save al
0425+  0776 19 00         mov al, 0
0426+  0778 05 03         syscall sys_io        ; display ah
0427+  077A 24            mov ah, bl        ; retrieve al
0428+  077B 19 00         mov al, 0
0429+  077D 05 03         syscall sys_io        ; display al
0430+  077F             
0431+  077F EA            pop bl
0432+  0780 07 B4 05      call _itoa        ; convert bh to char in a
0433+  0783 2F            mov bl, al        ; save al
0434+  0784 19 00         mov al, 0
0435+  0786 05 03         syscall sys_io        ; display ah
0436+  0788 24            mov ah, bl        ; retrieve al
0437+  0789 19 00         mov al, 0
0438+  078B 05 03         syscall sys_io        ; display al
0439+  078D             
0440+  078D E5            pop b
0441+  078E E4            pop a
0442+  078F 09            ret
0443+  0790             
0444+  0790             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0790             ; input 16bit hex integer
0446+  0790             ; read 16bit integer into a
0447+  0790             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0790             scan_u16x:
0449+  0790 F8 10 00      enter 16
0450+  0793 D8            push b
0451+  0794 DA            push d
0452+  0795             
0453+  0795 FA F1 FF      lea d, [bp + -15]
0454+  0798 07 ED 05      call _gets        ; get number
0455+  079B             
0456+  079B 32            mov bl, [d]
0457+  079C 37            mov bh, bl
0458+  079D 33 01 00      mov bl, [d + 1]
0459+  07A0 07 A3 05      call _atoi        ; convert to int in al
0460+  07A3 23            mov ah, al        ; move to ah
0461+  07A4             
0462+  07A4 33 02 00      mov bl, [d + 2]
0463+  07A7 37            mov bh, bl
0464+  07A8 33 03 00      mov bl, [d + 3]
0465+  07AB 07 A3 05      call _atoi        ; convert to int in al
0466+  07AE             
0467+  07AE E7            pop d
0468+  07AF E5            pop b
0469+  07B0 F9            leave
0470+  07B1 09            ret
0471+  07B2             
0472+  07B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  07B2             ; print 8bit hex integer
0474+  07B2             ; integer value in reg bl
0475+  07B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  07B2             print_u8x:
0477+  07B2 D7            push a
0478+  07B3 DD            push bl
0479+  07B4             
0480+  07B4 07 B4 05      call _itoa        ; convert bl to char in a
0481+  07B7 2F            mov bl, al        ; save al
0482+  07B8 19 00         mov al, 0
0483+  07BA 05 03         syscall sys_io        ; display ah
0484+  07BC 24            mov ah, bl        ; retrieve al
0485+  07BD 19 00         mov al, 0
0486+  07BF 05 03         syscall sys_io        ; display al
0487+  07C1             
0488+  07C1 EA            pop bl
0489+  07C2 E4            pop a
0490+  07C3 09            ret
0491+  07C4             
0492+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  07C4             ; print 8bit decimal unsigned number
0494+  07C4             ; input number in al
0495+  07C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  07C4             print_u8d:
0497+  07C4 D7            push a
0498+  07C5 D8            push b
0499+  07C6 FD D8         push g
0500+  07C8 22 00         mov ah, 0
0501+  07CA 26 64 00      mov b, 100
0502+  07CD AE            div a, b
0503+  07CE D8            push b      ; save remainder
0504+  07CF B9 00         cmp al, 0
0505+  07D1 C6 DB 07      je skip100
0506+  07D4 6A 30         add al, $30
0507+  07D6 23            mov ah, al
0508+  07D7 19 00         mov al, 0
0509+  07D9 05 03         syscall sys_io  ; print coeff
0510+  07DB             skip100:
0511+  07DB E4            pop a
0512+  07DC 22 00         mov ah, 0
0513+  07DE 26 0A 00      mov b, 10
0514+  07E1 AE            div a, b
0515+  07E2 D8            push b      ; save remainder
0516+  07E3 B9 00         cmp al, 0
0517+  07E5 C6 EF 07      je skip10
0518+  07E8 6A 30         add al, $30
0519+  07EA 23            mov ah, al
0520+  07EB 19 00         mov al, 0
0521+  07ED 05 03         syscall sys_io  ; print coeff
0522+  07EF             skip10:
0523+  07EF E4            pop a
0524+  07F0 1B            mov al, bl
0525+  07F1 6A 30         add al, $30
0526+  07F3 23            mov ah, al
0527+  07F4 19 00         mov al, 0
0528+  07F6 05 03         syscall sys_io  ; print coeff
0529+  07F8 FD F1         pop g
0530+  07FA E5            pop b
0531+  07FB E4            pop a
0532+  07FC 09            ret
0533+  07FD             
0534+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  07FD             ; input 8bit hex integer
0536+  07FD             ; read 8bit integer into al
0537+  07FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  07FD             scan_u8x:
0539+  07FD F8 04 00      enter 4
0540+  0800 D8            push b
0541+  0801 DA            push d
0542+  0802             
0543+  0802 FA FD FF      lea d, [bp + -3]
0544+  0805 07 ED 05      call _gets        ; get number
0545+  0808             
0546+  0808 32            mov bl, [d]
0547+  0809 37            mov bh, bl
0548+  080A 33 01 00      mov bl, [d + 1]
0549+  080D 07 A3 05      call _atoi        ; convert to int in al
0550+  0810             
0551+  0810 E7            pop d
0552+  0811 E5            pop b
0553+  0812 F9            leave
0554+  0813 09            ret
0555+  0814             
0556+  0814             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0814             ; input decimal number
0558+  0814             ; result in a
0559+  0814             ; 655'\0'
0560+  0814             ; low--------high
0561+  0814             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0814             scan_u16d:
0563+  0814 F8 08 00      enter 8
0564+  0817 E2            push si
0565+  0818 D8            push b
0566+  0819 D9            push c
0567+  081A DA            push d
0568+  081B FA F9 FF      lea d, [bp +- 7]
0569+  081E 07 ED 05      call _gets
0570+  0821 07 45 05      call _strlen      ; get string length in c
0571+  0824 7E            dec c
0572+  0825 FD 4E         mov si, d
0573+  0827 12            mov a, c
0574+  0828 FD 99         shl a
0575+  082A 3B 66 08      mov d, table_power
0576+  082D 59            add d, a
0577+  082E 38 00 00      mov c, 0
0578+  0831             mul_loop:
0579+  0831 F6            lodsb      ; load ascii to al
0580+  0832 B9 00         cmp al, 0
0581+  0834 C6 47 08      je mul_exit
0582+  0837 6F 30         sub al, $30    ; make into integer
0583+  0839 22 00         mov ah, 0
0584+  083B 2A            mov b, [d]
0585+  083C AC            mul a, b      ; result in b since it fits in 16bits
0586+  083D 11            mov a, b
0587+  083E 28            mov b, c
0588+  083F 54            add a, b
0589+  0840 39            mov c, a
0590+  0841 63 02 00      sub d, 2
0591+  0844 0A 31 08      jmp mul_loop
0592+  0847             mul_exit:
0593+  0847 12            mov a, c
0594+  0848 E7            pop d
0595+  0849 E6            pop c
0596+  084A E5            pop b
0597+  084B EF            pop si
0598+  084C F9            leave
0599+  084D 09            ret
0600+  084E             
0601+  084E             
0602+  084E 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  0852 34 35 36 37 
0602+  0856 38 39 61 62 
0602+  085A 63 64 65 66 
0603+  085E 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  0862 1B 5B 68 00 
0604+  0866             
0605+  0866             table_power:
0606+  0866 01 00         .dw 1
0607+  0868 0A 00         .dw 10
0608+  086A 64 00         .dw 100
0609+  086C E8 03         .dw 1000
0610+  086E 10 27         .dw 100001132   0870             .include "lib/ctype.asm"
0001+  0870             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0870             ; ctype.s
0003+  0870             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0870             
0005+  0870             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0870             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  0870             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  0870             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  0870             ;; characters are supported.
0010+  0870             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0870             ;; _isalnum 
0012+  0870             ;; _isalpha 
0013+  0870             ;; islower 
0014+  0870             ;; isupper 
0015+  0870             ;; _isdigit 
0016+  0870             ;; isxdigit
0017+  0870             ;; iscntrl 
0018+  0870             ;; isgraph 
0019+  0870             ;; _isspace 
0020+  0870             ;; isblank 
0021+  0870             ;; isprint 
0022+  0870             ;; ispunct 
0023+  0870             ;; tolower 
0024+  0870             ;; toupper
0025+  0870             
0026+  0870             
0027+  0870             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0870             ;; is alphanumeric
0029+  0870             ;; sets zf according with result
0030+  0870             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0870             _isalnum:
0032+  0870 07 8D 08    	call _isalpha
0033+  0873 C6 79 08    	je _isalnum_exit
0034+  0876 07 7A 08    	call _isdigit
0035+  0879             _isalnum_exit:
0036+  0879 09          	ret	
0037+  087A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  087A             ;; is digit
0039+  087A             ;; sets zf according with result
0040+  087A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  087A             _isdigit:
0042+  087A DB          	push al
0043+  087B B9 30       	cmp al, '0'
0044+  087D C8 89 08    	jlu _isdigit_false
0045+  0880 B9 39       	cmp al, '9'
0046+  0882 D1 89 08    	jgu _isdigit_false
0047+  0885 87 00       	and al, 0	; set zf
0048+  0887 E8          	pop al
0049+  0888 09          	ret
0050+  0889             _isdigit_false:
0051+  0889 8B 01       	or al, 1	; clear zf
0052+  088B E8          	pop al
0053+  088C 09          	ret	
0054+  088D             	
0055+  088D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  088D             ;; is alpha
0057+  088D             ;; sets zf according with result
0058+  088D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  088D             _isalpha:
0060+  088D DB          	push al
0061+  088E B9 5F       	cmp al, '_'
0062+  0890 C6 B0 08    	je _isalpha_true
0063+  0893 B9 2E       	cmp al, '.'
0064+  0895 C6 B0 08    	je _isalpha_true
0065+  0898 B9 61       	cmp al, 'a'
0066+  089A C8 AC 08    	jlu _isalpha_false
0067+  089D B9 7A       	cmp al, 'z'
0068+  089F D1 AC 08    	jgu _isalpha_false
0069+  08A2 B9 7A       	cmp al, 'z'
0070+  08A4 D0 B0 08    	jleu _isalpha_true
0071+  08A7 B9 61       	cmp al, 'a'
0072+  08A9 C9 B0 08    	jgeu _isalpha_true
0073+  08AC             _isalpha_false:
0074+  08AC 8B 01       	or al, 1	; clear zf
0075+  08AE E8          	pop al
0076+  08AF 09          	ret
0077+  08B0             _isalpha_true:
0078+  08B0 87 00       	and al, 0	; set zf
0079+  08B2 E8          	pop al
0080+  08B3 09          	ret
0081+  08B4             
0082+  08B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  08B4             ;; is path-alpha
0084+  08B4             ;; sets zf according with result
0085+  08B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  08B4             ispath:
0087+  08B4 DB          	push al
0088+  08B5 07 7A 08    	call _isdigit
0089+  08B8 C6 E2 08    	je ispath_true
0090+  08BB B9 5F       	cmp al, '_'
0091+  08BD C6 E2 08    	je ispath_true
0092+  08C0 B9 2F       	cmp al, '/'
0093+  08C2 C6 E2 08    	je ispath_true
0094+  08C5 B9 2E       	cmp al, '.'
0095+  08C7 C6 E2 08    	je ispath_true
0096+  08CA B9 61       	cmp al, 'a'
0097+  08CC C8 DE 08    	jlu ispath_false
0098+  08CF B9 7A       	cmp al, 'z'
0099+  08D1 D1 DE 08    	jgu ispath_false
0100+  08D4 B9 7A       	cmp al, 'z'
0101+  08D6 D0 E2 08    	jleu ispath_true
0102+  08D9 B9 61       	cmp al, 'a'
0103+  08DB C9 E2 08    	jgeu ispath_true
0104+  08DE             ispath_false:
0105+  08DE 8B 01       	or al, 1	; clear zf
0106+  08E0 E8          	pop al
0107+  08E1 09          	ret
0108+  08E2             ispath_true:
0109+  08E2 87 00       	and al, 0	; set zf
0110+  08E4 E8          	pop al
0111+  08E5 09          	ret
0112+  08E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  08E6             ;; is space
0114+  08E6             ;; sets zf according with result
0115+  08E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  08E6             _isspace:
0117+  08E6 B9 20       	cmp al, $20		; ' '
0118+  08E8 C6 FC 08    	je _isspace_exit
0119+  08EB B9 09       	cmp al, $09		; '\t'
0120+  08ED C6 FC 08    	je _isspace_exit
0121+  08F0 B9 0A       	cmp al, $0a		; '\n'
0122+  08F2 C6 FC 08    	je _isspace_exit
0123+  08F5 B9 0D       	cmp al, $0d		; '\r'
0124+  08F7 C6 FC 08    	je _isspace_exit
0125+  08FA B9 0B       	cmp al, $0b		; '\v'
0126+  08FC             _isspace_exit:
0127+  08FC 09          	ret	
0128+  08FD             
0129+  08FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08FD             ; to lower
0131+  08FD             ; input in al
0132+  08FD             ; output in al
0133+  08FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  08FD             _to_lower:
0135+  08FD B9 7A       	cmp al, 'z'
0136+  08FF D1 04 09    	jgu _to_lower_ret
0137+  0902 6A 20       	add al, $20				; convert to lower case
0138+  0904             _to_lower_ret:
0139+  0904 09          	ret
0140+  0905             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0905             ; to upper
0142+  0905             ; input in al
0143+  0905             ; output in al
0144+  0905             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0905             _to_upper:
0146+  0905 B9 61       	cmp al, 'a'
0147+  0907 C8 0C 09    	jlu _to_upper_ret
0148+  090A 6F 20       	sub al, $20			; convert to upper case
0149+  090C             _to_upper_ret:
0150+  090C 09          	ret
0151+  090D             
1133   090D             .include "lib/token.asm"
0001+  090D             toktyp_identifier  .equ 0
0002+  090D             toktyp_keyword     .equ 1
0003+  090D             toktyp_delimiter   .equ 2
0004+  090D             toktyp_string      .equ 3
0005+  090D             toktyp_char        .equ 4
0006+  090D             toktyp_numeric     .equ 5
0007+  090D             toktyp_end         .equ 6
0008+  090D             
0009+  090D             tok_null           .equ 0
0010+  090D             tok_fslash         .equ 1
0011+  090D             tok_times          .equ 2
0012+  090D             tok_plus           .equ 3
0013+  090D             tok_minus          .equ 4
0014+  090D             tok_dot            .equ 5
0015+  090D             tok_semi           .equ 6
0016+  090D             tok_angle          .equ 7
0017+  090D             tok_tilde          .equ 8
0018+  090D             tok_equal          .equ 9
0019+  090D             tok_colon          .equ 10
0020+  090D             tok_comma          .equ 11
0021+  090D             
0022+  090D             tok_end            .equ 20
0023+  090D             
0024+  090D             
0025+  090D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  090D             ;; read a full command argment from shell input buffer
0027+  090D             ;; argument is written into tokstr
0028+  090D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  090D             get_arg:
0030+  090D D7            push a
0031+  090E E2            push si
0032+  090F E3            push di
0033+  0910 19 00         mov al, 0
0034+  0912 3D 3B 0B      mov [tokstr], al      ; nullify tokstr string
0035+  0915 14 37 0B      mov a, [prog]
0036+  0918 4D            mov si, a
0037+  0919 FD 4F 3B 0B   mov di, tokstr
0038+  091D             get_arg_skip_spaces:
0039+  091D F6            lodsb
0040+  091E 07 E6 08      call _isspace
0041+  0921 C6 1D 09      je get_arg_skip_spaces
0042+  0924             get_arg_l0:
0043+  0924 B9 3B         cmp al, $3b        ; check if is ';'
0044+  0926 C6 33 09      je get_arg_end
0045+  0929 B9 00         cmp al, 0
0046+  092B C6 33 09      je get_arg_end      ; check if end of input
0047+  092E F7            stosb
0048+  092F F6            lodsb
0049+  0930 0A 24 09      jmp get_arg_l0
0050+  0933             get_arg_end:
0051+  0933 19 00         mov al, 0
0052+  0935 F7            stosb
0053+  0936 D5 01 00      sub si, 1
0054+  0939 4E            mov a, si
0055+  093A 42 37 0B      mov [prog], a    ; update pointer
0056+  093D F0            pop di
0057+  093E EF            pop si
0058+  093F E4            pop a
0059+  0940 09            ret
0060+  0941             
0061+  0941             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0941             ;; read a path formation from shell input buffer
0063+  0941             ;; path is written into tokstr
0064+  0941             ;; /usr/bin
0065+  0941             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0941             get_path:
0067+  0941 D7            push a
0068+  0942 E2            push si
0069+  0943 E3            push di
0070+  0944 19 00         mov al, 0
0071+  0946 3D 3B 0B      mov [tokstr], al      ; nullify tokstr string
0072+  0949 14 37 0B      mov a, [prog]
0073+  094C 4D            mov si, a
0074+  094D FD 4F 3B 0B   mov di, tokstr
0075+  0951             get_path_skip_spaces:
0076+  0951 F6            lodsb
0077+  0952 07 E6 08      call _isspace
0078+  0955 C6 51 09      je get_path_skip_spaces
0079+  0958             get_path_is_pathchar:
0080+  0958 F7            stosb
0081+  0959 F6            lodsb
0082+  095A 07 70 08      call _isalnum      ;check if is alphanumeric
0083+  095D C6 58 09      je get_path_is_pathchar
0084+  0960 B9 2F         cmp al, '/'        ; check if is '/'
0085+  0962 C6 58 09      je get_path_is_pathchar
0086+  0965 19 00         mov al, 0
0087+  0967 F7            stosb
0088+  0968 D5 01 00      sub si, 1
0089+  096B 4E            mov a, si
0090+  096C 42 37 0B      mov [prog], a    ; update pointer
0091+  096F             get_path_end:
0092+  096F F0            pop di
0093+  0970 EF            pop si
0094+  0971 E4            pop a
0095+  0972 09            ret
0096+  0973             
0097+  0973             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0973             ;; read a line
0099+  0973             ;; line is written into tokstr
0100+  0973             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0973             get_line:
0102+  0973 D7            push a
0103+  0974 E2            push si
0104+  0975 E3            push di
0105+  0976 19 00         mov al, 0
0106+  0978 3D 3B 0B      mov [tokstr], al      ; nullify tokstr string
0107+  097B 14 37 0B      mov a, [prog]
0108+  097E 4D            mov si, a
0109+  097F FD 4F 3B 0B   mov di, tokstr
0110+  0983             get_line_l0:
0111+  0983 F6            lodsb
0112+  0984 B9 0A         cmp al, $0a    ; check for new line
0113+  0986 C6 8D 09      je get_line_exit
0114+  0989 F7            stosb
0115+  098A 0A 83 09      jmp get_line_l0
0116+  098D             get_line_exit:
0117+  098D 19 00         mov al, 0
0118+  098F F7            stosb
0119+  0990 4E            mov a, si
0120+  0991 42 37 0B      mov [prog], a    ; update pointer
0121+  0994 F0            pop di
0122+  0995 EF            pop si
0123+  0996 E4            pop a
0124+  0997 09            ret
0125+  0998             
0126+  0998             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0998             ;; token parser
0128+  0998             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0998             get_token:
0130+  0998 D7            push a
0131+  0999 DA            push d
0132+  099A E2            push si
0133+  099B E3            push di
0134+  099C 19 00         mov al, 0
0135+  099E 3D 3B 0B      mov [tokstr], al      ; nullify tokstr string
0136+  09A1 19 00         mov al, tok_null
0137+  09A3 3D 3A 0B      mov [tok], al        ; nullify token
0138+  09A6 14 37 0B      mov a, [prog]
0139+  09A9 4D            mov si, a
0140+  09AA FD 4F 3B 0B   mov di, tokstr
0141+  09AE             get_tok_skip_spaces:
0142+  09AE F6            lodsb
0143+  09AF 07 E6 08      call _isspace
0144+  09B2 C6 AE 09      je get_tok_skip_spaces
0145+  09B5 B9 00         cmp al, 0      ; check for end of input (null)
0146+  09B7 C6 9C 0A      je get_token_end
0147+  09BA B9 23         cmp al, '#'      ; comments!
0148+  09BC C6 CA 0A      je get_tok_comment
0149+  09BF 07 70 08      call _isalnum
0150+  09C2 C6 A9 0A      jz is_alphanumeric
0151+  09C5             ; other token types
0152+  09C5             get_token_slash:
0153+  09C5 B9 2F         cmp al, '/'        ; check if '/'
0154+  09C7 C7 DF 09      jne get_token_minus
0155+  09CA F7            stosb          ; store '/' into token string
0156+  09CB 19 00         mov al, 0
0157+  09CD F7            stosb          ; terminate token string
0158+  09CE 19 01         mov al, tok_fslash
0159+  09D0 3D 3A 0B      mov [tok], al      
0160+  09D3 19 02         mov al, toktyp_delimiter
0161+  09D5 3D 39 0B      mov [toktyp], al
0162+  09D8 4E            mov a, si
0163+  09D9 42 37 0B      mov [prog], a    ; update pointer
0164+  09DC 0A C5 0A      jmp get_token_return
0165+  09DF             get_token_minus:
0166+  09DF B9 2D         cmp al, '-'        ; check if '-'
0167+  09E1 C7 F9 09      jne get_token_comma
0168+  09E4 F7            stosb          ; store '-' into token string
0169+  09E5 19 00         mov al, 0
0170+  09E7 F7            stosb          ; terminate token string
0171+  09E8 19 04         mov al, tok_minus
0172+  09EA 3D 3A 0B      mov [tok], al      
0173+  09ED 19 02         mov al, toktyp_delimiter
0174+  09EF 3D 39 0B      mov [toktyp], al
0175+  09F2 4E            mov a, si
0176+  09F3 42 37 0B      mov [prog], a    ; update pointer
0177+  09F6 0A C5 0A      jmp get_token_return
0178+  09F9             get_token_comma:
0179+  09F9 B9 2C         cmp al, ','        ; check if ','
0180+  09FB C7 13 0A      jne get_token_semi
0181+  09FE F7            stosb          ; store ',' into token string
0182+  09FF 19 00         mov al, 0
0183+  0A01 F7            stosb          ; terminate token string
0184+  0A02 19 0B         mov al, tok_comma
0185+  0A04 3D 3A 0B      mov [tok], al      
0186+  0A07 19 02         mov al, toktyp_delimiter
0187+  0A09 3D 39 0B      mov [toktyp], al
0188+  0A0C 4E            mov a, si
0189+  0A0D 42 37 0B      mov [prog], a    ; update pointer
0190+  0A10 0A C5 0A      jmp get_token_return
0191+  0A13             get_token_semi:
0192+  0A13 B9 3B         cmp al, $3b        ; check if ';'
0193+  0A15 C7 2D 0A      jne get_token_colon
0194+  0A18 F7            stosb          ; store ';' into token string
0195+  0A19 19 00         mov al, 0
0196+  0A1B F7            stosb          ; terminate token string
0197+  0A1C 19 06         mov al, tok_semi
0198+  0A1E 3D 3A 0B      mov [tok], al      
0199+  0A21 19 02         mov al, toktyp_delimiter
0200+  0A23 3D 39 0B      mov [toktyp], al
0201+  0A26 4E            mov a, si
0202+  0A27 42 37 0B      mov [prog], a    ; update pointer
0203+  0A2A 0A C5 0A      jmp get_token_return
0204+  0A2D             get_token_colon:
0205+  0A2D B9 3A         cmp al, $3a        ; check if ':'
0206+  0A2F C7 47 0A      jne get_token_angle
0207+  0A32 F7            stosb          ; store ':' into token string
0208+  0A33 19 00         mov al, 0
0209+  0A35 F7            stosb          ; terminate token string
0210+  0A36 19 0A         mov al, tok_colon
0211+  0A38 3D 3A 0B      mov [tok], al      
0212+  0A3B 19 02         mov al, toktyp_delimiter
0213+  0A3D 3D 39 0B      mov [toktyp], al
0214+  0A40 4E            mov a, si
0215+  0A41 42 37 0B      mov [prog], a    ; update pointer
0216+  0A44 0A C5 0A      jmp get_token_return
0217+  0A47             get_token_angle:
0218+  0A47 B9 3E         cmp al, $3e        ; check if '>'
0219+  0A49 C7 61 0A      jne get_token_tilde
0220+  0A4C F7            stosb          ; store '>' into token string
0221+  0A4D 19 00         mov al, 0
0222+  0A4F F7            stosb          ; terminate token string
0223+  0A50 19 07         mov al, tok_angle
0224+  0A52 3D 3A 0B      mov [tok], al      
0225+  0A55 19 02         mov al, toktyp_delimiter
0226+  0A57 3D 39 0B      mov [toktyp], al
0227+  0A5A 4E            mov a, si
0228+  0A5B 42 37 0B      mov [prog], a    ; update pointer
0229+  0A5E 0A C5 0A      jmp get_token_return
0230+  0A61             get_token_tilde:
0231+  0A61 B9 7E         cmp al, '~'        ; check if '~'
0232+  0A63 C7 7B 0A      jne get_token_equal
0233+  0A66 F7            stosb          ; store '~' into token string
0234+  0A67 19 00         mov al, 0
0235+  0A69 F7            stosb          ; terminate token string
0236+  0A6A 19 08         mov al, tok_tilde
0237+  0A6C 3D 3A 0B      mov [tok], al      
0238+  0A6F 19 02         mov al, toktyp_delimiter
0239+  0A71 3D 39 0B      mov [toktyp], al
0240+  0A74 4E            mov a, si
0241+  0A75 42 37 0B      mov [prog], a    ; update pointer
0242+  0A78 0A C5 0A      jmp get_token_return
0243+  0A7B             get_token_equal:
0244+  0A7B B9 3D         cmp al, '='        ; check if '='
0245+  0A7D C7 95 0A      jne get_token_skip
0246+  0A80 F7            stosb          ; store '=' into token string
0247+  0A81 19 00         mov al, 0
0248+  0A83 F7            stosb          ; terminate token string
0249+  0A84 19 09         mov al, tok_equal
0250+  0A86 3D 3A 0B      mov [tok], al      
0251+  0A89 19 02         mov al, toktyp_delimiter
0252+  0A8B 3D 39 0B      mov [toktyp], al
0253+  0A8E 4E            mov a, si
0254+  0A8F 42 37 0B      mov [prog], a    ; update pointer
0255+  0A92 0A C5 0A      jmp get_token_return
0256+  0A95             get_token_skip:
0257+  0A95 4E            mov a, si
0258+  0A96 42 37 0B      mov [prog], a    ; update pointer
0259+  0A99 0A C5 0A      jmp get_token_return
0260+  0A9C             get_token_end:        ; end of file token
0261+  0A9C 19 14         mov al, tok_end
0262+  0A9E 3D 3A 0B      mov [tok], al
0263+  0AA1 19 06         mov al, toktyp_end
0264+  0AA3 3D 39 0B      mov [toktyp], al
0265+  0AA6 0A C5 0A      jmp get_token_return
0266+  0AA9             is_alphanumeric:
0267+  0AA9 F7            stosb
0268+  0AAA F6            lodsb
0269+  0AAB 07 70 08      call _isalnum      ;check if is alphanumeric
0270+  0AAE C6 A9 0A      jz is_alphanumeric
0271+  0AB1 B9 2E         cmp al, $2e        ; check if is '.'
0272+  0AB3 C6 A9 0A      je is_alphanumeric
0273+  0AB6 19 00         mov al, 0
0274+  0AB8 F7            stosb
0275+  0AB9 19 00         mov al, toktyp_identifier
0276+  0ABB 3D 39 0B      mov [toktyp], al
0277+  0ABE D5 01 00      sub si, 1
0278+  0AC1 4E            mov a, si
0279+  0AC2 42 37 0B      mov [prog], a    ; update pointer
0280+  0AC5             get_token_return:
0281+  0AC5 F0            pop di
0282+  0AC6 EF            pop si
0283+  0AC7 E7            pop d
0284+  0AC8 E4            pop a
0285+  0AC9 09            ret
0286+  0ACA             get_tok_comment:
0287+  0ACA F6            lodsb
0288+  0ACB B9 0A         cmp al, $0a      ; new line
0289+  0ACD C7 CA 0A      jne get_tok_comment
0290+  0AD0 0A AE 09      jmp get_tok_skip_spaces
0291+  0AD3             
0292+  0AD3             
0293+  0AD3             get_number:
0294+  0AD3 D7            push a
0295+  0AD4 DA            push d
0296+  0AD5 E2            push si
0297+  0AD6 E3            push di
0298+  0AD7 19 00         mov al, 0
0299+  0AD9 3D 3B 0B      mov [tokstr], al      ; nullify tokstr string
0300+  0ADC 19 00         mov al, tok_null
0301+  0ADE 3D 3A 0B      mov [tok], al        ; nullify token
0302+  0AE1 14 37 0B      mov a, [prog]
0303+  0AE4 4D            mov si, a
0304+  0AE5 FD 4F 3B 0B   mov di, tokstr
0305+  0AE9             get_number_skip_spaces:
0306+  0AE9 F6            lodsb
0307+  0AEA 07 E6 08      call _isspace
0308+  0AED C6 E9 0A      je get_number_skip_spaces
0309+  0AF0 B9 00         cmp al, 0      ; check for end of input (null)
0310+  0AF2 C7 02 0B      jne get_number_l0
0311+  0AF5 19 14         mov al, tok_end
0312+  0AF7 3D 3A 0B      mov [tok], al
0313+  0AFA 19 06         mov al, toktyp_end
0314+  0AFC 3D 39 0B      mov [toktyp], al
0315+  0AFF 0A 19 0B      jmp get_number_return
0316+  0B02             get_number_l0:
0317+  0B02 F7            stosb
0318+  0B03 F6            lodsb
0319+  0B04 07 7A 08      call _isdigit      ;check if is numeric
0320+  0B07 C6 02 0B      jz get_number_l0
0321+  0B0A 19 00         mov al, 0
0322+  0B0C F7            stosb
0323+  0B0D 19 05         mov al, toktyp_numeric
0324+  0B0F 3D 39 0B      mov [toktyp], al
0325+  0B12 D5 01 00      sub si, 1
0326+  0B15 4E            mov a, si
0327+  0B16 42 37 0B      mov [prog], a    ; update pointer
0328+  0B19             get_number_return:
0329+  0B19 F0            pop di
0330+  0B1A EF            pop si
0331+  0B1B E7            pop d
0332+  0B1C E4            pop a
0333+  0B1D 09            ret
0334+  0B1E             
0335+  0B1E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0B1E             ;; put back token
0337+  0B1E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  0B1E             _putback:
0339+  0B1E D7            push a
0340+  0B1F E2            push si
0341+  0B20 FD 4D 3B 0B   mov si, tokstr  
0342+  0B24             _putback_loop:
0343+  0B24 F6            lodsb
0344+  0B25 B9 00         cmp al, 0
0345+  0B27 C6 34 0B      je _putback_end
0346+  0B2A 14 37 0B      mov a, [prog]
0347+  0B2D 7D            dec a
0348+  0B2E 42 37 0B      mov [prog], a      ; update pointer
0349+  0B31 0A 24 0B      jmp _putback_loop
0350+  0B34             _putback_end:
0351+  0B34 EF            pop si
0352+  0B35 E4            pop a
0353+  0B36 09            ret
0354+  0B37             
0355+  0B37             
0356+  0B37             
0357+  0B37             
0358+  0B37 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  0B39             
0360+  0B39 00          toktyp:    .db 0          ; token type symbol
0361+  0B3A 00          tok:       .db 0          ; current token symbol
0362+  0B3B 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  0B3F 00 00 00 00 
0362+  0B43 00 00 00 00 
0362+  0B47 00 00 00 00 
0362+  0B4B 00 00 00 00 
0362+  0B4F 00 00 00 00 
0362+  0B53 00 00 00 00 
0362+  0B57 00 00 00 00 
0362+  0B5B 00 00 00 00 
0362+  0B5F 00 00 00 00 
0362+  0B63 00 00 00 00 
0362+  0B67 00 00 00 00 
0362+  0B6B 00 00 00 00 
0362+  0B6F 00 00 00 00 
0362+  0B73 00 00 00 00 
0362+  0B77 00 00 00 00 
0362+  0B7B 00 00 00 00 
0362+  0B7F 00 00 00 00 
0362+  0B83 00 00 00 00 
0362+  0B87 00 00 00 00 
0362+  0B8B 00 00 00 00 
0362+  0B8F 00 00 00 00 
0362+  0B93 00 00 00 00 
0362+  0B97 00 00 00 00 
0362+  0B9B 00 00 00 00 
0362+  0B9F 00 00 00 00 
0362+  0BA3 00 00 00 00 
0362+  0BA7 00 00 00 00 
0362+  0BAB 00 00 00 00 
0362+  0BAF 00 00 00 00 
0362+  0BB3 00 00 00 00 
0362+  0BB7 00 00 00 00 
0362+  0BBB 00 00 00 00 
0362+  0BBF 00 00 00 00 
0362+  0BC3 00 00 00 00 
0362+  0BC7 00 00 00 00 
0362+  0BCB 00 00 00 00 
0362+  0BCF 00 00 00 00 
0362+  0BD3 00 00 00 00 
0362+  0BD7 00 00 00 00 
0362+  0BDB 00 00 00 00 
0362+  0BDF 00 00 00 00 
0362+  0BE3 00 00 00 00 
0362+  0BE7 00 00 00 00 
0362+  0BEB 00 00 00 00 
0362+  0BEF 00 00 00 00 
0362+  0BF3 00 00 00 00 
0362+  0BF7 00 00 00 00 
0362+  0BFB 00 00 00 00 
0362+  0BFF 00 00 00 00 
0362+  0C03 00 00 00 00 
0362+  0C07 00 00 00 00 
0362+  0C0B 00 00 00 00 
0362+  0C0F 00 00 00 00 
0362+  0C13 00 00 00 00 
0362+  0C17 00 00 00 00 
0362+  0C1B 00 00 00 00 
0362+  0C1F 00 00 00 00 
0362+  0C23 00 00 00 00 
0362+  0C27 00 00 00 00 
0362+  0C2B 00 00 00 00 
0362+  0C2F 00 00 00 00 
0362+  0C33 00 00 00 00 
0362+  0C37 00 00 00 00 
1134   0C3B             
1135   0C3B             
1136   0C3B             ; kernel parameters
1137   0C3B             ; baud  divisor
1138   0C3B             ; 50    2304
1139   0C3B             ; 110   1047
1140   0C3B             ; 300    384
1141   0C3B             ; 600    192
1142   0C3B             ; 1200    96
1143   0C3B             ; 9600    12
1144   0C3B             ; 19200    6
1145   0C3B             ; 38400    3
1146   0C3B             sys_uart0_lcr:
1147   0C3B 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1148   0C3C             sys_uart0_inten:
1149   0C3C 01            .db 1
1150   0C3D             sys_uart0_fifoen:
1151   0C3D 00            .db 0
1152   0C3E             sys_uart0_div0:
1153   0C3E 03            .db 3
1154   0C3F             sys_uart0_div1:
1155   0C3F 00            .db 0   ; default baud = 38400
1156   0C40             
1157   0C40             sys_uart1_lcr:
1158   0C40 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1159   0C41             sys_uart1_inten:
1160   0C41 01            .db 1
1161   0C42             sys_uart1_fifoen:
1162   0C42 00            .db 0
1163   0C43             sys_uart1_div0:
1164   0C43 03            .db 3
1165   0C44             sys_uart1_div1:
1166   0C44 00            .db 0   ; default baud = 38400
1167   0C45             
1168   0C45             fifo_in:
1169   0C45 AB 0F         .dw fifo
1170   0C47             fifo_out:
1171   0C47 AB 0F         .dw fifo
1172   0C49             
1173   0C49             
1174   0C49             s_init_path:
1175   0C49 2F 73 62 69   .db "/sbin/init", 0
1175   0C4D 6E 2F 69 6E 
1175   0C51 69 74 00 
1176   0C54             s_uname:
1177   0C54 73 6F 6C 61   .db "solarium v.1.0", 0
1177   0C58 72 69 75 6D 
1177   0C5C 20 76 2E 31 
1177   0C60 2E 30 00 
1178   0C63             s_dataentry:
1179   0C63 3E 20 00      .db "> ", 0
1180   0C66             s_parent_dir:
1181   0C66 2E 2E 00      .db "..", 0
1182   0C69             s_current_dir:
1183   0C69 2E 00         .db ".", 0
1184   0C6B             s_fslash:
1185   0C6B 2F 00         .db "/", 0
1186   0C6D             file_attrib:
1187   0C6D 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
1187   0C71 78 
1188   0C72             file_type:
1189   0C72 2D 64 63      .db "-dc"
1190   0C75             s_ps_header:
1191   0C75 70 69 64 20   .db "pid command\n", 0
1191   0C79 63 6F 6D 6D 
1191   0C7D 61 6E 64 0A 
1191   0C81 00 
1192   0C82             s_ls_total:
1193   0C82 74 6F 74 61   .db "total: ", 0
1193   0C86 6C 3A 20 00 
1194   0C8A             
1195   0C8A             s_int_en:
1196   0C8A 69 72 71 73   .db "irqs enabled\n", 0
1196   0C8E 20 65 6E 61 
1196   0C92 62 6C 65 64 
1196   0C96 0A 00 
1197   0C98             s_kernel_welcome:
1198   0C98 2A 2A 2A 2A   .db "************************************************\n"
1198   0C9C 2A 2A 2A 2A 
1198   0CA0 2A 2A 2A 2A 
1198   0CA4 2A 2A 2A 2A 
1198   0CA8 2A 2A 2A 2A 
1198   0CAC 2A 2A 2A 2A 
1198   0CB0 2A 2A 2A 2A 
1198   0CB4 2A 2A 2A 2A 
1198   0CB8 2A 2A 2A 2A 
1198   0CBC 2A 2A 2A 2A 
1198   0CC0 2A 2A 2A 2A 
1198   0CC4 2A 2A 2A 2A 
1198   0CC8 0A 
1199   0CC9 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
1199   0CCD 57 65 6C 63 
1199   0CD1 6F 6D 65 20 
1199   0CD5 74 6F 20 53 
1199   0CD9 6F 6C 61 72 
1199   0CDD 69 75 6D 20 
1199   0CE1 4F 53 20 2D 
1199   0CE5 20 4B 65 72 
1199   0CE9 6E 65 6C 20 
1199   0CED 76 65 72 2E 
1199   0CF1 20 31 2E 30 
1199   0CF5 20 2A 2A 2A 
1199   0CF9 0A 
1200   0CFA 2A 2A 2A 20   .db "*** type help for more information           ***\n"
1200   0CFE 74 79 70 65 
1200   0D02 20 68 65 6C 
1200   0D06 70 20 66 6F 
1200   0D0A 72 20 6D 6F 
1200   0D0E 72 65 20 69 
1200   0D12 6E 66 6F 72 
1200   0D16 6D 61 74 69 
1200   0D1A 6F 6E 20 20 
1200   0D1E 20 20 20 20 
1200   0D22 20 20 20 20 
1200   0D26 20 2A 2A 2A 
1200   0D2A 0A 
1201   0D2B 2A 2A 2A 2A   .db "************************************************\n", 0
1201   0D2F 2A 2A 2A 2A 
1201   0D33 2A 2A 2A 2A 
1201   0D37 2A 2A 2A 2A 
1201   0D3B 2A 2A 2A 2A 
1201   0D3F 2A 2A 2A 2A 
1201   0D43 2A 2A 2A 2A 
1201   0D47 2A 2A 2A 2A 
1201   0D4B 2A 2A 2A 2A 
1201   0D4F 2A 2A 2A 2A 
1201   0D53 2A 2A 2A 2A 
1201   0D57 2A 2A 2A 2A 
1201   0D5B 0A 00 
1202   0D5D             s_prompt_init:
1203   0D5D 73 74 61 72   .db "starting init\n", 0
1203   0D61 74 69 6E 67 
1203   0D65 20 69 6E 69 
1203   0D69 74 0A 00 
1204   0D6C             s_priviledge:
1205   0D6C 0A 65 78 63   .db "\nexception: privilege\n", 0
1205   0D70 65 70 74 69 
1205   0D74 6F 6E 3A 20 
1205   0D78 70 72 69 76 
1205   0D7C 69 6C 65 67 
1205   0D80 65 0A 00 
1206   0D83             s_divzero:
1207   0D83 0A 65 78 63   .db "\nexception: zero division\n", 0
1207   0D87 65 70 74 69 
1207   0D8B 6F 6E 3A 20 
1207   0D8F 7A 65 72 6F 
1207   0D93 20 64 69 76 
1207   0D97 69 73 69 6F 
1207   0D9B 6E 0A 00 
1208   0D9E             
1209   0D9E             s_break1:  
1210   0D9E 0A 64 65 62   .db "\ndebugger entry point.\n"
1210   0DA2 75 67 67 65 
1210   0DA6 72 20 65 6E 
1210   0DAA 74 72 79 20 
1210   0DAE 70 6F 69 6E 
1210   0DB2 74 2E 0A 
1211   0DB5 30 2E 20 73   .db "0. show registers\n"
1211   0DB9 68 6F 77 20 
1211   0DBD 72 65 67 69 
1211   0DC1 73 74 65 72 
1211   0DC5 73 0A 
1212   0DC7 31 2E 20 73   .db "1. show 512b ram block\n"
1212   0DCB 68 6F 77 20 
1212   0DCF 35 31 32 62 
1212   0DD3 20 72 61 6D 
1212   0DD7 20 62 6C 6F 
1212   0DDB 63 6B 0A 
1213   0DDE 32 2E 20 63   .db "2. continue execution", 0
1213   0DE2 6F 6E 74 69 
1213   0DE6 6E 75 65 20 
1213   0DEA 65 78 65 63 
1213   0DEE 75 74 69 6F 
1213   0DF2 6E 00 
1214   0DF4             
1215   0DF4             s_set_year:
1216   0DF4 79 65 61 72   .db "year: ", 0
1216   0DF8 3A 20 00 
1217   0DFB             s_set_month:
1218   0DFB 6D 6F 6E 74   .db "month: ", 0
1218   0DFF 68 3A 20 00 
1219   0E03             s_set_day:
1220   0E03 64 61 79 3A   .db "day: ", 0
1220   0E07 20 00 
1221   0E09             s_set_week:
1222   0E09 77 65 65 6B   .db "weekday: ", 0
1222   0E0D 64 61 79 3A 
1222   0E11 20 00 
1223   0E13             s_set_hours:
1224   0E13 68 6F 75 72   .db "hours: ", 0
1224   0E17 73 3A 20 00 
1225   0E1B             s_set_minutes:
1226   0E1B 6D 69 6E 75   .db "minutes: ", 0
1226   0E1F 74 65 73 3A 
1226   0E23 20 00 
1227   0E25             s_set_seconds:
1228   0E25 73 65 63 6F   .db "seconds: ", 0
1228   0E29 6E 64 73 3A 
1228   0E2D 20 00 
1229   0E2F             s_months:      
1230   0E2F 20 20 20 00   .db "   ", 0
1231   0E33 6A 61 6E 00   .db "jan", 0
1232   0E37 66 65 62 00   .db "feb", 0
1233   0E3B 6D 61 72 00   .db "mar", 0
1234   0E3F 61 70 72 00   .db "apr", 0
1235   0E43 6D 61 79 00   .db "may", 0
1236   0E47 6A 75 6E 00   .db "jun", 0
1237   0E4B 6A 75 6C 00   .db "jul", 0
1238   0E4F 61 75 67 00   .db "aug", 0
1239   0E53 73 65 70 00   .db "sep", 0
1240   0E57 6F 63 74 00   .db "oct", 0
1241   0E5B 6E 6F 76 00   .db "nov", 0
1242   0E5F 64 65 63 00   .db "dec", 0
1243   0E63             
1244   0E63             s_week:        
1245   0E63 73 75 6E 00   .db "sun", 0 
1246   0E67 6D 6F 6E 00   .db "mon", 0 
1247   0E6B 74 75 65 00   .db "tue", 0 
1248   0E6F 77 65 64 00   .db "wed", 0 
1249   0E73 74 68 75 00   .db "thu", 0 
1250   0E77 66 72 69 00   .db "fri", 0 
1251   0E7B 73 61 74 00   .db "sat", 0
1252   0E7F             
1253   0E7F 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
1253   0E83 30 20 45 78 
1253   0E87 65 63 75 74 
1253   0E8B 65 64 2E 0A 
1253   0E8F 00 
1254   0E90             s_fdc_config:
1255   0E90 66 6C 6F 70   .db "floppy drive configuration:\n" 
1255   0E94 70 79 20 64 
1255   0E98 72 69 76 65 
1255   0E9C 20 63 6F 6E 
1255   0EA0 66 69 67 75 
1255   0EA4 72 61 74 69 
1255   0EA8 6F 6E 3A 0A 
1256   0EAC 20 20 64 72   .db "  drive:     0\n"
1256   0EB0 69 76 65 3A 
1256   0EB4 20 20 20 20 
1256   0EB8 20 30 0A 
1257   0EBB 20 20 73 69   .db "  side:      0\n"
1257   0EBF 64 65 3A 20 
1257   0EC3 20 20 20 20 
1257   0EC7 20 30 0A 
1258   0ECA 20 20 64 65   .db "  density:   single density\n"
1258   0ECE 6E 73 69 74 
1258   0ED2 79 3A 20 20 
1258   0ED6 20 73 69 6E 
1258   0EDA 67 6C 65 20 
1258   0EDE 64 65 6E 73 
1258   0EE2 69 74 79 0A 
1259   0EE6 20 20 68 65   .db "  head load: loaded\n", 0
1259   0EEA 61 64 20 6C 
1259   0EEE 6F 61 64 3A 
1259   0EF2 20 6C 6F 61 
1259   0EF6 64 65 64 0A 
1259   0EFA 00 
1260   0EFB             
1261   0EFB 72 65 73 65 s_reset_proc_tbl: .db "resetting process table...\n", 0
1261   0EFF 74 74 69 6E 
1261   0F03 67 20 70 72 
1261   0F07 6F 63 65 73 
1261   0F0B 73 20 74 61 
1261   0F0F 62 6C 65 2E 
1261   0F13 2E 2E 0A 00 
1262   0F17             
1263   0F17 01 00       curr_pid_max:     .dw 1
1264   0F19 00 00       curr_pid:         .dw 0  ; current process pid
1265   0F1B             
1266   0F1B             file_obj_table:   .equ $
1267   0F1B             proc_table:       .equ $ + _size_file_obj_table
1268   0F1B             
1269   0F1B             
1270   0F1B             ; here we define areas that keep transient data
1271   0F1B             ; we use '$' which is the assembler's current address pointer so that these areas are defined to be exactly
1272   0F1B             ; after all the static data has been declared
1273   0F1B             fifo:           .equ $ + _size_file_obj_table + _size_proc_table
1274   0F1B             scrap_sector:   .equ $ + _size_file_obj_table + _size_proc_table + _fifo_size
1275   0F1B             transient_area: .equ $ + _size_file_obj_table + _size_proc_table + _fifo_size + _scrap_size
1276   0F1B             
1277   0F1B             
1278   0F1B             
1279   0F1B             .end
tasm: Number of errors = 0
