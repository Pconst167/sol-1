0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_1     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 59 00       .dw int_6
0141   000E A5 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 C9 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 C1 02       .dw trap_privilege
0153   0014 DE 03       .dw trap_div_zero
0154   0016 EB 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 CD 02       .dw syscall_break
0165   0022 EC 03       .dw syscall_rtc
0166   0024 26 05       .dw syscall_ide
0167   0026 01 06       .dw syscall_io
0168   0028 BE 06       .dw syscall_file_system
0169   002A 16 10       .dw syscall_create_proc
0170   002C 86 02       .dw syscall_list_procs
0171   002E 1E 04       .dw syscall_datetime
0172   0030 42 02       .dw syscall_reboot
0173   0032 E0 0F       .dw syscall_pause_proc
0174   0034 4E 02       .dw syscall_resume_proc
0175   0036 9D 0F       .dw syscall_terminate_proc
0176   0038 0E 02       .dw syscall_system
0177   003A F0 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; irqs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" floppy drive controller irq
0220   003C             int_0_fdc:
0221   003C 3B 48 00      mov d, s_fdc_irq
0222   003F 07 1D 13      call _puts
0223   0042 06            sysret
0224   0043             int_1:
0225   0043 06            sysret
0226   0044             int_2:
0227   0044 06            sysret
0228   0045             int_3:
0229   0045 06            sysret
0230   0046             int_4:
0231   0046 06            sysret
0232   0047             int_5:
0233   0047 06            sysret
0234   0048             
0235   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0235   004C 30 20 45 78 
0235   0050 65 63 75 74 
0235   0054 65 64 2E 0A 
0235   0058 00 
0236   0059             
0237   0059             ; ------------------------------------------------------------------------------------------------------------------;
0238   0059             ; process swapping
0239   0059             ; ------------------------------------------------------------------------------------------------------------------;
0240   0059             int_6:  
0241   0059 4B            pusha                             ; save all registers into kernel stack
0242   005A 22 00         mov ah, 0
0243   005C 1D 4E 18      mov al, [active_proc_index]
0244   005F FD 99         shl a                             ; x2
0245   0061 B7 93 10      mov a, [proc_table_convert + a]   ; get process state start index
0246   0064 4F            mov di, a
0247   0065 48            mov a, sp
0248   0066 77            inc a
0249   0067 4D            mov si, a
0250   0068 38 14 00      mov c, 20
0251   006B FD F5         rep movsb                         ; save process state!
0252   006D             ; restore kernel stack position to point before interrupt arrived
0253   006D 51 14 00      add sp, 20
0254   0070             ; now load next process in queue
0255   0070 1D 4E 18      mov al, [active_proc_index]
0256   0073 31 4D 18      mov bl, [nbr_active_procs]
0257   0076 BA            cmp al, bl
0258   0077 C6 7E 00      je int6_cycle_back
0259   007A 7A            inc al                            ; next process is next in the series
0260   007B 0A 80 00      jmp int6_continue
0261   007E             int6_cycle_back:
0262   007E 19 01         mov al, 1                         ; next process = process 1
0263   0080             int6_continue:
0264   0080 3D 4E 18      mov [active_proc_index], al       ; set next active proc
0265   0083             
0266   0083             ; calculate LUT entry for next process
0267   0083 22 00         mov ah, 0
0268   0085 FD 99         shl a                             ; x2
0269   0087 B7 93 10      mov a, [proc_table_convert + a]   ; get process state start index  
0270   008A               
0271   008A 4D            mov si, a                         ; source is proc state block
0272   008B 48            mov a, sp
0273   008C 5F 13 00      sub a, 19
0274   008F 4F            mov di, a                         ; destination is kernel stack
0275   0090             ; restore SP
0276   0090 7D            dec a
0277   0091 47            mov sp, a
0278   0092 38 14 00      mov c, 20
0279   0095 FD F5         rep movsb
0280   0097             ; set vm process
0281   0097 1D 4E 18      mov al, [active_proc_index]
0282   009A 01            setptb
0283   009B F2 E0 FF 00   mov byte[_timer_c_0], 0           ; load counter 0 low byte
0284   009F F2 E0 FF 10   mov byte[_timer_c_0], $10         ; load counter 0 high byte
0285   00A3 4C            popa
0286   00A4 06            sysret
0287   00A5             
0288   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0289   00A5             ; uart0 interrupt
0290   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0291   00A5             int_7_uart0:
0292   00A5 D7            push a
0293   00A6 DA            push d
0294   00A7 E1            pushf
0295   00A8 14 53 18      mov a, [fifo_in]
0296   00AB 3C            mov d, a
0297   00AC 1D 80 FF      mov al, [_uart0_data]       ; get character
0298   00AF B9 03         cmp al, $03                 ; ctrl-c
0299   00B1 C6 CE 00      je ctrlc
0300   00B4 B9 1A         cmp al, $1a                 ; ctrl-z
0301   00B6 C6 D4 00      je ctrlz
0302   00B9 3E            mov [d], al                 ; add to fifo
0303   00BA 14 53 18      mov a, [fifo_in]
0304   00BD 77            inc a
0305   00BE AF A5 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0306   00C1 C7 C7 00      jne int_7_continue
0307   00C4 10 A5 1F      mov a, fifo  
0308   00C7             int_7_continue:  
0309   00C7 42 53 18      mov [fifo_in], a            ; update fifo pointer
0310   00CA EE            popf
0311   00CB E7            pop d
0312   00CC E4            pop a  
0313   00CD 06            sysret
0314   00CE             ctrlc:
0315   00CE 51 05 00      add sp, 5
0316   00D1 0A 9D 0F      jmp syscall_terminate_proc
0317   00D4             ctrlz:
0318   00D4 EE            popf
0319   00D5 E7            pop d
0320   00D6 E4            pop a
0321   00D7 0A E0 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0322   00DA             
0323   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0324   00DA             ; floppy drive syscalls
0325   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0326   00DA             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0327   00DA             ; fdc_40_ff:
0328   00DA             ;   .fill 40,  $ff    ; or 00                                                                                
0329   00DA             ; fdc_128_format_inner:
0330   00DA             ;   .fill 6,   $00    ;                                                                            <--|        
0331   00DA             ;   .fill 1,   $fe    ; id address mark                                                               |        
0332   00DA             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0333   00DA             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0334   00DA             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0335   00DA             ;   .fill 1,   $00    ; sector length                                                                 |                        
0336   00DA             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0337   00DA             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0338   00DA             ;   .fill 6,   $00    ;                                                                               |                        
0339   00DA             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0340   00DA             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0341   00DA             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0342   00DA             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0343   00DA             ; fdc_128_format_end:
0344   00DA             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0345   00DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0346   00DA             fdc_jmptbl:
0347   00DA F4 00         .dw syscall_fdc_restore
0348   00DC F5 00         .dw syscall_fdc_step
0349   00DE F6 00         .dw syscall_fdc_step_in
0350   00E0 F7 00         .dw syscall_fdc_step_out
0351   00E2 F8 00         .dw syscall_fdc_seek
0352   00E4 FB 00         .dw syscall_fdc_format
0353   00E6 F9 00         .dw syscall_fdc_read_addr
0354   00E8 1F 01         .dw syscall_fdc_read_track
0355   00EA 43 01         .dw syscall_fdc_read_sect
0356   00EC 6E 01         .dw syscall_fdc_write_sect
0357   00EE FA 00         .dw syscall_fdc_force_int
0358   00F0             syscall_fdc:
0359   00F0 FD 0A DA 00   jmp [fdc_jmptbl + al]
0360   00F4             
0361   00F4             syscall_fdc_restore:
0362   00F4 06            sysret
0363   00F5             syscall_fdc_step:
0364   00F5 06            sysret
0365   00F6             syscall_fdc_step_in:
0366   00F6 06            sysret
0367   00F7             syscall_fdc_step_out:
0368   00F7 06            sysret
0369   00F8             syscall_fdc_seek:
0370   00F8 06            sysret
0371   00F9             syscall_fdc_read_addr:
0372   00F9 06            sysret
0373   00FA             syscall_fdc_force_int:
0374   00FA 06            sysret
0375   00FB             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0376   00FB             ; in the ram formatting block because they are all set as 00 right now
0377   00FB             ; bl: track number
0378   00FB             syscall_fdc_format:
0379   00FB FD 3D C9 FF   mov [_fdc_track], bl
0380   00FF F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0381   0103 07 FD 01      call fdc_wait_64us
0382   0106             ;fdc_wait_busy_high:
0383   0106             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0384   0106             ;  test al, $01                ; 
0385   0106             ;  jz fdc_wait_busy_high
0386   0106 FD 4D A5 25   mov si, transient_area
0387   010A             fdc_format_drq:
0388   010A 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0389   010D 93 01         test al, $01                ; 4
0390   010F C6 1E 01      jz fdc_format_end           ; 8
0391   0112 93 02         test al, $02                ; 4
0392   0114 C6 0A 01      jz fdc_format_drq           ; 8
0393   0117 F6            lodsb                       ; 7
0394   0118 3D CB FF      mov [_fdc_data], al      ; 10   
0395   011B 0A 0A 01      jmp fdc_format_drq
0396   011E             fdc_format_end:
0397   011E 06            sysret
0398   011F             
0399   011F             syscall_fdc_read_track:
0400   011F F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0401   0123 07 FD 01      call fdc_wait_64us
0402   0126             ;fdc_wait_busy_high1:
0403   0126             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0404   0126             ;  test al, $01                    ; 
0405   0126             ;  jz fdc_wait_busy_high1
0406   0126 FD 4F A5 25   mov di, transient_area
0407   012A             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0408   012A 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0409   012D 93 01         test al, $01                ; check busy bit
0410   012F C6 3E 01      jz fdc_read_track_end
0411   0132 93 02         test al, $02                ; check drq bit
0412   0134 C6 2A 01      jz fdc_read_track_l0
0413   0137 1D CB FF      mov al, [_fdc_data]     ; 
0414   013A F7            stosb
0415   013B 0A 2A 01      jmp fdc_read_track_l0
0416   013E             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0417   013E             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0418   013E             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0419   013E             fdc_read_track_end:
0420   013E 50            mov a, di
0421   013F 5F A5 25      sub a, transient_area
0422   0142 06            sysret
0423   0143             
0424   0143             ; sector in al
0425   0143             ; track in ah
0426   0143             syscall_fdc_read_sect:
0427   0143 3D CA FF      mov [_fdc_sector], al
0428   0146 1A            mov al, ah
0429   0147 3D C9 FF      mov [_fdc_track], al
0430   014A F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0431   014E 07 FD 01      call fdc_wait_64us
0432   0151             ;fdc_wait_busy_high2:
0433   0151             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0434   0151             ;  test al, $01                ; 
0435   0151             ;  jz fdc_wait_busy_high2
0436   0151 FD 4F A5 25   mov di, transient_area
0437   0155             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0438   0155 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0439   0158 93 01         test al, $01                ; check drq bit
0440   015A C6 69 01      jz fdc_read_sect_end
0441   015D 93 02         test al, $02                ; check drq bit
0442   015F C6 55 01      jz fdc_read_sect_l0
0443   0162 1D CB FF      mov al, [_fdc_data]     ; 
0444   0165 F7            stosb
0445   0166 0A 55 01      jmp fdc_read_sect_l0
0446   0169             fdc_read_sect_end:
0447   0169 50            mov a, di
0448   016A 5F A5 25      sub a, transient_area
0449   016D 06            sysret
0450   016E             
0451   016E             ; sector in al
0452   016E             ; track in ah
0453   016E             ; data pointer in si
0454   016E             syscall_fdc_write_sect:
0455   016E 3D CA FF      mov [_fdc_sector], al
0456   0171 1A            mov al, ah
0457   0172 3D C9 FF      mov [_fdc_track], al
0458   0175 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0459   0179 07 FD 01      call fdc_wait_64us
0460   017C             ;fdc_wait_busy_high2:
0461   017C             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0462   017C             ;  test al, $01                ; 
0463   017C             ;  jz fdc_wait_busy_high2
0464   017C             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0465   017C 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0466   017F 93 01         test al, $01                ; 4
0467   0181 C6 90 01      jz fdc_write_sect_end           ; 8
0468   0184 93 02         test al, $02                ; 4
0469   0186 C6 7C 01      jz fdc_write_sect_l0           ; 8
0470   0189 F6            lodsb                       ; 7
0471   018A 3D CB FF      mov [_fdc_data], al      ; 10   
0472   018D 0A 7C 01      jmp fdc_write_sect_l0
0473   0190             fdc_write_sect_end:
0474   0190 06            sysret
0475   0191             
0476   0191             fdc_format_mem:
0477   0191 3B 01 00      mov d, 1
0478   0194 FD 4F A5 25   mov di, transient_area
0479   0198             ; 40 * FF
0480   0198 38 28 00      mov c, 40
0481   019B 19 FF         mov al, $ff
0482   019D             fdc_l0: 
0483   019D F7            stosb
0484   019E 7E            dec c
0485   019F C7 9D 01      jnz fdc_l0
0486   01A2             ; 6 * 00
0487   01A2             fdc_inner_loop:
0488   01A2 38 06 00      mov c, 6
0489   01A5 19 00         mov al, $00
0490   01A7             fdc_l1:
0491   01A7 F7            stosb
0492   01A8 7E            dec c
0493   01A9 C7 A7 01      jnz fdc_l1
0494   01AC             ; FE address mark
0495   01AC             fdc_l2:
0496   01AC 19 FE         mov al, $fe
0497   01AE F7            stosb
0498   01AF             ; track number
0499   01AF             fdc_l3:
0500   01AF 19 00         mov al, $00
0501   01B1 F7            stosb
0502   01B2             ; side number
0503   01B2             fdc_l4:
0504   01B2 19 00         mov al, $00
0505   01B4 F7            stosb
0506   01B5             ; sector number
0507   01B5             fdc_l5:
0508   01B5 13            mov a, d
0509   01B6 F7            stosb
0510   01B7             ; sector length 128 bytes
0511   01B7             fdc_l6:
0512   01B7 19 00         mov al, $00
0513   01B9 F7            stosb
0514   01BA             ; 2 crc's
0515   01BA             fdc_l7:
0516   01BA 19 F7         mov al, $f7
0517   01BC F7            stosb
0518   01BD             ; 11 times $ff
0519   01BD 38 0B 00      mov c, 11
0520   01C0 19 FF         mov al, $ff
0521   01C2             fdc_l8:
0522   01C2 F7            stosb
0523   01C3 7E            dec c
0524   01C4 C7 C2 01      jnz fdc_l8
0525   01C7             ; 6 times 00
0526   01C7 38 06 00      mov c, 6
0527   01CA 19 00         mov al, $00
0528   01CC             fdc_l9:
0529   01CC F7            stosb
0530   01CD 7E            dec c
0531   01CE C7 CC 01      jnz fdc_l9
0532   01D1             ; FB data address mark
0533   01D1 19 FB         mov al, $fb
0534   01D3             fdc_l10:
0535   01D3 F7            stosb
0536   01D4             ; 128 bytes sector data
0537   01D4 38 80 00      mov c, 128
0538   01D7 19 E5         mov al, $E5
0539   01D9             fdc_l11:
0540   01D9 F7            stosb
0541   01DA 7E            dec c
0542   01DB C7 D9 01      jnz fdc_l11
0543   01DE             ; 2 crc's
0544   01DE             fdc_l12:
0545   01DE 19 F7         mov al, $f7
0546   01E0 F7            stosb
0547   01E1             ; 10 * $FF
0548   01E1 38 0A 00      mov c, 10
0549   01E4 19 FF         mov al, $ff
0550   01E6             fdc_l13:
0551   01E6 F7            stosb
0552   01E7 7E            dec c
0553   01E8 C7 E6 01      jnz fdc_l13
0554   01EB             ; check whether we did this 16 times
0555   01EB 79            inc d
0556   01EC C5 11 00      cmp d, 17
0557   01EF C7 A2 01      jne fdc_inner_loop
0558   01F2             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0559   01F2 38 F4 01      mov c, 500
0560   01F5 19 FF         mov al, $ff
0561   01F7             fdc_format_footer:
0562   01F7             fdc_footer_drq_loop:
0563   01F7 F7            stosb
0564   01F8 7E            dec c
0565   01F9 C7 F7 01      jnz fdc_footer_drq_loop
0566   01FC 09            ret
0567   01FD             
0568   01FD             ; fetch is 2 cycles long when 'display_reg_load' is false.
0569   01FD             ; 64us amounts to 160 cycles of the 2.5mhz clock
0570   01FD             ; call u16 is 14 cycles long
0571   01FD             ; 160 - 5 - 14 = 
0572   01FD             fdc_wait_64us:
0573   01FD 3A 01         mov cl, 1                       ; 5 cycles
0574   01FF             fdc_wait_64_loop:
0575   01FF 81            dec cl                           ; 3 cycles
0576   0200 C7 FF 01      jnz fdc_wait_64_loop             ; 8 cycles
0577   0203 09            ret
0578   0204             
0579   0204             ; ------------------------------------------------------------------------------------------------------------------;
0580   0204             ; system syscalls
0581   0204             ; ------------------------------------------------------------------------------------------------------------------;
0582   0204             system_jmptbl:
0583   0204 3A 02         .dw system_uname
0584   0206 41 02         .dw system_whoami
0585   0208 14 02         .dw system_setparam
0586   020A 17 02         .dw system_bootloader_install
0587   020C 12 02         .dw system_getparam
0588   020E             syscall_system:
0589   020E FD 0A 04 02   jmp [system_jmptbl + al]
0590   0212             
0591   0212             ; param register address in register d
0592   0212             ; param value in register bl
0593   0212             system_getparam:
0594   0212 32            mov bl, [d]
0595   0213 06            sysret
0596   0214             
0597   0214             ; param register address in register d
0598   0214             ; param value in register bl
0599   0214             system_setparam:
0600   0214 FD 3E         mov [d], bl
0601   0216 06            sysret
0602   0217             
0603   0217             ; kernel LBA address in 'b'
0604   0217             system_bootloader_install:
0605   0217 D8            push b
0606   0218 26 00 00      mov b, 0
0607   021B 38 00 00      mov c, 0
0608   021E 22 01         mov ah, $01                 ; 1 sector
0609   0220 3B A5 25      mov d, transient_area
0610   0223 07 70 05      call ide_read_sect          ; read sector
0611   0226 E5            pop b
0612   0227 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0613   022B 26 00 00      mov b, 0
0614   022E 38 00 00      mov c, 0
0615   0231 22 01         mov ah, $01                 ; 1 sector
0616   0233 3B A5 25      mov d, transient_area
0617   0236 07 96 05      call ide_write_sect         ; write sector
0618   0239 06            sysret
0619   023A             
0620   023A             system_uname:
0621   023A 3B 64 18      mov d, s_uname
0622   023D 07 1D 13      call _puts
0623   0240 06            sysret
0624   0241             
0625   0241             system_whoami:
0626   0241 06            sysret
0627   0242             
0628   0242             ; reboot system
0629   0242             syscall_reboot:
0630   0242 FD D7 FF FF   push word $ffff 
0631   0246 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0632   0249 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0633   024D 06            sysret
0634   024E             
0635   024E             ;------------------------------------------------------------------------------------------------------;;
0636   024E             ; switch to another process
0637   024E             ; inputs:
0638   024E             ; al = new process number
0639   024E             ;------------------------------------------------------------------------------------------------------;;
0640   024E             syscall_resume_proc:
0641   024E FD 78         mov g, a                            ; save the process number
0642   0250 4B            pusha                               ; save all registers into kernel stack
0643   0251 22 00         mov ah, 0
0644   0253 1D 4E 18      mov al, [active_proc_index]
0645   0256 FD 99         shl a              ; x2
0646   0258 B7 93 10      mov a, [proc_table_convert + a]     ; get process state start index
0647   025B 4F            mov di, a
0648   025C 48            mov a, sp
0649   025D 77            inc a
0650   025E 4D            mov si, a
0651   025F 38 14 00      mov c, 20
0652   0262 FD F5         rep movsb                           ; save process state!
0653   0264             ; restore kernel stack position to point before interrupt arrived
0654   0264 51 14 00      add sp, 20
0655   0267             ; now load the new process number!
0656   0267 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0657   0269 3D 4E 18      mov [active_proc_index], al         ; set new active proc
0658   026C             ; calculate lut entry for next process
0659   026C 22 00         mov ah, 0
0660   026E FD 99         shl a                               ; x2
0661   0270 B7 93 10      mov a, [proc_table_convert + a]     ; get process state start index  
0662   0273 4D            mov si, a                           ; source is proc state block
0663   0274 48            mov a, sp
0664   0275 5F 13 00      sub a, 19
0665   0278 4F            mov di, a                           ; destination is kernel stack
0666   0279             ; restore sp
0667   0279 7D            dec a
0668   027A 47            mov sp, a
0669   027B 38 14 00      mov c, 20
0670   027E FD F5         rep movsb
0671   0280             ; set vm process
0672   0280 1D 4E 18      mov al, [active_proc_index]
0673   0283 01            setptb
0674   0284 4C            popa
0675   0285 06            sysret
0676   0286             
0677   0286             ;------------------------------------------------------------------------------------------------------;;
0678   0286             ; list processes
0679   0286             ;------------------------------------------------------------------------------------------------------;;
0680   0286             syscall_list_procs:
0681   0286 3B 85 18      mov d, s_ps_header
0682   0289 07 1D 13      call _puts
0683   028C 3B 16 1B      mov d, proc_availab_table + 1
0684   028F 38 01 00      mov c, 1
0685   0292             list_procs_l0:  
0686   0292 BD 01         cmp byte[d], 1
0687   0294 C7 B8 02      jne list_procs_next
0688   0297 2D            mov b, d
0689   0298 61 15 1B      sub b, proc_availab_table
0690   029B FD 9F 05      shl b, 5
0691   029E DA            push d
0692   029F D8            push b
0693   02A0 28            mov b, c
0694   02A1 07 BD 13      call print_u8x
0695   02A4 22 20         mov ah, ' '
0696   02A6 07 F1 11      call _putchar
0697   02A9 07 F1 11      call _putchar
0698   02AC E5            pop b
0699   02AD 74            mov d, b
0700   02AE 58 25 1B      add d, proc_names
0701   02B1 07 1D 13      call _puts
0702   02B4 07 CA 12      call printnl
0703   02B7 E7            pop d
0704   02B8             list_procs_next:
0705   02B8 79            inc d
0706   02B9 78            inc c
0707   02BA C2 09 00      cmp c, 9
0708   02BD C7 92 02      jne list_procs_l0
0709   02C0             list_procs_end:
0710   02C0 06            sysret
0711   02C1             
0712   02C1             ; ------------------------------------------------------------------------------------------------------------------;
0713   02C1             ; exceptions code block
0714   02C1             ; ------------------------------------------------------------------------------------------------------------------;
0715   02C1             ; privilege exception
0716   02C1             ; ------------------------------------------------------------------------------------------------------------------;
0717   02C1             trap_privilege:
0718   02C1 0A 42 02      jmp syscall_reboot
0719   02C4 DA            push d
0720   02C5 3B D4 18      mov d, s_priviledge
0721   02C8 07 1D 13      call _puts
0722   02CB E7            pop d
0723   02CC 06            sysret
0724   02CD             
0725   02CD             ; ------------------------------------------------------------------------------------------------------------------;
0726   02CD             ; breakpoint
0727   02CD             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0728   02CD             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0729   02CD             ; ------------------------------------------------------------------------------------------------------------------;
0730   02CD             syscall_break:
0731   02CD 4B            pusha
0732   02CE             syscall_break_prompt:
0733   02CE 3B 88 03      mov d, s_break1
0734   02D1 07 1D 13      call _puts
0735   02D4 07 CA 12      call printnl
0736   02D7 07 1F 14      call scan_u16d
0737   02DA AF 00 00      cmp a, 0
0738   02DD C6 E8 02      je syscall_break_regs
0739   02E0 AF 01 00      cmp a, 1
0740   02E3 C6 0B 03      je syscall_break_mem
0741   02E6             syscall_break_end:  
0742   02E6 4C            popa
0743   02E7 06            sysret
0744   02E8             syscall_break_regs:
0745   02E8 48            mov a, sp
0746   02E9 53 0E 00      add a, 14               ; back-track 7 registers
0747   02EC 3C            mov d, a
0748   02ED 3A 07         mov cl, 7
0749   02EF             syscall_regs_l0:
0750   02EF 2A            mov b, [d]
0751   02F0 FD AB         swp b
0752   02F2 07 79 13      call print_u16x         ; print register value
0753   02F5 07 CA 12      call printnl
0754   02F8 63 02 00      sub d, 2
0755   02FB 71 01         sub cl, 1
0756   02FD C3 00         cmp cl, 0
0757   02FF C7 EF 02      jne syscall_regs_l0
0758   0302 0A CE 02      jmp syscall_break_prompt
0759   0305 07 CA 12      call printnl
0760   0308 0A CE 02      jmp syscall_break_prompt
0761   030B             syscall_break_mem:
0762   030B 07 CA 12      call printnl
0763   030E 07 9B 13      call scan_u16x
0764   0311 4D            mov si, a               ; data source from user space
0765   0312 FD 4F A5 23   mov di, scrap_sector    ; destination in kernel space
0766   0316 38 00 02      mov c, 512
0767   0319 04            load                    ; transfer data to kernel space!
0768   031A 3B A5 23      mov d, scrap_sector     ; dump pointer in d
0769   031D 38 00 00      mov c, 0
0770   0320             dump_loop:
0771   0320 84            mov al, cl
0772   0321 87 0F         and al, $0f
0773   0323 C6 71 03      jz print_base
0774   0326             back:
0775   0326 1E            mov al, [d]             ; read byte
0776   0327 2F            mov bl, al
0777   0328 07 BD 13      call print_u8x
0778   032B 10 00 20      mov a, $2000
0779   032E 05 03         syscall sys_io          ; space
0780   0330 84            mov al, cl
0781   0331 87 0F         and al, $0f
0782   0333 B9 0F         cmp al, $0f
0783   0335 C6 46 03      je print_ascii
0784   0338             back1:
0785   0338 79            inc d
0786   0339 78            inc c
0787   033A C2 00 02      cmp c, 512
0788   033D C7 20 03      jne dump_loop
0789   0340 07 CA 12      call printnl
0790   0343 0A CE 02      jmp syscall_break_prompt  ; go to syscall_break return point
0791   0346             print_ascii:
0792   0346 10 00 20      mov a, $2000
0793   0349 05 03         syscall sys_io
0794   034B 63 10 00      sub d, 16
0795   034E 26 10 00      mov b, 16
0796   0351             print_ascii_l:
0797   0351 79            inc d
0798   0352 1E            mov al, [d]               ; read byte
0799   0353 B9 20         cmp al, $20
0800   0355 C8 5D 03      jlu dot
0801   0358 B9 7E         cmp al, $7e
0802   035A D0 65 03      jleu ascii
0803   035D             dot:
0804   035D 10 00 2E      mov a, $2e00
0805   0360 05 03         syscall sys_io
0806   0362 0A 6A 03      jmp ascii_continue
0807   0365             ascii:
0808   0365 23            mov ah, al
0809   0366 19 00         mov al, 0
0810   0368 05 03         syscall sys_io
0811   036A             ascii_continue:
0812   036A FD A9 51 03   loopb print_ascii_l
0813   036E 0A 38 03      jmp back1
0814   0371             print_base:
0815   0371 07 CA 12      call printnl
0816   0374 2D            mov b, d
0817   0375 61 A5 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0818   0378 07 79 13      call print_u16x          ; display row
0819   037B 10 00 3A      mov a, $3a00
0820   037E 05 03         syscall sys_io
0821   0380 10 00 20      mov a, $2000
0822   0383 05 03         syscall sys_io
0823   0385 0A 26 03      jmp back
0824   0388             
0825   0388             s_break1:  
0826   0388 0A 64 65 62   .db "\ndebugger entry point.\n"
0826   038C 75 67 67 65 
0826   0390 72 20 65 6E 
0826   0394 74 72 79 20 
0826   0398 70 6F 69 6E 
0826   039C 74 2E 0A 
0827   039F 30 2E 20 73   .db "0. show registers\n"
0827   03A3 68 6F 77 20 
0827   03A7 72 65 67 69 
0827   03AB 73 74 65 72 
0827   03AF 73 0A 
0828   03B1 31 2E 20 73   .db "1. show 512b ram block\n"
0828   03B5 68 6F 77 20 
0828   03B9 35 31 32 62 
0828   03BD 20 72 61 6D 
0828   03C1 20 62 6C 6F 
0828   03C5 63 6B 0A 
0829   03C8 32 2E 20 63   .db "2. continue execution", 0
0829   03CC 6F 6E 74 69 
0829   03D0 6E 75 65 20 
0829   03D4 65 78 65 63 
0829   03D8 75 74 69 6F 
0829   03DC 6E 00 
0830   03DE             
0831   03DE             ; ------------------------------------------------------------------------------------------------------------------;
0832   03DE             ; divide by zero exception
0833   03DE             ; ------------------------------------------------------------------------------------------------------------------;
0834   03DE             trap_div_zero:
0835   03DE D7            push a
0836   03DF DA            push d
0837   03E0 E1            pushf
0838   03E1 3B EB 18      mov d, s_divzero
0839   03E4 07 1D 13      call _puts
0840   03E7 EE            popf
0841   03E8 E7            pop d
0842   03E9 E4            pop a
0843   03EA 06            sysret ; enable interrupts
0844   03EB             
0845   03EB             ; ------------------------------------------------------------------------------------------------------------------;
0846   03EB             ; undefined opcode exception
0847   03EB             ; ------------------------------------------------------------------------------------------------------------------;
0848   03EB             trap_undef_opcode:
0849   03EB 06            sysret
0850   03EC             
0851   03EC             ; ------------------------------------------------------------------------------------------------------------------;
0852   03EC             ; real-time clock services syscall
0853   03EC             ; rtc i/o bank = ffa0 to ffaf
0854   03EC             ; ffa0 to ffa7 is scratch ram
0855   03EC             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0856   03EC             ; al = 0..6 -> get
0857   03EC             ; al = 7..d -> set
0858   03EC             ; ------------------------------------------------------------------------------------------------------------------;
0859   03EC             syscall_rtc:
0860   03EC DB            push al
0861   03ED DA            push d
0862   03EE B9 06         cmp al, 6
0863   03F0 D1 05 04      jgu syscall_rtc_set
0864   03F3             syscall_rtc_get:
0865   03F3 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0866   03F5 22 FF         mov ah, $ff    
0867   03F7 3C            mov d, a                ; get to ffa9 + offset
0868   03F8 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0869   03FC 1E            mov al, [d]             ; get data
0870   03FD F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0871   0401 23            mov ah, al
0872   0402 E7            pop d
0873   0403 E8            pop al
0874   0404 06            sysret
0875   0405             syscall_rtc_set:
0876   0405 DD            push bl
0877   0406 99            mov bl, ah              ; set data aside
0878   0407 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0879   0409 22 FF         mov ah, $ff    
0880   040B 3C            mov d, a                ; get to ffa9 + offset
0881   040C 1B            mov al, bl              ; get data back
0882   040D F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0883   0411 3E            mov [d], al             ; set data
0884   0412 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0885   0416 EA            pop bl
0886   0417 E7            pop d
0887   0418 E8            pop al
0888   0419 06            sysret
0889   041A             
0890   041A             datetime_serv_tbl:
0891   041A 22 04         .dw print_date
0892   041C 96 04         .dw set_date
0893   041E             syscall_datetime:
0894   041E FD 0A 1A 04   jmp [datetime_serv_tbl + al]      
0895   0422             print_date:
0896   0422 10 00 0D      mov a, $0d00           ; print carriage return char
0897   0425 19 03         mov al, 3
0898   0427 05 01         syscall sys_rtc        ; get week
0899   0429 1A            mov al, ah
0900   042A 22 00         mov ah, 0
0901   042C FD 9D 02      shl a, 2          
0902   042F 3B 75 19      mov d, s_week
0903   0432 59            add d, a
0904   0433 07 1D 13      call _puts
0905   0436 10 00 20      mov a, $2000
0906   0439 05 03         syscall sys_io         ; display ' '
0907   043B 19 04         mov al, 4
0908   043D 05 01         syscall sys_rtc        ; get day
0909   043F 99            mov bl, ah
0910   0440 07 BD 13      call print_u8x
0911   0443 10 00 20      mov a, $2000
0912   0446 05 03         syscall sys_io         ; display ' '
0913   0448             ; there is a problem with the month displaying
0914   0448             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0915   0448             ; even though it is to be understood as bcd.
0916   0448             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0917   0448 19 05         mov al, 05
0918   044A 05 01         syscall sys_rtc        ; get month
0919   044C 1A            mov al, ah
0920   044D 22 00         mov ah, 0
0921   044F FD 9D 02      shl a, 2          
0922   0452 3B 41 19      mov d, s_months
0923   0455 59            add d, a
0924   0456 07 1D 13      call _puts
0925   0459 10 00 20      mov a, $2000
0926   045C 05 03         syscall sys_io         ; display ' '
0927   045E 2E 20         mov bl, $20
0928   0460 07 BD 13      call print_u8x         ; print 20 for year prefix
0929   0463 19 06         mov al, 06
0930   0465 05 01         syscall sys_rtc        ; get year
0931   0467 99            mov bl, ah
0932   0468 07 BD 13      call print_u8x
0933   046B 10 00 20      mov a, $2000  
0934   046E 05 03         syscall sys_io         ; display ' '
0935   0470 19 02         mov al, 2
0936   0472 05 01         syscall sys_rtc        ; get hours
0937   0474 99            mov bl, ah
0938   0475 07 BD 13      call print_u8x
0939   0478 10 00 3A      mov a, $3a00    
0940   047B 05 03         syscall sys_io         ; display ':'
0941   047D 19 01         mov al, 01
0942   047F 05 01         syscall sys_rtc        ; get minutes
0943   0481 99            mov bl, ah
0944   0482 07 BD 13      call print_u8x
0945   0485 10 00 3A      mov a, $3a00  
0946   0488 05 03         syscall sys_io         ; display ':'
0947   048A 19 00         mov al, 0
0948   048C 05 01         syscall sys_rtc        ; get seconds
0949   048E 99            mov bl, ah
0950   048F 07 BD 13      call print_u8x
0951   0492 07 CA 12      call printnl
0952   0495 06            sysret
0953   0496             set_date:
0954   0496 3B 06 19      mov d, s_set_year
0955   0499 07 1D 13      call _puts
0956   049C 07 08 14      call scan_u8x          ; read integer into a
0957   049F FD 9D 08      shl a, 8               ; only al used, move to ah
0958   04A2 19 0D         mov al, 0dh            ; set rtc year
0959   04A4 05 01         syscall sys_rtc        ; set rtc
0960   04A6 3B 0D 19      mov d, s_set_month
0961   04A9 07 1D 13      call _puts
0962   04AC 07 08 14      call scan_u8x          ; read integer into a
0963   04AF FD 9D 08      shl a, 8               ; only al used, move to ah
0964   04B2 19 0C         mov al, 0ch            ; set rtc month
0965   04B4 05 01         syscall sys_rtc        ; set rtc
0966   04B6 3B 15 19      mov d, s_set_day
0967   04B9 07 1D 13      call _puts
0968   04BC 07 08 14      call scan_u8x          ; read integer into a
0969   04BF FD 9D 08      shl a, 8               ; only al used, move to ah
0970   04C2 19 0B         mov al, 0bh            ; set rtc month
0971   04C4 05 01         syscall sys_rtc        ; set rtc
0972   04C6 3B 1B 19      mov d, s_set_week
0973   04C9 07 1D 13      call _puts
0974   04CC 07 08 14      call scan_u8x          ; read integer into a
0975   04CF FD 9D 08      shl a, 8               ; only al used, move to ah
0976   04D2 19 0A         mov al, 0ah            ; set rtc month
0977   04D4 05 01         syscall sys_rtc        ; set rtc
0978   04D6 3B 25 19      mov d, s_set_hours
0979   04D9 07 1D 13      call _puts
0980   04DC 07 08 14      call scan_u8x          ; read integer into a
0981   04DF FD 9D 08      shl a, 8               ; only al used, move to ah
0982   04E2 19 09         mov al, 09h            ; set rtc month
0983   04E4 05 01         syscall sys_rtc        ; set rtc
0984   04E6 3B 2D 19      mov d, s_set_minutes
0985   04E9 07 1D 13      call _puts
0986   04EC 07 08 14      call scan_u8x          ; read integer into a
0987   04EF FD 9D 08      shl a, 8               ; only al used, move to ah
0988   04F2 19 08         mov al, 08h            ; set rtc month
0989   04F4 05 01         syscall sys_rtc        ; set rtc
0990   04F6 3B 37 19      mov d, s_set_seconds
0991   04F9 07 1D 13      call _puts
0992   04FC 07 08 14      call scan_u8x          ; read integer into a
0993   04FF FD 9D 08      shl a, 8               ; only al used, move to ah
0994   0502 19 07         mov al, 07h            ; set rtc month
0995   0504 05 01         syscall sys_rtc        ; set rtc
0996   0506 06            sysret
0997   0507             
0998   0507             ; ------------------------------------------------------------------------------------------------------------------;
0999   0507             ; ide services syscall
1000   0507             ; al = option
1001   0507             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1002   0507             ; ide read/write sector
1003   0507             ; 512 bytes
1004   0507             ; user buffer pointer in d
1005   0507             ; ah = number of sectors
1006   0507             ; cb = lba bytes 3..0
1007   0507             ; ------------------------------------------------------------------------------------------------------------------;
1008   0507 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
1008   050B 73 63 61 6C 
1008   050F 6C 5F 69 64 
1008   0513 65 20 63 61 
1008   0517 6C 6C 65 64 
1008   051B 3A 20 00 
1009   051E             ide_serv_tbl:
1010   051E 45 05         .dw ide_reset
1011   0520 59 05         .dw ide_sleep
1012   0522 68 05         .dw ide_read_sect_wrapper
1013   0524 6C 05         .dw ide_write_sect_wrapper
1014   0526             syscall_ide:
1015   0526 DD            push bl
1016   0527 31 46 18      mov bl, [sys_debug_mode]
1017   052A               ; debug block
1018   052A C1 00         cmp bl, 0
1019   052C EA            pop bl
1020   052D C6 41 05      je syscall_ide_jmp
1021   0530 DA            push d
1022   0531 DD            push bl
1023   0532 3B 07 05      mov d, s_syscall_ide_dbg0
1024   0535 07 1D 13      call _puts
1025   0538 2F            mov bl, al
1026   0539 07 BD 13      call print_u8x
1027   053C 07 CA 12      call printnl
1028   053F EA            pop bl
1029   0540 E7            pop d
1030   0541             syscall_ide_jmp:
1031   0541 FD 0A 1E 05   jmp [ide_serv_tbl + al]    
1032   0545               
1033   0545             ide_reset:      
1034   0545 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1035   0549 07 F2 05      call ide_wait                   ; wait for ide ready             
1036   054C F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1037   0550 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1038   0554 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1039   0558 06            sysret
1040   0559             ide_sleep:
1041   0559 07 F2 05      call ide_wait                   ; wait for ide ready             
1042   055C F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1043   0560 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1044   0564 07 F2 05      call ide_wait                   ; wait for ide ready
1045   0567 06            sysret
1046   0568             ide_read_sect_wrapper:
1047   0568 07 70 05      call ide_read_sect
1048   056B 06            sysret
1049   056C             ide_write_sect_wrapper:
1050   056C 07 96 05      call ide_write_sect
1051   056F 06            sysret
1052   0570             ide_read_sect:
1053   0570 1A            mov al, ah
1054   0571 24            mov ah, bl
1055   0572 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1056   0575 1C            mov al, bh
1057   0576 3D D4 FF      mov [_ide_r4], al
1058   0579 12            mov a, c
1059   057A 3D D5 FF      mov [_ide_r5], al
1060   057D 1A            mov al, ah
1061   057E 87 0F         and al, %00001111
1062   0580 8B E0         or al, %11100000                ; mode lba, master
1063   0582 3D D6 FF      mov [_ide_r6], al
1064   0585             ide_read_sect_wait:
1065   0585 1D D7 FF      mov al, [_ide_r7]  
1066   0588 87 80         and al, $80                     ; busy flag
1067   058A C7 85 05      jnz ide_read_sect_wait
1068   058D 19 20         mov al, $20
1069   058F 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1070   0592 07 BC 05      call ide_read  
1071   0595 09            ret
1072   0596             ide_write_sect:
1073   0596 1A            mov al, ah
1074   0597 24            mov ah, bl
1075   0598 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1076   059B 1C            mov al, bh
1077   059C 3D D4 FF      mov [_ide_r4], al
1078   059F 12            mov a, c
1079   05A0 3D D5 FF      mov [_ide_r5], al
1080   05A3 1A            mov al, ah
1081   05A4 87 0F         and al, %00001111
1082   05A6 8B E0         or al, %11100000                ; mode lba, master
1083   05A8 3D D6 FF      mov [_ide_r6], al
1084   05AB             ide_write_sect_wait:
1085   05AB 1D D7 FF      mov al, [_ide_r7]  
1086   05AE 87 80         and al, $80                     ; busy flag
1087   05B0 C7 AB 05      jnz ide_write_sect_wait
1088   05B3 19 30         mov al, $30
1089   05B5 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1090   05B8 07 D7 05      call ide_write      
1091   05BB 09            ret
1092   05BC             
1093   05BC             ;----------------------------------------------------------------------------------------------------;
1094   05BC             ; read ide data
1095   05BC             ; pointer in d
1096   05BC             ;----------------------------------------------------------------------------------------------------;
1097   05BC             ide_read:
1098   05BC DA            push d
1099   05BD             ide_read_loop:
1100   05BD 1D D7 FF      mov al, [_ide_r7]  
1101   05C0 87 80         and al, 80h                     ; busy flag
1102   05C2 C7 BD 05      jnz ide_read_loop               ; wait loop
1103   05C5 1D D7 FF      mov al, [_ide_r7]
1104   05C8 87 08         and al, %00001000               ; drq flag
1105   05CA C6 D5 05      jz ide_read_end
1106   05CD 1D D0 FF      mov al, [_ide_r0]
1107   05D0 3E            mov [d], al
1108   05D1 79            inc d
1109   05D2 0A BD 05      jmp ide_read_loop
1110   05D5             ide_read_end:
1111   05D5 E7            pop d
1112   05D6 09            ret
1113   05D7             
1114   05D7             ;----------------------------------------------------------------------------------------------------;
1115   05D7             ; write ide data
1116   05D7             ; data pointer in d
1117   05D7             ;----------------------------------------------------------------------------------------------------;
1118   05D7             ide_write:
1119   05D7 DA            push d
1120   05D8             ide_write_loop:
1121   05D8 1D D7 FF      mov al, [_ide_r7]  
1122   05DB 87 80         and al, 80h             ; busy flag
1123   05DD C7 D8 05      jnz ide_write_loop      ; wait loop
1124   05E0 1D D7 FF      mov al, [_ide_r7]
1125   05E3 87 08         and al, %00001000       ; drq flag
1126   05E5 C6 F0 05      jz ide_write_end
1127   05E8 1E            mov al, [d]
1128   05E9 3D D0 FF      mov [_ide_r0], al
1129   05EC 79            inc d 
1130   05ED 0A D8 05      jmp ide_write_loop
1131   05F0             ide_write_end:
1132   05F0 E7            pop d
1133   05F1 09            ret
1134   05F2             
1135   05F2             ;----------------------------------------------------------------------------------------------------;
1136   05F2             ; wait for ide to be ready
1137   05F2             ;----------------------------------------------------------------------------------------------------;
1138   05F2             ide_wait:
1139   05F2 1D D7 FF      mov al, [_ide_r7]  
1140   05F5 87 80         and al, 80h        ; busy flag
1141   05F7 C7 F2 05      jnz ide_wait
1142   05FA 09            ret
1143   05FB             
1144   05FB             ;----------------------------------------------------------------------------------------------------;
1145   05FB             ; io syscall
1146   05FB             ;----------------------------------------------------------------------------------------------------;
1147   05FB             ; baud  divisor
1148   05FB             ; 50    2304
1149   05FB             ; 110   1047
1150   05FB             ; 300    384
1151   05FB             ; 600    192
1152   05FB             ; 1200    96
1153   05FB             ; 9600    12
1154   05FB             ; 19200    6
1155   05FB             ; 38400    3
1156   05FB             syscall_io_jmp:
1157   05FB 2E 06         .dw syscall_io_putchar
1158   05FD 3B 06         .dw syscall_io_getch
1159   05FF 05 06         .dw syscall_io_uart_setup
1160   0601             syscall_io:
1161   0601 FD 0A FB 05   jmp [syscall_io_jmp + al]
1162   0605             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1163   0605             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1164   0605             ; buffer, the transmitter holding register, or the interrupt enable register.
1165   0605             syscall_io_uart_setup:
1166   0605 1D 48 18      mov al, [sys_uart0_lcr]
1167   0608 8B 80         or al, $80                ; set dlab access bit
1168   060A 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1169   060D 1D 4B 18      mov al, [sys_uart0_div0]
1170   0610 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1171   0613 1D 4C 18      mov al, [sys_uart0_div1]
1172   0616 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1173   0619             
1174   0619 1D 48 18      mov al, [sys_uart0_lcr]
1175   061C 87 7F         and al, $7f               ; clear dlab access bit 
1176   061E 3D 83 FF      mov [_uart0_lcr], al
1177   0621 1D 49 18      mov al, [sys_uart0_inten]
1178   0624 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1179   0627 1D 4A 18      mov al, [sys_uart0_fifoen]
1180   062A 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1181   062D 06            sysret
1182   062E             
1183   062E             ; char in ah
1184   062E             syscall_io_putchar:
1185   062E             syscall_io_putchar_l0:
1186   062E 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1187   0631 87 20         and al, $20
1188   0633 C6 2E 06      jz syscall_io_putchar_l0    
1189   0636 1A            mov al, ah
1190   0637 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1191   063A 06            sysret
1192   063B             
1193   063B             ; char in ah
1194   063B             ; al = sucess code
1195   063B             syscall_io_getch:
1196   063B D8            push b
1197   063C DA            push d
1198   063D FD 0C         sti
1199   063F             syscall_io_getch_l0:  
1200   063F 14 55 18      mov a, [fifo_out]
1201   0642 29 53 18      mov b, [fifo_in]
1202   0645 B0            cmp a, b
1203   0646 C6 3F 06      je syscall_io_getch_l0
1204   0649 3C            mov d, a
1205   064A 77            inc a
1206   064B AF A5 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1207   064E C7 54 06      jne syscall_io_getch_cont
1208   0651 10 A5 1F      mov a, fifo  
1209   0654             syscall_io_getch_cont:  
1210   0654 42 55 18      mov [fifo_out], a             ; update fifo pointer
1211   0657 1E            mov al, [d]                   ; get char
1212   0658 23            mov ah, al
1213   0659 1D 47 18      mov al, [sys_echo_on]
1214   065C B9 01         cmp al, 1
1215   065E C7 6D 06      jne syscall_io_getch_noecho 
1216   0661             ; here we just echo the char back to the console
1217   0661             syscall_io_getch_echo_l0:
1218   0661 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1219   0664 87 20         and al, $20                 ; isolate transmitter empty
1220   0666 C6 61 06      jz syscall_io_getch_echo_l0
1221   0669 1A            mov al, ah
1222   066A 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1223   066D             syscall_io_getch_noecho:
1224   066D 19 01         mov al, 1                    ; al = 1 means a char successfully received
1225   066F E7            pop d
1226   0670 E5            pop b
1227   0671 06            sysret
1228   0672             
1229   0672             ;------------------------------------------------------------------------------------------------------;
1230   0672             ; file system data
1231   0672             ;------------------------------------------------------------------------------------------------------;
1232   0672             ; infor for : ide services interrupt
1233   0672             ; ide read/write 512-byte sector
1234   0672             ; al = option
1235   0672             ; user buffer pointer in d
1236   0672             ; ah = number of sectors
1237   0672             ; cb = lba bytes 3..0  
1238   0672             ;------------------------------------------------------------------------------------------------------;
1239   0672             ; file system data structure
1240   0672             ;------------------------------------------------------------------------------------------------------;
1241   0672             ; for a directory we have the header first, followed by metadata
1242   0672             ; header 1 sector (512 bytes)
1243   0672             ; metadata 1 sector (512 bytes)
1244   0672             ; header entries:
1245   0672             ; filename (64)
1246   0672             ; parent dir lba (2) -  to be used for faster backwards navigation...
1247   0672             ;
1248   0672             ; metadata entries:
1249   0672             ; filename (24)
1250   0672             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1251   0672             ; lba (2)
1252   0672             ; size (2)
1253   0672             ; day (1)
1254   0672             ; month (1)
1255   0672             ; year (1)
1256   0672             ; packet size = 32 bytes
1257   0672             ;
1258   0672             ; first directory on disk is the root directory '/'
1259   0672             file_system_jmptbl:
1260   0672 DD 06         .dw fs_mkfs                   ; 0
1261   0674 00 00         .dw 0                         ; 1
1262   0676 3F 07         .dw fs_mkdir                  ; 2
1263   0678 B8 0A         .dw fs_cd                     ; 3
1264   067A BF 0A         .dw fs_ls                     ; 4
1265   067C 35 0C         .dw fs_mktxt                  ; 5
1266   067E 00 0D         .dw fs_mkbin                  ; 6
1267   0680 C7 0D         .dw fs_pwd                    ; 7
1268   0682 E4 0D         .dw fs_cat                    ; 8
1269   0684 40 0E         .dw fs_rmdir                  ; 9
1270   0686 9C 0E         .dw fs_rm                     ; 10
1271   0688 90 0B         .dw fs_starcom                ; 11
1272   068A 00 00         .dw 0                         ; 12
1273   068C 00 00         .dw 0                         ; 13
1274   068E E5 06         .dw fs_chmod                  ; 14
1275   0690 04 0F         .dw fs_mv                     ; 15
1276   0692 DE 06         .dw fs_cd_root                ; 16
1277   0694 B4 0A         .dw fs_get_curr_dirid         ; 17
1278   0696 90 08         .dw fs_dir_id_to_path         ; 18
1279   0698 F6 08         .dw fs_path_to_dir_id_user    ; 19
1280   069A 10 0A         .dw fs_load_from_path_user    ; 20  
1281   069C 80 09         .dw fs_filepath_exists_user   ; 21
1282   069E             
1283   069E 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1283   06A2 79 73 63 61 
1283   06A6 6C 6C 5F 66 
1283   06AA 69 6C 65 5F 
1283   06AE 73 79 73 74 
1283   06B2 65 6D 20 63 
1283   06B6 61 6C 6C 65 
1283   06BA 64 3A 20 00 
1284   06BE             syscall_file_system:
1285   06BE DD            push bl
1286   06BF 31 46 18      mov bl, [sys_debug_mode]
1287   06C2               ; debug block
1288   06C2 C1 00         cmp bl, 0
1289   06C4 EA            pop bl
1290   06C5 C6 D9 06      je syscall_filesystem_jmp
1291   06C8 DA            push d
1292   06C9 DD            push bl
1293   06CA 3B 9E 06      mov d, s_syscall_fs_dbg0
1294   06CD 07 1D 13      call _puts
1295   06D0 2F            mov bl, al
1296   06D1 07 BD 13      call print_u8x
1297   06D4 07 CA 12      call printnl
1298   06D7 EA            pop bl
1299   06D8 E7            pop d
1300   06D9             syscall_filesystem_jmp:
1301   06D9 FD 0A 72 06   jmp [file_system_jmptbl + al]
1302   06DD             
1303   06DD             fs_mkfs:  
1304   06DD 06            sysret  
1305   06DE               
1306   06DE             fs_cd_root:
1307   06DE 10 20 00      mov a, root_id
1308   06E1 42 57 18      mov [current_dir_id], a      ; set current directory lba to root
1309   06E4 06            sysret  
1310   06E5             
1311   06E5             ; filename in d (userspace data)
1312   06E5             ; permission in bl
1313   06E5             fs_chmod:
1314   06E5 DD            push bl
1315   06E6 FD 4E         mov si, d
1316   06E8 FD 4F A5 1D   mov di, user_data
1317   06EC 38 80 00      mov c, 128
1318   06EF 04            load                        ; load filename from user-space
1319   06F0 14 57 18      mov a, [current_dir_id]
1320   06F3 77            inc a                       ; metadata sector
1321   06F4 27            mov b, a
1322   06F5 38 00 00      mov c, 0                    ; upper lba = 0
1323   06F8 22 01         mov ah, $01                  ; 1 sector
1324   06FA 3B A5 25      mov d, transient_area
1325   06FD 07 70 05      call ide_read_sect          ; read directory
1326   0700 FD 10         cla
1327   0702 42 4F 18      mov [index], a              ; reset file counter
1328   0705             fs_chmod_l1:
1329   0705 FD 4E         mov si, d
1330   0707 FD 4F A5 1D   mov di, user_data
1331   070B 07 60 11      call _strcmp
1332   070E C6 25 07      je fs_chmod_found_entry
1333   0711 58 20 00      add d, 32
1334   0714 14 4F 18      mov a, [index]
1335   0717 77            inc a
1336   0718 42 4F 18      mov [index], a
1337   071B AF 10 00      cmp a, fst_files_per_dir
1338   071E C7 05 07      jne fs_chmod_l1
1339   0721 EA            pop bl
1340   0722 0A 3E 07      jmp fs_chmod_not_found
1341   0725             fs_chmod_found_entry:  
1342   0725 FD 79         mov g, b                    ; save lba
1343   0727 EA            pop bl                      ; retrieve saved permission value
1344   0728 1F 18 00      mov al, [d + 24]            ; read file permissions
1345   072B 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1346   072D 8C            or al, bl                   ; set new permissions
1347   072E 3F 18 00      mov [d + 24], al            ; write new permissions
1348   0731 38 00 00      mov c, 0
1349   0734 3B A5 25      mov d, transient_area
1350   0737 22 01         mov ah, $01                 ; disk write 1 sect
1351   0739 FD 27         mov b, g                    ; retrieve lba
1352   073B 07 96 05      call ide_write_sect         ; write sector
1353   073E             fs_chmod_not_found:
1354   073E 06            sysret
1355   073F             
1356   073F             ;------------------------------------------------------------------------------------------------------;
1357   073F             ; create new directory
1358   073F             ;------------------------------------------------------------------------------------------------------;
1359   073F             ; search list for null name entry. add new directory to list
1360   073F             fs_mkdir:
1361   073F FD 4E         mov si, d
1362   0741 FD 4F A5 1D   mov di, user_data
1363   0745 38 00 02      mov c, 512
1364   0748 04            load                        ; load data from user-space
1365   0749 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1366   074C                                           ; when checking for null name, since root has a null name)
1367   074C 38 00 00      mov c, 0                    ; upper lba = 0
1368   074F             fs_mkdir_l1:  
1369   074F 22 01         mov ah, $01                  ; 1 sector
1370   0751 3B A5 25      mov d, transient_area
1371   0754 07 70 05      call ide_read_sect          ; read sector
1372   0757 BD 00         cmp byte[d], 0              ; check for null
1373   0759 C6 62 07      je fs_mkdir_found_null
1374   075C 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1375   075F 0A 4F 07      jmp fs_mkdir_l1
1376   0762             fs_mkdir_found_null:
1377   0762             ;create header file by grabbing dir name from parameter
1378   0762 D8            push b                      ; save new directory's lba
1379   0763 38 40 00      mov c, 64
1380   0766 FD 4D A5 1D   mov si, user_data
1381   076A FD 4F A5 25   mov di, transient_area
1382   076E FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1383   0770 14 57 18      mov a, [current_dir_id]
1384   0773 42 E5 25      mov [transient_area + 64], a    ; store parent directory lba
1385   0776 19 00         mov al, 0
1386   0778 FD 4F A5 27   mov di, transient_area + 512
1387   077C 38 00 02      mov c, 512
1388   077F FD F7         rep stosb                       ; clean buffer
1389   0781 38 00 00      mov c, 0                        ; reset lba(c) to 0
1390   0784             ; write directory entry sectors
1391   0784 3B A5 25      mov d, transient_area
1392   0787 22 02         mov ah, $02                     ; disk write, 2 sectors
1393   0789 07 96 05      call ide_write_sect             ; write sector
1394   078C             ; now we need to add the new directory to the list, inside the current directory
1395   078C 14 57 18      mov a, [current_dir_id]
1396   078F 53 01 00      add a, 1
1397   0792 27            mov b, a                        ; metadata sector
1398   0793 38 00 00      mov c, 0
1399   0796 FD 79         mov g, b                        ; save lba
1400   0798 3B A5 25      mov d, transient_area
1401   079B 22 01         mov ah, $01                  ; 1 sector
1402   079D 07 70 05      call ide_read_sect              ; read metadata sector
1403   07A0             fs_mkdir_l2:
1404   07A0 BD 00         cmp byte[d], 0
1405   07A2 C6 AB 07      je fs_mkdir_found_null2
1406   07A5 58 20 00      add d, fst_entry_size
1407   07A8 0A A0 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1408   07AB             fs_mkdir_found_null2:
1409   07AB FD 4D A5 1D   mov si, user_data
1410   07AF FD 50         mov di, d
1411   07B1 07 75 11      call _strcpy                    ; copy directory name
1412   07B4 58 18 00      add d, 24                       ; goto attributes
1413   07B7 19 0B         mov al, %00001011               ; directory, no execute, write, read
1414   07B9 3E            mov [d], al      
1415   07BA 79            inc d
1416   07BB E5            pop b
1417   07BC D8            push b                          ; push lba back
1418   07BD FD 43         mov [d], b                      ; save lba
1419   07BF             ; set file creation date  
1420   07BF 58 04 00      add d, 4
1421   07C2 19 04         mov al, 4
1422   07C4 05 01         syscall sys_rtc
1423   07C6 1A            mov al, ah
1424   07C7 3E            mov [d], al                     ; set day
1425   07C8 79            inc d
1426   07C9 19 05         mov al, 5
1427   07CB 05 01         syscall sys_rtc
1428   07CD 1A            mov al, ah
1429   07CE 3E            mov [d], al                     ; set month
1430   07CF 79            inc d
1431   07D0 19 06         mov al, 6
1432   07D2 05 01         syscall sys_rtc
1433   07D4 1A            mov al, ah
1434   07D5 3E            mov [d], al                     ; set year
1435   07D6             ; write sector into disk for new directory entry
1436   07D6 FD 27         mov b, g
1437   07D8 38 00 00      mov c, 0
1438   07DB 3B A5 25      mov d, transient_area
1439   07DE 22 01         mov ah, $01                     ; disk write, 1 sector
1440   07E0 07 96 05      call ide_write_sect             ; write sector
1441   07E3             
1442   07E3             ; after adding the new directory's information to its parent directory's list
1443   07E3             ; we need to now enter the new directory, and to it add two new directories!
1444   07E3             ; which directories do we need to add ? '..' and '.' are the directories needed.
1445   07E3             ; importantly, note that these two new directories are only entries in the list
1446   07E3             ; and do not have actual physical entries in the disk as real directories.
1447   07E3             ; i.e. they only exist as list entries in the new directory created so that
1448   07E3             ; the new directory can reference its parent and itself.
1449   07E3             ; we need to add both '..' and '.'
1450   07E3             ; this first section is for '..' and on the section below we do the same for '.'
1451   07E3 E4            pop a                         ; retrieve the new directory's lba  
1452   07E4 D7            push a                        ; and save again
1453   07E5 53 01 00      add a, 1
1454   07E8 27            mov b, a                      ; metadata sector
1455   07E9 38 00 00      mov c, 0
1456   07EC FD 79         mov g, b                      ; save lba
1457   07EE 3B A5 25      mov d, transient_area
1458   07F1 22 01         mov ah, $01                  ; 1 sector
1459   07F3 07 70 05      call ide_read_sect            ; read metadata sector
1460   07F6             fs_mkdir_l3:
1461   07F6 BD 00         cmp byte[d], 0
1462   07F8 C6 01 08      je fs_mkdir_found_null3
1463   07FB 58 20 00      add d, fst_entry_size
1464   07FE 0A F6 07      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1465   0801             fs_mkdir_found_null3:
1466   0801 FD 4D 76 18   mov si, s_parent_dir
1467   0805 FD 50         mov di, d
1468   0807 07 75 11      call _strcpy                  ; copy directory name
1469   080A 58 18 00      add d, 24                     ; goto attributes
1470   080D 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1471   080F 3E            mov [d], al      
1472   0810 79            inc d
1473   0811 29 57 18      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1474   0814 FD 43         mov [d], b                    ; save lba
1475   0816             ; set file creation date  
1476   0816 58 04 00      add d, 4
1477   0819 19 04         mov al, 4
1478   081B 05 01         syscall sys_rtc
1479   081D 1A            mov al, ah
1480   081E 3E            mov [d], al                   ; set day
1481   081F 79            inc d
1482   0820 19 05         mov al, 5
1483   0822 05 01         syscall sys_rtc
1484   0824 1A            mov al, ah
1485   0825 3E            mov [d], al                   ; set month
1486   0826 79            inc d
1487   0827 19 06         mov al, 6
1488   0829 05 01         syscall sys_rtc
1489   082B 1A            mov al, ah
1490   082C 3E            mov [d], al                   ; set year
1491   082D             ; write sector into disk for new directory entry
1492   082D FD 27         mov b, g
1493   082F 38 00 00      mov c, 0
1494   0832 3B A5 25      mov d, transient_area
1495   0835 22 01         mov ah, $01                   ; disk write, 1 sector
1496   0837 07 96 05      call ide_write_sect           ; write sector
1497   083A             ;;;;;;;;;;;;;
1498   083A             ; like we did above for '..', we need to now add the '.' directory to the list.
1499   083A             ;------------------------------------------------------------------------------------------------------;
1500   083A E4            pop a                         ; retrieve the new directory's lba  
1501   083B D7            push a
1502   083C 53 01 00      add a, 1
1503   083F 27            mov b, a                      ; metadata sector
1504   0840 38 00 00      mov c, 0
1505   0843 FD 79         mov g, b                      ; save lba
1506   0845 3B A5 25      mov d, transient_area
1507   0848 22 01         mov ah, $01                  ; 1 sector
1508   084A 07 70 05      call ide_read_sect            ; read metadata sector
1509   084D             fs_mkdir_l4:
1510   084D BD 00         cmp byte[d], 0
1511   084F C6 58 08      je fs_mkdir_found_null4
1512   0852 58 20 00      add d, fst_entry_size
1513   0855 0A 4D 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1514   0858             fs_mkdir_found_null4:
1515   0858 FD 4D 79 18   mov si, s_current_dir
1516   085C FD 50         mov di, d
1517   085E 07 75 11      call _strcpy                  ; copy directory name
1518   0861 58 18 00      add d, 24                     ; goto attributes
1519   0864 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1520   0866 3E            mov [d], al      
1521   0867 79            inc d
1522   0868 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1523   0869 FD 43         mov [d], b                    ; save lba
1524   086B             ; set file creation date  
1525   086B 58 04 00      add d, 4
1526   086E 19 04         mov al, 4
1527   0870 05 01         syscall sys_rtc
1528   0872 1A            mov al, ah
1529   0873 3E            mov [d], al                   ; set day
1530   0874 79            inc d
1531   0875 19 05         mov al, 5
1532   0877 05 01         syscall sys_rtc
1533   0879 1A            mov al, ah
1534   087A 3E            mov [d], al                   ; set month
1535   087B 79            inc d
1536   087C 19 06         mov al, 6
1537   087E 05 01         syscall sys_rtc
1538   0880 1A            mov al, ah
1539   0881 3E            mov [d], al                   ; set year
1540   0882             ; write sector into disk for new directory entry
1541   0882 FD 27         mov b, g
1542   0884 38 00 00      mov c, 0
1543   0887 3B A5 25      mov d, transient_area
1544   088A 22 01         mov ah, $01                   ; disk write, 1 sector
1545   088C 07 96 05      call ide_write_sect           ; write sector
1546   088F             fs_mkdir_end:
1547   088F 06            sysret
1548   0890             
1549   0890             ;------------------------------------------------------------------------------------------------------;
1550   0890             ; get path from a given directory dirid
1551   0890             ; pseudo code:
1552   0890             ;  fs_dir_id_to_path(int dirid, char *d){
1553   0890             ;    if(dirid == 0){
1554   0890             ;      reverse path in d;
1555   0890             ;      return;
1556   0890             ;    }
1557   0890             ;    else{
1558   0890             ;      copy directory name to end of d;
1559   0890             ;      add '/' to end of d;
1560   0890             ;      parentid = get parent directory id;
1561   0890             ;      fs_dir_id_to_path(parentid, d);
1562   0890             ;    }
1563   0890             ;  }
1564   0890             ; a = dirid
1565   0890             ; d = generated path string pointer
1566   0890             ;------------------------------------------------------------------------------------------------------;
1567   0890             ; sample path: /usr/bin
1568   0890             fs_dir_id_to_path:
1569   0890 3B 25 1D      mov d, filename
1570   0893 19 00         mov al, 0
1571   0895 3E            mov [d], al                     ; initialize path string 
1572   0896 14 57 18      mov a, [current_dir_id]
1573   0899 07 A6 08      call fs_dir_id_to_path_e0
1574   089C 3B 25 1D      mov d, filename
1575   089F 07 09 11      call _strrev
1576   08A2 07 1D 13      call _puts
1577   08A5 06            sysret
1578   08A6             fs_dir_id_to_path_e0:
1579   08A6 07 C5 08      call get_dirname_from_dirid
1580   08A9 FD 4D 7B 18   mov si, s_fslash
1581   08AD FD 50         mov di, d
1582   08AF 07 83 11      call _strcat                    ; add '/' to end of path
1583   08B2 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1584   08B5 C6 C4 08      je fs_dir_id_to_path_root
1585   08B8 07 E2 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1586   08BB AF 20 00      cmp a, root_id               ; check if we are at the root directory
1587   08BE C6 C4 08      je fs_dir_id_to_path_root
1588   08C1 07 A6 08      call fs_dir_id_to_path_e0     ; recursively call itself
1589   08C4             fs_dir_id_to_path_root:
1590   08C4 09            ret
1591   08C5             
1592   08C5             ;------------------------------------------------------------------------------------------------------;
1593   08C5             ; in_puts:
1594   08C5             ; a = directory id
1595   08C5             ; out_puts:
1596   08C5             ; d = pointer to directory name string
1597   08C5             ;------------------------------------------------------------------------------------------------------;
1598   08C5             get_dirname_from_dirid:
1599   08C5 D7            push a
1600   08C6 D8            push b
1601   08C7 DA            push d
1602   08C8 27            mov b, a
1603   08C9 38 00 00      mov c, 0                      ; upper lba = 0
1604   08CC 22 01         mov ah, $01                  ; 1 sector
1605   08CE 3B A5 23      mov d, transient_area - 512
1606   08D1 07 70 05      call ide_read_sect            ; read directory
1607   08D4 07 09 11      call _strrev                  ; reverse dir name before copying
1608   08D7 FD 4E         mov si, d
1609   08D9 E7            pop d                         ; destination address = d value pushed at beginning
1610   08DA FD 50         mov di, d
1611   08DC 07 83 11      call _strcat                  ; copy filename to d
1612   08DF E5            pop b
1613   08E0 E4            pop a
1614   08E1 09            ret
1615   08E2             
1616   08E2             ;------------------------------------------------------------------------------------------------------;
1617   08E2             ; in_puts:
1618   08E2             ; a = directory id
1619   08E2             ; out_puts:
1620   08E2             ; a = parent directory id
1621   08E2             ;------------------------------------------------------------------------------------------------------;
1622   08E2             get_parentid_from_dirid:
1623   08E2 D8            push b
1624   08E3 DA            push d
1625   08E4 27            mov b, a
1626   08E5 38 00 00      mov c, 0                      ; upper lba = 0
1627   08E8 22 01         mov ah, $01                  ; 1 sector
1628   08EA 3B A5 23      mov d, transient_area - 512
1629   08ED 07 70 05      call ide_read_sect            ; read directory
1630   08F0 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1631   08F3 E7            pop d
1632   08F4 E5            pop b
1633   08F5 09            ret
1634   08F6             
1635   08F6             ;------------------------------------------------------------------------------------------------------;
1636   08F6             ; get dirid from a given path string
1637   08F6             ; in_puts:
1638   08F6             ; d = path pointer 
1639   08F6             ; out_puts:
1640   08F6             ; a = dirid
1641   08F6             ; if dir non existent, a = ffff (fail code)
1642   08F6             ; /usr/local/bin    - absolute
1643   08F6             ; local/bin/games    - relative
1644   08F6             ;------------------------------------------------------------------------------------------------------;
1645   08F6             fs_path_to_dir_id_user:
1646   08F6 FD 4E         mov si, d
1647   08F8 FD 4F A5 1D   mov di, user_data
1648   08FC 38 00 02      mov c, 512
1649   08FF 04            load
1650   0900 07 04 09      call get_dirid_from_path
1651   0903 06            sysret
1652   0904             get_dirid_from_path:
1653   0904 26 A5 1D      mov b, user_data
1654   0907 FD 42 42 17   mov [prog], b                  ; token pointer set to path string
1655   090B 07 A3 15      call get_token
1656   090E 31 45 17      mov bl, [tok]
1657   0911 C1 01         cmp bl, tok_fslash
1658   0913 C6 1F 09      je get_dirid_from_path_abs 
1659   0916 14 57 18      mov a, [current_dir_id]
1660   0919 07 29 17      call _putback
1661   091C 0A 22 09      jmp get_dirid_from_path_e0
1662   091F             get_dirid_from_path_abs:
1663   091F 10 20 00      mov a, root_id
1664   0922             get_dirid_from_path_e0:
1665   0922 07 A3 15      call get_token
1666   0925 31 44 17      mov bl, [toktyp]
1667   0928 C1 00         cmp bl, toktyp_identifier
1668   092A C7 7B 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1669   092D             
1670   092D FD 4D 46 17   mov si, tokstr
1671   0931 FD 4F 25 1D   mov di, filename
1672   0935 07 75 11      call _strcpy        
1673   0938 77            inc a                         ; metadata sector
1674   0939 27            mov b, a
1675   093A 38 00 00      mov c, 0                      ; upper lba = 0
1676   093D 22 01         mov ah, $01                  ; 1 sector
1677   093F 3B A5 25      mov d, transient_area
1678   0942 07 70 05      call ide_read_sect            ; read directory
1679   0945 FD 10         cla
1680   0947 42 4F 18      mov [index], a
1681   094A             get_dirid_from_path_l1:
1682   094A FD 4E         mov si, d
1683   094C FD 4F 25 1D   mov di, filename
1684   0950 07 60 11      call _strcmp
1685   0953 C6 69 09      je get_dirid_from_path_name_equal  
1686   0956 58 20 00      add d, 32
1687   0959 14 4F 18      mov a, [index]
1688   095C 77            inc a
1689   095D 42 4F 18      mov [index], a
1690   0960 AF 10 00      cmp a, fst_files_per_dir
1691   0963 C6 7C 09      je get_dirid_from_path_fail
1692   0966 0A 4A 09      jmp get_dirid_from_path_l1
1693   0969             get_dirid_from_path_name_equal:
1694   0969 58 19 00      add d, 25           
1695   096C 15            mov a, [d]                    ; set result register a = dirid
1696   096D 07 A3 15      call get_token
1697   0970 31 45 17      mov bl, [tok]
1698   0973 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1699   0975 C6 22 09      je get_dirid_from_path_e0
1700   0978 07 29 17      call _putback
1701   097B             get_dirid_from_path_end:
1702   097B 09            ret
1703   097C             get_dirid_from_path_fail:
1704   097C 10 FF FF      mov a, $ffff
1705   097F 09            ret
1706   0980             
1707   0980             
1708   0980             ;------------------------------------------------------------------------------------------------------;
1709   0980             ; check if file exists by a given path string
1710   0980             ; in_puts:
1711   0980             ; d = path pointer 
1712   0980             ; outputs:
1713   0980             ; a = success code, if file exists gives lba, else, give 0
1714   0980             ; /usr/local/bin/ed
1715   0980             ;------------------------------------------------------------------------------------------------------;
1716   0980             fs_filepath_exists_user:
1717   0980 FD 4E         mov si, d
1718   0982 FD 4F A5 1D   mov di, user_data
1719   0986 38 00 02      mov c, 512
1720   0989 04            load
1721   098A 07 8E 09      call file_exists_by_path
1722   098D 06            sysret
1723   098E             file_exists_by_path:
1724   098E 26 A5 1D      mov b, user_data
1725   0991 FD 42 42 17   mov [prog], b                   ; token pointer set to path string
1726   0995 07 A3 15      call get_token
1727   0998 31 45 17      mov bl, [tok]
1728   099B C1 01         cmp bl, tok_fslash
1729   099D C6 A9 09      je  file_exists_by_path_abs
1730   09A0 14 57 18      mov a, [current_dir_id]
1731   09A3 07 29 17      call _putback
1732   09A6 0A AC 09      jmp file_exists_by_path_e0
1733   09A9             file_exists_by_path_abs:
1734   09A9 10 20 00      mov a, root_id
1735   09AC             file_exists_by_path_e0:
1736   09AC 07 A3 15      call get_token
1737   09AF 31 44 17      mov bl, [toktyp]
1738   09B2 C1 00         cmp bl, toktyp_identifier
1739   09B4 C7 0C 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1740   09B7 FD 4D 46 17   mov si, tokstr
1741   09BB FD 4F 25 1D   mov di, filename
1742   09BF 07 75 11      call _strcpy        
1743   09C2 77            inc a                           ; metadata sector
1744   09C3 27            mov b, a
1745   09C4 38 00 00      mov c, 0                        ; upper lba = 0
1746   09C7 22 01         mov ah, $01                  ; 1 sector
1747   09C9 3B A5 25      mov d, transient_area
1748   09CC 07 70 05      call ide_read_sect              ; read directory
1749   09CF FD 10         cla
1750   09D1 42 4F 18      mov [index], a
1751   09D4             file_exists_by_path_l1:
1752   09D4 FD 4E         mov si, d
1753   09D6 FD 4F 25 1D   mov di, filename
1754   09DA 07 60 11      call _strcmp
1755   09DD C6 F3 09      je   file_exists_by_path_name_equal
1756   09E0 58 20 00      add d, 32
1757   09E3 14 4F 18      mov a, [index]
1758   09E6 77            inc a
1759   09E7 42 4F 18      mov [index], a
1760   09EA AF 10 00      cmp a, fst_files_per_dir
1761   09ED C6 0C 0A      je file_exists_by_path_end
1762   09F0 0A D4 09      jmp file_exists_by_path_l1
1763   09F3             file_exists_by_path_name_equal:
1764   09F3 33 18 00      mov bl, [d + 24]
1765   09F6 FD 87 38      and bl, %00111000               ; directory flag
1766   09F9 C1 08         cmp bl, %00001000               ; is dir?
1767   09FB C6 02 0A      je file_exists_by_path_isdir;
1768   09FE             ; entry is a file
1769   09FE 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1770   0A01 09            ret
1771   0A02             file_exists_by_path_isdir:
1772   0A02 58 19 00      add d, 25           
1773   0A05 15            mov a, [d]                      ; set result register a = dirid
1774   0A06 07 A3 15      call get_token
1775   0A09 0A AC 09      jmp file_exists_by_path_e0
1776   0A0C             file_exists_by_path_end:
1777   0A0C 10 00 00      mov a, 0                        ; return 0 because file was not found
1778   0A0F 09            ret
1779   0A10             
1780   0A10             ;------------------------------------------------------------------------------------------------------;
1781   0A10             ; load file data from a given path string
1782   0A10             ; inputs:
1783   0A10             ; d = path pointer 
1784   0A10             ; di = userspace program data destination
1785   0A10             ; /usr/local/bin/ed
1786   0A10             ; ./ed
1787   0A10             ;------------------------------------------------------------------------------------------------------;
1788   0A10             fs_load_from_path_user:
1789   0A10 E3            push di
1790   0A11 FD 4E         mov si, d
1791   0A13 FD 4F A5 1D   mov di, user_data
1792   0A17 38 00 02      mov c, 512
1793   0A1A 04            load
1794   0A1B 07 28 0A      call loadfile_from_path
1795   0A1E F0            pop di
1796   0A1F FD 4D A5 25   mov si, transient_area
1797   0A23 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1798   0A26 03            store
1799   0A27 06            sysret
1800   0A28             loadfile_from_path:
1801   0A28 26 A5 1D      mov b, user_data
1802   0A2B FD 42 42 17   mov [prog], b                 ; token pointer set to path string
1803   0A2F 07 A3 15      call get_token
1804   0A32 31 45 17      mov bl, [tok]
1805   0A35 C1 01         cmp bl, tok_fslash
1806   0A37 C6 43 0A      je loadfile_from_path_abs 
1807   0A3A 14 57 18      mov a, [current_dir_id]
1808   0A3D 07 29 17      call _putback
1809   0A40 0A 46 0A      jmp loadfile_from_path_e0
1810   0A43             loadfile_from_path_abs:
1811   0A43 10 20 00      mov a, root_id
1812   0A46             loadfile_from_path_e0:
1813   0A46 07 A3 15      call get_token
1814   0A49 31 44 17      mov bl, [toktyp]
1815   0A4C C1 00         cmp bl, toktyp_identifier
1816   0A4E C7 B3 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1817   0A51 FD 4D 46 17   mov si, tokstr
1818   0A55 FD 4F 25 1D   mov di, filename
1819   0A59 07 75 11      call _strcpy        
1820   0A5C 77            inc a                         ; metadata sector
1821   0A5D 27            mov b, a
1822   0A5E 38 00 00      mov c, 0                      ; upper lba = 0
1823   0A61 22 01         mov ah, $01                  ; 1 sector
1824   0A63 3B A5 25      mov d, transient_area
1825   0A66 07 70 05      call ide_read_sect            ; read directory
1826   0A69 FD 10         cla
1827   0A6B 42 4F 18      mov [index], a
1828   0A6E             loadfile_from_path_l1:
1829   0A6E FD 4E         mov si, d
1830   0A70 FD 4F 25 1D   mov di, filename
1831   0A74 07 60 11      call _strcmp
1832   0A77 C6 8D 0A      je loadfile_from_path_name_equal  
1833   0A7A 58 20 00      add d, 32
1834   0A7D 14 4F 18      mov a, [index]
1835   0A80 77            inc a
1836   0A81 42 4F 18      mov [index], a
1837   0A84 AF 10 00      cmp a, fst_files_per_dir
1838   0A87 C6 B3 0A      je loadfile_from_path_end
1839   0A8A 0A 6E 0A      jmp loadfile_from_path_l1
1840   0A8D             loadfile_from_path_name_equal:
1841   0A8D 33 18 00      mov bl, [d + 24]
1842   0A90 FD 87 38      and bl, %00111000             ; directory flag
1843   0A93 C1 08         cmp bl, %00001000             ; is dir?
1844   0A95 C6 A9 0A      je loadfile_isdirectory  
1845   0A98             ; entry is a file
1846   0A98 2B 19 00      mov b, [d + 25]               ; get lba
1847   0A9B FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1848   0A9D 3B A5 25      mov d, transient_area
1849   0AA0 38 00 00      mov c, 0
1850   0AA3 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1851   0AA5 07 70 05      call ide_read_sect            ; read sector
1852   0AA8 09            ret
1853   0AA9             loadfile_isdirectory:
1854   0AA9 58 19 00      add d, 25           
1855   0AAC 15            mov a, [d]                    ; set result register a = dirid
1856   0AAD 07 A3 15      call get_token
1857   0AB0 0A 46 0A      jmp loadfile_from_path_e0
1858   0AB3             loadfile_from_path_end:
1859   0AB3 09            ret
1860   0AB4             
1861   0AB4             ;------------------------------------------------------------------------------------------------------;
1862   0AB4             ; return the id of the current directory
1863   0AB4             ; id returned in b
1864   0AB4             ;------------------------------------------------------------------------------------------------------;
1865   0AB4             fs_get_curr_dirid:
1866   0AB4 29 57 18      mov b, [current_dir_id]
1867   0AB7 06            sysret
1868   0AB8             
1869   0AB8             ;------------------------------------------------------------------------------------------------------;
1870   0AB8             ; cd
1871   0AB8             ;------------------------------------------------------------------------------------------------------;
1872   0AB8             ; new dirid in b
1873   0AB8             fs_cd:
1874   0AB8 FD 42 57 18   mov [current_dir_id], b
1875   0ABC 06            sysret  
1876   0ABD             
1877   0ABD             ;------------------------------------------------------------------------------------------------------;
1878   0ABD             ; ls
1879   0ABD             ; dirid in b
1880   0ABD             ;------------------------------------------------------------------------------------------------------;
1881   0ABD 00 00       ls_count:       .dw 0
1882   0ABF             fs_ls:
1883   0ABF FD 77         inc b                        ; metadata sector
1884   0AC1 38 00 00      mov c, 0                     ; upper lba = 0
1885   0AC4 22 01         mov ah, $01                  ; 1 sector
1886   0AC6 3B A5 25      mov d, transient_area
1887   0AC9 07 70 05      call ide_read_sect           ; read directory
1888   0ACC FD 10         cla
1889   0ACE 42 4F 18      mov [index], a               ; reset entry index
1890   0AD1 3D BD 0A      mov [ls_count], al           ; reset item count
1891   0AD4             fs_ls_l1:
1892   0AD4 BD 00         cmp byte [d], 0              ; check for null
1893   0AD6 C6 6D 0B      je fs_ls_next
1894   0AD9             fs_ls_non_null:
1895   0AD9 1D BD 0A      mov al, [ls_count]
1896   0ADC 7A            inc al
1897   0ADD 3D BD 0A      mov [ls_count], al           ; increment item count
1898   0AE0 1F 18 00      mov al, [d + 24]
1899   0AE3 87 38         and al, %00111000
1900   0AE5 FD A2 03      shr al, 3
1901   0AE8 22 00         mov ah, 0                    ; file type
1902   0AEA B7 82 18      mov a, [a + file_type]      
1903   0AED 23            mov ah, al
1904   0AEE 07 F1 11      call _putchar
1905   0AF1 1F 18 00      mov al, [d + 24]
1906   0AF4 87 01         and al, %00000001
1907   0AF6 22 00         mov ah, 0
1908   0AF8 B7 7D 18      mov a, [a + file_attrib]     ; read
1909   0AFB 23            mov ah, al
1910   0AFC 07 F1 11      call _putchar
1911   0AFF 1F 18 00      mov al, [d + 24]
1912   0B02 87 02         and al, %00000010
1913   0B04 22 00         mov ah, 0
1914   0B06 B7 7D 18      mov a, [a + file_attrib]     ; write
1915   0B09 23            mov ah, al
1916   0B0A 07 F1 11      call _putchar
1917   0B0D 1F 18 00      mov al, [d + 24]
1918   0B10 87 04         and al, %00000100
1919   0B12 22 00         mov ah, 0
1920   0B14 B7 7D 18      mov a, [a + file_attrib]     ; execute
1921   0B17 23            mov ah, al
1922   0B18 07 F1 11      call _putchar
1923   0B1B 22 20         mov ah, $20
1924   0B1D 07 F1 11      call _putchar  
1925   0B20 2B 1B 00      mov b, [d + 27]
1926   0B23 07 79 13      call print_u16x              ; filesize
1927   0B26 22 20         mov ah, $20
1928   0B28 07 F1 11      call _putchar  
1929   0B2B 2B 19 00      mov b, [d + 25]
1930   0B2E 07 79 13      call print_u16x              ; dirid / lba
1931   0B31 22 20         mov ah, $20
1932   0B33 07 F1 11      call _putchar
1933   0B36             ; print date
1934   0B36 33 1D 00      mov bl, [d + 29]             ; day
1935   0B39 07 BD 13      call print_u8x
1936   0B3C 22 20         mov ah, $20
1937   0B3E 07 F1 11      call _putchar  
1938   0B41 1F 1E 00      mov al, [d + 30]             ; month
1939   0B44 FD 9E 02      shl al, 2
1940   0B47 DA            push d
1941   0B48 3B 41 19      mov d, s_months
1942   0B4B 22 00         mov ah, 0
1943   0B4D 59            add d, a
1944   0B4E 07 1D 13      call _puts
1945   0B51 E7            pop d
1946   0B52 22 20         mov ah, $20
1947   0B54 07 F1 11      call _putchar
1948   0B57 2E 20         mov bl, $20
1949   0B59 07 BD 13      call print_u8x
1950   0B5C 33 1F 00      mov bl, [d + 31]             ; year
1951   0B5F 07 BD 13      call print_u8x  
1952   0B62 22 20         mov ah, $20
1953   0B64 07 F1 11      call _putchar  
1954   0B67 07 1D 13      call _puts                   ; print filename  
1955   0B6A 07 CA 12      call printnl
1956   0B6D             fs_ls_next:
1957   0B6D 14 4F 18      mov a, [index]
1958   0B70 77            inc a
1959   0B71 42 4F 18      mov [index], a
1960   0B74 AF 10 00      cmp a, fst_files_per_dir
1961   0B77 C6 80 0B      je fs_ls_end
1962   0B7A 58 20 00      add d, 32      
1963   0B7D 0A D4 0A      jmp fs_ls_l1  
1964   0B80             fs_ls_end:
1965   0B80 3B 92 18      mov d, s_ls_total
1966   0B83 07 1D 13      call _puts
1967   0B86 1D BD 0A      mov al, [ls_count]
1968   0B89 07 CF 13      call print_u8d
1969   0B8C 07 CA 12      call printnl
1970   0B8F 06            sysret
1971   0B90             
1972   0B90             
1973   0B90             ;------------------------------------------------------------------------------------------------------;
1974   0B90             ; create new textfile
1975   0B90             ;------------------------------------------------------------------------------------------------------;
1976   0B90             ; file structure:
1977   0B90             ; 512 bytes header
1978   0B90             ; header used to tell whether the block is free
1979   0B90             ; d = content pointer in user space
1980   0B90             ; c = file size
1981   0B90             ; todo: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1982   0B90             fs_starcom:
1983   0B90 FD 4E       	mov si, d
1984   0B92 FD 4F A5 25 	mov di, transient_area
1985   0B96 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1986   0B99 04          	load					; load data from user-space
1987   0B9A 07 1B 0C    	call fs_find_empty_block	; look for empty data blocks
1988   0B9D D8          	push b				; save empty block lba
1989   0B9E FD 79         mov g, b
1990   0BA0             ;create header file by grabbing file name from parameter	
1991   0BA0 3B A5 27    	mov d, transient_area + 512			; pointer to file contents
1992   0BA3 D9          	push c							; save length
1993   0BA4 19 01       	mov al, 1
1994   0BA6 3D A5 25    	mov [transient_area], al					; mark sectors as used (not null)
1995   0BA9 3B A5 25    	mov d, transient_area
1996   0BAC 12            mov a, c
1997   0BAD 26 00 02      mov b, 512
1998   0BB0 AE            div a, b
1999   0BB1 FD 77         inc b         ; inc b as the division will most likely have a remainder
2000   0BB3 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
2001   0BB4 38 00 00    	mov c, 0      ; lba 
2002   0BB7 FD 27         mov b, g      ; lba 
2003   0BB9 07 96 05    	call ide_write_sect			; write sectors
2004   0BBC             ; now we add the file to the current directory!
2005   0BBC             fs_starcom_add_to_dir:	
2006   0BBC 14 57 18    	mov a, [current_dir_id]
2007   0BBF 77          	inc a
2008   0BC0 27          	mov b, a					; metadata sector
2009   0BC1 38 00 00    	mov c, 0
2010   0BC4 FD 79       	mov g, b					; save lba
2011   0BC6 3B A5 23    	mov d, scrap_sector
2012   0BC9 22 01       	mov ah, $01			  ; 1 sector
2013   0BCB 07 70 05    	call ide_read_sect		; read metadata sector
2014   0BCE             fs_starcom_add_to_dir_l2:
2015   0BCE BD 00       	cmp byte[d], 0
2016   0BD0 C6 D9 0B    	je fs_starcom_add_to_dir_null
2017   0BD3 58 20 00    	add d, fst_entry_size
2018   0BD6 0A CE 0B    	jmp fs_starcom_add_to_dir_l2		; we look for a null entry here but dont check for limits. 
2019   0BD9             fs_starcom_add_to_dir_null:
2020   0BD9 FD 4D A6 25 	mov si, transient_area + 1		; filename located after the data block 'used' marker byte
2021   0BDD FD 50       	mov di, d
2022   0BDF 07 75 11    	call _strcpy			; copy file name
2023   0BE2 58 18 00    	add d, 24			; skip name
2024   0BE5 19 07       	mov al, %00000111	; type=file, execute, write, read
2025   0BE7 3E          	mov [d], al			
2026   0BE8 58 03 00    	add d, 3
2027   0BEB E4          	pop a
2028   0BEC 5F 00 02      sub a, 512
2029   0BEF 43          	mov [d], a ; file size
2030   0BF0 63 02 00    	sub d, 2
2031   0BF3 E5          	pop b				; get file lba
2032   0BF4 FD 43       	mov [d], b			; save lba	
2033   0BF6             ; set file creation date	
2034   0BF6 58 04 00    	add d, 4
2035   0BF9 19 04       	mov al, 4
2036   0BFB 05 01       	syscall sys_rtc
2037   0BFD 1A          	mov al, ah
2038   0BFE 3E          	mov [d], al			; set day
2039   0BFF 79          	inc d
2040   0C00 19 05       	mov al, 5
2041   0C02 05 01       	syscall sys_rtc
2042   0C04 1A          	mov al, ah
2043   0C05 3E          	mov [d], al			; set month
2044   0C06 79          	inc d
2045   0C07 19 06       	mov al, 6
2046   0C09 05 01       	syscall sys_rtc
2047   0C0B 1A          	mov al, ah
2048   0C0C 3E          	mov [d], al			; set year
2049   0C0D             ; write sector into disk for new directory entry
2050   0C0D FD 27       	mov b, g
2051   0C0F 38 00 00    	mov c, 0
2052   0C12 3B A5 23    	mov d, scrap_sector
2053   0C15 22 01       	mov ah, $01			; disk write, 1 sector
2054   0C17 07 96 05    	call ide_write_sect		; write sector
2055   0C1A 06          	sysret
2056   0C1B             
2057   0C1B             ;------------------------------------------------------------------------------------------------------;
2058   0C1B             ; finds an empty data block
2059   0C1B             ; block lba returned in b
2060   0C1B             ;------------------------------------------------------------------------------------------------------;
2061   0C1B             fs_find_empty_block:
2062   0C1B 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2063   0C1E 38 00 00      mov c, 0                ; upper lba = 0
2064   0C21             fs_find_empty_block_l1:  
2065   0C21 22 01         mov ah, $01                  ; 1 sector
2066   0C23 3B A5 23      mov d, transient_area - 512
2067   0C26 07 70 05      call ide_read_sect      ; read sector
2068   0C29 BD 00         cmp byte [d], 0
2069   0C2B C6 34 0C      je fs_find_empty_block_found_null
2070   0C2E 55 20 00      add b, fs_sectors_per_file
2071   0C31 0A 21 0C      jmp fs_find_empty_block_l1
2072   0C34             fs_find_empty_block_found_null:
2073   0C34 09            ret
2074   0C35             
2075   0C35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2076   0C35             ;; create new textfile
2077   0C35             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2078   0C35             ; search for first null block
2079   0C35             fs_mktxt:
2080   0C35 FD 4E       	mov si, d
2081   0C37 FD 4F A5 1D 	mov di, user_data
2082   0C3B 38 00 01    	mov c, 256
2083   0C3E 04          	load					; load data from user-space
2084   0C3F             	
2085   0C3F 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2086   0C42 38 00 00    	mov c, 0						; reset lba to 0
2087   0C45             fs_mktxt_l1:	
2088   0C45 10 02 01    	mov a, $0102			; disk read
2089   0C48 3B A5 25    	mov d, transient_area
2090   0C4B 05 02       	syscall sys_ide ; read sector
2091   0C4D 1E          	mov al, [d]
2092   0C4E B9 00       	cmp al, 0			; check for null
2093   0C50 C6 59 0C    	je fs_mktxt_found_null
2094   0C53 55 20 00    	add b, fs_sectors_per_file
2095   0C56 0A 45 0C    	jmp fs_mktxt_l1
2096   0C59             fs_mktxt_found_null:
2097   0C59 D8          	push b				; save lba
2098   0C5A             ;create header file by grabbing file name from parameter	
2099   0C5A 3B 73 18    	mov d, s_dataentry
2100   0C5D 07 1D 13    	call _puts
2101   0C60 3B A5 27    	mov d, transient_area + 512			; pointer to file contents
2102   0C63 07 83 12    	call _gettxt
2103   0C66 07 50 11    	call _strlen						; get length of file
2104   0C69 D9          	push c							; save length
2105   0C6A 19 01       	mov al, 1
2106   0C6C 3D A5 25    	mov [transient_area], al					; mark sectors as used (not null)
2107   0C6F 10 00 00    	mov a, 0
2108   0C72 42 4F 18    	mov [index], a
2109   0C75 3B A5 25    	mov d, transient_area
2110   0C78 13          	mov a, d
2111   0C79 42 51 18    	mov [buffer_addr], a
2112   0C7C             fs_mktxt_l2:
2113   0C7C 38 00 00    	mov c, 0
2114   0C7F 10 03 01    	mov a, $0103			; disk write, 1 sector
2115   0C82 05 02       	syscall sys_ide		; write sector
2116   0C84 14 4F 18    	mov a, [index]
2117   0C87 77          	inc a
2118   0C88 42 4F 18    	mov [index], a
2119   0C8B AF 20 00    	cmp a, fs_sectors_per_file
2120   0C8E C6 A0 0C    	je fs_mktxt_add_to_dir
2121   0C91 FD 77       	inc b
2122   0C93 14 51 18    	mov a, [buffer_addr]
2123   0C96 53 00 02    	add a, 512
2124   0C99 42 51 18    	mov [buffer_addr], a
2125   0C9C 3C          	mov d, a
2126   0C9D 0A 7C 0C    	jmp fs_mktxt_l2
2127   0CA0             ; now we add the file to the current directory!
2128   0CA0             fs_mktxt_add_to_dir:	
2129   0CA0 14 57 18    	mov a, [current_dir_id]
2130   0CA3 77          	inc a
2131   0CA4 27          	mov b, a					; metadata sector
2132   0CA5 38 00 00    	mov c, 0
2133   0CA8 FD 79       	mov g, b					; save lba
2134   0CAA 3B A5 25    	mov d, transient_area
2135   0CAD 10 02 01    	mov a, $0102			; disk read
2136   0CB0 05 02       	syscall sys_ide		; read metadata sector
2137   0CB2             fs_mktxt_add_to_dir_l2:
2138   0CB2 1E          	mov al, [d]
2139   0CB3 B9 00       	cmp al, 0
2140   0CB5 C6 BE 0C    	je fs_mktxt_add_to_dir_null
2141   0CB8 58 20 00    	add d, fst_entry_size
2142   0CBB 0A B2 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2143   0CBE             fs_mktxt_add_to_dir_null:
2144   0CBE FD 4D A5 1D 	mov si, user_data
2145   0CC2 FD 50       	mov di, d
2146   0CC4 07 75 11    	call _strcpy			; copy file name
2147   0CC7 58 18 00    	add d, 24			; skip name
2148   0CCA 19 06       	mov al, %00000110		; no execute, write, read, not directory
2149   0CCC 3E          	mov [d], al			
2150   0CCD 58 03 00    	add d, 3
2151   0CD0 E4          	pop a
2152   0CD1 43          	mov [d], a
2153   0CD2 63 02 00    	sub d, 2
2154   0CD5 E5          	pop b				; get file lba
2155   0CD6 FD 43       	mov [d], b			; save lba	
2156   0CD8             	
2157   0CD8             	; set file creation date	
2158   0CD8 58 04 00    	add d, 4
2159   0CDB 19 04       	mov al, 4
2160   0CDD 05 01       	syscall sys_rtc
2161   0CDF 1A          	mov al, ah
2162   0CE0 3E          	mov [d], al			; set day
2163   0CE1             	
2164   0CE1 79          	inc d
2165   0CE2 19 05       	mov al, 5
2166   0CE4 05 01       	syscall sys_rtc
2167   0CE6 1A          	mov al, ah
2168   0CE7 3E          	mov [d], al			; set month
2169   0CE8             	
2170   0CE8 79          	inc d
2171   0CE9 19 06       	mov al, 6
2172   0CEB 05 01       	syscall sys_rtc
2173   0CED 1A          	mov al, ah
2174   0CEE 3E          	mov [d], al			; set year
2175   0CEF             	
2176   0CEF             ; write sector into disk for new directory entry
2177   0CEF FD 27       	mov b, g
2178   0CF1 38 00 00    	mov c, 0
2179   0CF4 3B A5 25    	mov d, transient_area
2180   0CF7 10 03 01    	mov a, $0103			; disk write, 1 sector
2181   0CFA 05 02       	syscall sys_ide		; write sector
2182   0CFC 07 CA 12    	call printnl
2183   0CFF 06          	sysret
2184   0D00             
2185   0D00             
2186   0D00             
2187   0D00             ;------------------------------------------------------------------------------------------------------;
2188   0D00             ; create new binary file
2189   0D00             ;------------------------------------------------------------------------------------------------------;
2190   0D00             ; search for first null block
2191   0D00             fs_mkbin:
2192   0D00 19 00         mov al, 0
2193   0D02 3D 47 18      mov [sys_echo_on], al ; disable echo
2194   0D05 FD 4E         mov si, d
2195   0D07 FD 4F A5 1D   mov di, user_data
2196   0D0B 38 00 02      mov c, 512
2197   0D0E 04            load                          ; load data from user-space
2198   0D0F 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2199   0D12 38 00 00      mov c, 0                      ; upper lba = 0
2200   0D15             fs_mkbin_l1:  
2201   0D15 22 01         mov ah, $01                  ; 1 sector
2202   0D17 3B A5 25      mov d, transient_area
2203   0D1A 07 70 05      call ide_read_sect            ; read sector
2204   0D1D BD 00         cmp byte[d], 0                ; check for null
2205   0D1F C6 28 0D      je fs_mkbin_found_null
2206   0D22 55 20 00      add b, fs_sectors_per_file
2207   0D25 0A 15 0D      jmp fs_mkbin_l1
2208   0D28             fs_mkbin_found_null:
2209   0D28 D8            push b                        ; save lba
2210   0D29             ;create header file by grabbing file name from parameter
2211   0D29 FD 4F A5 27   mov di, transient_area + 512  ; pointer to file contents
2212   0D2D 07 A3 10      call _load_hex                ; load binary hex
2213   0D30 D9            push c                        ; save size (nbr of bytes)
2214   0D31 19 01         mov al, 1
2215   0D33 3D A5 25      mov [transient_area], al      ; mark sectors as used (not null)
2216   0D36 FD 10         cla
2217   0D38 42 4F 18      mov [index], a
2218   0D3B 3B A5 25      mov d, transient_area
2219   0D3E 13            mov a, d
2220   0D3F 42 51 18      mov [buffer_addr], a
2221   0D42             fs_mkbin_l2:
2222   0D42 38 00 00      mov c, 0
2223   0D45 22 01         mov ah, $01                   ; disk write, 1 sector
2224   0D47 07 96 05      call ide_write_sect           ; write sector
2225   0D4A 14 4F 18      mov a, [index]
2226   0D4D 77            inc a
2227   0D4E 42 4F 18      mov [index], a
2228   0D51 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2229   0D54 C6 66 0D      je fs_mkbin_add_to_dir
2230   0D57 FD 77         inc b
2231   0D59 14 51 18      mov a, [buffer_addr]
2232   0D5C 53 00 02      add a, 512
2233   0D5F 42 51 18      mov [buffer_addr], a
2234   0D62 3C            mov d, a
2235   0D63 0A 42 0D      jmp fs_mkbin_l2
2236   0D66             ; now we add the file to the current directory!
2237   0D66             fs_mkbin_add_to_dir:  
2238   0D66 14 57 18      mov a, [current_dir_id]
2239   0D69 77            inc a
2240   0D6A 27            mov b, a                      ; metadata sector
2241   0D6B 38 00 00      mov c, 0
2242   0D6E FD 79         mov g, b                      ; save lba
2243   0D70 3B A5 25      mov d, transient_area
2244   0D73 22 01         mov ah, $01                  ; 1 sector
2245   0D75 07 70 05      call ide_read_sect            ; read metadata sector
2246   0D78             fs_mkbin_add_to_dir_l2:
2247   0D78 BD 00         cmp byte[d], 0
2248   0D7A C6 83 0D      je fs_mkbin_add_to_dir_null
2249   0D7D 58 20 00      add d, fst_entry_size
2250   0D80 0A 78 0D      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2251   0D83             fs_mkbin_add_to_dir_null:
2252   0D83 FD 4D A5 1D   mov si, user_data
2253   0D87 FD 50         mov di, d
2254   0D89 07 75 11      call _strcpy                  ; copy file name
2255   0D8C 58 18 00      add d, 24                     ; skip name
2256   0D8F 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2257   0D91 3E            mov [d], al
2258   0D92 58 03 00      add d, 3
2259   0D95 E4            pop a
2260   0D96 43            mov [d], a
2261   0D97 63 02 00      sub d, 2
2262   0D9A E5            pop b                         ; get file lba
2263   0D9B FD 43         mov [d], b                    ; save lba
2264   0D9D               ; set file creation date  
2265   0D9D 58 04 00      add d, 4
2266   0DA0 19 04         mov al, 4
2267   0DA2 05 01         syscall sys_rtc
2268   0DA4 1A            mov al, ah
2269   0DA5 3E            mov [d], al                   ; set day
2270   0DA6 79            inc d
2271   0DA7 19 05         mov al, 5
2272   0DA9 05 01         syscall sys_rtc
2273   0DAB 1A            mov al, ah
2274   0DAC 3E            mov [d], al                   ; set month
2275   0DAD 79            inc d
2276   0DAE 19 06         mov al, 6
2277   0DB0 05 01         syscall sys_rtc
2278   0DB2 1A            mov al, ah
2279   0DB3 3E            mov [d], al                   ; set year
2280   0DB4             ; write sector into disk for new directory entry
2281   0DB4 FD 27         mov b, g
2282   0DB6 38 00 00      mov c, 0
2283   0DB9 3B A5 25      mov d, transient_area
2284   0DBC 22 01         mov ah, $01                   ; disk write, 1 sector
2285   0DBE 07 96 05      call ide_write_sect           ; write sector
2286   0DC1 19 01         mov al, 1
2287   0DC3 3D 47 18      mov [sys_echo_on], al ; enable echo
2288   0DC6 06            sysret
2289   0DC7             
2290   0DC7             ;------------------------------------------------------------------------------------------------------;
2291   0DC7             ; pwd - print working directory
2292   0DC7             ;------------------------------------------------------------------------------------------------------;    
2293   0DC7             fs_pwd:
2294   0DC7 3B 25 1D      mov d, filename
2295   0DCA 19 00         mov al, 0
2296   0DCC 3E            mov [d], al                   ; initialize path string 
2297   0DCD 14 57 18      mov a, [current_dir_id]
2298   0DD0 07 A6 08      call fs_dir_id_to_path_e0
2299   0DD3 3B 25 1D      mov d, filename
2300   0DD6 07 09 11      call _strrev
2301   0DD9 07 1D 13      call _puts
2302   0DDC 07 CA 12      call printnl
2303   0DDF 06            sysret
2304   0DE0             
2305   0DE0             ;------------------------------------------------------------------------------------------------------;
2306   0DE0             ; get current directory lba
2307   0DE0             ; a: returned lba
2308   0DE0             ;------------------------------------------------------------------------------------------------------;
2309   0DE0             cmd_get_curr_dir_lba:
2310   0DE0 14 57 18      mov a, [current_dir_id]
2311   0DE3 06            sysret
2312   0DE4             
2313   0DE4             ;------------------------------------------------------------------------------------------------------;
2314   0DE4             ; cat
2315   0DE4             ; userspace destination data pointer in d
2316   0DE4             ; filename starts at d, but is overwritten after the read is made
2317   0DE4             ;------------------------------------------------------------------------------------------------------;:
2318   0DE4             fs_cat:
2319   0DE4 DA            push d                              ; save userspace file data destination
2320   0DE5 FD 4E         mov si, d
2321   0DE7 FD 4F A5 1D   mov di, user_data
2322   0DEB 38 00 02      mov c, 512
2323   0DEE 04            load                                ; copy filename from user-space
2324   0DEF 29 57 18      mov b, [current_dir_id]
2325   0DF2 FD 77         inc b                               ; metadata sector
2326   0DF4 38 00 00      mov c, 0                            ; upper lba = 0
2327   0DF7 22 01         mov ah, $01                  ; 1 sector
2328   0DF9 3B A5 23      mov d, transient_area-512
2329   0DFC 07 70 05      call ide_read_sect                  ; read directory
2330   0DFF FD 10         cla
2331   0E01 42 4F 18      mov [index], a                      ; reset file counter
2332   0E04             fs_cat_l1:
2333   0E04 FD 4E         mov si, d
2334   0E06 FD 4F A5 1D   mov di, user_data
2335   0E0A 07 60 11      call _strcmp
2336   0E0D C6 23 0E      je fs_cat_found_entry
2337   0E10 58 20 00      add d, 32
2338   0E13 14 4F 18      mov a, [index]
2339   0E16 77            inc a
2340   0E17 42 4F 18      mov [index], a
2341   0E1A AF 10 00      cmp a, fst_files_per_dir
2342   0E1D C6 3E 0E      je fs_cat_not_found
2343   0E20 0A 04 0E      jmp fs_cat_l1
2344   0E23             fs_cat_found_entry:
2345   0E23 58 19 00      add d, 25                           ; get to dirid of file in disk
2346   0E26 2A            mov b, [d]                          ; get lba
2347   0E27 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2348   0E29 3B A5 25      mov d, transient_area  
2349   0E2C 38 00 00      mov c, 0
2350   0E2F 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2351   0E31 07 70 05      call ide_read_sect                  ; read sectors
2352   0E34 F0            pop di                              ; write userspace file data destination to di
2353   0E35 FD 4D A5 25   mov si, transient_area              ; data origin
2354   0E39 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2355   0E3C 03            store
2356   0E3D 06            sysret
2357   0E3E             fs_cat_not_found:
2358   0E3E E7            pop d
2359   0E3F 06            sysret
2360   0E40             
2361   0E40             ;------------------------------------------------------------------------------------------------------;
2362   0E40             ; rmdir - remove dir by dirid
2363   0E40             ;------------------------------------------------------------------------------------------------------;
2364   0E40             ; deletes a directory entry in the given directory's file list 
2365   0E40             ; also deletes the actual directory entry in the fst
2366   0E40             ; synopsis: rmdir /usr/local/testdir
2367   0E40             ; b = dirid
2368   0E40             fs_rmdir:
2369   0E40 FD 79         mov g, b
2370   0E42 11            mov a, b
2371   0E43 07 E2 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2372   0E46 D7            push a                        ; save dirid
2373   0E47             ; search for directory's entry in the parent's directory then and delete it
2374   0E47 77            inc a                         ; metadata sector
2375   0E48 27            mov b, a
2376   0E49 38 00 00      mov c, 0                      ; upper lba = 0
2377   0E4C 22 01         mov ah, $01          ;
2378   0E4E 3B A5 25      mov d, transient_area
2379   0E51 07 70 05      call ide_read_sect            ; read directory
2380   0E54 FD 10         cla
2381   0E56 42 4F 18      mov [index], a                ; reset file counter
2382   0E59 FD 27         mov b, g                      ; retrieve directory's dirid
2383   0E5B             fs_rmdir_l1:
2384   0E5B 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2385   0E5E B0            cmp a, b                      ; compare dirid's to find the directory
2386   0E5F C6 75 0E      je fs_rmdir_found_entry
2387   0E62 58 20 00      add d, 32
2388   0E65 14 4F 18      mov a, [index]
2389   0E68 77            inc a
2390   0E69 42 4F 18      mov [index], a
2391   0E6C AF 10 00      cmp a, fst_files_per_dir
2392   0E6F C6 9A 0E      je fs_rmdir_not_found
2393   0E72 0A 5B 0E      jmp fs_rmdir_l1
2394   0E75             fs_rmdir_found_entry:
2395   0E75 FD 10         cla
2396   0E77 3E            mov [d], al                   ; make filename null
2397   0E78 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2398   0E7B E5            pop b
2399   0E7C FD 77         inc b                         ; metadata sector
2400   0E7E 38 00 00      mov c, 0                      ; upper lba = 0
2401   0E81 22 01         mov ah, $01          ; 
2402   0E83 3B A5 25      mov d, transient_area
2403   0E86 07 96 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2404   0E89             
2405   0E89 FD 27         mov b, g
2406   0E8B 3B A5 25      mov d, transient_area  
2407   0E8E FD 10         cla
2408   0E90 3E            mov [d], al                   ; make directory's name header null for re-use
2409   0E91 38 00 00      mov c, 0
2410   0E94 22 01         mov ah, $01                   ; disk write 1 sect
2411   0E96 07 96 05      call ide_write_sect           ; delete directory given by dirid in b
2412   0E99 06            sysret
2413   0E9A             fs_rmdir_not_found:
2414   0E9A E5            pop b
2415   0E9B 06            sysret
2416   0E9C             
2417   0E9C             ;------------------------------------------------------------------------------------------------------;
2418   0E9C             ; rm - remove file
2419   0E9C             ;------------------------------------------------------------------------------------------------------;
2420   0E9C             ; frees up the data sectors for the file further down the disk
2421   0E9C             ; deletes file entry in the directory's file list 
2422   0E9C             fs_rm:
2423   0E9C FD 4E         mov si, d
2424   0E9E FD 4F A5 1D   mov di, user_data
2425   0EA2 38 00 02      mov c, 512
2426   0EA5 04            load                          ; load data from user-space
2427   0EA6 14 57 18      mov a, [current_dir_id]
2428   0EA9 77            inc a                         ; metadata sector
2429   0EAA 27            mov b, a
2430   0EAB 38 00 00      mov c, 0                      ; upper lba = 0
2431   0EAE 22 01         mov ah, $01                  ; 1 sector
2432   0EB0 3B A5 25      mov d, transient_area
2433   0EB3 07 70 05      call ide_read_sect            ; read directory
2434   0EB6 10 00 00      mov a, 0
2435   0EB9 42 4F 18      mov [index], a                ; reset file counter
2436   0EBC             fs_rm_l1:
2437   0EBC FD 4E         mov si, d
2438   0EBE FD 4F A5 1D   mov di, user_data
2439   0EC2 07 60 11      call _strcmp
2440   0EC5 C6 DB 0E      je fs_rm_found_entry
2441   0EC8 58 20 00      add d, 32
2442   0ECB 14 4F 18      mov a, [index]
2443   0ECE 77            inc a
2444   0ECF 42 4F 18      mov [index], a
2445   0ED2 AF 10 00      cmp a, fst_files_per_dir
2446   0ED5 C6 03 0F      je fs_rm_not_found
2447   0ED8 0A BC 0E      jmp fs_rm_l1
2448   0EDB             fs_rm_found_entry:
2449   0EDB 2B 19 00      mov b, [d + 25]               ; get lba
2450   0EDE FD 79         mov g, b                      ; save lba
2451   0EE0 19 00         mov al, 0
2452   0EE2 3E            mov [d], al                   ; make file entry null
2453   0EE3 14 57 18      mov a, [current_dir_id]
2454   0EE6 77            inc a                         ; metadata sector
2455   0EE7 27            mov b, a
2456   0EE8 38 00 00      mov c, 0                      ; upper lba = 0
2457   0EEB 22 01         mov ah, $01                   ; disk write
2458   0EED 3B A5 25      mov d, transient_area
2459   0EF0 07 96 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2460   0EF3 3B A5 25      mov d, transient_area  
2461   0EF6 19 00         mov al, 0
2462   0EF8 3E            mov [d], al                   ; make file's data header null for re-use
2463   0EF9 38 00 00      mov c, 0
2464   0EFC FD 27         mov b, g                      ; get data header lba
2465   0EFE 22 01         mov ah, $01                   ; disk write 1 sect
2466   0F00 07 96 05      call ide_write_sect           ; write sector
2467   0F03             fs_rm_not_found:  
2468   0F03 06            sysret  
2469   0F04             
2470   0F04             ;------------------------------------------------------------------------------------------------------;
2471   0F04             ; mv - move / change file name
2472   0F04             ;------------------------------------------------------------------------------------------------------;
2473   0F04             fs_mv:
2474   0F04 FD 4E         mov si, d
2475   0F06 FD 4F A5 1D   mov di, user_data
2476   0F0A 38 00 02      mov c, 512
2477   0F0D 04            load                          ; load data from user-space
2478   0F0E 14 57 18      mov a, [current_dir_id]
2479   0F11 77            inc a                         ; metadata sector
2480   0F12 27            mov b, a  
2481   0F13 38 00 00      mov c, 0                      ; upper lba = 0
2482   0F16 22 01         mov ah, $01                  ; 1 sector
2483   0F18 3B A5 25      mov d, transient_area
2484   0F1B 07 70 05      call ide_read_sect            ; read directory
2485   0F1E FD 10         cla
2486   0F20 42 4F 18      mov [index], a                ; reset file counter
2487   0F23             fs_mv_l1:
2488   0F23 FD 4E         mov si, d
2489   0F25 FD 4F A5 1D   mov di, user_data
2490   0F29 07 60 11      call _strcmp
2491   0F2C C6 42 0F      je fs_mv_found_entry
2492   0F2F 58 20 00      add d, 32
2493   0F32 14 4F 18      mov a, [index]
2494   0F35 77            inc a
2495   0F36 42 4F 18      mov [index], a
2496   0F39 AF 10 00      cmp a, fst_files_per_dir
2497   0F3C C6 74 0F      je fs_mv_not_found
2498   0F3F 0A 23 0F      jmp fs_mv_l1
2499   0F42             fs_mv_found_entry:  
2500   0F42 DA            push d
2501   0F43 FD 4D 25 1E   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2502   0F47 FD 50         mov di, d
2503   0F49 07 75 11      call _strcpy  
2504   0F4C 38 00 00      mov c, 0
2505   0F4F 3B A5 25      mov d, transient_area
2506   0F52 22 01         mov ah, $01                   ; disk write 1 sect
2507   0F54 07 96 05      call ide_write_sect           ; write sector
2508   0F57 E7            pop d
2509   0F58             ;; need to check whether its a dir or a file here ;;;
2510   0F58 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2511   0F5B 22 01         mov ah, $01
2512   0F5D 3B A5 25      mov d, transient_area
2513   0F60 38 00 00      mov c, 0
2514   0F63 07 70 05      call ide_read_sect            ; read directory entry
2515   0F66 FD 4D 25 1E   mov si, user_data + 128
2516   0F6A FD 50         mov di, d
2517   0F6C 07 75 11      call _strcpy                  ; change directory's name
2518   0F6F 22 01         mov ah, $01
2519   0F71 07 96 05      call ide_write_sect           ; rewrite directory back to disk
2520   0F74             fs_mv_not_found:
2521   0F74 06            sysret
2522   0F75             
2523   0F75             
2524   0F75             ;----------------------------------------------------------------------------------------------------;
2525   0F75             ; process index in a
2526   0F75             ;----------------------------------------------------------------------------------------------------;
2527   0F75             find_free_proc:
2528   0F75 FD 4D 16 1B   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2529   0F79             find_free_proc_l0:
2530   0F79 F6            lodsb                               ; get process state
2531   0F7A B9 00         cmp al, 0
2532   0F7C C6 82 0F      je find_free_proc_free              ; if free, jump
2533   0F7F 0A 79 0F      jmp find_free_proc_l0               ; else, goto next
2534   0F82             find_free_proc_free:
2535   0F82 4E            mov a, si
2536   0F83 5F 16 1B      sub a, 1 + proc_availab_table       ; get process index
2537   0F86 09            ret
2538   0F87               
2539   0F87             
2540   0F87             ;----------------------------------------------------------------------------------------------------;
2541   0F87             ; process index in al
2542   0F87             ;----------------------------------------------------------------------------------------------------;
2543   0F87             proc_memory_map:
2544   0F87 22 00         mov ah, 0
2545   0F89 27            mov b, a                      ; page in bl, 0 in bh
2546   0F8A FD 9D 05      shl a, 5                      ; multiply by 32
2547   0F8D 39            mov c, a                      ; save in c
2548   0F8E 57 20 00      add c, 32
2549   0F91             proc_memory_map_l0:
2550   0F91 02            pagemap
2551   0F92 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2552   0F95 53 01 00      add a, 1                      ; increase both 
2553   0F98 B1            cmp a, c                      ; check to see if we reached the end of memory
2554   0F99 C7 91 0F      jne proc_memory_map_l0
2555   0F9C 09            ret
2556   0F9D               
2557   0F9D             
2558   0F9D             ;----------------------------------------------------------------------------------------------------;
2559   0F9D             ; terminate process
2560   0F9D             ;----------------------------------------------------------------------------------------------------;
2561   0F9D             syscall_terminate_proc:
2562   0F9D 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2563   0FA0                                                    ; since they will not be used for anything here.
2564   0FA0 1D 4E 18      mov al, [active_proc_index]
2565   0FA3 22 00         mov ah, 0  
2566   0FA5 FD 9D 05      shl a, 5                             ; x32
2567   0FA8 53 25 1B      add a, proc_names
2568   0FAB 3C            mov d, a
2569   0FAC 19 00         mov al, 0
2570   0FAE 3E            mov [d], al                           ; nullify process name
2571   0FAF             
2572   0FAF 1D 4E 18      mov al, [active_proc_index]
2573   0FB2 22 00         mov ah, 0  
2574   0FB4 3C            mov d, a
2575   0FB5 19 00         mov al, 0
2576   0FB7 3F 15 1B      mov [d + proc_availab_table], al    ; make process empty again
2577   0FBA               
2578   0FBA 1D 4D 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2579   0FBD 80            dec al
2580   0FBE 3D 4D 18      mov [nbr_active_procs], al
2581   0FC1             
2582   0FC1             ; now load the shell process again
2583   0FC1 19 02         mov al, 2                           ; next process = process 2 = shell
2584   0FC3 3D 4E 18      mov [active_proc_index], al         ; set next active proc
2585   0FC6             
2586   0FC6             ; calculate lut entry for next process
2587   0FC6 22 00         mov ah, 0
2588   0FC8 FD 99         shl a                               ; x2
2589   0FCA B7 93 10      mov a, [proc_table_convert + a]     ; get process state start index  
2590   0FCD               
2591   0FCD 4D            mov si, a                           ; source is proc state block
2592   0FCE 48            mov a, sp
2593   0FCF 5F 13 00      sub a, 19
2594   0FD2 4F            mov di, a                           ; destination is kernel stack
2595   0FD3             ; restore sp
2596   0FD3 7D            dec a
2597   0FD4 47            mov sp, a
2598   0FD5 38 14 00      mov c, 20
2599   0FD8 FD F5         rep movsb
2600   0FDA             ; set vm process
2601   0FDA 1D 4E 18      mov al, [active_proc_index]
2602   0FDD 01            setptb
2603   0FDE                 
2604   0FDE 4C            popa
2605   0FDF 06            sysret
2606   0FE0             
2607   0FE0             ;----------------------------------------------------------------------------------------------------;
2608   0FE0             ; pause process
2609   0FE0             ;----------------------------------------------------------------------------------------------------;
2610   0FE0             syscall_pause_proc:
2611   0FE0             ; save all registers into kernel stack
2612   0FE0 4B            pusha
2613   0FE1 22 00         mov ah, 0
2614   0FE3 1D 4E 18      mov al, [active_proc_index]
2615   0FE6 FD 99         shl a              ; x2
2616   0FE8 B7 93 10      mov a, [proc_table_convert + a]   ; get process state start index
2617   0FEB                 
2618   0FEB 4F            mov di, a
2619   0FEC 48            mov a, sp
2620   0FED 77            inc a
2621   0FEE 4D            mov si, a
2622   0FEF 38 14 00      mov c, 20
2623   0FF2 FD F5         rep movsb                         ; save process state!
2624   0FF4             ; restore kernel stack position to point before interrupt arrived
2625   0FF4 51 14 00      add sp, 20
2626   0FF7             ; now load the shell process again
2627   0FF7 19 02         mov al, 2                         ; next process = process 2 = shell
2628   0FF9 3D 4E 18      mov [active_proc_index], al       ; set next active proc
2629   0FFC             
2630   0FFC             ; calculate lut entry for next process
2631   0FFC 22 00         mov ah, 0
2632   0FFE FD 99         shl a                             ; x2
2633   1000 B7 93 10      mov a, [proc_table_convert + a]   ; get process state start index  
2634   1003               
2635   1003 4D            mov si, a                         ; source is proc state block
2636   1004 48            mov a, sp
2637   1005 5F 13 00      sub a, 19
2638   1008 4F            mov di, a                         ; destination is kernel stack
2639   1009             ; restore sp
2640   1009 7D            dec a
2641   100A 47            mov sp, a
2642   100B 38 14 00      mov c, 20
2643   100E FD F5         rep movsb
2644   1010             ; set vm process
2645   1010 1D 4E 18      mov al, [active_proc_index]
2646   1013 01            setptb
2647   1014                 
2648   1014 4C            popa
2649   1015 06            sysret
2650   1016             
2651   1016             ;----------------------------------------------------------------------------------------------------;
2652   1016             ; create a new process
2653   1016             ; d = path of the process file to be createed
2654   1016             ; b = arguments ptr
2655   1016             ;----------------------------------------------------------------------------------------------------;
2656   1016             syscall_create_proc:
2657   1016             ; we save the active process first  
2658   1016 4B            pusha
2659   1017 22 00         mov ah, 0
2660   1019 1D 4E 18      mov al, [active_proc_index]
2661   101C FD 99         shl a              ; x2
2662   101E B7 93 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2663   1021               
2664   1021 4F            mov di, a
2665   1022 48            mov a, sp
2666   1023 77            inc a
2667   1024 4D            mov si, a
2668   1025 38 14 00      mov c, 20
2669   1028 FD F5         rep movsb                          ; save process state!
2670   102A             ; restore kernel stack position to point before interrupt arrived
2671   102A 51 14 00      add sp, 20
2672   102D               
2673   102D FD 4E         mov si, d                          ; copy the file path
2674   102F FD 4F A5 1D   mov di, user_data
2675   1033 38 00 02      mov c, 512
2676   1036 04            load
2677   1037 11            mov a, b
2678   1038 4D            mov si, a                          ; copy the arguments
2679   1039 FD 4F A5 23   mov di, scrap_sector
2680   103D 38 00 02      mov c, 512
2681   1040 04            load
2682   1041 07 28 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2683   1044                                                  ; the file data is loaded into transient_area
2684   1044             ; now we allocate a new process  
2685   1044 07 75 0F      call find_free_proc                ; index in a
2686   1047 01            setptb 
2687   1048 07 87 0F      call proc_memory_map               ; map process memory pages
2688   104B             ; copy arguments into process's memory
2689   104B FD 4D A5 23   mov si, scrap_sector
2690   104F FD 4F 00 00   mov di, 0
2691   1053 38 00 02      mov c, 512
2692   1056 03            store
2693   1057             ; now copy process binary data into process's memory
2694   1057 FD 4D A5 25   mov si, transient_area
2695   105B FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2696   105F 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2697   1062 03            store                              ; copy process data
2698   1063                 
2699   1063 07 75 0F      call find_free_proc                ; index in a
2700   1066 3D 4E 18      mov [active_proc_index], al        ; set new active process
2701   1069 FD 9D 05      shl a, 5                           ; x32
2702   106C 53 25 1B      add a, proc_names
2703   106F 4F            mov di, a
2704   1070 FD 4D A5 1D   mov si, user_data                  ; copy and store process filename
2705   1074 07 75 11      call _strcpy
2706   1077               
2707   1077 07 75 0F      call find_free_proc                ; index in a
2708   107A 3C            mov d, a
2709   107B 19 01         mov al, 1
2710   107D 3F 15 1B      mov [d + proc_availab_table], al   ; make process busy
2711   1080               
2712   1080 1D 4D 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2713   1083 7A            inc al
2714   1084 3D 4D 18      mov [nbr_active_procs], al
2715   1087             ; launch process
2716   1087 FD D7 FF FF   push word $ffff 
2717   108B FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2718   108E FD D7 00 04   push word text_org
2719   1092 06            sysret
2720   1093             
2721   1093             proc_table_convert:
2722   1093 D5 19         .dw proc_state_table + 0
2723   1095 E9 19         .dw proc_state_table + 20
2724   1097 FD 19         .dw proc_state_table + 40
2725   1099 11 1A         .dw proc_state_table + 60
2726   109B 25 1A         .dw proc_state_table + 80
2727   109D 39 1A         .dw proc_state_table + 100
2728   109F 4D 1A         .dw proc_state_table + 120
2729   10A1 61 1A         .dw proc_state_table + 140
2730   10A3               
2731   10A3             ;----------------------------------------------------------------------------------------------;
2732   10A3             ; get hex file
2733   10A3             ; di = destination address
2734   10A3             ; return length in bytes in c
2735   10A3             ;----------------------------------------------------------------------------------------------;
2736   10A3             _load_hex:
2737   10A3 D7            push a
2738   10A4 D8            push b
2739   10A5 DA            push d
2740   10A6 E2            push si
2741   10A7 E3            push di
2742   10A8 38 00 00      mov c, 0
2743   10AB 50            mov a, di
2744   10AC 3C            mov d, a          ; start of string data block
2745   10AD 07 F8 11      call _gets        ; get program string
2746   10B0 4D            mov si, a
2747   10B1             __load_hex_loop:
2748   10B1 F6            lodsb             ; load from [si] to al
2749   10B2 B9 00         cmp al, 0         ; check if ascii 0
2750   10B4 C6 C2 10      jz __load_hex_ret
2751   10B7 36            mov bh, al
2752   10B8 F6            lodsb
2753   10B9 2F            mov bl, al
2754   10BA 07 AE 11      call _atoi        ; convert ascii byte in b to int (to al)
2755   10BD F7            stosb             ; store al to [di]
2756   10BE 78            inc c
2757   10BF 0A B1 10      jmp __load_hex_loop
2758   10C2             __load_hex_ret:
2759   10C2 F0            pop di
2760   10C3 EF            pop si
2761   10C4 E7            pop d
2762   10C5 E5            pop b
2763   10C6 E4            pop a
2764   10C7 09            ret
2765   10C8             
2766   10C8             ; synopsis: look inside a certain directory for files/directories
2767   10C8             ; before calling this function, cd into required directory
2768   10C8             ; for each entry inside directory:
2769   10C8             ;  if entry is a file:
2770   10C8             ;    compare filename to searched filename
2771   10C8             ;    if filenames are the same, print filename
2772   10C8             ;  else if entry is a directory:
2773   10C8             ;    cd to the given directory
2774   10C8             ;    recursively call cmd_find
2775   10C8             ;    cd outside previous directory
2776   10C8             ;  if current entry == last entry, return
2777   10C8             ; endfor
2778   10C8             f_find:
2779   10C8 09            ret
2780   10C9             
2781   10C9             
2782   10C9             ; ---------------------------------------------------------------------
2783   10C9             ; kernel reset vector
2784   10C9             ; ---------------------------------------------------------------------
2785   10C9             kernel_reset_vector:  
2786   10C9 FD 49 FF F7   mov bp, stack_begin
2787   10CD FD 47 FF F7   mov sp, stack_begin
2788   10D1               
2789   10D1 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2790   10D3 FD 0F         stomsk                        
2791   10D5 FD 0C         sti  
2792   10D7             
2793   10D7 0C            lodstat
2794   10D8 87 DF         and al, %11011111             ; disable display register loading
2795   10DA 0D            stostat
2796   10DB               
2797   10DB             ; reset fifo pointers
2798   10DB 10 A5 1F      mov a, fifo
2799   10DE 3B 53 18      mov d, fifo_in
2800   10E1 43            mov [d], a
2801   10E2 3B 55 18      mov d, fifo_out
2802   10E5 43            mov [d], a  
2803   10E6 19 02         mov al, 2
2804   10E8 05 03         syscall sys_io                ; enable uart in interrupt mode
2805   10EA             
2806   10EA 3B 91 19      mov d, s_fdc_config
2807   10ED 07 1D 13      call _puts
2808   10F0 F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2809   10F4               
2810   10F4 3B A8 18      mov d, s_kernel_started
2811   10F7 07 1D 13      call _puts
2812   10FA             
2813   10FA 19 10         mov al, 16
2814   10FC 05 04         syscall sys_filesystem        ; set root dirid
2815   10FE             
2816   10FE 3B C5 18      mov d, s_prompt_init
2817   1101 07 1D 13      call _puts
2818   1104 3B 59 18      mov d, s_init_path
2819   1107 05 05         syscall sys_create_proc       ; launch init as a new process
2820   1109             
2821   1109             
2822   1109             ; file includes
2823   1109             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1109             boot_origin      .EQU  $8004
0002+  1109             bios_uart        .EQU  $0002
0003+  1109             bios_ide         .EQU  $0003
0004+  1109             bios_reset_vector .EQU  $01c0
0005+  1109             ide_buffer       .EQU  $8204
2824   1109             .include "lib/stdio.asm"
0001+  1109             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1109             ; stdio.s
0003+  1109             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1109             .include "lib/string.asm"
0001++ 1109             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1109             ; string.s
0003++ 1109             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1109             
0005++ 1109             
0006++ 1109             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1109             ; _strrev
0008++ 1109             ; reverse a string
0009++ 1109             ; d = string address
0010++ 1109             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1109             ; 01234
0012++ 1109             _strrev:
0013++ 1109 4B          	pusha
0014++ 110A 07 50 11    	call _strlen	; length in c
0015++ 110D 12          	mov a, c
0016++ 110E AF 01 00    	cmp a, 1
0017++ 1111 D0 2B 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1114 7D          	dec a
0019++ 1115 FD 4E       	mov si, d	; beginning of string
0020++ 1117 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1119 59          	add d, a	; end of string
0022++ 111A 12          	mov a, c
0023++ 111B FD 9B       	shr a		; divide by 2
0024++ 111D 39          	mov c, a	; c now counts the steps
0025++ 111E             _strrev_l0:
0026++ 111E 32          	mov bl, [d]	; save load right-side char into bl
0027++ 111F F6          	lodsb		; load left-side char into al; increase si
0028++ 1120 3E          	mov [d], al	; store left char into right side
0029++ 1121 1B          	mov al, bl
0030++ 1122 F7          	stosb		; store right-side char into left-side; increase di
0031++ 1123 7E          	dec c
0032++ 1124 7F          	dec d
0033++ 1125 C2 00 00    	cmp c, 0
0034++ 1128 C7 1E 11    	jne _strrev_l0
0035++ 112B             _strrev_end:
0036++ 112B 4C          	popa
0037++ 112C 09          	ret
0038++ 112D             	
0039++ 112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 112D             ; _strchr
0041++ 112D             ; search string in d for char in al
0042++ 112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 112D             _strchr:
0044++ 112D             _strchr_l0:
0045++ 112D 32          	mov bl, [d]
0046++ 112E C1 00       	cmp bl, 0
0047++ 1130 C6 3B 11    	je _strchr_end
0048++ 1133 BA          	cmp al, bl
0049++ 1134 C6 3B 11    	je _strchr_end
0050++ 1137 79          	inc d
0051++ 1138 0A 2D 11    	jmp _strchr_l0
0052++ 113B             _strchr_end:
0053++ 113B 1B          	mov al, bl
0054++ 113C 09          	ret
0055++ 113D             
0056++ 113D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 113D             ; _strstr
0058++ 113D             ; find sub-string
0059++ 113D             ; str1 in si
0060++ 113D             ; str2 in di
0061++ 113D             ; si points to end of source string
0062++ 113D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 113D             _strstr:
0064++ 113D DB          	push al
0065++ 113E DA          	push d
0066++ 113F E3          	push di
0067++ 1140             _strstr_loop:
0068++ 1140 F3          	cmpsb					; compare a byte of the strings
0069++ 1141 C7 4C 11    	jne _strstr_ret
0070++ 1144 FC 00 00    	lea d, [di + 0]
0071++ 1147 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1149 C7 40 11    	jne _strstr_loop				; equal chars but not at end
0073++ 114C             _strstr_ret:
0074++ 114C F0          	pop di
0075++ 114D E7          	pop d
0076++ 114E E8          	pop al
0077++ 114F 09          	ret
0078++ 1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1150             ; length of null terminated string
0080++ 1150             ; result in c
0081++ 1150             ; pointer in d
0082++ 1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1150             _strlen:
0084++ 1150 DA          	push d
0085++ 1151 38 00 00    	mov c, 0
0086++ 1154             _strlen_l1:
0087++ 1154 BD 00       	cmp byte [d], 0
0088++ 1156 C6 5E 11    	je _strlen_ret
0089++ 1159 79          	inc d
0090++ 115A 78          	inc c
0091++ 115B 0A 54 11    	jmp _strlen_l1
0092++ 115E             _strlen_ret:
0093++ 115E E7          	pop d
0094++ 115F 09          	ret
0095++ 1160             
0096++ 1160             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1160             ; strcmp
0098++ 1160             ; compare two strings
0099++ 1160             ; str1 in si
0100++ 1160             ; str2 in di
0101++ 1160             ; create a string compairon instrucion ?????
0102++ 1160             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1160             _strcmp:
0104++ 1160 DB          	push al
0105++ 1161 DA          	push d
0106++ 1162 E3          	push di
0107++ 1163 E2          	push si
0108++ 1164             _strcmp_loop:
0109++ 1164 F3          	cmpsb					; compare a byte of the strings
0110++ 1165 C7 70 11    	jne _strcmp_ret
0111++ 1168 FB FF FF    	lea d, [si +- 1]
0112++ 116B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 116D C7 64 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1170             _strcmp_ret:
0115++ 1170 EF          	pop si
0116++ 1171 F0          	pop di
0117++ 1172 E7          	pop d
0118++ 1173 E8          	pop al
0119++ 1174 09          	ret
0120++ 1175             
0121++ 1175             
0122++ 1175             ; strcpy
0123++ 1175             ; copy null terminated string from si to di
0124++ 1175             ; source in si
0125++ 1175             ; destination in di
0126++ 1175             _strcpy:
0127++ 1175 E2          	push si
0128++ 1176 E3          	push di
0129++ 1177 DB          	push al
0130++ 1178             _strcpy_l1:
0131++ 1178 F6          	lodsb
0132++ 1179 F7          	stosb
0133++ 117A B9 00       	cmp al, 0
0134++ 117C C7 78 11    	jne _strcpy_l1
0135++ 117F             _strcpy_end:
0136++ 117F E8          	pop al
0137++ 1180 F0          	pop di
0138++ 1181 EF          	pop si
0139++ 1182 09          	ret
0140++ 1183             
0141++ 1183             ; strcat
0142++ 1183             ; concatenate a null terminated string into string at di, from string at si
0143++ 1183             ; source in si
0144++ 1183             ; destination in di
0145++ 1183             _strcat:
0146++ 1183 E2          	push si
0147++ 1184 E3          	push di
0148++ 1185 D7          	push a
0149++ 1186 DA          	push d
0150++ 1187 50          	mov a, di
0151++ 1188 3C          	mov d, a
0152++ 1189             _strcat_goto_end_l1:
0153++ 1189 BD 00       	cmp byte[d], 0
0154++ 118B C6 92 11    	je _strcat_start
0155++ 118E 79          	inc d
0156++ 118F 0A 89 11    	jmp _strcat_goto_end_l1
0157++ 1192             _strcat_start:
0158++ 1192 FD 50       	mov di, d
0159++ 1194             _strcat_l1:
0160++ 1194 F6          	lodsb
0161++ 1195 F7          	stosb
0162++ 1196 B9 00       	cmp al, 0
0163++ 1198 C7 94 11    	jne _strcat_l1
0164++ 119B             _strcat_end:
0165++ 119B E7          	pop d
0166++ 119C E4          	pop a
0167++ 119D F0          	pop di
0168++ 119E EF          	pop si
0169++ 119F 09          	ret
0170++ 11A0             
0171++ 11A0             
0005+  11A0             
0006+  11A0             
0007+  11A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  11A0             ; convert ascii 'o'..'f' to integer 0..15
0009+  11A0             ; ascii in bl
0010+  11A0             ; result in al
0011+  11A0             ; ascii for f = 0100 0110
0012+  11A0             ; ascii for 9 = 0011 1001
0013+  11A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  11A0             hex_ascii_encode:
0015+  11A0 1B            mov al, bl
0016+  11A1 93 40         test al, $40        ; test if letter or number
0017+  11A3 C7 A9 11      jnz hex_letter
0018+  11A6 87 0F         and al, $0f        ; get number
0019+  11A8 09            ret
0020+  11A9             hex_letter:
0021+  11A9 87 0F         and al, $0f        ; get letter
0022+  11AB 6A 09         add al, 9
0023+  11AD 09            ret
0024+  11AE             
0025+  11AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  11AE             ; atoi
0027+  11AE             ; 2 letter hex string in b
0028+  11AE             ; 8bit integer returned in al
0029+  11AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  11AE             _atoi:
0031+  11AE D8            push b
0032+  11AF 07 A0 11      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  11B2 30            mov bl, bh
0034+  11B3 DB            push al          ; save a
0035+  11B4 07 A0 11      call hex_ascii_encode
0036+  11B7 EA            pop bl  
0037+  11B8 FD 9E 04      shl al, 4
0038+  11BB 8C            or al, bl
0039+  11BC E5            pop b
0040+  11BD 09            ret  
0041+  11BE             
0042+  11BE             
0043+  11BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  11BE             ; scanf
0045+  11BE             ; no need for explanations!
0046+  11BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  11BE             scanf:
0048+  11BE 09            ret
0049+  11BF             
0050+  11BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  11BF             ; itoa
0052+  11BF             ; 8bit value in bl
0053+  11BF             ; 2 byte ascii result in a
0054+  11BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  11BF             _itoa:
0056+  11BF DA            push d
0057+  11C0 D8            push b
0058+  11C1 A7 00         mov bh, 0
0059+  11C3 FD A4 04      shr bl, 4  
0060+  11C6 74            mov d, b
0061+  11C7 1F 59 14      mov al, [d + s_hex_digits]
0062+  11CA 23            mov ah, al
0063+  11CB               
0064+  11CB E5            pop b
0065+  11CC D8            push b
0066+  11CD A7 00         mov bh, 0
0067+  11CF FD 87 0F      and bl, $0f
0068+  11D2 74            mov d, b
0069+  11D3 1F 59 14      mov al, [d + s_hex_digits]
0070+  11D6 E5            pop b
0071+  11D7 E7            pop d
0072+  11D8 09            ret
0073+  11D9             
0074+  11D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11D9             ; hex string to binary
0076+  11D9             ; di = destination address
0077+  11D9             ; si = source
0078+  11D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11D9             _hex_to_int:
0080+  11D9             _hex_to_int_l1:
0081+  11D9 F6            lodsb          ; load from [si] to al
0082+  11DA B9 00         cmp al, 0        ; check if ascii 0
0083+  11DC C6 E9 11      jz _hex_to_int_ret
0084+  11DF 36            mov bh, al
0085+  11E0 F6            lodsb
0086+  11E1 2F            mov bl, al
0087+  11E2 07 AE 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  11E5 F7            stosb          ; store al to [di]
0089+  11E6 0A D9 11      jmp _hex_to_int_l1
0090+  11E9             _hex_to_int_ret:
0091+  11E9 09            ret    
0092+  11EA             
0093+  11EA             
0094+  11EA             
0095+  11EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11EA             ; getchar
0097+  11EA             ; char in ah
0098+  11EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11EA             getch:
0100+  11EA DB            push al
0101+  11EB             getch_retry:
0102+  11EB 19 01         mov al, 1
0103+  11ED 05 03         syscall sys_io      ; receive in ah
0104+  11EF E8            pop al
0105+  11F0 09            ret
0106+  11F1             
0107+  11F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11F1             ; putchar
0109+  11F1             ; char in ah
0110+  11F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11F1             _putchar:
0112+  11F1 DB            push al
0113+  11F2 19 00         mov al, 0
0114+  11F4 05 03         syscall sys_io      ; char in ah
0115+  11F6 E8            pop al
0116+  11F7 09            ret
0117+  11F8             
0118+  11F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11F8             ;; input a string
0120+  11F8             ;; terminates with null
0121+  11F8             ;; pointer in d
0122+  11F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11F8             _gets:
0124+  11F8 D7            push a
0125+  11F9 DA            push d
0126+  11FA             _gets_loop:
0127+  11FA 19 01         mov al, 1
0128+  11FC 05 03         syscall sys_io      ; receive in ah
0129+  11FE 76 1B         cmp ah, 27
0130+  1200 C6 21 12      je _gets_ansi_esc
0131+  1203 76 0A         cmp ah, $0a        ; lf
0132+  1205 C6 7D 12      je _gets_end
0133+  1208 76 0D         cmp ah, $0d        ; cr
0134+  120A C6 7D 12      je _gets_end
0135+  120D 76 5C         cmp ah, $5c        ; '\\'
0136+  120F C6 43 12      je _gets_escape
0137+  1212 76 08         cmp ah, $08      ; check for backspace
0138+  1214 C6 1D 12      je _gets_backspace
0139+  1217 1A            mov al, ah
0140+  1218 3E            mov [d], al
0141+  1219 79            inc d
0142+  121A 0A FA 11      jmp _gets_loop
0143+  121D             _gets_backspace:
0144+  121D 7F            dec d
0145+  121E 0A FA 11      jmp _gets_loop
0146+  1221             _gets_ansi_esc:
0147+  1221 19 01         mov al, 1
0148+  1223 05 03         syscall sys_io        ; receive in ah without echo
0149+  1225 76 5B         cmp ah, '['
0150+  1227 C7 FA 11      jne _gets_loop
0151+  122A 19 01         mov al, 1
0152+  122C 05 03         syscall sys_io          ; receive in ah without echo
0153+  122E 76 64         cmp ah, 'd'
0154+  1230 C6 3B 12      je _gets_left_arrow
0155+  1233 76 63         cmp ah, 'c'
0156+  1235 C6 3F 12      je _gets_right_arrow
0157+  1238 0A FA 11      jmp _gets_loop
0158+  123B             _gets_left_arrow:
0159+  123B 7F            dec d
0160+  123C 0A FA 11      jmp _gets_loop
0161+  123F             _gets_right_arrow:
0162+  123F 79            inc d
0163+  1240 0A FA 11      jmp _gets_loop
0164+  1243             _gets_escape:
0165+  1243 19 01         mov al, 1
0166+  1245 05 03         syscall sys_io      ; receive in ah
0167+  1247 76 6E         cmp ah, 'n'
0168+  1249 C6 68 12      je _gets_lf
0169+  124C 76 72         cmp ah, 'r'
0170+  124E C6 6F 12      je _gets_cr
0171+  1251 76 30         cmp ah, '0'
0172+  1253 C6 76 12      je _gets_null
0173+  1256 76 5C         cmp ah, $5c  ; '\'
0174+  1258 C6 61 12      je _gets_slash
0175+  125B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  125C 3E            mov [d], al
0177+  125D 79            inc d
0178+  125E 0A FA 11      jmp _gets_loop
0179+  1261             _gets_slash:
0180+  1261 19 5C         mov al, $5c
0181+  1263 3E            mov [d], al
0182+  1264 79            inc d
0183+  1265 0A FA 11      jmp _gets_loop
0184+  1268             _gets_lf:
0185+  1268 19 0A         mov al, $0a
0186+  126A 3E            mov [d], al
0187+  126B 79            inc d
0188+  126C 0A FA 11      jmp _gets_loop
0189+  126F             _gets_cr:
0190+  126F 19 0D         mov al, $0d
0191+  1271 3E            mov [d], al
0192+  1272 79            inc d
0193+  1273 0A FA 11      jmp _gets_loop
0194+  1276             _gets_null:
0195+  1276 19 00         mov al, $00
0196+  1278 3E            mov [d], al
0197+  1279 79            inc d
0198+  127A 0A FA 11      jmp _gets_loop
0199+  127D             _gets_end:
0200+  127D 19 00         mov al, 0
0201+  127F 3E            mov [d], al        ; terminate string
0202+  1280 E7            pop d
0203+  1281 E4            pop a
0204+  1282 09            ret
0205+  1283             
0206+  1283             
0207+  1283             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1283             ;; input text
0209+  1283             ;; terminated with ctrl+d
0210+  1283             ;; pointer in d
0211+  1283             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1283             _gettxt:
0213+  1283 D7            push a
0214+  1284 DA            push d
0215+  1285             _gettxt_loop:
0216+  1285 19 01         mov al, 1
0217+  1287 05 03         syscall sys_io      ; receive in ah
0218+  1289 76 04         cmp ah, 4      ; eot
0219+  128B C6 C4 12      je _gettxt_end
0220+  128E 76 08         cmp ah, $08      ; check for backspace
0221+  1290 C6 C0 12      je _gettxt_backspace
0222+  1293 76 5C         cmp ah, $5c        ; '\'
0223+  1295 C6 9E 12      je _gettxt_escape
0224+  1298 1A            mov al, ah
0225+  1299 3E            mov [d], al
0226+  129A 79            inc d
0227+  129B 0A 85 12      jmp _gettxt_loop
0228+  129E             _gettxt_escape:
0229+  129E 19 01         mov al, 1
0230+  12A0 05 03         syscall sys_io      ; receive in ah
0231+  12A2 76 6E         cmp ah, 'n'
0232+  12A4 C6 B2 12      je _gettxt_lf
0233+  12A7 76 72         cmp ah, 'r'
0234+  12A9 C6 B9 12      je _gettxt_cr
0235+  12AC 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  12AD 3E            mov [d], al
0237+  12AE 79            inc d
0238+  12AF 0A 85 12      jmp _gettxt_loop
0239+  12B2             _gettxt_lf:
0240+  12B2 19 0A         mov al, $0a
0241+  12B4 3E            mov [d], al
0242+  12B5 79            inc d
0243+  12B6 0A 85 12      jmp _gettxt_loop
0244+  12B9             _gettxt_cr:
0245+  12B9 19 0D         mov al, $0d
0246+  12BB 3E            mov [d], al
0247+  12BC 79            inc d
0248+  12BD 0A 85 12      jmp _gettxt_loop
0249+  12C0             _gettxt_backspace:
0250+  12C0 7F            dec d
0251+  12C1 0A 85 12      jmp _gettxt_loop
0252+  12C4             _gettxt_end:
0253+  12C4 19 00         mov al, 0
0254+  12C6 3E            mov [d], al        ; terminate string
0255+  12C7 E7            pop d
0256+  12C8 E4            pop a
0257+  12C9 09            ret
0258+  12CA             
0259+  12CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  12CA             ; print new line
0261+  12CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  12CA             printnl:
0263+  12CA D7            push a
0264+  12CB 10 00 0A      mov a, $0a00
0265+  12CE 05 03         syscall sys_io
0266+  12D0 10 00 0D      mov a, $0d00
0267+  12D3 05 03         syscall sys_io
0268+  12D5 E4            pop a
0269+  12D6 09            ret
0270+  12D7             
0271+  12D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  12D7             ; _strtoint
0273+  12D7             ; 4 digit hex string number in d
0274+  12D7             ; integer returned in a
0275+  12D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12D7             _strtointx:
0277+  12D7 D8            push b
0278+  12D8 32            mov bl, [d]
0279+  12D9 37            mov bh, bl
0280+  12DA 33 01 00      mov bl, [d + 1]
0281+  12DD 07 AE 11      call _atoi        ; convert to int in al
0282+  12E0 23            mov ah, al        ; move to ah
0283+  12E1 33 02 00      mov bl, [d + 2]
0284+  12E4 37            mov bh, bl
0285+  12E5 33 03 00      mov bl, [d + 3]
0286+  12E8 07 AE 11      call _atoi        ; convert to int in al
0287+  12EB E5            pop b
0288+  12EC 09            ret
0289+  12ED             
0290+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  12ED             ; _strtoint
0292+  12ED             ; 5 digit base10 string number in d
0293+  12ED             ; integer returned in a
0294+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  12ED             _strtoint:
0296+  12ED E2            push si
0297+  12EE D8            push b
0298+  12EF D9            push c
0299+  12F0 DA            push d
0300+  12F1 07 50 11      call _strlen      ; get string length in c
0301+  12F4 7E            dec c
0302+  12F5 FD 4E         mov si, d
0303+  12F7 12            mov a, c
0304+  12F8 FD 99         shl a
0305+  12FA 3B 71 14      mov d, table_power
0306+  12FD 59            add d, a
0307+  12FE 38 00 00      mov c, 0
0308+  1301             _strtoint_l0:
0309+  1301 F6            lodsb      ; load ascii to al
0310+  1302 B9 00         cmp al, 0
0311+  1304 C6 17 13      je _strtoint_end
0312+  1307 6F 30         sub al, $30    ; make into integer
0313+  1309 22 00         mov ah, 0
0314+  130B 2A            mov b, [d]
0315+  130C AC            mul a, b      ; result in b since it fits in 16bits
0316+  130D 11            mov a, b
0317+  130E 28            mov b, c
0318+  130F 54            add a, b
0319+  1310 39            mov c, a
0320+  1311 63 02 00      sub d, 2
0321+  1314 0A 01 13      jmp _strtoint_l0
0322+  1317             _strtoint_end:
0323+  1317 12            mov a, c
0324+  1318 E7            pop d
0325+  1319 E6            pop c
0326+  131A E5            pop b
0327+  131B EF            pop si
0328+  131C 09            ret
0329+  131D             
0330+  131D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  131D             ; print null terminated string
0332+  131D             ; pointer in d
0333+  131D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  131D             _puts:
0335+  131D D7            push a
0336+  131E DA            push d
0337+  131F             _puts_l1:
0338+  131F 1E            mov al, [d]
0339+  1320 B9 00         cmp al, 0
0340+  1322 C6 2E 13      jz _puts_end
0341+  1325 23            mov ah, al
0342+  1326 19 00         mov al, 0
0343+  1328 05 03         syscall sys_io
0344+  132A 79            inc d
0345+  132B 0A 1F 13      jmp _puts_l1
0346+  132E             _puts_end:
0347+  132E E7            pop d
0348+  132F E4            pop a
0349+  1330 09            ret
0350+  1331             
0351+  1331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1331             ; print n size string
0353+  1331             ; pointer in d
0354+  1331             ; size in c
0355+  1331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1331             _putsn:
0357+  1331 DB            push al
0358+  1332 DA            push d
0359+  1333 D9            push c
0360+  1334             _putsn_l0:
0361+  1334 1E            mov al, [d]
0362+  1335 23            mov ah, al
0363+  1336 19 00         mov al, 0
0364+  1338 05 03         syscall sys_io
0365+  133A 79            inc d
0366+  133B 7E            dec c  
0367+  133C C2 00 00      cmp c, 0
0368+  133F C7 34 13      jne _putsn_l0
0369+  1342             _putsn_end:
0370+  1342 E6            pop c
0371+  1343 E7            pop d
0372+  1344 E8            pop al
0373+  1345 09            ret
0374+  1346             
0375+  1346             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1346             ; print 16bit decimal number
0377+  1346             ; input number in a
0378+  1346             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1346             print_u16d:
0380+  1346 D7            push a
0381+  1347 D8            push b
0382+  1348 FD D8         push g
0383+  134A 26 10 27      mov b, 10000
0384+  134D AE            div a, b      ; get 10000's coeff.
0385+  134E 07 72 13      call print_number
0386+  1351 11            mov a, b
0387+  1352 26 E8 03      mov b, 1000
0388+  1355 AE            div a, b      ; get 1000's coeff.
0389+  1356 07 72 13      call print_number
0390+  1359 11            mov a, b
0391+  135A 26 64 00      mov b, 100
0392+  135D AE            div a, b
0393+  135E 07 72 13      call print_number
0394+  1361 11            mov a, b
0395+  1362 26 0A 00      mov b, 10
0396+  1365 AE            div a, b
0397+  1366 07 72 13      call print_number
0398+  1369 1B            mov al, bl      ; 1's coeff in bl
0399+  136A 07 72 13      call print_number
0400+  136D FD F1         pop g
0401+  136F E5            pop b
0402+  1370 E4            pop a
0403+  1371 09            ret
0404+  1372             
0405+  1372             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1372             ; print al
0407+  1372             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1372             print_number:
0409+  1372 6A 30         add al, $30
0410+  1374 23            mov ah, al
0411+  1375 07 F1 11      call _putchar
0412+  1378 09            ret
0413+  1379             
0414+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1379             ; print 16bit hex integer
0416+  1379             ; integer value in reg b
0417+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1379             print_u16x:
0419+  1379 D7            push a
0420+  137A D8            push b
0421+  137B DD            push bl
0422+  137C 30            mov bl, bh
0423+  137D 07 BF 11      call _itoa        ; convert bh to char in a
0424+  1380 2F            mov bl, al        ; save al
0425+  1381 19 00         mov al, 0
0426+  1383 05 03         syscall sys_io        ; display ah
0427+  1385 24            mov ah, bl        ; retrieve al
0428+  1386 19 00         mov al, 0
0429+  1388 05 03         syscall sys_io        ; display al
0430+  138A             
0431+  138A EA            pop bl
0432+  138B 07 BF 11      call _itoa        ; convert bh to char in a
0433+  138E 2F            mov bl, al        ; save al
0434+  138F 19 00         mov al, 0
0435+  1391 05 03         syscall sys_io        ; display ah
0436+  1393 24            mov ah, bl        ; retrieve al
0437+  1394 19 00         mov al, 0
0438+  1396 05 03         syscall sys_io        ; display al
0439+  1398             
0440+  1398 E5            pop b
0441+  1399 E4            pop a
0442+  139A 09            ret
0443+  139B             
0444+  139B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  139B             ; input 16bit hex integer
0446+  139B             ; read 16bit integer into a
0447+  139B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  139B             scan_u16x:
0449+  139B F8 10 00      enter 16
0450+  139E D8            push b
0451+  139F DA            push d
0452+  13A0             
0453+  13A0 FA F1 FF      lea d, [bp + -15]
0454+  13A3 07 F8 11      call _gets        ; get number
0455+  13A6             
0456+  13A6 32            mov bl, [d]
0457+  13A7 37            mov bh, bl
0458+  13A8 33 01 00      mov bl, [d + 1]
0459+  13AB 07 AE 11      call _atoi        ; convert to int in al
0460+  13AE 23            mov ah, al        ; move to ah
0461+  13AF             
0462+  13AF 33 02 00      mov bl, [d + 2]
0463+  13B2 37            mov bh, bl
0464+  13B3 33 03 00      mov bl, [d + 3]
0465+  13B6 07 AE 11      call _atoi        ; convert to int in al
0466+  13B9             
0467+  13B9 E7            pop d
0468+  13BA E5            pop b
0469+  13BB F9            leave
0470+  13BC 09            ret
0471+  13BD             
0472+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  13BD             ; print 8bit hex integer
0474+  13BD             ; integer value in reg bl
0475+  13BD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  13BD             print_u8x:
0477+  13BD D7            push a
0478+  13BE DD            push bl
0479+  13BF             
0480+  13BF 07 BF 11      call _itoa        ; convert bl to char in a
0481+  13C2 2F            mov bl, al        ; save al
0482+  13C3 19 00         mov al, 0
0483+  13C5 05 03         syscall sys_io        ; display ah
0484+  13C7 24            mov ah, bl        ; retrieve al
0485+  13C8 19 00         mov al, 0
0486+  13CA 05 03         syscall sys_io        ; display al
0487+  13CC             
0488+  13CC EA            pop bl
0489+  13CD E4            pop a
0490+  13CE 09            ret
0491+  13CF             
0492+  13CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  13CF             ; print 8bit decimal unsigned number
0494+  13CF             ; input number in al
0495+  13CF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  13CF             print_u8d:
0497+  13CF D7            push a
0498+  13D0 D8            push b
0499+  13D1 FD D8         push g
0500+  13D3 22 00         mov ah, 0
0501+  13D5 26 64 00      mov b, 100
0502+  13D8 AE            div a, b
0503+  13D9 D8            push b      ; save remainder
0504+  13DA B9 00         cmp al, 0
0505+  13DC C6 E6 13      je skip100
0506+  13DF 6A 30         add al, $30
0507+  13E1 23            mov ah, al
0508+  13E2 19 00         mov al, 0
0509+  13E4 05 03         syscall sys_io  ; print coeff
0510+  13E6             skip100:
0511+  13E6 E4            pop a
0512+  13E7 22 00         mov ah, 0
0513+  13E9 26 0A 00      mov b, 10
0514+  13EC AE            div a, b
0515+  13ED D8            push b      ; save remainder
0516+  13EE B9 00         cmp al, 0
0517+  13F0 C6 FA 13      je skip10
0518+  13F3 6A 30         add al, $30
0519+  13F5 23            mov ah, al
0520+  13F6 19 00         mov al, 0
0521+  13F8 05 03         syscall sys_io  ; print coeff
0522+  13FA             skip10:
0523+  13FA E4            pop a
0524+  13FB 1B            mov al, bl
0525+  13FC 6A 30         add al, $30
0526+  13FE 23            mov ah, al
0527+  13FF 19 00         mov al, 0
0528+  1401 05 03         syscall sys_io  ; print coeff
0529+  1403 FD F1         pop g
0530+  1405 E5            pop b
0531+  1406 E4            pop a
0532+  1407 09            ret
0533+  1408             
0534+  1408             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1408             ; input 8bit hex integer
0536+  1408             ; read 8bit integer into al
0537+  1408             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1408             scan_u8x:
0539+  1408 F8 04 00      enter 4
0540+  140B D8            push b
0541+  140C DA            push d
0542+  140D             
0543+  140D FA FD FF      lea d, [bp + -3]
0544+  1410 07 F8 11      call _gets        ; get number
0545+  1413             
0546+  1413 32            mov bl, [d]
0547+  1414 37            mov bh, bl
0548+  1415 33 01 00      mov bl, [d + 1]
0549+  1418 07 AE 11      call _atoi        ; convert to int in al
0550+  141B             
0551+  141B E7            pop d
0552+  141C E5            pop b
0553+  141D F9            leave
0554+  141E 09            ret
0555+  141F             
0556+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  141F             ; input decimal number
0558+  141F             ; result in a
0559+  141F             ; 655'\0'
0560+  141F             ; low--------high
0561+  141F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  141F             scan_u16d:
0563+  141F F8 08 00      enter 8
0564+  1422 E2            push si
0565+  1423 D8            push b
0566+  1424 D9            push c
0567+  1425 DA            push d
0568+  1426 FA F9 FF      lea d, [bp +- 7]
0569+  1429 07 F8 11      call _gets
0570+  142C 07 50 11      call _strlen      ; get string length in c
0571+  142F 7E            dec c
0572+  1430 FD 4E         mov si, d
0573+  1432 12            mov a, c
0574+  1433 FD 99         shl a
0575+  1435 3B 71 14      mov d, table_power
0576+  1438 59            add d, a
0577+  1439 38 00 00      mov c, 0
0578+  143C             mul_loop:
0579+  143C F6            lodsb      ; load ascii to al
0580+  143D B9 00         cmp al, 0
0581+  143F C6 52 14      je mul_exit
0582+  1442 6F 30         sub al, $30    ; make into integer
0583+  1444 22 00         mov ah, 0
0584+  1446 2A            mov b, [d]
0585+  1447 AC            mul a, b      ; result in b since it fits in 16bits
0586+  1448 11            mov a, b
0587+  1449 28            mov b, c
0588+  144A 54            add a, b
0589+  144B 39            mov c, a
0590+  144C 63 02 00      sub d, 2
0591+  144F 0A 3C 14      jmp mul_loop
0592+  1452             mul_exit:
0593+  1452 12            mov a, c
0594+  1453 E7            pop d
0595+  1454 E6            pop c
0596+  1455 E5            pop b
0597+  1456 EF            pop si
0598+  1457 F9            leave
0599+  1458 09            ret
0600+  1459             
0601+  1459             
0602+  1459 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  145D 34 35 36 37 
0602+  1461 38 39 61 62 
0602+  1465 63 64 65 66 
0603+  1469 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  146D 1B 5B 68 00 
0604+  1471             
0605+  1471             table_power:
0606+  1471 01 00         .dw 1
0607+  1473 0A 00         .dw 10
0608+  1475 64 00         .dw 100
0609+  1477 E8 03         .dw 1000
0610+  1479 10 27         .dw 100002825   147B             .include "lib/ctype.asm"
0001+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  147B             ; ctype.s
0003+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  147B             
0005+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  147B             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  147B             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  147B             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  147B             ;; characters are supported.
0010+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  147B             ;; _isalnum 
0012+  147B             ;; _isalpha 
0013+  147B             ;; islower 
0014+  147B             ;; isupper 
0015+  147B             ;; _isdigit 
0016+  147B             ;; isxdigit
0017+  147B             ;; iscntrl 
0018+  147B             ;; isgraph 
0019+  147B             ;; _isspace 
0020+  147B             ;; isblank 
0021+  147B             ;; isprint 
0022+  147B             ;; ispunct 
0023+  147B             ;; tolower 
0024+  147B             ;; toupper
0025+  147B             
0026+  147B             
0027+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  147B             ;; is alphanumeric
0029+  147B             ;; sets zf according with result
0030+  147B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  147B             _isalnum:
0032+  147B 07 98 14    	call _isalpha
0033+  147E C6 84 14    	je _isalnum_exit
0034+  1481 07 85 14    	call _isdigit
0035+  1484             _isalnum_exit:
0036+  1484 09          	ret	
0037+  1485             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1485             ;; is digit
0039+  1485             ;; sets zf according with result
0040+  1485             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1485             _isdigit:
0042+  1485 DB          	push al
0043+  1486 B9 30       	cmp al, '0'
0044+  1488 C8 94 14    	jlu _isdigit_false
0045+  148B B9 39       	cmp al, '9'
0046+  148D D1 94 14    	jgu _isdigit_false
0047+  1490 87 00       	and al, 0	; set zf
0048+  1492 E8          	pop al
0049+  1493 09          	ret
0050+  1494             _isdigit_false:
0051+  1494 8B 01       	or al, 1	; clear zf
0052+  1496 E8          	pop al
0053+  1497 09          	ret	
0054+  1498             	
0055+  1498             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1498             ;; is alpha
0057+  1498             ;; sets zf according with result
0058+  1498             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1498             _isalpha:
0060+  1498 DB          	push al
0061+  1499 B9 5F       	cmp al, '_'
0062+  149B C6 BB 14    	je _isalpha_true
0063+  149E B9 2E       	cmp al, '.'
0064+  14A0 C6 BB 14    	je _isalpha_true
0065+  14A3 B9 61       	cmp al, 'a'
0066+  14A5 C8 B7 14    	jlu _isalpha_false
0067+  14A8 B9 7A       	cmp al, 'z'
0068+  14AA D1 B7 14    	jgu _isalpha_false
0069+  14AD B9 7A       	cmp al, 'z'
0070+  14AF D0 BB 14    	jleu _isalpha_true
0071+  14B2 B9 61       	cmp al, 'a'
0072+  14B4 C9 BB 14    	jgeu _isalpha_true
0073+  14B7             _isalpha_false:
0074+  14B7 8B 01       	or al, 1	; clear zf
0075+  14B9 E8          	pop al
0076+  14BA 09          	ret
0077+  14BB             _isalpha_true:
0078+  14BB 87 00       	and al, 0	; set zf
0079+  14BD E8          	pop al
0080+  14BE 09          	ret
0081+  14BF             
0082+  14BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  14BF             ;; is path-alpha
0084+  14BF             ;; sets zf according with result
0085+  14BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  14BF             ispath:
0087+  14BF DB          	push al
0088+  14C0 07 85 14    	call _isdigit
0089+  14C3 C6 ED 14    	je ispath_true
0090+  14C6 B9 5F       	cmp al, '_'
0091+  14C8 C6 ED 14    	je ispath_true
0092+  14CB B9 2F       	cmp al, '/'
0093+  14CD C6 ED 14    	je ispath_true
0094+  14D0 B9 2E       	cmp al, '.'
0095+  14D2 C6 ED 14    	je ispath_true
0096+  14D5 B9 61       	cmp al, 'a'
0097+  14D7 C8 E9 14    	jlu ispath_false
0098+  14DA B9 7A       	cmp al, 'z'
0099+  14DC D1 E9 14    	jgu ispath_false
0100+  14DF B9 7A       	cmp al, 'z'
0101+  14E1 D0 ED 14    	jleu ispath_true
0102+  14E4 B9 61       	cmp al, 'a'
0103+  14E6 C9 ED 14    	jgeu ispath_true
0104+  14E9             ispath_false:
0105+  14E9 8B 01       	or al, 1	; clear zf
0106+  14EB E8          	pop al
0107+  14EC 09          	ret
0108+  14ED             ispath_true:
0109+  14ED 87 00       	and al, 0	; set zf
0110+  14EF E8          	pop al
0111+  14F0 09          	ret
0112+  14F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14F1             ;; is space
0114+  14F1             ;; sets zf according with result
0115+  14F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14F1             _isspace:
0117+  14F1 B9 20       	cmp al, $20		; ' '
0118+  14F3 C6 07 15    	je _isspace_exit
0119+  14F6 B9 09       	cmp al, $09		; '\t'
0120+  14F8 C6 07 15    	je _isspace_exit
0121+  14FB B9 0A       	cmp al, $0a		; '\n'
0122+  14FD C6 07 15    	je _isspace_exit
0123+  1500 B9 0D       	cmp al, $0d		; '\r'
0124+  1502 C6 07 15    	je _isspace_exit
0125+  1505 B9 0B       	cmp al, $0b		; '\v'
0126+  1507             _isspace_exit:
0127+  1507 09          	ret	
0128+  1508             
0129+  1508             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1508             ; to lower
0131+  1508             ; input in al
0132+  1508             ; output in al
0133+  1508             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1508             _to_lower:
0135+  1508 B9 7A       	cmp al, 'z'
0136+  150A D1 0F 15    	jgu _to_lower_ret
0137+  150D 6A 20       	add al, $20				; convert to lower case
0138+  150F             _to_lower_ret:
0139+  150F 09          	ret
0140+  1510             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1510             ; to upper
0142+  1510             ; input in al
0143+  1510             ; output in al
0144+  1510             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1510             _to_upper:
0146+  1510 B9 61       	cmp al, 'a'
0147+  1512 C8 17 15    	jlu _to_upper_ret
0148+  1515 6F 20       	sub al, $20			; convert to upper case
0149+  1517             _to_upper_ret:
0150+  1517 09          	ret
0151+  1518             
2826   1518             .include "lib/token.asm"
0001+  1518             toktyp_identifier  .equ 0
0002+  1518             toktyp_keyword     .equ 1
0003+  1518             toktyp_delimiter   .equ 2
0004+  1518             toktyp_string      .equ 3
0005+  1518             toktyp_char        .equ 4
0006+  1518             toktyp_numeric     .equ 5
0007+  1518             toktyp_end         .equ 6
0008+  1518             
0009+  1518             tok_null           .equ 0
0010+  1518             tok_fslash         .equ 1
0011+  1518             tok_times          .equ 2
0012+  1518             tok_plus           .equ 3
0013+  1518             tok_minus          .equ 4
0014+  1518             tok_dot            .equ 5
0015+  1518             tok_semi           .equ 6
0016+  1518             tok_angle          .equ 7
0017+  1518             tok_tilde          .equ 8
0018+  1518             tok_equal          .equ 9
0019+  1518             tok_colon          .equ 10
0020+  1518             tok_comma          .equ 11
0021+  1518             
0022+  1518             tok_end            .equ 20
0023+  1518             
0024+  1518             
0025+  1518             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1518             ;; read a full command argment from shell input buffer
0027+  1518             ;; argument is written into tokstr
0028+  1518             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1518             get_arg:
0030+  1518 D7            push a
0031+  1519 E2            push si
0032+  151A E3            push di
0033+  151B 19 00         mov al, 0
0034+  151D 3D 46 17      mov [tokstr], al      ; nullify tokstr string
0035+  1520 14 42 17      mov a, [prog]
0036+  1523 4D            mov si, a
0037+  1524 FD 4F 46 17   mov di, tokstr
0038+  1528             get_arg_skip_spaces:
0039+  1528 F6            lodsb
0040+  1529 07 F1 14      call _isspace
0041+  152C C6 28 15      je get_arg_skip_spaces
0042+  152F             get_arg_l0:
0043+  152F B9 3B         cmp al, $3b        ; check if is ';'
0044+  1531 C6 3E 15      je get_arg_end
0045+  1534 B9 00         cmp al, 0
0046+  1536 C6 3E 15      je get_arg_end      ; check if end of input
0047+  1539 F7            stosb
0048+  153A F6            lodsb
0049+  153B 0A 2F 15      jmp get_arg_l0
0050+  153E             get_arg_end:
0051+  153E 19 00         mov al, 0
0052+  1540 F7            stosb
0053+  1541 D5 01 00      sub si, 1
0054+  1544 4E            mov a, si
0055+  1545 42 42 17      mov [prog], a    ; update pointer
0056+  1548 F0            pop di
0057+  1549 EF            pop si
0058+  154A E4            pop a
0059+  154B 09            ret
0060+  154C             
0061+  154C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  154C             ;; read a path formation from shell input buffer
0063+  154C             ;; path is written into tokstr
0064+  154C             ;; /usr/bin
0065+  154C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  154C             get_path:
0067+  154C D7            push a
0068+  154D E2            push si
0069+  154E E3            push di
0070+  154F 19 00         mov al, 0
0071+  1551 3D 46 17      mov [tokstr], al      ; nullify tokstr string
0072+  1554 14 42 17      mov a, [prog]
0073+  1557 4D            mov si, a
0074+  1558 FD 4F 46 17   mov di, tokstr
0075+  155C             get_path_skip_spaces:
0076+  155C F6            lodsb
0077+  155D 07 F1 14      call _isspace
0078+  1560 C6 5C 15      je get_path_skip_spaces
0079+  1563             get_path_is_pathchar:
0080+  1563 F7            stosb
0081+  1564 F6            lodsb
0082+  1565 07 7B 14      call _isalnum      ;check if is alphanumeric
0083+  1568 C6 63 15      je get_path_is_pathchar
0084+  156B B9 2F         cmp al, '/'        ; check if is '/'
0085+  156D C6 63 15      je get_path_is_pathchar
0086+  1570 19 00         mov al, 0
0087+  1572 F7            stosb
0088+  1573 D5 01 00      sub si, 1
0089+  1576 4E            mov a, si
0090+  1577 42 42 17      mov [prog], a    ; update pointer
0091+  157A             get_path_end:
0092+  157A F0            pop di
0093+  157B EF            pop si
0094+  157C E4            pop a
0095+  157D 09            ret
0096+  157E             
0097+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  157E             ;; read a line
0099+  157E             ;; line is written into tokstr
0100+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  157E             get_line:
0102+  157E D7            push a
0103+  157F E2            push si
0104+  1580 E3            push di
0105+  1581 19 00         mov al, 0
0106+  1583 3D 46 17      mov [tokstr], al      ; nullify tokstr string
0107+  1586 14 42 17      mov a, [prog]
0108+  1589 4D            mov si, a
0109+  158A FD 4F 46 17   mov di, tokstr
0110+  158E             get_line_l0:
0111+  158E F6            lodsb
0112+  158F B9 0A         cmp al, $0a    ; check for new line
0113+  1591 C6 98 15      je get_line_exit
0114+  1594 F7            stosb
0115+  1595 0A 8E 15      jmp get_line_l0
0116+  1598             get_line_exit:
0117+  1598 19 00         mov al, 0
0118+  159A F7            stosb
0119+  159B 4E            mov a, si
0120+  159C 42 42 17      mov [prog], a    ; update pointer
0121+  159F F0            pop di
0122+  15A0 EF            pop si
0123+  15A1 E4            pop a
0124+  15A2 09            ret
0125+  15A3             
0126+  15A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  15A3             ;; token parser
0128+  15A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  15A3             get_token:
0130+  15A3 D7            push a
0131+  15A4 DA            push d
0132+  15A5 E2            push si
0133+  15A6 E3            push di
0134+  15A7 19 00         mov al, 0
0135+  15A9 3D 46 17      mov [tokstr], al      ; nullify tokstr string
0136+  15AC 19 00         mov al, tok_null
0137+  15AE 3D 45 17      mov [tok], al        ; nullify token
0138+  15B1 14 42 17      mov a, [prog]
0139+  15B4 4D            mov si, a
0140+  15B5 FD 4F 46 17   mov di, tokstr
0141+  15B9             get_tok_skip_spaces:
0142+  15B9 F6            lodsb
0143+  15BA 07 F1 14      call _isspace
0144+  15BD C6 B9 15      je get_tok_skip_spaces
0145+  15C0 B9 00         cmp al, 0      ; check for end of input (null)
0146+  15C2 C6 A7 16      je get_token_end
0147+  15C5 B9 23         cmp al, '#'      ; comments!
0148+  15C7 C6 D5 16      je get_tok_comment
0149+  15CA 07 7B 14      call _isalnum
0150+  15CD C6 B4 16      jz is_alphanumeric
0151+  15D0             ; other token types
0152+  15D0             get_token_slash:
0153+  15D0 B9 2F         cmp al, '/'        ; check if '/'
0154+  15D2 C7 EA 15      jne get_token_minus
0155+  15D5 F7            stosb          ; store '/' into token string
0156+  15D6 19 00         mov al, 0
0157+  15D8 F7            stosb          ; terminate token string
0158+  15D9 19 01         mov al, tok_fslash
0159+  15DB 3D 45 17      mov [tok], al      
0160+  15DE 19 02         mov al, toktyp_delimiter
0161+  15E0 3D 44 17      mov [toktyp], al
0162+  15E3 4E            mov a, si
0163+  15E4 42 42 17      mov [prog], a    ; update pointer
0164+  15E7 0A D0 16      jmp get_token_return
0165+  15EA             get_token_minus:
0166+  15EA B9 2D         cmp al, '-'        ; check if '-'
0167+  15EC C7 04 16      jne get_token_comma
0168+  15EF F7            stosb          ; store '-' into token string
0169+  15F0 19 00         mov al, 0
0170+  15F2 F7            stosb          ; terminate token string
0171+  15F3 19 04         mov al, tok_minus
0172+  15F5 3D 45 17      mov [tok], al      
0173+  15F8 19 02         mov al, toktyp_delimiter
0174+  15FA 3D 44 17      mov [toktyp], al
0175+  15FD 4E            mov a, si
0176+  15FE 42 42 17      mov [prog], a    ; update pointer
0177+  1601 0A D0 16      jmp get_token_return
0178+  1604             get_token_comma:
0179+  1604 B9 2C         cmp al, ','        ; check if ','
0180+  1606 C7 1E 16      jne get_token_semi
0181+  1609 F7            stosb          ; store ',' into token string
0182+  160A 19 00         mov al, 0
0183+  160C F7            stosb          ; terminate token string
0184+  160D 19 0B         mov al, tok_comma
0185+  160F 3D 45 17      mov [tok], al      
0186+  1612 19 02         mov al, toktyp_delimiter
0187+  1614 3D 44 17      mov [toktyp], al
0188+  1617 4E            mov a, si
0189+  1618 42 42 17      mov [prog], a    ; update pointer
0190+  161B 0A D0 16      jmp get_token_return
0191+  161E             get_token_semi:
0192+  161E B9 3B         cmp al, $3b        ; check if ';'
0193+  1620 C7 38 16      jne get_token_colon
0194+  1623 F7            stosb          ; store ';' into token string
0195+  1624 19 00         mov al, 0
0196+  1626 F7            stosb          ; terminate token string
0197+  1627 19 06         mov al, tok_semi
0198+  1629 3D 45 17      mov [tok], al      
0199+  162C 19 02         mov al, toktyp_delimiter
0200+  162E 3D 44 17      mov [toktyp], al
0201+  1631 4E            mov a, si
0202+  1632 42 42 17      mov [prog], a    ; update pointer
0203+  1635 0A D0 16      jmp get_token_return
0204+  1638             get_token_colon:
0205+  1638 B9 3A         cmp al, $3a        ; check if ':'
0206+  163A C7 52 16      jne get_token_angle
0207+  163D F7            stosb          ; store ':' into token string
0208+  163E 19 00         mov al, 0
0209+  1640 F7            stosb          ; terminate token string
0210+  1641 19 0A         mov al, tok_colon
0211+  1643 3D 45 17      mov [tok], al      
0212+  1646 19 02         mov al, toktyp_delimiter
0213+  1648 3D 44 17      mov [toktyp], al
0214+  164B 4E            mov a, si
0215+  164C 42 42 17      mov [prog], a    ; update pointer
0216+  164F 0A D0 16      jmp get_token_return
0217+  1652             get_token_angle:
0218+  1652 B9 3E         cmp al, $3e        ; check if '>'
0219+  1654 C7 6C 16      jne get_token_tilde
0220+  1657 F7            stosb          ; store '>' into token string
0221+  1658 19 00         mov al, 0
0222+  165A F7            stosb          ; terminate token string
0223+  165B 19 07         mov al, tok_angle
0224+  165D 3D 45 17      mov [tok], al      
0225+  1660 19 02         mov al, toktyp_delimiter
0226+  1662 3D 44 17      mov [toktyp], al
0227+  1665 4E            mov a, si
0228+  1666 42 42 17      mov [prog], a    ; update pointer
0229+  1669 0A D0 16      jmp get_token_return
0230+  166C             get_token_tilde:
0231+  166C B9 7E         cmp al, '~'        ; check if '~'
0232+  166E C7 86 16      jne get_token_equal
0233+  1671 F7            stosb          ; store '~' into token string
0234+  1672 19 00         mov al, 0
0235+  1674 F7            stosb          ; terminate token string
0236+  1675 19 08         mov al, tok_tilde
0237+  1677 3D 45 17      mov [tok], al      
0238+  167A 19 02         mov al, toktyp_delimiter
0239+  167C 3D 44 17      mov [toktyp], al
0240+  167F 4E            mov a, si
0241+  1680 42 42 17      mov [prog], a    ; update pointer
0242+  1683 0A D0 16      jmp get_token_return
0243+  1686             get_token_equal:
0244+  1686 B9 3D         cmp al, '='        ; check if '='
0245+  1688 C7 A0 16      jne get_token_skip
0246+  168B F7            stosb          ; store '=' into token string
0247+  168C 19 00         mov al, 0
0248+  168E F7            stosb          ; terminate token string
0249+  168F 19 09         mov al, tok_equal
0250+  1691 3D 45 17      mov [tok], al      
0251+  1694 19 02         mov al, toktyp_delimiter
0252+  1696 3D 44 17      mov [toktyp], al
0253+  1699 4E            mov a, si
0254+  169A 42 42 17      mov [prog], a    ; update pointer
0255+  169D 0A D0 16      jmp get_token_return
0256+  16A0             get_token_skip:
0257+  16A0 4E            mov a, si
0258+  16A1 42 42 17      mov [prog], a    ; update pointer
0259+  16A4 0A D0 16      jmp get_token_return
0260+  16A7             get_token_end:        ; end of file token
0261+  16A7 19 14         mov al, tok_end
0262+  16A9 3D 45 17      mov [tok], al
0263+  16AC 19 06         mov al, toktyp_end
0264+  16AE 3D 44 17      mov [toktyp], al
0265+  16B1 0A D0 16      jmp get_token_return
0266+  16B4             is_alphanumeric:
0267+  16B4 F7            stosb
0268+  16B5 F6            lodsb
0269+  16B6 07 7B 14      call _isalnum      ;check if is alphanumeric
0270+  16B9 C6 B4 16      jz is_alphanumeric
0271+  16BC B9 2E         cmp al, $2e        ; check if is '.'
0272+  16BE C6 B4 16      je is_alphanumeric
0273+  16C1 19 00         mov al, 0
0274+  16C3 F7            stosb
0275+  16C4 19 00         mov al, toktyp_identifier
0276+  16C6 3D 44 17      mov [toktyp], al
0277+  16C9 D5 01 00      sub si, 1
0278+  16CC 4E            mov a, si
0279+  16CD 42 42 17      mov [prog], a    ; update pointer
0280+  16D0             get_token_return:
0281+  16D0 F0            pop di
0282+  16D1 EF            pop si
0283+  16D2 E7            pop d
0284+  16D3 E4            pop a
0285+  16D4 09            ret
0286+  16D5             get_tok_comment:
0287+  16D5 F6            lodsb
0288+  16D6 B9 0A         cmp al, $0a      ; new line
0289+  16D8 C7 D5 16      jne get_tok_comment
0290+  16DB 0A B9 15      jmp get_tok_skip_spaces
0291+  16DE             
0292+  16DE             
0293+  16DE             get_number:
0294+  16DE D7            push a
0295+  16DF DA            push d
0296+  16E0 E2            push si
0297+  16E1 E3            push di
0298+  16E2 19 00         mov al, 0
0299+  16E4 3D 46 17      mov [tokstr], al      ; nullify tokstr string
0300+  16E7 19 00         mov al, tok_null
0301+  16E9 3D 45 17      mov [tok], al        ; nullify token
0302+  16EC 14 42 17      mov a, [prog]
0303+  16EF 4D            mov si, a
0304+  16F0 FD 4F 46 17   mov di, tokstr
0305+  16F4             get_number_skip_spaces:
0306+  16F4 F6            lodsb
0307+  16F5 07 F1 14      call _isspace
0308+  16F8 C6 F4 16      je get_number_skip_spaces
0309+  16FB B9 00         cmp al, 0      ; check for end of input (null)
0310+  16FD C7 0D 17      jne get_number_l0
0311+  1700 19 14         mov al, tok_end
0312+  1702 3D 45 17      mov [tok], al
0313+  1705 19 06         mov al, toktyp_end
0314+  1707 3D 44 17      mov [toktyp], al
0315+  170A 0A 24 17      jmp get_number_return
0316+  170D             get_number_l0:
0317+  170D F7            stosb
0318+  170E F6            lodsb
0319+  170F 07 85 14      call _isdigit      ;check if is numeric
0320+  1712 C6 0D 17      jz get_number_l0
0321+  1715 19 00         mov al, 0
0322+  1717 F7            stosb
0323+  1718 19 05         mov al, toktyp_numeric
0324+  171A 3D 44 17      mov [toktyp], al
0325+  171D D5 01 00      sub si, 1
0326+  1720 4E            mov a, si
0327+  1721 42 42 17      mov [prog], a    ; update pointer
0328+  1724             get_number_return:
0329+  1724 F0            pop di
0330+  1725 EF            pop si
0331+  1726 E7            pop d
0332+  1727 E4            pop a
0333+  1728 09            ret
0334+  1729             
0335+  1729             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1729             ;; put back token
0337+  1729             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1729             _putback:
0339+  1729 D7            push a
0340+  172A E2            push si
0341+  172B FD 4D 46 17   mov si, tokstr  
0342+  172F             _putback_loop:
0343+  172F F6            lodsb
0344+  1730 B9 00         cmp al, 0
0345+  1732 C6 3F 17      je _putback_end
0346+  1735 14 42 17      mov a, [prog]
0347+  1738 7D            dec a
0348+  1739 42 42 17      mov [prog], a      ; update pointer
0349+  173C 0A 2F 17      jmp _putback_loop
0350+  173F             _putback_end:
0351+  173F EF            pop si
0352+  1740 E4            pop a
0353+  1741 09            ret
0354+  1742             
0355+  1742             
0356+  1742             
0357+  1742             
0358+  1742 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1744             
0360+  1744 00          toktyp:    .db 0          ; token type symbol
0361+  1745 00          tok:       .db 0          ; current token symbol
0362+  1746 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  174A 00 00 00 00 
0362+  174E 00 00 00 00 
0362+  1752 00 00 00 00 
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
0362+  176E 00 00 00 00 
0362+  1772 00 00 00 00 
0362+  1776 00 00 00 00 
0362+  177A 00 00 00 00 
0362+  177E 00 00 00 00 
0362+  1782 00 00 00 00 
0362+  1786 00 00 00 00 
0362+  178A 00 00 00 00 
0362+  178E 00 00 00 00 
0362+  1792 00 00 00 00 
0362+  1796 00 00 00 00 
0362+  179A 00 00 00 00 
0362+  179E 00 00 00 00 
0362+  17A2 00 00 00 00 
0362+  17A6 00 00 00 00 
0362+  17AA 00 00 00 00 
0362+  17AE 00 00 00 00 
0362+  17B2 00 00 00 00 
0362+  17B6 00 00 00 00 
0362+  17BA 00 00 00 00 
0362+  17BE 00 00 00 00 
0362+  17C2 00 00 00 00 
0362+  17C6 00 00 00 00 
0362+  17CA 00 00 00 00 
0362+  17CE 00 00 00 00 
0362+  17D2 00 00 00 00 
0362+  17D6 00 00 00 00 
0362+  17DA 00 00 00 00 
0362+  17DE 00 00 00 00 
0362+  17E2 00 00 00 00 
0362+  17E6 00 00 00 00 
0362+  17EA 00 00 00 00 
0362+  17EE 00 00 00 00 
0362+  17F2 00 00 00 00 
0362+  17F6 00 00 00 00 
0362+  17FA 00 00 00 00 
0362+  17FE 00 00 00 00 
0362+  1802 00 00 00 00 
0362+  1806 00 00 00 00 
0362+  180A 00 00 00 00 
0362+  180E 00 00 00 00 
0362+  1812 00 00 00 00 
0362+  1816 00 00 00 00 
0362+  181A 00 00 00 00 
0362+  181E 00 00 00 00 
0362+  1822 00 00 00 00 
0362+  1826 00 00 00 00 
0362+  182A 00 00 00 00 
0362+  182E 00 00 00 00 
0362+  1832 00 00 00 00 
0362+  1836 00 00 00 00 
0362+  183A 00 00 00 00 
0362+  183E 00 00 00 00 
0362+  1842 00 00 00 00 
2827   1846             
2828   1846             ; kernel parameters
2829   1846             sys_debug_mode:
2830   1846 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2831   1847             sys_echo_on:
2832   1847 01            .db 1
2833   1848             sys_uart0_lcr:
2834   1848 07            .db $07 ; 8 data bits, 2 stop bit, no parity
2835   1849             sys_uart0_inten:
2836   1849 01            .db 1
2837   184A             sys_uart0_fifoen:
2838   184A 00            .db 0
2839   184B             sys_uart0_div0:
2840   184B 0C            .db 12  ;
2841   184C             sys_uart0_div1:
2842   184C 00            .db 0   ; default baud = 9600
2843   184D             ; baud  divisor
2844   184D             ; 50    2304
2845   184D             ; 110   1047
2846   184D             ; 300    384
2847   184D             ; 600    192
2848   184D             ; 1200    96
2849   184D             ; 9600    12
2850   184D             ; 19200    6
2851   184D             ; 38400    3
2852   184D             
2853   184D             nbr_active_procs:
2854   184D 00            .db 0
2855   184E             active_proc_index:
2856   184E 01            .db 1
2857   184F             
2858   184F             index:
2859   184F 00 00         .dw 0
2860   1851             buffer_addr:
2861   1851 00 00         .dw 0
2862   1853             
2863   1853             fifo_in:
2864   1853 A5 1F         .dw fifo
2865   1855             fifo_out:
2866   1855 A5 1F         .dw fifo
2867   1857             
2868   1857             ; file system variables
2869   1857             current_dir_id:
2870   1857 00 00         .dw 0     ; keep dirid of current directory
2871   1859             s_init_path:
2872   1859 2F 73 62 69   .db "/sbin/init", 0
2872   185D 6E 2F 69 6E 
2872   1861 69 74 00 
2873   1864             
2874   1864             s_uname:
2875   1864 73 6F 6C 61   .db "solarium v.1.0", 0
2875   1868 72 69 75 6D 
2875   186C 20 76 2E 31 
2875   1870 2E 30 00 
2876   1873             s_dataentry:
2877   1873 3E 20 00      .db "> ", 0
2878   1876             s_parent_dir:
2879   1876 2E 2E 00      .db "..", 0
2880   1879             s_current_dir:
2881   1879 2E 00         .db ".", 0
2882   187B             s_fslash:
2883   187B 2F 00         .db "/", 0
2884   187D             file_attrib:
2885   187D 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2885   1881 78 
2886   1882             file_type:
2887   1882 2D 64 63      .db "-dc"
2888   1885             s_ps_header:
2889   1885 70 69 64 20   .db "pid command\n", 0
2889   1889 63 6F 6D 6D 
2889   188D 61 6E 64 0A 
2889   1891 00 
2890   1892             s_ls_total:
2891   1892 74 6F 74 61   .db "total: ", 0
2891   1896 6C 3A 20 00 
2892   189A             
2893   189A             s_int_en:
2894   189A 69 72 71 73   .db "irqs enabled\n", 0
2894   189E 20 65 6E 61 
2894   18A2 62 6C 65 64 
2894   18A6 0A 00 
2895   18A8             s_kernel_started:
2896   18A8 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2896   18AC 65 6C 20 73 
2896   18B0 74 61 72 74 
2896   18B4 65 64 28 76 
2896   18B8 65 72 73 69 
2896   18BC 6F 6E 20 31 
2896   18C0 2E 30 29 0A 
2896   18C4 00 
2897   18C5             s_prompt_init:
2898   18C5 73 74 61 72   .db "starting init\n", 0
2898   18C9 74 69 6E 67 
2898   18CD 20 69 6E 69 
2898   18D1 74 0A 00 
2899   18D4             s_priviledge:
2900   18D4 0A 65 78 63   .db "\nexception: privilege\n", 0
2900   18D8 65 70 74 69 
2900   18DC 6F 6E 3A 20 
2900   18E0 70 72 69 76 
2900   18E4 69 6C 65 67 
2900   18E8 65 0A 00 
2901   18EB             s_divzero:
2902   18EB 0A 65 78 63   .db "\nexception: zero division\n", 0
2902   18EF 65 70 74 69 
2902   18F3 6F 6E 3A 20 
2902   18F7 7A 65 72 6F 
2902   18FB 20 64 69 76 
2902   18FF 69 73 69 6F 
2902   1903 6E 0A 00 
2903   1906             
2904   1906             s_set_year:
2905   1906 79 65 61 72   .db "year: ", 0
2905   190A 3A 20 00 
2906   190D             s_set_month:
2907   190D 6D 6F 6E 74   .db "month: ", 0
2907   1911 68 3A 20 00 
2908   1915             s_set_day:
2909   1915 64 61 79 3A   .db "day: ", 0
2909   1919 20 00 
2910   191B             s_set_week:
2911   191B 77 65 65 6B   .db "weekday: ", 0
2911   191F 64 61 79 3A 
2911   1923 20 00 
2912   1925             s_set_hours:
2913   1925 68 6F 75 72   .db "hours: ", 0
2913   1929 73 3A 20 00 
2914   192D             s_set_minutes:
2915   192D 6D 69 6E 75   .db "minutes: ", 0
2915   1931 74 65 73 3A 
2915   1935 20 00 
2916   1937             s_set_seconds:
2917   1937 73 65 63 6F   .db "seconds: ", 0
2917   193B 6E 64 73 3A 
2917   193F 20 00 
2918   1941             s_months:      
2919   1941 20 20 20 00   .db "   ", 0
2920   1945 6A 61 6E 00   .db "jan", 0
2921   1949 66 65 62 00   .db "feb", 0
2922   194D 6D 61 72 00   .db "mar", 0
2923   1951 61 70 72 00   .db "apr", 0
2924   1955 6D 61 79 00   .db "may", 0
2925   1959 6A 75 6E 00   .db "jun", 0
2926   195D 6A 75 6C 00   .db "jul", 0
2927   1961 61 75 67 00   .db "aug", 0
2928   1965 73 65 70 00   .db "sep", 0
2929   1969 6F 63 74 00   .db "oct", 0
2930   196D 6E 6F 76 00   .db "nov", 0
2931   1971 64 65 63 00   .db "dec", 0
2932   1975             
2933   1975             s_week:        
2934   1975 73 75 6E 00   .db "sun", 0 
2935   1979 6D 6F 6E 00   .db "mon", 0 
2936   197D 74 75 65 00   .db "tue", 0 
2937   1981 77 65 64 00   .db "wed", 0 
2938   1985 74 68 75 00   .db "thu", 0 
2939   1989 66 72 69 00   .db "fri", 0 
2940   198D 73 61 74 00   .db "sat", 0
2941   1991             
2942   1991             s_fdc_config:
2943   1991 0A 0D 73 65   .db "\n\rselecting diskette drive 0, side 0, single density, head loaded\n\r", 0
2943   1995 6C 65 63 74 
2943   1999 69 6E 67 20 
2943   199D 64 69 73 6B 
2943   19A1 65 74 74 65 
2943   19A5 20 64 72 69 
2943   19A9 76 65 20 30 
2943   19AD 2C 20 73 69 
2943   19B1 64 65 20 30 
2943   19B5 2C 20 73 69 
2943   19B9 6E 67 6C 65 
2943   19BD 20 64 65 6E 
2943   19C1 73 69 74 79 
2943   19C5 2C 20 68 65 
2943   19C9 61 64 20 6C 
2943   19CD 6F 61 64 65 
2943   19D1 64 0A 0D 00 
2944   19D5             
2945   19D5             proc_state_table:   
2946   19D5 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2946   19D9 00 00 00 00 
2946   19DD 00 00 00 00 
2946   19E1 00 00 00 00 
2946   19E5 00 00 00 00 
2946   19E9 00 00 00 00 
2946   19ED 00 00 00 00 
2946   19F1 00 00 00 00 
2946   19F5 00 00 00 00 
2946   19F9 00 00 00 00 
2946   19FD 00 00 00 00 
2946   1A01 00 00 00 00 
2946   1A05 00 00 00 00 
2946   1A09 00 00 00 00 
2946   1A0D 00 00 00 00 
2946   1A11 00 00 00 00 
2946   1A15 00 00 00 00 
2946   1A19 00 00 00 00 
2946   1A1D 00 00 00 00 
2946   1A21 00 00 00 00 
2946   1A25 00 00 00 00 
2946   1A29 00 00 00 00 
2946   1A2D 00 00 00 00 
2946   1A31 00 00 00 00 
2946   1A35 00 00 00 00 
2946   1A39 00 00 00 00 
2946   1A3D 00 00 00 00 
2946   1A41 00 00 00 00 
2946   1A45 00 00 00 00 
2946   1A49 00 00 00 00 
2946   1A4D 00 00 00 00 
2946   1A51 00 00 00 00 
2946   1A55 00 00 00 00 
2946   1A59 00 00 00 00 
2946   1A5D 00 00 00 00 
2946   1A61 00 00 00 00 
2946   1A65 00 00 00 00 
2946   1A69 00 00 00 00 
2946   1A6D 00 00 00 00 
2946   1A71 00 00 00 00 
2946   1A75 00 00 00 00 
2946   1A79 00 00 00 00 
2946   1A7D 00 00 00 00 
2946   1A81 00 00 00 00 
2946   1A85 00 00 00 00 
2946   1A89 00 00 00 00 
2946   1A8D 00 00 00 00 
2946   1A91 00 00 00 00 
2946   1A95 00 00 00 00 
2946   1A99 00 00 00 00 
2946   1A9D 00 00 00 00 
2946   1AA1 00 00 00 00 
2946   1AA5 00 00 00 00 
2946   1AA9 00 00 00 00 
2946   1AAD 00 00 00 00 
2946   1AB1 00 00 00 00 
2946   1AB5 00 00 00 00 
2946   1AB9 00 00 00 00 
2946   1ABD 00 00 00 00 
2946   1AC1 00 00 00 00 
2946   1AC5 00 00 00 00 
2946   1AC9 00 00 00 00 
2946   1ACD 00 00 00 00 
2946   1AD1 00 00 00 00 
2946   1AD5 00 00 00 00 
2946   1AD9 00 00 00 00 
2946   1ADD 00 00 00 00 
2946   1AE1 00 00 00 00 
2946   1AE5 00 00 00 00 
2946   1AE9 00 00 00 00 
2946   1AED 00 00 00 00 
2946   1AF1 00 00 00 00 
2946   1AF5 00 00 00 00 
2946   1AF9 00 00 00 00 
2946   1AFD 00 00 00 00 
2946   1B01 00 00 00 00 
2946   1B05 00 00 00 00 
2946   1B09 00 00 00 00 
2946   1B0D 00 00 00 00 
2946   1B11 00 00 00 00 
2947   1B15             proc_availab_table: 
2948   1B15 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2948   1B19 00 00 00 00 
2948   1B1D 00 00 00 00 
2948   1B21 00 00 00 00 
2949   1B25             proc_names:
2950   1B25 00 00 00 00   .fill 16 * 32, 0  ; process names
2950   1B29 00 00 00 00 
2950   1B2D 00 00 00 00 
2950   1B31 00 00 00 00 
2950   1B35 00 00 00 00 
2950   1B39 00 00 00 00 
2950   1B3D 00 00 00 00 
2950   1B41 00 00 00 00 
2950   1B45 00 00 00 00 
2950   1B49 00 00 00 00 
2950   1B4D 00 00 00 00 
2950   1B51 00 00 00 00 
2950   1B55 00 00 00 00 
2950   1B59 00 00 00 00 
2950   1B5D 00 00 00 00 
2950   1B61 00 00 00 00 
2950   1B65 00 00 00 00 
2950   1B69 00 00 00 00 
2950   1B6D 00 00 00 00 
2950   1B71 00 00 00 00 
2950   1B75 00 00 00 00 
2950   1B79 00 00 00 00 
2950   1B7D 00 00 00 00 
2950   1B81 00 00 00 00 
2950   1B85 00 00 00 00 
2950   1B89 00 00 00 00 
2950   1B8D 00 00 00 00 
2950   1B91 00 00 00 00 
2950   1B95 00 00 00 00 
2950   1B99 00 00 00 00 
2950   1B9D 00 00 00 00 
2950   1BA1 00 00 00 00 
2950   1BA5 00 00 00 00 
2950   1BA9 00 00 00 00 
2950   1BAD 00 00 00 00 
2950   1BB1 00 00 00 00 
2950   1BB5 00 00 00 00 
2950   1BB9 00 00 00 00 
2950   1BBD 00 00 00 00 
2950   1BC1 00 00 00 00 
2950   1BC5 00 00 00 00 
2950   1BC9 00 00 00 00 
2950   1BCD 00 00 00 00 
2950   1BD1 00 00 00 00 
2950   1BD5 00 00 00 00 
2950   1BD9 00 00 00 00 
2950   1BDD 00 00 00 00 
2950   1BE1 00 00 00 00 
2950   1BE5 00 00 00 00 
2950   1BE9 00 00 00 00 
2950   1BED 00 00 00 00 
2950   1BF1 00 00 00 00 
2950   1BF5 00 00 00 00 
2950   1BF9 00 00 00 00 
2950   1BFD 00 00 00 00 
2950   1C01 00 00 00 00 
2950   1C05 00 00 00 00 
2950   1C09 00 00 00 00 
2950   1C0D 00 00 00 00 
2950   1C11 00 00 00 00 
2950   1C15 00 00 00 00 
2950   1C19 00 00 00 00 
2950   1C1D 00 00 00 00 
2950   1C21 00 00 00 00 
2950   1C25 00 00 00 00 
2950   1C29 00 00 00 00 
2950   1C2D 00 00 00 00 
2950   1C31 00 00 00 00 
2950   1C35 00 00 00 00 
2950   1C39 00 00 00 00 
2950   1C3D 00 00 00 00 
2950   1C41 00 00 00 00 
2950   1C45 00 00 00 00 
2950   1C49 00 00 00 00 
2950   1C4D 00 00 00 00 
2950   1C51 00 00 00 00 
2950   1C55 00 00 00 00 
2950   1C59 00 00 00 00 
2950   1C5D 00 00 00 00 
2950   1C61 00 00 00 00 
2950   1C65 00 00 00 00 
2950   1C69 00 00 00 00 
2950   1C6D 00 00 00 00 
2950   1C71 00 00 00 00 
2950   1C75 00 00 00 00 
2950   1C79 00 00 00 00 
2950   1C7D 00 00 00 00 
2950   1C81 00 00 00 00 
2950   1C85 00 00 00 00 
2950   1C89 00 00 00 00 
2950   1C8D 00 00 00 00 
2950   1C91 00 00 00 00 
2950   1C95 00 00 00 00 
2950   1C99 00 00 00 00 
2950   1C9D 00 00 00 00 
2950   1CA1 00 00 00 00 
2950   1CA5 00 00 00 00 
2950   1CA9 00 00 00 00 
2950   1CAD 00 00 00 00 
2950   1CB1 00 00 00 00 
2950   1CB5 00 00 00 00 
2950   1CB9 00 00 00 00 
2950   1CBD 00 00 00 00 
2950   1CC1 00 00 00 00 
2950   1CC5 00 00 00 00 
2950   1CC9 00 00 00 00 
2950   1CCD 00 00 00 00 
2950   1CD1 00 00 00 00 
2950   1CD5 00 00 00 00 
2950   1CD9 00 00 00 00 
2950   1CDD 00 00 00 00 
2950   1CE1 00 00 00 00 
2950   1CE5 00 00 00 00 
2950   1CE9 00 00 00 00 
2950   1CED 00 00 00 00 
2950   1CF1 00 00 00 00 
2950   1CF5 00 00 00 00 
2950   1CF9 00 00 00 00 
2950   1CFD 00 00 00 00 
2950   1D01 00 00 00 00 
2950   1D05 00 00 00 00 
2950   1D09 00 00 00 00 
2950   1D0D 00 00 00 00 
2950   1D11 00 00 00 00 
2950   1D15 00 00 00 00 
2950   1D19 00 00 00 00 
2950   1D1D 00 00 00 00 
2950   1D21 00 00 00 00 
2951   1D25             filename:
2952   1D25 00 00 00 00   .fill 128, 0      ; holds a path for file search
2952   1D29 00 00 00 00 
2952   1D2D 00 00 00 00 
2952   1D31 00 00 00 00 
2952   1D35 00 00 00 00 
2952   1D39 00 00 00 00 
2952   1D3D 00 00 00 00 
2952   1D41 00 00 00 00 
2952   1D45 00 00 00 00 
2952   1D49 00 00 00 00 
2952   1D4D 00 00 00 00 
2952   1D51 00 00 00 00 
2952   1D55 00 00 00 00 
2952   1D59 00 00 00 00 
2952   1D5D 00 00 00 00 
2952   1D61 00 00 00 00 
2952   1D65 00 00 00 00 
2952   1D69 00 00 00 00 
2952   1D6D 00 00 00 00 
2952   1D71 00 00 00 00 
2952   1D75 00 00 00 00 
2952   1D79 00 00 00 00 
2952   1D7D 00 00 00 00 
2952   1D81 00 00 00 00 
2952   1D85 00 00 00 00 
2952   1D89 00 00 00 00 
2952   1D8D 00 00 00 00 
2952   1D91 00 00 00 00 
2952   1D95 00 00 00 00 
2952   1D99 00 00 00 00 
2952   1D9D 00 00 00 00 
2952   1DA1 00 00 00 00 
2953   1DA5             user_data:
2954   1DA5 00 00 00 00   .fill 512, 0      ;  user space data
2954   1DA9 00 00 00 00 
2954   1DAD 00 00 00 00 
2954   1DB1 00 00 00 00 
2954   1DB5 00 00 00 00 
2954   1DB9 00 00 00 00 
2954   1DBD 00 00 00 00 
2954   1DC1 00 00 00 00 
2954   1DC5 00 00 00 00 
2954   1DC9 00 00 00 00 
2954   1DCD 00 00 00 00 
2954   1DD1 00 00 00 00 
2954   1DD5 00 00 00 00 
2954   1DD9 00 00 00 00 
2954   1DDD 00 00 00 00 
2954   1DE1 00 00 00 00 
2954   1DE5 00 00 00 00 
2954   1DE9 00 00 00 00 
2954   1DED 00 00 00 00 
2954   1DF1 00 00 00 00 
2954   1DF5 00 00 00 00 
2954   1DF9 00 00 00 00 
2954   1DFD 00 00 00 00 
2954   1E01 00 00 00 00 
2954   1E05 00 00 00 00 
2954   1E09 00 00 00 00 
2954   1E0D 00 00 00 00 
2954   1E11 00 00 00 00 
2954   1E15 00 00 00 00 
2954   1E19 00 00 00 00 
2954   1E1D 00 00 00 00 
2954   1E21 00 00 00 00 
2954   1E25 00 00 00 00 
2954   1E29 00 00 00 00 
2954   1E2D 00 00 00 00 
2954   1E31 00 00 00 00 
2954   1E35 00 00 00 00 
2954   1E39 00 00 00 00 
2954   1E3D 00 00 00 00 
2954   1E41 00 00 00 00 
2954   1E45 00 00 00 00 
2954   1E49 00 00 00 00 
2954   1E4D 00 00 00 00 
2954   1E51 00 00 00 00 
2954   1E55 00 00 00 00 
2954   1E59 00 00 00 00 
2954   1E5D 00 00 00 00 
2954   1E61 00 00 00 00 
2954   1E65 00 00 00 00 
2954   1E69 00 00 00 00 
2954   1E6D 00 00 00 00 
2954   1E71 00 00 00 00 
2954   1E75 00 00 00 00 
2954   1E79 00 00 00 00 
2954   1E7D 00 00 00 00 
2954   1E81 00 00 00 00 
2954   1E85 00 00 00 00 
2954   1E89 00 00 00 00 
2954   1E8D 00 00 00 00 
2954   1E91 00 00 00 00 
2954   1E95 00 00 00 00 
2954   1E99 00 00 00 00 
2954   1E9D 00 00 00 00 
2954   1EA1 00 00 00 00 
2954   1EA5 00 00 00 00 
2954   1EA9 00 00 00 00 
2954   1EAD 00 00 00 00 
2954   1EB1 00 00 00 00 
2954   1EB5 00 00 00 00 
2954   1EB9 00 00 00 00 
2954   1EBD 00 00 00 00 
2954   1EC1 00 00 00 00 
2954   1EC5 00 00 00 00 
2954   1EC9 00 00 00 00 
2954   1ECD 00 00 00 00 
2954   1ED1 00 00 00 00 
2954   1ED5 00 00 00 00 
2954   1ED9 00 00 00 00 
2954   1EDD 00 00 00 00 
2954   1EE1 00 00 00 00 
2954   1EE5 00 00 00 00 
2954   1EE9 00 00 00 00 
2954   1EED 00 00 00 00 
2954   1EF1 00 00 00 00 
2954   1EF5 00 00 00 00 
2954   1EF9 00 00 00 00 
2954   1EFD 00 00 00 00 
2954   1F01 00 00 00 00 
2954   1F05 00 00 00 00 
2954   1F09 00 00 00 00 
2954   1F0D 00 00 00 00 
2954   1F11 00 00 00 00 
2954   1F15 00 00 00 00 
2954   1F19 00 00 00 00 
2954   1F1D 00 00 00 00 
2954   1F21 00 00 00 00 
2954   1F25 00 00 00 00 
2954   1F29 00 00 00 00 
2954   1F2D 00 00 00 00 
2954   1F31 00 00 00 00 
2954   1F35 00 00 00 00 
2954   1F39 00 00 00 00 
2954   1F3D 00 00 00 00 
2954   1F41 00 00 00 00 
2954   1F45 00 00 00 00 
2954   1F49 00 00 00 00 
2954   1F4D 00 00 00 00 
2954   1F51 00 00 00 00 
2954   1F55 00 00 00 00 
2954   1F59 00 00 00 00 
2954   1F5D 00 00 00 00 
2954   1F61 00 00 00 00 
2954   1F65 00 00 00 00 
2954   1F69 00 00 00 00 
2954   1F6D 00 00 00 00 
2954   1F71 00 00 00 00 
2954   1F75 00 00 00 00 
2954   1F79 00 00 00 00 
2954   1F7D 00 00 00 00 
2954   1F81 00 00 00 00 
2954   1F85 00 00 00 00 
2954   1F89 00 00 00 00 
2954   1F8D 00 00 00 00 
2954   1F91 00 00 00 00 
2954   1F95 00 00 00 00 
2954   1F99 00 00 00 00 
2954   1F9D 00 00 00 00 
2954   1FA1 00 00 00 00 
2955   1FA5             fifo:
2956   1FA5 FF FF FF FF   .fill fifo_size
2956   1FA9 FF FF FF FF 
2956   1FAD FF FF FF FF 
2956   1FB1 FF FF FF FF 
2956   1FB5 FF FF FF FF 
2956   1FB9 FF FF FF FF 
2956   1FBD FF FF FF FF 
2956   1FC1 FF FF FF FF 
2956   1FC5 FF FF FF FF 
2956   1FC9 FF FF FF FF 
2956   1FCD FF FF FF FF 
2956   1FD1 FF FF FF FF 
2956   1FD5 FF FF FF FF 
2956   1FD9 FF FF FF FF 
2956   1FDD FF FF FF FF 
2956   1FE1 FF FF FF FF 
2956   1FE5 FF FF FF FF 
2956   1FE9 FF FF FF FF 
2956   1FED FF FF FF FF 
2956   1FF1 FF FF FF FF 
2956   1FF5 FF FF FF FF 
2956   1FF9 FF FF FF FF 
2956   1FFD FF FF FF FF 
2956   2001 FF FF FF FF 
2956   2005 FF FF FF FF 
2956   2009 FF FF FF FF 
2956   200D FF FF FF FF 
2956   2011 FF FF FF FF 
2956   2015 FF FF FF FF 
2956   2019 FF FF FF FF 
2956   201D FF FF FF FF 
2956   2021 FF FF FF FF 
2956   2025 FF FF FF FF 
2956   2029 FF FF FF FF 
2956   202D FF FF FF FF 
2956   2031 FF FF FF FF 
2956   2035 FF FF FF FF 
2956   2039 FF FF FF FF 
2956   203D FF FF FF FF 
2956   2041 FF FF FF FF 
2956   2045 FF FF FF FF 
2956   2049 FF FF FF FF 
2956   204D FF FF FF FF 
2956   2051 FF FF FF FF 
2956   2055 FF FF FF FF 
2956   2059 FF FF FF FF 
2956   205D FF FF FF FF 
2956   2061 FF FF FF FF 
2956   2065 FF FF FF FF 
2956   2069 FF FF FF FF 
2956   206D FF FF FF FF 
2956   2071 FF FF FF FF 
2956   2075 FF FF FF FF 
2956   2079 FF FF FF FF 
2956   207D FF FF FF FF 
2956   2081 FF FF FF FF 
2956   2085 FF FF FF FF 
2956   2089 FF FF FF FF 
2956   208D FF FF FF FF 
2956   2091 FF FF FF FF 
2956   2095 FF FF FF FF 
2956   2099 FF FF FF FF 
2956   209D FF FF FF FF 
2956   20A1 FF FF FF FF 
2956   20A5 FF FF FF FF 
2956   20A9 FF FF FF FF 
2956   20AD FF FF FF FF 
2956   20B1 FF FF FF FF 
2956   20B5 FF FF FF FF 
2956   20B9 FF FF FF FF 
2956   20BD FF FF FF FF 
2956   20C1 FF FF FF FF 
2956   20C5 FF FF FF FF 
2956   20C9 FF FF FF FF 
2956   20CD FF FF FF FF 
2956   20D1 FF FF FF FF 
2956   20D5 FF FF FF FF 
2956   20D9 FF FF FF FF 
2956   20DD FF FF FF FF 
2956   20E1 FF FF FF FF 
2956   20E5 FF FF FF FF 
2956   20E9 FF FF FF FF 
2956   20ED FF FF FF FF 
2956   20F1 FF FF FF FF 
2956   20F5 FF FF FF FF 
2956   20F9 FF FF FF FF 
2956   20FD FF FF FF FF 
2956   2101 FF FF FF FF 
2956   2105 FF FF FF FF 
2956   2109 FF FF FF FF 
2956   210D FF FF FF FF 
2956   2111 FF FF FF FF 
2956   2115 FF FF FF FF 
2956   2119 FF FF FF FF 
2956   211D FF FF FF FF 
2956   2121 FF FF FF FF 
2956   2125 FF FF FF FF 
2956   2129 FF FF FF FF 
2956   212D FF FF FF FF 
2956   2131 FF FF FF FF 
2956   2135 FF FF FF FF 
2956   2139 FF FF FF FF 
2956   213D FF FF FF FF 
2956   2141 FF FF FF FF 
2956   2145 FF FF FF FF 
2956   2149 FF FF FF FF 
2956   214D FF FF FF FF 
2956   2151 FF FF FF FF 
2956   2155 FF FF FF FF 
2956   2159 FF FF FF FF 
2956   215D FF FF FF FF 
2956   2161 FF FF FF FF 
2956   2165 FF FF FF FF 
2956   2169 FF FF FF FF 
2956   216D FF FF FF FF 
2956   2171 FF FF FF FF 
2956   2175 FF FF FF FF 
2956   2179 FF FF FF FF 
2956   217D FF FF FF FF 
2956   2181 FF FF FF FF 
2956   2185 FF FF FF FF 
2956   2189 FF FF FF FF 
2956   218D FF FF FF FF 
2956   2191 FF FF FF FF 
2956   2195 FF FF FF FF 
2956   2199 FF FF FF FF 
2956   219D FF FF FF FF 
2956   21A1 FF FF FF FF 
2956   21A5 FF FF FF FF 
2956   21A9 FF FF FF FF 
2956   21AD FF FF FF FF 
2956   21B1 FF FF FF FF 
2956   21B5 FF FF FF FF 
2956   21B9 FF FF FF FF 
2956   21BD FF FF FF FF 
2956   21C1 FF FF FF FF 
2956   21C5 FF FF FF FF 
2956   21C9 FF FF FF FF 
2956   21CD FF FF FF FF 
2956   21D1 FF FF FF FF 
2956   21D5 FF FF FF FF 
2956   21D9 FF FF FF FF 
2956   21DD FF FF FF FF 
2956   21E1 FF FF FF FF 
2956   21E5 FF FF FF FF 
2956   21E9 FF FF FF FF 
2956   21ED FF FF FF FF 
2956   21F1 FF FF FF FF 
2956   21F5 FF FF FF FF 
2956   21F9 FF FF FF FF 
2956   21FD FF FF FF FF 
2956   2201 FF FF FF FF 
2956   2205 FF FF FF FF 
2956   2209 FF FF FF FF 
2956   220D FF FF FF FF 
2956   2211 FF FF FF FF 
2956   2215 FF FF FF FF 
2956   2219 FF FF FF FF 
2956   221D FF FF FF FF 
2956   2221 FF FF FF FF 
2956   2225 FF FF FF FF 
2956   2229 FF FF FF FF 
2956   222D FF FF FF FF 
2956   2231 FF FF FF FF 
2956   2235 FF FF FF FF 
2956   2239 FF FF FF FF 
2956   223D FF FF FF FF 
2956   2241 FF FF FF FF 
2956   2245 FF FF FF FF 
2956   2249 FF FF FF FF 
2956   224D FF FF FF FF 
2956   2251 FF FF FF FF 
2956   2255 FF FF FF FF 
2956   2259 FF FF FF FF 
2956   225D FF FF FF FF 
2956   2261 FF FF FF FF 
2956   2265 FF FF FF FF 
2956   2269 FF FF FF FF 
2956   226D FF FF FF FF 
2956   2271 FF FF FF FF 
2956   2275 FF FF FF FF 
2956   2279 FF FF FF FF 
2956   227D FF FF FF FF 
2956   2281 FF FF FF FF 
2956   2285 FF FF FF FF 
2956   2289 FF FF FF FF 
2956   228D FF FF FF FF 
2956   2291 FF FF FF FF 
2956   2295 FF FF FF FF 
2956   2299 FF FF FF FF 
2956   229D FF FF FF FF 
2956   22A1 FF FF FF FF 
2956   22A5 FF FF FF FF 
2956   22A9 FF FF FF FF 
2956   22AD FF FF FF FF 
2956   22B1 FF FF FF FF 
2956   22B5 FF FF FF FF 
2956   22B9 FF FF FF FF 
2956   22BD FF FF FF FF 
2956   22C1 FF FF FF FF 
2956   22C5 FF FF FF FF 
2956   22C9 FF FF FF FF 
2956   22CD FF FF FF FF 
2956   22D1 FF FF FF FF 
2956   22D5 FF FF FF FF 
2956   22D9 FF FF FF FF 
2956   22DD FF FF FF FF 
2956   22E1 FF FF FF FF 
2956   22E5 FF FF FF FF 
2956   22E9 FF FF FF FF 
2956   22ED FF FF FF FF 
2956   22F1 FF FF FF FF 
2956   22F5 FF FF FF FF 
2956   22F9 FF FF FF FF 
2956   22FD FF FF FF FF 
2956   2301 FF FF FF FF 
2956   2305 FF FF FF FF 
2956   2309 FF FF FF FF 
2956   230D FF FF FF FF 
2956   2311 FF FF FF FF 
2956   2315 FF FF FF FF 
2956   2319 FF FF FF FF 
2956   231D FF FF FF FF 
2956   2321 FF FF FF FF 
2956   2325 FF FF FF FF 
2956   2329 FF FF FF FF 
2956   232D FF FF FF FF 
2956   2331 FF FF FF FF 
2956   2335 FF FF FF FF 
2956   2339 FF FF FF FF 
2956   233D FF FF FF FF 
2956   2341 FF FF FF FF 
2956   2345 FF FF FF FF 
2956   2349 FF FF FF FF 
2956   234D FF FF FF FF 
2956   2351 FF FF FF FF 
2956   2355 FF FF FF FF 
2956   2359 FF FF FF FF 
2956   235D FF FF FF FF 
2956   2361 FF FF FF FF 
2956   2365 FF FF FF FF 
2956   2369 FF FF FF FF 
2956   236D FF FF FF FF 
2956   2371 FF FF FF FF 
2956   2375 FF FF FF FF 
2956   2379 FF FF FF FF 
2956   237D FF FF FF FF 
2956   2381 FF FF FF FF 
2956   2385 FF FF FF FF 
2956   2389 FF FF FF FF 
2956   238D FF FF FF FF 
2956   2391 FF FF FF FF 
2956   2395 FF FF FF FF 
2956   2399 FF FF FF FF 
2956   239D FF FF FF FF 
2956   23A1 FF FF FF FF 
2957   23A5             
2958   23A5             scrap_sector:
2959   23A5 FF FF FF FF   .fill 512         ; scrap sector
2959   23A9 FF FF FF FF 
2959   23AD FF FF FF FF 
2959   23B1 FF FF FF FF 
2959   23B5 FF FF FF FF 
2959   23B9 FF FF FF FF 
2959   23BD FF FF FF FF 
2959   23C1 FF FF FF FF 
2959   23C5 FF FF FF FF 
2959   23C9 FF FF FF FF 
2959   23CD FF FF FF FF 
2959   23D1 FF FF FF FF 
2959   23D5 FF FF FF FF 
2959   23D9 FF FF FF FF 
2959   23DD FF FF FF FF 
2959   23E1 FF FF FF FF 
2959   23E5 FF FF FF FF 
2959   23E9 FF FF FF FF 
2959   23ED FF FF FF FF 
2959   23F1 FF FF FF FF 
2959   23F5 FF FF FF FF 
2959   23F9 FF FF FF FF 
2959   23FD FF FF FF FF 
2959   2401 FF FF FF FF 
2959   2405 FF FF FF FF 
2959   2409 FF FF FF FF 
2959   240D FF FF FF FF 
2959   2411 FF FF FF FF 
2959   2415 FF FF FF FF 
2959   2419 FF FF FF FF 
2959   241D FF FF FF FF 
2959   2421 FF FF FF FF 
2959   2425 FF FF FF FF 
2959   2429 FF FF FF FF 
2959   242D FF FF FF FF 
2959   2431 FF FF FF FF 
2959   2435 FF FF FF FF 
2959   2439 FF FF FF FF 
2959   243D FF FF FF FF 
2959   2441 FF FF FF FF 
2959   2445 FF FF FF FF 
2959   2449 FF FF FF FF 
2959   244D FF FF FF FF 
2959   2451 FF FF FF FF 
2959   2455 FF FF FF FF 
2959   2459 FF FF FF FF 
2959   245D FF FF FF FF 
2959   2461 FF FF FF FF 
2959   2465 FF FF FF FF 
2959   2469 FF FF FF FF 
2959   246D FF FF FF FF 
2959   2471 FF FF FF FF 
2959   2475 FF FF FF FF 
2959   2479 FF FF FF FF 
2959   247D FF FF FF FF 
2959   2481 FF FF FF FF 
2959   2485 FF FF FF FF 
2959   2489 FF FF FF FF 
2959   248D FF FF FF FF 
2959   2491 FF FF FF FF 
2959   2495 FF FF FF FF 
2959   2499 FF FF FF FF 
2959   249D FF FF FF FF 
2959   24A1 FF FF FF FF 
2959   24A5 FF FF FF FF 
2959   24A9 FF FF FF FF 
2959   24AD FF FF FF FF 
2959   24B1 FF FF FF FF 
2959   24B5 FF FF FF FF 
2959   24B9 FF FF FF FF 
2959   24BD FF FF FF FF 
2959   24C1 FF FF FF FF 
2959   24C5 FF FF FF FF 
2959   24C9 FF FF FF FF 
2959   24CD FF FF FF FF 
2959   24D1 FF FF FF FF 
2959   24D5 FF FF FF FF 
2959   24D9 FF FF FF FF 
2959   24DD FF FF FF FF 
2959   24E1 FF FF FF FF 
2959   24E5 FF FF FF FF 
2959   24E9 FF FF FF FF 
2959   24ED FF FF FF FF 
2959   24F1 FF FF FF FF 
2959   24F5 FF FF FF FF 
2959   24F9 FF FF FF FF 
2959   24FD FF FF FF FF 
2959   2501 FF FF FF FF 
2959   2505 FF FF FF FF 
2959   2509 FF FF FF FF 
2959   250D FF FF FF FF 
2959   2511 FF FF FF FF 
2959   2515 FF FF FF FF 
2959   2519 FF FF FF FF 
2959   251D FF FF FF FF 
2959   2521 FF FF FF FF 
2959   2525 FF FF FF FF 
2959   2529 FF FF FF FF 
2959   252D FF FF FF FF 
2959   2531 FF FF FF FF 
2959   2535 FF FF FF FF 
2959   2539 FF FF FF FF 
2959   253D FF FF FF FF 
2959   2541 FF FF FF FF 
2959   2545 FF FF FF FF 
2959   2549 FF FF FF FF 
2959   254D FF FF FF FF 
2959   2551 FF FF FF FF 
2959   2555 FF FF FF FF 
2959   2559 FF FF FF FF 
2959   255D FF FF FF FF 
2959   2561 FF FF FF FF 
2959   2565 FF FF FF FF 
2959   2569 FF FF FF FF 
2959   256D FF FF FF FF 
2959   2571 FF FF FF FF 
2959   2575 FF FF FF FF 
2959   2579 FF FF FF FF 
2959   257D FF FF FF FF 
2959   2581 FF FF FF FF 
2959   2585 FF FF FF FF 
2959   2589 FF FF FF FF 
2959   258D FF FF FF FF 
2959   2591 FF FF FF FF 
2959   2595 FF FF FF FF 
2959   2599 FF FF FF FF 
2959   259D FF FF FF FF 
2959   25A1 FF FF FF FF 
2960   25A5             transient_area:
2961   25A5 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2962   25A6             
2963   25A6             .end
tasm: Number of errors = 0
