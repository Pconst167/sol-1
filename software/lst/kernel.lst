0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 48 00       .dw int_6
0141   000E 94 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 4F 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 D2 02       .dw trap_privilege
0153   0014 EF 03       .dw trap_div_zero
0154   0016 FC 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 DE 02       .dw syscall_break
0165   0022 FD 03       .dw syscall_rtc
0166   0024 37 05       .dw syscall_ide
0167   0026 12 06       .dw syscall_io
0168   0028 CF 06       .dw syscall_file_system
0169   002A 9C 0F       .dw syscall_create_proc
0170   002C 97 02       .dw syscall_list_procs
0171   002E 2F 04       .dw syscall_datetime
0172   0030 53 02       .dw syscall_reboot
0173   0032 66 0F       .dw syscall_pause_proc
0174   0034 5F 02       .dw syscall_resume_proc
0175   0036 23 0F       .dw syscall_terminate_proc
0176   0038 1F 02       .dw syscall_system
0177   003A E3 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; aliases for individual 'al' options for FDC system calls
0198   003C             sys_fdc_restore      .equ 0
0199   003C             sys_fdc_step         .equ 1
0200   003C             sys_fdc_step_in      .equ 2
0201   003C             sys_fdc_step_out     .equ 3
0202   003C             sys_fdc_seek         .equ 4
0203   003C             sys_fdc_format       .equ 5
0204   003C             sys_fdc_read_addr    .equ 6
0205   003C             sys_fdc_read_track   .equ 7
0206   003C             sys_fdc_read_sect    .equ 8
0207   003C             sys_fdc_write_sect   .equ 9
0208   003C             sys_fdc_force_int    .equ 10
0209   003C             sys_fdc_status0      .equ 11
0210   003C             sys_fdc_status1      .equ 12
0211   003C             
0212   003C             ; ------------------------------------------------------------------------------------------------------------------;
0213   003C             ; alias exports
0214   003C             ; ------------------------------------------------------------------------------------------------------------------;
0215   003C             .export text_org
0216   003C             .export sys_break
0217   003C             .export sys_rtc
0218   003C             .export sys_ide
0219   003C             .export sys_io
0220   003C             .export sys_filesystem
0221   003C             .export sys_create_proc
0222   003C             .export sys_list_proc
0223   003C             .export sys_datetime
0224   003C             .export sys_reboot
0225   003C             .export sys_pause_proc
0226   003C             .export sys_resume_proc
0227   003C             .export sys_terminate_proc
0228   003C             .export sys_system
0229   003C             .export sys_fdc
0230   003C             
0231   003C             ; exports of aliases for individual 'al' options for FDC system calls
0232   003C             .export sys_fdc_restore
0233   003C             .export sys_fdc_step
0234   003C             .export sys_fdc_step_in
0235   003C             .export sys_fdc_step_out
0236   003C             .export sys_fdc_seek
0237   003C             .export sys_fdc_format
0238   003C             .export sys_fdc_read_addr
0239   003C             .export sys_fdc_read_track
0240   003C             .export sys_fdc_read_sect
0241   003C             .export sys_fdc_write_sect
0242   003C             .export sys_fdc_force_int
0243   003C             .export sys_fdc_status0
0244   003C             .export sys_fdc_status1
0245   003C             ; ------------------------------------------------------------------------------------------------------------------;
0246   003C             ; irqs' code block
0247   003C             ; ------------------------------------------------------------------------------------------------------------------;
0248   003C             ; 5.25" floppy drive controller irq
0249   003C             int_0_fdc:
0250   003C 3B 17 19      mov d, s_fdc_irq
0251   003F 07 A3 12      call _puts
0252   0042 06            sysret
0253   0043             int_1:
0254   0043 06            sysret
0255   0044             int_2:
0256   0044 06            sysret
0257   0045             int_3:
0258   0045 06            sysret
0259   0046             int_4:
0260   0046 06            sysret
0261   0047             int_5:
0262   0047 06            sysret
0263   0048             
0264   0048             ; ------------------------------------------------------------------------------------------------------------------;
0265   0048             ; process swapping
0266   0048             ; ------------------------------------------------------------------------------------------------------------------;
0267   0048             int_6:  
0268   0048 4B            pusha                             ; save all registers into kernel stack
0269   0049 22 00         mov ah, 0
0270   004B 1D D4 17      mov al, [active_proc_index]
0271   004E FD 99         shl a                             ; x2
0272   0050 B7 19 10      mov a, [proc_table_convert + a]   ; get process state start index
0273   0053 4F            mov di, a
0274   0054 48            mov a, sp
0275   0055 77            inc a
0276   0056 4D            mov si, a
0277   0057 38 14 00      mov c, 20
0278   005A FD F5         rep movsb                         ; save process state!
0279   005C             ; restore kernel stack position to point before interrupt arrived
0280   005C 51 14 00      add sp, 20
0281   005F             ; now load next process in queue
0282   005F 1D D4 17      mov al, [active_proc_index]
0283   0062 31 D3 17      mov bl, [nbr_active_procs]
0284   0065 BA            cmp al, bl
0285   0066 C6 6D 00      je int6_cycle_back
0286   0069 7A            inc al                            ; next process is next in the series
0287   006A 0A 6F 00      jmp int6_continue
0288   006D             int6_cycle_back:
0289   006D 19 01         mov al, 1                         ; next process = process 1
0290   006F             int6_continue:
0291   006F 3D D4 17      mov [active_proc_index], al       ; set next active proc
0292   0072             
0293   0072             ; calculate LUT entry for next process
0294   0072 22 00         mov ah, 0
0295   0074 FD 99         shl a                             ; x2
0296   0076 B7 19 10      mov a, [proc_table_convert + a]   ; get process state start index  
0297   0079               
0298   0079 4D            mov si, a                         ; source is proc state block
0299   007A 48            mov a, sp
0300   007B 5F 13 00      sub a, 19
0301   007E 4F            mov di, a                         ; destination is kernel stack
0302   007F             ; restore SP
0303   007F 7D            dec a
0304   0080 47            mov sp, a
0305   0081 38 14 00      mov c, 20
0306   0084 FD F5         rep movsb
0307   0086             ; set vm process
0308   0086 1D D4 17      mov al, [active_proc_index]
0309   0089 01            setptb
0310   008A F2 E0 FF 00   mov byte[_timer_c_0], 0           ; load counter 0 low byte
0311   008E F2 E0 FF 10   mov byte[_timer_c_0], $10         ; load counter 0 high byte
0312   0092 4C            popa
0313   0093 06            sysret
0314   0094             
0315   0094             ; ------------------------------------------------------------------------------------------------------------------;
0316   0094             ; uart0 interrupt
0317   0094             ; ------------------------------------------------------------------------------------------------------------------;
0318   0094             int_7_uart0:
0319   0094 D7            push a
0320   0095 DA            push d
0321   0096 E1            pushf
0322   0097 14 D9 17      mov a, [fifo_in]
0323   009A 3C            mov d, a
0324   009B 1D 80 FF      mov al, [_uart0_data]       ; get character
0325   009E B9 03         cmp al, $03                 ; ctrl-c
0326   00A0 C6 BD 00      je ctrlc
0327   00A3 B9 1A         cmp al, $1a                 ; ctrl-z
0328   00A5 C6 C3 00      je ctrlz
0329   00A8 3E            mov [d], al                 ; add to fifo
0330   00A9 14 D9 17      mov a, [fifo_in]
0331   00AC 77            inc a
0332   00AD AF 3A 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0333   00B0 C7 B6 00      jne int_7_continue
0334   00B3 10 3A 1F      mov a, fifo  
0335   00B6             int_7_continue:  
0336   00B6 42 D9 17      mov [fifo_in], a            ; update fifo pointer
0337   00B9 EE            popf
0338   00BA E7            pop d
0339   00BB E4            pop a  
0340   00BC 06            sysret
0341   00BD             ctrlc:
0342   00BD 51 05 00      add sp, 5
0343   00C0 0A 23 0F      jmp syscall_terminate_proc
0344   00C3             ctrlz:
0345   00C3 EE            popf
0346   00C4 E7            pop d
0347   00C5 E4            pop a
0348   00C6 0A 66 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0349   00C9             
0350   00C9             ; ------------------------------------------------------------------------------------------------------------------;
0351   00C9             ; floppy drive syscalls
0352   00C9             ; ------------------------------------------------------------------------------------------------------------------;
0353   00C9             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0354   00C9             ; fdc_40_ff:
0355   00C9             ;   .fill 40,  $ff    ; or 00                                                                                
0356   00C9             ; fdc_128_format_inner:
0357   00C9             ;   .fill 6,   $00    ;                                                                            <--|        
0358   00C9             ;   .fill 1,   $fe    ; id address mark                                                               |        
0359   00C9             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0360   00C9             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0361   00C9             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0362   00C9             ;   .fill 1,   $00    ; sector length                                                                 |                        
0363   00C9             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0364   00C9             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0365   00C9             ;   .fill 6,   $00    ;                                                                               |                        
0366   00C9             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0367   00C9             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0368   00C9             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0369   00C9             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0370   00C9             ; fdc_128_format_end:
0371   00C9             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0372   00C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373   00C9             fdc_jmptbl:
0374   00C9 EF 00         .dw syscall_fdc_restore
0375   00CB F4 00         .dw syscall_fdc_step
0376   00CD F5 00         .dw syscall_fdc_step_in
0377   00CF FA 00         .dw syscall_fdc_step_out
0378   00D1 FF 00         .dw syscall_fdc_seek
0379   00D3 02 01         .dw syscall_fdc_format
0380   00D5 00 01         .dw syscall_fdc_read_addr
0381   00D7 2A 01         .dw syscall_fdc_read_track
0382   00D9 4E 01         .dw syscall_fdc_read_sect
0383   00DB 7A 01         .dw syscall_fdc_write_sect
0384   00DD 01 01         .dw syscall_fdc_force_int
0385   00DF E7 00         .dw syscall_fdc_status0
0386   00E1 EB 00         .dw syscall_fdc_status1
0387   00E3             syscall_fdc:
0388   00E3 FD 0A C9 00   jmp [fdc_jmptbl + al]
0389   00E7             
0390   00E7             syscall_fdc_status0:
0391   00E7 1D C1 FF      mov al, [_fdc_status_0]
0392   00EA 06            sysret
0393   00EB             syscall_fdc_status1:
0394   00EB 1D C8 FF      mov al, [_fdc_stat_cmd]
0395   00EE 06            sysret
0396   00EF             syscall_fdc_restore:
0397   00EF F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0398   00F3 06            sysret
0399   00F4             
0400   00F4             syscall_fdc_step:
0401   00F4 06            sysret
0402   00F5             
0403   00F5             syscall_fdc_step_in:
0404   00F5 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0405   00F9 06            sysret
0406   00FA             
0407   00FA             syscall_fdc_step_out:
0408   00FA F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0409   00FE 06            sysret
0410   00FF             
0411   00FF             syscall_fdc_seek:
0412   00FF 06            sysret
0413   0100             
0414   0100             syscall_fdc_read_addr:
0415   0100 06            sysret
0416   0101             
0417   0101             syscall_fdc_force_int:
0418   0101 06            sysret
0419   0102             
0420   0102             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0421   0102             ; in the ram formatting block because they are all set as 00 right now
0422   0102             ; bl: track number
0423   0102             syscall_fdc_format:
0424   0102 FD 3D C9 FF   mov [_fdc_track], bl
0425   0106 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0426   010A             ;fdc_wait_busy_high:
0427   010A             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0428   010A             ;  test al, $01                ; 
0429   010A             ;  jz fdc_wait_busy_high
0430   010A FD 4D 3A 25   mov si, transient_area
0431   010E F6            lodsb
0432   010F 3D CB FF      mov [_fdc_data], al      ; 10   
0433   0112 07 0E 02      call fdc_wait_64us
0434   0115             fdc_format_drq:
0435   0115 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0436   0118 93 01         test al, $01                ; 4
0437   011A C6 29 01      jz fdc_format_end           ; 8
0438   011D 93 02         test al, $02                ; 4
0439   011F C6 15 01      jz fdc_format_drq           ; 8
0440   0122 F6            lodsb                       ; 7
0441   0123 3D CB FF      mov [_fdc_data], al         ; 10   
0442   0126 0A 15 01      jmp fdc_format_drq
0443   0129             fdc_format_end:
0444   0129 06            sysret
0445   012A             
0446   012A             syscall_fdc_read_track:
0447   012A F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0448   012E 07 0E 02      call fdc_wait_64us
0449   0131             ;fdc_wait_busy_high1:
0450   0131             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0451   0131             ;  test al, $01                    ; 
0452   0131             ;  jz fdc_wait_busy_high1
0453   0131 FD 4F 3A 25   mov di, transient_area
0454   0135             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0455   0135 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0456   0138 93 01         test al, $01                ; check busy bit
0457   013A C6 49 01      jz fdc_read_track_end
0458   013D 93 02         test al, $02                ; check drq bit
0459   013F C6 35 01      jz fdc_read_track_l0
0460   0142 1D CB FF      mov al, [_fdc_data]     ; 
0461   0145 F7            stosb
0462   0146 0A 35 01      jmp fdc_read_track_l0
0463   0149             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0464   0149             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0465   0149             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0466   0149             fdc_read_track_end:
0467   0149 50            mov a, di
0468   014A 5F 3A 25      sub a, transient_area
0469   014D 06            sysret
0470   014E             
0471   014E             ; sector in bl
0472   014E             ; track in bh
0473   014E             syscall_fdc_read_sect:
0474   014E 11            mov a, b
0475   014F 3D CA FF      mov [_fdc_sector], al
0476   0152 1A            mov al, ah
0477   0153 3D C9 FF      mov [_fdc_track], al
0478   0156 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0479   015A 07 0E 02      call fdc_wait_64us
0480   015D             ;fdc_wait_busy_high2:
0481   015D             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0482   015D             ;  test al, $01                ; 
0483   015D             ;  jz fdc_wait_busy_high2
0484   015D FD 4F 3A 25   mov di, transient_area
0485   0161             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0486   0161 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0487   0164 93 01         test al, $01                ; check drq bit
0488   0166 C6 75 01      jz fdc_read_sect_end
0489   0169 93 02         test al, $02                ; check drq bit
0490   016B C6 61 01      jz fdc_read_sect_l0
0491   016E 1D CB FF      mov al, [_fdc_data]     ; 
0492   0171 F7            stosb
0493   0172 0A 61 01      jmp fdc_read_sect_l0
0494   0175             fdc_read_sect_end:
0495   0175 50            mov a, di
0496   0176 5F 3A 25      sub a, transient_area
0497   0179 06            sysret
0498   017A             
0499   017A             ; sector in al
0500   017A             ; track in ah
0501   017A             ; data pointer in si
0502   017A             syscall_fdc_write_sect:
0503   017A 11            mov a, b
0504   017B 3D CA FF      mov [_fdc_sector], al
0505   017E 1A            mov al, ah
0506   017F 3D C9 FF      mov [_fdc_track], al
0507   0182 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0508   0186             ;fdc_wait_busy_high2:
0509   0186             ;  mov al, [_fdc_wd_stat_cmd]    
0510   0186             ;  test al, $01                
0511   0186             ;  jz fdc_wait_busy_high2
0512   0186 F6            lodsb                      
0513   0187 3D CB FF      mov [_fdc_data], al      
0514   018A 07 0E 02      call fdc_wait_64us
0515   018D             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0516   018D 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0517   0190 93 01         test al, $01                ; 4
0518   0192 C6 A1 01      jz fdc_write_sect_end           ; 8
0519   0195 93 02         test al, $02                ; 4
0520   0197 C6 8D 01      jz fdc_write_sect_l0           ; 8
0521   019A F6            lodsb                       ; 7
0522   019B 3D CB FF      mov [_fdc_data], al      ; 10   
0523   019E 0A 8D 01      jmp fdc_write_sect_l0
0524   01A1             fdc_write_sect_end:
0525   01A1 06            sysret
0526   01A2             
0527   01A2             fdc_format_mem:
0528   01A2 3B 01 00      mov d, 1
0529   01A5 FD 4F 3A 25   mov di, transient_area
0530   01A9             ; 40 * FF
0531   01A9 38 28 00      mov c, 40
0532   01AC 19 FF         mov al, $ff
0533   01AE             fdc_l0: 
0534   01AE F7            stosb
0535   01AF 7E            dec c
0536   01B0 C7 AE 01      jnz fdc_l0
0537   01B3             ; 6 * 00
0538   01B3             fdc_inner_loop:
0539   01B3 38 06 00      mov c, 6
0540   01B6 19 00         mov al, $00
0541   01B8             fdc_l1:
0542   01B8 F7            stosb
0543   01B9 7E            dec c
0544   01BA C7 B8 01      jnz fdc_l1
0545   01BD             ; FE address mark
0546   01BD             fdc_l2:
0547   01BD 19 FE         mov al, $fe
0548   01BF F7            stosb
0549   01C0             ; track number
0550   01C0             fdc_l3:
0551   01C0 19 00         mov al, $00
0552   01C2 F7            stosb
0553   01C3             ; side number
0554   01C3             fdc_l4:
0555   01C3 19 00         mov al, $00
0556   01C5 F7            stosb
0557   01C6             ; sector number
0558   01C6             fdc_l5:
0559   01C6 13            mov a, d
0560   01C7 F7            stosb
0561   01C8             ; sector length 128 bytes
0562   01C8             fdc_l6:
0563   01C8 19 00         mov al, $00
0564   01CA F7            stosb
0565   01CB             ; 2 crc's
0566   01CB             fdc_l7:
0567   01CB 19 F7         mov al, $f7
0568   01CD F7            stosb
0569   01CE             ; 11 times $ff
0570   01CE 38 0B 00      mov c, 11
0571   01D1 19 FF         mov al, $ff
0572   01D3             fdc_l8:
0573   01D3 F7            stosb
0574   01D4 7E            dec c
0575   01D5 C7 D3 01      jnz fdc_l8
0576   01D8             ; 6 times 00
0577   01D8 38 06 00      mov c, 6
0578   01DB 19 00         mov al, $00
0579   01DD             fdc_l9:
0580   01DD F7            stosb
0581   01DE 7E            dec c
0582   01DF C7 DD 01      jnz fdc_l9
0583   01E2             ; FB data address mark
0584   01E2 19 FB         mov al, $fb
0585   01E4             fdc_l10:
0586   01E4 F7            stosb
0587   01E5             ; 128 bytes sector data
0588   01E5 38 80 00      mov c, 128
0589   01E8 19 E5         mov al, $E5
0590   01EA             fdc_l11:
0591   01EA F7            stosb
0592   01EB 7E            dec c
0593   01EC C7 EA 01      jnz fdc_l11
0594   01EF             ; 2 crc's
0595   01EF             fdc_l12:
0596   01EF 19 F7         mov al, $f7
0597   01F1 F7            stosb
0598   01F2             ; 10 * $FF
0599   01F2 38 0A 00      mov c, 10
0600   01F5 19 FF         mov al, $ff
0601   01F7             fdc_l13:
0602   01F7 F7            stosb
0603   01F8 7E            dec c
0604   01F9 C7 F7 01      jnz fdc_l13
0605   01FC             ; check whether we did this 16 times
0606   01FC 79            inc d
0607   01FD C5 11 00      cmp d, 17
0608   0200 C7 B3 01      jne fdc_inner_loop
0609   0203             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0610   0203 38 F4 01      mov c, 500
0611   0206 19 FF         mov al, $ff
0612   0208             fdc_format_footer:
0613   0208             fdc_footer_drq_loop:
0614   0208 F7            stosb
0615   0209 7E            dec c
0616   020A C7 08 02      jnz fdc_footer_drq_loop
0617   020D 09            ret
0618   020E             
0619   020E             ; fetch is 2 cycles long when 'display_reg_load' is false.
0620   020E             ; 64us amounts to 160 cycles of the 2.5mhz clock
0621   020E             ; call u16 is 14 cycles long
0622   020E             ; 160 - 5 - 14 = 
0623   020E             fdc_wait_64us:
0624   020E 3A 0D         mov cl, 13                       ; 5 cycles
0625   0210             fdc_wait_64_loop:
0626   0210 81            dec cl                           ; 3 cycles
0627   0211 C7 10 02      jnz fdc_wait_64_loop             ; 8 cycles
0628   0214 09            ret
0629   0215             
0630   0215             ; ------------------------------------------------------------------------------------------------------------------;
0631   0215             ; system syscalls
0632   0215             ; ------------------------------------------------------------------------------------------------------------------;
0633   0215             system_jmptbl:
0634   0215 4B 02         .dw system_uname
0635   0217 52 02         .dw system_whoami
0636   0219 25 02         .dw system_setparam
0637   021B 28 02         .dw system_bootloader_install
0638   021D 23 02         .dw system_getparam
0639   021F             syscall_system:
0640   021F FD 0A 15 02   jmp [system_jmptbl + al]
0641   0223             
0642   0223             ; param register address in register d
0643   0223             ; param value in register bl
0644   0223             system_getparam:
0645   0223 32            mov bl, [d]
0646   0224 06            sysret
0647   0225             
0648   0225             ; param register address in register d
0649   0225             ; param value in register bl
0650   0225             system_setparam:
0651   0225 FD 3E         mov [d], bl
0652   0227 06            sysret
0653   0228             
0654   0228             ; kernel LBA address in 'b'
0655   0228             system_bootloader_install:
0656   0228 D8            push b
0657   0229 26 00 00      mov b, 0
0658   022C 38 00 00      mov c, 0
0659   022F 22 01         mov ah, $01                 ; 1 sector
0660   0231 3B 3A 25      mov d, transient_area
0661   0234 07 81 05      call ide_read_sect          ; read sector
0662   0237 E5            pop b
0663   0238 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0664   023C 26 00 00      mov b, 0
0665   023F 38 00 00      mov c, 0
0666   0242 22 01         mov ah, $01                 ; 1 sector
0667   0244 3B 3A 25      mov d, transient_area
0668   0247 07 A7 05      call ide_write_sect         ; write sector
0669   024A 06            sysret
0670   024B             
0671   024B             system_uname:
0672   024B 3B EA 17      mov d, s_uname
0673   024E 07 A3 12      call _puts
0674   0251 06            sysret
0675   0252             
0676   0252             system_whoami:
0677   0252 06            sysret
0678   0253             
0679   0253             ; reboot system
0680   0253             syscall_reboot:
0681   0253 FD D7 FF FF   push word $ffff 
0682   0257 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0683   025A FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0684   025E 06            sysret
0685   025F             
0686   025F             ;------------------------------------------------------------------------------------------------------;;
0687   025F             ; switch to another process
0688   025F             ; inputs:
0689   025F             ; al = new process number
0690   025F             ;------------------------------------------------------------------------------------------------------;;
0691   025F             syscall_resume_proc:
0692   025F FD 78         mov g, a                            ; save the process number
0693   0261 4B            pusha                               ; save all registers into kernel stack
0694   0262 22 00         mov ah, 0
0695   0264 1D D4 17      mov al, [active_proc_index]
0696   0267 FD 99         shl a              ; x2
0697   0269 B7 19 10      mov a, [proc_table_convert + a]     ; get process state start index
0698   026C 4F            mov di, a
0699   026D 48            mov a, sp
0700   026E 77            inc a
0701   026F 4D            mov si, a
0702   0270 38 14 00      mov c, 20
0703   0273 FD F5         rep movsb                           ; save process state!
0704   0275             ; restore kernel stack position to point before interrupt arrived
0705   0275 51 14 00      add sp, 20
0706   0278             ; now load the new process number!
0707   0278 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0708   027A 3D D4 17      mov [active_proc_index], al         ; set new active proc
0709   027D             ; calculate lut entry for next process
0710   027D 22 00         mov ah, 0
0711   027F FD 99         shl a                               ; x2
0712   0281 B7 19 10      mov a, [proc_table_convert + a]     ; get process state start index  
0713   0284 4D            mov si, a                           ; source is proc state block
0714   0285 48            mov a, sp
0715   0286 5F 13 00      sub a, 19
0716   0289 4F            mov di, a                           ; destination is kernel stack
0717   028A             ; restore sp
0718   028A 7D            dec a
0719   028B 47            mov sp, a
0720   028C 38 14 00      mov c, 20
0721   028F FD F5         rep movsb
0722   0291             ; set vm process
0723   0291 1D D4 17      mov al, [active_proc_index]
0724   0294 01            setptb
0725   0295 4C            popa
0726   0296 06            sysret
0727   0297             
0728   0297             ;------------------------------------------------------------------------------------------------------;;
0729   0297             ; list processes
0730   0297             ;------------------------------------------------------------------------------------------------------;;
0731   0297             syscall_list_procs:
0732   0297 3B 0B 18      mov d, s_ps_header
0733   029A 07 A3 12      call _puts
0734   029D 3B AB 1A      mov d, proc_availab_table + 1
0735   02A0 38 01 00      mov c, 1
0736   02A3             list_procs_l0:  
0737   02A3 BD 01         cmp byte[d], 1
0738   02A5 C7 C9 02      jne list_procs_next
0739   02A8 2D            mov b, d
0740   02A9 61 AA 1A      sub b, proc_availab_table
0741   02AC FD 9F 05      shl b, 5
0742   02AF DA            push d
0743   02B0 D8            push b
0744   02B1 28            mov b, c
0745   02B2 07 43 13      call print_u8x
0746   02B5 22 20         mov ah, ' '
0747   02B7 07 77 11      call _putchar
0748   02BA 07 77 11      call _putchar
0749   02BD E5            pop b
0750   02BE 74            mov d, b
0751   02BF 58 BA 1A      add d, proc_names
0752   02C2 07 A3 12      call _puts
0753   02C5 07 50 12      call printnl
0754   02C8 E7            pop d
0755   02C9             list_procs_next:
0756   02C9 79            inc d
0757   02CA 78            inc c
0758   02CB C2 09 00      cmp c, 9
0759   02CE C7 A3 02      jne list_procs_l0
0760   02D1             list_procs_end:
0761   02D1 06            sysret
0762   02D2             
0763   02D2             ; ------------------------------------------------------------------------------------------------------------------;
0764   02D2             ; exceptions code block
0765   02D2             ; ------------------------------------------------------------------------------------------------------------------;
0766   02D2             ; privilege exception
0767   02D2             ; ------------------------------------------------------------------------------------------------------------------;
0768   02D2             trap_privilege:
0769   02D2 0A 53 02      jmp syscall_reboot
0770   02D5 DA            push d
0771   02D6 3B 5A 18      mov d, s_priviledge
0772   02D9 07 A3 12      call _puts
0773   02DC E7            pop d
0774   02DD 06            sysret
0775   02DE             
0776   02DE             ; ------------------------------------------------------------------------------------------------------------------;
0777   02DE             ; breakpoint
0778   02DE             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0779   02DE             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0780   02DE             ; ------------------------------------------------------------------------------------------------------------------;
0781   02DE             syscall_break:
0782   02DE 4B            pusha
0783   02DF             syscall_break_prompt:
0784   02DF 3B 99 03      mov d, s_break1
0785   02E2 07 A3 12      call _puts
0786   02E5 07 50 12      call printnl
0787   02E8 07 A5 13      call scan_u16d
0788   02EB AF 00 00      cmp a, 0
0789   02EE C6 F9 02      je syscall_break_regs
0790   02F1 AF 01 00      cmp a, 1
0791   02F4 C6 1C 03      je syscall_break_mem
0792   02F7             syscall_break_end:  
0793   02F7 4C            popa
0794   02F8 06            sysret
0795   02F9             syscall_break_regs:
0796   02F9 48            mov a, sp
0797   02FA 53 0E 00      add a, 14               ; back-track 7 registers
0798   02FD 3C            mov d, a
0799   02FE 3A 07         mov cl, 7
0800   0300             syscall_regs_l0:
0801   0300 2A            mov b, [d]
0802   0301 FD AB         swp b
0803   0303 07 FF 12      call print_u16x         ; print register value
0804   0306 07 50 12      call printnl
0805   0309 63 02 00      sub d, 2
0806   030C 71 01         sub cl, 1
0807   030E C3 00         cmp cl, 0
0808   0310 C7 00 03      jne syscall_regs_l0
0809   0313 0A DF 02      jmp syscall_break_prompt
0810   0316 07 50 12      call printnl
0811   0319 0A DF 02      jmp syscall_break_prompt
0812   031C             syscall_break_mem:
0813   031C 07 50 12      call printnl
0814   031F 07 21 13      call scan_u16x
0815   0322 4D            mov si, a               ; data source from user space
0816   0323 FD 4F 3A 23   mov di, scrap_sector    ; destination in kernel space
0817   0327 38 00 02      mov c, 512
0818   032A 04            load                    ; transfer data to kernel space!
0819   032B 3B 3A 23      mov d, scrap_sector     ; dump pointer in d
0820   032E 38 00 00      mov c, 0
0821   0331             dump_loop:
0822   0331 84            mov al, cl
0823   0332 87 0F         and al, $0f
0824   0334 C6 82 03      jz print_base
0825   0337             back:
0826   0337 1E            mov al, [d]             ; read byte
0827   0338 2F            mov bl, al
0828   0339 07 43 13      call print_u8x
0829   033C 10 00 20      mov a, $2000
0830   033F 05 03         syscall sys_io          ; space
0831   0341 84            mov al, cl
0832   0342 87 0F         and al, $0f
0833   0344 B9 0F         cmp al, $0f
0834   0346 C6 57 03      je print_ascii
0835   0349             back1:
0836   0349 79            inc d
0837   034A 78            inc c
0838   034B C2 00 02      cmp c, 512
0839   034E C7 31 03      jne dump_loop
0840   0351 07 50 12      call printnl
0841   0354 0A DF 02      jmp syscall_break_prompt  ; go to syscall_break return point
0842   0357             print_ascii:
0843   0357 10 00 20      mov a, $2000
0844   035A 05 03         syscall sys_io
0845   035C 63 10 00      sub d, 16
0846   035F 26 10 00      mov b, 16
0847   0362             print_ascii_l:
0848   0362 79            inc d
0849   0363 1E            mov al, [d]               ; read byte
0850   0364 B9 20         cmp al, $20
0851   0366 C8 6E 03      jlu dot
0852   0369 B9 7E         cmp al, $7e
0853   036B D0 76 03      jleu ascii
0854   036E             dot:
0855   036E 10 00 2E      mov a, $2e00
0856   0371 05 03         syscall sys_io
0857   0373 0A 7B 03      jmp ascii_continue
0858   0376             ascii:
0859   0376 23            mov ah, al
0860   0377 19 00         mov al, 0
0861   0379 05 03         syscall sys_io
0862   037B             ascii_continue:
0863   037B FD A9 62 03   loopb print_ascii_l
0864   037F 0A 49 03      jmp back1
0865   0382             print_base:
0866   0382 07 50 12      call printnl
0867   0385 2D            mov b, d
0868   0386 61 3A 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0869   0389 07 FF 12      call print_u16x          ; display row
0870   038C 10 00 3A      mov a, $3a00
0871   038F 05 03         syscall sys_io
0872   0391 10 00 20      mov a, $2000
0873   0394 05 03         syscall sys_io
0874   0396 0A 37 03      jmp back
0875   0399             
0876   0399             s_break1:  
0877   0399 0A 64 65 62   .db "\ndebugger entry point.\n"
0877   039D 75 67 67 65 
0877   03A1 72 20 65 6E 
0877   03A5 74 72 79 20 
0877   03A9 70 6F 69 6E 
0877   03AD 74 2E 0A 
0878   03B0 30 2E 20 73   .db "0. show registers\n"
0878   03B4 68 6F 77 20 
0878   03B8 72 65 67 69 
0878   03BC 73 74 65 72 
0878   03C0 73 0A 
0879   03C2 31 2E 20 73   .db "1. show 512b ram block\n"
0879   03C6 68 6F 77 20 
0879   03CA 35 31 32 62 
0879   03CE 20 72 61 6D 
0879   03D2 20 62 6C 6F 
0879   03D6 63 6B 0A 
0880   03D9 32 2E 20 63   .db "2. continue execution", 0
0880   03DD 6F 6E 74 69 
0880   03E1 6E 75 65 20 
0880   03E5 65 78 65 63 
0880   03E9 75 74 69 6F 
0880   03ED 6E 00 
0881   03EF             
0882   03EF             ; ------------------------------------------------------------------------------------------------------------------;
0883   03EF             ; divide by zero exception
0884   03EF             ; ------------------------------------------------------------------------------------------------------------------;
0885   03EF             trap_div_zero:
0886   03EF D7            push a
0887   03F0 DA            push d
0888   03F1 E1            pushf
0889   03F2 3B 71 18      mov d, s_divzero
0890   03F5 07 A3 12      call _puts
0891   03F8 EE            popf
0892   03F9 E7            pop d
0893   03FA E4            pop a
0894   03FB 06            sysret ; enable interrupts
0895   03FC             
0896   03FC             ; ------------------------------------------------------------------------------------------------------------------;
0897   03FC             ; undefined opcode exception
0898   03FC             ; ------------------------------------------------------------------------------------------------------------------;
0899   03FC             trap_undef_opcode:
0900   03FC 06            sysret
0901   03FD             
0902   03FD             ; ------------------------------------------------------------------------------------------------------------------;
0903   03FD             ; real-time clock services syscall
0904   03FD             ; rtc i/o bank = ffa0 to ffaf
0905   03FD             ; ffa0 to ffa7 is scratch ram
0906   03FD             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0907   03FD             ; al = 0..6 -> get
0908   03FD             ; al = 7..d -> set
0909   03FD             ; ------------------------------------------------------------------------------------------------------------------;
0910   03FD             syscall_rtc:
0911   03FD DB            push al
0912   03FE DA            push d
0913   03FF B9 06         cmp al, 6
0914   0401 D1 16 04      jgu syscall_rtc_set
0915   0404             syscall_rtc_get:
0916   0404 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0917   0406 22 FF         mov ah, $ff    
0918   0408 3C            mov d, a                ; get to ffa9 + offset
0919   0409 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0920   040D 1E            mov al, [d]             ; get data
0921   040E F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0922   0412 23            mov ah, al
0923   0413 E7            pop d
0924   0414 E8            pop al
0925   0415 06            sysret
0926   0416             syscall_rtc_set:
0927   0416 DD            push bl
0928   0417 99            mov bl, ah              ; set data aside
0929   0418 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0930   041A 22 FF         mov ah, $ff    
0931   041C 3C            mov d, a                ; get to ffa9 + offset
0932   041D 1B            mov al, bl              ; get data back
0933   041E F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0934   0422 3E            mov [d], al             ; set data
0935   0423 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0936   0427 EA            pop bl
0937   0428 E7            pop d
0938   0429 E8            pop al
0939   042A 06            sysret
0940   042B             
0941   042B             datetime_serv_tbl:
0942   042B 33 04         .dw print_date
0943   042D A7 04         .dw set_date
0944   042F             syscall_datetime:
0945   042F FD 0A 2B 04   jmp [datetime_serv_tbl + al]      
0946   0433             print_date:
0947   0433 10 00 0D      mov a, $0d00           ; print carriage return char
0948   0436 19 03         mov al, 3
0949   0438 05 01         syscall sys_rtc        ; get week
0950   043A 1A            mov al, ah
0951   043B 22 00         mov ah, 0
0952   043D FD 9D 02      shl a, 2          
0953   0440 3B FB 18      mov d, s_week
0954   0443 59            add d, a
0955   0444 07 A3 12      call _puts
0956   0447 10 00 20      mov a, $2000
0957   044A 05 03         syscall sys_io         ; display ' '
0958   044C 19 04         mov al, 4
0959   044E 05 01         syscall sys_rtc        ; get day
0960   0450 99            mov bl, ah
0961   0451 07 43 13      call print_u8x
0962   0454 10 00 20      mov a, $2000
0963   0457 05 03         syscall sys_io         ; display ' '
0964   0459             ; there is a problem with the month displaying
0965   0459             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0966   0459             ; even though it is to be understood as bcd.
0967   0459             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0968   0459 19 05         mov al, 05
0969   045B 05 01         syscall sys_rtc        ; get month
0970   045D 1A            mov al, ah
0971   045E 22 00         mov ah, 0
0972   0460 FD 9D 02      shl a, 2          
0973   0463 3B C7 18      mov d, s_months
0974   0466 59            add d, a
0975   0467 07 A3 12      call _puts
0976   046A 10 00 20      mov a, $2000
0977   046D 05 03         syscall sys_io         ; display ' '
0978   046F 2E 20         mov bl, $20
0979   0471 07 43 13      call print_u8x         ; print 20 for year prefix
0980   0474 19 06         mov al, 06
0981   0476 05 01         syscall sys_rtc        ; get year
0982   0478 99            mov bl, ah
0983   0479 07 43 13      call print_u8x
0984   047C 10 00 20      mov a, $2000  
0985   047F 05 03         syscall sys_io         ; display ' '
0986   0481 19 02         mov al, 2
0987   0483 05 01         syscall sys_rtc        ; get hours
0988   0485 99            mov bl, ah
0989   0486 07 43 13      call print_u8x
0990   0489 10 00 3A      mov a, $3a00    
0991   048C 05 03         syscall sys_io         ; display ':'
0992   048E 19 01         mov al, 01
0993   0490 05 01         syscall sys_rtc        ; get minutes
0994   0492 99            mov bl, ah
0995   0493 07 43 13      call print_u8x
0996   0496 10 00 3A      mov a, $3a00  
0997   0499 05 03         syscall sys_io         ; display ':'
0998   049B 19 00         mov al, 0
0999   049D 05 01         syscall sys_rtc        ; get seconds
1000   049F 99            mov bl, ah
1001   04A0 07 43 13      call print_u8x
1002   04A3 07 50 12      call printnl
1003   04A6 06            sysret
1004   04A7             set_date:
1005   04A7 3B 8C 18      mov d, s_set_year
1006   04AA 07 A3 12      call _puts
1007   04AD 07 8E 13      call scan_u8x          ; read integer into a
1008   04B0 FD 9D 08      shl a, 8               ; only al used, move to ah
1009   04B3 19 0D         mov al, 0dh            ; set rtc year
1010   04B5 05 01         syscall sys_rtc        ; set rtc
1011   04B7 3B 93 18      mov d, s_set_month
1012   04BA 07 A3 12      call _puts
1013   04BD 07 8E 13      call scan_u8x          ; read integer into a
1014   04C0 FD 9D 08      shl a, 8               ; only al used, move to ah
1015   04C3 19 0C         mov al, 0ch            ; set rtc month
1016   04C5 05 01         syscall sys_rtc        ; set rtc
1017   04C7 3B 9B 18      mov d, s_set_day
1018   04CA 07 A3 12      call _puts
1019   04CD 07 8E 13      call scan_u8x          ; read integer into a
1020   04D0 FD 9D 08      shl a, 8               ; only al used, move to ah
1021   04D3 19 0B         mov al, 0bh            ; set rtc month
1022   04D5 05 01         syscall sys_rtc        ; set rtc
1023   04D7 3B A1 18      mov d, s_set_week
1024   04DA 07 A3 12      call _puts
1025   04DD 07 8E 13      call scan_u8x          ; read integer into a
1026   04E0 FD 9D 08      shl a, 8               ; only al used, move to ah
1027   04E3 19 0A         mov al, 0ah            ; set rtc month
1028   04E5 05 01         syscall sys_rtc        ; set rtc
1029   04E7 3B AB 18      mov d, s_set_hours
1030   04EA 07 A3 12      call _puts
1031   04ED 07 8E 13      call scan_u8x          ; read integer into a
1032   04F0 FD 9D 08      shl a, 8               ; only al used, move to ah
1033   04F3 19 09         mov al, 09h            ; set rtc month
1034   04F5 05 01         syscall sys_rtc        ; set rtc
1035   04F7 3B B3 18      mov d, s_set_minutes
1036   04FA 07 A3 12      call _puts
1037   04FD 07 8E 13      call scan_u8x          ; read integer into a
1038   0500 FD 9D 08      shl a, 8               ; only al used, move to ah
1039   0503 19 08         mov al, 08h            ; set rtc month
1040   0505 05 01         syscall sys_rtc        ; set rtc
1041   0507 3B BD 18      mov d, s_set_seconds
1042   050A 07 A3 12      call _puts
1043   050D 07 8E 13      call scan_u8x          ; read integer into a
1044   0510 FD 9D 08      shl a, 8               ; only al used, move to ah
1045   0513 19 07         mov al, 07h            ; set rtc month
1046   0515 05 01         syscall sys_rtc        ; set rtc
1047   0517 06            sysret
1048   0518             
1049   0518             ; ------------------------------------------------------------------------------------------------------------------;
1050   0518             ; ide services syscall
1051   0518             ; al = option
1052   0518             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1053   0518             ; ide read/write sector
1054   0518             ; 512 bytes
1055   0518             ; user buffer pointer in d
1056   0518             ; ah = number of sectors
1057   0518             ; cb = lba bytes 3..0
1058   0518             ; ------------------------------------------------------------------------------------------------------------------;
1059   0518 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
1059   051C 73 63 61 6C 
1059   0520 6C 5F 69 64 
1059   0524 65 20 63 61 
1059   0528 6C 6C 65 64 
1059   052C 3A 20 00 
1060   052F             ide_serv_tbl:
1061   052F 56 05         .dw ide_reset
1062   0531 6A 05         .dw ide_sleep
1063   0533 79 05         .dw ide_read_sect_wrapper
1064   0535 7D 05         .dw ide_write_sect_wrapper
1065   0537             syscall_ide:
1066   0537 DD            push bl
1067   0538 31 CC 17      mov bl, [sys_debug_mode]
1068   053B               ; debug block
1069   053B C1 00         cmp bl, 0
1070   053D EA            pop bl
1071   053E C6 52 05      je syscall_ide_jmp
1072   0541 DA            push d
1073   0542 DD            push bl
1074   0543 3B 18 05      mov d, s_syscall_ide_dbg0
1075   0546 07 A3 12      call _puts
1076   0549 2F            mov bl, al
1077   054A 07 43 13      call print_u8x
1078   054D 07 50 12      call printnl
1079   0550 EA            pop bl
1080   0551 E7            pop d
1081   0552             syscall_ide_jmp:
1082   0552 FD 0A 2F 05   jmp [ide_serv_tbl + al]    
1083   0556               
1084   0556             ide_reset:      
1085   0556 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1086   055A 07 03 06      call ide_wait                   ; wait for ide ready             
1087   055D F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1088   0561 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1089   0565 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1090   0569 06            sysret
1091   056A             ide_sleep:
1092   056A 07 03 06      call ide_wait                   ; wait for ide ready             
1093   056D F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1094   0571 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1095   0575 07 03 06      call ide_wait                   ; wait for ide ready
1096   0578 06            sysret
1097   0579             ide_read_sect_wrapper:
1098   0579 07 81 05      call ide_read_sect
1099   057C 06            sysret
1100   057D             ide_write_sect_wrapper:
1101   057D 07 A7 05      call ide_write_sect
1102   0580 06            sysret
1103   0581             ide_read_sect:
1104   0581 1A            mov al, ah
1105   0582 24            mov ah, bl
1106   0583 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1107   0586 1C            mov al, bh
1108   0587 3D D4 FF      mov [_ide_r4], al
1109   058A 12            mov a, c
1110   058B 3D D5 FF      mov [_ide_r5], al
1111   058E 1A            mov al, ah
1112   058F 87 0F         and al, %00001111
1113   0591 8B E0         or al, %11100000                ; mode lba, master
1114   0593 3D D6 FF      mov [_ide_r6], al
1115   0596             ide_read_sect_wait:
1116   0596 1D D7 FF      mov al, [_ide_r7]  
1117   0599 87 80         and al, $80                     ; busy flag
1118   059B C7 96 05      jnz ide_read_sect_wait
1119   059E 19 20         mov al, $20
1120   05A0 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1121   05A3 07 CD 05      call ide_read  
1122   05A6 09            ret
1123   05A7             ide_write_sect:
1124   05A7 1A            mov al, ah
1125   05A8 24            mov ah, bl
1126   05A9 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1127   05AC 1C            mov al, bh
1128   05AD 3D D4 FF      mov [_ide_r4], al
1129   05B0 12            mov a, c
1130   05B1 3D D5 FF      mov [_ide_r5], al
1131   05B4 1A            mov al, ah
1132   05B5 87 0F         and al, %00001111
1133   05B7 8B E0         or al, %11100000                ; mode lba, master
1134   05B9 3D D6 FF      mov [_ide_r6], al
1135   05BC             ide_write_sect_wait:
1136   05BC 1D D7 FF      mov al, [_ide_r7]  
1137   05BF 87 80         and al, $80                     ; busy flag
1138   05C1 C7 BC 05      jnz ide_write_sect_wait
1139   05C4 19 30         mov al, $30
1140   05C6 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1141   05C9 07 E8 05      call ide_write      
1142   05CC 09            ret
1143   05CD             
1144   05CD             ;----------------------------------------------------------------------------------------------------;
1145   05CD             ; read ide data
1146   05CD             ; pointer in d
1147   05CD             ;----------------------------------------------------------------------------------------------------;
1148   05CD             ide_read:
1149   05CD DA            push d
1150   05CE             ide_read_loop:
1151   05CE 1D D7 FF      mov al, [_ide_r7]  
1152   05D1 87 80         and al, 80h                     ; busy flag
1153   05D3 C7 CE 05      jnz ide_read_loop               ; wait loop
1154   05D6 1D D7 FF      mov al, [_ide_r7]
1155   05D9 87 08         and al, %00001000               ; drq flag
1156   05DB C6 E6 05      jz ide_read_end
1157   05DE 1D D0 FF      mov al, [_ide_r0]
1158   05E1 3E            mov [d], al
1159   05E2 79            inc d
1160   05E3 0A CE 05      jmp ide_read_loop
1161   05E6             ide_read_end:
1162   05E6 E7            pop d
1163   05E7 09            ret
1164   05E8             
1165   05E8             ;----------------------------------------------------------------------------------------------------;
1166   05E8             ; write ide data
1167   05E8             ; data pointer in d
1168   05E8             ;----------------------------------------------------------------------------------------------------;
1169   05E8             ide_write:
1170   05E8 DA            push d
1171   05E9             ide_write_loop:
1172   05E9 1D D7 FF      mov al, [_ide_r7]  
1173   05EC 87 80         and al, 80h             ; busy flag
1174   05EE C7 E9 05      jnz ide_write_loop      ; wait loop
1175   05F1 1D D7 FF      mov al, [_ide_r7]
1176   05F4 87 08         and al, %00001000       ; drq flag
1177   05F6 C6 01 06      jz ide_write_end
1178   05F9 1E            mov al, [d]
1179   05FA 3D D0 FF      mov [_ide_r0], al
1180   05FD 79            inc d 
1181   05FE 0A E9 05      jmp ide_write_loop
1182   0601             ide_write_end:
1183   0601 E7            pop d
1184   0602 09            ret
1185   0603             
1186   0603             ;----------------------------------------------------------------------------------------------------;
1187   0603             ; wait for ide to be ready
1188   0603             ;----------------------------------------------------------------------------------------------------;
1189   0603             ide_wait:
1190   0603 1D D7 FF      mov al, [_ide_r7]  
1191   0606 87 80         and al, 80h        ; busy flag
1192   0608 C7 03 06      jnz ide_wait
1193   060B 09            ret
1194   060C             
1195   060C             ;----------------------------------------------------------------------------------------------------;
1196   060C             ; io syscall
1197   060C             ;----------------------------------------------------------------------------------------------------;
1198   060C             ; baud  divisor
1199   060C             ; 50    2304
1200   060C             ; 110   1047
1201   060C             ; 300    384
1202   060C             ; 600    192
1203   060C             ; 1200    96
1204   060C             ; 9600    12
1205   060C             ; 19200    6
1206   060C             ; 38400    3
1207   060C             syscall_io_jmp:
1208   060C 3F 06         .dw syscall_io_putchar
1209   060E 4C 06         .dw syscall_io_getch
1210   0610 16 06         .dw syscall_io_uart_setup
1211   0612             syscall_io:
1212   0612 FD 0A 0C 06   jmp [syscall_io_jmp + al]
1213   0616             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1214   0616             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1215   0616             ; buffer, the transmitter holding register, or the interrupt enable register.
1216   0616             syscall_io_uart_setup:
1217   0616 1D CE 17      mov al, [sys_uart0_lcr]
1218   0619 8B 80         or al, $80                ; set dlab access bit
1219   061B 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1220   061E 1D D1 17      mov al, [sys_uart0_div0]
1221   0621 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1222   0624 1D D2 17      mov al, [sys_uart0_div1]
1223   0627 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1224   062A             
1225   062A 1D CE 17      mov al, [sys_uart0_lcr]
1226   062D 87 7F         and al, $7f               ; clear dlab access bit 
1227   062F 3D 83 FF      mov [_uart0_lcr], al
1228   0632 1D CF 17      mov al, [sys_uart0_inten]
1229   0635 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1230   0638 1D D0 17      mov al, [sys_uart0_fifoen]
1231   063B 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1232   063E 06            sysret
1233   063F             
1234   063F             ; char in ah
1235   063F             syscall_io_putchar:
1236   063F             syscall_io_putchar_l0:
1237   063F 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1238   0642 87 20         and al, $20
1239   0644 C6 3F 06      jz syscall_io_putchar_l0    
1240   0647 1A            mov al, ah
1241   0648 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1242   064B 06            sysret
1243   064C             
1244   064C             ; char in ah
1245   064C             ; al = sucess code
1246   064C             syscall_io_getch:
1247   064C D8            push b
1248   064D DA            push d
1249   064E FD 0C         sti
1250   0650             syscall_io_getch_l0:  
1251   0650 14 DB 17      mov a, [fifo_out]
1252   0653 29 D9 17      mov b, [fifo_in]
1253   0656 B0            cmp a, b
1254   0657 C6 50 06      je syscall_io_getch_l0
1255   065A 3C            mov d, a
1256   065B 77            inc a
1257   065C AF 3A 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1258   065F C7 65 06      jne syscall_io_getch_cont
1259   0662 10 3A 1F      mov a, fifo  
1260   0665             syscall_io_getch_cont:  
1261   0665 42 DB 17      mov [fifo_out], a             ; update fifo pointer
1262   0668 1E            mov al, [d]                   ; get char
1263   0669 23            mov ah, al
1264   066A 1D CD 17      mov al, [sys_echo_on]
1265   066D B9 01         cmp al, 1
1266   066F C7 7E 06      jne syscall_io_getch_noecho 
1267   0672             ; here we just echo the char back to the console
1268   0672             syscall_io_getch_echo_l0:
1269   0672 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1270   0675 87 20         and al, $20                 ; isolate transmitter empty
1271   0677 C6 72 06      jz syscall_io_getch_echo_l0
1272   067A 1A            mov al, ah
1273   067B 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1274   067E             syscall_io_getch_noecho:
1275   067E 19 01         mov al, 1                    ; al = 1 means a char successfully received
1276   0680 E7            pop d
1277   0681 E5            pop b
1278   0682 06            sysret
1279   0683             
1280   0683             ;------------------------------------------------------------------------------------------------------;
1281   0683             ; file system data
1282   0683             ;------------------------------------------------------------------------------------------------------;
1283   0683             ; infor for : ide services interrupt
1284   0683             ; ide read/write 512-byte sector
1285   0683             ; al = option
1286   0683             ; user buffer pointer in d
1287   0683             ; ah = number of sectors
1288   0683             ; cb = lba bytes 3..0  
1289   0683             ;------------------------------------------------------------------------------------------------------;
1290   0683             ; file system data structure
1291   0683             ;------------------------------------------------------------------------------------------------------;
1292   0683             ; for a directory we have the header first, followed by metadata
1293   0683             ; header 1 sector (512 bytes)
1294   0683             ; metadata 1 sector (512 bytes)
1295   0683             ; header entries:
1296   0683             ; filename (64)
1297   0683             ; parent dir lba (2) -  to be used for faster backwards navigation...
1298   0683             ;
1299   0683             ; metadata entries:
1300   0683             ; filename (24)
1301   0683             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1302   0683             ; lba (2)
1303   0683             ; size (2)
1304   0683             ; day (1)
1305   0683             ; month (1)
1306   0683             ; year (1)
1307   0683             ; packet size = 32 bytes
1308   0683             ;
1309   0683             ; first directory on disk is the root directory '/'
1310   0683             file_system_jmptbl:
1311   0683 EE 06         .dw fs_mkfs                   ; 0
1312   0685 00 00         .dw 0                         ; 1
1313   0687 50 07         .dw fs_mkdir                  ; 2
1314   0689 C9 0A         .dw fs_cd                     ; 3
1315   068B D0 0A         .dw fs_ls                     ; 4
1316   068D BB 0B         .dw fs_mktxt                  ; 5
1317   068F 86 0C         .dw fs_mkbin                  ; 6
1318   0691 4D 0D         .dw fs_pwd                    ; 7
1319   0693 6A 0D         .dw fs_cat                    ; 8
1320   0695 C6 0D         .dw fs_rmdir                  ; 9
1321   0697 22 0E         .dw fs_rm                     ; 10
1322   0699 00 00         .dw 0                         ; 11
1323   069B 00 00         .dw 0                         ; 12
1324   069D 00 00         .dw 0                         ; 13
1325   069F F6 06         .dw fs_chmod                  ; 14
1326   06A1 8A 0E         .dw fs_mv                     ; 15
1327   06A3 EF 06         .dw fs_cd_root                ; 16
1328   06A5 C5 0A         .dw fs_get_curr_dirid         ; 17
1329   06A7 A1 08         .dw fs_dir_id_to_path         ; 18
1330   06A9 07 09         .dw fs_path_to_dir_id_user    ; 19
1331   06AB 21 0A         .dw fs_load_from_path_user    ; 20  
1332   06AD 91 09         .dw fs_filepath_exists_user   ; 21
1333   06AF             
1334   06AF 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1334   06B3 79 73 63 61 
1334   06B7 6C 6C 5F 66 
1334   06BB 69 6C 65 5F 
1334   06BF 73 79 73 74 
1334   06C3 65 6D 20 63 
1334   06C7 61 6C 6C 65 
1334   06CB 64 3A 20 00 
1335   06CF             syscall_file_system:
1336   06CF DD            push bl
1337   06D0 31 CC 17      mov bl, [sys_debug_mode]
1338   06D3               ; debug block
1339   06D3 C1 00         cmp bl, 0
1340   06D5 EA            pop bl
1341   06D6 C6 EA 06      je syscall_filesystem_jmp
1342   06D9 DA            push d
1343   06DA DD            push bl
1344   06DB 3B AF 06      mov d, s_syscall_fs_dbg0
1345   06DE 07 A3 12      call _puts
1346   06E1 2F            mov bl, al
1347   06E2 07 43 13      call print_u8x
1348   06E5 07 50 12      call printnl
1349   06E8 EA            pop bl
1350   06E9 E7            pop d
1351   06EA             syscall_filesystem_jmp:
1352   06EA FD 0A 83 06   jmp [file_system_jmptbl + al]
1353   06EE             
1354   06EE             fs_mkfs:  
1355   06EE 06            sysret  
1356   06EF               
1357   06EF             fs_cd_root:
1358   06EF 10 20 00      mov a, root_id
1359   06F2 42 DD 17      mov [current_dir_id], a      ; set current directory lba to root
1360   06F5 06            sysret  
1361   06F6             
1362   06F6             ; filename in d (userspace data)
1363   06F6             ; permission in bl
1364   06F6             fs_chmod:
1365   06F6 DD            push bl
1366   06F7 FD 4E         mov si, d
1367   06F9 FD 4F 3A 1D   mov di, user_data
1368   06FD 38 80 00      mov c, 128
1369   0700 04            load                        ; load filename from user-space
1370   0701 14 DD 17      mov a, [current_dir_id]
1371   0704 77            inc a                       ; metadata sector
1372   0705 27            mov b, a
1373   0706 38 00 00      mov c, 0                    ; upper lba = 0
1374   0709 22 01         mov ah, $01                  ; 1 sector
1375   070B 3B 3A 25      mov d, transient_area
1376   070E 07 81 05      call ide_read_sect          ; read directory
1377   0711 FD 10         cla
1378   0713 42 D5 17      mov [index], a              ; reset file counter
1379   0716             fs_chmod_l1:
1380   0716 FD 4E         mov si, d
1381   0718 FD 4F 3A 1D   mov di, user_data
1382   071C 07 E6 10      call _strcmp
1383   071F C6 36 07      je fs_chmod_found_entry
1384   0722 58 20 00      add d, 32
1385   0725 14 D5 17      mov a, [index]
1386   0728 77            inc a
1387   0729 42 D5 17      mov [index], a
1388   072C AF 10 00      cmp a, fst_files_per_dir
1389   072F C7 16 07      jne fs_chmod_l1
1390   0732 EA            pop bl
1391   0733 0A 4F 07      jmp fs_chmod_not_found
1392   0736             fs_chmod_found_entry:  
1393   0736 FD 79         mov g, b                    ; save lba
1394   0738 EA            pop bl                      ; retrieve saved permission value
1395   0739 1F 18 00      mov al, [d + 24]            ; read file permissions
1396   073C 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1397   073E 8C            or al, bl                   ; set new permissions
1398   073F 3F 18 00      mov [d + 24], al            ; write new permissions
1399   0742 38 00 00      mov c, 0
1400   0745 3B 3A 25      mov d, transient_area
1401   0748 22 01         mov ah, $01                 ; disk write 1 sect
1402   074A FD 27         mov b, g                    ; retrieve lba
1403   074C 07 A7 05      call ide_write_sect         ; write sector
1404   074F             fs_chmod_not_found:
1405   074F 06            sysret
1406   0750             
1407   0750             ;------------------------------------------------------------------------------------------------------;
1408   0750             ; create new directory
1409   0750             ;------------------------------------------------------------------------------------------------------;
1410   0750             ; search list for null name entry. add new directory to list
1411   0750             fs_mkdir:
1412   0750 FD 4E         mov si, d
1413   0752 FD 4F 3A 1D   mov di, user_data
1414   0756 38 00 02      mov c, 512
1415   0759 04            load                        ; load data from user-space
1416   075A 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1417   075D                                           ; when checking for null name, since root has a null name)
1418   075D 38 00 00      mov c, 0                    ; upper lba = 0
1419   0760             fs_mkdir_l1:  
1420   0760 22 01         mov ah, $01                  ; 1 sector
1421   0762 3B 3A 25      mov d, transient_area
1422   0765 07 81 05      call ide_read_sect          ; read sector
1423   0768 BD 00         cmp byte[d], 0              ; check for null
1424   076A C6 73 07      je fs_mkdir_found_null
1425   076D 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1426   0770 0A 60 07      jmp fs_mkdir_l1
1427   0773             fs_mkdir_found_null:
1428   0773             ;create header file by grabbing dir name from parameter
1429   0773 D8            push b                      ; save new directory's lba
1430   0774 38 40 00      mov c, 64
1431   0777 FD 4D 3A 1D   mov si, user_data
1432   077B FD 4F 3A 25   mov di, transient_area
1433   077F FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1434   0781 14 DD 17      mov a, [current_dir_id]
1435   0784 42 7A 25      mov [transient_area + 64], a    ; store parent directory lba
1436   0787 19 00         mov al, 0
1437   0789 FD 4F 3A 27   mov di, transient_area + 512
1438   078D 38 00 02      mov c, 512
1439   0790 FD F7         rep stosb                       ; clean buffer
1440   0792 38 00 00      mov c, 0                        ; reset lba(c) to 0
1441   0795             ; write directory entry sectors
1442   0795 3B 3A 25      mov d, transient_area
1443   0798 22 02         mov ah, $02                     ; disk write, 2 sectors
1444   079A 07 A7 05      call ide_write_sect             ; write sector
1445   079D             ; now we need to add the new directory to the list, inside the current directory
1446   079D 14 DD 17      mov a, [current_dir_id]
1447   07A0 53 01 00      add a, 1
1448   07A3 27            mov b, a                        ; metadata sector
1449   07A4 38 00 00      mov c, 0
1450   07A7 FD 79         mov g, b                        ; save lba
1451   07A9 3B 3A 25      mov d, transient_area
1452   07AC 22 01         mov ah, $01                  ; 1 sector
1453   07AE 07 81 05      call ide_read_sect              ; read metadata sector
1454   07B1             fs_mkdir_l2:
1455   07B1 BD 00         cmp byte[d], 0
1456   07B3 C6 BC 07      je fs_mkdir_found_null2
1457   07B6 58 20 00      add d, fst_entry_size
1458   07B9 0A B1 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1459   07BC             fs_mkdir_found_null2:
1460   07BC FD 4D 3A 1D   mov si, user_data
1461   07C0 FD 50         mov di, d
1462   07C2 07 FB 10      call _strcpy                    ; copy directory name
1463   07C5 58 18 00      add d, 24                       ; goto attributes
1464   07C8 19 0B         mov al, %00001011               ; directory, no execute, write, read
1465   07CA 3E            mov [d], al      
1466   07CB 79            inc d
1467   07CC E5            pop b
1468   07CD D8            push b                          ; push lba back
1469   07CE FD 43         mov [d], b                      ; save lba
1470   07D0             ; set file creation date  
1471   07D0 58 04 00      add d, 4
1472   07D3 19 04         mov al, 4
1473   07D5 05 01         syscall sys_rtc
1474   07D7 1A            mov al, ah
1475   07D8 3E            mov [d], al                     ; set day
1476   07D9 79            inc d
1477   07DA 19 05         mov al, 5
1478   07DC 05 01         syscall sys_rtc
1479   07DE 1A            mov al, ah
1480   07DF 3E            mov [d], al                     ; set month
1481   07E0 79            inc d
1482   07E1 19 06         mov al, 6
1483   07E3 05 01         syscall sys_rtc
1484   07E5 1A            mov al, ah
1485   07E6 3E            mov [d], al                     ; set year
1486   07E7             ; write sector into disk for new directory entry
1487   07E7 FD 27         mov b, g
1488   07E9 38 00 00      mov c, 0
1489   07EC 3B 3A 25      mov d, transient_area
1490   07EF 22 01         mov ah, $01                     ; disk write, 1 sector
1491   07F1 07 A7 05      call ide_write_sect             ; write sector
1492   07F4             
1493   07F4             ; after adding the new directory's information to its parent directory's list
1494   07F4             ; we need to now enter the new directory, and to it add two new directories!
1495   07F4             ; which directories do we need to add ? '..' and '.' are the directories needed.
1496   07F4             ; importantly, note that these two new directories are only entries in the list
1497   07F4             ; and do not have actual physical entries in the disk as real directories.
1498   07F4             ; i.e. they only exist as list entries in the new directory created so that
1499   07F4             ; the new directory can reference its parent and itself.
1500   07F4             ; we need to add both '..' and '.'
1501   07F4             ; this first section is for '..' and on the section below we do the same for '.'
1502   07F4 E4            pop a                         ; retrieve the new directory's lba  
1503   07F5 D7            push a                        ; and save again
1504   07F6 53 01 00      add a, 1
1505   07F9 27            mov b, a                      ; metadata sector
1506   07FA 38 00 00      mov c, 0
1507   07FD FD 79         mov g, b                      ; save lba
1508   07FF 3B 3A 25      mov d, transient_area
1509   0802 22 01         mov ah, $01                  ; 1 sector
1510   0804 07 81 05      call ide_read_sect            ; read metadata sector
1511   0807             fs_mkdir_l3:
1512   0807 BD 00         cmp byte[d], 0
1513   0809 C6 12 08      je fs_mkdir_found_null3
1514   080C 58 20 00      add d, fst_entry_size
1515   080F 0A 07 08      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1516   0812             fs_mkdir_found_null3:
1517   0812 FD 4D FC 17   mov si, s_parent_dir
1518   0816 FD 50         mov di, d
1519   0818 07 FB 10      call _strcpy                  ; copy directory name
1520   081B 58 18 00      add d, 24                     ; goto attributes
1521   081E 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1522   0820 3E            mov [d], al      
1523   0821 79            inc d
1524   0822 29 DD 17      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1525   0825 FD 43         mov [d], b                    ; save lba
1526   0827             ; set file creation date  
1527   0827 58 04 00      add d, 4
1528   082A 19 04         mov al, 4
1529   082C 05 01         syscall sys_rtc
1530   082E 1A            mov al, ah
1531   082F 3E            mov [d], al                   ; set day
1532   0830 79            inc d
1533   0831 19 05         mov al, 5
1534   0833 05 01         syscall sys_rtc
1535   0835 1A            mov al, ah
1536   0836 3E            mov [d], al                   ; set month
1537   0837 79            inc d
1538   0838 19 06         mov al, 6
1539   083A 05 01         syscall sys_rtc
1540   083C 1A            mov al, ah
1541   083D 3E            mov [d], al                   ; set year
1542   083E             ; write sector into disk for new directory entry
1543   083E FD 27         mov b, g
1544   0840 38 00 00      mov c, 0
1545   0843 3B 3A 25      mov d, transient_area
1546   0846 22 01         mov ah, $01                   ; disk write, 1 sector
1547   0848 07 A7 05      call ide_write_sect           ; write sector
1548   084B             ;;;;;;;;;;;;;
1549   084B             ; like we did above for '..', we need to now add the '.' directory to the list.
1550   084B             ;------------------------------------------------------------------------------------------------------;
1551   084B E4            pop a                         ; retrieve the new directory's lba  
1552   084C D7            push a
1553   084D 53 01 00      add a, 1
1554   0850 27            mov b, a                      ; metadata sector
1555   0851 38 00 00      mov c, 0
1556   0854 FD 79         mov g, b                      ; save lba
1557   0856 3B 3A 25      mov d, transient_area
1558   0859 22 01         mov ah, $01                  ; 1 sector
1559   085B 07 81 05      call ide_read_sect            ; read metadata sector
1560   085E             fs_mkdir_l4:
1561   085E BD 00         cmp byte[d], 0
1562   0860 C6 69 08      je fs_mkdir_found_null4
1563   0863 58 20 00      add d, fst_entry_size
1564   0866 0A 5E 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1565   0869             fs_mkdir_found_null4:
1566   0869 FD 4D FF 17   mov si, s_current_dir
1567   086D FD 50         mov di, d
1568   086F 07 FB 10      call _strcpy                  ; copy directory name
1569   0872 58 18 00      add d, 24                     ; goto attributes
1570   0875 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1571   0877 3E            mov [d], al      
1572   0878 79            inc d
1573   0879 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1574   087A FD 43         mov [d], b                    ; save lba
1575   087C             ; set file creation date  
1576   087C 58 04 00      add d, 4
1577   087F 19 04         mov al, 4
1578   0881 05 01         syscall sys_rtc
1579   0883 1A            mov al, ah
1580   0884 3E            mov [d], al                   ; set day
1581   0885 79            inc d
1582   0886 19 05         mov al, 5
1583   0888 05 01         syscall sys_rtc
1584   088A 1A            mov al, ah
1585   088B 3E            mov [d], al                   ; set month
1586   088C 79            inc d
1587   088D 19 06         mov al, 6
1588   088F 05 01         syscall sys_rtc
1589   0891 1A            mov al, ah
1590   0892 3E            mov [d], al                   ; set year
1591   0893             ; write sector into disk for new directory entry
1592   0893 FD 27         mov b, g
1593   0895 38 00 00      mov c, 0
1594   0898 3B 3A 25      mov d, transient_area
1595   089B 22 01         mov ah, $01                   ; disk write, 1 sector
1596   089D 07 A7 05      call ide_write_sect           ; write sector
1597   08A0             fs_mkdir_end:
1598   08A0 06            sysret
1599   08A1             
1600   08A1             ;------------------------------------------------------------------------------------------------------;
1601   08A1             ; get path from a given directory dirid
1602   08A1             ; pseudo code:
1603   08A1             ;  fs_dir_id_to_path(int dirid, char *d){
1604   08A1             ;    if(dirid == 0){
1605   08A1             ;      reverse path in d;
1606   08A1             ;      return;
1607   08A1             ;    }
1608   08A1             ;    else{
1609   08A1             ;      copy directory name to end of d;
1610   08A1             ;      add '/' to end of d;
1611   08A1             ;      parentid = get parent directory id;
1612   08A1             ;      fs_dir_id_to_path(parentid, d);
1613   08A1             ;    }
1614   08A1             ;  }
1615   08A1             ; a = dirid
1616   08A1             ; d = generated path string pointer
1617   08A1             ;------------------------------------------------------------------------------------------------------;
1618   08A1             ; sample path: /usr/bin
1619   08A1             fs_dir_id_to_path:
1620   08A1 3B BA 1C      mov d, filename
1621   08A4 19 00         mov al, 0
1622   08A6 3E            mov [d], al                     ; initialize path string 
1623   08A7 14 DD 17      mov a, [current_dir_id]
1624   08AA 07 B7 08      call fs_dir_id_to_path_e0
1625   08AD 3B BA 1C      mov d, filename
1626   08B0 07 8F 10      call _strrev
1627   08B3 07 A3 12      call _puts
1628   08B6 06            sysret
1629   08B7             fs_dir_id_to_path_e0:
1630   08B7 07 D6 08      call get_dirname_from_dirid
1631   08BA FD 4D 01 18   mov si, s_fslash
1632   08BE FD 50         mov di, d
1633   08C0 07 09 11      call _strcat                    ; add '/' to end of path
1634   08C3 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1635   08C6 C6 D5 08      je fs_dir_id_to_path_root
1636   08C9 07 F3 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1637   08CC AF 20 00      cmp a, root_id               ; check if we are at the root directory
1638   08CF C6 D5 08      je fs_dir_id_to_path_root
1639   08D2 07 B7 08      call fs_dir_id_to_path_e0     ; recursively call itself
1640   08D5             fs_dir_id_to_path_root:
1641   08D5 09            ret
1642   08D6             
1643   08D6             ;------------------------------------------------------------------------------------------------------;
1644   08D6             ; in_puts:
1645   08D6             ; a = directory id
1646   08D6             ; out_puts:
1647   08D6             ; d = pointer to directory name string
1648   08D6             ;------------------------------------------------------------------------------------------------------;
1649   08D6             get_dirname_from_dirid:
1650   08D6 D7            push a
1651   08D7 D8            push b
1652   08D8 DA            push d
1653   08D9 27            mov b, a
1654   08DA 38 00 00      mov c, 0                      ; upper lba = 0
1655   08DD 22 01         mov ah, $01                  ; 1 sector
1656   08DF 3B 3A 23      mov d, transient_area - 512
1657   08E2 07 81 05      call ide_read_sect            ; read directory
1658   08E5 07 8F 10      call _strrev                  ; reverse dir name before copying
1659   08E8 FD 4E         mov si, d
1660   08EA E7            pop d                         ; destination address = d value pushed at beginning
1661   08EB FD 50         mov di, d
1662   08ED 07 09 11      call _strcat                  ; copy filename to d
1663   08F0 E5            pop b
1664   08F1 E4            pop a
1665   08F2 09            ret
1666   08F3             
1667   08F3             ;------------------------------------------------------------------------------------------------------;
1668   08F3             ; in_puts:
1669   08F3             ; a = directory id
1670   08F3             ; out_puts:
1671   08F3             ; a = parent directory id
1672   08F3             ;------------------------------------------------------------------------------------------------------;
1673   08F3             get_parentid_from_dirid:
1674   08F3 D8            push b
1675   08F4 DA            push d
1676   08F5 27            mov b, a
1677   08F6 38 00 00      mov c, 0                      ; upper lba = 0
1678   08F9 22 01         mov ah, $01                  ; 1 sector
1679   08FB 3B 3A 23      mov d, transient_area - 512
1680   08FE 07 81 05      call ide_read_sect            ; read directory
1681   0901 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1682   0904 E7            pop d
1683   0905 E5            pop b
1684   0906 09            ret
1685   0907             
1686   0907             ;------------------------------------------------------------------------------------------------------;
1687   0907             ; get dirid from a given path string
1688   0907             ; in_puts:
1689   0907             ; d = path pointer 
1690   0907             ; out_puts:
1691   0907             ; a = dirid
1692   0907             ; if dir non existent, a = ffff (fail code)
1693   0907             ; /usr/local/bin    - absolute
1694   0907             ; local/bin/games    - relative
1695   0907             ;------------------------------------------------------------------------------------------------------;
1696   0907             fs_path_to_dir_id_user:
1697   0907 FD 4E         mov si, d
1698   0909 FD 4F 3A 1D   mov di, user_data
1699   090D 38 00 02      mov c, 512
1700   0910 04            load
1701   0911 07 15 09      call get_dirid_from_path
1702   0914 06            sysret
1703   0915             get_dirid_from_path:
1704   0915 26 3A 1D      mov b, user_data
1705   0918 FD 42 C8 16   mov [prog], b                  ; token pointer set to path string
1706   091C 07 29 15      call get_token
1707   091F 31 CB 16      mov bl, [tok]
1708   0922 C1 01         cmp bl, tok_fslash
1709   0924 C6 30 09      je get_dirid_from_path_abs 
1710   0927 14 DD 17      mov a, [current_dir_id]
1711   092A 07 AF 16      call _putback
1712   092D 0A 33 09      jmp get_dirid_from_path_e0
1713   0930             get_dirid_from_path_abs:
1714   0930 10 20 00      mov a, root_id
1715   0933             get_dirid_from_path_e0:
1716   0933 07 29 15      call get_token
1717   0936 31 CA 16      mov bl, [toktyp]
1718   0939 C1 00         cmp bl, toktyp_identifier
1719   093B C7 8C 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1720   093E             
1721   093E FD 4D CC 16   mov si, tokstr
1722   0942 FD 4F BA 1C   mov di, filename
1723   0946 07 FB 10      call _strcpy        
1724   0949 77            inc a                         ; metadata sector
1725   094A 27            mov b, a
1726   094B 38 00 00      mov c, 0                      ; upper lba = 0
1727   094E 22 01         mov ah, $01                  ; 1 sector
1728   0950 3B 3A 25      mov d, transient_area
1729   0953 07 81 05      call ide_read_sect            ; read directory
1730   0956 FD 10         cla
1731   0958 42 D5 17      mov [index], a
1732   095B             get_dirid_from_path_l1:
1733   095B FD 4E         mov si, d
1734   095D FD 4F BA 1C   mov di, filename
1735   0961 07 E6 10      call _strcmp
1736   0964 C6 7A 09      je get_dirid_from_path_name_equal  
1737   0967 58 20 00      add d, 32
1738   096A 14 D5 17      mov a, [index]
1739   096D 77            inc a
1740   096E 42 D5 17      mov [index], a
1741   0971 AF 10 00      cmp a, fst_files_per_dir
1742   0974 C6 8D 09      je get_dirid_from_path_fail
1743   0977 0A 5B 09      jmp get_dirid_from_path_l1
1744   097A             get_dirid_from_path_name_equal:
1745   097A 58 19 00      add d, 25           
1746   097D 15            mov a, [d]                    ; set result register a = dirid
1747   097E 07 29 15      call get_token
1748   0981 31 CB 16      mov bl, [tok]
1749   0984 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1750   0986 C6 33 09      je get_dirid_from_path_e0
1751   0989 07 AF 16      call _putback
1752   098C             get_dirid_from_path_end:
1753   098C 09            ret
1754   098D             get_dirid_from_path_fail:
1755   098D 10 FF FF      mov a, $ffff
1756   0990 09            ret
1757   0991             
1758   0991             
1759   0991             ;------------------------------------------------------------------------------------------------------;
1760   0991             ; check if file exists by a given path string
1761   0991             ; in_puts:
1762   0991             ; d = path pointer 
1763   0991             ; outputs:
1764   0991             ; a = success code, if file exists gives lba, else, give 0
1765   0991             ; /usr/local/bin/ed
1766   0991             ;------------------------------------------------------------------------------------------------------;
1767   0991             fs_filepath_exists_user:
1768   0991 FD 4E         mov si, d
1769   0993 FD 4F 3A 1D   mov di, user_data
1770   0997 38 00 02      mov c, 512
1771   099A 04            load
1772   099B 07 9F 09      call file_exists_by_path
1773   099E 06            sysret
1774   099F             file_exists_by_path:
1775   099F 26 3A 1D      mov b, user_data
1776   09A2 FD 42 C8 16   mov [prog], b                   ; token pointer set to path string
1777   09A6 07 29 15      call get_token
1778   09A9 31 CB 16      mov bl, [tok]
1779   09AC C1 01         cmp bl, tok_fslash
1780   09AE C6 BA 09      je  file_exists_by_path_abs
1781   09B1 14 DD 17      mov a, [current_dir_id]
1782   09B4 07 AF 16      call _putback
1783   09B7 0A BD 09      jmp file_exists_by_path_e0
1784   09BA             file_exists_by_path_abs:
1785   09BA 10 20 00      mov a, root_id
1786   09BD             file_exists_by_path_e0:
1787   09BD 07 29 15      call get_token
1788   09C0 31 CA 16      mov bl, [toktyp]
1789   09C3 C1 00         cmp bl, toktyp_identifier
1790   09C5 C7 1D 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1791   09C8 FD 4D CC 16   mov si, tokstr
1792   09CC FD 4F BA 1C   mov di, filename
1793   09D0 07 FB 10      call _strcpy        
1794   09D3 77            inc a                           ; metadata sector
1795   09D4 27            mov b, a
1796   09D5 38 00 00      mov c, 0                        ; upper lba = 0
1797   09D8 22 01         mov ah, $01                  ; 1 sector
1798   09DA 3B 3A 25      mov d, transient_area
1799   09DD 07 81 05      call ide_read_sect              ; read directory
1800   09E0 FD 10         cla
1801   09E2 42 D5 17      mov [index], a
1802   09E5             file_exists_by_path_l1:
1803   09E5 FD 4E         mov si, d
1804   09E7 FD 4F BA 1C   mov di, filename
1805   09EB 07 E6 10      call _strcmp
1806   09EE C6 04 0A      je   file_exists_by_path_name_equal
1807   09F1 58 20 00      add d, 32
1808   09F4 14 D5 17      mov a, [index]
1809   09F7 77            inc a
1810   09F8 42 D5 17      mov [index], a
1811   09FB AF 10 00      cmp a, fst_files_per_dir
1812   09FE C6 1D 0A      je file_exists_by_path_end
1813   0A01 0A E5 09      jmp file_exists_by_path_l1
1814   0A04             file_exists_by_path_name_equal:
1815   0A04 33 18 00      mov bl, [d + 24]
1816   0A07 FD 87 38      and bl, %00111000               ; directory flag
1817   0A0A C1 08         cmp bl, %00001000               ; is dir?
1818   0A0C C6 13 0A      je file_exists_by_path_isdir;
1819   0A0F             ; entry is a file
1820   0A0F 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1821   0A12 09            ret
1822   0A13             file_exists_by_path_isdir:
1823   0A13 58 19 00      add d, 25           
1824   0A16 15            mov a, [d]                      ; set result register a = dirid
1825   0A17 07 29 15      call get_token
1826   0A1A 0A BD 09      jmp file_exists_by_path_e0
1827   0A1D             file_exists_by_path_end:
1828   0A1D 10 00 00      mov a, 0                        ; return 0 because file was not found
1829   0A20 09            ret
1830   0A21             
1831   0A21             ;------------------------------------------------------------------------------------------------------;
1832   0A21             ; load file data from a given path string
1833   0A21             ; inputs:
1834   0A21             ; d = path pointer 
1835   0A21             ; di = userspace program data destination
1836   0A21             ; /usr/local/bin/ed
1837   0A21             ; ./ed
1838   0A21             ;------------------------------------------------------------------------------------------------------;
1839   0A21             fs_load_from_path_user:
1840   0A21 E3            push di
1841   0A22 FD 4E         mov si, d
1842   0A24 FD 4F 3A 1D   mov di, user_data
1843   0A28 38 00 02      mov c, 512
1844   0A2B 04            load
1845   0A2C 07 39 0A      call loadfile_from_path
1846   0A2F F0            pop di
1847   0A30 FD 4D 3A 25   mov si, transient_area
1848   0A34 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1849   0A37 03            store
1850   0A38 06            sysret
1851   0A39             loadfile_from_path:
1852   0A39 26 3A 1D      mov b, user_data
1853   0A3C FD 42 C8 16   mov [prog], b                 ; token pointer set to path string
1854   0A40 07 29 15      call get_token
1855   0A43 31 CB 16      mov bl, [tok]
1856   0A46 C1 01         cmp bl, tok_fslash
1857   0A48 C6 54 0A      je loadfile_from_path_abs 
1858   0A4B 14 DD 17      mov a, [current_dir_id]
1859   0A4E 07 AF 16      call _putback
1860   0A51 0A 57 0A      jmp loadfile_from_path_e0
1861   0A54             loadfile_from_path_abs:
1862   0A54 10 20 00      mov a, root_id
1863   0A57             loadfile_from_path_e0:
1864   0A57 07 29 15      call get_token
1865   0A5A 31 CA 16      mov bl, [toktyp]
1866   0A5D C1 00         cmp bl, toktyp_identifier
1867   0A5F C7 C4 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1868   0A62 FD 4D CC 16   mov si, tokstr
1869   0A66 FD 4F BA 1C   mov di, filename
1870   0A6A 07 FB 10      call _strcpy        
1871   0A6D 77            inc a                         ; metadata sector
1872   0A6E 27            mov b, a
1873   0A6F 38 00 00      mov c, 0                      ; upper lba = 0
1874   0A72 22 01         mov ah, $01                  ; 1 sector
1875   0A74 3B 3A 25      mov d, transient_area
1876   0A77 07 81 05      call ide_read_sect            ; read directory
1877   0A7A FD 10         cla
1878   0A7C 42 D5 17      mov [index], a
1879   0A7F             loadfile_from_path_l1:
1880   0A7F FD 4E         mov si, d
1881   0A81 FD 4F BA 1C   mov di, filename
1882   0A85 07 E6 10      call _strcmp
1883   0A88 C6 9E 0A      je loadfile_from_path_name_equal  
1884   0A8B 58 20 00      add d, 32
1885   0A8E 14 D5 17      mov a, [index]
1886   0A91 77            inc a
1887   0A92 42 D5 17      mov [index], a
1888   0A95 AF 10 00      cmp a, fst_files_per_dir
1889   0A98 C6 C4 0A      je loadfile_from_path_end
1890   0A9B 0A 7F 0A      jmp loadfile_from_path_l1
1891   0A9E             loadfile_from_path_name_equal:
1892   0A9E 33 18 00      mov bl, [d + 24]
1893   0AA1 FD 87 38      and bl, %00111000             ; directory flag
1894   0AA4 C1 08         cmp bl, %00001000             ; is dir?
1895   0AA6 C6 BA 0A      je loadfile_isdirectory  
1896   0AA9             ; entry is a file
1897   0AA9 2B 19 00      mov b, [d + 25]               ; get lba
1898   0AAC FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1899   0AAE 3B 3A 25      mov d, transient_area
1900   0AB1 38 00 00      mov c, 0
1901   0AB4 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1902   0AB6 07 81 05      call ide_read_sect            ; read sector
1903   0AB9 09            ret
1904   0ABA             loadfile_isdirectory:
1905   0ABA 58 19 00      add d, 25           
1906   0ABD 15            mov a, [d]                    ; set result register a = dirid
1907   0ABE 07 29 15      call get_token
1908   0AC1 0A 57 0A      jmp loadfile_from_path_e0
1909   0AC4             loadfile_from_path_end:
1910   0AC4 09            ret
1911   0AC5             
1912   0AC5             ;------------------------------------------------------------------------------------------------------;
1913   0AC5             ; return the id of the current directory
1914   0AC5             ; id returned in b
1915   0AC5             ;------------------------------------------------------------------------------------------------------;
1916   0AC5             fs_get_curr_dirid:
1917   0AC5 29 DD 17      mov b, [current_dir_id]
1918   0AC8 06            sysret
1919   0AC9             
1920   0AC9             ;------------------------------------------------------------------------------------------------------;
1921   0AC9             ; cd
1922   0AC9             ;------------------------------------------------------------------------------------------------------;
1923   0AC9             ; new dirid in b
1924   0AC9             fs_cd:
1925   0AC9 FD 42 DD 17   mov [current_dir_id], b
1926   0ACD 06            sysret  
1927   0ACE             
1928   0ACE             ;------------------------------------------------------------------------------------------------------;
1929   0ACE             ; ls
1930   0ACE             ; dirid in b
1931   0ACE             ;------------------------------------------------------------------------------------------------------;
1932   0ACE 00 00       ls_count:       .dw 0
1933   0AD0             fs_ls:
1934   0AD0 FD 77         inc b                        ; metadata sector
1935   0AD2 38 00 00      mov c, 0                     ; upper lba = 0
1936   0AD5 22 01         mov ah, $01                  ; 1 sector
1937   0AD7 3B 3A 25      mov d, transient_area
1938   0ADA 07 81 05      call ide_read_sect           ; read directory
1939   0ADD FD 10         cla
1940   0ADF 42 D5 17      mov [index], a               ; reset entry index
1941   0AE2 3D CE 0A      mov [ls_count], al           ; reset item count
1942   0AE5             fs_ls_l1:
1943   0AE5 BD 00         cmp byte [d], 0              ; check for null
1944   0AE7 C6 7E 0B      je fs_ls_next
1945   0AEA             fs_ls_non_null:
1946   0AEA 1D CE 0A      mov al, [ls_count]
1947   0AED 7A            inc al
1948   0AEE 3D CE 0A      mov [ls_count], al           ; increment item count
1949   0AF1 1F 18 00      mov al, [d + 24]
1950   0AF4 87 38         and al, %00111000
1951   0AF6 FD A2 03      shr al, 3
1952   0AF9 22 00         mov ah, 0                    ; file type
1953   0AFB B7 08 18      mov a, [a + file_type]      
1954   0AFE 23            mov ah, al
1955   0AFF 07 77 11      call _putchar
1956   0B02 1F 18 00      mov al, [d + 24]
1957   0B05 87 01         and al, %00000001
1958   0B07 22 00         mov ah, 0
1959   0B09 B7 03 18      mov a, [a + file_attrib]     ; read
1960   0B0C 23            mov ah, al
1961   0B0D 07 77 11      call _putchar
1962   0B10 1F 18 00      mov al, [d + 24]
1963   0B13 87 02         and al, %00000010
1964   0B15 22 00         mov ah, 0
1965   0B17 B7 03 18      mov a, [a + file_attrib]     ; write
1966   0B1A 23            mov ah, al
1967   0B1B 07 77 11      call _putchar
1968   0B1E 1F 18 00      mov al, [d + 24]
1969   0B21 87 04         and al, %00000100
1970   0B23 22 00         mov ah, 0
1971   0B25 B7 03 18      mov a, [a + file_attrib]     ; execute
1972   0B28 23            mov ah, al
1973   0B29 07 77 11      call _putchar
1974   0B2C 22 20         mov ah, $20
1975   0B2E 07 77 11      call _putchar  
1976   0B31 2B 1B 00      mov b, [d + 27]
1977   0B34 07 FF 12      call print_u16x              ; filesize
1978   0B37 22 20         mov ah, $20
1979   0B39 07 77 11      call _putchar  
1980   0B3C 2B 19 00      mov b, [d + 25]
1981   0B3F 07 FF 12      call print_u16x              ; dirid / lba
1982   0B42 22 20         mov ah, $20
1983   0B44 07 77 11      call _putchar
1984   0B47             ; print date
1985   0B47 33 1D 00      mov bl, [d + 29]             ; day
1986   0B4A 07 43 13      call print_u8x
1987   0B4D 22 20         mov ah, $20
1988   0B4F 07 77 11      call _putchar  
1989   0B52 1F 1E 00      mov al, [d + 30]             ; month
1990   0B55 FD 9E 02      shl al, 2
1991   0B58 DA            push d
1992   0B59 3B C7 18      mov d, s_months
1993   0B5C 22 00         mov ah, 0
1994   0B5E 59            add d, a
1995   0B5F 07 A3 12      call _puts
1996   0B62 E7            pop d
1997   0B63 22 20         mov ah, $20
1998   0B65 07 77 11      call _putchar
1999   0B68 2E 20         mov bl, $20
2000   0B6A 07 43 13      call print_u8x
2001   0B6D 33 1F 00      mov bl, [d + 31]             ; year
2002   0B70 07 43 13      call print_u8x  
2003   0B73 22 20         mov ah, $20
2004   0B75 07 77 11      call _putchar  
2005   0B78 07 A3 12      call _puts                   ; print filename  
2006   0B7B 07 50 12      call printnl
2007   0B7E             fs_ls_next:
2008   0B7E 14 D5 17      mov a, [index]
2009   0B81 77            inc a
2010   0B82 42 D5 17      mov [index], a
2011   0B85 AF 10 00      cmp a, fst_files_per_dir
2012   0B88 C6 91 0B      je fs_ls_end
2013   0B8B 58 20 00      add d, 32      
2014   0B8E 0A E5 0A      jmp fs_ls_l1  
2015   0B91             fs_ls_end:
2016   0B91 3B 18 18      mov d, s_ls_total
2017   0B94 07 A3 12      call _puts
2018   0B97 1D CE 0A      mov al, [ls_count]
2019   0B9A 07 55 13      call print_u8d
2020   0B9D 07 50 12      call printnl
2021   0BA0 06            sysret
2022   0BA1             
2023   0BA1             ;------------------------------------------------------------------------------------------------------;
2024   0BA1             ; finds an empty data block
2025   0BA1             ; block lba returned in b
2026   0BA1             ;------------------------------------------------------------------------------------------------------;
2027   0BA1             fs_find_empty_block:
2028   0BA1 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2029   0BA4 38 00 00      mov c, 0                ; upper lba = 0
2030   0BA7             fs_find_empty_block_l1:  
2031   0BA7 22 01         mov ah, $01                  ; 1 sector
2032   0BA9 3B 3A 23      mov d, transient_area - 512
2033   0BAC 07 81 05      call ide_read_sect      ; read sector
2034   0BAF BD 00         cmp byte [d], 0
2035   0BB1 C6 BA 0B      je fs_find_empty_block_found_null
2036   0BB4 55 20 00      add b, fs_sectors_per_file
2037   0BB7 0A A7 0B      jmp fs_find_empty_block_l1
2038   0BBA             fs_find_empty_block_found_null:
2039   0BBA 09            ret
2040   0BBB             
2041   0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2042   0BBB             ;; create new textfile
2043   0BBB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2044   0BBB             ; search for first null block
2045   0BBB             fs_mktxt:
2046   0BBB FD 4E       	mov si, d
2047   0BBD FD 4F 3A 1D 	mov di, user_data
2048   0BC1 38 00 01    	mov c, 256
2049   0BC4 04          	load					; load data from user-space
2050   0BC5             	
2051   0BC5 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2052   0BC8 38 00 00    	mov c, 0						; reset lba to 0
2053   0BCB             fs_mktxt_l1:	
2054   0BCB 10 02 01    	mov a, $0102			; disk read
2055   0BCE 3B 3A 25    	mov d, transient_area
2056   0BD1 05 02       	syscall sys_ide ; read sector
2057   0BD3 1E          	mov al, [d]
2058   0BD4 B9 00       	cmp al, 0			; check for null
2059   0BD6 C6 DF 0B    	je fs_mktxt_found_null
2060   0BD9 55 20 00    	add b, fs_sectors_per_file
2061   0BDC 0A CB 0B    	jmp fs_mktxt_l1
2062   0BDF             fs_mktxt_found_null:
2063   0BDF D8          	push b				; save lba
2064   0BE0             ;create header file by grabbing file name from parameter	
2065   0BE0 3B F9 17    	mov d, s_dataentry
2066   0BE3 07 A3 12    	call _puts
2067   0BE6 3B 3A 27    	mov d, transient_area + 512			; pointer to file contents
2068   0BE9 07 09 12    	call _gettxt
2069   0BEC 07 D6 10    	call _strlen						; get length of file
2070   0BEF D9          	push c							; save length
2071   0BF0 19 01       	mov al, 1
2072   0BF2 3D 3A 25    	mov [transient_area], al					; mark sectors as used (not null)
2073   0BF5 10 00 00    	mov a, 0
2074   0BF8 42 D5 17    	mov [index], a
2075   0BFB 3B 3A 25    	mov d, transient_area
2076   0BFE 13          	mov a, d
2077   0BFF 42 D7 17    	mov [buffer_addr], a
2078   0C02             fs_mktxt_l2:
2079   0C02 38 00 00    	mov c, 0
2080   0C05 10 03 01    	mov a, $0103			; disk write, 1 sector
2081   0C08 05 02       	syscall sys_ide		; write sector
2082   0C0A 14 D5 17    	mov a, [index]
2083   0C0D 77          	inc a
2084   0C0E 42 D5 17    	mov [index], a
2085   0C11 AF 20 00    	cmp a, fs_sectors_per_file
2086   0C14 C6 26 0C    	je fs_mktxt_add_to_dir
2087   0C17 FD 77       	inc b
2088   0C19 14 D7 17    	mov a, [buffer_addr]
2089   0C1C 53 00 02    	add a, 512
2090   0C1F 42 D7 17    	mov [buffer_addr], a
2091   0C22 3C          	mov d, a
2092   0C23 0A 02 0C    	jmp fs_mktxt_l2
2093   0C26             ; now we add the file to the current directory!
2094   0C26             fs_mktxt_add_to_dir:	
2095   0C26 14 DD 17    	mov a, [current_dir_id]
2096   0C29 77          	inc a
2097   0C2A 27          	mov b, a					; metadata sector
2098   0C2B 38 00 00    	mov c, 0
2099   0C2E FD 79       	mov g, b					; save lba
2100   0C30 3B 3A 25    	mov d, transient_area
2101   0C33 10 02 01    	mov a, $0102			; disk read
2102   0C36 05 02       	syscall sys_ide		; read metadata sector
2103   0C38             fs_mktxt_add_to_dir_l2:
2104   0C38 1E          	mov al, [d]
2105   0C39 B9 00       	cmp al, 0
2106   0C3B C6 44 0C    	je fs_mktxt_add_to_dir_null
2107   0C3E 58 20 00    	add d, fst_entry_size
2108   0C41 0A 38 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2109   0C44             fs_mktxt_add_to_dir_null:
2110   0C44 FD 4D 3A 1D 	mov si, user_data
2111   0C48 FD 50       	mov di, d
2112   0C4A 07 FB 10    	call _strcpy			; copy file name
2113   0C4D 58 18 00    	add d, 24			; skip name
2114   0C50 19 06       	mov al, %00000110		; no execute, write, read, not directory
2115   0C52 3E          	mov [d], al			
2116   0C53 58 03 00    	add d, 3
2117   0C56 E4          	pop a
2118   0C57 43          	mov [d], a
2119   0C58 63 02 00    	sub d, 2
2120   0C5B E5          	pop b				; get file lba
2121   0C5C FD 43       	mov [d], b			; save lba	
2122   0C5E             	
2123   0C5E             	; set file creation date	
2124   0C5E 58 04 00    	add d, 4
2125   0C61 19 04       	mov al, 4
2126   0C63 05 01       	syscall sys_rtc
2127   0C65 1A          	mov al, ah
2128   0C66 3E          	mov [d], al			; set day
2129   0C67             	
2130   0C67 79          	inc d
2131   0C68 19 05       	mov al, 5
2132   0C6A 05 01       	syscall sys_rtc
2133   0C6C 1A          	mov al, ah
2134   0C6D 3E          	mov [d], al			; set month
2135   0C6E             	
2136   0C6E 79          	inc d
2137   0C6F 19 06       	mov al, 6
2138   0C71 05 01       	syscall sys_rtc
2139   0C73 1A          	mov al, ah
2140   0C74 3E          	mov [d], al			; set year
2141   0C75             	
2142   0C75             ; write sector into disk for new directory entry
2143   0C75 FD 27       	mov b, g
2144   0C77 38 00 00    	mov c, 0
2145   0C7A 3B 3A 25    	mov d, transient_area
2146   0C7D 10 03 01    	mov a, $0103			; disk write, 1 sector
2147   0C80 05 02       	syscall sys_ide		; write sector
2148   0C82 07 50 12    	call printnl
2149   0C85 06          	sysret
2150   0C86             
2151   0C86             
2152   0C86             
2153   0C86             ;------------------------------------------------------------------------------------------------------;
2154   0C86             ; create new binary file
2155   0C86             ;------------------------------------------------------------------------------------------------------;
2156   0C86             ; search for first null block
2157   0C86             fs_mkbin:
2158   0C86 19 00         mov al, 0
2159   0C88 3D CD 17      mov [sys_echo_on], al ; disable echo
2160   0C8B FD 4E         mov si, d
2161   0C8D FD 4F 3A 1D   mov di, user_data
2162   0C91 38 00 02      mov c, 512
2163   0C94 04            load                          ; load data from user-space
2164   0C95 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2165   0C98 38 00 00      mov c, 0                      ; upper lba = 0
2166   0C9B             fs_mkbin_l1:  
2167   0C9B 22 01         mov ah, $01                  ; 1 sector
2168   0C9D 3B 3A 25      mov d, transient_area
2169   0CA0 07 81 05      call ide_read_sect            ; read sector
2170   0CA3 BD 00         cmp byte[d], 0                ; check for null
2171   0CA5 C6 AE 0C      je fs_mkbin_found_null
2172   0CA8 55 20 00      add b, fs_sectors_per_file
2173   0CAB 0A 9B 0C      jmp fs_mkbin_l1
2174   0CAE             fs_mkbin_found_null:
2175   0CAE D8            push b                        ; save lba
2176   0CAF             ;create header file by grabbing file name from parameter
2177   0CAF FD 4F 3A 27   mov di, transient_area + 512  ; pointer to file contents
2178   0CB3 07 29 10      call _load_hex                ; load binary hex
2179   0CB6 D9            push c                        ; save size (nbr of bytes)
2180   0CB7 19 01         mov al, 1
2181   0CB9 3D 3A 25      mov [transient_area], al      ; mark sectors as used (not null)
2182   0CBC FD 10         cla
2183   0CBE 42 D5 17      mov [index], a
2184   0CC1 3B 3A 25      mov d, transient_area
2185   0CC4 13            mov a, d
2186   0CC5 42 D7 17      mov [buffer_addr], a
2187   0CC8             fs_mkbin_l2:
2188   0CC8 38 00 00      mov c, 0
2189   0CCB 22 01         mov ah, $01                   ; disk write, 1 sector
2190   0CCD 07 A7 05      call ide_write_sect           ; write sector
2191   0CD0 14 D5 17      mov a, [index]
2192   0CD3 77            inc a
2193   0CD4 42 D5 17      mov [index], a
2194   0CD7 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2195   0CDA C6 EC 0C      je fs_mkbin_add_to_dir
2196   0CDD FD 77         inc b
2197   0CDF 14 D7 17      mov a, [buffer_addr]
2198   0CE2 53 00 02      add a, 512
2199   0CE5 42 D7 17      mov [buffer_addr], a
2200   0CE8 3C            mov d, a
2201   0CE9 0A C8 0C      jmp fs_mkbin_l2
2202   0CEC             ; now we add the file to the current directory!
2203   0CEC             fs_mkbin_add_to_dir:  
2204   0CEC 14 DD 17      mov a, [current_dir_id]
2205   0CEF 77            inc a
2206   0CF0 27            mov b, a                      ; metadata sector
2207   0CF1 38 00 00      mov c, 0
2208   0CF4 FD 79         mov g, b                      ; save lba
2209   0CF6 3B 3A 25      mov d, transient_area
2210   0CF9 22 01         mov ah, $01                  ; 1 sector
2211   0CFB 07 81 05      call ide_read_sect            ; read metadata sector
2212   0CFE             fs_mkbin_add_to_dir_l2:
2213   0CFE BD 00         cmp byte[d], 0
2214   0D00 C6 09 0D      je fs_mkbin_add_to_dir_null
2215   0D03 58 20 00      add d, fst_entry_size
2216   0D06 0A FE 0C      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2217   0D09             fs_mkbin_add_to_dir_null:
2218   0D09 FD 4D 3A 1D   mov si, user_data
2219   0D0D FD 50         mov di, d
2220   0D0F 07 FB 10      call _strcpy                  ; copy file name
2221   0D12 58 18 00      add d, 24                     ; skip name
2222   0D15 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2223   0D17 3E            mov [d], al
2224   0D18 58 03 00      add d, 3
2225   0D1B E4            pop a
2226   0D1C 43            mov [d], a
2227   0D1D 63 02 00      sub d, 2
2228   0D20 E5            pop b                         ; get file lba
2229   0D21 FD 43         mov [d], b                    ; save lba
2230   0D23               ; set file creation date  
2231   0D23 58 04 00      add d, 4
2232   0D26 19 04         mov al, 4
2233   0D28 05 01         syscall sys_rtc
2234   0D2A 1A            mov al, ah
2235   0D2B 3E            mov [d], al                   ; set day
2236   0D2C 79            inc d
2237   0D2D 19 05         mov al, 5
2238   0D2F 05 01         syscall sys_rtc
2239   0D31 1A            mov al, ah
2240   0D32 3E            mov [d], al                   ; set month
2241   0D33 79            inc d
2242   0D34 19 06         mov al, 6
2243   0D36 05 01         syscall sys_rtc
2244   0D38 1A            mov al, ah
2245   0D39 3E            mov [d], al                   ; set year
2246   0D3A             ; write sector into disk for new directory entry
2247   0D3A FD 27         mov b, g
2248   0D3C 38 00 00      mov c, 0
2249   0D3F 3B 3A 25      mov d, transient_area
2250   0D42 22 01         mov ah, $01                   ; disk write, 1 sector
2251   0D44 07 A7 05      call ide_write_sect           ; write sector
2252   0D47 19 01         mov al, 1
2253   0D49 3D CD 17      mov [sys_echo_on], al ; enable echo
2254   0D4C 06            sysret
2255   0D4D             
2256   0D4D             ;------------------------------------------------------------------------------------------------------;
2257   0D4D             ; pwd - print working directory
2258   0D4D             ;------------------------------------------------------------------------------------------------------;    
2259   0D4D             fs_pwd:
2260   0D4D 3B BA 1C      mov d, filename
2261   0D50 19 00         mov al, 0
2262   0D52 3E            mov [d], al                   ; initialize path string 
2263   0D53 14 DD 17      mov a, [current_dir_id]
2264   0D56 07 B7 08      call fs_dir_id_to_path_e0
2265   0D59 3B BA 1C      mov d, filename
2266   0D5C 07 8F 10      call _strrev
2267   0D5F 07 A3 12      call _puts
2268   0D62 07 50 12      call printnl
2269   0D65 06            sysret
2270   0D66             
2271   0D66             ;------------------------------------------------------------------------------------------------------;
2272   0D66             ; get current directory lba
2273   0D66             ; a: returned lba
2274   0D66             ;------------------------------------------------------------------------------------------------------;
2275   0D66             cmd_get_curr_dir_lba:
2276   0D66 14 DD 17      mov a, [current_dir_id]
2277   0D69 06            sysret
2278   0D6A             
2279   0D6A             ;------------------------------------------------------------------------------------------------------;
2280   0D6A             ; cat
2281   0D6A             ; userspace destination data pointer in d
2282   0D6A             ; filename starts at d, but is overwritten after the read is made
2283   0D6A             ;------------------------------------------------------------------------------------------------------;:
2284   0D6A             fs_cat:
2285   0D6A DA            push d                              ; save userspace file data destination
2286   0D6B FD 4E         mov si, d
2287   0D6D FD 4F 3A 1D   mov di, user_data
2288   0D71 38 00 02      mov c, 512
2289   0D74 04            load                                ; copy filename from user-space
2290   0D75 29 DD 17      mov b, [current_dir_id]
2291   0D78 FD 77         inc b                               ; metadata sector
2292   0D7A 38 00 00      mov c, 0                            ; upper lba = 0
2293   0D7D 22 01         mov ah, $01                  ; 1 sector
2294   0D7F 3B 3A 23      mov d, transient_area-512
2295   0D82 07 81 05      call ide_read_sect                  ; read directory
2296   0D85 FD 10         cla
2297   0D87 42 D5 17      mov [index], a                      ; reset file counter
2298   0D8A             fs_cat_l1:
2299   0D8A FD 4E         mov si, d
2300   0D8C FD 4F 3A 1D   mov di, user_data
2301   0D90 07 E6 10      call _strcmp
2302   0D93 C6 A9 0D      je fs_cat_found_entry
2303   0D96 58 20 00      add d, 32
2304   0D99 14 D5 17      mov a, [index]
2305   0D9C 77            inc a
2306   0D9D 42 D5 17      mov [index], a
2307   0DA0 AF 10 00      cmp a, fst_files_per_dir
2308   0DA3 C6 C4 0D      je fs_cat_not_found
2309   0DA6 0A 8A 0D      jmp fs_cat_l1
2310   0DA9             fs_cat_found_entry:
2311   0DA9 58 19 00      add d, 25                           ; get to dirid of file in disk
2312   0DAC 2A            mov b, [d]                          ; get lba
2313   0DAD FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2314   0DAF 3B 3A 25      mov d, transient_area  
2315   0DB2 38 00 00      mov c, 0
2316   0DB5 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2317   0DB7 07 81 05      call ide_read_sect                  ; read sectors
2318   0DBA F0            pop di                              ; write userspace file data destination to di
2319   0DBB FD 4D 3A 25   mov si, transient_area              ; data origin
2320   0DBF 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2321   0DC2 03            store
2322   0DC3 06            sysret
2323   0DC4             fs_cat_not_found:
2324   0DC4 E7            pop d
2325   0DC5 06            sysret
2326   0DC6             
2327   0DC6             ;------------------------------------------------------------------------------------------------------;
2328   0DC6             ; rmdir - remove dir by dirid
2329   0DC6             ;------------------------------------------------------------------------------------------------------;
2330   0DC6             ; deletes a directory entry in the given directory's file list 
2331   0DC6             ; also deletes the actual directory entry in the fst
2332   0DC6             ; synopsis: rmdir /usr/local/testdir
2333   0DC6             ; b = dirid
2334   0DC6             fs_rmdir:
2335   0DC6 FD 79         mov g, b
2336   0DC8 11            mov a, b
2337   0DC9 07 F3 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2338   0DCC D7            push a                        ; save dirid
2339   0DCD             ; search for directory's entry in the parent's directory then and delete it
2340   0DCD 77            inc a                         ; metadata sector
2341   0DCE 27            mov b, a
2342   0DCF 38 00 00      mov c, 0                      ; upper lba = 0
2343   0DD2 22 01         mov ah, $01          ;
2344   0DD4 3B 3A 25      mov d, transient_area
2345   0DD7 07 81 05      call ide_read_sect            ; read directory
2346   0DDA FD 10         cla
2347   0DDC 42 D5 17      mov [index], a                ; reset file counter
2348   0DDF FD 27         mov b, g                      ; retrieve directory's dirid
2349   0DE1             fs_rmdir_l1:
2350   0DE1 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2351   0DE4 B0            cmp a, b                      ; compare dirid's to find the directory
2352   0DE5 C6 FB 0D      je fs_rmdir_found_entry
2353   0DE8 58 20 00      add d, 32
2354   0DEB 14 D5 17      mov a, [index]
2355   0DEE 77            inc a
2356   0DEF 42 D5 17      mov [index], a
2357   0DF2 AF 10 00      cmp a, fst_files_per_dir
2358   0DF5 C6 20 0E      je fs_rmdir_not_found
2359   0DF8 0A E1 0D      jmp fs_rmdir_l1
2360   0DFB             fs_rmdir_found_entry:
2361   0DFB FD 10         cla
2362   0DFD 3E            mov [d], al                   ; make filename null
2363   0DFE 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2364   0E01 E5            pop b
2365   0E02 FD 77         inc b                         ; metadata sector
2366   0E04 38 00 00      mov c, 0                      ; upper lba = 0
2367   0E07 22 01         mov ah, $01          ; 
2368   0E09 3B 3A 25      mov d, transient_area
2369   0E0C 07 A7 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2370   0E0F             
2371   0E0F FD 27         mov b, g
2372   0E11 3B 3A 25      mov d, transient_area  
2373   0E14 FD 10         cla
2374   0E16 3E            mov [d], al                   ; make directory's name header null for re-use
2375   0E17 38 00 00      mov c, 0
2376   0E1A 22 01         mov ah, $01                   ; disk write 1 sect
2377   0E1C 07 A7 05      call ide_write_sect           ; delete directory given by dirid in b
2378   0E1F 06            sysret
2379   0E20             fs_rmdir_not_found:
2380   0E20 E5            pop b
2381   0E21 06            sysret
2382   0E22             
2383   0E22             ;------------------------------------------------------------------------------------------------------;
2384   0E22             ; rm - remove file
2385   0E22             ;------------------------------------------------------------------------------------------------------;
2386   0E22             ; frees up the data sectors for the file further down the disk
2387   0E22             ; deletes file entry in the directory's file list 
2388   0E22             fs_rm:
2389   0E22 FD 4E         mov si, d
2390   0E24 FD 4F 3A 1D   mov di, user_data
2391   0E28 38 00 02      mov c, 512
2392   0E2B 04            load                          ; load data from user-space
2393   0E2C 14 DD 17      mov a, [current_dir_id]
2394   0E2F 77            inc a                         ; metadata sector
2395   0E30 27            mov b, a
2396   0E31 38 00 00      mov c, 0                      ; upper lba = 0
2397   0E34 22 01         mov ah, $01                  ; 1 sector
2398   0E36 3B 3A 25      mov d, transient_area
2399   0E39 07 81 05      call ide_read_sect            ; read directory
2400   0E3C 10 00 00      mov a, 0
2401   0E3F 42 D5 17      mov [index], a                ; reset file counter
2402   0E42             fs_rm_l1:
2403   0E42 FD 4E         mov si, d
2404   0E44 FD 4F 3A 1D   mov di, user_data
2405   0E48 07 E6 10      call _strcmp
2406   0E4B C6 61 0E      je fs_rm_found_entry
2407   0E4E 58 20 00      add d, 32
2408   0E51 14 D5 17      mov a, [index]
2409   0E54 77            inc a
2410   0E55 42 D5 17      mov [index], a
2411   0E58 AF 10 00      cmp a, fst_files_per_dir
2412   0E5B C6 89 0E      je fs_rm_not_found
2413   0E5E 0A 42 0E      jmp fs_rm_l1
2414   0E61             fs_rm_found_entry:
2415   0E61 2B 19 00      mov b, [d + 25]               ; get lba
2416   0E64 FD 79         mov g, b                      ; save lba
2417   0E66 19 00         mov al, 0
2418   0E68 3E            mov [d], al                   ; make file entry null
2419   0E69 14 DD 17      mov a, [current_dir_id]
2420   0E6C 77            inc a                         ; metadata sector
2421   0E6D 27            mov b, a
2422   0E6E 38 00 00      mov c, 0                      ; upper lba = 0
2423   0E71 22 01         mov ah, $01                   ; disk write
2424   0E73 3B 3A 25      mov d, transient_area
2425   0E76 07 A7 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2426   0E79 3B 3A 25      mov d, transient_area  
2427   0E7C 19 00         mov al, 0
2428   0E7E 3E            mov [d], al                   ; make file's data header null for re-use
2429   0E7F 38 00 00      mov c, 0
2430   0E82 FD 27         mov b, g                      ; get data header lba
2431   0E84 22 01         mov ah, $01                   ; disk write 1 sect
2432   0E86 07 A7 05      call ide_write_sect           ; write sector
2433   0E89             fs_rm_not_found:  
2434   0E89 06            sysret  
2435   0E8A             
2436   0E8A             ;------------------------------------------------------------------------------------------------------;
2437   0E8A             ; mv - move / change file name
2438   0E8A             ;------------------------------------------------------------------------------------------------------;
2439   0E8A             fs_mv:
2440   0E8A FD 4E         mov si, d
2441   0E8C FD 4F 3A 1D   mov di, user_data
2442   0E90 38 00 02      mov c, 512
2443   0E93 04            load                          ; load data from user-space
2444   0E94 14 DD 17      mov a, [current_dir_id]
2445   0E97 77            inc a                         ; metadata sector
2446   0E98 27            mov b, a  
2447   0E99 38 00 00      mov c, 0                      ; upper lba = 0
2448   0E9C 22 01         mov ah, $01                  ; 1 sector
2449   0E9E 3B 3A 25      mov d, transient_area
2450   0EA1 07 81 05      call ide_read_sect            ; read directory
2451   0EA4 FD 10         cla
2452   0EA6 42 D5 17      mov [index], a                ; reset file counter
2453   0EA9             fs_mv_l1:
2454   0EA9 FD 4E         mov si, d
2455   0EAB FD 4F 3A 1D   mov di, user_data
2456   0EAF 07 E6 10      call _strcmp
2457   0EB2 C6 C8 0E      je fs_mv_found_entry
2458   0EB5 58 20 00      add d, 32
2459   0EB8 14 D5 17      mov a, [index]
2460   0EBB 77            inc a
2461   0EBC 42 D5 17      mov [index], a
2462   0EBF AF 10 00      cmp a, fst_files_per_dir
2463   0EC2 C6 FA 0E      je fs_mv_not_found
2464   0EC5 0A A9 0E      jmp fs_mv_l1
2465   0EC8             fs_mv_found_entry:  
2466   0EC8 DA            push d
2467   0EC9 FD 4D BA 1D   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2468   0ECD FD 50         mov di, d
2469   0ECF 07 FB 10      call _strcpy  
2470   0ED2 38 00 00      mov c, 0
2471   0ED5 3B 3A 25      mov d, transient_area
2472   0ED8 22 01         mov ah, $01                   ; disk write 1 sect
2473   0EDA 07 A7 05      call ide_write_sect           ; write sector
2474   0EDD E7            pop d
2475   0EDE             ;; need to check whether its a dir or a file here ;;;
2476   0EDE 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2477   0EE1 22 01         mov ah, $01
2478   0EE3 3B 3A 25      mov d, transient_area
2479   0EE6 38 00 00      mov c, 0
2480   0EE9 07 81 05      call ide_read_sect            ; read directory entry
2481   0EEC FD 4D BA 1D   mov si, user_data + 128
2482   0EF0 FD 50         mov di, d
2483   0EF2 07 FB 10      call _strcpy                  ; change directory's name
2484   0EF5 22 01         mov ah, $01
2485   0EF7 07 A7 05      call ide_write_sect           ; rewrite directory back to disk
2486   0EFA             fs_mv_not_found:
2487   0EFA 06            sysret
2488   0EFB             
2489   0EFB             
2490   0EFB             ;----------------------------------------------------------------------------------------------------;
2491   0EFB             ; process index in a
2492   0EFB             ;----------------------------------------------------------------------------------------------------;
2493   0EFB             find_free_proc:
2494   0EFB FD 4D AB 1A   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2495   0EFF             find_free_proc_l0:
2496   0EFF F6            lodsb                               ; get process state
2497   0F00 B9 00         cmp al, 0
2498   0F02 C6 08 0F      je find_free_proc_free              ; if free, jump
2499   0F05 0A FF 0E      jmp find_free_proc_l0               ; else, goto next
2500   0F08             find_free_proc_free:
2501   0F08 4E            mov a, si
2502   0F09 5F AB 1A      sub a, 1 + proc_availab_table       ; get process index
2503   0F0C 09            ret
2504   0F0D               
2505   0F0D             
2506   0F0D             ;----------------------------------------------------------------------------------------------------;
2507   0F0D             ; process index in al
2508   0F0D             ;----------------------------------------------------------------------------------------------------;
2509   0F0D             proc_memory_map:
2510   0F0D 22 00         mov ah, 0
2511   0F0F 27            mov b, a                      ; page in bl, 0 in bh
2512   0F10 FD 9D 05      shl a, 5                      ; multiply by 32
2513   0F13 39            mov c, a                      ; save in c
2514   0F14 57 20 00      add c, 32
2515   0F17             proc_memory_map_l0:
2516   0F17 02            pagemap
2517   0F18 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2518   0F1B 53 01 00      add a, 1                      ; increase both 
2519   0F1E B1            cmp a, c                      ; check to see if we reached the end of memory
2520   0F1F C7 17 0F      jne proc_memory_map_l0
2521   0F22 09            ret
2522   0F23               
2523   0F23             
2524   0F23             ;----------------------------------------------------------------------------------------------------;
2525   0F23             ; terminate process
2526   0F23             ;----------------------------------------------------------------------------------------------------;
2527   0F23             syscall_terminate_proc:
2528   0F23 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2529   0F26                                                    ; since they will not be used for anything here.
2530   0F26 1D D4 17      mov al, [active_proc_index]
2531   0F29 22 00         mov ah, 0  
2532   0F2B FD 9D 05      shl a, 5                             ; x32
2533   0F2E 53 BA 1A      add a, proc_names
2534   0F31 3C            mov d, a
2535   0F32 19 00         mov al, 0
2536   0F34 3E            mov [d], al                           ; nullify process name
2537   0F35             
2538   0F35 1D D4 17      mov al, [active_proc_index]
2539   0F38 22 00         mov ah, 0  
2540   0F3A 3C            mov d, a
2541   0F3B 19 00         mov al, 0
2542   0F3D 3F AA 1A      mov [d + proc_availab_table], al    ; make process empty again
2543   0F40               
2544   0F40 1D D3 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2545   0F43 80            dec al
2546   0F44 3D D3 17      mov [nbr_active_procs], al
2547   0F47             
2548   0F47             ; now load the shell process again
2549   0F47 19 02         mov al, 2                           ; next process = process 2 = shell
2550   0F49 3D D4 17      mov [active_proc_index], al         ; set next active proc
2551   0F4C             
2552   0F4C             ; calculate lut entry for next process
2553   0F4C 22 00         mov ah, 0
2554   0F4E FD 99         shl a                               ; x2
2555   0F50 B7 19 10      mov a, [proc_table_convert + a]     ; get process state start index  
2556   0F53               
2557   0F53 4D            mov si, a                           ; source is proc state block
2558   0F54 48            mov a, sp
2559   0F55 5F 13 00      sub a, 19
2560   0F58 4F            mov di, a                           ; destination is kernel stack
2561   0F59             ; restore sp
2562   0F59 7D            dec a
2563   0F5A 47            mov sp, a
2564   0F5B 38 14 00      mov c, 20
2565   0F5E FD F5         rep movsb
2566   0F60             ; set vm process
2567   0F60 1D D4 17      mov al, [active_proc_index]
2568   0F63 01            setptb
2569   0F64                 
2570   0F64 4C            popa
2571   0F65 06            sysret
2572   0F66             
2573   0F66             ;----------------------------------------------------------------------------------------------------;
2574   0F66             ; pause process
2575   0F66             ;----------------------------------------------------------------------------------------------------;
2576   0F66             syscall_pause_proc:
2577   0F66             ; save all registers into kernel stack
2578   0F66 4B            pusha
2579   0F67 22 00         mov ah, 0
2580   0F69 1D D4 17      mov al, [active_proc_index]
2581   0F6C FD 99         shl a              ; x2
2582   0F6E B7 19 10      mov a, [proc_table_convert + a]   ; get process state start index
2583   0F71                 
2584   0F71 4F            mov di, a
2585   0F72 48            mov a, sp
2586   0F73 77            inc a
2587   0F74 4D            mov si, a
2588   0F75 38 14 00      mov c, 20
2589   0F78 FD F5         rep movsb                         ; save process state!
2590   0F7A             ; restore kernel stack position to point before interrupt arrived
2591   0F7A 51 14 00      add sp, 20
2592   0F7D             ; now load the shell process again
2593   0F7D 19 02         mov al, 2                         ; next process = process 2 = shell
2594   0F7F 3D D4 17      mov [active_proc_index], al       ; set next active proc
2595   0F82             
2596   0F82             ; calculate lut entry for next process
2597   0F82 22 00         mov ah, 0
2598   0F84 FD 99         shl a                             ; x2
2599   0F86 B7 19 10      mov a, [proc_table_convert + a]   ; get process state start index  
2600   0F89               
2601   0F89 4D            mov si, a                         ; source is proc state block
2602   0F8A 48            mov a, sp
2603   0F8B 5F 13 00      sub a, 19
2604   0F8E 4F            mov di, a                         ; destination is kernel stack
2605   0F8F             ; restore sp
2606   0F8F 7D            dec a
2607   0F90 47            mov sp, a
2608   0F91 38 14 00      mov c, 20
2609   0F94 FD F5         rep movsb
2610   0F96             ; set vm process
2611   0F96 1D D4 17      mov al, [active_proc_index]
2612   0F99 01            setptb
2613   0F9A                 
2614   0F9A 4C            popa
2615   0F9B 06            sysret
2616   0F9C             
2617   0F9C             ;----------------------------------------------------------------------------------------------------;
2618   0F9C             ; create a new process
2619   0F9C             ; d = path of the process file to be createed
2620   0F9C             ; b = arguments ptr
2621   0F9C             ;----------------------------------------------------------------------------------------------------;
2622   0F9C             syscall_create_proc:
2623   0F9C             ; we save the active process first  
2624   0F9C 4B            pusha
2625   0F9D 22 00         mov ah, 0
2626   0F9F 1D D4 17      mov al, [active_proc_index]
2627   0FA2 FD 99         shl a              ; x2
2628   0FA4 B7 19 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2629   0FA7               
2630   0FA7 4F            mov di, a
2631   0FA8 48            mov a, sp
2632   0FA9 77            inc a
2633   0FAA 4D            mov si, a
2634   0FAB 38 14 00      mov c, 20
2635   0FAE FD F5         rep movsb                          ; save process state!
2636   0FB0             ; restore kernel stack position to point before interrupt arrived
2637   0FB0 51 14 00      add sp, 20
2638   0FB3               
2639   0FB3 FD 4E         mov si, d                          ; copy the file path
2640   0FB5 FD 4F 3A 1D   mov di, user_data
2641   0FB9 38 00 02      mov c, 512
2642   0FBC 04            load
2643   0FBD 11            mov a, b
2644   0FBE 4D            mov si, a                          ; copy the arguments
2645   0FBF FD 4F 3A 23   mov di, scrap_sector
2646   0FC3 38 00 02      mov c, 512
2647   0FC6 04            load
2648   0FC7 07 39 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2649   0FCA                                                  ; the file data is loaded into transient_area
2650   0FCA             ; now we allocate a new process  
2651   0FCA 07 FB 0E      call find_free_proc                ; index in a
2652   0FCD 01            setptb 
2653   0FCE 07 0D 0F      call proc_memory_map               ; map process memory pages
2654   0FD1             ; copy arguments into process's memory
2655   0FD1 FD 4D 3A 23   mov si, scrap_sector
2656   0FD5 FD 4F 00 00   mov di, 0
2657   0FD9 38 00 02      mov c, 512
2658   0FDC 03            store
2659   0FDD             ; now copy process binary data into process's memory
2660   0FDD FD 4D 3A 25   mov si, transient_area
2661   0FE1 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2662   0FE5 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2663   0FE8 03            store                              ; copy process data
2664   0FE9                 
2665   0FE9 07 FB 0E      call find_free_proc                ; index in a
2666   0FEC 3D D4 17      mov [active_proc_index], al        ; set new active process
2667   0FEF FD 9D 05      shl a, 5                           ; x32
2668   0FF2 53 BA 1A      add a, proc_names
2669   0FF5 4F            mov di, a
2670   0FF6 FD 4D 3A 1D   mov si, user_data                  ; copy and store process filename
2671   0FFA 07 FB 10      call _strcpy
2672   0FFD               
2673   0FFD 07 FB 0E      call find_free_proc                ; index in a
2674   1000 3C            mov d, a
2675   1001 19 01         mov al, 1
2676   1003 3F AA 1A      mov [d + proc_availab_table], al   ; make process busy
2677   1006               
2678   1006 1D D3 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2679   1009 7A            inc al
2680   100A 3D D3 17      mov [nbr_active_procs], al
2681   100D             ; launch process
2682   100D FD D7 FF FF   push word $ffff 
2683   1011 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2684   1014 FD D7 00 04   push word text_org
2685   1018 06            sysret
2686   1019             
2687   1019             proc_table_convert:
2688   1019 6A 19         .dw proc_state_table + 0
2689   101B 7E 19         .dw proc_state_table + 20
2690   101D 92 19         .dw proc_state_table + 40
2691   101F A6 19         .dw proc_state_table + 60
2692   1021 BA 19         .dw proc_state_table + 80
2693   1023 CE 19         .dw proc_state_table + 100
2694   1025 E2 19         .dw proc_state_table + 120
2695   1027 F6 19         .dw proc_state_table + 140
2696   1029               
2697   1029             ;----------------------------------------------------------------------------------------------;
2698   1029             ; get hex file
2699   1029             ; di = destination address
2700   1029             ; return length in bytes in c
2701   1029             ;----------------------------------------------------------------------------------------------;
2702   1029             _load_hex:
2703   1029 D7            push a
2704   102A D8            push b
2705   102B DA            push d
2706   102C E2            push si
2707   102D E3            push di
2708   102E 38 00 00      mov c, 0
2709   1031 50            mov a, di
2710   1032 3C            mov d, a          ; start of string data block
2711   1033 07 7E 11      call _gets        ; get program string
2712   1036 4D            mov si, a
2713   1037             __load_hex_loop:
2714   1037 F6            lodsb             ; load from [si] to al
2715   1038 B9 00         cmp al, 0         ; check if ascii 0
2716   103A C6 48 10      jz __load_hex_ret
2717   103D 36            mov bh, al
2718   103E F6            lodsb
2719   103F 2F            mov bl, al
2720   1040 07 34 11      call _atoi        ; convert ascii byte in b to int (to al)
2721   1043 F7            stosb             ; store al to [di]
2722   1044 78            inc c
2723   1045 0A 37 10      jmp __load_hex_loop
2724   1048             __load_hex_ret:
2725   1048 F0            pop di
2726   1049 EF            pop si
2727   104A E7            pop d
2728   104B E5            pop b
2729   104C E4            pop a
2730   104D 09            ret
2731   104E             
2732   104E             ; synopsis: look inside a certain directory for files/directories
2733   104E             ; before calling this function, cd into required directory
2734   104E             ; for each entry inside directory:
2735   104E             ;  if entry is a file:
2736   104E             ;    compare filename to searched filename
2737   104E             ;    if filenames are the same, print filename
2738   104E             ;  else if entry is a directory:
2739   104E             ;    cd to the given directory
2740   104E             ;    recursively call cmd_find
2741   104E             ;    cd outside previous directory
2742   104E             ;  if current entry == last entry, return
2743   104E             ; endfor
2744   104E             f_find:
2745   104E 09            ret
2746   104F             
2747   104F             
2748   104F             ; ---------------------------------------------------------------------
2749   104F             ; kernel reset vector
2750   104F             ; ---------------------------------------------------------------------
2751   104F             kernel_reset_vector:  
2752   104F FD 49 FF F7   mov bp, stack_begin
2753   1053 FD 47 FF F7   mov sp, stack_begin
2754   1057               
2755   1057 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2756   1059 FD 0F         stomsk                        
2757   105B FD 0C         sti  
2758   105D             
2759   105D 0C            lodstat
2760   105E 87 DF         and al, %11011111             ; disable display register loading
2761   1060 0D            stostat
2762   1061               
2763   1061             ; reset fifo pointers
2764   1061 10 3A 1F      mov a, fifo
2765   1064 3B D9 17      mov d, fifo_in
2766   1067 43            mov [d], a
2767   1068 3B DB 17      mov d, fifo_out
2768   106B 43            mov [d], a  
2769   106C 19 02         mov al, 2
2770   106E 05 03         syscall sys_io                ; enable uart in interrupt mode
2771   1070             
2772   1070 3B 28 19      mov d, s_fdc_config
2773   1073 07 A3 12      call _puts
2774   1076 F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2775   107A               
2776   107A 3B 2E 18      mov d, s_kernel_started
2777   107D 07 A3 12      call _puts
2778   1080             
2779   1080 19 10         mov al, 16
2780   1082 05 04         syscall sys_filesystem        ; set root dirid
2781   1084             
2782   1084 3B 4B 18      mov d, s_prompt_init
2783   1087 07 A3 12      call _puts
2784   108A 3B DF 17      mov d, s_init_path
2785   108D 05 05         syscall sys_create_proc       ; launch init as a new process
2786   108F             
2787   108F             
2788   108F             ; file includes
2789   108F             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  108F             boot_origin      .EQU  $8004
0002+  108F             bios_uart        .EQU  $0002
0003+  108F             bios_ide         .EQU  $0003
0004+  108F             bios_reset_vector .EQU  $01c0
0005+  108F             ide_buffer       .EQU  $8204
2790   108F             .include "lib/stdio.asm"
0001+  108F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  108F             ; stdio.s
0003+  108F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  108F             .include "lib/string.asm"
0001++ 108F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 108F             ; string.s
0003++ 108F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 108F             
0005++ 108F             
0006++ 108F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 108F             ; _strrev
0008++ 108F             ; reverse a string
0009++ 108F             ; d = string address
0010++ 108F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 108F             ; 01234
0012++ 108F             _strrev:
0013++ 108F 4B          	pusha
0014++ 1090 07 D6 10    	call _strlen	; length in c
0015++ 1093 12          	mov a, c
0016++ 1094 AF 01 00    	cmp a, 1
0017++ 1097 D0 B1 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 109A 7D          	dec a
0019++ 109B FD 4E       	mov si, d	; beginning of string
0020++ 109D FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 109F 59          	add d, a	; end of string
0022++ 10A0 12          	mov a, c
0023++ 10A1 FD 9B       	shr a		; divide by 2
0024++ 10A3 39          	mov c, a	; c now counts the steps
0025++ 10A4             _strrev_l0:
0026++ 10A4 32          	mov bl, [d]	; save load right-side char into bl
0027++ 10A5 F6          	lodsb		; load left-side char into al; increase si
0028++ 10A6 3E          	mov [d], al	; store left char into right side
0029++ 10A7 1B          	mov al, bl
0030++ 10A8 F7          	stosb		; store right-side char into left-side; increase di
0031++ 10A9 7E          	dec c
0032++ 10AA 7F          	dec d
0033++ 10AB C2 00 00    	cmp c, 0
0034++ 10AE C7 A4 10    	jne _strrev_l0
0035++ 10B1             _strrev_end:
0036++ 10B1 4C          	popa
0037++ 10B2 09          	ret
0038++ 10B3             	
0039++ 10B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10B3             ; _strchr
0041++ 10B3             ; search string in d for char in al
0042++ 10B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10B3             _strchr:
0044++ 10B3             _strchr_l0:
0045++ 10B3 32          	mov bl, [d]
0046++ 10B4 C1 00       	cmp bl, 0
0047++ 10B6 C6 C1 10    	je _strchr_end
0048++ 10B9 BA          	cmp al, bl
0049++ 10BA C6 C1 10    	je _strchr_end
0050++ 10BD 79          	inc d
0051++ 10BE 0A B3 10    	jmp _strchr_l0
0052++ 10C1             _strchr_end:
0053++ 10C1 1B          	mov al, bl
0054++ 10C2 09          	ret
0055++ 10C3             
0056++ 10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10C3             ; _strstr
0058++ 10C3             ; find sub-string
0059++ 10C3             ; str1 in si
0060++ 10C3             ; str2 in di
0061++ 10C3             ; si points to end of source string
0062++ 10C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10C3             _strstr:
0064++ 10C3 DB          	push al
0065++ 10C4 DA          	push d
0066++ 10C5 E3          	push di
0067++ 10C6             _strstr_loop:
0068++ 10C6 F3          	cmpsb					; compare a byte of the strings
0069++ 10C7 C7 D2 10    	jne _strstr_ret
0070++ 10CA FC 00 00    	lea d, [di + 0]
0071++ 10CD BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10CF C7 C6 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10D2             _strstr_ret:
0074++ 10D2 F0          	pop di
0075++ 10D3 E7          	pop d
0076++ 10D4 E8          	pop al
0077++ 10D5 09          	ret
0078++ 10D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10D6             ; length of null terminated string
0080++ 10D6             ; result in c
0081++ 10D6             ; pointer in d
0082++ 10D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10D6             _strlen:
0084++ 10D6 DA          	push d
0085++ 10D7 38 00 00    	mov c, 0
0086++ 10DA             _strlen_l1:
0087++ 10DA BD 00       	cmp byte [d], 0
0088++ 10DC C6 E4 10    	je _strlen_ret
0089++ 10DF 79          	inc d
0090++ 10E0 78          	inc c
0091++ 10E1 0A DA 10    	jmp _strlen_l1
0092++ 10E4             _strlen_ret:
0093++ 10E4 E7          	pop d
0094++ 10E5 09          	ret
0095++ 10E6             
0096++ 10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10E6             ; strcmp
0098++ 10E6             ; compare two strings
0099++ 10E6             ; str1 in si
0100++ 10E6             ; str2 in di
0101++ 10E6             ; create a string compairon instrucion ?????
0102++ 10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10E6             _strcmp:
0104++ 10E6 DB          	push al
0105++ 10E7 DA          	push d
0106++ 10E8 E3          	push di
0107++ 10E9 E2          	push si
0108++ 10EA             _strcmp_loop:
0109++ 10EA F3          	cmpsb					; compare a byte of the strings
0110++ 10EB C7 F6 10    	jne _strcmp_ret
0111++ 10EE FB FF FF    	lea d, [si +- 1]
0112++ 10F1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10F3 C7 EA 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10F6             _strcmp_ret:
0115++ 10F6 EF          	pop si
0116++ 10F7 F0          	pop di
0117++ 10F8 E7          	pop d
0118++ 10F9 E8          	pop al
0119++ 10FA 09          	ret
0120++ 10FB             
0121++ 10FB             
0122++ 10FB             ; strcpy
0123++ 10FB             ; copy null terminated string from si to di
0124++ 10FB             ; source in si
0125++ 10FB             ; destination in di
0126++ 10FB             _strcpy:
0127++ 10FB E2          	push si
0128++ 10FC E3          	push di
0129++ 10FD DB          	push al
0130++ 10FE             _strcpy_l1:
0131++ 10FE F6          	lodsb
0132++ 10FF F7          	stosb
0133++ 1100 B9 00       	cmp al, 0
0134++ 1102 C7 FE 10    	jne _strcpy_l1
0135++ 1105             _strcpy_end:
0136++ 1105 E8          	pop al
0137++ 1106 F0          	pop di
0138++ 1107 EF          	pop si
0139++ 1108 09          	ret
0140++ 1109             
0141++ 1109             ; strcat
0142++ 1109             ; concatenate a null terminated string into string at di, from string at si
0143++ 1109             ; source in si
0144++ 1109             ; destination in di
0145++ 1109             _strcat:
0146++ 1109 E2          	push si
0147++ 110A E3          	push di
0148++ 110B D7          	push a
0149++ 110C DA          	push d
0150++ 110D 50          	mov a, di
0151++ 110E 3C          	mov d, a
0152++ 110F             _strcat_goto_end_l1:
0153++ 110F BD 00       	cmp byte[d], 0
0154++ 1111 C6 18 11    	je _strcat_start
0155++ 1114 79          	inc d
0156++ 1115 0A 0F 11    	jmp _strcat_goto_end_l1
0157++ 1118             _strcat_start:
0158++ 1118 FD 50       	mov di, d
0159++ 111A             _strcat_l1:
0160++ 111A F6          	lodsb
0161++ 111B F7          	stosb
0162++ 111C B9 00       	cmp al, 0
0163++ 111E C7 1A 11    	jne _strcat_l1
0164++ 1121             _strcat_end:
0165++ 1121 E7          	pop d
0166++ 1122 E4          	pop a
0167++ 1123 F0          	pop di
0168++ 1124 EF          	pop si
0169++ 1125 09          	ret
0170++ 1126             
0171++ 1126             
0005+  1126             
0006+  1126             
0007+  1126             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1126             ; convert ascii 'o'..'f' to integer 0..15
0009+  1126             ; ascii in bl
0010+  1126             ; result in al
0011+  1126             ; ascii for f = 0100 0110
0012+  1126             ; ascii for 9 = 0011 1001
0013+  1126             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1126             hex_ascii_encode:
0015+  1126 1B            mov al, bl
0016+  1127 93 40         test al, $40        ; test if letter or number
0017+  1129 C7 2F 11      jnz hex_letter
0018+  112C 87 0F         and al, $0f        ; get number
0019+  112E 09            ret
0020+  112F             hex_letter:
0021+  112F 87 0F         and al, $0f        ; get letter
0022+  1131 6A 09         add al, 9
0023+  1133 09            ret
0024+  1134             
0025+  1134             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1134             ; atoi
0027+  1134             ; 2 letter hex string in b
0028+  1134             ; 8bit integer returned in al
0029+  1134             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1134             _atoi:
0031+  1134 D8            push b
0032+  1135 07 26 11      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  1138 30            mov bl, bh
0034+  1139 DB            push al          ; save a
0035+  113A 07 26 11      call hex_ascii_encode
0036+  113D EA            pop bl  
0037+  113E FD 9E 04      shl al, 4
0038+  1141 8C            or al, bl
0039+  1142 E5            pop b
0040+  1143 09            ret  
0041+  1144             
0042+  1144             
0043+  1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1144             ; scanf
0045+  1144             ; no need for explanations!
0046+  1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1144             scanf:
0048+  1144 09            ret
0049+  1145             
0050+  1145             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1145             ; itoa
0052+  1145             ; 8bit value in bl
0053+  1145             ; 2 byte ascii result in a
0054+  1145             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1145             _itoa:
0056+  1145 DA            push d
0057+  1146 D8            push b
0058+  1147 A7 00         mov bh, 0
0059+  1149 FD A4 04      shr bl, 4  
0060+  114C 74            mov d, b
0061+  114D 1F DF 13      mov al, [d + s_hex_digits]
0062+  1150 23            mov ah, al
0063+  1151               
0064+  1151 E5            pop b
0065+  1152 D8            push b
0066+  1153 A7 00         mov bh, 0
0067+  1155 FD 87 0F      and bl, $0f
0068+  1158 74            mov d, b
0069+  1159 1F DF 13      mov al, [d + s_hex_digits]
0070+  115C E5            pop b
0071+  115D E7            pop d
0072+  115E 09            ret
0073+  115F             
0074+  115F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  115F             ; hex string to binary
0076+  115F             ; di = destination address
0077+  115F             ; si = source
0078+  115F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  115F             _hex_to_int:
0080+  115F             _hex_to_int_l1:
0081+  115F F6            lodsb          ; load from [si] to al
0082+  1160 B9 00         cmp al, 0        ; check if ascii 0
0083+  1162 C6 6F 11      jz _hex_to_int_ret
0084+  1165 36            mov bh, al
0085+  1166 F6            lodsb
0086+  1167 2F            mov bl, al
0087+  1168 07 34 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  116B F7            stosb          ; store al to [di]
0089+  116C 0A 5F 11      jmp _hex_to_int_l1
0090+  116F             _hex_to_int_ret:
0091+  116F 09            ret    
0092+  1170             
0093+  1170             
0094+  1170             
0095+  1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1170             ; getchar
0097+  1170             ; char in ah
0098+  1170             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1170             getch:
0100+  1170 DB            push al
0101+  1171             getch_retry:
0102+  1171 19 01         mov al, 1
0103+  1173 05 03         syscall sys_io      ; receive in ah
0104+  1175 E8            pop al
0105+  1176 09            ret
0106+  1177             
0107+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1177             ; putchar
0109+  1177             ; char in ah
0110+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1177             _putchar:
0112+  1177 DB            push al
0113+  1178 19 00         mov al, 0
0114+  117A 05 03         syscall sys_io      ; char in ah
0115+  117C E8            pop al
0116+  117D 09            ret
0117+  117E             
0118+  117E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  117E             ;; input a string
0120+  117E             ;; terminates with null
0121+  117E             ;; pointer in d
0122+  117E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  117E             _gets:
0124+  117E D7            push a
0125+  117F DA            push d
0126+  1180             _gets_loop:
0127+  1180 19 01         mov al, 1
0128+  1182 05 03         syscall sys_io      ; receive in ah
0129+  1184 76 1B         cmp ah, 27
0130+  1186 C6 A7 11      je _gets_ansi_esc
0131+  1189 76 0A         cmp ah, $0a        ; lf
0132+  118B C6 03 12      je _gets_end
0133+  118E 76 0D         cmp ah, $0d        ; cr
0134+  1190 C6 03 12      je _gets_end
0135+  1193 76 5C         cmp ah, $5c        ; '\\'
0136+  1195 C6 C9 11      je _gets_escape
0137+  1198 76 08         cmp ah, $08      ; check for backspace
0138+  119A C6 A3 11      je _gets_backspace
0139+  119D 1A            mov al, ah
0140+  119E 3E            mov [d], al
0141+  119F 79            inc d
0142+  11A0 0A 80 11      jmp _gets_loop
0143+  11A3             _gets_backspace:
0144+  11A3 7F            dec d
0145+  11A4 0A 80 11      jmp _gets_loop
0146+  11A7             _gets_ansi_esc:
0147+  11A7 19 01         mov al, 1
0148+  11A9 05 03         syscall sys_io        ; receive in ah without echo
0149+  11AB 76 5B         cmp ah, '['
0150+  11AD C7 80 11      jne _gets_loop
0151+  11B0 19 01         mov al, 1
0152+  11B2 05 03         syscall sys_io          ; receive in ah without echo
0153+  11B4 76 64         cmp ah, 'd'
0154+  11B6 C6 C1 11      je _gets_left_arrow
0155+  11B9 76 63         cmp ah, 'c'
0156+  11BB C6 C5 11      je _gets_right_arrow
0157+  11BE 0A 80 11      jmp _gets_loop
0158+  11C1             _gets_left_arrow:
0159+  11C1 7F            dec d
0160+  11C2 0A 80 11      jmp _gets_loop
0161+  11C5             _gets_right_arrow:
0162+  11C5 79            inc d
0163+  11C6 0A 80 11      jmp _gets_loop
0164+  11C9             _gets_escape:
0165+  11C9 19 01         mov al, 1
0166+  11CB 05 03         syscall sys_io      ; receive in ah
0167+  11CD 76 6E         cmp ah, 'n'
0168+  11CF C6 EE 11      je _gets_lf
0169+  11D2 76 72         cmp ah, 'r'
0170+  11D4 C6 F5 11      je _gets_cr
0171+  11D7 76 30         cmp ah, '0'
0172+  11D9 C6 FC 11      je _gets_null
0173+  11DC 76 5C         cmp ah, $5c  ; '\'
0174+  11DE C6 E7 11      je _gets_slash
0175+  11E1 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  11E2 3E            mov [d], al
0177+  11E3 79            inc d
0178+  11E4 0A 80 11      jmp _gets_loop
0179+  11E7             _gets_slash:
0180+  11E7 19 5C         mov al, $5c
0181+  11E9 3E            mov [d], al
0182+  11EA 79            inc d
0183+  11EB 0A 80 11      jmp _gets_loop
0184+  11EE             _gets_lf:
0185+  11EE 19 0A         mov al, $0a
0186+  11F0 3E            mov [d], al
0187+  11F1 79            inc d
0188+  11F2 0A 80 11      jmp _gets_loop
0189+  11F5             _gets_cr:
0190+  11F5 19 0D         mov al, $0d
0191+  11F7 3E            mov [d], al
0192+  11F8 79            inc d
0193+  11F9 0A 80 11      jmp _gets_loop
0194+  11FC             _gets_null:
0195+  11FC 19 00         mov al, $00
0196+  11FE 3E            mov [d], al
0197+  11FF 79            inc d
0198+  1200 0A 80 11      jmp _gets_loop
0199+  1203             _gets_end:
0200+  1203 19 00         mov al, 0
0201+  1205 3E            mov [d], al        ; terminate string
0202+  1206 E7            pop d
0203+  1207 E4            pop a
0204+  1208 09            ret
0205+  1209             
0206+  1209             
0207+  1209             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1209             ;; input text
0209+  1209             ;; terminated with ctrl+d
0210+  1209             ;; pointer in d
0211+  1209             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1209             _gettxt:
0213+  1209 D7            push a
0214+  120A DA            push d
0215+  120B             _gettxt_loop:
0216+  120B 19 01         mov al, 1
0217+  120D 05 03         syscall sys_io      ; receive in ah
0218+  120F 76 04         cmp ah, 4      ; eot
0219+  1211 C6 4A 12      je _gettxt_end
0220+  1214 76 08         cmp ah, $08      ; check for backspace
0221+  1216 C6 46 12      je _gettxt_backspace
0222+  1219 76 5C         cmp ah, $5c        ; '\'
0223+  121B C6 24 12      je _gettxt_escape
0224+  121E 1A            mov al, ah
0225+  121F 3E            mov [d], al
0226+  1220 79            inc d
0227+  1221 0A 0B 12      jmp _gettxt_loop
0228+  1224             _gettxt_escape:
0229+  1224 19 01         mov al, 1
0230+  1226 05 03         syscall sys_io      ; receive in ah
0231+  1228 76 6E         cmp ah, 'n'
0232+  122A C6 38 12      je _gettxt_lf
0233+  122D 76 72         cmp ah, 'r'
0234+  122F C6 3F 12      je _gettxt_cr
0235+  1232 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1233 3E            mov [d], al
0237+  1234 79            inc d
0238+  1235 0A 0B 12      jmp _gettxt_loop
0239+  1238             _gettxt_lf:
0240+  1238 19 0A         mov al, $0a
0241+  123A 3E            mov [d], al
0242+  123B 79            inc d
0243+  123C 0A 0B 12      jmp _gettxt_loop
0244+  123F             _gettxt_cr:
0245+  123F 19 0D         mov al, $0d
0246+  1241 3E            mov [d], al
0247+  1242 79            inc d
0248+  1243 0A 0B 12      jmp _gettxt_loop
0249+  1246             _gettxt_backspace:
0250+  1246 7F            dec d
0251+  1247 0A 0B 12      jmp _gettxt_loop
0252+  124A             _gettxt_end:
0253+  124A 19 00         mov al, 0
0254+  124C 3E            mov [d], al        ; terminate string
0255+  124D E7            pop d
0256+  124E E4            pop a
0257+  124F 09            ret
0258+  1250             
0259+  1250             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1250             ; print new line
0261+  1250             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1250             printnl:
0263+  1250 D7            push a
0264+  1251 10 00 0A      mov a, $0a00
0265+  1254 05 03         syscall sys_io
0266+  1256 10 00 0D      mov a, $0d00
0267+  1259 05 03         syscall sys_io
0268+  125B E4            pop a
0269+  125C 09            ret
0270+  125D             
0271+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  125D             ; _strtoint
0273+  125D             ; 4 digit hex string number in d
0274+  125D             ; integer returned in a
0275+  125D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  125D             _strtointx:
0277+  125D D8            push b
0278+  125E 32            mov bl, [d]
0279+  125F 37            mov bh, bl
0280+  1260 33 01 00      mov bl, [d + 1]
0281+  1263 07 34 11      call _atoi        ; convert to int in al
0282+  1266 23            mov ah, al        ; move to ah
0283+  1267 33 02 00      mov bl, [d + 2]
0284+  126A 37            mov bh, bl
0285+  126B 33 03 00      mov bl, [d + 3]
0286+  126E 07 34 11      call _atoi        ; convert to int in al
0287+  1271 E5            pop b
0288+  1272 09            ret
0289+  1273             
0290+  1273             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1273             ; _strtoint
0292+  1273             ; 5 digit base10 string number in d
0293+  1273             ; integer returned in a
0294+  1273             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1273             _strtoint:
0296+  1273 E2            push si
0297+  1274 D8            push b
0298+  1275 D9            push c
0299+  1276 DA            push d
0300+  1277 07 D6 10      call _strlen      ; get string length in c
0301+  127A 7E            dec c
0302+  127B FD 4E         mov si, d
0303+  127D 12            mov a, c
0304+  127E FD 99         shl a
0305+  1280 3B F7 13      mov d, table_power
0306+  1283 59            add d, a
0307+  1284 38 00 00      mov c, 0
0308+  1287             _strtoint_l0:
0309+  1287 F6            lodsb      ; load ascii to al
0310+  1288 B9 00         cmp al, 0
0311+  128A C6 9D 12      je _strtoint_end
0312+  128D 6F 30         sub al, $30    ; make into integer
0313+  128F 22 00         mov ah, 0
0314+  1291 2A            mov b, [d]
0315+  1292 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1293 11            mov a, b
0317+  1294 28            mov b, c
0318+  1295 54            add a, b
0319+  1296 39            mov c, a
0320+  1297 63 02 00      sub d, 2
0321+  129A 0A 87 12      jmp _strtoint_l0
0322+  129D             _strtoint_end:
0323+  129D 12            mov a, c
0324+  129E E7            pop d
0325+  129F E6            pop c
0326+  12A0 E5            pop b
0327+  12A1 EF            pop si
0328+  12A2 09            ret
0329+  12A3             
0330+  12A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  12A3             ; print null terminated string
0332+  12A3             ; pointer in d
0333+  12A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  12A3             _puts:
0335+  12A3 D7            push a
0336+  12A4 DA            push d
0337+  12A5             _puts_l1:
0338+  12A5 1E            mov al, [d]
0339+  12A6 B9 00         cmp al, 0
0340+  12A8 C6 B4 12      jz _puts_end
0341+  12AB 23            mov ah, al
0342+  12AC 19 00         mov al, 0
0343+  12AE 05 03         syscall sys_io
0344+  12B0 79            inc d
0345+  12B1 0A A5 12      jmp _puts_l1
0346+  12B4             _puts_end:
0347+  12B4 E7            pop d
0348+  12B5 E4            pop a
0349+  12B6 09            ret
0350+  12B7             
0351+  12B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12B7             ; print n size string
0353+  12B7             ; pointer in d
0354+  12B7             ; size in c
0355+  12B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12B7             _putsn:
0357+  12B7 DB            push al
0358+  12B8 DA            push d
0359+  12B9 D9            push c
0360+  12BA             _putsn_l0:
0361+  12BA 1E            mov al, [d]
0362+  12BB 23            mov ah, al
0363+  12BC 19 00         mov al, 0
0364+  12BE 05 03         syscall sys_io
0365+  12C0 79            inc d
0366+  12C1 7E            dec c  
0367+  12C2 C2 00 00      cmp c, 0
0368+  12C5 C7 BA 12      jne _putsn_l0
0369+  12C8             _putsn_end:
0370+  12C8 E6            pop c
0371+  12C9 E7            pop d
0372+  12CA E8            pop al
0373+  12CB 09            ret
0374+  12CC             
0375+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  12CC             ; print 16bit decimal number
0377+  12CC             ; input number in a
0378+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  12CC             print_u16d:
0380+  12CC D7            push a
0381+  12CD D8            push b
0382+  12CE FD D8         push g
0383+  12D0 26 10 27      mov b, 10000
0384+  12D3 AE            div a, b      ; get 10000's coeff.
0385+  12D4 07 F8 12      call print_number
0386+  12D7 11            mov a, b
0387+  12D8 26 E8 03      mov b, 1000
0388+  12DB AE            div a, b      ; get 1000's coeff.
0389+  12DC 07 F8 12      call print_number
0390+  12DF 11            mov a, b
0391+  12E0 26 64 00      mov b, 100
0392+  12E3 AE            div a, b
0393+  12E4 07 F8 12      call print_number
0394+  12E7 11            mov a, b
0395+  12E8 26 0A 00      mov b, 10
0396+  12EB AE            div a, b
0397+  12EC 07 F8 12      call print_number
0398+  12EF 1B            mov al, bl      ; 1's coeff in bl
0399+  12F0 07 F8 12      call print_number
0400+  12F3 FD F1         pop g
0401+  12F5 E5            pop b
0402+  12F6 E4            pop a
0403+  12F7 09            ret
0404+  12F8             
0405+  12F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12F8             ; print al
0407+  12F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12F8             print_number:
0409+  12F8 6A 30         add al, $30
0410+  12FA 23            mov ah, al
0411+  12FB 07 77 11      call _putchar
0412+  12FE 09            ret
0413+  12FF             
0414+  12FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12FF             ; print 16bit hex integer
0416+  12FF             ; integer value in reg b
0417+  12FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12FF             print_u16x:
0419+  12FF D7            push a
0420+  1300 D8            push b
0421+  1301 DD            push bl
0422+  1302 30            mov bl, bh
0423+  1303 07 45 11      call _itoa        ; convert bh to char in a
0424+  1306 2F            mov bl, al        ; save al
0425+  1307 19 00         mov al, 0
0426+  1309 05 03         syscall sys_io        ; display ah
0427+  130B 24            mov ah, bl        ; retrieve al
0428+  130C 19 00         mov al, 0
0429+  130E 05 03         syscall sys_io        ; display al
0430+  1310             
0431+  1310 EA            pop bl
0432+  1311 07 45 11      call _itoa        ; convert bh to char in a
0433+  1314 2F            mov bl, al        ; save al
0434+  1315 19 00         mov al, 0
0435+  1317 05 03         syscall sys_io        ; display ah
0436+  1319 24            mov ah, bl        ; retrieve al
0437+  131A 19 00         mov al, 0
0438+  131C 05 03         syscall sys_io        ; display al
0439+  131E             
0440+  131E E5            pop b
0441+  131F E4            pop a
0442+  1320 09            ret
0443+  1321             
0444+  1321             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1321             ; input 16bit hex integer
0446+  1321             ; read 16bit integer into a
0447+  1321             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1321             scan_u16x:
0449+  1321 F8 10 00      enter 16
0450+  1324 D8            push b
0451+  1325 DA            push d
0452+  1326             
0453+  1326 FA F1 FF      lea d, [bp + -15]
0454+  1329 07 7E 11      call _gets        ; get number
0455+  132C             
0456+  132C 32            mov bl, [d]
0457+  132D 37            mov bh, bl
0458+  132E 33 01 00      mov bl, [d + 1]
0459+  1331 07 34 11      call _atoi        ; convert to int in al
0460+  1334 23            mov ah, al        ; move to ah
0461+  1335             
0462+  1335 33 02 00      mov bl, [d + 2]
0463+  1338 37            mov bh, bl
0464+  1339 33 03 00      mov bl, [d + 3]
0465+  133C 07 34 11      call _atoi        ; convert to int in al
0466+  133F             
0467+  133F E7            pop d
0468+  1340 E5            pop b
0469+  1341 F9            leave
0470+  1342 09            ret
0471+  1343             
0472+  1343             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1343             ; print 8bit hex integer
0474+  1343             ; integer value in reg bl
0475+  1343             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1343             print_u8x:
0477+  1343 D7            push a
0478+  1344 DD            push bl
0479+  1345             
0480+  1345 07 45 11      call _itoa        ; convert bl to char in a
0481+  1348 2F            mov bl, al        ; save al
0482+  1349 19 00         mov al, 0
0483+  134B 05 03         syscall sys_io        ; display ah
0484+  134D 24            mov ah, bl        ; retrieve al
0485+  134E 19 00         mov al, 0
0486+  1350 05 03         syscall sys_io        ; display al
0487+  1352             
0488+  1352 EA            pop bl
0489+  1353 E4            pop a
0490+  1354 09            ret
0491+  1355             
0492+  1355             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1355             ; print 8bit decimal unsigned number
0494+  1355             ; input number in al
0495+  1355             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1355             print_u8d:
0497+  1355 D7            push a
0498+  1356 D8            push b
0499+  1357 FD D8         push g
0500+  1359 22 00         mov ah, 0
0501+  135B 26 64 00      mov b, 100
0502+  135E AE            div a, b
0503+  135F D8            push b      ; save remainder
0504+  1360 B9 00         cmp al, 0
0505+  1362 C6 6C 13      je skip100
0506+  1365 6A 30         add al, $30
0507+  1367 23            mov ah, al
0508+  1368 19 00         mov al, 0
0509+  136A 05 03         syscall sys_io  ; print coeff
0510+  136C             skip100:
0511+  136C E4            pop a
0512+  136D 22 00         mov ah, 0
0513+  136F 26 0A 00      mov b, 10
0514+  1372 AE            div a, b
0515+  1373 D8            push b      ; save remainder
0516+  1374 B9 00         cmp al, 0
0517+  1376 C6 80 13      je skip10
0518+  1379 6A 30         add al, $30
0519+  137B 23            mov ah, al
0520+  137C 19 00         mov al, 0
0521+  137E 05 03         syscall sys_io  ; print coeff
0522+  1380             skip10:
0523+  1380 E4            pop a
0524+  1381 1B            mov al, bl
0525+  1382 6A 30         add al, $30
0526+  1384 23            mov ah, al
0527+  1385 19 00         mov al, 0
0528+  1387 05 03         syscall sys_io  ; print coeff
0529+  1389 FD F1         pop g
0530+  138B E5            pop b
0531+  138C E4            pop a
0532+  138D 09            ret
0533+  138E             
0534+  138E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  138E             ; input 8bit hex integer
0536+  138E             ; read 8bit integer into al
0537+  138E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  138E             scan_u8x:
0539+  138E F8 04 00      enter 4
0540+  1391 D8            push b
0541+  1392 DA            push d
0542+  1393             
0543+  1393 FA FD FF      lea d, [bp + -3]
0544+  1396 07 7E 11      call _gets        ; get number
0545+  1399             
0546+  1399 32            mov bl, [d]
0547+  139A 37            mov bh, bl
0548+  139B 33 01 00      mov bl, [d + 1]
0549+  139E 07 34 11      call _atoi        ; convert to int in al
0550+  13A1             
0551+  13A1 E7            pop d
0552+  13A2 E5            pop b
0553+  13A3 F9            leave
0554+  13A4 09            ret
0555+  13A5             
0556+  13A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  13A5             ; input decimal number
0558+  13A5             ; result in a
0559+  13A5             ; 655'\0'
0560+  13A5             ; low--------high
0561+  13A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  13A5             scan_u16d:
0563+  13A5 F8 08 00      enter 8
0564+  13A8 E2            push si
0565+  13A9 D8            push b
0566+  13AA D9            push c
0567+  13AB DA            push d
0568+  13AC FA F9 FF      lea d, [bp +- 7]
0569+  13AF 07 7E 11      call _gets
0570+  13B2 07 D6 10      call _strlen      ; get string length in c
0571+  13B5 7E            dec c
0572+  13B6 FD 4E         mov si, d
0573+  13B8 12            mov a, c
0574+  13B9 FD 99         shl a
0575+  13BB 3B F7 13      mov d, table_power
0576+  13BE 59            add d, a
0577+  13BF 38 00 00      mov c, 0
0578+  13C2             mul_loop:
0579+  13C2 F6            lodsb      ; load ascii to al
0580+  13C3 B9 00         cmp al, 0
0581+  13C5 C6 D8 13      je mul_exit
0582+  13C8 6F 30         sub al, $30    ; make into integer
0583+  13CA 22 00         mov ah, 0
0584+  13CC 2A            mov b, [d]
0585+  13CD AC            mul a, b      ; result in b since it fits in 16bits
0586+  13CE 11            mov a, b
0587+  13CF 28            mov b, c
0588+  13D0 54            add a, b
0589+  13D1 39            mov c, a
0590+  13D2 63 02 00      sub d, 2
0591+  13D5 0A C2 13      jmp mul_loop
0592+  13D8             mul_exit:
0593+  13D8 12            mov a, c
0594+  13D9 E7            pop d
0595+  13DA E6            pop c
0596+  13DB E5            pop b
0597+  13DC EF            pop si
0598+  13DD F9            leave
0599+  13DE 09            ret
0600+  13DF             
0601+  13DF             
0602+  13DF 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  13E3 34 35 36 37 
0602+  13E7 38 39 61 62 
0602+  13EB 63 64 65 66 
0603+  13EF 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  13F3 1B 5B 68 00 
0604+  13F7             
0605+  13F7             table_power:
0606+  13F7 01 00         .dw 1
0607+  13F9 0A 00         .dw 10
0608+  13FB 64 00         .dw 100
0609+  13FD E8 03         .dw 1000
0610+  13FF 10 27         .dw 100002791   1401             .include "lib/ctype.asm"
0001+  1401             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1401             ; ctype.s
0003+  1401             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1401             
0005+  1401             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1401             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  1401             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  1401             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  1401             ;; characters are supported.
0010+  1401             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1401             ;; _isalnum 
0012+  1401             ;; _isalpha 
0013+  1401             ;; islower 
0014+  1401             ;; isupper 
0015+  1401             ;; _isdigit 
0016+  1401             ;; isxdigit
0017+  1401             ;; iscntrl 
0018+  1401             ;; isgraph 
0019+  1401             ;; _isspace 
0020+  1401             ;; isblank 
0021+  1401             ;; isprint 
0022+  1401             ;; ispunct 
0023+  1401             ;; tolower 
0024+  1401             ;; toupper
0025+  1401             
0026+  1401             
0027+  1401             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1401             ;; is alphanumeric
0029+  1401             ;; sets zf according with result
0030+  1401             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1401             _isalnum:
0032+  1401 07 1E 14    	call _isalpha
0033+  1404 C6 0A 14    	je _isalnum_exit
0034+  1407 07 0B 14    	call _isdigit
0035+  140A             _isalnum_exit:
0036+  140A 09          	ret	
0037+  140B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  140B             ;; is digit
0039+  140B             ;; sets zf according with result
0040+  140B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  140B             _isdigit:
0042+  140B DB          	push al
0043+  140C B9 30       	cmp al, '0'
0044+  140E C8 1A 14    	jlu _isdigit_false
0045+  1411 B9 39       	cmp al, '9'
0046+  1413 D1 1A 14    	jgu _isdigit_false
0047+  1416 87 00       	and al, 0	; set zf
0048+  1418 E8          	pop al
0049+  1419 09          	ret
0050+  141A             _isdigit_false:
0051+  141A 8B 01       	or al, 1	; clear zf
0052+  141C E8          	pop al
0053+  141D 09          	ret	
0054+  141E             	
0055+  141E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  141E             ;; is alpha
0057+  141E             ;; sets zf according with result
0058+  141E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  141E             _isalpha:
0060+  141E DB          	push al
0061+  141F B9 5F       	cmp al, '_'
0062+  1421 C6 41 14    	je _isalpha_true
0063+  1424 B9 2E       	cmp al, '.'
0064+  1426 C6 41 14    	je _isalpha_true
0065+  1429 B9 61       	cmp al, 'a'
0066+  142B C8 3D 14    	jlu _isalpha_false
0067+  142E B9 7A       	cmp al, 'z'
0068+  1430 D1 3D 14    	jgu _isalpha_false
0069+  1433 B9 7A       	cmp al, 'z'
0070+  1435 D0 41 14    	jleu _isalpha_true
0071+  1438 B9 61       	cmp al, 'a'
0072+  143A C9 41 14    	jgeu _isalpha_true
0073+  143D             _isalpha_false:
0074+  143D 8B 01       	or al, 1	; clear zf
0075+  143F E8          	pop al
0076+  1440 09          	ret
0077+  1441             _isalpha_true:
0078+  1441 87 00       	and al, 0	; set zf
0079+  1443 E8          	pop al
0080+  1444 09          	ret
0081+  1445             
0082+  1445             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1445             ;; is path-alpha
0084+  1445             ;; sets zf according with result
0085+  1445             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1445             ispath:
0087+  1445 DB          	push al
0088+  1446 07 0B 14    	call _isdigit
0089+  1449 C6 73 14    	je ispath_true
0090+  144C B9 5F       	cmp al, '_'
0091+  144E C6 73 14    	je ispath_true
0092+  1451 B9 2F       	cmp al, '/'
0093+  1453 C6 73 14    	je ispath_true
0094+  1456 B9 2E       	cmp al, '.'
0095+  1458 C6 73 14    	je ispath_true
0096+  145B B9 61       	cmp al, 'a'
0097+  145D C8 6F 14    	jlu ispath_false
0098+  1460 B9 7A       	cmp al, 'z'
0099+  1462 D1 6F 14    	jgu ispath_false
0100+  1465 B9 7A       	cmp al, 'z'
0101+  1467 D0 73 14    	jleu ispath_true
0102+  146A B9 61       	cmp al, 'a'
0103+  146C C9 73 14    	jgeu ispath_true
0104+  146F             ispath_false:
0105+  146F 8B 01       	or al, 1	; clear zf
0106+  1471 E8          	pop al
0107+  1472 09          	ret
0108+  1473             ispath_true:
0109+  1473 87 00       	and al, 0	; set zf
0110+  1475 E8          	pop al
0111+  1476 09          	ret
0112+  1477             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1477             ;; is space
0114+  1477             ;; sets zf according with result
0115+  1477             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1477             _isspace:
0117+  1477 B9 20       	cmp al, $20		; ' '
0118+  1479 C6 8D 14    	je _isspace_exit
0119+  147C B9 09       	cmp al, $09		; '\t'
0120+  147E C6 8D 14    	je _isspace_exit
0121+  1481 B9 0A       	cmp al, $0a		; '\n'
0122+  1483 C6 8D 14    	je _isspace_exit
0123+  1486 B9 0D       	cmp al, $0d		; '\r'
0124+  1488 C6 8D 14    	je _isspace_exit
0125+  148B B9 0B       	cmp al, $0b		; '\v'
0126+  148D             _isspace_exit:
0127+  148D 09          	ret	
0128+  148E             
0129+  148E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  148E             ; to lower
0131+  148E             ; input in al
0132+  148E             ; output in al
0133+  148E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  148E             _to_lower:
0135+  148E B9 7A       	cmp al, 'z'
0136+  1490 D1 95 14    	jgu _to_lower_ret
0137+  1493 6A 20       	add al, $20				; convert to lower case
0138+  1495             _to_lower_ret:
0139+  1495 09          	ret
0140+  1496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1496             ; to upper
0142+  1496             ; input in al
0143+  1496             ; output in al
0144+  1496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1496             _to_upper:
0146+  1496 B9 61       	cmp al, 'a'
0147+  1498 C8 9D 14    	jlu _to_upper_ret
0148+  149B 6F 20       	sub al, $20			; convert to upper case
0149+  149D             _to_upper_ret:
0150+  149D 09          	ret
0151+  149E             
2792   149E             .include "lib/token.asm"
0001+  149E             toktyp_identifier  .equ 0
0002+  149E             toktyp_keyword     .equ 1
0003+  149E             toktyp_delimiter   .equ 2
0004+  149E             toktyp_string      .equ 3
0005+  149E             toktyp_char        .equ 4
0006+  149E             toktyp_numeric     .equ 5
0007+  149E             toktyp_end         .equ 6
0008+  149E             
0009+  149E             tok_null           .equ 0
0010+  149E             tok_fslash         .equ 1
0011+  149E             tok_times          .equ 2
0012+  149E             tok_plus           .equ 3
0013+  149E             tok_minus          .equ 4
0014+  149E             tok_dot            .equ 5
0015+  149E             tok_semi           .equ 6
0016+  149E             tok_angle          .equ 7
0017+  149E             tok_tilde          .equ 8
0018+  149E             tok_equal          .equ 9
0019+  149E             tok_colon          .equ 10
0020+  149E             tok_comma          .equ 11
0021+  149E             
0022+  149E             tok_end            .equ 20
0023+  149E             
0024+  149E             
0025+  149E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  149E             ;; read a full command argment from shell input buffer
0027+  149E             ;; argument is written into tokstr
0028+  149E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  149E             get_arg:
0030+  149E D7            push a
0031+  149F E2            push si
0032+  14A0 E3            push di
0033+  14A1 19 00         mov al, 0
0034+  14A3 3D CC 16      mov [tokstr], al      ; nullify tokstr string
0035+  14A6 14 C8 16      mov a, [prog]
0036+  14A9 4D            mov si, a
0037+  14AA FD 4F CC 16   mov di, tokstr
0038+  14AE             get_arg_skip_spaces:
0039+  14AE F6            lodsb
0040+  14AF 07 77 14      call _isspace
0041+  14B2 C6 AE 14      je get_arg_skip_spaces
0042+  14B5             get_arg_l0:
0043+  14B5 B9 3B         cmp al, $3b        ; check if is ';'
0044+  14B7 C6 C4 14      je get_arg_end
0045+  14BA B9 00         cmp al, 0
0046+  14BC C6 C4 14      je get_arg_end      ; check if end of input
0047+  14BF F7            stosb
0048+  14C0 F6            lodsb
0049+  14C1 0A B5 14      jmp get_arg_l0
0050+  14C4             get_arg_end:
0051+  14C4 19 00         mov al, 0
0052+  14C6 F7            stosb
0053+  14C7 D5 01 00      sub si, 1
0054+  14CA 4E            mov a, si
0055+  14CB 42 C8 16      mov [prog], a    ; update pointer
0056+  14CE F0            pop di
0057+  14CF EF            pop si
0058+  14D0 E4            pop a
0059+  14D1 09            ret
0060+  14D2             
0061+  14D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  14D2             ;; read a path formation from shell input buffer
0063+  14D2             ;; path is written into tokstr
0064+  14D2             ;; /usr/bin
0065+  14D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  14D2             get_path:
0067+  14D2 D7            push a
0068+  14D3 E2            push si
0069+  14D4 E3            push di
0070+  14D5 19 00         mov al, 0
0071+  14D7 3D CC 16      mov [tokstr], al      ; nullify tokstr string
0072+  14DA 14 C8 16      mov a, [prog]
0073+  14DD 4D            mov si, a
0074+  14DE FD 4F CC 16   mov di, tokstr
0075+  14E2             get_path_skip_spaces:
0076+  14E2 F6            lodsb
0077+  14E3 07 77 14      call _isspace
0078+  14E6 C6 E2 14      je get_path_skip_spaces
0079+  14E9             get_path_is_pathchar:
0080+  14E9 F7            stosb
0081+  14EA F6            lodsb
0082+  14EB 07 01 14      call _isalnum      ;check if is alphanumeric
0083+  14EE C6 E9 14      je get_path_is_pathchar
0084+  14F1 B9 2F         cmp al, '/'        ; check if is '/'
0085+  14F3 C6 E9 14      je get_path_is_pathchar
0086+  14F6 19 00         mov al, 0
0087+  14F8 F7            stosb
0088+  14F9 D5 01 00      sub si, 1
0089+  14FC 4E            mov a, si
0090+  14FD 42 C8 16      mov [prog], a    ; update pointer
0091+  1500             get_path_end:
0092+  1500 F0            pop di
0093+  1501 EF            pop si
0094+  1502 E4            pop a
0095+  1503 09            ret
0096+  1504             
0097+  1504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1504             ;; read a line
0099+  1504             ;; line is written into tokstr
0100+  1504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1504             get_line:
0102+  1504 D7            push a
0103+  1505 E2            push si
0104+  1506 E3            push di
0105+  1507 19 00         mov al, 0
0106+  1509 3D CC 16      mov [tokstr], al      ; nullify tokstr string
0107+  150C 14 C8 16      mov a, [prog]
0108+  150F 4D            mov si, a
0109+  1510 FD 4F CC 16   mov di, tokstr
0110+  1514             get_line_l0:
0111+  1514 F6            lodsb
0112+  1515 B9 0A         cmp al, $0a    ; check for new line
0113+  1517 C6 1E 15      je get_line_exit
0114+  151A F7            stosb
0115+  151B 0A 14 15      jmp get_line_l0
0116+  151E             get_line_exit:
0117+  151E 19 00         mov al, 0
0118+  1520 F7            stosb
0119+  1521 4E            mov a, si
0120+  1522 42 C8 16      mov [prog], a    ; update pointer
0121+  1525 F0            pop di
0122+  1526 EF            pop si
0123+  1527 E4            pop a
0124+  1528 09            ret
0125+  1529             
0126+  1529             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1529             ;; token parser
0128+  1529             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1529             get_token:
0130+  1529 D7            push a
0131+  152A DA            push d
0132+  152B E2            push si
0133+  152C E3            push di
0134+  152D 19 00         mov al, 0
0135+  152F 3D CC 16      mov [tokstr], al      ; nullify tokstr string
0136+  1532 19 00         mov al, tok_null
0137+  1534 3D CB 16      mov [tok], al        ; nullify token
0138+  1537 14 C8 16      mov a, [prog]
0139+  153A 4D            mov si, a
0140+  153B FD 4F CC 16   mov di, tokstr
0141+  153F             get_tok_skip_spaces:
0142+  153F F6            lodsb
0143+  1540 07 77 14      call _isspace
0144+  1543 C6 3F 15      je get_tok_skip_spaces
0145+  1546 B9 00         cmp al, 0      ; check for end of input (null)
0146+  1548 C6 2D 16      je get_token_end
0147+  154B B9 23         cmp al, '#'      ; comments!
0148+  154D C6 5B 16      je get_tok_comment
0149+  1550 07 01 14      call _isalnum
0150+  1553 C6 3A 16      jz is_alphanumeric
0151+  1556             ; other token types
0152+  1556             get_token_slash:
0153+  1556 B9 2F         cmp al, '/'        ; check if '/'
0154+  1558 C7 70 15      jne get_token_minus
0155+  155B F7            stosb          ; store '/' into token string
0156+  155C 19 00         mov al, 0
0157+  155E F7            stosb          ; terminate token string
0158+  155F 19 01         mov al, tok_fslash
0159+  1561 3D CB 16      mov [tok], al      
0160+  1564 19 02         mov al, toktyp_delimiter
0161+  1566 3D CA 16      mov [toktyp], al
0162+  1569 4E            mov a, si
0163+  156A 42 C8 16      mov [prog], a    ; update pointer
0164+  156D 0A 56 16      jmp get_token_return
0165+  1570             get_token_minus:
0166+  1570 B9 2D         cmp al, '-'        ; check if '-'
0167+  1572 C7 8A 15      jne get_token_comma
0168+  1575 F7            stosb          ; store '-' into token string
0169+  1576 19 00         mov al, 0
0170+  1578 F7            stosb          ; terminate token string
0171+  1579 19 04         mov al, tok_minus
0172+  157B 3D CB 16      mov [tok], al      
0173+  157E 19 02         mov al, toktyp_delimiter
0174+  1580 3D CA 16      mov [toktyp], al
0175+  1583 4E            mov a, si
0176+  1584 42 C8 16      mov [prog], a    ; update pointer
0177+  1587 0A 56 16      jmp get_token_return
0178+  158A             get_token_comma:
0179+  158A B9 2C         cmp al, ','        ; check if ','
0180+  158C C7 A4 15      jne get_token_semi
0181+  158F F7            stosb          ; store ',' into token string
0182+  1590 19 00         mov al, 0
0183+  1592 F7            stosb          ; terminate token string
0184+  1593 19 0B         mov al, tok_comma
0185+  1595 3D CB 16      mov [tok], al      
0186+  1598 19 02         mov al, toktyp_delimiter
0187+  159A 3D CA 16      mov [toktyp], al
0188+  159D 4E            mov a, si
0189+  159E 42 C8 16      mov [prog], a    ; update pointer
0190+  15A1 0A 56 16      jmp get_token_return
0191+  15A4             get_token_semi:
0192+  15A4 B9 3B         cmp al, $3b        ; check if ';'
0193+  15A6 C7 BE 15      jne get_token_colon
0194+  15A9 F7            stosb          ; store ';' into token string
0195+  15AA 19 00         mov al, 0
0196+  15AC F7            stosb          ; terminate token string
0197+  15AD 19 06         mov al, tok_semi
0198+  15AF 3D CB 16      mov [tok], al      
0199+  15B2 19 02         mov al, toktyp_delimiter
0200+  15B4 3D CA 16      mov [toktyp], al
0201+  15B7 4E            mov a, si
0202+  15B8 42 C8 16      mov [prog], a    ; update pointer
0203+  15BB 0A 56 16      jmp get_token_return
0204+  15BE             get_token_colon:
0205+  15BE B9 3A         cmp al, $3a        ; check if ':'
0206+  15C0 C7 D8 15      jne get_token_angle
0207+  15C3 F7            stosb          ; store ':' into token string
0208+  15C4 19 00         mov al, 0
0209+  15C6 F7            stosb          ; terminate token string
0210+  15C7 19 0A         mov al, tok_colon
0211+  15C9 3D CB 16      mov [tok], al      
0212+  15CC 19 02         mov al, toktyp_delimiter
0213+  15CE 3D CA 16      mov [toktyp], al
0214+  15D1 4E            mov a, si
0215+  15D2 42 C8 16      mov [prog], a    ; update pointer
0216+  15D5 0A 56 16      jmp get_token_return
0217+  15D8             get_token_angle:
0218+  15D8 B9 3E         cmp al, $3e        ; check if '>'
0219+  15DA C7 F2 15      jne get_token_tilde
0220+  15DD F7            stosb          ; store '>' into token string
0221+  15DE 19 00         mov al, 0
0222+  15E0 F7            stosb          ; terminate token string
0223+  15E1 19 07         mov al, tok_angle
0224+  15E3 3D CB 16      mov [tok], al      
0225+  15E6 19 02         mov al, toktyp_delimiter
0226+  15E8 3D CA 16      mov [toktyp], al
0227+  15EB 4E            mov a, si
0228+  15EC 42 C8 16      mov [prog], a    ; update pointer
0229+  15EF 0A 56 16      jmp get_token_return
0230+  15F2             get_token_tilde:
0231+  15F2 B9 7E         cmp al, '~'        ; check if '~'
0232+  15F4 C7 0C 16      jne get_token_equal
0233+  15F7 F7            stosb          ; store '~' into token string
0234+  15F8 19 00         mov al, 0
0235+  15FA F7            stosb          ; terminate token string
0236+  15FB 19 08         mov al, tok_tilde
0237+  15FD 3D CB 16      mov [tok], al      
0238+  1600 19 02         mov al, toktyp_delimiter
0239+  1602 3D CA 16      mov [toktyp], al
0240+  1605 4E            mov a, si
0241+  1606 42 C8 16      mov [prog], a    ; update pointer
0242+  1609 0A 56 16      jmp get_token_return
0243+  160C             get_token_equal:
0244+  160C B9 3D         cmp al, '='        ; check if '='
0245+  160E C7 26 16      jne get_token_skip
0246+  1611 F7            stosb          ; store '=' into token string
0247+  1612 19 00         mov al, 0
0248+  1614 F7            stosb          ; terminate token string
0249+  1615 19 09         mov al, tok_equal
0250+  1617 3D CB 16      mov [tok], al      
0251+  161A 19 02         mov al, toktyp_delimiter
0252+  161C 3D CA 16      mov [toktyp], al
0253+  161F 4E            mov a, si
0254+  1620 42 C8 16      mov [prog], a    ; update pointer
0255+  1623 0A 56 16      jmp get_token_return
0256+  1626             get_token_skip:
0257+  1626 4E            mov a, si
0258+  1627 42 C8 16      mov [prog], a    ; update pointer
0259+  162A 0A 56 16      jmp get_token_return
0260+  162D             get_token_end:        ; end of file token
0261+  162D 19 14         mov al, tok_end
0262+  162F 3D CB 16      mov [tok], al
0263+  1632 19 06         mov al, toktyp_end
0264+  1634 3D CA 16      mov [toktyp], al
0265+  1637 0A 56 16      jmp get_token_return
0266+  163A             is_alphanumeric:
0267+  163A F7            stosb
0268+  163B F6            lodsb
0269+  163C 07 01 14      call _isalnum      ;check if is alphanumeric
0270+  163F C6 3A 16      jz is_alphanumeric
0271+  1642 B9 2E         cmp al, $2e        ; check if is '.'
0272+  1644 C6 3A 16      je is_alphanumeric
0273+  1647 19 00         mov al, 0
0274+  1649 F7            stosb
0275+  164A 19 00         mov al, toktyp_identifier
0276+  164C 3D CA 16      mov [toktyp], al
0277+  164F D5 01 00      sub si, 1
0278+  1652 4E            mov a, si
0279+  1653 42 C8 16      mov [prog], a    ; update pointer
0280+  1656             get_token_return:
0281+  1656 F0            pop di
0282+  1657 EF            pop si
0283+  1658 E7            pop d
0284+  1659 E4            pop a
0285+  165A 09            ret
0286+  165B             get_tok_comment:
0287+  165B F6            lodsb
0288+  165C B9 0A         cmp al, $0a      ; new line
0289+  165E C7 5B 16      jne get_tok_comment
0290+  1661 0A 3F 15      jmp get_tok_skip_spaces
0291+  1664             
0292+  1664             
0293+  1664             get_number:
0294+  1664 D7            push a
0295+  1665 DA            push d
0296+  1666 E2            push si
0297+  1667 E3            push di
0298+  1668 19 00         mov al, 0
0299+  166A 3D CC 16      mov [tokstr], al      ; nullify tokstr string
0300+  166D 19 00         mov al, tok_null
0301+  166F 3D CB 16      mov [tok], al        ; nullify token
0302+  1672 14 C8 16      mov a, [prog]
0303+  1675 4D            mov si, a
0304+  1676 FD 4F CC 16   mov di, tokstr
0305+  167A             get_number_skip_spaces:
0306+  167A F6            lodsb
0307+  167B 07 77 14      call _isspace
0308+  167E C6 7A 16      je get_number_skip_spaces
0309+  1681 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1683 C7 93 16      jne get_number_l0
0311+  1686 19 14         mov al, tok_end
0312+  1688 3D CB 16      mov [tok], al
0313+  168B 19 06         mov al, toktyp_end
0314+  168D 3D CA 16      mov [toktyp], al
0315+  1690 0A AA 16      jmp get_number_return
0316+  1693             get_number_l0:
0317+  1693 F7            stosb
0318+  1694 F6            lodsb
0319+  1695 07 0B 14      call _isdigit      ;check if is numeric
0320+  1698 C6 93 16      jz get_number_l0
0321+  169B 19 00         mov al, 0
0322+  169D F7            stosb
0323+  169E 19 05         mov al, toktyp_numeric
0324+  16A0 3D CA 16      mov [toktyp], al
0325+  16A3 D5 01 00      sub si, 1
0326+  16A6 4E            mov a, si
0327+  16A7 42 C8 16      mov [prog], a    ; update pointer
0328+  16AA             get_number_return:
0329+  16AA F0            pop di
0330+  16AB EF            pop si
0331+  16AC E7            pop d
0332+  16AD E4            pop a
0333+  16AE 09            ret
0334+  16AF             
0335+  16AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  16AF             ;; put back token
0337+  16AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  16AF             _putback:
0339+  16AF D7            push a
0340+  16B0 E2            push si
0341+  16B1 FD 4D CC 16   mov si, tokstr  
0342+  16B5             _putback_loop:
0343+  16B5 F6            lodsb
0344+  16B6 B9 00         cmp al, 0
0345+  16B8 C6 C5 16      je _putback_end
0346+  16BB 14 C8 16      mov a, [prog]
0347+  16BE 7D            dec a
0348+  16BF 42 C8 16      mov [prog], a      ; update pointer
0349+  16C2 0A B5 16      jmp _putback_loop
0350+  16C5             _putback_end:
0351+  16C5 EF            pop si
0352+  16C6 E4            pop a
0353+  16C7 09            ret
0354+  16C8             
0355+  16C8             
0356+  16C8             
0357+  16C8             
0358+  16C8 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  16CA             
0360+  16CA 00          toktyp:    .db 0          ; token type symbol
0361+  16CB 00          tok:       .db 0          ; current token symbol
0362+  16CC 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  16D0 00 00 00 00 
0362+  16D4 00 00 00 00 
0362+  16D8 00 00 00 00 
0362+  16DC 00 00 00 00 
0362+  16E0 00 00 00 00 
0362+  16E4 00 00 00 00 
0362+  16E8 00 00 00 00 
0362+  16EC 00 00 00 00 
0362+  16F0 00 00 00 00 
0362+  16F4 00 00 00 00 
0362+  16F8 00 00 00 00 
0362+  16FC 00 00 00 00 
0362+  1700 00 00 00 00 
0362+  1704 00 00 00 00 
0362+  1708 00 00 00 00 
0362+  170C 00 00 00 00 
0362+  1710 00 00 00 00 
0362+  1714 00 00 00 00 
0362+  1718 00 00 00 00 
0362+  171C 00 00 00 00 
0362+  1720 00 00 00 00 
0362+  1724 00 00 00 00 
0362+  1728 00 00 00 00 
0362+  172C 00 00 00 00 
0362+  1730 00 00 00 00 
0362+  1734 00 00 00 00 
0362+  1738 00 00 00 00 
0362+  173C 00 00 00 00 
0362+  1740 00 00 00 00 
0362+  1744 00 00 00 00 
0362+  1748 00 00 00 00 
0362+  174C 00 00 00 00 
0362+  1750 00 00 00 00 
0362+  1754 00 00 00 00 
0362+  1758 00 00 00 00 
0362+  175C 00 00 00 00 
0362+  1760 00 00 00 00 
0362+  1764 00 00 00 00 
0362+  1768 00 00 00 00 
0362+  176C 00 00 00 00 
0362+  1770 00 00 00 00 
0362+  1774 00 00 00 00 
0362+  1778 00 00 00 00 
0362+  177C 00 00 00 00 
0362+  1780 00 00 00 00 
0362+  1784 00 00 00 00 
0362+  1788 00 00 00 00 
0362+  178C 00 00 00 00 
0362+  1790 00 00 00 00 
0362+  1794 00 00 00 00 
0362+  1798 00 00 00 00 
0362+  179C 00 00 00 00 
0362+  17A0 00 00 00 00 
0362+  17A4 00 00 00 00 
0362+  17A8 00 00 00 00 
0362+  17AC 00 00 00 00 
0362+  17B0 00 00 00 00 
0362+  17B4 00 00 00 00 
0362+  17B8 00 00 00 00 
0362+  17BC 00 00 00 00 
0362+  17C0 00 00 00 00 
0362+  17C4 00 00 00 00 
0362+  17C8 00 00 00 00 
2793   17CC             
2794   17CC             ; kernel parameters
2795   17CC             sys_debug_mode:
2796   17CC 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2797   17CD             sys_echo_on:
2798   17CD 01            .db 1
2799   17CE             sys_uart0_lcr:
2800   17CE 07            .db $07 ; 8 data bits, 2 stop bit, no parity
2801   17CF             sys_uart0_inten:
2802   17CF 01            .db 1
2803   17D0             sys_uart0_fifoen:
2804   17D0 00            .db 0
2805   17D1             sys_uart0_div0:
2806   17D1 0C            .db 12  ;
2807   17D2             sys_uart0_div1:
2808   17D2 00            .db 0   ; default baud = 9600
2809   17D3             ; baud  divisor
2810   17D3             ; 50    2304
2811   17D3             ; 110   1047
2812   17D3             ; 300    384
2813   17D3             ; 600    192
2814   17D3             ; 1200    96
2815   17D3             ; 9600    12
2816   17D3             ; 19200    6
2817   17D3             ; 38400    3
2818   17D3             
2819   17D3             nbr_active_procs:
2820   17D3 00            .db 0
2821   17D4             active_proc_index:
2822   17D4 01            .db 1
2823   17D5             
2824   17D5             index:
2825   17D5 00 00         .dw 0
2826   17D7             buffer_addr:
2827   17D7 00 00         .dw 0
2828   17D9             
2829   17D9             fifo_in:
2830   17D9 3A 1F         .dw fifo
2831   17DB             fifo_out:
2832   17DB 3A 1F         .dw fifo
2833   17DD             
2834   17DD             ; file system variables
2835   17DD             current_dir_id:
2836   17DD 00 00         .dw 0     ; keep dirid of current directory
2837   17DF             s_init_path:
2838   17DF 2F 73 62 69   .db "/sbin/init", 0
2838   17E3 6E 2F 69 6E 
2838   17E7 69 74 00 
2839   17EA             
2840   17EA             s_uname:
2841   17EA 73 6F 6C 61   .db "solarium v.1.0", 0
2841   17EE 72 69 75 6D 
2841   17F2 20 76 2E 31 
2841   17F6 2E 30 00 
2842   17F9             s_dataentry:
2843   17F9 3E 20 00      .db "> ", 0
2844   17FC             s_parent_dir:
2845   17FC 2E 2E 00      .db "..", 0
2846   17FF             s_current_dir:
2847   17FF 2E 00         .db ".", 0
2848   1801             s_fslash:
2849   1801 2F 00         .db "/", 0
2850   1803             file_attrib:
2851   1803 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2851   1807 78 
2852   1808             file_type:
2853   1808 2D 64 63      .db "-dc"
2854   180B             s_ps_header:
2855   180B 70 69 64 20   .db "pid command\n", 0
2855   180F 63 6F 6D 6D 
2855   1813 61 6E 64 0A 
2855   1817 00 
2856   1818             s_ls_total:
2857   1818 74 6F 74 61   .db "total: ", 0
2857   181C 6C 3A 20 00 
2858   1820             
2859   1820             s_int_en:
2860   1820 69 72 71 73   .db "irqs enabled\n", 0
2860   1824 20 65 6E 61 
2860   1828 62 6C 65 64 
2860   182C 0A 00 
2861   182E             s_kernel_started:
2862   182E 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2862   1832 65 6C 20 73 
2862   1836 74 61 72 74 
2862   183A 65 64 28 76 
2862   183E 65 72 73 69 
2862   1842 6F 6E 20 31 
2862   1846 2E 30 29 0A 
2862   184A 00 
2863   184B             s_prompt_init:
2864   184B 73 74 61 72   .db "starting init\n", 0
2864   184F 74 69 6E 67 
2864   1853 20 69 6E 69 
2864   1857 74 0A 00 
2865   185A             s_priviledge:
2866   185A 0A 65 78 63   .db "\nexception: privilege\n", 0
2866   185E 65 70 74 69 
2866   1862 6F 6E 3A 20 
2866   1866 70 72 69 76 
2866   186A 69 6C 65 67 
2866   186E 65 0A 00 
2867   1871             s_divzero:
2868   1871 0A 65 78 63   .db "\nexception: zero division\n", 0
2868   1875 65 70 74 69 
2868   1879 6F 6E 3A 20 
2868   187D 7A 65 72 6F 
2868   1881 20 64 69 76 
2868   1885 69 73 69 6F 
2868   1889 6E 0A 00 
2869   188C             
2870   188C             s_set_year:
2871   188C 79 65 61 72   .db "year: ", 0
2871   1890 3A 20 00 
2872   1893             s_set_month:
2873   1893 6D 6F 6E 74   .db "month: ", 0
2873   1897 68 3A 20 00 
2874   189B             s_set_day:
2875   189B 64 61 79 3A   .db "day: ", 0
2875   189F 20 00 
2876   18A1             s_set_week:
2877   18A1 77 65 65 6B   .db "weekday: ", 0
2877   18A5 64 61 79 3A 
2877   18A9 20 00 
2878   18AB             s_set_hours:
2879   18AB 68 6F 75 72   .db "hours: ", 0
2879   18AF 73 3A 20 00 
2880   18B3             s_set_minutes:
2881   18B3 6D 69 6E 75   .db "minutes: ", 0
2881   18B7 74 65 73 3A 
2881   18BB 20 00 
2882   18BD             s_set_seconds:
2883   18BD 73 65 63 6F   .db "seconds: ", 0
2883   18C1 6E 64 73 3A 
2883   18C5 20 00 
2884   18C7             s_months:      
2885   18C7 20 20 20 00   .db "   ", 0
2886   18CB 6A 61 6E 00   .db "jan", 0
2887   18CF 66 65 62 00   .db "feb", 0
2888   18D3 6D 61 72 00   .db "mar", 0
2889   18D7 61 70 72 00   .db "apr", 0
2890   18DB 6D 61 79 00   .db "may", 0
2891   18DF 6A 75 6E 00   .db "jun", 0
2892   18E3 6A 75 6C 00   .db "jul", 0
2893   18E7 61 75 67 00   .db "aug", 0
2894   18EB 73 65 70 00   .db "sep", 0
2895   18EF 6F 63 74 00   .db "oct", 0
2896   18F3 6E 6F 76 00   .db "nov", 0
2897   18F7 64 65 63 00   .db "dec", 0
2898   18FB             
2899   18FB             s_week:        
2900   18FB 73 75 6E 00   .db "sun", 0 
2901   18FF 6D 6F 6E 00   .db "mon", 0 
2902   1903 74 75 65 00   .db "tue", 0 
2903   1907 77 65 64 00   .db "wed", 0 
2904   190B 74 68 75 00   .db "thu", 0 
2905   190F 66 72 69 00   .db "fri", 0 
2906   1913 73 61 74 00   .db "sat", 0
2907   1917             
2908   1917 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2908   191B 30 20 45 78 
2908   191F 65 63 75 74 
2908   1923 65 64 2E 0A 
2908   1927 00 
2909   1928             s_fdc_config:
2910   1928 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2910   192C 65 63 74 69 
2910   1930 6E 67 20 64 
2910   1934 69 73 6B 65 
2910   1938 74 74 65 20 
2910   193C 64 72 69 76 
2910   1940 65 20 30 2C 
2910   1944 20 73 69 64 
2910   1948 65 20 30 2C 
2910   194C 20 73 69 6E 
2910   1950 67 6C 65 20 
2910   1954 64 65 6E 73 
2910   1958 69 74 79 2C 
2910   195C 20 68 65 61 
2910   1960 64 20 6C 6F 
2910   1964 61 64 65 64 
2910   1968 0A 00 
2911   196A             
2912   196A             proc_state_table:   
2913   196A 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2913   196E 00 00 00 00 
2913   1972 00 00 00 00 
2913   1976 00 00 00 00 
2913   197A 00 00 00 00 
2913   197E 00 00 00 00 
2913   1982 00 00 00 00 
2913   1986 00 00 00 00 
2913   198A 00 00 00 00 
2913   198E 00 00 00 00 
2913   1992 00 00 00 00 
2913   1996 00 00 00 00 
2913   199A 00 00 00 00 
2913   199E 00 00 00 00 
2913   19A2 00 00 00 00 
2913   19A6 00 00 00 00 
2913   19AA 00 00 00 00 
2913   19AE 00 00 00 00 
2913   19B2 00 00 00 00 
2913   19B6 00 00 00 00 
2913   19BA 00 00 00 00 
2913   19BE 00 00 00 00 
2913   19C2 00 00 00 00 
2913   19C6 00 00 00 00 
2913   19CA 00 00 00 00 
2913   19CE 00 00 00 00 
2913   19D2 00 00 00 00 
2913   19D6 00 00 00 00 
2913   19DA 00 00 00 00 
2913   19DE 00 00 00 00 
2913   19E2 00 00 00 00 
2913   19E6 00 00 00 00 
2913   19EA 00 00 00 00 
2913   19EE 00 00 00 00 
2913   19F2 00 00 00 00 
2913   19F6 00 00 00 00 
2913   19FA 00 00 00 00 
2913   19FE 00 00 00 00 
2913   1A02 00 00 00 00 
2913   1A06 00 00 00 00 
2913   1A0A 00 00 00 00 
2913   1A0E 00 00 00 00 
2913   1A12 00 00 00 00 
2913   1A16 00 00 00 00 
2913   1A1A 00 00 00 00 
2913   1A1E 00 00 00 00 
2913   1A22 00 00 00 00 
2913   1A26 00 00 00 00 
2913   1A2A 00 00 00 00 
2913   1A2E 00 00 00 00 
2913   1A32 00 00 00 00 
2913   1A36 00 00 00 00 
2913   1A3A 00 00 00 00 
2913   1A3E 00 00 00 00 
2913   1A42 00 00 00 00 
2913   1A46 00 00 00 00 
2913   1A4A 00 00 00 00 
2913   1A4E 00 00 00 00 
2913   1A52 00 00 00 00 
2913   1A56 00 00 00 00 
2913   1A5A 00 00 00 00 
2913   1A5E 00 00 00 00 
2913   1A62 00 00 00 00 
2913   1A66 00 00 00 00 
2913   1A6A 00 00 00 00 
2913   1A6E 00 00 00 00 
2913   1A72 00 00 00 00 
2913   1A76 00 00 00 00 
2913   1A7A 00 00 00 00 
2913   1A7E 00 00 00 00 
2913   1A82 00 00 00 00 
2913   1A86 00 00 00 00 
2913   1A8A 00 00 00 00 
2913   1A8E 00 00 00 00 
2913   1A92 00 00 00 00 
2913   1A96 00 00 00 00 
2913   1A9A 00 00 00 00 
2913   1A9E 00 00 00 00 
2913   1AA2 00 00 00 00 
2913   1AA6 00 00 00 00 
2914   1AAA             proc_availab_table: 
2915   1AAA 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2915   1AAE 00 00 00 00 
2915   1AB2 00 00 00 00 
2915   1AB6 00 00 00 00 
2916   1ABA             proc_names:
2917   1ABA 00 00 00 00   .fill 16 * 32, 0  ; process names
2917   1ABE 00 00 00 00 
2917   1AC2 00 00 00 00 
2917   1AC6 00 00 00 00 
2917   1ACA 00 00 00 00 
2917   1ACE 00 00 00 00 
2917   1AD2 00 00 00 00 
2917   1AD6 00 00 00 00 
2917   1ADA 00 00 00 00 
2917   1ADE 00 00 00 00 
2917   1AE2 00 00 00 00 
2917   1AE6 00 00 00 00 
2917   1AEA 00 00 00 00 
2917   1AEE 00 00 00 00 
2917   1AF2 00 00 00 00 
2917   1AF6 00 00 00 00 
2917   1AFA 00 00 00 00 
2917   1AFE 00 00 00 00 
2917   1B02 00 00 00 00 
2917   1B06 00 00 00 00 
2917   1B0A 00 00 00 00 
2917   1B0E 00 00 00 00 
2917   1B12 00 00 00 00 
2917   1B16 00 00 00 00 
2917   1B1A 00 00 00 00 
2917   1B1E 00 00 00 00 
2917   1B22 00 00 00 00 
2917   1B26 00 00 00 00 
2917   1B2A 00 00 00 00 
2917   1B2E 00 00 00 00 
2917   1B32 00 00 00 00 
2917   1B36 00 00 00 00 
2917   1B3A 00 00 00 00 
2917   1B3E 00 00 00 00 
2917   1B42 00 00 00 00 
2917   1B46 00 00 00 00 
2917   1B4A 00 00 00 00 
2917   1B4E 00 00 00 00 
2917   1B52 00 00 00 00 
2917   1B56 00 00 00 00 
2917   1B5A 00 00 00 00 
2917   1B5E 00 00 00 00 
2917   1B62 00 00 00 00 
2917   1B66 00 00 00 00 
2917   1B6A 00 00 00 00 
2917   1B6E 00 00 00 00 
2917   1B72 00 00 00 00 
2917   1B76 00 00 00 00 
2917   1B7A 00 00 00 00 
2917   1B7E 00 00 00 00 
2917   1B82 00 00 00 00 
2917   1B86 00 00 00 00 
2917   1B8A 00 00 00 00 
2917   1B8E 00 00 00 00 
2917   1B92 00 00 00 00 
2917   1B96 00 00 00 00 
2917   1B9A 00 00 00 00 
2917   1B9E 00 00 00 00 
2917   1BA2 00 00 00 00 
2917   1BA6 00 00 00 00 
2917   1BAA 00 00 00 00 
2917   1BAE 00 00 00 00 
2917   1BB2 00 00 00 00 
2917   1BB6 00 00 00 00 
2917   1BBA 00 00 00 00 
2917   1BBE 00 00 00 00 
2917   1BC2 00 00 00 00 
2917   1BC6 00 00 00 00 
2917   1BCA 00 00 00 00 
2917   1BCE 00 00 00 00 
2917   1BD2 00 00 00 00 
2917   1BD6 00 00 00 00 
2917   1BDA 00 00 00 00 
2917   1BDE 00 00 00 00 
2917   1BE2 00 00 00 00 
2917   1BE6 00 00 00 00 
2917   1BEA 00 00 00 00 
2917   1BEE 00 00 00 00 
2917   1BF2 00 00 00 00 
2917   1BF6 00 00 00 00 
2917   1BFA 00 00 00 00 
2917   1BFE 00 00 00 00 
2917   1C02 00 00 00 00 
2917   1C06 00 00 00 00 
2917   1C0A 00 00 00 00 
2917   1C0E 00 00 00 00 
2917   1C12 00 00 00 00 
2917   1C16 00 00 00 00 
2917   1C1A 00 00 00 00 
2917   1C1E 00 00 00 00 
2917   1C22 00 00 00 00 
2917   1C26 00 00 00 00 
2917   1C2A 00 00 00 00 
2917   1C2E 00 00 00 00 
2917   1C32 00 00 00 00 
2917   1C36 00 00 00 00 
2917   1C3A 00 00 00 00 
2917   1C3E 00 00 00 00 
2917   1C42 00 00 00 00 
2917   1C46 00 00 00 00 
2917   1C4A 00 00 00 00 
2917   1C4E 00 00 00 00 
2917   1C52 00 00 00 00 
2917   1C56 00 00 00 00 
2917   1C5A 00 00 00 00 
2917   1C5E 00 00 00 00 
2917   1C62 00 00 00 00 
2917   1C66 00 00 00 00 
2917   1C6A 00 00 00 00 
2917   1C6E 00 00 00 00 
2917   1C72 00 00 00 00 
2917   1C76 00 00 00 00 
2917   1C7A 00 00 00 00 
2917   1C7E 00 00 00 00 
2917   1C82 00 00 00 00 
2917   1C86 00 00 00 00 
2917   1C8A 00 00 00 00 
2917   1C8E 00 00 00 00 
2917   1C92 00 00 00 00 
2917   1C96 00 00 00 00 
2917   1C9A 00 00 00 00 
2917   1C9E 00 00 00 00 
2917   1CA2 00 00 00 00 
2917   1CA6 00 00 00 00 
2917   1CAA 00 00 00 00 
2917   1CAE 00 00 00 00 
2917   1CB2 00 00 00 00 
2917   1CB6 00 00 00 00 
2918   1CBA             filename:
2919   1CBA 00 00 00 00   .fill 128, 0      ; holds a path for file search
2919   1CBE 00 00 00 00 
2919   1CC2 00 00 00 00 
2919   1CC6 00 00 00 00 
2919   1CCA 00 00 00 00 
2919   1CCE 00 00 00 00 
2919   1CD2 00 00 00 00 
2919   1CD6 00 00 00 00 
2919   1CDA 00 00 00 00 
2919   1CDE 00 00 00 00 
2919   1CE2 00 00 00 00 
2919   1CE6 00 00 00 00 
2919   1CEA 00 00 00 00 
2919   1CEE 00 00 00 00 
2919   1CF2 00 00 00 00 
2919   1CF6 00 00 00 00 
2919   1CFA 00 00 00 00 
2919   1CFE 00 00 00 00 
2919   1D02 00 00 00 00 
2919   1D06 00 00 00 00 
2919   1D0A 00 00 00 00 
2919   1D0E 00 00 00 00 
2919   1D12 00 00 00 00 
2919   1D16 00 00 00 00 
2919   1D1A 00 00 00 00 
2919   1D1E 00 00 00 00 
2919   1D22 00 00 00 00 
2919   1D26 00 00 00 00 
2919   1D2A 00 00 00 00 
2919   1D2E 00 00 00 00 
2919   1D32 00 00 00 00 
2919   1D36 00 00 00 00 
2920   1D3A             user_data:
2921   1D3A 00 00 00 00   .fill 512, 0      ;  user space data
2921   1D3E 00 00 00 00 
2921   1D42 00 00 00 00 
2921   1D46 00 00 00 00 
2921   1D4A 00 00 00 00 
2921   1D4E 00 00 00 00 
2921   1D52 00 00 00 00 
2921   1D56 00 00 00 00 
2921   1D5A 00 00 00 00 
2921   1D5E 00 00 00 00 
2921   1D62 00 00 00 00 
2921   1D66 00 00 00 00 
2921   1D6A 00 00 00 00 
2921   1D6E 00 00 00 00 
2921   1D72 00 00 00 00 
2921   1D76 00 00 00 00 
2921   1D7A 00 00 00 00 
2921   1D7E 00 00 00 00 
2921   1D82 00 00 00 00 
2921   1D86 00 00 00 00 
2921   1D8A 00 00 00 00 
2921   1D8E 00 00 00 00 
2921   1D92 00 00 00 00 
2921   1D96 00 00 00 00 
2921   1D9A 00 00 00 00 
2921   1D9E 00 00 00 00 
2921   1DA2 00 00 00 00 
2921   1DA6 00 00 00 00 
2921   1DAA 00 00 00 00 
2921   1DAE 00 00 00 00 
2921   1DB2 00 00 00 00 
2921   1DB6 00 00 00 00 
2921   1DBA 00 00 00 00 
2921   1DBE 00 00 00 00 
2921   1DC2 00 00 00 00 
2921   1DC6 00 00 00 00 
2921   1DCA 00 00 00 00 
2921   1DCE 00 00 00 00 
2921   1DD2 00 00 00 00 
2921   1DD6 00 00 00 00 
2921   1DDA 00 00 00 00 
2921   1DDE 00 00 00 00 
2921   1DE2 00 00 00 00 
2921   1DE6 00 00 00 00 
2921   1DEA 00 00 00 00 
2921   1DEE 00 00 00 00 
2921   1DF2 00 00 00 00 
2921   1DF6 00 00 00 00 
2921   1DFA 00 00 00 00 
2921   1DFE 00 00 00 00 
2921   1E02 00 00 00 00 
2921   1E06 00 00 00 00 
2921   1E0A 00 00 00 00 
2921   1E0E 00 00 00 00 
2921   1E12 00 00 00 00 
2921   1E16 00 00 00 00 
2921   1E1A 00 00 00 00 
2921   1E1E 00 00 00 00 
2921   1E22 00 00 00 00 
2921   1E26 00 00 00 00 
2921   1E2A 00 00 00 00 
2921   1E2E 00 00 00 00 
2921   1E32 00 00 00 00 
2921   1E36 00 00 00 00 
2921   1E3A 00 00 00 00 
2921   1E3E 00 00 00 00 
2921   1E42 00 00 00 00 
2921   1E46 00 00 00 00 
2921   1E4A 00 00 00 00 
2921   1E4E 00 00 00 00 
2921   1E52 00 00 00 00 
2921   1E56 00 00 00 00 
2921   1E5A 00 00 00 00 
2921   1E5E 00 00 00 00 
2921   1E62 00 00 00 00 
2921   1E66 00 00 00 00 
2921   1E6A 00 00 00 00 
2921   1E6E 00 00 00 00 
2921   1E72 00 00 00 00 
2921   1E76 00 00 00 00 
2921   1E7A 00 00 00 00 
2921   1E7E 00 00 00 00 
2921   1E82 00 00 00 00 
2921   1E86 00 00 00 00 
2921   1E8A 00 00 00 00 
2921   1E8E 00 00 00 00 
2921   1E92 00 00 00 00 
2921   1E96 00 00 00 00 
2921   1E9A 00 00 00 00 
2921   1E9E 00 00 00 00 
2921   1EA2 00 00 00 00 
2921   1EA6 00 00 00 00 
2921   1EAA 00 00 00 00 
2921   1EAE 00 00 00 00 
2921   1EB2 00 00 00 00 
2921   1EB6 00 00 00 00 
2921   1EBA 00 00 00 00 
2921   1EBE 00 00 00 00 
2921   1EC2 00 00 00 00 
2921   1EC6 00 00 00 00 
2921   1ECA 00 00 00 00 
2921   1ECE 00 00 00 00 
2921   1ED2 00 00 00 00 
2921   1ED6 00 00 00 00 
2921   1EDA 00 00 00 00 
2921   1EDE 00 00 00 00 
2921   1EE2 00 00 00 00 
2921   1EE6 00 00 00 00 
2921   1EEA 00 00 00 00 
2921   1EEE 00 00 00 00 
2921   1EF2 00 00 00 00 
2921   1EF6 00 00 00 00 
2921   1EFA 00 00 00 00 
2921   1EFE 00 00 00 00 
2921   1F02 00 00 00 00 
2921   1F06 00 00 00 00 
2921   1F0A 00 00 00 00 
2921   1F0E 00 00 00 00 
2921   1F12 00 00 00 00 
2921   1F16 00 00 00 00 
2921   1F1A 00 00 00 00 
2921   1F1E 00 00 00 00 
2921   1F22 00 00 00 00 
2921   1F26 00 00 00 00 
2921   1F2A 00 00 00 00 
2921   1F2E 00 00 00 00 
2921   1F32 00 00 00 00 
2921   1F36 00 00 00 00 
2922   1F3A             fifo:
2923   1F3A FF FF FF FF   .fill fifo_size
2923   1F3E FF FF FF FF 
2923   1F42 FF FF FF FF 
2923   1F46 FF FF FF FF 
2923   1F4A FF FF FF FF 
2923   1F4E FF FF FF FF 
2923   1F52 FF FF FF FF 
2923   1F56 FF FF FF FF 
2923   1F5A FF FF FF FF 
2923   1F5E FF FF FF FF 
2923   1F62 FF FF FF FF 
2923   1F66 FF FF FF FF 
2923   1F6A FF FF FF FF 
2923   1F6E FF FF FF FF 
2923   1F72 FF FF FF FF 
2923   1F76 FF FF FF FF 
2923   1F7A FF FF FF FF 
2923   1F7E FF FF FF FF 
2923   1F82 FF FF FF FF 
2923   1F86 FF FF FF FF 
2923   1F8A FF FF FF FF 
2923   1F8E FF FF FF FF 
2923   1F92 FF FF FF FF 
2923   1F96 FF FF FF FF 
2923   1F9A FF FF FF FF 
2923   1F9E FF FF FF FF 
2923   1FA2 FF FF FF FF 
2923   1FA6 FF FF FF FF 
2923   1FAA FF FF FF FF 
2923   1FAE FF FF FF FF 
2923   1FB2 FF FF FF FF 
2923   1FB6 FF FF FF FF 
2923   1FBA FF FF FF FF 
2923   1FBE FF FF FF FF 
2923   1FC2 FF FF FF FF 
2923   1FC6 FF FF FF FF 
2923   1FCA FF FF FF FF 
2923   1FCE FF FF FF FF 
2923   1FD2 FF FF FF FF 
2923   1FD6 FF FF FF FF 
2923   1FDA FF FF FF FF 
2923   1FDE FF FF FF FF 
2923   1FE2 FF FF FF FF 
2923   1FE6 FF FF FF FF 
2923   1FEA FF FF FF FF 
2923   1FEE FF FF FF FF 
2923   1FF2 FF FF FF FF 
2923   1FF6 FF FF FF FF 
2923   1FFA FF FF FF FF 
2923   1FFE FF FF FF FF 
2923   2002 FF FF FF FF 
2923   2006 FF FF FF FF 
2923   200A FF FF FF FF 
2923   200E FF FF FF FF 
2923   2012 FF FF FF FF 
2923   2016 FF FF FF FF 
2923   201A FF FF FF FF 
2923   201E FF FF FF FF 
2923   2022 FF FF FF FF 
2923   2026 FF FF FF FF 
2923   202A FF FF FF FF 
2923   202E FF FF FF FF 
2923   2032 FF FF FF FF 
2923   2036 FF FF FF FF 
2923   203A FF FF FF FF 
2923   203E FF FF FF FF 
2923   2042 FF FF FF FF 
2923   2046 FF FF FF FF 
2923   204A FF FF FF FF 
2923   204E FF FF FF FF 
2923   2052 FF FF FF FF 
2923   2056 FF FF FF FF 
2923   205A FF FF FF FF 
2923   205E FF FF FF FF 
2923   2062 FF FF FF FF 
2923   2066 FF FF FF FF 
2923   206A FF FF FF FF 
2923   206E FF FF FF FF 
2923   2072 FF FF FF FF 
2923   2076 FF FF FF FF 
2923   207A FF FF FF FF 
2923   207E FF FF FF FF 
2923   2082 FF FF FF FF 
2923   2086 FF FF FF FF 
2923   208A FF FF FF FF 
2923   208E FF FF FF FF 
2923   2092 FF FF FF FF 
2923   2096 FF FF FF FF 
2923   209A FF FF FF FF 
2923   209E FF FF FF FF 
2923   20A2 FF FF FF FF 
2923   20A6 FF FF FF FF 
2923   20AA FF FF FF FF 
2923   20AE FF FF FF FF 
2923   20B2 FF FF FF FF 
2923   20B6 FF FF FF FF 
2923   20BA FF FF FF FF 
2923   20BE FF FF FF FF 
2923   20C2 FF FF FF FF 
2923   20C6 FF FF FF FF 
2923   20CA FF FF FF FF 
2923   20CE FF FF FF FF 
2923   20D2 FF FF FF FF 
2923   20D6 FF FF FF FF 
2923   20DA FF FF FF FF 
2923   20DE FF FF FF FF 
2923   20E2 FF FF FF FF 
2923   20E6 FF FF FF FF 
2923   20EA FF FF FF FF 
2923   20EE FF FF FF FF 
2923   20F2 FF FF FF FF 
2923   20F6 FF FF FF FF 
2923   20FA FF FF FF FF 
2923   20FE FF FF FF FF 
2923   2102 FF FF FF FF 
2923   2106 FF FF FF FF 
2923   210A FF FF FF FF 
2923   210E FF FF FF FF 
2923   2112 FF FF FF FF 
2923   2116 FF FF FF FF 
2923   211A FF FF FF FF 
2923   211E FF FF FF FF 
2923   2122 FF FF FF FF 
2923   2126 FF FF FF FF 
2923   212A FF FF FF FF 
2923   212E FF FF FF FF 
2923   2132 FF FF FF FF 
2923   2136 FF FF FF FF 
2923   213A FF FF FF FF 
2923   213E FF FF FF FF 
2923   2142 FF FF FF FF 
2923   2146 FF FF FF FF 
2923   214A FF FF FF FF 
2923   214E FF FF FF FF 
2923   2152 FF FF FF FF 
2923   2156 FF FF FF FF 
2923   215A FF FF FF FF 
2923   215E FF FF FF FF 
2923   2162 FF FF FF FF 
2923   2166 FF FF FF FF 
2923   216A FF FF FF FF 
2923   216E FF FF FF FF 
2923   2172 FF FF FF FF 
2923   2176 FF FF FF FF 
2923   217A FF FF FF FF 
2923   217E FF FF FF FF 
2923   2182 FF FF FF FF 
2923   2186 FF FF FF FF 
2923   218A FF FF FF FF 
2923   218E FF FF FF FF 
2923   2192 FF FF FF FF 
2923   2196 FF FF FF FF 
2923   219A FF FF FF FF 
2923   219E FF FF FF FF 
2923   21A2 FF FF FF FF 
2923   21A6 FF FF FF FF 
2923   21AA FF FF FF FF 
2923   21AE FF FF FF FF 
2923   21B2 FF FF FF FF 
2923   21B6 FF FF FF FF 
2923   21BA FF FF FF FF 
2923   21BE FF FF FF FF 
2923   21C2 FF FF FF FF 
2923   21C6 FF FF FF FF 
2923   21CA FF FF FF FF 
2923   21CE FF FF FF FF 
2923   21D2 FF FF FF FF 
2923   21D6 FF FF FF FF 
2923   21DA FF FF FF FF 
2923   21DE FF FF FF FF 
2923   21E2 FF FF FF FF 
2923   21E6 FF FF FF FF 
2923   21EA FF FF FF FF 
2923   21EE FF FF FF FF 
2923   21F2 FF FF FF FF 
2923   21F6 FF FF FF FF 
2923   21FA FF FF FF FF 
2923   21FE FF FF FF FF 
2923   2202 FF FF FF FF 
2923   2206 FF FF FF FF 
2923   220A FF FF FF FF 
2923   220E FF FF FF FF 
2923   2212 FF FF FF FF 
2923   2216 FF FF FF FF 
2923   221A FF FF FF FF 
2923   221E FF FF FF FF 
2923   2222 FF FF FF FF 
2923   2226 FF FF FF FF 
2923   222A FF FF FF FF 
2923   222E FF FF FF FF 
2923   2232 FF FF FF FF 
2923   2236 FF FF FF FF 
2923   223A FF FF FF FF 
2923   223E FF FF FF FF 
2923   2242 FF FF FF FF 
2923   2246 FF FF FF FF 
2923   224A FF FF FF FF 
2923   224E FF FF FF FF 
2923   2252 FF FF FF FF 
2923   2256 FF FF FF FF 
2923   225A FF FF FF FF 
2923   225E FF FF FF FF 
2923   2262 FF FF FF FF 
2923   2266 FF FF FF FF 
2923   226A FF FF FF FF 
2923   226E FF FF FF FF 
2923   2272 FF FF FF FF 
2923   2276 FF FF FF FF 
2923   227A FF FF FF FF 
2923   227E FF FF FF FF 
2923   2282 FF FF FF FF 
2923   2286 FF FF FF FF 
2923   228A FF FF FF FF 
2923   228E FF FF FF FF 
2923   2292 FF FF FF FF 
2923   2296 FF FF FF FF 
2923   229A FF FF FF FF 
2923   229E FF FF FF FF 
2923   22A2 FF FF FF FF 
2923   22A6 FF FF FF FF 
2923   22AA FF FF FF FF 
2923   22AE FF FF FF FF 
2923   22B2 FF FF FF FF 
2923   22B6 FF FF FF FF 
2923   22BA FF FF FF FF 
2923   22BE FF FF FF FF 
2923   22C2 FF FF FF FF 
2923   22C6 FF FF FF FF 
2923   22CA FF FF FF FF 
2923   22CE FF FF FF FF 
2923   22D2 FF FF FF FF 
2923   22D6 FF FF FF FF 
2923   22DA FF FF FF FF 
2923   22DE FF FF FF FF 
2923   22E2 FF FF FF FF 
2923   22E6 FF FF FF FF 
2923   22EA FF FF FF FF 
2923   22EE FF FF FF FF 
2923   22F2 FF FF FF FF 
2923   22F6 FF FF FF FF 
2923   22FA FF FF FF FF 
2923   22FE FF FF FF FF 
2923   2302 FF FF FF FF 
2923   2306 FF FF FF FF 
2923   230A FF FF FF FF 
2923   230E FF FF FF FF 
2923   2312 FF FF FF FF 
2923   2316 FF FF FF FF 
2923   231A FF FF FF FF 
2923   231E FF FF FF FF 
2923   2322 FF FF FF FF 
2923   2326 FF FF FF FF 
2923   232A FF FF FF FF 
2923   232E FF FF FF FF 
2923   2332 FF FF FF FF 
2923   2336 FF FF FF FF 
2924   233A             
2925   233A             scrap_sector:
2926   233A FF FF FF FF   .fill 512         ; scrap sector
2926   233E FF FF FF FF 
2926   2342 FF FF FF FF 
2926   2346 FF FF FF FF 
2926   234A FF FF FF FF 
2926   234E FF FF FF FF 
2926   2352 FF FF FF FF 
2926   2356 FF FF FF FF 
2926   235A FF FF FF FF 
2926   235E FF FF FF FF 
2926   2362 FF FF FF FF 
2926   2366 FF FF FF FF 
2926   236A FF FF FF FF 
2926   236E FF FF FF FF 
2926   2372 FF FF FF FF 
2926   2376 FF FF FF FF 
2926   237A FF FF FF FF 
2926   237E FF FF FF FF 
2926   2382 FF FF FF FF 
2926   2386 FF FF FF FF 
2926   238A FF FF FF FF 
2926   238E FF FF FF FF 
2926   2392 FF FF FF FF 
2926   2396 FF FF FF FF 
2926   239A FF FF FF FF 
2926   239E FF FF FF FF 
2926   23A2 FF FF FF FF 
2926   23A6 FF FF FF FF 
2926   23AA FF FF FF FF 
2926   23AE FF FF FF FF 
2926   23B2 FF FF FF FF 
2926   23B6 FF FF FF FF 
2926   23BA FF FF FF FF 
2926   23BE FF FF FF FF 
2926   23C2 FF FF FF FF 
2926   23C6 FF FF FF FF 
2926   23CA FF FF FF FF 
2926   23CE FF FF FF FF 
2926   23D2 FF FF FF FF 
2926   23D6 FF FF FF FF 
2926   23DA FF FF FF FF 
2926   23DE FF FF FF FF 
2926   23E2 FF FF FF FF 
2926   23E6 FF FF FF FF 
2926   23EA FF FF FF FF 
2926   23EE FF FF FF FF 
2926   23F2 FF FF FF FF 
2926   23F6 FF FF FF FF 
2926   23FA FF FF FF FF 
2926   23FE FF FF FF FF 
2926   2402 FF FF FF FF 
2926   2406 FF FF FF FF 
2926   240A FF FF FF FF 
2926   240E FF FF FF FF 
2926   2412 FF FF FF FF 
2926   2416 FF FF FF FF 
2926   241A FF FF FF FF 
2926   241E FF FF FF FF 
2926   2422 FF FF FF FF 
2926   2426 FF FF FF FF 
2926   242A FF FF FF FF 
2926   242E FF FF FF FF 
2926   2432 FF FF FF FF 
2926   2436 FF FF FF FF 
2926   243A FF FF FF FF 
2926   243E FF FF FF FF 
2926   2442 FF FF FF FF 
2926   2446 FF FF FF FF 
2926   244A FF FF FF FF 
2926   244E FF FF FF FF 
2926   2452 FF FF FF FF 
2926   2456 FF FF FF FF 
2926   245A FF FF FF FF 
2926   245E FF FF FF FF 
2926   2462 FF FF FF FF 
2926   2466 FF FF FF FF 
2926   246A FF FF FF FF 
2926   246E FF FF FF FF 
2926   2472 FF FF FF FF 
2926   2476 FF FF FF FF 
2926   247A FF FF FF FF 
2926   247E FF FF FF FF 
2926   2482 FF FF FF FF 
2926   2486 FF FF FF FF 
2926   248A FF FF FF FF 
2926   248E FF FF FF FF 
2926   2492 FF FF FF FF 
2926   2496 FF FF FF FF 
2926   249A FF FF FF FF 
2926   249E FF FF FF FF 
2926   24A2 FF FF FF FF 
2926   24A6 FF FF FF FF 
2926   24AA FF FF FF FF 
2926   24AE FF FF FF FF 
2926   24B2 FF FF FF FF 
2926   24B6 FF FF FF FF 
2926   24BA FF FF FF FF 
2926   24BE FF FF FF FF 
2926   24C2 FF FF FF FF 
2926   24C6 FF FF FF FF 
2926   24CA FF FF FF FF 
2926   24CE FF FF FF FF 
2926   24D2 FF FF FF FF 
2926   24D6 FF FF FF FF 
2926   24DA FF FF FF FF 
2926   24DE FF FF FF FF 
2926   24E2 FF FF FF FF 
2926   24E6 FF FF FF FF 
2926   24EA FF FF FF FF 
2926   24EE FF FF FF FF 
2926   24F2 FF FF FF FF 
2926   24F6 FF FF FF FF 
2926   24FA FF FF FF FF 
2926   24FE FF FF FF FF 
2926   2502 FF FF FF FF 
2926   2506 FF FF FF FF 
2926   250A FF FF FF FF 
2926   250E FF FF FF FF 
2926   2512 FF FF FF FF 
2926   2516 FF FF FF FF 
2926   251A FF FF FF FF 
2926   251E FF FF FF FF 
2926   2522 FF FF FF FF 
2926   2526 FF FF FF FF 
2926   252A FF FF FF FF 
2926   252E FF FF FF FF 
2926   2532 FF FF FF FF 
2926   2536 FF FF FF FF 
2927   253A             transient_area:
2928   253A 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2929   253B             
2930   253B             .end
tasm: Number of errors = 0
