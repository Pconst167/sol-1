0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff88         ; data
0042   0000             _uart1_dlab_0     .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff8A         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff8B         ; line control register
0047   0000             _uart1_lsr        .equ $ff8D         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _til311_display   .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             _stack_begin      .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size        .equ 4096
0080   0000             
0081   0000             _mbr              .equ 446
0082   0000             _superblock       .equ 512
0083   0000             
0084   0000             text_org          .equ $400          ; code origin address for all user processes
0085   0000             
0086   0000             
0087   0000             ; ------------------------------------------------------------------------------------------------------------------;
0088   0000             ; DISK LAYOUT:
0089   0000             ; | Metadata               | Size (bytes)    | Blocks (2048 bytes)              |
0090   0000             ; | ---------------------- | --------------- | -------------------------------- |
0091   0000             ; | Bootloader/MBR         | 512 bytes       | 0.25 (1 sector)                  |
0092   0000             ; | Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0093   0000             ; | Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0094   0000             ; | Block Bitmap           | 16,384 bytes    | 8 blocks                         |
0095   0000             ; | Inode Bitmap           | 2,048 bytes     | 1 block                          |
0096   0000             ; | Inode Table            | 2,097,152 bytes | 1024 blocks                      |
0097   0000             ; 
0098   0000             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0099   0000             ; up to 4 partitions, each 16 bytes long
0100   0000             ; MBR:
0101   0000             ; Byte | Description
0102   0000             ; -----|----------------------------
0103   0000             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0104   0000             ; 1-3  | Start CHS (head, sector, cylinder)
0105   0000             ; 4    | Partition type (filesystem ID)
0106   0000             ;   0x83 = Linux native (ext2/3/4)
0107   0000             ;   0x07 = NTFS/exFAT
0108   0000             ;   0x0B = FAT32 CHS
0109   0000             ;   0x0C = FAT32 LBA
0110   0000             ;   0x05 = Extended partition
0111   0000             ; 5-7  | End CHS
0112   0000             ; 8-11 | Start LBA (little endian)
0113   0000             ; 12-15| Size in sectors (little endian)
0114   0000             ; 
0115   0000             ; 
0116   0000             ; SUPERBLOCK:
0117   0000             ; | Field                 | Description                              | Typical Size (bytes) | Notes                           |
0118   0000             ; | --------------------- | ---------------------------------------- | -------------------- | ------------------------------- |
0119   0000             ; | `s_inodes_count`      | Total number of inodes in the filesystem | 4                    | 32-bit unsigned int             |
0120   0000             ; | `s_blocks_count`      | Total number of data blocks              | 4                    | 32-bit unsigned int             |
0121   0000             ; | `s_free_inodes_count` | Number of free inodes                    | 4                    | 32-bit unsigned int             |
0122   0000             ; | `s_free_blocks_count` | Number of free blocks                    | 4                    | 32-bit unsigned int             |
0123   0000             ; | `s_first_data_block`  | Block number of the first data block     | 4                    | 32-bit unsigned int             |
0124   0000             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`  | 4                    | 32-bit unsigned int             |
0125   0000             ; | `s_inode_size`        | Size of each inode (in bytes)            | 2                    | 16-bit unsigned int             |
0126   0000             ; | `s_magic`             | Filesystem signature (`0xEF53`)          | 2                    | 16-bit unsigned int             |
0127   0000             ; | `s_mtime`             | Last mount time                          | 4                    | 32-bit unsigned int (Unix time) |
0128   0000             ; | `s_wtime`             | Last write time                          | 4                    | 32-bit unsigned int (Unix time) |
0129   0000             ; | `s_uuid`              | Unique ID of the filesystem              | 16                   | 128-bit UUID                    |
0130   0000             ; | `s_volume_name`       | Label of the filesystem                  | 16                   | Usually ASCII, padded           |
0131   0000             ; | `s_feature_flags`     | Compatibility flags                      | 4                    | 32-bit unsigned int             |
0132   0000             ; 
0133   0000             ; 
0134   0000             ; inode for root dir is #2, #0 and #1 not used
0135   0000             ; block size: 2048
0136   0000             
0137   0000             ; inode-table format:
0138   0000             ; | Field         | Size (bytes) | Description                                                                                  |
0139   0000             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0140   0000             ; | `mode`        | 2            | File type and permissions                                                                    |
0141   0000             ; | `uid`         | 2            | Owner user ID                                                                                |
0142   0000             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0143   0000             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0144   0000             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0145   0000             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0146   0000             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0147   0000             ; | `gid`         | 2            | Group ID                                                                                     |
0148   0000             ; | `links_count` | 2            | Number of hard links                                                                         |
0149   0000             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0150   0000             ; | `flags`       | 4            | File flags                                                                                   |
0151   0000             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0152   0000             
0153   0000             
0154   0000             ; file entry attributes
0155   0000             ; filename (24)
0156   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0157   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0158   0000             ; size (2)             : filesize
0159   0000             ; day (1)           
0160   0000             ; month (1)
0161   0000             ; year (1)
0162   0000             ; packet size = 32 bytes  : total packet size in bytes
0163   0000             
0164   0000             fst_entry_size      .equ 32  ; bytes
0165   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0166   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0167   0000             fst_nbr_directories .equ 64
0168   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0169   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0170   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0171   0000             fst_lba_start       .equ 32
0172   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0173   0000             
0174   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0175   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0176   0000                                         ; so that we know which blocks are free or taken
0177   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0178   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0179   0000             fs_lba_start        .equ (fst_lba_end + 1)
0180   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0181   0000             
0182   0000             root_id:            .equ fst_lba_start
0183   0000             
0184   0000             ; ------------------------------------------------------------------------------------------------------------------;
0185   0000             ; global system variables
0186   0000             ; ------------------------------------------------------------------------------------------------------------------;
0187   0000             
0188   0000             ; ------------------------------------------------------------------------------------------------------------------;
0189   0000             ; irq table
0190   0000             ; highest priority at lowest address
0191   0000             ; ------------------------------------------------------------------------------------------------------------------;
0192   0000 3C 00       .dw int_0_fdc
0193   0002 43 00       .dw int_1
0194   0004 44 00       .dw int_2
0195   0006 45 00       .dw int_3
0196   0008 46 00       .dw int_4
0197   000A 47 00       .dw int_5_uart1
0198   000C 73 00       .dw int_6_timer
0199   000E 74 00       .dw int_7_uart0
0200   0010             
0201   0010             ; ------------------------------------------------------------------------------------------------------------------;
0202   0010             ; kernel reset vector
0203   0010             ; ------------------------------------------------------------------------------------------------------------------;
0204   0010 93 12       .dw kernel_reset_vector
0205   0012             
0206   0012             ; ------------------------------------------------------------------------------------------------------------------;
0207   0012             ; exception vector table
0208   0012             ; total of 7 entries, starting at address $0012
0209   0012             ; ------------------------------------------------------------------------------------------------------------------;
0210   0012 11 05       .dw trap_privilege
0211   0014 2E 06       .dw trap_div_zero
0212   0016 3B 06       .dw trap_undef_opcode
0213   0018 00 00       .dw 0
0214   001A 00 00       .dw 0
0215   001C 00 00       .dw 0
0216   001E 00 00       .dw 0
0217   0020             
0218   0020             ; ------------------------------------------------------------------------------------------------------------------;
0219   0020             ; system call vector table
0220   0020             ; starts at address $0020
0221   0020             ; ------------------------------------------------------------------------------------------------------------------;
0222   0020 1D 05       .dw syscall_break
0223   0022 3C 06       .dw syscall_rtc
0224   0024 5F 07       .dw syscall_ide
0225   0026 1F 08       .dw syscall_io
0226   0028 14 09       .dw syscall_file_system
0227   002A E0 11       .dw syscall_create_proc
0228   002C D6 04       .dw syscall_list_procs
0229   002E 6E 06       .dw syscall_datetime
0230   0030 92 04       .dw syscall_reboot
0231   0032 AA 11       .dw syscall_pause_proc
0232   0034 9E 04       .dw syscall_resume_proc
0233   0036 67 11       .dw syscall_terminate_proc
0234   0038 5E 04       .dw syscall_system
0235   003A 9D 01       .dw syscall_fdc
0236   003C             
0237   003C             ; ------------------------------------------------------------------------------------------------------------------;
0238   003C             ; system call aliases
0239   003C             ; ------------------------------------------------------------------------------------------------------------------;
0240   003C             sys_break            .equ 0
0241   003C             sys_rtc              .equ 1
0242   003C             sys_ide              .equ 2
0243   003C             sys_io               .equ 3
0244   003C             sys_filesystem       .equ 4
0245   003C             sys_create_proc      .equ 5
0246   003C             sys_list_proc        .equ 6
0247   003C             sys_datetime         .equ 7
0248   003C             sys_reboot           .equ 8
0249   003C             sys_pause_proc       .equ 9
0250   003C             sys_resume_proc      .equ 10
0251   003C             sys_terminate_proc   .equ 11
0252   003C             sys_system           .equ 12
0253   003C             sys_fdc              .equ 13
0254   003C             
0255   003C             ; aliases for individual 'al' options for FDC system calls
0256   003C             fdc_al_restore      .equ 0
0257   003C             fdc_al_step         .equ 1
0258   003C             fdc_al_step_in      .equ 2
0259   003C             fdc_al_step_out     .equ 3
0260   003C             fdc_al_seek         .equ 4
0261   003C             fdc_al_format_128   .equ 5
0262   003C             fdc_al_formatdisk_128   .equ 6
0263   003C             fdc_al_format_512   .equ 7
0264   003C             fdc_al_formatdisk_512   .equ 8
0265   003C             fdc_al_read_addr    .equ 9
0266   003C             fdc_al_read_track   .equ 10
0267   003C             fdc_al_read_sect    .equ 11
0268   003C             fdc_al_write_sect   .equ 12
0269   003C             fdc_al_force_int    .equ 13
0270   003C             fdc_al_status0      .equ 14
0271   003C             fdc_al_status1      .equ 15
0272   003C             
0273   003C             ; ------------------------------------------------------------------------------------------------------------------;
0274   003C             ; alias exports
0275   003C             ; ------------------------------------------------------------------------------------------------------------------;
0276   003C             .export text_org
0277   003C             .export sys_break
0278   003C             .export sys_rtc
0279   003C             .export sys_ide
0280   003C             .export sys_io
0281   003C             .export sys_filesystem
0282   003C             .export sys_create_proc
0283   003C             .export sys_list_proc
0284   003C             .export sys_datetime
0285   003C             .export sys_reboot
0286   003C             .export sys_pause_proc
0287   003C             .export sys_resume_proc
0288   003C             .export sys_terminate_proc
0289   003C             .export sys_system
0290   003C             .export sys_fdc
0291   003C             
0292   003C             .export _til311_display
0293   003C             
0294   003C             .export _fdc_config        
0295   003C             .export _fdc_status_0      
0296   003C             .export _fdc_stat_cmd     
0297   003C             
0298   003C             ; exports of aliases for individual 'al' options for FDC system calls
0299   003C             .export fdc_al_restore
0300   003C             .export fdc_al_step
0301   003C             .export fdc_al_step_in
0302   003C             .export fdc_al_step_out
0303   003C             .export fdc_al_seek
0304   003C             .export fdc_al_format_128
0305   003C             .export fdc_al_formatdisk_128
0306   003C             .export fdc_al_format_512
0307   003C             .export fdc_al_formatdisk_512
0308   003C             .export fdc_al_read_addr
0309   003C             .export fdc_al_read_track
0310   003C             .export fdc_al_read_sect
0311   003C             .export fdc_al_write_sect
0312   003C             .export fdc_al_force_int
0313   003C             .export fdc_al_status0
0314   003C             .export fdc_al_status1
0315   003C             
0316   003C             ; ------------------------------------------------------------------------------------------------------------------;
0317   003C             ; irqs' code block
0318   003C             ; ------------------------------------------------------------------------------------------------------------------;
0319   003C             ; 5.25" floppy drive controller irq
0320   003C             int_0_fdc:
0321   003C 3B 0F 1C      mov d, s_fdc_irq
0322   003F 07 EF 14      call _puts
0323   0042 06            sysret
0324   0043             int_1:
0325   0043 06            sysret
0326   0044             int_2:
0327   0044 06            sysret
0328   0045             int_3:
0329   0045 06            sysret
0330   0046             int_4:
0331   0046 06            sysret
0332   0047             
0333   0047             ; ------------------------------------------------------------------------------------------------------------------;
0334   0047             ; uart1 interrupt
0335   0047             ; ------------------------------------------------------------------------------------------------------------------;
0336   0047             int_5_uart1:
0337   0047 D7            push a
0338   0048 DA            push d
0339   0049 E1            pushf
0340   004A 1D 88 FF      mov al, [_uart1_data]       ; get character
0341   004D B9 03         cmp al, $03                 ; ctrl-c
0342   004F C6 A0 00      je ctrlc
0343   0052 B9 1A         cmp al, $1a                 ; ctrl-z
0344   0054 C6 A6 00      je ctrlz
0345   0057               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0346   0057 3B 2A 1A      mov d, fifo_in
0347   005A FD 2A         mov d, [d]
0348   005C 3E            mov [d], al                 ; add to fifo
0349   005D 13            mov a, d
0350   005E 77            inc a
0351   005F AF 31 32      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0352   0062 C7 68 00      jne int_5_continue
0353   0065 10 31 22      mov a, fifo  
0354   0068             int_5_continue:  
0355   0068 42 2A 1A      mov [fifo_in], a            ; update fifo pointer
0356   006B 1A            mov al, ah
0357   006C 3D B0 FF      mov [_til311_display], al
0358   006F EE            popf
0359   0070 E7            pop d
0360   0071 E4            pop a  
0361   0072 06            sysret
0362   0073             
0363   0073             ; ------------------------------------------------------------------------------------------------------------------;
0364   0073             ; timer irq
0365   0073             ; ------------------------------------------------------------------------------------------------------------------;
0366   0073             int_6_timer:  
0367   0073 06            sysret
0368   0074             
0369   0074             ; ------------------------------------------------------------------------------------------------------------------;
0370   0074             ; uart0 interrupt
0371   0074             ; ------------------------------------------------------------------------------------------------------------------;
0372   0074             int_7_uart0:
0373   0074 D7            push a
0374   0075 DA            push d
0375   0076 E1            pushf
0376   0077 1D 80 FF      mov al, [_uart0_data]       ; get character
0377   007A B9 03         cmp al, $03                 ; ctrl-c
0378   007C C6 A0 00      je ctrlc
0379   007F B9 1A         cmp al, $1a                 ; ctrl-z
0380   0081 C6 A6 00      je ctrlz
0381   0084               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0382   0084 3B 2A 1A      mov d, fifo_in
0383   0087 FD 2A         mov d, [d]
0384   0089 3E            mov [d], al                 ; add to fifo
0385   008A 13            mov a, d
0386   008B 77            inc a
0387   008C AF 31 32      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0388   008F C7 95 00      jne int_7_continue
0389   0092 10 31 22      mov a, fifo  
0390   0095             int_7_continue:  
0391   0095 42 2A 1A      mov [fifo_in], a            ; update fifo pointer
0392   0098 1A            mov al, ah
0393   0099 3D B0 FF      mov [_til311_display], al
0394   009C EE            popf
0395   009D E7            pop d
0396   009E E4            pop a  
0397   009F 06            sysret
0398   00A0             
0399   00A0             ctrlc:
0400   00A0 51 05 00      add sp, 5
0401   00A3 0A 67 11      jmp syscall_terminate_proc
0402   00A6             ctrlz:
0403   00A6 51 05 00      add sp, 5
0404   00A9 0A AA 11      jmp syscall_pause_proc      ; pause current process and go back to the shell
0405   00AC             
0406   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0407   00AC             ; ext2 file system
0408   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0409   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0410   00AC             ; DISK LAYOUT:
0411   00AC             ; Metadata               | Size (bytes)    | Blocks (2048 bytes)              |  Comment
0412   00AC             ; ---------------------- | --------------- | -------------------------------- | ----------------------------------
0413   00AC             ; Bootloader/MBR         | 512 bytes       | 0.25 (1 sector)                  |
0414   00AC             ; Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0415   00AC             ; Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0416   00AC             ; Block Bitmap           | 16,384 bytes    | 8 blocks                         | 16384*2048 = 33554432 blocks.  33554432*8 = 256MB of disk space
0417   00AC             ; Inode Bitmap           | 2,048 bytes     | 1 block                          | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is a standard default of 1 inode per 16KB of disk space
0418   00AC             ; Inode Table            | 2,097,152 bytes | 1024 blocks                      | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0419   00AC             ; 
0420   00AC             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0421   00AC             ; up to 4 partitions, each 16 bytes long
0422   00AC             ; MBR:
0423   00AC             ; Byte | Description
0424   00AC             ; -----|----------------------------
0425   00AC             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0426   00AC             ; 1-3  | Start CHS (head, sector, cylinder)
0427   00AC             ; 4    | Partition type (filesystem ID)
0428   00AC             ;   0x83 = Linux native (ext2/3/4)
0429   00AC             ;   0x07 = NTFS/exFAT
0430   00AC             ;   0x0B = FAT32 CHS
0431   00AC             ;   0x0C = FAT32 LBA
0432   00AC             ;   0x05 = Extended partition
0433   00AC             ; 5-7  | End CHS
0434   00AC             ; 8-11 | Start LBA (little endian)
0435   00AC             ; 12-15| Size in sectors (little endian)
0436   00AC             ; 
0437   00AC             ; 
0438   00AC             ; SUPERBLOCK:
0439   00AC             ; | Field                 | Description                              | Typical Size (bytes) | Notes                           |
0440   00AC             ; | --------------------- | ---------------------------------------- | -------------------- | ------------------------------- |
0441   00AC             ; | `s_inodes_count`      | Total number of inodes in the filesystem | 4                    | 32-bit unsigned int             |
0442   00AC             ; | `s_blocks_count`      | Total number of data blocks              | 4                    | 32-bit unsigned int             |
0443   00AC             ; | `s_free_inodes_count` | Number of free inodes                    | 4                    | 32-bit unsigned int             |
0444   00AC             ; | `s_free_blocks_count` | Number of free blocks                    | 4                    | 32-bit unsigned int             |
0445   00AC             ; | `s_first_data_block`  | Block number of the first data block     | 4                    | 32-bit unsigned int             |
0446   00AC             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`  | 4                    | 32-bit unsigned int             |
0447   00AC             ; | `s_inode_size`        | Size of each inode (in bytes)            | 2                    | 16-bit unsigned int             |
0448   00AC             ; | `s_magic`             | Filesystem signature (`0xEF53`)          | 2                    | 16-bit unsigned int             |
0449   00AC             ; | `s_mtime`             | Last mount time                          | 4                    | 32-bit unsigned int (Unix time) |
0450   00AC             ; | `s_wtime`             | Last write time                          | 4                    | 32-bit unsigned int (Unix time) |
0451   00AC             ; | `s_uuid`              | Unique ID of the filesystem              | 16                   | 128-bit UUID                    |
0452   00AC             ; | `s_volume_name`       | Label of the filesystem                  | 16                   | Usually ASCII, padded           |
0453   00AC             ; | `s_feature_flags`     | Compatibility flags                      | 4                    | 32-bit unsigned int             |
0454   00AC             ; 
0455   00AC             ; 
0456   00AC             ; inode for root dir is #2, #0 and #1 not used
0457   00AC             ; block size: 2048
0458   00AC             
0459   00AC             ; inode-table format:
0460   00AC             ; entry size: 128 bytes per entry (default)
0461   00AC             ; | Field         | Size (bytes) | Description                                                                                  |
0462   00AC             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0463   00AC             ; | `mode`        | 2            | File type and permissions                                                                    |
0464   00AC             ; | `uid`         | 2            | Owner user ID                                                                                |
0465   00AC             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0466   00AC             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0467   00AC             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0468   00AC             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0469   00AC             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0470   00AC             ; | `gid`         | 2            | Group ID                                                                                     |
0471   00AC             ; | `links_count` | 2            | Number of hard links                                                                         |
0472   00AC             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0473   00AC             ; | `flags`       | 4            | File flags                                                                                   |
0474   00AC             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0475   00AC             ; | padding       | 32 bytes
0476   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0477   00AC             ; ext2 file system
0478   00AC             ; ------------------------------------------------------------------------------------------------------------------;
0479   00AC             ; up to 4 partitions, each 16 bytes long
0480   00AC             ; MBR:
0481   00AC             ; Byte | Description
0482   00AC             ; -----|----------------------------
0483   00AC             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0484   00AC             ; 1-3  | Start CHS (head, sector, cylinder)
0485   00AC             ; 4    | Partition type (filesystem ID)
0486   00AC             ;   0x83 = Linux native (ext2/3/4)
0487   00AC             ;   0x07 = NTFS/exFAT
0488   00AC             ;   0x0B = FAT32 CHS
0489   00AC             ;   0x0C = FAT32 LBA
0490   00AC             ;   0x05 = Extended partition
0491   00AC             ; 5-7  | End CHS
0492   00AC             ; 8-11 | Start LBA (little endian)
0493   00AC             ; 12-15| Size in sectors (little endian)
0494   00AC             sys_mkfs:
0495   00AC             ; master boot record
0496   00AC             ; partition 0
0497   00AC F2 EF 35 80   mov byte[transient_area + 446 + 0 +  0], $80      ; boot flag, 0x80 = active
0498   00B0 B8 F0 35 00   mov word[transient_area + 446 + 0 +  1], $0000    ; start of CHS
0498   00B4 00 
0499   00B5 F2 F2 35 00   mov byte[transient_area + 446 + 0 +  3], $00      ; start of CHS
0500   00B9 F2 F3 35 83   mov byte[transient_area + 446 + 0 +  4], $83      ; artition type, 0x83 = linux/ext2
0501   00BD B8 F4 35 00   mov word[transient_area + 446 + 0 +  5], $0000    ; end of CHS
0501   00C1 00 
0502   00C2 F2 F6 35 00   mov byte[transient_area + 446 + 0 +  7], $00      ; end of CHS
0503   00C6 B8 F7 35 01   mov word[transient_area + 446 + 0 +  8], $0001    ; start LBA of file system, at sector 1
0503   00CA 00 
0504   00CB B8 F9 35 00   mov word[transient_area + 446 + 0 + 10], $0000    ; start LBA of file system, at sector 1
0504   00CF 00 
0505   00D0 B8 FB 35 00   mov word[transient_area + 446 + 0 + 12], $0000    ; size of file system in sectors/lba, 256MB
0505   00D4 00 
0506   00D5 B8 FD 35 08   mov word[transient_area + 446 + 0 + 14], $0008    ; 256MB = 524288 sectors
0506   00D9 00 
0507   00DA             ; partition 1
0508   00DA F2 FF 35 00   mov byte[transient_area + 446 + 16 +  0], $00      ; boot flag, 0x00 = inactive
0509   00DE B8 00 36 00   mov word[transient_area + 446 + 16 +  1], $0000    ; start of CHS
0509   00E2 00 
0510   00E3 F2 02 36 00   mov byte[transient_area + 446 + 16 +  3], $00      ; start of CHS
0511   00E7 F2 03 36 83   mov byte[transient_area + 446 + 16 +  4], $83      ; artition type, 0x83 = linux/ext2
0512   00EB B8 04 36 00   mov word[transient_area + 446 + 16 +  5], $0000    ; end of CHS
0512   00EF 00 
0513   00F0 F2 06 36 00   mov byte[transient_area + 446 + 16 +  7], $00      ; end of CHS
0514   00F4 B8 07 36 00   mov word[transient_area + 446 + 16 +  8], $0000    ; start LBA of file system, at sector 1
0514   00F8 00 
0515   00F9 B8 09 36 00   mov word[transient_area + 446 + 16 + 10], $0000    ; start LBA of file system, at sector 1
0515   00FD 00 
0516   00FE B8 0B 36 00   mov word[transient_area + 446 + 16 + 12], $0000    ; size of file system in sectors/lba, 256MB
0516   0102 00 
0517   0103 B8 0D 36 00   mov word[transient_area + 446 + 16 + 14], $0000    ; 256MB = 524288 sectors
0517   0107 00 
0518   0108             ; partition 2
0519   0108 F2 0F 36 00   mov byte[transient_area + 446 + 32 +  0], $00      ; boot flag, 0x00 = inactive
0520   010C B8 10 36 00   mov word[transient_area + 446 + 32 +  1], $0000    ; start of CHS
0520   0110 00 
0521   0111 F2 12 36 00   mov byte[transient_area + 446 + 32 +  3], $00      ; start of CHS
0522   0115 F2 13 36 83   mov byte[transient_area + 446 + 32 +  4], $83      ; artition type, 0x83 = linux/ext2
0523   0119 B8 14 36 00   mov word[transient_area + 446 + 32 +  5], $0000    ; end of CHS
0523   011D 00 
0524   011E F2 16 36 00   mov byte[transient_area + 446 + 32 +  7], $00      ; end of CHS
0525   0122 B8 17 36 00   mov word[transient_area + 446 + 32 +  8], $0000    ; start LBA of file system, at sector 1
0525   0126 00 
0526   0127 B8 19 36 00   mov word[transient_area + 446 + 32 + 10], $0000    ; start LBA of file system, at sector 1
0526   012B 00 
0527   012C B8 1B 36 00   mov word[transient_area + 446 + 32 + 12], $0000    ; size of file system in sectors/lba, 256MB
0527   0130 00 
0528   0131 B8 1D 36 00   mov word[transient_area + 446 + 32 + 14], $0000    ; 256MB = 524288 sectors
0528   0135 00 
0529   0136             ; partition 3
0530   0136 F2 1F 36 00   mov byte[transient_area + 446 + 48 +  0], $00      ; boot flag, 0x00 = inactive
0531   013A B8 20 36 00   mov word[transient_area + 446 + 48 +  1], $0000    ; start of CHS
0531   013E 00 
0532   013F F2 22 36 00   mov byte[transient_area + 446 + 48 +  3], $00      ; start of CHS
0533   0143 F2 23 36 83   mov byte[transient_area + 446 + 48 +  4], $83      ; artition type, 0x83 = linux/ext2
0534   0147 B8 24 36 00   mov word[transient_area + 446 + 48 +  5], $0000    ; end of CHS
0534   014B 00 
0535   014C F2 26 36 00   mov byte[transient_area + 446 + 48 +  7], $00      ; end of CHS
0536   0150 B8 27 36 00   mov word[transient_area + 446 + 48 +  8], $0000    ; start LBA of file system, at sector 1
0536   0154 00 
0537   0155 B8 29 36 00   mov word[transient_area + 446 + 48 + 10], $0000    ; start LBA of file system, at sector 1
0537   0159 00 
0538   015A B8 2B 36 00   mov word[transient_area + 446 + 48 + 12], $0000    ; size of file system in sectors/lba, 256MB
0538   015E 00 
0539   015F B8 2D 36 00   mov word[transient_area + 446 + 48 + 14], $0000    ; 256MB = 524288 sectors
0539   0163 00 
0540   0164             ; --- MBR signature ---
0541   0164 B8 FE 01 55   mov word [510], $AA55          ; Must be present for BIOS to boot
0541   0168 00 
0542   0169             
0543   0169             ; Metadata               | Size (bytes)    | Blocks (2048 bytes)              |  Comment
0544   0169             ; ---------------------- | --------------- | -------------------------------- | ----------------------------------
0545   0169             ; Bootloader/MBR         | 512 bytes       | 0.25 (1 sector)                  |
0546   0169             ; Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0547   0169             ; Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0548   0169             ; Block Bitmap           | 16,384 bytes    | 8 blocks                         | 16384*2048 = 33554432 blocks.  33554432*8 = 256MB of disk space
0549   0169             ; Inode Bitmap           | 2,048 bytes     | 1 block                          | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is a standard default of 1 inode per 16KB of disk space
0550   0169             ; Inode Table            | 2,097,152 bytes | 1024 blocks                      | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0551   0169             ; SUPERBLOCK:
0552   0169             ; | Field                 | Description                              | Typical Size (bytes) | Notes                           |
0553   0169             ; | --------------------- | ---------------------------------------- | -------------------- | ------------------------------- |
0554   0169             ; | `s_inodes_count`      | Total number of inodes in the filesystem | 4                    | 32-bit unsigned int             |
0555   0169             ; | `s_blocks_count`      | Total number of data blocks              | 4                    | 32-bit unsigned int             |
0556   0169             ; | `s_free_inodes_count` | Number of free inodes                    | 4                    | 32-bit unsigned int             |
0557   0169             ; | `s_free_blocks_count` | Number of free blocks                    | 4                    | 32-bit unsigned int             |
0558   0169             ; | `s_first_data_block`  | Block number of the first data block     | 4                    | 32-bit unsigned int             |
0559   0169             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`  | 4                    | 32-bit unsigned int             |
0560   0169             ; | `s_inode_size`        | Size of each inode (in bytes)            | 2                    | 16-bit unsigned int             |
0561   0169             ; | `s_magic`             | Filesystem signature (`0xEF53`)          | 2                    | 16-bit unsigned int             |
0562   0169             ; | `s_mtime`             | Last mount time                          | 4                    | 32-bit unsigned int (Unix time) |
0563   0169             ; | `s_wtime`             | Last write time                          | 4                    | 32-bit unsigned int (Unix time) |
0564   0169             ; | `s_uuid`              | Unique ID of the filesystem              | 16                   | 128-bit UUID                    |
0565   0169             ; | `s_volume_name`       | Label of the filesystem                  | 16                   | Usually ASCII, padded           |
0566   0169             ; | `s_feature_flags`     | Compatibility flags                      | 4                    | 32-bit unsigned int             |
0567   0169             ; superblock
0568   0169 B8 31 36 00   mov word[transient_area + 512 + 0], 2048
0568   016D 00 
0569   016E B8 33 36 00   mov word[transient_area + 512 + 2], $0000
0569   0172 00 
0570   0173 B8 35 36 00   mov word[transient_area + 512 + 4], $2800
0570   0177 00 
0571   0178 B8 37 36 00   mov word[transient_area + 512 + 6], $0000
0571   017C 00 
0572   017D             
0573   017D             ; ------------------------------------------------------------------------------------------------------------------;
0574   017D             ; floppy drive syscalls
0575   017D             ; ------------------------------------------------------------------------------------------------------------------;
0576   017D             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0577   017D             ; fdc_40_ff:
0578   017D             ;   .fill 40,  $ff    ; or 00                                                                                
0579   017D             ; fdc_128_format_inner:
0580   017D             ;   .fill 6,   $00    ;                                                                            <--|        
0581   017D             ;   .fill 1,   $fe    ; id address mark                                                               |        
0582   017D             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0583   017D             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0584   017D             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0585   017D             ;   .fill 1,   $00    ; sector length                                                                 |                        
0586   017D             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0587   017D             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0588   017D             ;   .fill 6,   $00    ;                                                                               |                        
0589   017D             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0590   017D             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0591   017D             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0592   017D             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0593   017D             ; fdc_128_format_end:
0594   017D             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0595   017D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0596   017D             fdc_jmptbl:
0597   017D A9 01         .dw syscall_fdc_restore
0598   017F B5 01         .dw syscall_fdc_step
0599   0181 BD 01         .dw syscall_fdc_step_in
0600   0183 C5 01         .dw syscall_fdc_step_out
0601   0185 CD 01         .dw syscall_fdc_seek
0602   0187 DB 01         .dw syscall_fdc_format_128
0603   0189 2F 02         .dw syscall_fdc_formatdisk_128
0604   018B 05 02         .dw syscall_fdc_format_512
0605   018D 71 02         .dw syscall_fdc_formatdisk_512
0606   018F D9 01         .dw syscall_fdc_read_addr
0607   0191 B3 02         .dw syscall_fdc_read_track
0608   0193 E2 02         .dw syscall_fdc_read_sect
0609   0195 1A 03         .dw syscall_fdc_write_sect
0610   0197 DA 01         .dw syscall_fdc_force_int
0611   0199 A1 01         .dw syscall_fdc_status0
0612   019B A5 01         .dw syscall_fdc_status1
0613   019D             syscall_fdc:
0614   019D FD 0A 7D 01   jmp [fdc_jmptbl + al]
0615   01A1             
0616   01A1             syscall_fdc_status0:
0617   01A1 1D C1 FF      mov al, [_fdc_status_0]
0618   01A4 06            sysret
0619   01A5             
0620   01A5             syscall_fdc_status1:
0621   01A5 1D C8 FF      mov al, [_fdc_stat_cmd]
0622   01A8 06            sysret
0623   01A9             
0624   01A9             syscall_fdc_restore:
0625   01A9 07 4B 03      call fdc_wait_not_busy
0626   01AC F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011
0627   01B0 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0628   01B4 06            sysret
0629   01B5             
0630   01B5             syscall_fdc_step:
0631   01B5 07 4B 03      call fdc_wait_not_busy
0632   01B8 F2 C8 FF 3B   mov byte [_fdc_stat_cmd], %00111011
0633   01BC 06            sysret
0634   01BD             
0635   01BD             syscall_fdc_step_in:
0636   01BD 07 4B 03      call fdc_wait_not_busy
0637   01C0 F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011
0638   01C4 06            sysret
0639   01C5             
0640   01C5             syscall_fdc_step_out:
0641   01C5 07 4B 03      call fdc_wait_not_busy
0642   01C8 F2 C8 FF 7B   mov byte [_fdc_stat_cmd], %01111011
0643   01CC 06            sysret
0644   01CD             
0645   01CD             ; bl: desired track
0646   01CD             syscall_fdc_seek:
0647   01CD 07 4B 03      call fdc_wait_not_busy
0648   01D0 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to bl
0649   01D4 F2 C8 FF 1B   mov byte [_fdc_stat_cmd], %00011011 ; seek command
0650   01D8 06            sysret
0651   01D9             
0652   01D9             syscall_fdc_read_addr:
0653   01D9 06            sysret
0654   01DA             
0655   01DA             syscall_fdc_force_int:
0656   01DA 06            sysret
0657   01DB             
0658   01DB             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0659   01DB             ; in the ram formatting block because they are all set as 00 right now
0660   01DB             ; bl: track number
0661   01DB             syscall_fdc_format_128:
0662   01DB 07 56 03      call fdc_format_mem_128
0663   01DE 07 4B 03      call fdc_wait_not_busy
0664   01E1 FD 3D C9 FF   mov [_fdc_track], bl
0665   01E5 FD 4D 31 34   mov si, transient_area
0666   01E9 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0667   01ED 07 2C 04      call fdc_wait_64us
0668   01F0             fdc_format_drq_128:
0669   01F0 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0670   01F3 93 01         test al, $01                ; 4
0671   01F5 C6 04 02      jz fdc_format_end_128           ; 8
0672   01F8 93 02         test al, $02                ; 4
0673   01FA C6 F0 01      jz fdc_format_drq_128           ; 8
0674   01FD F6            lodsb                       ; 7
0675   01FE 3D CB FF      mov [_fdc_data], al         ; 10   
0676   0201 0A F0 01      jmp fdc_format_drq_128
0677   0204             fdc_format_end_128:
0678   0204 06            sysret
0679   0205             
0680   0205             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0681   0205             ; in the ram formatting block because they are all set as 00 right now
0682   0205             ; bl: track number
0683   0205             syscall_fdc_format_512:
0684   0205 07 C1 03      call fdc_format_mem_512
0685   0208 07 4B 03      call fdc_wait_not_busy
0686   020B FD 3D C9 FF   mov [_fdc_track], bl
0687   020F FD 4D 31 34   mov si, transient_area
0688   0213 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0689   0217 07 2C 04      call fdc_wait_64us
0690   021A             fdc_format_drq_512:
0691   021A 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0692   021D 93 01         test al, $01                ; 4
0693   021F C6 2E 02      jz fdc_format_end_512           ; 8
0694   0222 93 02         test al, $02                ; 4
0695   0224 C6 1A 02      jz fdc_format_drq_512           ; 8
0696   0227 F6            lodsb                       ; 7
0697   0228 3D CB FF      mov [_fdc_data], al         ; 10   
0698   022B 0A 1A 02      jmp fdc_format_drq_512
0699   022E             fdc_format_end_512:
0700   022E 06            sysret
0701   022F             
0702   022F             syscall_fdc_formatdisk_128:
0703   022F 2E 00         mov bl, 0
0704   0231             fdc_formatdisk128_l0:
0705   0231 07 56 03      call fdc_format_mem_128
0706   0234 07 4B 03      call fdc_wait_not_busy
0707   0237 FD 3D C9 FF   mov [_fdc_track], bl
0708   023B FD 4D 31 34   mov si, transient_area
0709   023F F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command
0710   0243 07 2C 04      call fdc_wait_64us
0711   0246             fdc_formatdisk_drq_128:
0712   0246 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0713   0249 93 01         test al, $01                ; 4
0714   024B C6 5A 02      jz fdc_formatdisk_end_128           ; 8
0715   024E 93 02         test al, $02                ; 4
0716   0250 C6 46 02      jz fdc_formatdisk_drq_128           ; 8
0717   0253 F6            lodsb                       ; 7
0718   0254 3D CB FF      mov [_fdc_data], al         ; 10   
0719   0257 0A 46 02      jmp fdc_formatdisk_drq_128
0720   025A             fdc_formatdisk_end_128:
0721   025A 07 4B 03      call fdc_wait_not_busy
0722   025D D8            push b
0723   025E 26 08 00      mov b, 8
0724   0261 07 33 04      call wait_xs
0725   0264 F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011  ; step in
0726   0268 E5            pop b
0727   0269 6C 01         add bl, 1
0728   026B C1 28         cmp bl, 40
0729   026D C7 31 02      jne fdc_formatdisk128_l0
0730   0270 06            sysret
0731   0271             
0732   0271             syscall_fdc_formatdisk_512:
0733   0271 2E 00         mov bl, 0
0734   0273             fdc_formatdisk512_l0:
0735   0273 07 C1 03      call fdc_format_mem_512
0736   0276 07 4B 03      call fdc_wait_not_busy
0737   0279 FD 3D C9 FF   mov [_fdc_track], bl
0738   027D FD 4D 31 34   mov si, transient_area
0739   0281 F2 C8 FF F2   mov byte [_fdc_stat_cmd], %11110010 ; write track command
0740   0285 07 2C 04      call fdc_wait_64us
0741   0288             fdc_formatdisk_drq_512:
0742   0288 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0743   028B 93 01         test al, $01                ; 4
0744   028D C6 9C 02      jz fdc_formatdisk_end_512           ; 8
0745   0290 93 02         test al, $02                ; 4
0746   0292 C6 88 02      jz fdc_formatdisk_drq_512           ; 8
0747   0295 F6            lodsb                       ; 7
0748   0296 3D CB FF      mov [_fdc_data], al         ; 10   
0749   0299 0A 88 02      jmp fdc_formatdisk_drq_512
0750   029C             fdc_formatdisk_end_512:
0751   029C 07 4B 03      call fdc_wait_not_busy
0752   029F D8            push b
0753   02A0 26 08 00      mov b, 8
0754   02A3 07 33 04      call wait_xs
0755   02A6 F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011   ; step in
0756   02AA E5            pop b
0757   02AB 6C 01         add bl, 1
0758   02AD C1 28         cmp bl, 40
0759   02AF C7 73 02      jne fdc_formatdisk512_l0
0760   02B2 06            sysret
0761   02B3             
0762   02B3             ; di : destination in user space
0763   02B3             ; a  : returns number of read bytes
0764   02B3             syscall_fdc_read_track:
0765   02B3 07 4B 03      call fdc_wait_not_busy
0766   02B6 E3            push di
0767   02B7 FD 4F 31 34   mov di, transient_area
0768   02BB F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0769   02BF 07 2C 04      call fdc_wait_64us
0770   02C2             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0771   02C2 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0772   02C5 93 01         test al, $01                ; check busy bit
0773   02C7 C6 D6 02      jz fdc_read_track_end
0774   02CA 93 02         test al, $02                ; check drq bit
0775   02CC C6 C2 02      jz fdc_read_track_l0
0776   02CF 1D CB FF      mov al, [_fdc_data]     ; 
0777   02D2 F7            stosb
0778   02D3 0A C2 02      jmp fdc_read_track_l0
0779   02D6             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0780   02D6             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0781   02D6             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0782   02D6             fdc_read_track_end:
0783   02D6 50            mov a, di
0784   02D7 5F 31 34      sub a, transient_area
0785   02DA F0            pop di
0786   02DB FD 4D 31 34   mov si, transient_area
0787   02DF 39            mov c, a  ; copy track over to user space
0788   02E0 03            store
0789   02E1 06            sysret
0790   02E2             
0791   02E2             ; sector in bl
0792   02E2             ; track in bh
0793   02E2             ; di = user space destination
0794   02E2             syscall_fdc_read_sect:
0795   02E2 07 4B 03      call fdc_wait_not_busy
0796   02E5 E3            push di
0797   02E6 FD 3D CA FF   mov [_fdc_sector], bl
0798   02EA 30            mov bl, bh
0799   02EB FD 3D C9 FF   mov [_fdc_track], bl
0800   02EF F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0801   02F3 07 2C 04      call fdc_wait_64us
0802   02F6 FD 4F 31 34   mov di, transient_area
0803   02FA             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0804   02FA 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0805   02FD 93 01         test al, $01                ; check drq bit
0806   02FF C6 0E 03      jz fdc_read_sect_end
0807   0302 93 02         test al, $02                ; check drq bit
0808   0304 C6 FA 02      jz fdc_read_sect_l0
0809   0307 1D CB FF      mov al, [_fdc_data]     ; 
0810   030A F7            stosb
0811   030B 0A FA 02      jmp fdc_read_sect_l0
0812   030E             fdc_read_sect_end:
0813   030E 50            mov a, di
0814   030F 5F 31 34      sub a, transient_area
0815   0312 F0            pop di
0816   0313 FD 4D 31 34   mov si, transient_area
0817   0317 39            mov c, a  ; copy sector over to user space
0818   0318 03            store
0819   0319 06            sysret
0820   031A             
0821   031A             ; sector size in c
0822   031A             ; sector in bl
0823   031A             ; track in bh
0824   031A             ; data pointer in si
0825   031A             syscall_fdc_write_sect:
0826   031A 07 4B 03      call fdc_wait_not_busy
0827   031D FD 3D CA FF   mov [_fdc_sector], bl
0828   0321 30            mov bl, bh
0829   0322 FD 3D C9 FF   mov [_fdc_track], bl
0830   0326 FD 4F 31 34   mov di, transient_area    ; si = data source, di = destination 
0831   032A 04            load                    ; transfer data to kernel space!
0832   032B FD 4D 31 34   mov si, transient_area
0833   032F F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0834   0333 07 2C 04      call fdc_wait_64us
0835   0336             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0836   0336 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0837   0339 93 01         test al, $01                    ; 4
0838   033B C6 4A 03      jz fdc_write_sect_end           ; 8
0839   033E 93 02         test al, $02                    ; 4
0840   0340 C6 36 03      jz fdc_write_sect_l0            ; 8
0841   0343 F6            lodsb                           ; 7
0842   0344 3D CB FF      mov [_fdc_data], al             ; 10   
0843   0347 0A 36 03      jmp fdc_write_sect_l0
0844   034A             fdc_write_sect_end:
0845   034A 06            sysret
0846   034B             
0847   034B             fdc_wait_not_busy:
0848   034B DB            push al
0849   034C             fdc_wait_not_busy_l0:
0850   034C 1D C8 FF      mov al, [_fdc_stat_cmd]   
0851   034F 93 01         test al, $01               
0852   0351 C7 4C 03      jnz fdc_wait_not_busy_l0          
0853   0354 E8            pop al
0854   0355 09            ret
0855   0356             
0856   0356             ; track number in bl
0857   0356             fdc_format_mem_128:
0858   0356 3B 01 00      mov d, 1
0859   0359 FD 4F 31 34   mov di, transient_area
0860   035D             ; 40 * FF
0861   035D 38 28 00      mov c, 40
0862   0360 19 FF         mov al, $ff
0863   0362             fdc_l0: 
0864   0362 F7            stosb
0865   0363 7E            dec c
0866   0364 C7 62 03      jnz fdc_l0
0867   0367             ; 6 * 00
0868   0367             fdc_inner_loop:
0869   0367 38 06 00      mov c, 6
0870   036A 19 00         mov al, $00
0871   036C             fdc_l1:
0872   036C F7            stosb
0873   036D 7E            dec c
0874   036E C7 6C 03      jnz fdc_l1
0875   0371             ; FE address mark
0876   0371             fdc_l2:
0877   0371 19 FE         mov al, $fe
0878   0373 F7            stosb
0879   0374             ; track number
0880   0374             fdc_l3:
0881   0374 1B            mov al, bl  ; track number in bl
0882   0375 F7            stosb
0883   0376             ; side number
0884   0376             fdc_l4:
0885   0376 19 00         mov al, $00
0886   0378 F7            stosb
0887   0379             ; sector number
0888   0379             fdc_l5:
0889   0379 13            mov a, d
0890   037A F7            stosb
0891   037B             ; sector length 128 bytes
0892   037B             fdc_l6:
0893   037B 19 00         mov al, $00
0894   037D F7            stosb
0895   037E             ; 2 crc's
0896   037E             fdc_l7:
0897   037E 19 F7         mov al, $f7
0898   0380 F7            stosb
0899   0381             ; 11 times $ff
0900   0381 38 0B 00      mov c, 11
0901   0384 19 FF         mov al, $ff
0902   0386             fdc_l8:
0903   0386 F7            stosb
0904   0387 7E            dec c
0905   0388 C7 86 03      jnz fdc_l8
0906   038B             ; 6 times 00
0907   038B 38 06 00      mov c, 6
0908   038E 19 00         mov al, $00
0909   0390             fdc_l9:
0910   0390 F7            stosb
0911   0391 7E            dec c
0912   0392 C7 90 03      jnz fdc_l9
0913   0395             ; FB data address mark
0914   0395 19 FB         mov al, $fb
0915   0397             fdc_l10:
0916   0397 F7            stosb
0917   0398             ; 128 bytes sector data
0918   0398 38 80 00      mov c, 128
0919   039B 19 E5         mov al, $E5
0920   039D             fdc_l11:
0921   039D F7            stosb
0922   039E 7E            dec c
0923   039F C7 9D 03      jnz fdc_l11
0924   03A2             ; 2 crc's
0925   03A2             fdc_l12:
0926   03A2 19 F7         mov al, $f7
0927   03A4 F7            stosb
0928   03A5             ; 10 * $FF
0929   03A5 38 0A 00      mov c, 10
0930   03A8 19 FF         mov al, $ff
0931   03AA             fdc_l13:
0932   03AA F7            stosb
0933   03AB 7E            dec c
0934   03AC C7 AA 03      jnz fdc_l13
0935   03AF             ; check whether we did this 16 times
0936   03AF 79            inc d
0937   03B0 C5 11 00      cmp d, 17
0938   03B3 C7 67 03      jne fdc_inner_loop
0939   03B6             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0940   03B6 38 F4 01      mov c, 500
0941   03B9 19 FF         mov al, $ff
0942   03BB             fdc_format_footer:
0943   03BB             fdc_footer_drq_loop:
0944   03BB F7            stosb
0945   03BC 7E            dec c
0946   03BD C7 BB 03      jnz fdc_footer_drq_loop
0947   03C0 09            ret
0948   03C1             
0949   03C1             ; track number in bl
0950   03C1             fdc_format_mem_512:
0951   03C1 3B 01 00      mov d, 1
0952   03C4 FD 4F 31 34   mov di, transient_area
0953   03C8             ; 40 * FF
0954   03C8 38 28 00      mov c, 40
0955   03CB 19 FF         mov al, $ff
0956   03CD             fdc_512_l0: 
0957   03CD F7            stosb
0958   03CE 7E            dec c
0959   03CF C7 CD 03      jnz fdc_512_l0
0960   03D2             ; 6 * 00
0961   03D2             fdc_512_inner_loop:
0962   03D2 38 06 00      mov c, 6
0963   03D5 19 00         mov al, $00
0964   03D7             fdc_512_l1:
0965   03D7 F7            stosb
0966   03D8 7E            dec c
0967   03D9 C7 D7 03      jnz fdc_512_l1
0968   03DC             ; FE address mark
0969   03DC             fdc_512_l2:
0970   03DC 19 FE         mov al, $fe
0971   03DE F7            stosb
0972   03DF             ; track number
0973   03DF             fdc_512_l3:
0974   03DF 1B            mov al, bl ; track number was in bl
0975   03E0 F7            stosb
0976   03E1             ; side number
0977   03E1             fdc_512_l4:
0978   03E1 19 00         mov al, $00
0979   03E3 F7            stosb
0980   03E4             ; sector number
0981   03E4             fdc_512_l5:
0982   03E4 13            mov a, d
0983   03E5 F7            stosb
0984   03E6             ; sector length 512 bytes
0985   03E6             fdc_512_l6:
0986   03E6 19 02         mov al, $02
0987   03E8 F7            stosb
0988   03E9             ; 2 crc's
0989   03E9             fdc_512_l7:
0990   03E9 19 F7         mov al, $f7
0991   03EB F7            stosb
0992   03EC             ; 11 times $ff
0993   03EC 38 0B 00      mov c, 11
0994   03EF 19 FF         mov al, $ff
0995   03F1             fdc_512_l8:
0996   03F1 F7            stosb
0997   03F2 7E            dec c
0998   03F3 C7 F1 03      jnz fdc_512_l8
0999   03F6             ; 6 times 00
1000   03F6 38 06 00      mov c, 6
1001   03F9 19 00         mov al, $00
1002   03FB             fdc_512_l9:
1003   03FB F7            stosb
1004   03FC 7E            dec c
1005   03FD C7 FB 03      jnz fdc_512_l9
1006   0400             ; FB data address mark
1007   0400 19 FB         mov al, $fb
1008   0402             fdc_512_l10:
1009   0402 F7            stosb
1010   0403             ; 128 bytes sector data
1011   0403 38 00 02      mov c, 512
1012   0406 19 E5         mov al, $E5
1013   0408             fdc_512_l11:
1014   0408 F7            stosb
1015   0409 7E            dec c
1016   040A C7 08 04      jnz fdc_512_l11
1017   040D             ; 2 crc's
1018   040D             fdc_512_l12:
1019   040D 19 F7         mov al, $f7
1020   040F F7            stosb
1021   0410             ; 10 * $FF
1022   0410 38 0A 00      mov c, 10
1023   0413 19 FF         mov al, $ff
1024   0415             fdc_512_l13:
1025   0415 F7            stosb
1026   0416 7E            dec c
1027   0417 C7 15 04      jnz fdc_512_l13
1028   041A             ; check whether we did this 16 times
1029   041A 79            inc d
1030   041B C5 06 00      cmp d, 6
1031   041E C7 D2 03      jne fdc_512_inner_loop
1032   0421             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
1033   0421 38 F4 01      mov c, 500
1034   0424 19 FF         mov al, $ff
1035   0426             fdc_512_format_footer:
1036   0426             fdc_512_footer_drq_loop:
1037   0426 F7            stosb
1038   0427 7E            dec c
1039   0428 C7 26 04      jnz fdc_512_footer_drq_loop
1040   042B 09            ret
1041   042C             
1042   042C             ; fetch is 2 cycles long when 'display_reg_load' is false.
1043   042C             ; 64us amounts to 160 cycles of the 2.5mhz clock
1044   042C             ; call u16 is 14 cycles long
1045   042C             ; 160 - 5 - 14 = 
1046   042C             fdc_wait_64us:
1047   042C 3A 0D         mov cl, 13                       ; 5 cycles
1048   042E             fdc_wait_64_loop:
1049   042E 81            dec cl                           ; 3 cycles
1050   042F C7 2E 04      jnz fdc_wait_64_loop             ; 8 cycles
1051   0432 09            ret
1052   0433             
1053   0433             ; number of seconds in b
1054   0433             wait_xs:
1055   0433 C0 00 00      cmp b, 0
1056   0436 C6 41 04      je wait_xs_end
1057   0439 07 42 04      call wait_1s
1058   043C FD 7D         dec b
1059   043E 0A 33 04      jmp wait_xs
1060   0441             wait_xs_end:
1061   0441 09            ret
1062   0442             
1063   0442             wait_1s:
1064   0442 DB            push al
1065   0443 D9            push c
1066   0444 19 03         mov al, 3
1067   0446             wait_1s_l0:
1068   0446 38 FF FF      mov c, 65535                       
1069   0449             wait_1s_l1:
1070   0449 7E            dec c        ; 4
1071   044A C7 49 04      jnz wait_1s_l1   ; 8
1072   044D 80            dec al
1073   044E C7 46 04      jnz wait_1s_l0
1074   0451 E6            pop c
1075   0452 E8            pop al
1076   0453 09            ret
1077   0454             
1078   0454             ; ------------------------------------------------------------------------------------------------------------------;
1079   0454             ; system syscalls
1080   0454             ; ------------------------------------------------------------------------------------------------------------------;
1081   0454             system_jmptbl:
1082   0454 8A 04         .dw system_uname
1083   0456 91 04         .dw system_whoami
1084   0458 64 04         .dw system_poke
1085   045A 67 04         .dw system_bootloader_install
1086   045C 62 04         .dw system_peek
1087   045E             syscall_system:
1088   045E FD 0A 54 04   jmp [system_jmptbl + al]
1089   0462             
1090   0462             ; param register address in register d
1091   0462             ; param value in register bl
1092   0462             system_peek:
1093   0462 32            mov bl, [d]
1094   0463 06            sysret
1095   0464             
1096   0464             ; param register address in register d
1097   0464             ; param value in register bl
1098   0464             system_poke:
1099   0464 FD 3E         mov [d], bl
1100   0466 06            sysret
1101   0467             
1102   0467             ; kernel LBA address in 'b'
1103   0467             system_bootloader_install:
1104   0467 D8            push b
1105   0468 26 00 00      mov b, 0
1106   046B 38 00 00      mov c, 0
1107   046E 22 01         mov ah, $01                 ; 1 sector
1108   0470 3B 31 34      mov d, transient_area
1109   0473 07 8E 07      call ide_read_sect          ; read sector
1110   0476 E5            pop b
1111   0477 FD 44 FE 01   mov [d + 510], b            ; update LBA address
1112   047B 26 00 00      mov b, 0
1113   047E 38 00 00      mov c, 0
1114   0481 22 01         mov ah, $01                 ; 1 sector
1115   0483 3B 31 34      mov d, transient_area
1116   0486 07 B4 07      call ide_write_sect         ; write sector
1117   0489 06            sysret
1118   048A             
1119   048A             system_uname:
1120   048A 3B 3B 1A      mov d, s_uname
1121   048D 07 EF 14      call _puts
1122   0490 06            sysret
1123   0491             
1124   0491             system_whoami:
1125   0491 06            sysret
1126   0492             
1127   0492             ; reboot system
1128   0492             syscall_reboot:
1129   0492 FD D7 FF FF   push word $ffff 
1130   0496 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
1131   0499 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
1132   049D 06            sysret
1133   049E             
1134   049E             ;------------------------------------------------------------------------------------------------------;;
1135   049E             ; switch to another process
1136   049E             ; inputs:
1137   049E             ; al = new process number
1138   049E             ;------------------------------------------------------------------------------------------------------;;
1139   049E             syscall_resume_proc:
1140   049E FD 78         mov g, a                            ; save the process number
1141   04A0 4B            pusha                               ; save all registers into kernel stack
1142   04A1 22 00         mov ah, 0
1143   04A3 1D 25 1A      mov al, [active_proc_index]
1144   04A6 FD 99         shl a              ; x2
1145   04A8 B7 5D 12      mov a, [proc_table_convert + a]     ; get process state start index
1146   04AB 4F            mov di, a
1147   04AC 48            mov a, sp
1148   04AD 77            inc a
1149   04AE 4D            mov si, a
1150   04AF 38 14 00      mov c, 20
1151   04B2 FD F5         rep movsb                           ; save process state!
1152   04B4             ; restore kernel stack position to point before interrupt arrived
1153   04B4 51 14 00      add sp, 20
1154   04B7             ; now load the new process number!
1155   04B7 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
1156   04B9 3D 25 1A      mov [active_proc_index], al         ; set new active proc
1157   04BC             ; calculate lut entry for next process
1158   04BC 22 00         mov ah, 0
1159   04BE FD 99         shl a                               ; x2
1160   04C0 B7 5D 12      mov a, [proc_table_convert + a]     ; get process state start index  
1161   04C3 4D            mov si, a                           ; source is proc state block
1162   04C4 48            mov a, sp
1163   04C5 5F 13 00      sub a, 19
1164   04C8 4F            mov di, a                           ; destination is kernel stack
1165   04C9             ; restore sp
1166   04C9 7D            dec a
1167   04CA 47            mov sp, a
1168   04CB 38 14 00      mov c, 20
1169   04CE FD F5         rep movsb
1170   04D0             ; set vm process
1171   04D0 1D 25 1A      mov al, [active_proc_index]
1172   04D3 01            setptb
1173   04D4 4C            popa
1174   04D5 06            sysret
1175   04D6             
1176   04D6             ;------------------------------------------------------------------------------------------------------;;
1177   04D6             ; list processes
1178   04D6             ;------------------------------------------------------------------------------------------------------;;
1179   04D6             syscall_list_procs:
1180   04D6 3B 5C 1A      mov d, s_ps_header
1181   04D9 07 EF 14      call _puts
1182   04DC 3B A2 1D      mov d, proc_availab_table + 1
1183   04DF 38 01 00      mov c, 1
1184   04E2             list_procs_l0:  
1185   04E2 BD 01         cmp byte[d], 1
1186   04E4 C7 08 05      jne list_procs_next
1187   04E7 2D            mov b, d
1188   04E8 61 A1 1D      sub b, proc_availab_table
1189   04EB FD 9F 05      shl b, 5
1190   04EE DA            push d
1191   04EF D8            push b
1192   04F0 28            mov b, c
1193   04F1 07 8F 15      call print_u8x
1194   04F4 22 20         mov ah, ' '
1195   04F6 07 C3 13      call _putchar
1196   04F9 07 C3 13      call _putchar
1197   04FC E5            pop b
1198   04FD 74            mov d, b
1199   04FE 58 B1 1D      add d, proc_names
1200   0501 07 EF 14      call _puts
1201   0504 07 9C 14      call printnl
1202   0507 E7            pop d
1203   0508             list_procs_next:
1204   0508 79            inc d
1205   0509 78            inc c
1206   050A C2 09 00      cmp c, 9
1207   050D C7 E2 04      jne list_procs_l0
1208   0510             list_procs_end:
1209   0510 06            sysret
1210   0511             
1211   0511             ; ------------------------------------------------------------------------------------------------------------------;
1212   0511             ; exceptions code block
1213   0511             ; ------------------------------------------------------------------------------------------------------------------;
1214   0511             ; privilege exception
1215   0511             ; ------------------------------------------------------------------------------------------------------------------;
1216   0511             trap_privilege:
1217   0511 0A 92 04      jmp syscall_reboot
1218   0514 DA            push d
1219   0515 3B 52 1B      mov d, s_priviledge
1220   0518 07 EF 14      call _puts
1221   051B E7            pop d
1222   051C 06            sysret
1223   051D             
1224   051D             ; ------------------------------------------------------------------------------------------------------------------;
1225   051D             ; breakpoint
1226   051D             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
1227   051D             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
1228   051D             ; ------------------------------------------------------------------------------------------------------------------;
1229   051D             syscall_break:
1230   051D 4B            pusha
1231   051E             syscall_break_prompt:
1232   051E 3B D8 05      mov d, s_break1
1233   0521 07 EF 14      call _puts
1234   0524 07 9C 14      call printnl
1235   0527 07 F1 15      call scan_u16d
1236   052A AF 00 00      cmp a, 0
1237   052D C6 38 05      je syscall_break_regs
1238   0530 AF 01 00      cmp a, 1
1239   0533 C6 5B 05      je syscall_break_mem
1240   0536             syscall_break_end:  
1241   0536 4C            popa
1242   0537 06            sysret
1243   0538             syscall_break_regs:
1244   0538 48            mov a, sp
1245   0539 53 0E 00      add a, 14               ; back-track 7 registers
1246   053C 3C            mov d, a
1247   053D 3A 07         mov cl, 7
1248   053F             syscall_regs_l0:
1249   053F 2A            mov b, [d]
1250   0540 FD AB         swp b
1251   0542 07 4B 15      call print_u16x         ; print register value
1252   0545 07 9C 14      call printnl
1253   0548 63 02 00      sub d, 2
1254   054B 71 01         sub cl, 1
1255   054D C3 00         cmp cl, 0
1256   054F C7 3F 05      jne syscall_regs_l0
1257   0552 0A 1E 05      jmp syscall_break_prompt
1258   0555 07 9C 14      call printnl
1259   0558 0A 1E 05      jmp syscall_break_prompt
1260   055B             syscall_break_mem:
1261   055B 07 9C 14      call printnl
1262   055E 07 6D 15      call scan_u16x
1263   0561 4D            mov si, a               ; data source from user space
1264   0562 FD 4F 31 32   mov di, scrap_sector    ; destination in kernel space
1265   0566 38 00 02      mov c, 512
1266   0569 04            load                    ; transfer data to kernel space!
1267   056A 3B 31 32      mov d, scrap_sector     ; dump pointer in d
1268   056D 38 00 00      mov c, 0
1269   0570             dump_loop:
1270   0570 84            mov al, cl
1271   0571 87 0F         and al, $0f
1272   0573 C6 C1 05      jz print_base
1273   0576             back:
1274   0576 1E            mov al, [d]             ; read byte
1275   0577 2F            mov bl, al
1276   0578 07 8F 15      call print_u8x
1277   057B 10 00 20      mov a, $2000
1278   057E 05 03         syscall sys_io          ; space
1279   0580 84            mov al, cl
1280   0581 87 0F         and al, $0f
1281   0583 B9 0F         cmp al, $0f
1282   0585 C6 96 05      je print_ascii
1283   0588             back1:
1284   0588 79            inc d
1285   0589 78            inc c
1286   058A C2 00 02      cmp c, 512
1287   058D C7 70 05      jne dump_loop
1288   0590 07 9C 14      call printnl
1289   0593 0A 1E 05      jmp syscall_break_prompt  ; go to syscall_break return point
1290   0596             print_ascii:
1291   0596 10 00 20      mov a, $2000
1292   0599 05 03         syscall sys_io
1293   059B 63 10 00      sub d, 16
1294   059E 26 10 00      mov b, 16
1295   05A1             print_ascii_l:
1296   05A1 79            inc d
1297   05A2 1E            mov al, [d]               ; read byte
1298   05A3 B9 20         cmp al, $20
1299   05A5 C8 AD 05      jlu dot
1300   05A8 B9 7E         cmp al, $7e
1301   05AA D0 B5 05      jleu ascii
1302   05AD             dot:
1303   05AD 10 00 2E      mov a, $2e00
1304   05B0 05 03         syscall sys_io
1305   05B2 0A BA 05      jmp ascii_continue
1306   05B5             ascii:
1307   05B5 23            mov ah, al
1308   05B6 19 00         mov al, 0
1309   05B8 05 03         syscall sys_io
1310   05BA             ascii_continue:
1311   05BA FD A9 A1 05   loopb print_ascii_l
1312   05BE 0A 88 05      jmp back1
1313   05C1             print_base:
1314   05C1 07 9C 14      call printnl
1315   05C4 2D            mov b, d
1316   05C5 61 31 32      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
1317   05C8 07 4B 15      call print_u16x          ; display row
1318   05CB 10 00 3A      mov a, $3a00
1319   05CE 05 03         syscall sys_io
1320   05D0 10 00 20      mov a, $2000
1321   05D3 05 03         syscall sys_io
1322   05D5 0A 76 05      jmp back
1323   05D8             
1324   05D8             s_break1:  
1325   05D8 0A 64 65 62   .db "\ndebugger entry point.\n"
1325   05DC 75 67 67 65 
1325   05E0 72 20 65 6E 
1325   05E4 74 72 79 20 
1325   05E8 70 6F 69 6E 
1325   05EC 74 2E 0A 
1326   05EF 30 2E 20 73   .db "0. show registers\n"
1326   05F3 68 6F 77 20 
1326   05F7 72 65 67 69 
1326   05FB 73 74 65 72 
1326   05FF 73 0A 
1327   0601 31 2E 20 73   .db "1. show 512b ram block\n"
1327   0605 68 6F 77 20 
1327   0609 35 31 32 62 
1327   060D 20 72 61 6D 
1327   0611 20 62 6C 6F 
1327   0615 63 6B 0A 
1328   0618 32 2E 20 63   .db "2. continue execution", 0
1328   061C 6F 6E 74 69 
1328   0620 6E 75 65 20 
1328   0624 65 78 65 63 
1328   0628 75 74 69 6F 
1328   062C 6E 00 
1329   062E             
1330   062E             ; ------------------------------------------------------------------------------------------------------------------;
1331   062E             ; divide by zero exception
1332   062E             ; ------------------------------------------------------------------------------------------------------------------;
1333   062E             trap_div_zero:
1334   062E D7            push a
1335   062F DA            push d
1336   0630 E1            pushf
1337   0631 3B 69 1B      mov d, s_divzero
1338   0634 07 EF 14      call _puts
1339   0637 EE            popf
1340   0638 E7            pop d
1341   0639 E4            pop a
1342   063A 06            sysret ; enable interrupts
1343   063B             
1344   063B             ; ------------------------------------------------------------------------------------------------------------------;
1345   063B             ; undefined opcode exception
1346   063B             ; ------------------------------------------------------------------------------------------------------------------;
1347   063B             trap_undef_opcode:
1348   063B 06            sysret
1349   063C             
1350   063C             ; ------------------------------------------------------------------------------------------------------------------;
1351   063C             ; real-time clock services syscall
1352   063C             ; rtc i/o bank = ffa0 to ffaf
1353   063C             ; ffa0 to ffa7 is scratch ram
1354   063C             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
1355   063C             ; al = 0..6 -> get
1356   063C             ; al = 7..d -> set
1357   063C             ; ------------------------------------------------------------------------------------------------------------------;
1358   063C             syscall_rtc:
1359   063C DB            push al
1360   063D DA            push d
1361   063E B9 06         cmp al, 6
1362   0640 D1 55 06      jgu syscall_rtc_set
1363   0643             syscall_rtc_get:
1364   0643 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
1365   0645 22 FF         mov ah, $ff    
1366   0647 3C            mov d, a                ; get to ffa9 + offset
1367   0648 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
1368   064C 1E            mov al, [d]             ; get data
1369   064D F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
1370   0651 23            mov ah, al
1371   0652 E7            pop d
1372   0653 E8            pop al
1373   0654 06            sysret
1374   0655             syscall_rtc_set:
1375   0655 DD            push bl
1376   0656 99            mov bl, ah              ; set data aside
1377   0657 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
1378   0659 22 FF         mov ah, $ff    
1379   065B 3C            mov d, a                ; get to ffa9 + offset
1380   065C 1B            mov al, bl              ; get data back
1381   065D F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
1382   0661 3E            mov [d], al             ; set data
1383   0662 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
1384   0666 EA            pop bl
1385   0667 E7            pop d
1386   0668 E8            pop al
1387   0669 06            sysret
1388   066A             
1389   066A             datetime_serv_tbl:
1390   066A 72 06         .dw print_date
1391   066C E6 06         .dw set_date
1392   066E             syscall_datetime:
1393   066E FD 0A 6A 06   jmp [datetime_serv_tbl + al]      
1394   0672             print_date:
1395   0672 10 00 0D      mov a, $0d00           ; print carriage return char
1396   0675 19 03         mov al, 3
1397   0677 05 01         syscall sys_rtc        ; get week
1398   0679 1A            mov al, ah
1399   067A 22 00         mov ah, 0
1400   067C FD 9D 02      shl a, 2          
1401   067F 3B F3 1B      mov d, s_week
1402   0682 59            add d, a
1403   0683 07 EF 14      call _puts
1404   0686 10 00 20      mov a, $2000
1405   0689 05 03         syscall sys_io         ; display ' '
1406   068B 19 04         mov al, 4
1407   068D 05 01         syscall sys_rtc        ; get day
1408   068F 99            mov bl, ah
1409   0690 07 8F 15      call print_u8x
1410   0693 10 00 20      mov a, $2000
1411   0696 05 03         syscall sys_io         ; display ' '
1412   0698             ; there is a problem with the month displaying
1413   0698             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
1414   0698             ; even though it is to be understood as bcd.
1415   0698             ; when retrieving the value and adding the string table address offset the value will go overboard!  
1416   0698 19 05         mov al, 05
1417   069A 05 01         syscall sys_rtc        ; get month
1418   069C 1A            mov al, ah
1419   069D 22 00         mov ah, 0
1420   069F FD 9D 02      shl a, 2          
1421   06A2 3B BF 1B      mov d, s_months
1422   06A5 59            add d, a
1423   06A6 07 EF 14      call _puts
1424   06A9 10 00 20      mov a, $2000
1425   06AC 05 03         syscall sys_io         ; display ' '
1426   06AE 2E 20         mov bl, $20
1427   06B0 07 8F 15      call print_u8x         ; print 20 for year prefix
1428   06B3 19 06         mov al, 06
1429   06B5 05 01         syscall sys_rtc        ; get year
1430   06B7 99            mov bl, ah
1431   06B8 07 8F 15      call print_u8x
1432   06BB 10 00 20      mov a, $2000  
1433   06BE 05 03         syscall sys_io         ; display ' '
1434   06C0 19 02         mov al, 2
1435   06C2 05 01         syscall sys_rtc        ; get hours
1436   06C4 99            mov bl, ah
1437   06C5 07 8F 15      call print_u8x
1438   06C8 10 00 3A      mov a, $3a00    
1439   06CB 05 03         syscall sys_io         ; display ':'
1440   06CD 19 01         mov al, 01
1441   06CF 05 01         syscall sys_rtc        ; get minutes
1442   06D1 99            mov bl, ah
1443   06D2 07 8F 15      call print_u8x
1444   06D5 10 00 3A      mov a, $3a00  
1445   06D8 05 03         syscall sys_io         ; display ':'
1446   06DA 19 00         mov al, 0
1447   06DC 05 01         syscall sys_rtc        ; get seconds
1448   06DE 99            mov bl, ah
1449   06DF 07 8F 15      call print_u8x
1450   06E2 07 9C 14      call printnl
1451   06E5 06            sysret
1452   06E6             set_date:
1453   06E6 3B 84 1B      mov d, s_set_year
1454   06E9 07 EF 14      call _puts
1455   06EC 07 DA 15      call scan_u8x          ; read integer into a
1456   06EF FD 9D 08      shl a, 8               ; only al used, move to ah
1457   06F2 19 0D         mov al, 0dh            ; set rtc year
1458   06F4 05 01         syscall sys_rtc        ; set rtc
1459   06F6 3B 8B 1B      mov d, s_set_month
1460   06F9 07 EF 14      call _puts
1461   06FC 07 DA 15      call scan_u8x          ; read integer into a
1462   06FF FD 9D 08      shl a, 8               ; only al used, move to ah
1463   0702 19 0C         mov al, 0ch            ; set rtc month
1464   0704 05 01         syscall sys_rtc        ; set rtc
1465   0706 3B 93 1B      mov d, s_set_day
1466   0709 07 EF 14      call _puts
1467   070C 07 DA 15      call scan_u8x          ; read integer into a
1468   070F FD 9D 08      shl a, 8               ; only al used, move to ah
1469   0712 19 0B         mov al, 0bh            ; set rtc month
1470   0714 05 01         syscall sys_rtc        ; set rtc
1471   0716 3B 99 1B      mov d, s_set_week
1472   0719 07 EF 14      call _puts
1473   071C 07 DA 15      call scan_u8x          ; read integer into a
1474   071F FD 9D 08      shl a, 8               ; only al used, move to ah
1475   0722 19 0A         mov al, 0ah            ; set rtc month
1476   0724 05 01         syscall sys_rtc        ; set rtc
1477   0726 3B A3 1B      mov d, s_set_hours
1478   0729 07 EF 14      call _puts
1479   072C 07 DA 15      call scan_u8x          ; read integer into a
1480   072F FD 9D 08      shl a, 8               ; only al used, move to ah
1481   0732 19 09         mov al, 09h            ; set rtc month
1482   0734 05 01         syscall sys_rtc        ; set rtc
1483   0736 3B AB 1B      mov d, s_set_minutes
1484   0739 07 EF 14      call _puts
1485   073C 07 DA 15      call scan_u8x          ; read integer into a
1486   073F FD 9D 08      shl a, 8               ; only al used, move to ah
1487   0742 19 08         mov al, 08h            ; set rtc month
1488   0744 05 01         syscall sys_rtc        ; set rtc
1489   0746 3B B5 1B      mov d, s_set_seconds
1490   0749 07 EF 14      call _puts
1491   074C 07 DA 15      call scan_u8x          ; read integer into a
1492   074F FD 9D 08      shl a, 8               ; only al used, move to ah
1493   0752 19 07         mov al, 07h            ; set rtc month
1494   0754 05 01         syscall sys_rtc        ; set rtc
1495   0756 06            sysret
1496   0757             
1497   0757             ; ------------------------------------------------------------------------------------------------------------------;
1498   0757             ; ide services syscall
1499   0757             ; al = option
1500   0757             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1501   0757             ; ide read/write sector
1502   0757             ; 512 bytes
1503   0757             ; user buffer pointer in d
1504   0757             ; ah = number of sectors
1505   0757             ; cb = lba bytes 3..0
1506   0757             ; ------------------------------------------------------------------------------------------------------------------;
1507   0757             ide_serv_tbl:
1508   0757 63 07         .dw ide_reset
1509   0759 77 07         .dw ide_sleep
1510   075B 86 07         .dw ide_read_sect_wrapper
1511   075D 8A 07         .dw ide_write_sect_wrapper
1512   075F             syscall_ide:
1513   075F FD 0A 57 07   jmp [ide_serv_tbl + al]    
1514   0763             
1515   0763             ide_reset:      
1516   0763 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1517   0767 07 10 08      call ide_wait                   ; wait for ide ready             
1518   076A F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1519   076E F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1520   0772 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1521   0776 06            sysret
1522   0777             ide_sleep:
1523   0777 07 10 08      call ide_wait                   ; wait for ide ready             
1524   077A F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1525   077E F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1526   0782 07 10 08      call ide_wait                   ; wait for ide ready
1527   0785 06            sysret
1528   0786             ide_read_sect_wrapper:
1529   0786 07 8E 07      call ide_read_sect
1530   0789 06            sysret
1531   078A             ide_write_sect_wrapper:
1532   078A 07 B4 07      call ide_write_sect
1533   078D 06            sysret
1534   078E             ide_read_sect:
1535   078E 1A            mov al, ah
1536   078F 24            mov ah, bl
1537   0790 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1538   0793 1C            mov al, bh
1539   0794 3D D4 FF      mov [_ide_r4], al
1540   0797 12            mov a, c
1541   0798 3D D5 FF      mov [_ide_r5], al
1542   079B 1A            mov al, ah
1543   079C 87 0F         and al, %00001111
1544   079E 8B E0         or al, %11100000                ; mode lba, master
1545   07A0 3D D6 FF      mov [_ide_r6], al
1546   07A3             ide_read_sect_wait:
1547   07A3 1D D7 FF      mov al, [_ide_r7]  
1548   07A6 87 80         and al, $80                     ; busy flag
1549   07A8 C7 A3 07      jnz ide_read_sect_wait
1550   07AB 19 20         mov al, $20
1551   07AD 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1552   07B0 07 DA 07      call ide_read  
1553   07B3 09            ret
1554   07B4             ide_write_sect:
1555   07B4 1A            mov al, ah
1556   07B5 24            mov ah, bl
1557   07B6 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1558   07B9 1C            mov al, bh
1559   07BA 3D D4 FF      mov [_ide_r4], al
1560   07BD 12            mov a, c
1561   07BE 3D D5 FF      mov [_ide_r5], al
1562   07C1 1A            mov al, ah
1563   07C2 87 0F         and al, %00001111
1564   07C4 8B E0         or al, %11100000                ; mode lba, master
1565   07C6 3D D6 FF      mov [_ide_r6], al
1566   07C9             ide_write_sect_wait:
1567   07C9 1D D7 FF      mov al, [_ide_r7]  
1568   07CC 87 80         and al, $80                     ; busy flag
1569   07CE C7 C9 07      jnz ide_write_sect_wait
1570   07D1 19 30         mov al, $30
1571   07D3 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1572   07D6 07 F5 07      call ide_write      
1573   07D9 09            ret
1574   07DA             
1575   07DA             ;----------------------------------------------------------------------------------------------------;
1576   07DA             ; read ide data
1577   07DA             ; pointer in d
1578   07DA             ;----------------------------------------------------------------------------------------------------;
1579   07DA             ide_read:
1580   07DA DA            push d
1581   07DB             ide_read_loop:
1582   07DB 1D D7 FF      mov al, [_ide_r7]  
1583   07DE 87 80         and al, 80h                     ; busy flag
1584   07E0 C7 DB 07      jnz ide_read_loop               ; wait loop
1585   07E3 1D D7 FF      mov al, [_ide_r7]
1586   07E6 87 08         and al, %00001000               ; drq flag
1587   07E8 C6 F3 07      jz ide_read_end
1588   07EB 1D D0 FF      mov al, [_ide_r0]
1589   07EE 3E            mov [d], al
1590   07EF 79            inc d
1591   07F0 0A DB 07      jmp ide_read_loop
1592   07F3             ide_read_end:
1593   07F3 E7            pop d
1594   07F4 09            ret
1595   07F5             
1596   07F5             ;----------------------------------------------------------------------------------------------------;
1597   07F5             ; write ide data
1598   07F5             ; data pointer in d
1599   07F5             ;----------------------------------------------------------------------------------------------------;
1600   07F5             ide_write:
1601   07F5 DA            push d
1602   07F6             ide_write_loop:
1603   07F6 1D D7 FF      mov al, [_ide_r7]  
1604   07F9 87 80         and al, 80h             ; busy flag
1605   07FB C7 F6 07      jnz ide_write_loop      ; wait loop
1606   07FE 1D D7 FF      mov al, [_ide_r7]
1607   0801 87 08         and al, %00001000       ; drq flag
1608   0803 C6 0E 08      jz ide_write_end
1609   0806 1E            mov al, [d]
1610   0807 3D D0 FF      mov [_ide_r0], al
1611   080A 79            inc d 
1612   080B 0A F6 07      jmp ide_write_loop
1613   080E             ide_write_end:
1614   080E E7            pop d
1615   080F 09            ret
1616   0810             
1617   0810             ;----------------------------------------------------------------------------------------------------;
1618   0810             ; wait for ide to be ready
1619   0810             ;----------------------------------------------------------------------------------------------------;
1620   0810             ide_wait:
1621   0810 1D D7 FF      mov al, [_ide_r7]  
1622   0813 87 80         and al, 80h        ; busy flag
1623   0815 C7 10 08      jnz ide_wait
1624   0818 09            ret
1625   0819             
1626   0819             ;----------------------------------------------------------------------------------------------------;
1627   0819             ; io syscall
1628   0819             ;----------------------------------------------------------------------------------------------------;
1629   0819             ; baud  divisor
1630   0819             ; 50    2304
1631   0819             ; 110   1047
1632   0819             ; 300    384
1633   0819             ; 600    192
1634   0819             ; 1200    96
1635   0819             ; 9600    12
1636   0819             ; 19200    6
1637   0819             ; 38400    3
1638   0819             syscall_io_jmp:
1639   0819 74 08         .dw syscall_io_putchar
1640   081B 8D 08         .dw syscall_io_getch
1641   081D 23 08         .dw syscall_io_uart_setup
1642   081F             syscall_io:
1643   081F FD 0A 19 08   jmp [syscall_io_jmp + al]
1644   0823             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1645   0823             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1646   0823             ; buffer, the transmitter holding register, or the interrupt enable register.
1647   0823             syscall_io_uart_setup:
1648   0823 1D 1A 1A      mov al, [sys_uart0_lcr]
1649   0826 8B 80         or al, $80                ; set dlab access bit
1650   0828 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1651   082B 1D 1D 1A      mov al, [sys_uart0_div0]
1652   082E 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1653   0831 1D 1E 1A      mov al, [sys_uart0_div1]
1654   0834 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1655   0837 1D 1A 1A      mov al, [sys_uart0_lcr]
1656   083A 87 7F         and al, $7f               ; clear dlab access bit 
1657   083C 3D 83 FF      mov [_uart0_lcr], al
1658   083F 1D 1B 1A      mov al, [sys_uart0_inten]
1659   0842 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1660   0845 1D 1C 1A      mov al, [sys_uart0_fifoen]
1661   0848 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1662   084B             ; uart1:
1663   084B 1D 1F 1A      mov al, [sys_uart1_lcr]
1664   084E 8B 80         or al, $80                ; set dlab access bit
1665   0850 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, no parity by default
1666   0853 1D 22 1A      mov al, [sys_uart1_div0]
1667   0856 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
1668   0859 1D 23 1A      mov al, [sys_uart1_div1]
1669   085C 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
1670   085F 1D 1F 1A      mov al, [sys_uart1_lcr]
1671   0862 87 7F         and al, $7f               ; clear dlab access bit 
1672   0864 3D 8B FF      mov [_uart1_lcr], al
1673   0867 1D 20 1A      mov al, [sys_uart1_inten]
1674   086A 3D 89 FF      mov [_uart1_ier], al      ; interrupts
1675   086D 1D 21 1A      mov al, [sys_uart1_fifoen]
1676   0870 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
1677   0873 06            sysret
1678   0874             
1679   0874             ; char in ah
1680   0874             syscall_io_putchar:
1681   0874             syscall_io_putchar_l0:
1682   0874 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1683   0877 87 20         and al, $20
1684   0879 C6 74 08      jz syscall_io_putchar_l0    
1685   087C 1A            mov al, ah
1686   087D 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1687   0880             ; write to uart1
1688   0880             syscall_io_putchar_l1:
1689   0880 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1690   0883 87 20         and al, $20
1691   0885 C6 80 08      jz syscall_io_putchar_l1
1692   0888 1A            mov al, ah
1693   0889 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1694   088C 06            sysret
1695   088D             
1696   088D             ; char in ah
1697   088D             ; al = sucess code
1698   088D             syscall_io_getch:
1699   088D D8            push b
1700   088E DA            push d
1701   088F FD 0C         sti
1702   0891             syscall_io_getch_l0:  
1703   0891 14 2C 1A      mov a, [fifo_out]
1704   0894 29 2A 1A      mov b, [fifo_in]
1705   0897 B0            cmp a, b
1706   0898 C6 91 08      je syscall_io_getch_l0
1707   089B 3C            mov d, a
1708   089C 77            inc a
1709   089D AF 31 32      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
1710   08A0 C7 A6 08      jne syscall_io_getch_cont
1711   08A3 10 31 22      mov a, fifo  
1712   08A6             syscall_io_getch_cont:  
1713   08A6 42 2C 1A      mov [fifo_out], a             ; update fifo pointer
1714   08A9 1E            mov al, [d]                   ; get char
1715   08AA 23            mov ah, al
1716   08AB             ; here we just echo the char back to the console
1717   08AB             syscall_io_getch_echo_l0:
1718   08AB 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1719   08AE 87 20         and al, $20                 ; isolate transmitter empty
1720   08B0 C6 AB 08      jz syscall_io_getch_echo_l0
1721   08B3 1A            mov al, ah
1722   08B4 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1723   08B7             syscall_io_getch_echo_l1:
1724   08B7 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1725   08BA 87 20         and al, $20                 ; isolate transmitter empty
1726   08BC C6 B7 08      jz syscall_io_getch_echo_l1
1727   08BF 1A            mov al, ah
1728   08C0 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1729   08C3             syscall_io_getch_noecho:
1730   08C3 19 01         mov al, 1                    ; al = 1 means a char successfully received
1731   08C5 E7            pop d
1732   08C6 E5            pop b
1733   08C7 06            sysret
1734   08C8             
1735   08C8             ;------------------------------------------------------------------------------------------------------;
1736   08C8             ; file system data
1737   08C8             ;------------------------------------------------------------------------------------------------------;
1738   08C8             ; infor for : ide services interrupt
1739   08C8             ; ide read/write 512-byte sector
1740   08C8             ; al = option
1741   08C8             ; user buffer pointer in d
1742   08C8             ; ah = number of sectors
1743   08C8             ; cb = lba bytes 3..0  
1744   08C8             ;------------------------------------------------------------------------------------------------------;
1745   08C8             ; file system data structure
1746   08C8             ;------------------------------------------------------------------------------------------------------;
1747   08C8             ; for a directory we have the header first, followed by metadata
1748   08C8             ; header 1 sector (512 bytes)
1749   08C8             ; metadata 1 sector (512 bytes)
1750   08C8             ; header entries:
1751   08C8             ; filename (64)
1752   08C8             ; parent dir lba (2) -  to be used for faster backwards navigation...
1753   08C8             ;
1754   08C8             ; metadata entries:
1755   08C8             ; filename (24)
1756   08C8             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1757   08C8             ; lba (2)
1758   08C8             ; size (2)
1759   08C8             ; day (1)
1760   08C8             ; month (1)
1761   08C8             ; year (1)
1762   08C8             ; packet size = 32 bytes
1763   08C8             ;
1764   08C8             ; first directory on disk is the root directory '/'
1765   08C8             file_system_jmptbl:
1766   08C8 00 00         .dw 0                         ; 0
1767   08CA 00 00         .dw 0                         ; 1
1768   08CC 94 09         .dw fs_mkdir                  ; 2
1769   08CE 0D 0D         .dw fs_cd                     ; 3
1770   08D0 14 0D         .dw fs_ls                     ; 4
1771   08D2 FF 0D         .dw fs_mktxt                  ; 5
1772   08D4 CA 0E         .dw fs_mkbin                  ; 6
1773   08D6 91 0F         .dw fs_pwd                    ; 7
1774   08D8 AE 0F         .dw fs_cat                    ; 8
1775   08DA 0A 10         .dw fs_rmdir                  ; 9
1776   08DC 66 10         .dw fs_rm                     ; 10
1777   08DE 00 00         .dw 0                         ; 11
1778   08E0 00 00         .dw 0                         ; 12
1779   08E2 00 00         .dw 0                         ; 13
1780   08E4 3A 09         .dw fs_chmod                  ; 14
1781   08E6 CE 10         .dw fs_mv                     ; 15
1782   08E8 33 09         .dw fs_cd_root                ; 16
1783   08EA 09 0D         .dw fs_get_curr_dirid         ; 17
1784   08EC E5 0A         .dw fs_dir_id_to_path         ; 18
1785   08EE 4B 0B         .dw fs_path_to_dir_id_user    ; 19
1786   08F0 65 0C         .dw fs_load_from_path_user    ; 20  
1787   08F2 D5 0B         .dw fs_filepath_exists_user   ; 21
1788   08F4             
1789   08F4 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1789   08F8 79 73 63 61 
1789   08FC 6C 6C 5F 66 
1789   0900 69 6C 65 5F 
1789   0904 73 79 73 74 
1789   0908 65 6D 20 63 
1789   090C 61 6C 6C 65 
1789   0910 64 3A 20 00 
1790   0914             syscall_file_system:
1791   0914 DD            push bl
1792   0915 31 18 1A      mov bl, [sys_debug_mode]
1793   0918               ; debug block
1794   0918 C1 00         cmp bl, 0
1795   091A EA            pop bl
1796   091B C6 2F 09      je syscall_filesystem_jmp
1797   091E DA            push d
1798   091F DD            push bl
1799   0920 3B F4 08      mov d, s_syscall_fs_dbg0
1800   0923 07 EF 14      call _puts
1801   0926 2F            mov bl, al
1802   0927 07 8F 15      call print_u8x
1803   092A 07 9C 14      call printnl
1804   092D EA            pop bl
1805   092E E7            pop d
1806   092F             syscall_filesystem_jmp:
1807   092F FD 0A C8 08   jmp [file_system_jmptbl + al]
1808   0933               
1809   0933             fs_cd_root:
1810   0933 10 20 00      mov a, root_id
1811   0936 42 2E 1A      mov [current_dir_id], a      ; set current directory lba to root
1812   0939 06            sysret  
1813   093A             
1814   093A             ; filename in d (userspace data)
1815   093A             ; permission in bl
1816   093A             fs_chmod:
1817   093A DD            push bl
1818   093B FD 4E         mov si, d
1819   093D FD 4F 31 20   mov di, user_data
1820   0941 38 80 00      mov c, 128
1821   0944 04            load                        ; load filename from user-space
1822   0945 14 2E 1A      mov a, [current_dir_id]
1823   0948 77            inc a                       ; metadata sector
1824   0949 27            mov b, a
1825   094A 38 00 00      mov c, 0                    ; upper lba = 0
1826   094D 22 01         mov ah, $01                  ; 1 sector
1827   094F 3B 31 34      mov d, transient_area
1828   0952 07 8E 07      call ide_read_sect          ; read directory
1829   0955 FD 10         cla
1830   0957 42 26 1A      mov [index], a              ; reset file counter
1831   095A             fs_chmod_l1:
1832   095A FD 4E         mov si, d
1833   095C FD 4F 31 20   mov di, user_data
1834   0960 07 32 13      call _strcmp
1835   0963 C6 7A 09      je fs_chmod_found_entry
1836   0966 58 20 00      add d, 32
1837   0969 14 26 1A      mov a, [index]
1838   096C 77            inc a
1839   096D 42 26 1A      mov [index], a
1840   0970 AF 10 00      cmp a, fst_files_per_dir
1841   0973 C7 5A 09      jne fs_chmod_l1
1842   0976 EA            pop bl
1843   0977 0A 93 09      jmp fs_chmod_not_found
1844   097A             fs_chmod_found_entry:  
1845   097A FD 79         mov g, b                    ; save lba
1846   097C EA            pop bl                      ; retrieve saved permission value
1847   097D 1F 18 00      mov al, [d + 24]            ; read file permissions
1848   0980 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1849   0982 8C            or al, bl                   ; set new permissions
1850   0983 3F 18 00      mov [d + 24], al            ; write new permissions
1851   0986 38 00 00      mov c, 0
1852   0989 3B 31 34      mov d, transient_area
1853   098C 22 01         mov ah, $01                 ; disk write 1 sect
1854   098E FD 27         mov b, g                    ; retrieve lba
1855   0990 07 B4 07      call ide_write_sect         ; write sector
1856   0993             fs_chmod_not_found:
1857   0993 06            sysret
1858   0994             
1859   0994             ;------------------------------------------------------------------------------------------------------;
1860   0994             ; create new directory
1861   0994             ;------------------------------------------------------------------------------------------------------;
1862   0994             ; search list for null name entry. add new directory to list
1863   0994             fs_mkdir:
1864   0994 FD 4E         mov si, d
1865   0996 FD 4F 31 20   mov di, user_data
1866   099A 38 00 02      mov c, 512
1867   099D 04            load                        ; load data from user-space
1868   099E 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1869   09A1                                           ; when checking for null name, since root has a null name)
1870   09A1 38 00 00      mov c, 0                    ; upper lba = 0
1871   09A4             fs_mkdir_l1:  
1872   09A4 22 01         mov ah, $01                  ; 1 sector
1873   09A6 3B 31 34      mov d, transient_area
1874   09A9 07 8E 07      call ide_read_sect          ; read sector
1875   09AC BD 00         cmp byte[d], 0              ; check for null
1876   09AE C6 B7 09      je fs_mkdir_found_null
1877   09B1 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1878   09B4 0A A4 09      jmp fs_mkdir_l1
1879   09B7             fs_mkdir_found_null:
1880   09B7             ;create header file by grabbing dir name from parameter
1881   09B7 D8            push b                      ; save new directory's lba
1882   09B8 38 40 00      mov c, 64
1883   09BB FD 4D 31 20   mov si, user_data
1884   09BF FD 4F 31 34   mov di, transient_area
1885   09C3 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1886   09C5 14 2E 1A      mov a, [current_dir_id]
1887   09C8 42 71 34      mov [transient_area + 64], a    ; store parent directory lba
1888   09CB 19 00         mov al, 0
1889   09CD FD 4F 31 36   mov di, transient_area + 512
1890   09D1 38 00 02      mov c, 512
1891   09D4 FD F7         rep stosb                       ; clean buffer
1892   09D6 38 00 00      mov c, 0                        ; reset lba(c) to 0
1893   09D9             ; write directory entry sectors
1894   09D9 3B 31 34      mov d, transient_area
1895   09DC 22 02         mov ah, $02                     ; disk write, 2 sectors
1896   09DE 07 B4 07      call ide_write_sect             ; write sector
1897   09E1             ; now we need to add the new directory to the list, inside the current directory
1898   09E1 14 2E 1A      mov a, [current_dir_id]
1899   09E4 53 01 00      add a, 1
1900   09E7 27            mov b, a                        ; metadata sector
1901   09E8 38 00 00      mov c, 0
1902   09EB FD 79         mov g, b                        ; save lba
1903   09ED 3B 31 34      mov d, transient_area
1904   09F0 22 01         mov ah, $01                  ; 1 sector
1905   09F2 07 8E 07      call ide_read_sect              ; read metadata sector
1906   09F5             fs_mkdir_l2:
1907   09F5 BD 00         cmp byte[d], 0
1908   09F7 C6 00 0A      je fs_mkdir_found_null2
1909   09FA 58 20 00      add d, fst_entry_size
1910   09FD 0A F5 09      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1911   0A00             fs_mkdir_found_null2:
1912   0A00 FD 4D 31 20   mov si, user_data
1913   0A04 FD 50         mov di, d
1914   0A06 07 47 13      call _strcpy                    ; copy directory name
1915   0A09 58 18 00      add d, 24                       ; goto attributes
1916   0A0C 19 0B         mov al, %00001011               ; directory, no execute, write, read
1917   0A0E 3E            mov [d], al      
1918   0A0F 79            inc d
1919   0A10 E5            pop b
1920   0A11 D8            push b                          ; push lba back
1921   0A12 FD 43         mov [d], b                      ; save lba
1922   0A14             ; set file creation date  
1923   0A14 58 04 00      add d, 4
1924   0A17 19 04         mov al, 4
1925   0A19 05 01         syscall sys_rtc
1926   0A1B 1A            mov al, ah
1927   0A1C 3E            mov [d], al                     ; set day
1928   0A1D 79            inc d
1929   0A1E 19 05         mov al, 5
1930   0A20 05 01         syscall sys_rtc
1931   0A22 1A            mov al, ah
1932   0A23 3E            mov [d], al                     ; set month
1933   0A24 79            inc d
1934   0A25 19 06         mov al, 6
1935   0A27 05 01         syscall sys_rtc
1936   0A29 1A            mov al, ah
1937   0A2A 3E            mov [d], al                     ; set year
1938   0A2B             ; write sector into disk for new directory entry
1939   0A2B FD 27         mov b, g
1940   0A2D 38 00 00      mov c, 0
1941   0A30 3B 31 34      mov d, transient_area
1942   0A33 22 01         mov ah, $01                     ; disk write, 1 sector
1943   0A35 07 B4 07      call ide_write_sect             ; write sector
1944   0A38             
1945   0A38             ; after adding the new directory's information to its parent directory's list
1946   0A38             ; we need to now enter the new directory, and to it add two new directories!
1947   0A38             ; which directories do we need to add ? '..' and '.' are the directories needed.
1948   0A38             ; importantly, note that these two new directories are only entries in the list
1949   0A38             ; and do not have actual physical entries in the disk as real directories.
1950   0A38             ; i.e. they only exist as list entries in the new directory created so that
1951   0A38             ; the new directory can reference its parent and itself.
1952   0A38             ; we need to add both '..' and '.'
1953   0A38             ; this first section is for '..' and on the section below we do the same for '.'
1954   0A38 E4            pop a                         ; retrieve the new directory's lba  
1955   0A39 D7            push a                        ; and save again
1956   0A3A 53 01 00      add a, 1
1957   0A3D 27            mov b, a                      ; metadata sector
1958   0A3E 38 00 00      mov c, 0
1959   0A41 FD 79         mov g, b                      ; save lba
1960   0A43 3B 31 34      mov d, transient_area
1961   0A46 22 01         mov ah, $01                  ; 1 sector
1962   0A48 07 8E 07      call ide_read_sect            ; read metadata sector
1963   0A4B             fs_mkdir_l3:
1964   0A4B BD 00         cmp byte[d], 0
1965   0A4D C6 56 0A      je fs_mkdir_found_null3
1966   0A50 58 20 00      add d, fst_entry_size
1967   0A53 0A 4B 0A      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1968   0A56             fs_mkdir_found_null3:
1969   0A56 FD 4D 4D 1A   mov si, s_parent_dir
1970   0A5A FD 50         mov di, d
1971   0A5C 07 47 13      call _strcpy                  ; copy directory name
1972   0A5F 58 18 00      add d, 24                     ; goto attributes
1973   0A62 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1974   0A64 3E            mov [d], al      
1975   0A65 79            inc d
1976   0A66 29 2E 1A      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1977   0A69 FD 43         mov [d], b                    ; save lba
1978   0A6B             ; set file creation date  
1979   0A6B 58 04 00      add d, 4
1980   0A6E 19 04         mov al, 4
1981   0A70 05 01         syscall sys_rtc
1982   0A72 1A            mov al, ah
1983   0A73 3E            mov [d], al                   ; set day
1984   0A74 79            inc d
1985   0A75 19 05         mov al, 5
1986   0A77 05 01         syscall sys_rtc
1987   0A79 1A            mov al, ah
1988   0A7A 3E            mov [d], al                   ; set month
1989   0A7B 79            inc d
1990   0A7C 19 06         mov al, 6
1991   0A7E 05 01         syscall sys_rtc
1992   0A80 1A            mov al, ah
1993   0A81 3E            mov [d], al                   ; set year
1994   0A82             ; write sector into disk for new directory entry
1995   0A82 FD 27         mov b, g
1996   0A84 38 00 00      mov c, 0
1997   0A87 3B 31 34      mov d, transient_area
1998   0A8A 22 01         mov ah, $01                   ; disk write, 1 sector
1999   0A8C 07 B4 07      call ide_write_sect           ; write sector
2000   0A8F             ;;;;;;;;;;;;;
2001   0A8F             ; like we did above for '..', we need to now add the '.' directory to the list.
2002   0A8F             ;------------------------------------------------------------------------------------------------------;
2003   0A8F E4            pop a                         ; retrieve the new directory's lba  
2004   0A90 D7            push a
2005   0A91 53 01 00      add a, 1
2006   0A94 27            mov b, a                      ; metadata sector
2007   0A95 38 00 00      mov c, 0
2008   0A98 FD 79         mov g, b                      ; save lba
2009   0A9A 3B 31 34      mov d, transient_area
2010   0A9D 22 01         mov ah, $01                  ; 1 sector
2011   0A9F 07 8E 07      call ide_read_sect            ; read metadata sector
2012   0AA2             fs_mkdir_l4:
2013   0AA2 BD 00         cmp byte[d], 0
2014   0AA4 C6 AD 0A      je fs_mkdir_found_null4
2015   0AA7 58 20 00      add d, fst_entry_size
2016   0AAA 0A A2 0A      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2017   0AAD             fs_mkdir_found_null4:
2018   0AAD FD 4D 50 1A   mov si, s_current_dir
2019   0AB1 FD 50         mov di, d
2020   0AB3 07 47 13      call _strcpy                  ; copy directory name
2021   0AB6 58 18 00      add d, 24                     ; goto attributes
2022   0AB9 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
2023   0ABB 3E            mov [d], al      
2024   0ABC 79            inc d
2025   0ABD E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
2026   0ABE FD 43         mov [d], b                    ; save lba
2027   0AC0             ; set file creation date  
2028   0AC0 58 04 00      add d, 4
2029   0AC3 19 04         mov al, 4
2030   0AC5 05 01         syscall sys_rtc
2031   0AC7 1A            mov al, ah
2032   0AC8 3E            mov [d], al                   ; set day
2033   0AC9 79            inc d
2034   0ACA 19 05         mov al, 5
2035   0ACC 05 01         syscall sys_rtc
2036   0ACE 1A            mov al, ah
2037   0ACF 3E            mov [d], al                   ; set month
2038   0AD0 79            inc d
2039   0AD1 19 06         mov al, 6
2040   0AD3 05 01         syscall sys_rtc
2041   0AD5 1A            mov al, ah
2042   0AD6 3E            mov [d], al                   ; set year
2043   0AD7             ; write sector into disk for new directory entry
2044   0AD7 FD 27         mov b, g
2045   0AD9 38 00 00      mov c, 0
2046   0ADC 3B 31 34      mov d, transient_area
2047   0ADF 22 01         mov ah, $01                   ; disk write, 1 sector
2048   0AE1 07 B4 07      call ide_write_sect           ; write sector
2049   0AE4             fs_mkdir_end:
2050   0AE4 06            sysret
2051   0AE5             
2052   0AE5             ;------------------------------------------------------------------------------------------------------;
2053   0AE5             ; get path from a given directory dirid
2054   0AE5             ; pseudo code:
2055   0AE5             ;  fs_dir_id_to_path(int dirid, char *d){
2056   0AE5             ;    if(dirid == 0){
2057   0AE5             ;      reverse path in d;
2058   0AE5             ;      return;
2059   0AE5             ;    }
2060   0AE5             ;    else{
2061   0AE5             ;      copy directory name to end of d;
2062   0AE5             ;      add '/' to end of d;
2063   0AE5             ;      parentid = get parent directory id;
2064   0AE5             ;      fs_dir_id_to_path(parentid, d);
2065   0AE5             ;    }
2066   0AE5             ;  }
2067   0AE5             ; a = dirid
2068   0AE5             ; d = generated path string pointer
2069   0AE5             ;------------------------------------------------------------------------------------------------------;
2070   0AE5             ; sample path: /usr/bin
2071   0AE5             fs_dir_id_to_path:
2072   0AE5 3B B1 1F      mov d, filename
2073   0AE8 19 00         mov al, 0
2074   0AEA 3E            mov [d], al                     ; initialize path string 
2075   0AEB 14 2E 1A      mov a, [current_dir_id]
2076   0AEE 07 FB 0A      call fs_dir_id_to_path_e0
2077   0AF1 3B B1 1F      mov d, filename
2078   0AF4 07 DB 12      call _strrev
2079   0AF7 07 EF 14      call _puts
2080   0AFA 06            sysret
2081   0AFB             fs_dir_id_to_path_e0:
2082   0AFB 07 1A 0B      call get_dirname_from_dirid
2083   0AFE FD 4D 52 1A   mov si, s_fslash
2084   0B02 FD 50         mov di, d
2085   0B04 07 55 13      call _strcat                    ; add '/' to end of path
2086   0B07 AF 20 00      cmp a, root_id               ; check if we are at the root directory
2087   0B0A C6 19 0B      je fs_dir_id_to_path_root
2088   0B0D 07 37 0B      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
2089   0B10 AF 20 00      cmp a, root_id               ; check if we are at the root directory
2090   0B13 C6 19 0B      je fs_dir_id_to_path_root
2091   0B16 07 FB 0A      call fs_dir_id_to_path_e0     ; recursively call itself
2092   0B19             fs_dir_id_to_path_root:
2093   0B19 09            ret
2094   0B1A             
2095   0B1A             ;------------------------------------------------------------------------------------------------------;
2096   0B1A             ; in_puts:
2097   0B1A             ; a = directory id
2098   0B1A             ; out_puts:
2099   0B1A             ; d = pointer to directory name string
2100   0B1A             ;------------------------------------------------------------------------------------------------------;
2101   0B1A             get_dirname_from_dirid:
2102   0B1A D7            push a
2103   0B1B D8            push b
2104   0B1C DA            push d
2105   0B1D 27            mov b, a
2106   0B1E 38 00 00      mov c, 0                      ; upper lba = 0
2107   0B21 22 01         mov ah, $01                  ; 1 sector
2108   0B23 3B 31 32      mov d, transient_area - 512
2109   0B26 07 8E 07      call ide_read_sect            ; read directory
2110   0B29 07 DB 12      call _strrev                  ; reverse dir name before copying
2111   0B2C FD 4E         mov si, d
2112   0B2E E7            pop d                         ; destination address = d value pushed at beginning
2113   0B2F FD 50         mov di, d
2114   0B31 07 55 13      call _strcat                  ; copy filename to d
2115   0B34 E5            pop b
2116   0B35 E4            pop a
2117   0B36 09            ret
2118   0B37             
2119   0B37             ;------------------------------------------------------------------------------------------------------;
2120   0B37             ; in_puts:
2121   0B37             ; a = directory id
2122   0B37             ; out_puts:
2123   0B37             ; a = parent directory id
2124   0B37             ;------------------------------------------------------------------------------------------------------;
2125   0B37             get_parentid_from_dirid:
2126   0B37 D8            push b
2127   0B38 DA            push d
2128   0B39 27            mov b, a
2129   0B3A 38 00 00      mov c, 0                      ; upper lba = 0
2130   0B3D 22 01         mov ah, $01                  ; 1 sector
2131   0B3F 3B 31 32      mov d, transient_area - 512
2132   0B42 07 8E 07      call ide_read_sect            ; read directory
2133   0B45 16 40 00      mov a, [d + 64]               ; copy parent id value to a
2134   0B48 E7            pop d
2135   0B49 E5            pop b
2136   0B4A 09            ret
2137   0B4B             
2138   0B4B             ;------------------------------------------------------------------------------------------------------;
2139   0B4B             ; get dirid from a given path string
2140   0B4B             ; in_puts:
2141   0B4B             ; d = path pointer 
2142   0B4B             ; out_puts:
2143   0B4B             ; a = dirid
2144   0B4B             ; if dir non existent, a = ffff (fail code)
2145   0B4B             ; /usr/local/bin    - absolute
2146   0B4B             ; local/bin/games    - relative
2147   0B4B             ;------------------------------------------------------------------------------------------------------;
2148   0B4B             fs_path_to_dir_id_user:
2149   0B4B FD 4E         mov si, d
2150   0B4D FD 4F 31 20   mov di, user_data
2151   0B51 38 00 02      mov c, 512
2152   0B54 04            load
2153   0B55 07 59 0B      call get_dirid_from_path
2154   0B58 06            sysret
2155   0B59             get_dirid_from_path:
2156   0B59 26 31 20      mov b, user_data
2157   0B5C FD 42 14 19   mov [prog], b                  ; token pointer set to path string
2158   0B60 07 75 17      call get_token
2159   0B63 31 17 19      mov bl, [tok]
2160   0B66 C1 01         cmp bl, tok_fslash
2161   0B68 C6 74 0B      je get_dirid_from_path_abs 
2162   0B6B 14 2E 1A      mov a, [current_dir_id]
2163   0B6E 07 FB 18      call _putback
2164   0B71 0A 77 0B      jmp get_dirid_from_path_e0
2165   0B74             get_dirid_from_path_abs:
2166   0B74 10 20 00      mov a, root_id
2167   0B77             get_dirid_from_path_e0:
2168   0B77 07 75 17      call get_token
2169   0B7A 31 16 19      mov bl, [toktyp]
2170   0B7D C1 00         cmp bl, toktyp_identifier
2171   0B7F C7 D0 0B      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2172   0B82             
2173   0B82 FD 4D 18 19   mov si, tokstr
2174   0B86 FD 4F B1 1F   mov di, filename
2175   0B8A 07 47 13      call _strcpy        
2176   0B8D 77            inc a                         ; metadata sector
2177   0B8E 27            mov b, a
2178   0B8F 38 00 00      mov c, 0                      ; upper lba = 0
2179   0B92 22 01         mov ah, $01                  ; 1 sector
2180   0B94 3B 31 34      mov d, transient_area
2181   0B97 07 8E 07      call ide_read_sect            ; read directory
2182   0B9A FD 10         cla
2183   0B9C 42 26 1A      mov [index], a
2184   0B9F             get_dirid_from_path_l1:
2185   0B9F FD 4E         mov si, d
2186   0BA1 FD 4F B1 1F   mov di, filename
2187   0BA5 07 32 13      call _strcmp
2188   0BA8 C6 BE 0B      je get_dirid_from_path_name_equal  
2189   0BAB 58 20 00      add d, 32
2190   0BAE 14 26 1A      mov a, [index]
2191   0BB1 77            inc a
2192   0BB2 42 26 1A      mov [index], a
2193   0BB5 AF 10 00      cmp a, fst_files_per_dir
2194   0BB8 C6 D1 0B      je get_dirid_from_path_fail
2195   0BBB 0A 9F 0B      jmp get_dirid_from_path_l1
2196   0BBE             get_dirid_from_path_name_equal:
2197   0BBE 58 19 00      add d, 25           
2198   0BC1 15            mov a, [d]                    ; set result register a = dirid
2199   0BC2 07 75 17      call get_token
2200   0BC5 31 17 19      mov bl, [tok]
2201   0BC8 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
2202   0BCA C6 77 0B      je get_dirid_from_path_e0
2203   0BCD 07 FB 18      call _putback
2204   0BD0             get_dirid_from_path_end:
2205   0BD0 09            ret
2206   0BD1             get_dirid_from_path_fail:
2207   0BD1 10 FF FF      mov a, $ffff
2208   0BD4 09            ret
2209   0BD5             
2210   0BD5             
2211   0BD5             ;------------------------------------------------------------------------------------------------------;
2212   0BD5             ; check if file exists by a given path string
2213   0BD5             ; in_puts:
2214   0BD5             ; d = path pointer 
2215   0BD5             ; outputs:
2216   0BD5             ; a = success code, if file exists gives lba, else, give 0
2217   0BD5             ; /usr/local/bin/ed
2218   0BD5             ;------------------------------------------------------------------------------------------------------;
2219   0BD5             fs_filepath_exists_user:
2220   0BD5 FD 4E         mov si, d
2221   0BD7 FD 4F 31 20   mov di, user_data
2222   0BDB 38 00 02      mov c, 512
2223   0BDE 04            load
2224   0BDF 07 E3 0B      call file_exists_by_path
2225   0BE2 06            sysret
2226   0BE3             file_exists_by_path:
2227   0BE3 26 31 20      mov b, user_data
2228   0BE6 FD 42 14 19   mov [prog], b                   ; token pointer set to path string
2229   0BEA 07 75 17      call get_token
2230   0BED 31 17 19      mov bl, [tok]
2231   0BF0 C1 01         cmp bl, tok_fslash
2232   0BF2 C6 FE 0B      je  file_exists_by_path_abs
2233   0BF5 14 2E 1A      mov a, [current_dir_id]
2234   0BF8 07 FB 18      call _putback
2235   0BFB 0A 01 0C      jmp file_exists_by_path_e0
2236   0BFE             file_exists_by_path_abs:
2237   0BFE 10 20 00      mov a, root_id
2238   0C01             file_exists_by_path_e0:
2239   0C01 07 75 17      call get_token
2240   0C04 31 16 19      mov bl, [toktyp]
2241   0C07 C1 00         cmp bl, toktyp_identifier
2242   0C09 C7 61 0C      jne file_exists_by_path_end     ; check if there are tokens after '/'
2243   0C0C FD 4D 18 19   mov si, tokstr
2244   0C10 FD 4F B1 1F   mov di, filename
2245   0C14 07 47 13      call _strcpy        
2246   0C17 77            inc a                           ; metadata sector
2247   0C18 27            mov b, a
2248   0C19 38 00 00      mov c, 0                        ; upper lba = 0
2249   0C1C 22 01         mov ah, $01                  ; 1 sector
2250   0C1E 3B 31 34      mov d, transient_area
2251   0C21 07 8E 07      call ide_read_sect              ; read directory
2252   0C24 FD 10         cla
2253   0C26 42 26 1A      mov [index], a
2254   0C29             file_exists_by_path_l1:
2255   0C29 FD 4E         mov si, d
2256   0C2B FD 4F B1 1F   mov di, filename
2257   0C2F 07 32 13      call _strcmp
2258   0C32 C6 48 0C      je   file_exists_by_path_name_equal
2259   0C35 58 20 00      add d, 32
2260   0C38 14 26 1A      mov a, [index]
2261   0C3B 77            inc a
2262   0C3C 42 26 1A      mov [index], a
2263   0C3F AF 10 00      cmp a, fst_files_per_dir
2264   0C42 C6 61 0C      je file_exists_by_path_end
2265   0C45 0A 29 0C      jmp file_exists_by_path_l1
2266   0C48             file_exists_by_path_name_equal:
2267   0C48 33 18 00      mov bl, [d + 24]
2268   0C4B FD 87 38      and bl, %00111000               ; directory flag
2269   0C4E C1 08         cmp bl, %00001000               ; is dir?
2270   0C50 C6 57 0C      je file_exists_by_path_isdir;
2271   0C53             ; entry is a file
2272   0C53 16 19 00      mov a, [d + 25]                 ; get and return lba of file
2273   0C56 09            ret
2274   0C57             file_exists_by_path_isdir:
2275   0C57 58 19 00      add d, 25           
2276   0C5A 15            mov a, [d]                      ; set result register a = dirid
2277   0C5B 07 75 17      call get_token
2278   0C5E 0A 01 0C      jmp file_exists_by_path_e0
2279   0C61             file_exists_by_path_end:
2280   0C61 10 00 00      mov a, 0                        ; return 0 because file was not found
2281   0C64 09            ret
2282   0C65             
2283   0C65             ;------------------------------------------------------------------------------------------------------;
2284   0C65             ; load file data from a given path string
2285   0C65             ; inputs:
2286   0C65             ; d = path pointer 
2287   0C65             ; di = userspace program data destination
2288   0C65             ; /usr/local/bin/ed
2289   0C65             ; ./ed
2290   0C65             ;------------------------------------------------------------------------------------------------------;
2291   0C65             fs_load_from_path_user:
2292   0C65 E3            push di
2293   0C66 FD 4E         mov si, d
2294   0C68 FD 4F 31 20   mov di, user_data
2295   0C6C 38 00 02      mov c, 512
2296   0C6F 04            load
2297   0C70 07 7D 0C      call loadfile_from_path
2298   0C73 F0            pop di
2299   0C74 FD 4D 31 34   mov si, transient_area
2300   0C78 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
2301   0C7B 03            store
2302   0C7C 06            sysret
2303   0C7D             loadfile_from_path:
2304   0C7D 26 31 20      mov b, user_data
2305   0C80 FD 42 14 19   mov [prog], b                 ; token pointer set to path string
2306   0C84 07 75 17      call get_token
2307   0C87 31 17 19      mov bl, [tok]
2308   0C8A C1 01         cmp bl, tok_fslash
2309   0C8C C6 98 0C      je loadfile_from_path_abs 
2310   0C8F 14 2E 1A      mov a, [current_dir_id]
2311   0C92 07 FB 18      call _putback
2312   0C95 0A 9B 0C      jmp loadfile_from_path_e0
2313   0C98             loadfile_from_path_abs:
2314   0C98 10 20 00      mov a, root_id
2315   0C9B             loadfile_from_path_e0:
2316   0C9B 07 75 17      call get_token
2317   0C9E 31 16 19      mov bl, [toktyp]
2318   0CA1 C1 00         cmp bl, toktyp_identifier
2319   0CA3 C7 08 0D      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2320   0CA6 FD 4D 18 19   mov si, tokstr
2321   0CAA FD 4F B1 1F   mov di, filename
2322   0CAE 07 47 13      call _strcpy        
2323   0CB1 77            inc a                         ; metadata sector
2324   0CB2 27            mov b, a
2325   0CB3 38 00 00      mov c, 0                      ; upper lba = 0
2326   0CB6 22 01         mov ah, $01                  ; 1 sector
2327   0CB8 3B 31 34      mov d, transient_area
2328   0CBB 07 8E 07      call ide_read_sect            ; read directory
2329   0CBE FD 10         cla
2330   0CC0 42 26 1A      mov [index], a
2331   0CC3             loadfile_from_path_l1:
2332   0CC3 FD 4E         mov si, d
2333   0CC5 FD 4F B1 1F   mov di, filename
2334   0CC9 07 32 13      call _strcmp
2335   0CCC C6 E2 0C      je loadfile_from_path_name_equal  
2336   0CCF 58 20 00      add d, 32
2337   0CD2 14 26 1A      mov a, [index]
2338   0CD5 77            inc a
2339   0CD6 42 26 1A      mov [index], a
2340   0CD9 AF 10 00      cmp a, fst_files_per_dir
2341   0CDC C6 08 0D      je loadfile_from_path_end
2342   0CDF 0A C3 0C      jmp loadfile_from_path_l1
2343   0CE2             loadfile_from_path_name_equal:
2344   0CE2 33 18 00      mov bl, [d + 24]
2345   0CE5 FD 87 38      and bl, %00111000             ; directory flag
2346   0CE8 C1 08         cmp bl, %00001000             ; is dir?
2347   0CEA C6 FE 0C      je loadfile_isdirectory  
2348   0CED             ; entry is a file
2349   0CED 2B 19 00      mov b, [d + 25]               ; get lba
2350   0CF0 FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
2351   0CF2 3B 31 34      mov d, transient_area
2352   0CF5 38 00 00      mov c, 0
2353   0CF8 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
2354   0CFA 07 8E 07      call ide_read_sect            ; read sector
2355   0CFD 09            ret
2356   0CFE             loadfile_isdirectory:
2357   0CFE 58 19 00      add d, 25           
2358   0D01 15            mov a, [d]                    ; set result register a = dirid
2359   0D02 07 75 17      call get_token
2360   0D05 0A 9B 0C      jmp loadfile_from_path_e0
2361   0D08             loadfile_from_path_end:
2362   0D08 09            ret
2363   0D09             
2364   0D09             ;------------------------------------------------------------------------------------------------------;
2365   0D09             ; return the id of the current directory
2366   0D09             ; id returned in b
2367   0D09             ;------------------------------------------------------------------------------------------------------;
2368   0D09             fs_get_curr_dirid:
2369   0D09 29 2E 1A      mov b, [current_dir_id]
2370   0D0C 06            sysret
2371   0D0D             
2372   0D0D             ;------------------------------------------------------------------------------------------------------;
2373   0D0D             ; cd
2374   0D0D             ;------------------------------------------------------------------------------------------------------;
2375   0D0D             ; new dirid in b
2376   0D0D             fs_cd:
2377   0D0D FD 42 2E 1A   mov [current_dir_id], b
2378   0D11 06            sysret  
2379   0D12             
2380   0D12             ;------------------------------------------------------------------------------------------------------;
2381   0D12             ; ls
2382   0D12             ; dirid in b
2383   0D12             ;------------------------------------------------------------------------------------------------------;
2384   0D12 00 00       ls_count:       .dw 0
2385   0D14             fs_ls:
2386   0D14 FD 77         inc b                        ; metadata sector
2387   0D16 38 00 00      mov c, 0                     ; upper lba = 0
2388   0D19 22 01         mov ah, $01                  ; 1 sector
2389   0D1B 3B 31 34      mov d, transient_area
2390   0D1E 07 8E 07      call ide_read_sect           ; read directory
2391   0D21 FD 10         cla
2392   0D23 42 26 1A      mov [index], a               ; reset entry index
2393   0D26 3D 12 0D      mov [ls_count], al           ; reset item count
2394   0D29             fs_ls_l1:
2395   0D29 BD 00         cmp byte [d], 0              ; check for null
2396   0D2B C6 C2 0D      je fs_ls_next
2397   0D2E             fs_ls_non_null:
2398   0D2E 1D 12 0D      mov al, [ls_count]
2399   0D31 7A            inc al
2400   0D32 3D 12 0D      mov [ls_count], al           ; increment item count
2401   0D35 1F 18 00      mov al, [d + 24]
2402   0D38 87 38         and al, %00111000
2403   0D3A FD A2 03      shr al, 3
2404   0D3D 22 00         mov ah, 0                    ; file type
2405   0D3F B7 59 1A      mov a, [a + file_type]      
2406   0D42 23            mov ah, al
2407   0D43 07 C3 13      call _putchar
2408   0D46 1F 18 00      mov al, [d + 24]
2409   0D49 87 01         and al, %00000001
2410   0D4B 22 00         mov ah, 0
2411   0D4D B7 54 1A      mov a, [a + file_attrib]     ; read
2412   0D50 23            mov ah, al
2413   0D51 07 C3 13      call _putchar
2414   0D54 1F 18 00      mov al, [d + 24]
2415   0D57 87 02         and al, %00000010
2416   0D59 22 00         mov ah, 0
2417   0D5B B7 54 1A      mov a, [a + file_attrib]     ; write
2418   0D5E 23            mov ah, al
2419   0D5F 07 C3 13      call _putchar
2420   0D62 1F 18 00      mov al, [d + 24]
2421   0D65 87 04         and al, %00000100
2422   0D67 22 00         mov ah, 0
2423   0D69 B7 54 1A      mov a, [a + file_attrib]     ; execute
2424   0D6C 23            mov ah, al
2425   0D6D 07 C3 13      call _putchar
2426   0D70 22 20         mov ah, $20
2427   0D72 07 C3 13      call _putchar  
2428   0D75 2B 1B 00      mov b, [d + 27]
2429   0D78 07 4B 15      call print_u16x              ; filesize
2430   0D7B 22 20         mov ah, $20
2431   0D7D 07 C3 13      call _putchar  
2432   0D80 2B 19 00      mov b, [d + 25]
2433   0D83 07 4B 15      call print_u16x              ; dirid / lba
2434   0D86 22 20         mov ah, $20
2435   0D88 07 C3 13      call _putchar
2436   0D8B             ; print date
2437   0D8B 33 1D 00      mov bl, [d + 29]             ; day
2438   0D8E 07 8F 15      call print_u8x
2439   0D91 22 20         mov ah, $20
2440   0D93 07 C3 13      call _putchar  
2441   0D96 1F 1E 00      mov al, [d + 30]             ; month
2442   0D99 FD 9E 02      shl al, 2
2443   0D9C DA            push d
2444   0D9D 3B BF 1B      mov d, s_months
2445   0DA0 22 00         mov ah, 0
2446   0DA2 59            add d, a
2447   0DA3 07 EF 14      call _puts
2448   0DA6 E7            pop d
2449   0DA7 22 20         mov ah, $20
2450   0DA9 07 C3 13      call _putchar
2451   0DAC 2E 20         mov bl, $20
2452   0DAE 07 8F 15      call print_u8x
2453   0DB1 33 1F 00      mov bl, [d + 31]             ; year
2454   0DB4 07 8F 15      call print_u8x  
2455   0DB7 22 20         mov ah, $20
2456   0DB9 07 C3 13      call _putchar  
2457   0DBC 07 EF 14      call _puts                   ; print filename  
2458   0DBF 07 9C 14      call printnl
2459   0DC2             fs_ls_next:
2460   0DC2 14 26 1A      mov a, [index]
2461   0DC5 77            inc a
2462   0DC6 42 26 1A      mov [index], a
2463   0DC9 AF 10 00      cmp a, fst_files_per_dir
2464   0DCC C6 D5 0D      je fs_ls_end
2465   0DCF 58 20 00      add d, 32      
2466   0DD2 0A 29 0D      jmp fs_ls_l1  
2467   0DD5             fs_ls_end:
2468   0DD5 3B 69 1A      mov d, s_ls_total
2469   0DD8 07 EF 14      call _puts
2470   0DDB 1D 12 0D      mov al, [ls_count]
2471   0DDE 07 A1 15      call print_u8d
2472   0DE1 07 9C 14      call printnl
2473   0DE4 06            sysret
2474   0DE5             
2475   0DE5             ;------------------------------------------------------------------------------------------------------;
2476   0DE5             ; finds an empty data block
2477   0DE5             ; block lba returned in b
2478   0DE5             ;------------------------------------------------------------------------------------------------------;
2479   0DE5             fs_find_empty_block:
2480   0DE5 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2481   0DE8 38 00 00      mov c, 0                ; upper lba = 0
2482   0DEB             fs_find_empty_block_l1:  
2483   0DEB 22 01         mov ah, $01                  ; 1 sector
2484   0DED 3B 31 32      mov d, transient_area - 512
2485   0DF0 07 8E 07      call ide_read_sect      ; read sector
2486   0DF3 BD 00         cmp byte [d], 0
2487   0DF5 C6 FE 0D      je fs_find_empty_block_found_null
2488   0DF8 55 20 00      add b, fs_sectors_per_file
2489   0DFB 0A EB 0D      jmp fs_find_empty_block_l1
2490   0DFE             fs_find_empty_block_found_null:
2491   0DFE 09            ret
2492   0DFF             
2493   0DFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2494   0DFF             ;; create new textfile
2495   0DFF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2496   0DFF             ; search for first null block
2497   0DFF             fs_mktxt:
2498   0DFF FD 4E       	mov si, d
2499   0E01 FD 4F 31 20 	mov di, user_data
2500   0E05 38 00 01    	mov c, 256
2501   0E08 04          	load					; load data from user-space
2502   0E09             	
2503   0E09 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2504   0E0C 38 00 00    	mov c, 0						; reset lba to 0
2505   0E0F             fs_mktxt_l1:	
2506   0E0F 10 02 01    	mov a, $0102			; disk read
2507   0E12 3B 31 34    	mov d, transient_area
2508   0E15 05 02       	syscall sys_ide ; read sector
2509   0E17 1E          	mov al, [d]
2510   0E18 B9 00       	cmp al, 0			; check for null
2511   0E1A C6 23 0E    	je fs_mktxt_found_null
2512   0E1D 55 20 00    	add b, fs_sectors_per_file
2513   0E20 0A 0F 0E    	jmp fs_mktxt_l1
2514   0E23             fs_mktxt_found_null:
2515   0E23 D8          	push b				; save lba
2516   0E24             ;create header file by grabbing file name from parameter	
2517   0E24 3B 4A 1A    	mov d, s_dataentry
2518   0E27 07 EF 14    	call _puts
2519   0E2A 3B 31 36    	mov d, transient_area + 512			; pointer to file contents
2520   0E2D 07 55 14    	call _gettxt
2521   0E30 07 22 13    	call _strlen						; get length of file
2522   0E33 D9          	push c							; save length
2523   0E34 19 01       	mov al, 1
2524   0E36 3D 31 34    	mov [transient_area], al					; mark sectors as used (not null)
2525   0E39 10 00 00    	mov a, 0
2526   0E3C 42 26 1A    	mov [index], a
2527   0E3F 3B 31 34    	mov d, transient_area
2528   0E42 13          	mov a, d
2529   0E43 42 28 1A    	mov [buffer_addr], a
2530   0E46             fs_mktxt_l2:
2531   0E46 38 00 00    	mov c, 0
2532   0E49 10 03 01    	mov a, $0103			; disk write, 1 sector
2533   0E4C 05 02       	syscall sys_ide		; write sector
2534   0E4E 14 26 1A    	mov a, [index]
2535   0E51 77          	inc a
2536   0E52 42 26 1A    	mov [index], a
2537   0E55 AF 20 00    	cmp a, fs_sectors_per_file
2538   0E58 C6 6A 0E    	je fs_mktxt_add_to_dir
2539   0E5B FD 77       	inc b
2540   0E5D 14 28 1A    	mov a, [buffer_addr]
2541   0E60 53 00 02    	add a, 512
2542   0E63 42 28 1A    	mov [buffer_addr], a
2543   0E66 3C          	mov d, a
2544   0E67 0A 46 0E    	jmp fs_mktxt_l2
2545   0E6A             ; now we add the file to the current directory!
2546   0E6A             fs_mktxt_add_to_dir:	
2547   0E6A 14 2E 1A    	mov a, [current_dir_id]
2548   0E6D 77          	inc a
2549   0E6E 27          	mov b, a					; metadata sector
2550   0E6F 38 00 00    	mov c, 0
2551   0E72 FD 79       	mov g, b					; save lba
2552   0E74 3B 31 34    	mov d, transient_area
2553   0E77 10 02 01    	mov a, $0102			; disk read
2554   0E7A 05 02       	syscall sys_ide		; read metadata sector
2555   0E7C             fs_mktxt_add_to_dir_l2:
2556   0E7C 1E          	mov al, [d]
2557   0E7D B9 00       	cmp al, 0
2558   0E7F C6 88 0E    	je fs_mktxt_add_to_dir_null
2559   0E82 58 20 00    	add d, fst_entry_size
2560   0E85 0A 7C 0E    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2561   0E88             fs_mktxt_add_to_dir_null:
2562   0E88 FD 4D 31 20 	mov si, user_data
2563   0E8C FD 50       	mov di, d
2564   0E8E 07 47 13    	call _strcpy			; copy file name
2565   0E91 58 18 00    	add d, 24			; skip name
2566   0E94 19 06       	mov al, %00000110		; no execute, write, read, not directory
2567   0E96 3E          	mov [d], al			
2568   0E97 58 03 00    	add d, 3
2569   0E9A E4          	pop a
2570   0E9B 43          	mov [d], a
2571   0E9C 63 02 00    	sub d, 2
2572   0E9F E5          	pop b				; get file lba
2573   0EA0 FD 43       	mov [d], b			; save lba	
2574   0EA2             	
2575   0EA2             	; set file creation date	
2576   0EA2 58 04 00    	add d, 4
2577   0EA5 19 04       	mov al, 4
2578   0EA7 05 01       	syscall sys_rtc
2579   0EA9 1A          	mov al, ah
2580   0EAA 3E          	mov [d], al			; set day
2581   0EAB             	
2582   0EAB 79          	inc d
2583   0EAC 19 05       	mov al, 5
2584   0EAE 05 01       	syscall sys_rtc
2585   0EB0 1A          	mov al, ah
2586   0EB1 3E          	mov [d], al			; set month
2587   0EB2             	
2588   0EB2 79          	inc d
2589   0EB3 19 06       	mov al, 6
2590   0EB5 05 01       	syscall sys_rtc
2591   0EB7 1A          	mov al, ah
2592   0EB8 3E          	mov [d], al			; set year
2593   0EB9             	
2594   0EB9             ; write sector into disk for new directory entry
2595   0EB9 FD 27       	mov b, g
2596   0EBB 38 00 00    	mov c, 0
2597   0EBE 3B 31 34    	mov d, transient_area
2598   0EC1 10 03 01    	mov a, $0103			; disk write, 1 sector
2599   0EC4 05 02       	syscall sys_ide		; write sector
2600   0EC6 07 9C 14    	call printnl
2601   0EC9 06          	sysret
2602   0ECA             
2603   0ECA             ;------------------------------------------------------------------------------------------------------;
2604   0ECA             ; create new binary file
2605   0ECA             ;------------------------------------------------------------------------------------------------------;
2606   0ECA             ; search for first null block
2607   0ECA             fs_mkbin:
2608   0ECA 19 00         mov al, 0
2609   0ECC 3D 19 1A      mov [sys_echo_on], al ; disable echo
2610   0ECF FD 4E         mov si, d
2611   0ED1 FD 4F 31 20   mov di, user_data
2612   0ED5 38 00 02      mov c, 512
2613   0ED8 04            load                          ; load data from user-space
2614   0ED9 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2615   0EDC 38 00 00      mov c, 0                      ; upper lba = 0
2616   0EDF             fs_mkbin_l1:  
2617   0EDF 22 01         mov ah, $01                  ; 1 sector
2618   0EE1 3B 31 34      mov d, transient_area
2619   0EE4 07 8E 07      call ide_read_sect            ; read sector
2620   0EE7 BD 00         cmp byte[d], 0                ; check for null
2621   0EE9 C6 F2 0E      je fs_mkbin_found_null
2622   0EEC 55 20 00      add b, fs_sectors_per_file
2623   0EEF 0A DF 0E      jmp fs_mkbin_l1
2624   0EF2             fs_mkbin_found_null:
2625   0EF2 D8            push b                        ; save lba
2626   0EF3             ;create header file by grabbing file name from parameter
2627   0EF3 FD 4F 31 36   mov di, transient_area + 512  ; pointer to file contents
2628   0EF7 07 6D 12      call _load_hex                ; load binary hex
2629   0EFA D9            push c                        ; save size (nbr of bytes)
2630   0EFB 19 01         mov al, 1
2631   0EFD 3D 31 34      mov [transient_area], al      ; mark sectors as used (not null)
2632   0F00 FD 10         cla
2633   0F02 42 26 1A      mov [index], a
2634   0F05 3B 31 34      mov d, transient_area
2635   0F08 13            mov a, d
2636   0F09 42 28 1A      mov [buffer_addr], a
2637   0F0C             fs_mkbin_l2:
2638   0F0C 38 00 00      mov c, 0
2639   0F0F 22 01         mov ah, $01                   ; disk write, 1 sector
2640   0F11 07 B4 07      call ide_write_sect           ; write sector
2641   0F14 14 26 1A      mov a, [index]
2642   0F17 77            inc a
2643   0F18 42 26 1A      mov [index], a
2644   0F1B AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2645   0F1E C6 30 0F      je fs_mkbin_add_to_dir
2646   0F21 FD 77         inc b
2647   0F23 14 28 1A      mov a, [buffer_addr]
2648   0F26 53 00 02      add a, 512
2649   0F29 42 28 1A      mov [buffer_addr], a
2650   0F2C 3C            mov d, a
2651   0F2D 0A 0C 0F      jmp fs_mkbin_l2
2652   0F30             ; now we add the file to the current directory!
2653   0F30             fs_mkbin_add_to_dir:  
2654   0F30 14 2E 1A      mov a, [current_dir_id]
2655   0F33 77            inc a
2656   0F34 27            mov b, a                      ; metadata sector
2657   0F35 38 00 00      mov c, 0
2658   0F38 FD 79         mov g, b                      ; save lba
2659   0F3A 3B 31 34      mov d, transient_area
2660   0F3D 22 01         mov ah, $01                  ; 1 sector
2661   0F3F 07 8E 07      call ide_read_sect            ; read metadata sector
2662   0F42             fs_mkbin_add_to_dir_l2:
2663   0F42 BD 00         cmp byte[d], 0
2664   0F44 C6 4D 0F      je fs_mkbin_add_to_dir_null
2665   0F47 58 20 00      add d, fst_entry_size
2666   0F4A 0A 42 0F      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2667   0F4D             fs_mkbin_add_to_dir_null:
2668   0F4D FD 4D 31 20   mov si, user_data
2669   0F51 FD 50         mov di, d
2670   0F53 07 47 13      call _strcpy                  ; copy file name
2671   0F56 58 18 00      add d, 24                     ; skip name
2672   0F59 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2673   0F5B 3E            mov [d], al
2674   0F5C 58 03 00      add d, 3
2675   0F5F E4            pop a
2676   0F60 43            mov [d], a
2677   0F61 63 02 00      sub d, 2
2678   0F64 E5            pop b                         ; get file lba
2679   0F65 FD 43         mov [d], b                    ; save lba
2680   0F67               ; set file creation date  
2681   0F67 58 04 00      add d, 4
2682   0F6A 19 04         mov al, 4
2683   0F6C 05 01         syscall sys_rtc
2684   0F6E 1A            mov al, ah
2685   0F6F 3E            mov [d], al                   ; set day
2686   0F70 79            inc d
2687   0F71 19 05         mov al, 5
2688   0F73 05 01         syscall sys_rtc
2689   0F75 1A            mov al, ah
2690   0F76 3E            mov [d], al                   ; set month
2691   0F77 79            inc d
2692   0F78 19 06         mov al, 6
2693   0F7A 05 01         syscall sys_rtc
2694   0F7C 1A            mov al, ah
2695   0F7D 3E            mov [d], al                   ; set year
2696   0F7E             ; write sector into disk for new directory entry
2697   0F7E FD 27         mov b, g
2698   0F80 38 00 00      mov c, 0
2699   0F83 3B 31 34      mov d, transient_area
2700   0F86 22 01         mov ah, $01                   ; disk write, 1 sector
2701   0F88 07 B4 07      call ide_write_sect           ; write sector
2702   0F8B 19 01         mov al, 1
2703   0F8D 3D 19 1A      mov [sys_echo_on], al ; enable echo
2704   0F90 06            sysret
2705   0F91             
2706   0F91             ;------------------------------------------------------------------------------------------------------;
2707   0F91             ; pwd - print working directory
2708   0F91             ;------------------------------------------------------------------------------------------------------;    
2709   0F91             fs_pwd:
2710   0F91 3B B1 1F      mov d, filename
2711   0F94 19 00         mov al, 0
2712   0F96 3E            mov [d], al                   ; initialize path string 
2713   0F97 14 2E 1A      mov a, [current_dir_id]
2714   0F9A 07 FB 0A      call fs_dir_id_to_path_e0
2715   0F9D 3B B1 1F      mov d, filename
2716   0FA0 07 DB 12      call _strrev
2717   0FA3 07 EF 14      call _puts
2718   0FA6 07 9C 14      call printnl
2719   0FA9 06            sysret
2720   0FAA             
2721   0FAA             ;------------------------------------------------------------------------------------------------------;
2722   0FAA             ; get current directory lba
2723   0FAA             ; a: returned lba
2724   0FAA             ;------------------------------------------------------------------------------------------------------;
2725   0FAA             cmd_get_curr_dir_lba:
2726   0FAA 14 2E 1A      mov a, [current_dir_id]
2727   0FAD 06            sysret
2728   0FAE             
2729   0FAE             ;------------------------------------------------------------------------------------------------------;
2730   0FAE             ; cat
2731   0FAE             ; userspace destination data pointer in d
2732   0FAE             ; filename starts at d, but is overwritten after the read is made
2733   0FAE             ;------------------------------------------------------------------------------------------------------;:
2734   0FAE             fs_cat:
2735   0FAE DA            push d                              ; save userspace file data destination
2736   0FAF FD 4E         mov si, d
2737   0FB1 FD 4F 31 20   mov di, user_data
2738   0FB5 38 00 02      mov c, 512
2739   0FB8 04            load                                ; copy filename from user-space
2740   0FB9 29 2E 1A      mov b, [current_dir_id]
2741   0FBC FD 77         inc b                               ; metadata sector
2742   0FBE 38 00 00      mov c, 0                            ; upper lba = 0
2743   0FC1 22 01         mov ah, $01                  ; 1 sector
2744   0FC3 3B 31 32      mov d, transient_area-512
2745   0FC6 07 8E 07      call ide_read_sect                  ; read directory
2746   0FC9 FD 10         cla
2747   0FCB 42 26 1A      mov [index], a                      ; reset file counter
2748   0FCE             fs_cat_l1:
2749   0FCE FD 4E         mov si, d
2750   0FD0 FD 4F 31 20   mov di, user_data
2751   0FD4 07 32 13      call _strcmp
2752   0FD7 C6 ED 0F      je fs_cat_found_entry
2753   0FDA 58 20 00      add d, 32
2754   0FDD 14 26 1A      mov a, [index]
2755   0FE0 77            inc a
2756   0FE1 42 26 1A      mov [index], a
2757   0FE4 AF 10 00      cmp a, fst_files_per_dir
2758   0FE7 C6 08 10      je fs_cat_not_found
2759   0FEA 0A CE 0F      jmp fs_cat_l1
2760   0FED             fs_cat_found_entry:
2761   0FED 58 19 00      add d, 25                           ; get to dirid of file in disk
2762   0FF0 2A            mov b, [d]                          ; get lba
2763   0FF1 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2764   0FF3 3B 31 34      mov d, transient_area  
2765   0FF6 38 00 00      mov c, 0
2766   0FF9 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2767   0FFB 07 8E 07      call ide_read_sect                  ; read sectors
2768   0FFE F0            pop di                              ; write userspace file data destination to di
2769   0FFF FD 4D 31 34   mov si, transient_area              ; data origin
2770   1003 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2771   1006 03            store
2772   1007 06            sysret
2773   1008             fs_cat_not_found:
2774   1008 E7            pop d
2775   1009 06            sysret
2776   100A             
2777   100A             ;------------------------------------------------------------------------------------------------------;
2778   100A             ; rmdir - remove dir by dirid
2779   100A             ;------------------------------------------------------------------------------------------------------;
2780   100A             ; deletes a directory entry in the given directory's file list 
2781   100A             ; also deletes the actual directory entry in the fst
2782   100A             ; synopsis: rmdir /usr/local/testdir
2783   100A             ; b = dirid
2784   100A             fs_rmdir:
2785   100A FD 79         mov g, b
2786   100C 11            mov a, b
2787   100D 07 37 0B      call get_parentid_from_dirid  ; now get the directory's parent, in a
2788   1010 D7            push a                        ; save dirid
2789   1011             ; search for directory's entry in the parent's directory then and delete it
2790   1011 77            inc a                         ; metadata sector
2791   1012 27            mov b, a
2792   1013 38 00 00      mov c, 0                      ; upper lba = 0
2793   1016 22 01         mov ah, $01          ;
2794   1018 3B 31 34      mov d, transient_area
2795   101B 07 8E 07      call ide_read_sect            ; read directory
2796   101E FD 10         cla
2797   1020 42 26 1A      mov [index], a                ; reset file counter
2798   1023 FD 27         mov b, g                      ; retrieve directory's dirid
2799   1025             fs_rmdir_l1:
2800   1025 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2801   1028 B0            cmp a, b                      ; compare dirid's to find the directory
2802   1029 C6 3F 10      je fs_rmdir_found_entry
2803   102C 58 20 00      add d, 32
2804   102F 14 26 1A      mov a, [index]
2805   1032 77            inc a
2806   1033 42 26 1A      mov [index], a
2807   1036 AF 10 00      cmp a, fst_files_per_dir
2808   1039 C6 64 10      je fs_rmdir_not_found
2809   103C 0A 25 10      jmp fs_rmdir_l1
2810   103F             fs_rmdir_found_entry:
2811   103F FD 10         cla
2812   1041 3E            mov [d], al                   ; make filename null
2813   1042 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2814   1045 E5            pop b
2815   1046 FD 77         inc b                         ; metadata sector
2816   1048 38 00 00      mov c, 0                      ; upper lba = 0
2817   104B 22 01         mov ah, $01          ; 
2818   104D 3B 31 34      mov d, transient_area
2819   1050 07 B4 07      call ide_write_sect           ; write sector and erase file's entry in the current dir
2820   1053             
2821   1053 FD 27         mov b, g
2822   1055 3B 31 34      mov d, transient_area  
2823   1058 FD 10         cla
2824   105A 3E            mov [d], al                   ; make directory's name header null for re-use
2825   105B 38 00 00      mov c, 0
2826   105E 22 01         mov ah, $01                   ; disk write 1 sect
2827   1060 07 B4 07      call ide_write_sect           ; delete directory given by dirid in b
2828   1063 06            sysret
2829   1064             fs_rmdir_not_found:
2830   1064 E5            pop b
2831   1065 06            sysret
2832   1066             
2833   1066             ;------------------------------------------------------------------------------------------------------;
2834   1066             ; rm - remove file
2835   1066             ;------------------------------------------------------------------------------------------------------;
2836   1066             ; frees up the data sectors for the file further down the disk
2837   1066             ; deletes file entry in the directory's file list 
2838   1066             fs_rm:
2839   1066 FD 4E         mov si, d
2840   1068 FD 4F 31 20   mov di, user_data
2841   106C 38 00 02      mov c, 512
2842   106F 04            load                          ; load data from user-space
2843   1070 14 2E 1A      mov a, [current_dir_id]
2844   1073 77            inc a                         ; metadata sector
2845   1074 27            mov b, a
2846   1075 38 00 00      mov c, 0                      ; upper lba = 0
2847   1078 22 01         mov ah, $01                  ; 1 sector
2848   107A 3B 31 34      mov d, transient_area
2849   107D 07 8E 07      call ide_read_sect            ; read directory
2850   1080 10 00 00      mov a, 0
2851   1083 42 26 1A      mov [index], a                ; reset file counter
2852   1086             fs_rm_l1:
2853   1086 FD 4E         mov si, d
2854   1088 FD 4F 31 20   mov di, user_data
2855   108C 07 32 13      call _strcmp
2856   108F C6 A5 10      je fs_rm_found_entry
2857   1092 58 20 00      add d, 32
2858   1095 14 26 1A      mov a, [index]
2859   1098 77            inc a
2860   1099 42 26 1A      mov [index], a
2861   109C AF 10 00      cmp a, fst_files_per_dir
2862   109F C6 CD 10      je fs_rm_not_found
2863   10A2 0A 86 10      jmp fs_rm_l1
2864   10A5             fs_rm_found_entry:
2865   10A5 2B 19 00      mov b, [d + 25]               ; get lba
2866   10A8 FD 79         mov g, b                      ; save lba
2867   10AA 19 00         mov al, 0
2868   10AC 3E            mov [d], al                   ; make file entry null
2869   10AD 14 2E 1A      mov a, [current_dir_id]
2870   10B0 77            inc a                         ; metadata sector
2871   10B1 27            mov b, a
2872   10B2 38 00 00      mov c, 0                      ; upper lba = 0
2873   10B5 22 01         mov ah, $01                   ; disk write
2874   10B7 3B 31 34      mov d, transient_area
2875   10BA 07 B4 07      call ide_write_sect           ; write sector and erase file's entry in the current dir
2876   10BD 3B 31 34      mov d, transient_area  
2877   10C0 19 00         mov al, 0
2878   10C2 3E            mov [d], al                   ; make file's data header null for re-use
2879   10C3 38 00 00      mov c, 0
2880   10C6 FD 27         mov b, g                      ; get data header lba
2881   10C8 22 01         mov ah, $01                   ; disk write 1 sect
2882   10CA 07 B4 07      call ide_write_sect           ; write sector
2883   10CD             fs_rm_not_found:  
2884   10CD 06            sysret  
2885   10CE             
2886   10CE             ;------------------------------------------------------------------------------------------------------;
2887   10CE             ; mv - move / change file name
2888   10CE             ;------------------------------------------------------------------------------------------------------;
2889   10CE             fs_mv:
2890   10CE FD 4E         mov si, d
2891   10D0 FD 4F 31 20   mov di, user_data
2892   10D4 38 00 02      mov c, 512
2893   10D7 04            load                          ; load data from user-space
2894   10D8 14 2E 1A      mov a, [current_dir_id]
2895   10DB 77            inc a                         ; metadata sector
2896   10DC 27            mov b, a  
2897   10DD 38 00 00      mov c, 0                      ; upper lba = 0
2898   10E0 22 01         mov ah, $01                  ; 1 sector
2899   10E2 3B 31 34      mov d, transient_area
2900   10E5 07 8E 07      call ide_read_sect            ; read directory
2901   10E8 FD 10         cla
2902   10EA 42 26 1A      mov [index], a                ; reset file counter
2903   10ED             fs_mv_l1:
2904   10ED FD 4E         mov si, d
2905   10EF FD 4F 31 20   mov di, user_data
2906   10F3 07 32 13      call _strcmp
2907   10F6 C6 0C 11      je fs_mv_found_entry
2908   10F9 58 20 00      add d, 32
2909   10FC 14 26 1A      mov a, [index]
2910   10FF 77            inc a
2911   1100 42 26 1A      mov [index], a
2912   1103 AF 10 00      cmp a, fst_files_per_dir
2913   1106 C6 3E 11      je fs_mv_not_found
2914   1109 0A ED 10      jmp fs_mv_l1
2915   110C             fs_mv_found_entry:  
2916   110C DA            push d
2917   110D FD 4D B1 20   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2918   1111 FD 50         mov di, d
2919   1113 07 47 13      call _strcpy  
2920   1116 38 00 00      mov c, 0
2921   1119 3B 31 34      mov d, transient_area
2922   111C 22 01         mov ah, $01                   ; disk write 1 sect
2923   111E 07 B4 07      call ide_write_sect           ; write sector
2924   1121 E7            pop d
2925   1122             ;; need to check whether its a dir or a file here ;;;
2926   1122 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2927   1125 22 01         mov ah, $01
2928   1127 3B 31 34      mov d, transient_area
2929   112A 38 00 00      mov c, 0
2930   112D 07 8E 07      call ide_read_sect            ; read directory entry
2931   1130 FD 4D B1 20   mov si, user_data + 128
2932   1134 FD 50         mov di, d
2933   1136 07 47 13      call _strcpy                  ; change directory's name
2934   1139 22 01         mov ah, $01
2935   113B 07 B4 07      call ide_write_sect           ; rewrite directory back to disk
2936   113E             fs_mv_not_found:
2937   113E 06            sysret
2938   113F             
2939   113F             
2940   113F             ;----------------------------------------------------------------------------------------------------;
2941   113F             ; process index in a
2942   113F             ;----------------------------------------------------------------------------------------------------;
2943   113F             find_free_proc:
2944   113F FD 4D A2 1D   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2945   1143             find_free_proc_l0:
2946   1143 F6            lodsb                               ; get process state
2947   1144 B9 00         cmp al, 0
2948   1146 C6 4C 11      je find_free_proc_free              ; if free, jump
2949   1149 0A 43 11      jmp find_free_proc_l0               ; else, goto next
2950   114C             find_free_proc_free:
2951   114C 4E            mov a, si
2952   114D 5F A2 1D      sub a, 1 + proc_availab_table       ; get process index
2953   1150 09            ret
2954   1151               
2955   1151             
2956   1151             ;----------------------------------------------------------------------------------------------------;
2957   1151             ; process index in al
2958   1151             ;----------------------------------------------------------------------------------------------------;
2959   1151             proc_memory_map:
2960   1151 22 00         mov ah, 0
2961   1153 27            mov b, a                      ; page in bl, 0 in bh
2962   1154 FD 9D 05      shl a, 5                      ; multiply by 32
2963   1157 39            mov c, a                      ; save in c
2964   1158 57 20 00      add c, 32
2965   115B             proc_memory_map_l0:
2966   115B 02            pagemap
2967   115C 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2968   115F 53 01 00      add a, 1                      ; increase both 
2969   1162 B1            cmp a, c                      ; check to see if we reached the end of memory
2970   1163 C7 5B 11      jne proc_memory_map_l0
2971   1166 09            ret
2972   1167               
2973   1167             
2974   1167             ;----------------------------------------------------------------------------------------------------;
2975   1167             ; terminate process
2976   1167             ;----------------------------------------------------------------------------------------------------;
2977   1167             syscall_terminate_proc:
2978   1167 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2979   116A                                                    ; since they will not be used for anything here.
2980   116A 1D 25 1A      mov al, [active_proc_index]
2981   116D 22 00         mov ah, 0  
2982   116F FD 9D 05      shl a, 5                             ; x32
2983   1172 53 B1 1D      add a, proc_names
2984   1175 3C            mov d, a
2985   1176 19 00         mov al, 0
2986   1178 3E            mov [d], al                           ; nullify process name
2987   1179             
2988   1179 1D 25 1A      mov al, [active_proc_index]
2989   117C 22 00         mov ah, 0  
2990   117E 3C            mov d, a
2991   117F 19 00         mov al, 0
2992   1181 3F A1 1D      mov [d + proc_availab_table], al    ; make process empty again
2993   1184               
2994   1184 1D 24 1A      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2995   1187 80            dec al
2996   1188 3D 24 1A      mov [nbr_active_procs], al
2997   118B             
2998   118B             ; now load the shell process again
2999   118B 19 02         mov al, 2                           ; next process = process 2 = shell
3000   118D 3D 25 1A      mov [active_proc_index], al         ; set next active proc
3001   1190             
3002   1190             ; calculate lut entry for next process
3003   1190 22 00         mov ah, 0
3004   1192 FD 99         shl a                               ; x2
3005   1194 B7 5D 12      mov a, [proc_table_convert + a]     ; get process state start index  
3006   1197               
3007   1197 4D            mov si, a                           ; source is proc state block
3008   1198 48            mov a, sp
3009   1199 5F 13 00      sub a, 19
3010   119C 4F            mov di, a                           ; destination is kernel stack
3011   119D             ; restore sp
3012   119D 7D            dec a
3013   119E 47            mov sp, a
3014   119F 38 14 00      mov c, 20
3015   11A2 FD F5         rep movsb
3016   11A4             ; set vm process
3017   11A4 1D 25 1A      mov al, [active_proc_index]
3018   11A7 01            setptb
3019   11A8                 
3020   11A8 4C            popa
3021   11A9 06            sysret
3022   11AA             
3023   11AA             ;----------------------------------------------------------------------------------------------------;
3024   11AA             ; pause process
3025   11AA             ;----------------------------------------------------------------------------------------------------;
3026   11AA             syscall_pause_proc:
3027   11AA             ; save all registers into kernel stack
3028   11AA 4B            pusha
3029   11AB 22 00         mov ah, 0
3030   11AD 1D 25 1A      mov al, [active_proc_index]
3031   11B0 FD 99         shl a              ; x2
3032   11B2 B7 5D 12      mov a, [proc_table_convert + a]   ; get process state start index
3033   11B5                 
3034   11B5 4F            mov di, a
3035   11B6 48            mov a, sp
3036   11B7 77            inc a
3037   11B8 4D            mov si, a
3038   11B9 38 14 00      mov c, 20
3039   11BC FD F5         rep movsb                         ; save process state!
3040   11BE             ; restore kernel stack position to point before interrupt arrived
3041   11BE 51 14 00      add sp, 20
3042   11C1             ; now load the shell process again
3043   11C1 19 02         mov al, 2                         ; next process = process 2 = shell
3044   11C3 3D 25 1A      mov [active_proc_index], al       ; set next active proc
3045   11C6             
3046   11C6             ; calculate lut entry for next process
3047   11C6 22 00         mov ah, 0
3048   11C8 FD 99         shl a                             ; x2
3049   11CA B7 5D 12      mov a, [proc_table_convert + a]   ; get process state start index  
3050   11CD               
3051   11CD 4D            mov si, a                         ; source is proc state block
3052   11CE 48            mov a, sp
3053   11CF 5F 13 00      sub a, 19
3054   11D2 4F            mov di, a                         ; destination is kernel stack
3055   11D3             ; restore sp
3056   11D3 7D            dec a
3057   11D4 47            mov sp, a
3058   11D5 38 14 00      mov c, 20
3059   11D8 FD F5         rep movsb
3060   11DA             ; set vm process
3061   11DA 1D 25 1A      mov al, [active_proc_index]
3062   11DD 01            setptb
3063   11DE                 
3064   11DE 4C            popa
3065   11DF 06            sysret
3066   11E0             
3067   11E0             ;----------------------------------------------------------------------------------------------------;
3068   11E0             ; create a new process
3069   11E0             ; d = path of the process file to be createed
3070   11E0             ; b = arguments ptr
3071   11E0             ;----------------------------------------------------------------------------------------------------;
3072   11E0             syscall_create_proc:
3073   11E0             ; we save the active process first  
3074   11E0 4B            pusha
3075   11E1 22 00         mov ah, 0
3076   11E3 1D 25 1A      mov al, [active_proc_index]
3077   11E6 FD 99         shl a              ; x2
3078   11E8 B7 5D 12      mov a, [proc_table_convert + a]    ; get process state table's start index
3079   11EB               
3080   11EB 4F            mov di, a
3081   11EC 48            mov a, sp
3082   11ED 77            inc a
3083   11EE 4D            mov si, a
3084   11EF 38 14 00      mov c, 20
3085   11F2 FD F5         rep movsb                          ; save process state!
3086   11F4             ; restore kernel stack position to point before interrupt arrived
3087   11F4 51 14 00      add sp, 20
3088   11F7               
3089   11F7 FD 4E         mov si, d                          ; copy the file path
3090   11F9 FD 4F 31 20   mov di, user_data
3091   11FD 38 00 02      mov c, 512
3092   1200 04            load
3093   1201 11            mov a, b
3094   1202 4D            mov si, a                          ; copy the arguments
3095   1203 FD 4F 31 32   mov di, scrap_sector
3096   1207 38 00 02      mov c, 512
3097   120A 04            load
3098   120B 07 7D 0C      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
3099   120E                                                  ; the file data is loaded into transient_area
3100   120E             ; now we allocate a new process  
3101   120E 07 3F 11      call find_free_proc                ; index in a
3102   1211 01            setptb 
3103   1212 07 51 11      call proc_memory_map               ; map process memory pages
3104   1215             ; copy arguments into process's memory
3105   1215 FD 4D 31 32   mov si, scrap_sector
3106   1219 FD 4F 00 00   mov di, 0
3107   121D 38 00 02      mov c, 512
3108   1220 03            store
3109   1221             ; now copy process binary data into process's memory
3110   1221 FD 4D 31 34   mov si, transient_area
3111   1225 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
3112   1229 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
3113   122C 03            store                              ; copy process data
3114   122D                 
3115   122D 07 3F 11      call find_free_proc                ; index in a
3116   1230 3D 25 1A      mov [active_proc_index], al        ; set new active process
3117   1233 FD 9D 05      shl a, 5                           ; x32
3118   1236 53 B1 1D      add a, proc_names
3119   1239 4F            mov di, a
3120   123A FD 4D 31 20   mov si, user_data                  ; copy and store process filename
3121   123E 07 47 13      call _strcpy
3122   1241               
3123   1241 07 3F 11      call find_free_proc                ; index in a
3124   1244 3C            mov d, a
3125   1245 19 01         mov al, 1
3126   1247 3F A1 1D      mov [d + proc_availab_table], al   ; make process busy
3127   124A               
3128   124A 1D 24 1A      mov al, [nbr_active_procs]         ; increase nbr of active processes
3129   124D 7A            inc al
3130   124E 3D 24 1A      mov [nbr_active_procs], al
3131   1251             ; launch process
3132   1251 FD D7 FF FF   push word $ffff 
3133   1255 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
3134   1258 FD D7 00 04   push word text_org
3135   125C 06            sysret
3136   125D             
3137   125D             proc_table_convert:
3138   125D 61 1C         .dw proc_state_table + 0
3139   125F 75 1C         .dw proc_state_table + 20
3140   1261 89 1C         .dw proc_state_table + 40
3141   1263 9D 1C         .dw proc_state_table + 60
3142   1265 B1 1C         .dw proc_state_table + 80
3143   1267 C5 1C         .dw proc_state_table + 100
3144   1269 D9 1C         .dw proc_state_table + 120
3145   126B ED 1C         .dw proc_state_table + 140
3146   126D               
3147   126D             ;----------------------------------------------------------------------------------------------;
3148   126D             ; get hex file
3149   126D             ; di = destination address
3150   126D             ; return length in bytes in c
3151   126D             ;----------------------------------------------------------------------------------------------;
3152   126D             _load_hex:
3153   126D D7            push a
3154   126E D8            push b
3155   126F DA            push d
3156   1270 E2            push si
3157   1271 E3            push di
3158   1272 38 00 00      mov c, 0
3159   1275 50            mov a, di
3160   1276 3C            mov d, a          ; start of string data block
3161   1277 07 CA 13      call _gets        ; get program string
3162   127A 4D            mov si, a
3163   127B             __load_hex_loop:
3164   127B F6            lodsb             ; load from [si] to al
3165   127C B9 00         cmp al, 0         ; check if ascii 0
3166   127E C6 8C 12      jz __load_hex_ret
3167   1281 36            mov bh, al
3168   1282 F6            lodsb
3169   1283 2F            mov bl, al
3170   1284 07 80 13      call _atoi        ; convert ascii byte in b to int (to al)
3171   1287 F7            stosb             ; store al to [di]
3172   1288 78            inc c
3173   1289 0A 7B 12      jmp __load_hex_loop
3174   128C             __load_hex_ret:
3175   128C F0            pop di
3176   128D EF            pop si
3177   128E E7            pop d
3178   128F E5            pop b
3179   1290 E4            pop a
3180   1291 09            ret
3181   1292             
3182   1292             ; synopsis: look inside a certain directory for files/directories
3183   1292             ; before calling this function, cd into required directory
3184   1292             ; for each entry inside directory:
3185   1292             ;  if entry is a file:
3186   1292             ;    compare filename to searched filename
3187   1292             ;    if filenames are the same, print filename
3188   1292             ;  else if entry is a directory:
3189   1292             ;    cd to the given directory
3190   1292             ;    recursively call cmd_find
3191   1292             ;    cd outside previous directory
3192   1292             ;  if current entry == last entry, return
3193   1292             ; endfor
3194   1292             f_find:
3195   1292 09            ret
3196   1293             
3197   1293             
3198   1293             ; ---------------------------------------------------------------------
3199   1293             ; kernel reset vector
3200   1293             ; ---------------------------------------------------------------------
3201   1293             kernel_reset_vector:  
3202   1293 FD 49 FF F7   mov bp, _stack_begin
3203   1297 FD 47 FF F7   mov sp, _stack_begin
3204   129B               
3205   129B 19 A1         mov al, %10100001             ; mask out timer interrupt for now - enable uarts and fdc irqs 
3206   129D FD 0F         stomsk                        
3207   129F FD 0C         sti  
3208   12A1             
3209   12A1 0C            lodstat
3210   12A2 87 DF         and al, %11011111             ; disable display register loading
3211   12A4 0D            stostat
3212   12A5               
3213   12A5             ; reset fifo pointers
3214   12A5 10 31 22      mov a, fifo
3215   12A8 3B 2A 1A      mov d, fifo_in
3216   12AB 43            mov [d], a
3217   12AC 3B 2C 1A      mov d, fifo_out
3218   12AF 43            mov [d], a  
3219   12B0 19 02         mov al, 2
3220   12B2 05 03         syscall sys_io                ; enable uart in interrupt mode
3221   12B4             
3222   12B4 3B 7F 1A      mov d, s_kernel_welcome
3223   12B7 07 EF 14      call _puts
3224   12BA             
3225   12BA 3B 20 1C      mov d, s_fdc_config
3226   12BD 07 EF 14      call _puts
3227   12C0 F2 C0 FF 0D   mov byte [_fdc_config], %00001101  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
3228   12C4 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011     ; leave this restore command in order to clear BUSY flag
3229   12C8 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
3230   12CC             
3231   12CC 19 10         mov al, 16
3232   12CE 05 04         syscall sys_filesystem        ; set root dirid
3233   12D0             
3234   12D0 3B 43 1B      mov d, s_prompt_init
3235   12D3 07 EF 14      call _puts
3236   12D6 3B 30 1A      mov d, s_init_path
3237   12D9 05 05         syscall sys_create_proc       ; launch init as a new process
3238   12DB             
3239   12DB             ; file includes
3240   12DB             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  12DB             boot_origin      .EQU  $8004
0002+  12DB             bios_uart        .EQU  $0002
0003+  12DB             bios_ide         .EQU  $0003
0004+  12DB             bios_reset_vector .EQU  $01c0
0005+  12DB             ide_buffer       .EQU  $8204
3241   12DB             .include "lib/stdio.asm"
0001+  12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  12DB             ; stdio.s
0003+  12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  12DB             .include "lib/string.asm"
0001++ 12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 12DB             ; string.s
0003++ 12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 12DB             
0005++ 12DB             
0006++ 12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 12DB             ; _strrev
0008++ 12DB             ; reverse a string
0009++ 12DB             ; d = string address
0010++ 12DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 12DB             ; 01234
0012++ 12DB             _strrev:
0013++ 12DB 4B          	pusha
0014++ 12DC 07 22 13    	call _strlen	; length in c
0015++ 12DF 12          	mov a, c
0016++ 12E0 AF 01 00    	cmp a, 1
0017++ 12E3 D0 FD 12    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 12E6 7D          	dec a
0019++ 12E7 FD 4E       	mov si, d	; beginning of string
0020++ 12E9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 12EB 59          	add d, a	; end of string
0022++ 12EC 12          	mov a, c
0023++ 12ED FD 9B       	shr a		; divide by 2
0024++ 12EF 39          	mov c, a	; c now counts the steps
0025++ 12F0             _strrev_l0:
0026++ 12F0 32          	mov bl, [d]	; save load right-side char into bl
0027++ 12F1 F6          	lodsb		; load left-side char into al; increase si
0028++ 12F2 3E          	mov [d], al	; store left char into right side
0029++ 12F3 1B          	mov al, bl
0030++ 12F4 F7          	stosb		; store right-side char into left-side; increase di
0031++ 12F5 7E          	dec c
0032++ 12F6 7F          	dec d
0033++ 12F7 C2 00 00    	cmp c, 0
0034++ 12FA C7 F0 12    	jne _strrev_l0
0035++ 12FD             _strrev_end:
0036++ 12FD 4C          	popa
0037++ 12FE 09          	ret
0038++ 12FF             	
0039++ 12FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 12FF             ; _strchr
0041++ 12FF             ; search string in d for char in al
0042++ 12FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 12FF             _strchr:
0044++ 12FF             _strchr_l0:
0045++ 12FF 32          	mov bl, [d]
0046++ 1300 C1 00       	cmp bl, 0
0047++ 1302 C6 0D 13    	je _strchr_end
0048++ 1305 BA          	cmp al, bl
0049++ 1306 C6 0D 13    	je _strchr_end
0050++ 1309 79          	inc d
0051++ 130A 0A FF 12    	jmp _strchr_l0
0052++ 130D             _strchr_end:
0053++ 130D 1B          	mov al, bl
0054++ 130E 09          	ret
0055++ 130F             
0056++ 130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 130F             ; _strstr
0058++ 130F             ; find sub-string
0059++ 130F             ; str1 in si
0060++ 130F             ; str2 in di
0061++ 130F             ; si points to end of source string
0062++ 130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 130F             _strstr:
0064++ 130F DB          	push al
0065++ 1310 DA          	push d
0066++ 1311 E3          	push di
0067++ 1312             _strstr_loop:
0068++ 1312 F3          	cmpsb					; compare a byte of the strings
0069++ 1313 C7 1E 13    	jne _strstr_ret
0070++ 1316 FC 00 00    	lea d, [di + 0]
0071++ 1319 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 131B C7 12 13    	jne _strstr_loop				; equal chars but not at end
0073++ 131E             _strstr_ret:
0074++ 131E F0          	pop di
0075++ 131F E7          	pop d
0076++ 1320 E8          	pop al
0077++ 1321 09          	ret
0078++ 1322             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1322             ; length of null terminated string
0080++ 1322             ; result in c
0081++ 1322             ; pointer in d
0082++ 1322             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1322             _strlen:
0084++ 1322 DA          	push d
0085++ 1323 38 00 00    	mov c, 0
0086++ 1326             _strlen_l1:
0087++ 1326 BD 00       	cmp byte [d], 0
0088++ 1328 C6 30 13    	je _strlen_ret
0089++ 132B 79          	inc d
0090++ 132C 78          	inc c
0091++ 132D 0A 26 13    	jmp _strlen_l1
0092++ 1330             _strlen_ret:
0093++ 1330 E7          	pop d
0094++ 1331 09          	ret
0095++ 1332             
0096++ 1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1332             ; strcmp
0098++ 1332             ; compare two strings
0099++ 1332             ; str1 in si
0100++ 1332             ; str2 in di
0101++ 1332             ; create a string compairon instrucion ?????
0102++ 1332             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1332             _strcmp:
0104++ 1332 DB          	push al
0105++ 1333 DA          	push d
0106++ 1334 E3          	push di
0107++ 1335 E2          	push si
0108++ 1336             _strcmp_loop:
0109++ 1336 F3          	cmpsb					; compare a byte of the strings
0110++ 1337 C7 42 13    	jne _strcmp_ret
0111++ 133A FB FF FF    	lea d, [si +- 1]
0112++ 133D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 133F C7 36 13    	jne _strcmp_loop				; equal chars but not at end
0114++ 1342             _strcmp_ret:
0115++ 1342 EF          	pop si
0116++ 1343 F0          	pop di
0117++ 1344 E7          	pop d
0118++ 1345 E8          	pop al
0119++ 1346 09          	ret
0120++ 1347             
0121++ 1347             
0122++ 1347             ; strcpy
0123++ 1347             ; copy null terminated string from si to di
0124++ 1347             ; source in si
0125++ 1347             ; destination in di
0126++ 1347             _strcpy:
0127++ 1347 E2          	push si
0128++ 1348 E3          	push di
0129++ 1349 DB          	push al
0130++ 134A             _strcpy_l1:
0131++ 134A F6          	lodsb
0132++ 134B F7          	stosb
0133++ 134C B9 00       	cmp al, 0
0134++ 134E C7 4A 13    	jne _strcpy_l1
0135++ 1351             _strcpy_end:
0136++ 1351 E8          	pop al
0137++ 1352 F0          	pop di
0138++ 1353 EF          	pop si
0139++ 1354 09          	ret
0140++ 1355             
0141++ 1355             ; strcat
0142++ 1355             ; concatenate a null terminated string into string at di, from string at si
0143++ 1355             ; source in si
0144++ 1355             ; destination in di
0145++ 1355             _strcat:
0146++ 1355 E2          	push si
0147++ 1356 E3          	push di
0148++ 1357 D7          	push a
0149++ 1358 DA          	push d
0150++ 1359 50          	mov a, di
0151++ 135A 3C          	mov d, a
0152++ 135B             _strcat_goto_end_l1:
0153++ 135B BD 00       	cmp byte[d], 0
0154++ 135D C6 64 13    	je _strcat_start
0155++ 1360 79          	inc d
0156++ 1361 0A 5B 13    	jmp _strcat_goto_end_l1
0157++ 1364             _strcat_start:
0158++ 1364 FD 50       	mov di, d
0159++ 1366             _strcat_l1:
0160++ 1366 F6          	lodsb
0161++ 1367 F7          	stosb
0162++ 1368 B9 00       	cmp al, 0
0163++ 136A C7 66 13    	jne _strcat_l1
0164++ 136D             _strcat_end:
0165++ 136D E7          	pop d
0166++ 136E E4          	pop a
0167++ 136F F0          	pop di
0168++ 1370 EF          	pop si
0169++ 1371 09          	ret
0170++ 1372             
0171++ 1372             
0005+  1372             
0006+  1372             
0007+  1372             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1372             ; convert ascii 'o'..'f' to integer 0..15
0009+  1372             ; ascii in bl
0010+  1372             ; result in al
0011+  1372             ; ascii for f = 0100 0110
0012+  1372             ; ascii for 9 = 0011 1001
0013+  1372             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1372             hex_ascii_encode:
0015+  1372 1B            mov al, bl
0016+  1373 93 40         test al, $40        ; test if letter or number
0017+  1375 C7 7B 13      jnz hex_letter
0018+  1378 87 0F         and al, $0f        ; get number
0019+  137A 09            ret
0020+  137B             hex_letter:
0021+  137B 87 0F         and al, $0f        ; get letter
0022+  137D 6A 09         add al, 9
0023+  137F 09            ret
0024+  1380             
0025+  1380             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1380             ; atoi
0027+  1380             ; 2 letter hex string in b
0028+  1380             ; 8bit integer returned in al
0029+  1380             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1380             _atoi:
0031+  1380 D8            push b
0032+  1381 07 72 13      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  1384 30            mov bl, bh
0034+  1385 DB            push al          ; save a
0035+  1386 07 72 13      call hex_ascii_encode
0036+  1389 EA            pop bl  
0037+  138A FD 9E 04      shl al, 4
0038+  138D 8C            or al, bl
0039+  138E E5            pop b
0040+  138F 09            ret  
0041+  1390             
0042+  1390             
0043+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1390             ; scanf
0045+  1390             ; no need for explanations!
0046+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1390             scanf:
0048+  1390 09            ret
0049+  1391             
0050+  1391             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1391             ; itoa
0052+  1391             ; 8bit value in bl
0053+  1391             ; 2 byte ascii result in a
0054+  1391             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1391             _itoa:
0056+  1391 DA            push d
0057+  1392 D8            push b
0058+  1393 A7 00         mov bh, 0
0059+  1395 FD A4 04      shr bl, 4  
0060+  1398 74            mov d, b
0061+  1399 1F 2B 16      mov al, [d + s_hex_digits]
0062+  139C 23            mov ah, al
0063+  139D               
0064+  139D E5            pop b
0065+  139E D8            push b
0066+  139F A7 00         mov bh, 0
0067+  13A1 FD 87 0F      and bl, $0f
0068+  13A4 74            mov d, b
0069+  13A5 1F 2B 16      mov al, [d + s_hex_digits]
0070+  13A8 E5            pop b
0071+  13A9 E7            pop d
0072+  13AA 09            ret
0073+  13AB             
0074+  13AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  13AB             ; hex string to binary
0076+  13AB             ; di = destination address
0077+  13AB             ; si = source
0078+  13AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  13AB             _hex_to_int:
0080+  13AB             _hex_to_int_l1:
0081+  13AB F6            lodsb          ; load from [si] to al
0082+  13AC B9 00         cmp al, 0        ; check if ascii 0
0083+  13AE C6 BB 13      jz _hex_to_int_ret
0084+  13B1 36            mov bh, al
0085+  13B2 F6            lodsb
0086+  13B3 2F            mov bl, al
0087+  13B4 07 80 13      call _atoi        ; convert ascii byte in b to int (to al)
0088+  13B7 F7            stosb          ; store al to [di]
0089+  13B8 0A AB 13      jmp _hex_to_int_l1
0090+  13BB             _hex_to_int_ret:
0091+  13BB 09            ret    
0092+  13BC             
0093+  13BC             
0094+  13BC             
0095+  13BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  13BC             ; getchar
0097+  13BC             ; char in ah
0098+  13BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  13BC             getch:
0100+  13BC DB            push al
0101+  13BD             getch_retry:
0102+  13BD 19 01         mov al, 1
0103+  13BF 05 03         syscall sys_io      ; receive in ah
0104+  13C1 E8            pop al
0105+  13C2 09            ret
0106+  13C3             
0107+  13C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  13C3             ; putchar
0109+  13C3             ; char in ah
0110+  13C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  13C3             _putchar:
0112+  13C3 DB            push al
0113+  13C4 19 00         mov al, 0
0114+  13C6 05 03         syscall sys_io      ; char in ah
0115+  13C8 E8            pop al
0116+  13C9 09            ret
0117+  13CA             
0118+  13CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  13CA             ;; input a string
0120+  13CA             ;; terminates with null
0121+  13CA             ;; pointer in d
0122+  13CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  13CA             _gets:
0124+  13CA D7            push a
0125+  13CB DA            push d
0126+  13CC             _gets_loop:
0127+  13CC 19 01         mov al, 1
0128+  13CE 05 03         syscall sys_io      ; receive in ah
0129+  13D0 76 1B         cmp ah, 27
0130+  13D2 C6 F3 13      je _gets_ansi_esc
0131+  13D5 76 0A         cmp ah, $0a        ; lf
0132+  13D7 C6 4F 14      je _gets_end
0133+  13DA 76 0D         cmp ah, $0d        ; cr
0134+  13DC C6 4F 14      je _gets_end
0135+  13DF 76 5C         cmp ah, $5c        ; '\\'
0136+  13E1 C6 15 14      je _gets_escape
0137+  13E4 76 08         cmp ah, $08      ; check for backspace
0138+  13E6 C6 EF 13      je _gets_backspace
0139+  13E9 1A            mov al, ah
0140+  13EA 3E            mov [d], al
0141+  13EB 79            inc d
0142+  13EC 0A CC 13      jmp _gets_loop
0143+  13EF             _gets_backspace:
0144+  13EF 7F            dec d
0145+  13F0 0A CC 13      jmp _gets_loop
0146+  13F3             _gets_ansi_esc:
0147+  13F3 19 01         mov al, 1
0148+  13F5 05 03         syscall sys_io        ; receive in ah without echo
0149+  13F7 76 5B         cmp ah, '['
0150+  13F9 C7 CC 13      jne _gets_loop
0151+  13FC 19 01         mov al, 1
0152+  13FE 05 03         syscall sys_io          ; receive in ah without echo
0153+  1400 76 64         cmp ah, 'd'
0154+  1402 C6 0D 14      je _gets_left_arrow
0155+  1405 76 63         cmp ah, 'c'
0156+  1407 C6 11 14      je _gets_right_arrow
0157+  140A 0A CC 13      jmp _gets_loop
0158+  140D             _gets_left_arrow:
0159+  140D 7F            dec d
0160+  140E 0A CC 13      jmp _gets_loop
0161+  1411             _gets_right_arrow:
0162+  1411 79            inc d
0163+  1412 0A CC 13      jmp _gets_loop
0164+  1415             _gets_escape:
0165+  1415 19 01         mov al, 1
0166+  1417 05 03         syscall sys_io      ; receive in ah
0167+  1419 76 6E         cmp ah, 'n'
0168+  141B C6 3A 14      je _gets_lf
0169+  141E 76 72         cmp ah, 'r'
0170+  1420 C6 41 14      je _gets_cr
0171+  1423 76 30         cmp ah, '0'
0172+  1425 C6 48 14      je _gets_null
0173+  1428 76 5C         cmp ah, $5c  ; '\'
0174+  142A C6 33 14      je _gets_slash
0175+  142D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  142E 3E            mov [d], al
0177+  142F 79            inc d
0178+  1430 0A CC 13      jmp _gets_loop
0179+  1433             _gets_slash:
0180+  1433 19 5C         mov al, $5c
0181+  1435 3E            mov [d], al
0182+  1436 79            inc d
0183+  1437 0A CC 13      jmp _gets_loop
0184+  143A             _gets_lf:
0185+  143A 19 0A         mov al, $0a
0186+  143C 3E            mov [d], al
0187+  143D 79            inc d
0188+  143E 0A CC 13      jmp _gets_loop
0189+  1441             _gets_cr:
0190+  1441 19 0D         mov al, $0d
0191+  1443 3E            mov [d], al
0192+  1444 79            inc d
0193+  1445 0A CC 13      jmp _gets_loop
0194+  1448             _gets_null:
0195+  1448 19 00         mov al, $00
0196+  144A 3E            mov [d], al
0197+  144B 79            inc d
0198+  144C 0A CC 13      jmp _gets_loop
0199+  144F             _gets_end:
0200+  144F 19 00         mov al, 0
0201+  1451 3E            mov [d], al        ; terminate string
0202+  1452 E7            pop d
0203+  1453 E4            pop a
0204+  1454 09            ret
0205+  1455             
0206+  1455             
0207+  1455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1455             ;; input text
0209+  1455             ;; terminated with ctrl+d
0210+  1455             ;; pointer in d
0211+  1455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1455             _gettxt:
0213+  1455 D7            push a
0214+  1456 DA            push d
0215+  1457             _gettxt_loop:
0216+  1457 19 01         mov al, 1
0217+  1459 05 03         syscall sys_io      ; receive in ah
0218+  145B 76 04         cmp ah, 4      ; eot
0219+  145D C6 96 14      je _gettxt_end
0220+  1460 76 08         cmp ah, $08      ; check for backspace
0221+  1462 C6 92 14      je _gettxt_backspace
0222+  1465 76 5C         cmp ah, $5c        ; '\'
0223+  1467 C6 70 14      je _gettxt_escape
0224+  146A 1A            mov al, ah
0225+  146B 3E            mov [d], al
0226+  146C 79            inc d
0227+  146D 0A 57 14      jmp _gettxt_loop
0228+  1470             _gettxt_escape:
0229+  1470 19 01         mov al, 1
0230+  1472 05 03         syscall sys_io      ; receive in ah
0231+  1474 76 6E         cmp ah, 'n'
0232+  1476 C6 84 14      je _gettxt_lf
0233+  1479 76 72         cmp ah, 'r'
0234+  147B C6 8B 14      je _gettxt_cr
0235+  147E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  147F 3E            mov [d], al
0237+  1480 79            inc d
0238+  1481 0A 57 14      jmp _gettxt_loop
0239+  1484             _gettxt_lf:
0240+  1484 19 0A         mov al, $0a
0241+  1486 3E            mov [d], al
0242+  1487 79            inc d
0243+  1488 0A 57 14      jmp _gettxt_loop
0244+  148B             _gettxt_cr:
0245+  148B 19 0D         mov al, $0d
0246+  148D 3E            mov [d], al
0247+  148E 79            inc d
0248+  148F 0A 57 14      jmp _gettxt_loop
0249+  1492             _gettxt_backspace:
0250+  1492 7F            dec d
0251+  1493 0A 57 14      jmp _gettxt_loop
0252+  1496             _gettxt_end:
0253+  1496 19 00         mov al, 0
0254+  1498 3E            mov [d], al        ; terminate string
0255+  1499 E7            pop d
0256+  149A E4            pop a
0257+  149B 09            ret
0258+  149C             
0259+  149C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  149C             ; print new line
0261+  149C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  149C             printnl:
0263+  149C D7            push a
0264+  149D 10 00 0A      mov a, $0a00
0265+  14A0 05 03         syscall sys_io
0266+  14A2 10 00 0D      mov a, $0d00
0267+  14A5 05 03         syscall sys_io
0268+  14A7 E4            pop a
0269+  14A8 09            ret
0270+  14A9             
0271+  14A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  14A9             ; _strtoint
0273+  14A9             ; 4 digit hex string number in d
0274+  14A9             ; integer returned in a
0275+  14A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  14A9             _strtointx:
0277+  14A9 D8            push b
0278+  14AA 32            mov bl, [d]
0279+  14AB 37            mov bh, bl
0280+  14AC 33 01 00      mov bl, [d + 1]
0281+  14AF 07 80 13      call _atoi        ; convert to int in al
0282+  14B2 23            mov ah, al        ; move to ah
0283+  14B3 33 02 00      mov bl, [d + 2]
0284+  14B6 37            mov bh, bl
0285+  14B7 33 03 00      mov bl, [d + 3]
0286+  14BA 07 80 13      call _atoi        ; convert to int in al
0287+  14BD E5            pop b
0288+  14BE 09            ret
0289+  14BF             
0290+  14BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  14BF             ; _strtoint
0292+  14BF             ; 5 digit base10 string number in d
0293+  14BF             ; integer returned in a
0294+  14BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  14BF             _strtoint:
0296+  14BF E2            push si
0297+  14C0 D8            push b
0298+  14C1 D9            push c
0299+  14C2 DA            push d
0300+  14C3 07 22 13      call _strlen      ; get string length in c
0301+  14C6 7E            dec c
0302+  14C7 FD 4E         mov si, d
0303+  14C9 12            mov a, c
0304+  14CA FD 99         shl a
0305+  14CC 3B 43 16      mov d, table_power
0306+  14CF 59            add d, a
0307+  14D0 38 00 00      mov c, 0
0308+  14D3             _strtoint_l0:
0309+  14D3 F6            lodsb      ; load ascii to al
0310+  14D4 B9 00         cmp al, 0
0311+  14D6 C6 E9 14      je _strtoint_end
0312+  14D9 6F 30         sub al, $30    ; make into integer
0313+  14DB 22 00         mov ah, 0
0314+  14DD 2A            mov b, [d]
0315+  14DE AC            mul a, b      ; result in b since it fits in 16bits
0316+  14DF 11            mov a, b
0317+  14E0 28            mov b, c
0318+  14E1 54            add a, b
0319+  14E2 39            mov c, a
0320+  14E3 63 02 00      sub d, 2
0321+  14E6 0A D3 14      jmp _strtoint_l0
0322+  14E9             _strtoint_end:
0323+  14E9 12            mov a, c
0324+  14EA E7            pop d
0325+  14EB E6            pop c
0326+  14EC E5            pop b
0327+  14ED EF            pop si
0328+  14EE 09            ret
0329+  14EF             
0330+  14EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  14EF             ; print null terminated string
0332+  14EF             ; pointer in d
0333+  14EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  14EF             _puts:
0335+  14EF D7            push a
0336+  14F0 DA            push d
0337+  14F1             _puts_l1:
0338+  14F1 1E            mov al, [d]
0339+  14F2 B9 00         cmp al, 0
0340+  14F4 C6 00 15      jz _puts_end
0341+  14F7 23            mov ah, al
0342+  14F8 19 00         mov al, 0
0343+  14FA 05 03         syscall sys_io
0344+  14FC 79            inc d
0345+  14FD 0A F1 14      jmp _puts_l1
0346+  1500             _puts_end:
0347+  1500 E7            pop d
0348+  1501 E4            pop a
0349+  1502 09            ret
0350+  1503             
0351+  1503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1503             ; print n size string
0353+  1503             ; pointer in d
0354+  1503             ; size in c
0355+  1503             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1503             _putsn:
0357+  1503 DB            push al
0358+  1504 DA            push d
0359+  1505 D9            push c
0360+  1506             _putsn_l0:
0361+  1506 1E            mov al, [d]
0362+  1507 23            mov ah, al
0363+  1508 19 00         mov al, 0
0364+  150A 05 03         syscall sys_io
0365+  150C 79            inc d
0366+  150D 7E            dec c  
0367+  150E C2 00 00      cmp c, 0
0368+  1511 C7 06 15      jne _putsn_l0
0369+  1514             _putsn_end:
0370+  1514 E6            pop c
0371+  1515 E7            pop d
0372+  1516 E8            pop al
0373+  1517 09            ret
0374+  1518             
0375+  1518             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1518             ; print 16bit decimal number
0377+  1518             ; input number in a
0378+  1518             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1518             print_u16d:
0380+  1518 D7            push a
0381+  1519 D8            push b
0382+  151A FD D8         push g
0383+  151C 26 10 27      mov b, 10000
0384+  151F AE            div a, b      ; get 10000's coeff.
0385+  1520 07 44 15      call print_number
0386+  1523 11            mov a, b
0387+  1524 26 E8 03      mov b, 1000
0388+  1527 AE            div a, b      ; get 1000's coeff.
0389+  1528 07 44 15      call print_number
0390+  152B 11            mov a, b
0391+  152C 26 64 00      mov b, 100
0392+  152F AE            div a, b
0393+  1530 07 44 15      call print_number
0394+  1533 11            mov a, b
0395+  1534 26 0A 00      mov b, 10
0396+  1537 AE            div a, b
0397+  1538 07 44 15      call print_number
0398+  153B 1B            mov al, bl      ; 1's coeff in bl
0399+  153C 07 44 15      call print_number
0400+  153F FD F1         pop g
0401+  1541 E5            pop b
0402+  1542 E4            pop a
0403+  1543 09            ret
0404+  1544             
0405+  1544             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1544             ; print al
0407+  1544             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1544             print_number:
0409+  1544 6A 30         add al, $30
0410+  1546 23            mov ah, al
0411+  1547 07 C3 13      call _putchar
0412+  154A 09            ret
0413+  154B             
0414+  154B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  154B             ; print 16bit hex integer
0416+  154B             ; integer value in reg b
0417+  154B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  154B             print_u16x:
0419+  154B D7            push a
0420+  154C D8            push b
0421+  154D DD            push bl
0422+  154E 30            mov bl, bh
0423+  154F 07 91 13      call _itoa        ; convert bh to char in a
0424+  1552 2F            mov bl, al        ; save al
0425+  1553 19 00         mov al, 0
0426+  1555 05 03         syscall sys_io        ; display ah
0427+  1557 24            mov ah, bl        ; retrieve al
0428+  1558 19 00         mov al, 0
0429+  155A 05 03         syscall sys_io        ; display al
0430+  155C             
0431+  155C EA            pop bl
0432+  155D 07 91 13      call _itoa        ; convert bh to char in a
0433+  1560 2F            mov bl, al        ; save al
0434+  1561 19 00         mov al, 0
0435+  1563 05 03         syscall sys_io        ; display ah
0436+  1565 24            mov ah, bl        ; retrieve al
0437+  1566 19 00         mov al, 0
0438+  1568 05 03         syscall sys_io        ; display al
0439+  156A             
0440+  156A E5            pop b
0441+  156B E4            pop a
0442+  156C 09            ret
0443+  156D             
0444+  156D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  156D             ; input 16bit hex integer
0446+  156D             ; read 16bit integer into a
0447+  156D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  156D             scan_u16x:
0449+  156D F8 10 00      enter 16
0450+  1570 D8            push b
0451+  1571 DA            push d
0452+  1572             
0453+  1572 FA F1 FF      lea d, [bp + -15]
0454+  1575 07 CA 13      call _gets        ; get number
0455+  1578             
0456+  1578 32            mov bl, [d]
0457+  1579 37            mov bh, bl
0458+  157A 33 01 00      mov bl, [d + 1]
0459+  157D 07 80 13      call _atoi        ; convert to int in al
0460+  1580 23            mov ah, al        ; move to ah
0461+  1581             
0462+  1581 33 02 00      mov bl, [d + 2]
0463+  1584 37            mov bh, bl
0464+  1585 33 03 00      mov bl, [d + 3]
0465+  1588 07 80 13      call _atoi        ; convert to int in al
0466+  158B             
0467+  158B E7            pop d
0468+  158C E5            pop b
0469+  158D F9            leave
0470+  158E 09            ret
0471+  158F             
0472+  158F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  158F             ; print 8bit hex integer
0474+  158F             ; integer value in reg bl
0475+  158F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  158F             print_u8x:
0477+  158F D7            push a
0478+  1590 DD            push bl
0479+  1591             
0480+  1591 07 91 13      call _itoa        ; convert bl to char in a
0481+  1594 2F            mov bl, al        ; save al
0482+  1595 19 00         mov al, 0
0483+  1597 05 03         syscall sys_io        ; display ah
0484+  1599 24            mov ah, bl        ; retrieve al
0485+  159A 19 00         mov al, 0
0486+  159C 05 03         syscall sys_io        ; display al
0487+  159E             
0488+  159E EA            pop bl
0489+  159F E4            pop a
0490+  15A0 09            ret
0491+  15A1             
0492+  15A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  15A1             ; print 8bit decimal unsigned number
0494+  15A1             ; input number in al
0495+  15A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  15A1             print_u8d:
0497+  15A1 D7            push a
0498+  15A2 D8            push b
0499+  15A3 FD D8         push g
0500+  15A5 22 00         mov ah, 0
0501+  15A7 26 64 00      mov b, 100
0502+  15AA AE            div a, b
0503+  15AB D8            push b      ; save remainder
0504+  15AC B9 00         cmp al, 0
0505+  15AE C6 B8 15      je skip100
0506+  15B1 6A 30         add al, $30
0507+  15B3 23            mov ah, al
0508+  15B4 19 00         mov al, 0
0509+  15B6 05 03         syscall sys_io  ; print coeff
0510+  15B8             skip100:
0511+  15B8 E4            pop a
0512+  15B9 22 00         mov ah, 0
0513+  15BB 26 0A 00      mov b, 10
0514+  15BE AE            div a, b
0515+  15BF D8            push b      ; save remainder
0516+  15C0 B9 00         cmp al, 0
0517+  15C2 C6 CC 15      je skip10
0518+  15C5 6A 30         add al, $30
0519+  15C7 23            mov ah, al
0520+  15C8 19 00         mov al, 0
0521+  15CA 05 03         syscall sys_io  ; print coeff
0522+  15CC             skip10:
0523+  15CC E4            pop a
0524+  15CD 1B            mov al, bl
0525+  15CE 6A 30         add al, $30
0526+  15D0 23            mov ah, al
0527+  15D1 19 00         mov al, 0
0528+  15D3 05 03         syscall sys_io  ; print coeff
0529+  15D5 FD F1         pop g
0530+  15D7 E5            pop b
0531+  15D8 E4            pop a
0532+  15D9 09            ret
0533+  15DA             
0534+  15DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  15DA             ; input 8bit hex integer
0536+  15DA             ; read 8bit integer into al
0537+  15DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  15DA             scan_u8x:
0539+  15DA F8 04 00      enter 4
0540+  15DD D8            push b
0541+  15DE DA            push d
0542+  15DF             
0543+  15DF FA FD FF      lea d, [bp + -3]
0544+  15E2 07 CA 13      call _gets        ; get number
0545+  15E5             
0546+  15E5 32            mov bl, [d]
0547+  15E6 37            mov bh, bl
0548+  15E7 33 01 00      mov bl, [d + 1]
0549+  15EA 07 80 13      call _atoi        ; convert to int in al
0550+  15ED             
0551+  15ED E7            pop d
0552+  15EE E5            pop b
0553+  15EF F9            leave
0554+  15F0 09            ret
0555+  15F1             
0556+  15F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  15F1             ; input decimal number
0558+  15F1             ; result in a
0559+  15F1             ; 655'\0'
0560+  15F1             ; low--------high
0561+  15F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  15F1             scan_u16d:
0563+  15F1 F8 08 00      enter 8
0564+  15F4 E2            push si
0565+  15F5 D8            push b
0566+  15F6 D9            push c
0567+  15F7 DA            push d
0568+  15F8 FA F9 FF      lea d, [bp +- 7]
0569+  15FB 07 CA 13      call _gets
0570+  15FE 07 22 13      call _strlen      ; get string length in c
0571+  1601 7E            dec c
0572+  1602 FD 4E         mov si, d
0573+  1604 12            mov a, c
0574+  1605 FD 99         shl a
0575+  1607 3B 43 16      mov d, table_power
0576+  160A 59            add d, a
0577+  160B 38 00 00      mov c, 0
0578+  160E             mul_loop:
0579+  160E F6            lodsb      ; load ascii to al
0580+  160F B9 00         cmp al, 0
0581+  1611 C6 24 16      je mul_exit
0582+  1614 6F 30         sub al, $30    ; make into integer
0583+  1616 22 00         mov ah, 0
0584+  1618 2A            mov b, [d]
0585+  1619 AC            mul a, b      ; result in b since it fits in 16bits
0586+  161A 11            mov a, b
0587+  161B 28            mov b, c
0588+  161C 54            add a, b
0589+  161D 39            mov c, a
0590+  161E 63 02 00      sub d, 2
0591+  1621 0A 0E 16      jmp mul_loop
0592+  1624             mul_exit:
0593+  1624 12            mov a, c
0594+  1625 E7            pop d
0595+  1626 E6            pop c
0596+  1627 E5            pop b
0597+  1628 EF            pop si
0598+  1629 F9            leave
0599+  162A 09            ret
0600+  162B             
0601+  162B             
0602+  162B 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  162F 34 35 36 37 
0602+  1633 38 39 61 62 
0602+  1637 63 64 65 66 
0603+  163B 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  163F 1B 5B 68 00 
0604+  1643             
0605+  1643             table_power:
0606+  1643 01 00         .dw 1
0607+  1645 0A 00         .dw 10
0608+  1647 64 00         .dw 100
0609+  1649 E8 03         .dw 1000
0610+  164B 10 27         .dw 100003242   164D             .include "lib/ctype.asm"
0001+  164D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  164D             ; ctype.s
0003+  164D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  164D             
0005+  164D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  164D             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  164D             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  164D             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  164D             ;; characters are supported.
0010+  164D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  164D             ;; _isalnum 
0012+  164D             ;; _isalpha 
0013+  164D             ;; islower 
0014+  164D             ;; isupper 
0015+  164D             ;; _isdigit 
0016+  164D             ;; isxdigit
0017+  164D             ;; iscntrl 
0018+  164D             ;; isgraph 
0019+  164D             ;; _isspace 
0020+  164D             ;; isblank 
0021+  164D             ;; isprint 
0022+  164D             ;; ispunct 
0023+  164D             ;; tolower 
0024+  164D             ;; toupper
0025+  164D             
0026+  164D             
0027+  164D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  164D             ;; is alphanumeric
0029+  164D             ;; sets zf according with result
0030+  164D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  164D             _isalnum:
0032+  164D 07 6A 16    	call _isalpha
0033+  1650 C6 56 16    	je _isalnum_exit
0034+  1653 07 57 16    	call _isdigit
0035+  1656             _isalnum_exit:
0036+  1656 09          	ret	
0037+  1657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1657             ;; is digit
0039+  1657             ;; sets zf according with result
0040+  1657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1657             _isdigit:
0042+  1657 DB          	push al
0043+  1658 B9 30       	cmp al, '0'
0044+  165A C8 66 16    	jlu _isdigit_false
0045+  165D B9 39       	cmp al, '9'
0046+  165F D1 66 16    	jgu _isdigit_false
0047+  1662 87 00       	and al, 0	; set zf
0048+  1664 E8          	pop al
0049+  1665 09          	ret
0050+  1666             _isdigit_false:
0051+  1666 8B 01       	or al, 1	; clear zf
0052+  1668 E8          	pop al
0053+  1669 09          	ret	
0054+  166A             	
0055+  166A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  166A             ;; is alpha
0057+  166A             ;; sets zf according with result
0058+  166A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  166A             _isalpha:
0060+  166A DB          	push al
0061+  166B B9 5F       	cmp al, '_'
0062+  166D C6 8D 16    	je _isalpha_true
0063+  1670 B9 2E       	cmp al, '.'
0064+  1672 C6 8D 16    	je _isalpha_true
0065+  1675 B9 61       	cmp al, 'a'
0066+  1677 C8 89 16    	jlu _isalpha_false
0067+  167A B9 7A       	cmp al, 'z'
0068+  167C D1 89 16    	jgu _isalpha_false
0069+  167F B9 7A       	cmp al, 'z'
0070+  1681 D0 8D 16    	jleu _isalpha_true
0071+  1684 B9 61       	cmp al, 'a'
0072+  1686 C9 8D 16    	jgeu _isalpha_true
0073+  1689             _isalpha_false:
0074+  1689 8B 01       	or al, 1	; clear zf
0075+  168B E8          	pop al
0076+  168C 09          	ret
0077+  168D             _isalpha_true:
0078+  168D 87 00       	and al, 0	; set zf
0079+  168F E8          	pop al
0080+  1690 09          	ret
0081+  1691             
0082+  1691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1691             ;; is path-alpha
0084+  1691             ;; sets zf according with result
0085+  1691             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1691             ispath:
0087+  1691 DB          	push al
0088+  1692 07 57 16    	call _isdigit
0089+  1695 C6 BF 16    	je ispath_true
0090+  1698 B9 5F       	cmp al, '_'
0091+  169A C6 BF 16    	je ispath_true
0092+  169D B9 2F       	cmp al, '/'
0093+  169F C6 BF 16    	je ispath_true
0094+  16A2 B9 2E       	cmp al, '.'
0095+  16A4 C6 BF 16    	je ispath_true
0096+  16A7 B9 61       	cmp al, 'a'
0097+  16A9 C8 BB 16    	jlu ispath_false
0098+  16AC B9 7A       	cmp al, 'z'
0099+  16AE D1 BB 16    	jgu ispath_false
0100+  16B1 B9 7A       	cmp al, 'z'
0101+  16B3 D0 BF 16    	jleu ispath_true
0102+  16B6 B9 61       	cmp al, 'a'
0103+  16B8 C9 BF 16    	jgeu ispath_true
0104+  16BB             ispath_false:
0105+  16BB 8B 01       	or al, 1	; clear zf
0106+  16BD E8          	pop al
0107+  16BE 09          	ret
0108+  16BF             ispath_true:
0109+  16BF 87 00       	and al, 0	; set zf
0110+  16C1 E8          	pop al
0111+  16C2 09          	ret
0112+  16C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  16C3             ;; is space
0114+  16C3             ;; sets zf according with result
0115+  16C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  16C3             _isspace:
0117+  16C3 B9 20       	cmp al, $20		; ' '
0118+  16C5 C6 D9 16    	je _isspace_exit
0119+  16C8 B9 09       	cmp al, $09		; '\t'
0120+  16CA C6 D9 16    	je _isspace_exit
0121+  16CD B9 0A       	cmp al, $0a		; '\n'
0122+  16CF C6 D9 16    	je _isspace_exit
0123+  16D2 B9 0D       	cmp al, $0d		; '\r'
0124+  16D4 C6 D9 16    	je _isspace_exit
0125+  16D7 B9 0B       	cmp al, $0b		; '\v'
0126+  16D9             _isspace_exit:
0127+  16D9 09          	ret	
0128+  16DA             
0129+  16DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  16DA             ; to lower
0131+  16DA             ; input in al
0132+  16DA             ; output in al
0133+  16DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  16DA             _to_lower:
0135+  16DA B9 7A       	cmp al, 'z'
0136+  16DC D1 E1 16    	jgu _to_lower_ret
0137+  16DF 6A 20       	add al, $20				; convert to lower case
0138+  16E1             _to_lower_ret:
0139+  16E1 09          	ret
0140+  16E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  16E2             ; to upper
0142+  16E2             ; input in al
0143+  16E2             ; output in al
0144+  16E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  16E2             _to_upper:
0146+  16E2 B9 61       	cmp al, 'a'
0147+  16E4 C8 E9 16    	jlu _to_upper_ret
0148+  16E7 6F 20       	sub al, $20			; convert to upper case
0149+  16E9             _to_upper_ret:
0150+  16E9 09          	ret
0151+  16EA             
3243   16EA             .include "lib/token.asm"
0001+  16EA             toktyp_identifier  .equ 0
0002+  16EA             toktyp_keyword     .equ 1
0003+  16EA             toktyp_delimiter   .equ 2
0004+  16EA             toktyp_string      .equ 3
0005+  16EA             toktyp_char        .equ 4
0006+  16EA             toktyp_numeric     .equ 5
0007+  16EA             toktyp_end         .equ 6
0008+  16EA             
0009+  16EA             tok_null           .equ 0
0010+  16EA             tok_fslash         .equ 1
0011+  16EA             tok_times          .equ 2
0012+  16EA             tok_plus           .equ 3
0013+  16EA             tok_minus          .equ 4
0014+  16EA             tok_dot            .equ 5
0015+  16EA             tok_semi           .equ 6
0016+  16EA             tok_angle          .equ 7
0017+  16EA             tok_tilde          .equ 8
0018+  16EA             tok_equal          .equ 9
0019+  16EA             tok_colon          .equ 10
0020+  16EA             tok_comma          .equ 11
0021+  16EA             
0022+  16EA             tok_end            .equ 20
0023+  16EA             
0024+  16EA             
0025+  16EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  16EA             ;; read a full command argment from shell input buffer
0027+  16EA             ;; argument is written into tokstr
0028+  16EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  16EA             get_arg:
0030+  16EA D7            push a
0031+  16EB E2            push si
0032+  16EC E3            push di
0033+  16ED 19 00         mov al, 0
0034+  16EF 3D 18 19      mov [tokstr], al      ; nullify tokstr string
0035+  16F2 14 14 19      mov a, [prog]
0036+  16F5 4D            mov si, a
0037+  16F6 FD 4F 18 19   mov di, tokstr
0038+  16FA             get_arg_skip_spaces:
0039+  16FA F6            lodsb
0040+  16FB 07 C3 16      call _isspace
0041+  16FE C6 FA 16      je get_arg_skip_spaces
0042+  1701             get_arg_l0:
0043+  1701 B9 3B         cmp al, $3b        ; check if is ';'
0044+  1703 C6 10 17      je get_arg_end
0045+  1706 B9 00         cmp al, 0
0046+  1708 C6 10 17      je get_arg_end      ; check if end of input
0047+  170B F7            stosb
0048+  170C F6            lodsb
0049+  170D 0A 01 17      jmp get_arg_l0
0050+  1710             get_arg_end:
0051+  1710 19 00         mov al, 0
0052+  1712 F7            stosb
0053+  1713 D5 01 00      sub si, 1
0054+  1716 4E            mov a, si
0055+  1717 42 14 19      mov [prog], a    ; update pointer
0056+  171A F0            pop di
0057+  171B EF            pop si
0058+  171C E4            pop a
0059+  171D 09            ret
0060+  171E             
0061+  171E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  171E             ;; read a path formation from shell input buffer
0063+  171E             ;; path is written into tokstr
0064+  171E             ;; /usr/bin
0065+  171E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  171E             get_path:
0067+  171E D7            push a
0068+  171F E2            push si
0069+  1720 E3            push di
0070+  1721 19 00         mov al, 0
0071+  1723 3D 18 19      mov [tokstr], al      ; nullify tokstr string
0072+  1726 14 14 19      mov a, [prog]
0073+  1729 4D            mov si, a
0074+  172A FD 4F 18 19   mov di, tokstr
0075+  172E             get_path_skip_spaces:
0076+  172E F6            lodsb
0077+  172F 07 C3 16      call _isspace
0078+  1732 C6 2E 17      je get_path_skip_spaces
0079+  1735             get_path_is_pathchar:
0080+  1735 F7            stosb
0081+  1736 F6            lodsb
0082+  1737 07 4D 16      call _isalnum      ;check if is alphanumeric
0083+  173A C6 35 17      je get_path_is_pathchar
0084+  173D B9 2F         cmp al, '/'        ; check if is '/'
0085+  173F C6 35 17      je get_path_is_pathchar
0086+  1742 19 00         mov al, 0
0087+  1744 F7            stosb
0088+  1745 D5 01 00      sub si, 1
0089+  1748 4E            mov a, si
0090+  1749 42 14 19      mov [prog], a    ; update pointer
0091+  174C             get_path_end:
0092+  174C F0            pop di
0093+  174D EF            pop si
0094+  174E E4            pop a
0095+  174F 09            ret
0096+  1750             
0097+  1750             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1750             ;; read a line
0099+  1750             ;; line is written into tokstr
0100+  1750             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1750             get_line:
0102+  1750 D7            push a
0103+  1751 E2            push si
0104+  1752 E3            push di
0105+  1753 19 00         mov al, 0
0106+  1755 3D 18 19      mov [tokstr], al      ; nullify tokstr string
0107+  1758 14 14 19      mov a, [prog]
0108+  175B 4D            mov si, a
0109+  175C FD 4F 18 19   mov di, tokstr
0110+  1760             get_line_l0:
0111+  1760 F6            lodsb
0112+  1761 B9 0A         cmp al, $0a    ; check for new line
0113+  1763 C6 6A 17      je get_line_exit
0114+  1766 F7            stosb
0115+  1767 0A 60 17      jmp get_line_l0
0116+  176A             get_line_exit:
0117+  176A 19 00         mov al, 0
0118+  176C F7            stosb
0119+  176D 4E            mov a, si
0120+  176E 42 14 19      mov [prog], a    ; update pointer
0121+  1771 F0            pop di
0122+  1772 EF            pop si
0123+  1773 E4            pop a
0124+  1774 09            ret
0125+  1775             
0126+  1775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1775             ;; token parser
0128+  1775             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1775             get_token:
0130+  1775 D7            push a
0131+  1776 DA            push d
0132+  1777 E2            push si
0133+  1778 E3            push di
0134+  1779 19 00         mov al, 0
0135+  177B 3D 18 19      mov [tokstr], al      ; nullify tokstr string
0136+  177E 19 00         mov al, tok_null
0137+  1780 3D 17 19      mov [tok], al        ; nullify token
0138+  1783 14 14 19      mov a, [prog]
0139+  1786 4D            mov si, a
0140+  1787 FD 4F 18 19   mov di, tokstr
0141+  178B             get_tok_skip_spaces:
0142+  178B F6            lodsb
0143+  178C 07 C3 16      call _isspace
0144+  178F C6 8B 17      je get_tok_skip_spaces
0145+  1792 B9 00         cmp al, 0      ; check for end of input (null)
0146+  1794 C6 79 18      je get_token_end
0147+  1797 B9 23         cmp al, '#'      ; comments!
0148+  1799 C6 A7 18      je get_tok_comment
0149+  179C 07 4D 16      call _isalnum
0150+  179F C6 86 18      jz is_alphanumeric
0151+  17A2             ; other token types
0152+  17A2             get_token_slash:
0153+  17A2 B9 2F         cmp al, '/'        ; check if '/'
0154+  17A4 C7 BC 17      jne get_token_minus
0155+  17A7 F7            stosb          ; store '/' into token string
0156+  17A8 19 00         mov al, 0
0157+  17AA F7            stosb          ; terminate token string
0158+  17AB 19 01         mov al, tok_fslash
0159+  17AD 3D 17 19      mov [tok], al      
0160+  17B0 19 02         mov al, toktyp_delimiter
0161+  17B2 3D 16 19      mov [toktyp], al
0162+  17B5 4E            mov a, si
0163+  17B6 42 14 19      mov [prog], a    ; update pointer
0164+  17B9 0A A2 18      jmp get_token_return
0165+  17BC             get_token_minus:
0166+  17BC B9 2D         cmp al, '-'        ; check if '-'
0167+  17BE C7 D6 17      jne get_token_comma
0168+  17C1 F7            stosb          ; store '-' into token string
0169+  17C2 19 00         mov al, 0
0170+  17C4 F7            stosb          ; terminate token string
0171+  17C5 19 04         mov al, tok_minus
0172+  17C7 3D 17 19      mov [tok], al      
0173+  17CA 19 02         mov al, toktyp_delimiter
0174+  17CC 3D 16 19      mov [toktyp], al
0175+  17CF 4E            mov a, si
0176+  17D0 42 14 19      mov [prog], a    ; update pointer
0177+  17D3 0A A2 18      jmp get_token_return
0178+  17D6             get_token_comma:
0179+  17D6 B9 2C         cmp al, ','        ; check if ','
0180+  17D8 C7 F0 17      jne get_token_semi
0181+  17DB F7            stosb          ; store ',' into token string
0182+  17DC 19 00         mov al, 0
0183+  17DE F7            stosb          ; terminate token string
0184+  17DF 19 0B         mov al, tok_comma
0185+  17E1 3D 17 19      mov [tok], al      
0186+  17E4 19 02         mov al, toktyp_delimiter
0187+  17E6 3D 16 19      mov [toktyp], al
0188+  17E9 4E            mov a, si
0189+  17EA 42 14 19      mov [prog], a    ; update pointer
0190+  17ED 0A A2 18      jmp get_token_return
0191+  17F0             get_token_semi:
0192+  17F0 B9 3B         cmp al, $3b        ; check if ';'
0193+  17F2 C7 0A 18      jne get_token_colon
0194+  17F5 F7            stosb          ; store ';' into token string
0195+  17F6 19 00         mov al, 0
0196+  17F8 F7            stosb          ; terminate token string
0197+  17F9 19 06         mov al, tok_semi
0198+  17FB 3D 17 19      mov [tok], al      
0199+  17FE 19 02         mov al, toktyp_delimiter
0200+  1800 3D 16 19      mov [toktyp], al
0201+  1803 4E            mov a, si
0202+  1804 42 14 19      mov [prog], a    ; update pointer
0203+  1807 0A A2 18      jmp get_token_return
0204+  180A             get_token_colon:
0205+  180A B9 3A         cmp al, $3a        ; check if ':'
0206+  180C C7 24 18      jne get_token_angle
0207+  180F F7            stosb          ; store ':' into token string
0208+  1810 19 00         mov al, 0
0209+  1812 F7            stosb          ; terminate token string
0210+  1813 19 0A         mov al, tok_colon
0211+  1815 3D 17 19      mov [tok], al      
0212+  1818 19 02         mov al, toktyp_delimiter
0213+  181A 3D 16 19      mov [toktyp], al
0214+  181D 4E            mov a, si
0215+  181E 42 14 19      mov [prog], a    ; update pointer
0216+  1821 0A A2 18      jmp get_token_return
0217+  1824             get_token_angle:
0218+  1824 B9 3E         cmp al, $3e        ; check if '>'
0219+  1826 C7 3E 18      jne get_token_tilde
0220+  1829 F7            stosb          ; store '>' into token string
0221+  182A 19 00         mov al, 0
0222+  182C F7            stosb          ; terminate token string
0223+  182D 19 07         mov al, tok_angle
0224+  182F 3D 17 19      mov [tok], al      
0225+  1832 19 02         mov al, toktyp_delimiter
0226+  1834 3D 16 19      mov [toktyp], al
0227+  1837 4E            mov a, si
0228+  1838 42 14 19      mov [prog], a    ; update pointer
0229+  183B 0A A2 18      jmp get_token_return
0230+  183E             get_token_tilde:
0231+  183E B9 7E         cmp al, '~'        ; check if '~'
0232+  1840 C7 58 18      jne get_token_equal
0233+  1843 F7            stosb          ; store '~' into token string
0234+  1844 19 00         mov al, 0
0235+  1846 F7            stosb          ; terminate token string
0236+  1847 19 08         mov al, tok_tilde
0237+  1849 3D 17 19      mov [tok], al      
0238+  184C 19 02         mov al, toktyp_delimiter
0239+  184E 3D 16 19      mov [toktyp], al
0240+  1851 4E            mov a, si
0241+  1852 42 14 19      mov [prog], a    ; update pointer
0242+  1855 0A A2 18      jmp get_token_return
0243+  1858             get_token_equal:
0244+  1858 B9 3D         cmp al, '='        ; check if '='
0245+  185A C7 72 18      jne get_token_skip
0246+  185D F7            stosb          ; store '=' into token string
0247+  185E 19 00         mov al, 0
0248+  1860 F7            stosb          ; terminate token string
0249+  1861 19 09         mov al, tok_equal
0250+  1863 3D 17 19      mov [tok], al      
0251+  1866 19 02         mov al, toktyp_delimiter
0252+  1868 3D 16 19      mov [toktyp], al
0253+  186B 4E            mov a, si
0254+  186C 42 14 19      mov [prog], a    ; update pointer
0255+  186F 0A A2 18      jmp get_token_return
0256+  1872             get_token_skip:
0257+  1872 4E            mov a, si
0258+  1873 42 14 19      mov [prog], a    ; update pointer
0259+  1876 0A A2 18      jmp get_token_return
0260+  1879             get_token_end:        ; end of file token
0261+  1879 19 14         mov al, tok_end
0262+  187B 3D 17 19      mov [tok], al
0263+  187E 19 06         mov al, toktyp_end
0264+  1880 3D 16 19      mov [toktyp], al
0265+  1883 0A A2 18      jmp get_token_return
0266+  1886             is_alphanumeric:
0267+  1886 F7            stosb
0268+  1887 F6            lodsb
0269+  1888 07 4D 16      call _isalnum      ;check if is alphanumeric
0270+  188B C6 86 18      jz is_alphanumeric
0271+  188E B9 2E         cmp al, $2e        ; check if is '.'
0272+  1890 C6 86 18      je is_alphanumeric
0273+  1893 19 00         mov al, 0
0274+  1895 F7            stosb
0275+  1896 19 00         mov al, toktyp_identifier
0276+  1898 3D 16 19      mov [toktyp], al
0277+  189B D5 01 00      sub si, 1
0278+  189E 4E            mov a, si
0279+  189F 42 14 19      mov [prog], a    ; update pointer
0280+  18A2             get_token_return:
0281+  18A2 F0            pop di
0282+  18A3 EF            pop si
0283+  18A4 E7            pop d
0284+  18A5 E4            pop a
0285+  18A6 09            ret
0286+  18A7             get_tok_comment:
0287+  18A7 F6            lodsb
0288+  18A8 B9 0A         cmp al, $0a      ; new line
0289+  18AA C7 A7 18      jne get_tok_comment
0290+  18AD 0A 8B 17      jmp get_tok_skip_spaces
0291+  18B0             
0292+  18B0             
0293+  18B0             get_number:
0294+  18B0 D7            push a
0295+  18B1 DA            push d
0296+  18B2 E2            push si
0297+  18B3 E3            push di
0298+  18B4 19 00         mov al, 0
0299+  18B6 3D 18 19      mov [tokstr], al      ; nullify tokstr string
0300+  18B9 19 00         mov al, tok_null
0301+  18BB 3D 17 19      mov [tok], al        ; nullify token
0302+  18BE 14 14 19      mov a, [prog]
0303+  18C1 4D            mov si, a
0304+  18C2 FD 4F 18 19   mov di, tokstr
0305+  18C6             get_number_skip_spaces:
0306+  18C6 F6            lodsb
0307+  18C7 07 C3 16      call _isspace
0308+  18CA C6 C6 18      je get_number_skip_spaces
0309+  18CD B9 00         cmp al, 0      ; check for end of input (null)
0310+  18CF C7 DF 18      jne get_number_l0
0311+  18D2 19 14         mov al, tok_end
0312+  18D4 3D 17 19      mov [tok], al
0313+  18D7 19 06         mov al, toktyp_end
0314+  18D9 3D 16 19      mov [toktyp], al
0315+  18DC 0A F6 18      jmp get_number_return
0316+  18DF             get_number_l0:
0317+  18DF F7            stosb
0318+  18E0 F6            lodsb
0319+  18E1 07 57 16      call _isdigit      ;check if is numeric
0320+  18E4 C6 DF 18      jz get_number_l0
0321+  18E7 19 00         mov al, 0
0322+  18E9 F7            stosb
0323+  18EA 19 05         mov al, toktyp_numeric
0324+  18EC 3D 16 19      mov [toktyp], al
0325+  18EF D5 01 00      sub si, 1
0326+  18F2 4E            mov a, si
0327+  18F3 42 14 19      mov [prog], a    ; update pointer
0328+  18F6             get_number_return:
0329+  18F6 F0            pop di
0330+  18F7 EF            pop si
0331+  18F8 E7            pop d
0332+  18F9 E4            pop a
0333+  18FA 09            ret
0334+  18FB             
0335+  18FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  18FB             ;; put back token
0337+  18FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  18FB             _putback:
0339+  18FB D7            push a
0340+  18FC E2            push si
0341+  18FD FD 4D 18 19   mov si, tokstr  
0342+  1901             _putback_loop:
0343+  1901 F6            lodsb
0344+  1902 B9 00         cmp al, 0
0345+  1904 C6 11 19      je _putback_end
0346+  1907 14 14 19      mov a, [prog]
0347+  190A 7D            dec a
0348+  190B 42 14 19      mov [prog], a      ; update pointer
0349+  190E 0A 01 19      jmp _putback_loop
0350+  1911             _putback_end:
0351+  1911 EF            pop si
0352+  1912 E4            pop a
0353+  1913 09            ret
0354+  1914             
0355+  1914             
0356+  1914             
0357+  1914             
0358+  1914 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1916             
0360+  1916 00          toktyp:    .db 0          ; token type symbol
0361+  1917 00          tok:       .db 0          ; current token symbol
0362+  1918 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  191C 00 00 00 00 
0362+  1920 00 00 00 00 
0362+  1924 00 00 00 00 
0362+  1928 00 00 00 00 
0362+  192C 00 00 00 00 
0362+  1930 00 00 00 00 
0362+  1934 00 00 00 00 
0362+  1938 00 00 00 00 
0362+  193C 00 00 00 00 
0362+  1940 00 00 00 00 
0362+  1944 00 00 00 00 
0362+  1948 00 00 00 00 
0362+  194C 00 00 00 00 
0362+  1950 00 00 00 00 
0362+  1954 00 00 00 00 
0362+  1958 00 00 00 00 
0362+  195C 00 00 00 00 
0362+  1960 00 00 00 00 
0362+  1964 00 00 00 00 
0362+  1968 00 00 00 00 
0362+  196C 00 00 00 00 
0362+  1970 00 00 00 00 
0362+  1974 00 00 00 00 
0362+  1978 00 00 00 00 
0362+  197C 00 00 00 00 
0362+  1980 00 00 00 00 
0362+  1984 00 00 00 00 
0362+  1988 00 00 00 00 
0362+  198C 00 00 00 00 
0362+  1990 00 00 00 00 
0362+  1994 00 00 00 00 
0362+  1998 00 00 00 00 
0362+  199C 00 00 00 00 
0362+  19A0 00 00 00 00 
0362+  19A4 00 00 00 00 
0362+  19A8 00 00 00 00 
0362+  19AC 00 00 00 00 
0362+  19B0 00 00 00 00 
0362+  19B4 00 00 00 00 
0362+  19B8 00 00 00 00 
0362+  19BC 00 00 00 00 
0362+  19C0 00 00 00 00 
0362+  19C4 00 00 00 00 
0362+  19C8 00 00 00 00 
0362+  19CC 00 00 00 00 
0362+  19D0 00 00 00 00 
0362+  19D4 00 00 00 00 
0362+  19D8 00 00 00 00 
0362+  19DC 00 00 00 00 
0362+  19E0 00 00 00 00 
0362+  19E4 00 00 00 00 
0362+  19E8 00 00 00 00 
0362+  19EC 00 00 00 00 
0362+  19F0 00 00 00 00 
0362+  19F4 00 00 00 00 
0362+  19F8 00 00 00 00 
0362+  19FC 00 00 00 00 
0362+  1A00 00 00 00 00 
0362+  1A04 00 00 00 00 
0362+  1A08 00 00 00 00 
0362+  1A0C 00 00 00 00 
0362+  1A10 00 00 00 00 
0362+  1A14 00 00 00 00 
3244   1A18             
3245   1A18             ; kernel parameters
3246   1A18             sys_debug_mode:
3247   1A18 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
3248   1A19             sys_echo_on:
3249   1A19 01            .db 1
3250   1A1A             sys_uart0_lcr:
3251   1A1A 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
3252   1A1B             sys_uart0_inten:
3253   1A1B 01            .db 1
3254   1A1C             sys_uart0_fifoen:
3255   1A1C 00            .db 0
3256   1A1D             sys_uart0_div0:
3257   1A1D 03            .db 3
3258   1A1E             sys_uart0_div1:
3259   1A1E 00            .db 0   ; default baud = 38400
3260   1A1F             ; baud  divisor
3261   1A1F             ; 50    2304
3262   1A1F             ; 110   1047
3263   1A1F             ; 300    384
3264   1A1F             ; 600    192
3265   1A1F             ; 1200    96
3266   1A1F             ; 9600    12
3267   1A1F             ; 19200    6
3268   1A1F             ; 38400    3
3269   1A1F             sys_uart1_lcr:
3270   1A1F 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
3271   1A20             sys_uart1_inten:
3272   1A20 01            .db 1
3273   1A21             sys_uart1_fifoen:
3274   1A21 00            .db 0
3275   1A22             sys_uart1_div0:
3276   1A22 03            .db 3
3277   1A23             sys_uart1_div1:
3278   1A23 00            .db 0   ; default baud = 38400
3279   1A24             
3280   1A24             nbr_active_procs:
3281   1A24 00            .db 0
3282   1A25             active_proc_index:
3283   1A25 01            .db 1
3284   1A26             
3285   1A26             index:
3286   1A26 00 00         .dw 0
3287   1A28             buffer_addr:
3288   1A28 00 00         .dw 0
3289   1A2A             
3290   1A2A             fifo_in:
3291   1A2A 31 22         .dw fifo
3292   1A2C             fifo_out:
3293   1A2C 31 22         .dw fifo
3294   1A2E             
3295   1A2E             ; file system variables
3296   1A2E             current_dir_id:
3297   1A2E 00 00         .dw 0     ; keep dirid of current directory
3298   1A30             s_init_path:
3299   1A30 2F 73 62 69   .db "/sbin/init", 0
3299   1A34 6E 2F 69 6E 
3299   1A38 69 74 00 
3300   1A3B             
3301   1A3B             s_uname:
3302   1A3B 73 6F 6C 61   .db "solarium v.1.0", 0
3302   1A3F 72 69 75 6D 
3302   1A43 20 76 2E 31 
3302   1A47 2E 30 00 
3303   1A4A             s_dataentry:
3304   1A4A 3E 20 00      .db "> ", 0
3305   1A4D             s_parent_dir:
3306   1A4D 2E 2E 00      .db "..", 0
3307   1A50             s_current_dir:
3308   1A50 2E 00         .db ".", 0
3309   1A52             s_fslash:
3310   1A52 2F 00         .db "/", 0
3311   1A54             file_attrib:
3312   1A54 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
3312   1A58 78 
3313   1A59             file_type:
3314   1A59 2D 64 63      .db "-dc"
3315   1A5C             s_ps_header:
3316   1A5C 70 69 64 20   .db "pid command\n", 0
3316   1A60 63 6F 6D 6D 
3316   1A64 61 6E 64 0A 
3316   1A68 00 
3317   1A69             s_ls_total:
3318   1A69 74 6F 74 61   .db "total: ", 0
3318   1A6D 6C 3A 20 00 
3319   1A71             
3320   1A71             s_int_en:
3321   1A71 69 72 71 73   .db "irqs enabled\n", 0
3321   1A75 20 65 6E 61 
3321   1A79 62 6C 65 64 
3321   1A7D 0A 00 
3322   1A7F             s_kernel_welcome:
3323   1A7F 2A 2A 2A 2A   .db "************************************************\n"
3323   1A83 2A 2A 2A 2A 
3323   1A87 2A 2A 2A 2A 
3323   1A8B 2A 2A 2A 2A 
3323   1A8F 2A 2A 2A 2A 
3323   1A93 2A 2A 2A 2A 
3323   1A97 2A 2A 2A 2A 
3323   1A9B 2A 2A 2A 2A 
3323   1A9F 2A 2A 2A 2A 
3323   1AA3 2A 2A 2A 2A 
3323   1AA7 2A 2A 2A 2A 
3323   1AAB 2A 2A 2A 2A 
3323   1AAF 0A 
3324   1AB0 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
3324   1AB4 57 65 6C 63 
3324   1AB8 6F 6D 65 20 
3324   1ABC 74 6F 20 53 
3324   1AC0 6F 6C 61 72 
3324   1AC4 69 75 6D 20 
3324   1AC8 4F 53 20 2D 
3324   1ACC 20 4B 65 72 
3324   1AD0 6E 65 6C 20 
3324   1AD4 76 65 72 2E 
3324   1AD8 20 31 2E 30 
3324   1ADC 20 2A 2A 2A 
3324   1AE0 0A 
3325   1AE1 2A 2A 2A 20   .db "*** type help for more information           ***\n"
3325   1AE5 74 79 70 65 
3325   1AE9 20 68 65 6C 
3325   1AED 70 20 66 6F 
3325   1AF1 72 20 6D 6F 
3325   1AF5 72 65 20 69 
3325   1AF9 6E 66 6F 72 
3325   1AFD 6D 61 74 69 
3325   1B01 6F 6E 20 20 
3325   1B05 20 20 20 20 
3325   1B09 20 20 20 20 
3325   1B0D 20 2A 2A 2A 
3325   1B11 0A 
3326   1B12 2A 2A 2A 2A   .db "************************************************\n"
3326   1B16 2A 2A 2A 2A 
3326   1B1A 2A 2A 2A 2A 
3326   1B1E 2A 2A 2A 2A 
3326   1B22 2A 2A 2A 2A 
3326   1B26 2A 2A 2A 2A 
3326   1B2A 2A 2A 2A 2A 
3326   1B2E 2A 2A 2A 2A 
3326   1B32 2A 2A 2A 2A 
3326   1B36 2A 2A 2A 2A 
3326   1B3A 2A 2A 2A 2A 
3326   1B3E 2A 2A 2A 2A 
3326   1B42 0A 
3327   1B43             s_prompt_init:
3328   1B43 73 74 61 72   .db "starting init\n", 0
3328   1B47 74 69 6E 67 
3328   1B4B 20 69 6E 69 
3328   1B4F 74 0A 00 
3329   1B52             s_priviledge:
3330   1B52 0A 65 78 63   .db "\nexception: privilege\n", 0
3330   1B56 65 70 74 69 
3330   1B5A 6F 6E 3A 20 
3330   1B5E 70 72 69 76 
3330   1B62 69 6C 65 67 
3330   1B66 65 0A 00 
3331   1B69             s_divzero:
3332   1B69 0A 65 78 63   .db "\nexception: zero division\n", 0
3332   1B6D 65 70 74 69 
3332   1B71 6F 6E 3A 20 
3332   1B75 7A 65 72 6F 
3332   1B79 20 64 69 76 
3332   1B7D 69 73 69 6F 
3332   1B81 6E 0A 00 
3333   1B84             
3334   1B84             s_set_year:
3335   1B84 79 65 61 72   .db "year: ", 0
3335   1B88 3A 20 00 
3336   1B8B             s_set_month:
3337   1B8B 6D 6F 6E 74   .db "month: ", 0
3337   1B8F 68 3A 20 00 
3338   1B93             s_set_day:
3339   1B93 64 61 79 3A   .db "day: ", 0
3339   1B97 20 00 
3340   1B99             s_set_week:
3341   1B99 77 65 65 6B   .db "weekday: ", 0
3341   1B9D 64 61 79 3A 
3341   1BA1 20 00 
3342   1BA3             s_set_hours:
3343   1BA3 68 6F 75 72   .db "hours: ", 0
3343   1BA7 73 3A 20 00 
3344   1BAB             s_set_minutes:
3345   1BAB 6D 69 6E 75   .db "minutes: ", 0
3345   1BAF 74 65 73 3A 
3345   1BB3 20 00 
3346   1BB5             s_set_seconds:
3347   1BB5 73 65 63 6F   .db "seconds: ", 0
3347   1BB9 6E 64 73 3A 
3347   1BBD 20 00 
3348   1BBF             s_months:      
3349   1BBF 20 20 20 00   .db "   ", 0
3350   1BC3 6A 61 6E 00   .db "jan", 0
3351   1BC7 66 65 62 00   .db "feb", 0
3352   1BCB 6D 61 72 00   .db "mar", 0
3353   1BCF 61 70 72 00   .db "apr", 0
3354   1BD3 6D 61 79 00   .db "may", 0
3355   1BD7 6A 75 6E 00   .db "jun", 0
3356   1BDB 6A 75 6C 00   .db "jul", 0
3357   1BDF 61 75 67 00   .db "aug", 0
3358   1BE3 73 65 70 00   .db "sep", 0
3359   1BE7 6F 63 74 00   .db "oct", 0
3360   1BEB 6E 6F 76 00   .db "nov", 0
3361   1BEF 64 65 63 00   .db "dec", 0
3362   1BF3             
3363   1BF3             s_week:        
3364   1BF3 73 75 6E 00   .db "sun", 0 
3365   1BF7 6D 6F 6E 00   .db "mon", 0 
3366   1BFB 74 75 65 00   .db "tue", 0 
3367   1BFF 77 65 64 00   .db "wed", 0 
3368   1C03 74 68 75 00   .db "thu", 0 
3369   1C07 66 72 69 00   .db "fri", 0 
3370   1C0B 73 61 74 00   .db "sat", 0
3371   1C0F             
3372   1C0F 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
3372   1C13 30 20 45 78 
3372   1C17 65 63 75 74 
3372   1C1B 65 64 2E 0A 
3372   1C1F 00 
3373   1C20             s_fdc_config:
3374   1C20 73 65 6C 65   .db "selecting diskette drive 0, side 0, single density, head loaded\n", 0
3374   1C24 63 74 69 6E 
3374   1C28 67 20 64 69 
3374   1C2C 73 6B 65 74 
3374   1C30 74 65 20 64 
3374   1C34 72 69 76 65 
3374   1C38 20 30 2C 20 
3374   1C3C 73 69 64 65 
3374   1C40 20 30 2C 20 
3374   1C44 73 69 6E 67 
3374   1C48 6C 65 20 64 
3374   1C4C 65 6E 73 69 
3374   1C50 74 79 2C 20 
3374   1C54 68 65 61 64 
3374   1C58 20 6C 6F 61 
3374   1C5C 64 65 64 0A 
3374   1C60 00 
3375   1C61             
3376   1C61             proc_state_table:   
3377   1C61 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
3377   1C65 00 00 00 00 
3377   1C69 00 00 00 00 
3377   1C6D 00 00 00 00 
3377   1C71 00 00 00 00 
3377   1C75 00 00 00 00 
3377   1C79 00 00 00 00 
3377   1C7D 00 00 00 00 
3377   1C81 00 00 00 00 
3377   1C85 00 00 00 00 
3377   1C89 00 00 00 00 
3377   1C8D 00 00 00 00 
3377   1C91 00 00 00 00 
3377   1C95 00 00 00 00 
3377   1C99 00 00 00 00 
3377   1C9D 00 00 00 00 
3377   1CA1 00 00 00 00 
3377   1CA5 00 00 00 00 
3377   1CA9 00 00 00 00 
3377   1CAD 00 00 00 00 
3377   1CB1 00 00 00 00 
3377   1CB5 00 00 00 00 
3377   1CB9 00 00 00 00 
3377   1CBD 00 00 00 00 
3377   1CC1 00 00 00 00 
3377   1CC5 00 00 00 00 
3377   1CC9 00 00 00 00 
3377   1CCD 00 00 00 00 
3377   1CD1 00 00 00 00 
3377   1CD5 00 00 00 00 
3377   1CD9 00 00 00 00 
3377   1CDD 00 00 00 00 
3377   1CE1 00 00 00 00 
3377   1CE5 00 00 00 00 
3377   1CE9 00 00 00 00 
3377   1CED 00 00 00 00 
3377   1CF1 00 00 00 00 
3377   1CF5 00 00 00 00 
3377   1CF9 00 00 00 00 
3377   1CFD 00 00 00 00 
3377   1D01 00 00 00 00 
3377   1D05 00 00 00 00 
3377   1D09 00 00 00 00 
3377   1D0D 00 00 00 00 
3377   1D11 00 00 00 00 
3377   1D15 00 00 00 00 
3377   1D19 00 00 00 00 
3377   1D1D 00 00 00 00 
3377   1D21 00 00 00 00 
3377   1D25 00 00 00 00 
3377   1D29 00 00 00 00 
3377   1D2D 00 00 00 00 
3377   1D31 00 00 00 00 
3377   1D35 00 00 00 00 
3377   1D39 00 00 00 00 
3377   1D3D 00 00 00 00 
3377   1D41 00 00 00 00 
3377   1D45 00 00 00 00 
3377   1D49 00 00 00 00 
3377   1D4D 00 00 00 00 
3377   1D51 00 00 00 00 
3377   1D55 00 00 00 00 
3377   1D59 00 00 00 00 
3377   1D5D 00 00 00 00 
3377   1D61 00 00 00 00 
3377   1D65 00 00 00 00 
3377   1D69 00 00 00 00 
3377   1D6D 00 00 00 00 
3377   1D71 00 00 00 00 
3377   1D75 00 00 00 00 
3377   1D79 00 00 00 00 
3377   1D7D 00 00 00 00 
3377   1D81 00 00 00 00 
3377   1D85 00 00 00 00 
3377   1D89 00 00 00 00 
3377   1D8D 00 00 00 00 
3377   1D91 00 00 00 00 
3377   1D95 00 00 00 00 
3377   1D99 00 00 00 00 
3377   1D9D 00 00 00 00 
3378   1DA1             proc_availab_table: 
3379   1DA1 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
3379   1DA5 00 00 00 00 
3379   1DA9 00 00 00 00 
3379   1DAD 00 00 00 00 
3380   1DB1             proc_names:
3381   1DB1 00 00 00 00   .fill 16 * 32, 0  ; process names
3381   1DB5 00 00 00 00 
3381   1DB9 00 00 00 00 
3381   1DBD 00 00 00 00 
3381   1DC1 00 00 00 00 
3381   1DC5 00 00 00 00 
3381   1DC9 00 00 00 00 
3381   1DCD 00 00 00 00 
3381   1DD1 00 00 00 00 
3381   1DD5 00 00 00 00 
3381   1DD9 00 00 00 00 
3381   1DDD 00 00 00 00 
3381   1DE1 00 00 00 00 
3381   1DE5 00 00 00 00 
3381   1DE9 00 00 00 00 
3381   1DED 00 00 00 00 
3381   1DF1 00 00 00 00 
3381   1DF5 00 00 00 00 
3381   1DF9 00 00 00 00 
3381   1DFD 00 00 00 00 
3381   1E01 00 00 00 00 
3381   1E05 00 00 00 00 
3381   1E09 00 00 00 00 
3381   1E0D 00 00 00 00 
3381   1E11 00 00 00 00 
3381   1E15 00 00 00 00 
3381   1E19 00 00 00 00 
3381   1E1D 00 00 00 00 
3381   1E21 00 00 00 00 
3381   1E25 00 00 00 00 
3381   1E29 00 00 00 00 
3381   1E2D 00 00 00 00 
3381   1E31 00 00 00 00 
3381   1E35 00 00 00 00 
3381   1E39 00 00 00 00 
3381   1E3D 00 00 00 00 
3381   1E41 00 00 00 00 
3381   1E45 00 00 00 00 
3381   1E49 00 00 00 00 
3381   1E4D 00 00 00 00 
3381   1E51 00 00 00 00 
3381   1E55 00 00 00 00 
3381   1E59 00 00 00 00 
3381   1E5D 00 00 00 00 
3381   1E61 00 00 00 00 
3381   1E65 00 00 00 00 
3381   1E69 00 00 00 00 
3381   1E6D 00 00 00 00 
3381   1E71 00 00 00 00 
3381   1E75 00 00 00 00 
3381   1E79 00 00 00 00 
3381   1E7D 00 00 00 00 
3381   1E81 00 00 00 00 
3381   1E85 00 00 00 00 
3381   1E89 00 00 00 00 
3381   1E8D 00 00 00 00 
3381   1E91 00 00 00 00 
3381   1E95 00 00 00 00 
3381   1E99 00 00 00 00 
3381   1E9D 00 00 00 00 
3381   1EA1 00 00 00 00 
3381   1EA5 00 00 00 00 
3381   1EA9 00 00 00 00 
3381   1EAD 00 00 00 00 
3381   1EB1 00 00 00 00 
3381   1EB5 00 00 00 00 
3381   1EB9 00 00 00 00 
3381   1EBD 00 00 00 00 
3381   1EC1 00 00 00 00 
3381   1EC5 00 00 00 00 
3381   1EC9 00 00 00 00 
3381   1ECD 00 00 00 00 
3381   1ED1 00 00 00 00 
3381   1ED5 00 00 00 00 
3381   1ED9 00 00 00 00 
3381   1EDD 00 00 00 00 
3381   1EE1 00 00 00 00 
3381   1EE5 00 00 00 00 
3381   1EE9 00 00 00 00 
3381   1EED 00 00 00 00 
3381   1EF1 00 00 00 00 
3381   1EF5 00 00 00 00 
3381   1EF9 00 00 00 00 
3381   1EFD 00 00 00 00 
3381   1F01 00 00 00 00 
3381   1F05 00 00 00 00 
3381   1F09 00 00 00 00 
3381   1F0D 00 00 00 00 
3381   1F11 00 00 00 00 
3381   1F15 00 00 00 00 
3381   1F19 00 00 00 00 
3381   1F1D 00 00 00 00 
3381   1F21 00 00 00 00 
3381   1F25 00 00 00 00 
3381   1F29 00 00 00 00 
3381   1F2D 00 00 00 00 
3381   1F31 00 00 00 00 
3381   1F35 00 00 00 00 
3381   1F39 00 00 00 00 
3381   1F3D 00 00 00 00 
3381   1F41 00 00 00 00 
3381   1F45 00 00 00 00 
3381   1F49 00 00 00 00 
3381   1F4D 00 00 00 00 
3381   1F51 00 00 00 00 
3381   1F55 00 00 00 00 
3381   1F59 00 00 00 00 
3381   1F5D 00 00 00 00 
3381   1F61 00 00 00 00 
3381   1F65 00 00 00 00 
3381   1F69 00 00 00 00 
3381   1F6D 00 00 00 00 
3381   1F71 00 00 00 00 
3381   1F75 00 00 00 00 
3381   1F79 00 00 00 00 
3381   1F7D 00 00 00 00 
3381   1F81 00 00 00 00 
3381   1F85 00 00 00 00 
3381   1F89 00 00 00 00 
3381   1F8D 00 00 00 00 
3381   1F91 00 00 00 00 
3381   1F95 00 00 00 00 
3381   1F99 00 00 00 00 
3381   1F9D 00 00 00 00 
3381   1FA1 00 00 00 00 
3381   1FA5 00 00 00 00 
3381   1FA9 00 00 00 00 
3381   1FAD 00 00 00 00 
3382   1FB1             filename:
3383   1FB1 00 00 00 00   .fill 128, 0      ; holds a path for file search
3383   1FB5 00 00 00 00 
3383   1FB9 00 00 00 00 
3383   1FBD 00 00 00 00 
3383   1FC1 00 00 00 00 
3383   1FC5 00 00 00 00 
3383   1FC9 00 00 00 00 
3383   1FCD 00 00 00 00 
3383   1FD1 00 00 00 00 
3383   1FD5 00 00 00 00 
3383   1FD9 00 00 00 00 
3383   1FDD 00 00 00 00 
3383   1FE1 00 00 00 00 
3383   1FE5 00 00 00 00 
3383   1FE9 00 00 00 00 
3383   1FED 00 00 00 00 
3383   1FF1 00 00 00 00 
3383   1FF5 00 00 00 00 
3383   1FF9 00 00 00 00 
3383   1FFD 00 00 00 00 
3383   2001 00 00 00 00 
3383   2005 00 00 00 00 
3383   2009 00 00 00 00 
3383   200D 00 00 00 00 
3383   2011 00 00 00 00 
3383   2015 00 00 00 00 
3383   2019 00 00 00 00 
3383   201D 00 00 00 00 
3383   2021 00 00 00 00 
3383   2025 00 00 00 00 
3383   2029 00 00 00 00 
3383   202D 00 00 00 00 
3384   2031             user_data:
3385   2031 00 00 00 00   .fill 512, 0      ;  user space data
3385   2035 00 00 00 00 
3385   2039 00 00 00 00 
3385   203D 00 00 00 00 
3385   2041 00 00 00 00 
3385   2045 00 00 00 00 
3385   2049 00 00 00 00 
3385   204D 00 00 00 00 
3385   2051 00 00 00 00 
3385   2055 00 00 00 00 
3385   2059 00 00 00 00 
3385   205D 00 00 00 00 
3385   2061 00 00 00 00 
3385   2065 00 00 00 00 
3385   2069 00 00 00 00 
3385   206D 00 00 00 00 
3385   2071 00 00 00 00 
3385   2075 00 00 00 00 
3385   2079 00 00 00 00 
3385   207D 00 00 00 00 
3385   2081 00 00 00 00 
3385   2085 00 00 00 00 
3385   2089 00 00 00 00 
3385   208D 00 00 00 00 
3385   2091 00 00 00 00 
3385   2095 00 00 00 00 
3385   2099 00 00 00 00 
3385   209D 00 00 00 00 
3385   20A1 00 00 00 00 
3385   20A5 00 00 00 00 
3385   20A9 00 00 00 00 
3385   20AD 00 00 00 00 
3385   20B1 00 00 00 00 
3385   20B5 00 00 00 00 
3385   20B9 00 00 00 00 
3385   20BD 00 00 00 00 
3385   20C1 00 00 00 00 
3385   20C5 00 00 00 00 
3385   20C9 00 00 00 00 
3385   20CD 00 00 00 00 
3385   20D1 00 00 00 00 
3385   20D5 00 00 00 00 
3385   20D9 00 00 00 00 
3385   20DD 00 00 00 00 
3385   20E1 00 00 00 00 
3385   20E5 00 00 00 00 
3385   20E9 00 00 00 00 
3385   20ED 00 00 00 00 
3385   20F1 00 00 00 00 
3385   20F5 00 00 00 00 
3385   20F9 00 00 00 00 
3385   20FD 00 00 00 00 
3385   2101 00 00 00 00 
3385   2105 00 00 00 00 
3385   2109 00 00 00 00 
3385   210D 00 00 00 00 
3385   2111 00 00 00 00 
3385   2115 00 00 00 00 
3385   2119 00 00 00 00 
3385   211D 00 00 00 00 
3385   2121 00 00 00 00 
3385   2125 00 00 00 00 
3385   2129 00 00 00 00 
3385   212D 00 00 00 00 
3385   2131 00 00 00 00 
3385   2135 00 00 00 00 
3385   2139 00 00 00 00 
3385   213D 00 00 00 00 
3385   2141 00 00 00 00 
3385   2145 00 00 00 00 
3385   2149 00 00 00 00 
3385   214D 00 00 00 00 
3385   2151 00 00 00 00 
3385   2155 00 00 00 00 
3385   2159 00 00 00 00 
3385   215D 00 00 00 00 
3385   2161 00 00 00 00 
3385   2165 00 00 00 00 
3385   2169 00 00 00 00 
3385   216D 00 00 00 00 
3385   2171 00 00 00 00 
3385   2175 00 00 00 00 
3385   2179 00 00 00 00 
3385   217D 00 00 00 00 
3385   2181 00 00 00 00 
3385   2185 00 00 00 00 
3385   2189 00 00 00 00 
3385   218D 00 00 00 00 
3385   2191 00 00 00 00 
3385   2195 00 00 00 00 
3385   2199 00 00 00 00 
3385   219D 00 00 00 00 
3385   21A1 00 00 00 00 
3385   21A5 00 00 00 00 
3385   21A9 00 00 00 00 
3385   21AD 00 00 00 00 
3385   21B1 00 00 00 00 
3385   21B5 00 00 00 00 
3385   21B9 00 00 00 00 
3385   21BD 00 00 00 00 
3385   21C1 00 00 00 00 
3385   21C5 00 00 00 00 
3385   21C9 00 00 00 00 
3385   21CD 00 00 00 00 
3385   21D1 00 00 00 00 
3385   21D5 00 00 00 00 
3385   21D9 00 00 00 00 
3385   21DD 00 00 00 00 
3385   21E1 00 00 00 00 
3385   21E5 00 00 00 00 
3385   21E9 00 00 00 00 
3385   21ED 00 00 00 00 
3385   21F1 00 00 00 00 
3385   21F5 00 00 00 00 
3385   21F9 00 00 00 00 
3385   21FD 00 00 00 00 
3385   2201 00 00 00 00 
3385   2205 00 00 00 00 
3385   2209 00 00 00 00 
3385   220D 00 00 00 00 
3385   2211 00 00 00 00 
3385   2215 00 00 00 00 
3385   2219 00 00 00 00 
3385   221D 00 00 00 00 
3385   2221 00 00 00 00 
3385   2225 00 00 00 00 
3385   2229 00 00 00 00 
3385   222D 00 00 00 00 
3386   2231             fifo:
3387   2231 FF FF FF FF   .fill _fifo_size
3387   2235 FF FF FF FF 
3387   2239 FF FF FF FF 
3387   223D FF FF FF FF 
3387   2241 FF FF FF FF 
3387   2245 FF FF FF FF 
3387   2249 FF FF FF FF 
3387   224D FF FF FF FF 
3387   2251 FF FF FF FF 
3387   2255 FF FF FF FF 
3387   2259 FF FF FF FF 
3387   225D FF FF FF FF 
3387   2261 FF FF FF FF 
3387   2265 FF FF FF FF 
3387   2269 FF FF FF FF 
3387   226D FF FF FF FF 
3387   2271 FF FF FF FF 
3387   2275 FF FF FF FF 
3387   2279 FF FF FF FF 
3387   227D FF FF FF FF 
3387   2281 FF FF FF FF 
3387   2285 FF FF FF FF 
3387   2289 FF FF FF FF 
3387   228D FF FF FF FF 
3387   2291 FF FF FF FF 
3387   2295 FF FF FF FF 
3387   2299 FF FF FF FF 
3387   229D FF FF FF FF 
3387   22A1 FF FF FF FF 
3387   22A5 FF FF FF FF 
3387   22A9 FF FF FF FF 
3387   22AD FF FF FF FF 
3387   22B1 FF FF FF FF 
3387   22B5 FF FF FF FF 
3387   22B9 FF FF FF FF 
3387   22BD FF FF FF FF 
3387   22C1 FF FF FF FF 
3387   22C5 FF FF FF FF 
3387   22C9 FF FF FF FF 
3387   22CD FF FF FF FF 
3387   22D1 FF FF FF FF 
3387   22D5 FF FF FF FF 
3387   22D9 FF FF FF FF 
3387   22DD FF FF FF FF 
3387   22E1 FF FF FF FF 
3387   22E5 FF FF FF FF 
3387   22E9 FF FF FF FF 
3387   22ED FF FF FF FF 
3387   22F1 FF FF FF FF 
3387   22F5 FF FF FF FF 
3387   22F9 FF FF FF FF 
3387   22FD FF FF FF FF 
3387   2301 FF FF FF FF 
3387   2305 FF FF FF FF 
3387   2309 FF FF FF FF 
3387   230D FF FF FF FF 
3387   2311 FF FF FF FF 
3387   2315 FF FF FF FF 
3387   2319 FF FF FF FF 
3387   231D FF FF FF FF 
3387   2321 FF FF FF FF 
3387   2325 FF FF FF FF 
3387   2329 FF FF FF FF 
3387   232D FF FF FF FF 
3387   2331 FF FF FF FF 
3387   2335 FF FF FF FF 
3387   2339 FF FF FF FF 
3387   233D FF FF FF FF 
3387   2341 FF FF FF FF 
3387   2345 FF FF FF FF 
3387   2349 FF FF FF FF 
3387   234D FF FF FF FF 
3387   2351 FF FF FF FF 
3387   2355 FF FF FF FF 
3387   2359 FF FF FF FF 
3387   235D FF FF FF FF 
3387   2361 FF FF FF FF 
3387   2365 FF FF FF FF 
3387   2369 FF FF FF FF 
3387   236D FF FF FF FF 
3387   2371 FF FF FF FF 
3387   2375 FF FF FF FF 
3387   2379 FF FF FF FF 
3387   237D FF FF FF FF 
3387   2381 FF FF FF FF 
3387   2385 FF FF FF FF 
3387   2389 FF FF FF FF 
3387   238D FF FF FF FF 
3387   2391 FF FF FF FF 
3387   2395 FF FF FF FF 
3387   2399 FF FF FF FF 
3387   239D FF FF FF FF 
3387   23A1 FF FF FF FF 
3387   23A5 FF FF FF FF 
3387   23A9 FF FF FF FF 
3387   23AD FF FF FF FF 
3387   23B1 FF FF FF FF 
3387   23B5 FF FF FF FF 
3387   23B9 FF FF FF FF 
3387   23BD FF FF FF FF 
3387   23C1 FF FF FF FF 
3387   23C5 FF FF FF FF 
3387   23C9 FF FF FF FF 
3387   23CD FF FF FF FF 
3387   23D1 FF FF FF FF 
3387   23D5 FF FF FF FF 
3387   23D9 FF FF FF FF 
3387   23DD FF FF FF FF 
3387   23E1 FF FF FF FF 
3387   23E5 FF FF FF FF 
3387   23E9 FF FF FF FF 
3387   23ED FF FF FF FF 
3387   23F1 FF FF FF FF 
3387   23F5 FF FF FF FF 
3387   23F9 FF FF FF FF 
3387   23FD FF FF FF FF 
3387   2401 FF FF FF FF 
3387   2405 FF FF FF FF 
3387   2409 FF FF FF FF 
3387   240D FF FF FF FF 
3387   2411 FF FF FF FF 
3387   2415 FF FF FF FF 
3387   2419 FF FF FF FF 
3387   241D FF FF FF FF 
3387   2421 FF FF FF FF 
3387   2425 FF FF FF FF 
3387   2429 FF FF FF FF 
3387   242D FF FF FF FF 
3387   2431 FF FF FF FF 
3387   2435 FF FF FF FF 
3387   2439 FF FF FF FF 
3387   243D FF FF FF FF 
3387   2441 FF FF FF FF 
3387   2445 FF FF FF FF 
3387   2449 FF FF FF FF 
3387   244D FF FF FF FF 
3387   2451 FF FF FF FF 
3387   2455 FF FF FF FF 
3387   2459 FF FF FF FF 
3387   245D FF FF FF FF 
3387   2461 FF FF FF FF 
3387   2465 FF FF FF FF 
3387   2469 FF FF FF FF 
3387   246D FF FF FF FF 
3387   2471 FF FF FF FF 
3387   2475 FF FF FF FF 
3387   2479 FF FF FF FF 
3387   247D FF FF FF FF 
3387   2481 FF FF FF FF 
3387   2485 FF FF FF FF 
3387   2489 FF FF FF FF 
3387   248D FF FF FF FF 
3387   2491 FF FF FF FF 
3387   2495 FF FF FF FF 
3387   2499 FF FF FF FF 
3387   249D FF FF FF FF 
3387   24A1 FF FF FF FF 
3387   24A5 FF FF FF FF 
3387   24A9 FF FF FF FF 
3387   24AD FF FF FF FF 
3387   24B1 FF FF FF FF 
3387   24B5 FF FF FF FF 
3387   24B9 FF FF FF FF 
3387   24BD FF FF FF FF 
3387   24C1 FF FF FF FF 
3387   24C5 FF FF FF FF 
3387   24C9 FF FF FF FF 
3387   24CD FF FF FF FF 
3387   24D1 FF FF FF FF 
3387   24D5 FF FF FF FF 
3387   24D9 FF FF FF FF 
3387   24DD FF FF FF FF 
3387   24E1 FF FF FF FF 
3387   24E5 FF FF FF FF 
3387   24E9 FF FF FF FF 
3387   24ED FF FF FF FF 
3387   24F1 FF FF FF FF 
3387   24F5 FF FF FF FF 
3387   24F9 FF FF FF FF 
3387   24FD FF FF FF FF 
3387   2501 FF FF FF FF 
3387   2505 FF FF FF FF 
3387   2509 FF FF FF FF 
3387   250D FF FF FF FF 
3387   2511 FF FF FF FF 
3387   2515 FF FF FF FF 
3387   2519 FF FF FF FF 
3387   251D FF FF FF FF 
3387   2521 FF FF FF FF 
3387   2525 FF FF FF FF 
3387   2529 FF FF FF FF 
3387   252D FF FF FF FF 
3387   2531 FF FF FF FF 
3387   2535 FF FF FF FF 
3387   2539 FF FF FF FF 
3387   253D FF FF FF FF 
3387   2541 FF FF FF FF 
3387   2545 FF FF FF FF 
3387   2549 FF FF FF FF 
3387   254D FF FF FF FF 
3387   2551 FF FF FF FF 
3387   2555 FF FF FF FF 
3387   2559 FF FF FF FF 
3387   255D FF FF FF FF 
3387   2561 FF FF FF FF 
3387   2565 FF FF FF FF 
3387   2569 FF FF FF FF 
3387   256D FF FF FF FF 
3387   2571 FF FF FF FF 
3387   2575 FF FF FF FF 
3387   2579 FF FF FF FF 
3387   257D FF FF FF FF 
3387   2581 FF FF FF FF 
3387   2585 FF FF FF FF 
3387   2589 FF FF FF FF 
3387   258D FF FF FF FF 
3387   2591 FF FF FF FF 
3387   2595 FF FF FF FF 
3387   2599 FF FF FF FF 
3387   259D FF FF FF FF 
3387   25A1 FF FF FF FF 
3387   25A5 FF FF FF FF 
3387   25A9 FF FF FF FF 
3387   25AD FF FF FF FF 
3387   25B1 FF FF FF FF 
3387   25B5 FF FF FF FF 
3387   25B9 FF FF FF FF 
3387   25BD FF FF FF FF 
3387   25C1 FF FF FF FF 
3387   25C5 FF FF FF FF 
3387   25C9 FF FF FF FF 
3387   25CD FF FF FF FF 
3387   25D1 FF FF FF FF 
3387   25D5 FF FF FF FF 
3387   25D9 FF FF FF FF 
3387   25DD FF FF FF FF 
3387   25E1 FF FF FF FF 
3387   25E5 FF FF FF FF 
3387   25E9 FF FF FF FF 
3387   25ED FF FF FF FF 
3387   25F1 FF FF FF FF 
3387   25F5 FF FF FF FF 
3387   25F9 FF FF FF FF 
3387   25FD FF FF FF FF 
3387   2601 FF FF FF FF 
3387   2605 FF FF FF FF 
3387   2609 FF FF FF FF 
3387   260D FF FF FF FF 
3387   2611 FF FF FF FF 
3387   2615 FF FF FF FF 
3387   2619 FF FF FF FF 
3387   261D FF FF FF FF 
3387   2621 FF FF FF FF 
3387   2625 FF FF FF FF 
3387   2629 FF FF FF FF 
3387   262D FF FF FF FF 
3387   2631 FF FF FF FF 
3387   2635 FF FF FF FF 
3387   2639 FF FF FF FF 
3387   263D FF FF FF FF 
3387   2641 FF FF FF FF 
3387   2645 FF FF FF FF 
3387   2649 FF FF FF FF 
3387   264D FF FF FF FF 
3387   2651 FF FF FF FF 
3387   2655 FF FF FF FF 
3387   2659 FF FF FF FF 
3387   265D FF FF FF FF 
3387   2661 FF FF FF FF 
3387   2665 FF FF FF FF 
3387   2669 FF FF FF FF 
3387   266D FF FF FF FF 
3387   2671 FF FF FF FF 
3387   2675 FF FF FF FF 
3387   2679 FF FF FF FF 
3387   267D FF FF FF FF 
3387   2681 FF FF FF FF 
3387   2685 FF FF FF FF 
3387   2689 FF FF FF FF 
3387   268D FF FF FF FF 
3387   2691 FF FF FF FF 
3387   2695 FF FF FF FF 
3387   2699 FF FF FF FF 
3387   269D FF FF FF FF 
3387   26A1 FF FF FF FF 
3387   26A5 FF FF FF FF 
3387   26A9 FF FF FF FF 
3387   26AD FF FF FF FF 
3387   26B1 FF FF FF FF 
3387   26B5 FF FF FF FF 
3387   26B9 FF FF FF FF 
3387   26BD FF FF FF FF 
3387   26C1 FF FF FF FF 
3387   26C5 FF FF FF FF 
3387   26C9 FF FF FF FF 
3387   26CD FF FF FF FF 
3387   26D1 FF FF FF FF 
3387   26D5 FF FF FF FF 
3387   26D9 FF FF FF FF 
3387   26DD FF FF FF FF 
3387   26E1 FF FF FF FF 
3387   26E5 FF FF FF FF 
3387   26E9 FF FF FF FF 
3387   26ED FF FF FF FF 
3387   26F1 FF FF FF FF 
3387   26F5 FF FF FF FF 
3387   26F9 FF FF FF FF 
3387   26FD FF FF FF FF 
3387   2701 FF FF FF FF 
3387   2705 FF FF FF FF 
3387   2709 FF FF FF FF 
3387   270D FF FF FF FF 
3387   2711 FF FF FF FF 
3387   2715 FF FF FF FF 
3387   2719 FF FF FF FF 
3387   271D FF FF FF FF 
3387   2721 FF FF FF FF 
3387   2725 FF FF FF FF 
3387   2729 FF FF FF FF 
3387   272D FF FF FF FF 
3387   2731 FF FF FF FF 
3387   2735 FF FF FF FF 
3387   2739 FF FF FF FF 
3387   273D FF FF FF FF 
3387   2741 FF FF FF FF 
3387   2745 FF FF FF FF 
3387   2749 FF FF FF FF 
3387   274D FF FF FF FF 
3387   2751 FF FF FF FF 
3387   2755 FF FF FF FF 
3387   2759 FF FF FF FF 
3387   275D FF FF FF FF 
3387   2761 FF FF FF FF 
3387   2765 FF FF FF FF 
3387   2769 FF FF FF FF 
3387   276D FF FF FF FF 
3387   2771 FF FF FF FF 
3387   2775 FF FF FF FF 
3387   2779 FF FF FF FF 
3387   277D FF FF FF FF 
3387   2781 FF FF FF FF 
3387   2785 FF FF FF FF 
3387   2789 FF FF FF FF 
3387   278D FF FF FF FF 
3387   2791 FF FF FF FF 
3387   2795 FF FF FF FF 
3387   2799 FF FF FF FF 
3387   279D FF FF FF FF 
3387   27A1 FF FF FF FF 
3387   27A5 FF FF FF FF 
3387   27A9 FF FF FF FF 
3387   27AD FF FF FF FF 
3387   27B1 FF FF FF FF 
3387   27B5 FF FF FF FF 
3387   27B9 FF FF FF FF 
3387   27BD FF FF FF FF 
3387   27C1 FF FF FF FF 
3387   27C5 FF FF FF FF 
3387   27C9 FF FF FF FF 
3387   27CD FF FF FF FF 
3387   27D1 FF FF FF FF 
3387   27D5 FF FF FF FF 
3387   27D9 FF FF FF FF 
3387   27DD FF FF FF FF 
3387   27E1 FF FF FF FF 
3387   27E5 FF FF FF FF 
3387   27E9 FF FF FF FF 
3387   27ED FF FF FF FF 
3387   27F1 FF FF FF FF 
3387   27F5 FF FF FF FF 
3387   27F9 FF FF FF FF 
3387   27FD FF FF FF FF 
3387   2801 FF FF FF FF 
3387   2805 FF FF FF FF 
3387   2809 FF FF FF FF 
3387   280D FF FF FF FF 
3387   2811 FF FF FF FF 
3387   2815 FF FF FF FF 
3387   2819 FF FF FF FF 
3387   281D FF FF FF FF 
3387   2821 FF FF FF FF 
3387   2825 FF FF FF FF 
3387   2829 FF FF FF FF 
3387   282D FF FF FF FF 
3387   2831 FF FF FF FF 
3387   2835 FF FF FF FF 
3387   2839 FF FF FF FF 
3387   283D FF FF FF FF 
3387   2841 FF FF FF FF 
3387   2845 FF FF FF FF 
3387   2849 FF FF FF FF 
3387   284D FF FF FF FF 
3387   2851 FF FF FF FF 
3387   2855 FF FF FF FF 
3387   2859 FF FF FF FF 
3387   285D FF FF FF FF 
3387   2861 FF FF FF FF 
3387   2865 FF FF FF FF 
3387   2869 FF FF FF FF 
3387   286D FF FF FF FF 
3387   2871 FF FF FF FF 
3387   2875 FF FF FF FF 
3387   2879 FF FF FF FF 
3387   287D FF FF FF FF 
3387   2881 FF FF FF FF 
3387   2885 FF FF FF FF 
3387   2889 FF FF FF FF 
3387   288D FF FF FF FF 
3387   2891 FF FF FF FF 
3387   2895 FF FF FF FF 
3387   2899 FF FF FF FF 
3387   289D FF FF FF FF 
3387   28A1 FF FF FF FF 
3387   28A5 FF FF FF FF 
3387   28A9 FF FF FF FF 
3387   28AD FF FF FF FF 
3387   28B1 FF FF FF FF 
3387   28B5 FF FF FF FF 
3387   28B9 FF FF FF FF 
3387   28BD FF FF FF FF 
3387   28C1 FF FF FF FF 
3387   28C5 FF FF FF FF 
3387   28C9 FF FF FF FF 
3387   28CD FF FF FF FF 
3387   28D1 FF FF FF FF 
3387   28D5 FF FF FF FF 
3387   28D9 FF FF FF FF 
3387   28DD FF FF FF FF 
3387   28E1 FF FF FF FF 
3387   28E5 FF FF FF FF 
3387   28E9 FF FF FF FF 
3387   28ED FF FF FF FF 
3387   28F1 FF FF FF FF 
3387   28F5 FF FF FF FF 
3387   28F9 FF FF FF FF 
3387   28FD FF FF FF FF 
3387   2901 FF FF FF FF 
3387   2905 FF FF FF FF 
3387   2909 FF FF FF FF 
3387   290D FF FF FF FF 
3387   2911 FF FF FF FF 
3387   2915 FF FF FF FF 
3387   2919 FF FF FF FF 
3387   291D FF FF FF FF 
3387   2921 FF FF FF FF 
3387   2925 FF FF FF FF 
3387   2929 FF FF FF FF 
3387   292D FF FF FF FF 
3387   2931 FF FF FF FF 
3387   2935 FF FF FF FF 
3387   2939 FF FF FF FF 
3387   293D FF FF FF FF 
3387   2941 FF FF FF FF 
3387   2945 FF FF FF FF 
3387   2949 FF FF FF FF 
3387   294D FF FF FF FF 
3387   2951 FF FF FF FF 
3387   2955 FF FF FF FF 
3387   2959 FF FF FF FF 
3387   295D FF FF FF FF 
3387   2961 FF FF FF FF 
3387   2965 FF FF FF FF 
3387   2969 FF FF FF FF 
3387   296D FF FF FF FF 
3387   2971 FF FF FF FF 
3387   2975 FF FF FF FF 
3387   2979 FF FF FF FF 
3387   297D FF FF FF FF 
3387   2981 FF FF FF FF 
3387   2985 FF FF FF FF 
3387   2989 FF FF FF FF 
3387   298D FF FF FF FF 
3387   2991 FF FF FF FF 
3387   2995 FF FF FF FF 
3387   2999 FF FF FF FF 
3387   299D FF FF FF FF 
3387   29A1 FF FF FF FF 
3387   29A5 FF FF FF FF 
3387   29A9 FF FF FF FF 
3387   29AD FF FF FF FF 
3387   29B1 FF FF FF FF 
3387   29B5 FF FF FF FF 
3387   29B9 FF FF FF FF 
3387   29BD FF FF FF FF 
3387   29C1 FF FF FF FF 
3387   29C5 FF FF FF FF 
3387   29C9 FF FF FF FF 
3387   29CD FF FF FF FF 
3387   29D1 FF FF FF FF 
3387   29D5 FF FF FF FF 
3387   29D9 FF FF FF FF 
3387   29DD FF FF FF FF 
3387   29E1 FF FF FF FF 
3387   29E5 FF FF FF FF 
3387   29E9 FF FF FF FF 
3387   29ED FF FF FF FF 
3387   29F1 FF FF FF FF 
3387   29F5 FF FF FF FF 
3387   29F9 FF FF FF FF 
3387   29FD FF FF FF FF 
3387   2A01 FF FF FF FF 
3387   2A05 FF FF FF FF 
3387   2A09 FF FF FF FF 
3387   2A0D FF FF FF FF 
3387   2A11 FF FF FF FF 
3387   2A15 FF FF FF FF 
3387   2A19 FF FF FF FF 
3387   2A1D FF FF FF FF 
3387   2A21 FF FF FF FF 
3387   2A25 FF FF FF FF 
3387   2A29 FF FF FF FF 
3387   2A2D FF FF FF FF 
3387   2A31 FF FF FF FF 
3387   2A35 FF FF FF FF 
3387   2A39 FF FF FF FF 
3387   2A3D FF FF FF FF 
3387   2A41 FF FF FF FF 
3387   2A45 FF FF FF FF 
3387   2A49 FF FF FF FF 
3387   2A4D FF FF FF FF 
3387   2A51 FF FF FF FF 
3387   2A55 FF FF FF FF 
3387   2A59 FF FF FF FF 
3387   2A5D FF FF FF FF 
3387   2A61 FF FF FF FF 
3387   2A65 FF FF FF FF 
3387   2A69 FF FF FF FF 
3387   2A6D FF FF FF FF 
3387   2A71 FF FF FF FF 
3387   2A75 FF FF FF FF 
3387   2A79 FF FF FF FF 
3387   2A7D FF FF FF FF 
3387   2A81 FF FF FF FF 
3387   2A85 FF FF FF FF 
3387   2A89 FF FF FF FF 
3387   2A8D FF FF FF FF 
3387   2A91 FF FF FF FF 
3387   2A95 FF FF FF FF 
3387   2A99 FF FF FF FF 
3387   2A9D FF FF FF FF 
3387   2AA1 FF FF FF FF 
3387   2AA5 FF FF FF FF 
3387   2AA9 FF FF FF FF 
3387   2AAD FF FF FF FF 
3387   2AB1 FF FF FF FF 
3387   2AB5 FF FF FF FF 
3387   2AB9 FF FF FF FF 
3387   2ABD FF FF FF FF 
3387   2AC1 FF FF FF FF 
3387   2AC5 FF FF FF FF 
3387   2AC9 FF FF FF FF 
3387   2ACD FF FF FF FF 
3387   2AD1 FF FF FF FF 
3387   2AD5 FF FF FF FF 
3387   2AD9 FF FF FF FF 
3387   2ADD FF FF FF FF 
3387   2AE1 FF FF FF FF 
3387   2AE5 FF FF FF FF 
3387   2AE9 FF FF FF FF 
3387   2AED FF FF FF FF 
3387   2AF1 FF FF FF FF 
3387   2AF5 FF FF FF FF 
3387   2AF9 FF FF FF FF 
3387   2AFD FF FF FF FF 
3387   2B01 FF FF FF FF 
3387   2B05 FF FF FF FF 
3387   2B09 FF FF FF FF 
3387   2B0D FF FF FF FF 
3387   2B11 FF FF FF FF 
3387   2B15 FF FF FF FF 
3387   2B19 FF FF FF FF 
3387   2B1D FF FF FF FF 
3387   2B21 FF FF FF FF 
3387   2B25 FF FF FF FF 
3387   2B29 FF FF FF FF 
3387   2B2D FF FF FF FF 
3387   2B31 FF FF FF FF 
3387   2B35 FF FF FF FF 
3387   2B39 FF FF FF FF 
3387   2B3D FF FF FF FF 
3387   2B41 FF FF FF FF 
3387   2B45 FF FF FF FF 
3387   2B49 FF FF FF FF 
3387   2B4D FF FF FF FF 
3387   2B51 FF FF FF FF 
3387   2B55 FF FF FF FF 
3387   2B59 FF FF FF FF 
3387   2B5D FF FF FF FF 
3387   2B61 FF FF FF FF 
3387   2B65 FF FF FF FF 
3387   2B69 FF FF FF FF 
3387   2B6D FF FF FF FF 
3387   2B71 FF FF FF FF 
3387   2B75 FF FF FF FF 
3387   2B79 FF FF FF FF 
3387   2B7D FF FF FF FF 
3387   2B81 FF FF FF FF 
3387   2B85 FF FF FF FF 
3387   2B89 FF FF FF FF 
3387   2B8D FF FF FF FF 
3387   2B91 FF FF FF FF 
3387   2B95 FF FF FF FF 
3387   2B99 FF FF FF FF 
3387   2B9D FF FF FF FF 
3387   2BA1 FF FF FF FF 
3387   2BA5 FF FF FF FF 
3387   2BA9 FF FF FF FF 
3387   2BAD FF FF FF FF 
3387   2BB1 FF FF FF FF 
3387   2BB5 FF FF FF FF 
3387   2BB9 FF FF FF FF 
3387   2BBD FF FF FF FF 
3387   2BC1 FF FF FF FF 
3387   2BC5 FF FF FF FF 
3387   2BC9 FF FF FF FF 
3387   2BCD FF FF FF FF 
3387   2BD1 FF FF FF FF 
3387   2BD5 FF FF FF FF 
3387   2BD9 FF FF FF FF 
3387   2BDD FF FF FF FF 
3387   2BE1 FF FF FF FF 
3387   2BE5 FF FF FF FF 
3387   2BE9 FF FF FF FF 
3387   2BED FF FF FF FF 
3387   2BF1 FF FF FF FF 
3387   2BF5 FF FF FF FF 
3387   2BF9 FF FF FF FF 
3387   2BFD FF FF FF FF 
3387   2C01 FF FF FF FF 
3387   2C05 FF FF FF FF 
3387   2C09 FF FF FF FF 
3387   2C0D FF FF FF FF 
3387   2C11 FF FF FF FF 
3387   2C15 FF FF FF FF 
3387   2C19 FF FF FF FF 
3387   2C1D FF FF FF FF 
3387   2C21 FF FF FF FF 
3387   2C25 FF FF FF FF 
3387   2C29 FF FF FF FF 
3387   2C2D FF FF FF FF 
3387   2C31 FF FF FF FF 
3387   2C35 FF FF FF FF 
3387   2C39 FF FF FF FF 
3387   2C3D FF FF FF FF 
3387   2C41 FF FF FF FF 
3387   2C45 FF FF FF FF 
3387   2C49 FF FF FF FF 
3387   2C4D FF FF FF FF 
3387   2C51 FF FF FF FF 
3387   2C55 FF FF FF FF 
3387   2C59 FF FF FF FF 
3387   2C5D FF FF FF FF 
3387   2C61 FF FF FF FF 
3387   2C65 FF FF FF FF 
3387   2C69 FF FF FF FF 
3387   2C6D FF FF FF FF 
3387   2C71 FF FF FF FF 
3387   2C75 FF FF FF FF 
3387   2C79 FF FF FF FF 
3387   2C7D FF FF FF FF 
3387   2C81 FF FF FF FF 
3387   2C85 FF FF FF FF 
3387   2C89 FF FF FF FF 
3387   2C8D FF FF FF FF 
3387   2C91 FF FF FF FF 
3387   2C95 FF FF FF FF 
3387   2C99 FF FF FF FF 
3387   2C9D FF FF FF FF 
3387   2CA1 FF FF FF FF 
3387   2CA5 FF FF FF FF 
3387   2CA9 FF FF FF FF 
3387   2CAD FF FF FF FF 
3387   2CB1 FF FF FF FF 
3387   2CB5 FF FF FF FF 
3387   2CB9 FF FF FF FF 
3387   2CBD FF FF FF FF 
3387   2CC1 FF FF FF FF 
3387   2CC5 FF FF FF FF 
3387   2CC9 FF FF FF FF 
3387   2CCD FF FF FF FF 
3387   2CD1 FF FF FF FF 
3387   2CD5 FF FF FF FF 
3387   2CD9 FF FF FF FF 
3387   2CDD FF FF FF FF 
3387   2CE1 FF FF FF FF 
3387   2CE5 FF FF FF FF 
3387   2CE9 FF FF FF FF 
3387   2CED FF FF FF FF 
3387   2CF1 FF FF FF FF 
3387   2CF5 FF FF FF FF 
3387   2CF9 FF FF FF FF 
3387   2CFD FF FF FF FF 
3387   2D01 FF FF FF FF 
3387   2D05 FF FF FF FF 
3387   2D09 FF FF FF FF 
3387   2D0D FF FF FF FF 
3387   2D11 FF FF FF FF 
3387   2D15 FF FF FF FF 
3387   2D19 FF FF FF FF 
3387   2D1D FF FF FF FF 
3387   2D21 FF FF FF FF 
3387   2D25 FF FF FF FF 
3387   2D29 FF FF FF FF 
3387   2D2D FF FF FF FF 
3387   2D31 FF FF FF FF 
3387   2D35 FF FF FF FF 
3387   2D39 FF FF FF FF 
3387   2D3D FF FF FF FF 
3387   2D41 FF FF FF FF 
3387   2D45 FF FF FF FF 
3387   2D49 FF FF FF FF 
3387   2D4D FF FF FF FF 
3387   2D51 FF FF FF FF 
3387   2D55 FF FF FF FF 
3387   2D59 FF FF FF FF 
3387   2D5D FF FF FF FF 
3387   2D61 FF FF FF FF 
3387   2D65 FF FF FF FF 
3387   2D69 FF FF FF FF 
3387   2D6D FF FF FF FF 
3387   2D71 FF FF FF FF 
3387   2D75 FF FF FF FF 
3387   2D79 FF FF FF FF 
3387   2D7D FF FF FF FF 
3387   2D81 FF FF FF FF 
3387   2D85 FF FF FF FF 
3387   2D89 FF FF FF FF 
3387   2D8D FF FF FF FF 
3387   2D91 FF FF FF FF 
3387   2D95 FF FF FF FF 
3387   2D99 FF FF FF FF 
3387   2D9D FF FF FF FF 
3387   2DA1 FF FF FF FF 
3387   2DA5 FF FF FF FF 
3387   2DA9 FF FF FF FF 
3387   2DAD FF FF FF FF 
3387   2DB1 FF FF FF FF 
3387   2DB5 FF FF FF FF 
3387   2DB9 FF FF FF FF 
3387   2DBD FF FF FF FF 
3387   2DC1 FF FF FF FF 
3387   2DC5 FF FF FF FF 
3387   2DC9 FF FF FF FF 
3387   2DCD FF FF FF FF 
3387   2DD1 FF FF FF FF 
3387   2DD5 FF FF FF FF 
3387   2DD9 FF FF FF FF 
3387   2DDD FF FF FF FF 
3387   2DE1 FF FF FF FF 
3387   2DE5 FF FF FF FF 
3387   2DE9 FF FF FF FF 
3387   2DED FF FF FF FF 
3387   2DF1 FF FF FF FF 
3387   2DF5 FF FF FF FF 
3387   2DF9 FF FF FF FF 
3387   2DFD FF FF FF FF 
3387   2E01 FF FF FF FF 
3387   2E05 FF FF FF FF 
3387   2E09 FF FF FF FF 
3387   2E0D FF FF FF FF 
3387   2E11 FF FF FF FF 
3387   2E15 FF FF FF FF 
3387   2E19 FF FF FF FF 
3387   2E1D FF FF FF FF 
3387   2E21 FF FF FF FF 
3387   2E25 FF FF FF FF 
3387   2E29 FF FF FF FF 
3387   2E2D FF FF FF FF 
3387   2E31 FF FF FF FF 
3387   2E35 FF FF FF FF 
3387   2E39 FF FF FF FF 
3387   2E3D FF FF FF FF 
3387   2E41 FF FF FF FF 
3387   2E45 FF FF FF FF 
3387   2E49 FF FF FF FF 
3387   2E4D FF FF FF FF 
3387   2E51 FF FF FF FF 
3387   2E55 FF FF FF FF 
3387   2E59 FF FF FF FF 
3387   2E5D FF FF FF FF 
3387   2E61 FF FF FF FF 
3387   2E65 FF FF FF FF 
3387   2E69 FF FF FF FF 
3387   2E6D FF FF FF FF 
3387   2E71 FF FF FF FF 
3387   2E75 FF FF FF FF 
3387   2E79 FF FF FF FF 
3387   2E7D FF FF FF FF 
3387   2E81 FF FF FF FF 
3387   2E85 FF FF FF FF 
3387   2E89 FF FF FF FF 
3387   2E8D FF FF FF FF 
3387   2E91 FF FF FF FF 
3387   2E95 FF FF FF FF 
3387   2E99 FF FF FF FF 
3387   2E9D FF FF FF FF 
3387   2EA1 FF FF FF FF 
3387   2EA5 FF FF FF FF 
3387   2EA9 FF FF FF FF 
3387   2EAD FF FF FF FF 
3387   2EB1 FF FF FF FF 
3387   2EB5 FF FF FF FF 
3387   2EB9 FF FF FF FF 
3387   2EBD FF FF FF FF 
3387   2EC1 FF FF FF FF 
3387   2EC5 FF FF FF FF 
3387   2EC9 FF FF FF FF 
3387   2ECD FF FF FF FF 
3387   2ED1 FF FF FF FF 
3387   2ED5 FF FF FF FF 
3387   2ED9 FF FF FF FF 
3387   2EDD FF FF FF FF 
3387   2EE1 FF FF FF FF 
3387   2EE5 FF FF FF FF 
3387   2EE9 FF FF FF FF 
3387   2EED FF FF FF FF 
3387   2EF1 FF FF FF FF 
3387   2EF5 FF FF FF FF 
3387   2EF9 FF FF FF FF 
3387   2EFD FF FF FF FF 
3387   2F01 FF FF FF FF 
3387   2F05 FF FF FF FF 
3387   2F09 FF FF FF FF 
3387   2F0D FF FF FF FF 
3387   2F11 FF FF FF FF 
3387   2F15 FF FF FF FF 
3387   2F19 FF FF FF FF 
3387   2F1D FF FF FF FF 
3387   2F21 FF FF FF FF 
3387   2F25 FF FF FF FF 
3387   2F29 FF FF FF FF 
3387   2F2D FF FF FF FF 
3387   2F31 FF FF FF FF 
3387   2F35 FF FF FF FF 
3387   2F39 FF FF FF FF 
3387   2F3D FF FF FF FF 
3387   2F41 FF FF FF FF 
3387   2F45 FF FF FF FF 
3387   2F49 FF FF FF FF 
3387   2F4D FF FF FF FF 
3387   2F51 FF FF FF FF 
3387   2F55 FF FF FF FF 
3387   2F59 FF FF FF FF 
3387   2F5D FF FF FF FF 
3387   2F61 FF FF FF FF 
3387   2F65 FF FF FF FF 
3387   2F69 FF FF FF FF 
3387   2F6D FF FF FF FF 
3387   2F71 FF FF FF FF 
3387   2F75 FF FF FF FF 
3387   2F79 FF FF FF FF 
3387   2F7D FF FF FF FF 
3387   2F81 FF FF FF FF 
3387   2F85 FF FF FF FF 
3387   2F89 FF FF FF FF 
3387   2F8D FF FF FF FF 
3387   2F91 FF FF FF FF 
3387   2F95 FF FF FF FF 
3387   2F99 FF FF FF FF 
3387   2F9D FF FF FF FF 
3387   2FA1 FF FF FF FF 
3387   2FA5 FF FF FF FF 
3387   2FA9 FF FF FF FF 
3387   2FAD FF FF FF FF 
3387   2FB1 FF FF FF FF 
3387   2FB5 FF FF FF FF 
3387   2FB9 FF FF FF FF 
3387   2FBD FF FF FF FF 
3387   2FC1 FF FF FF FF 
3387   2FC5 FF FF FF FF 
3387   2FC9 FF FF FF FF 
3387   2FCD FF FF FF FF 
3387   2FD1 FF FF FF FF 
3387   2FD5 FF FF FF FF 
3387   2FD9 FF FF FF FF 
3387   2FDD FF FF FF FF 
3387   2FE1 FF FF FF FF 
3387   2FE5 FF FF FF FF 
3387   2FE9 FF FF FF FF 
3387   2FED FF FF FF FF 
3387   2FF1 FF FF FF FF 
3387   2FF5 FF FF FF FF 
3387   2FF9 FF FF FF FF 
3387   2FFD FF FF FF FF 
3387   3001 FF FF FF FF 
3387   3005 FF FF FF FF 
3387   3009 FF FF FF FF 
3387   300D FF FF FF FF 
3387   3011 FF FF FF FF 
3387   3015 FF FF FF FF 
3387   3019 FF FF FF FF 
3387   301D FF FF FF FF 
3387   3021 FF FF FF FF 
3387   3025 FF FF FF FF 
3387   3029 FF FF FF FF 
3387   302D FF FF FF FF 
3387   3031 FF FF FF FF 
3387   3035 FF FF FF FF 
3387   3039 FF FF FF FF 
3387   303D FF FF FF FF 
3387   3041 FF FF FF FF 
3387   3045 FF FF FF FF 
3387   3049 FF FF FF FF 
3387   304D FF FF FF FF 
3387   3051 FF FF FF FF 
3387   3055 FF FF FF FF 
3387   3059 FF FF FF FF 
3387   305D FF FF FF FF 
3387   3061 FF FF FF FF 
3387   3065 FF FF FF FF 
3387   3069 FF FF FF FF 
3387   306D FF FF FF FF 
3387   3071 FF FF FF FF 
3387   3075 FF FF FF FF 
3387   3079 FF FF FF FF 
3387   307D FF FF FF FF 
3387   3081 FF FF FF FF 
3387   3085 FF FF FF FF 
3387   3089 FF FF FF FF 
3387   308D FF FF FF FF 
3387   3091 FF FF FF FF 
3387   3095 FF FF FF FF 
3387   3099 FF FF FF FF 
3387   309D FF FF FF FF 
3387   30A1 FF FF FF FF 
3387   30A5 FF FF FF FF 
3387   30A9 FF FF FF FF 
3387   30AD FF FF FF FF 
3387   30B1 FF FF FF FF 
3387   30B5 FF FF FF FF 
3387   30B9 FF FF FF FF 
3387   30BD FF FF FF FF 
3387   30C1 FF FF FF FF 
3387   30C5 FF FF FF FF 
3387   30C9 FF FF FF FF 
3387   30CD FF FF FF FF 
3387   30D1 FF FF FF FF 
3387   30D5 FF FF FF FF 
3387   30D9 FF FF FF FF 
3387   30DD FF FF FF FF 
3387   30E1 FF FF FF FF 
3387   30E5 FF FF FF FF 
3387   30E9 FF FF FF FF 
3387   30ED FF FF FF FF 
3387   30F1 FF FF FF FF 
3387   30F5 FF FF FF FF 
3387   30F9 FF FF FF FF 
3387   30FD FF FF FF FF 
3387   3101 FF FF FF FF 
3387   3105 FF FF FF FF 
3387   3109 FF FF FF FF 
3387   310D FF FF FF FF 
3387   3111 FF FF FF FF 
3387   3115 FF FF FF FF 
3387   3119 FF FF FF FF 
3387   311D FF FF FF FF 
3387   3121 FF FF FF FF 
3387   3125 FF FF FF FF 
3387   3129 FF FF FF FF 
3387   312D FF FF FF FF 
3387   3131 FF FF FF FF 
3387   3135 FF FF FF FF 
3387   3139 FF FF FF FF 
3387   313D FF FF FF FF 
3387   3141 FF FF FF FF 
3387   3145 FF FF FF FF 
3387   3149 FF FF FF FF 
3387   314D FF FF FF FF 
3387   3151 FF FF FF FF 
3387   3155 FF FF FF FF 
3387   3159 FF FF FF FF 
3387   315D FF FF FF FF 
3387   3161 FF FF FF FF 
3387   3165 FF FF FF FF 
3387   3169 FF FF FF FF 
3387   316D FF FF FF FF 
3387   3171 FF FF FF FF 
3387   3175 FF FF FF FF 
3387   3179 FF FF FF FF 
3387   317D FF FF FF FF 
3387   3181 FF FF FF FF 
3387   3185 FF FF FF FF 
3387   3189 FF FF FF FF 
3387   318D FF FF FF FF 
3387   3191 FF FF FF FF 
3387   3195 FF FF FF FF 
3387   3199 FF FF FF FF 
3387   319D FF FF FF FF 
3387   31A1 FF FF FF FF 
3387   31A5 FF FF FF FF 
3387   31A9 FF FF FF FF 
3387   31AD FF FF FF FF 
3387   31B1 FF FF FF FF 
3387   31B5 FF FF FF FF 
3387   31B9 FF FF FF FF 
3387   31BD FF FF FF FF 
3387   31C1 FF FF FF FF 
3387   31C5 FF FF FF FF 
3387   31C9 FF FF FF FF 
3387   31CD FF FF FF FF 
3387   31D1 FF FF FF FF 
3387   31D5 FF FF FF FF 
3387   31D9 FF FF FF FF 
3387   31DD FF FF FF FF 
3387   31E1 FF FF FF FF 
3387   31E5 FF FF FF FF 
3387   31E9 FF FF FF FF 
3387   31ED FF FF FF FF 
3387   31F1 FF FF FF FF 
3387   31F5 FF FF FF FF 
3387   31F9 FF FF FF FF 
3387   31FD FF FF FF FF 
3387   3201 FF FF FF FF 
3387   3205 FF FF FF FF 
3387   3209 FF FF FF FF 
3387   320D FF FF FF FF 
3387   3211 FF FF FF FF 
3387   3215 FF FF FF FF 
3387   3219 FF FF FF FF 
3387   321D FF FF FF FF 
3387   3221 FF FF FF FF 
3387   3225 FF FF FF FF 
3387   3229 FF FF FF FF 
3387   322D FF FF FF FF 
3388   3231             
3389   3231             scrap_sector:
3390   3231 FF FF FF FF   .fill 512         ; scrap sector
3390   3235 FF FF FF FF 
3390   3239 FF FF FF FF 
3390   323D FF FF FF FF 
3390   3241 FF FF FF FF 
3390   3245 FF FF FF FF 
3390   3249 FF FF FF FF 
3390   324D FF FF FF FF 
3390   3251 FF FF FF FF 
3390   3255 FF FF FF FF 
3390   3259 FF FF FF FF 
3390   325D FF FF FF FF 
3390   3261 FF FF FF FF 
3390   3265 FF FF FF FF 
3390   3269 FF FF FF FF 
3390   326D FF FF FF FF 
3390   3271 FF FF FF FF 
3390   3275 FF FF FF FF 
3390   3279 FF FF FF FF 
3390   327D FF FF FF FF 
3390   3281 FF FF FF FF 
3390   3285 FF FF FF FF 
3390   3289 FF FF FF FF 
3390   328D FF FF FF FF 
3390   3291 FF FF FF FF 
3390   3295 FF FF FF FF 
3390   3299 FF FF FF FF 
3390   329D FF FF FF FF 
3390   32A1 FF FF FF FF 
3390   32A5 FF FF FF FF 
3390   32A9 FF FF FF FF 
3390   32AD FF FF FF FF 
3390   32B1 FF FF FF FF 
3390   32B5 FF FF FF FF 
3390   32B9 FF FF FF FF 
3390   32BD FF FF FF FF 
3390   32C1 FF FF FF FF 
3390   32C5 FF FF FF FF 
3390   32C9 FF FF FF FF 
3390   32CD FF FF FF FF 
3390   32D1 FF FF FF FF 
3390   32D5 FF FF FF FF 
3390   32D9 FF FF FF FF 
3390   32DD FF FF FF FF 
3390   32E1 FF FF FF FF 
3390   32E5 FF FF FF FF 
3390   32E9 FF FF FF FF 
3390   32ED FF FF FF FF 
3390   32F1 FF FF FF FF 
3390   32F5 FF FF FF FF 
3390   32F9 FF FF FF FF 
3390   32FD FF FF FF FF 
3390   3301 FF FF FF FF 
3390   3305 FF FF FF FF 
3390   3309 FF FF FF FF 
3390   330D FF FF FF FF 
3390   3311 FF FF FF FF 
3390   3315 FF FF FF FF 
3390   3319 FF FF FF FF 
3390   331D FF FF FF FF 
3390   3321 FF FF FF FF 
3390   3325 FF FF FF FF 
3390   3329 FF FF FF FF 
3390   332D FF FF FF FF 
3390   3331 FF FF FF FF 
3390   3335 FF FF FF FF 
3390   3339 FF FF FF FF 
3390   333D FF FF FF FF 
3390   3341 FF FF FF FF 
3390   3345 FF FF FF FF 
3390   3349 FF FF FF FF 
3390   334D FF FF FF FF 
3390   3351 FF FF FF FF 
3390   3355 FF FF FF FF 
3390   3359 FF FF FF FF 
3390   335D FF FF FF FF 
3390   3361 FF FF FF FF 
3390   3365 FF FF FF FF 
3390   3369 FF FF FF FF 
3390   336D FF FF FF FF 
3390   3371 FF FF FF FF 
3390   3375 FF FF FF FF 
3390   3379 FF FF FF FF 
3390   337D FF FF FF FF 
3390   3381 FF FF FF FF 
3390   3385 FF FF FF FF 
3390   3389 FF FF FF FF 
3390   338D FF FF FF FF 
3390   3391 FF FF FF FF 
3390   3395 FF FF FF FF 
3390   3399 FF FF FF FF 
3390   339D FF FF FF FF 
3390   33A1 FF FF FF FF 
3390   33A5 FF FF FF FF 
3390   33A9 FF FF FF FF 
3390   33AD FF FF FF FF 
3390   33B1 FF FF FF FF 
3390   33B5 FF FF FF FF 
3390   33B9 FF FF FF FF 
3390   33BD FF FF FF FF 
3390   33C1 FF FF FF FF 
3390   33C5 FF FF FF FF 
3390   33C9 FF FF FF FF 
3390   33CD FF FF FF FF 
3390   33D1 FF FF FF FF 
3390   33D5 FF FF FF FF 
3390   33D9 FF FF FF FF 
3390   33DD FF FF FF FF 
3390   33E1 FF FF FF FF 
3390   33E5 FF FF FF FF 
3390   33E9 FF FF FF FF 
3390   33ED FF FF FF FF 
3390   33F1 FF FF FF FF 
3390   33F5 FF FF FF FF 
3390   33F9 FF FF FF FF 
3390   33FD FF FF FF FF 
3390   3401 FF FF FF FF 
3390   3405 FF FF FF FF 
3390   3409 FF FF FF FF 
3390   340D FF FF FF FF 
3390   3411 FF FF FF FF 
3390   3415 FF FF FF FF 
3390   3419 FF FF FF FF 
3390   341D FF FF FF FF 
3390   3421 FF FF FF FF 
3390   3425 FF FF FF FF 
3390   3429 FF FF FF FF 
3390   342D FF FF FF FF 
3391   3431             transient_area:
3392   3431 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
3393   3432             
3394   3432             .end
tasm: Number of errors = 0
