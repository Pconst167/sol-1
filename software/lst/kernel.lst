0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; For the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; FILE ENTRY ATTRIBUTES
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0107   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0108   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0109   0000             FST_NBR_DIRECTORIES     .equ 64
0110   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0112   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0113   0000             FST_LBA_START           .equ 32
0114   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0115   0000             
0116   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0117   0000             FS_SECTORS_PER_FILE     .equ 32 ; the first sector is always a header with a NULL parameter (first byte)
0118   0000                                             ; so that we know which blocks are free or taken
0119   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0120   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0121   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0122   0000             FS_LBA_END              .equ (FS_LBA_START + FS_TOTAL_SECTORS - 1)
0123   0000             
0124   0000             root_id:                .equ FST_LBA_START
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; GLOBAL SYSTEM VARIABLES
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; IRQ table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 59 00       .dw int_6
0141   000E A5 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 4D 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 45 02       .dw trap_privilege
0153   0014 62 03       .dw trap_div_zero
0154   0016 6F 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 51 02       .dw syscall_break
0165   0022 70 03       .dw syscall_rtc
0166   0024 AA 04       .dw syscall_ide
0167   0026 85 05       .dw syscall_io
0168   0028 42 06       .dw syscall_file_system
0169   002A 9A 0F       .dw syscall_create_proc
0170   002C 0A 02       .dw syscall_list_procs
0171   002E A2 03       .dw syscall_datetime
0172   0030 C6 01       .dw syscall_reboot
0173   0032 64 0F       .dw syscall_pause_proc
0174   0034 D2 01       .dw syscall_resume_proc
0175   0036 21 0F       .dw syscall_terminate_proc
0176   0038 E4 00       .dw syscall_system
0177   003A 1A 01       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; IRQs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" Floppy Drive Controller IRQ
0220   003C             int_0_fdc:
0221   003C 3B 48 00      mov d, s_fdc_irq
0222   003F 07 97 12      call _puts
0223   0042 06            sysret
0224   0043             int_1:
0225   0043 06            sysret
0226   0044             int_2:
0227   0044 06            sysret
0228   0045             int_3:
0229   0045 06            sysret
0230   0046             int_4:
0231   0046 06            sysret
0232   0047             int_5:
0233   0047 06            sysret
0234   0048             
0235   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0235   004C 30 20 45 78 
0235   0050 65 63 75 74 
0235   0054 65 64 2E 0A 
0235   0058 00 
0236   0059             
0237   0059             ; ------------------------------------------------------------------------------------------------------------------;
0238   0059             ; process swapping
0239   0059             ; ------------------------------------------------------------------------------------------------------------------;
0240   0059             int_6:  
0241   0059 4B            pusha                             ; save all registers into kernel stack
0242   005A 22 00         mov ah, 0
0243   005C 1D C8 17      mov al, [active_proc_index]
0244   005F FD 99         shl a                             ; x2
0245   0061 B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index
0246   0064 4F            mov di, a
0247   0065 48            mov a, sp
0248   0066 77            inc a
0249   0067 4D            mov si, a
0250   0068 38 14 00      mov c, 20
0251   006B FD F5         rep movsb                         ; save process state!
0252   006D             ; restore kernel stack position to point before interrupt arrived
0253   006D 51 14 00      add sp, 20
0254   0070             ; now load next process in queue
0255   0070 1D C8 17      mov al, [active_proc_index]
0256   0073 31 C7 17      mov bl, [nbr_active_procs]
0257   0076 BA            cmp al, bl
0258   0077 C6 7E 00      je int6_cycle_back
0259   007A 7A            inc al                            ; next process is next in the series
0260   007B 0A 80 00      jmp int6_continue
0261   007E             int6_cycle_back:
0262   007E 19 01         mov al, 1                         ; next process = process 1
0263   0080             int6_continue:
0264   0080 3D C8 17      mov [active_proc_index], al       ; set next active proc
0265   0083             
0266   0083             ; calculate LUT entry for next process
0267   0083 22 00         mov ah, 0
0268   0085 FD 99         shl a                             ; x2
0269   0087 B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index  
0270   008A               
0271   008A 4D            mov si, a                         ; source is proc state block
0272   008B 48            mov a, sp
0273   008C 5F 13 00      sub a, 19
0274   008F 4F            mov di, a                         ; destination is kernel stack
0275   0090             ; restore SP
0276   0090 7D            dec a
0277   0091 47            mov sp, a
0278   0092 38 14 00      mov c, 20
0279   0095 FD F5         rep movsb
0280   0097             ; set VM process
0281   0097 1D C8 17      mov al, [active_proc_index]
0282   009A 01            setptb
0283   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0           ; load counter 0 low byte
0284   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10         ; load counter 0 high byte
0285   00A3 4C            popa
0286   00A4 06            sysret
0287   00A5             
0288   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0289   00A5             ; UART0 Interrupt
0290   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0291   00A5             int_7_uart0:
0292   00A5 D7            push a
0293   00A6 DA            push d
0294   00A7 E1            pushf
0295   00A8 14 CD 17      mov a, [fifo_in]
0296   00AB 3C            mov d, a
0297   00AC 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0298   00AF B9 03         cmp al, $03                 ; CTRL-C
0299   00B1 C6 CE 00      je CTRLC
0300   00B4 B9 1A         cmp al, $1A                 ; CTRL-Z
0301   00B6 C6 D4 00      je CTRLZ
0302   00B9 3E            mov [d], al                 ; add to fifo
0303   00BA 14 CD 17      mov a, [fifo_in]
0304   00BD 77            inc a
0305   00BE AF 1D 25      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0306   00C1 C7 C7 00      jne int_7_continue
0307   00C4 10 1D 21      mov a, fifo  
0308   00C7             int_7_continue:  
0309   00C7 42 CD 17      mov [fifo_in], a            ; update fifo pointer
0310   00CA EE            popf
0311   00CB E7            pop d
0312   00CC E4            pop a  
0313   00CD 06            sysret
0314   00CE             CTRLC:
0315   00CE 51 05 00      add sp, 5
0316   00D1 0A 21 0F      jmp syscall_terminate_proc
0317   00D4             CTRLZ:
0318   00D4 EE            popf
0319   00D5 E7            pop d
0320   00D6 E4            pop a
0321   00D7 0A 64 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0322   00DA             
0323   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0324   00DA             ; system syscalls
0325   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0326   00DA             system_jmptbl:
0327   00DA 10 01         .dw system_uname
0328   00DC 17 01         .dw system_whoami
0329   00DE EA 00         .dw system_setparam
0330   00E0 ED 00         .dw system_bootloader_install
0331   00E2 E8 00         .dw system_getparam
0332   00E4             syscall_system:
0333   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0334   00E8             
0335   00E8             ; param register address in register d
0336   00E8             ; param value in register bl
0337   00E8             system_getparam:
0338   00E8 32            mov bl, [d]
0339   00E9 06            sysret
0340   00EA             
0341   00EA             ; param register address in register d
0342   00EA             ; param value in register bl
0343   00EA             system_setparam:
0344   00EA FD 3E         mov [d], bl
0345   00EC 06            sysret
0346   00ED             
0347   00ED             ; kernel LBA address in 'b'
0348   00ED             system_bootloader_install:
0349   00ED D8            push b
0350   00EE 26 00 00      mov b, 0
0351   00F1 38 00 00      mov c, 0
0352   00F4 22 01         mov ah, $01                 ; 1 sector
0353   00F6 3B 1D 27      mov d, transient_area
0354   00F9 07 F4 04      call ide_read_sect          ; read sector
0355   00FC E5            pop b
0356   00FD FD 44 FE 01   mov [d + 510], b            ; update LBA address
0357   0101 26 00 00      mov b, 0
0358   0104 38 00 00      mov c, 0
0359   0107 22 01         mov ah, $01                 ; 1 sector
0360   0109 3B 1D 27      mov d, transient_area
0361   010C 07 1A 05      call ide_write_sect         ; write sector
0362   010F 06            sysret
0363   0110             
0364   0110             system_uname:
0365   0110 3B DE 17      mov d, s_uname
0366   0113 07 97 12      call _puts
0367   0116 06            sysret
0368   0117             
0369   0117             system_whoami:
0370   0117 06            sysret
0371   0118             
0372   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373   0118             ; floppy drive system calls
0374   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0375   0118             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0376   0118             ;
0377   0118             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0378   0118             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0379   0118             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0380   0118             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0381   0118             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0382   0118             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0383   0118             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0384   0118             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0385   0118             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0386   0118             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0387   0118             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0388   0118             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0389   0118             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0390   0118             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0391   0118             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0392   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0393   0118             ; _FDC_CONFIG       .equ $FFC0 
0394   0118             ; _FDC_STATUS_1     .equ $FFC1
0395   0118             ; _FDC_WD_STAT_CMD  .equ $FFC8
0396   0118             ; _FDC_WD_TRACK     .equ $FFC9
0397   0118             ; _FDC_WD_SECTOR    .equ $FFCA
0398   0118             ; _FDC_WD_DATA      .equ $FFCB
0399   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0400   0118             fdc_jmptbl:
0401   0118 1E 01         .dw syscall_fdc_format
0402   011A             syscall_fdc:
0403   011A FD 0A 18 01   jmp [fdc_jmptbl + al]
0404   011E             
0405   011E             syscall_fdc_format:
0406   011E 3B 9A 01      mov d, s_format_begin
0407   0121 07 97 12      call _puts
0408   0124 FD 22 FF 00   mov g, $FF
0409   0128             fdc_wait_busy:
0410   0128 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0411   012B 87 01         and al, $01                ; busy bit
0412   012D C7 28 01      jnz fdc_wait_busy
0413   0130             
0414   0130 FD 4D 0B 19   mov si, fdc_40_FF
0415   0134 38 D1 00      mov c, 209
0416   0137 3B 7F 01      mov d, s_send_write_cmd
0417   013A 07 97 12      call _puts
0418   013D 3B C8 FF      mov d, _FDC_WD_STAT_CMD
0419   0140 19 F2         mov al, %11110010          ; Write Track Command: {1111, 0: Enable Spin-up Seq, 0: No Settling Delay, 1: No Write Precompensation, 0}
0420   0142 3E            mov [d], al
0421   0143             fdc_sector_loop:
0422   0143             fdc_drq_loop:
0423   0143 3B C1 FF      mov d, _FDC_STATUS_1
0424   0146 1E            mov al, [d]
0425   0147 87 01         and al, $01                ; check drq bit
0426   0149 C6 43 01      jz fdc_drq_loop
0427   014C F6            lodsb                      ; load format byte
0428   014D 3B CB FF      mov d, _FDC_WD_DATA        ; data register
0429   0150 3E            mov [d], al                ; send data byte to wd1770
0430   0151 7E            dec c
0431   0152 C7 43 01      jnz fdc_sector_loop
0432   0155 3B 3C 19      mov d, fdc_sector
0433   0158 32            mov bl, [d]
0434   0159 FD 77         inc b
0435   015B FD 3E         mov [d], bl
0436   015D C1 0B         cmp bl, 11
0437   015F C7 43 01      jne fdc_sector_loop        ; continue formatting
0438   0162             
0439   0162             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0440   0162             fdc_drq_loop_fill:
0441   0162 3B C1 FF      mov d, _FDC_STATUS_1
0442   0165 1E            mov al, [d]
0443   0166 87 01         and al, $01                ; check drq bit
0444   0168 C6 62 01      jz fdc_drq_loop_fill
0445   016B 3B CB FF      mov d, _FDC_WD_DATA        ; data register
0446   016E FD 1A         mov al, gl
0447   0170 3E            mov [d], al                ; send data byte to wd1770
0448   0171 0C            lodstat
0449   0172 1A            mov al, ah
0450   0173 87 01         and al, $01
0451   0175 C6 62 01      jz fdc_drq_loop_fill
0452   0178             
0453   0178 3B B3 01      mov d, s_format_done
0454   017B 07 97 12      call _puts
0455   017E             
0456   017E 06            sysret
0457   017F             
0458   017F 0A 53 65 6E s_send_write_cmd: .db "\nSending Write Command...\n", 0
0458   0183 64 69 6E 67 
0458   0187 20 57 72 69 
0458   018B 74 65 20 43 
0458   018F 6F 6D 6D 61 
0458   0193 6E 64 2E 2E 
0458   0197 2E 0A 00 
0459   019A 0A 46 6F 72 s_format_begin:   .db "\nFormatting starting...\n", 0
0459   019E 6D 61 74 74 
0459   01A2 69 6E 67 20 
0459   01A6 73 74 61 72 
0459   01AA 74 69 6E 67 
0459   01AE 2E 2E 2E 0A 
0459   01B2 00 
0460   01B3 0A 46 6F 72 s_format_done:    .db "\nFormatting done.\n", 0
0460   01B7 6D 61 74 74 
0460   01BB 69 6E 67 20 
0460   01BF 64 6F 6E 65 
0460   01C3 2E 0A 00 
0461   01C6             
0462   01C6             ; REBOOT SYSTEM
0463   01C6             syscall_reboot:
0464   01C6 FD D7 FF FF   push word $FFFF 
0465   01CA FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0466   01CD FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0467   01D1 06            sysret
0468   01D2             
0469   01D2             ;------------------------------------------------------------------------------------------------------;;
0470   01D2             ; switch to another process
0471   01D2             ; inputs:
0472   01D2             ; AL = new process number
0473   01D2             ;------------------------------------------------------------------------------------------------------;;
0474   01D2             syscall_resume_proc:
0475   01D2 FD 78         mov g, a                            ; save the process number
0476   01D4 4B            pusha                               ; save all registers into kernel stack
0477   01D5 22 00         mov ah, 0
0478   01D7 1D C8 17      mov al, [active_proc_index]
0479   01DA FD 99         shl a              ; x2
0480   01DC B7 17 10      mov a, [proc_table_convert + a]     ; get process state start index
0481   01DF 4F            mov di, a
0482   01E0 48            mov a, sp
0483   01E1 77            inc a
0484   01E2 4D            mov si, a
0485   01E3 38 14 00      mov c, 20
0486   01E6 FD F5         rep movsb                           ; save process state!
0487   01E8             ; restore kernel stack position to point before interrupt arrived
0488   01E8 51 14 00      add sp, 20
0489   01EB             ; now load the new process number!
0490   01EB FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0491   01ED 3D C8 17      mov [active_proc_index], al         ; set new active proc
0492   01F0             ; calculate LUT entry for next process
0493   01F0 22 00         mov ah, 0
0494   01F2 FD 99         shl a                               ; x2
0495   01F4 B7 17 10      mov a, [proc_table_convert + a]     ; get process state start index  
0496   01F7 4D            mov si, a                           ; source is proc state block
0497   01F8 48            mov a, sp
0498   01F9 5F 13 00      sub a, 19
0499   01FC 4F            mov di, a                           ; destination is kernel stack
0500   01FD             ; restore SP
0501   01FD 7D            dec a
0502   01FE 47            mov sp, a
0503   01FF 38 14 00      mov c, 20
0504   0202 FD F5         rep movsb
0505   0204             ; set VM process
0506   0204 1D C8 17      mov al, [active_proc_index]
0507   0207 01            setptb
0508   0208 4C            popa
0509   0209 06            sysret
0510   020A             
0511   020A             ;------------------------------------------------------------------------------------------------------;;
0512   020A             ; list processes
0513   020A             ;------------------------------------------------------------------------------------------------------;;
0514   020A             syscall_list_procs:
0515   020A 3B FF 17      mov d, s_ps_header
0516   020D 07 97 12      call _puts
0517   0210 3B 8E 1C      mov d, proc_availab_table + 1
0518   0213 38 01 00      mov c, 1
0519   0216             list_procs_L0:  
0520   0216 BD 01         cmp byte[d], 1
0521   0218 C7 3C 02      jne list_procs_next
0522   021B 2D            mov b, d
0523   021C 61 8D 1C      sub b, proc_availab_table
0524   021F FD 9F 05      shl b, 5
0525   0222 DA            push d
0526   0223 D8            push b
0527   0224 28            mov b, c
0528   0225 07 37 13      call print_u8x
0529   0228 22 20         mov ah, ' '
0530   022A 07 6B 11      call _putchar
0531   022D 07 6B 11      call _putchar
0532   0230 E5            pop b
0533   0231 74            mov d, b
0534   0232 58 9D 1C      add d, proc_names
0535   0235 07 97 12      call _puts
0536   0238 07 44 12      call printnl
0537   023B E7            pop d
0538   023C             list_procs_next:
0539   023C 79            inc d
0540   023D 78            inc c
0541   023E C2 09 00      cmp c, 9
0542   0241 C7 16 02      jne list_procs_L0
0543   0244             list_procs_end:
0544   0244 06            sysret
0545   0245             
0546   0245             ; ------------------------------------------------------------------------------------------------------------------;
0547   0245             ; exceptions code block
0548   0245             ; ------------------------------------------------------------------------------------------------------------------;
0549   0245             ; privilege exception
0550   0245             ; ------------------------------------------------------------------------------------------------------------------;
0551   0245             trap_privilege:
0552   0245 0A C6 01      jmp syscall_reboot
0553   0248 DA            push d
0554   0249 3B 4E 18      mov d, s_priviledge
0555   024C 07 97 12      call _puts
0556   024F E7            pop d
0557   0250 06            sysret
0558   0251             
0559   0251             ; ------------------------------------------------------------------------------------------------------------------;
0560   0251             ; breakpoint
0561   0251             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0562   0251             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0563   0251             ; ------------------------------------------------------------------------------------------------------------------;
0564   0251             syscall_break:
0565   0251 4B            pusha
0566   0252             syscall_break_prompt:
0567   0252 3B 0C 03      mov d, s_break1
0568   0255 07 97 12      call _puts
0569   0258 07 44 12      call printnl
0570   025B 07 99 13      call scan_u16d
0571   025E AF 00 00      cmp a, 0
0572   0261 C6 6C 02      je syscall_break_regs
0573   0264 AF 01 00      cmp a, 1
0574   0267 C6 8F 02      je syscall_break_mem
0575   026A             syscall_break_end:  
0576   026A 4C            popa
0577   026B 06            sysret
0578   026C             syscall_break_regs:
0579   026C 48            mov a, sp
0580   026D 53 0E 00      add a, 14               ; back-track 7 registers
0581   0270 3C            mov d, a
0582   0271 3A 07         mov cl, 7
0583   0273             syscall_regs_L0:
0584   0273 2A            mov b, [d]
0585   0274 FD AB         swp b
0586   0276 07 F3 12      call print_u16x         ; print register value
0587   0279 07 44 12      call printnl
0588   027C 63 02 00      sub d, 2
0589   027F 71 01         sub cl, 1
0590   0281 C3 00         cmp cl, 0
0591   0283 C7 73 02      jne syscall_regs_L0
0592   0286 0A 52 02      jmp syscall_break_prompt
0593   0289 07 44 12      call printnl
0594   028C 0A 52 02      jmp syscall_break_prompt
0595   028F             syscall_break_mem:
0596   028F 07 44 12      call printnl
0597   0292 07 15 13      call scan_u16x
0598   0295 4D            mov si, a               ; data source from user space
0599   0296 FD 4F 1D 25   mov di, scrap_sector    ; destination in kernel space
0600   029A 38 00 02      mov c, 512
0601   029D 04            load                    ; transfer data to kernel space!
0602   029E 3B 1D 25      mov d, scrap_sector     ; dump pointer in d
0603   02A1 38 00 00      mov c, 0
0604   02A4             dump_loop:
0605   02A4 84            mov al, cl
0606   02A5 87 0F         and al, $0F
0607   02A7 C6 F5 02      jz print_base
0608   02AA             back:
0609   02AA 1E            mov al, [d]             ; read byte
0610   02AB 2F            mov bl, al
0611   02AC 07 37 13      call print_u8x
0612   02AF 10 00 20      mov a, $2000
0613   02B2 05 03         syscall sys_io          ; space
0614   02B4 84            mov al, cl
0615   02B5 87 0F         and al, $0F
0616   02B7 B9 0F         cmp al, $0F
0617   02B9 C6 CA 02      je print_ascii
0618   02BC             back1:
0619   02BC 79            inc d
0620   02BD 78            inc c
0621   02BE C2 00 02      cmp c, 512
0622   02C1 C7 A4 02      jne dump_loop
0623   02C4 07 44 12      call printnl
0624   02C7 0A 52 02      jmp syscall_break_prompt  ; go to syscall_break return point
0625   02CA             print_ascii:
0626   02CA 10 00 20      mov a, $2000
0627   02CD 05 03         syscall sys_io
0628   02CF 63 10 00      sub d, 16
0629   02D2 26 10 00      mov b, 16
0630   02D5             print_ascii_L:
0631   02D5 79            inc d
0632   02D6 1E            mov al, [d]               ; read byte
0633   02D7 B9 20         cmp al, $20
0634   02D9 C8 E1 02      jlu dot
0635   02DC B9 7E         cmp al, $7E
0636   02DE D0 E9 02      jleu ascii
0637   02E1             dot:
0638   02E1 10 00 2E      mov a, $2E00
0639   02E4 05 03         syscall sys_io
0640   02E6 0A EE 02      jmp ascii_continue
0641   02E9             ascii:
0642   02E9 23            mov ah, al
0643   02EA 19 00         mov al, 0
0644   02EC 05 03         syscall sys_io
0645   02EE             ascii_continue:
0646   02EE FD A9 D5 02   loopb print_ascii_L
0647   02F2 0A BC 02      jmp back1
0648   02F5             print_base:
0649   02F5 07 44 12      call printnl
0650   02F8 2D            mov b, d
0651   02F9 61 1D 25      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0652   02FC 07 F3 12      call print_u16x          ; display row
0653   02FF 10 00 3A      mov a, $3A00
0654   0302 05 03         syscall sys_io
0655   0304 10 00 20      mov a, $2000
0656   0307 05 03         syscall sys_io
0657   0309 0A AA 02      jmp back
0658   030C             
0659   030C             s_break1:  
0660   030C 0A 44 65 62   .db "\nDebugger entry point.\n"
0660   0310 75 67 67 65 
0660   0314 72 20 65 6E 
0660   0318 74 72 79 20 
0660   031C 70 6F 69 6E 
0660   0320 74 2E 0A 
0661   0323 30 2E 20 53   .db "0. Show Registers\n"
0661   0327 68 6F 77 20 
0661   032B 52 65 67 69 
0661   032F 73 74 65 72 
0661   0333 73 0A 
0662   0335 31 2E 20 53   .db "1. Show 512B RAM block\n"
0662   0339 68 6F 77 20 
0662   033D 35 31 32 42 
0662   0341 20 52 41 4D 
0662   0345 20 62 6C 6F 
0662   0349 63 6B 0A 
0663   034C 32 2E 20 43   .db "2. Continue Execution", 0
0663   0350 6F 6E 74 69 
0663   0354 6E 75 65 20 
0663   0358 45 78 65 63 
0663   035C 75 74 69 6F 
0663   0360 6E 00 
0664   0362             
0665   0362             ; ------------------------------------------------------------------------------------------------------------------;
0666   0362             ; divide by zero exception
0667   0362             ; ------------------------------------------------------------------------------------------------------------------;
0668   0362             trap_div_zero:
0669   0362 D7            push a
0670   0363 DA            push d
0671   0364 E1            pushf
0672   0365 3B 65 18      mov d, s_divzero
0673   0368 07 97 12      call _puts
0674   036B EE            popf
0675   036C E7            pop d
0676   036D E4            pop a
0677   036E 06            sysret ; enable interrupts
0678   036F             
0679   036F             ; ------------------------------------------------------------------------------------------------------------------;
0680   036F             ; undefined opcode exception
0681   036F             ; ------------------------------------------------------------------------------------------------------------------;
0682   036F             trap_undef_opcode:
0683   036F 06            sysret
0684   0370             
0685   0370             ; ------------------------------------------------------------------------------------------------------------------;
0686   0370             ; real-time clock services syscall
0687   0370             ; RTC I/O bank = FFA0 to FFAF
0688   0370             ; FFA0 to FFA7 is scratch RAM
0689   0370             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0690   0370             ; al = 0..6 -> get
0691   0370             ; al = 7..D -> set
0692   0370             ; ------------------------------------------------------------------------------------------------------------------;
0693   0370             syscall_rtc:
0694   0370 DB            push al
0695   0371 DA            push d
0696   0372 B9 06         cmp al, 6
0697   0374 D1 89 03      jgu syscall_rtc_set
0698   0377             syscall_rtc_get:
0699   0377 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0700   0379 22 FF         mov ah, $FF    
0701   037B 3C            mov d, a                ; get to FFA9 + offset
0702   037C F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0703   0380 1E            mov al, [d]             ; get data
0704   0381 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0705   0385 23            mov ah, al
0706   0386 E7            pop d
0707   0387 E8            pop al
0708   0388 06            sysret
0709   0389             syscall_rtc_set:
0710   0389 DD            push bl
0711   038A 99            mov bl, ah              ; set data asIDE
0712   038B 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0713   038D 22 FF         mov ah, $FF    
0714   038F 3C            mov d, a                ; get to FFA9 + offset
0715   0390 1B            mov al, bl              ; get data back
0716   0391 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0717   0395 3E            mov [d], al             ; set data
0718   0396 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0719   039A EA            pop bl
0720   039B E7            pop d
0721   039C E8            pop al
0722   039D 06            sysret
0723   039E             
0724   039E             datetime_serv_tbl:
0725   039E A6 03         .dw print_date
0726   03A0 1A 04         .dw set_date
0727   03A2             syscall_datetime:
0728   03A2 FD 0A 9E 03   jmp [datetime_serv_tbl + al]      
0729   03A6             print_date:
0730   03A6 10 00 0D      mov a, $0D00           ; print carriage return char
0731   03A9 19 03         mov al, 3
0732   03AB 05 01         syscall sys_rtc        ; get week
0733   03AD 1A            mov al, ah
0734   03AE 22 00         mov ah, 0
0735   03B0 FD 9D 02      shl a, 2          
0736   03B3 3B EF 18      mov d, s_week
0737   03B6 59            add d, a
0738   03B7 07 97 12      call _puts
0739   03BA 10 00 20      mov a, $2000
0740   03BD 05 03         syscall sys_io         ; display ' '
0741   03BF 19 04         mov al, 4
0742   03C1 05 01         syscall sys_rtc        ; get day
0743   03C3 99            mov bl, ah
0744   03C4 07 37 13      call print_u8x
0745   03C7 10 00 20      mov a, $2000
0746   03CA 05 03         syscall sys_io         ; display ' '
0747   03CC             ; there is a problem with the month displaying
0748   03CC             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0749   03CC             ; even though it is to be understood as BCD.
0750   03CC             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0751   03CC 19 05         mov al, 05
0752   03CE 05 01         syscall sys_rtc        ; get month
0753   03D0 1A            mov al, ah
0754   03D1 22 00         mov ah, 0
0755   03D3 FD 9D 02      shl a, 2          
0756   03D6 3B BB 18      mov d, s_months
0757   03D9 59            add d, a
0758   03DA 07 97 12      call _puts
0759   03DD 10 00 20      mov a, $2000
0760   03E0 05 03         syscall sys_io         ; display ' '
0761   03E2 2E 20         mov bl, $20
0762   03E4 07 37 13      call print_u8x         ; print 20 for year prefix
0763   03E7 19 06         mov al, 06
0764   03E9 05 01         syscall sys_rtc        ; get year
0765   03EB 99            mov bl, ah
0766   03EC 07 37 13      call print_u8x
0767   03EF 10 00 20      mov a, $2000  
0768   03F2 05 03         syscall sys_io         ; display ' '
0769   03F4 19 02         mov al, 2
0770   03F6 05 01         syscall sys_rtc        ; get hours
0771   03F8 99            mov bl, ah
0772   03F9 07 37 13      call print_u8x
0773   03FC 10 00 3A      mov a, $3A00    
0774   03FF 05 03         syscall sys_io         ; display ':'
0775   0401 19 01         mov al, 01
0776   0403 05 01         syscall sys_rtc        ; get minutes
0777   0405 99            mov bl, ah
0778   0406 07 37 13      call print_u8x
0779   0409 10 00 3A      mov a, $3A00  
0780   040C 05 03         syscall sys_io         ; display ':'
0781   040E 19 00         mov al, 0
0782   0410 05 01         syscall sys_rtc        ; get seconds
0783   0412 99            mov bl, ah
0784   0413 07 37 13      call print_u8x
0785   0416 07 44 12      call printnl
0786   0419 06            sysret
0787   041A             set_date:
0788   041A 3B 80 18      mov d, s_set_year
0789   041D 07 97 12      call _puts
0790   0420 07 82 13      call scan_u8x          ; read integer into A
0791   0423 FD 9D 08      shl a, 8               ; only AL used, move to AH
0792   0426 19 0D         mov al, 0Dh            ; set RTC year
0793   0428 05 01         syscall sys_rtc        ; set RTC
0794   042A 3B 87 18      mov d, s_set_month
0795   042D 07 97 12      call _puts
0796   0430 07 82 13      call scan_u8x          ; read integer into A
0797   0433 FD 9D 08      shl a, 8               ; only AL used, move to AH
0798   0436 19 0C         mov al, 0Ch            ; set RTC month
0799   0438 05 01         syscall sys_rtc        ; set RTC
0800   043A 3B 8F 18      mov d, s_set_day
0801   043D 07 97 12      call _puts
0802   0440 07 82 13      call scan_u8x          ; read integer into A
0803   0443 FD 9D 08      shl a, 8               ; only AL used, move to AH
0804   0446 19 0B         mov al, 0Bh            ; set RTC month
0805   0448 05 01         syscall sys_rtc        ; set RTC
0806   044A 3B 95 18      mov d, s_set_week
0807   044D 07 97 12      call _puts
0808   0450 07 82 13      call scan_u8x          ; read integer into A
0809   0453 FD 9D 08      shl a, 8               ; only AL used, move to AH
0810   0456 19 0A         mov al, 0Ah            ; set RTC month
0811   0458 05 01         syscall sys_rtc        ; set RTC
0812   045A 3B 9F 18      mov d, s_set_hours
0813   045D 07 97 12      call _puts
0814   0460 07 82 13      call scan_u8x          ; read integer into A
0815   0463 FD 9D 08      shl a, 8               ; only AL used, move to AH
0816   0466 19 09         mov al, 09h            ; set RTC month
0817   0468 05 01         syscall sys_rtc        ; set RTC
0818   046A 3B A7 18      mov d, s_set_minutes
0819   046D 07 97 12      call _puts
0820   0470 07 82 13      call scan_u8x          ; read integer into A
0821   0473 FD 9D 08      shl a, 8               ; only AL used, move to AH
0822   0476 19 08         mov al, 08h            ; set RTC month
0823   0478 05 01         syscall sys_rtc        ; set RTC
0824   047A 3B B1 18      mov d, s_set_seconds
0825   047D 07 97 12      call _puts
0826   0480 07 82 13      call scan_u8x          ; read integer into A
0827   0483 FD 9D 08      shl a, 8               ; only AL used, move to AH
0828   0486 19 07         mov al, 07h            ; set RTC month
0829   0488 05 01         syscall sys_rtc        ; set RTC
0830   048A 06            sysret
0831   048B             
0832   048B             ; ------------------------------------------------------------------------------------------------------------------;
0833   048B             ; IDE Services Syscall
0834   048B             ; al = option
0835   048B             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0836   048B             ; IDE read/write sector
0837   048B             ; 512 bytes
0838   048B             ; User buffer pointer in D
0839   048B             ; AH = number of sectors
0840   048B             ; CB = LBA bytes 3..0
0841   048B             ; ------------------------------------------------------------------------------------------------------------------;
0842   048B 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0842   048F 73 63 61 6C 
0842   0493 6C 5F 69 64 
0842   0497 65 20 63 61 
0842   049B 6C 6C 65 64 
0842   049F 3A 20 00 
0843   04A2             ide_serv_tbl:
0844   04A2 C9 04         .dw ide_reset
0845   04A4 DD 04         .dw ide_sleep
0846   04A6 EC 04         .dw ide_read_sect_wrapper
0847   04A8 F0 04         .dw ide_write_sect_wrapper
0848   04AA             syscall_ide:
0849   04AA DD            push bl
0850   04AB 31 C0 17      mov bl, [sys_debug_mode]
0851   04AE               ; debug block
0852   04AE C1 00         cmp bl, 0
0853   04B0 EA            pop bl
0854   04B1 C6 C5 04      je syscall_ide_jmp
0855   04B4 DA            push d
0856   04B5 DD            push bl
0857   04B6 3B 8B 04      mov d, s_syscall_ide_dbg0
0858   04B9 07 97 12      call _puts
0859   04BC 2F            mov bl, al
0860   04BD 07 37 13      call print_u8x
0861   04C0 07 44 12      call printnl
0862   04C3 EA            pop bl
0863   04C4 E7            pop d
0864   04C5             syscall_ide_jmp:
0865   04C5 FD 0A A2 04   jmp [ide_serv_tbl + al]    
0866   04C9               
0867   04C9             ide_reset:      
0868   04C9 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0869   04CD 07 76 05      call ide_wait                   ; wait for IDE ready             
0870   04D0 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0871   04D4 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0872   04D8 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0873   04DC 06            sysret
0874   04DD             ide_sleep:
0875   04DD 07 76 05      call ide_wait                   ; wait for IDE ready             
0876   04E0 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0877   04E4 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0878   04E8 07 76 05      call ide_wait                   ; wait for IDE ready
0879   04EB 06            sysret
0880   04EC             ide_read_sect_wrapper:
0881   04EC 07 F4 04      call ide_read_sect
0882   04EF 06            sysret
0883   04F0             ide_write_sect_wrapper:
0884   04F0 07 1A 05      call ide_write_sect
0885   04F3 06            sysret
0886   04F4             ide_read_sect:
0887   04F4 1A            mov al, ah
0888   04F5 24            mov ah, bl
0889   04F6 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0890   04F9 1C            mov al, bh
0891   04FA 3D D4 FF      mov [_ide_R4], al
0892   04FD 12            mov a, c
0893   04FE 3D D5 FF      mov [_ide_R5], al
0894   0501 1A            mov al, ah
0895   0502 87 0F         and al, %00001111
0896   0504 8B E0         or al, %11100000                ; mode lba, master
0897   0506 3D D6 FF      mov [_ide_R6], al
0898   0509             ide_read_sect_wait:
0899   0509 1D D7 FF      mov al, [_ide_R7]  
0900   050C 87 80         and al, $80                     ; BUSY FLAG
0901   050E C7 09 05      jnz ide_read_sect_wait
0902   0511 19 20         mov al, $20
0903   0513 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0904   0516 07 40 05      call ide_read  
0905   0519 09            ret
0906   051A             ide_write_sect:
0907   051A 1A            mov al, ah
0908   051B 24            mov ah, bl
0909   051C 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0910   051F 1C            mov al, bh
0911   0520 3D D4 FF      mov [_ide_R4], al
0912   0523 12            mov a, c
0913   0524 3D D5 FF      mov [_ide_R5], al
0914   0527 1A            mov al, ah
0915   0528 87 0F         and al, %00001111
0916   052A 8B E0         or al, %11100000                ; mode lba, master
0917   052C 3D D6 FF      mov [_ide_R6], al
0918   052F             ide_write_sect_wait:
0919   052F 1D D7 FF      mov al, [_ide_R7]  
0920   0532 87 80         and al, $80                     ; BUSY FLAG
0921   0534 C7 2F 05      jnz ide_write_sect_wait
0922   0537 19 30         mov al, $30
0923   0539 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0924   053C 07 5B 05      call ide_write      
0925   053F 09            ret
0926   0540             
0927   0540             ;----------------------------------------------------------------------------------------------------;
0928   0540             ; READ IDE DATA
0929   0540             ; pointer in D
0930   0540             ;----------------------------------------------------------------------------------------------------;
0931   0540             ide_read:
0932   0540 DA            push d
0933   0541             ide_read_loop:
0934   0541 1D D7 FF      mov al, [_ide_R7]  
0935   0544 87 80         and al, 80h                     ; BUSY FLAG
0936   0546 C7 41 05      jnz ide_read_loop               ; wait loop
0937   0549 1D D7 FF      mov al, [_ide_R7]
0938   054C 87 08         and al, %00001000               ; DRQ FLAG
0939   054E C6 59 05      jz ide_read_end
0940   0551 1D D0 FF      mov al, [_ide_R0]
0941   0554 3E            mov [d], al
0942   0555 79            inc d
0943   0556 0A 41 05      jmp ide_read_loop
0944   0559             ide_read_end:
0945   0559 E7            pop d
0946   055A 09            ret
0947   055B             
0948   055B             ;----------------------------------------------------------------------------------------------------;
0949   055B             ; WRITE IDE DATA
0950   055B             ; data pointer in D
0951   055B             ;----------------------------------------------------------------------------------------------------;
0952   055B             ide_write:
0953   055B DA            push d
0954   055C             ide_write_loop:
0955   055C 1D D7 FF      mov al, [_ide_R7]  
0956   055F 87 80         and al, 80h             ; BUSY FLAG
0957   0561 C7 5C 05      jnz ide_write_loop      ; wait loop
0958   0564 1D D7 FF      mov al, [_ide_R7]
0959   0567 87 08         and al, %00001000       ; DRQ FLAG
0960   0569 C6 74 05      jz ide_write_end
0961   056C 1E            mov al, [d]
0962   056D 3D D0 FF      mov [_ide_R0], al
0963   0570 79            inc d 
0964   0571 0A 5C 05      jmp ide_write_loop
0965   0574             ide_write_end:
0966   0574 E7            pop d
0967   0575 09            ret
0968   0576             
0969   0576             ;----------------------------------------------------------------------------------------------------;
0970   0576             ; wait for IDE to be ready
0971   0576             ;----------------------------------------------------------------------------------------------------;
0972   0576             ide_wait:
0973   0576 1D D7 FF      mov al, [_ide_R7]  
0974   0579 87 80         and al, 80h        ; BUSY FLAG
0975   057B C7 76 05      jnz ide_wait
0976   057E 09            ret
0977   057F             
0978   057F             ;----------------------------------------------------------------------------------------------------;
0979   057F             ; IO Syscall
0980   057F             ;----------------------------------------------------------------------------------------------------;
0981   057F             ; Baud  Divisor
0982   057F             ; 50    2304
0983   057F             ; 110   1047
0984   057F             ; 300    384
0985   057F             ; 600    192
0986   057F             ; 1200    96
0987   057F             ; 9600    12
0988   057F             ; 19200    6
0989   057F             ; 38400    3
0990   057F             syscall_io_jmp:
0991   057F B2 05         .dw syscall_io_putchar
0992   0581 BF 05         .dw syscall_io_getch
0993   0583 89 05         .dw syscall_io_uart_setup
0994   0585             syscall_io:
0995   0585 FD 0A 7F 05   jmp [syscall_io_jmp + al]
0996   0589             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0997   0589             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0998   0589             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0999   0589             syscall_io_uart_setup:
1000   0589 1D C2 17      mov al, [sys_uart0_lcr]
1001   058C 8B 80         or al, $80                ; set DLAB access bit
1002   058E 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
1003   0591 1D C5 17      mov al, [sys_uart0_div0]
1004   0594 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
1005   0597 1D C6 17      mov al, [sys_uart0_div1]
1006   059A 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
1007   059D             
1008   059D 1D C2 17      mov al, [sys_uart0_lcr]
1009   05A0 87 7F         and al, $7F               ; clear DLAB access bit 
1010   05A2 3D 83 FF      mov [_UART0_LCR], al
1011   05A5 1D C3 17      mov al, [sys_uart0_inten]
1012   05A8 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1013   05AB 1D C4 17      mov al, [sys_uart0_fifoen]
1014   05AE 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1015   05B1 06            sysret
1016   05B2             
1017   05B2             ; char in ah
1018   05B2             syscall_io_putchar:
1019   05B2             syscall_io_putchar_L0:
1020   05B2 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1021   05B5 87 20         and al, $20
1022   05B7 C6 B2 05      jz syscall_io_putchar_L0    
1023   05BA 1A            mov al, ah
1024   05BB 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1025   05BE 06            sysret
1026   05BF             
1027   05BF             ; char in ah
1028   05BF             ; al = sucess code
1029   05BF             syscall_io_getch:
1030   05BF D8            push b
1031   05C0 DA            push d
1032   05C1 FD 0C         sti
1033   05C3             syscall_io_getch_L0:  
1034   05C3 14 CF 17      mov a, [fifo_out]
1035   05C6 29 CD 17      mov b, [fifo_in]
1036   05C9 B0            cmp a, b
1037   05CA C6 C3 05      je syscall_io_getch_L0
1038   05CD 3C            mov d, a
1039   05CE 77            inc a
1040   05CF AF 1D 25      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1041   05D2 C7 D8 05      jne syscall_io_getch_cont
1042   05D5 10 1D 21      mov a, fifo  
1043   05D8             syscall_io_getch_cont:  
1044   05D8 42 CF 17      mov [fifo_out], a             ; update fifo pointer
1045   05DB 1E            mov al, [d]                   ; get char
1046   05DC 23            mov ah, al
1047   05DD 1D C1 17      mov al, [sys_echo_on]
1048   05E0 B9 01         cmp al, 1
1049   05E2 C7 F1 05      jne syscall_io_getch_noecho 
1050   05E5             ; here we just echo the char back to the console
1051   05E5             syscall_io_getch_echo_L0:
1052   05E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1053   05E8 87 20         and al, $20                 ; isolate Transmitter Empty
1054   05EA C6 E5 05      jz syscall_io_getch_echo_L0
1055   05ED 1A            mov al, ah
1056   05EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1057   05F1             syscall_io_getch_noecho:
1058   05F1 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1059   05F3 E7            pop d
1060   05F4 E5            pop b
1061   05F5 06            sysret
1062   05F6             
1063   05F6             ;------------------------------------------------------------------------------------------------------;
1064   05F6             ; FILE SYSTEM DATA
1065   05F6             ;------------------------------------------------------------------------------------------------------;
1066   05F6             ; infor for : IDE SERVICES INTERRUPT
1067   05F6             ; IDE read/write 512-byte sector
1068   05F6             ; al = option
1069   05F6             ; user buffer pointer in D
1070   05F6             ; AH = number of sectors
1071   05F6             ; CB = LBA bytes 3..0  
1072   05F6             ;------------------------------------------------------------------------------------------------------;
1073   05F6             ; FILE SYSTEM DATA STRUCTURE
1074   05F6             ;------------------------------------------------------------------------------------------------------;
1075   05F6             ; for a directory we have the header first, followed by metadata
1076   05F6             ; header 1 sector (512 bytes)
1077   05F6             ; metadata 1 sector (512 bytes)
1078   05F6             ; HEADER ENTRIES:
1079   05F6             ; filename (64)
1080   05F6             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1081   05F6             ;
1082   05F6             ; metadata entries:
1083   05F6             ; filename (24)
1084   05F6             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1085   05F6             ; LBA (2)
1086   05F6             ; size (2)
1087   05F6             ; day (1)
1088   05F6             ; month (1)
1089   05F6             ; year (1)
1090   05F6             ; packet size = 32 bytes
1091   05F6             ;
1092   05F6             ; first directory on disk is the root directory '/'
1093   05F6             file_system_jmptbl:
1094   05F6 61 06         .dw fs_mkfs                   ; 0
1095   05F8 00 00         .dw 0                         ; 1
1096   05FA C3 06         .dw fs_mkdir                  ; 2
1097   05FC 3C 0A         .dw fs_cd                     ; 3
1098   05FE 43 0A         .dw fs_ls                     ; 4
1099   0600 B9 0B         .dw fs_mktxt                  ; 5
1100   0602 84 0C         .dw fs_mkbin                  ; 6
1101   0604 4B 0D         .dw fs_pwd                    ; 7
1102   0606 68 0D         .dw fs_cat                    ; 8
1103   0608 C4 0D         .dw fs_rmdir                  ; 9
1104   060A 20 0E         .dw fs_rm                     ; 10
1105   060C 14 0B         .dw fs_starcom                ; 11
1106   060E 00 00         .dw 0                         ; 12
1107   0610 00 00         .dw 0                         ; 13
1108   0612 69 06         .dw fs_chmod                  ; 14
1109   0614 88 0E         .dw fs_mv                     ; 15
1110   0616 62 06         .dw fs_cd_root                ; 16
1111   0618 38 0A         .dw fs_get_curr_dirID         ; 17
1112   061A 14 08         .dw fs_dir_id_to_path         ; 18
1113   061C 7A 08         .dw fs_path_to_dir_id_user    ; 19
1114   061E 94 09         .dw fs_load_from_path_user    ; 20  
1115   0620 04 09         .dw fs_filepath_exists_user   ; 21
1116   0622             
1117   0622 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1117   0626 79 73 63 61 
1117   062A 6C 6C 5F 66 
1117   062E 69 6C 65 5F 
1117   0632 73 79 73 74 
1117   0636 65 6D 20 63 
1117   063A 61 6C 6C 65 
1117   063E 64 3A 20 00 
1118   0642             syscall_file_system:
1119   0642 DD            push bl
1120   0643 31 C0 17      mov bl, [sys_debug_mode]
1121   0646               ; debug block
1122   0646 C1 00         cmp bl, 0
1123   0648 EA            pop bl
1124   0649 C6 5D 06      je syscall_filesystem_jmp
1125   064C DA            push d
1126   064D DD            push bl
1127   064E 3B 22 06      mov d, s_syscall_fs_dbg0
1128   0651 07 97 12      call _puts
1129   0654 2F            mov bl, al
1130   0655 07 37 13      call print_u8x
1131   0658 07 44 12      call printnl
1132   065B EA            pop bl
1133   065C E7            pop d
1134   065D             syscall_filesystem_jmp:
1135   065D FD 0A F6 05   jmp [file_system_jmptbl + al]
1136   0661             
1137   0661             fs_mkfs:  
1138   0661 06            sysret  
1139   0662               
1140   0662             fs_cd_root:
1141   0662 10 20 00      mov a, root_id
1142   0665 42 D1 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1143   0668 06            sysret  
1144   0669             
1145   0669             ; filename in D (userspace data)
1146   0669             ; permission in BL
1147   0669             fs_chmod:
1148   0669 DD            push bl
1149   066A FD 4E         mov si, d
1150   066C FD 4F 1D 1F   mov di, user_data
1151   0670 38 80 00      mov c, 128
1152   0673 04            load                        ; load filename from user-space
1153   0674 14 D1 17      mov a, [current_dir_id]
1154   0677 77            inc a                       ; metadata sector
1155   0678 27            mov b, a
1156   0679 38 00 00      mov c, 0                    ; upper LBA = 0
1157   067C 22 01         mov ah, $01                  ; 1 sector
1158   067E 3B 1D 27      mov d, transient_area
1159   0681 07 F4 04      call ide_read_sect          ; read directory
1160   0684 FD 10         cla
1161   0686 42 C9 17      mov [index], a              ; reset file counter
1162   0689             fs_chmod_L1:
1163   0689 FD 4E         mov si, d
1164   068B FD 4F 1D 1F   mov di, user_data
1165   068F 07 DA 10      call _strcmp
1166   0692 C6 A9 06      je fs_chmod_found_entry
1167   0695 58 20 00      add d, 32
1168   0698 14 C9 17      mov a, [index]
1169   069B 77            inc a
1170   069C 42 C9 17      mov [index], a
1171   069F AF 10 00      cmp a, FST_FILES_PER_DIR
1172   06A2 C7 89 06      jne fs_chmod_L1
1173   06A5 EA            pop bl
1174   06A6 0A C2 06      jmp fs_chmod_not_found
1175   06A9             fs_chmod_found_entry:  
1176   06A9 FD 79         mov g, b                    ; save LBA
1177   06AB EA            pop bl                      ; retrieve saved permission value
1178   06AC 1F 18 00      mov al, [d + 24]            ; read file permissions
1179   06AF 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1180   06B1 8C            or al, bl                   ; set new permissions
1181   06B2 3F 18 00      mov [d + 24], al            ; write new permissions
1182   06B5 38 00 00      mov c, 0
1183   06B8 3B 1D 27      mov d, transient_area
1184   06BB 22 01         mov ah, $01                 ; disk write 1 sect
1185   06BD FD 27         mov b, g                    ; retrieve LBA
1186   06BF 07 1A 05      call ide_write_sect         ; write sector
1187   06C2             fs_chmod_not_found:
1188   06C2 06            sysret
1189   06C3             
1190   06C3             ;------------------------------------------------------------------------------------------------------;
1191   06C3             ; CREATE NEW DIRECTORY
1192   06C3             ;------------------------------------------------------------------------------------------------------;
1193   06C3             ; search list for NULL name entry. add new directory to list
1194   06C3             fs_mkdir:
1195   06C3 FD 4E         mov si, d
1196   06C5 FD 4F 1D 1F   mov di, user_data
1197   06C9 38 00 02      mov c, 512
1198   06CC 04            load                        ; load data from user-space
1199   06CD 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1200   06D0                                           ; when checking for NULL name, since root has a NULL name)
1201   06D0 38 00 00      mov c, 0                    ; upper LBA = 0
1202   06D3             fs_mkdir_L1:  
1203   06D3 22 01         mov ah, $01                  ; 1 sector
1204   06D5 3B 1D 27      mov d, transient_area
1205   06D8 07 F4 04      call ide_read_sect          ; read sector
1206   06DB BD 00         cmp byte[d], 0              ; check for NULL
1207   06DD C6 E6 06      je fs_mkdir_found_null
1208   06E0 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1209   06E3 0A D3 06      jmp fs_mkdir_L1
1210   06E6             fs_mkdir_found_null:
1211   06E6             ;create header file by grabbing dir name from parameter
1212   06E6 D8            push b                      ; save new directory's LBA
1213   06E7 38 40 00      mov c, 64
1214   06EA FD 4D 1D 1F   mov si, user_data
1215   06EE FD 4F 1D 27   mov di, transient_area
1216   06F2 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1217   06F4 14 D1 17      mov a, [current_dir_id]
1218   06F7 42 5D 27      mov [transient_area + 64], a    ; store parent directory LBA
1219   06FA 19 00         mov al, 0
1220   06FC FD 4F 1D 29   mov di, transient_area + 512
1221   0700 38 00 02      mov c, 512
1222   0703 FD F7         rep stosb                       ; clean buffer
1223   0705 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1224   0708             ; write directory entry sectors
1225   0708 3B 1D 27      mov d, transient_area
1226   070B 22 02         mov ah, $02                     ; disk write, 2 sectors
1227   070D 07 1A 05      call ide_write_sect             ; write sector
1228   0710             ; now we need to add the new directory to the list, insIDE the current directory
1229   0710 14 D1 17      mov a, [current_dir_id]
1230   0713 53 01 00      add a, 1
1231   0716 27            mov b, a                        ; metadata sector
1232   0717 38 00 00      mov c, 0
1233   071A FD 79         mov g, b                        ; save LBA
1234   071C 3B 1D 27      mov d, transient_area
1235   071F 22 01         mov ah, $01                  ; 1 sector
1236   0721 07 F4 04      call ide_read_sect              ; read metadata sector
1237   0724             fs_mkdir_L2:
1238   0724 BD 00         cmp byte[d], 0
1239   0726 C6 2F 07      je fs_mkdir_found_null2
1240   0729 58 20 00      add d, FST_ENTRY_SIZE
1241   072C 0A 24 07      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1242   072F             fs_mkdir_found_null2:
1243   072F FD 4D 1D 1F   mov si, user_data
1244   0733 FD 50         mov di, d
1245   0735 07 EF 10      call _strcpy                    ; copy directory name
1246   0738 58 18 00      add d, 24                       ; goto ATTRIBUTES
1247   073B 19 0B         mov al, %00001011               ; directory, no execute, write, read
1248   073D 3E            mov [d], al      
1249   073E 79            inc d
1250   073F E5            pop b
1251   0740 D8            push b                          ; push LBA back
1252   0741 FD 43         mov [d], b                      ; save LBA
1253   0743             ; set file creation date  
1254   0743 58 04 00      add d, 4
1255   0746 19 04         mov al, 4
1256   0748 05 01         syscall sys_rtc
1257   074A 1A            mov al, ah
1258   074B 3E            mov [d], al                     ; set day
1259   074C 79            inc d
1260   074D 19 05         mov al, 5
1261   074F 05 01         syscall sys_rtc
1262   0751 1A            mov al, ah
1263   0752 3E            mov [d], al                     ; set month
1264   0753 79            inc d
1265   0754 19 06         mov al, 6
1266   0756 05 01         syscall sys_rtc
1267   0758 1A            mov al, ah
1268   0759 3E            mov [d], al                     ; set year
1269   075A             ; write sector into disk for new directory entry
1270   075A FD 27         mov b, g
1271   075C 38 00 00      mov c, 0
1272   075F 3B 1D 27      mov d, transient_area
1273   0762 22 01         mov ah, $01                     ; disk write, 1 sector
1274   0764 07 1A 05      call ide_write_sect             ; write sector
1275   0767             
1276   0767             ; after adding the new directory's information to its parent directory's list
1277   0767             ; we need to now enter the new directory, and to it add two new directories!
1278   0767             ; which directories do we need to add ? '..' and '.' are the directories needed.
1279   0767             ; importantly, note that these two new directories are only entries in the list
1280   0767             ; and do not have actual physical entries in the disk as real directories.
1281   0767             ; i.e. they only exist as list entries in the new directory created so that
1282   0767             ; the new directory can reference its parent and itself.
1283   0767             ; We need to add both '..' and '.'
1284   0767             ; this first section is for '..' and on the section below we do the same for '.'
1285   0767 E4            pop a                         ; retrieve the new directory's LBA  
1286   0768 D7            push a                        ; and save again
1287   0769 53 01 00      add a, 1
1288   076C 27            mov b, a                      ; metadata sector
1289   076D 38 00 00      mov c, 0
1290   0770 FD 79         mov g, b                      ; save LBA
1291   0772 3B 1D 27      mov d, transient_area
1292   0775 22 01         mov ah, $01                  ; 1 sector
1293   0777 07 F4 04      call ide_read_sect            ; read metadata sector
1294   077A             fs_mkdir_L3:
1295   077A BD 00         cmp byte[d], 0
1296   077C C6 85 07      je fs_mkdir_found_null3
1297   077F 58 20 00      add d, FST_ENTRY_SIZE
1298   0782 0A 7A 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1299   0785             fs_mkdir_found_null3:
1300   0785 FD 4D F0 17   mov si, s_parent_dir
1301   0789 FD 50         mov di, d
1302   078B 07 EF 10      call _strcpy                  ; copy directory name
1303   078E 58 18 00      add d, 24                     ; goto ATTRIBUTES
1304   0791 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1305   0793 3E            mov [d], al      
1306   0794 79            inc d
1307   0795 29 D1 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1308   0798 FD 43         mov [d], b                    ; save LBA
1309   079A             ; set file creation date  
1310   079A 58 04 00      add d, 4
1311   079D 19 04         mov al, 4
1312   079F 05 01         syscall sys_rtc
1313   07A1 1A            mov al, ah
1314   07A2 3E            mov [d], al                   ; set day
1315   07A3 79            inc d
1316   07A4 19 05         mov al, 5
1317   07A6 05 01         syscall sys_rtc
1318   07A8 1A            mov al, ah
1319   07A9 3E            mov [d], al                   ; set month
1320   07AA 79            inc d
1321   07AB 19 06         mov al, 6
1322   07AD 05 01         syscall sys_rtc
1323   07AF 1A            mov al, ah
1324   07B0 3E            mov [d], al                   ; set year
1325   07B1             ; write sector into disk for new directory entry
1326   07B1 FD 27         mov b, g
1327   07B3 38 00 00      mov c, 0
1328   07B6 3B 1D 27      mov d, transient_area
1329   07B9 22 01         mov ah, $01                   ; disk write, 1 sector
1330   07BB 07 1A 05      call ide_write_sect           ; write sector
1331   07BE             ;;;;;;;;;;;;;
1332   07BE             ; like we did above for '..', we need to now add the '.' directory to the list.
1333   07BE             ;------------------------------------------------------------------------------------------------------;
1334   07BE E4            pop a                         ; retrieve the new directory's LBA  
1335   07BF D7            push a
1336   07C0 53 01 00      add a, 1
1337   07C3 27            mov b, a                      ; metadata sector
1338   07C4 38 00 00      mov c, 0
1339   07C7 FD 79         mov g, b                      ; save LBA
1340   07C9 3B 1D 27      mov d, transient_area
1341   07CC 22 01         mov ah, $01                  ; 1 sector
1342   07CE 07 F4 04      call ide_read_sect            ; read metadata sector
1343   07D1             fs_mkdir_L4:
1344   07D1 BD 00         cmp byte[d], 0
1345   07D3 C6 DC 07      je fs_mkdir_found_null4
1346   07D6 58 20 00      add d, FST_ENTRY_SIZE
1347   07D9 0A D1 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1348   07DC             fs_mkdir_found_null4:
1349   07DC FD 4D F3 17   mov si, s_current_dir
1350   07E0 FD 50         mov di, d
1351   07E2 07 EF 10      call _strcpy                  ; copy directory name
1352   07E5 58 18 00      add d, 24                     ; goto ATTRIBUTES
1353   07E8 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1354   07EA 3E            mov [d], al      
1355   07EB 79            inc d
1356   07EC E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1357   07ED FD 43         mov [d], b                    ; save LBA
1358   07EF             ; set file creation date  
1359   07EF 58 04 00      add d, 4
1360   07F2 19 04         mov al, 4
1361   07F4 05 01         syscall sys_rtc
1362   07F6 1A            mov al, ah
1363   07F7 3E            mov [d], al                   ; set day
1364   07F8 79            inc d
1365   07F9 19 05         mov al, 5
1366   07FB 05 01         syscall sys_rtc
1367   07FD 1A            mov al, ah
1368   07FE 3E            mov [d], al                   ; set month
1369   07FF 79            inc d
1370   0800 19 06         mov al, 6
1371   0802 05 01         syscall sys_rtc
1372   0804 1A            mov al, ah
1373   0805 3E            mov [d], al                   ; set year
1374   0806             ; write sector into disk for new directory entry
1375   0806 FD 27         mov b, g
1376   0808 38 00 00      mov c, 0
1377   080B 3B 1D 27      mov d, transient_area
1378   080E 22 01         mov ah, $01                   ; disk write, 1 sector
1379   0810 07 1A 05      call ide_write_sect           ; write sector
1380   0813             fs_mkdir_end:
1381   0813 06            sysret
1382   0814             
1383   0814             ;------------------------------------------------------------------------------------------------------;
1384   0814             ; get path from a given directory dirID
1385   0814             ; pseudo code:
1386   0814             ;  fs_dir_id_to_path(int dirID, char *D){
1387   0814             ;    if(dirID == 0){
1388   0814             ;      reverse path in D;
1389   0814             ;      return;
1390   0814             ;    }
1391   0814             ;    else{
1392   0814             ;      copy directory name to end of D;
1393   0814             ;      add '/' to end of D;
1394   0814             ;      parentID = get parent directory ID;
1395   0814             ;      fs_dir_id_to_path(parentID, D);
1396   0814             ;    }
1397   0814             ;  }
1398   0814             ; A = dirID
1399   0814             ; D = generated path string pointer
1400   0814             ;------------------------------------------------------------------------------------------------------;
1401   0814             ; sample path: /usr/bin
1402   0814             fs_dir_id_to_path:
1403   0814 3B 9D 1E      mov d, filename
1404   0817 19 00         mov al, 0
1405   0819 3E            mov [d], al                     ; initialize path string 
1406   081A 14 D1 17      mov a, [current_dir_id]
1407   081D 07 2A 08      call fs_dir_id_to_path_E0
1408   0820 3B 9D 1E      mov d, filename
1409   0823 07 83 10      call _strrev
1410   0826 07 97 12      call _puts
1411   0829 06            sysret
1412   082A             fs_dir_id_to_path_E0:
1413   082A 07 49 08      call get_dirname_from_dirID
1414   082D FD 4D F5 17   mov si, s_fslash
1415   0831 FD 50         mov di, d
1416   0833 07 FD 10      call _strcat                    ; add '/' to end of path
1417   0836 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1418   0839 C6 48 08      je fs_dir_id_to_path_root
1419   083C 07 66 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1420   083F AF 20 00      cmp a, root_id               ; check if we are at the root directory
1421   0842 C6 48 08      je fs_dir_id_to_path_root
1422   0845 07 2A 08      call fs_dir_id_to_path_E0     ; recursively call itself
1423   0848             fs_dir_id_to_path_root:
1424   0848 09            ret
1425   0849             
1426   0849             ;------------------------------------------------------------------------------------------------------;
1427   0849             ; in_puts:
1428   0849             ; A = directory ID
1429   0849             ; out_puts:
1430   0849             ; D = pointer to directory name string
1431   0849             ;------------------------------------------------------------------------------------------------------;
1432   0849             get_dirname_from_dirID:
1433   0849 D7            push a
1434   084A D8            push b
1435   084B DA            push d
1436   084C 27            mov b, a
1437   084D 38 00 00      mov c, 0                      ; upper LBA = 0
1438   0850 22 01         mov ah, $01                  ; 1 sector
1439   0852 3B 1D 25      mov d, transient_area - 512
1440   0855 07 F4 04      call ide_read_sect            ; read directory
1441   0858 07 83 10      call _strrev                  ; reverse dir name before copying
1442   085B FD 4E         mov si, d
1443   085D E7            pop d                         ; destination address = D value pushed at beginning
1444   085E FD 50         mov di, d
1445   0860 07 FD 10      call _strcat                  ; copy filename to D
1446   0863 E5            pop b
1447   0864 E4            pop a
1448   0865 09            ret
1449   0866             
1450   0866             ;------------------------------------------------------------------------------------------------------;
1451   0866             ; in_puts:
1452   0866             ; A = directory ID
1453   0866             ; out_puts:
1454   0866             ; A = parent directory ID
1455   0866             ;------------------------------------------------------------------------------------------------------;
1456   0866             get_parentID_from_dirID:
1457   0866 D8            push b
1458   0867 DA            push d
1459   0868 27            mov b, a
1460   0869 38 00 00      mov c, 0                      ; upper LBA = 0
1461   086C 22 01         mov ah, $01                  ; 1 sector
1462   086E 3B 1D 25      mov d, transient_area - 512
1463   0871 07 F4 04      call ide_read_sect            ; read directory
1464   0874 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1465   0877 E7            pop d
1466   0878 E5            pop b
1467   0879 09            ret
1468   087A             
1469   087A             ;------------------------------------------------------------------------------------------------------;
1470   087A             ; get dirID from a given path string
1471   087A             ; in_puts:
1472   087A             ; D = path pointer 
1473   087A             ; out_puts:
1474   087A             ; A = dirID
1475   087A             ; if dir non existent, A = FFFF (fail code)
1476   087A             ; /usr/local/bin    - absolute
1477   087A             ; local/bin/games    - relative
1478   087A             ;------------------------------------------------------------------------------------------------------;
1479   087A             fs_path_to_dir_id_user:
1480   087A FD 4E         mov si, d
1481   087C FD 4F 1D 1F   mov di, user_data
1482   0880 38 00 02      mov c, 512
1483   0883 04            load
1484   0884 07 88 08      call get_dirID_from_path
1485   0887 06            sysret
1486   0888             get_dirID_from_path:
1487   0888 26 1D 1F      mov b, user_data
1488   088B FD 42 BC 16   mov [prog], b                  ; token pointer set to path string
1489   088F 07 1D 15      call get_token
1490   0892 31 BF 16      mov bl, [tok]
1491   0895 C1 01         cmp bl, TOK_FSLASH
1492   0897 C6 A3 08      je get_dirID_from_path_abs 
1493   089A 14 D1 17      mov a, [current_dir_id]
1494   089D 07 A3 16      call _putback
1495   08A0 0A A6 08      jmp get_dirID_from_path_E0
1496   08A3             get_dirID_from_path_abs:
1497   08A3 10 20 00      mov a, root_id
1498   08A6             get_dirID_from_path_E0:
1499   08A6 07 1D 15      call get_token
1500   08A9 31 BE 16      mov bl, [toktyp]
1501   08AC C1 00         cmp bl, TOKTYP_IDENTIFIER
1502   08AE C7 FF 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1503   08B1             
1504   08B1 FD 4D C0 16   mov si, tokstr
1505   08B5 FD 4F 9D 1E   mov di, filename
1506   08B9 07 EF 10      call _strcpy        
1507   08BC 77            inc a                         ; metadata sector
1508   08BD 27            mov b, a
1509   08BE 38 00 00      mov c, 0                      ; upper LBA = 0
1510   08C1 22 01         mov ah, $01                  ; 1 sector
1511   08C3 3B 1D 27      mov d, transient_area
1512   08C6 07 F4 04      call ide_read_sect            ; read directory
1513   08C9 FD 10         cla
1514   08CB 42 C9 17      mov [index], a
1515   08CE             get_dirID_from_path_L1:
1516   08CE FD 4E         mov si, d
1517   08D0 FD 4F 9D 1E   mov di, filename
1518   08D4 07 DA 10      call _strcmp
1519   08D7 C6 ED 08      je get_dirID_from_path_name_equal  
1520   08DA 58 20 00      add d, 32
1521   08DD 14 C9 17      mov a, [index]
1522   08E0 77            inc a
1523   08E1 42 C9 17      mov [index], a
1524   08E4 AF 10 00      cmp a, FST_FILES_PER_DIR
1525   08E7 C6 00 09      je get_dirID_from_path_fail
1526   08EA 0A CE 08      jmp get_dirID_from_path_L1
1527   08ED             get_dirID_from_path_name_equal:
1528   08ED 58 19 00      add d, 25           
1529   08F0 15            mov a, [d]                    ; set result register A = dirID
1530   08F1 07 1D 15      call get_token
1531   08F4 31 BF 16      mov bl, [tok]
1532   08F7 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1533   08F9 C6 A6 08      je get_dirID_from_path_E0
1534   08FC 07 A3 16      call _putback
1535   08FF             get_dirID_from_path_end:
1536   08FF 09            ret
1537   0900             get_dirID_from_path_fail:
1538   0900 10 FF FF      mov A, $FFFF
1539   0903 09            ret
1540   0904             
1541   0904             
1542   0904             ;------------------------------------------------------------------------------------------------------;
1543   0904             ; check if file exists by a given path string
1544   0904             ; in_puts:
1545   0904             ; D = path pointer 
1546   0904             ; OUTPUTS:
1547   0904             ; A = success code, if file exists gives LBA, else, give 0
1548   0904             ; /usr/local/bin/ed
1549   0904             ;------------------------------------------------------------------------------------------------------;
1550   0904             fs_filepath_exists_user:
1551   0904 FD 4E         mov si, d
1552   0906 FD 4F 1D 1F   mov di, user_data
1553   090A 38 00 02      mov c, 512
1554   090D 04            load
1555   090E 07 12 09      call file_exists_by_path
1556   0911 06            sysret
1557   0912             file_exists_by_path:
1558   0912 26 1D 1F      mov b, user_data
1559   0915 FD 42 BC 16   mov [prog], b                   ; token pointer set to path string
1560   0919 07 1D 15      call get_token
1561   091C 31 BF 16      mov bl, [tok]
1562   091F C1 01         cmp bl, TOK_FSLASH
1563   0921 C6 2D 09      je  file_exists_by_path_abs
1564   0924 14 D1 17      mov a, [current_dir_id]
1565   0927 07 A3 16      call _putback
1566   092A 0A 30 09      jmp file_exists_by_path_E0
1567   092D             file_exists_by_path_abs:
1568   092D 10 20 00      mov a, root_id
1569   0930             file_exists_by_path_E0:
1570   0930 07 1D 15      call get_token
1571   0933 31 BE 16      mov bl, [toktyp]
1572   0936 C1 00         cmp bl, TOKTYP_IDENTIFIER
1573   0938 C7 90 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1574   093B FD 4D C0 16   mov si, tokstr
1575   093F FD 4F 9D 1E   mov di, filename
1576   0943 07 EF 10      call _strcpy        
1577   0946 77            inc a                           ; metadata sector
1578   0947 27            mov b, a
1579   0948 38 00 00      mov c, 0                        ; upper LBA = 0
1580   094B 22 01         mov ah, $01                  ; 1 sector
1581   094D 3B 1D 27      mov d, transient_area
1582   0950 07 F4 04      call ide_read_sect              ; read directory
1583   0953 FD 10         cla
1584   0955 42 C9 17      mov [index], a
1585   0958             file_exists_by_path_L1:
1586   0958 FD 4E         mov si, d
1587   095A FD 4F 9D 1E   mov di, filename
1588   095E 07 DA 10      call _strcmp
1589   0961 C6 77 09      je   file_exists_by_path_name_equal
1590   0964 58 20 00      add d, 32
1591   0967 14 C9 17      mov a, [index]
1592   096A 77            inc a
1593   096B 42 C9 17      mov [index], a
1594   096E AF 10 00      cmp a, FST_FILES_PER_DIR
1595   0971 C6 90 09      je file_exists_by_path_end
1596   0974 0A 58 09      jmp file_exists_by_path_L1
1597   0977             file_exists_by_path_name_equal:
1598   0977 33 18 00      mov bl, [d + 24]
1599   097A FD 87 38      and bl, %00111000               ; directory flag
1600   097D C1 08         cmp bl, %00001000               ; is dir?
1601   097F C6 86 09      je file_exists_by_path_isdir;
1602   0982             ; entry is a file
1603   0982 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1604   0985 09            ret
1605   0986             file_exists_by_path_isdir:
1606   0986 58 19 00      add d, 25           
1607   0989 15            mov a, [d]                      ; set result register A = dirID
1608   098A 07 1D 15      call get_token
1609   098D 0A 30 09      jmp file_exists_by_path_E0
1610   0990             file_exists_by_path_end:
1611   0990 10 00 00      mov a, 0                        ; return 0 because file was not found
1612   0993 09            ret
1613   0994             
1614   0994             ;------------------------------------------------------------------------------------------------------;
1615   0994             ; load file data from a given path string
1616   0994             ; inputs:
1617   0994             ; D = path pointer 
1618   0994             ; DI = userspace program data destination
1619   0994             ; /usr/local/bin/ed
1620   0994             ; ./ed
1621   0994             ;------------------------------------------------------------------------------------------------------;
1622   0994             fs_load_from_path_user:
1623   0994 E3            push di
1624   0995 FD 4E         mov si, d
1625   0997 FD 4F 1D 1F   mov di, user_data
1626   099B 38 00 02      mov c, 512
1627   099E 04            load
1628   099F 07 AC 09      call loadfile_from_path
1629   09A2 F0            pop di
1630   09A3 FD 4D 1D 27   mov si, transient_area
1631   09A7 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1632   09AA 03            store
1633   09AB 06            sysret
1634   09AC             loadfile_from_path:
1635   09AC 26 1D 1F      mov b, user_data
1636   09AF FD 42 BC 16   mov [prog], b                 ; token pointer set to path string
1637   09B3 07 1D 15      call get_token
1638   09B6 31 BF 16      mov bl, [tok]
1639   09B9 C1 01         cmp bl, TOK_FSLASH
1640   09BB C6 C7 09      je loadfile_from_path_abs 
1641   09BE 14 D1 17      mov a, [current_dir_id]
1642   09C1 07 A3 16      call _putback
1643   09C4 0A CA 09      jmp loadfile_from_path_E0
1644   09C7             loadfile_from_path_abs:
1645   09C7 10 20 00      mov a, root_id
1646   09CA             loadfile_from_path_E0:
1647   09CA 07 1D 15      call get_token
1648   09CD 31 BE 16      mov bl, [toktyp]
1649   09D0 C1 00         cmp bl, TOKTYP_IDENTIFIER
1650   09D2 C7 37 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1651   09D5 FD 4D C0 16   mov si, tokstr
1652   09D9 FD 4F 9D 1E   mov di, filename
1653   09DD 07 EF 10      call _strcpy        
1654   09E0 77            inc a                         ; metadata sector
1655   09E1 27            mov b, a
1656   09E2 38 00 00      mov c, 0                      ; upper LBA = 0
1657   09E5 22 01         mov ah, $01                  ; 1 sector
1658   09E7 3B 1D 27      mov d, transient_area
1659   09EA 07 F4 04      call ide_read_sect            ; read directory
1660   09ED FD 10         cla
1661   09EF 42 C9 17      mov [index], a
1662   09F2             loadfile_from_path_L1:
1663   09F2 FD 4E         mov si, d
1664   09F4 FD 4F 9D 1E   mov di, filename
1665   09F8 07 DA 10      call _strcmp
1666   09FB C6 11 0A      je loadfile_from_path_name_equal  
1667   09FE 58 20 00      add d, 32
1668   0A01 14 C9 17      mov a, [index]
1669   0A04 77            inc a
1670   0A05 42 C9 17      mov [index], a
1671   0A08 AF 10 00      cmp a, FST_FILES_PER_DIR
1672   0A0B C6 37 0A      je loadfile_from_path_end
1673   0A0E 0A F2 09      jmp loadfile_from_path_L1
1674   0A11             loadfile_from_path_name_equal:
1675   0A11 33 18 00      mov bl, [d + 24]
1676   0A14 FD 87 38      and bl, %00111000             ; directory flag
1677   0A17 C1 08         cmp bl, %00001000             ; is dir?
1678   0A19 C6 2D 0A      je loadfile_isdirectory  
1679   0A1C             ; entry is a file
1680   0A1C 2B 19 00      mov b, [d + 25]               ; get LBA
1681   0A1F FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1682   0A21 3B 1D 27      mov d, transient_area
1683   0A24 38 00 00      mov c, 0
1684   0A27 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1685   0A29 07 F4 04      call ide_read_sect            ; read sector
1686   0A2C 09            ret
1687   0A2D             loadfile_isdirectory:
1688   0A2D 58 19 00      add d, 25           
1689   0A30 15            mov a, [d]                    ; set result register A = dirID
1690   0A31 07 1D 15      call get_token
1691   0A34 0A CA 09      jmp loadfile_from_path_E0
1692   0A37             loadfile_from_path_end:
1693   0A37 09            ret
1694   0A38             
1695   0A38             ;------------------------------------------------------------------------------------------------------;
1696   0A38             ; return the ID of the current directory
1697   0A38             ; ID returned in B
1698   0A38             ;------------------------------------------------------------------------------------------------------;
1699   0A38             fs_get_curr_dirID:
1700   0A38 29 D1 17      mov b, [current_dir_id]
1701   0A3B 06            sysret
1702   0A3C             
1703   0A3C             ;------------------------------------------------------------------------------------------------------;
1704   0A3C             ; CD
1705   0A3C             ;------------------------------------------------------------------------------------------------------;
1706   0A3C             ; new dirID in B
1707   0A3C             fs_cd:
1708   0A3C FD 42 D1 17   mov [current_dir_id], b
1709   0A40 06            sysret  
1710   0A41             
1711   0A41             ;------------------------------------------------------------------------------------------------------;
1712   0A41             ; LS
1713   0A41             ; dirID in B
1714   0A41             ;------------------------------------------------------------------------------------------------------;
1715   0A41 00 00       ls_count:       .dw 0
1716   0A43             fs_ls:
1717   0A43 FD 77         inc b                        ; metadata sector
1718   0A45 38 00 00      mov c, 0                     ; upper LBA = 0
1719   0A48 22 01         mov ah, $01                  ; 1 sector
1720   0A4A 3B 1D 27      mov d, transient_area
1721   0A4D 07 F4 04      call ide_read_sect           ; read directory
1722   0A50 FD 10         cla
1723   0A52 42 C9 17      mov [index], a               ; reset entry index
1724   0A55 3D 41 0A      mov [ls_count], al           ; reset item count
1725   0A58             fs_ls_L1:
1726   0A58 BD 00         cmp byte [d], 0              ; check for NULL
1727   0A5A C6 F1 0A      je fs_ls_next
1728   0A5D             fs_ls_non_null:
1729   0A5D 1D 41 0A      mov al, [ls_count]
1730   0A60 7A            inc al
1731   0A61 3D 41 0A      mov [ls_count], al           ; increment item count
1732   0A64 1F 18 00      mov al, [d + 24]
1733   0A67 87 38         and al, %00111000
1734   0A69 FD A2 03      shr al, 3
1735   0A6C 22 00         mov ah, 0                    ; file type
1736   0A6E B7 FC 17      mov a, [a + file_type]      
1737   0A71 23            mov ah, al
1738   0A72 07 6B 11      call _putchar
1739   0A75 1F 18 00      mov al, [d + 24]
1740   0A78 87 01         and al, %00000001
1741   0A7A 22 00         mov ah, 0
1742   0A7C B7 F7 17      mov a, [a + file_attrib]     ; read
1743   0A7F 23            mov ah, al
1744   0A80 07 6B 11      call _putchar
1745   0A83 1F 18 00      mov al, [d + 24]
1746   0A86 87 02         and al, %00000010
1747   0A88 22 00         mov ah, 0
1748   0A8A B7 F7 17      mov a, [a + file_attrib]     ; write
1749   0A8D 23            mov ah, al
1750   0A8E 07 6B 11      call _putchar
1751   0A91 1F 18 00      mov al, [d + 24]
1752   0A94 87 04         and al, %00000100
1753   0A96 22 00         mov ah, 0
1754   0A98 B7 F7 17      mov a, [a + file_attrib]     ; execute
1755   0A9B 23            mov ah, al
1756   0A9C 07 6B 11      call _putchar
1757   0A9F 22 20         mov ah, $20
1758   0AA1 07 6B 11      call _putchar  
1759   0AA4 2B 1B 00      mov b, [d + 27]
1760   0AA7 07 F3 12      call print_u16x              ; filesize
1761   0AAA 22 20         mov ah, $20
1762   0AAC 07 6B 11      call _putchar  
1763   0AAF 2B 19 00      mov b, [d + 25]
1764   0AB2 07 F3 12      call print_u16x              ; dirID / LBA
1765   0AB5 22 20         mov ah, $20
1766   0AB7 07 6B 11      call _putchar
1767   0ABA             ; print date
1768   0ABA 33 1D 00      mov bl, [d + 29]             ; day
1769   0ABD 07 37 13      call print_u8x
1770   0AC0 22 20         mov ah, $20
1771   0AC2 07 6B 11      call _putchar  
1772   0AC5 1F 1E 00      mov al, [d + 30]             ; month
1773   0AC8 FD 9E 02      shl al, 2
1774   0ACB DA            push d
1775   0ACC 3B BB 18      mov d, s_months
1776   0ACF 22 00         mov ah, 0
1777   0AD1 59            add d, a
1778   0AD2 07 97 12      call _puts
1779   0AD5 E7            pop d
1780   0AD6 22 20         mov ah, $20
1781   0AD8 07 6B 11      call _putchar
1782   0ADB 2E 20         mov bl, $20
1783   0ADD 07 37 13      call print_u8x
1784   0AE0 33 1F 00      mov bl, [d + 31]             ; year
1785   0AE3 07 37 13      call print_u8x  
1786   0AE6 22 20         mov ah, $20
1787   0AE8 07 6B 11      call _putchar  
1788   0AEB 07 97 12      call _puts                   ; print filename  
1789   0AEE 07 44 12      call printnl
1790   0AF1             fs_ls_next:
1791   0AF1 14 C9 17      mov a, [index]
1792   0AF4 77            inc a
1793   0AF5 42 C9 17      mov [index], a
1794   0AF8 AF 10 00      cmp a, FST_FILES_PER_DIR
1795   0AFB C6 04 0B      je fs_ls_end
1796   0AFE 58 20 00      add d, 32      
1797   0B01 0A 58 0A      jmp fs_ls_L1  
1798   0B04             fs_ls_end:
1799   0B04 3B 0C 18      mov d, s_ls_total
1800   0B07 07 97 12      call _puts
1801   0B0A 1D 41 0A      mov al, [ls_count]
1802   0B0D 07 49 13      call print_u8d
1803   0B10 07 44 12      call printnl
1804   0B13 06            sysret
1805   0B14             
1806   0B14             
1807   0B14             ;------------------------------------------------------------------------------------------------------;
1808   0B14             ; CREATE NEW TEXTFILE
1809   0B14             ;------------------------------------------------------------------------------------------------------;
1810   0B14             ; file structure:
1811   0B14             ; 512 bytes header
1812   0B14             ; header used to tell whether the block is free
1813   0B14             ; d = content pointer in user space
1814   0B14             ; c = file size
1815   0B14             ; TODO: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1816   0B14             fs_starcom:
1817   0B14 FD 4E       	mov si, d
1818   0B16 FD 4F 1D 27 	mov di, transient_area
1819   0B1A 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1820   0B1D 04          	load					; load data from user-space
1821   0B1E 07 9F 0B    	call fs_find_empty_block	; look for empty data blocks
1822   0B21 D8          	push b				; save empty block LBA
1823   0B22 FD 79         mov g, b
1824   0B24             ;create header file by grabbing file name from parameter	
1825   0B24 3B 1D 29    	mov d, transient_area + 512			; pointer to file contents
1826   0B27 D9          	push c							; save length
1827   0B28 19 01       	mov al, 1
1828   0B2A 3D 1D 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1829   0B2D 3B 1D 27    	mov d, transient_area
1830   0B30 12            mov a, c
1831   0B31 26 00 02      mov b, 512
1832   0B34 AE            div a, b
1833   0B35 FD 77         inc b         ; inc b as the division will most likely have a remainder
1834   0B37 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1835   0B38 38 00 00    	mov c, 0      ; lba 
1836   0B3B FD 27         mov b, g      ; lba 
1837   0B3D 07 1A 05    	call ide_write_sect			; write sectors
1838   0B40             ; now we add the file to the current directory!
1839   0B40             fs_starcom_add_to_dir:	
1840   0B40 14 D1 17    	mov a, [current_dir_id]
1841   0B43 77          	inc a
1842   0B44 27          	mov b, a					; metadata sector
1843   0B45 38 00 00    	mov c, 0
1844   0B48 FD 79       	mov g, b					; save LBA
1845   0B4A 3B 1D 25    	mov d, scrap_sector
1846   0B4D 22 01       	mov ah, $01			  ; 1 sector
1847   0B4F 07 F4 04    	call ide_read_sect		; read metadata sector
1848   0B52             fs_starcom_add_to_dir_L2:
1849   0B52 BD 00       	cmp byte[d], 0
1850   0B54 C6 5D 0B    	je fs_starcom_add_to_dir_null
1851   0B57 58 20 00    	add d, FST_ENTRY_SIZE
1852   0B5A 0A 52 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1853   0B5D             fs_starcom_add_to_dir_null:
1854   0B5D FD 4D 1E 27 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1855   0B61 FD 50       	mov di, d
1856   0B63 07 EF 10    	call _strcpy			; copy file name
1857   0B66 58 18 00    	add d, 24			; skip name
1858   0B69 19 07       	mov al, %00000111	; type=file, execute, write, read
1859   0B6B 3E          	mov [d], al			
1860   0B6C 58 03 00    	add d, 3
1861   0B6F E4          	pop a
1862   0B70 5F 00 02      sub a, 512
1863   0B73 43          	mov [d], a ; file size
1864   0B74 63 02 00    	sub d, 2
1865   0B77 E5          	pop b				; get file LBA
1866   0B78 FD 43       	mov [d], b			; save LBA	
1867   0B7A             ; set file creation date	
1868   0B7A 58 04 00    	add d, 4
1869   0B7D 19 04       	mov al, 4
1870   0B7F 05 01       	syscall sys_rtc
1871   0B81 1A          	mov al, ah
1872   0B82 3E          	mov [d], al			; set day
1873   0B83 79          	inc d
1874   0B84 19 05       	mov al, 5
1875   0B86 05 01       	syscall sys_rtc
1876   0B88 1A          	mov al, ah
1877   0B89 3E          	mov [d], al			; set month
1878   0B8A 79          	inc d
1879   0B8B 19 06       	mov al, 6
1880   0B8D 05 01       	syscall sys_rtc
1881   0B8F 1A          	mov al, ah
1882   0B90 3E          	mov [d], al			; set year
1883   0B91             ; write sector into disk for new directory entry
1884   0B91 FD 27       	mov b, g
1885   0B93 38 00 00    	mov c, 0
1886   0B96 3B 1D 25    	mov d, scrap_sector
1887   0B99 22 01       	mov ah, $01			; disk write, 1 sector
1888   0B9B 07 1A 05    	call ide_write_sect		; write sector
1889   0B9E 06          	sysret
1890   0B9F             
1891   0B9F             ;------------------------------------------------------------------------------------------------------;
1892   0B9F             ; finds an empty data block
1893   0B9F             ; block LBA returned in B
1894   0B9F             ;------------------------------------------------------------------------------------------------------;
1895   0B9F             fs_find_empty_block:
1896   0B9F 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1897   0BA2 38 00 00      mov c, 0                ; upper LBA = 0
1898   0BA5             fs_find_empty_block_L1:  
1899   0BA5 22 01         mov ah, $01                  ; 1 sector
1900   0BA7 3B 1D 25      mov d, transient_area - 512
1901   0BAA 07 F4 04      call ide_read_sect      ; read sector
1902   0BAD BD 00         cmp byte [d], 0
1903   0BAF C6 B8 0B      je fs_find_empty_block_found_null
1904   0BB2 55 20 00      add b, FS_SECTORS_PER_FILE
1905   0BB5 0A A5 0B      jmp fs_find_empty_block_L1
1906   0BB8             fs_find_empty_block_found_null:
1907   0BB8 09            ret
1908   0BB9             
1909   0BB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1910   0BB9             ;; CREATE NEW TEXTFILE
1911   0BB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1912   0BB9             ; search for first null block
1913   0BB9             fs_mktxt:
1914   0BB9 FD 4E       	mov si, d
1915   0BBB FD 4F 1D 1F 	mov di, user_data
1916   0BBF 38 00 01    	mov c, 256
1917   0BC2 04          	load					; load data from user-space
1918   0BC3             	
1919   0BC3 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1920   0BC6 38 00 00    	mov c, 0						; reset LBA to 0
1921   0BC9             fs_mktxt_L1:	
1922   0BC9 10 02 01    	mov a, $0102			; disk read
1923   0BCC 3B 1D 27    	mov d, transient_area
1924   0BCF 05 02       	syscall sys_ide ; read sector
1925   0BD1 1E          	mov al, [d]
1926   0BD2 B9 00       	cmp al, 0			; check for NULL
1927   0BD4 C6 DD 0B    	je fs_mktxt_found_null
1928   0BD7 55 20 00    	add b, FS_SECTORS_PER_FILE
1929   0BDA 0A C9 0B    	jmp fs_mktxt_L1
1930   0BDD             fs_mktxt_found_null:
1931   0BDD D8          	push b				; save LBA
1932   0BDE             ;create header file by grabbing file name from parameter	
1933   0BDE 3B ED 17    	mov d, s_dataentry
1934   0BE1 07 97 12    	call _puts
1935   0BE4 3B 1D 29    	mov d, transient_area + 512			; pointer to file contents
1936   0BE7 07 FD 11    	call _gettxt
1937   0BEA 07 CA 10    	call _strlen						; get length of file
1938   0BED D9          	push c							; save length
1939   0BEE 19 01       	mov al, 1
1940   0BF0 3D 1D 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1941   0BF3 10 00 00    	mov a, 0
1942   0BF6 42 C9 17    	mov [index], a
1943   0BF9 3B 1D 27    	mov d, transient_area
1944   0BFC 13          	mov a, d
1945   0BFD 42 CB 17    	mov [buffer_addr], a
1946   0C00             fs_mktxt_L2:
1947   0C00 38 00 00    	mov c, 0
1948   0C03 10 03 01    	mov a, $0103			; disk write, 1 sector
1949   0C06 05 02       	syscall sys_ide		; write sector
1950   0C08 14 C9 17    	mov a, [index]
1951   0C0B 77          	inc a
1952   0C0C 42 C9 17    	mov [index], a
1953   0C0F AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1954   0C12 C6 24 0C    	je fs_mktxt_add_to_dir
1955   0C15 FD 77       	inc b
1956   0C17 14 CB 17    	mov a, [buffer_addr]
1957   0C1A 53 00 02    	add a, 512
1958   0C1D 42 CB 17    	mov [buffer_addr], a
1959   0C20 3C          	mov d, a
1960   0C21 0A 00 0C    	jmp fs_mktxt_L2
1961   0C24             ; now we add the file to the current directory!
1962   0C24             fs_mktxt_add_to_dir:	
1963   0C24 14 D1 17    	mov a, [current_dir_id]
1964   0C27 77          	inc a
1965   0C28 27          	mov b, a					; metadata sector
1966   0C29 38 00 00    	mov c, 0
1967   0C2C FD 79       	mov g, b					; save LBA
1968   0C2E 3B 1D 27    	mov d, transient_area
1969   0C31 10 02 01    	mov a, $0102			; disk read
1970   0C34 05 02       	syscall sys_ide		; read metadata sector
1971   0C36             fs_mktxt_add_to_dir_L2:
1972   0C36 1E          	mov al, [d]
1973   0C37 B9 00       	cmp al, 0
1974   0C39 C6 42 0C    	je fs_mktxt_add_to_dir_null
1975   0C3C 58 20 00    	add d, FST_ENTRY_SIZE
1976   0C3F 0A 36 0C    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1977   0C42             fs_mktxt_add_to_dir_null:
1978   0C42 FD 4D 1D 1F 	mov si, user_data
1979   0C46 FD 50       	mov di, d
1980   0C48 07 EF 10    	call _strcpy			; copy file name
1981   0C4B 58 18 00    	add d, 24			; skip name
1982   0C4E 19 06       	mov al, %00000110		; no execute, write, read, not directory
1983   0C50 3E          	mov [d], al			
1984   0C51 58 03 00    	add d, 3
1985   0C54 E4          	pop a
1986   0C55 43          	mov [d], a
1987   0C56 63 02 00    	sub d, 2
1988   0C59 E5          	pop b				; get file LBA
1989   0C5A FD 43       	mov [d], b			; save LBA	
1990   0C5C             	
1991   0C5C             	; set file creation date	
1992   0C5C 58 04 00    	add d, 4
1993   0C5F 19 04       	mov al, 4
1994   0C61 05 01       	syscall sys_rtc
1995   0C63 1A          	mov al, ah
1996   0C64 3E          	mov [d], al			; set day
1997   0C65             	
1998   0C65 79          	inc d
1999   0C66 19 05       	mov al, 5
2000   0C68 05 01       	syscall sys_rtc
2001   0C6A 1A          	mov al, ah
2002   0C6B 3E          	mov [d], al			; set month
2003   0C6C             	
2004   0C6C 79          	inc d
2005   0C6D 19 06       	mov al, 6
2006   0C6F 05 01       	syscall sys_rtc
2007   0C71 1A          	mov al, ah
2008   0C72 3E          	mov [d], al			; set year
2009   0C73             	
2010   0C73             ; write sector into disk for new directory entry
2011   0C73 FD 27       	mov b, g
2012   0C75 38 00 00    	mov c, 0
2013   0C78 3B 1D 27    	mov d, transient_area
2014   0C7B 10 03 01    	mov a, $0103			; disk write, 1 sector
2015   0C7E 05 02       	syscall sys_ide		; write sector
2016   0C80 07 44 12    	call printnl
2017   0C83 06          	sysret
2018   0C84             
2019   0C84             
2020   0C84             
2021   0C84             ;------------------------------------------------------------------------------------------------------;
2022   0C84             ; create new binary file
2023   0C84             ;------------------------------------------------------------------------------------------------------;
2024   0C84             ; search for first null block
2025   0C84             fs_mkbin:
2026   0C84 19 00         mov al, 0
2027   0C86 3D C1 17      mov [sys_echo_on], al ; disable echo
2028   0C89 FD 4E         mov si, d
2029   0C8B FD 4F 1D 1F   mov di, user_data
2030   0C8F 38 00 02      mov c, 512
2031   0C92 04            load                          ; load data from user-space
2032   0C93 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2033   0C96 38 00 00      mov c, 0                      ; upper LBA = 0
2034   0C99             fs_mkbin_L1:  
2035   0C99 22 01         mov ah, $01                  ; 1 sector
2036   0C9B 3B 1D 27      mov d, transient_area
2037   0C9E 07 F4 04      call ide_read_sect            ; read sector
2038   0CA1 BD 00         cmp byte[d], 0                ; check for NULL
2039   0CA3 C6 AC 0C      je fs_mkbin_found_null
2040   0CA6 55 20 00      add b, FS_SECTORS_PER_FILE
2041   0CA9 0A 99 0C      jmp fs_mkbin_L1
2042   0CAC             fs_mkbin_found_null:
2043   0CAC D8            push b                        ; save LBA
2044   0CAD             ;create header file by grabbing file name from parameter
2045   0CAD FD 4F 1D 29   mov di, transient_area + 512  ; pointer to file contents
2046   0CB1 07 27 10      call _load_hex                ; load binary hex
2047   0CB4 D9            push c                        ; save size (nbr of bytes)
2048   0CB5 19 01         mov al, 1
2049   0CB7 3D 1D 27      mov [transient_area], al      ; mark sectors as USED (not NULL)
2050   0CBA FD 10         cla
2051   0CBC 42 C9 17      mov [index], a
2052   0CBF 3B 1D 27      mov d, transient_area
2053   0CC2 13            mov a, d
2054   0CC3 42 CB 17      mov [buffer_addr], a
2055   0CC6             fs_mkbin_L2:
2056   0CC6 38 00 00      mov c, 0
2057   0CC9 22 01         mov ah, $01                   ; disk write, 1 sector
2058   0CCB 07 1A 05      call ide_write_sect           ; write sector
2059   0CCE 14 C9 17      mov a, [index]
2060   0CD1 77            inc a
2061   0CD2 42 C9 17      mov [index], a
2062   0CD5 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2063   0CD8 C6 EA 0C      je fs_mkbin_add_to_dir
2064   0CDB FD 77         inc b
2065   0CDD 14 CB 17      mov a, [buffer_addr]
2066   0CE0 53 00 02      add a, 512
2067   0CE3 42 CB 17      mov [buffer_addr], a
2068   0CE6 3C            mov d, a
2069   0CE7 0A C6 0C      jmp fs_mkbin_L2
2070   0CEA             ; now we add the file to the current directory!
2071   0CEA             fs_mkbin_add_to_dir:  
2072   0CEA 14 D1 17      mov a, [current_dir_id]
2073   0CED 77            inc a
2074   0CEE 27            mov b, a                      ; metadata sector
2075   0CEF 38 00 00      mov c, 0
2076   0CF2 FD 79         mov g, b                      ; save LBA
2077   0CF4 3B 1D 27      mov d, transient_area
2078   0CF7 22 01         mov ah, $01                  ; 1 sector
2079   0CF9 07 F4 04      call ide_read_sect            ; read metadata sector
2080   0CFC             fs_mkbin_add_to_dir_L2:
2081   0CFC BD 00         cmp byte[d], 0
2082   0CFE C6 07 0D      je fs_mkbin_add_to_dir_null
2083   0D01 58 20 00      add d, FST_ENTRY_SIZE
2084   0D04 0A FC 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2085   0D07             fs_mkbin_add_to_dir_null:
2086   0D07 FD 4D 1D 1F   mov si, user_data
2087   0D0B FD 50         mov di, d
2088   0D0D 07 EF 10      call _strcpy                  ; copy file name
2089   0D10 58 18 00      add d, 24                     ; skip name
2090   0D13 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2091   0D15 3E            mov [d], al
2092   0D16 58 03 00      add d, 3
2093   0D19 E4            pop a
2094   0D1A 43            mov [d], a
2095   0D1B 63 02 00      sub d, 2
2096   0D1E E5            pop b                         ; get file LBA
2097   0D1F FD 43         mov [d], b                    ; save LBA
2098   0D21               ; set file creation date  
2099   0D21 58 04 00      add d, 4
2100   0D24 19 04         mov al, 4
2101   0D26 05 01         syscall sys_rtc
2102   0D28 1A            mov al, ah
2103   0D29 3E            mov [d], al                   ; set day
2104   0D2A 79            inc d
2105   0D2B 19 05         mov al, 5
2106   0D2D 05 01         syscall sys_rtc
2107   0D2F 1A            mov al, ah
2108   0D30 3E            mov [d], al                   ; set month
2109   0D31 79            inc d
2110   0D32 19 06         mov al, 6
2111   0D34 05 01         syscall sys_rtc
2112   0D36 1A            mov al, ah
2113   0D37 3E            mov [d], al                   ; set year
2114   0D38             ; write sector into disk for new directory entry
2115   0D38 FD 27         mov b, g
2116   0D3A 38 00 00      mov c, 0
2117   0D3D 3B 1D 27      mov d, transient_area
2118   0D40 22 01         mov ah, $01                   ; disk write, 1 sector
2119   0D42 07 1A 05      call ide_write_sect           ; write sector
2120   0D45 19 01         mov al, 1
2121   0D47 3D C1 17      mov [sys_echo_on], al ; enable echo
2122   0D4A 06            sysret
2123   0D4B             
2124   0D4B             ;------------------------------------------------------------------------------------------------------;
2125   0D4B             ; pwd - print working directory
2126   0D4B             ;------------------------------------------------------------------------------------------------------;    
2127   0D4B             fs_pwd:
2128   0D4B 3B 9D 1E      mov d, filename
2129   0D4E 19 00         mov al, 0
2130   0D50 3E            mov [d], al                   ; initialize path string 
2131   0D51 14 D1 17      mov a, [current_dir_id]
2132   0D54 07 2A 08      call fs_dir_id_to_path_E0
2133   0D57 3B 9D 1E      mov d, filename
2134   0D5A 07 83 10      call _strrev
2135   0D5D 07 97 12      call _puts
2136   0D60 07 44 12      call printnl
2137   0D63 06            sysret
2138   0D64             
2139   0D64             ;------------------------------------------------------------------------------------------------------;
2140   0D64             ; get current directory LBA
2141   0D64             ; A: returned LBA
2142   0D64             ;------------------------------------------------------------------------------------------------------;
2143   0D64             cmd_get_curr_dir_LBA:
2144   0D64 14 D1 17      mov a, [current_dir_id]
2145   0D67 06            sysret
2146   0D68             
2147   0D68             ;------------------------------------------------------------------------------------------------------;
2148   0D68             ; CAT
2149   0D68             ; userspace destination data pointer in D
2150   0D68             ; filename starts at D, but is overwritten after the read is made
2151   0D68             ;------------------------------------------------------------------------------------------------------;:
2152   0D68             fs_cat:
2153   0D68 DA            push d                              ; save userspace file data destination
2154   0D69 FD 4E         mov si, d
2155   0D6B FD 4F 1D 1F   mov di, user_data
2156   0D6F 38 00 02      mov c, 512
2157   0D72 04            load                                ; copy filename from user-space
2158   0D73 29 D1 17      mov b, [current_dir_id]
2159   0D76 FD 77         inc b                               ; metadata sector
2160   0D78 38 00 00      mov c, 0                            ; upper LBA = 0
2161   0D7B 22 01         mov ah, $01                  ; 1 sector
2162   0D7D 3B 1D 25      mov d, transient_area-512
2163   0D80 07 F4 04      call ide_read_sect                  ; read directory
2164   0D83 FD 10         cla
2165   0D85 42 C9 17      mov [index], a                      ; reset file counter
2166   0D88             fs_cat_L1:
2167   0D88 FD 4E         mov si, d
2168   0D8A FD 4F 1D 1F   mov di, user_data
2169   0D8E 07 DA 10      call _strcmp
2170   0D91 C6 A7 0D      je fs_cat_found_entry
2171   0D94 58 20 00      add d, 32
2172   0D97 14 C9 17      mov a, [index]
2173   0D9A 77            inc a
2174   0D9B 42 C9 17      mov [index], a
2175   0D9E AF 10 00      cmp a, FST_FILES_PER_DIR
2176   0DA1 C6 C2 0D      je fs_cat_not_found
2177   0DA4 0A 88 0D      jmp fs_cat_L1
2178   0DA7             fs_cat_found_entry:
2179   0DA7 58 19 00      add d, 25                           ; get to dirID of file in disk
2180   0DAA 2A            mov b, [d]                          ; get LBA
2181   0DAB FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2182   0DAD 3B 1D 27      mov d, transient_area  
2183   0DB0 38 00 00      mov c, 0
2184   0DB3 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2185   0DB5 07 F4 04      call ide_read_sect                  ; read sectors
2186   0DB8 F0            pop di                              ; write userspace file data destination to DI
2187   0DB9 FD 4D 1D 27   mov si, transient_area              ; data origin
2188   0DBD 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2189   0DC0 03            store
2190   0DC1 06            sysret
2191   0DC2             fs_cat_not_found:
2192   0DC2 E7            pop d
2193   0DC3 06            sysret
2194   0DC4             
2195   0DC4             ;------------------------------------------------------------------------------------------------------;
2196   0DC4             ; RMDIR - remove DIR by dirID
2197   0DC4             ;------------------------------------------------------------------------------------------------------;
2198   0DC4             ; deletes a directory entry in the given directory's file list 
2199   0DC4             ; also deletes the actual directory entry in the FST
2200   0DC4             ; synopsis: rmdir /usr/local/testdir
2201   0DC4             ; B = dirID
2202   0DC4             fs_rmdir:
2203   0DC4 FD 79         mov g, b
2204   0DC6 11            mov a, b
2205   0DC7 07 66 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2206   0DCA D7            push a                        ; save dirID
2207   0DCB             ; search for directory's entry in the parent's directory then and delete it
2208   0DCB 77            inc a                         ; metadata sector
2209   0DCC 27            mov b, a
2210   0DCD 38 00 00      mov c, 0                      ; upper LBA = 0
2211   0DD0 22 01         mov ah, $01          ;
2212   0DD2 3B 1D 27      mov d, transient_area
2213   0DD5 07 F4 04      call ide_read_sect            ; read directory
2214   0DD8 FD 10         cla
2215   0DDA 42 C9 17      mov [index], a                ; reset file counter
2216   0DDD FD 27         mov b, g                      ; retrieve directory's dirID
2217   0DDF             fs_rmdir_L1:
2218   0DDF 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2219   0DE2 B0            cmp a, b                      ; compare dirID's to find the directory
2220   0DE3 C6 F9 0D      je fs_rmdir_found_entry
2221   0DE6 58 20 00      add d, 32
2222   0DE9 14 C9 17      mov a, [index]
2223   0DEC 77            inc a
2224   0DED 42 C9 17      mov [index], a
2225   0DF0 AF 10 00      cmp a, FST_FILES_PER_DIR
2226   0DF3 C6 1E 0E      je fs_rmdir_not_found
2227   0DF6 0A DF 0D      jmp fs_rmdir_L1
2228   0DF9             fs_rmdir_found_entry:
2229   0DF9 FD 10         cla
2230   0DFB 3E            mov [d], al                   ; make filename NULL
2231   0DFC 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2232   0DFF E5            pop b
2233   0E00 FD 77         inc b                         ; metadata sector
2234   0E02 38 00 00      mov c, 0                      ; upper LBA = 0
2235   0E05 22 01         mov ah, $01          ; 
2236   0E07 3B 1D 27      mov d, transient_area
2237   0E0A 07 1A 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2238   0E0D             
2239   0E0D FD 27         mov b, g
2240   0E0F 3B 1D 27      mov d, transient_area  
2241   0E12 FD 10         cla
2242   0E14 3E            mov [d], al                   ; make directory's name header NULL for re-use
2243   0E15 38 00 00      mov c, 0
2244   0E18 22 01         mov ah, $01                   ; disk write 1 sect
2245   0E1A 07 1A 05      call ide_write_sect           ; delete directory given by dirID in B
2246   0E1D 06            sysret
2247   0E1E             fs_rmdir_not_found:
2248   0E1E E5            pop b
2249   0E1F 06            sysret
2250   0E20             
2251   0E20             ;------------------------------------------------------------------------------------------------------;
2252   0E20             ; RM - remove file
2253   0E20             ;------------------------------------------------------------------------------------------------------;
2254   0E20             ; frees up the data sectors for the file further down the disk
2255   0E20             ; deletes file entry in the directory's file list 
2256   0E20             fs_rm:
2257   0E20 FD 4E         mov si, d
2258   0E22 FD 4F 1D 1F   mov di, user_data
2259   0E26 38 00 02      mov c, 512
2260   0E29 04            load                          ; load data from user-space
2261   0E2A 14 D1 17      mov a, [current_dir_id]
2262   0E2D 77            inc a                         ; metadata sector
2263   0E2E 27            mov b, a
2264   0E2F 38 00 00      mov c, 0                      ; upper LBA = 0
2265   0E32 22 01         mov ah, $01                  ; 1 sector
2266   0E34 3B 1D 27      mov d, transient_area
2267   0E37 07 F4 04      call ide_read_sect            ; read directory
2268   0E3A 10 00 00      mov a, 0
2269   0E3D 42 C9 17      mov [index], a                ; reset file counter
2270   0E40             fs_rm_L1:
2271   0E40 FD 4E         mov si, d
2272   0E42 FD 4F 1D 1F   mov di, user_data
2273   0E46 07 DA 10      call _strcmp
2274   0E49 C6 5F 0E      je fs_rm_found_entry
2275   0E4C 58 20 00      add d, 32
2276   0E4F 14 C9 17      mov a, [index]
2277   0E52 77            inc a
2278   0E53 42 C9 17      mov [index], a
2279   0E56 AF 10 00      cmp a, FST_FILES_PER_DIR
2280   0E59 C6 87 0E      je fs_rm_not_found
2281   0E5C 0A 40 0E      jmp fs_rm_L1
2282   0E5F             fs_rm_found_entry:
2283   0E5F 2B 19 00      mov b, [d + 25]               ; get LBA
2284   0E62 FD 79         mov g, b                      ; save LBA
2285   0E64 19 00         mov al, 0
2286   0E66 3E            mov [d], al                   ; make file entry NULL
2287   0E67 14 D1 17      mov a, [current_dir_id]
2288   0E6A 77            inc a                         ; metadata sector
2289   0E6B 27            mov b, a
2290   0E6C 38 00 00      mov c, 0                      ; upper LBA = 0
2291   0E6F 22 01         mov ah, $01                   ; disk write
2292   0E71 3B 1D 27      mov d, transient_area
2293   0E74 07 1A 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2294   0E77 3B 1D 27      mov d, transient_area  
2295   0E7A 19 00         mov al, 0
2296   0E7C 3E            mov [d], al                   ; make file's data header NULL for re-use
2297   0E7D 38 00 00      mov c, 0
2298   0E80 FD 27         mov b, g                      ; get data header LBA
2299   0E82 22 01         mov ah, $01                   ; disk write 1 sect
2300   0E84 07 1A 05      call ide_write_sect           ; write sector
2301   0E87             fs_rm_not_found:  
2302   0E87 06            sysret  
2303   0E88             
2304   0E88             ;------------------------------------------------------------------------------------------------------;
2305   0E88             ; mv - move / change file name
2306   0E88             ;------------------------------------------------------------------------------------------------------;
2307   0E88             fs_mv:
2308   0E88 FD 4E         mov si, d
2309   0E8A FD 4F 1D 1F   mov di, user_data
2310   0E8E 38 00 02      mov c, 512
2311   0E91 04            load                          ; load data from user-space
2312   0E92 14 D1 17      mov a, [current_dir_id]
2313   0E95 77            inc a                         ; metadata sector
2314   0E96 27            mov b, a  
2315   0E97 38 00 00      mov c, 0                      ; upper LBA = 0
2316   0E9A 22 01         mov ah, $01                  ; 1 sector
2317   0E9C 3B 1D 27      mov d, transient_area
2318   0E9F 07 F4 04      call ide_read_sect            ; read directory
2319   0EA2 FD 10         cla
2320   0EA4 42 C9 17      mov [index], a                ; reset file counter
2321   0EA7             fs_mv_L1:
2322   0EA7 FD 4E         mov si, d
2323   0EA9 FD 4F 1D 1F   mov di, user_data
2324   0EAD 07 DA 10      call _strcmp
2325   0EB0 C6 C6 0E      je fs_mv_found_entry
2326   0EB3 58 20 00      add d, 32
2327   0EB6 14 C9 17      mov a, [index]
2328   0EB9 77            inc a
2329   0EBA 42 C9 17      mov [index], a
2330   0EBD AF 10 00      cmp a, FST_FILES_PER_DIR
2331   0EC0 C6 F8 0E      je fs_mv_not_found
2332   0EC3 0A A7 0E      jmp fs_mv_L1
2333   0EC6             fs_mv_found_entry:  
2334   0EC6 DA            push d
2335   0EC7 FD 4D 9D 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2336   0ECB FD 50         mov di, d
2337   0ECD 07 EF 10      call _strcpy  
2338   0ED0 38 00 00      mov c, 0
2339   0ED3 3B 1D 27      mov d, transient_area
2340   0ED6 22 01         mov ah, $01                   ; disk write 1 sect
2341   0ED8 07 1A 05      call ide_write_sect           ; write sector
2342   0EDB E7            pop d
2343   0EDC             ;; need to check whether its a dir or a file here ;;;
2344   0EDC 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2345   0EDF 22 01         mov ah, $01
2346   0EE1 3B 1D 27      mov d, transient_area
2347   0EE4 38 00 00      mov c, 0
2348   0EE7 07 F4 04      call ide_read_sect            ; read directory entry
2349   0EEA FD 4D 9D 1F   mov si, user_data + 128
2350   0EEE FD 50         mov di, d
2351   0EF0 07 EF 10      call _strcpy                  ; change directory's name
2352   0EF3 22 01         mov ah, $01
2353   0EF5 07 1A 05      call ide_write_sect           ; rewrite directory back to disk
2354   0EF8             fs_mv_not_found:
2355   0EF8 06            sysret
2356   0EF9             
2357   0EF9             
2358   0EF9             ;----------------------------------------------------------------------------------------------------;
2359   0EF9             ; Process Index in A
2360   0EF9             ;----------------------------------------------------------------------------------------------------;
2361   0EF9             find_free_proc:
2362   0EF9 FD 4D 8E 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2363   0EFD             find_free_proc_L0:
2364   0EFD F6            lodsb                               ; get process state
2365   0EFE B9 00         cmp al, 0
2366   0F00 C6 06 0F      je find_free_proc_free              ; if free, jump
2367   0F03 0A FD 0E      jmp find_free_proc_L0               ; else, goto next
2368   0F06             find_free_proc_free:
2369   0F06 4E            mov a, si
2370   0F07 5F 8E 1C      sub a, 1 + proc_availab_table       ; get process index
2371   0F0A 09            ret
2372   0F0B               
2373   0F0B             
2374   0F0B             ;----------------------------------------------------------------------------------------------------;
2375   0F0B             ; Process Index in AL
2376   0F0B             ;----------------------------------------------------------------------------------------------------;
2377   0F0B             proc_memory_map:
2378   0F0B 22 00         mov ah, 0
2379   0F0D 27            mov b, a                      ; page in BL, 0 in BH
2380   0F0E FD 9D 05      shl a, 5                      ; multiply by 32
2381   0F11 39            mov c, a                      ; save in C
2382   0F12 57 20 00      add c, 32
2383   0F15             proc_memory_map_L0:
2384   0F15 02            pagemap
2385   0F16 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2386   0F19 53 01 00      add a, 1                      ; increase both 
2387   0F1C B1            cmp a, c                      ; check to see if we reached the end of memory
2388   0F1D C7 15 0F      jne proc_memory_map_L0
2389   0F20 09            ret
2390   0F21               
2391   0F21             
2392   0F21             ;----------------------------------------------------------------------------------------------------;
2393   0F21             ; terminate process
2394   0F21             ;----------------------------------------------------------------------------------------------------;
2395   0F21             syscall_terminate_proc:
2396   0F21 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2397   0F24                                                    ; since they will not be used for anything here.
2398   0F24 1D C8 17      mov al, [active_proc_index]
2399   0F27 22 00         mov ah, 0  
2400   0F29 FD 9D 05      shl a, 5                             ; x32
2401   0F2C 53 9D 1C      add a, proc_names
2402   0F2F 3C            mov d, a
2403   0F30 19 00         mov al, 0
2404   0F32 3E            mov [d], al                           ; nullify process name
2405   0F33             
2406   0F33 1D C8 17      mov al, [active_proc_index]
2407   0F36 22 00         mov ah, 0  
2408   0F38 3C            mov d, a
2409   0F39 19 00         mov al, 0
2410   0F3B 3F 8D 1C      mov [d + proc_availab_table], al    ; make process empty again
2411   0F3E               
2412   0F3E 1D C7 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2413   0F41 80            dec al
2414   0F42 3D C7 17      mov [nbr_active_procs], al
2415   0F45             
2416   0F45             ; now load the shell process again
2417   0F45 19 02         mov al, 2                           ; next process = process 2 = shell
2418   0F47 3D C8 17      mov [active_proc_index], al         ; set next active proc
2419   0F4A             
2420   0F4A             ; calculate LUT entry for next process
2421   0F4A 22 00         mov ah, 0
2422   0F4C FD 99         shl a                               ; x2
2423   0F4E B7 17 10      mov a, [proc_table_convert + a]     ; get process state start index  
2424   0F51               
2425   0F51 4D            mov si, a                           ; source is proc state block
2426   0F52 48            mov a, sp
2427   0F53 5F 13 00      sub a, 19
2428   0F56 4F            mov di, a                           ; destination is kernel stack
2429   0F57             ; restore SP
2430   0F57 7D            dec a
2431   0F58 47            mov sp, a
2432   0F59 38 14 00      mov c, 20
2433   0F5C FD F5         rep movsb
2434   0F5E             ; set VM process
2435   0F5E 1D C8 17      mov al, [active_proc_index]
2436   0F61 01            setptb
2437   0F62                 
2438   0F62 4C            popa
2439   0F63 06            sysret
2440   0F64             
2441   0F64             ;----------------------------------------------------------------------------------------------------;
2442   0F64             ; pause process
2443   0F64             ;----------------------------------------------------------------------------------------------------;
2444   0F64             syscall_pause_proc:
2445   0F64             ; save all registers into kernel stack
2446   0F64 4B            pusha
2447   0F65 22 00         mov ah, 0
2448   0F67 1D C8 17      mov al, [active_proc_index]
2449   0F6A FD 99         shl a              ; x2
2450   0F6C B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index
2451   0F6F                 
2452   0F6F 4F            mov di, a
2453   0F70 48            mov a, sp
2454   0F71 77            inc a
2455   0F72 4D            mov si, a
2456   0F73 38 14 00      mov c, 20
2457   0F76 FD F5         rep movsb                         ; save process state!
2458   0F78             ; restore kernel stack position to point before interrupt arrived
2459   0F78 51 14 00      add sp, 20
2460   0F7B             ; now load the shell process again
2461   0F7B 19 02         mov al, 2                         ; next process = process 2 = shell
2462   0F7D 3D C8 17      mov [active_proc_index], al       ; set next active proc
2463   0F80             
2464   0F80             ; calculate LUT entry for next process
2465   0F80 22 00         mov ah, 0
2466   0F82 FD 99         shl a                             ; x2
2467   0F84 B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index  
2468   0F87               
2469   0F87 4D            mov si, a                         ; source is proc state block
2470   0F88 48            mov a, sp
2471   0F89 5F 13 00      sub a, 19
2472   0F8C 4F            mov di, a                         ; destination is kernel stack
2473   0F8D             ; restore SP
2474   0F8D 7D            dec a
2475   0F8E 47            mov sp, a
2476   0F8F 38 14 00      mov c, 20
2477   0F92 FD F5         rep movsb
2478   0F94             ; set VM process
2479   0F94 1D C8 17      mov al, [active_proc_index]
2480   0F97 01            setptb
2481   0F98                 
2482   0F98 4C            popa
2483   0F99 06            sysret
2484   0F9A             
2485   0F9A             ;----------------------------------------------------------------------------------------------------;
2486   0F9A             ; create a new process
2487   0F9A             ; D = path of the process file to be createed
2488   0F9A             ; B = arguments ptr
2489   0F9A             ;----------------------------------------------------------------------------------------------------;
2490   0F9A             syscall_create_proc:
2491   0F9A             ; we save the active process first  
2492   0F9A 4B            pusha
2493   0F9B 22 00         mov ah, 0
2494   0F9D 1D C8 17      mov al, [active_proc_index]
2495   0FA0 FD 99         shl a              ; x2
2496   0FA2 B7 17 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2497   0FA5               
2498   0FA5 4F            mov di, a
2499   0FA6 48            mov a, sp
2500   0FA7 77            inc a
2501   0FA8 4D            mov si, a
2502   0FA9 38 14 00      mov c, 20
2503   0FAC FD F5         rep movsb                          ; save process state!
2504   0FAE             ; restore kernel stack position to point before interrupt arrived
2505   0FAE 51 14 00      add sp, 20
2506   0FB1               
2507   0FB1 FD 4E         mov si, d                          ; copy the file path
2508   0FB3 FD 4F 1D 1F   mov di, user_data
2509   0FB7 38 00 02      mov c, 512
2510   0FBA 04            load
2511   0FBB 11            mov a, b
2512   0FBC 4D            mov si, a                          ; copy the arguments
2513   0FBD FD 4F 1D 25   mov di, scrap_sector
2514   0FC1 38 00 02      mov c, 512
2515   0FC4 04            load
2516   0FC5 07 AC 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2517   0FC8                                                  ; the file data is loaded into transient_area
2518   0FC8             ; now we allocate a new process  
2519   0FC8 07 F9 0E      call find_free_proc                ; index in A
2520   0FCB 01            setptb 
2521   0FCC 07 0B 0F      call proc_memory_map               ; map process memory pages
2522   0FCF             ; copy arguments into process's memory
2523   0FCF FD 4D 1D 25   mov si, scrap_sector
2524   0FD3 FD 4F 00 00   mov di, 0
2525   0FD7 38 00 02      mov c, 512
2526   0FDA 03            store
2527   0FDB             ; now copy process binary data into process's memory
2528   0FDB FD 4D 1D 27   mov si, transient_area
2529   0FDF FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2530   0FE3 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2531   0FE6 03            store                              ; copy process data
2532   0FE7                 
2533   0FE7 07 F9 0E      call find_free_proc                ; index in A
2534   0FEA 3D C8 17      mov [active_proc_index], al        ; set new active process
2535   0FED FD 9D 05      shl a, 5                           ; x32
2536   0FF0 53 9D 1C      add a, proc_names
2537   0FF3 4F            mov di, a
2538   0FF4 FD 4D 1D 1F   mov si, user_data                  ; copy and store process filename
2539   0FF8 07 EF 10      call _strcpy
2540   0FFB               
2541   0FFB 07 F9 0E      call find_free_proc                ; index in A
2542   0FFE 3C            mov d, a
2543   0FFF 19 01         mov al, 1
2544   1001 3F 8D 1C      mov [d + proc_availab_table], al   ; make process busy
2545   1004               
2546   1004 1D C7 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2547   1007 7A            inc al
2548   1008 3D C7 17      mov [nbr_active_procs], al
2549   100B             ; launch process
2550   100B FD D7 FF FF   push word $FFFF 
2551   100F FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2552   1012 FD D7 00 04   push word text_org
2553   1016 06            sysret
2554   1017             
2555   1017             proc_table_convert:
2556   1017 4D 1B         .dw proc_state_table + 0
2557   1019 61 1B         .dw proc_state_table + 20
2558   101B 75 1B         .dw proc_state_table + 40
2559   101D 89 1B         .dw proc_state_table + 60
2560   101F 9D 1B         .dw proc_state_table + 80
2561   1021 B1 1B         .dw proc_state_table + 100
2562   1023 C5 1B         .dw proc_state_table + 120
2563   1025 D9 1B         .dw proc_state_table + 140
2564   1027               
2565   1027             ;----------------------------------------------------------------------------------------------;
2566   1027             ; GET HEX FILE
2567   1027             ; di = destination address
2568   1027             ; return length in bytes in C
2569   1027             ;----------------------------------------------------------------------------------------------;
2570   1027             _load_hex:
2571   1027 D7            push a
2572   1028 D8            push b
2573   1029 DA            push d
2574   102A E2            push si
2575   102B E3            push di
2576   102C 38 00 00      mov c, 0
2577   102F 50            mov a, di
2578   1030 3C            mov d, a          ; start of string data block
2579   1031 07 72 11      call _gets        ; get program string
2580   1034 4D            mov si, a
2581   1035             __load_hex_loop:
2582   1035 F6            lodsb             ; load from [SI] to AL
2583   1036 B9 00         cmp al, 0         ; check if ASCII 0
2584   1038 C6 46 10      jz __load_hex_ret
2585   103B 36            mov bh, al
2586   103C F6            lodsb
2587   103D 2F            mov bl, al
2588   103E 07 28 11      call _atoi        ; convert ASCII byte in B to int (to AL)
2589   1041 F7            stosb             ; store AL to [DI]
2590   1042 78            inc c
2591   1043 0A 35 10      jmp __load_hex_loop
2592   1046             __load_hex_ret:
2593   1046 F0            pop di
2594   1047 EF            pop si
2595   1048 E7            pop d
2596   1049 E5            pop b
2597   104A E4            pop a
2598   104B 09            ret
2599   104C             
2600   104C             ; synopsis: look inside a certain directory for files/directories
2601   104C             ; before calling this function, cd into required directory
2602   104C             ; for each entry inside directory:
2603   104C             ;  if entry is a file:
2604   104C             ;    compare filename to searched filename
2605   104C             ;    if filenames are the same, print filename
2606   104C             ;  else if entry is a directory:
2607   104C             ;    cd to the given directory
2608   104C             ;    recursively call cmd_find
2609   104C             ;    cd outside previous directory
2610   104C             ;  if current entry == last entry, return
2611   104C             ; endfor
2612   104C             f_find:
2613   104C 09            ret
2614   104D             
2615   104D             
2616   104D             ; ---------------------------------------------------------------------
2617   104D             ; kernel reset vector
2618   104D             ; ---------------------------------------------------------------------
2619   104D             kernel_reset_vector:  
2620   104D FD 49 FF F7   mov bp, STACK_BEGIN
2621   1051 FD 47 FF F7   mov sp, STACK_BEGIN
2622   1055               
2623   1055 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2624   1057 FD 0F         stomsk                        
2625   1059 FD 0C         sti  
2626   105B             
2627   105B 0C            lodstat
2628   105C 87 DF         and al, %11011111             ; disable display register loading
2629   105E 0D            stostat
2630   105F               
2631   105F             ; reset fifo pointers
2632   105F 10 1D 21      mov a, fifo
2633   1062 3B CD 17      mov d, fifo_in
2634   1065 43            mov [d], a
2635   1066 3B CF 17      mov d, fifo_out
2636   1069 43            mov [d], a  
2637   106A 19 02         mov al, 2
2638   106C 05 03         syscall sys_io                ; enable uart in interrupt mode
2639   106E               
2640   106E 3B 22 18      mov d, s_kernel_started
2641   1071 07 97 12      call _puts
2642   1074             
2643   1074 19 10         mov al, 16
2644   1076 05 04         syscall sys_filesystem        ; set root dirID
2645   1078             
2646   1078 3B 3F 18      mov d, s_prompt_init
2647   107B 07 97 12      call _puts
2648   107E 3B D3 17      mov d, s_init_path
2649   1081 05 05         syscall sys_create_proc       ; launch init as a new process
2650   1083             
2651   1083             
2652   1083             ; FILE INCLUDES
2653   1083             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  1083             BIOS_RESET_VECTOR .EQU  $01c0
0002+  1083             IDE_buffer       .EQU  $8204
0003+  1083             boot_origin      .EQU  $8004
0004+  1083             bios_uart        .EQU  $0002
0005+  1083             bios_ide         .EQU  $0003
2654   1083             .include "lib/stdio.asm"
0001+  1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1083             ; stdio.s
0003+  1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1083             .include "lib/string.asm"
0001++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1083             ; string.s
0003++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1083             
0005++ 1083             
0006++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1083             ; _strrev
0008++ 1083             ; reverse a string
0009++ 1083             ; D = string address
0010++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1083             ; 01234
0012++ 1083             _strrev:
0013++ 1083 4B          	pusha
0014++ 1084 07 CA 10    	call _strlen	; length in C
0015++ 1087 12          	mov a, c
0016++ 1088 AF 01 00    	cmp a, 1
0017++ 108B D0 A5 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 108E 7D          	dec a
0019++ 108F FD 4E       	mov si, d	; beginning of string
0020++ 1091 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1093 59          	add d, a	; end of string
0022++ 1094 12          	mov a, c
0023++ 1095 FD 9B       	shr a		; divide by 2
0024++ 1097 39          	mov c, a	; C now counts the steps
0025++ 1098             _strrev_L0:
0026++ 1098 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1099 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 109A 3E          	mov [d], al	; store left char into right side
0029++ 109B 1B          	mov al, bl
0030++ 109C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 109D 7E          	dec c
0032++ 109E 7F          	dec d
0033++ 109F C2 00 00    	cmp c, 0
0034++ 10A2 C7 98 10    	jne _strrev_L0
0035++ 10A5             _strrev_end:
0036++ 10A5 4C          	popa
0037++ 10A6 09          	ret
0038++ 10A7             	
0039++ 10A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10A7             ; _strchr
0041++ 10A7             ; search string in D for char in AL
0042++ 10A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10A7             _strchr:
0044++ 10A7             _strchr_L0:
0045++ 10A7 32          	mov bl, [d]
0046++ 10A8 C1 00       	cmp bl, 0
0047++ 10AA C6 B5 10    	je _strchr_end
0048++ 10AD BA          	cmp al, bl
0049++ 10AE C6 B5 10    	je _strchr_end
0050++ 10B1 79          	inc d
0051++ 10B2 0A A7 10    	jmp _strchr_L0
0052++ 10B5             _strchr_end:
0053++ 10B5 1B          	mov al, bl
0054++ 10B6 09          	ret
0055++ 10B7             
0056++ 10B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10B7             ; _strstr
0058++ 10B7             ; find sub-string
0059++ 10B7             ; str1 in SI
0060++ 10B7             ; str2 in DI
0061++ 10B7             ; SI points to end of source string
0062++ 10B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10B7             _strstr:
0064++ 10B7 DB          	push al
0065++ 10B8 DA          	push d
0066++ 10B9 E3          	push di
0067++ 10BA             _strstr_loop:
0068++ 10BA F3          	cmpsb					; compare a byte of the strings
0069++ 10BB C7 C6 10    	jne _strstr_ret
0070++ 10BE FC 00 00    	lea d, [di + 0]
0071++ 10C1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10C3 C7 BA 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10C6             _strstr_ret:
0074++ 10C6 F0          	pop di
0075++ 10C7 E7          	pop d
0076++ 10C8 E8          	pop al
0077++ 10C9 09          	ret
0078++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10CA             ; length of null terminated string
0080++ 10CA             ; result in C
0081++ 10CA             ; pointer in D
0082++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10CA             _strlen:
0084++ 10CA DA          	push d
0085++ 10CB 38 00 00    	mov c, 0
0086++ 10CE             _strlen_L1:
0087++ 10CE BD 00       	cmp byte [d], 0
0088++ 10D0 C6 D8 10    	je _strlen_ret
0089++ 10D3 79          	inc d
0090++ 10D4 78          	inc c
0091++ 10D5 0A CE 10    	jmp _strlen_L1
0092++ 10D8             _strlen_ret:
0093++ 10D8 E7          	pop d
0094++ 10D9 09          	ret
0095++ 10DA             
0096++ 10DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10DA             ; STRCMP
0098++ 10DA             ; compare two strings
0099++ 10DA             ; str1 in SI
0100++ 10DA             ; str2 in DI
0101++ 10DA             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10DA             _strcmp:
0104++ 10DA DB          	push al
0105++ 10DB DA          	push d
0106++ 10DC E3          	push di
0107++ 10DD E2          	push si
0108++ 10DE             _strcmp_loop:
0109++ 10DE F3          	cmpsb					; compare a byte of the strings
0110++ 10DF C7 EA 10    	jne _strcmp_ret
0111++ 10E2 FB FF FF    	lea d, [si +- 1]
0112++ 10E5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10E7 C7 DE 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10EA             _strcmp_ret:
0115++ 10EA EF          	pop si
0116++ 10EB F0          	pop di
0117++ 10EC E7          	pop d
0118++ 10ED E8          	pop al
0119++ 10EE 09          	ret
0120++ 10EF             
0121++ 10EF             
0122++ 10EF             ; STRCPY
0123++ 10EF             ; copy null terminated string from SI to DI
0124++ 10EF             ; source in SI
0125++ 10EF             ; destination in DI
0126++ 10EF             _strcpy:
0127++ 10EF E2          	push si
0128++ 10F0 E3          	push di
0129++ 10F1 DB          	push al
0130++ 10F2             _strcpy_L1:
0131++ 10F2 F6          	lodsb
0132++ 10F3 F7          	stosb
0133++ 10F4 B9 00       	cmp al, 0
0134++ 10F6 C7 F2 10    	jne _strcpy_L1
0135++ 10F9             _strcpy_end:
0136++ 10F9 E8          	pop al
0137++ 10FA F0          	pop di
0138++ 10FB EF          	pop si
0139++ 10FC 09          	ret
0140++ 10FD             
0141++ 10FD             ; STRCAT
0142++ 10FD             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10FD             ; source in SI
0144++ 10FD             ; destination in DI
0145++ 10FD             _strcat:
0146++ 10FD E2          	push si
0147++ 10FE E3          	push di
0148++ 10FF D7          	push a
0149++ 1100 DA          	push d
0150++ 1101 50          	mov a, di
0151++ 1102 3C          	mov d, a
0152++ 1103             _strcat_goto_end_L1:
0153++ 1103 BD 00       	cmp byte[d], 0
0154++ 1105 C6 0C 11    	je _strcat_start
0155++ 1108 79          	inc d
0156++ 1109 0A 03 11    	jmp _strcat_goto_end_L1
0157++ 110C             _strcat_start:
0158++ 110C FD 50       	mov di, d
0159++ 110E             _strcat_L1:
0160++ 110E F6          	lodsb
0161++ 110F F7          	stosb
0162++ 1110 B9 00       	cmp al, 0
0163++ 1112 C7 0E 11    	jne _strcat_L1
0164++ 1115             _strcat_end:
0165++ 1115 E7          	pop d
0166++ 1116 E4          	pop a
0167++ 1117 F0          	pop di
0168++ 1118 EF          	pop si
0169++ 1119 09          	ret
0170++ 111A             
0171++ 111A             
0005+  111A             
0006+  111A             
0007+  111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  111A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  111A             ; ASCII in BL
0010+  111A             ; result in AL
0011+  111A             ; ascii for F = 0100 0110
0012+  111A             ; ascii for 9 = 0011 1001
0013+  111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  111A             hex_ascii_encode:
0015+  111A 1B            mov al, bl
0016+  111B 93 40         test al, $40        ; test if letter or number
0017+  111D C7 23 11      jnz hex_letter
0018+  1120 87 0F         and al, $0F        ; get number
0019+  1122 09            ret
0020+  1123             hex_letter:
0021+  1123 87 0F         and al, $0F        ; get letter
0022+  1125 6A 09         add al, 9
0023+  1127 09            ret
0024+  1128             
0025+  1128             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1128             ; ATOI
0027+  1128             ; 2 letter hex string in B
0028+  1128             ; 8bit integer returned in AL
0029+  1128             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1128             _atoi:
0031+  1128 D8            push b
0032+  1129 07 1A 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  112C 30            mov bl, bh
0034+  112D DB            push al          ; save a
0035+  112E 07 1A 11      call hex_ascii_encode
0036+  1131 EA            pop bl  
0037+  1132 FD 9E 04      shl al, 4
0038+  1135 8C            or al, bl
0039+  1136 E5            pop b
0040+  1137 09            ret  
0041+  1138             
0042+  1138             
0043+  1138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1138             ; scanf
0045+  1138             ; no need for explanations!
0046+  1138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1138             scanf:
0048+  1138 09            ret
0049+  1139             
0050+  1139             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1139             ; ITOA
0052+  1139             ; 8bit value in BL
0053+  1139             ; 2 byte ASCII result in A
0054+  1139             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1139             _itoa:
0056+  1139 DA            push d
0057+  113A D8            push b
0058+  113B A7 00         mov bh, 0
0059+  113D FD A4 04      shr bl, 4  
0060+  1140 74            mov d, b
0061+  1141 1F D3 13      mov al, [d + s_hex_digits]
0062+  1144 23            mov ah, al
0063+  1145               
0064+  1145 E5            pop b
0065+  1146 D8            push b
0066+  1147 A7 00         mov bh, 0
0067+  1149 FD 87 0F      and bl, $0F
0068+  114C 74            mov d, b
0069+  114D 1F D3 13      mov al, [d + s_hex_digits]
0070+  1150 E5            pop b
0071+  1151 E7            pop d
0072+  1152 09            ret
0073+  1153             
0074+  1153             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1153             ; HEX STRING TO BINARY
0076+  1153             ; di = destination address
0077+  1153             ; si = source
0078+  1153             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1153             _hex_to_int:
0080+  1153             _hex_to_int_L1:
0081+  1153 F6            lodsb          ; load from [SI] to AL
0082+  1154 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1156 C6 63 11      jz _hex_to_int_ret
0084+  1159 36            mov bh, al
0085+  115A F6            lodsb
0086+  115B 2F            mov bl, al
0087+  115C 07 28 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  115F F7            stosb          ; store AL to [DI]
0089+  1160 0A 53 11      jmp _hex_to_int_L1
0090+  1163             _hex_to_int_ret:
0091+  1163 09            ret    
0092+  1164             
0093+  1164             
0094+  1164             
0095+  1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1164             ; GETCHAR
0097+  1164             ; char in ah
0098+  1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1164             getch:
0100+  1164 DB            push al
0101+  1165             getch_retry:
0102+  1165 19 01         mov al, 1
0103+  1167 05 03         syscall sys_io      ; receive in AH
0104+  1169 E8            pop al
0105+  116A 09            ret
0106+  116B             
0107+  116B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  116B             ; PUTCHAR
0109+  116B             ; char in ah
0110+  116B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  116B             _putchar:
0112+  116B DB            push al
0113+  116C 19 00         mov al, 0
0114+  116E 05 03         syscall sys_io      ; char in AH
0115+  1170 E8            pop al
0116+  1171 09            ret
0117+  1172             
0118+  1172             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1172             ;; INPUT A STRING
0120+  1172             ;; terminates with null
0121+  1172             ;; pointer in D
0122+  1172             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1172             _gets:
0124+  1172 D7            push a
0125+  1173 DA            push d
0126+  1174             _gets_loop:
0127+  1174 19 01         mov al, 1
0128+  1176 05 03         syscall sys_io      ; receive in AH
0129+  1178 76 1B         cmp ah, 27
0130+  117A C6 9B 11      je _gets_ansi_esc
0131+  117D 76 0A         cmp ah, $0A        ; LF
0132+  117F C6 F7 11      je _gets_end
0133+  1182 76 0D         cmp ah, $0D        ; CR
0134+  1184 C6 F7 11      je _gets_end
0135+  1187 76 5C         cmp ah, $5C        ; '\\'
0136+  1189 C6 BD 11      je _gets_escape
0137+  118C 76 08         cmp ah, $08      ; check for backspace
0138+  118E C6 97 11      je _gets_backspace
0139+  1191 1A            mov al, ah
0140+  1192 3E            mov [d], al
0141+  1193 79            inc d
0142+  1194 0A 74 11      jmp _gets_loop
0143+  1197             _gets_backspace:
0144+  1197 7F            dec d
0145+  1198 0A 74 11      jmp _gets_loop
0146+  119B             _gets_ansi_esc:
0147+  119B 19 01         mov al, 1
0148+  119D 05 03         syscall sys_io        ; receive in AH without echo
0149+  119F 76 5B         cmp ah, '['
0150+  11A1 C7 74 11      jne _gets_loop
0151+  11A4 19 01         mov al, 1
0152+  11A6 05 03         syscall sys_io          ; receive in AH without echo
0153+  11A8 76 44         cmp ah, 'D'
0154+  11AA C6 B5 11      je _gets_left_arrow
0155+  11AD 76 43         cmp ah, 'C'
0156+  11AF C6 B9 11      je _gets_right_arrow
0157+  11B2 0A 74 11      jmp _gets_loop
0158+  11B5             _gets_left_arrow:
0159+  11B5 7F            dec d
0160+  11B6 0A 74 11      jmp _gets_loop
0161+  11B9             _gets_right_arrow:
0162+  11B9 79            inc d
0163+  11BA 0A 74 11      jmp _gets_loop
0164+  11BD             _gets_escape:
0165+  11BD 19 01         mov al, 1
0166+  11BF 05 03         syscall sys_io      ; receive in AH
0167+  11C1 76 6E         cmp ah, 'n'
0168+  11C3 C6 E2 11      je _gets_LF
0169+  11C6 76 72         cmp ah, 'r'
0170+  11C8 C6 E9 11      je _gets_CR
0171+  11CB 76 30         cmp ah, '0'
0172+  11CD C6 F0 11      je _gets_NULL
0173+  11D0 76 5C         cmp ah, $5C  ; '\'
0174+  11D2 C6 DB 11      je _gets_slash
0175+  11D5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  11D6 3E            mov [d], al
0177+  11D7 79            inc d
0178+  11D8 0A 74 11      jmp _gets_loop
0179+  11DB             _gets_slash:
0180+  11DB 19 5C         mov al, $5C
0181+  11DD 3E            mov [d], al
0182+  11DE 79            inc d
0183+  11DF 0A 74 11      jmp _gets_loop
0184+  11E2             _gets_LF:
0185+  11E2 19 0A         mov al, $0A
0186+  11E4 3E            mov [d], al
0187+  11E5 79            inc d
0188+  11E6 0A 74 11      jmp _gets_loop
0189+  11E9             _gets_CR:
0190+  11E9 19 0D         mov al, $0D
0191+  11EB 3E            mov [d], al
0192+  11EC 79            inc d
0193+  11ED 0A 74 11      jmp _gets_loop
0194+  11F0             _gets_NULL:
0195+  11F0 19 00         mov al, $00
0196+  11F2 3E            mov [d], al
0197+  11F3 79            inc d
0198+  11F4 0A 74 11      jmp _gets_loop
0199+  11F7             _gets_end:
0200+  11F7 19 00         mov al, 0
0201+  11F9 3E            mov [d], al        ; terminate string
0202+  11FA E7            pop d
0203+  11FB E4            pop a
0204+  11FC 09            ret
0205+  11FD             
0206+  11FD             
0207+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11FD             ;; INPUT TEXT
0209+  11FD             ;; terminated with CTRL+D
0210+  11FD             ;; pointer in D
0211+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11FD             _gettxt:
0213+  11FD D7            push a
0214+  11FE DA            push d
0215+  11FF             _gettxt_loop:
0216+  11FF 19 01         mov al, 1
0217+  1201 05 03         syscall sys_io      ; receive in AH
0218+  1203 76 04         cmp ah, 4      ; EOT
0219+  1205 C6 3E 12      je _gettxt_end
0220+  1208 76 08         cmp ah, $08      ; check for backspace
0221+  120A C6 3A 12      je _gettxt_backspace
0222+  120D 76 5C         cmp ah, $5C        ; '\'
0223+  120F C6 18 12      je _gettxt_escape
0224+  1212 1A            mov al, ah
0225+  1213 3E            mov [d], al
0226+  1214 79            inc d
0227+  1215 0A FF 11      jmp _gettxt_loop
0228+  1218             _gettxt_escape:
0229+  1218 19 01         mov al, 1
0230+  121A 05 03         syscall sys_io      ; receive in AH
0231+  121C 76 6E         cmp ah, 'n'
0232+  121E C6 2C 12      je _gettxt_LF
0233+  1221 76 72         cmp ah, 'r'
0234+  1223 C6 33 12      je _gettxt_CR
0235+  1226 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1227 3E            mov [d], al
0237+  1228 79            inc d
0238+  1229 0A FF 11      jmp _gettxt_loop
0239+  122C             _gettxt_LF:
0240+  122C 19 0A         mov al, $0A
0241+  122E 3E            mov [d], al
0242+  122F 79            inc d
0243+  1230 0A FF 11      jmp _gettxt_loop
0244+  1233             _gettxt_CR:
0245+  1233 19 0D         mov al, $0D
0246+  1235 3E            mov [d], al
0247+  1236 79            inc d
0248+  1237 0A FF 11      jmp _gettxt_loop
0249+  123A             _gettxt_backspace:
0250+  123A 7F            dec d
0251+  123B 0A FF 11      jmp _gettxt_loop
0252+  123E             _gettxt_end:
0253+  123E 19 00         mov al, 0
0254+  1240 3E            mov [d], al        ; terminate string
0255+  1241 E7            pop d
0256+  1242 E4            pop a
0257+  1243 09            ret
0258+  1244             
0259+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1244             ; PRINT NEW LINE
0261+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1244             printnl:
0263+  1244 D7            push a
0264+  1245 10 00 0A      mov a, $0A00
0265+  1248 05 03         syscall sys_io
0266+  124A 10 00 0D      mov a, $0D00
0267+  124D 05 03         syscall sys_io
0268+  124F E4            pop a
0269+  1250 09            ret
0270+  1251             
0271+  1251             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1251             ; _strtoint
0273+  1251             ; 4 digit hex string number in d
0274+  1251             ; integer returned in A
0275+  1251             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1251             _strtointx:
0277+  1251 D8            push b
0278+  1252 32            mov bl, [d]
0279+  1253 37            mov bh, bl
0280+  1254 33 01 00      mov bl, [d + 1]
0281+  1257 07 28 11      call _atoi        ; convert to int in AL
0282+  125A 23            mov ah, al        ; move to AH
0283+  125B 33 02 00      mov bl, [d + 2]
0284+  125E 37            mov bh, bl
0285+  125F 33 03 00      mov bl, [d + 3]
0286+  1262 07 28 11      call _atoi        ; convert to int in AL
0287+  1265 E5            pop b
0288+  1266 09            ret
0289+  1267             
0290+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1267             ; _strtoint
0292+  1267             ; 5 digit base10 string number in d
0293+  1267             ; integer returned in A
0294+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1267             _strtoint:
0296+  1267 E2            push si
0297+  1268 D8            push b
0298+  1269 D9            push c
0299+  126A DA            push d
0300+  126B 07 CA 10      call _strlen      ; get string length in C
0301+  126E 7E            dec c
0302+  126F FD 4E         mov si, d
0303+  1271 12            mov a, c
0304+  1272 FD 99         shl a
0305+  1274 3B EB 13      mov d, table_power
0306+  1277 59            add d, a
0307+  1278 38 00 00      mov c, 0
0308+  127B             _strtoint_L0:
0309+  127B F6            lodsb      ; load ASCII to al
0310+  127C B9 00         cmp al, 0
0311+  127E C6 91 12      je _strtoint_end
0312+  1281 6F 30         sub al, $30    ; make into integer
0313+  1283 22 00         mov ah, 0
0314+  1285 2A            mov b, [d]
0315+  1286 AC            mul a, b      ; result in B since it fits in 16bits
0316+  1287 11            mov a, b
0317+  1288 28            mov b, c
0318+  1289 54            add a, b
0319+  128A 39            mov c, a
0320+  128B 63 02 00      sub d, 2
0321+  128E 0A 7B 12      jmp _strtoint_L0
0322+  1291             _strtoint_end:
0323+  1291 12            mov a, c
0324+  1292 E7            pop d
0325+  1293 E6            pop c
0326+  1294 E5            pop b
0327+  1295 EF            pop si
0328+  1296 09            ret
0329+  1297             
0330+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1297             ; PRINT NULL TERMINATED STRING
0332+  1297             ; pointer in D
0333+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1297             _puts:
0335+  1297 D7            push a
0336+  1298 DA            push d
0337+  1299             _puts_L1:
0338+  1299 1E            mov al, [d]
0339+  129A B9 00         cmp al, 0
0340+  129C C6 A8 12      jz _puts_END
0341+  129F 23            mov ah, al
0342+  12A0 19 00         mov al, 0
0343+  12A2 05 03         syscall sys_io
0344+  12A4 79            inc d
0345+  12A5 0A 99 12      jmp _puts_L1
0346+  12A8             _puts_END:
0347+  12A8 E7            pop d
0348+  12A9 E4            pop a
0349+  12AA 09            ret
0350+  12AB             
0351+  12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12AB             ; PRINT N SIZE STRING
0353+  12AB             ; pointer in D
0354+  12AB             ; size in C
0355+  12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12AB             _putsn:
0357+  12AB DB            push al
0358+  12AC DA            push d
0359+  12AD D9            push c
0360+  12AE             _putsn_L0:
0361+  12AE 1E            mov al, [d]
0362+  12AF 23            mov ah, al
0363+  12B0 19 00         mov al, 0
0364+  12B2 05 03         syscall sys_io
0365+  12B4 79            inc d
0366+  12B5 7E            dec c  
0367+  12B6 C2 00 00      cmp c, 0
0368+  12B9 C7 AE 12      jne _putsn_L0
0369+  12BC             _putsn_end:
0370+  12BC E6            pop c
0371+  12BD E7            pop d
0372+  12BE E8            pop al
0373+  12BF 09            ret
0374+  12C0             
0375+  12C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  12C0             ; print 16bit decimal number
0377+  12C0             ; input number in A
0378+  12C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  12C0             print_u16d:
0380+  12C0 D7            push a
0381+  12C1 D8            push b
0382+  12C2 FD D8         push g
0383+  12C4 26 10 27      mov b, 10000
0384+  12C7 AE            div a, b      ; get 10000's coeff.
0385+  12C8 07 EC 12      call print_number
0386+  12CB 11            mov a, b
0387+  12CC 26 E8 03      mov b, 1000
0388+  12CF AE            div a, b      ; get 1000's coeff.
0389+  12D0 07 EC 12      call print_number
0390+  12D3 11            mov a, b
0391+  12D4 26 64 00      mov b, 100
0392+  12D7 AE            div a, b
0393+  12D8 07 EC 12      call print_number
0394+  12DB 11            mov a, b
0395+  12DC 26 0A 00      mov b, 10
0396+  12DF AE            div a, b
0397+  12E0 07 EC 12      call print_number
0398+  12E3 1B            mov al, bl      ; 1's coeff in bl
0399+  12E4 07 EC 12      call print_number
0400+  12E7 FD F1         pop g
0401+  12E9 E5            pop b
0402+  12EA E4            pop a
0403+  12EB 09            ret
0404+  12EC             
0405+  12EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12EC             ; print AL
0407+  12EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12EC             print_number:
0409+  12EC 6A 30         add al, $30
0410+  12EE 23            mov ah, al
0411+  12EF 07 6B 11      call _putchar
0412+  12F2 09            ret
0413+  12F3             
0414+  12F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12F3             ; PRINT 16BIT HEX INTEGER
0416+  12F3             ; integer value in reg B
0417+  12F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12F3             print_u16x:
0419+  12F3 D7            push a
0420+  12F4 D8            push b
0421+  12F5 DD            push bl
0422+  12F6 30            mov bl, bh
0423+  12F7 07 39 11      call _itoa        ; convert bh to char in A
0424+  12FA 2F            mov bl, al        ; save al
0425+  12FB 19 00         mov al, 0
0426+  12FD 05 03         syscall sys_io        ; display AH
0427+  12FF 24            mov ah, bl        ; retrieve al
0428+  1300 19 00         mov al, 0
0429+  1302 05 03         syscall sys_io        ; display AL
0430+  1304             
0431+  1304 EA            pop bl
0432+  1305 07 39 11      call _itoa        ; convert bh to char in A
0433+  1308 2F            mov bl, al        ; save al
0434+  1309 19 00         mov al, 0
0435+  130B 05 03         syscall sys_io        ; display AH
0436+  130D 24            mov ah, bl        ; retrieve al
0437+  130E 19 00         mov al, 0
0438+  1310 05 03         syscall sys_io        ; display AL
0439+  1312             
0440+  1312 E5            pop b
0441+  1313 E4            pop a
0442+  1314 09            ret
0443+  1315             
0444+  1315             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1315             ; INPUT 16BIT HEX INTEGER
0446+  1315             ; read 16bit integer into A
0447+  1315             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1315             scan_u16x:
0449+  1315 F8 10 00      enter 16
0450+  1318 D8            push b
0451+  1319 DA            push d
0452+  131A             
0453+  131A FA F1 FF      lea d, [bp + -15]
0454+  131D 07 72 11      call _gets        ; get number
0455+  1320             
0456+  1320 32            mov bl, [d]
0457+  1321 37            mov bh, bl
0458+  1322 33 01 00      mov bl, [d + 1]
0459+  1325 07 28 11      call _atoi        ; convert to int in AL
0460+  1328 23            mov ah, al        ; move to AH
0461+  1329             
0462+  1329 33 02 00      mov bl, [d + 2]
0463+  132C 37            mov bh, bl
0464+  132D 33 03 00      mov bl, [d + 3]
0465+  1330 07 28 11      call _atoi        ; convert to int in AL
0466+  1333             
0467+  1333 E7            pop d
0468+  1334 E5            pop b
0469+  1335 F9            leave
0470+  1336 09            ret
0471+  1337             
0472+  1337             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1337             ; PRINT 8bit HEX INTEGER
0474+  1337             ; integer value in reg bl
0475+  1337             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1337             print_u8x:
0477+  1337 D7            push a
0478+  1338 DD            push bl
0479+  1339             
0480+  1339 07 39 11      call _itoa        ; convert bl to char in A
0481+  133C 2F            mov bl, al        ; save al
0482+  133D 19 00         mov al, 0
0483+  133F 05 03         syscall sys_io        ; display AH
0484+  1341 24            mov ah, bl        ; retrieve al
0485+  1342 19 00         mov al, 0
0486+  1344 05 03         syscall sys_io        ; display AL
0487+  1346             
0488+  1346 EA            pop bl
0489+  1347 E4            pop a
0490+  1348 09            ret
0491+  1349             
0492+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1349             ; print 8bit decimal unsigned number
0494+  1349             ; input number in AL
0495+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1349             print_u8d:
0497+  1349 D7            push a
0498+  134A D8            push b
0499+  134B FD D8         push g
0500+  134D 22 00         mov ah, 0
0501+  134F 26 64 00      mov b, 100
0502+  1352 AE            div a, b
0503+  1353 D8            push b      ; save remainder
0504+  1354 B9 00         cmp al, 0
0505+  1356 C6 60 13      je skip100
0506+  1359 6A 30         add al, $30
0507+  135B 23            mov ah, al
0508+  135C 19 00         mov al, 0
0509+  135E 05 03         syscall sys_io  ; print coeff
0510+  1360             skip100:
0511+  1360 E4            pop a
0512+  1361 22 00         mov ah, 0
0513+  1363 26 0A 00      mov b, 10
0514+  1366 AE            div a, b
0515+  1367 D8            push b      ; save remainder
0516+  1368 B9 00         cmp al, 0
0517+  136A C6 74 13      je skip10
0518+  136D 6A 30         add al, $30
0519+  136F 23            mov ah, al
0520+  1370 19 00         mov al, 0
0521+  1372 05 03         syscall sys_io  ; print coeff
0522+  1374             skip10:
0523+  1374 E4            pop a
0524+  1375 1B            mov al, bl
0525+  1376 6A 30         add al, $30
0526+  1378 23            mov ah, al
0527+  1379 19 00         mov al, 0
0528+  137B 05 03         syscall sys_io  ; print coeff
0529+  137D FD F1         pop g
0530+  137F E5            pop b
0531+  1380 E4            pop a
0532+  1381 09            ret
0533+  1382             
0534+  1382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1382             ; INPUT 8BIT HEX INTEGER
0536+  1382             ; read 8bit integer into AL
0537+  1382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1382             scan_u8x:
0539+  1382 F8 04 00      enter 4
0540+  1385 D8            push b
0541+  1386 DA            push d
0542+  1387             
0543+  1387 FA FD FF      lea d, [bp + -3]
0544+  138A 07 72 11      call _gets        ; get number
0545+  138D             
0546+  138D 32            mov bl, [d]
0547+  138E 37            mov bh, bl
0548+  138F 33 01 00      mov bl, [d + 1]
0549+  1392 07 28 11      call _atoi        ; convert to int in AL
0550+  1395             
0551+  1395 E7            pop d
0552+  1396 E5            pop b
0553+  1397 F9            leave
0554+  1398 09            ret
0555+  1399             
0556+  1399             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1399             ; input decimal number
0558+  1399             ; result in A
0559+  1399             ; 655'\0'
0560+  1399             ; low--------high
0561+  1399             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1399             scan_u16d:
0563+  1399 F8 08 00      enter 8
0564+  139C E2            push si
0565+  139D D8            push b
0566+  139E D9            push c
0567+  139F DA            push d
0568+  13A0 FA F9 FF      lea d, [bp +- 7]
0569+  13A3 07 72 11      call _gets
0570+  13A6 07 CA 10      call _strlen      ; get string length in C
0571+  13A9 7E            dec c
0572+  13AA FD 4E         mov si, d
0573+  13AC 12            mov a, c
0574+  13AD FD 99         shl a
0575+  13AF 3B EB 13      mov d, table_power
0576+  13B2 59            add d, a
0577+  13B3 38 00 00      mov c, 0
0578+  13B6             mul_loop:
0579+  13B6 F6            lodsb      ; load ASCII to al
0580+  13B7 B9 00         cmp al, 0
0581+  13B9 C6 CC 13      je mul_exit
0582+  13BC 6F 30         sub al, $30    ; make into integer
0583+  13BE 22 00         mov ah, 0
0584+  13C0 2A            mov b, [d]
0585+  13C1 AC            mul a, b      ; result in B since it fits in 16bits
0586+  13C2 11            mov a, b
0587+  13C3 28            mov b, c
0588+  13C4 54            add a, b
0589+  13C5 39            mov c, a
0590+  13C6 63 02 00      sub d, 2
0591+  13C9 0A B6 13      jmp mul_loop
0592+  13CC             mul_exit:
0593+  13CC 12            mov a, c
0594+  13CD E7            pop d
0595+  13CE E6            pop c
0596+  13CF E5            pop b
0597+  13D0 EF            pop si
0598+  13D1 F9            leave
0599+  13D2 09            ret
0600+  13D3             
0601+  13D3             
0602+  13D3 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  13D7 34 35 36 37 
0602+  13DB 38 39 41 42 
0602+  13DF 43 44 45 46 
0603+  13E3 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  13E7 1B 5B 48 00 
0604+  13EB             
0605+  13EB             table_power:
0606+  13EB 01 00         .dw 1
0607+  13ED 0A 00         .dw 10
0608+  13EF 64 00         .dw 100
0609+  13F1 E8 03         .dw 1000
0610+  13F3 10 27         .dw 100002655   13F5             .include "lib/ctype.asm"
0001+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13F5             ; ctype.s
0003+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13F5             
0005+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13F5             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  13F5             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  13F5             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  13F5             ;; characters are supported.
0010+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13F5             ;; _isalnum 
0012+  13F5             ;; _isalpha 
0013+  13F5             ;; islower 
0014+  13F5             ;; isupper 
0015+  13F5             ;; _isdigit 
0016+  13F5             ;; isxdigit
0017+  13F5             ;; iscntrl 
0018+  13F5             ;; isgraph 
0019+  13F5             ;; _isspace 
0020+  13F5             ;; isblank 
0021+  13F5             ;; isprint 
0022+  13F5             ;; ispunct 
0023+  13F5             ;; tolower 
0024+  13F5             ;; toupper
0025+  13F5             
0026+  13F5             
0027+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13F5             ;; IS ALPHANUMERIC
0029+  13F5             ;; sets ZF according with result
0030+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13F5             _isalnum:
0032+  13F5 07 12 14    	call _isalpha
0033+  13F8 C6 FE 13    	je _isalnum_exit
0034+  13FB 07 FF 13    	call _isdigit
0035+  13FE             _isalnum_exit:
0036+  13FE 09          	ret	
0037+  13FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13FF             ;; IS DIGIT
0039+  13FF             ;; sets ZF according with result
0040+  13FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13FF             _isdigit:
0042+  13FF DB          	push al
0043+  1400 B9 30       	cmp al, '0'
0044+  1402 C8 0E 14    	jlu _isdigit_false
0045+  1405 B9 39       	cmp al, '9'
0046+  1407 D1 0E 14    	jgu _isdigit_false
0047+  140A 87 00       	and al, 0	; set ZF
0048+  140C E8          	pop al
0049+  140D 09          	ret
0050+  140E             _isdigit_false:
0051+  140E 8B 01       	or al, 1	; clear ZF
0052+  1410 E8          	pop al
0053+  1411 09          	ret	
0054+  1412             	
0055+  1412             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1412             ;; IS ALPHA
0057+  1412             ;; sets ZF according with result
0058+  1412             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1412             _isalpha:
0060+  1412 DB          	push al
0061+  1413 B9 5F       	cmp al, '_'
0062+  1415 C6 35 14    	je _isalpha_true
0063+  1418 B9 2E       	cmp al, '.'
0064+  141A C6 35 14    	je _isalpha_true
0065+  141D B9 41       	cmp al, 'A'
0066+  141F C8 31 14    	jlu _isalpha_false
0067+  1422 B9 7A       	cmp al, 'z'
0068+  1424 D1 31 14    	jgu _isalpha_false
0069+  1427 B9 5A       	cmp al, 'Z'
0070+  1429 D0 35 14    	jleu _isalpha_true
0071+  142C B9 61       	cmp al, 'a'
0072+  142E C9 35 14    	jgeu _isalpha_true
0073+  1431             _isalpha_false:
0074+  1431 8B 01       	or al, 1	; clear ZF
0075+  1433 E8          	pop al
0076+  1434 09          	ret
0077+  1435             _isalpha_true:
0078+  1435 87 00       	and al, 0	; set ZF
0079+  1437 E8          	pop al
0080+  1438 09          	ret
0081+  1439             
0082+  1439             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1439             ;; IS PATH-ALPHA
0084+  1439             ;; sets ZF according with result
0085+  1439             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1439             ispath:
0087+  1439 DB          	push al
0088+  143A 07 FF 13    	call _isdigit
0089+  143D C6 67 14    	je ispath_true
0090+  1440 B9 5F       	cmp al, '_'
0091+  1442 C6 67 14    	je ispath_true
0092+  1445 B9 2F       	cmp al, '/'
0093+  1447 C6 67 14    	je ispath_true
0094+  144A B9 2E       	cmp al, '.'
0095+  144C C6 67 14    	je ispath_true
0096+  144F B9 41       	cmp al, 'A'
0097+  1451 C8 63 14    	jlu ispath_false
0098+  1454 B9 7A       	cmp al, 'z'
0099+  1456 D1 63 14    	jgu ispath_false
0100+  1459 B9 5A       	cmp al, 'Z'
0101+  145B D0 67 14    	jleu ispath_true
0102+  145E B9 61       	cmp al, 'a'
0103+  1460 C9 67 14    	jgeu ispath_true
0104+  1463             ispath_false:
0105+  1463 8B 01       	or al, 1	; clear ZF
0106+  1465 E8          	pop al
0107+  1466 09          	ret
0108+  1467             ispath_true:
0109+  1467 87 00       	and al, 0	; set ZF
0110+  1469 E8          	pop al
0111+  146A 09          	ret
0112+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  146B             ;; IS SPACE
0114+  146B             ;; sets ZF according with result
0115+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  146B             _isspace:
0117+  146B B9 20       	cmp al, $20		; ' '
0118+  146D C6 81 14    	je _isspace_exit
0119+  1470 B9 09       	cmp al, $09		; '\t'
0120+  1472 C6 81 14    	je _isspace_exit
0121+  1475 B9 0A       	cmp al, $0A		; '\n'
0122+  1477 C6 81 14    	je _isspace_exit
0123+  147A B9 0D       	cmp al, $0D		; '\r'
0124+  147C C6 81 14    	je _isspace_exit
0125+  147F B9 0B       	cmp al, $0B		; '\v'
0126+  1481             _isspace_exit:
0127+  1481 09          	ret	
0128+  1482             
0129+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1482             ; TO LOWER
0131+  1482             ; input in AL
0132+  1482             ; output in AL
0133+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1482             _to_lower:
0135+  1482 B9 5A       	cmp al, 'Z'
0136+  1484 D1 89 14    	jgu _to_lower_ret
0137+  1487 6A 20       	add al, $20				; convert to lower case
0138+  1489             _to_lower_ret:
0139+  1489 09          	ret
0140+  148A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  148A             ; TO UPPER
0142+  148A             ; input in AL
0143+  148A             ; output in AL
0144+  148A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  148A             _to_upper:
0146+  148A B9 61       	cmp al, 'a'
0147+  148C C8 91 14    	jlu _to_upper_ret
0148+  148F 6F 20       	sub al, $20			; convert to upper case
0149+  1491             _to_upper_ret:
0150+  1491 09          	ret
0151+  1492             
2656   1492             .include "lib/token.asm"
0001+  1492             TOKTYP_IDENTIFIER  .equ 0
0002+  1492             TOKTYP_KEYWORD     .equ 1
0003+  1492             TOKTYP_DELIMITER   .equ 2
0004+  1492             TOKTYP_STRING      .equ 3
0005+  1492             TOKTYP_CHAR        .equ 4
0006+  1492             TOKTYP_NUMERIC     .equ 5
0007+  1492             TOKTYP_END         .equ 6
0008+  1492             
0009+  1492             TOK_NULL           .equ 0
0010+  1492             TOK_FSLASH         .equ 1
0011+  1492             TOK_TIMES          .equ 2
0012+  1492             TOK_PLUS           .equ 3
0013+  1492             TOK_MINUS          .equ 4
0014+  1492             TOK_DOT            .equ 5
0015+  1492             TOK_SEMI           .equ 6
0016+  1492             TOK_ANGLE          .equ 7
0017+  1492             TOK_TILDE          .equ 8
0018+  1492             TOK_EQUAL          .equ 9
0019+  1492             TOK_COLON          .equ 10
0020+  1492             TOK_COMMA          .equ 11
0021+  1492             
0022+  1492             TOK_END            .equ 20
0023+  1492             
0024+  1492             
0025+  1492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1492             ;; read a full command argment from shell input buffer
0027+  1492             ;; argument is written into tokstr
0028+  1492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1492             get_arg:
0030+  1492 D7            push a
0031+  1493 E2            push si
0032+  1494 E3            push di
0033+  1495 19 00         mov al, 0
0034+  1497 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0035+  149A 14 BC 16      mov a, [prog]
0036+  149D 4D            mov si, a
0037+  149E FD 4F C0 16   mov di, tokstr
0038+  14A2             get_arg_skip_spaces:
0039+  14A2 F6            lodsb
0040+  14A3 07 6B 14      call _isspace
0041+  14A6 C6 A2 14      je get_arg_skip_spaces
0042+  14A9             get_arg_L0:
0043+  14A9 B9 3B         cmp al, $3B        ; check if is ';'
0044+  14AB C6 B8 14      je get_arg_end
0045+  14AE B9 00         cmp al, 0
0046+  14B0 C6 B8 14      je get_arg_end      ; check if end of input
0047+  14B3 F7            stosb
0048+  14B4 F6            lodsb
0049+  14B5 0A A9 14      jmp get_arg_L0
0050+  14B8             get_arg_end:
0051+  14B8 19 00         mov al, 0
0052+  14BA F7            stosb
0053+  14BB D5 01 00      sub si, 1
0054+  14BE 4E            mov a, si
0055+  14BF 42 BC 16      mov [prog], a    ; update pointer
0056+  14C2 F0            pop di
0057+  14C3 EF            pop si
0058+  14C4 E4            pop a
0059+  14C5 09            ret
0060+  14C6             
0061+  14C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  14C6             ;; read a path formation from shell input buffer
0063+  14C6             ;; path is written into tokstr
0064+  14C6             ;; /usr/bin
0065+  14C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  14C6             get_path:
0067+  14C6 D7            push a
0068+  14C7 E2            push si
0069+  14C8 E3            push di
0070+  14C9 19 00         mov al, 0
0071+  14CB 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0072+  14CE 14 BC 16      mov a, [prog]
0073+  14D1 4D            mov si, a
0074+  14D2 FD 4F C0 16   mov di, tokstr
0075+  14D6             get_path_skip_spaces:
0076+  14D6 F6            lodsb
0077+  14D7 07 6B 14      call _isspace
0078+  14DA C6 D6 14      je get_path_skip_spaces
0079+  14DD             get_path_is_pathchar:
0080+  14DD F7            stosb
0081+  14DE F6            lodsb
0082+  14DF 07 F5 13      call _isalnum      ;check if is alphanumeric
0083+  14E2 C6 DD 14      je get_path_is_pathchar
0084+  14E5 B9 2F         cmp al, '/'        ; check if is '/'
0085+  14E7 C6 DD 14      je get_path_is_pathchar
0086+  14EA 19 00         mov al, 0
0087+  14EC F7            stosb
0088+  14ED D5 01 00      sub si, 1
0089+  14F0 4E            mov a, si
0090+  14F1 42 BC 16      mov [prog], a    ; update pointer
0091+  14F4             get_path_end:
0092+  14F4 F0            pop di
0093+  14F5 EF            pop si
0094+  14F6 E4            pop a
0095+  14F7 09            ret
0096+  14F8             
0097+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14F8             ;; read a line
0099+  14F8             ;; line is written into tokstr
0100+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14F8             get_line:
0102+  14F8 D7            push a
0103+  14F9 E2            push si
0104+  14FA E3            push di
0105+  14FB 19 00         mov al, 0
0106+  14FD 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0107+  1500 14 BC 16      mov a, [prog]
0108+  1503 4D            mov si, a
0109+  1504 FD 4F C0 16   mov di, tokstr
0110+  1508             get_line_L0:
0111+  1508 F6            lodsb
0112+  1509 B9 0A         cmp al, $0A    ; check for new line
0113+  150B C6 12 15      je get_line_exit
0114+  150E F7            stosb
0115+  150F 0A 08 15      jmp get_line_L0
0116+  1512             get_line_exit:
0117+  1512 19 00         mov al, 0
0118+  1514 F7            stosb
0119+  1515 4E            mov a, si
0120+  1516 42 BC 16      mov [prog], a    ; update pointer
0121+  1519 F0            pop di
0122+  151A EF            pop si
0123+  151B E4            pop a
0124+  151C 09            ret
0125+  151D             
0126+  151D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  151D             ;; token parser
0128+  151D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  151D             get_token:
0130+  151D D7            push a
0131+  151E DA            push d
0132+  151F E2            push si
0133+  1520 E3            push di
0134+  1521 19 00         mov al, 0
0135+  1523 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0136+  1526 19 00         mov al, TOK_NULL
0137+  1528 3D BF 16      mov [tok], al        ; nullify token
0138+  152B 14 BC 16      mov a, [prog]
0139+  152E 4D            mov si, a
0140+  152F FD 4F C0 16   mov di, tokstr
0141+  1533             get_tok_skip_spaces:
0142+  1533 F6            lodsb
0143+  1534 07 6B 14      call _isspace
0144+  1537 C6 33 15      je get_tok_skip_spaces
0145+  153A B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  153C C6 21 16      je get_token_end
0147+  153F B9 23         cmp al, '#'      ; comments!
0148+  1541 C6 4F 16      je get_tok_comment
0149+  1544 07 F5 13      call _isalnum
0150+  1547 C6 2E 16      jz is_alphanumeric
0151+  154A             ; other token types
0152+  154A             get_token_slash:
0153+  154A B9 2F         cmp al, '/'        ; check if '/'
0154+  154C C7 64 15      jne get_token_minus
0155+  154F F7            stosb          ; store '/' into token string
0156+  1550 19 00         mov al, 0
0157+  1552 F7            stosb          ; terminate token string
0158+  1553 19 01         mov al, TOK_FSLASH
0159+  1555 3D BF 16      mov [tok], al      
0160+  1558 19 02         mov al, TOKTYP_DELIMITER
0161+  155A 3D BE 16      mov [toktyp], al
0162+  155D 4E            mov a, si
0163+  155E 42 BC 16      mov [prog], a    ; update pointer
0164+  1561 0A 4A 16      jmp get_token_return
0165+  1564             get_token_minus:
0166+  1564 B9 2D         cmp al, '-'        ; check if '-'
0167+  1566 C7 7E 15      jne get_token_comma
0168+  1569 F7            stosb          ; store '-' into token string
0169+  156A 19 00         mov al, 0
0170+  156C F7            stosb          ; terminate token string
0171+  156D 19 04         mov al, TOK_MINUS
0172+  156F 3D BF 16      mov [tok], al      
0173+  1572 19 02         mov al, TOKTYP_DELIMITER
0174+  1574 3D BE 16      mov [toktyp], al
0175+  1577 4E            mov a, si
0176+  1578 42 BC 16      mov [prog], a    ; update pointer
0177+  157B 0A 4A 16      jmp get_token_return
0178+  157E             get_token_comma:
0179+  157E B9 2C         cmp al, ','        ; check if ','
0180+  1580 C7 98 15      jne get_token_semi
0181+  1583 F7            stosb          ; store ',' into token string
0182+  1584 19 00         mov al, 0
0183+  1586 F7            stosb          ; terminate token string
0184+  1587 19 0B         mov al, TOK_COMMA
0185+  1589 3D BF 16      mov [tok], al      
0186+  158C 19 02         mov al, TOKTYP_DELIMITER
0187+  158E 3D BE 16      mov [toktyp], al
0188+  1591 4E            mov a, si
0189+  1592 42 BC 16      mov [prog], a    ; update pointer
0190+  1595 0A 4A 16      jmp get_token_return
0191+  1598             get_token_semi:
0192+  1598 B9 3B         cmp al, $3B        ; check if ';'
0193+  159A C7 B2 15      jne get_token_colon
0194+  159D F7            stosb          ; store ';' into token string
0195+  159E 19 00         mov al, 0
0196+  15A0 F7            stosb          ; terminate token string
0197+  15A1 19 06         mov al, TOK_SEMI
0198+  15A3 3D BF 16      mov [tok], al      
0199+  15A6 19 02         mov al, TOKTYP_DELIMITER
0200+  15A8 3D BE 16      mov [toktyp], al
0201+  15AB 4E            mov a, si
0202+  15AC 42 BC 16      mov [prog], a    ; update pointer
0203+  15AF 0A 4A 16      jmp get_token_return
0204+  15B2             get_token_colon:
0205+  15B2 B9 3A         cmp al, $3A        ; check if ':'
0206+  15B4 C7 CC 15      jne get_token_angle
0207+  15B7 F7            stosb          ; store ':' into token string
0208+  15B8 19 00         mov al, 0
0209+  15BA F7            stosb          ; terminate token string
0210+  15BB 19 0A         mov al, TOK_COLON
0211+  15BD 3D BF 16      mov [tok], al      
0212+  15C0 19 02         mov al, TOKTYP_DELIMITER
0213+  15C2 3D BE 16      mov [toktyp], al
0214+  15C5 4E            mov a, si
0215+  15C6 42 BC 16      mov [prog], a    ; update pointer
0216+  15C9 0A 4A 16      jmp get_token_return
0217+  15CC             get_token_angle:
0218+  15CC B9 3E         cmp al, $3E        ; check if '>'
0219+  15CE C7 E6 15      jne get_token_tilde
0220+  15D1 F7            stosb          ; store '>' into token string
0221+  15D2 19 00         mov al, 0
0222+  15D4 F7            stosb          ; terminate token string
0223+  15D5 19 07         mov al, TOK_ANGLE
0224+  15D7 3D BF 16      mov [tok], al      
0225+  15DA 19 02         mov al, TOKTYP_DELIMITER
0226+  15DC 3D BE 16      mov [toktyp], al
0227+  15DF 4E            mov a, si
0228+  15E0 42 BC 16      mov [prog], a    ; update pointer
0229+  15E3 0A 4A 16      jmp get_token_return
0230+  15E6             get_token_tilde:
0231+  15E6 B9 7E         cmp al, '~'        ; check if '~'
0232+  15E8 C7 00 16      jne get_token_equal
0233+  15EB F7            stosb          ; store '~' into token string
0234+  15EC 19 00         mov al, 0
0235+  15EE F7            stosb          ; terminate token string
0236+  15EF 19 08         mov al, TOK_TILDE
0237+  15F1 3D BF 16      mov [tok], al      
0238+  15F4 19 02         mov al, TOKTYP_DELIMITER
0239+  15F6 3D BE 16      mov [toktyp], al
0240+  15F9 4E            mov a, si
0241+  15FA 42 BC 16      mov [prog], a    ; update pointer
0242+  15FD 0A 4A 16      jmp get_token_return
0243+  1600             get_token_equal:
0244+  1600 B9 3D         cmp al, '='        ; check if '='
0245+  1602 C7 1A 16      jne get_token_skip
0246+  1605 F7            stosb          ; store '=' into token string
0247+  1606 19 00         mov al, 0
0248+  1608 F7            stosb          ; terminate token string
0249+  1609 19 09         mov al, TOK_EQUAL
0250+  160B 3D BF 16      mov [tok], al      
0251+  160E 19 02         mov al, TOKTYP_DELIMITER
0252+  1610 3D BE 16      mov [toktyp], al
0253+  1613 4E            mov a, si
0254+  1614 42 BC 16      mov [prog], a    ; update pointer
0255+  1617 0A 4A 16      jmp get_token_return
0256+  161A             get_token_skip:
0257+  161A 4E            mov a, si
0258+  161B 42 BC 16      mov [prog], a    ; update pointer
0259+  161E 0A 4A 16      jmp get_token_return
0260+  1621             get_token_end:        ; end of file token
0261+  1621 19 14         mov al, TOK_END
0262+  1623 3D BF 16      mov [tok], al
0263+  1626 19 06         mov al, TOKTYP_END
0264+  1628 3D BE 16      mov [toktyp], al
0265+  162B 0A 4A 16      jmp get_token_return
0266+  162E             is_alphanumeric:
0267+  162E F7            stosb
0268+  162F F6            lodsb
0269+  1630 07 F5 13      call _isalnum      ;check if is alphanumeric
0270+  1633 C6 2E 16      jz is_alphanumeric
0271+  1636 B9 2E         cmp al, $2E        ; check if is '.'
0272+  1638 C6 2E 16      je is_alphanumeric
0273+  163B 19 00         mov al, 0
0274+  163D F7            stosb
0275+  163E 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1640 3D BE 16      mov [toktyp], al
0277+  1643 D5 01 00      sub si, 1
0278+  1646 4E            mov a, si
0279+  1647 42 BC 16      mov [prog], a    ; update pointer
0280+  164A             get_token_return:
0281+  164A F0            pop di
0282+  164B EF            pop si
0283+  164C E7            pop d
0284+  164D E4            pop a
0285+  164E 09            ret
0286+  164F             get_tok_comment:
0287+  164F F6            lodsb
0288+  1650 B9 0A         cmp al, $0A      ; new line
0289+  1652 C7 4F 16      jne get_tok_comment
0290+  1655 0A 33 15      jmp get_tok_skip_spaces
0291+  1658             
0292+  1658             
0293+  1658             get_number:
0294+  1658 D7            push a
0295+  1659 DA            push d
0296+  165A E2            push si
0297+  165B E3            push di
0298+  165C 19 00         mov al, 0
0299+  165E 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0300+  1661 19 00         mov al, TOK_NULL
0301+  1663 3D BF 16      mov [tok], al        ; nullify token
0302+  1666 14 BC 16      mov a, [prog]
0303+  1669 4D            mov si, a
0304+  166A FD 4F C0 16   mov di, tokstr
0305+  166E             get_number_skip_spaces:
0306+  166E F6            lodsb
0307+  166F 07 6B 14      call _isspace
0308+  1672 C6 6E 16      je get_number_skip_spaces
0309+  1675 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  1677 C7 87 16      jne get_number_L0
0311+  167A 19 14         mov al, TOK_END
0312+  167C 3D BF 16      mov [tok], al
0313+  167F 19 06         mov al, TOKTYP_END
0314+  1681 3D BE 16      mov [toktyp], al
0315+  1684 0A 9E 16      jmp get_number_return
0316+  1687             get_number_L0:
0317+  1687 F7            stosb
0318+  1688 F6            lodsb
0319+  1689 07 FF 13      call _isdigit      ;check if is numeric
0320+  168C C6 87 16      jz get_number_L0
0321+  168F 19 00         mov al, 0
0322+  1691 F7            stosb
0323+  1692 19 05         mov al, TOKTYP_NUMERIC
0324+  1694 3D BE 16      mov [toktyp], al
0325+  1697 D5 01 00      sub si, 1
0326+  169A 4E            mov a, si
0327+  169B 42 BC 16      mov [prog], a    ; update pointer
0328+  169E             get_number_return:
0329+  169E F0            pop di
0330+  169F EF            pop si
0331+  16A0 E7            pop d
0332+  16A1 E4            pop a
0333+  16A2 09            ret
0334+  16A3             
0335+  16A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  16A3             ;; PUT BACK TOKEN
0337+  16A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  16A3             _putback:
0339+  16A3 D7            push a
0340+  16A4 E2            push si
0341+  16A5 FD 4D C0 16   mov si, tokstr  
0342+  16A9             _putback_loop:
0343+  16A9 F6            lodsb
0344+  16AA B9 00         cmp al, 0
0345+  16AC C6 B9 16      je _putback_end
0346+  16AF 14 BC 16      mov a, [prog]
0347+  16B2 7D            dec a
0348+  16B3 42 BC 16      mov [prog], a      ; update pointer
0349+  16B6 0A A9 16      jmp _putback_loop
0350+  16B9             _putback_end:
0351+  16B9 EF            pop si
0352+  16BA E4            pop a
0353+  16BB 09            ret
0354+  16BC             
0355+  16BC             
0356+  16BC             
0357+  16BC             
0358+  16BC 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  16BE             
0360+  16BE 00          toktyp:    .db 0          ; token type symbol
0361+  16BF 00          tok:       .db 0          ; current token symbol
0362+  16C0 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  16C4 00 00 00 00 
0362+  16C8 00 00 00 00 
0362+  16CC 00 00 00 00 
0362+  16D0 00 00 00 00 
0362+  16D4 00 00 00 00 
0362+  16D8 00 00 00 00 
0362+  16DC 00 00 00 00 
0362+  16E0 00 00 00 00 
0362+  16E4 00 00 00 00 
0362+  16E8 00 00 00 00 
0362+  16EC 00 00 00 00 
0362+  16F0 00 00 00 00 
0362+  16F4 00 00 00 00 
0362+  16F8 00 00 00 00 
0362+  16FC 00 00 00 00 
0362+  1700 00 00 00 00 
0362+  1704 00 00 00 00 
0362+  1708 00 00 00 00 
0362+  170C 00 00 00 00 
0362+  1710 00 00 00 00 
0362+  1714 00 00 00 00 
0362+  1718 00 00 00 00 
0362+  171C 00 00 00 00 
0362+  1720 00 00 00 00 
0362+  1724 00 00 00 00 
0362+  1728 00 00 00 00 
0362+  172C 00 00 00 00 
0362+  1730 00 00 00 00 
0362+  1734 00 00 00 00 
0362+  1738 00 00 00 00 
0362+  173C 00 00 00 00 
0362+  1740 00 00 00 00 
0362+  1744 00 00 00 00 
0362+  1748 00 00 00 00 
0362+  174C 00 00 00 00 
0362+  1750 00 00 00 00 
0362+  1754 00 00 00 00 
0362+  1758 00 00 00 00 
0362+  175C 00 00 00 00 
0362+  1760 00 00 00 00 
0362+  1764 00 00 00 00 
0362+  1768 00 00 00 00 
0362+  176C 00 00 00 00 
0362+  1770 00 00 00 00 
0362+  1774 00 00 00 00 
0362+  1778 00 00 00 00 
0362+  177C 00 00 00 00 
0362+  1780 00 00 00 00 
0362+  1784 00 00 00 00 
0362+  1788 00 00 00 00 
0362+  178C 00 00 00 00 
0362+  1790 00 00 00 00 
0362+  1794 00 00 00 00 
0362+  1798 00 00 00 00 
0362+  179C 00 00 00 00 
0362+  17A0 00 00 00 00 
0362+  17A4 00 00 00 00 
0362+  17A8 00 00 00 00 
0362+  17AC 00 00 00 00 
0362+  17B0 00 00 00 00 
0362+  17B4 00 00 00 00 
0362+  17B8 00 00 00 00 
0362+  17BC 00 00 00 00 
2657   17C0             
2658   17C0             ; kernel parameters
2659   17C0 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2660   17C1 01          sys_echo_on:        .db 1
2661   17C2 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2662   17C3 01          sys_uart0_inten:    .db 1
2663   17C4 00          sys_uart0_fifoen:   .db 0
2664   17C5 0C          sys_uart0_div0:     .db 12  ;
2665   17C6 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2666   17C7             ; Baud  Divisor
2667   17C7             ; 50    2304
2668   17C7             ; 110   1047
2669   17C7             ; 300    384
2670   17C7             ; 600    192
2671   17C7             ; 1200    96
2672   17C7             ; 9600    12
2673   17C7             ; 19200    6
2674   17C7             ; 38400    3
2675   17C7             
2676   17C7 00          nbr_active_procs:   .db 0
2677   17C8 01          active_proc_index:  .db 1
2678   17C9             
2679   17C9 00 00       index:              .dw 0
2680   17CB 00 00       buffer_addr:        .dw 0
2681   17CD             
2682   17CD 1D 21       fifo_in:            .dw fifo
2683   17CF 1D 21       fifo_out:           .dw fifo
2684   17D1             
2685   17D1             ; file system variables
2686   17D1 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2687   17D3 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2687   17D7 6E 2F 69 6E 
2687   17DB 69 74 00 
2688   17DE             
2689   17DE 73 6F 6C 61 s_uname:            .db "solarium v.1.0", 0
2689   17E2 72 69 75 6D 
2689   17E6 20 76 2E 31 
2689   17EA 2E 30 00 
2690   17ED 3E 20 00    s_dataentry:        .db "> ", 0
2691   17F0 2E 2E 00    s_parent_dir:       .db "..", 0
2692   17F3 2E 00       s_current_dir:      .db ".", 0
2693   17F5 2F 00       s_fslash:           .db "/", 0
2694   17F7 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2694   17FB 78 
2695   17FC 2D 64 63    file_type:          .db "-dc"
2696   17FF 70 69 64 20 s_ps_header:        .db "pid command\n", 0
2696   1803 63 6F 6D 6D 
2696   1807 61 6E 64 0A 
2696   180B 00 
2697   180C 74 6F 74 61 s_ls_total:         .db "total: ", 0
2697   1810 6C 3A 20 00 
2698   1814             
2699   1814 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2699   1818 20 65 6E 61 
2699   181C 62 6C 65 64 
2699   1820 0A 00 
2700   1822 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2700   1826 65 6C 20 73 
2700   182A 74 61 72 74 
2700   182E 65 64 28 76 
2700   1832 65 72 73 69 
2700   1836 6F 6E 20 31 
2700   183A 2E 30 29 0A 
2700   183E 00 
2701   183F 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2701   1843 74 69 6E 67 
2701   1847 20 69 6E 69 
2701   184B 74 0A 00 
2702   184E 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2702   1852 65 70 74 69 
2702   1856 6F 6E 3A 20 
2702   185A 70 72 69 76 
2702   185E 69 6C 65 67 
2702   1862 65 0A 00 
2703   1865 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2703   1869 65 70 74 69 
2703   186D 6F 6E 3A 20 
2703   1871 7A 65 72 6F 
2703   1875 20 64 69 76 
2703   1879 69 73 69 6F 
2703   187D 6E 0A 00 
2704   1880             
2705   1880 79 65 61 72 s_set_year:         .db "year: ", 0
2705   1884 3A 20 00 
2706   1887 6D 6F 6E 74 s_set_month:        .db "month: ", 0
2706   188B 68 3A 20 00 
2707   188F 64 61 79 3A s_set_day:          .db "day: ", 0
2707   1893 20 00 
2708   1895 77 65 65 6B s_set_week:         .db "weekday: ", 0
2708   1899 64 61 79 3A 
2708   189D 20 00 
2709   189F 68 6F 75 72 s_set_hours:        .db "hours: ", 0
2709   18A3 73 3A 20 00 
2710   18A7 6D 69 6E 75 s_set_minutes:      .db "minutes: ", 0
2710   18AB 74 65 73 3A 
2710   18AF 20 00 
2711   18B1 73 65 63 6F s_set_seconds:      .db "seconds: ", 0
2711   18B5 6E 64 73 3A 
2711   18B9 20 00 
2712   18BB             s_months:      
2713   18BB 20 20 20 00   .db "   ", 0
2714   18BF 4A 61 6E 00   .db "Jan", 0
2715   18C3 46 65 62 00   .db "Feb", 0
2716   18C7 4D 61 72 00   .db "Mar", 0
2717   18CB 41 70 72 00   .db "Apr", 0
2718   18CF 4D 61 79 00   .db "May", 0
2719   18D3 4A 75 6E 00   .db "Jun", 0
2720   18D7 4A 75 6C 00   .db "Jul", 0
2721   18DB 41 75 67 00   .db "Aug", 0
2722   18DF 53 65 70 00   .db "Sep", 0
2723   18E3 4F 63 74 00   .db "Oct", 0
2724   18E7 4E 6F 76 00   .db "Nov", 0
2725   18EB 44 65 63 00   .db "Dec", 0
2726   18EF             
2727   18EF             s_week:        
2728   18EF 53 75 6E 00   .db "Sun", 0 
2729   18F3 4D 6F 6E 00   .db "Mon", 0 
2730   18F7 54 75 65 00   .db "Tue", 0 
2731   18FB 57 65 64 00   .db "Wed", 0 
2732   18FF 54 68 75 00   .db "Thu", 0 
2733   1903 46 72 69 00   .db "Fri", 0 
2734   1907 53 61 74 00   .db "Sat", 0
2735   190B             
2736   190B             ; This is the format of a sector for the 128 byte per sector format.
2737   190B             ; Write the bracketed data 16 times per track.
2738   190B             ; The recommended single-density format with 128
2739   190B             ; bytes/sector is shown. In order to format a diskette,
2740   190B             ; the user issues the Write Track Command, and loads
2741   190B             ; the Data Register with the following values. For every
2742   190B             ; byte to be written, there is one Data Request.
2743   190B             fdc_128_bytes_per_sect:                                                                       
2744   190B FF FF FF FF fdc_40_FF:          .fill 40,  $FF    ; or 00                                                                                
2744   190F FF FF FF FF 
2744   1913 FF FF FF FF 
2744   1917 FF FF FF FF 
2744   191B FF FF FF FF 
2744   191F FF FF FF FF 
2744   1923 FF FF FF FF 
2744   1927 FF FF FF FF 
2744   192B FF FF FF FF 
2744   192F FF FF FF FF 
2745   1933 00 00 00 00 fdc_6_00_0:         .fill 6,   $00    ;                                                                            <--|        
2745   1937 00 00 
2746   1939 FE          fdc_id_fe:          .fill 1,   $FE    ; ID Address Mark                                                               |        
2747   193A 00          fdc_track:          .fill 1,   $00    ; Track Number                                                                  |                    
2748   193B 00          fdc_side:           .fill 1,   $00    ; Side Number 00 or 01                                                          |                
2749   193C 01          fdc_sector:         .fill 1,   $01    ; Sector Number  1 through 10                                                   |                              
2750   193D 00          fdc_length:         .fill 1,   $00    ; Sector Length                                                                 |                        
2751   193E F7          fdc_2_crc_0:        .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
2752   193F FF FF FF FF fdc_11_ff:          .fill 11,  $FF    ; or 00                                                                         |                      
2752   1943 FF FF FF FF 
2752   1947 FF FF FF 
2753   194A 00 00 00 00 fdc_6_00_1:         .fill 6,   $00    ;                                                                               |                        
2753   194E 00 00 
2754   1950 FB          fdc_data_addr:      .fill 1,   $FB    ; Data Address Mark                                                             |                                  
2755   1951 E5 E5 E5 E5 fdc_data:           .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
2755   1955 E5 E5 E5 E5 
2755   1959 E5 E5 E5 E5 
2755   195D E5 E5 E5 E5 
2755   1961 E5 E5 E5 E5 
2755   1965 E5 E5 E5 E5 
2755   1969 E5 E5 E5 E5 
2755   196D E5 E5 E5 E5 
2755   1971 E5 E5 E5 E5 
2755   1975 E5 E5 E5 E5 
2755   1979 E5 E5 E5 E5 
2755   197D E5 E5 E5 E5 
2755   1981 E5 E5 E5 E5 
2755   1985 E5 E5 E5 E5 
2755   1989 E5 E5 E5 E5 
2755   198D E5 E5 E5 E5 
2755   1991 E5 E5 E5 E5 
2755   1995 E5 E5 E5 E5 
2755   1999 E5 E5 E5 E5 
2755   199D E5 E5 E5 E5 
2755   19A1 E5 E5 E5 E5 
2755   19A5 E5 E5 E5 E5 
2755   19A9 E5 E5 E5 E5 
2755   19AD E5 E5 E5 E5 
2755   19B1 E5 E5 E5 E5 
2755   19B5 E5 E5 E5 E5 
2755   19B9 E5 E5 E5 E5 
2755   19BD E5 E5 E5 E5 
2755   19C1 E5 E5 E5 E5 
2755   19C5 E5 E5 E5 E5 
2755   19C9 E5 E5 E5 E5 
2755   19CD E5 E5 E5 E5 
2756   19D1 F7          fdc_2_crc_1:        .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
2757   19D2 FF FF FF FF fdc_10_ff:          .fill 10,  $FF    ; or 00                                                                      <--|                                                  
2757   19D6 FF FF FF FF 
2757   19DA FF FF 
2758   19DC FF FF FF FF fdc_369_ff:         .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2758   19E0 FF FF FF FF 
2758   19E4 FF FF FF FF 
2758   19E8 FF FF FF FF 
2758   19EC FF FF FF FF 
2758   19F0 FF FF FF FF 
2758   19F4 FF FF FF FF 
2758   19F8 FF FF FF FF 
2758   19FC FF FF FF FF 
2758   1A00 FF FF FF FF 
2758   1A04 FF FF FF FF 
2758   1A08 FF FF FF FF 
2758   1A0C FF FF FF FF 
2758   1A10 FF FF FF FF 
2758   1A14 FF FF FF FF 
2758   1A18 FF FF FF FF 
2758   1A1C FF FF FF FF 
2758   1A20 FF FF FF FF 
2758   1A24 FF FF FF FF 
2758   1A28 FF FF FF FF 
2758   1A2C FF FF FF FF 
2758   1A30 FF FF FF FF 
2758   1A34 FF FF FF FF 
2758   1A38 FF FF FF FF 
2758   1A3C FF FF FF FF 
2758   1A40 FF FF FF FF 
2758   1A44 FF FF FF FF 
2758   1A48 FF FF FF FF 
2758   1A4C FF FF FF FF 
2758   1A50 FF FF FF FF 
2758   1A54 FF FF FF FF 
2758   1A58 FF FF FF FF 
2758   1A5C FF FF FF FF 
2758   1A60 FF FF FF FF 
2758   1A64 FF FF FF FF 
2758   1A68 FF FF FF FF 
2758   1A6C FF FF FF FF 
2758   1A70 FF FF FF FF 
2758   1A74 FF FF FF FF 
2758   1A78 FF FF FF FF 
2758   1A7C FF FF FF FF 
2758   1A80 FF FF FF FF 
2758   1A84 FF FF FF FF 
2758   1A88 FF FF FF FF 
2758   1A8C FF FF FF FF 
2758   1A90 FF FF FF FF 
2758   1A94 FF FF FF FF 
2758   1A98 FF FF FF FF 
2758   1A9C FF FF FF FF 
2758   1AA0 FF FF FF FF 
2758   1AA4 FF FF FF FF 
2758   1AA8 FF FF FF FF 
2758   1AAC FF FF FF FF 
2758   1AB0 FF FF FF FF 
2758   1AB4 FF FF FF FF 
2758   1AB8 FF FF FF FF 
2758   1ABC FF FF FF FF 
2758   1AC0 FF FF FF FF 
2758   1AC4 FF FF FF FF 
2758   1AC8 FF FF FF FF 
2758   1ACC FF FF FF FF 
2758   1AD0 FF FF FF FF 
2758   1AD4 FF FF FF FF 
2758   1AD8 FF FF FF FF 
2758   1ADC FF FF FF FF 
2758   1AE0 FF FF FF FF 
2758   1AE4 FF FF FF FF 
2758   1AE8 FF FF FF FF 
2758   1AEC FF FF FF FF 
2758   1AF0 FF FF FF FF 
2758   1AF4 FF FF FF FF 
2758   1AF8 FF FF FF FF 
2758   1AFC FF FF FF FF 
2758   1B00 FF FF FF FF 
2758   1B04 FF FF FF FF 
2758   1B08 FF FF FF FF 
2758   1B0C FF FF FF FF 
2758   1B10 FF FF FF FF 
2758   1B14 FF FF FF FF 
2758   1B18 FF FF FF FF 
2758   1B1C FF FF FF FF 
2758   1B20 FF FF FF FF 
2758   1B24 FF FF FF FF 
2758   1B28 FF FF FF FF 
2758   1B2C FF FF FF FF 
2758   1B30 FF FF FF FF 
2758   1B34 FF FF FF FF 
2758   1B38 FF FF FF FF 
2758   1B3C FF FF FF FF 
2758   1B40 FF FF FF FF 
2758   1B44 FF FF FF FF 
2758   1B48 FF FF FF FF 
2758   1B4C FF 
2759   1B4D             
2760   1B4D 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2760   1B51 00 00 00 00 
2760   1B55 00 00 00 00 
2760   1B59 00 00 00 00 
2760   1B5D 00 00 00 00 
2760   1B61 00 00 00 00 
2760   1B65 00 00 00 00 
2760   1B69 00 00 00 00 
2760   1B6D 00 00 00 00 
2760   1B71 00 00 00 00 
2760   1B75 00 00 00 00 
2760   1B79 00 00 00 00 
2760   1B7D 00 00 00 00 
2760   1B81 00 00 00 00 
2760   1B85 00 00 00 00 
2760   1B89 00 00 00 00 
2760   1B8D 00 00 00 00 
2760   1B91 00 00 00 00 
2760   1B95 00 00 00 00 
2760   1B99 00 00 00 00 
2760   1B9D 00 00 00 00 
2760   1BA1 00 00 00 00 
2760   1BA5 00 00 00 00 
2760   1BA9 00 00 00 00 
2760   1BAD 00 00 00 00 
2760   1BB1 00 00 00 00 
2760   1BB5 00 00 00 00 
2760   1BB9 00 00 00 00 
2760   1BBD 00 00 00 00 
2760   1BC1 00 00 00 00 
2760   1BC5 00 00 00 00 
2760   1BC9 00 00 00 00 
2760   1BCD 00 00 00 00 
2760   1BD1 00 00 00 00 
2760   1BD5 00 00 00 00 
2760   1BD9 00 00 00 00 
2760   1BDD 00 00 00 00 
2760   1BE1 00 00 00 00 
2760   1BE5 00 00 00 00 
2760   1BE9 00 00 00 00 
2760   1BED 00 00 00 00 
2760   1BF1 00 00 00 00 
2760   1BF5 00 00 00 00 
2760   1BF9 00 00 00 00 
2760   1BFD 00 00 00 00 
2760   1C01 00 00 00 00 
2760   1C05 00 00 00 00 
2760   1C09 00 00 00 00 
2760   1C0D 00 00 00 00 
2760   1C11 00 00 00 00 
2760   1C15 00 00 00 00 
2760   1C19 00 00 00 00 
2760   1C1D 00 00 00 00 
2760   1C21 00 00 00 00 
2760   1C25 00 00 00 00 
2760   1C29 00 00 00 00 
2760   1C2D 00 00 00 00 
2760   1C31 00 00 00 00 
2760   1C35 00 00 00 00 
2760   1C39 00 00 00 00 
2760   1C3D 00 00 00 00 
2760   1C41 00 00 00 00 
2760   1C45 00 00 00 00 
2760   1C49 00 00 00 00 
2760   1C4D 00 00 00 00 
2760   1C51 00 00 00 00 
2760   1C55 00 00 00 00 
2760   1C59 00 00 00 00 
2760   1C5D 00 00 00 00 
2760   1C61 00 00 00 00 
2760   1C65 00 00 00 00 
2760   1C69 00 00 00 00 
2760   1C6D 00 00 00 00 
2760   1C71 00 00 00 00 
2760   1C75 00 00 00 00 
2760   1C79 00 00 00 00 
2760   1C7D 00 00 00 00 
2760   1C81 00 00 00 00 
2760   1C85 00 00 00 00 
2760   1C89 00 00 00 00 
2761   1C8D 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2761   1C91 00 00 00 00 
2761   1C95 00 00 00 00 
2761   1C99 00 00 00 00 
2762   1C9D 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2762   1CA1 00 00 00 00 
2762   1CA5 00 00 00 00 
2762   1CA9 00 00 00 00 
2762   1CAD 00 00 00 00 
2762   1CB1 00 00 00 00 
2762   1CB5 00 00 00 00 
2762   1CB9 00 00 00 00 
2762   1CBD 00 00 00 00 
2762   1CC1 00 00 00 00 
2762   1CC5 00 00 00 00 
2762   1CC9 00 00 00 00 
2762   1CCD 00 00 00 00 
2762   1CD1 00 00 00 00 
2762   1CD5 00 00 00 00 
2762   1CD9 00 00 00 00 
2762   1CDD 00 00 00 00 
2762   1CE1 00 00 00 00 
2762   1CE5 00 00 00 00 
2762   1CE9 00 00 00 00 
2762   1CED 00 00 00 00 
2762   1CF1 00 00 00 00 
2762   1CF5 00 00 00 00 
2762   1CF9 00 00 00 00 
2762   1CFD 00 00 00 00 
2762   1D01 00 00 00 00 
2762   1D05 00 00 00 00 
2762   1D09 00 00 00 00 
2762   1D0D 00 00 00 00 
2762   1D11 00 00 00 00 
2762   1D15 00 00 00 00 
2762   1D19 00 00 00 00 
2762   1D1D 00 00 00 00 
2762   1D21 00 00 00 00 
2762   1D25 00 00 00 00 
2762   1D29 00 00 00 00 
2762   1D2D 00 00 00 00 
2762   1D31 00 00 00 00 
2762   1D35 00 00 00 00 
2762   1D39 00 00 00 00 
2762   1D3D 00 00 00 00 
2762   1D41 00 00 00 00 
2762   1D45 00 00 00 00 
2762   1D49 00 00 00 00 
2762   1D4D 00 00 00 00 
2762   1D51 00 00 00 00 
2762   1D55 00 00 00 00 
2762   1D59 00 00 00 00 
2762   1D5D 00 00 00 00 
2762   1D61 00 00 00 00 
2762   1D65 00 00 00 00 
2762   1D69 00 00 00 00 
2762   1D6D 00 00 00 00 
2762   1D71 00 00 00 00 
2762   1D75 00 00 00 00 
2762   1D79 00 00 00 00 
2762   1D7D 00 00 00 00 
2762   1D81 00 00 00 00 
2762   1D85 00 00 00 00 
2762   1D89 00 00 00 00 
2762   1D8D 00 00 00 00 
2762   1D91 00 00 00 00 
2762   1D95 00 00 00 00 
2762   1D99 00 00 00 00 
2762   1D9D 00 00 00 00 
2762   1DA1 00 00 00 00 
2762   1DA5 00 00 00 00 
2762   1DA9 00 00 00 00 
2762   1DAD 00 00 00 00 
2762   1DB1 00 00 00 00 
2762   1DB5 00 00 00 00 
2762   1DB9 00 00 00 00 
2762   1DBD 00 00 00 00 
2762   1DC1 00 00 00 00 
2762   1DC5 00 00 00 00 
2762   1DC9 00 00 00 00 
2762   1DCD 00 00 00 00 
2762   1DD1 00 00 00 00 
2762   1DD5 00 00 00 00 
2762   1DD9 00 00 00 00 
2762   1DDD 00 00 00 00 
2762   1DE1 00 00 00 00 
2762   1DE5 00 00 00 00 
2762   1DE9 00 00 00 00 
2762   1DED 00 00 00 00 
2762   1DF1 00 00 00 00 
2762   1DF5 00 00 00 00 
2762   1DF9 00 00 00 00 
2762   1DFD 00 00 00 00 
2762   1E01 00 00 00 00 
2762   1E05 00 00 00 00 
2762   1E09 00 00 00 00 
2762   1E0D 00 00 00 00 
2762   1E11 00 00 00 00 
2762   1E15 00 00 00 00 
2762   1E19 00 00 00 00 
2762   1E1D 00 00 00 00 
2762   1E21 00 00 00 00 
2762   1E25 00 00 00 00 
2762   1E29 00 00 00 00 
2762   1E2D 00 00 00 00 
2762   1E31 00 00 00 00 
2762   1E35 00 00 00 00 
2762   1E39 00 00 00 00 
2762   1E3D 00 00 00 00 
2762   1E41 00 00 00 00 
2762   1E45 00 00 00 00 
2762   1E49 00 00 00 00 
2762   1E4D 00 00 00 00 
2762   1E51 00 00 00 00 
2762   1E55 00 00 00 00 
2762   1E59 00 00 00 00 
2762   1E5D 00 00 00 00 
2762   1E61 00 00 00 00 
2762   1E65 00 00 00 00 
2762   1E69 00 00 00 00 
2762   1E6D 00 00 00 00 
2762   1E71 00 00 00 00 
2762   1E75 00 00 00 00 
2762   1E79 00 00 00 00 
2762   1E7D 00 00 00 00 
2762   1E81 00 00 00 00 
2762   1E85 00 00 00 00 
2762   1E89 00 00 00 00 
2762   1E8D 00 00 00 00 
2762   1E91 00 00 00 00 
2762   1E95 00 00 00 00 
2762   1E99 00 00 00 00 
2763   1E9D 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2763   1EA1 00 00 00 00 
2763   1EA5 00 00 00 00 
2763   1EA9 00 00 00 00 
2763   1EAD 00 00 00 00 
2763   1EB1 00 00 00 00 
2763   1EB5 00 00 00 00 
2763   1EB9 00 00 00 00 
2763   1EBD 00 00 00 00 
2763   1EC1 00 00 00 00 
2763   1EC5 00 00 00 00 
2763   1EC9 00 00 00 00 
2763   1ECD 00 00 00 00 
2763   1ED1 00 00 00 00 
2763   1ED5 00 00 00 00 
2763   1ED9 00 00 00 00 
2763   1EDD 00 00 00 00 
2763   1EE1 00 00 00 00 
2763   1EE5 00 00 00 00 
2763   1EE9 00 00 00 00 
2763   1EED 00 00 00 00 
2763   1EF1 00 00 00 00 
2763   1EF5 00 00 00 00 
2763   1EF9 00 00 00 00 
2763   1EFD 00 00 00 00 
2763   1F01 00 00 00 00 
2763   1F05 00 00 00 00 
2763   1F09 00 00 00 00 
2763   1F0D 00 00 00 00 
2763   1F11 00 00 00 00 
2763   1F15 00 00 00 00 
2763   1F19 00 00 00 00 
2764   1F1D 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2764   1F21 00 00 00 00 
2764   1F25 00 00 00 00 
2764   1F29 00 00 00 00 
2764   1F2D 00 00 00 00 
2764   1F31 00 00 00 00 
2764   1F35 00 00 00 00 
2764   1F39 00 00 00 00 
2764   1F3D 00 00 00 00 
2764   1F41 00 00 00 00 
2764   1F45 00 00 00 00 
2764   1F49 00 00 00 00 
2764   1F4D 00 00 00 00 
2764   1F51 00 00 00 00 
2764   1F55 00 00 00 00 
2764   1F59 00 00 00 00 
2764   1F5D 00 00 00 00 
2764   1F61 00 00 00 00 
2764   1F65 00 00 00 00 
2764   1F69 00 00 00 00 
2764   1F6D 00 00 00 00 
2764   1F71 00 00 00 00 
2764   1F75 00 00 00 00 
2764   1F79 00 00 00 00 
2764   1F7D 00 00 00 00 
2764   1F81 00 00 00 00 
2764   1F85 00 00 00 00 
2764   1F89 00 00 00 00 
2764   1F8D 00 00 00 00 
2764   1F91 00 00 00 00 
2764   1F95 00 00 00 00 
2764   1F99 00 00 00 00 
2764   1F9D 00 00 00 00 
2764   1FA1 00 00 00 00 
2764   1FA5 00 00 00 00 
2764   1FA9 00 00 00 00 
2764   1FAD 00 00 00 00 
2764   1FB1 00 00 00 00 
2764   1FB5 00 00 00 00 
2764   1FB9 00 00 00 00 
2764   1FBD 00 00 00 00 
2764   1FC1 00 00 00 00 
2764   1FC5 00 00 00 00 
2764   1FC9 00 00 00 00 
2764   1FCD 00 00 00 00 
2764   1FD1 00 00 00 00 
2764   1FD5 00 00 00 00 
2764   1FD9 00 00 00 00 
2764   1FDD 00 00 00 00 
2764   1FE1 00 00 00 00 
2764   1FE5 00 00 00 00 
2764   1FE9 00 00 00 00 
2764   1FED 00 00 00 00 
2764   1FF1 00 00 00 00 
2764   1FF5 00 00 00 00 
2764   1FF9 00 00 00 00 
2764   1FFD 00 00 00 00 
2764   2001 00 00 00 00 
2764   2005 00 00 00 00 
2764   2009 00 00 00 00 
2764   200D 00 00 00 00 
2764   2011 00 00 00 00 
2764   2015 00 00 00 00 
2764   2019 00 00 00 00 
2764   201D 00 00 00 00 
2764   2021 00 00 00 00 
2764   2025 00 00 00 00 
2764   2029 00 00 00 00 
2764   202D 00 00 00 00 
2764   2031 00 00 00 00 
2764   2035 00 00 00 00 
2764   2039 00 00 00 00 
2764   203D 00 00 00 00 
2764   2041 00 00 00 00 
2764   2045 00 00 00 00 
2764   2049 00 00 00 00 
2764   204D 00 00 00 00 
2764   2051 00 00 00 00 
2764   2055 00 00 00 00 
2764   2059 00 00 00 00 
2764   205D 00 00 00 00 
2764   2061 00 00 00 00 
2764   2065 00 00 00 00 
2764   2069 00 00 00 00 
2764   206D 00 00 00 00 
2764   2071 00 00 00 00 
2764   2075 00 00 00 00 
2764   2079 00 00 00 00 
2764   207D 00 00 00 00 
2764   2081 00 00 00 00 
2764   2085 00 00 00 00 
2764   2089 00 00 00 00 
2764   208D 00 00 00 00 
2764   2091 00 00 00 00 
2764   2095 00 00 00 00 
2764   2099 00 00 00 00 
2764   209D 00 00 00 00 
2764   20A1 00 00 00 00 
2764   20A5 00 00 00 00 
2764   20A9 00 00 00 00 
2764   20AD 00 00 00 00 
2764   20B1 00 00 00 00 
2764   20B5 00 00 00 00 
2764   20B9 00 00 00 00 
2764   20BD 00 00 00 00 
2764   20C1 00 00 00 00 
2764   20C5 00 00 00 00 
2764   20C9 00 00 00 00 
2764   20CD 00 00 00 00 
2764   20D1 00 00 00 00 
2764   20D5 00 00 00 00 
2764   20D9 00 00 00 00 
2764   20DD 00 00 00 00 
2764   20E1 00 00 00 00 
2764   20E5 00 00 00 00 
2764   20E9 00 00 00 00 
2764   20ED 00 00 00 00 
2764   20F1 00 00 00 00 
2764   20F5 00 00 00 00 
2764   20F9 00 00 00 00 
2764   20FD 00 00 00 00 
2764   2101 00 00 00 00 
2764   2105 00 00 00 00 
2764   2109 00 00 00 00 
2764   210D 00 00 00 00 
2764   2111 00 00 00 00 
2764   2115 00 00 00 00 
2764   2119 00 00 00 00 
2765   211D FF FF FF FF fifo:               .fill FIFO_SIZE
2765   2121 FF FF FF FF 
2765   2125 FF FF FF FF 
2765   2129 FF FF FF FF 
2765   212D FF FF FF FF 
2765   2131 FF FF FF FF 
2765   2135 FF FF FF FF 
2765   2139 FF FF FF FF 
2765   213D FF FF FF FF 
2765   2141 FF FF FF FF 
2765   2145 FF FF FF FF 
2765   2149 FF FF FF FF 
2765   214D FF FF FF FF 
2765   2151 FF FF FF FF 
2765   2155 FF FF FF FF 
2765   2159 FF FF FF FF 
2765   215D FF FF FF FF 
2765   2161 FF FF FF FF 
2765   2165 FF FF FF FF 
2765   2169 FF FF FF FF 
2765   216D FF FF FF FF 
2765   2171 FF FF FF FF 
2765   2175 FF FF FF FF 
2765   2179 FF FF FF FF 
2765   217D FF FF FF FF 
2765   2181 FF FF FF FF 
2765   2185 FF FF FF FF 
2765   2189 FF FF FF FF 
2765   218D FF FF FF FF 
2765   2191 FF FF FF FF 
2765   2195 FF FF FF FF 
2765   2199 FF FF FF FF 
2765   219D FF FF FF FF 
2765   21A1 FF FF FF FF 
2765   21A5 FF FF FF FF 
2765   21A9 FF FF FF FF 
2765   21AD FF FF FF FF 
2765   21B1 FF FF FF FF 
2765   21B5 FF FF FF FF 
2765   21B9 FF FF FF FF 
2765   21BD FF FF FF FF 
2765   21C1 FF FF FF FF 
2765   21C5 FF FF FF FF 
2765   21C9 FF FF FF FF 
2765   21CD FF FF FF FF 
2765   21D1 FF FF FF FF 
2765   21D5 FF FF FF FF 
2765   21D9 FF FF FF FF 
2765   21DD FF FF FF FF 
2765   21E1 FF FF FF FF 
2765   21E5 FF FF FF FF 
2765   21E9 FF FF FF FF 
2765   21ED FF FF FF FF 
2765   21F1 FF FF FF FF 
2765   21F5 FF FF FF FF 
2765   21F9 FF FF FF FF 
2765   21FD FF FF FF FF 
2765   2201 FF FF FF FF 
2765   2205 FF FF FF FF 
2765   2209 FF FF FF FF 
2765   220D FF FF FF FF 
2765   2211 FF FF FF FF 
2765   2215 FF FF FF FF 
2765   2219 FF FF FF FF 
2765   221D FF FF FF FF 
2765   2221 FF FF FF FF 
2765   2225 FF FF FF FF 
2765   2229 FF FF FF FF 
2765   222D FF FF FF FF 
2765   2231 FF FF FF FF 
2765   2235 FF FF FF FF 
2765   2239 FF FF FF FF 
2765   223D FF FF FF FF 
2765   2241 FF FF FF FF 
2765   2245 FF FF FF FF 
2765   2249 FF FF FF FF 
2765   224D FF FF FF FF 
2765   2251 FF FF FF FF 
2765   2255 FF FF FF FF 
2765   2259 FF FF FF FF 
2765   225D FF FF FF FF 
2765   2261 FF FF FF FF 
2765   2265 FF FF FF FF 
2765   2269 FF FF FF FF 
2765   226D FF FF FF FF 
2765   2271 FF FF FF FF 
2765   2275 FF FF FF FF 
2765   2279 FF FF FF FF 
2765   227D FF FF FF FF 
2765   2281 FF FF FF FF 
2765   2285 FF FF FF FF 
2765   2289 FF FF FF FF 
2765   228D FF FF FF FF 
2765   2291 FF FF FF FF 
2765   2295 FF FF FF FF 
2765   2299 FF FF FF FF 
2765   229D FF FF FF FF 
2765   22A1 FF FF FF FF 
2765   22A5 FF FF FF FF 
2765   22A9 FF FF FF FF 
2765   22AD FF FF FF FF 
2765   22B1 FF FF FF FF 
2765   22B5 FF FF FF FF 
2765   22B9 FF FF FF FF 
2765   22BD FF FF FF FF 
2765   22C1 FF FF FF FF 
2765   22C5 FF FF FF FF 
2765   22C9 FF FF FF FF 
2765   22CD FF FF FF FF 
2765   22D1 FF FF FF FF 
2765   22D5 FF FF FF FF 
2765   22D9 FF FF FF FF 
2765   22DD FF FF FF FF 
2765   22E1 FF FF FF FF 
2765   22E5 FF FF FF FF 
2765   22E9 FF FF FF FF 
2765   22ED FF FF FF FF 
2765   22F1 FF FF FF FF 
2765   22F5 FF FF FF FF 
2765   22F9 FF FF FF FF 
2765   22FD FF FF FF FF 
2765   2301 FF FF FF FF 
2765   2305 FF FF FF FF 
2765   2309 FF FF FF FF 
2765   230D FF FF FF FF 
2765   2311 FF FF FF FF 
2765   2315 FF FF FF FF 
2765   2319 FF FF FF FF 
2765   231D FF FF FF FF 
2765   2321 FF FF FF FF 
2765   2325 FF FF FF FF 
2765   2329 FF FF FF FF 
2765   232D FF FF FF FF 
2765   2331 FF FF FF FF 
2765   2335 FF FF FF FF 
2765   2339 FF FF FF FF 
2765   233D FF FF FF FF 
2765   2341 FF FF FF FF 
2765   2345 FF FF FF FF 
2765   2349 FF FF FF FF 
2765   234D FF FF FF FF 
2765   2351 FF FF FF FF 
2765   2355 FF FF FF FF 
2765   2359 FF FF FF FF 
2765   235D FF FF FF FF 
2765   2361 FF FF FF FF 
2765   2365 FF FF FF FF 
2765   2369 FF FF FF FF 
2765   236D FF FF FF FF 
2765   2371 FF FF FF FF 
2765   2375 FF FF FF FF 
2765   2379 FF FF FF FF 
2765   237D FF FF FF FF 
2765   2381 FF FF FF FF 
2765   2385 FF FF FF FF 
2765   2389 FF FF FF FF 
2765   238D FF FF FF FF 
2765   2391 FF FF FF FF 
2765   2395 FF FF FF FF 
2765   2399 FF FF FF FF 
2765   239D FF FF FF FF 
2765   23A1 FF FF FF FF 
2765   23A5 FF FF FF FF 
2765   23A9 FF FF FF FF 
2765   23AD FF FF FF FF 
2765   23B1 FF FF FF FF 
2765   23B5 FF FF FF FF 
2765   23B9 FF FF FF FF 
2765   23BD FF FF FF FF 
2765   23C1 FF FF FF FF 
2765   23C5 FF FF FF FF 
2765   23C9 FF FF FF FF 
2765   23CD FF FF FF FF 
2765   23D1 FF FF FF FF 
2765   23D5 FF FF FF FF 
2765   23D9 FF FF FF FF 
2765   23DD FF FF FF FF 
2765   23E1 FF FF FF FF 
2765   23E5 FF FF FF FF 
2765   23E9 FF FF FF FF 
2765   23ED FF FF FF FF 
2765   23F1 FF FF FF FF 
2765   23F5 FF FF FF FF 
2765   23F9 FF FF FF FF 
2765   23FD FF FF FF FF 
2765   2401 FF FF FF FF 
2765   2405 FF FF FF FF 
2765   2409 FF FF FF FF 
2765   240D FF FF FF FF 
2765   2411 FF FF FF FF 
2765   2415 FF FF FF FF 
2765   2419 FF FF FF FF 
2765   241D FF FF FF FF 
2765   2421 FF FF FF FF 
2765   2425 FF FF FF FF 
2765   2429 FF FF FF FF 
2765   242D FF FF FF FF 
2765   2431 FF FF FF FF 
2765   2435 FF FF FF FF 
2765   2439 FF FF FF FF 
2765   243D FF FF FF FF 
2765   2441 FF FF FF FF 
2765   2445 FF FF FF FF 
2765   2449 FF FF FF FF 
2765   244D FF FF FF FF 
2765   2451 FF FF FF FF 
2765   2455 FF FF FF FF 
2765   2459 FF FF FF FF 
2765   245D FF FF FF FF 
2765   2461 FF FF FF FF 
2765   2465 FF FF FF FF 
2765   2469 FF FF FF FF 
2765   246D FF FF FF FF 
2765   2471 FF FF FF FF 
2765   2475 FF FF FF FF 
2765   2479 FF FF FF FF 
2765   247D FF FF FF FF 
2765   2481 FF FF FF FF 
2765   2485 FF FF FF FF 
2765   2489 FF FF FF FF 
2765   248D FF FF FF FF 
2765   2491 FF FF FF FF 
2765   2495 FF FF FF FF 
2765   2499 FF FF FF FF 
2765   249D FF FF FF FF 
2765   24A1 FF FF FF FF 
2765   24A5 FF FF FF FF 
2765   24A9 FF FF FF FF 
2765   24AD FF FF FF FF 
2765   24B1 FF FF FF FF 
2765   24B5 FF FF FF FF 
2765   24B9 FF FF FF FF 
2765   24BD FF FF FF FF 
2765   24C1 FF FF FF FF 
2765   24C5 FF FF FF FF 
2765   24C9 FF FF FF FF 
2765   24CD FF FF FF FF 
2765   24D1 FF FF FF FF 
2765   24D5 FF FF FF FF 
2765   24D9 FF FF FF FF 
2765   24DD FF FF FF FF 
2765   24E1 FF FF FF FF 
2765   24E5 FF FF FF FF 
2765   24E9 FF FF FF FF 
2765   24ED FF FF FF FF 
2765   24F1 FF FF FF FF 
2765   24F5 FF FF FF FF 
2765   24F9 FF FF FF FF 
2765   24FD FF FF FF FF 
2765   2501 FF FF FF FF 
2765   2505 FF FF FF FF 
2765   2509 FF FF FF FF 
2765   250D FF FF FF FF 
2765   2511 FF FF FF FF 
2765   2515 FF FF FF FF 
2765   2519 FF FF FF FF 
2766   251D             
2767   251D FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2767   2521 FF FF FF FF 
2767   2525 FF FF FF FF 
2767   2529 FF FF FF FF 
2767   252D FF FF FF FF 
2767   2531 FF FF FF FF 
2767   2535 FF FF FF FF 
2767   2539 FF FF FF FF 
2767   253D FF FF FF FF 
2767   2541 FF FF FF FF 
2767   2545 FF FF FF FF 
2767   2549 FF FF FF FF 
2767   254D FF FF FF FF 
2767   2551 FF FF FF FF 
2767   2555 FF FF FF FF 
2767   2559 FF FF FF FF 
2767   255D FF FF FF FF 
2767   2561 FF FF FF FF 
2767   2565 FF FF FF FF 
2767   2569 FF FF FF FF 
2767   256D FF FF FF FF 
2767   2571 FF FF FF FF 
2767   2575 FF FF FF FF 
2767   2579 FF FF FF FF 
2767   257D FF FF FF FF 
2767   2581 FF FF FF FF 
2767   2585 FF FF FF FF 
2767   2589 FF FF FF FF 
2767   258D FF FF FF FF 
2767   2591 FF FF FF FF 
2767   2595 FF FF FF FF 
2767   2599 FF FF FF FF 
2767   259D FF FF FF FF 
2767   25A1 FF FF FF FF 
2767   25A5 FF FF FF FF 
2767   25A9 FF FF FF FF 
2767   25AD FF FF FF FF 
2767   25B1 FF FF FF FF 
2767   25B5 FF FF FF FF 
2767   25B9 FF FF FF FF 
2767   25BD FF FF FF FF 
2767   25C1 FF FF FF FF 
2767   25C5 FF FF FF FF 
2767   25C9 FF FF FF FF 
2767   25CD FF FF FF FF 
2767   25D1 FF FF FF FF 
2767   25D5 FF FF FF FF 
2767   25D9 FF FF FF FF 
2767   25DD FF FF FF FF 
2767   25E1 FF FF FF FF 
2767   25E5 FF FF FF FF 
2767   25E9 FF FF FF FF 
2767   25ED FF FF FF FF 
2767   25F1 FF FF FF FF 
2767   25F5 FF FF FF FF 
2767   25F9 FF FF FF FF 
2767   25FD FF FF FF FF 
2767   2601 FF FF FF FF 
2767   2605 FF FF FF FF 
2767   2609 FF FF FF FF 
2767   260D FF FF FF FF 
2767   2611 FF FF FF FF 
2767   2615 FF FF FF FF 
2767   2619 FF FF FF FF 
2767   261D FF FF FF FF 
2767   2621 FF FF FF FF 
2767   2625 FF FF FF FF 
2767   2629 FF FF FF FF 
2767   262D FF FF FF FF 
2767   2631 FF FF FF FF 
2767   2635 FF FF FF FF 
2767   2639 FF FF FF FF 
2767   263D FF FF FF FF 
2767   2641 FF FF FF FF 
2767   2645 FF FF FF FF 
2767   2649 FF FF FF FF 
2767   264D FF FF FF FF 
2767   2651 FF FF FF FF 
2767   2655 FF FF FF FF 
2767   2659 FF FF FF FF 
2767   265D FF FF FF FF 
2767   2661 FF FF FF FF 
2767   2665 FF FF FF FF 
2767   2669 FF FF FF FF 
2767   266D FF FF FF FF 
2767   2671 FF FF FF FF 
2767   2675 FF FF FF FF 
2767   2679 FF FF FF FF 
2767   267D FF FF FF FF 
2767   2681 FF FF FF FF 
2767   2685 FF FF FF FF 
2767   2689 FF FF FF FF 
2767   268D FF FF FF FF 
2767   2691 FF FF FF FF 
2767   2695 FF FF FF FF 
2767   2699 FF FF FF FF 
2767   269D FF FF FF FF 
2767   26A1 FF FF FF FF 
2767   26A5 FF FF FF FF 
2767   26A9 FF FF FF FF 
2767   26AD FF FF FF FF 
2767   26B1 FF FF FF FF 
2767   26B5 FF FF FF FF 
2767   26B9 FF FF FF FF 
2767   26BD FF FF FF FF 
2767   26C1 FF FF FF FF 
2767   26C5 FF FF FF FF 
2767   26C9 FF FF FF FF 
2767   26CD FF FF FF FF 
2767   26D1 FF FF FF FF 
2767   26D5 FF FF FF FF 
2767   26D9 FF FF FF FF 
2767   26DD FF FF FF FF 
2767   26E1 FF FF FF FF 
2767   26E5 FF FF FF FF 
2767   26E9 FF FF FF FF 
2767   26ED FF FF FF FF 
2767   26F1 FF FF FF FF 
2767   26F5 FF FF FF FF 
2767   26F9 FF FF FF FF 
2767   26FD FF FF FF FF 
2767   2701 FF FF FF FF 
2767   2705 FF FF FF FF 
2767   2709 FF FF FF FF 
2767   270D FF FF FF FF 
2767   2711 FF FF FF FF 
2767   2715 FF FF FF FF 
2767   2719 FF FF FF FF 
2768   271D 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2769   271E             
2770   271E             
2771   271E             .end
tasm: Number of errors = 0
