0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_1     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 59 00       .dw int_6
0141   000E A5 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 D5 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 CD 02       .dw trap_privilege
0153   0014 EA 03       .dw trap_div_zero
0154   0016 F7 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 D9 02       .dw syscall_break
0165   0022 F8 03       .dw syscall_rtc
0166   0024 32 05       .dw syscall_ide
0167   0026 0D 06       .dw syscall_io
0168   0028 CA 06       .dw syscall_file_system
0169   002A 22 10       .dw syscall_create_proc
0170   002C 92 02       .dw syscall_list_procs
0171   002E 2A 04       .dw syscall_datetime
0172   0030 4E 02       .dw syscall_reboot
0173   0032 EC 0F       .dw syscall_pause_proc
0174   0034 5A 02       .dw syscall_resume_proc
0175   0036 A9 0F       .dw syscall_terminate_proc
0176   0038 1A 02       .dw syscall_system
0177   003A F0 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; irqs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" floppy drive controller irq
0220   003C             int_0_fdc:
0221   003C 3B 48 00      mov d, s_fdc_irq
0222   003F 07 29 13      call _puts
0223   0042 06            sysret
0224   0043             int_1:
0225   0043 06            sysret
0226   0044             int_2:
0227   0044 06            sysret
0228   0045             int_3:
0229   0045 06            sysret
0230   0046             int_4:
0231   0046 06            sysret
0232   0047             int_5:
0233   0047 06            sysret
0234   0048             
0235   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0235   004C 30 20 45 78 
0235   0050 65 63 75 74 
0235   0054 65 64 2E 0A 
0235   0058 00 
0236   0059             
0237   0059             ; ------------------------------------------------------------------------------------------------------------------;
0238   0059             ; process swapping
0239   0059             ; ------------------------------------------------------------------------------------------------------------------;
0240   0059             int_6:  
0241   0059 4B            pusha                             ; save all registers into kernel stack
0242   005A 22 00         mov ah, 0
0243   005C 1D 5A 18      mov al, [active_proc_index]
0244   005F FD 99         shl a                             ; x2
0245   0061 B7 9F 10      mov a, [proc_table_convert + a]   ; get process state start index
0246   0064 4F            mov di, a
0247   0065 48            mov a, sp
0248   0066 77            inc a
0249   0067 4D            mov si, a
0250   0068 38 14 00      mov c, 20
0251   006B FD F5         rep movsb                         ; save process state!
0252   006D             ; restore kernel stack position to point before interrupt arrived
0253   006D 51 14 00      add sp, 20
0254   0070             ; now load next process in queue
0255   0070 1D 5A 18      mov al, [active_proc_index]
0256   0073 31 59 18      mov bl, [nbr_active_procs]
0257   0076 BA            cmp al, bl
0258   0077 C6 7E 00      je int6_cycle_back
0259   007A 7A            inc al                            ; next process is next in the series
0260   007B 0A 80 00      jmp int6_continue
0261   007E             int6_cycle_back:
0262   007E 19 01         mov al, 1                         ; next process = process 1
0263   0080             int6_continue:
0264   0080 3D 5A 18      mov [active_proc_index], al       ; set next active proc
0265   0083             
0266   0083             ; calculate LUT entry for next process
0267   0083 22 00         mov ah, 0
0268   0085 FD 99         shl a                             ; x2
0269   0087 B7 9F 10      mov a, [proc_table_convert + a]   ; get process state start index  
0270   008A               
0271   008A 4D            mov si, a                         ; source is proc state block
0272   008B 48            mov a, sp
0273   008C 5F 13 00      sub a, 19
0274   008F 4F            mov di, a                         ; destination is kernel stack
0275   0090             ; restore SP
0276   0090 7D            dec a
0277   0091 47            mov sp, a
0278   0092 38 14 00      mov c, 20
0279   0095 FD F5         rep movsb
0280   0097             ; set vm process
0281   0097 1D 5A 18      mov al, [active_proc_index]
0282   009A 01            setptb
0283   009B F2 E0 FF 00   mov byte[_timer_c_0], 0           ; load counter 0 low byte
0284   009F F2 E0 FF 10   mov byte[_timer_c_0], $10         ; load counter 0 high byte
0285   00A3 4C            popa
0286   00A4 06            sysret
0287   00A5             
0288   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0289   00A5             ; uart0 interrupt
0290   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0291   00A5             int_7_uart0:
0292   00A5 D7            push a
0293   00A6 DA            push d
0294   00A7 E1            pushf
0295   00A8 14 5F 18      mov a, [fifo_in]
0296   00AB 3C            mov d, a
0297   00AC 1D 80 FF      mov al, [_uart0_data]       ; get character
0298   00AF B9 03         cmp al, $03                 ; ctrl-c
0299   00B1 C6 CE 00      je ctrlc
0300   00B4 B9 1A         cmp al, $1a                 ; ctrl-z
0301   00B6 C6 D4 00      je ctrlz
0302   00B9 3E            mov [d], al                 ; add to fifo
0303   00BA 14 5F 18      mov a, [fifo_in]
0304   00BD 77            inc a
0305   00BE AF B1 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0306   00C1 C7 C7 00      jne int_7_continue
0307   00C4 10 B1 1F      mov a, fifo  
0308   00C7             int_7_continue:  
0309   00C7 42 5F 18      mov [fifo_in], a            ; update fifo pointer
0310   00CA EE            popf
0311   00CB E7            pop d
0312   00CC E4            pop a  
0313   00CD 06            sysret
0314   00CE             ctrlc:
0315   00CE 51 05 00      add sp, 5
0316   00D1 0A A9 0F      jmp syscall_terminate_proc
0317   00D4             ctrlz:
0318   00D4 EE            popf
0319   00D5 E7            pop d
0320   00D6 E4            pop a
0321   00D7 0A EC 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0322   00DA             
0323   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0324   00DA             ; floppy drive syscalls
0325   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0326   00DA             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0327   00DA             ; fdc_40_ff:
0328   00DA             ;   .fill 40,  $ff    ; or 00                                                                                
0329   00DA             ; fdc_128_format_inner:
0330   00DA             ;   .fill 6,   $00    ;                                                                            <--|        
0331   00DA             ;   .fill 1,   $fe    ; id address mark                                                               |        
0332   00DA             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0333   00DA             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0334   00DA             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0335   00DA             ;   .fill 1,   $00    ; sector length                                                                 |                        
0336   00DA             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0337   00DA             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0338   00DA             ;   .fill 6,   $00    ;                                                                               |                        
0339   00DA             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0340   00DA             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0341   00DA             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0342   00DA             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0343   00DA             ; fdc_128_format_end:
0344   00DA             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0345   00DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0346   00DA             fdc_jmptbl:
0347   00DA F4 00         .dw syscall_fdc_restore
0348   00DC F9 00         .dw syscall_fdc_step
0349   00DE FA 00         .dw syscall_fdc_step_in
0350   00E0 FF 00         .dw syscall_fdc_step_out
0351   00E2 04 01         .dw syscall_fdc_seek
0352   00E4 07 01         .dw syscall_fdc_format
0353   00E6 05 01         .dw syscall_fdc_read_addr
0354   00E8 2B 01         .dw syscall_fdc_read_track
0355   00EA 4F 01         .dw syscall_fdc_read_sect
0356   00EC 7A 01         .dw syscall_fdc_write_sect
0357   00EE 06 01         .dw syscall_fdc_force_int
0358   00F0             syscall_fdc:
0359   00F0 FD 0A DA 00   jmp [fdc_jmptbl + al]
0360   00F4             
0361   00F4             syscall_fdc_restore:
0362   00F4 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0363   00F8 06            sysret
0364   00F9             
0365   00F9             syscall_fdc_step:
0366   00F9 06            sysret
0367   00FA             
0368   00FA             syscall_fdc_step_in:
0369   00FA F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0370   00FE 06            sysret
0371   00FF             
0372   00FF             syscall_fdc_step_out:
0373   00FF F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0374   0103 06            sysret
0375   0104             
0376   0104             syscall_fdc_seek:
0377   0104 06            sysret
0378   0105             
0379   0105             syscall_fdc_read_addr:
0380   0105 06            sysret
0381   0106             
0382   0106             syscall_fdc_force_int:
0383   0106 06            sysret
0384   0107             
0385   0107             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0386   0107             ; in the ram formatting block because they are all set as 00 right now
0387   0107             ; bl: track number
0388   0107             syscall_fdc_format:
0389   0107 FD 3D C9 FF   mov [_fdc_track], bl
0390   010B F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0391   010F 07 09 02      call fdc_wait_64us
0392   0112             ;fdc_wait_busy_high:
0393   0112             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0394   0112             ;  test al, $01                ; 
0395   0112             ;  jz fdc_wait_busy_high
0396   0112 FD 4D B1 25   mov si, transient_area
0397   0116             fdc_format_drq:
0398   0116 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0399   0119 93 01         test al, $01                ; 4
0400   011B C6 2A 01      jz fdc_format_end           ; 8
0401   011E 93 02         test al, $02                ; 4
0402   0120 C6 16 01      jz fdc_format_drq           ; 8
0403   0123 F6            lodsb                       ; 7
0404   0124 3D CB FF      mov [_fdc_data], al      ; 10   
0405   0127 0A 16 01      jmp fdc_format_drq
0406   012A             fdc_format_end:
0407   012A 06            sysret
0408   012B             
0409   012B             syscall_fdc_read_track:
0410   012B F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0411   012F 07 09 02      call fdc_wait_64us
0412   0132             ;fdc_wait_busy_high1:
0413   0132             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0414   0132             ;  test al, $01                    ; 
0415   0132             ;  jz fdc_wait_busy_high1
0416   0132 FD 4F B1 25   mov di, transient_area
0417   0136             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0418   0136 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0419   0139 93 01         test al, $01                ; check busy bit
0420   013B C6 4A 01      jz fdc_read_track_end
0421   013E 93 02         test al, $02                ; check drq bit
0422   0140 C6 36 01      jz fdc_read_track_l0
0423   0143 1D CB FF      mov al, [_fdc_data]     ; 
0424   0146 F7            stosb
0425   0147 0A 36 01      jmp fdc_read_track_l0
0426   014A             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0427   014A             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0428   014A             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0429   014A             fdc_read_track_end:
0430   014A 50            mov a, di
0431   014B 5F B1 25      sub a, transient_area
0432   014E 06            sysret
0433   014F             
0434   014F             ; sector in al
0435   014F             ; track in ah
0436   014F             syscall_fdc_read_sect:
0437   014F 3D CA FF      mov [_fdc_sector], al
0438   0152 1A            mov al, ah
0439   0153 3D C9 FF      mov [_fdc_track], al
0440   0156 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0441   015A 07 09 02      call fdc_wait_64us
0442   015D             ;fdc_wait_busy_high2:
0443   015D             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0444   015D             ;  test al, $01                ; 
0445   015D             ;  jz fdc_wait_busy_high2
0446   015D FD 4F B1 25   mov di, transient_area
0447   0161             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0448   0161 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0449   0164 93 01         test al, $01                ; check drq bit
0450   0166 C6 75 01      jz fdc_read_sect_end
0451   0169 93 02         test al, $02                ; check drq bit
0452   016B C6 61 01      jz fdc_read_sect_l0
0453   016E 1D CB FF      mov al, [_fdc_data]     ; 
0454   0171 F7            stosb
0455   0172 0A 61 01      jmp fdc_read_sect_l0
0456   0175             fdc_read_sect_end:
0457   0175 50            mov a, di
0458   0176 5F B1 25      sub a, transient_area
0459   0179 06            sysret
0460   017A             
0461   017A             ; sector in al
0462   017A             ; track in ah
0463   017A             ; data pointer in si
0464   017A             syscall_fdc_write_sect:
0465   017A 3D CA FF      mov [_fdc_sector], al
0466   017D 1A            mov al, ah
0467   017E 3D C9 FF      mov [_fdc_track], al
0468   0181 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0469   0185 07 09 02      call fdc_wait_64us
0470   0188             ;fdc_wait_busy_high2:
0471   0188             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0472   0188             ;  test al, $01                ; 
0473   0188             ;  jz fdc_wait_busy_high2
0474   0188             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0475   0188 1D C8 FF      mov al, [_fdc_stat_cmd]  ; 10
0476   018B 93 01         test al, $01                ; 4
0477   018D C6 9C 01      jz fdc_write_sect_end           ; 8
0478   0190 93 02         test al, $02                ; 4
0479   0192 C6 88 01      jz fdc_write_sect_l0           ; 8
0480   0195 F6            lodsb                       ; 7
0481   0196 3D CB FF      mov [_fdc_data], al      ; 10   
0482   0199 0A 88 01      jmp fdc_write_sect_l0
0483   019C             fdc_write_sect_end:
0484   019C 06            sysret
0485   019D             
0486   019D             fdc_format_mem:
0487   019D 3B 01 00      mov d, 1
0488   01A0 FD 4F B1 25   mov di, transient_area
0489   01A4             ; 40 * FF
0490   01A4 38 28 00      mov c, 40
0491   01A7 19 FF         mov al, $ff
0492   01A9             fdc_l0: 
0493   01A9 F7            stosb
0494   01AA 7E            dec c
0495   01AB C7 A9 01      jnz fdc_l0
0496   01AE             ; 6 * 00
0497   01AE             fdc_inner_loop:
0498   01AE 38 06 00      mov c, 6
0499   01B1 19 00         mov al, $00
0500   01B3             fdc_l1:
0501   01B3 F7            stosb
0502   01B4 7E            dec c
0503   01B5 C7 B3 01      jnz fdc_l1
0504   01B8             ; FE address mark
0505   01B8             fdc_l2:
0506   01B8 19 FE         mov al, $fe
0507   01BA F7            stosb
0508   01BB             ; track number
0509   01BB             fdc_l3:
0510   01BB 19 00         mov al, $00
0511   01BD F7            stosb
0512   01BE             ; side number
0513   01BE             fdc_l4:
0514   01BE 19 00         mov al, $00
0515   01C0 F7            stosb
0516   01C1             ; sector number
0517   01C1             fdc_l5:
0518   01C1 13            mov a, d
0519   01C2 F7            stosb
0520   01C3             ; sector length 128 bytes
0521   01C3             fdc_l6:
0522   01C3 19 00         mov al, $00
0523   01C5 F7            stosb
0524   01C6             ; 2 crc's
0525   01C6             fdc_l7:
0526   01C6 19 F7         mov al, $f7
0527   01C8 F7            stosb
0528   01C9             ; 11 times $ff
0529   01C9 38 0B 00      mov c, 11
0530   01CC 19 FF         mov al, $ff
0531   01CE             fdc_l8:
0532   01CE F7            stosb
0533   01CF 7E            dec c
0534   01D0 C7 CE 01      jnz fdc_l8
0535   01D3             ; 6 times 00
0536   01D3 38 06 00      mov c, 6
0537   01D6 19 00         mov al, $00
0538   01D8             fdc_l9:
0539   01D8 F7            stosb
0540   01D9 7E            dec c
0541   01DA C7 D8 01      jnz fdc_l9
0542   01DD             ; FB data address mark
0543   01DD 19 FB         mov al, $fb
0544   01DF             fdc_l10:
0545   01DF F7            stosb
0546   01E0             ; 128 bytes sector data
0547   01E0 38 80 00      mov c, 128
0548   01E3 19 E5         mov al, $E5
0549   01E5             fdc_l11:
0550   01E5 F7            stosb
0551   01E6 7E            dec c
0552   01E7 C7 E5 01      jnz fdc_l11
0553   01EA             ; 2 crc's
0554   01EA             fdc_l12:
0555   01EA 19 F7         mov al, $f7
0556   01EC F7            stosb
0557   01ED             ; 10 * $FF
0558   01ED 38 0A 00      mov c, 10
0559   01F0 19 FF         mov al, $ff
0560   01F2             fdc_l13:
0561   01F2 F7            stosb
0562   01F3 7E            dec c
0563   01F4 C7 F2 01      jnz fdc_l13
0564   01F7             ; check whether we did this 16 times
0565   01F7 79            inc d
0566   01F8 C5 11 00      cmp d, 17
0567   01FB C7 AE 01      jne fdc_inner_loop
0568   01FE             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0569   01FE 38 F4 01      mov c, 500
0570   0201 19 FF         mov al, $ff
0571   0203             fdc_format_footer:
0572   0203             fdc_footer_drq_loop:
0573   0203 F7            stosb
0574   0204 7E            dec c
0575   0205 C7 03 02      jnz fdc_footer_drq_loop
0576   0208 09            ret
0577   0209             
0578   0209             ; fetch is 2 cycles long when 'display_reg_load' is false.
0579   0209             ; 64us amounts to 160 cycles of the 2.5mhz clock
0580   0209             ; call u16 is 14 cycles long
0581   0209             ; 160 - 5 - 14 = 
0582   0209             fdc_wait_64us:
0583   0209 3A 01         mov cl, 1                       ; 5 cycles
0584   020B             fdc_wait_64_loop:
0585   020B 81            dec cl                           ; 3 cycles
0586   020C C7 0B 02      jnz fdc_wait_64_loop             ; 8 cycles
0587   020F 09            ret
0588   0210             
0589   0210             ; ------------------------------------------------------------------------------------------------------------------;
0590   0210             ; system syscalls
0591   0210             ; ------------------------------------------------------------------------------------------------------------------;
0592   0210             system_jmptbl:
0593   0210 46 02         .dw system_uname
0594   0212 4D 02         .dw system_whoami
0595   0214 20 02         .dw system_setparam
0596   0216 23 02         .dw system_bootloader_install
0597   0218 1E 02         .dw system_getparam
0598   021A             syscall_system:
0599   021A FD 0A 10 02   jmp [system_jmptbl + al]
0600   021E             
0601   021E             ; param register address in register d
0602   021E             ; param value in register bl
0603   021E             system_getparam:
0604   021E 32            mov bl, [d]
0605   021F 06            sysret
0606   0220             
0607   0220             ; param register address in register d
0608   0220             ; param value in register bl
0609   0220             system_setparam:
0610   0220 FD 3E         mov [d], bl
0611   0222 06            sysret
0612   0223             
0613   0223             ; kernel LBA address in 'b'
0614   0223             system_bootloader_install:
0615   0223 D8            push b
0616   0224 26 00 00      mov b, 0
0617   0227 38 00 00      mov c, 0
0618   022A 22 01         mov ah, $01                 ; 1 sector
0619   022C 3B B1 25      mov d, transient_area
0620   022F 07 7C 05      call ide_read_sect          ; read sector
0621   0232 E5            pop b
0622   0233 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0623   0237 26 00 00      mov b, 0
0624   023A 38 00 00      mov c, 0
0625   023D 22 01         mov ah, $01                 ; 1 sector
0626   023F 3B B1 25      mov d, transient_area
0627   0242 07 A2 05      call ide_write_sect         ; write sector
0628   0245 06            sysret
0629   0246             
0630   0246             system_uname:
0631   0246 3B 70 18      mov d, s_uname
0632   0249 07 29 13      call _puts
0633   024C 06            sysret
0634   024D             
0635   024D             system_whoami:
0636   024D 06            sysret
0637   024E             
0638   024E             ; reboot system
0639   024E             syscall_reboot:
0640   024E FD D7 FF FF   push word $ffff 
0641   0252 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0642   0255 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0643   0259 06            sysret
0644   025A             
0645   025A             ;------------------------------------------------------------------------------------------------------;;
0646   025A             ; switch to another process
0647   025A             ; inputs:
0648   025A             ; al = new process number
0649   025A             ;------------------------------------------------------------------------------------------------------;;
0650   025A             syscall_resume_proc:
0651   025A FD 78         mov g, a                            ; save the process number
0652   025C 4B            pusha                               ; save all registers into kernel stack
0653   025D 22 00         mov ah, 0
0654   025F 1D 5A 18      mov al, [active_proc_index]
0655   0262 FD 99         shl a              ; x2
0656   0264 B7 9F 10      mov a, [proc_table_convert + a]     ; get process state start index
0657   0267 4F            mov di, a
0658   0268 48            mov a, sp
0659   0269 77            inc a
0660   026A 4D            mov si, a
0661   026B 38 14 00      mov c, 20
0662   026E FD F5         rep movsb                           ; save process state!
0663   0270             ; restore kernel stack position to point before interrupt arrived
0664   0270 51 14 00      add sp, 20
0665   0273             ; now load the new process number!
0666   0273 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0667   0275 3D 5A 18      mov [active_proc_index], al         ; set new active proc
0668   0278             ; calculate lut entry for next process
0669   0278 22 00         mov ah, 0
0670   027A FD 99         shl a                               ; x2
0671   027C B7 9F 10      mov a, [proc_table_convert + a]     ; get process state start index  
0672   027F 4D            mov si, a                           ; source is proc state block
0673   0280 48            mov a, sp
0674   0281 5F 13 00      sub a, 19
0675   0284 4F            mov di, a                           ; destination is kernel stack
0676   0285             ; restore sp
0677   0285 7D            dec a
0678   0286 47            mov sp, a
0679   0287 38 14 00      mov c, 20
0680   028A FD F5         rep movsb
0681   028C             ; set vm process
0682   028C 1D 5A 18      mov al, [active_proc_index]
0683   028F 01            setptb
0684   0290 4C            popa
0685   0291 06            sysret
0686   0292             
0687   0292             ;------------------------------------------------------------------------------------------------------;;
0688   0292             ; list processes
0689   0292             ;------------------------------------------------------------------------------------------------------;;
0690   0292             syscall_list_procs:
0691   0292 3B 91 18      mov d, s_ps_header
0692   0295 07 29 13      call _puts
0693   0298 3B 22 1B      mov d, proc_availab_table + 1
0694   029B 38 01 00      mov c, 1
0695   029E             list_procs_l0:  
0696   029E BD 01         cmp byte[d], 1
0697   02A0 C7 C4 02      jne list_procs_next
0698   02A3 2D            mov b, d
0699   02A4 61 21 1B      sub b, proc_availab_table
0700   02A7 FD 9F 05      shl b, 5
0701   02AA DA            push d
0702   02AB D8            push b
0703   02AC 28            mov b, c
0704   02AD 07 C9 13      call print_u8x
0705   02B0 22 20         mov ah, ' '
0706   02B2 07 FD 11      call _putchar
0707   02B5 07 FD 11      call _putchar
0708   02B8 E5            pop b
0709   02B9 74            mov d, b
0710   02BA 58 31 1B      add d, proc_names
0711   02BD 07 29 13      call _puts
0712   02C0 07 D6 12      call printnl
0713   02C3 E7            pop d
0714   02C4             list_procs_next:
0715   02C4 79            inc d
0716   02C5 78            inc c
0717   02C6 C2 09 00      cmp c, 9
0718   02C9 C7 9E 02      jne list_procs_l0
0719   02CC             list_procs_end:
0720   02CC 06            sysret
0721   02CD             
0722   02CD             ; ------------------------------------------------------------------------------------------------------------------;
0723   02CD             ; exceptions code block
0724   02CD             ; ------------------------------------------------------------------------------------------------------------------;
0725   02CD             ; privilege exception
0726   02CD             ; ------------------------------------------------------------------------------------------------------------------;
0727   02CD             trap_privilege:
0728   02CD 0A 4E 02      jmp syscall_reboot
0729   02D0 DA            push d
0730   02D1 3B E0 18      mov d, s_priviledge
0731   02D4 07 29 13      call _puts
0732   02D7 E7            pop d
0733   02D8 06            sysret
0734   02D9             
0735   02D9             ; ------------------------------------------------------------------------------------------------------------------;
0736   02D9             ; breakpoint
0737   02D9             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0738   02D9             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0739   02D9             ; ------------------------------------------------------------------------------------------------------------------;
0740   02D9             syscall_break:
0741   02D9 4B            pusha
0742   02DA             syscall_break_prompt:
0743   02DA 3B 94 03      mov d, s_break1
0744   02DD 07 29 13      call _puts
0745   02E0 07 D6 12      call printnl
0746   02E3 07 2B 14      call scan_u16d
0747   02E6 AF 00 00      cmp a, 0
0748   02E9 C6 F4 02      je syscall_break_regs
0749   02EC AF 01 00      cmp a, 1
0750   02EF C6 17 03      je syscall_break_mem
0751   02F2             syscall_break_end:  
0752   02F2 4C            popa
0753   02F3 06            sysret
0754   02F4             syscall_break_regs:
0755   02F4 48            mov a, sp
0756   02F5 53 0E 00      add a, 14               ; back-track 7 registers
0757   02F8 3C            mov d, a
0758   02F9 3A 07         mov cl, 7
0759   02FB             syscall_regs_l0:
0760   02FB 2A            mov b, [d]
0761   02FC FD AB         swp b
0762   02FE 07 85 13      call print_u16x         ; print register value
0763   0301 07 D6 12      call printnl
0764   0304 63 02 00      sub d, 2
0765   0307 71 01         sub cl, 1
0766   0309 C3 00         cmp cl, 0
0767   030B C7 FB 02      jne syscall_regs_l0
0768   030E 0A DA 02      jmp syscall_break_prompt
0769   0311 07 D6 12      call printnl
0770   0314 0A DA 02      jmp syscall_break_prompt
0771   0317             syscall_break_mem:
0772   0317 07 D6 12      call printnl
0773   031A 07 A7 13      call scan_u16x
0774   031D 4D            mov si, a               ; data source from user space
0775   031E FD 4F B1 23   mov di, scrap_sector    ; destination in kernel space
0776   0322 38 00 02      mov c, 512
0777   0325 04            load                    ; transfer data to kernel space!
0778   0326 3B B1 23      mov d, scrap_sector     ; dump pointer in d
0779   0329 38 00 00      mov c, 0
0780   032C             dump_loop:
0781   032C 84            mov al, cl
0782   032D 87 0F         and al, $0f
0783   032F C6 7D 03      jz print_base
0784   0332             back:
0785   0332 1E            mov al, [d]             ; read byte
0786   0333 2F            mov bl, al
0787   0334 07 C9 13      call print_u8x
0788   0337 10 00 20      mov a, $2000
0789   033A 05 03         syscall sys_io          ; space
0790   033C 84            mov al, cl
0791   033D 87 0F         and al, $0f
0792   033F B9 0F         cmp al, $0f
0793   0341 C6 52 03      je print_ascii
0794   0344             back1:
0795   0344 79            inc d
0796   0345 78            inc c
0797   0346 C2 00 02      cmp c, 512
0798   0349 C7 2C 03      jne dump_loop
0799   034C 07 D6 12      call printnl
0800   034F 0A DA 02      jmp syscall_break_prompt  ; go to syscall_break return point
0801   0352             print_ascii:
0802   0352 10 00 20      mov a, $2000
0803   0355 05 03         syscall sys_io
0804   0357 63 10 00      sub d, 16
0805   035A 26 10 00      mov b, 16
0806   035D             print_ascii_l:
0807   035D 79            inc d
0808   035E 1E            mov al, [d]               ; read byte
0809   035F B9 20         cmp al, $20
0810   0361 C8 69 03      jlu dot
0811   0364 B9 7E         cmp al, $7e
0812   0366 D0 71 03      jleu ascii
0813   0369             dot:
0814   0369 10 00 2E      mov a, $2e00
0815   036C 05 03         syscall sys_io
0816   036E 0A 76 03      jmp ascii_continue
0817   0371             ascii:
0818   0371 23            mov ah, al
0819   0372 19 00         mov al, 0
0820   0374 05 03         syscall sys_io
0821   0376             ascii_continue:
0822   0376 FD A9 5D 03   loopb print_ascii_l
0823   037A 0A 44 03      jmp back1
0824   037D             print_base:
0825   037D 07 D6 12      call printnl
0826   0380 2D            mov b, d
0827   0381 61 B1 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0828   0384 07 85 13      call print_u16x          ; display row
0829   0387 10 00 3A      mov a, $3a00
0830   038A 05 03         syscall sys_io
0831   038C 10 00 20      mov a, $2000
0832   038F 05 03         syscall sys_io
0833   0391 0A 32 03      jmp back
0834   0394             
0835   0394             s_break1:  
0836   0394 0A 64 65 62   .db "\ndebugger entry point.\n"
0836   0398 75 67 67 65 
0836   039C 72 20 65 6E 
0836   03A0 74 72 79 20 
0836   03A4 70 6F 69 6E 
0836   03A8 74 2E 0A 
0837   03AB 30 2E 20 73   .db "0. show registers\n"
0837   03AF 68 6F 77 20 
0837   03B3 72 65 67 69 
0837   03B7 73 74 65 72 
0837   03BB 73 0A 
0838   03BD 31 2E 20 73   .db "1. show 512b ram block\n"
0838   03C1 68 6F 77 20 
0838   03C5 35 31 32 62 
0838   03C9 20 72 61 6D 
0838   03CD 20 62 6C 6F 
0838   03D1 63 6B 0A 
0839   03D4 32 2E 20 63   .db "2. continue execution", 0
0839   03D8 6F 6E 74 69 
0839   03DC 6E 75 65 20 
0839   03E0 65 78 65 63 
0839   03E4 75 74 69 6F 
0839   03E8 6E 00 
0840   03EA             
0841   03EA             ; ------------------------------------------------------------------------------------------------------------------;
0842   03EA             ; divide by zero exception
0843   03EA             ; ------------------------------------------------------------------------------------------------------------------;
0844   03EA             trap_div_zero:
0845   03EA D7            push a
0846   03EB DA            push d
0847   03EC E1            pushf
0848   03ED 3B F7 18      mov d, s_divzero
0849   03F0 07 29 13      call _puts
0850   03F3 EE            popf
0851   03F4 E7            pop d
0852   03F5 E4            pop a
0853   03F6 06            sysret ; enable interrupts
0854   03F7             
0855   03F7             ; ------------------------------------------------------------------------------------------------------------------;
0856   03F7             ; undefined opcode exception
0857   03F7             ; ------------------------------------------------------------------------------------------------------------------;
0858   03F7             trap_undef_opcode:
0859   03F7 06            sysret
0860   03F8             
0861   03F8             ; ------------------------------------------------------------------------------------------------------------------;
0862   03F8             ; real-time clock services syscall
0863   03F8             ; rtc i/o bank = ffa0 to ffaf
0864   03F8             ; ffa0 to ffa7 is scratch ram
0865   03F8             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0866   03F8             ; al = 0..6 -> get
0867   03F8             ; al = 7..d -> set
0868   03F8             ; ------------------------------------------------------------------------------------------------------------------;
0869   03F8             syscall_rtc:
0870   03F8 DB            push al
0871   03F9 DA            push d
0872   03FA B9 06         cmp al, 6
0873   03FC D1 11 04      jgu syscall_rtc_set
0874   03FF             syscall_rtc_get:
0875   03FF 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0876   0401 22 FF         mov ah, $ff    
0877   0403 3C            mov d, a                ; get to ffa9 + offset
0878   0404 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0879   0408 1E            mov al, [d]             ; get data
0880   0409 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0881   040D 23            mov ah, al
0882   040E E7            pop d
0883   040F E8            pop al
0884   0410 06            sysret
0885   0411             syscall_rtc_set:
0886   0411 DD            push bl
0887   0412 99            mov bl, ah              ; set data aside
0888   0413 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0889   0415 22 FF         mov ah, $ff    
0890   0417 3C            mov d, a                ; get to ffa9 + offset
0891   0418 1B            mov al, bl              ; get data back
0892   0419 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0893   041D 3E            mov [d], al             ; set data
0894   041E F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0895   0422 EA            pop bl
0896   0423 E7            pop d
0897   0424 E8            pop al
0898   0425 06            sysret
0899   0426             
0900   0426             datetime_serv_tbl:
0901   0426 2E 04         .dw print_date
0902   0428 A2 04         .dw set_date
0903   042A             syscall_datetime:
0904   042A FD 0A 26 04   jmp [datetime_serv_tbl + al]      
0905   042E             print_date:
0906   042E 10 00 0D      mov a, $0d00           ; print carriage return char
0907   0431 19 03         mov al, 3
0908   0433 05 01         syscall sys_rtc        ; get week
0909   0435 1A            mov al, ah
0910   0436 22 00         mov ah, 0
0911   0438 FD 9D 02      shl a, 2          
0912   043B 3B 81 19      mov d, s_week
0913   043E 59            add d, a
0914   043F 07 29 13      call _puts
0915   0442 10 00 20      mov a, $2000
0916   0445 05 03         syscall sys_io         ; display ' '
0917   0447 19 04         mov al, 4
0918   0449 05 01         syscall sys_rtc        ; get day
0919   044B 99            mov bl, ah
0920   044C 07 C9 13      call print_u8x
0921   044F 10 00 20      mov a, $2000
0922   0452 05 03         syscall sys_io         ; display ' '
0923   0454             ; there is a problem with the month displaying
0924   0454             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0925   0454             ; even though it is to be understood as bcd.
0926   0454             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0927   0454 19 05         mov al, 05
0928   0456 05 01         syscall sys_rtc        ; get month
0929   0458 1A            mov al, ah
0930   0459 22 00         mov ah, 0
0931   045B FD 9D 02      shl a, 2          
0932   045E 3B 4D 19      mov d, s_months
0933   0461 59            add d, a
0934   0462 07 29 13      call _puts
0935   0465 10 00 20      mov a, $2000
0936   0468 05 03         syscall sys_io         ; display ' '
0937   046A 2E 20         mov bl, $20
0938   046C 07 C9 13      call print_u8x         ; print 20 for year prefix
0939   046F 19 06         mov al, 06
0940   0471 05 01         syscall sys_rtc        ; get year
0941   0473 99            mov bl, ah
0942   0474 07 C9 13      call print_u8x
0943   0477 10 00 20      mov a, $2000  
0944   047A 05 03         syscall sys_io         ; display ' '
0945   047C 19 02         mov al, 2
0946   047E 05 01         syscall sys_rtc        ; get hours
0947   0480 99            mov bl, ah
0948   0481 07 C9 13      call print_u8x
0949   0484 10 00 3A      mov a, $3a00    
0950   0487 05 03         syscall sys_io         ; display ':'
0951   0489 19 01         mov al, 01
0952   048B 05 01         syscall sys_rtc        ; get minutes
0953   048D 99            mov bl, ah
0954   048E 07 C9 13      call print_u8x
0955   0491 10 00 3A      mov a, $3a00  
0956   0494 05 03         syscall sys_io         ; display ':'
0957   0496 19 00         mov al, 0
0958   0498 05 01         syscall sys_rtc        ; get seconds
0959   049A 99            mov bl, ah
0960   049B 07 C9 13      call print_u8x
0961   049E 07 D6 12      call printnl
0962   04A1 06            sysret
0963   04A2             set_date:
0964   04A2 3B 12 19      mov d, s_set_year
0965   04A5 07 29 13      call _puts
0966   04A8 07 14 14      call scan_u8x          ; read integer into a
0967   04AB FD 9D 08      shl a, 8               ; only al used, move to ah
0968   04AE 19 0D         mov al, 0dh            ; set rtc year
0969   04B0 05 01         syscall sys_rtc        ; set rtc
0970   04B2 3B 19 19      mov d, s_set_month
0971   04B5 07 29 13      call _puts
0972   04B8 07 14 14      call scan_u8x          ; read integer into a
0973   04BB FD 9D 08      shl a, 8               ; only al used, move to ah
0974   04BE 19 0C         mov al, 0ch            ; set rtc month
0975   04C0 05 01         syscall sys_rtc        ; set rtc
0976   04C2 3B 21 19      mov d, s_set_day
0977   04C5 07 29 13      call _puts
0978   04C8 07 14 14      call scan_u8x          ; read integer into a
0979   04CB FD 9D 08      shl a, 8               ; only al used, move to ah
0980   04CE 19 0B         mov al, 0bh            ; set rtc month
0981   04D0 05 01         syscall sys_rtc        ; set rtc
0982   04D2 3B 27 19      mov d, s_set_week
0983   04D5 07 29 13      call _puts
0984   04D8 07 14 14      call scan_u8x          ; read integer into a
0985   04DB FD 9D 08      shl a, 8               ; only al used, move to ah
0986   04DE 19 0A         mov al, 0ah            ; set rtc month
0987   04E0 05 01         syscall sys_rtc        ; set rtc
0988   04E2 3B 31 19      mov d, s_set_hours
0989   04E5 07 29 13      call _puts
0990   04E8 07 14 14      call scan_u8x          ; read integer into a
0991   04EB FD 9D 08      shl a, 8               ; only al used, move to ah
0992   04EE 19 09         mov al, 09h            ; set rtc month
0993   04F0 05 01         syscall sys_rtc        ; set rtc
0994   04F2 3B 39 19      mov d, s_set_minutes
0995   04F5 07 29 13      call _puts
0996   04F8 07 14 14      call scan_u8x          ; read integer into a
0997   04FB FD 9D 08      shl a, 8               ; only al used, move to ah
0998   04FE 19 08         mov al, 08h            ; set rtc month
0999   0500 05 01         syscall sys_rtc        ; set rtc
1000   0502 3B 43 19      mov d, s_set_seconds
1001   0505 07 29 13      call _puts
1002   0508 07 14 14      call scan_u8x          ; read integer into a
1003   050B FD 9D 08      shl a, 8               ; only al used, move to ah
1004   050E 19 07         mov al, 07h            ; set rtc month
1005   0510 05 01         syscall sys_rtc        ; set rtc
1006   0512 06            sysret
1007   0513             
1008   0513             ; ------------------------------------------------------------------------------------------------------------------;
1009   0513             ; ide services syscall
1010   0513             ; al = option
1011   0513             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1012   0513             ; ide read/write sector
1013   0513             ; 512 bytes
1014   0513             ; user buffer pointer in d
1015   0513             ; ah = number of sectors
1016   0513             ; cb = lba bytes 3..0
1017   0513             ; ------------------------------------------------------------------------------------------------------------------;
1018   0513 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
1018   0517 73 63 61 6C 
1018   051B 6C 5F 69 64 
1018   051F 65 20 63 61 
1018   0523 6C 6C 65 64 
1018   0527 3A 20 00 
1019   052A             ide_serv_tbl:
1020   052A 51 05         .dw ide_reset
1021   052C 65 05         .dw ide_sleep
1022   052E 74 05         .dw ide_read_sect_wrapper
1023   0530 78 05         .dw ide_write_sect_wrapper
1024   0532             syscall_ide:
1025   0532 DD            push bl
1026   0533 31 52 18      mov bl, [sys_debug_mode]
1027   0536               ; debug block
1028   0536 C1 00         cmp bl, 0
1029   0538 EA            pop bl
1030   0539 C6 4D 05      je syscall_ide_jmp
1031   053C DA            push d
1032   053D DD            push bl
1033   053E 3B 13 05      mov d, s_syscall_ide_dbg0
1034   0541 07 29 13      call _puts
1035   0544 2F            mov bl, al
1036   0545 07 C9 13      call print_u8x
1037   0548 07 D6 12      call printnl
1038   054B EA            pop bl
1039   054C E7            pop d
1040   054D             syscall_ide_jmp:
1041   054D FD 0A 2A 05   jmp [ide_serv_tbl + al]    
1042   0551               
1043   0551             ide_reset:      
1044   0551 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1045   0555 07 FE 05      call ide_wait                   ; wait for ide ready             
1046   0558 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1047   055C F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1048   0560 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1049   0564 06            sysret
1050   0565             ide_sleep:
1051   0565 07 FE 05      call ide_wait                   ; wait for ide ready             
1052   0568 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1053   056C F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1054   0570 07 FE 05      call ide_wait                   ; wait for ide ready
1055   0573 06            sysret
1056   0574             ide_read_sect_wrapper:
1057   0574 07 7C 05      call ide_read_sect
1058   0577 06            sysret
1059   0578             ide_write_sect_wrapper:
1060   0578 07 A2 05      call ide_write_sect
1061   057B 06            sysret
1062   057C             ide_read_sect:
1063   057C 1A            mov al, ah
1064   057D 24            mov ah, bl
1065   057E 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1066   0581 1C            mov al, bh
1067   0582 3D D4 FF      mov [_ide_r4], al
1068   0585 12            mov a, c
1069   0586 3D D5 FF      mov [_ide_r5], al
1070   0589 1A            mov al, ah
1071   058A 87 0F         and al, %00001111
1072   058C 8B E0         or al, %11100000                ; mode lba, master
1073   058E 3D D6 FF      mov [_ide_r6], al
1074   0591             ide_read_sect_wait:
1075   0591 1D D7 FF      mov al, [_ide_r7]  
1076   0594 87 80         and al, $80                     ; busy flag
1077   0596 C7 91 05      jnz ide_read_sect_wait
1078   0599 19 20         mov al, $20
1079   059B 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1080   059E 07 C8 05      call ide_read  
1081   05A1 09            ret
1082   05A2             ide_write_sect:
1083   05A2 1A            mov al, ah
1084   05A3 24            mov ah, bl
1085   05A4 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1086   05A7 1C            mov al, bh
1087   05A8 3D D4 FF      mov [_ide_r4], al
1088   05AB 12            mov a, c
1089   05AC 3D D5 FF      mov [_ide_r5], al
1090   05AF 1A            mov al, ah
1091   05B0 87 0F         and al, %00001111
1092   05B2 8B E0         or al, %11100000                ; mode lba, master
1093   05B4 3D D6 FF      mov [_ide_r6], al
1094   05B7             ide_write_sect_wait:
1095   05B7 1D D7 FF      mov al, [_ide_r7]  
1096   05BA 87 80         and al, $80                     ; busy flag
1097   05BC C7 B7 05      jnz ide_write_sect_wait
1098   05BF 19 30         mov al, $30
1099   05C1 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1100   05C4 07 E3 05      call ide_write      
1101   05C7 09            ret
1102   05C8             
1103   05C8             ;----------------------------------------------------------------------------------------------------;
1104   05C8             ; read ide data
1105   05C8             ; pointer in d
1106   05C8             ;----------------------------------------------------------------------------------------------------;
1107   05C8             ide_read:
1108   05C8 DA            push d
1109   05C9             ide_read_loop:
1110   05C9 1D D7 FF      mov al, [_ide_r7]  
1111   05CC 87 80         and al, 80h                     ; busy flag
1112   05CE C7 C9 05      jnz ide_read_loop               ; wait loop
1113   05D1 1D D7 FF      mov al, [_ide_r7]
1114   05D4 87 08         and al, %00001000               ; drq flag
1115   05D6 C6 E1 05      jz ide_read_end
1116   05D9 1D D0 FF      mov al, [_ide_r0]
1117   05DC 3E            mov [d], al
1118   05DD 79            inc d
1119   05DE 0A C9 05      jmp ide_read_loop
1120   05E1             ide_read_end:
1121   05E1 E7            pop d
1122   05E2 09            ret
1123   05E3             
1124   05E3             ;----------------------------------------------------------------------------------------------------;
1125   05E3             ; write ide data
1126   05E3             ; data pointer in d
1127   05E3             ;----------------------------------------------------------------------------------------------------;
1128   05E3             ide_write:
1129   05E3 DA            push d
1130   05E4             ide_write_loop:
1131   05E4 1D D7 FF      mov al, [_ide_r7]  
1132   05E7 87 80         and al, 80h             ; busy flag
1133   05E9 C7 E4 05      jnz ide_write_loop      ; wait loop
1134   05EC 1D D7 FF      mov al, [_ide_r7]
1135   05EF 87 08         and al, %00001000       ; drq flag
1136   05F1 C6 FC 05      jz ide_write_end
1137   05F4 1E            mov al, [d]
1138   05F5 3D D0 FF      mov [_ide_r0], al
1139   05F8 79            inc d 
1140   05F9 0A E4 05      jmp ide_write_loop
1141   05FC             ide_write_end:
1142   05FC E7            pop d
1143   05FD 09            ret
1144   05FE             
1145   05FE             ;----------------------------------------------------------------------------------------------------;
1146   05FE             ; wait for ide to be ready
1147   05FE             ;----------------------------------------------------------------------------------------------------;
1148   05FE             ide_wait:
1149   05FE 1D D7 FF      mov al, [_ide_r7]  
1150   0601 87 80         and al, 80h        ; busy flag
1151   0603 C7 FE 05      jnz ide_wait
1152   0606 09            ret
1153   0607             
1154   0607             ;----------------------------------------------------------------------------------------------------;
1155   0607             ; io syscall
1156   0607             ;----------------------------------------------------------------------------------------------------;
1157   0607             ; baud  divisor
1158   0607             ; 50    2304
1159   0607             ; 110   1047
1160   0607             ; 300    384
1161   0607             ; 600    192
1162   0607             ; 1200    96
1163   0607             ; 9600    12
1164   0607             ; 19200    6
1165   0607             ; 38400    3
1166   0607             syscall_io_jmp:
1167   0607 3A 06         .dw syscall_io_putchar
1168   0609 47 06         .dw syscall_io_getch
1169   060B 11 06         .dw syscall_io_uart_setup
1170   060D             syscall_io:
1171   060D FD 0A 07 06   jmp [syscall_io_jmp + al]
1172   0611             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1173   0611             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1174   0611             ; buffer, the transmitter holding register, or the interrupt enable register.
1175   0611             syscall_io_uart_setup:
1176   0611 1D 54 18      mov al, [sys_uart0_lcr]
1177   0614 8B 80         or al, $80                ; set dlab access bit
1178   0616 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1179   0619 1D 57 18      mov al, [sys_uart0_div0]
1180   061C 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1181   061F 1D 58 18      mov al, [sys_uart0_div1]
1182   0622 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1183   0625             
1184   0625 1D 54 18      mov al, [sys_uart0_lcr]
1185   0628 87 7F         and al, $7f               ; clear dlab access bit 
1186   062A 3D 83 FF      mov [_uart0_lcr], al
1187   062D 1D 55 18      mov al, [sys_uart0_inten]
1188   0630 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1189   0633 1D 56 18      mov al, [sys_uart0_fifoen]
1190   0636 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1191   0639 06            sysret
1192   063A             
1193   063A             ; char in ah
1194   063A             syscall_io_putchar:
1195   063A             syscall_io_putchar_l0:
1196   063A 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1197   063D 87 20         and al, $20
1198   063F C6 3A 06      jz syscall_io_putchar_l0    
1199   0642 1A            mov al, ah
1200   0643 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1201   0646 06            sysret
1202   0647             
1203   0647             ; char in ah
1204   0647             ; al = sucess code
1205   0647             syscall_io_getch:
1206   0647 D8            push b
1207   0648 DA            push d
1208   0649 FD 0C         sti
1209   064B             syscall_io_getch_l0:  
1210   064B 14 61 18      mov a, [fifo_out]
1211   064E 29 5F 18      mov b, [fifo_in]
1212   0651 B0            cmp a, b
1213   0652 C6 4B 06      je syscall_io_getch_l0
1214   0655 3C            mov d, a
1215   0656 77            inc a
1216   0657 AF B1 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1217   065A C7 60 06      jne syscall_io_getch_cont
1218   065D 10 B1 1F      mov a, fifo  
1219   0660             syscall_io_getch_cont:  
1220   0660 42 61 18      mov [fifo_out], a             ; update fifo pointer
1221   0663 1E            mov al, [d]                   ; get char
1222   0664 23            mov ah, al
1223   0665 1D 53 18      mov al, [sys_echo_on]
1224   0668 B9 01         cmp al, 1
1225   066A C7 79 06      jne syscall_io_getch_noecho 
1226   066D             ; here we just echo the char back to the console
1227   066D             syscall_io_getch_echo_l0:
1228   066D 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1229   0670 87 20         and al, $20                 ; isolate transmitter empty
1230   0672 C6 6D 06      jz syscall_io_getch_echo_l0
1231   0675 1A            mov al, ah
1232   0676 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1233   0679             syscall_io_getch_noecho:
1234   0679 19 01         mov al, 1                    ; al = 1 means a char successfully received
1235   067B E7            pop d
1236   067C E5            pop b
1237   067D 06            sysret
1238   067E             
1239   067E             ;------------------------------------------------------------------------------------------------------;
1240   067E             ; file system data
1241   067E             ;------------------------------------------------------------------------------------------------------;
1242   067E             ; infor for : ide services interrupt
1243   067E             ; ide read/write 512-byte sector
1244   067E             ; al = option
1245   067E             ; user buffer pointer in d
1246   067E             ; ah = number of sectors
1247   067E             ; cb = lba bytes 3..0  
1248   067E             ;------------------------------------------------------------------------------------------------------;
1249   067E             ; file system data structure
1250   067E             ;------------------------------------------------------------------------------------------------------;
1251   067E             ; for a directory we have the header first, followed by metadata
1252   067E             ; header 1 sector (512 bytes)
1253   067E             ; metadata 1 sector (512 bytes)
1254   067E             ; header entries:
1255   067E             ; filename (64)
1256   067E             ; parent dir lba (2) -  to be used for faster backwards navigation...
1257   067E             ;
1258   067E             ; metadata entries:
1259   067E             ; filename (24)
1260   067E             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1261   067E             ; lba (2)
1262   067E             ; size (2)
1263   067E             ; day (1)
1264   067E             ; month (1)
1265   067E             ; year (1)
1266   067E             ; packet size = 32 bytes
1267   067E             ;
1268   067E             ; first directory on disk is the root directory '/'
1269   067E             file_system_jmptbl:
1270   067E E9 06         .dw fs_mkfs                   ; 0
1271   0680 00 00         .dw 0                         ; 1
1272   0682 4B 07         .dw fs_mkdir                  ; 2
1273   0684 C4 0A         .dw fs_cd                     ; 3
1274   0686 CB 0A         .dw fs_ls                     ; 4
1275   0688 41 0C         .dw fs_mktxt                  ; 5
1276   068A 0C 0D         .dw fs_mkbin                  ; 6
1277   068C D3 0D         .dw fs_pwd                    ; 7
1278   068E F0 0D         .dw fs_cat                    ; 8
1279   0690 4C 0E         .dw fs_rmdir                  ; 9
1280   0692 A8 0E         .dw fs_rm                     ; 10
1281   0694 9C 0B         .dw fs_starcom                ; 11
1282   0696 00 00         .dw 0                         ; 12
1283   0698 00 00         .dw 0                         ; 13
1284   069A F1 06         .dw fs_chmod                  ; 14
1285   069C 10 0F         .dw fs_mv                     ; 15
1286   069E EA 06         .dw fs_cd_root                ; 16
1287   06A0 C0 0A         .dw fs_get_curr_dirid         ; 17
1288   06A2 9C 08         .dw fs_dir_id_to_path         ; 18
1289   06A4 02 09         .dw fs_path_to_dir_id_user    ; 19
1290   06A6 1C 0A         .dw fs_load_from_path_user    ; 20  
1291   06A8 8C 09         .dw fs_filepath_exists_user   ; 21
1292   06AA             
1293   06AA 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1293   06AE 79 73 63 61 
1293   06B2 6C 6C 5F 66 
1293   06B6 69 6C 65 5F 
1293   06BA 73 79 73 74 
1293   06BE 65 6D 20 63 
1293   06C2 61 6C 6C 65 
1293   06C6 64 3A 20 00 
1294   06CA             syscall_file_system:
1295   06CA DD            push bl
1296   06CB 31 52 18      mov bl, [sys_debug_mode]
1297   06CE               ; debug block
1298   06CE C1 00         cmp bl, 0
1299   06D0 EA            pop bl
1300   06D1 C6 E5 06      je syscall_filesystem_jmp
1301   06D4 DA            push d
1302   06D5 DD            push bl
1303   06D6 3B AA 06      mov d, s_syscall_fs_dbg0
1304   06D9 07 29 13      call _puts
1305   06DC 2F            mov bl, al
1306   06DD 07 C9 13      call print_u8x
1307   06E0 07 D6 12      call printnl
1308   06E3 EA            pop bl
1309   06E4 E7            pop d
1310   06E5             syscall_filesystem_jmp:
1311   06E5 FD 0A 7E 06   jmp [file_system_jmptbl + al]
1312   06E9             
1313   06E9             fs_mkfs:  
1314   06E9 06            sysret  
1315   06EA               
1316   06EA             fs_cd_root:
1317   06EA 10 20 00      mov a, root_id
1318   06ED 42 63 18      mov [current_dir_id], a      ; set current directory lba to root
1319   06F0 06            sysret  
1320   06F1             
1321   06F1             ; filename in d (userspace data)
1322   06F1             ; permission in bl
1323   06F1             fs_chmod:
1324   06F1 DD            push bl
1325   06F2 FD 4E         mov si, d
1326   06F4 FD 4F B1 1D   mov di, user_data
1327   06F8 38 80 00      mov c, 128
1328   06FB 04            load                        ; load filename from user-space
1329   06FC 14 63 18      mov a, [current_dir_id]
1330   06FF 77            inc a                       ; metadata sector
1331   0700 27            mov b, a
1332   0701 38 00 00      mov c, 0                    ; upper lba = 0
1333   0704 22 01         mov ah, $01                  ; 1 sector
1334   0706 3B B1 25      mov d, transient_area
1335   0709 07 7C 05      call ide_read_sect          ; read directory
1336   070C FD 10         cla
1337   070E 42 5B 18      mov [index], a              ; reset file counter
1338   0711             fs_chmod_l1:
1339   0711 FD 4E         mov si, d
1340   0713 FD 4F B1 1D   mov di, user_data
1341   0717 07 6C 11      call _strcmp
1342   071A C6 31 07      je fs_chmod_found_entry
1343   071D 58 20 00      add d, 32
1344   0720 14 5B 18      mov a, [index]
1345   0723 77            inc a
1346   0724 42 5B 18      mov [index], a
1347   0727 AF 10 00      cmp a, fst_files_per_dir
1348   072A C7 11 07      jne fs_chmod_l1
1349   072D EA            pop bl
1350   072E 0A 4A 07      jmp fs_chmod_not_found
1351   0731             fs_chmod_found_entry:  
1352   0731 FD 79         mov g, b                    ; save lba
1353   0733 EA            pop bl                      ; retrieve saved permission value
1354   0734 1F 18 00      mov al, [d + 24]            ; read file permissions
1355   0737 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1356   0739 8C            or al, bl                   ; set new permissions
1357   073A 3F 18 00      mov [d + 24], al            ; write new permissions
1358   073D 38 00 00      mov c, 0
1359   0740 3B B1 25      mov d, transient_area
1360   0743 22 01         mov ah, $01                 ; disk write 1 sect
1361   0745 FD 27         mov b, g                    ; retrieve lba
1362   0747 07 A2 05      call ide_write_sect         ; write sector
1363   074A             fs_chmod_not_found:
1364   074A 06            sysret
1365   074B             
1366   074B             ;------------------------------------------------------------------------------------------------------;
1367   074B             ; create new directory
1368   074B             ;------------------------------------------------------------------------------------------------------;
1369   074B             ; search list for null name entry. add new directory to list
1370   074B             fs_mkdir:
1371   074B FD 4E         mov si, d
1372   074D FD 4F B1 1D   mov di, user_data
1373   0751 38 00 02      mov c, 512
1374   0754 04            load                        ; load data from user-space
1375   0755 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1376   0758                                           ; when checking for null name, since root has a null name)
1377   0758 38 00 00      mov c, 0                    ; upper lba = 0
1378   075B             fs_mkdir_l1:  
1379   075B 22 01         mov ah, $01                  ; 1 sector
1380   075D 3B B1 25      mov d, transient_area
1381   0760 07 7C 05      call ide_read_sect          ; read sector
1382   0763 BD 00         cmp byte[d], 0              ; check for null
1383   0765 C6 6E 07      je fs_mkdir_found_null
1384   0768 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1385   076B 0A 5B 07      jmp fs_mkdir_l1
1386   076E             fs_mkdir_found_null:
1387   076E             ;create header file by grabbing dir name from parameter
1388   076E D8            push b                      ; save new directory's lba
1389   076F 38 40 00      mov c, 64
1390   0772 FD 4D B1 1D   mov si, user_data
1391   0776 FD 4F B1 25   mov di, transient_area
1392   077A FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1393   077C 14 63 18      mov a, [current_dir_id]
1394   077F 42 F1 25      mov [transient_area + 64], a    ; store parent directory lba
1395   0782 19 00         mov al, 0
1396   0784 FD 4F B1 27   mov di, transient_area + 512
1397   0788 38 00 02      mov c, 512
1398   078B FD F7         rep stosb                       ; clean buffer
1399   078D 38 00 00      mov c, 0                        ; reset lba(c) to 0
1400   0790             ; write directory entry sectors
1401   0790 3B B1 25      mov d, transient_area
1402   0793 22 02         mov ah, $02                     ; disk write, 2 sectors
1403   0795 07 A2 05      call ide_write_sect             ; write sector
1404   0798             ; now we need to add the new directory to the list, inside the current directory
1405   0798 14 63 18      mov a, [current_dir_id]
1406   079B 53 01 00      add a, 1
1407   079E 27            mov b, a                        ; metadata sector
1408   079F 38 00 00      mov c, 0
1409   07A2 FD 79         mov g, b                        ; save lba
1410   07A4 3B B1 25      mov d, transient_area
1411   07A7 22 01         mov ah, $01                  ; 1 sector
1412   07A9 07 7C 05      call ide_read_sect              ; read metadata sector
1413   07AC             fs_mkdir_l2:
1414   07AC BD 00         cmp byte[d], 0
1415   07AE C6 B7 07      je fs_mkdir_found_null2
1416   07B1 58 20 00      add d, fst_entry_size
1417   07B4 0A AC 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1418   07B7             fs_mkdir_found_null2:
1419   07B7 FD 4D B1 1D   mov si, user_data
1420   07BB FD 50         mov di, d
1421   07BD 07 81 11      call _strcpy                    ; copy directory name
1422   07C0 58 18 00      add d, 24                       ; goto attributes
1423   07C3 19 0B         mov al, %00001011               ; directory, no execute, write, read
1424   07C5 3E            mov [d], al      
1425   07C6 79            inc d
1426   07C7 E5            pop b
1427   07C8 D8            push b                          ; push lba back
1428   07C9 FD 43         mov [d], b                      ; save lba
1429   07CB             ; set file creation date  
1430   07CB 58 04 00      add d, 4
1431   07CE 19 04         mov al, 4
1432   07D0 05 01         syscall sys_rtc
1433   07D2 1A            mov al, ah
1434   07D3 3E            mov [d], al                     ; set day
1435   07D4 79            inc d
1436   07D5 19 05         mov al, 5
1437   07D7 05 01         syscall sys_rtc
1438   07D9 1A            mov al, ah
1439   07DA 3E            mov [d], al                     ; set month
1440   07DB 79            inc d
1441   07DC 19 06         mov al, 6
1442   07DE 05 01         syscall sys_rtc
1443   07E0 1A            mov al, ah
1444   07E1 3E            mov [d], al                     ; set year
1445   07E2             ; write sector into disk for new directory entry
1446   07E2 FD 27         mov b, g
1447   07E4 38 00 00      mov c, 0
1448   07E7 3B B1 25      mov d, transient_area
1449   07EA 22 01         mov ah, $01                     ; disk write, 1 sector
1450   07EC 07 A2 05      call ide_write_sect             ; write sector
1451   07EF             
1452   07EF             ; after adding the new directory's information to its parent directory's list
1453   07EF             ; we need to now enter the new directory, and to it add two new directories!
1454   07EF             ; which directories do we need to add ? '..' and '.' are the directories needed.
1455   07EF             ; importantly, note that these two new directories are only entries in the list
1456   07EF             ; and do not have actual physical entries in the disk as real directories.
1457   07EF             ; i.e. they only exist as list entries in the new directory created so that
1458   07EF             ; the new directory can reference its parent and itself.
1459   07EF             ; we need to add both '..' and '.'
1460   07EF             ; this first section is for '..' and on the section below we do the same for '.'
1461   07EF E4            pop a                         ; retrieve the new directory's lba  
1462   07F0 D7            push a                        ; and save again
1463   07F1 53 01 00      add a, 1
1464   07F4 27            mov b, a                      ; metadata sector
1465   07F5 38 00 00      mov c, 0
1466   07F8 FD 79         mov g, b                      ; save lba
1467   07FA 3B B1 25      mov d, transient_area
1468   07FD 22 01         mov ah, $01                  ; 1 sector
1469   07FF 07 7C 05      call ide_read_sect            ; read metadata sector
1470   0802             fs_mkdir_l3:
1471   0802 BD 00         cmp byte[d], 0
1472   0804 C6 0D 08      je fs_mkdir_found_null3
1473   0807 58 20 00      add d, fst_entry_size
1474   080A 0A 02 08      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1475   080D             fs_mkdir_found_null3:
1476   080D FD 4D 82 18   mov si, s_parent_dir
1477   0811 FD 50         mov di, d
1478   0813 07 81 11      call _strcpy                  ; copy directory name
1479   0816 58 18 00      add d, 24                     ; goto attributes
1480   0819 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1481   081B 3E            mov [d], al      
1482   081C 79            inc d
1483   081D 29 63 18      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1484   0820 FD 43         mov [d], b                    ; save lba
1485   0822             ; set file creation date  
1486   0822 58 04 00      add d, 4
1487   0825 19 04         mov al, 4
1488   0827 05 01         syscall sys_rtc
1489   0829 1A            mov al, ah
1490   082A 3E            mov [d], al                   ; set day
1491   082B 79            inc d
1492   082C 19 05         mov al, 5
1493   082E 05 01         syscall sys_rtc
1494   0830 1A            mov al, ah
1495   0831 3E            mov [d], al                   ; set month
1496   0832 79            inc d
1497   0833 19 06         mov al, 6
1498   0835 05 01         syscall sys_rtc
1499   0837 1A            mov al, ah
1500   0838 3E            mov [d], al                   ; set year
1501   0839             ; write sector into disk for new directory entry
1502   0839 FD 27         mov b, g
1503   083B 38 00 00      mov c, 0
1504   083E 3B B1 25      mov d, transient_area
1505   0841 22 01         mov ah, $01                   ; disk write, 1 sector
1506   0843 07 A2 05      call ide_write_sect           ; write sector
1507   0846             ;;;;;;;;;;;;;
1508   0846             ; like we did above for '..', we need to now add the '.' directory to the list.
1509   0846             ;------------------------------------------------------------------------------------------------------;
1510   0846 E4            pop a                         ; retrieve the new directory's lba  
1511   0847 D7            push a
1512   0848 53 01 00      add a, 1
1513   084B 27            mov b, a                      ; metadata sector
1514   084C 38 00 00      mov c, 0
1515   084F FD 79         mov g, b                      ; save lba
1516   0851 3B B1 25      mov d, transient_area
1517   0854 22 01         mov ah, $01                  ; 1 sector
1518   0856 07 7C 05      call ide_read_sect            ; read metadata sector
1519   0859             fs_mkdir_l4:
1520   0859 BD 00         cmp byte[d], 0
1521   085B C6 64 08      je fs_mkdir_found_null4
1522   085E 58 20 00      add d, fst_entry_size
1523   0861 0A 59 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1524   0864             fs_mkdir_found_null4:
1525   0864 FD 4D 85 18   mov si, s_current_dir
1526   0868 FD 50         mov di, d
1527   086A 07 81 11      call _strcpy                  ; copy directory name
1528   086D 58 18 00      add d, 24                     ; goto attributes
1529   0870 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1530   0872 3E            mov [d], al      
1531   0873 79            inc d
1532   0874 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1533   0875 FD 43         mov [d], b                    ; save lba
1534   0877             ; set file creation date  
1535   0877 58 04 00      add d, 4
1536   087A 19 04         mov al, 4
1537   087C 05 01         syscall sys_rtc
1538   087E 1A            mov al, ah
1539   087F 3E            mov [d], al                   ; set day
1540   0880 79            inc d
1541   0881 19 05         mov al, 5
1542   0883 05 01         syscall sys_rtc
1543   0885 1A            mov al, ah
1544   0886 3E            mov [d], al                   ; set month
1545   0887 79            inc d
1546   0888 19 06         mov al, 6
1547   088A 05 01         syscall sys_rtc
1548   088C 1A            mov al, ah
1549   088D 3E            mov [d], al                   ; set year
1550   088E             ; write sector into disk for new directory entry
1551   088E FD 27         mov b, g
1552   0890 38 00 00      mov c, 0
1553   0893 3B B1 25      mov d, transient_area
1554   0896 22 01         mov ah, $01                   ; disk write, 1 sector
1555   0898 07 A2 05      call ide_write_sect           ; write sector
1556   089B             fs_mkdir_end:
1557   089B 06            sysret
1558   089C             
1559   089C             ;------------------------------------------------------------------------------------------------------;
1560   089C             ; get path from a given directory dirid
1561   089C             ; pseudo code:
1562   089C             ;  fs_dir_id_to_path(int dirid, char *d){
1563   089C             ;    if(dirid == 0){
1564   089C             ;      reverse path in d;
1565   089C             ;      return;
1566   089C             ;    }
1567   089C             ;    else{
1568   089C             ;      copy directory name to end of d;
1569   089C             ;      add '/' to end of d;
1570   089C             ;      parentid = get parent directory id;
1571   089C             ;      fs_dir_id_to_path(parentid, d);
1572   089C             ;    }
1573   089C             ;  }
1574   089C             ; a = dirid
1575   089C             ; d = generated path string pointer
1576   089C             ;------------------------------------------------------------------------------------------------------;
1577   089C             ; sample path: /usr/bin
1578   089C             fs_dir_id_to_path:
1579   089C 3B 31 1D      mov d, filename
1580   089F 19 00         mov al, 0
1581   08A1 3E            mov [d], al                     ; initialize path string 
1582   08A2 14 63 18      mov a, [current_dir_id]
1583   08A5 07 B2 08      call fs_dir_id_to_path_e0
1584   08A8 3B 31 1D      mov d, filename
1585   08AB 07 15 11      call _strrev
1586   08AE 07 29 13      call _puts
1587   08B1 06            sysret
1588   08B2             fs_dir_id_to_path_e0:
1589   08B2 07 D1 08      call get_dirname_from_dirid
1590   08B5 FD 4D 87 18   mov si, s_fslash
1591   08B9 FD 50         mov di, d
1592   08BB 07 8F 11      call _strcat                    ; add '/' to end of path
1593   08BE AF 20 00      cmp a, root_id               ; check if we are at the root directory
1594   08C1 C6 D0 08      je fs_dir_id_to_path_root
1595   08C4 07 EE 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1596   08C7 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1597   08CA C6 D0 08      je fs_dir_id_to_path_root
1598   08CD 07 B2 08      call fs_dir_id_to_path_e0     ; recursively call itself
1599   08D0             fs_dir_id_to_path_root:
1600   08D0 09            ret
1601   08D1             
1602   08D1             ;------------------------------------------------------------------------------------------------------;
1603   08D1             ; in_puts:
1604   08D1             ; a = directory id
1605   08D1             ; out_puts:
1606   08D1             ; d = pointer to directory name string
1607   08D1             ;------------------------------------------------------------------------------------------------------;
1608   08D1             get_dirname_from_dirid:
1609   08D1 D7            push a
1610   08D2 D8            push b
1611   08D3 DA            push d
1612   08D4 27            mov b, a
1613   08D5 38 00 00      mov c, 0                      ; upper lba = 0
1614   08D8 22 01         mov ah, $01                  ; 1 sector
1615   08DA 3B B1 23      mov d, transient_area - 512
1616   08DD 07 7C 05      call ide_read_sect            ; read directory
1617   08E0 07 15 11      call _strrev                  ; reverse dir name before copying
1618   08E3 FD 4E         mov si, d
1619   08E5 E7            pop d                         ; destination address = d value pushed at beginning
1620   08E6 FD 50         mov di, d
1621   08E8 07 8F 11      call _strcat                  ; copy filename to d
1622   08EB E5            pop b
1623   08EC E4            pop a
1624   08ED 09            ret
1625   08EE             
1626   08EE             ;------------------------------------------------------------------------------------------------------;
1627   08EE             ; in_puts:
1628   08EE             ; a = directory id
1629   08EE             ; out_puts:
1630   08EE             ; a = parent directory id
1631   08EE             ;------------------------------------------------------------------------------------------------------;
1632   08EE             get_parentid_from_dirid:
1633   08EE D8            push b
1634   08EF DA            push d
1635   08F0 27            mov b, a
1636   08F1 38 00 00      mov c, 0                      ; upper lba = 0
1637   08F4 22 01         mov ah, $01                  ; 1 sector
1638   08F6 3B B1 23      mov d, transient_area - 512
1639   08F9 07 7C 05      call ide_read_sect            ; read directory
1640   08FC 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1641   08FF E7            pop d
1642   0900 E5            pop b
1643   0901 09            ret
1644   0902             
1645   0902             ;------------------------------------------------------------------------------------------------------;
1646   0902             ; get dirid from a given path string
1647   0902             ; in_puts:
1648   0902             ; d = path pointer 
1649   0902             ; out_puts:
1650   0902             ; a = dirid
1651   0902             ; if dir non existent, a = ffff (fail code)
1652   0902             ; /usr/local/bin    - absolute
1653   0902             ; local/bin/games    - relative
1654   0902             ;------------------------------------------------------------------------------------------------------;
1655   0902             fs_path_to_dir_id_user:
1656   0902 FD 4E         mov si, d
1657   0904 FD 4F B1 1D   mov di, user_data
1658   0908 38 00 02      mov c, 512
1659   090B 04            load
1660   090C 07 10 09      call get_dirid_from_path
1661   090F 06            sysret
1662   0910             get_dirid_from_path:
1663   0910 26 B1 1D      mov b, user_data
1664   0913 FD 42 4E 17   mov [prog], b                  ; token pointer set to path string
1665   0917 07 AF 15      call get_token
1666   091A 31 51 17      mov bl, [tok]
1667   091D C1 01         cmp bl, tok_fslash
1668   091F C6 2B 09      je get_dirid_from_path_abs 
1669   0922 14 63 18      mov a, [current_dir_id]
1670   0925 07 35 17      call _putback
1671   0928 0A 2E 09      jmp get_dirid_from_path_e0
1672   092B             get_dirid_from_path_abs:
1673   092B 10 20 00      mov a, root_id
1674   092E             get_dirid_from_path_e0:
1675   092E 07 AF 15      call get_token
1676   0931 31 50 17      mov bl, [toktyp]
1677   0934 C1 00         cmp bl, toktyp_identifier
1678   0936 C7 87 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1679   0939             
1680   0939 FD 4D 52 17   mov si, tokstr
1681   093D FD 4F 31 1D   mov di, filename
1682   0941 07 81 11      call _strcpy        
1683   0944 77            inc a                         ; metadata sector
1684   0945 27            mov b, a
1685   0946 38 00 00      mov c, 0                      ; upper lba = 0
1686   0949 22 01         mov ah, $01                  ; 1 sector
1687   094B 3B B1 25      mov d, transient_area
1688   094E 07 7C 05      call ide_read_sect            ; read directory
1689   0951 FD 10         cla
1690   0953 42 5B 18      mov [index], a
1691   0956             get_dirid_from_path_l1:
1692   0956 FD 4E         mov si, d
1693   0958 FD 4F 31 1D   mov di, filename
1694   095C 07 6C 11      call _strcmp
1695   095F C6 75 09      je get_dirid_from_path_name_equal  
1696   0962 58 20 00      add d, 32
1697   0965 14 5B 18      mov a, [index]
1698   0968 77            inc a
1699   0969 42 5B 18      mov [index], a
1700   096C AF 10 00      cmp a, fst_files_per_dir
1701   096F C6 88 09      je get_dirid_from_path_fail
1702   0972 0A 56 09      jmp get_dirid_from_path_l1
1703   0975             get_dirid_from_path_name_equal:
1704   0975 58 19 00      add d, 25           
1705   0978 15            mov a, [d]                    ; set result register a = dirid
1706   0979 07 AF 15      call get_token
1707   097C 31 51 17      mov bl, [tok]
1708   097F C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1709   0981 C6 2E 09      je get_dirid_from_path_e0
1710   0984 07 35 17      call _putback
1711   0987             get_dirid_from_path_end:
1712   0987 09            ret
1713   0988             get_dirid_from_path_fail:
1714   0988 10 FF FF      mov a, $ffff
1715   098B 09            ret
1716   098C             
1717   098C             
1718   098C             ;------------------------------------------------------------------------------------------------------;
1719   098C             ; check if file exists by a given path string
1720   098C             ; in_puts:
1721   098C             ; d = path pointer 
1722   098C             ; outputs:
1723   098C             ; a = success code, if file exists gives lba, else, give 0
1724   098C             ; /usr/local/bin/ed
1725   098C             ;------------------------------------------------------------------------------------------------------;
1726   098C             fs_filepath_exists_user:
1727   098C FD 4E         mov si, d
1728   098E FD 4F B1 1D   mov di, user_data
1729   0992 38 00 02      mov c, 512
1730   0995 04            load
1731   0996 07 9A 09      call file_exists_by_path
1732   0999 06            sysret
1733   099A             file_exists_by_path:
1734   099A 26 B1 1D      mov b, user_data
1735   099D FD 42 4E 17   mov [prog], b                   ; token pointer set to path string
1736   09A1 07 AF 15      call get_token
1737   09A4 31 51 17      mov bl, [tok]
1738   09A7 C1 01         cmp bl, tok_fslash
1739   09A9 C6 B5 09      je  file_exists_by_path_abs
1740   09AC 14 63 18      mov a, [current_dir_id]
1741   09AF 07 35 17      call _putback
1742   09B2 0A B8 09      jmp file_exists_by_path_e0
1743   09B5             file_exists_by_path_abs:
1744   09B5 10 20 00      mov a, root_id
1745   09B8             file_exists_by_path_e0:
1746   09B8 07 AF 15      call get_token
1747   09BB 31 50 17      mov bl, [toktyp]
1748   09BE C1 00         cmp bl, toktyp_identifier
1749   09C0 C7 18 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1750   09C3 FD 4D 52 17   mov si, tokstr
1751   09C7 FD 4F 31 1D   mov di, filename
1752   09CB 07 81 11      call _strcpy        
1753   09CE 77            inc a                           ; metadata sector
1754   09CF 27            mov b, a
1755   09D0 38 00 00      mov c, 0                        ; upper lba = 0
1756   09D3 22 01         mov ah, $01                  ; 1 sector
1757   09D5 3B B1 25      mov d, transient_area
1758   09D8 07 7C 05      call ide_read_sect              ; read directory
1759   09DB FD 10         cla
1760   09DD 42 5B 18      mov [index], a
1761   09E0             file_exists_by_path_l1:
1762   09E0 FD 4E         mov si, d
1763   09E2 FD 4F 31 1D   mov di, filename
1764   09E6 07 6C 11      call _strcmp
1765   09E9 C6 FF 09      je   file_exists_by_path_name_equal
1766   09EC 58 20 00      add d, 32
1767   09EF 14 5B 18      mov a, [index]
1768   09F2 77            inc a
1769   09F3 42 5B 18      mov [index], a
1770   09F6 AF 10 00      cmp a, fst_files_per_dir
1771   09F9 C6 18 0A      je file_exists_by_path_end
1772   09FC 0A E0 09      jmp file_exists_by_path_l1
1773   09FF             file_exists_by_path_name_equal:
1774   09FF 33 18 00      mov bl, [d + 24]
1775   0A02 FD 87 38      and bl, %00111000               ; directory flag
1776   0A05 C1 08         cmp bl, %00001000               ; is dir?
1777   0A07 C6 0E 0A      je file_exists_by_path_isdir;
1778   0A0A             ; entry is a file
1779   0A0A 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1780   0A0D 09            ret
1781   0A0E             file_exists_by_path_isdir:
1782   0A0E 58 19 00      add d, 25           
1783   0A11 15            mov a, [d]                      ; set result register a = dirid
1784   0A12 07 AF 15      call get_token
1785   0A15 0A B8 09      jmp file_exists_by_path_e0
1786   0A18             file_exists_by_path_end:
1787   0A18 10 00 00      mov a, 0                        ; return 0 because file was not found
1788   0A1B 09            ret
1789   0A1C             
1790   0A1C             ;------------------------------------------------------------------------------------------------------;
1791   0A1C             ; load file data from a given path string
1792   0A1C             ; inputs:
1793   0A1C             ; d = path pointer 
1794   0A1C             ; di = userspace program data destination
1795   0A1C             ; /usr/local/bin/ed
1796   0A1C             ; ./ed
1797   0A1C             ;------------------------------------------------------------------------------------------------------;
1798   0A1C             fs_load_from_path_user:
1799   0A1C E3            push di
1800   0A1D FD 4E         mov si, d
1801   0A1F FD 4F B1 1D   mov di, user_data
1802   0A23 38 00 02      mov c, 512
1803   0A26 04            load
1804   0A27 07 34 0A      call loadfile_from_path
1805   0A2A F0            pop di
1806   0A2B FD 4D B1 25   mov si, transient_area
1807   0A2F 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1808   0A32 03            store
1809   0A33 06            sysret
1810   0A34             loadfile_from_path:
1811   0A34 26 B1 1D      mov b, user_data
1812   0A37 FD 42 4E 17   mov [prog], b                 ; token pointer set to path string
1813   0A3B 07 AF 15      call get_token
1814   0A3E 31 51 17      mov bl, [tok]
1815   0A41 C1 01         cmp bl, tok_fslash
1816   0A43 C6 4F 0A      je loadfile_from_path_abs 
1817   0A46 14 63 18      mov a, [current_dir_id]
1818   0A49 07 35 17      call _putback
1819   0A4C 0A 52 0A      jmp loadfile_from_path_e0
1820   0A4F             loadfile_from_path_abs:
1821   0A4F 10 20 00      mov a, root_id
1822   0A52             loadfile_from_path_e0:
1823   0A52 07 AF 15      call get_token
1824   0A55 31 50 17      mov bl, [toktyp]
1825   0A58 C1 00         cmp bl, toktyp_identifier
1826   0A5A C7 BF 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1827   0A5D FD 4D 52 17   mov si, tokstr
1828   0A61 FD 4F 31 1D   mov di, filename
1829   0A65 07 81 11      call _strcpy        
1830   0A68 77            inc a                         ; metadata sector
1831   0A69 27            mov b, a
1832   0A6A 38 00 00      mov c, 0                      ; upper lba = 0
1833   0A6D 22 01         mov ah, $01                  ; 1 sector
1834   0A6F 3B B1 25      mov d, transient_area
1835   0A72 07 7C 05      call ide_read_sect            ; read directory
1836   0A75 FD 10         cla
1837   0A77 42 5B 18      mov [index], a
1838   0A7A             loadfile_from_path_l1:
1839   0A7A FD 4E         mov si, d
1840   0A7C FD 4F 31 1D   mov di, filename
1841   0A80 07 6C 11      call _strcmp
1842   0A83 C6 99 0A      je loadfile_from_path_name_equal  
1843   0A86 58 20 00      add d, 32
1844   0A89 14 5B 18      mov a, [index]
1845   0A8C 77            inc a
1846   0A8D 42 5B 18      mov [index], a
1847   0A90 AF 10 00      cmp a, fst_files_per_dir
1848   0A93 C6 BF 0A      je loadfile_from_path_end
1849   0A96 0A 7A 0A      jmp loadfile_from_path_l1
1850   0A99             loadfile_from_path_name_equal:
1851   0A99 33 18 00      mov bl, [d + 24]
1852   0A9C FD 87 38      and bl, %00111000             ; directory flag
1853   0A9F C1 08         cmp bl, %00001000             ; is dir?
1854   0AA1 C6 B5 0A      je loadfile_isdirectory  
1855   0AA4             ; entry is a file
1856   0AA4 2B 19 00      mov b, [d + 25]               ; get lba
1857   0AA7 FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1858   0AA9 3B B1 25      mov d, transient_area
1859   0AAC 38 00 00      mov c, 0
1860   0AAF 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1861   0AB1 07 7C 05      call ide_read_sect            ; read sector
1862   0AB4 09            ret
1863   0AB5             loadfile_isdirectory:
1864   0AB5 58 19 00      add d, 25           
1865   0AB8 15            mov a, [d]                    ; set result register a = dirid
1866   0AB9 07 AF 15      call get_token
1867   0ABC 0A 52 0A      jmp loadfile_from_path_e0
1868   0ABF             loadfile_from_path_end:
1869   0ABF 09            ret
1870   0AC0             
1871   0AC0             ;------------------------------------------------------------------------------------------------------;
1872   0AC0             ; return the id of the current directory
1873   0AC0             ; id returned in b
1874   0AC0             ;------------------------------------------------------------------------------------------------------;
1875   0AC0             fs_get_curr_dirid:
1876   0AC0 29 63 18      mov b, [current_dir_id]
1877   0AC3 06            sysret
1878   0AC4             
1879   0AC4             ;------------------------------------------------------------------------------------------------------;
1880   0AC4             ; cd
1881   0AC4             ;------------------------------------------------------------------------------------------------------;
1882   0AC4             ; new dirid in b
1883   0AC4             fs_cd:
1884   0AC4 FD 42 63 18   mov [current_dir_id], b
1885   0AC8 06            sysret  
1886   0AC9             
1887   0AC9             ;------------------------------------------------------------------------------------------------------;
1888   0AC9             ; ls
1889   0AC9             ; dirid in b
1890   0AC9             ;------------------------------------------------------------------------------------------------------;
1891   0AC9 00 00       ls_count:       .dw 0
1892   0ACB             fs_ls:
1893   0ACB FD 77         inc b                        ; metadata sector
1894   0ACD 38 00 00      mov c, 0                     ; upper lba = 0
1895   0AD0 22 01         mov ah, $01                  ; 1 sector
1896   0AD2 3B B1 25      mov d, transient_area
1897   0AD5 07 7C 05      call ide_read_sect           ; read directory
1898   0AD8 FD 10         cla
1899   0ADA 42 5B 18      mov [index], a               ; reset entry index
1900   0ADD 3D C9 0A      mov [ls_count], al           ; reset item count
1901   0AE0             fs_ls_l1:
1902   0AE0 BD 00         cmp byte [d], 0              ; check for null
1903   0AE2 C6 79 0B      je fs_ls_next
1904   0AE5             fs_ls_non_null:
1905   0AE5 1D C9 0A      mov al, [ls_count]
1906   0AE8 7A            inc al
1907   0AE9 3D C9 0A      mov [ls_count], al           ; increment item count
1908   0AEC 1F 18 00      mov al, [d + 24]
1909   0AEF 87 38         and al, %00111000
1910   0AF1 FD A2 03      shr al, 3
1911   0AF4 22 00         mov ah, 0                    ; file type
1912   0AF6 B7 8E 18      mov a, [a + file_type]      
1913   0AF9 23            mov ah, al
1914   0AFA 07 FD 11      call _putchar
1915   0AFD 1F 18 00      mov al, [d + 24]
1916   0B00 87 01         and al, %00000001
1917   0B02 22 00         mov ah, 0
1918   0B04 B7 89 18      mov a, [a + file_attrib]     ; read
1919   0B07 23            mov ah, al
1920   0B08 07 FD 11      call _putchar
1921   0B0B 1F 18 00      mov al, [d + 24]
1922   0B0E 87 02         and al, %00000010
1923   0B10 22 00         mov ah, 0
1924   0B12 B7 89 18      mov a, [a + file_attrib]     ; write
1925   0B15 23            mov ah, al
1926   0B16 07 FD 11      call _putchar
1927   0B19 1F 18 00      mov al, [d + 24]
1928   0B1C 87 04         and al, %00000100
1929   0B1E 22 00         mov ah, 0
1930   0B20 B7 89 18      mov a, [a + file_attrib]     ; execute
1931   0B23 23            mov ah, al
1932   0B24 07 FD 11      call _putchar
1933   0B27 22 20         mov ah, $20
1934   0B29 07 FD 11      call _putchar  
1935   0B2C 2B 1B 00      mov b, [d + 27]
1936   0B2F 07 85 13      call print_u16x              ; filesize
1937   0B32 22 20         mov ah, $20
1938   0B34 07 FD 11      call _putchar  
1939   0B37 2B 19 00      mov b, [d + 25]
1940   0B3A 07 85 13      call print_u16x              ; dirid / lba
1941   0B3D 22 20         mov ah, $20
1942   0B3F 07 FD 11      call _putchar
1943   0B42             ; print date
1944   0B42 33 1D 00      mov bl, [d + 29]             ; day
1945   0B45 07 C9 13      call print_u8x
1946   0B48 22 20         mov ah, $20
1947   0B4A 07 FD 11      call _putchar  
1948   0B4D 1F 1E 00      mov al, [d + 30]             ; month
1949   0B50 FD 9E 02      shl al, 2
1950   0B53 DA            push d
1951   0B54 3B 4D 19      mov d, s_months
1952   0B57 22 00         mov ah, 0
1953   0B59 59            add d, a
1954   0B5A 07 29 13      call _puts
1955   0B5D E7            pop d
1956   0B5E 22 20         mov ah, $20
1957   0B60 07 FD 11      call _putchar
1958   0B63 2E 20         mov bl, $20
1959   0B65 07 C9 13      call print_u8x
1960   0B68 33 1F 00      mov bl, [d + 31]             ; year
1961   0B6B 07 C9 13      call print_u8x  
1962   0B6E 22 20         mov ah, $20
1963   0B70 07 FD 11      call _putchar  
1964   0B73 07 29 13      call _puts                   ; print filename  
1965   0B76 07 D6 12      call printnl
1966   0B79             fs_ls_next:
1967   0B79 14 5B 18      mov a, [index]
1968   0B7C 77            inc a
1969   0B7D 42 5B 18      mov [index], a
1970   0B80 AF 10 00      cmp a, fst_files_per_dir
1971   0B83 C6 8C 0B      je fs_ls_end
1972   0B86 58 20 00      add d, 32      
1973   0B89 0A E0 0A      jmp fs_ls_l1  
1974   0B8C             fs_ls_end:
1975   0B8C 3B 9E 18      mov d, s_ls_total
1976   0B8F 07 29 13      call _puts
1977   0B92 1D C9 0A      mov al, [ls_count]
1978   0B95 07 DB 13      call print_u8d
1979   0B98 07 D6 12      call printnl
1980   0B9B 06            sysret
1981   0B9C             
1982   0B9C             
1983   0B9C             ;------------------------------------------------------------------------------------------------------;
1984   0B9C             ; create new textfile
1985   0B9C             ;------------------------------------------------------------------------------------------------------;
1986   0B9C             ; file structure:
1987   0B9C             ; 512 bytes header
1988   0B9C             ; header used to tell whether the block is free
1989   0B9C             ; d = content pointer in user space
1990   0B9C             ; c = file size
1991   0B9C             ; todo: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1992   0B9C             fs_starcom:
1993   0B9C FD 4E       	mov si, d
1994   0B9E FD 4F B1 25 	mov di, transient_area
1995   0BA2 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1996   0BA5 04          	load					; load data from user-space
1997   0BA6 07 27 0C    	call fs_find_empty_block	; look for empty data blocks
1998   0BA9 D8          	push b				; save empty block lba
1999   0BAA FD 79         mov g, b
2000   0BAC             ;create header file by grabbing file name from parameter	
2001   0BAC 3B B1 27    	mov d, transient_area + 512			; pointer to file contents
2002   0BAF D9          	push c							; save length
2003   0BB0 19 01       	mov al, 1
2004   0BB2 3D B1 25    	mov [transient_area], al					; mark sectors as used (not null)
2005   0BB5 3B B1 25    	mov d, transient_area
2006   0BB8 12            mov a, c
2007   0BB9 26 00 02      mov b, 512
2008   0BBC AE            div a, b
2009   0BBD FD 77         inc b         ; inc b as the division will most likely have a remainder
2010   0BBF 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
2011   0BC0 38 00 00    	mov c, 0      ; lba 
2012   0BC3 FD 27         mov b, g      ; lba 
2013   0BC5 07 A2 05    	call ide_write_sect			; write sectors
2014   0BC8             ; now we add the file to the current directory!
2015   0BC8             fs_starcom_add_to_dir:	
2016   0BC8 14 63 18    	mov a, [current_dir_id]
2017   0BCB 77          	inc a
2018   0BCC 27          	mov b, a					; metadata sector
2019   0BCD 38 00 00    	mov c, 0
2020   0BD0 FD 79       	mov g, b					; save lba
2021   0BD2 3B B1 23    	mov d, scrap_sector
2022   0BD5 22 01       	mov ah, $01			  ; 1 sector
2023   0BD7 07 7C 05    	call ide_read_sect		; read metadata sector
2024   0BDA             fs_starcom_add_to_dir_l2:
2025   0BDA BD 00       	cmp byte[d], 0
2026   0BDC C6 E5 0B    	je fs_starcom_add_to_dir_null
2027   0BDF 58 20 00    	add d, fst_entry_size
2028   0BE2 0A DA 0B    	jmp fs_starcom_add_to_dir_l2		; we look for a null entry here but dont check for limits. 
2029   0BE5             fs_starcom_add_to_dir_null:
2030   0BE5 FD 4D B2 25 	mov si, transient_area + 1		; filename located after the data block 'used' marker byte
2031   0BE9 FD 50       	mov di, d
2032   0BEB 07 81 11    	call _strcpy			; copy file name
2033   0BEE 58 18 00    	add d, 24			; skip name
2034   0BF1 19 07       	mov al, %00000111	; type=file, execute, write, read
2035   0BF3 3E          	mov [d], al			
2036   0BF4 58 03 00    	add d, 3
2037   0BF7 E4          	pop a
2038   0BF8 5F 00 02      sub a, 512
2039   0BFB 43          	mov [d], a ; file size
2040   0BFC 63 02 00    	sub d, 2
2041   0BFF E5          	pop b				; get file lba
2042   0C00 FD 43       	mov [d], b			; save lba	
2043   0C02             ; set file creation date	
2044   0C02 58 04 00    	add d, 4
2045   0C05 19 04       	mov al, 4
2046   0C07 05 01       	syscall sys_rtc
2047   0C09 1A          	mov al, ah
2048   0C0A 3E          	mov [d], al			; set day
2049   0C0B 79          	inc d
2050   0C0C 19 05       	mov al, 5
2051   0C0E 05 01       	syscall sys_rtc
2052   0C10 1A          	mov al, ah
2053   0C11 3E          	mov [d], al			; set month
2054   0C12 79          	inc d
2055   0C13 19 06       	mov al, 6
2056   0C15 05 01       	syscall sys_rtc
2057   0C17 1A          	mov al, ah
2058   0C18 3E          	mov [d], al			; set year
2059   0C19             ; write sector into disk for new directory entry
2060   0C19 FD 27       	mov b, g
2061   0C1B 38 00 00    	mov c, 0
2062   0C1E 3B B1 23    	mov d, scrap_sector
2063   0C21 22 01       	mov ah, $01			; disk write, 1 sector
2064   0C23 07 A2 05    	call ide_write_sect		; write sector
2065   0C26 06          	sysret
2066   0C27             
2067   0C27             ;------------------------------------------------------------------------------------------------------;
2068   0C27             ; finds an empty data block
2069   0C27             ; block lba returned in b
2070   0C27             ;------------------------------------------------------------------------------------------------------;
2071   0C27             fs_find_empty_block:
2072   0C27 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2073   0C2A 38 00 00      mov c, 0                ; upper lba = 0
2074   0C2D             fs_find_empty_block_l1:  
2075   0C2D 22 01         mov ah, $01                  ; 1 sector
2076   0C2F 3B B1 23      mov d, transient_area - 512
2077   0C32 07 7C 05      call ide_read_sect      ; read sector
2078   0C35 BD 00         cmp byte [d], 0
2079   0C37 C6 40 0C      je fs_find_empty_block_found_null
2080   0C3A 55 20 00      add b, fs_sectors_per_file
2081   0C3D 0A 2D 0C      jmp fs_find_empty_block_l1
2082   0C40             fs_find_empty_block_found_null:
2083   0C40 09            ret
2084   0C41             
2085   0C41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2086   0C41             ;; create new textfile
2087   0C41             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2088   0C41             ; search for first null block
2089   0C41             fs_mktxt:
2090   0C41 FD 4E       	mov si, d
2091   0C43 FD 4F B1 1D 	mov di, user_data
2092   0C47 38 00 01    	mov c, 256
2093   0C4A 04          	load					; load data from user-space
2094   0C4B             	
2095   0C4B 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2096   0C4E 38 00 00    	mov c, 0						; reset lba to 0
2097   0C51             fs_mktxt_l1:	
2098   0C51 10 02 01    	mov a, $0102			; disk read
2099   0C54 3B B1 25    	mov d, transient_area
2100   0C57 05 02       	syscall sys_ide ; read sector
2101   0C59 1E          	mov al, [d]
2102   0C5A B9 00       	cmp al, 0			; check for null
2103   0C5C C6 65 0C    	je fs_mktxt_found_null
2104   0C5F 55 20 00    	add b, fs_sectors_per_file
2105   0C62 0A 51 0C    	jmp fs_mktxt_l1
2106   0C65             fs_mktxt_found_null:
2107   0C65 D8          	push b				; save lba
2108   0C66             ;create header file by grabbing file name from parameter	
2109   0C66 3B 7F 18    	mov d, s_dataentry
2110   0C69 07 29 13    	call _puts
2111   0C6C 3B B1 27    	mov d, transient_area + 512			; pointer to file contents
2112   0C6F 07 8F 12    	call _gettxt
2113   0C72 07 5C 11    	call _strlen						; get length of file
2114   0C75 D9          	push c							; save length
2115   0C76 19 01       	mov al, 1
2116   0C78 3D B1 25    	mov [transient_area], al					; mark sectors as used (not null)
2117   0C7B 10 00 00    	mov a, 0
2118   0C7E 42 5B 18    	mov [index], a
2119   0C81 3B B1 25    	mov d, transient_area
2120   0C84 13          	mov a, d
2121   0C85 42 5D 18    	mov [buffer_addr], a
2122   0C88             fs_mktxt_l2:
2123   0C88 38 00 00    	mov c, 0
2124   0C8B 10 03 01    	mov a, $0103			; disk write, 1 sector
2125   0C8E 05 02       	syscall sys_ide		; write sector
2126   0C90 14 5B 18    	mov a, [index]
2127   0C93 77          	inc a
2128   0C94 42 5B 18    	mov [index], a
2129   0C97 AF 20 00    	cmp a, fs_sectors_per_file
2130   0C9A C6 AC 0C    	je fs_mktxt_add_to_dir
2131   0C9D FD 77       	inc b
2132   0C9F 14 5D 18    	mov a, [buffer_addr]
2133   0CA2 53 00 02    	add a, 512
2134   0CA5 42 5D 18    	mov [buffer_addr], a
2135   0CA8 3C          	mov d, a
2136   0CA9 0A 88 0C    	jmp fs_mktxt_l2
2137   0CAC             ; now we add the file to the current directory!
2138   0CAC             fs_mktxt_add_to_dir:	
2139   0CAC 14 63 18    	mov a, [current_dir_id]
2140   0CAF 77          	inc a
2141   0CB0 27          	mov b, a					; metadata sector
2142   0CB1 38 00 00    	mov c, 0
2143   0CB4 FD 79       	mov g, b					; save lba
2144   0CB6 3B B1 25    	mov d, transient_area
2145   0CB9 10 02 01    	mov a, $0102			; disk read
2146   0CBC 05 02       	syscall sys_ide		; read metadata sector
2147   0CBE             fs_mktxt_add_to_dir_l2:
2148   0CBE 1E          	mov al, [d]
2149   0CBF B9 00       	cmp al, 0
2150   0CC1 C6 CA 0C    	je fs_mktxt_add_to_dir_null
2151   0CC4 58 20 00    	add d, fst_entry_size
2152   0CC7 0A BE 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2153   0CCA             fs_mktxt_add_to_dir_null:
2154   0CCA FD 4D B1 1D 	mov si, user_data
2155   0CCE FD 50       	mov di, d
2156   0CD0 07 81 11    	call _strcpy			; copy file name
2157   0CD3 58 18 00    	add d, 24			; skip name
2158   0CD6 19 06       	mov al, %00000110		; no execute, write, read, not directory
2159   0CD8 3E          	mov [d], al			
2160   0CD9 58 03 00    	add d, 3
2161   0CDC E4          	pop a
2162   0CDD 43          	mov [d], a
2163   0CDE 63 02 00    	sub d, 2
2164   0CE1 E5          	pop b				; get file lba
2165   0CE2 FD 43       	mov [d], b			; save lba	
2166   0CE4             	
2167   0CE4             	; set file creation date	
2168   0CE4 58 04 00    	add d, 4
2169   0CE7 19 04       	mov al, 4
2170   0CE9 05 01       	syscall sys_rtc
2171   0CEB 1A          	mov al, ah
2172   0CEC 3E          	mov [d], al			; set day
2173   0CED             	
2174   0CED 79          	inc d
2175   0CEE 19 05       	mov al, 5
2176   0CF0 05 01       	syscall sys_rtc
2177   0CF2 1A          	mov al, ah
2178   0CF3 3E          	mov [d], al			; set month
2179   0CF4             	
2180   0CF4 79          	inc d
2181   0CF5 19 06       	mov al, 6
2182   0CF7 05 01       	syscall sys_rtc
2183   0CF9 1A          	mov al, ah
2184   0CFA 3E          	mov [d], al			; set year
2185   0CFB             	
2186   0CFB             ; write sector into disk for new directory entry
2187   0CFB FD 27       	mov b, g
2188   0CFD 38 00 00    	mov c, 0
2189   0D00 3B B1 25    	mov d, transient_area
2190   0D03 10 03 01    	mov a, $0103			; disk write, 1 sector
2191   0D06 05 02       	syscall sys_ide		; write sector
2192   0D08 07 D6 12    	call printnl
2193   0D0B 06          	sysret
2194   0D0C             
2195   0D0C             
2196   0D0C             
2197   0D0C             ;------------------------------------------------------------------------------------------------------;
2198   0D0C             ; create new binary file
2199   0D0C             ;------------------------------------------------------------------------------------------------------;
2200   0D0C             ; search for first null block
2201   0D0C             fs_mkbin:
2202   0D0C 19 00         mov al, 0
2203   0D0E 3D 53 18      mov [sys_echo_on], al ; disable echo
2204   0D11 FD 4E         mov si, d
2205   0D13 FD 4F B1 1D   mov di, user_data
2206   0D17 38 00 02      mov c, 512
2207   0D1A 04            load                          ; load data from user-space
2208   0D1B 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2209   0D1E 38 00 00      mov c, 0                      ; upper lba = 0
2210   0D21             fs_mkbin_l1:  
2211   0D21 22 01         mov ah, $01                  ; 1 sector
2212   0D23 3B B1 25      mov d, transient_area
2213   0D26 07 7C 05      call ide_read_sect            ; read sector
2214   0D29 BD 00         cmp byte[d], 0                ; check for null
2215   0D2B C6 34 0D      je fs_mkbin_found_null
2216   0D2E 55 20 00      add b, fs_sectors_per_file
2217   0D31 0A 21 0D      jmp fs_mkbin_l1
2218   0D34             fs_mkbin_found_null:
2219   0D34 D8            push b                        ; save lba
2220   0D35             ;create header file by grabbing file name from parameter
2221   0D35 FD 4F B1 27   mov di, transient_area + 512  ; pointer to file contents
2222   0D39 07 AF 10      call _load_hex                ; load binary hex
2223   0D3C D9            push c                        ; save size (nbr of bytes)
2224   0D3D 19 01         mov al, 1
2225   0D3F 3D B1 25      mov [transient_area], al      ; mark sectors as used (not null)
2226   0D42 FD 10         cla
2227   0D44 42 5B 18      mov [index], a
2228   0D47 3B B1 25      mov d, transient_area
2229   0D4A 13            mov a, d
2230   0D4B 42 5D 18      mov [buffer_addr], a
2231   0D4E             fs_mkbin_l2:
2232   0D4E 38 00 00      mov c, 0
2233   0D51 22 01         mov ah, $01                   ; disk write, 1 sector
2234   0D53 07 A2 05      call ide_write_sect           ; write sector
2235   0D56 14 5B 18      mov a, [index]
2236   0D59 77            inc a
2237   0D5A 42 5B 18      mov [index], a
2238   0D5D AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2239   0D60 C6 72 0D      je fs_mkbin_add_to_dir
2240   0D63 FD 77         inc b
2241   0D65 14 5D 18      mov a, [buffer_addr]
2242   0D68 53 00 02      add a, 512
2243   0D6B 42 5D 18      mov [buffer_addr], a
2244   0D6E 3C            mov d, a
2245   0D6F 0A 4E 0D      jmp fs_mkbin_l2
2246   0D72             ; now we add the file to the current directory!
2247   0D72             fs_mkbin_add_to_dir:  
2248   0D72 14 63 18      mov a, [current_dir_id]
2249   0D75 77            inc a
2250   0D76 27            mov b, a                      ; metadata sector
2251   0D77 38 00 00      mov c, 0
2252   0D7A FD 79         mov g, b                      ; save lba
2253   0D7C 3B B1 25      mov d, transient_area
2254   0D7F 22 01         mov ah, $01                  ; 1 sector
2255   0D81 07 7C 05      call ide_read_sect            ; read metadata sector
2256   0D84             fs_mkbin_add_to_dir_l2:
2257   0D84 BD 00         cmp byte[d], 0
2258   0D86 C6 8F 0D      je fs_mkbin_add_to_dir_null
2259   0D89 58 20 00      add d, fst_entry_size
2260   0D8C 0A 84 0D      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2261   0D8F             fs_mkbin_add_to_dir_null:
2262   0D8F FD 4D B1 1D   mov si, user_data
2263   0D93 FD 50         mov di, d
2264   0D95 07 81 11      call _strcpy                  ; copy file name
2265   0D98 58 18 00      add d, 24                     ; skip name
2266   0D9B 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2267   0D9D 3E            mov [d], al
2268   0D9E 58 03 00      add d, 3
2269   0DA1 E4            pop a
2270   0DA2 43            mov [d], a
2271   0DA3 63 02 00      sub d, 2
2272   0DA6 E5            pop b                         ; get file lba
2273   0DA7 FD 43         mov [d], b                    ; save lba
2274   0DA9               ; set file creation date  
2275   0DA9 58 04 00      add d, 4
2276   0DAC 19 04         mov al, 4
2277   0DAE 05 01         syscall sys_rtc
2278   0DB0 1A            mov al, ah
2279   0DB1 3E            mov [d], al                   ; set day
2280   0DB2 79            inc d
2281   0DB3 19 05         mov al, 5
2282   0DB5 05 01         syscall sys_rtc
2283   0DB7 1A            mov al, ah
2284   0DB8 3E            mov [d], al                   ; set month
2285   0DB9 79            inc d
2286   0DBA 19 06         mov al, 6
2287   0DBC 05 01         syscall sys_rtc
2288   0DBE 1A            mov al, ah
2289   0DBF 3E            mov [d], al                   ; set year
2290   0DC0             ; write sector into disk for new directory entry
2291   0DC0 FD 27         mov b, g
2292   0DC2 38 00 00      mov c, 0
2293   0DC5 3B B1 25      mov d, transient_area
2294   0DC8 22 01         mov ah, $01                   ; disk write, 1 sector
2295   0DCA 07 A2 05      call ide_write_sect           ; write sector
2296   0DCD 19 01         mov al, 1
2297   0DCF 3D 53 18      mov [sys_echo_on], al ; enable echo
2298   0DD2 06            sysret
2299   0DD3             
2300   0DD3             ;------------------------------------------------------------------------------------------------------;
2301   0DD3             ; pwd - print working directory
2302   0DD3             ;------------------------------------------------------------------------------------------------------;    
2303   0DD3             fs_pwd:
2304   0DD3 3B 31 1D      mov d, filename
2305   0DD6 19 00         mov al, 0
2306   0DD8 3E            mov [d], al                   ; initialize path string 
2307   0DD9 14 63 18      mov a, [current_dir_id]
2308   0DDC 07 B2 08      call fs_dir_id_to_path_e0
2309   0DDF 3B 31 1D      mov d, filename
2310   0DE2 07 15 11      call _strrev
2311   0DE5 07 29 13      call _puts
2312   0DE8 07 D6 12      call printnl
2313   0DEB 06            sysret
2314   0DEC             
2315   0DEC             ;------------------------------------------------------------------------------------------------------;
2316   0DEC             ; get current directory lba
2317   0DEC             ; a: returned lba
2318   0DEC             ;------------------------------------------------------------------------------------------------------;
2319   0DEC             cmd_get_curr_dir_lba:
2320   0DEC 14 63 18      mov a, [current_dir_id]
2321   0DEF 06            sysret
2322   0DF0             
2323   0DF0             ;------------------------------------------------------------------------------------------------------;
2324   0DF0             ; cat
2325   0DF0             ; userspace destination data pointer in d
2326   0DF0             ; filename starts at d, but is overwritten after the read is made
2327   0DF0             ;------------------------------------------------------------------------------------------------------;:
2328   0DF0             fs_cat:
2329   0DF0 DA            push d                              ; save userspace file data destination
2330   0DF1 FD 4E         mov si, d
2331   0DF3 FD 4F B1 1D   mov di, user_data
2332   0DF7 38 00 02      mov c, 512
2333   0DFA 04            load                                ; copy filename from user-space
2334   0DFB 29 63 18      mov b, [current_dir_id]
2335   0DFE FD 77         inc b                               ; metadata sector
2336   0E00 38 00 00      mov c, 0                            ; upper lba = 0
2337   0E03 22 01         mov ah, $01                  ; 1 sector
2338   0E05 3B B1 23      mov d, transient_area-512
2339   0E08 07 7C 05      call ide_read_sect                  ; read directory
2340   0E0B FD 10         cla
2341   0E0D 42 5B 18      mov [index], a                      ; reset file counter
2342   0E10             fs_cat_l1:
2343   0E10 FD 4E         mov si, d
2344   0E12 FD 4F B1 1D   mov di, user_data
2345   0E16 07 6C 11      call _strcmp
2346   0E19 C6 2F 0E      je fs_cat_found_entry
2347   0E1C 58 20 00      add d, 32
2348   0E1F 14 5B 18      mov a, [index]
2349   0E22 77            inc a
2350   0E23 42 5B 18      mov [index], a
2351   0E26 AF 10 00      cmp a, fst_files_per_dir
2352   0E29 C6 4A 0E      je fs_cat_not_found
2353   0E2C 0A 10 0E      jmp fs_cat_l1
2354   0E2F             fs_cat_found_entry:
2355   0E2F 58 19 00      add d, 25                           ; get to dirid of file in disk
2356   0E32 2A            mov b, [d]                          ; get lba
2357   0E33 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2358   0E35 3B B1 25      mov d, transient_area  
2359   0E38 38 00 00      mov c, 0
2360   0E3B 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2361   0E3D 07 7C 05      call ide_read_sect                  ; read sectors
2362   0E40 F0            pop di                              ; write userspace file data destination to di
2363   0E41 FD 4D B1 25   mov si, transient_area              ; data origin
2364   0E45 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2365   0E48 03            store
2366   0E49 06            sysret
2367   0E4A             fs_cat_not_found:
2368   0E4A E7            pop d
2369   0E4B 06            sysret
2370   0E4C             
2371   0E4C             ;------------------------------------------------------------------------------------------------------;
2372   0E4C             ; rmdir - remove dir by dirid
2373   0E4C             ;------------------------------------------------------------------------------------------------------;
2374   0E4C             ; deletes a directory entry in the given directory's file list 
2375   0E4C             ; also deletes the actual directory entry in the fst
2376   0E4C             ; synopsis: rmdir /usr/local/testdir
2377   0E4C             ; b = dirid
2378   0E4C             fs_rmdir:
2379   0E4C FD 79         mov g, b
2380   0E4E 11            mov a, b
2381   0E4F 07 EE 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2382   0E52 D7            push a                        ; save dirid
2383   0E53             ; search for directory's entry in the parent's directory then and delete it
2384   0E53 77            inc a                         ; metadata sector
2385   0E54 27            mov b, a
2386   0E55 38 00 00      mov c, 0                      ; upper lba = 0
2387   0E58 22 01         mov ah, $01          ;
2388   0E5A 3B B1 25      mov d, transient_area
2389   0E5D 07 7C 05      call ide_read_sect            ; read directory
2390   0E60 FD 10         cla
2391   0E62 42 5B 18      mov [index], a                ; reset file counter
2392   0E65 FD 27         mov b, g                      ; retrieve directory's dirid
2393   0E67             fs_rmdir_l1:
2394   0E67 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2395   0E6A B0            cmp a, b                      ; compare dirid's to find the directory
2396   0E6B C6 81 0E      je fs_rmdir_found_entry
2397   0E6E 58 20 00      add d, 32
2398   0E71 14 5B 18      mov a, [index]
2399   0E74 77            inc a
2400   0E75 42 5B 18      mov [index], a
2401   0E78 AF 10 00      cmp a, fst_files_per_dir
2402   0E7B C6 A6 0E      je fs_rmdir_not_found
2403   0E7E 0A 67 0E      jmp fs_rmdir_l1
2404   0E81             fs_rmdir_found_entry:
2405   0E81 FD 10         cla
2406   0E83 3E            mov [d], al                   ; make filename null
2407   0E84 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2408   0E87 E5            pop b
2409   0E88 FD 77         inc b                         ; metadata sector
2410   0E8A 38 00 00      mov c, 0                      ; upper lba = 0
2411   0E8D 22 01         mov ah, $01          ; 
2412   0E8F 3B B1 25      mov d, transient_area
2413   0E92 07 A2 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2414   0E95             
2415   0E95 FD 27         mov b, g
2416   0E97 3B B1 25      mov d, transient_area  
2417   0E9A FD 10         cla
2418   0E9C 3E            mov [d], al                   ; make directory's name header null for re-use
2419   0E9D 38 00 00      mov c, 0
2420   0EA0 22 01         mov ah, $01                   ; disk write 1 sect
2421   0EA2 07 A2 05      call ide_write_sect           ; delete directory given by dirid in b
2422   0EA5 06            sysret
2423   0EA6             fs_rmdir_not_found:
2424   0EA6 E5            pop b
2425   0EA7 06            sysret
2426   0EA8             
2427   0EA8             ;------------------------------------------------------------------------------------------------------;
2428   0EA8             ; rm - remove file
2429   0EA8             ;------------------------------------------------------------------------------------------------------;
2430   0EA8             ; frees up the data sectors for the file further down the disk
2431   0EA8             ; deletes file entry in the directory's file list 
2432   0EA8             fs_rm:
2433   0EA8 FD 4E         mov si, d
2434   0EAA FD 4F B1 1D   mov di, user_data
2435   0EAE 38 00 02      mov c, 512
2436   0EB1 04            load                          ; load data from user-space
2437   0EB2 14 63 18      mov a, [current_dir_id]
2438   0EB5 77            inc a                         ; metadata sector
2439   0EB6 27            mov b, a
2440   0EB7 38 00 00      mov c, 0                      ; upper lba = 0
2441   0EBA 22 01         mov ah, $01                  ; 1 sector
2442   0EBC 3B B1 25      mov d, transient_area
2443   0EBF 07 7C 05      call ide_read_sect            ; read directory
2444   0EC2 10 00 00      mov a, 0
2445   0EC5 42 5B 18      mov [index], a                ; reset file counter
2446   0EC8             fs_rm_l1:
2447   0EC8 FD 4E         mov si, d
2448   0ECA FD 4F B1 1D   mov di, user_data
2449   0ECE 07 6C 11      call _strcmp
2450   0ED1 C6 E7 0E      je fs_rm_found_entry
2451   0ED4 58 20 00      add d, 32
2452   0ED7 14 5B 18      mov a, [index]
2453   0EDA 77            inc a
2454   0EDB 42 5B 18      mov [index], a
2455   0EDE AF 10 00      cmp a, fst_files_per_dir
2456   0EE1 C6 0F 0F      je fs_rm_not_found
2457   0EE4 0A C8 0E      jmp fs_rm_l1
2458   0EE7             fs_rm_found_entry:
2459   0EE7 2B 19 00      mov b, [d + 25]               ; get lba
2460   0EEA FD 79         mov g, b                      ; save lba
2461   0EEC 19 00         mov al, 0
2462   0EEE 3E            mov [d], al                   ; make file entry null
2463   0EEF 14 63 18      mov a, [current_dir_id]
2464   0EF2 77            inc a                         ; metadata sector
2465   0EF3 27            mov b, a
2466   0EF4 38 00 00      mov c, 0                      ; upper lba = 0
2467   0EF7 22 01         mov ah, $01                   ; disk write
2468   0EF9 3B B1 25      mov d, transient_area
2469   0EFC 07 A2 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2470   0EFF 3B B1 25      mov d, transient_area  
2471   0F02 19 00         mov al, 0
2472   0F04 3E            mov [d], al                   ; make file's data header null for re-use
2473   0F05 38 00 00      mov c, 0
2474   0F08 FD 27         mov b, g                      ; get data header lba
2475   0F0A 22 01         mov ah, $01                   ; disk write 1 sect
2476   0F0C 07 A2 05      call ide_write_sect           ; write sector
2477   0F0F             fs_rm_not_found:  
2478   0F0F 06            sysret  
2479   0F10             
2480   0F10             ;------------------------------------------------------------------------------------------------------;
2481   0F10             ; mv - move / change file name
2482   0F10             ;------------------------------------------------------------------------------------------------------;
2483   0F10             fs_mv:
2484   0F10 FD 4E         mov si, d
2485   0F12 FD 4F B1 1D   mov di, user_data
2486   0F16 38 00 02      mov c, 512
2487   0F19 04            load                          ; load data from user-space
2488   0F1A 14 63 18      mov a, [current_dir_id]
2489   0F1D 77            inc a                         ; metadata sector
2490   0F1E 27            mov b, a  
2491   0F1F 38 00 00      mov c, 0                      ; upper lba = 0
2492   0F22 22 01         mov ah, $01                  ; 1 sector
2493   0F24 3B B1 25      mov d, transient_area
2494   0F27 07 7C 05      call ide_read_sect            ; read directory
2495   0F2A FD 10         cla
2496   0F2C 42 5B 18      mov [index], a                ; reset file counter
2497   0F2F             fs_mv_l1:
2498   0F2F FD 4E         mov si, d
2499   0F31 FD 4F B1 1D   mov di, user_data
2500   0F35 07 6C 11      call _strcmp
2501   0F38 C6 4E 0F      je fs_mv_found_entry
2502   0F3B 58 20 00      add d, 32
2503   0F3E 14 5B 18      mov a, [index]
2504   0F41 77            inc a
2505   0F42 42 5B 18      mov [index], a
2506   0F45 AF 10 00      cmp a, fst_files_per_dir
2507   0F48 C6 80 0F      je fs_mv_not_found
2508   0F4B 0A 2F 0F      jmp fs_mv_l1
2509   0F4E             fs_mv_found_entry:  
2510   0F4E DA            push d
2511   0F4F FD 4D 31 1E   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2512   0F53 FD 50         mov di, d
2513   0F55 07 81 11      call _strcpy  
2514   0F58 38 00 00      mov c, 0
2515   0F5B 3B B1 25      mov d, transient_area
2516   0F5E 22 01         mov ah, $01                   ; disk write 1 sect
2517   0F60 07 A2 05      call ide_write_sect           ; write sector
2518   0F63 E7            pop d
2519   0F64             ;; need to check whether its a dir or a file here ;;;
2520   0F64 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2521   0F67 22 01         mov ah, $01
2522   0F69 3B B1 25      mov d, transient_area
2523   0F6C 38 00 00      mov c, 0
2524   0F6F 07 7C 05      call ide_read_sect            ; read directory entry
2525   0F72 FD 4D 31 1E   mov si, user_data + 128
2526   0F76 FD 50         mov di, d
2527   0F78 07 81 11      call _strcpy                  ; change directory's name
2528   0F7B 22 01         mov ah, $01
2529   0F7D 07 A2 05      call ide_write_sect           ; rewrite directory back to disk
2530   0F80             fs_mv_not_found:
2531   0F80 06            sysret
2532   0F81             
2533   0F81             
2534   0F81             ;----------------------------------------------------------------------------------------------------;
2535   0F81             ; process index in a
2536   0F81             ;----------------------------------------------------------------------------------------------------;
2537   0F81             find_free_proc:
2538   0F81 FD 4D 22 1B   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2539   0F85             find_free_proc_l0:
2540   0F85 F6            lodsb                               ; get process state
2541   0F86 B9 00         cmp al, 0
2542   0F88 C6 8E 0F      je find_free_proc_free              ; if free, jump
2543   0F8B 0A 85 0F      jmp find_free_proc_l0               ; else, goto next
2544   0F8E             find_free_proc_free:
2545   0F8E 4E            mov a, si
2546   0F8F 5F 22 1B      sub a, 1 + proc_availab_table       ; get process index
2547   0F92 09            ret
2548   0F93               
2549   0F93             
2550   0F93             ;----------------------------------------------------------------------------------------------------;
2551   0F93             ; process index in al
2552   0F93             ;----------------------------------------------------------------------------------------------------;
2553   0F93             proc_memory_map:
2554   0F93 22 00         mov ah, 0
2555   0F95 27            mov b, a                      ; page in bl, 0 in bh
2556   0F96 FD 9D 05      shl a, 5                      ; multiply by 32
2557   0F99 39            mov c, a                      ; save in c
2558   0F9A 57 20 00      add c, 32
2559   0F9D             proc_memory_map_l0:
2560   0F9D 02            pagemap
2561   0F9E 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2562   0FA1 53 01 00      add a, 1                      ; increase both 
2563   0FA4 B1            cmp a, c                      ; check to see if we reached the end of memory
2564   0FA5 C7 9D 0F      jne proc_memory_map_l0
2565   0FA8 09            ret
2566   0FA9               
2567   0FA9             
2568   0FA9             ;----------------------------------------------------------------------------------------------------;
2569   0FA9             ; terminate process
2570   0FA9             ;----------------------------------------------------------------------------------------------------;
2571   0FA9             syscall_terminate_proc:
2572   0FA9 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2573   0FAC                                                    ; since they will not be used for anything here.
2574   0FAC 1D 5A 18      mov al, [active_proc_index]
2575   0FAF 22 00         mov ah, 0  
2576   0FB1 FD 9D 05      shl a, 5                             ; x32
2577   0FB4 53 31 1B      add a, proc_names
2578   0FB7 3C            mov d, a
2579   0FB8 19 00         mov al, 0
2580   0FBA 3E            mov [d], al                           ; nullify process name
2581   0FBB             
2582   0FBB 1D 5A 18      mov al, [active_proc_index]
2583   0FBE 22 00         mov ah, 0  
2584   0FC0 3C            mov d, a
2585   0FC1 19 00         mov al, 0
2586   0FC3 3F 21 1B      mov [d + proc_availab_table], al    ; make process empty again
2587   0FC6               
2588   0FC6 1D 59 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2589   0FC9 80            dec al
2590   0FCA 3D 59 18      mov [nbr_active_procs], al
2591   0FCD             
2592   0FCD             ; now load the shell process again
2593   0FCD 19 02         mov al, 2                           ; next process = process 2 = shell
2594   0FCF 3D 5A 18      mov [active_proc_index], al         ; set next active proc
2595   0FD2             
2596   0FD2             ; calculate lut entry for next process
2597   0FD2 22 00         mov ah, 0
2598   0FD4 FD 99         shl a                               ; x2
2599   0FD6 B7 9F 10      mov a, [proc_table_convert + a]     ; get process state start index  
2600   0FD9               
2601   0FD9 4D            mov si, a                           ; source is proc state block
2602   0FDA 48            mov a, sp
2603   0FDB 5F 13 00      sub a, 19
2604   0FDE 4F            mov di, a                           ; destination is kernel stack
2605   0FDF             ; restore sp
2606   0FDF 7D            dec a
2607   0FE0 47            mov sp, a
2608   0FE1 38 14 00      mov c, 20
2609   0FE4 FD F5         rep movsb
2610   0FE6             ; set vm process
2611   0FE6 1D 5A 18      mov al, [active_proc_index]
2612   0FE9 01            setptb
2613   0FEA                 
2614   0FEA 4C            popa
2615   0FEB 06            sysret
2616   0FEC             
2617   0FEC             ;----------------------------------------------------------------------------------------------------;
2618   0FEC             ; pause process
2619   0FEC             ;----------------------------------------------------------------------------------------------------;
2620   0FEC             syscall_pause_proc:
2621   0FEC             ; save all registers into kernel stack
2622   0FEC 4B            pusha
2623   0FED 22 00         mov ah, 0
2624   0FEF 1D 5A 18      mov al, [active_proc_index]
2625   0FF2 FD 99         shl a              ; x2
2626   0FF4 B7 9F 10      mov a, [proc_table_convert + a]   ; get process state start index
2627   0FF7                 
2628   0FF7 4F            mov di, a
2629   0FF8 48            mov a, sp
2630   0FF9 77            inc a
2631   0FFA 4D            mov si, a
2632   0FFB 38 14 00      mov c, 20
2633   0FFE FD F5         rep movsb                         ; save process state!
2634   1000             ; restore kernel stack position to point before interrupt arrived
2635   1000 51 14 00      add sp, 20
2636   1003             ; now load the shell process again
2637   1003 19 02         mov al, 2                         ; next process = process 2 = shell
2638   1005 3D 5A 18      mov [active_proc_index], al       ; set next active proc
2639   1008             
2640   1008             ; calculate lut entry for next process
2641   1008 22 00         mov ah, 0
2642   100A FD 99         shl a                             ; x2
2643   100C B7 9F 10      mov a, [proc_table_convert + a]   ; get process state start index  
2644   100F               
2645   100F 4D            mov si, a                         ; source is proc state block
2646   1010 48            mov a, sp
2647   1011 5F 13 00      sub a, 19
2648   1014 4F            mov di, a                         ; destination is kernel stack
2649   1015             ; restore sp
2650   1015 7D            dec a
2651   1016 47            mov sp, a
2652   1017 38 14 00      mov c, 20
2653   101A FD F5         rep movsb
2654   101C             ; set vm process
2655   101C 1D 5A 18      mov al, [active_proc_index]
2656   101F 01            setptb
2657   1020                 
2658   1020 4C            popa
2659   1021 06            sysret
2660   1022             
2661   1022             ;----------------------------------------------------------------------------------------------------;
2662   1022             ; create a new process
2663   1022             ; d = path of the process file to be createed
2664   1022             ; b = arguments ptr
2665   1022             ;----------------------------------------------------------------------------------------------------;
2666   1022             syscall_create_proc:
2667   1022             ; we save the active process first  
2668   1022 4B            pusha
2669   1023 22 00         mov ah, 0
2670   1025 1D 5A 18      mov al, [active_proc_index]
2671   1028 FD 99         shl a              ; x2
2672   102A B7 9F 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2673   102D               
2674   102D 4F            mov di, a
2675   102E 48            mov a, sp
2676   102F 77            inc a
2677   1030 4D            mov si, a
2678   1031 38 14 00      mov c, 20
2679   1034 FD F5         rep movsb                          ; save process state!
2680   1036             ; restore kernel stack position to point before interrupt arrived
2681   1036 51 14 00      add sp, 20
2682   1039               
2683   1039 FD 4E         mov si, d                          ; copy the file path
2684   103B FD 4F B1 1D   mov di, user_data
2685   103F 38 00 02      mov c, 512
2686   1042 04            load
2687   1043 11            mov a, b
2688   1044 4D            mov si, a                          ; copy the arguments
2689   1045 FD 4F B1 23   mov di, scrap_sector
2690   1049 38 00 02      mov c, 512
2691   104C 04            load
2692   104D 07 34 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2693   1050                                                  ; the file data is loaded into transient_area
2694   1050             ; now we allocate a new process  
2695   1050 07 81 0F      call find_free_proc                ; index in a
2696   1053 01            setptb 
2697   1054 07 93 0F      call proc_memory_map               ; map process memory pages
2698   1057             ; copy arguments into process's memory
2699   1057 FD 4D B1 23   mov si, scrap_sector
2700   105B FD 4F 00 00   mov di, 0
2701   105F 38 00 02      mov c, 512
2702   1062 03            store
2703   1063             ; now copy process binary data into process's memory
2704   1063 FD 4D B1 25   mov si, transient_area
2705   1067 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2706   106B 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2707   106E 03            store                              ; copy process data
2708   106F                 
2709   106F 07 81 0F      call find_free_proc                ; index in a
2710   1072 3D 5A 18      mov [active_proc_index], al        ; set new active process
2711   1075 FD 9D 05      shl a, 5                           ; x32
2712   1078 53 31 1B      add a, proc_names
2713   107B 4F            mov di, a
2714   107C FD 4D B1 1D   mov si, user_data                  ; copy and store process filename
2715   1080 07 81 11      call _strcpy
2716   1083               
2717   1083 07 81 0F      call find_free_proc                ; index in a
2718   1086 3C            mov d, a
2719   1087 19 01         mov al, 1
2720   1089 3F 21 1B      mov [d + proc_availab_table], al   ; make process busy
2721   108C               
2722   108C 1D 59 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2723   108F 7A            inc al
2724   1090 3D 59 18      mov [nbr_active_procs], al
2725   1093             ; launch process
2726   1093 FD D7 FF FF   push word $ffff 
2727   1097 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2728   109A FD D7 00 04   push word text_org
2729   109E 06            sysret
2730   109F             
2731   109F             proc_table_convert:
2732   109F E1 19         .dw proc_state_table + 0
2733   10A1 F5 19         .dw proc_state_table + 20
2734   10A3 09 1A         .dw proc_state_table + 40
2735   10A5 1D 1A         .dw proc_state_table + 60
2736   10A7 31 1A         .dw proc_state_table + 80
2737   10A9 45 1A         .dw proc_state_table + 100
2738   10AB 59 1A         .dw proc_state_table + 120
2739   10AD 6D 1A         .dw proc_state_table + 140
2740   10AF               
2741   10AF             ;----------------------------------------------------------------------------------------------;
2742   10AF             ; get hex file
2743   10AF             ; di = destination address
2744   10AF             ; return length in bytes in c
2745   10AF             ;----------------------------------------------------------------------------------------------;
2746   10AF             _load_hex:
2747   10AF D7            push a
2748   10B0 D8            push b
2749   10B1 DA            push d
2750   10B2 E2            push si
2751   10B3 E3            push di
2752   10B4 38 00 00      mov c, 0
2753   10B7 50            mov a, di
2754   10B8 3C            mov d, a          ; start of string data block
2755   10B9 07 04 12      call _gets        ; get program string
2756   10BC 4D            mov si, a
2757   10BD             __load_hex_loop:
2758   10BD F6            lodsb             ; load from [si] to al
2759   10BE B9 00         cmp al, 0         ; check if ascii 0
2760   10C0 C6 CE 10      jz __load_hex_ret
2761   10C3 36            mov bh, al
2762   10C4 F6            lodsb
2763   10C5 2F            mov bl, al
2764   10C6 07 BA 11      call _atoi        ; convert ascii byte in b to int (to al)
2765   10C9 F7            stosb             ; store al to [di]
2766   10CA 78            inc c
2767   10CB 0A BD 10      jmp __load_hex_loop
2768   10CE             __load_hex_ret:
2769   10CE F0            pop di
2770   10CF EF            pop si
2771   10D0 E7            pop d
2772   10D1 E5            pop b
2773   10D2 E4            pop a
2774   10D3 09            ret
2775   10D4             
2776   10D4             ; synopsis: look inside a certain directory for files/directories
2777   10D4             ; before calling this function, cd into required directory
2778   10D4             ; for each entry inside directory:
2779   10D4             ;  if entry is a file:
2780   10D4             ;    compare filename to searched filename
2781   10D4             ;    if filenames are the same, print filename
2782   10D4             ;  else if entry is a directory:
2783   10D4             ;    cd to the given directory
2784   10D4             ;    recursively call cmd_find
2785   10D4             ;    cd outside previous directory
2786   10D4             ;  if current entry == last entry, return
2787   10D4             ; endfor
2788   10D4             f_find:
2789   10D4 09            ret
2790   10D5             
2791   10D5             
2792   10D5             ; ---------------------------------------------------------------------
2793   10D5             ; kernel reset vector
2794   10D5             ; ---------------------------------------------------------------------
2795   10D5             kernel_reset_vector:  
2796   10D5 FD 49 FF F7   mov bp, stack_begin
2797   10D9 FD 47 FF F7   mov sp, stack_begin
2798   10DD               
2799   10DD 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2800   10DF FD 0F         stomsk                        
2801   10E1 FD 0C         sti  
2802   10E3             
2803   10E3 0C            lodstat
2804   10E4 87 DF         and al, %11011111             ; disable display register loading
2805   10E6 0D            stostat
2806   10E7               
2807   10E7             ; reset fifo pointers
2808   10E7 10 B1 1F      mov a, fifo
2809   10EA 3B 5F 18      mov d, fifo_in
2810   10ED 43            mov [d], a
2811   10EE 3B 61 18      mov d, fifo_out
2812   10F1 43            mov [d], a  
2813   10F2 19 02         mov al, 2
2814   10F4 05 03         syscall sys_io                ; enable uart in interrupt mode
2815   10F6             
2816   10F6 3B 9D 19      mov d, s_fdc_config
2817   10F9 07 29 13      call _puts
2818   10FC F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2819   1100               
2820   1100 3B B4 18      mov d, s_kernel_started
2821   1103 07 29 13      call _puts
2822   1106             
2823   1106 19 10         mov al, 16
2824   1108 05 04         syscall sys_filesystem        ; set root dirid
2825   110A             
2826   110A 3B D1 18      mov d, s_prompt_init
2827   110D 07 29 13      call _puts
2828   1110 3B 65 18      mov d, s_init_path
2829   1113 05 05         syscall sys_create_proc       ; launch init as a new process
2830   1115             
2831   1115             
2832   1115             ; file includes
2833   1115             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1115             boot_origin      .EQU  $8004
0002+  1115             bios_uart        .EQU  $0002
0003+  1115             bios_ide         .EQU  $0003
0004+  1115             bios_reset_vector .EQU  $01c0
0005+  1115             ide_buffer       .EQU  $8204
2834   1115             .include "lib/stdio.asm"
0001+  1115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1115             ; stdio.s
0003+  1115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1115             .include "lib/string.asm"
0001++ 1115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1115             ; string.s
0003++ 1115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1115             
0005++ 1115             
0006++ 1115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1115             ; _strrev
0008++ 1115             ; reverse a string
0009++ 1115             ; d = string address
0010++ 1115             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1115             ; 01234
0012++ 1115             _strrev:
0013++ 1115 4B          	pusha
0014++ 1116 07 5C 11    	call _strlen	; length in c
0015++ 1119 12          	mov a, c
0016++ 111A AF 01 00    	cmp a, 1
0017++ 111D D0 37 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1120 7D          	dec a
0019++ 1121 FD 4E       	mov si, d	; beginning of string
0020++ 1123 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1125 59          	add d, a	; end of string
0022++ 1126 12          	mov a, c
0023++ 1127 FD 9B       	shr a		; divide by 2
0024++ 1129 39          	mov c, a	; c now counts the steps
0025++ 112A             _strrev_l0:
0026++ 112A 32          	mov bl, [d]	; save load right-side char into bl
0027++ 112B F6          	lodsb		; load left-side char into al; increase si
0028++ 112C 3E          	mov [d], al	; store left char into right side
0029++ 112D 1B          	mov al, bl
0030++ 112E F7          	stosb		; store right-side char into left-side; increase di
0031++ 112F 7E          	dec c
0032++ 1130 7F          	dec d
0033++ 1131 C2 00 00    	cmp c, 0
0034++ 1134 C7 2A 11    	jne _strrev_l0
0035++ 1137             _strrev_end:
0036++ 1137 4C          	popa
0037++ 1138 09          	ret
0038++ 1139             	
0039++ 1139             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1139             ; _strchr
0041++ 1139             ; search string in d for char in al
0042++ 1139             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1139             _strchr:
0044++ 1139             _strchr_l0:
0045++ 1139 32          	mov bl, [d]
0046++ 113A C1 00       	cmp bl, 0
0047++ 113C C6 47 11    	je _strchr_end
0048++ 113F BA          	cmp al, bl
0049++ 1140 C6 47 11    	je _strchr_end
0050++ 1143 79          	inc d
0051++ 1144 0A 39 11    	jmp _strchr_l0
0052++ 1147             _strchr_end:
0053++ 1147 1B          	mov al, bl
0054++ 1148 09          	ret
0055++ 1149             
0056++ 1149             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1149             ; _strstr
0058++ 1149             ; find sub-string
0059++ 1149             ; str1 in si
0060++ 1149             ; str2 in di
0061++ 1149             ; si points to end of source string
0062++ 1149             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1149             _strstr:
0064++ 1149 DB          	push al
0065++ 114A DA          	push d
0066++ 114B E3          	push di
0067++ 114C             _strstr_loop:
0068++ 114C F3          	cmpsb					; compare a byte of the strings
0069++ 114D C7 58 11    	jne _strstr_ret
0070++ 1150 FC 00 00    	lea d, [di + 0]
0071++ 1153 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1155 C7 4C 11    	jne _strstr_loop				; equal chars but not at end
0073++ 1158             _strstr_ret:
0074++ 1158 F0          	pop di
0075++ 1159 E7          	pop d
0076++ 115A E8          	pop al
0077++ 115B 09          	ret
0078++ 115C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 115C             ; length of null terminated string
0080++ 115C             ; result in c
0081++ 115C             ; pointer in d
0082++ 115C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 115C             _strlen:
0084++ 115C DA          	push d
0085++ 115D 38 00 00    	mov c, 0
0086++ 1160             _strlen_l1:
0087++ 1160 BD 00       	cmp byte [d], 0
0088++ 1162 C6 6A 11    	je _strlen_ret
0089++ 1165 79          	inc d
0090++ 1166 78          	inc c
0091++ 1167 0A 60 11    	jmp _strlen_l1
0092++ 116A             _strlen_ret:
0093++ 116A E7          	pop d
0094++ 116B 09          	ret
0095++ 116C             
0096++ 116C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 116C             ; strcmp
0098++ 116C             ; compare two strings
0099++ 116C             ; str1 in si
0100++ 116C             ; str2 in di
0101++ 116C             ; create a string compairon instrucion ?????
0102++ 116C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 116C             _strcmp:
0104++ 116C DB          	push al
0105++ 116D DA          	push d
0106++ 116E E3          	push di
0107++ 116F E2          	push si
0108++ 1170             _strcmp_loop:
0109++ 1170 F3          	cmpsb					; compare a byte of the strings
0110++ 1171 C7 7C 11    	jne _strcmp_ret
0111++ 1174 FB FF FF    	lea d, [si +- 1]
0112++ 1177 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1179 C7 70 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 117C             _strcmp_ret:
0115++ 117C EF          	pop si
0116++ 117D F0          	pop di
0117++ 117E E7          	pop d
0118++ 117F E8          	pop al
0119++ 1180 09          	ret
0120++ 1181             
0121++ 1181             
0122++ 1181             ; strcpy
0123++ 1181             ; copy null terminated string from si to di
0124++ 1181             ; source in si
0125++ 1181             ; destination in di
0126++ 1181             _strcpy:
0127++ 1181 E2          	push si
0128++ 1182 E3          	push di
0129++ 1183 DB          	push al
0130++ 1184             _strcpy_l1:
0131++ 1184 F6          	lodsb
0132++ 1185 F7          	stosb
0133++ 1186 B9 00       	cmp al, 0
0134++ 1188 C7 84 11    	jne _strcpy_l1
0135++ 118B             _strcpy_end:
0136++ 118B E8          	pop al
0137++ 118C F0          	pop di
0138++ 118D EF          	pop si
0139++ 118E 09          	ret
0140++ 118F             
0141++ 118F             ; strcat
0142++ 118F             ; concatenate a null terminated string into string at di, from string at si
0143++ 118F             ; source in si
0144++ 118F             ; destination in di
0145++ 118F             _strcat:
0146++ 118F E2          	push si
0147++ 1190 E3          	push di
0148++ 1191 D7          	push a
0149++ 1192 DA          	push d
0150++ 1193 50          	mov a, di
0151++ 1194 3C          	mov d, a
0152++ 1195             _strcat_goto_end_l1:
0153++ 1195 BD 00       	cmp byte[d], 0
0154++ 1197 C6 9E 11    	je _strcat_start
0155++ 119A 79          	inc d
0156++ 119B 0A 95 11    	jmp _strcat_goto_end_l1
0157++ 119E             _strcat_start:
0158++ 119E FD 50       	mov di, d
0159++ 11A0             _strcat_l1:
0160++ 11A0 F6          	lodsb
0161++ 11A1 F7          	stosb
0162++ 11A2 B9 00       	cmp al, 0
0163++ 11A4 C7 A0 11    	jne _strcat_l1
0164++ 11A7             _strcat_end:
0165++ 11A7 E7          	pop d
0166++ 11A8 E4          	pop a
0167++ 11A9 F0          	pop di
0168++ 11AA EF          	pop si
0169++ 11AB 09          	ret
0170++ 11AC             
0171++ 11AC             
0005+  11AC             
0006+  11AC             
0007+  11AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  11AC             ; convert ascii 'o'..'f' to integer 0..15
0009+  11AC             ; ascii in bl
0010+  11AC             ; result in al
0011+  11AC             ; ascii for f = 0100 0110
0012+  11AC             ; ascii for 9 = 0011 1001
0013+  11AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  11AC             hex_ascii_encode:
0015+  11AC 1B            mov al, bl
0016+  11AD 93 40         test al, $40        ; test if letter or number
0017+  11AF C7 B5 11      jnz hex_letter
0018+  11B2 87 0F         and al, $0f        ; get number
0019+  11B4 09            ret
0020+  11B5             hex_letter:
0021+  11B5 87 0F         and al, $0f        ; get letter
0022+  11B7 6A 09         add al, 9
0023+  11B9 09            ret
0024+  11BA             
0025+  11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  11BA             ; atoi
0027+  11BA             ; 2 letter hex string in b
0028+  11BA             ; 8bit integer returned in al
0029+  11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  11BA             _atoi:
0031+  11BA D8            push b
0032+  11BB 07 AC 11      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  11BE 30            mov bl, bh
0034+  11BF DB            push al          ; save a
0035+  11C0 07 AC 11      call hex_ascii_encode
0036+  11C3 EA            pop bl  
0037+  11C4 FD 9E 04      shl al, 4
0038+  11C7 8C            or al, bl
0039+  11C8 E5            pop b
0040+  11C9 09            ret  
0041+  11CA             
0042+  11CA             
0043+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  11CA             ; scanf
0045+  11CA             ; no need for explanations!
0046+  11CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  11CA             scanf:
0048+  11CA 09            ret
0049+  11CB             
0050+  11CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  11CB             ; itoa
0052+  11CB             ; 8bit value in bl
0053+  11CB             ; 2 byte ascii result in a
0054+  11CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  11CB             _itoa:
0056+  11CB DA            push d
0057+  11CC D8            push b
0058+  11CD A7 00         mov bh, 0
0059+  11CF FD A4 04      shr bl, 4  
0060+  11D2 74            mov d, b
0061+  11D3 1F 65 14      mov al, [d + s_hex_digits]
0062+  11D6 23            mov ah, al
0063+  11D7               
0064+  11D7 E5            pop b
0065+  11D8 D8            push b
0066+  11D9 A7 00         mov bh, 0
0067+  11DB FD 87 0F      and bl, $0f
0068+  11DE 74            mov d, b
0069+  11DF 1F 65 14      mov al, [d + s_hex_digits]
0070+  11E2 E5            pop b
0071+  11E3 E7            pop d
0072+  11E4 09            ret
0073+  11E5             
0074+  11E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11E5             ; hex string to binary
0076+  11E5             ; di = destination address
0077+  11E5             ; si = source
0078+  11E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11E5             _hex_to_int:
0080+  11E5             _hex_to_int_l1:
0081+  11E5 F6            lodsb          ; load from [si] to al
0082+  11E6 B9 00         cmp al, 0        ; check if ascii 0
0083+  11E8 C6 F5 11      jz _hex_to_int_ret
0084+  11EB 36            mov bh, al
0085+  11EC F6            lodsb
0086+  11ED 2F            mov bl, al
0087+  11EE 07 BA 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  11F1 F7            stosb          ; store al to [di]
0089+  11F2 0A E5 11      jmp _hex_to_int_l1
0090+  11F5             _hex_to_int_ret:
0091+  11F5 09            ret    
0092+  11F6             
0093+  11F6             
0094+  11F6             
0095+  11F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11F6             ; getchar
0097+  11F6             ; char in ah
0098+  11F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11F6             getch:
0100+  11F6 DB            push al
0101+  11F7             getch_retry:
0102+  11F7 19 01         mov al, 1
0103+  11F9 05 03         syscall sys_io      ; receive in ah
0104+  11FB E8            pop al
0105+  11FC 09            ret
0106+  11FD             
0107+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11FD             ; putchar
0109+  11FD             ; char in ah
0110+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11FD             _putchar:
0112+  11FD DB            push al
0113+  11FE 19 00         mov al, 0
0114+  1200 05 03         syscall sys_io      ; char in ah
0115+  1202 E8            pop al
0116+  1203 09            ret
0117+  1204             
0118+  1204             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1204             ;; input a string
0120+  1204             ;; terminates with null
0121+  1204             ;; pointer in d
0122+  1204             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1204             _gets:
0124+  1204 D7            push a
0125+  1205 DA            push d
0126+  1206             _gets_loop:
0127+  1206 19 01         mov al, 1
0128+  1208 05 03         syscall sys_io      ; receive in ah
0129+  120A 76 1B         cmp ah, 27
0130+  120C C6 2D 12      je _gets_ansi_esc
0131+  120F 76 0A         cmp ah, $0a        ; lf
0132+  1211 C6 89 12      je _gets_end
0133+  1214 76 0D         cmp ah, $0d        ; cr
0134+  1216 C6 89 12      je _gets_end
0135+  1219 76 5C         cmp ah, $5c        ; '\\'
0136+  121B C6 4F 12      je _gets_escape
0137+  121E 76 08         cmp ah, $08      ; check for backspace
0138+  1220 C6 29 12      je _gets_backspace
0139+  1223 1A            mov al, ah
0140+  1224 3E            mov [d], al
0141+  1225 79            inc d
0142+  1226 0A 06 12      jmp _gets_loop
0143+  1229             _gets_backspace:
0144+  1229 7F            dec d
0145+  122A 0A 06 12      jmp _gets_loop
0146+  122D             _gets_ansi_esc:
0147+  122D 19 01         mov al, 1
0148+  122F 05 03         syscall sys_io        ; receive in ah without echo
0149+  1231 76 5B         cmp ah, '['
0150+  1233 C7 06 12      jne _gets_loop
0151+  1236 19 01         mov al, 1
0152+  1238 05 03         syscall sys_io          ; receive in ah without echo
0153+  123A 76 64         cmp ah, 'd'
0154+  123C C6 47 12      je _gets_left_arrow
0155+  123F 76 63         cmp ah, 'c'
0156+  1241 C6 4B 12      je _gets_right_arrow
0157+  1244 0A 06 12      jmp _gets_loop
0158+  1247             _gets_left_arrow:
0159+  1247 7F            dec d
0160+  1248 0A 06 12      jmp _gets_loop
0161+  124B             _gets_right_arrow:
0162+  124B 79            inc d
0163+  124C 0A 06 12      jmp _gets_loop
0164+  124F             _gets_escape:
0165+  124F 19 01         mov al, 1
0166+  1251 05 03         syscall sys_io      ; receive in ah
0167+  1253 76 6E         cmp ah, 'n'
0168+  1255 C6 74 12      je _gets_lf
0169+  1258 76 72         cmp ah, 'r'
0170+  125A C6 7B 12      je _gets_cr
0171+  125D 76 30         cmp ah, '0'
0172+  125F C6 82 12      je _gets_null
0173+  1262 76 5C         cmp ah, $5c  ; '\'
0174+  1264 C6 6D 12      je _gets_slash
0175+  1267 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1268 3E            mov [d], al
0177+  1269 79            inc d
0178+  126A 0A 06 12      jmp _gets_loop
0179+  126D             _gets_slash:
0180+  126D 19 5C         mov al, $5c
0181+  126F 3E            mov [d], al
0182+  1270 79            inc d
0183+  1271 0A 06 12      jmp _gets_loop
0184+  1274             _gets_lf:
0185+  1274 19 0A         mov al, $0a
0186+  1276 3E            mov [d], al
0187+  1277 79            inc d
0188+  1278 0A 06 12      jmp _gets_loop
0189+  127B             _gets_cr:
0190+  127B 19 0D         mov al, $0d
0191+  127D 3E            mov [d], al
0192+  127E 79            inc d
0193+  127F 0A 06 12      jmp _gets_loop
0194+  1282             _gets_null:
0195+  1282 19 00         mov al, $00
0196+  1284 3E            mov [d], al
0197+  1285 79            inc d
0198+  1286 0A 06 12      jmp _gets_loop
0199+  1289             _gets_end:
0200+  1289 19 00         mov al, 0
0201+  128B 3E            mov [d], al        ; terminate string
0202+  128C E7            pop d
0203+  128D E4            pop a
0204+  128E 09            ret
0205+  128F             
0206+  128F             
0207+  128F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  128F             ;; input text
0209+  128F             ;; terminated with ctrl+d
0210+  128F             ;; pointer in d
0211+  128F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  128F             _gettxt:
0213+  128F D7            push a
0214+  1290 DA            push d
0215+  1291             _gettxt_loop:
0216+  1291 19 01         mov al, 1
0217+  1293 05 03         syscall sys_io      ; receive in ah
0218+  1295 76 04         cmp ah, 4      ; eot
0219+  1297 C6 D0 12      je _gettxt_end
0220+  129A 76 08         cmp ah, $08      ; check for backspace
0221+  129C C6 CC 12      je _gettxt_backspace
0222+  129F 76 5C         cmp ah, $5c        ; '\'
0223+  12A1 C6 AA 12      je _gettxt_escape
0224+  12A4 1A            mov al, ah
0225+  12A5 3E            mov [d], al
0226+  12A6 79            inc d
0227+  12A7 0A 91 12      jmp _gettxt_loop
0228+  12AA             _gettxt_escape:
0229+  12AA 19 01         mov al, 1
0230+  12AC 05 03         syscall sys_io      ; receive in ah
0231+  12AE 76 6E         cmp ah, 'n'
0232+  12B0 C6 BE 12      je _gettxt_lf
0233+  12B3 76 72         cmp ah, 'r'
0234+  12B5 C6 C5 12      je _gettxt_cr
0235+  12B8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  12B9 3E            mov [d], al
0237+  12BA 79            inc d
0238+  12BB 0A 91 12      jmp _gettxt_loop
0239+  12BE             _gettxt_lf:
0240+  12BE 19 0A         mov al, $0a
0241+  12C0 3E            mov [d], al
0242+  12C1 79            inc d
0243+  12C2 0A 91 12      jmp _gettxt_loop
0244+  12C5             _gettxt_cr:
0245+  12C5 19 0D         mov al, $0d
0246+  12C7 3E            mov [d], al
0247+  12C8 79            inc d
0248+  12C9 0A 91 12      jmp _gettxt_loop
0249+  12CC             _gettxt_backspace:
0250+  12CC 7F            dec d
0251+  12CD 0A 91 12      jmp _gettxt_loop
0252+  12D0             _gettxt_end:
0253+  12D0 19 00         mov al, 0
0254+  12D2 3E            mov [d], al        ; terminate string
0255+  12D3 E7            pop d
0256+  12D4 E4            pop a
0257+  12D5 09            ret
0258+  12D6             
0259+  12D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  12D6             ; print new line
0261+  12D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  12D6             printnl:
0263+  12D6 D7            push a
0264+  12D7 10 00 0A      mov a, $0a00
0265+  12DA 05 03         syscall sys_io
0266+  12DC 10 00 0D      mov a, $0d00
0267+  12DF 05 03         syscall sys_io
0268+  12E1 E4            pop a
0269+  12E2 09            ret
0270+  12E3             
0271+  12E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  12E3             ; _strtoint
0273+  12E3             ; 4 digit hex string number in d
0274+  12E3             ; integer returned in a
0275+  12E3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12E3             _strtointx:
0277+  12E3 D8            push b
0278+  12E4 32            mov bl, [d]
0279+  12E5 37            mov bh, bl
0280+  12E6 33 01 00      mov bl, [d + 1]
0281+  12E9 07 BA 11      call _atoi        ; convert to int in al
0282+  12EC 23            mov ah, al        ; move to ah
0283+  12ED 33 02 00      mov bl, [d + 2]
0284+  12F0 37            mov bh, bl
0285+  12F1 33 03 00      mov bl, [d + 3]
0286+  12F4 07 BA 11      call _atoi        ; convert to int in al
0287+  12F7 E5            pop b
0288+  12F8 09            ret
0289+  12F9             
0290+  12F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  12F9             ; _strtoint
0292+  12F9             ; 5 digit base10 string number in d
0293+  12F9             ; integer returned in a
0294+  12F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  12F9             _strtoint:
0296+  12F9 E2            push si
0297+  12FA D8            push b
0298+  12FB D9            push c
0299+  12FC DA            push d
0300+  12FD 07 5C 11      call _strlen      ; get string length in c
0301+  1300 7E            dec c
0302+  1301 FD 4E         mov si, d
0303+  1303 12            mov a, c
0304+  1304 FD 99         shl a
0305+  1306 3B 7D 14      mov d, table_power
0306+  1309 59            add d, a
0307+  130A 38 00 00      mov c, 0
0308+  130D             _strtoint_l0:
0309+  130D F6            lodsb      ; load ascii to al
0310+  130E B9 00         cmp al, 0
0311+  1310 C6 23 13      je _strtoint_end
0312+  1313 6F 30         sub al, $30    ; make into integer
0313+  1315 22 00         mov ah, 0
0314+  1317 2A            mov b, [d]
0315+  1318 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1319 11            mov a, b
0317+  131A 28            mov b, c
0318+  131B 54            add a, b
0319+  131C 39            mov c, a
0320+  131D 63 02 00      sub d, 2
0321+  1320 0A 0D 13      jmp _strtoint_l0
0322+  1323             _strtoint_end:
0323+  1323 12            mov a, c
0324+  1324 E7            pop d
0325+  1325 E6            pop c
0326+  1326 E5            pop b
0327+  1327 EF            pop si
0328+  1328 09            ret
0329+  1329             
0330+  1329             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1329             ; print null terminated string
0332+  1329             ; pointer in d
0333+  1329             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1329             _puts:
0335+  1329 D7            push a
0336+  132A DA            push d
0337+  132B             _puts_l1:
0338+  132B 1E            mov al, [d]
0339+  132C B9 00         cmp al, 0
0340+  132E C6 3A 13      jz _puts_end
0341+  1331 23            mov ah, al
0342+  1332 19 00         mov al, 0
0343+  1334 05 03         syscall sys_io
0344+  1336 79            inc d
0345+  1337 0A 2B 13      jmp _puts_l1
0346+  133A             _puts_end:
0347+  133A E7            pop d
0348+  133B E4            pop a
0349+  133C 09            ret
0350+  133D             
0351+  133D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  133D             ; print n size string
0353+  133D             ; pointer in d
0354+  133D             ; size in c
0355+  133D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  133D             _putsn:
0357+  133D DB            push al
0358+  133E DA            push d
0359+  133F D9            push c
0360+  1340             _putsn_l0:
0361+  1340 1E            mov al, [d]
0362+  1341 23            mov ah, al
0363+  1342 19 00         mov al, 0
0364+  1344 05 03         syscall sys_io
0365+  1346 79            inc d
0366+  1347 7E            dec c  
0367+  1348 C2 00 00      cmp c, 0
0368+  134B C7 40 13      jne _putsn_l0
0369+  134E             _putsn_end:
0370+  134E E6            pop c
0371+  134F E7            pop d
0372+  1350 E8            pop al
0373+  1351 09            ret
0374+  1352             
0375+  1352             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1352             ; print 16bit decimal number
0377+  1352             ; input number in a
0378+  1352             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1352             print_u16d:
0380+  1352 D7            push a
0381+  1353 D8            push b
0382+  1354 FD D8         push g
0383+  1356 26 10 27      mov b, 10000
0384+  1359 AE            div a, b      ; get 10000's coeff.
0385+  135A 07 7E 13      call print_number
0386+  135D 11            mov a, b
0387+  135E 26 E8 03      mov b, 1000
0388+  1361 AE            div a, b      ; get 1000's coeff.
0389+  1362 07 7E 13      call print_number
0390+  1365 11            mov a, b
0391+  1366 26 64 00      mov b, 100
0392+  1369 AE            div a, b
0393+  136A 07 7E 13      call print_number
0394+  136D 11            mov a, b
0395+  136E 26 0A 00      mov b, 10
0396+  1371 AE            div a, b
0397+  1372 07 7E 13      call print_number
0398+  1375 1B            mov al, bl      ; 1's coeff in bl
0399+  1376 07 7E 13      call print_number
0400+  1379 FD F1         pop g
0401+  137B E5            pop b
0402+  137C E4            pop a
0403+  137D 09            ret
0404+  137E             
0405+  137E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  137E             ; print al
0407+  137E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  137E             print_number:
0409+  137E 6A 30         add al, $30
0410+  1380 23            mov ah, al
0411+  1381 07 FD 11      call _putchar
0412+  1384 09            ret
0413+  1385             
0414+  1385             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1385             ; print 16bit hex integer
0416+  1385             ; integer value in reg b
0417+  1385             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1385             print_u16x:
0419+  1385 D7            push a
0420+  1386 D8            push b
0421+  1387 DD            push bl
0422+  1388 30            mov bl, bh
0423+  1389 07 CB 11      call _itoa        ; convert bh to char in a
0424+  138C 2F            mov bl, al        ; save al
0425+  138D 19 00         mov al, 0
0426+  138F 05 03         syscall sys_io        ; display ah
0427+  1391 24            mov ah, bl        ; retrieve al
0428+  1392 19 00         mov al, 0
0429+  1394 05 03         syscall sys_io        ; display al
0430+  1396             
0431+  1396 EA            pop bl
0432+  1397 07 CB 11      call _itoa        ; convert bh to char in a
0433+  139A 2F            mov bl, al        ; save al
0434+  139B 19 00         mov al, 0
0435+  139D 05 03         syscall sys_io        ; display ah
0436+  139F 24            mov ah, bl        ; retrieve al
0437+  13A0 19 00         mov al, 0
0438+  13A2 05 03         syscall sys_io        ; display al
0439+  13A4             
0440+  13A4 E5            pop b
0441+  13A5 E4            pop a
0442+  13A6 09            ret
0443+  13A7             
0444+  13A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  13A7             ; input 16bit hex integer
0446+  13A7             ; read 16bit integer into a
0447+  13A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  13A7             scan_u16x:
0449+  13A7 F8 10 00      enter 16
0450+  13AA D8            push b
0451+  13AB DA            push d
0452+  13AC             
0453+  13AC FA F1 FF      lea d, [bp + -15]
0454+  13AF 07 04 12      call _gets        ; get number
0455+  13B2             
0456+  13B2 32            mov bl, [d]
0457+  13B3 37            mov bh, bl
0458+  13B4 33 01 00      mov bl, [d + 1]
0459+  13B7 07 BA 11      call _atoi        ; convert to int in al
0460+  13BA 23            mov ah, al        ; move to ah
0461+  13BB             
0462+  13BB 33 02 00      mov bl, [d + 2]
0463+  13BE 37            mov bh, bl
0464+  13BF 33 03 00      mov bl, [d + 3]
0465+  13C2 07 BA 11      call _atoi        ; convert to int in al
0466+  13C5             
0467+  13C5 E7            pop d
0468+  13C6 E5            pop b
0469+  13C7 F9            leave
0470+  13C8 09            ret
0471+  13C9             
0472+  13C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  13C9             ; print 8bit hex integer
0474+  13C9             ; integer value in reg bl
0475+  13C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  13C9             print_u8x:
0477+  13C9 D7            push a
0478+  13CA DD            push bl
0479+  13CB             
0480+  13CB 07 CB 11      call _itoa        ; convert bl to char in a
0481+  13CE 2F            mov bl, al        ; save al
0482+  13CF 19 00         mov al, 0
0483+  13D1 05 03         syscall sys_io        ; display ah
0484+  13D3 24            mov ah, bl        ; retrieve al
0485+  13D4 19 00         mov al, 0
0486+  13D6 05 03         syscall sys_io        ; display al
0487+  13D8             
0488+  13D8 EA            pop bl
0489+  13D9 E4            pop a
0490+  13DA 09            ret
0491+  13DB             
0492+  13DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  13DB             ; print 8bit decimal unsigned number
0494+  13DB             ; input number in al
0495+  13DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  13DB             print_u8d:
0497+  13DB D7            push a
0498+  13DC D8            push b
0499+  13DD FD D8         push g
0500+  13DF 22 00         mov ah, 0
0501+  13E1 26 64 00      mov b, 100
0502+  13E4 AE            div a, b
0503+  13E5 D8            push b      ; save remainder
0504+  13E6 B9 00         cmp al, 0
0505+  13E8 C6 F2 13      je skip100
0506+  13EB 6A 30         add al, $30
0507+  13ED 23            mov ah, al
0508+  13EE 19 00         mov al, 0
0509+  13F0 05 03         syscall sys_io  ; print coeff
0510+  13F2             skip100:
0511+  13F2 E4            pop a
0512+  13F3 22 00         mov ah, 0
0513+  13F5 26 0A 00      mov b, 10
0514+  13F8 AE            div a, b
0515+  13F9 D8            push b      ; save remainder
0516+  13FA B9 00         cmp al, 0
0517+  13FC C6 06 14      je skip10
0518+  13FF 6A 30         add al, $30
0519+  1401 23            mov ah, al
0520+  1402 19 00         mov al, 0
0521+  1404 05 03         syscall sys_io  ; print coeff
0522+  1406             skip10:
0523+  1406 E4            pop a
0524+  1407 1B            mov al, bl
0525+  1408 6A 30         add al, $30
0526+  140A 23            mov ah, al
0527+  140B 19 00         mov al, 0
0528+  140D 05 03         syscall sys_io  ; print coeff
0529+  140F FD F1         pop g
0530+  1411 E5            pop b
0531+  1412 E4            pop a
0532+  1413 09            ret
0533+  1414             
0534+  1414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1414             ; input 8bit hex integer
0536+  1414             ; read 8bit integer into al
0537+  1414             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1414             scan_u8x:
0539+  1414 F8 04 00      enter 4
0540+  1417 D8            push b
0541+  1418 DA            push d
0542+  1419             
0543+  1419 FA FD FF      lea d, [bp + -3]
0544+  141C 07 04 12      call _gets        ; get number
0545+  141F             
0546+  141F 32            mov bl, [d]
0547+  1420 37            mov bh, bl
0548+  1421 33 01 00      mov bl, [d + 1]
0549+  1424 07 BA 11      call _atoi        ; convert to int in al
0550+  1427             
0551+  1427 E7            pop d
0552+  1428 E5            pop b
0553+  1429 F9            leave
0554+  142A 09            ret
0555+  142B             
0556+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  142B             ; input decimal number
0558+  142B             ; result in a
0559+  142B             ; 655'\0'
0560+  142B             ; low--------high
0561+  142B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  142B             scan_u16d:
0563+  142B F8 08 00      enter 8
0564+  142E E2            push si
0565+  142F D8            push b
0566+  1430 D9            push c
0567+  1431 DA            push d
0568+  1432 FA F9 FF      lea d, [bp +- 7]
0569+  1435 07 04 12      call _gets
0570+  1438 07 5C 11      call _strlen      ; get string length in c
0571+  143B 7E            dec c
0572+  143C FD 4E         mov si, d
0573+  143E 12            mov a, c
0574+  143F FD 99         shl a
0575+  1441 3B 7D 14      mov d, table_power
0576+  1444 59            add d, a
0577+  1445 38 00 00      mov c, 0
0578+  1448             mul_loop:
0579+  1448 F6            lodsb      ; load ascii to al
0580+  1449 B9 00         cmp al, 0
0581+  144B C6 5E 14      je mul_exit
0582+  144E 6F 30         sub al, $30    ; make into integer
0583+  1450 22 00         mov ah, 0
0584+  1452 2A            mov b, [d]
0585+  1453 AC            mul a, b      ; result in b since it fits in 16bits
0586+  1454 11            mov a, b
0587+  1455 28            mov b, c
0588+  1456 54            add a, b
0589+  1457 39            mov c, a
0590+  1458 63 02 00      sub d, 2
0591+  145B 0A 48 14      jmp mul_loop
0592+  145E             mul_exit:
0593+  145E 12            mov a, c
0594+  145F E7            pop d
0595+  1460 E6            pop c
0596+  1461 E5            pop b
0597+  1462 EF            pop si
0598+  1463 F9            leave
0599+  1464 09            ret
0600+  1465             
0601+  1465             
0602+  1465 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  1469 34 35 36 37 
0602+  146D 38 39 61 62 
0602+  1471 63 64 65 66 
0603+  1475 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  1479 1B 5B 68 00 
0604+  147D             
0605+  147D             table_power:
0606+  147D 01 00         .dw 1
0607+  147F 0A 00         .dw 10
0608+  1481 64 00         .dw 100
0609+  1483 E8 03         .dw 1000
0610+  1485 10 27         .dw 100002835   1487             .include "lib/ctype.asm"
0001+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1487             ; ctype.s
0003+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1487             
0005+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1487             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  1487             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  1487             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  1487             ;; characters are supported.
0010+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1487             ;; _isalnum 
0012+  1487             ;; _isalpha 
0013+  1487             ;; islower 
0014+  1487             ;; isupper 
0015+  1487             ;; _isdigit 
0016+  1487             ;; isxdigit
0017+  1487             ;; iscntrl 
0018+  1487             ;; isgraph 
0019+  1487             ;; _isspace 
0020+  1487             ;; isblank 
0021+  1487             ;; isprint 
0022+  1487             ;; ispunct 
0023+  1487             ;; tolower 
0024+  1487             ;; toupper
0025+  1487             
0026+  1487             
0027+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1487             ;; is alphanumeric
0029+  1487             ;; sets zf according with result
0030+  1487             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1487             _isalnum:
0032+  1487 07 A4 14    	call _isalpha
0033+  148A C6 90 14    	je _isalnum_exit
0034+  148D 07 91 14    	call _isdigit
0035+  1490             _isalnum_exit:
0036+  1490 09          	ret	
0037+  1491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1491             ;; is digit
0039+  1491             ;; sets zf according with result
0040+  1491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1491             _isdigit:
0042+  1491 DB          	push al
0043+  1492 B9 30       	cmp al, '0'
0044+  1494 C8 A0 14    	jlu _isdigit_false
0045+  1497 B9 39       	cmp al, '9'
0046+  1499 D1 A0 14    	jgu _isdigit_false
0047+  149C 87 00       	and al, 0	; set zf
0048+  149E E8          	pop al
0049+  149F 09          	ret
0050+  14A0             _isdigit_false:
0051+  14A0 8B 01       	or al, 1	; clear zf
0052+  14A2 E8          	pop al
0053+  14A3 09          	ret	
0054+  14A4             	
0055+  14A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  14A4             ;; is alpha
0057+  14A4             ;; sets zf according with result
0058+  14A4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  14A4             _isalpha:
0060+  14A4 DB          	push al
0061+  14A5 B9 5F       	cmp al, '_'
0062+  14A7 C6 C7 14    	je _isalpha_true
0063+  14AA B9 2E       	cmp al, '.'
0064+  14AC C6 C7 14    	je _isalpha_true
0065+  14AF B9 61       	cmp al, 'a'
0066+  14B1 C8 C3 14    	jlu _isalpha_false
0067+  14B4 B9 7A       	cmp al, 'z'
0068+  14B6 D1 C3 14    	jgu _isalpha_false
0069+  14B9 B9 7A       	cmp al, 'z'
0070+  14BB D0 C7 14    	jleu _isalpha_true
0071+  14BE B9 61       	cmp al, 'a'
0072+  14C0 C9 C7 14    	jgeu _isalpha_true
0073+  14C3             _isalpha_false:
0074+  14C3 8B 01       	or al, 1	; clear zf
0075+  14C5 E8          	pop al
0076+  14C6 09          	ret
0077+  14C7             _isalpha_true:
0078+  14C7 87 00       	and al, 0	; set zf
0079+  14C9 E8          	pop al
0080+  14CA 09          	ret
0081+  14CB             
0082+  14CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  14CB             ;; is path-alpha
0084+  14CB             ;; sets zf according with result
0085+  14CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  14CB             ispath:
0087+  14CB DB          	push al
0088+  14CC 07 91 14    	call _isdigit
0089+  14CF C6 F9 14    	je ispath_true
0090+  14D2 B9 5F       	cmp al, '_'
0091+  14D4 C6 F9 14    	je ispath_true
0092+  14D7 B9 2F       	cmp al, '/'
0093+  14D9 C6 F9 14    	je ispath_true
0094+  14DC B9 2E       	cmp al, '.'
0095+  14DE C6 F9 14    	je ispath_true
0096+  14E1 B9 61       	cmp al, 'a'
0097+  14E3 C8 F5 14    	jlu ispath_false
0098+  14E6 B9 7A       	cmp al, 'z'
0099+  14E8 D1 F5 14    	jgu ispath_false
0100+  14EB B9 7A       	cmp al, 'z'
0101+  14ED D0 F9 14    	jleu ispath_true
0102+  14F0 B9 61       	cmp al, 'a'
0103+  14F2 C9 F9 14    	jgeu ispath_true
0104+  14F5             ispath_false:
0105+  14F5 8B 01       	or al, 1	; clear zf
0106+  14F7 E8          	pop al
0107+  14F8 09          	ret
0108+  14F9             ispath_true:
0109+  14F9 87 00       	and al, 0	; set zf
0110+  14FB E8          	pop al
0111+  14FC 09          	ret
0112+  14FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14FD             ;; is space
0114+  14FD             ;; sets zf according with result
0115+  14FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14FD             _isspace:
0117+  14FD B9 20       	cmp al, $20		; ' '
0118+  14FF C6 13 15    	je _isspace_exit
0119+  1502 B9 09       	cmp al, $09		; '\t'
0120+  1504 C6 13 15    	je _isspace_exit
0121+  1507 B9 0A       	cmp al, $0a		; '\n'
0122+  1509 C6 13 15    	je _isspace_exit
0123+  150C B9 0D       	cmp al, $0d		; '\r'
0124+  150E C6 13 15    	je _isspace_exit
0125+  1511 B9 0B       	cmp al, $0b		; '\v'
0126+  1513             _isspace_exit:
0127+  1513 09          	ret	
0128+  1514             
0129+  1514             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1514             ; to lower
0131+  1514             ; input in al
0132+  1514             ; output in al
0133+  1514             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1514             _to_lower:
0135+  1514 B9 7A       	cmp al, 'z'
0136+  1516 D1 1B 15    	jgu _to_lower_ret
0137+  1519 6A 20       	add al, $20				; convert to lower case
0138+  151B             _to_lower_ret:
0139+  151B 09          	ret
0140+  151C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  151C             ; to upper
0142+  151C             ; input in al
0143+  151C             ; output in al
0144+  151C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  151C             _to_upper:
0146+  151C B9 61       	cmp al, 'a'
0147+  151E C8 23 15    	jlu _to_upper_ret
0148+  1521 6F 20       	sub al, $20			; convert to upper case
0149+  1523             _to_upper_ret:
0150+  1523 09          	ret
0151+  1524             
2836   1524             .include "lib/token.asm"
0001+  1524             toktyp_identifier  .equ 0
0002+  1524             toktyp_keyword     .equ 1
0003+  1524             toktyp_delimiter   .equ 2
0004+  1524             toktyp_string      .equ 3
0005+  1524             toktyp_char        .equ 4
0006+  1524             toktyp_numeric     .equ 5
0007+  1524             toktyp_end         .equ 6
0008+  1524             
0009+  1524             tok_null           .equ 0
0010+  1524             tok_fslash         .equ 1
0011+  1524             tok_times          .equ 2
0012+  1524             tok_plus           .equ 3
0013+  1524             tok_minus          .equ 4
0014+  1524             tok_dot            .equ 5
0015+  1524             tok_semi           .equ 6
0016+  1524             tok_angle          .equ 7
0017+  1524             tok_tilde          .equ 8
0018+  1524             tok_equal          .equ 9
0019+  1524             tok_colon          .equ 10
0020+  1524             tok_comma          .equ 11
0021+  1524             
0022+  1524             tok_end            .equ 20
0023+  1524             
0024+  1524             
0025+  1524             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1524             ;; read a full command argment from shell input buffer
0027+  1524             ;; argument is written into tokstr
0028+  1524             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1524             get_arg:
0030+  1524 D7            push a
0031+  1525 E2            push si
0032+  1526 E3            push di
0033+  1527 19 00         mov al, 0
0034+  1529 3D 52 17      mov [tokstr], al      ; nullify tokstr string
0035+  152C 14 4E 17      mov a, [prog]
0036+  152F 4D            mov si, a
0037+  1530 FD 4F 52 17   mov di, tokstr
0038+  1534             get_arg_skip_spaces:
0039+  1534 F6            lodsb
0040+  1535 07 FD 14      call _isspace
0041+  1538 C6 34 15      je get_arg_skip_spaces
0042+  153B             get_arg_l0:
0043+  153B B9 3B         cmp al, $3b        ; check if is ';'
0044+  153D C6 4A 15      je get_arg_end
0045+  1540 B9 00         cmp al, 0
0046+  1542 C6 4A 15      je get_arg_end      ; check if end of input
0047+  1545 F7            stosb
0048+  1546 F6            lodsb
0049+  1547 0A 3B 15      jmp get_arg_l0
0050+  154A             get_arg_end:
0051+  154A 19 00         mov al, 0
0052+  154C F7            stosb
0053+  154D D5 01 00      sub si, 1
0054+  1550 4E            mov a, si
0055+  1551 42 4E 17      mov [prog], a    ; update pointer
0056+  1554 F0            pop di
0057+  1555 EF            pop si
0058+  1556 E4            pop a
0059+  1557 09            ret
0060+  1558             
0061+  1558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1558             ;; read a path formation from shell input buffer
0063+  1558             ;; path is written into tokstr
0064+  1558             ;; /usr/bin
0065+  1558             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1558             get_path:
0067+  1558 D7            push a
0068+  1559 E2            push si
0069+  155A E3            push di
0070+  155B 19 00         mov al, 0
0071+  155D 3D 52 17      mov [tokstr], al      ; nullify tokstr string
0072+  1560 14 4E 17      mov a, [prog]
0073+  1563 4D            mov si, a
0074+  1564 FD 4F 52 17   mov di, tokstr
0075+  1568             get_path_skip_spaces:
0076+  1568 F6            lodsb
0077+  1569 07 FD 14      call _isspace
0078+  156C C6 68 15      je get_path_skip_spaces
0079+  156F             get_path_is_pathchar:
0080+  156F F7            stosb
0081+  1570 F6            lodsb
0082+  1571 07 87 14      call _isalnum      ;check if is alphanumeric
0083+  1574 C6 6F 15      je get_path_is_pathchar
0084+  1577 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1579 C6 6F 15      je get_path_is_pathchar
0086+  157C 19 00         mov al, 0
0087+  157E F7            stosb
0088+  157F D5 01 00      sub si, 1
0089+  1582 4E            mov a, si
0090+  1583 42 4E 17      mov [prog], a    ; update pointer
0091+  1586             get_path_end:
0092+  1586 F0            pop di
0093+  1587 EF            pop si
0094+  1588 E4            pop a
0095+  1589 09            ret
0096+  158A             
0097+  158A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  158A             ;; read a line
0099+  158A             ;; line is written into tokstr
0100+  158A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  158A             get_line:
0102+  158A D7            push a
0103+  158B E2            push si
0104+  158C E3            push di
0105+  158D 19 00         mov al, 0
0106+  158F 3D 52 17      mov [tokstr], al      ; nullify tokstr string
0107+  1592 14 4E 17      mov a, [prog]
0108+  1595 4D            mov si, a
0109+  1596 FD 4F 52 17   mov di, tokstr
0110+  159A             get_line_l0:
0111+  159A F6            lodsb
0112+  159B B9 0A         cmp al, $0a    ; check for new line
0113+  159D C6 A4 15      je get_line_exit
0114+  15A0 F7            stosb
0115+  15A1 0A 9A 15      jmp get_line_l0
0116+  15A4             get_line_exit:
0117+  15A4 19 00         mov al, 0
0118+  15A6 F7            stosb
0119+  15A7 4E            mov a, si
0120+  15A8 42 4E 17      mov [prog], a    ; update pointer
0121+  15AB F0            pop di
0122+  15AC EF            pop si
0123+  15AD E4            pop a
0124+  15AE 09            ret
0125+  15AF             
0126+  15AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  15AF             ;; token parser
0128+  15AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  15AF             get_token:
0130+  15AF D7            push a
0131+  15B0 DA            push d
0132+  15B1 E2            push si
0133+  15B2 E3            push di
0134+  15B3 19 00         mov al, 0
0135+  15B5 3D 52 17      mov [tokstr], al      ; nullify tokstr string
0136+  15B8 19 00         mov al, tok_null
0137+  15BA 3D 51 17      mov [tok], al        ; nullify token
0138+  15BD 14 4E 17      mov a, [prog]
0139+  15C0 4D            mov si, a
0140+  15C1 FD 4F 52 17   mov di, tokstr
0141+  15C5             get_tok_skip_spaces:
0142+  15C5 F6            lodsb
0143+  15C6 07 FD 14      call _isspace
0144+  15C9 C6 C5 15      je get_tok_skip_spaces
0145+  15CC B9 00         cmp al, 0      ; check for end of input (null)
0146+  15CE C6 B3 16      je get_token_end
0147+  15D1 B9 23         cmp al, '#'      ; comments!
0148+  15D3 C6 E1 16      je get_tok_comment
0149+  15D6 07 87 14      call _isalnum
0150+  15D9 C6 C0 16      jz is_alphanumeric
0151+  15DC             ; other token types
0152+  15DC             get_token_slash:
0153+  15DC B9 2F         cmp al, '/'        ; check if '/'
0154+  15DE C7 F6 15      jne get_token_minus
0155+  15E1 F7            stosb          ; store '/' into token string
0156+  15E2 19 00         mov al, 0
0157+  15E4 F7            stosb          ; terminate token string
0158+  15E5 19 01         mov al, tok_fslash
0159+  15E7 3D 51 17      mov [tok], al      
0160+  15EA 19 02         mov al, toktyp_delimiter
0161+  15EC 3D 50 17      mov [toktyp], al
0162+  15EF 4E            mov a, si
0163+  15F0 42 4E 17      mov [prog], a    ; update pointer
0164+  15F3 0A DC 16      jmp get_token_return
0165+  15F6             get_token_minus:
0166+  15F6 B9 2D         cmp al, '-'        ; check if '-'
0167+  15F8 C7 10 16      jne get_token_comma
0168+  15FB F7            stosb          ; store '-' into token string
0169+  15FC 19 00         mov al, 0
0170+  15FE F7            stosb          ; terminate token string
0171+  15FF 19 04         mov al, tok_minus
0172+  1601 3D 51 17      mov [tok], al      
0173+  1604 19 02         mov al, toktyp_delimiter
0174+  1606 3D 50 17      mov [toktyp], al
0175+  1609 4E            mov a, si
0176+  160A 42 4E 17      mov [prog], a    ; update pointer
0177+  160D 0A DC 16      jmp get_token_return
0178+  1610             get_token_comma:
0179+  1610 B9 2C         cmp al, ','        ; check if ','
0180+  1612 C7 2A 16      jne get_token_semi
0181+  1615 F7            stosb          ; store ',' into token string
0182+  1616 19 00         mov al, 0
0183+  1618 F7            stosb          ; terminate token string
0184+  1619 19 0B         mov al, tok_comma
0185+  161B 3D 51 17      mov [tok], al      
0186+  161E 19 02         mov al, toktyp_delimiter
0187+  1620 3D 50 17      mov [toktyp], al
0188+  1623 4E            mov a, si
0189+  1624 42 4E 17      mov [prog], a    ; update pointer
0190+  1627 0A DC 16      jmp get_token_return
0191+  162A             get_token_semi:
0192+  162A B9 3B         cmp al, $3b        ; check if ';'
0193+  162C C7 44 16      jne get_token_colon
0194+  162F F7            stosb          ; store ';' into token string
0195+  1630 19 00         mov al, 0
0196+  1632 F7            stosb          ; terminate token string
0197+  1633 19 06         mov al, tok_semi
0198+  1635 3D 51 17      mov [tok], al      
0199+  1638 19 02         mov al, toktyp_delimiter
0200+  163A 3D 50 17      mov [toktyp], al
0201+  163D 4E            mov a, si
0202+  163E 42 4E 17      mov [prog], a    ; update pointer
0203+  1641 0A DC 16      jmp get_token_return
0204+  1644             get_token_colon:
0205+  1644 B9 3A         cmp al, $3a        ; check if ':'
0206+  1646 C7 5E 16      jne get_token_angle
0207+  1649 F7            stosb          ; store ':' into token string
0208+  164A 19 00         mov al, 0
0209+  164C F7            stosb          ; terminate token string
0210+  164D 19 0A         mov al, tok_colon
0211+  164F 3D 51 17      mov [tok], al      
0212+  1652 19 02         mov al, toktyp_delimiter
0213+  1654 3D 50 17      mov [toktyp], al
0214+  1657 4E            mov a, si
0215+  1658 42 4E 17      mov [prog], a    ; update pointer
0216+  165B 0A DC 16      jmp get_token_return
0217+  165E             get_token_angle:
0218+  165E B9 3E         cmp al, $3e        ; check if '>'
0219+  1660 C7 78 16      jne get_token_tilde
0220+  1663 F7            stosb          ; store '>' into token string
0221+  1664 19 00         mov al, 0
0222+  1666 F7            stosb          ; terminate token string
0223+  1667 19 07         mov al, tok_angle
0224+  1669 3D 51 17      mov [tok], al      
0225+  166C 19 02         mov al, toktyp_delimiter
0226+  166E 3D 50 17      mov [toktyp], al
0227+  1671 4E            mov a, si
0228+  1672 42 4E 17      mov [prog], a    ; update pointer
0229+  1675 0A DC 16      jmp get_token_return
0230+  1678             get_token_tilde:
0231+  1678 B9 7E         cmp al, '~'        ; check if '~'
0232+  167A C7 92 16      jne get_token_equal
0233+  167D F7            stosb          ; store '~' into token string
0234+  167E 19 00         mov al, 0
0235+  1680 F7            stosb          ; terminate token string
0236+  1681 19 08         mov al, tok_tilde
0237+  1683 3D 51 17      mov [tok], al      
0238+  1686 19 02         mov al, toktyp_delimiter
0239+  1688 3D 50 17      mov [toktyp], al
0240+  168B 4E            mov a, si
0241+  168C 42 4E 17      mov [prog], a    ; update pointer
0242+  168F 0A DC 16      jmp get_token_return
0243+  1692             get_token_equal:
0244+  1692 B9 3D         cmp al, '='        ; check if '='
0245+  1694 C7 AC 16      jne get_token_skip
0246+  1697 F7            stosb          ; store '=' into token string
0247+  1698 19 00         mov al, 0
0248+  169A F7            stosb          ; terminate token string
0249+  169B 19 09         mov al, tok_equal
0250+  169D 3D 51 17      mov [tok], al      
0251+  16A0 19 02         mov al, toktyp_delimiter
0252+  16A2 3D 50 17      mov [toktyp], al
0253+  16A5 4E            mov a, si
0254+  16A6 42 4E 17      mov [prog], a    ; update pointer
0255+  16A9 0A DC 16      jmp get_token_return
0256+  16AC             get_token_skip:
0257+  16AC 4E            mov a, si
0258+  16AD 42 4E 17      mov [prog], a    ; update pointer
0259+  16B0 0A DC 16      jmp get_token_return
0260+  16B3             get_token_end:        ; end of file token
0261+  16B3 19 14         mov al, tok_end
0262+  16B5 3D 51 17      mov [tok], al
0263+  16B8 19 06         mov al, toktyp_end
0264+  16BA 3D 50 17      mov [toktyp], al
0265+  16BD 0A DC 16      jmp get_token_return
0266+  16C0             is_alphanumeric:
0267+  16C0 F7            stosb
0268+  16C1 F6            lodsb
0269+  16C2 07 87 14      call _isalnum      ;check if is alphanumeric
0270+  16C5 C6 C0 16      jz is_alphanumeric
0271+  16C8 B9 2E         cmp al, $2e        ; check if is '.'
0272+  16CA C6 C0 16      je is_alphanumeric
0273+  16CD 19 00         mov al, 0
0274+  16CF F7            stosb
0275+  16D0 19 00         mov al, toktyp_identifier
0276+  16D2 3D 50 17      mov [toktyp], al
0277+  16D5 D5 01 00      sub si, 1
0278+  16D8 4E            mov a, si
0279+  16D9 42 4E 17      mov [prog], a    ; update pointer
0280+  16DC             get_token_return:
0281+  16DC F0            pop di
0282+  16DD EF            pop si
0283+  16DE E7            pop d
0284+  16DF E4            pop a
0285+  16E0 09            ret
0286+  16E1             get_tok_comment:
0287+  16E1 F6            lodsb
0288+  16E2 B9 0A         cmp al, $0a      ; new line
0289+  16E4 C7 E1 16      jne get_tok_comment
0290+  16E7 0A C5 15      jmp get_tok_skip_spaces
0291+  16EA             
0292+  16EA             
0293+  16EA             get_number:
0294+  16EA D7            push a
0295+  16EB DA            push d
0296+  16EC E2            push si
0297+  16ED E3            push di
0298+  16EE 19 00         mov al, 0
0299+  16F0 3D 52 17      mov [tokstr], al      ; nullify tokstr string
0300+  16F3 19 00         mov al, tok_null
0301+  16F5 3D 51 17      mov [tok], al        ; nullify token
0302+  16F8 14 4E 17      mov a, [prog]
0303+  16FB 4D            mov si, a
0304+  16FC FD 4F 52 17   mov di, tokstr
0305+  1700             get_number_skip_spaces:
0306+  1700 F6            lodsb
0307+  1701 07 FD 14      call _isspace
0308+  1704 C6 00 17      je get_number_skip_spaces
0309+  1707 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1709 C7 19 17      jne get_number_l0
0311+  170C 19 14         mov al, tok_end
0312+  170E 3D 51 17      mov [tok], al
0313+  1711 19 06         mov al, toktyp_end
0314+  1713 3D 50 17      mov [toktyp], al
0315+  1716 0A 30 17      jmp get_number_return
0316+  1719             get_number_l0:
0317+  1719 F7            stosb
0318+  171A F6            lodsb
0319+  171B 07 91 14      call _isdigit      ;check if is numeric
0320+  171E C6 19 17      jz get_number_l0
0321+  1721 19 00         mov al, 0
0322+  1723 F7            stosb
0323+  1724 19 05         mov al, toktyp_numeric
0324+  1726 3D 50 17      mov [toktyp], al
0325+  1729 D5 01 00      sub si, 1
0326+  172C 4E            mov a, si
0327+  172D 42 4E 17      mov [prog], a    ; update pointer
0328+  1730             get_number_return:
0329+  1730 F0            pop di
0330+  1731 EF            pop si
0331+  1732 E7            pop d
0332+  1733 E4            pop a
0333+  1734 09            ret
0334+  1735             
0335+  1735             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1735             ;; put back token
0337+  1735             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1735             _putback:
0339+  1735 D7            push a
0340+  1736 E2            push si
0341+  1737 FD 4D 52 17   mov si, tokstr  
0342+  173B             _putback_loop:
0343+  173B F6            lodsb
0344+  173C B9 00         cmp al, 0
0345+  173E C6 4B 17      je _putback_end
0346+  1741 14 4E 17      mov a, [prog]
0347+  1744 7D            dec a
0348+  1745 42 4E 17      mov [prog], a      ; update pointer
0349+  1748 0A 3B 17      jmp _putback_loop
0350+  174B             _putback_end:
0351+  174B EF            pop si
0352+  174C E4            pop a
0353+  174D 09            ret
0354+  174E             
0355+  174E             
0356+  174E             
0357+  174E             
0358+  174E 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1750             
0360+  1750 00          toktyp:    .db 0          ; token type symbol
0361+  1751 00          tok:       .db 0          ; current token symbol
0362+  1752 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
0362+  176E 00 00 00 00 
0362+  1772 00 00 00 00 
0362+  1776 00 00 00 00 
0362+  177A 00 00 00 00 
0362+  177E 00 00 00 00 
0362+  1782 00 00 00 00 
0362+  1786 00 00 00 00 
0362+  178A 00 00 00 00 
0362+  178E 00 00 00 00 
0362+  1792 00 00 00 00 
0362+  1796 00 00 00 00 
0362+  179A 00 00 00 00 
0362+  179E 00 00 00 00 
0362+  17A2 00 00 00 00 
0362+  17A6 00 00 00 00 
0362+  17AA 00 00 00 00 
0362+  17AE 00 00 00 00 
0362+  17B2 00 00 00 00 
0362+  17B6 00 00 00 00 
0362+  17BA 00 00 00 00 
0362+  17BE 00 00 00 00 
0362+  17C2 00 00 00 00 
0362+  17C6 00 00 00 00 
0362+  17CA 00 00 00 00 
0362+  17CE 00 00 00 00 
0362+  17D2 00 00 00 00 
0362+  17D6 00 00 00 00 
0362+  17DA 00 00 00 00 
0362+  17DE 00 00 00 00 
0362+  17E2 00 00 00 00 
0362+  17E6 00 00 00 00 
0362+  17EA 00 00 00 00 
0362+  17EE 00 00 00 00 
0362+  17F2 00 00 00 00 
0362+  17F6 00 00 00 00 
0362+  17FA 00 00 00 00 
0362+  17FE 00 00 00 00 
0362+  1802 00 00 00 00 
0362+  1806 00 00 00 00 
0362+  180A 00 00 00 00 
0362+  180E 00 00 00 00 
0362+  1812 00 00 00 00 
0362+  1816 00 00 00 00 
0362+  181A 00 00 00 00 
0362+  181E 00 00 00 00 
0362+  1822 00 00 00 00 
0362+  1826 00 00 00 00 
0362+  182A 00 00 00 00 
0362+  182E 00 00 00 00 
0362+  1832 00 00 00 00 
0362+  1836 00 00 00 00 
0362+  183A 00 00 00 00 
0362+  183E 00 00 00 00 
0362+  1842 00 00 00 00 
0362+  1846 00 00 00 00 
0362+  184A 00 00 00 00 
0362+  184E 00 00 00 00 
2837   1852             
2838   1852             ; kernel parameters
2839   1852             sys_debug_mode:
2840   1852 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2841   1853             sys_echo_on:
2842   1853 01            .db 1
2843   1854             sys_uart0_lcr:
2844   1854 07            .db $07 ; 8 data bits, 2 stop bit, no parity
2845   1855             sys_uart0_inten:
2846   1855 01            .db 1
2847   1856             sys_uart0_fifoen:
2848   1856 00            .db 0
2849   1857             sys_uart0_div0:
2850   1857 0C            .db 12  ;
2851   1858             sys_uart0_div1:
2852   1858 00            .db 0   ; default baud = 9600
2853   1859             ; baud  divisor
2854   1859             ; 50    2304
2855   1859             ; 110   1047
2856   1859             ; 300    384
2857   1859             ; 600    192
2858   1859             ; 1200    96
2859   1859             ; 9600    12
2860   1859             ; 19200    6
2861   1859             ; 38400    3
2862   1859             
2863   1859             nbr_active_procs:
2864   1859 00            .db 0
2865   185A             active_proc_index:
2866   185A 01            .db 1
2867   185B             
2868   185B             index:
2869   185B 00 00         .dw 0
2870   185D             buffer_addr:
2871   185D 00 00         .dw 0
2872   185F             
2873   185F             fifo_in:
2874   185F B1 1F         .dw fifo
2875   1861             fifo_out:
2876   1861 B1 1F         .dw fifo
2877   1863             
2878   1863             ; file system variables
2879   1863             current_dir_id:
2880   1863 00 00         .dw 0     ; keep dirid of current directory
2881   1865             s_init_path:
2882   1865 2F 73 62 69   .db "/sbin/init", 0
2882   1869 6E 2F 69 6E 
2882   186D 69 74 00 
2883   1870             
2884   1870             s_uname:
2885   1870 73 6F 6C 61   .db "solarium v.1.0", 0
2885   1874 72 69 75 6D 
2885   1878 20 76 2E 31 
2885   187C 2E 30 00 
2886   187F             s_dataentry:
2887   187F 3E 20 00      .db "> ", 0
2888   1882             s_parent_dir:
2889   1882 2E 2E 00      .db "..", 0
2890   1885             s_current_dir:
2891   1885 2E 00         .db ".", 0
2892   1887             s_fslash:
2893   1887 2F 00         .db "/", 0
2894   1889             file_attrib:
2895   1889 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2895   188D 78 
2896   188E             file_type:
2897   188E 2D 64 63      .db "-dc"
2898   1891             s_ps_header:
2899   1891 70 69 64 20   .db "pid command\n", 0
2899   1895 63 6F 6D 6D 
2899   1899 61 6E 64 0A 
2899   189D 00 
2900   189E             s_ls_total:
2901   189E 74 6F 74 61   .db "total: ", 0
2901   18A2 6C 3A 20 00 
2902   18A6             
2903   18A6             s_int_en:
2904   18A6 69 72 71 73   .db "irqs enabled\n", 0
2904   18AA 20 65 6E 61 
2904   18AE 62 6C 65 64 
2904   18B2 0A 00 
2905   18B4             s_kernel_started:
2906   18B4 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2906   18B8 65 6C 20 73 
2906   18BC 74 61 72 74 
2906   18C0 65 64 28 76 
2906   18C4 65 72 73 69 
2906   18C8 6F 6E 20 31 
2906   18CC 2E 30 29 0A 
2906   18D0 00 
2907   18D1             s_prompt_init:
2908   18D1 73 74 61 72   .db "starting init\n", 0
2908   18D5 74 69 6E 67 
2908   18D9 20 69 6E 69 
2908   18DD 74 0A 00 
2909   18E0             s_priviledge:
2910   18E0 0A 65 78 63   .db "\nexception: privilege\n", 0
2910   18E4 65 70 74 69 
2910   18E8 6F 6E 3A 20 
2910   18EC 70 72 69 76 
2910   18F0 69 6C 65 67 
2910   18F4 65 0A 00 
2911   18F7             s_divzero:
2912   18F7 0A 65 78 63   .db "\nexception: zero division\n", 0
2912   18FB 65 70 74 69 
2912   18FF 6F 6E 3A 20 
2912   1903 7A 65 72 6F 
2912   1907 20 64 69 76 
2912   190B 69 73 69 6F 
2912   190F 6E 0A 00 
2913   1912             
2914   1912             s_set_year:
2915   1912 79 65 61 72   .db "year: ", 0
2915   1916 3A 20 00 
2916   1919             s_set_month:
2917   1919 6D 6F 6E 74   .db "month: ", 0
2917   191D 68 3A 20 00 
2918   1921             s_set_day:
2919   1921 64 61 79 3A   .db "day: ", 0
2919   1925 20 00 
2920   1927             s_set_week:
2921   1927 77 65 65 6B   .db "weekday: ", 0
2921   192B 64 61 79 3A 
2921   192F 20 00 
2922   1931             s_set_hours:
2923   1931 68 6F 75 72   .db "hours: ", 0
2923   1935 73 3A 20 00 
2924   1939             s_set_minutes:
2925   1939 6D 69 6E 75   .db "minutes: ", 0
2925   193D 74 65 73 3A 
2925   1941 20 00 
2926   1943             s_set_seconds:
2927   1943 73 65 63 6F   .db "seconds: ", 0
2927   1947 6E 64 73 3A 
2927   194B 20 00 
2928   194D             s_months:      
2929   194D 20 20 20 00   .db "   ", 0
2930   1951 6A 61 6E 00   .db "jan", 0
2931   1955 66 65 62 00   .db "feb", 0
2932   1959 6D 61 72 00   .db "mar", 0
2933   195D 61 70 72 00   .db "apr", 0
2934   1961 6D 61 79 00   .db "may", 0
2935   1965 6A 75 6E 00   .db "jun", 0
2936   1969 6A 75 6C 00   .db "jul", 0
2937   196D 61 75 67 00   .db "aug", 0
2938   1971 73 65 70 00   .db "sep", 0
2939   1975 6F 63 74 00   .db "oct", 0
2940   1979 6E 6F 76 00   .db "nov", 0
2941   197D 64 65 63 00   .db "dec", 0
2942   1981             
2943   1981             s_week:        
2944   1981 73 75 6E 00   .db "sun", 0 
2945   1985 6D 6F 6E 00   .db "mon", 0 
2946   1989 74 75 65 00   .db "tue", 0 
2947   198D 77 65 64 00   .db "wed", 0 
2948   1991 74 68 75 00   .db "thu", 0 
2949   1995 66 72 69 00   .db "fri", 0 
2950   1999 73 61 74 00   .db "sat", 0
2951   199D             
2952   199D             s_fdc_config:
2953   199D 0A 0D 73 65   .db "\n\rselecting diskette drive 0, side 0, single density, head loaded\n\r", 0
2953   19A1 6C 65 63 74 
2953   19A5 69 6E 67 20 
2953   19A9 64 69 73 6B 
2953   19AD 65 74 74 65 
2953   19B1 20 64 72 69 
2953   19B5 76 65 20 30 
2953   19B9 2C 20 73 69 
2953   19BD 64 65 20 30 
2953   19C1 2C 20 73 69 
2953   19C5 6E 67 6C 65 
2953   19C9 20 64 65 6E 
2953   19CD 73 69 74 79 
2953   19D1 2C 20 68 65 
2953   19D5 61 64 20 6C 
2953   19D9 6F 61 64 65 
2953   19DD 64 0A 0D 00 
2954   19E1             
2955   19E1             proc_state_table:   
2956   19E1 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2956   19E5 00 00 00 00 
2956   19E9 00 00 00 00 
2956   19ED 00 00 00 00 
2956   19F1 00 00 00 00 
2956   19F5 00 00 00 00 
2956   19F9 00 00 00 00 
2956   19FD 00 00 00 00 
2956   1A01 00 00 00 00 
2956   1A05 00 00 00 00 
2956   1A09 00 00 00 00 
2956   1A0D 00 00 00 00 
2956   1A11 00 00 00 00 
2956   1A15 00 00 00 00 
2956   1A19 00 00 00 00 
2956   1A1D 00 00 00 00 
2956   1A21 00 00 00 00 
2956   1A25 00 00 00 00 
2956   1A29 00 00 00 00 
2956   1A2D 00 00 00 00 
2956   1A31 00 00 00 00 
2956   1A35 00 00 00 00 
2956   1A39 00 00 00 00 
2956   1A3D 00 00 00 00 
2956   1A41 00 00 00 00 
2956   1A45 00 00 00 00 
2956   1A49 00 00 00 00 
2956   1A4D 00 00 00 00 
2956   1A51 00 00 00 00 
2956   1A55 00 00 00 00 
2956   1A59 00 00 00 00 
2956   1A5D 00 00 00 00 
2956   1A61 00 00 00 00 
2956   1A65 00 00 00 00 
2956   1A69 00 00 00 00 
2956   1A6D 00 00 00 00 
2956   1A71 00 00 00 00 
2956   1A75 00 00 00 00 
2956   1A79 00 00 00 00 
2956   1A7D 00 00 00 00 
2956   1A81 00 00 00 00 
2956   1A85 00 00 00 00 
2956   1A89 00 00 00 00 
2956   1A8D 00 00 00 00 
2956   1A91 00 00 00 00 
2956   1A95 00 00 00 00 
2956   1A99 00 00 00 00 
2956   1A9D 00 00 00 00 
2956   1AA1 00 00 00 00 
2956   1AA5 00 00 00 00 
2956   1AA9 00 00 00 00 
2956   1AAD 00 00 00 00 
2956   1AB1 00 00 00 00 
2956   1AB5 00 00 00 00 
2956   1AB9 00 00 00 00 
2956   1ABD 00 00 00 00 
2956   1AC1 00 00 00 00 
2956   1AC5 00 00 00 00 
2956   1AC9 00 00 00 00 
2956   1ACD 00 00 00 00 
2956   1AD1 00 00 00 00 
2956   1AD5 00 00 00 00 
2956   1AD9 00 00 00 00 
2956   1ADD 00 00 00 00 
2956   1AE1 00 00 00 00 
2956   1AE5 00 00 00 00 
2956   1AE9 00 00 00 00 
2956   1AED 00 00 00 00 
2956   1AF1 00 00 00 00 
2956   1AF5 00 00 00 00 
2956   1AF9 00 00 00 00 
2956   1AFD 00 00 00 00 
2956   1B01 00 00 00 00 
2956   1B05 00 00 00 00 
2956   1B09 00 00 00 00 
2956   1B0D 00 00 00 00 
2956   1B11 00 00 00 00 
2956   1B15 00 00 00 00 
2956   1B19 00 00 00 00 
2956   1B1D 00 00 00 00 
2957   1B21             proc_availab_table: 
2958   1B21 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2958   1B25 00 00 00 00 
2958   1B29 00 00 00 00 
2958   1B2D 00 00 00 00 
2959   1B31             proc_names:
2960   1B31 00 00 00 00   .fill 16 * 32, 0  ; process names
2960   1B35 00 00 00 00 
2960   1B39 00 00 00 00 
2960   1B3D 00 00 00 00 
2960   1B41 00 00 00 00 
2960   1B45 00 00 00 00 
2960   1B49 00 00 00 00 
2960   1B4D 00 00 00 00 
2960   1B51 00 00 00 00 
2960   1B55 00 00 00 00 
2960   1B59 00 00 00 00 
2960   1B5D 00 00 00 00 
2960   1B61 00 00 00 00 
2960   1B65 00 00 00 00 
2960   1B69 00 00 00 00 
2960   1B6D 00 00 00 00 
2960   1B71 00 00 00 00 
2960   1B75 00 00 00 00 
2960   1B79 00 00 00 00 
2960   1B7D 00 00 00 00 
2960   1B81 00 00 00 00 
2960   1B85 00 00 00 00 
2960   1B89 00 00 00 00 
2960   1B8D 00 00 00 00 
2960   1B91 00 00 00 00 
2960   1B95 00 00 00 00 
2960   1B99 00 00 00 00 
2960   1B9D 00 00 00 00 
2960   1BA1 00 00 00 00 
2960   1BA5 00 00 00 00 
2960   1BA9 00 00 00 00 
2960   1BAD 00 00 00 00 
2960   1BB1 00 00 00 00 
2960   1BB5 00 00 00 00 
2960   1BB9 00 00 00 00 
2960   1BBD 00 00 00 00 
2960   1BC1 00 00 00 00 
2960   1BC5 00 00 00 00 
2960   1BC9 00 00 00 00 
2960   1BCD 00 00 00 00 
2960   1BD1 00 00 00 00 
2960   1BD5 00 00 00 00 
2960   1BD9 00 00 00 00 
2960   1BDD 00 00 00 00 
2960   1BE1 00 00 00 00 
2960   1BE5 00 00 00 00 
2960   1BE9 00 00 00 00 
2960   1BED 00 00 00 00 
2960   1BF1 00 00 00 00 
2960   1BF5 00 00 00 00 
2960   1BF9 00 00 00 00 
2960   1BFD 00 00 00 00 
2960   1C01 00 00 00 00 
2960   1C05 00 00 00 00 
2960   1C09 00 00 00 00 
2960   1C0D 00 00 00 00 
2960   1C11 00 00 00 00 
2960   1C15 00 00 00 00 
2960   1C19 00 00 00 00 
2960   1C1D 00 00 00 00 
2960   1C21 00 00 00 00 
2960   1C25 00 00 00 00 
2960   1C29 00 00 00 00 
2960   1C2D 00 00 00 00 
2960   1C31 00 00 00 00 
2960   1C35 00 00 00 00 
2960   1C39 00 00 00 00 
2960   1C3D 00 00 00 00 
2960   1C41 00 00 00 00 
2960   1C45 00 00 00 00 
2960   1C49 00 00 00 00 
2960   1C4D 00 00 00 00 
2960   1C51 00 00 00 00 
2960   1C55 00 00 00 00 
2960   1C59 00 00 00 00 
2960   1C5D 00 00 00 00 
2960   1C61 00 00 00 00 
2960   1C65 00 00 00 00 
2960   1C69 00 00 00 00 
2960   1C6D 00 00 00 00 
2960   1C71 00 00 00 00 
2960   1C75 00 00 00 00 
2960   1C79 00 00 00 00 
2960   1C7D 00 00 00 00 
2960   1C81 00 00 00 00 
2960   1C85 00 00 00 00 
2960   1C89 00 00 00 00 
2960   1C8D 00 00 00 00 
2960   1C91 00 00 00 00 
2960   1C95 00 00 00 00 
2960   1C99 00 00 00 00 
2960   1C9D 00 00 00 00 
2960   1CA1 00 00 00 00 
2960   1CA5 00 00 00 00 
2960   1CA9 00 00 00 00 
2960   1CAD 00 00 00 00 
2960   1CB1 00 00 00 00 
2960   1CB5 00 00 00 00 
2960   1CB9 00 00 00 00 
2960   1CBD 00 00 00 00 
2960   1CC1 00 00 00 00 
2960   1CC5 00 00 00 00 
2960   1CC9 00 00 00 00 
2960   1CCD 00 00 00 00 
2960   1CD1 00 00 00 00 
2960   1CD5 00 00 00 00 
2960   1CD9 00 00 00 00 
2960   1CDD 00 00 00 00 
2960   1CE1 00 00 00 00 
2960   1CE5 00 00 00 00 
2960   1CE9 00 00 00 00 
2960   1CED 00 00 00 00 
2960   1CF1 00 00 00 00 
2960   1CF5 00 00 00 00 
2960   1CF9 00 00 00 00 
2960   1CFD 00 00 00 00 
2960   1D01 00 00 00 00 
2960   1D05 00 00 00 00 
2960   1D09 00 00 00 00 
2960   1D0D 00 00 00 00 
2960   1D11 00 00 00 00 
2960   1D15 00 00 00 00 
2960   1D19 00 00 00 00 
2960   1D1D 00 00 00 00 
2960   1D21 00 00 00 00 
2960   1D25 00 00 00 00 
2960   1D29 00 00 00 00 
2960   1D2D 00 00 00 00 
2961   1D31             filename:
2962   1D31 00 00 00 00   .fill 128, 0      ; holds a path for file search
2962   1D35 00 00 00 00 
2962   1D39 00 00 00 00 
2962   1D3D 00 00 00 00 
2962   1D41 00 00 00 00 
2962   1D45 00 00 00 00 
2962   1D49 00 00 00 00 
2962   1D4D 00 00 00 00 
2962   1D51 00 00 00 00 
2962   1D55 00 00 00 00 
2962   1D59 00 00 00 00 
2962   1D5D 00 00 00 00 
2962   1D61 00 00 00 00 
2962   1D65 00 00 00 00 
2962   1D69 00 00 00 00 
2962   1D6D 00 00 00 00 
2962   1D71 00 00 00 00 
2962   1D75 00 00 00 00 
2962   1D79 00 00 00 00 
2962   1D7D 00 00 00 00 
2962   1D81 00 00 00 00 
2962   1D85 00 00 00 00 
2962   1D89 00 00 00 00 
2962   1D8D 00 00 00 00 
2962   1D91 00 00 00 00 
2962   1D95 00 00 00 00 
2962   1D99 00 00 00 00 
2962   1D9D 00 00 00 00 
2962   1DA1 00 00 00 00 
2962   1DA5 00 00 00 00 
2962   1DA9 00 00 00 00 
2962   1DAD 00 00 00 00 
2963   1DB1             user_data:
2964   1DB1 00 00 00 00   .fill 512, 0      ;  user space data
2964   1DB5 00 00 00 00 
2964   1DB9 00 00 00 00 
2964   1DBD 00 00 00 00 
2964   1DC1 00 00 00 00 
2964   1DC5 00 00 00 00 
2964   1DC9 00 00 00 00 
2964   1DCD 00 00 00 00 
2964   1DD1 00 00 00 00 
2964   1DD5 00 00 00 00 
2964   1DD9 00 00 00 00 
2964   1DDD 00 00 00 00 
2964   1DE1 00 00 00 00 
2964   1DE5 00 00 00 00 
2964   1DE9 00 00 00 00 
2964   1DED 00 00 00 00 
2964   1DF1 00 00 00 00 
2964   1DF5 00 00 00 00 
2964   1DF9 00 00 00 00 
2964   1DFD 00 00 00 00 
2964   1E01 00 00 00 00 
2964   1E05 00 00 00 00 
2964   1E09 00 00 00 00 
2964   1E0D 00 00 00 00 
2964   1E11 00 00 00 00 
2964   1E15 00 00 00 00 
2964   1E19 00 00 00 00 
2964   1E1D 00 00 00 00 
2964   1E21 00 00 00 00 
2964   1E25 00 00 00 00 
2964   1E29 00 00 00 00 
2964   1E2D 00 00 00 00 
2964   1E31 00 00 00 00 
2964   1E35 00 00 00 00 
2964   1E39 00 00 00 00 
2964   1E3D 00 00 00 00 
2964   1E41 00 00 00 00 
2964   1E45 00 00 00 00 
2964   1E49 00 00 00 00 
2964   1E4D 00 00 00 00 
2964   1E51 00 00 00 00 
2964   1E55 00 00 00 00 
2964   1E59 00 00 00 00 
2964   1E5D 00 00 00 00 
2964   1E61 00 00 00 00 
2964   1E65 00 00 00 00 
2964   1E69 00 00 00 00 
2964   1E6D 00 00 00 00 
2964   1E71 00 00 00 00 
2964   1E75 00 00 00 00 
2964   1E79 00 00 00 00 
2964   1E7D 00 00 00 00 
2964   1E81 00 00 00 00 
2964   1E85 00 00 00 00 
2964   1E89 00 00 00 00 
2964   1E8D 00 00 00 00 
2964   1E91 00 00 00 00 
2964   1E95 00 00 00 00 
2964   1E99 00 00 00 00 
2964   1E9D 00 00 00 00 
2964   1EA1 00 00 00 00 
2964   1EA5 00 00 00 00 
2964   1EA9 00 00 00 00 
2964   1EAD 00 00 00 00 
2964   1EB1 00 00 00 00 
2964   1EB5 00 00 00 00 
2964   1EB9 00 00 00 00 
2964   1EBD 00 00 00 00 
2964   1EC1 00 00 00 00 
2964   1EC5 00 00 00 00 
2964   1EC9 00 00 00 00 
2964   1ECD 00 00 00 00 
2964   1ED1 00 00 00 00 
2964   1ED5 00 00 00 00 
2964   1ED9 00 00 00 00 
2964   1EDD 00 00 00 00 
2964   1EE1 00 00 00 00 
2964   1EE5 00 00 00 00 
2964   1EE9 00 00 00 00 
2964   1EED 00 00 00 00 
2964   1EF1 00 00 00 00 
2964   1EF5 00 00 00 00 
2964   1EF9 00 00 00 00 
2964   1EFD 00 00 00 00 
2964   1F01 00 00 00 00 
2964   1F05 00 00 00 00 
2964   1F09 00 00 00 00 
2964   1F0D 00 00 00 00 
2964   1F11 00 00 00 00 
2964   1F15 00 00 00 00 
2964   1F19 00 00 00 00 
2964   1F1D 00 00 00 00 
2964   1F21 00 00 00 00 
2964   1F25 00 00 00 00 
2964   1F29 00 00 00 00 
2964   1F2D 00 00 00 00 
2964   1F31 00 00 00 00 
2964   1F35 00 00 00 00 
2964   1F39 00 00 00 00 
2964   1F3D 00 00 00 00 
2964   1F41 00 00 00 00 
2964   1F45 00 00 00 00 
2964   1F49 00 00 00 00 
2964   1F4D 00 00 00 00 
2964   1F51 00 00 00 00 
2964   1F55 00 00 00 00 
2964   1F59 00 00 00 00 
2964   1F5D 00 00 00 00 
2964   1F61 00 00 00 00 
2964   1F65 00 00 00 00 
2964   1F69 00 00 00 00 
2964   1F6D 00 00 00 00 
2964   1F71 00 00 00 00 
2964   1F75 00 00 00 00 
2964   1F79 00 00 00 00 
2964   1F7D 00 00 00 00 
2964   1F81 00 00 00 00 
2964   1F85 00 00 00 00 
2964   1F89 00 00 00 00 
2964   1F8D 00 00 00 00 
2964   1F91 00 00 00 00 
2964   1F95 00 00 00 00 
2964   1F99 00 00 00 00 
2964   1F9D 00 00 00 00 
2964   1FA1 00 00 00 00 
2964   1FA5 00 00 00 00 
2964   1FA9 00 00 00 00 
2964   1FAD 00 00 00 00 
2965   1FB1             fifo:
2966   1FB1 FF FF FF FF   .fill fifo_size
2966   1FB5 FF FF FF FF 
2966   1FB9 FF FF FF FF 
2966   1FBD FF FF FF FF 
2966   1FC1 FF FF FF FF 
2966   1FC5 FF FF FF FF 
2966   1FC9 FF FF FF FF 
2966   1FCD FF FF FF FF 
2966   1FD1 FF FF FF FF 
2966   1FD5 FF FF FF FF 
2966   1FD9 FF FF FF FF 
2966   1FDD FF FF FF FF 
2966   1FE1 FF FF FF FF 
2966   1FE5 FF FF FF FF 
2966   1FE9 FF FF FF FF 
2966   1FED FF FF FF FF 
2966   1FF1 FF FF FF FF 
2966   1FF5 FF FF FF FF 
2966   1FF9 FF FF FF FF 
2966   1FFD FF FF FF FF 
2966   2001 FF FF FF FF 
2966   2005 FF FF FF FF 
2966   2009 FF FF FF FF 
2966   200D FF FF FF FF 
2966   2011 FF FF FF FF 
2966   2015 FF FF FF FF 
2966   2019 FF FF FF FF 
2966   201D FF FF FF FF 
2966   2021 FF FF FF FF 
2966   2025 FF FF FF FF 
2966   2029 FF FF FF FF 
2966   202D FF FF FF FF 
2966   2031 FF FF FF FF 
2966   2035 FF FF FF FF 
2966   2039 FF FF FF FF 
2966   203D FF FF FF FF 
2966   2041 FF FF FF FF 
2966   2045 FF FF FF FF 
2966   2049 FF FF FF FF 
2966   204D FF FF FF FF 
2966   2051 FF FF FF FF 
2966   2055 FF FF FF FF 
2966   2059 FF FF FF FF 
2966   205D FF FF FF FF 
2966   2061 FF FF FF FF 
2966   2065 FF FF FF FF 
2966   2069 FF FF FF FF 
2966   206D FF FF FF FF 
2966   2071 FF FF FF FF 
2966   2075 FF FF FF FF 
2966   2079 FF FF FF FF 
2966   207D FF FF FF FF 
2966   2081 FF FF FF FF 
2966   2085 FF FF FF FF 
2966   2089 FF FF FF FF 
2966   208D FF FF FF FF 
2966   2091 FF FF FF FF 
2966   2095 FF FF FF FF 
2966   2099 FF FF FF FF 
2966   209D FF FF FF FF 
2966   20A1 FF FF FF FF 
2966   20A5 FF FF FF FF 
2966   20A9 FF FF FF FF 
2966   20AD FF FF FF FF 
2966   20B1 FF FF FF FF 
2966   20B5 FF FF FF FF 
2966   20B9 FF FF FF FF 
2966   20BD FF FF FF FF 
2966   20C1 FF FF FF FF 
2966   20C5 FF FF FF FF 
2966   20C9 FF FF FF FF 
2966   20CD FF FF FF FF 
2966   20D1 FF FF FF FF 
2966   20D5 FF FF FF FF 
2966   20D9 FF FF FF FF 
2966   20DD FF FF FF FF 
2966   20E1 FF FF FF FF 
2966   20E5 FF FF FF FF 
2966   20E9 FF FF FF FF 
2966   20ED FF FF FF FF 
2966   20F1 FF FF FF FF 
2966   20F5 FF FF FF FF 
2966   20F9 FF FF FF FF 
2966   20FD FF FF FF FF 
2966   2101 FF FF FF FF 
2966   2105 FF FF FF FF 
2966   2109 FF FF FF FF 
2966   210D FF FF FF FF 
2966   2111 FF FF FF FF 
2966   2115 FF FF FF FF 
2966   2119 FF FF FF FF 
2966   211D FF FF FF FF 
2966   2121 FF FF FF FF 
2966   2125 FF FF FF FF 
2966   2129 FF FF FF FF 
2966   212D FF FF FF FF 
2966   2131 FF FF FF FF 
2966   2135 FF FF FF FF 
2966   2139 FF FF FF FF 
2966   213D FF FF FF FF 
2966   2141 FF FF FF FF 
2966   2145 FF FF FF FF 
2966   2149 FF FF FF FF 
2966   214D FF FF FF FF 
2966   2151 FF FF FF FF 
2966   2155 FF FF FF FF 
2966   2159 FF FF FF FF 
2966   215D FF FF FF FF 
2966   2161 FF FF FF FF 
2966   2165 FF FF FF FF 
2966   2169 FF FF FF FF 
2966   216D FF FF FF FF 
2966   2171 FF FF FF FF 
2966   2175 FF FF FF FF 
2966   2179 FF FF FF FF 
2966   217D FF FF FF FF 
2966   2181 FF FF FF FF 
2966   2185 FF FF FF FF 
2966   2189 FF FF FF FF 
2966   218D FF FF FF FF 
2966   2191 FF FF FF FF 
2966   2195 FF FF FF FF 
2966   2199 FF FF FF FF 
2966   219D FF FF FF FF 
2966   21A1 FF FF FF FF 
2966   21A5 FF FF FF FF 
2966   21A9 FF FF FF FF 
2966   21AD FF FF FF FF 
2966   21B1 FF FF FF FF 
2966   21B5 FF FF FF FF 
2966   21B9 FF FF FF FF 
2966   21BD FF FF FF FF 
2966   21C1 FF FF FF FF 
2966   21C5 FF FF FF FF 
2966   21C9 FF FF FF FF 
2966   21CD FF FF FF FF 
2966   21D1 FF FF FF FF 
2966   21D5 FF FF FF FF 
2966   21D9 FF FF FF FF 
2966   21DD FF FF FF FF 
2966   21E1 FF FF FF FF 
2966   21E5 FF FF FF FF 
2966   21E9 FF FF FF FF 
2966   21ED FF FF FF FF 
2966   21F1 FF FF FF FF 
2966   21F5 FF FF FF FF 
2966   21F9 FF FF FF FF 
2966   21FD FF FF FF FF 
2966   2201 FF FF FF FF 
2966   2205 FF FF FF FF 
2966   2209 FF FF FF FF 
2966   220D FF FF FF FF 
2966   2211 FF FF FF FF 
2966   2215 FF FF FF FF 
2966   2219 FF FF FF FF 
2966   221D FF FF FF FF 
2966   2221 FF FF FF FF 
2966   2225 FF FF FF FF 
2966   2229 FF FF FF FF 
2966   222D FF FF FF FF 
2966   2231 FF FF FF FF 
2966   2235 FF FF FF FF 
2966   2239 FF FF FF FF 
2966   223D FF FF FF FF 
2966   2241 FF FF FF FF 
2966   2245 FF FF FF FF 
2966   2249 FF FF FF FF 
2966   224D FF FF FF FF 
2966   2251 FF FF FF FF 
2966   2255 FF FF FF FF 
2966   2259 FF FF FF FF 
2966   225D FF FF FF FF 
2966   2261 FF FF FF FF 
2966   2265 FF FF FF FF 
2966   2269 FF FF FF FF 
2966   226D FF FF FF FF 
2966   2271 FF FF FF FF 
2966   2275 FF FF FF FF 
2966   2279 FF FF FF FF 
2966   227D FF FF FF FF 
2966   2281 FF FF FF FF 
2966   2285 FF FF FF FF 
2966   2289 FF FF FF FF 
2966   228D FF FF FF FF 
2966   2291 FF FF FF FF 
2966   2295 FF FF FF FF 
2966   2299 FF FF FF FF 
2966   229D FF FF FF FF 
2966   22A1 FF FF FF FF 
2966   22A5 FF FF FF FF 
2966   22A9 FF FF FF FF 
2966   22AD FF FF FF FF 
2966   22B1 FF FF FF FF 
2966   22B5 FF FF FF FF 
2966   22B9 FF FF FF FF 
2966   22BD FF FF FF FF 
2966   22C1 FF FF FF FF 
2966   22C5 FF FF FF FF 
2966   22C9 FF FF FF FF 
2966   22CD FF FF FF FF 
2966   22D1 FF FF FF FF 
2966   22D5 FF FF FF FF 
2966   22D9 FF FF FF FF 
2966   22DD FF FF FF FF 
2966   22E1 FF FF FF FF 
2966   22E5 FF FF FF FF 
2966   22E9 FF FF FF FF 
2966   22ED FF FF FF FF 
2966   22F1 FF FF FF FF 
2966   22F5 FF FF FF FF 
2966   22F9 FF FF FF FF 
2966   22FD FF FF FF FF 
2966   2301 FF FF FF FF 
2966   2305 FF FF FF FF 
2966   2309 FF FF FF FF 
2966   230D FF FF FF FF 
2966   2311 FF FF FF FF 
2966   2315 FF FF FF FF 
2966   2319 FF FF FF FF 
2966   231D FF FF FF FF 
2966   2321 FF FF FF FF 
2966   2325 FF FF FF FF 
2966   2329 FF FF FF FF 
2966   232D FF FF FF FF 
2966   2331 FF FF FF FF 
2966   2335 FF FF FF FF 
2966   2339 FF FF FF FF 
2966   233D FF FF FF FF 
2966   2341 FF FF FF FF 
2966   2345 FF FF FF FF 
2966   2349 FF FF FF FF 
2966   234D FF FF FF FF 
2966   2351 FF FF FF FF 
2966   2355 FF FF FF FF 
2966   2359 FF FF FF FF 
2966   235D FF FF FF FF 
2966   2361 FF FF FF FF 
2966   2365 FF FF FF FF 
2966   2369 FF FF FF FF 
2966   236D FF FF FF FF 
2966   2371 FF FF FF FF 
2966   2375 FF FF FF FF 
2966   2379 FF FF FF FF 
2966   237D FF FF FF FF 
2966   2381 FF FF FF FF 
2966   2385 FF FF FF FF 
2966   2389 FF FF FF FF 
2966   238D FF FF FF FF 
2966   2391 FF FF FF FF 
2966   2395 FF FF FF FF 
2966   2399 FF FF FF FF 
2966   239D FF FF FF FF 
2966   23A1 FF FF FF FF 
2966   23A5 FF FF FF FF 
2966   23A9 FF FF FF FF 
2966   23AD FF FF FF FF 
2967   23B1             
2968   23B1             scrap_sector:
2969   23B1 FF FF FF FF   .fill 512         ; scrap sector
2969   23B5 FF FF FF FF 
2969   23B9 FF FF FF FF 
2969   23BD FF FF FF FF 
2969   23C1 FF FF FF FF 
2969   23C5 FF FF FF FF 
2969   23C9 FF FF FF FF 
2969   23CD FF FF FF FF 
2969   23D1 FF FF FF FF 
2969   23D5 FF FF FF FF 
2969   23D9 FF FF FF FF 
2969   23DD FF FF FF FF 
2969   23E1 FF FF FF FF 
2969   23E5 FF FF FF FF 
2969   23E9 FF FF FF FF 
2969   23ED FF FF FF FF 
2969   23F1 FF FF FF FF 
2969   23F5 FF FF FF FF 
2969   23F9 FF FF FF FF 
2969   23FD FF FF FF FF 
2969   2401 FF FF FF FF 
2969   2405 FF FF FF FF 
2969   2409 FF FF FF FF 
2969   240D FF FF FF FF 
2969   2411 FF FF FF FF 
2969   2415 FF FF FF FF 
2969   2419 FF FF FF FF 
2969   241D FF FF FF FF 
2969   2421 FF FF FF FF 
2969   2425 FF FF FF FF 
2969   2429 FF FF FF FF 
2969   242D FF FF FF FF 
2969   2431 FF FF FF FF 
2969   2435 FF FF FF FF 
2969   2439 FF FF FF FF 
2969   243D FF FF FF FF 
2969   2441 FF FF FF FF 
2969   2445 FF FF FF FF 
2969   2449 FF FF FF FF 
2969   244D FF FF FF FF 
2969   2451 FF FF FF FF 
2969   2455 FF FF FF FF 
2969   2459 FF FF FF FF 
2969   245D FF FF FF FF 
2969   2461 FF FF FF FF 
2969   2465 FF FF FF FF 
2969   2469 FF FF FF FF 
2969   246D FF FF FF FF 
2969   2471 FF FF FF FF 
2969   2475 FF FF FF FF 
2969   2479 FF FF FF FF 
2969   247D FF FF FF FF 
2969   2481 FF FF FF FF 
2969   2485 FF FF FF FF 
2969   2489 FF FF FF FF 
2969   248D FF FF FF FF 
2969   2491 FF FF FF FF 
2969   2495 FF FF FF FF 
2969   2499 FF FF FF FF 
2969   249D FF FF FF FF 
2969   24A1 FF FF FF FF 
2969   24A5 FF FF FF FF 
2969   24A9 FF FF FF FF 
2969   24AD FF FF FF FF 
2969   24B1 FF FF FF FF 
2969   24B5 FF FF FF FF 
2969   24B9 FF FF FF FF 
2969   24BD FF FF FF FF 
2969   24C1 FF FF FF FF 
2969   24C5 FF FF FF FF 
2969   24C9 FF FF FF FF 
2969   24CD FF FF FF FF 
2969   24D1 FF FF FF FF 
2969   24D5 FF FF FF FF 
2969   24D9 FF FF FF FF 
2969   24DD FF FF FF FF 
2969   24E1 FF FF FF FF 
2969   24E5 FF FF FF FF 
2969   24E9 FF FF FF FF 
2969   24ED FF FF FF FF 
2969   24F1 FF FF FF FF 
2969   24F5 FF FF FF FF 
2969   24F9 FF FF FF FF 
2969   24FD FF FF FF FF 
2969   2501 FF FF FF FF 
2969   2505 FF FF FF FF 
2969   2509 FF FF FF FF 
2969   250D FF FF FF FF 
2969   2511 FF FF FF FF 
2969   2515 FF FF FF FF 
2969   2519 FF FF FF FF 
2969   251D FF FF FF FF 
2969   2521 FF FF FF FF 
2969   2525 FF FF FF FF 
2969   2529 FF FF FF FF 
2969   252D FF FF FF FF 
2969   2531 FF FF FF FF 
2969   2535 FF FF FF FF 
2969   2539 FF FF FF FF 
2969   253D FF FF FF FF 
2969   2541 FF FF FF FF 
2969   2545 FF FF FF FF 
2969   2549 FF FF FF FF 
2969   254D FF FF FF FF 
2969   2551 FF FF FF FF 
2969   2555 FF FF FF FF 
2969   2559 FF FF FF FF 
2969   255D FF FF FF FF 
2969   2561 FF FF FF FF 
2969   2565 FF FF FF FF 
2969   2569 FF FF FF FF 
2969   256D FF FF FF FF 
2969   2571 FF FF FF FF 
2969   2575 FF FF FF FF 
2969   2579 FF FF FF FF 
2969   257D FF FF FF FF 
2969   2581 FF FF FF FF 
2969   2585 FF FF FF FF 
2969   2589 FF FF FF FF 
2969   258D FF FF FF FF 
2969   2591 FF FF FF FF 
2969   2595 FF FF FF FF 
2969   2599 FF FF FF FF 
2969   259D FF FF FF FF 
2969   25A1 FF FF FF FF 
2969   25A5 FF FF FF FF 
2969   25A9 FF FF FF FF 
2969   25AD FF FF FF FF 
2970   25B1             transient_area:
2971   25B1 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2972   25B2             
2973   25B2             .end
tasm: Number of errors = 0
