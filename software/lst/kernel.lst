0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data             .equ $ff80         ; data
0034   0000             _uart0_dlab_0           .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1           .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier              .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr              .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr              .equ $ff83         ; line control register
0039   0000             _uart0_lsr              .equ $ff85         ; line status register
0040   0000                                   
0041   0000             _uart1_data             .equ $ff88         ; data
0042   0000             _uart1_dlab_0           .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1           .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier              .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr              .equ $ff8A         ; fifo control register
0046   0000             _uart1_lcr              .equ $ff8B         ; line control register
0047   0000             _uart1_lsr              .equ $ff8D         ; line status register
0048   0000                                   
0049   0000             _ide_base               .equ $ffd0         ; ide base
0050   0000             _ide_r0                 .equ _ide_base + 0 ; data port
0051   0000             _ide_r1                 .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2                 .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3                 .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4                 .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5                 .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6                 .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7                 .equ _ide_base + 7 ; read: status, write: command       
0058   0000                                   
0059   0000             _til311_display         .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl         .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a                  .equ $ffb0    
0062   0000             _pio_b                  .equ $ffb1
0063   0000             _pio_c                  .equ $ffb2
0064   0000             _pio_control            .equ $ffb3         ; pio control port
0065   0000                                   
0066   0000             _fdc_config             .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0           .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd           .equ $ffc8         ; status / command register
0069   0000             _fdc_track              .equ $ffc9         ; track register
0070   0000             _fdc_sector             .equ $ffca         ; sector register
0071   0000             _fdc_data               .equ $ffcb         ; data register
0072   0000                                   
0073   0000             _timer_c_0              .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1              .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2              .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl             .equ $ffe3         ; timer control register
0077   0000                                   
0078   0000             _stack_top              .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size              .equ 4096
0080   0000             _scrap_size             .equ 512
0081   0000             
0082   0000             _file_type_null         .equ 0
0083   0000             _file_type_reg          .equ 1
0084   0000             _file_type_chardev      .equ 2
0085   0000             _file_type_blockdev     .equ 3
0086   0000             
0087   0000             _num_cpu_regs           .equ 10                                     ; A, B, C, D, G, PC, BP, SP, SI, DI
0088   0000             _num_user_proc          .equ 128                                    ; max number of concurrent user processes
0089   0000             _fd_per_proc            .equ 32                                     ; for kernel's file descriptor table per process
0090   0000             _num_file_objs          .equ 128                                    ; for the kernel's file object table
0091   0000             _size_file_obj_entry    .equ 1 + 2 + 1 + 2 + 2 + (4 * 2)            ; refcount, flags, type, target, offset, ops
0092   0000             _size_file_obj_table    .equ _num_file_objs * _size_file_obj_entry  ; kernel's file object table
0093   0000             
0094   0000             _size_proc_entry        .equ 1 + 1 + _fd_per_proc * 2 + 2 + _num_cpu_regs * 2 + 1 + 39 ; pid, state, fd_table, tty pointer, context (general regs + flags), 39 bytes padding to reach 128
0095   0000             _size_proc_table        .equ _size_proc_entry * _num_user_proc  ; 16k total
0096   0000             
0097   0000             
0098   0000             text_org                .equ $400          ; code origin address for all user processes
0099   0000             
0100   0000             block_bitmap_start      .equ 2048 * 2
0101   0000             block_bitmap_sec_start  .equ 8
0102   0000             inode_bitmap_start      .equ 2048 * 6
0103   0000             inode_bitmap_sect_start .equ 24
0104   0000             inode_table_start       .equ 2048 * 7
0105   0000             inode_table_sect_start  .equ 28 ; inode table starts at sector 28
0106   0000             data_blocks_start       .equ 2111488
0107   0000             data_blocks_sect_start  .equ 4124
0108   0000             
0109   0000             ;  ------------------------------------------------------------------------------------------------------------------;
0110   0000             ;  DISK LAYOUT:
0111   0000             ;  Metadata               | Size (bytes)      | Blocks (2048 bytes)              |Start Block |  Comment
0112   0000             ;  ---------------------- | ----------------- | -------------------------------- |------------|-----------------------------------
0113   0000             ;  Bootloader/MBR         | 1024 bytes        | 0.5 (1 sector)                   |  0         |
0114   0000             ;  Superblock             | 1024 bytes        | 1 block (2048 bytes, must align) |  0         |
0115   0000             ;                         |                   | 1 block (2048 bytes)             |  1         | reserved
0116   0000             ;  Block Bitmap           | 8,192 bytes       | 4 blocks                         |  2         | 4*2048*8 = 4*16384 = 65536 raw data blocks.  65536*2048 bytes = 134217728 bytes of disk space = 128MB
0117   0000             ;  Inode Bitmap           | 2,048 bytes       | 1 block                          |  6         | 2048*8=16384. total of 16384 bits, meaning 16384 inodes, which is 1 inode per 8KB of disk space
0118   0000             ;  Inode Table            | 2,097,152 bytes   | 1024 blocks                      |  7         | 128bytes per inode entry. 2097152 / 128 = 16384 inodes
0119   0000             ;  Data Blocks            | 134,217,728 bytes | 65528 blocks                     | 1031       | 65528 blocks = 134,201,344 bytes
0120   0000             ;  
0121   0000             ;  first 1024 bytes: bootloader from 0 to 959, MBR partition table from 960 (64 bytes)
0122   0000             ;  up to 4 partitions, each 16 bytes long
0123   0000             ;  MBR:
0124   0000             ;  Byte | Description
0125   0000             ;  -----|----------------------------
0126   0000             ;  0    | Boot flag (0x80 active, 0x00 inactive)
0127   0000             ;  1-3  | Start CHS (head, sector, cylinder)
0128   0000             ;  4    | Partition type (filesystem ID)
0129   0000             ;    0x83 = Linux native (ext2/3/4)
0130   0000             ;    0x07 = NTFS/exFAT
0131   0000             ;    0x0B = FAT32 CHS
0132   0000             ;    0x0C = FAT32 LBA
0133   0000             ;    0x05 = Extended partition
0134   0000             ;    0x86 = Sol-1 partition
0135   0000             ;  5-7  | End CHS
0136   0000             ;  8-11 | Start LBA (little endian)
0137   0000             ;  12-15| Size in sectors (little endian)
0138   0000             ;  
0139   0000             ;  
0140   0000             ;  the superblock describers the filesystem as a whole such as inode count, free inode count, location of the raw data bitmap, inode table, etc.  
0141   0000             ;  SUPERBLOCK:
0142   0000             ;  | Field               | Description                               | Typical Size (bytes) | Notes                           |
0143   0000             ;  | ------------------- | ----------------------------------------- | -------------------- | ------------------------------- |
0144   0000             ;  | inodes_count        | Total number of inodes in the filesystem  | 2                    | 16-bit unsigned int             |
0145   0000             ;  | blocks_count        | Total number of data blocks               | 2                    | 16-bit unsigned int             |
0146   0000             ;  | free_inodes_count   | Number of free inodes                     | 2                    | 16-bit unsigned int             |
0147   0000             ;  | free_blocks_count   | Number of free blocks                     | 2                    | 16-bit unsigned int             |
0148   0000             ;  | block_bitmap        | Block ID of the **block bitmap**          | 2                    | 16-bit unsigned int
0149   0000             ;  | inode_bitmap        | Block ID of the **inode bitmap**          | 2                    | 16-bit unsigned int
0150   0000             ;  | inode_table         | Starting block of **inode table**         | 2                    | 16-bit unsigned int
0151   0000             ;  | first_data_block    | Block number of the first data block      | 2                    | 16-bit unsigned int             |
0152   0000             ;  | used_dirs_count     | Number of inodes allocated to directories | 2
0153   0000             ;  | log_block_size      | Block size = 1024 << `s_log_block_size    | 2                    | 16-bit unsigned int             |
0154   0000             ;  | mtime               | Last mount time                           | 4                    | 32-bit unsigned int (Unix time) |
0155   0000             ;  | wtime               | Last write time                           | 4                    | 32-bit unsigned int (Unix time) |
0156   0000             ;  | uuid                | Unique ID of the filesystem               | 16                   | 128-bit UUID                    |
0157   0000             ;  | volume_name         | Label of the filesystem                   | 16                   | Usually ASCII, padded           |
0158   0000             ;  | feature_flags       | Compatibility flags                       | 4                    | 32-bit unsigned int             |
0159   0000             ;  
0160   0000             ;  inode for root dir is #2, #0 and #1 not used
0161   0000             ;  raw data block #0 is not used. because 0 as a block ID means not used
0162   0000             ;  block size: 2048
0163   0000             ;  inode-table format:
0164   0000             ;  | Field         | Size (bytes) | Description                                                                                  |
0165   0000             ;  | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0166   0000             ;  | `mode`        | 2            | File type and permissions                                                                    |
0167   0000             ;  | `uid`         | 2            | Owner user ID                                                                                |
0168   0000             ;  | `size`        | 4            | Size of the file in bytes                                                                    |
0169   0000             ;  | `atime`       | 4            | Last access time (timestamp)                                                                 |
0170   0000             ;  | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0171   0000             ;  | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0172   0000             ;  | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0173   0000             ;  | `gid`         | 2            | Group ID                                                                                     |
0174   0000             ;  | `links_count` | 2            | Number of hard links                                                                         |
0175   0000             ;  | `blocks`      | 2            | Number of 2048-byte blocks allocated                                                         |
0176   0000             ;  | `flags`       | 4            | File flags                                                                                   |
0177   0000             ;  | `block`       | 47 * 2 = 94  | Pointers to data blocks (47 direct only) 
0178   0000             ;
0179   0000             ;
0180   0000             ;  DIRECTORY ENTRY
0181   0000             ;  this is the structure for file entries inside a directory.
0182   0000             ;  2048 / 64 = 32 entries
0183   0000             ;
0184   0000             ;  each entry is 64 bytes wide
0185   0000             ;  uint16_t inode;      // Inode number (0 if entry is unused)
0186   0000             ;  char     name[62];   // File name (null terminated)
0187   0000             
0188   0000             ; ------------------------------------------------------------------------------------------------------------------;
0189   0000             ; global system variables
0190   0000             ; ------------------------------------------------------------------------------------------------------------------;
0191   0000             
0192   0000             ; ------------------------------------------------------------------------------------------------------------------;
0193   0000             ; irq table
0194   0000             ; highest priority at lowest address
0195   0000             ; ------------------------------------------------------------------------------------------------------------------;
0196   0000 32 00       .dw int_0_fdc
0197   0002 39 00       .dw int_1
0198   0004 3A 00       .dw int_2
0199   0006 3B 00       .dw int_3
0200   0008 3C 00       .dw int_4
0201   000A 3D 00       .dw int_5_uart1
0202   000C 5F 00       .dw int_6_timer
0203   000E 60 00       .dw int_7_uart0
0204   0010             
0205   0010             ; ------------------------------------------------------------------------------------------------------------------;
0206   0010             ; kernel reset vector
0207   0010             ; ------------------------------------------------------------------------------------------------------------------;
0208   0010 75 04       .dw kernel_reset_vector
0209   0012             
0210   0012             ; ------------------------------------------------------------------------------------------------------------------;
0211   0012             ; exception vector table
0212   0012             ; total of 7 entries, starting at address $0012
0213   0012             ; ------------------------------------------------------------------------------------------------------------------;
0214   0012 D4 00       .dw trap_privilege
0215   0014 9A 01       .dw trap_div_zero
0216   0016 A7 01       .dw trap_undef_opcode
0217   0018 00 00       .dw 0
0218   001A 00 00       .dw 0
0219   001C 00 00       .dw 0
0220   001E 00 00       .dw 0
0221   0020             
0222   0020             ; ------------------------------------------------------------------------------------------------------------------;
0223   0020             ; system call vector table
0224   0020             ; starts at address $0020
0225   0020             ; ------------------------------------------------------------------------------------------------------------------;
0226   0020 DF 00       .dw syscall_break
0227   0022 A8 01       .dw syscall_rtc
0228   0024 CB 02       .dw syscall_ide
0229   0026 8B 03       .dw syscall_io
0230   0028 42 04       .dw syscall_file
0231   002A DA 01       .dw syscall_datetime
0232   002C C8 00       .dw syscall_reboot
0233   002E 94 00       .dw syscall_system
0234   0030 85 00       .dw syscall_proc
0235   0032             
0236   0032             ; ------------------------------------------------------------------------------------------------------------------;
0237   0032             ; system call aliases
0238   0032             ; ------------------------------------------------------------------------------------------------------------------;
0239   0032             sys_break            .equ 0
0240   0032             sys_rtc              .equ 1
0241   0032             sys_ide              .equ 2
0242   0032             sys_io               .equ 3
0243   0032             sys_file             .equ 4
0244   0032             sys_datetime         .equ 5
0245   0032             sys_reboot           .equ 6
0246   0032             sys_system           .equ 7
0247   0032             sys_proc             .equ 8
0248   0032             
0249   0032             ; ------------------------------------------------------------------------------------------------------------------;
0250   0032             ; alias exports
0251   0032             ; ------------------------------------------------------------------------------------------------------------------;
0252   0032             .export text_org
0253   0032             .export sys_break
0254   0032             .export sys_rtc
0255   0032             .export sys_ide
0256   0032             .export sys_io
0257   0032             .export sys_file
0258   0032             .export sys_datetime
0259   0032             .export sys_reboot
0260   0032             .export sys_system
0261   0032             
0262   0032             .export _til311_display
0263   0032             
0264   0032             .export _fdc_config        
0265   0032             .export _fdc_status_0      
0266   0032             .export _fdc_stat_cmd     
0267   0032             
0268   0032             ; ------------------------------------------------------------------------------------------------------------------;
0269   0032             ; irqs' code block
0270   0032             ; ------------------------------------------------------------------------------------------------------------------;
0271   0032             ; 5.25" floppy drive controller irq
0272   0032             int_0_fdc:
0273   0032 3B 3B 0E      mov d, s_fdc_irq
0274   0035 07 CC 06      call _puts
0275   0038 06            sysret
0276   0039             int_1:
0277   0039 06            sysret
0278   003A             int_2:
0279   003A 06            sysret
0280   003B             int_3:
0281   003B 06            sysret
0282   003C             int_4:
0283   003C 06            sysret
0284   003D             
0285   003D             ; ------------------------------------------------------------------------------------------------------------------;
0286   003D             ; uart1 interrupt
0287   003D             ; ------------------------------------------------------------------------------------------------------------------;
0288   003D             int_5_uart1:
0289   003D D7            push a
0290   003E DA            push d
0291   003F E1            pushf
0292   0040 1D 88 FF      mov al, [_uart1_data]       ; get character
0293   0043               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0294   0043 3B FF 0B      mov d, fifo_in
0295   0046 FD 2A         mov d, [d]
0296   0048 3E            mov [d], al                 ; add to fifo
0297   0049 13            mov a, d
0298   004A 77            inc a
0299   004B AF 47 1F      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0300   004E C7 54 00      jne int_5_continue
0301   0051 10 47 0F      mov a, fifo  
0302   0054             int_5_continue:  
0303   0054 42 FF 0B      mov [fifo_in], a            ; update fifo pointer
0304   0057 1A            mov al, ah
0305   0058 3D B0 FF      mov [_til311_display], al
0306   005B EE            popf
0307   005C E7            pop d
0308   005D E4            pop a  
0309   005E 06            sysret
0310   005F             
0311   005F             ; ------------------------------------------------------------------------------------------------------------------;
0312   005F             ; timer irq
0313   005F             ; ------------------------------------------------------------------------------------------------------------------;
0314   005F             int_6_timer:  
0315   005F 06            sysret
0316   0060             
0317   0060             ; ------------------------------------------------------------------------------------------------------------------;
0318   0060             ; uart0 interrupt
0319   0060             ; ------------------------------------------------------------------------------------------------------------------;
0320   0060             int_7_uart0:
0321   0060 D7            push a
0322   0061 DA            push d
0323   0062 E1            pushf
0324   0063 1D 80 FF      mov al, [_uart0_data]       ; get character
0325   0066               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0326   0066 3B FF 0B      mov d, fifo_in
0327   0069 FD 2A         mov d, [d]
0328   006B 3E            mov [d], al                 ; add to fifo
0329   006C 13            mov a, d
0330   006D 77            inc a
0331   006E AF 47 1F      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0332   0071 C7 77 00      jne int_7_continue
0333   0074 10 47 0F      mov a, fifo  
0334   0077             int_7_continue:  
0335   0077 42 FF 0B      mov [fifo_in], a            ; update fifo pointer
0336   007A 1A            mov al, ah
0337   007B 3D B0 FF      mov [_til311_display], al
0338   007E EE            popf
0339   007F E7            pop d
0340   0080 E4            pop a  
0341   0081 06            sysret
0342   0082             
0343   0082             sys_mkfs:
0344   0082 06            sysret
0345   0083             
0346   0083             ; ------------------------------------------------------------------------------------------------------------------;
0347   0083             ; process syscalls
0348   0083             ; ------------------------------------------------------------------------------------------------------------------;
0349   0083             proc_jmptbl:
0350   0083 89 00         .dw proc_creat
0351   0085             syscall_proc:
0352   0085 FD 0A 83 00   jmp [proc_jmptbl + al]
0353   0089             
0354   0089             proc_creat:
0355   0089 06            sysret
0356   008A             
0357   008A             ; ------------------------------------------------------------------------------------------------------------------;
0358   008A             ; system syscalls
0359   008A             ; ------------------------------------------------------------------------------------------------------------------;
0360   008A             system_jmptbl:
0361   008A C0 00         .dw system_uname
0362   008C C7 00         .dw system_whoami
0363   008E 9A 00         .dw system_poke
0364   0090 9D 00         .dw system_bootloader_install
0365   0092 98 00         .dw system_peek
0366   0094             syscall_system:
0367   0094 FD 0A 8A 00   jmp [system_jmptbl + al]
0368   0098             
0369   0098             ; param register address in register d
0370   0098             ; param value in register bl
0371   0098             system_peek:
0372   0098 32            mov bl, [d]
0373   0099 06            sysret
0374   009A             
0375   009A             ; param register address in register d
0376   009A             ; param value in register bl
0377   009A             system_poke:
0378   009A FD 3E         mov [d], bl
0379   009C 06            sysret
0380   009D             
0381   009D             ; kernel LBA address in 'b'
0382   009D             system_bootloader_install:
0383   009D D8            push b
0384   009E 26 00 00      mov b, 0
0385   00A1 38 00 00      mov c, 0
0386   00A4 22 01         mov ah, $01                 ; 1 sector
0387   00A6 3B 47 21      mov d, transient_area
0388   00A9 07 FA 02      call ide_read_sect          ; read sector
0389   00AC E5            pop b
0390   00AD FD 44 FE 01   mov [d + 510], b            ; update LBA address
0391   00B1 26 00 00      mov b, 0
0392   00B4 38 00 00      mov c, 0
0393   00B7 22 01         mov ah, $01                 ; 1 sector
0394   00B9 3B 47 21      mov d, transient_area
0395   00BC 07 20 03      call ide_write_sect         ; write sector
0396   00BF 06            sysret
0397   00C0             
0398   00C0             system_uname:
0399   00C0 3B 10 0C      mov d, s_uname
0400   00C3 07 CC 06      call _puts
0401   00C6 06            sysret
0402   00C7             
0403   00C7             system_whoami:
0404   00C7 06            sysret
0405   00C8             
0406   00C8             ; reboot system
0407   00C8             syscall_reboot:
0408   00C8 FD D7 FF FF   push word $ffff 
0409   00CC FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0410   00CF FD D7 90 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0411   00D3 06            sysret
0412   00D4             
0413   00D4             
0414   00D4             ; ------------------------------------------------------------------------------------------------------------------;
0415   00D4             ; exceptions code block
0416   00D4             ; ------------------------------------------------------------------------------------------------------------------;
0417   00D4             ; privilege exception
0418   00D4             ; ------------------------------------------------------------------------------------------------------------------;
0419   00D4             trap_privilege:
0420   00D4 DA            push d
0421   00D5 3B 28 0D      mov d, s_priviledge
0422   00D8 07 CC 06      call _puts
0423   00DB E7            pop d
0424   00DC 0A C8 00      jmp syscall_reboot
0425   00DF             
0426   00DF             ; ------------------------------------------------------------------------------------------------------------------;
0427   00DF             ; breakpoint
0428   00DF             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0429   00DF             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0430   00DF             ; ------------------------------------------------------------------------------------------------------------------;
0431   00DF             syscall_break:
0432   00DF 4B            pusha
0433   00E0             syscall_break_prompt:
0434   00E0 3B 5A 0D      mov d, s_break1
0435   00E3 07 CC 06      call _puts
0436   00E6 07 79 06      call printnl
0437   00E9 07 CE 07      call scan_u16d
0438   00EC AF 00 00      cmp a, 0
0439   00EF C6 FA 00      je syscall_break_regs
0440   00F2 AF 01 00      cmp a, 1
0441   00F5 C6 1D 01      je syscall_break_mem
0442   00F8             syscall_break_end:  
0443   00F8 4C            popa
0444   00F9 06            sysret
0445   00FA             syscall_break_regs:
0446   00FA 48            mov a, sp
0447   00FB 53 0E 00      add a, 14               ; back-track 7 registers
0448   00FE 3C            mov d, a
0449   00FF 3A 07         mov cl, 7
0450   0101             syscall_regs_l0:
0451   0101 2A            mov b, [d]
0452   0102 FD AB         swp b
0453   0104 07 28 07      call print_u16x         ; print register value
0454   0107 07 79 06      call printnl
0455   010A 63 02 00      sub d, 2
0456   010D 71 01         sub cl, 1
0457   010F C3 00         cmp cl, 0
0458   0111 C7 01 01      jne syscall_regs_l0
0459   0114 0A E0 00      jmp syscall_break_prompt
0460   0117 07 79 06      call printnl
0461   011A 0A E0 00      jmp syscall_break_prompt
0462   011D             syscall_break_mem:
0463   011D 07 79 06      call printnl
0464   0120 07 4A 07      call scan_u16x
0465   0123 4D            mov si, a               ; data source from user space
0466   0124 FD 4F 47 1F   mov di, scrap_sector    ; destination in kernel space
0467   0128 38 00 02      mov c, 512
0468   012B 04            load                    ; transfer data to kernel space!
0469   012C 3B 47 1F      mov d, scrap_sector     ; dump pointer in d
0470   012F 38 00 00      mov c, 0
0471   0132             dump_loop:
0472   0132 84            mov al, cl
0473   0133 87 0F         and al, $0f
0474   0135 C6 83 01      jz print_base
0475   0138             back:
0476   0138 1E            mov al, [d]             ; read byte
0477   0139 2F            mov bl, al
0478   013A 07 6C 07      call print_u8x
0479   013D 10 00 20      mov a, $2000
0480   0140 05 03         syscall sys_io          ; space
0481   0142 84            mov al, cl
0482   0143 87 0F         and al, $0f
0483   0145 B9 0F         cmp al, $0f
0484   0147 C6 58 01      je print_ascii
0485   014A             back1:
0486   014A 79            inc d
0487   014B 78            inc c
0488   014C C2 00 02      cmp c, 512
0489   014F C7 32 01      jne dump_loop
0490   0152 07 79 06      call printnl
0491   0155 0A E0 00      jmp syscall_break_prompt  ; go to syscall_break return point
0492   0158             print_ascii:
0493   0158 10 00 20      mov a, $2000
0494   015B 05 03         syscall sys_io
0495   015D 63 10 00      sub d, 16
0496   0160 26 10 00      mov b, 16
0497   0163             print_ascii_l:
0498   0163 79            inc d
0499   0164 1E            mov al, [d]               ; read byte
0500   0165 B9 20         cmp al, $20
0501   0167 C8 6F 01      jlu dot
0502   016A B9 7E         cmp al, $7e
0503   016C D0 77 01      jleu ascii
0504   016F             dot:
0505   016F 10 00 2E      mov a, $2e00
0506   0172 05 03         syscall sys_io
0507   0174 0A 7C 01      jmp ascii_continue
0508   0177             ascii:
0509   0177 23            mov ah, al
0510   0178 19 00         mov al, 0
0511   017A 05 03         syscall sys_io
0512   017C             ascii_continue:
0513   017C FD A9 63 01   loopb print_ascii_l
0514   0180 0A 4A 01      jmp back1
0515   0183             print_base:
0516   0183 07 79 06      call printnl
0517   0186 2D            mov b, d
0518   0187 61 47 1F      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0519   018A 07 28 07      call print_u16x          ; display row
0520   018D 10 00 3A      mov a, $3a00
0521   0190 05 03         syscall sys_io
0522   0192 10 00 20      mov a, $2000
0523   0195 05 03         syscall sys_io
0524   0197 0A 38 01      jmp back
0525   019A             
0526   019A             ; ------------------------------------------------------------------------------------------------------------------;
0527   019A             ; divide by zero exception
0528   019A             ; ------------------------------------------------------------------------------------------------------------------;
0529   019A             trap_div_zero:
0530   019A D7            push a
0531   019B DA            push d
0532   019C E1            pushf
0533   019D 3B 3F 0D      mov d, s_divzero
0534   01A0 07 CC 06      call _puts
0535   01A3 EE            popf
0536   01A4 E7            pop d
0537   01A5 E4            pop a
0538   01A6 06            sysret ; enable interrupts
0539   01A7             
0540   01A7             ; ------------------------------------------------------------------------------------------------------------------;
0541   01A7             ; undefined opcode exception
0542   01A7             ; ------------------------------------------------------------------------------------------------------------------;
0543   01A7             trap_undef_opcode:
0544   01A7 06            sysret
0545   01A8             
0546   01A8             ; ------------------------------------------------------------------------------------------------------------------;
0547   01A8             ; real-time clock services syscall
0548   01A8             ; rtc i/o bank = ffa0 to ffaf
0549   01A8             ; ffa0 to ffa7 is scratch ram
0550   01A8             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0551   01A8             ; al = 0..6 -> get
0552   01A8             ; al = 7..d -> set
0553   01A8             ; ------------------------------------------------------------------------------------------------------------------;
0554   01A8             syscall_rtc:
0555   01A8 DB            push al
0556   01A9 DA            push d
0557   01AA B9 06         cmp al, 6
0558   01AC D1 C1 01      jgu syscall_rtc_set
0559   01AF             syscall_rtc_get:
0560   01AF 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0561   01B1 22 FF         mov ah, $ff    
0562   01B3 3C            mov d, a                ; get to ffa9 + offset
0563   01B4 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0564   01B8 1E            mov al, [d]             ; get data
0565   01B9 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0566   01BD 23            mov ah, al
0567   01BE E7            pop d
0568   01BF E8            pop al
0569   01C0 06            sysret
0570   01C1             syscall_rtc_set:
0571   01C1 DD            push bl
0572   01C2 99            mov bl, ah              ; set data aside
0573   01C3 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0574   01C5 22 FF         mov ah, $ff    
0575   01C7 3C            mov d, a                ; get to ffa9 + offset
0576   01C8 1B            mov al, bl              ; get data back
0577   01C9 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0578   01CD 3E            mov [d], al             ; set data
0579   01CE F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0580   01D2 EA            pop bl
0581   01D3 E7            pop d
0582   01D4 E8            pop al
0583   01D5 06            sysret
0584   01D6             
0585   01D6             datetime_serv_tbl:
0586   01D6 DE 01         .dw print_date
0587   01D8 52 02         .dw set_date
0588   01DA             syscall_datetime:
0589   01DA FD 0A D6 01   jmp [datetime_serv_tbl + al]      
0590   01DE             print_date:
0591   01DE 10 00 0D      mov a, $0d00           ; print carriage return char
0592   01E1 19 03         mov al, 3
0593   01E3 05 01         syscall sys_rtc        ; get week
0594   01E5 1A            mov al, ah
0595   01E6 22 00         mov ah, 0
0596   01E8 FD 9D 02      shl a, 2          
0597   01EB 3B 1F 0E      mov d, s_week
0598   01EE 59            add d, a
0599   01EF 07 CC 06      call _puts
0600   01F2 10 00 20      mov a, $2000
0601   01F5 05 03         syscall sys_io         ; display ' '
0602   01F7 19 04         mov al, 4
0603   01F9 05 01         syscall sys_rtc        ; get day
0604   01FB 99            mov bl, ah
0605   01FC 07 6C 07      call print_u8x
0606   01FF 10 00 20      mov a, $2000
0607   0202 05 03         syscall sys_io         ; display ' '
0608   0204             ; there is a problem with the month displaying
0609   0204             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0610   0204             ; even though it is to be understood as bcd.
0611   0204             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0612   0204 19 05         mov al, 05
0613   0206 05 01         syscall sys_rtc        ; get month
0614   0208 1A            mov al, ah
0615   0209 22 00         mov ah, 0
0616   020B FD 9D 02      shl a, 2          
0617   020E 3B EB 0D      mov d, s_months
0618   0211 59            add d, a
0619   0212 07 CC 06      call _puts
0620   0215 10 00 20      mov a, $2000
0621   0218 05 03         syscall sys_io         ; display ' '
0622   021A 2E 20         mov bl, $20
0623   021C 07 6C 07      call print_u8x         ; print 20 for year prefix
0624   021F 19 06         mov al, 06
0625   0221 05 01         syscall sys_rtc        ; get year
0626   0223 99            mov bl, ah
0627   0224 07 6C 07      call print_u8x
0628   0227 10 00 20      mov a, $2000  
0629   022A 05 03         syscall sys_io         ; display ' '
0630   022C 19 02         mov al, 2
0631   022E 05 01         syscall sys_rtc        ; get hours
0632   0230 99            mov bl, ah
0633   0231 07 6C 07      call print_u8x
0634   0234 10 00 3A      mov a, $3a00    
0635   0237 05 03         syscall sys_io         ; display ':'
0636   0239 19 01         mov al, 01
0637   023B 05 01         syscall sys_rtc        ; get minutes
0638   023D 99            mov bl, ah
0639   023E 07 6C 07      call print_u8x
0640   0241 10 00 3A      mov a, $3a00  
0641   0244 05 03         syscall sys_io         ; display ':'
0642   0246 19 00         mov al, 0
0643   0248 05 01         syscall sys_rtc        ; get seconds
0644   024A 99            mov bl, ah
0645   024B 07 6C 07      call print_u8x
0646   024E 07 79 06      call printnl
0647   0251 06            sysret
0648   0252             set_date:
0649   0252 3B B0 0D      mov d, s_set_year
0650   0255 07 CC 06      call _puts
0651   0258 07 B7 07      call scan_u8x          ; read integer into a
0652   025B FD 9D 08      shl a, 8               ; only al used, move to ah
0653   025E 19 0D         mov al, 0dh            ; set rtc year
0654   0260 05 01         syscall sys_rtc        ; set rtc
0655   0262 3B B7 0D      mov d, s_set_month
0656   0265 07 CC 06      call _puts
0657   0268 07 B7 07      call scan_u8x          ; read integer into a
0658   026B FD 9D 08      shl a, 8               ; only al used, move to ah
0659   026E 19 0C         mov al, 0ch            ; set rtc month
0660   0270 05 01         syscall sys_rtc        ; set rtc
0661   0272 3B BF 0D      mov d, s_set_day
0662   0275 07 CC 06      call _puts
0663   0278 07 B7 07      call scan_u8x          ; read integer into a
0664   027B FD 9D 08      shl a, 8               ; only al used, move to ah
0665   027E 19 0B         mov al, 0bh            ; set rtc month
0666   0280 05 01         syscall sys_rtc        ; set rtc
0667   0282 3B C5 0D      mov d, s_set_week
0668   0285 07 CC 06      call _puts
0669   0288 07 B7 07      call scan_u8x          ; read integer into a
0670   028B FD 9D 08      shl a, 8               ; only al used, move to ah
0671   028E 19 0A         mov al, 0ah            ; set rtc month
0672   0290 05 01         syscall sys_rtc        ; set rtc
0673   0292 3B CF 0D      mov d, s_set_hours
0674   0295 07 CC 06      call _puts
0675   0298 07 B7 07      call scan_u8x          ; read integer into a
0676   029B FD 9D 08      shl a, 8               ; only al used, move to ah
0677   029E 19 09         mov al, 09h            ; set rtc month
0678   02A0 05 01         syscall sys_rtc        ; set rtc
0679   02A2 3B D7 0D      mov d, s_set_minutes
0680   02A5 07 CC 06      call _puts
0681   02A8 07 B7 07      call scan_u8x          ; read integer into a
0682   02AB FD 9D 08      shl a, 8               ; only al used, move to ah
0683   02AE 19 08         mov al, 08h            ; set rtc month
0684   02B0 05 01         syscall sys_rtc        ; set rtc
0685   02B2 3B E1 0D      mov d, s_set_seconds
0686   02B5 07 CC 06      call _puts
0687   02B8 07 B7 07      call scan_u8x          ; read integer into a
0688   02BB FD 9D 08      shl a, 8               ; only al used, move to ah
0689   02BE 19 07         mov al, 07h            ; set rtc month
0690   02C0 05 01         syscall sys_rtc        ; set rtc
0691   02C2 06            sysret
0692   02C3             
0693   02C3             ; ------------------------------------------------------------------------------------------------------------------;
0694   02C3             ; ide services syscall
0695   02C3             ; al = option
0696   02C3             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
0697   02C3             ; ide read/write sector
0698   02C3             ; 512 bytes
0699   02C3             ; user buffer pointer in d
0700   02C3             ; ah = number of sectors
0701   02C3             ; cb = lba bytes 3..0
0702   02C3             ; ------------------------------------------------------------------------------------------------------------------;
0703   02C3             ide_serv_tbl:
0704   02C3 CF 02         .dw ide_reset
0705   02C5 E3 02         .dw ide_sleep
0706   02C7 F2 02         .dw ide_read_sect_wrapper
0707   02C9 F6 02         .dw ide_write_sect_wrapper
0708   02CB             syscall_ide:
0709   02CB FD 0A C3 02   jmp [ide_serv_tbl + al]    
0710   02CF             
0711   02CF             ide_reset:      
0712   02CF F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
0713   02D3 07 7C 03      call ide_wait                   ; wait for ide ready             
0714   02D6 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
0715   02DA F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
0716   02DE F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
0717   02E2 06            sysret
0718   02E3             ide_sleep:
0719   02E3 07 7C 03      call ide_wait                   ; wait for ide ready             
0720   02E6 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
0721   02EA F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
0722   02EE 07 7C 03      call ide_wait                   ; wait for ide ready
0723   02F1 06            sysret
0724   02F2             ide_read_sect_wrapper:
0725   02F2 07 FA 02      call ide_read_sect
0726   02F5 06            sysret
0727   02F6             ide_write_sect_wrapper:
0728   02F6 07 20 03      call ide_write_sect
0729   02F9 06            sysret
0730   02FA             ide_read_sect:
0731   02FA 1A            mov al, ah
0732   02FB 24            mov ah, bl
0733   02FC 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0734   02FF 1C            mov al, bh
0735   0300 3D D4 FF      mov [_ide_r4], al
0736   0303 12            mov a, c
0737   0304 3D D5 FF      mov [_ide_r5], al
0738   0307 1A            mov al, ah
0739   0308 87 0F         and al, %00001111
0740   030A 8B E0         or al, %11100000                ; mode lba, master
0741   030C 3D D6 FF      mov [_ide_r6], al
0742   030F             ide_read_sect_wait:
0743   030F 1D D7 FF      mov al, [_ide_r7]  
0744   0312 87 80         and al, $80                     ; busy flag
0745   0314 C7 0F 03      jnz ide_read_sect_wait
0746   0317 19 20         mov al, $20
0747   0319 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
0748   031C 07 46 03      call ide_read  
0749   031F 09            ret
0750   0320             ide_write_sect:
0751   0320 1A            mov al, ah
0752   0321 24            mov ah, bl
0753   0322 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
0754   0325 1C            mov al, bh
0755   0326 3D D4 FF      mov [_ide_r4], al
0756   0329 12            mov a, c
0757   032A 3D D5 FF      mov [_ide_r5], al
0758   032D 1A            mov al, ah
0759   032E 87 0F         and al, %00001111
0760   0330 8B E0         or al, %11100000                ; mode lba, master
0761   0332 3D D6 FF      mov [_ide_r6], al
0762   0335             ide_write_sect_wait:
0763   0335 1D D7 FF      mov al, [_ide_r7]  
0764   0338 87 80         and al, $80                     ; busy flag
0765   033A C7 35 03      jnz ide_write_sect_wait
0766   033D 19 30         mov al, $30
0767   033F 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
0768   0342 07 61 03      call ide_write      
0769   0345 09            ret
0770   0346             
0771   0346             ;----------------------------------------------------------------------------------------------------;
0772   0346             ; read ide data
0773   0346             ; pointer in d
0774   0346             ;----------------------------------------------------------------------------------------------------;
0775   0346             ide_read:
0776   0346 DA            push d
0777   0347             ide_read_loop:
0778   0347 1D D7 FF      mov al, [_ide_r7]  
0779   034A 87 80         and al, 80h                     ; busy flag
0780   034C C7 47 03      jnz ide_read_loop               ; wait loop
0781   034F 1D D7 FF      mov al, [_ide_r7]
0782   0352 87 08         and al, %00001000               ; drq flag
0783   0354 C6 5F 03      jz ide_read_end
0784   0357 1D D0 FF      mov al, [_ide_r0]
0785   035A 3E            mov [d], al
0786   035B 79            inc d
0787   035C 0A 47 03      jmp ide_read_loop
0788   035F             ide_read_end:
0789   035F E7            pop d
0790   0360 09            ret
0791   0361             
0792   0361             ;----------------------------------------------------------------------------------------------------;
0793   0361             ; write ide data
0794   0361             ; data pointer in d
0795   0361             ;----------------------------------------------------------------------------------------------------;
0796   0361             ide_write:
0797   0361 DA            push d
0798   0362             ide_write_loop:
0799   0362 1D D7 FF      mov al, [_ide_r7]  
0800   0365 87 80         and al, 80h             ; busy flag
0801   0367 C7 62 03      jnz ide_write_loop      ; wait loop
0802   036A 1D D7 FF      mov al, [_ide_r7]
0803   036D 87 08         and al, %00001000       ; drq flag
0804   036F C6 7A 03      jz ide_write_end
0805   0372 1E            mov al, [d]
0806   0373 3D D0 FF      mov [_ide_r0], al
0807   0376 79            inc d 
0808   0377 0A 62 03      jmp ide_write_loop
0809   037A             ide_write_end:
0810   037A E7            pop d
0811   037B 09            ret
0812   037C             
0813   037C             ;----------------------------------------------------------------------------------------------------;
0814   037C             ; wait for ide to be ready
0815   037C             ;----------------------------------------------------------------------------------------------------;
0816   037C             ide_wait:
0817   037C 1D D7 FF      mov al, [_ide_r7]  
0818   037F 87 80         and al, 80h        ; busy flag
0819   0381 C7 7C 03      jnz ide_wait
0820   0384 09            ret
0821   0385             
0822   0385             ;----------------------------------------------------------------------------------------------------;
0823   0385             ; io syscall
0824   0385             ;----------------------------------------------------------------------------------------------------;
0825   0385             ; baud  divisor
0826   0385             ; 50    2304
0827   0385             ; 110   1047
0828   0385             ; 300    384
0829   0385             ; 600    192
0830   0385             ; 1200    96
0831   0385             ; 9600    12
0832   0385             ; 19200    6
0833   0385             ; 38400    3
0834   0385             syscall_io_jmp:
0835   0385 E0 03         .dw syscall_io_putchar
0836   0387 F9 03         .dw syscall_io_getch
0837   0389 8F 03         .dw syscall_io_uart_setup
0838   038B             syscall_io:
0839   038B FD 0A 85 03   jmp [syscall_io_jmp + al]
0840   038F             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
0841   038F             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
0842   038F             ; buffer, the transmitter holding register, or the interrupt enable register.
0843   038F             syscall_io_uart_setup:
0844   038F 1D F5 0B      mov al, [sys_uart0_lcr]
0845   0392 8B 80         or al, $80                ; set dlab access bit
0846   0394 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, even parity 
0847   0397 1D F8 0B      mov al, [sys_uart0_div0]
0848   039A 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
0849   039D 1D F9 0B      mov al, [sys_uart0_div1]
0850   03A0 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
0851   03A3 1D F5 0B      mov al, [sys_uart0_lcr]
0852   03A6 87 7F         and al, $7f               ; clear dlab access bit 
0853   03A8 3D 83 FF      mov [_uart0_lcr], al
0854   03AB 1D F6 0B      mov al, [sys_uart0_inten]
0855   03AE 3D 81 FF      mov [_uart0_ier], al      ; interrupts
0856   03B1 1D F7 0B      mov al, [sys_uart0_fifoen]
0857   03B4 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
0858   03B7             
0859   03B7             ; uart1:
0860   03B7 1D FA 0B      mov al, [sys_uart1_lcr]
0861   03BA 8B 80         or al, $80                ; set dlab access bit
0862   03BC 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, even parity 
0863   03BF 1D FD 0B      mov al, [sys_uart1_div0]
0864   03C2 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
0865   03C5 1D FE 0B      mov al, [sys_uart1_div1]
0866   03C8 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
0867   03CB 1D FA 0B      mov al, [sys_uart1_lcr]
0868   03CE 87 7F         and al, $7f               ; clear dlab access bit 
0869   03D0 3D 8B FF      mov [_uart1_lcr], al
0870   03D3 1D FB 0B      mov al, [sys_uart1_inten]
0871   03D6 3D 89 FF      mov [_uart1_ier], al      ; interrupts
0872   03D9 1D FC 0B      mov al, [sys_uart1_fifoen]
0873   03DC 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
0874   03DF 06            sysret
0875   03E0             
0876   03E0             ; char in ah
0877   03E0             syscall_io_putchar:
0878   03E0             syscall_io_putchar_l0:
0879   03E0 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0880   03E3 93 20         test al, $20
0881   03E5 C6 E0 03      jz syscall_io_putchar_l0    
0882   03E8 1A            mov al, ah
0883   03E9 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0884   03EC             ; uart1
0885   03EC             syscall_io_putchar_l1:
0886   03EC 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0887   03EF 93 20         test al, $20
0888   03F1 C6 EC 03      jz syscall_io_putchar_l1    
0889   03F4 1A            mov al, ah
0890   03F5 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0891   03F8 06            sysret
0892   03F9             
0893   03F9             ; char in ah
0894   03F9             ; al = sucess code
0895   03F9             syscall_io_getch:
0896   03F9 D8            push b
0897   03FA DA            push d
0898   03FB FD 0C         sti
0899   03FD             syscall_io_getch_l0:  
0900   03FD 14 01 0C      mov a, [fifo_out]
0901   0400 29 FF 0B      mov b, [fifo_in]
0902   0403 B0            cmp a, b
0903   0404 C6 FD 03      je syscall_io_getch_l0
0904   0407 3C            mov d, a
0905   0408 77            inc a
0906   0409 AF 47 1F      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
0907   040C C7 12 04      jne syscall_io_getch_cont
0908   040F 10 47 0F      mov a, fifo  
0909   0412             syscall_io_getch_cont:  
0910   0412 42 01 0C      mov [fifo_out], a             ; update fifo pointer
0911   0415 1E            mov al, [d]                   ; get char
0912   0416 23            mov ah, al
0913   0417             ; here we just echo the char back to the console
0914   0417             syscall_io_getch_echo_l0:
0915   0417 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0916   041A 87 20         and al, $20                 ; isolate transmitter empty
0917   041C C6 17 04      jz syscall_io_getch_echo_l0
0918   041F 1A            mov al, ah
0919   0420 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0920   0423             syscall_io_getch_echo_l1:
0921   0423 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
0922   0426 87 20         and al, $20                 ; isolate transmitter empty
0923   0428 C6 23 04      jz syscall_io_getch_echo_l1
0924   042B 1A            mov al, ah
0925   042C 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
0926   042F             syscall_io_getch_noecho:
0927   042F 19 01         mov al, 1                    ; al = 1 means a char successfully received
0928   0431 E7            pop d
0929   0432 E5            pop b
0930   0433 06            sysret
0931   0434             
0932   0434             ;------------------------------------------------------------------------------------------------------;
0933   0434             ; file system data
0934   0434             ;------------------------------------------------------------------------------------------------------;
0935   0434             ; infor for : ide services interrupt
0936   0434             ; ide read/write 512-byte sector
0937   0434             ; al = option
0938   0434             ; user buffer pointer in d
0939   0434             ; ah = number of sectors
0940   0434             ; cb = lba bytes 3..0  
0941   0434             ;------------------------------------------------------------------------------------------------------;
0942   0434             ; file system data structure
0943   0434             ;------------------------------------------------------------------------------------------------------;
0944   0434             ; first directory on disk is the root directory '/'
0945   0434             file_system_jmptbl:
0946   0434 47 04         .dw fs_cd                     
0947   0436 48 04         .dw fs_ls                     
0948   0438 4C 04         .dw fs_pwd                    
0949   043A 4D 04         .dw fs_rmdir                  
0950   043C 46 04         .dw fs_mkdir
0951   043E 4E 04         .dw fs_rm                     
0952   0440 4F 04         .dw fs_mv                     
0953   0442             
0954   0442             syscall_file:
0955   0442 FD 0A 34 04   jmp [file_system_jmptbl + al]
0956   0446             
0957   0446             ;------------------------------------------------------------------------------------------------------;
0958   0446             ; create new directory
0959   0446             ;------------------------------------------------------------------------------------------------------;
0960   0446             ; search list for null name entry. add new directory to list
0961   0446             fs_mkdir:
0962   0446 06            sysret
0963   0447             
0964   0447             ;------------------------------------------------------------------------------------------------------;
0965   0447             ; cd
0966   0447             ;------------------------------------------------------------------------------------------------------;
0967   0447             fs_cd:
0968   0447 06            sysret  
0969   0448             
0970   0448             ;------------------------------------------------------------------------------------------------------;
0971   0448             ; ls
0972   0448             ;------------------------------------------------------------------------------------------------------;
0973   0448             ; inode in a
0974   0448             fs_ls:
0975   0448 3B 1C 00      mov d, inode_table_sect_start
0976   044B             
0977   044B 06            sysret
0978   044C             
0979   044C             ;------------------------------------------------------------------------------------------------------;
0980   044C             ; pwd - print working directory
0981   044C             ;------------------------------------------------------------------------------------------------------;    
0982   044C             fs_pwd:
0983   044C 06            sysret
0984   044D             
0985   044D             ;------------------------------------------------------------------------------------------------------;
0986   044D             ; rmdir - remove dir by dirid
0987   044D             ;------------------------------------------------------------------------------------------------------;
0988   044D             fs_rmdir:
0989   044D 06            sysret
0990   044E             
0991   044E             ;------------------------------------------------------------------------------------------------------;
0992   044E             ; rm - remove file
0993   044E             ;------------------------------------------------------------------------------------------------------;
0994   044E             fs_rm:
0995   044E 06            sysret  
0996   044F             
0997   044F             ;------------------------------------------------------------------------------------------------------;
0998   044F             ; mv - move / change file name
0999   044F             ;------------------------------------------------------------------------------------------------------;
1000   044F             fs_mv:
1001   044F 06            sysret
1002   0450             
1003   0450             
1004   0450             ;----------------------------------------------------------------------------------------------;
1005   0450             ; get hex file
1006   0450             ; di = destination address
1007   0450             ; return length in bytes in c
1008   0450             ;----------------------------------------------------------------------------------------------;
1009   0450             _load_hex:
1010   0450 D7            push a
1011   0451 D8            push b
1012   0452 DA            push d
1013   0453 E2            push si
1014   0454 E3            push di
1015   0455 38 00 00      mov c, 0
1016   0458 50            mov a, di
1017   0459 3C            mov d, a          ; start of string data block
1018   045A 07 A7 05      call _gets        ; get program string
1019   045D 4D            mov si, a
1020   045E             __load_hex_loop:
1021   045E F6            lodsb             ; load from [si] to al
1022   045F B9 00         cmp al, 0         ; check if ascii 0
1023   0461 C6 6F 04      jz __load_hex_ret
1024   0464 36            mov bh, al
1025   0465 F6            lodsb
1026   0466 2F            mov bl, al
1027   0467 07 5D 05      call _atoi        ; convert ascii byte in b to int (to al)
1028   046A F7            stosb             ; store al to [di]
1029   046B 78            inc c
1030   046C 0A 5E 04      jmp __load_hex_loop
1031   046F             __load_hex_ret:
1032   046F F0            pop di
1033   0470 EF            pop si
1034   0471 E7            pop d
1035   0472 E5            pop b
1036   0473 E4            pop a
1037   0474 09            ret
1038   0475             
1039   0475             ; ---------------------------------------------------------------------
1040   0475             ; kernel reset vector
1041   0475             ; ---------------------------------------------------------------------
1042   0475             kernel_reset_vector:  
1043   0475 FD 49 FF F7   mov bp, _stack_top
1044   0479 FD 47 FF F7   mov sp, _stack_top
1045   047D               
1046   047D 0C            lodstat
1047   047E 87 DF         and al, %11011111             ; disable display register loading
1048   0480 0D            stostat
1049   0481             
1050   0481             ; reset fifo pointers
1051   0481 10 47 0F      mov a, fifo
1052   0484 3B FF 0B      mov d, fifo_in
1053   0487 43            mov [d], a
1054   0488 3B 01 0C      mov d, fifo_out
1055   048B 43            mov [d], a  
1056   048C 19 02         mov al, 2
1057   048E 05 03         syscall sys_io                ; enable uart in interrupt mode
1058   0490             
1059   0490 19 A0         mov al, %10100000             ; uart0 | timer | uart1 | 0 | 0 | 0 | 0| fdc
1060   0492 FD 0F         stomsk                        
1061   0494 FD 0C         sti  
1062   0496             
1063   0496 3B 54 0C      mov d, s_kernel_welcome
1064   0499 07 CC 06      call _puts
1065   049C             
1066   049C 3B 4C 0E      mov d, s_fdc_config
1067   049F 07 CC 06      call _puts
1068   04A2             
1069   04A2 F2 C0 FF 0D   mov byte [_fdc_config], %00001101   ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
1070   04A6 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011 ; leave this restore command in order to clear BUSY flag
1071   04AA F2 C9 FF 00   mov byte [_fdc_track], $00          ; reset track
1072   04AE             
1073   04AE             
1074   04AE 10 00 00      mov a, 0
1075   04B1             ker_loop:
1076   04B1 77            inc a
1077   04B2 3D B0 FF      mov [_til311_display], al
1078   04B5 0A B1 04      jmp ker_loop
1079   04B8             
1080   04B8             
1081   04B8             ; file includes
1082   04B8             .include "lib/bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  04B8             boot_origin      .EQU  $8004
0002+  04B8             bios_uart        .EQU  $0002
0003+  04B8             bios_ide         .EQU  $0003
0004+  04B8             bios_reset_vector .EQU  $0190
0005+  04B8             ide_buffer       .EQU  $8404
0006+  04B8             inode_buffer     .EQU  $8c04
0007+  04B8             noname.__print_u16x .EQU  $01f6
0008+  04B8             noname.__xput_u8 .EQU  $023e
0009+  04B8             noname.__puts    .EQU  $0252
0010+  04B8             noname.__print_u16d .EQU  $0379
1083   04B8             .include "lib/stdio.asm"
0001+  04B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04B8             ; stdio.s
0003+  04B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04B8             .include "lib/string.asm"
0001++ 04B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04B8             ; string.s
0003++ 04B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04B8             
0005++ 04B8             
0006++ 04B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04B8             ; _strrev
0008++ 04B8             ; reverse a string
0009++ 04B8             ; d = string address
0010++ 04B8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04B8             ; 01234
0012++ 04B8             _strrev:
0013++ 04B8 4B          	pusha
0014++ 04B9 07 FF 04    	call _strlen	; length in c
0015++ 04BC 12          	mov a, c
0016++ 04BD AF 01 00    	cmp a, 1
0017++ 04C0 D0 DA 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04C3 7D          	dec a
0019++ 04C4 FD 4E       	mov si, d	; beginning of string
0020++ 04C6 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04C8 59          	add d, a	; end of string
0022++ 04C9 12          	mov a, c
0023++ 04CA FD 9B       	shr a		; divide by 2
0024++ 04CC 39          	mov c, a	; c now counts the steps
0025++ 04CD             _strrev_l0:
0026++ 04CD 32          	mov bl, [d]	; save load right-side char into bl
0027++ 04CE F6          	lodsb		; load left-side char into al; increase si
0028++ 04CF 3E          	mov [d], al	; store left char into right side
0029++ 04D0 1B          	mov al, bl
0030++ 04D1 F7          	stosb		; store right-side char into left-side; increase di
0031++ 04D2 7E          	dec c
0032++ 04D3 7F          	dec d
0033++ 04D4 C2 00 00    	cmp c, 0
0034++ 04D7 C7 CD 04    	jne _strrev_l0
0035++ 04DA             _strrev_end:
0036++ 04DA 4C          	popa
0037++ 04DB 09          	ret
0038++ 04DC             	
0039++ 04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04DC             ; _strchr
0041++ 04DC             ; search string in d for char in al
0042++ 04DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04DC             _strchr:
0044++ 04DC             _strchr_l0:
0045++ 04DC 32          	mov bl, [d]
0046++ 04DD C1 00       	cmp bl, 0
0047++ 04DF C6 EA 04    	je _strchr_end
0048++ 04E2 BA          	cmp al, bl
0049++ 04E3 C6 EA 04    	je _strchr_end
0050++ 04E6 79          	inc d
0051++ 04E7 0A DC 04    	jmp _strchr_l0
0052++ 04EA             _strchr_end:
0053++ 04EA 1B          	mov al, bl
0054++ 04EB 09          	ret
0055++ 04EC             
0056++ 04EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04EC             ; _strstr
0058++ 04EC             ; find sub-string
0059++ 04EC             ; str1 in si
0060++ 04EC             ; str2 in di
0061++ 04EC             ; si points to end of source string
0062++ 04EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04EC             _strstr:
0064++ 04EC DB          	push al
0065++ 04ED DA          	push d
0066++ 04EE E3          	push di
0067++ 04EF             _strstr_loop:
0068++ 04EF F3          	cmpsb					; compare a byte of the strings
0069++ 04F0 C7 FB 04    	jne _strstr_ret
0070++ 04F3 FC 00 00    	lea d, [di + 0]
0071++ 04F6 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04F8 C7 EF 04    	jne _strstr_loop				; equal chars but not at end
0073++ 04FB             _strstr_ret:
0074++ 04FB F0          	pop di
0075++ 04FC E7          	pop d
0076++ 04FD E8          	pop al
0077++ 04FE 09          	ret
0078++ 04FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04FF             ; length of null terminated string
0080++ 04FF             ; result in c
0081++ 04FF             ; pointer in d
0082++ 04FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04FF             _strlen:
0084++ 04FF DA          	push d
0085++ 0500 38 00 00    	mov c, 0
0086++ 0503             _strlen_l1:
0087++ 0503 BD 00       	cmp byte [d], 0
0088++ 0505 C6 0D 05    	je _strlen_ret
0089++ 0508 79          	inc d
0090++ 0509 78          	inc c
0091++ 050A 0A 03 05    	jmp _strlen_l1
0092++ 050D             _strlen_ret:
0093++ 050D E7          	pop d
0094++ 050E 09          	ret
0095++ 050F             
0096++ 050F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 050F             ; strcmp
0098++ 050F             ; compare two strings
0099++ 050F             ; str1 in si
0100++ 050F             ; str2 in di
0101++ 050F             ; create a string compairon instrucion ?????
0102++ 050F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 050F             _strcmp:
0104++ 050F DB          	push al
0105++ 0510 DA          	push d
0106++ 0511 E3          	push di
0107++ 0512 E2          	push si
0108++ 0513             _strcmp_loop:
0109++ 0513 F3          	cmpsb					; compare a byte of the strings
0110++ 0514 C7 1F 05    	jne _strcmp_ret
0111++ 0517 FB FF FF    	lea d, [si +- 1]
0112++ 051A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 051C C7 13 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 051F             _strcmp_ret:
0115++ 051F EF          	pop si
0116++ 0520 F0          	pop di
0117++ 0521 E7          	pop d
0118++ 0522 E8          	pop al
0119++ 0523 09          	ret
0120++ 0524             
0121++ 0524             
0122++ 0524             ; strcpy
0123++ 0524             ; copy null terminated string from si to di
0124++ 0524             ; source in si
0125++ 0524             ; destination in di
0126++ 0524             _strcpy:
0127++ 0524 E2          	push si
0128++ 0525 E3          	push di
0129++ 0526 DB          	push al
0130++ 0527             _strcpy_l1:
0131++ 0527 F6          	lodsb
0132++ 0528 F7          	stosb
0133++ 0529 B9 00       	cmp al, 0
0134++ 052B C7 27 05    	jne _strcpy_l1
0135++ 052E             _strcpy_end:
0136++ 052E E8          	pop al
0137++ 052F F0          	pop di
0138++ 0530 EF          	pop si
0139++ 0531 09          	ret
0140++ 0532             
0141++ 0532             ; strcat
0142++ 0532             ; concatenate a null terminated string into string at di, from string at si
0143++ 0532             ; source in si
0144++ 0532             ; destination in di
0145++ 0532             _strcat:
0146++ 0532 E2          	push si
0147++ 0533 E3          	push di
0148++ 0534 D7          	push a
0149++ 0535 DA          	push d
0150++ 0536 50          	mov a, di
0151++ 0537 3C          	mov d, a
0152++ 0538             _strcat_goto_end_l1:
0153++ 0538 BD 00       	cmp byte[d], 0
0154++ 053A C6 41 05    	je _strcat_start
0155++ 053D 79          	inc d
0156++ 053E 0A 38 05    	jmp _strcat_goto_end_l1
0157++ 0541             _strcat_start:
0158++ 0541 FD 50       	mov di, d
0159++ 0543             _strcat_l1:
0160++ 0543 F6          	lodsb
0161++ 0544 F7          	stosb
0162++ 0545 B9 00       	cmp al, 0
0163++ 0547 C7 43 05    	jne _strcat_l1
0164++ 054A             _strcat_end:
0165++ 054A E7          	pop d
0166++ 054B E4          	pop a
0167++ 054C F0          	pop di
0168++ 054D EF          	pop si
0169++ 054E 09          	ret
0170++ 054F             
0171++ 054F             
0005+  054F             
0006+  054F             
0007+  054F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  054F             ; convert ascii 'o'..'f' to integer 0..15
0009+  054F             ; ascii in bl
0010+  054F             ; result in al
0011+  054F             ; ascii for f = 0100 0110
0012+  054F             ; ascii for 9 = 0011 1001
0013+  054F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  054F             hex_ascii_encode:
0015+  054F 1B            mov al, bl
0016+  0550 93 40         test al, $40        ; test if letter or number
0017+  0552 C7 58 05      jnz hex_letter
0018+  0555 87 0F         and al, $0f        ; get number
0019+  0557 09            ret
0020+  0558             hex_letter:
0021+  0558 87 0F         and al, $0f        ; get letter
0022+  055A 6A 09         add al, 9
0023+  055C 09            ret
0024+  055D             
0025+  055D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  055D             ; atoi
0027+  055D             ; 2 letter hex string in b
0028+  055D             ; 8bit integer returned in al
0029+  055D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  055D             _atoi:
0031+  055D D8            push b
0032+  055E 07 4F 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0561 30            mov bl, bh
0034+  0562 DB            push al          ; save a
0035+  0563 07 4F 05      call hex_ascii_encode
0036+  0566 EA            pop bl  
0037+  0567 FD 9E 04      shl al, 4
0038+  056A 8C            or al, bl
0039+  056B E5            pop b
0040+  056C 09            ret  
0041+  056D             
0042+  056D             
0043+  056D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  056D             ; scanf
0045+  056D             ; no need for explanations!
0046+  056D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  056D             scanf:
0048+  056D 09            ret
0049+  056E             
0050+  056E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  056E             ; itoa
0052+  056E             ; 8bit value in bl
0053+  056E             ; 2 byte ascii result in a
0054+  056E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  056E             _itoa:
0056+  056E DA            push d
0057+  056F D8            push b
0058+  0570 A7 00         mov bh, 0
0059+  0572 FD A4 04      shr bl, 4  
0060+  0575 74            mov d, b
0061+  0576 1F 08 08      mov al, [d + s_hex_digits]
0062+  0579 23            mov ah, al
0063+  057A               
0064+  057A E5            pop b
0065+  057B D8            push b
0066+  057C A7 00         mov bh, 0
0067+  057E FD 87 0F      and bl, $0f
0068+  0581 74            mov d, b
0069+  0582 1F 08 08      mov al, [d + s_hex_digits]
0070+  0585 E5            pop b
0071+  0586 E7            pop d
0072+  0587 09            ret
0073+  0588             
0074+  0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0588             ; hex string to binary
0076+  0588             ; di = destination address
0077+  0588             ; si = source
0078+  0588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0588             _hex_to_int:
0080+  0588             _hex_to_int_l1:
0081+  0588 F6            lodsb          ; load from [si] to al
0082+  0589 B9 00         cmp al, 0        ; check if ascii 0
0083+  058B C6 98 05      jz _hex_to_int_ret
0084+  058E 36            mov bh, al
0085+  058F F6            lodsb
0086+  0590 2F            mov bl, al
0087+  0591 07 5D 05      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0594 F7            stosb          ; store al to [di]
0089+  0595 0A 88 05      jmp _hex_to_int_l1
0090+  0598             _hex_to_int_ret:
0091+  0598 09            ret    
0092+  0599             
0093+  0599             
0094+  0599             
0095+  0599             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0599             ; getchar
0097+  0599             ; char in ah
0098+  0599             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0599             getch:
0100+  0599 DB            push al
0101+  059A             getch_retry:
0102+  059A 19 01         mov al, 1
0103+  059C 05 03         syscall sys_io      ; receive in ah
0104+  059E E8            pop al
0105+  059F 09            ret
0106+  05A0             
0107+  05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  05A0             ; putchar
0109+  05A0             ; char in ah
0110+  05A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05A0             _putchar:
0112+  05A0 DB            push al
0113+  05A1 19 00         mov al, 0
0114+  05A3 05 03         syscall sys_io      ; char in ah
0115+  05A5 E8            pop al
0116+  05A6 09            ret
0117+  05A7             
0118+  05A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  05A7             ;; input a string
0120+  05A7             ;; terminates with null
0121+  05A7             ;; pointer in d
0122+  05A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  05A7             _gets:
0124+  05A7 D7            push a
0125+  05A8 DA            push d
0126+  05A9             _gets_loop:
0127+  05A9 19 01         mov al, 1
0128+  05AB 05 03         syscall sys_io      ; receive in ah
0129+  05AD 76 1B         cmp ah, 27
0130+  05AF C6 D0 05      je _gets_ansi_esc
0131+  05B2 76 0A         cmp ah, $0a        ; lf
0132+  05B4 C6 2C 06      je _gets_end
0133+  05B7 76 0D         cmp ah, $0d        ; cr
0134+  05B9 C6 2C 06      je _gets_end
0135+  05BC 76 5C         cmp ah, $5c        ; '\\'
0136+  05BE C6 F2 05      je _gets_escape
0137+  05C1 76 08         cmp ah, $08      ; check for backspace
0138+  05C3 C6 CC 05      je _gets_backspace
0139+  05C6 1A            mov al, ah
0140+  05C7 3E            mov [d], al
0141+  05C8 79            inc d
0142+  05C9 0A A9 05      jmp _gets_loop
0143+  05CC             _gets_backspace:
0144+  05CC 7F            dec d
0145+  05CD 0A A9 05      jmp _gets_loop
0146+  05D0             _gets_ansi_esc:
0147+  05D0 19 01         mov al, 1
0148+  05D2 05 03         syscall sys_io        ; receive in ah without echo
0149+  05D4 76 5B         cmp ah, '['
0150+  05D6 C7 A9 05      jne _gets_loop
0151+  05D9 19 01         mov al, 1
0152+  05DB 05 03         syscall sys_io          ; receive in ah without echo
0153+  05DD 76 64         cmp ah, 'd'
0154+  05DF C6 EA 05      je _gets_left_arrow
0155+  05E2 76 63         cmp ah, 'c'
0156+  05E4 C6 EE 05      je _gets_right_arrow
0157+  05E7 0A A9 05      jmp _gets_loop
0158+  05EA             _gets_left_arrow:
0159+  05EA 7F            dec d
0160+  05EB 0A A9 05      jmp _gets_loop
0161+  05EE             _gets_right_arrow:
0162+  05EE 79            inc d
0163+  05EF 0A A9 05      jmp _gets_loop
0164+  05F2             _gets_escape:
0165+  05F2 19 01         mov al, 1
0166+  05F4 05 03         syscall sys_io      ; receive in ah
0167+  05F6 76 6E         cmp ah, 'n'
0168+  05F8 C6 17 06      je _gets_lf
0169+  05FB 76 72         cmp ah, 'r'
0170+  05FD C6 1E 06      je _gets_cr
0171+  0600 76 30         cmp ah, '0'
0172+  0602 C6 25 06      je _gets_null
0173+  0605 76 5C         cmp ah, $5c  ; '\'
0174+  0607 C6 10 06      je _gets_slash
0175+  060A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  060B 3E            mov [d], al
0177+  060C 79            inc d
0178+  060D 0A A9 05      jmp _gets_loop
0179+  0610             _gets_slash:
0180+  0610 19 5C         mov al, $5c
0181+  0612 3E            mov [d], al
0182+  0613 79            inc d
0183+  0614 0A A9 05      jmp _gets_loop
0184+  0617             _gets_lf:
0185+  0617 19 0A         mov al, $0a
0186+  0619 3E            mov [d], al
0187+  061A 79            inc d
0188+  061B 0A A9 05      jmp _gets_loop
0189+  061E             _gets_cr:
0190+  061E 19 0D         mov al, $0d
0191+  0620 3E            mov [d], al
0192+  0621 79            inc d
0193+  0622 0A A9 05      jmp _gets_loop
0194+  0625             _gets_null:
0195+  0625 19 00         mov al, $00
0196+  0627 3E            mov [d], al
0197+  0628 79            inc d
0198+  0629 0A A9 05      jmp _gets_loop
0199+  062C             _gets_end:
0200+  062C 19 00         mov al, 0
0201+  062E 3E            mov [d], al        ; terminate string
0202+  062F E7            pop d
0203+  0630 E4            pop a
0204+  0631 09            ret
0205+  0632             
0206+  0632             
0207+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0632             ;; input text
0209+  0632             ;; terminated with ctrl+d
0210+  0632             ;; pointer in d
0211+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0632             _gettxt:
0213+  0632 D7            push a
0214+  0633 DA            push d
0215+  0634             _gettxt_loop:
0216+  0634 19 01         mov al, 1
0217+  0636 05 03         syscall sys_io      ; receive in ah
0218+  0638 76 04         cmp ah, 4      ; eot
0219+  063A C6 73 06      je _gettxt_end
0220+  063D 76 08         cmp ah, $08      ; check for backspace
0221+  063F C6 6F 06      je _gettxt_backspace
0222+  0642 76 5C         cmp ah, $5c        ; '\'
0223+  0644 C6 4D 06      je _gettxt_escape
0224+  0647 1A            mov al, ah
0225+  0648 3E            mov [d], al
0226+  0649 79            inc d
0227+  064A 0A 34 06      jmp _gettxt_loop
0228+  064D             _gettxt_escape:
0229+  064D 19 01         mov al, 1
0230+  064F 05 03         syscall sys_io      ; receive in ah
0231+  0651 76 6E         cmp ah, 'n'
0232+  0653 C6 61 06      je _gettxt_lf
0233+  0656 76 72         cmp ah, 'r'
0234+  0658 C6 68 06      je _gettxt_cr
0235+  065B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  065C 3E            mov [d], al
0237+  065D 79            inc d
0238+  065E 0A 34 06      jmp _gettxt_loop
0239+  0661             _gettxt_lf:
0240+  0661 19 0A         mov al, $0a
0241+  0663 3E            mov [d], al
0242+  0664 79            inc d
0243+  0665 0A 34 06      jmp _gettxt_loop
0244+  0668             _gettxt_cr:
0245+  0668 19 0D         mov al, $0d
0246+  066A 3E            mov [d], al
0247+  066B 79            inc d
0248+  066C 0A 34 06      jmp _gettxt_loop
0249+  066F             _gettxt_backspace:
0250+  066F 7F            dec d
0251+  0670 0A 34 06      jmp _gettxt_loop
0252+  0673             _gettxt_end:
0253+  0673 19 00         mov al, 0
0254+  0675 3E            mov [d], al        ; terminate string
0255+  0676 E7            pop d
0256+  0677 E4            pop a
0257+  0678 09            ret
0258+  0679             
0259+  0679             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0679             ; print new line
0261+  0679             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0679             printnl:
0263+  0679 D7            push a
0264+  067A 10 00 0A      mov a, $0a00
0265+  067D 05 03         syscall sys_io
0266+  067F 10 00 0D      mov a, $0d00
0267+  0682 05 03         syscall sys_io
0268+  0684 E4            pop a
0269+  0685 09            ret
0270+  0686             
0271+  0686             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0686             ; _strtoint
0273+  0686             ; 4 digit hex string number in d
0274+  0686             ; integer returned in a
0275+  0686             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0686             _strtointx:
0277+  0686 D8            push b
0278+  0687 32            mov bl, [d]
0279+  0688 37            mov bh, bl
0280+  0689 33 01 00      mov bl, [d + 1]
0281+  068C 07 5D 05      call _atoi        ; convert to int in al
0282+  068F 23            mov ah, al        ; move to ah
0283+  0690 33 02 00      mov bl, [d + 2]
0284+  0693 37            mov bh, bl
0285+  0694 33 03 00      mov bl, [d + 3]
0286+  0697 07 5D 05      call _atoi        ; convert to int in al
0287+  069A E5            pop b
0288+  069B 09            ret
0289+  069C             
0290+  069C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  069C             ; _strtoint
0292+  069C             ; 5 digit base10 string number in d
0293+  069C             ; integer returned in a
0294+  069C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  069C             _strtoint:
0296+  069C E2            push si
0297+  069D D8            push b
0298+  069E D9            push c
0299+  069F DA            push d
0300+  06A0 07 FF 04      call _strlen      ; get string length in c
0301+  06A3 7E            dec c
0302+  06A4 FD 4E         mov si, d
0303+  06A6 12            mov a, c
0304+  06A7 FD 99         shl a
0305+  06A9 3B 20 08      mov d, table_power
0306+  06AC 59            add d, a
0307+  06AD 38 00 00      mov c, 0
0308+  06B0             _strtoint_l0:
0309+  06B0 F6            lodsb      ; load ascii to al
0310+  06B1 B9 00         cmp al, 0
0311+  06B3 C6 C6 06      je _strtoint_end
0312+  06B6 6F 30         sub al, $30    ; make into integer
0313+  06B8 22 00         mov ah, 0
0314+  06BA 2A            mov b, [d]
0315+  06BB AC            mul a, b      ; result in b since it fits in 16bits
0316+  06BC 11            mov a, b
0317+  06BD 28            mov b, c
0318+  06BE 54            add a, b
0319+  06BF 39            mov c, a
0320+  06C0 63 02 00      sub d, 2
0321+  06C3 0A B0 06      jmp _strtoint_l0
0322+  06C6             _strtoint_end:
0323+  06C6 12            mov a, c
0324+  06C7 E7            pop d
0325+  06C8 E6            pop c
0326+  06C9 E5            pop b
0327+  06CA EF            pop si
0328+  06CB 09            ret
0329+  06CC             
0330+  06CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  06CC             ; print null terminated string
0332+  06CC             ; pointer in d
0333+  06CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  06CC             _puts:
0335+  06CC D7            push a
0336+  06CD DA            push d
0337+  06CE             _puts_l1:
0338+  06CE 1E            mov al, [d]
0339+  06CF B9 00         cmp al, 0
0340+  06D1 C6 DD 06      jz _puts_end
0341+  06D4 23            mov ah, al
0342+  06D5 19 00         mov al, 0
0343+  06D7 05 03         syscall sys_io
0344+  06D9 79            inc d
0345+  06DA 0A CE 06      jmp _puts_l1
0346+  06DD             _puts_end:
0347+  06DD E7            pop d
0348+  06DE E4            pop a
0349+  06DF 09            ret
0350+  06E0             
0351+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  06E0             ; print n size string
0353+  06E0             ; pointer in d
0354+  06E0             ; size in c
0355+  06E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  06E0             _putsn:
0357+  06E0 DB            push al
0358+  06E1 DA            push d
0359+  06E2 D9            push c
0360+  06E3             _putsn_l0:
0361+  06E3 1E            mov al, [d]
0362+  06E4 23            mov ah, al
0363+  06E5 19 00         mov al, 0
0364+  06E7 05 03         syscall sys_io
0365+  06E9 79            inc d
0366+  06EA 7E            dec c  
0367+  06EB C2 00 00      cmp c, 0
0368+  06EE C7 E3 06      jne _putsn_l0
0369+  06F1             _putsn_end:
0370+  06F1 E6            pop c
0371+  06F2 E7            pop d
0372+  06F3 E8            pop al
0373+  06F4 09            ret
0374+  06F5             
0375+  06F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  06F5             ; print 16bit decimal number
0377+  06F5             ; input number in a
0378+  06F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06F5             print_u16d:
0380+  06F5 D7            push a
0381+  06F6 D8            push b
0382+  06F7 FD D8         push g
0383+  06F9 26 10 27      mov b, 10000
0384+  06FC AE            div a, b      ; get 10000's coeff.
0385+  06FD 07 21 07      call print_number
0386+  0700 11            mov a, b
0387+  0701 26 E8 03      mov b, 1000
0388+  0704 AE            div a, b      ; get 1000's coeff.
0389+  0705 07 21 07      call print_number
0390+  0708 11            mov a, b
0391+  0709 26 64 00      mov b, 100
0392+  070C AE            div a, b
0393+  070D 07 21 07      call print_number
0394+  0710 11            mov a, b
0395+  0711 26 0A 00      mov b, 10
0396+  0714 AE            div a, b
0397+  0715 07 21 07      call print_number
0398+  0718 1B            mov al, bl      ; 1's coeff in bl
0399+  0719 07 21 07      call print_number
0400+  071C FD F1         pop g
0401+  071E E5            pop b
0402+  071F E4            pop a
0403+  0720 09            ret
0404+  0721             
0405+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0721             ; print al
0407+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0721             print_number:
0409+  0721 6A 30         add al, $30
0410+  0723 23            mov ah, al
0411+  0724 07 A0 05      call _putchar
0412+  0727 09            ret
0413+  0728             
0414+  0728             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0728             ; print 16bit hex integer
0416+  0728             ; integer value in reg b
0417+  0728             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0728             print_u16x:
0419+  0728 D7            push a
0420+  0729 D8            push b
0421+  072A DD            push bl
0422+  072B 30            mov bl, bh
0423+  072C 07 6E 05      call _itoa        ; convert bh to char in a
0424+  072F 2F            mov bl, al        ; save al
0425+  0730 19 00         mov al, 0
0426+  0732 05 03         syscall sys_io        ; display ah
0427+  0734 24            mov ah, bl        ; retrieve al
0428+  0735 19 00         mov al, 0
0429+  0737 05 03         syscall sys_io        ; display al
0430+  0739             
0431+  0739 EA            pop bl
0432+  073A 07 6E 05      call _itoa        ; convert bh to char in a
0433+  073D 2F            mov bl, al        ; save al
0434+  073E 19 00         mov al, 0
0435+  0740 05 03         syscall sys_io        ; display ah
0436+  0742 24            mov ah, bl        ; retrieve al
0437+  0743 19 00         mov al, 0
0438+  0745 05 03         syscall sys_io        ; display al
0439+  0747             
0440+  0747 E5            pop b
0441+  0748 E4            pop a
0442+  0749 09            ret
0443+  074A             
0444+  074A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  074A             ; input 16bit hex integer
0446+  074A             ; read 16bit integer into a
0447+  074A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  074A             scan_u16x:
0449+  074A F8 10 00      enter 16
0450+  074D D8            push b
0451+  074E DA            push d
0452+  074F             
0453+  074F FA F1 FF      lea d, [bp + -15]
0454+  0752 07 A7 05      call _gets        ; get number
0455+  0755             
0456+  0755 32            mov bl, [d]
0457+  0756 37            mov bh, bl
0458+  0757 33 01 00      mov bl, [d + 1]
0459+  075A 07 5D 05      call _atoi        ; convert to int in al
0460+  075D 23            mov ah, al        ; move to ah
0461+  075E             
0462+  075E 33 02 00      mov bl, [d + 2]
0463+  0761 37            mov bh, bl
0464+  0762 33 03 00      mov bl, [d + 3]
0465+  0765 07 5D 05      call _atoi        ; convert to int in al
0466+  0768             
0467+  0768 E7            pop d
0468+  0769 E5            pop b
0469+  076A F9            leave
0470+  076B 09            ret
0471+  076C             
0472+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  076C             ; print 8bit hex integer
0474+  076C             ; integer value in reg bl
0475+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  076C             print_u8x:
0477+  076C D7            push a
0478+  076D DD            push bl
0479+  076E             
0480+  076E 07 6E 05      call _itoa        ; convert bl to char in a
0481+  0771 2F            mov bl, al        ; save al
0482+  0772 19 00         mov al, 0
0483+  0774 05 03         syscall sys_io        ; display ah
0484+  0776 24            mov ah, bl        ; retrieve al
0485+  0777 19 00         mov al, 0
0486+  0779 05 03         syscall sys_io        ; display al
0487+  077B             
0488+  077B EA            pop bl
0489+  077C E4            pop a
0490+  077D 09            ret
0491+  077E             
0492+  077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  077E             ; print 8bit decimal unsigned number
0494+  077E             ; input number in al
0495+  077E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  077E             print_u8d:
0497+  077E D7            push a
0498+  077F D8            push b
0499+  0780 FD D8         push g
0500+  0782 22 00         mov ah, 0
0501+  0784 26 64 00      mov b, 100
0502+  0787 AE            div a, b
0503+  0788 D8            push b      ; save remainder
0504+  0789 B9 00         cmp al, 0
0505+  078B C6 95 07      je skip100
0506+  078E 6A 30         add al, $30
0507+  0790 23            mov ah, al
0508+  0791 19 00         mov al, 0
0509+  0793 05 03         syscall sys_io  ; print coeff
0510+  0795             skip100:
0511+  0795 E4            pop a
0512+  0796 22 00         mov ah, 0
0513+  0798 26 0A 00      mov b, 10
0514+  079B AE            div a, b
0515+  079C D8            push b      ; save remainder
0516+  079D B9 00         cmp al, 0
0517+  079F C6 A9 07      je skip10
0518+  07A2 6A 30         add al, $30
0519+  07A4 23            mov ah, al
0520+  07A5 19 00         mov al, 0
0521+  07A7 05 03         syscall sys_io  ; print coeff
0522+  07A9             skip10:
0523+  07A9 E4            pop a
0524+  07AA 1B            mov al, bl
0525+  07AB 6A 30         add al, $30
0526+  07AD 23            mov ah, al
0527+  07AE 19 00         mov al, 0
0528+  07B0 05 03         syscall sys_io  ; print coeff
0529+  07B2 FD F1         pop g
0530+  07B4 E5            pop b
0531+  07B5 E4            pop a
0532+  07B6 09            ret
0533+  07B7             
0534+  07B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  07B7             ; input 8bit hex integer
0536+  07B7             ; read 8bit integer into al
0537+  07B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  07B7             scan_u8x:
0539+  07B7 F8 04 00      enter 4
0540+  07BA D8            push b
0541+  07BB DA            push d
0542+  07BC             
0543+  07BC FA FD FF      lea d, [bp + -3]
0544+  07BF 07 A7 05      call _gets        ; get number
0545+  07C2             
0546+  07C2 32            mov bl, [d]
0547+  07C3 37            mov bh, bl
0548+  07C4 33 01 00      mov bl, [d + 1]
0549+  07C7 07 5D 05      call _atoi        ; convert to int in al
0550+  07CA             
0551+  07CA E7            pop d
0552+  07CB E5            pop b
0553+  07CC F9            leave
0554+  07CD 09            ret
0555+  07CE             
0556+  07CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  07CE             ; input decimal number
0558+  07CE             ; result in a
0559+  07CE             ; 655'\0'
0560+  07CE             ; low--------high
0561+  07CE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  07CE             scan_u16d:
0563+  07CE F8 08 00      enter 8
0564+  07D1 E2            push si
0565+  07D2 D8            push b
0566+  07D3 D9            push c
0567+  07D4 DA            push d
0568+  07D5 FA F9 FF      lea d, [bp +- 7]
0569+  07D8 07 A7 05      call _gets
0570+  07DB 07 FF 04      call _strlen      ; get string length in c
0571+  07DE 7E            dec c
0572+  07DF FD 4E         mov si, d
0573+  07E1 12            mov a, c
0574+  07E2 FD 99         shl a
0575+  07E4 3B 20 08      mov d, table_power
0576+  07E7 59            add d, a
0577+  07E8 38 00 00      mov c, 0
0578+  07EB             mul_loop:
0579+  07EB F6            lodsb      ; load ascii to al
0580+  07EC B9 00         cmp al, 0
0581+  07EE C6 01 08      je mul_exit
0582+  07F1 6F 30         sub al, $30    ; make into integer
0583+  07F3 22 00         mov ah, 0
0584+  07F5 2A            mov b, [d]
0585+  07F6 AC            mul a, b      ; result in b since it fits in 16bits
0586+  07F7 11            mov a, b
0587+  07F8 28            mov b, c
0588+  07F9 54            add a, b
0589+  07FA 39            mov c, a
0590+  07FB 63 02 00      sub d, 2
0591+  07FE 0A EB 07      jmp mul_loop
0592+  0801             mul_exit:
0593+  0801 12            mov a, c
0594+  0802 E7            pop d
0595+  0803 E6            pop c
0596+  0804 E5            pop b
0597+  0805 EF            pop si
0598+  0806 F9            leave
0599+  0807 09            ret
0600+  0808             
0601+  0808             
0602+  0808 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  080C 34 35 36 37 
0602+  0810 38 39 61 62 
0602+  0814 63 64 65 66 
0603+  0818 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  081C 1B 5B 68 00 
0604+  0820             
0605+  0820             table_power:
0606+  0820 01 00         .dw 1
0607+  0822 0A 00         .dw 10
0608+  0824 64 00         .dw 100
0609+  0826 E8 03         .dw 1000
0610+  0828 10 27         .dw 100001084   082A             .include "lib/ctype.asm"
0001+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  082A             ; ctype.s
0003+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  082A             
0005+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  082A             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  082A             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  082A             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  082A             ;; characters are supported.
0010+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  082A             ;; _isalnum 
0012+  082A             ;; _isalpha 
0013+  082A             ;; islower 
0014+  082A             ;; isupper 
0015+  082A             ;; _isdigit 
0016+  082A             ;; isxdigit
0017+  082A             ;; iscntrl 
0018+  082A             ;; isgraph 
0019+  082A             ;; _isspace 
0020+  082A             ;; isblank 
0021+  082A             ;; isprint 
0022+  082A             ;; ispunct 
0023+  082A             ;; tolower 
0024+  082A             ;; toupper
0025+  082A             
0026+  082A             
0027+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  082A             ;; is alphanumeric
0029+  082A             ;; sets zf according with result
0030+  082A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  082A             _isalnum:
0032+  082A 07 47 08    	call _isalpha
0033+  082D C6 33 08    	je _isalnum_exit
0034+  0830 07 34 08    	call _isdigit
0035+  0833             _isalnum_exit:
0036+  0833 09          	ret	
0037+  0834             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0834             ;; is digit
0039+  0834             ;; sets zf according with result
0040+  0834             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0834             _isdigit:
0042+  0834 DB          	push al
0043+  0835 B9 30       	cmp al, '0'
0044+  0837 C8 43 08    	jlu _isdigit_false
0045+  083A B9 39       	cmp al, '9'
0046+  083C D1 43 08    	jgu _isdigit_false
0047+  083F 87 00       	and al, 0	; set zf
0048+  0841 E8          	pop al
0049+  0842 09          	ret
0050+  0843             _isdigit_false:
0051+  0843 8B 01       	or al, 1	; clear zf
0052+  0845 E8          	pop al
0053+  0846 09          	ret	
0054+  0847             	
0055+  0847             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0847             ;; is alpha
0057+  0847             ;; sets zf according with result
0058+  0847             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0847             _isalpha:
0060+  0847 DB          	push al
0061+  0848 B9 5F       	cmp al, '_'
0062+  084A C6 6A 08    	je _isalpha_true
0063+  084D B9 2E       	cmp al, '.'
0064+  084F C6 6A 08    	je _isalpha_true
0065+  0852 B9 61       	cmp al, 'a'
0066+  0854 C8 66 08    	jlu _isalpha_false
0067+  0857 B9 7A       	cmp al, 'z'
0068+  0859 D1 66 08    	jgu _isalpha_false
0069+  085C B9 7A       	cmp al, 'z'
0070+  085E D0 6A 08    	jleu _isalpha_true
0071+  0861 B9 61       	cmp al, 'a'
0072+  0863 C9 6A 08    	jgeu _isalpha_true
0073+  0866             _isalpha_false:
0074+  0866 8B 01       	or al, 1	; clear zf
0075+  0868 E8          	pop al
0076+  0869 09          	ret
0077+  086A             _isalpha_true:
0078+  086A 87 00       	and al, 0	; set zf
0079+  086C E8          	pop al
0080+  086D 09          	ret
0081+  086E             
0082+  086E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  086E             ;; is path-alpha
0084+  086E             ;; sets zf according with result
0085+  086E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  086E             ispath:
0087+  086E DB          	push al
0088+  086F 07 34 08    	call _isdigit
0089+  0872 C6 9C 08    	je ispath_true
0090+  0875 B9 5F       	cmp al, '_'
0091+  0877 C6 9C 08    	je ispath_true
0092+  087A B9 2F       	cmp al, '/'
0093+  087C C6 9C 08    	je ispath_true
0094+  087F B9 2E       	cmp al, '.'
0095+  0881 C6 9C 08    	je ispath_true
0096+  0884 B9 61       	cmp al, 'a'
0097+  0886 C8 98 08    	jlu ispath_false
0098+  0889 B9 7A       	cmp al, 'z'
0099+  088B D1 98 08    	jgu ispath_false
0100+  088E B9 7A       	cmp al, 'z'
0101+  0890 D0 9C 08    	jleu ispath_true
0102+  0893 B9 61       	cmp al, 'a'
0103+  0895 C9 9C 08    	jgeu ispath_true
0104+  0898             ispath_false:
0105+  0898 8B 01       	or al, 1	; clear zf
0106+  089A E8          	pop al
0107+  089B 09          	ret
0108+  089C             ispath_true:
0109+  089C 87 00       	and al, 0	; set zf
0110+  089E E8          	pop al
0111+  089F 09          	ret
0112+  08A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  08A0             ;; is space
0114+  08A0             ;; sets zf according with result
0115+  08A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  08A0             _isspace:
0117+  08A0 B9 20       	cmp al, $20		; ' '
0118+  08A2 C6 B6 08    	je _isspace_exit
0119+  08A5 B9 09       	cmp al, $09		; '\t'
0120+  08A7 C6 B6 08    	je _isspace_exit
0121+  08AA B9 0A       	cmp al, $0a		; '\n'
0122+  08AC C6 B6 08    	je _isspace_exit
0123+  08AF B9 0D       	cmp al, $0d		; '\r'
0124+  08B1 C6 B6 08    	je _isspace_exit
0125+  08B4 B9 0B       	cmp al, $0b		; '\v'
0126+  08B6             _isspace_exit:
0127+  08B6 09          	ret	
0128+  08B7             
0129+  08B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08B7             ; to lower
0131+  08B7             ; input in al
0132+  08B7             ; output in al
0133+  08B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  08B7             _to_lower:
0135+  08B7 B9 7A       	cmp al, 'z'
0136+  08B9 D1 BE 08    	jgu _to_lower_ret
0137+  08BC 6A 20       	add al, $20				; convert to lower case
0138+  08BE             _to_lower_ret:
0139+  08BE 09          	ret
0140+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  08BF             ; to upper
0142+  08BF             ; input in al
0143+  08BF             ; output in al
0144+  08BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  08BF             _to_upper:
0146+  08BF B9 61       	cmp al, 'a'
0147+  08C1 C8 C6 08    	jlu _to_upper_ret
0148+  08C4 6F 20       	sub al, $20			; convert to upper case
0149+  08C6             _to_upper_ret:
0150+  08C6 09          	ret
0151+  08C7             
1085   08C7             .include "lib/token.asm"
0001+  08C7             toktyp_identifier  .equ 0
0002+  08C7             toktyp_keyword     .equ 1
0003+  08C7             toktyp_delimiter   .equ 2
0004+  08C7             toktyp_string      .equ 3
0005+  08C7             toktyp_char        .equ 4
0006+  08C7             toktyp_numeric     .equ 5
0007+  08C7             toktyp_end         .equ 6
0008+  08C7             
0009+  08C7             tok_null           .equ 0
0010+  08C7             tok_fslash         .equ 1
0011+  08C7             tok_times          .equ 2
0012+  08C7             tok_plus           .equ 3
0013+  08C7             tok_minus          .equ 4
0014+  08C7             tok_dot            .equ 5
0015+  08C7             tok_semi           .equ 6
0016+  08C7             tok_angle          .equ 7
0017+  08C7             tok_tilde          .equ 8
0018+  08C7             tok_equal          .equ 9
0019+  08C7             tok_colon          .equ 10
0020+  08C7             tok_comma          .equ 11
0021+  08C7             
0022+  08C7             tok_end            .equ 20
0023+  08C7             
0024+  08C7             
0025+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  08C7             ;; read a full command argment from shell input buffer
0027+  08C7             ;; argument is written into tokstr
0028+  08C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  08C7             get_arg:
0030+  08C7 D7            push a
0031+  08C8 E2            push si
0032+  08C9 E3            push di
0033+  08CA 19 00         mov al, 0
0034+  08CC 3D F5 0A      mov [tokstr], al      ; nullify tokstr string
0035+  08CF 14 F1 0A      mov a, [prog]
0036+  08D2 4D            mov si, a
0037+  08D3 FD 4F F5 0A   mov di, tokstr
0038+  08D7             get_arg_skip_spaces:
0039+  08D7 F6            lodsb
0040+  08D8 07 A0 08      call _isspace
0041+  08DB C6 D7 08      je get_arg_skip_spaces
0042+  08DE             get_arg_l0:
0043+  08DE B9 3B         cmp al, $3b        ; check if is ';'
0044+  08E0 C6 ED 08      je get_arg_end
0045+  08E3 B9 00         cmp al, 0
0046+  08E5 C6 ED 08      je get_arg_end      ; check if end of input
0047+  08E8 F7            stosb
0048+  08E9 F6            lodsb
0049+  08EA 0A DE 08      jmp get_arg_l0
0050+  08ED             get_arg_end:
0051+  08ED 19 00         mov al, 0
0052+  08EF F7            stosb
0053+  08F0 D5 01 00      sub si, 1
0054+  08F3 4E            mov a, si
0055+  08F4 42 F1 0A      mov [prog], a    ; update pointer
0056+  08F7 F0            pop di
0057+  08F8 EF            pop si
0058+  08F9 E4            pop a
0059+  08FA 09            ret
0060+  08FB             
0061+  08FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  08FB             ;; read a path formation from shell input buffer
0063+  08FB             ;; path is written into tokstr
0064+  08FB             ;; /usr/bin
0065+  08FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  08FB             get_path:
0067+  08FB D7            push a
0068+  08FC E2            push si
0069+  08FD E3            push di
0070+  08FE 19 00         mov al, 0
0071+  0900 3D F5 0A      mov [tokstr], al      ; nullify tokstr string
0072+  0903 14 F1 0A      mov a, [prog]
0073+  0906 4D            mov si, a
0074+  0907 FD 4F F5 0A   mov di, tokstr
0075+  090B             get_path_skip_spaces:
0076+  090B F6            lodsb
0077+  090C 07 A0 08      call _isspace
0078+  090F C6 0B 09      je get_path_skip_spaces
0079+  0912             get_path_is_pathchar:
0080+  0912 F7            stosb
0081+  0913 F6            lodsb
0082+  0914 07 2A 08      call _isalnum      ;check if is alphanumeric
0083+  0917 C6 12 09      je get_path_is_pathchar
0084+  091A B9 2F         cmp al, '/'        ; check if is '/'
0085+  091C C6 12 09      je get_path_is_pathchar
0086+  091F 19 00         mov al, 0
0087+  0921 F7            stosb
0088+  0922 D5 01 00      sub si, 1
0089+  0925 4E            mov a, si
0090+  0926 42 F1 0A      mov [prog], a    ; update pointer
0091+  0929             get_path_end:
0092+  0929 F0            pop di
0093+  092A EF            pop si
0094+  092B E4            pop a
0095+  092C 09            ret
0096+  092D             
0097+  092D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  092D             ;; read a line
0099+  092D             ;; line is written into tokstr
0100+  092D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  092D             get_line:
0102+  092D D7            push a
0103+  092E E2            push si
0104+  092F E3            push di
0105+  0930 19 00         mov al, 0
0106+  0932 3D F5 0A      mov [tokstr], al      ; nullify tokstr string
0107+  0935 14 F1 0A      mov a, [prog]
0108+  0938 4D            mov si, a
0109+  0939 FD 4F F5 0A   mov di, tokstr
0110+  093D             get_line_l0:
0111+  093D F6            lodsb
0112+  093E B9 0A         cmp al, $0a    ; check for new line
0113+  0940 C6 47 09      je get_line_exit
0114+  0943 F7            stosb
0115+  0944 0A 3D 09      jmp get_line_l0
0116+  0947             get_line_exit:
0117+  0947 19 00         mov al, 0
0118+  0949 F7            stosb
0119+  094A 4E            mov a, si
0120+  094B 42 F1 0A      mov [prog], a    ; update pointer
0121+  094E F0            pop di
0122+  094F EF            pop si
0123+  0950 E4            pop a
0124+  0951 09            ret
0125+  0952             
0126+  0952             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  0952             ;; token parser
0128+  0952             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  0952             get_token:
0130+  0952 D7            push a
0131+  0953 DA            push d
0132+  0954 E2            push si
0133+  0955 E3            push di
0134+  0956 19 00         mov al, 0
0135+  0958 3D F5 0A      mov [tokstr], al      ; nullify tokstr string
0136+  095B 19 00         mov al, tok_null
0137+  095D 3D F4 0A      mov [tok], al        ; nullify token
0138+  0960 14 F1 0A      mov a, [prog]
0139+  0963 4D            mov si, a
0140+  0964 FD 4F F5 0A   mov di, tokstr
0141+  0968             get_tok_skip_spaces:
0142+  0968 F6            lodsb
0143+  0969 07 A0 08      call _isspace
0144+  096C C6 68 09      je get_tok_skip_spaces
0145+  096F B9 00         cmp al, 0      ; check for end of input (null)
0146+  0971 C6 56 0A      je get_token_end
0147+  0974 B9 23         cmp al, '#'      ; comments!
0148+  0976 C6 84 0A      je get_tok_comment
0149+  0979 07 2A 08      call _isalnum
0150+  097C C6 63 0A      jz is_alphanumeric
0151+  097F             ; other token types
0152+  097F             get_token_slash:
0153+  097F B9 2F         cmp al, '/'        ; check if '/'
0154+  0981 C7 99 09      jne get_token_minus
0155+  0984 F7            stosb          ; store '/' into token string
0156+  0985 19 00         mov al, 0
0157+  0987 F7            stosb          ; terminate token string
0158+  0988 19 01         mov al, tok_fslash
0159+  098A 3D F4 0A      mov [tok], al      
0160+  098D 19 02         mov al, toktyp_delimiter
0161+  098F 3D F3 0A      mov [toktyp], al
0162+  0992 4E            mov a, si
0163+  0993 42 F1 0A      mov [prog], a    ; update pointer
0164+  0996 0A 7F 0A      jmp get_token_return
0165+  0999             get_token_minus:
0166+  0999 B9 2D         cmp al, '-'        ; check if '-'
0167+  099B C7 B3 09      jne get_token_comma
0168+  099E F7            stosb          ; store '-' into token string
0169+  099F 19 00         mov al, 0
0170+  09A1 F7            stosb          ; terminate token string
0171+  09A2 19 04         mov al, tok_minus
0172+  09A4 3D F4 0A      mov [tok], al      
0173+  09A7 19 02         mov al, toktyp_delimiter
0174+  09A9 3D F3 0A      mov [toktyp], al
0175+  09AC 4E            mov a, si
0176+  09AD 42 F1 0A      mov [prog], a    ; update pointer
0177+  09B0 0A 7F 0A      jmp get_token_return
0178+  09B3             get_token_comma:
0179+  09B3 B9 2C         cmp al, ','        ; check if ','
0180+  09B5 C7 CD 09      jne get_token_semi
0181+  09B8 F7            stosb          ; store ',' into token string
0182+  09B9 19 00         mov al, 0
0183+  09BB F7            stosb          ; terminate token string
0184+  09BC 19 0B         mov al, tok_comma
0185+  09BE 3D F4 0A      mov [tok], al      
0186+  09C1 19 02         mov al, toktyp_delimiter
0187+  09C3 3D F3 0A      mov [toktyp], al
0188+  09C6 4E            mov a, si
0189+  09C7 42 F1 0A      mov [prog], a    ; update pointer
0190+  09CA 0A 7F 0A      jmp get_token_return
0191+  09CD             get_token_semi:
0192+  09CD B9 3B         cmp al, $3b        ; check if ';'
0193+  09CF C7 E7 09      jne get_token_colon
0194+  09D2 F7            stosb          ; store ';' into token string
0195+  09D3 19 00         mov al, 0
0196+  09D5 F7            stosb          ; terminate token string
0197+  09D6 19 06         mov al, tok_semi
0198+  09D8 3D F4 0A      mov [tok], al      
0199+  09DB 19 02         mov al, toktyp_delimiter
0200+  09DD 3D F3 0A      mov [toktyp], al
0201+  09E0 4E            mov a, si
0202+  09E1 42 F1 0A      mov [prog], a    ; update pointer
0203+  09E4 0A 7F 0A      jmp get_token_return
0204+  09E7             get_token_colon:
0205+  09E7 B9 3A         cmp al, $3a        ; check if ':'
0206+  09E9 C7 01 0A      jne get_token_angle
0207+  09EC F7            stosb          ; store ':' into token string
0208+  09ED 19 00         mov al, 0
0209+  09EF F7            stosb          ; terminate token string
0210+  09F0 19 0A         mov al, tok_colon
0211+  09F2 3D F4 0A      mov [tok], al      
0212+  09F5 19 02         mov al, toktyp_delimiter
0213+  09F7 3D F3 0A      mov [toktyp], al
0214+  09FA 4E            mov a, si
0215+  09FB 42 F1 0A      mov [prog], a    ; update pointer
0216+  09FE 0A 7F 0A      jmp get_token_return
0217+  0A01             get_token_angle:
0218+  0A01 B9 3E         cmp al, $3e        ; check if '>'
0219+  0A03 C7 1B 0A      jne get_token_tilde
0220+  0A06 F7            stosb          ; store '>' into token string
0221+  0A07 19 00         mov al, 0
0222+  0A09 F7            stosb          ; terminate token string
0223+  0A0A 19 07         mov al, tok_angle
0224+  0A0C 3D F4 0A      mov [tok], al      
0225+  0A0F 19 02         mov al, toktyp_delimiter
0226+  0A11 3D F3 0A      mov [toktyp], al
0227+  0A14 4E            mov a, si
0228+  0A15 42 F1 0A      mov [prog], a    ; update pointer
0229+  0A18 0A 7F 0A      jmp get_token_return
0230+  0A1B             get_token_tilde:
0231+  0A1B B9 7E         cmp al, '~'        ; check if '~'
0232+  0A1D C7 35 0A      jne get_token_equal
0233+  0A20 F7            stosb          ; store '~' into token string
0234+  0A21 19 00         mov al, 0
0235+  0A23 F7            stosb          ; terminate token string
0236+  0A24 19 08         mov al, tok_tilde
0237+  0A26 3D F4 0A      mov [tok], al      
0238+  0A29 19 02         mov al, toktyp_delimiter
0239+  0A2B 3D F3 0A      mov [toktyp], al
0240+  0A2E 4E            mov a, si
0241+  0A2F 42 F1 0A      mov [prog], a    ; update pointer
0242+  0A32 0A 7F 0A      jmp get_token_return
0243+  0A35             get_token_equal:
0244+  0A35 B9 3D         cmp al, '='        ; check if '='
0245+  0A37 C7 4F 0A      jne get_token_skip
0246+  0A3A F7            stosb          ; store '=' into token string
0247+  0A3B 19 00         mov al, 0
0248+  0A3D F7            stosb          ; terminate token string
0249+  0A3E 19 09         mov al, tok_equal
0250+  0A40 3D F4 0A      mov [tok], al      
0251+  0A43 19 02         mov al, toktyp_delimiter
0252+  0A45 3D F3 0A      mov [toktyp], al
0253+  0A48 4E            mov a, si
0254+  0A49 42 F1 0A      mov [prog], a    ; update pointer
0255+  0A4C 0A 7F 0A      jmp get_token_return
0256+  0A4F             get_token_skip:
0257+  0A4F 4E            mov a, si
0258+  0A50 42 F1 0A      mov [prog], a    ; update pointer
0259+  0A53 0A 7F 0A      jmp get_token_return
0260+  0A56             get_token_end:        ; end of file token
0261+  0A56 19 14         mov al, tok_end
0262+  0A58 3D F4 0A      mov [tok], al
0263+  0A5B 19 06         mov al, toktyp_end
0264+  0A5D 3D F3 0A      mov [toktyp], al
0265+  0A60 0A 7F 0A      jmp get_token_return
0266+  0A63             is_alphanumeric:
0267+  0A63 F7            stosb
0268+  0A64 F6            lodsb
0269+  0A65 07 2A 08      call _isalnum      ;check if is alphanumeric
0270+  0A68 C6 63 0A      jz is_alphanumeric
0271+  0A6B B9 2E         cmp al, $2e        ; check if is '.'
0272+  0A6D C6 63 0A      je is_alphanumeric
0273+  0A70 19 00         mov al, 0
0274+  0A72 F7            stosb
0275+  0A73 19 00         mov al, toktyp_identifier
0276+  0A75 3D F3 0A      mov [toktyp], al
0277+  0A78 D5 01 00      sub si, 1
0278+  0A7B 4E            mov a, si
0279+  0A7C 42 F1 0A      mov [prog], a    ; update pointer
0280+  0A7F             get_token_return:
0281+  0A7F F0            pop di
0282+  0A80 EF            pop si
0283+  0A81 E7            pop d
0284+  0A82 E4            pop a
0285+  0A83 09            ret
0286+  0A84             get_tok_comment:
0287+  0A84 F6            lodsb
0288+  0A85 B9 0A         cmp al, $0a      ; new line
0289+  0A87 C7 84 0A      jne get_tok_comment
0290+  0A8A 0A 68 09      jmp get_tok_skip_spaces
0291+  0A8D             
0292+  0A8D             
0293+  0A8D             get_number:
0294+  0A8D D7            push a
0295+  0A8E DA            push d
0296+  0A8F E2            push si
0297+  0A90 E3            push di
0298+  0A91 19 00         mov al, 0
0299+  0A93 3D F5 0A      mov [tokstr], al      ; nullify tokstr string
0300+  0A96 19 00         mov al, tok_null
0301+  0A98 3D F4 0A      mov [tok], al        ; nullify token
0302+  0A9B 14 F1 0A      mov a, [prog]
0303+  0A9E 4D            mov si, a
0304+  0A9F FD 4F F5 0A   mov di, tokstr
0305+  0AA3             get_number_skip_spaces:
0306+  0AA3 F6            lodsb
0307+  0AA4 07 A0 08      call _isspace
0308+  0AA7 C6 A3 0A      je get_number_skip_spaces
0309+  0AAA B9 00         cmp al, 0      ; check for end of input (null)
0310+  0AAC C7 BC 0A      jne get_number_l0
0311+  0AAF 19 14         mov al, tok_end
0312+  0AB1 3D F4 0A      mov [tok], al
0313+  0AB4 19 06         mov al, toktyp_end
0314+  0AB6 3D F3 0A      mov [toktyp], al
0315+  0AB9 0A D3 0A      jmp get_number_return
0316+  0ABC             get_number_l0:
0317+  0ABC F7            stosb
0318+  0ABD F6            lodsb
0319+  0ABE 07 34 08      call _isdigit      ;check if is numeric
0320+  0AC1 C6 BC 0A      jz get_number_l0
0321+  0AC4 19 00         mov al, 0
0322+  0AC6 F7            stosb
0323+  0AC7 19 05         mov al, toktyp_numeric
0324+  0AC9 3D F3 0A      mov [toktyp], al
0325+  0ACC D5 01 00      sub si, 1
0326+  0ACF 4E            mov a, si
0327+  0AD0 42 F1 0A      mov [prog], a    ; update pointer
0328+  0AD3             get_number_return:
0329+  0AD3 F0            pop di
0330+  0AD4 EF            pop si
0331+  0AD5 E7            pop d
0332+  0AD6 E4            pop a
0333+  0AD7 09            ret
0334+  0AD8             
0335+  0AD8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  0AD8             ;; put back token
0337+  0AD8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  0AD8             _putback:
0339+  0AD8 D7            push a
0340+  0AD9 E2            push si
0341+  0ADA FD 4D F5 0A   mov si, tokstr  
0342+  0ADE             _putback_loop:
0343+  0ADE F6            lodsb
0344+  0ADF B9 00         cmp al, 0
0345+  0AE1 C6 EE 0A      je _putback_end
0346+  0AE4 14 F1 0A      mov a, [prog]
0347+  0AE7 7D            dec a
0348+  0AE8 42 F1 0A      mov [prog], a      ; update pointer
0349+  0AEB 0A DE 0A      jmp _putback_loop
0350+  0AEE             _putback_end:
0351+  0AEE EF            pop si
0352+  0AEF E4            pop a
0353+  0AF0 09            ret
0354+  0AF1             
0355+  0AF1             
0356+  0AF1             
0357+  0AF1             
0358+  0AF1 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  0AF3             
0360+  0AF3 00          toktyp:    .db 0          ; token type symbol
0361+  0AF4 00          tok:       .db 0          ; current token symbol
0362+  0AF5 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  0AF9 00 00 00 00 
0362+  0AFD 00 00 00 00 
0362+  0B01 00 00 00 00 
0362+  0B05 00 00 00 00 
0362+  0B09 00 00 00 00 
0362+  0B0D 00 00 00 00 
0362+  0B11 00 00 00 00 
0362+  0B15 00 00 00 00 
0362+  0B19 00 00 00 00 
0362+  0B1D 00 00 00 00 
0362+  0B21 00 00 00 00 
0362+  0B25 00 00 00 00 
0362+  0B29 00 00 00 00 
0362+  0B2D 00 00 00 00 
0362+  0B31 00 00 00 00 
0362+  0B35 00 00 00 00 
0362+  0B39 00 00 00 00 
0362+  0B3D 00 00 00 00 
0362+  0B41 00 00 00 00 
0362+  0B45 00 00 00 00 
0362+  0B49 00 00 00 00 
0362+  0B4D 00 00 00 00 
0362+  0B51 00 00 00 00 
0362+  0B55 00 00 00 00 
0362+  0B59 00 00 00 00 
0362+  0B5D 00 00 00 00 
0362+  0B61 00 00 00 00 
0362+  0B65 00 00 00 00 
0362+  0B69 00 00 00 00 
0362+  0B6D 00 00 00 00 
0362+  0B71 00 00 00 00 
0362+  0B75 00 00 00 00 
0362+  0B79 00 00 00 00 
0362+  0B7D 00 00 00 00 
0362+  0B81 00 00 00 00 
0362+  0B85 00 00 00 00 
0362+  0B89 00 00 00 00 
0362+  0B8D 00 00 00 00 
0362+  0B91 00 00 00 00 
0362+  0B95 00 00 00 00 
0362+  0B99 00 00 00 00 
0362+  0B9D 00 00 00 00 
0362+  0BA1 00 00 00 00 
0362+  0BA5 00 00 00 00 
0362+  0BA9 00 00 00 00 
0362+  0BAD 00 00 00 00 
0362+  0BB1 00 00 00 00 
0362+  0BB5 00 00 00 00 
0362+  0BB9 00 00 00 00 
0362+  0BBD 00 00 00 00 
0362+  0BC1 00 00 00 00 
0362+  0BC5 00 00 00 00 
0362+  0BC9 00 00 00 00 
0362+  0BCD 00 00 00 00 
0362+  0BD1 00 00 00 00 
0362+  0BD5 00 00 00 00 
0362+  0BD9 00 00 00 00 
0362+  0BDD 00 00 00 00 
0362+  0BE1 00 00 00 00 
0362+  0BE5 00 00 00 00 
0362+  0BE9 00 00 00 00 
0362+  0BED 00 00 00 00 
0362+  0BF1 00 00 00 00 
1086   0BF5             
1087   0BF5             
1088   0BF5             ; kernel parameters
1089   0BF5             ; baud  divisor
1090   0BF5             ; 50    2304
1091   0BF5             ; 110   1047
1092   0BF5             ; 300    384
1093   0BF5             ; 600    192
1094   0BF5             ; 1200    96
1095   0BF5             ; 9600    12
1096   0BF5             ; 19200    6
1097   0BF5             ; 38400    3
1098   0BF5             sys_uart0_lcr:
1099   0BF5 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1100   0BF6             sys_uart0_inten:
1101   0BF6 01            .db 1
1102   0BF7             sys_uart0_fifoen:
1103   0BF7 00            .db 0
1104   0BF8             sys_uart0_div0:
1105   0BF8 03            .db 3
1106   0BF9             sys_uart0_div1:
1107   0BF9 00            .db 0   ; default baud = 38400
1108   0BFA             
1109   0BFA             sys_uart1_lcr:
1110   0BFA 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, even parity
1111   0BFB             sys_uart1_inten:
1112   0BFB 01            .db 1
1113   0BFC             sys_uart1_fifoen:
1114   0BFC 00            .db 0
1115   0BFD             sys_uart1_div0:
1116   0BFD 03            .db 3
1117   0BFE             sys_uart1_div1:
1118   0BFE 00            .db 0   ; default baud = 38400
1119   0BFF             
1120   0BFF             fifo_in:
1121   0BFF 47 0F         .dw fifo
1122   0C01             fifo_out:
1123   0C01 47 0F         .dw fifo
1124   0C03             
1125   0C03             ; file system variables
1126   0C03             current_dir_id:
1127   0C03 00 00         .dw 0     ; keep dirid of current directory
1128   0C05             s_init_path:
1129   0C05 2F 73 62 69   .db "/sbin/init", 0
1129   0C09 6E 2F 69 6E 
1129   0C0D 69 74 00 
1130   0C10             
1131   0C10             s_uname:
1132   0C10 73 6F 6C 61   .db "solarium v.1.0", 0
1132   0C14 72 69 75 6D 
1132   0C18 20 76 2E 31 
1132   0C1C 2E 30 00 
1133   0C1F             s_dataentry:
1134   0C1F 3E 20 00      .db "> ", 0
1135   0C22             s_parent_dir:
1136   0C22 2E 2E 00      .db "..", 0
1137   0C25             s_current_dir:
1138   0C25 2E 00         .db ".", 0
1139   0C27             s_fslash:
1140   0C27 2F 00         .db "/", 0
1141   0C29             file_attrib:
1142   0C29 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
1142   0C2D 78 
1143   0C2E             file_type:
1144   0C2E 2D 64 63      .db "-dc"
1145   0C31             s_ps_header:
1146   0C31 70 69 64 20   .db "pid command\n", 0
1146   0C35 63 6F 6D 6D 
1146   0C39 61 6E 64 0A 
1146   0C3D 00 
1147   0C3E             s_ls_total:
1148   0C3E 74 6F 74 61   .db "total: ", 0
1148   0C42 6C 3A 20 00 
1149   0C46             
1150   0C46             s_int_en:
1151   0C46 69 72 71 73   .db "irqs enabled\n", 0
1151   0C4A 20 65 6E 61 
1151   0C4E 62 6C 65 64 
1151   0C52 0A 00 
1152   0C54             s_kernel_welcome:
1153   0C54 2A 2A 2A 2A   .db "************************************************\n"
1153   0C58 2A 2A 2A 2A 
1153   0C5C 2A 2A 2A 2A 
1153   0C60 2A 2A 2A 2A 
1153   0C64 2A 2A 2A 2A 
1153   0C68 2A 2A 2A 2A 
1153   0C6C 2A 2A 2A 2A 
1153   0C70 2A 2A 2A 2A 
1153   0C74 2A 2A 2A 2A 
1153   0C78 2A 2A 2A 2A 
1153   0C7C 2A 2A 2A 2A 
1153   0C80 2A 2A 2A 2A 
1153   0C84 0A 
1154   0C85 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
1154   0C89 57 65 6C 63 
1154   0C8D 6F 6D 65 20 
1154   0C91 74 6F 20 53 
1154   0C95 6F 6C 61 72 
1154   0C99 69 75 6D 20 
1154   0C9D 4F 53 20 2D 
1154   0CA1 20 4B 65 72 
1154   0CA5 6E 65 6C 20 
1154   0CA9 76 65 72 2E 
1154   0CAD 20 31 2E 30 
1154   0CB1 20 2A 2A 2A 
1154   0CB5 0A 
1155   0CB6 2A 2A 2A 20   .db "*** type help for more information           ***\n"
1155   0CBA 74 79 70 65 
1155   0CBE 20 68 65 6C 
1155   0CC2 70 20 66 6F 
1155   0CC6 72 20 6D 6F 
1155   0CCA 72 65 20 69 
1155   0CCE 6E 66 6F 72 
1155   0CD2 6D 61 74 69 
1155   0CD6 6F 6E 20 20 
1155   0CDA 20 20 20 20 
1155   0CDE 20 20 20 20 
1155   0CE2 20 2A 2A 2A 
1155   0CE6 0A 
1156   0CE7 2A 2A 2A 2A   .db "************************************************\n", 0
1156   0CEB 2A 2A 2A 2A 
1156   0CEF 2A 2A 2A 2A 
1156   0CF3 2A 2A 2A 2A 
1156   0CF7 2A 2A 2A 2A 
1156   0CFB 2A 2A 2A 2A 
1156   0CFF 2A 2A 2A 2A 
1156   0D03 2A 2A 2A 2A 
1156   0D07 2A 2A 2A 2A 
1156   0D0B 2A 2A 2A 2A 
1156   0D0F 2A 2A 2A 2A 
1156   0D13 2A 2A 2A 2A 
1156   0D17 0A 00 
1157   0D19             s_prompt_init:
1158   0D19 73 74 61 72   .db "starting init\n", 0
1158   0D1D 74 69 6E 67 
1158   0D21 20 69 6E 69 
1158   0D25 74 0A 00 
1159   0D28             s_priviledge:
1160   0D28 0A 65 78 63   .db "\nexception: privilege\n", 0
1160   0D2C 65 70 74 69 
1160   0D30 6F 6E 3A 20 
1160   0D34 70 72 69 76 
1160   0D38 69 6C 65 67 
1160   0D3C 65 0A 00 
1161   0D3F             s_divzero:
1162   0D3F 0A 65 78 63   .db "\nexception: zero division\n", 0
1162   0D43 65 70 74 69 
1162   0D47 6F 6E 3A 20 
1162   0D4B 7A 65 72 6F 
1162   0D4F 20 64 69 76 
1162   0D53 69 73 69 6F 
1162   0D57 6E 0A 00 
1163   0D5A             
1164   0D5A             s_break1:  
1165   0D5A 0A 64 65 62   .db "\ndebugger entry point.\n"
1165   0D5E 75 67 67 65 
1165   0D62 72 20 65 6E 
1165   0D66 74 72 79 20 
1165   0D6A 70 6F 69 6E 
1165   0D6E 74 2E 0A 
1166   0D71 30 2E 20 73   .db "0. show registers\n"
1166   0D75 68 6F 77 20 
1166   0D79 72 65 67 69 
1166   0D7D 73 74 65 72 
1166   0D81 73 0A 
1167   0D83 31 2E 20 73   .db "1. show 512b ram block\n"
1167   0D87 68 6F 77 20 
1167   0D8B 35 31 32 62 
1167   0D8F 20 72 61 6D 
1167   0D93 20 62 6C 6F 
1167   0D97 63 6B 0A 
1168   0D9A 32 2E 20 63   .db "2. continue execution", 0
1168   0D9E 6F 6E 74 69 
1168   0DA2 6E 75 65 20 
1168   0DA6 65 78 65 63 
1168   0DAA 75 74 69 6F 
1168   0DAE 6E 00 
1169   0DB0             
1170   0DB0             s_set_year:
1171   0DB0 79 65 61 72   .db "year: ", 0
1171   0DB4 3A 20 00 
1172   0DB7             s_set_month:
1173   0DB7 6D 6F 6E 74   .db "month: ", 0
1173   0DBB 68 3A 20 00 
1174   0DBF             s_set_day:
1175   0DBF 64 61 79 3A   .db "day: ", 0
1175   0DC3 20 00 
1176   0DC5             s_set_week:
1177   0DC5 77 65 65 6B   .db "weekday: ", 0
1177   0DC9 64 61 79 3A 
1177   0DCD 20 00 
1178   0DCF             s_set_hours:
1179   0DCF 68 6F 75 72   .db "hours: ", 0
1179   0DD3 73 3A 20 00 
1180   0DD7             s_set_minutes:
1181   0DD7 6D 69 6E 75   .db "minutes: ", 0
1181   0DDB 74 65 73 3A 
1181   0DDF 20 00 
1182   0DE1             s_set_seconds:
1183   0DE1 73 65 63 6F   .db "seconds: ", 0
1183   0DE5 6E 64 73 3A 
1183   0DE9 20 00 
1184   0DEB             s_months:      
1185   0DEB 20 20 20 00   .db "   ", 0
1186   0DEF 6A 61 6E 00   .db "jan", 0
1187   0DF3 66 65 62 00   .db "feb", 0
1188   0DF7 6D 61 72 00   .db "mar", 0
1189   0DFB 61 70 72 00   .db "apr", 0
1190   0DFF 6D 61 79 00   .db "may", 0
1191   0E03 6A 75 6E 00   .db "jun", 0
1192   0E07 6A 75 6C 00   .db "jul", 0
1193   0E0B 61 75 67 00   .db "aug", 0
1194   0E0F 73 65 70 00   .db "sep", 0
1195   0E13 6F 63 74 00   .db "oct", 0
1196   0E17 6E 6F 76 00   .db "nov", 0
1197   0E1B 64 65 63 00   .db "dec", 0
1198   0E1F             
1199   0E1F             s_week:        
1200   0E1F 73 75 6E 00   .db "sun", 0 
1201   0E23 6D 6F 6E 00   .db "mon", 0 
1202   0E27 74 75 65 00   .db "tue", 0 
1203   0E2B 77 65 64 00   .db "wed", 0 
1204   0E2F 74 68 75 00   .db "thu", 0 
1205   0E33 66 72 69 00   .db "fri", 0 
1206   0E37 73 61 74 00   .db "sat", 0
1207   0E3B             
1208   0E3B 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
1208   0E3F 30 20 45 78 
1208   0E43 65 63 75 74 
1208   0E47 65 64 2E 0A 
1208   0E4B 00 
1209   0E4C             s_fdc_config:
1210   0E4C 66 6C 6F 70   .db "floppy drive configuration:\n" 
1210   0E50 70 79 20 64 
1210   0E54 72 69 76 65 
1210   0E58 20 63 6F 6E 
1210   0E5C 66 69 67 75 
1210   0E60 72 61 74 69 
1210   0E64 6F 6E 3A 0A 
1211   0E68 20 20 64 72   .db "  drive:     0\n"
1211   0E6C 69 76 65 3A 
1211   0E70 20 20 20 20 
1211   0E74 20 30 0A 
1212   0E77 20 20 73 69   .db "  side:      0\n"
1212   0E7B 64 65 3A 20 
1212   0E7F 20 20 20 20 
1212   0E83 20 30 0A 
1213   0E86 20 20 64 65   .db "  density:   single density\n"
1213   0E8A 6E 73 69 74 
1213   0E8E 79 3A 20 20 
1213   0E92 20 73 69 6E 
1213   0E96 67 6C 65 20 
1213   0E9A 64 65 6E 73 
1213   0E9E 69 74 79 0A 
1214   0EA2 20 20 68 65   .db "  head load: loaded\n", 0
1214   0EA6 61 64 20 6C 
1214   0EAA 6F 61 64 3A 
1214   0EAE 20 6C 6F 61 
1214   0EB2 64 65 64 0A 
1214   0EB6 00 
1215   0EB7             
1216   0EB7             
1217   0EB7             file_obj_table: .equ $
1218   0EB7             proc_table:     .equ $ + _size_file_obj_table
1219   0EB7             
1220   0EB7             ; here we define areas that keep transient data
1221   0EB7             ; we use '$' which is the assembler's current address pointer so that these areas are defined to be exactly
1222   0EB7             ; after all the static data has been declared
1223   0EB7             fifo:           .equ $ + _size_file_obj_table + _size_proc_table
1224   0EB7             scrap_sector:   .equ $ + _size_file_obj_table + _size_proc_table + _fifo_size
1225   0EB7             transient_area: .equ $ + _size_file_obj_table + _size_proc_table + _fifo_size + _scrap_size
1226   0EB7             
1227   0EB7             
1228   0EB7             
1229   0EB7             .end
tasm: Number of errors = 0
