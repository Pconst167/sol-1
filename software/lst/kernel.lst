0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; For the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; FILE ENTRY ATTRIBUTES
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0107   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0108   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0109   0000             FST_NBR_DIRECTORIES     .equ 64
0110   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0112   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0113   0000             FST_LBA_START           .equ 32
0114   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0115   0000             
0116   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0117   0000             FS_SECTORS_PER_FILE     .equ 32 ; the first sector is always a header with a NULL parameter (first byte)
0118   0000                                             ; so that we know which blocks are free or taken
0119   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0120   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0121   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0122   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0123   0000             
0124   0000             root_id:                .equ FST_LBA_START
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; GLOBAL SYSTEM VARIABLES
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; IRQ table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 59 00       .dw int_6
0141   000E A5 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 4D 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 45 02       .dw trap_privilege
0153   0014 62 03       .dw trap_div_zero
0154   0016 6F 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 51 02       .dw syscall_break
0165   0022 70 03       .dw syscall_rtc
0166   0024 AA 04       .dw syscall_ide
0167   0026 85 05       .dw syscall_io
0168   0028 42 06       .dw syscall_file_system
0169   002A 9A 0F       .dw syscall_create_proc
0170   002C 0A 02       .dw syscall_list_procs
0171   002E A2 03       .dw syscall_datetime
0172   0030 C6 01       .dw syscall_reboot
0173   0032 64 0F       .dw syscall_pause_proc
0174   0034 D2 01       .dw syscall_resume_proc
0175   0036 21 0F       .dw syscall_terminate_proc
0176   0038 E4 00       .dw syscall_system
0177   003A 1A 01       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; IRQs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" Floppy Drive Controller IRQ
0220   003C             int_0_fdc:
0221   003C 3B 48 00      mov d, s_fdc_irq
0222   003F 07 97 12      call _puts
0223   0042 06            sysret
0224   0043             int_1:
0225   0043 06            sysret
0226   0044             int_2:
0227   0044 06            sysret
0228   0045             int_3:
0229   0045 06            sysret
0230   0046             int_4:
0231   0046 06            sysret
0232   0047             int_5:
0233   0047 06            sysret
0234   0048             
0235   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0235   004C 30 20 45 78 
0235   0050 65 63 75 74 
0235   0054 65 64 2E 0A 
0235   0058 00 
0236   0059             
0237   0059             ; ------------------------------------------------------------------------------------------------------------------;
0238   0059             ; process swapping
0239   0059             ; ------------------------------------------------------------------------------------------------------------------;
0240   0059             int_6:  
0241   0059 4B            pusha                             ; save all registers into kernel stack
0242   005A 22 00         mov ah, 0
0243   005C 1D C8 17      mov al, [active_proc_index]
0244   005F FD 99         shl a                             ; x2
0245   0061 B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index
0246   0064 4F            mov di, a
0247   0065 48            mov a, sp
0248   0066 77            inc a
0249   0067 4D            mov si, a
0250   0068 38 14 00      mov c, 20
0251   006B FD F5         rep movsb                         ; save process state!
0252   006D             ; restore kernel stack position to point before interrupt arrived
0253   006D 51 14 00      add sp, 20
0254   0070             ; now load next process in queue
0255   0070 1D C8 17      mov al, [active_proc_index]
0256   0073 31 C7 17      mov bl, [nbr_active_procs]
0257   0076 BA            cmp al, bl
0258   0077 C6 7E 00      je int6_cycle_back
0259   007A 7A            inc al                            ; next process is next in the series
0260   007B 0A 80 00      jmp int6_continue
0261   007E             int6_cycle_back:
0262   007E 19 01         mov al, 1                         ; next process = process 1
0263   0080             int6_continue:
0264   0080 3D C8 17      mov [active_proc_index], al       ; set next active proc
0265   0083             
0266   0083             ; calculate LUT entry for next process
0267   0083 22 00         mov ah, 0
0268   0085 FD 99         shl a                             ; x2
0269   0087 B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index  
0270   008A               
0271   008A 4D            mov si, a                         ; source is proc state block
0272   008B 48            mov a, sp
0273   008C 5F 13 00      sub a, 19
0274   008F 4F            mov di, a                         ; destination is kernel stack
0275   0090             ; restore SP
0276   0090 7D            dec a
0277   0091 47            mov sp, a
0278   0092 38 14 00      mov c, 20
0279   0095 FD F5         rep movsb
0280   0097             ; set VM process
0281   0097 1D C8 17      mov al, [active_proc_index]
0282   009A 01            setptb
0283   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0           ; load counter 0 low byte
0284   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10         ; load counter 0 high byte
0285   00A3 4C            popa
0286   00A4 06            sysret
0287   00A5             
0288   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0289   00A5             ; UART0 Interrupt
0290   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0291   00A5             int_7_uart0:
0292   00A5 D7            push a
0293   00A6 DA            push d
0294   00A7 E1            pushf
0295   00A8 14 CD 17      mov a, [fifo_in]
0296   00AB 3C            mov d, a
0297   00AC 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0298   00AF B9 03         cmp al, $03                 ; CTRL-C
0299   00B1 C6 CE 00      je CTRLC
0300   00B4 B9 1A         cmp al, $1A                 ; CTRL-Z
0301   00B6 C6 D4 00      je CTRLZ
0302   00B9 3E            mov [d], al                 ; add to fifo
0303   00BA 14 CD 17      mov a, [fifo_in]
0304   00BD 77            inc a
0305   00BE AF 1D 25      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0306   00C1 C7 C7 00      jne int_7_continue
0307   00C4 10 1D 21      mov a, fifo  
0308   00C7             int_7_continue:  
0309   00C7 42 CD 17      mov [fifo_in], a            ; update fifo pointer
0310   00CA EE            popf
0311   00CB E7            pop d
0312   00CC E4            pop a  
0313   00CD 06            sysret
0314   00CE             CTRLC:
0315   00CE 51 05 00      add sp, 5
0316   00D1 0A 21 0F      jmp syscall_terminate_proc
0317   00D4             CTRLZ:
0318   00D4 EE            popf
0319   00D5 E7            pop d
0320   00D6 E4            pop a
0321   00D7 0A 64 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0322   00DA             
0323   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0324   00DA             ; system syscalls
0325   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0326   00DA             system_jmptbl:
0327   00DA 10 01         .dw system_uname
0328   00DC 17 01         .dw system_whoami
0329   00DE EA 00         .dw system_setparam
0330   00E0 ED 00         .dw system_bootloader_install
0331   00E2 E8 00         .dw system_getparam
0332   00E4             syscall_system:
0333   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0334   00E8             
0335   00E8             ; param register address in register d
0336   00E8             ; param value in register bl
0337   00E8             system_getparam:
0338   00E8 32            mov bl, [d]
0339   00E9 06            sysret
0340   00EA             
0341   00EA             ; param register address in register d
0342   00EA             ; param value in register bl
0343   00EA             system_setparam:
0344   00EA FD 3E         mov [d], bl
0345   00EC 06            sysret
0346   00ED             
0347   00ED             ; kernel LBA address in 'b'
0348   00ED             system_bootloader_install:
0349   00ED D8            push b
0350   00EE 26 00 00      mov b, 0
0351   00F1 38 00 00      mov c, 0
0352   00F4 22 01         mov ah, $01                 ; 1 sector
0353   00F6 3B 1D 27      mov d, transient_area
0354   00F9 07 F4 04      call ide_read_sect          ; read sector
0355   00FC E5            pop b
0356   00FD FD 44 FE 01   mov [d + 510], b            ; update LBA address
0357   0101 26 00 00      mov b, 0
0358   0104 38 00 00      mov c, 0
0359   0107 22 01         mov ah, $01                 ; 1 sector
0360   0109 3B 1D 27      mov d, transient_area
0361   010C 07 1A 05      call ide_write_sect         ; write sector
0362   010F 06            sysret
0363   0110             
0364   0110             system_uname:
0365   0110 3B DE 17      mov d, s_uname
0366   0113 07 97 12      call _puts
0367   0116 06            sysret
0368   0117             
0369   0117             system_whoami:
0370   0117 06            sysret
0371   0118             
0372   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0373   0118             ; floppy drive system calls
0374   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0375   0118             ; the floppy control below is not yet tested. it needs to be tested.
0376   0118             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0377   0118             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0378   0118             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0379   0118             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0380   0118             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0381   0118             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0382   0118             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0383   0118             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0384   0118             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0385   0118             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0386   0118             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0387   0118             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0388   0118             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0389   0118             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0390   0118             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0391   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0392   0118             ; _FDC_CONFIG       .equ $FFC0 
0393   0118             ; _FDC_STATUS_1     .equ $FFC1
0394   0118             ; _FDC_WD_STAT_CMD  .equ $FFC8
0395   0118             ; _FDC_WD_TRACK     .equ $FFC9
0396   0118             ; _FDC_WD_SECTOR    .equ $FFCA
0397   0118             ; _FDC_WD_DATA      .equ $FFCB
0398   0118             fdc_jmptbl:
0399   0118 1E 01         .dw syscall_fdc_format
0400   011A             syscall_fdc:
0401   011A FD 0A 18 01   jmp [fdc_jmptbl + al]
0402   011E             
0403   011E             syscall_fdc_format:
0404   011E 3B 9A 01      mov d, s_format_begin
0405   0121 07 97 12      call _puts
0406   0124 FD 22 FF 00   mov g, $FF
0407   0128             fdc_wait_busy:
0408   0128 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0409   012B 87 01         and al, $01                ; busy bit
0410   012D C7 28 01      jnz fdc_wait_busy
0411   0130             
0412   0130 FD 4D 0B 19   mov si, fdc_40_FF
0413   0134 38 D1 00      mov c, 209
0414   0137 3B 7F 01      mov d, s_send_write_cmd
0415   013A 07 97 12      call _puts
0416   013D 3B C8 FF      mov d, _FDC_WD_STAT_CMD
0417   0140 19 F2         mov al, %11110010          ; Write Track Command: {1111, 0: Enable Spin-up Seq, 0: No Settling Delay, 1: No Write Precompensation, 0}
0418   0142 3E            mov [d], al
0419   0143             fdc_sector_loop:
0420   0143             fdc_drq_loop:
0421   0143 3B C1 FF      mov d, _FDC_STATUS_1
0422   0146 1E            mov al, [d]
0423   0147 87 01         and al, $01                ; check drq bit
0424   0149 C6 43 01      jz fdc_drq_loop
0425   014C F6            lodsb                      ; load format byte
0426   014D 3B CB FF      mov d, _FDC_WD_DATA        ; data register
0427   0150 3E            mov [d], al                ; send data byte to wd1770
0428   0151 7E            dec c
0429   0152 C7 43 01      jnz fdc_sector_loop
0430   0155 3B 3C 19      mov d, fdc_sector
0431   0158 32            mov bl, [d]
0432   0159 FD 77         inc b
0433   015B FD 3E         mov [d], bl
0434   015D C1 0B         cmp bl, 11
0435   015F C7 43 01      jne fdc_sector_loop        ; continue formatting
0436   0162             
0437   0162             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0438   0162             fdc_drq_loop_fill:
0439   0162 3B C1 FF      mov d, _FDC_STATUS_1
0440   0165 1E            mov al, [d]
0441   0166 87 01         and al, $01                ; check drq bit
0442   0168 C6 62 01      jz fdc_drq_loop_fill
0443   016B 3B CB FF      mov d, _FDC_WD_DATA        ; data register
0444   016E FD 1A         mov al, gl
0445   0170 3E            mov [d], al                ; send data byte to wd1770
0446   0171 0C            lodstat
0447   0172 1A            mov al, ah
0448   0173 87 01         and al, $01
0449   0175 C6 62 01      jz fdc_drq_loop_fill
0450   0178             
0451   0178 3B B3 01      mov d, s_format_done
0452   017B 07 97 12      call _puts
0453   017E             
0454   017E 06            sysret
0455   017F             
0456   017F 0A 53 65 6E s_send_write_cmd: .db "\nSending Write Command...\n", 0
0456   0183 64 69 6E 67 
0456   0187 20 57 72 69 
0456   018B 74 65 20 43 
0456   018F 6F 6D 6D 61 
0456   0193 6E 64 2E 2E 
0456   0197 2E 0A 00 
0457   019A 0A 46 6F 72 s_format_begin:   .db "\nFormatting starting...\n", 0
0457   019E 6D 61 74 74 
0457   01A2 69 6E 67 20 
0457   01A6 73 74 61 72 
0457   01AA 74 69 6E 67 
0457   01AE 2E 2E 2E 0A 
0457   01B2 00 
0458   01B3 0A 46 6F 72 s_format_done:    .db "\nFormatting done.\n", 0
0458   01B7 6D 61 74 74 
0458   01BB 69 6E 67 20 
0458   01BF 64 6F 6E 65 
0458   01C3 2E 0A 00 
0459   01C6             
0460   01C6             ; REBOOT SYSTEM
0461   01C6             syscall_reboot:
0462   01C6 FD D7 FF FF   push word $FFFF 
0463   01CA FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0464   01CD FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0465   01D1 06            sysret
0466   01D2             
0467   01D2             ;------------------------------------------------------------------------------------------------------;;
0468   01D2             ; switch to another process
0469   01D2             ; inputs:
0470   01D2             ; AL = new process number
0471   01D2             ;------------------------------------------------------------------------------------------------------;;
0472   01D2             syscall_resume_proc:
0473   01D2 FD 78         mov g, a                            ; save the process number
0474   01D4 4B            pusha                               ; save all registers into kernel stack
0475   01D5 22 00         mov ah, 0
0476   01D7 1D C8 17      mov al, [active_proc_index]
0477   01DA FD 99         shl a              ; x2
0478   01DC B7 17 10      mov a, [proc_table_convert + a]     ; get process state start index
0479   01DF 4F            mov di, a
0480   01E0 48            mov a, sp
0481   01E1 77            inc a
0482   01E2 4D            mov si, a
0483   01E3 38 14 00      mov c, 20
0484   01E6 FD F5         rep movsb                           ; save process state!
0485   01E8             ; restore kernel stack position to point before interrupt arrived
0486   01E8 51 14 00      add sp, 20
0487   01EB             ; now load the new process number!
0488   01EB FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0489   01ED 3D C8 17      mov [active_proc_index], al         ; set new active proc
0490   01F0             ; calculate LUT entry for next process
0491   01F0 22 00         mov ah, 0
0492   01F2 FD 99         shl a                               ; x2
0493   01F4 B7 17 10      mov a, [proc_table_convert + a]     ; get process state start index  
0494   01F7 4D            mov si, a                           ; source is proc state block
0495   01F8 48            mov a, sp
0496   01F9 5F 13 00      sub a, 19
0497   01FC 4F            mov di, a                           ; destination is kernel stack
0498   01FD             ; restore SP
0499   01FD 7D            dec a
0500   01FE 47            mov sp, a
0501   01FF 38 14 00      mov c, 20
0502   0202 FD F5         rep movsb
0503   0204             ; set VM process
0504   0204 1D C8 17      mov al, [active_proc_index]
0505   0207 01            setptb
0506   0208 4C            popa
0507   0209 06            sysret
0508   020A             
0509   020A             ;------------------------------------------------------------------------------------------------------;;
0510   020A             ; list processes
0511   020A             ;------------------------------------------------------------------------------------------------------;;
0512   020A             syscall_list_procs:
0513   020A 3B FF 17      mov d, s_ps_header
0514   020D 07 97 12      call _puts
0515   0210 3B 8E 1C      mov d, proc_availab_table + 1
0516   0213 38 01 00      mov c, 1
0517   0216             list_procs_L0:  
0518   0216 BD 01         cmp byte[d], 1
0519   0218 C7 3C 02      jne list_procs_next
0520   021B 2D            mov b, d
0521   021C 61 8D 1C      sub b, proc_availab_table
0522   021F FD 9F 05      shl b, 5
0523   0222 DA            push d
0524   0223 D8            push b
0525   0224 28            mov b, c
0526   0225 07 37 13      call print_u8x
0527   0228 22 20         mov ah, ' '
0528   022A 07 6B 11      call _putchar
0529   022D 07 6B 11      call _putchar
0530   0230 E5            pop b
0531   0231 74            mov d, b
0532   0232 58 9D 1C      add d, proc_names
0533   0235 07 97 12      call _puts
0534   0238 07 44 12      call printnl
0535   023B E7            pop d
0536   023C             list_procs_next:
0537   023C 79            inc d
0538   023D 78            inc c
0539   023E C2 09 00      cmp c, 9
0540   0241 C7 16 02      jne list_procs_L0
0541   0244             list_procs_end:
0542   0244 06            sysret
0543   0245             
0544   0245             ; ------------------------------------------------------------------------------------------------------------------;
0545   0245             ; exceptions code block
0546   0245             ; ------------------------------------------------------------------------------------------------------------------;
0547   0245             ; privilege exception
0548   0245             ; ------------------------------------------------------------------------------------------------------------------;
0549   0245             trap_privilege:
0550   0245 0A C6 01      jmp syscall_reboot
0551   0248 DA            push d
0552   0249 3B 4E 18      mov d, s_priviledge
0553   024C 07 97 12      call _puts
0554   024F E7            pop d
0555   0250 06            sysret
0556   0251             
0557   0251             ; ------------------------------------------------------------------------------------------------------------------;
0558   0251             ; breakpoint
0559   0251             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0560   0251             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0561   0251             ; ------------------------------------------------------------------------------------------------------------------;
0562   0251             syscall_break:
0563   0251 4B            pusha
0564   0252             syscall_break_prompt:
0565   0252 3B 0C 03      mov d, s_break1
0566   0255 07 97 12      call _puts
0567   0258 07 44 12      call printnl
0568   025B 07 99 13      call scan_u16d
0569   025E AF 00 00      cmp a, 0
0570   0261 C6 6C 02      je syscall_break_regs
0571   0264 AF 01 00      cmp a, 1
0572   0267 C6 8F 02      je syscall_break_mem
0573   026A             syscall_break_end:  
0574   026A 4C            popa
0575   026B 06            sysret
0576   026C             syscall_break_regs:
0577   026C 48            mov a, sp
0578   026D 53 0E 00      add a, 14               ; back-track 7 registers
0579   0270 3C            mov d, a
0580   0271 3A 07         mov cl, 7
0581   0273             syscall_regs_L0:
0582   0273 2A            mov b, [d]
0583   0274 FD AB         swp b
0584   0276 07 F3 12      call print_u16x         ; print register value
0585   0279 07 44 12      call printnl
0586   027C 63 02 00      sub d, 2
0587   027F 71 01         sub cl, 1
0588   0281 C3 00         cmp cl, 0
0589   0283 C7 73 02      jne syscall_regs_L0
0590   0286 0A 52 02      jmp syscall_break_prompt
0591   0289 07 44 12      call printnl
0592   028C 0A 52 02      jmp syscall_break_prompt
0593   028F             syscall_break_mem:
0594   028F 07 44 12      call printnl
0595   0292 07 15 13      call scan_u16x
0596   0295 4D            mov si, a               ; data source from user space
0597   0296 FD 4F 1D 25   mov di, scrap_sector    ; destination in kernel space
0598   029A 38 00 02      mov c, 512
0599   029D 04            load                    ; transfer data to kernel space!
0600   029E 3B 1D 25      mov d, scrap_sector     ; dump pointer in d
0601   02A1 38 00 00      mov c, 0
0602   02A4             dump_loop:
0603   02A4 84            mov al, cl
0604   02A5 87 0F         and al, $0F
0605   02A7 C6 F5 02      jz print_base
0606   02AA             back:
0607   02AA 1E            mov al, [d]             ; read byte
0608   02AB 2F            mov bl, al
0609   02AC 07 37 13      call print_u8x
0610   02AF 10 00 20      mov a, $2000
0611   02B2 05 03         syscall sys_io          ; space
0612   02B4 84            mov al, cl
0613   02B5 87 0F         and al, $0F
0614   02B7 B9 0F         cmp al, $0F
0615   02B9 C6 CA 02      je print_ascii
0616   02BC             back1:
0617   02BC 79            inc d
0618   02BD 78            inc c
0619   02BE C2 00 02      cmp c, 512
0620   02C1 C7 A4 02      jne dump_loop
0621   02C4 07 44 12      call printnl
0622   02C7 0A 52 02      jmp syscall_break_prompt  ; go to syscall_break return point
0623   02CA             print_ascii:
0624   02CA 10 00 20      mov a, $2000
0625   02CD 05 03         syscall sys_io
0626   02CF 63 10 00      sub d, 16
0627   02D2 26 10 00      mov b, 16
0628   02D5             print_ascii_L:
0629   02D5 79            inc d
0630   02D6 1E            mov al, [d]               ; read byte
0631   02D7 B9 20         cmp al, $20
0632   02D9 C8 E1 02      jlu dot
0633   02DC B9 7E         cmp al, $7E
0634   02DE D0 E9 02      jleu ascii
0635   02E1             dot:
0636   02E1 10 00 2E      mov a, $2E00
0637   02E4 05 03         syscall sys_io
0638   02E6 0A EE 02      jmp ascii_continue
0639   02E9             ascii:
0640   02E9 23            mov ah, al
0641   02EA 19 00         mov al, 0
0642   02EC 05 03         syscall sys_io
0643   02EE             ascii_continue:
0644   02EE FD A9 D5 02   loopb print_ascii_L
0645   02F2 0A BC 02      jmp back1
0646   02F5             print_base:
0647   02F5 07 44 12      call printnl
0648   02F8 2D            mov b, d
0649   02F9 61 1D 25      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0650   02FC 07 F3 12      call print_u16x          ; display row
0651   02FF 10 00 3A      mov a, $3A00
0652   0302 05 03         syscall sys_io
0653   0304 10 00 20      mov a, $2000
0654   0307 05 03         syscall sys_io
0655   0309 0A AA 02      jmp back
0656   030C             
0657   030C             s_break1:  
0658   030C 0A 44 65 62   .db "\nDebugger entry point.\n"
0658   0310 75 67 67 65 
0658   0314 72 20 65 6E 
0658   0318 74 72 79 20 
0658   031C 70 6F 69 6E 
0658   0320 74 2E 0A 
0659   0323 30 2E 20 53   .db "0. Show Registers\n"
0659   0327 68 6F 77 20 
0659   032B 52 65 67 69 
0659   032F 73 74 65 72 
0659   0333 73 0A 
0660   0335 31 2E 20 53   .db "1. Show 512B RAM block\n"
0660   0339 68 6F 77 20 
0660   033D 35 31 32 42 
0660   0341 20 52 41 4D 
0660   0345 20 62 6C 6F 
0660   0349 63 6B 0A 
0661   034C 32 2E 20 43   .db "2. Continue Execution", 0
0661   0350 6F 6E 74 69 
0661   0354 6E 75 65 20 
0661   0358 45 78 65 63 
0661   035C 75 74 69 6F 
0661   0360 6E 00 
0662   0362             
0663   0362             ; ------------------------------------------------------------------------------------------------------------------;
0664   0362             ; divide by zero exception
0665   0362             ; ------------------------------------------------------------------------------------------------------------------;
0666   0362             trap_div_zero:
0667   0362 D7            push a
0668   0363 DA            push d
0669   0364 E1            pushf
0670   0365 3B 65 18      mov d, s_divzero
0671   0368 07 97 12      call _puts
0672   036B EE            popf
0673   036C E7            pop d
0674   036D E4            pop a
0675   036E 06            sysret ; enable interrupts
0676   036F             
0677   036F             ; ------------------------------------------------------------------------------------------------------------------;
0678   036F             ; undefined opcode exception
0679   036F             ; ------------------------------------------------------------------------------------------------------------------;
0680   036F             trap_undef_opcode:
0681   036F 06            sysret
0682   0370             
0683   0370             ; ------------------------------------------------------------------------------------------------------------------;
0684   0370             ; real-time clock services syscall
0685   0370             ; RTC I/O bank = FFA0 to FFAF
0686   0370             ; FFA0 to FFA7 is scratch RAM
0687   0370             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0688   0370             ; al = 0..6 -> get
0689   0370             ; al = 7..D -> set
0690   0370             ; ------------------------------------------------------------------------------------------------------------------;
0691   0370             syscall_rtc:
0692   0370 DB            push al
0693   0371 DA            push d
0694   0372 B9 06         cmp al, 6
0695   0374 D1 89 03      jgu syscall_rtc_set
0696   0377             syscall_rtc_get:
0697   0377 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0698   0379 22 FF         mov ah, $FF    
0699   037B 3C            mov d, a                ; get to FFA9 + offset
0700   037C F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0701   0380 1E            mov al, [d]             ; get data
0702   0381 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0703   0385 23            mov ah, al
0704   0386 E7            pop d
0705   0387 E8            pop al
0706   0388 06            sysret
0707   0389             syscall_rtc_set:
0708   0389 DD            push bl
0709   038A 99            mov bl, ah              ; set data asIDE
0710   038B 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0711   038D 22 FF         mov ah, $FF    
0712   038F 3C            mov d, a                ; get to FFA9 + offset
0713   0390 1B            mov al, bl              ; get data back
0714   0391 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0715   0395 3E            mov [d], al             ; set data
0716   0396 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0717   039A EA            pop bl
0718   039B E7            pop d
0719   039C E8            pop al
0720   039D 06            sysret
0721   039E             
0722   039E             datetime_serv_tbl:
0723   039E A6 03         .dw print_date
0724   03A0 1A 04         .dw set_date
0725   03A2             syscall_datetime:
0726   03A2 FD 0A 9E 03   jmp [datetime_serv_tbl + al]      
0727   03A6             print_date:
0728   03A6 10 00 0D      mov a, $0D00           ; print carriage return char
0729   03A9 19 03         mov al, 3
0730   03AB 05 01         syscall sys_rtc        ; get week
0731   03AD 1A            mov al, ah
0732   03AE 22 00         mov ah, 0
0733   03B0 FD 9D 02      shl a, 2          
0734   03B3 3B EF 18      mov d, s_week
0735   03B6 59            add d, a
0736   03B7 07 97 12      call _puts
0737   03BA 10 00 20      mov a, $2000
0738   03BD 05 03         syscall sys_io         ; display ' '
0739   03BF 19 04         mov al, 4
0740   03C1 05 01         syscall sys_rtc        ; get day
0741   03C3 99            mov bl, ah
0742   03C4 07 37 13      call print_u8x
0743   03C7 10 00 20      mov a, $2000
0744   03CA 05 03         syscall sys_io         ; display ' '
0745   03CC             ; there is a problem with the month displaying
0746   03CC             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0747   03CC             ; even though it is to be understood as BCD.
0748   03CC             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0749   03CC 19 05         mov al, 05
0750   03CE 05 01         syscall sys_rtc        ; get month
0751   03D0 1A            mov al, ah
0752   03D1 22 00         mov ah, 0
0753   03D3 FD 9D 02      shl a, 2          
0754   03D6 3B BB 18      mov d, s_months
0755   03D9 59            add d, a
0756   03DA 07 97 12      call _puts
0757   03DD 10 00 20      mov a, $2000
0758   03E0 05 03         syscall sys_io         ; display ' '
0759   03E2 2E 20         mov bl, $20
0760   03E4 07 37 13      call print_u8x         ; print 20 for year prefix
0761   03E7 19 06         mov al, 06
0762   03E9 05 01         syscall sys_rtc        ; get year
0763   03EB 99            mov bl, ah
0764   03EC 07 37 13      call print_u8x
0765   03EF 10 00 20      mov a, $2000  
0766   03F2 05 03         syscall sys_io         ; display ' '
0767   03F4 19 02         mov al, 2
0768   03F6 05 01         syscall sys_rtc        ; get hours
0769   03F8 99            mov bl, ah
0770   03F9 07 37 13      call print_u8x
0771   03FC 10 00 3A      mov a, $3A00    
0772   03FF 05 03         syscall sys_io         ; display ':'
0773   0401 19 01         mov al, 01
0774   0403 05 01         syscall sys_rtc        ; get minutes
0775   0405 99            mov bl, ah
0776   0406 07 37 13      call print_u8x
0777   0409 10 00 3A      mov a, $3A00  
0778   040C 05 03         syscall sys_io         ; display ':'
0779   040E 19 00         mov al, 0
0780   0410 05 01         syscall sys_rtc        ; get seconds
0781   0412 99            mov bl, ah
0782   0413 07 37 13      call print_u8x
0783   0416 07 44 12      call printnl
0784   0419 06            sysret
0785   041A             set_date:
0786   041A 3B 80 18      mov d, s_set_year
0787   041D 07 97 12      call _puts
0788   0420 07 82 13      call scan_u8x          ; read integer into A
0789   0423 FD 9D 08      shl a, 8               ; only AL used, move to AH
0790   0426 19 0D         mov al, 0Dh            ; set RTC year
0791   0428 05 01         syscall sys_rtc        ; set RTC
0792   042A 3B 87 18      mov d, s_set_month
0793   042D 07 97 12      call _puts
0794   0430 07 82 13      call scan_u8x          ; read integer into A
0795   0433 FD 9D 08      shl a, 8               ; only AL used, move to AH
0796   0436 19 0C         mov al, 0Ch            ; set RTC month
0797   0438 05 01         syscall sys_rtc        ; set RTC
0798   043A 3B 8F 18      mov d, s_set_day
0799   043D 07 97 12      call _puts
0800   0440 07 82 13      call scan_u8x          ; read integer into A
0801   0443 FD 9D 08      shl a, 8               ; only AL used, move to AH
0802   0446 19 0B         mov al, 0Bh            ; set RTC month
0803   0448 05 01         syscall sys_rtc        ; set RTC
0804   044A 3B 95 18      mov d, s_set_week
0805   044D 07 97 12      call _puts
0806   0450 07 82 13      call scan_u8x          ; read integer into A
0807   0453 FD 9D 08      shl a, 8               ; only AL used, move to AH
0808   0456 19 0A         mov al, 0Ah            ; set RTC month
0809   0458 05 01         syscall sys_rtc        ; set RTC
0810   045A 3B 9F 18      mov d, s_set_hours
0811   045D 07 97 12      call _puts
0812   0460 07 82 13      call scan_u8x          ; read integer into A
0813   0463 FD 9D 08      shl a, 8               ; only AL used, move to AH
0814   0466 19 09         mov al, 09h            ; set RTC month
0815   0468 05 01         syscall sys_rtc        ; set RTC
0816   046A 3B A7 18      mov d, s_set_minutes
0817   046D 07 97 12      call _puts
0818   0470 07 82 13      call scan_u8x          ; read integer into A
0819   0473 FD 9D 08      shl a, 8               ; only AL used, move to AH
0820   0476 19 08         mov al, 08h            ; set RTC month
0821   0478 05 01         syscall sys_rtc        ; set RTC
0822   047A 3B B1 18      mov d, s_set_seconds
0823   047D 07 97 12      call _puts
0824   0480 07 82 13      call scan_u8x          ; read integer into A
0825   0483 FD 9D 08      shl a, 8               ; only AL used, move to AH
0826   0486 19 07         mov al, 07h            ; set RTC month
0827   0488 05 01         syscall sys_rtc        ; set RTC
0828   048A 06            sysret
0829   048B             
0830   048B             ; ------------------------------------------------------------------------------------------------------------------;
0831   048B             ; IDE Services Syscall
0832   048B             ; al = option
0833   048B             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0834   048B             ; IDE read/write sector
0835   048B             ; 512 bytes
0836   048B             ; User buffer pointer in D
0837   048B             ; AH = number of sectors
0838   048B             ; CB = LBA bytes 3..0
0839   048B             ; ------------------------------------------------------------------------------------------------------------------;
0840   048B 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0840   048F 73 63 61 6C 
0840   0493 6C 5F 69 64 
0840   0497 65 20 63 61 
0840   049B 6C 6C 65 64 
0840   049F 3A 20 00 
0841   04A2             ide_serv_tbl:
0842   04A2 C9 04         .dw ide_reset
0843   04A4 DD 04         .dw ide_sleep
0844   04A6 EC 04         .dw ide_read_sect_wrapper
0845   04A8 F0 04         .dw ide_write_sect_wrapper
0846   04AA             syscall_ide:
0847   04AA DD            push bl
0848   04AB 31 C0 17      mov bl, [sys_debug_mode]
0849   04AE               ; debug block
0850   04AE C1 00         cmp bl, 0
0851   04B0 EA            pop bl
0852   04B1 C6 C5 04      je syscall_ide_jmp
0853   04B4 DA            push d
0854   04B5 DD            push bl
0855   04B6 3B 8B 04      mov d, s_syscall_ide_dbg0
0856   04B9 07 97 12      call _puts
0857   04BC 2F            mov bl, al
0858   04BD 07 37 13      call print_u8x
0859   04C0 07 44 12      call printnl
0860   04C3 EA            pop bl
0861   04C4 E7            pop d
0862   04C5             syscall_ide_jmp:
0863   04C5 FD 0A A2 04   jmp [ide_serv_tbl + al]    
0864   04C9               
0865   04C9             ide_reset:      
0866   04C9 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0867   04CD 07 76 05      call ide_wait                   ; wait for IDE ready             
0868   04D0 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0869   04D4 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0870   04D8 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0871   04DC 06            sysret
0872   04DD             ide_sleep:
0873   04DD 07 76 05      call ide_wait                   ; wait for IDE ready             
0874   04E0 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0875   04E4 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0876   04E8 07 76 05      call ide_wait                   ; wait for IDE ready
0877   04EB 06            sysret
0878   04EC             ide_read_sect_wrapper:
0879   04EC 07 F4 04      call ide_read_sect
0880   04EF 06            sysret
0881   04F0             ide_write_sect_wrapper:
0882   04F0 07 1A 05      call ide_write_sect
0883   04F3 06            sysret
0884   04F4             ide_read_sect:
0885   04F4 1A            mov al, ah
0886   04F5 24            mov ah, bl
0887   04F6 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0888   04F9 1C            mov al, bh
0889   04FA 3D D4 FF      mov [_ide_R4], al
0890   04FD 12            mov a, c
0891   04FE 3D D5 FF      mov [_ide_R5], al
0892   0501 1A            mov al, ah
0893   0502 87 0F         and al, %00001111
0894   0504 8B E0         or al, %11100000                ; mode lba, master
0895   0506 3D D6 FF      mov [_ide_R6], al
0896   0509             ide_read_sect_wait:
0897   0509 1D D7 FF      mov al, [_ide_R7]  
0898   050C 87 80         and al, $80                     ; BUSY FLAG
0899   050E C7 09 05      jnz ide_read_sect_wait
0900   0511 19 20         mov al, $20
0901   0513 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0902   0516 07 40 05      call ide_read  
0903   0519 09            ret
0904   051A             ide_write_sect:
0905   051A 1A            mov al, ah
0906   051B 24            mov ah, bl
0907   051C 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0908   051F 1C            mov al, bh
0909   0520 3D D4 FF      mov [_ide_R4], al
0910   0523 12            mov a, c
0911   0524 3D D5 FF      mov [_ide_R5], al
0912   0527 1A            mov al, ah
0913   0528 87 0F         and al, %00001111
0914   052A 8B E0         or al, %11100000                ; mode lba, master
0915   052C 3D D6 FF      mov [_ide_R6], al
0916   052F             ide_write_sect_wait:
0917   052F 1D D7 FF      mov al, [_ide_R7]  
0918   0532 87 80         and al, $80                     ; BUSY FLAG
0919   0534 C7 2F 05      jnz ide_write_sect_wait
0920   0537 19 30         mov al, $30
0921   0539 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0922   053C 07 5B 05      call ide_write      
0923   053F 09            ret
0924   0540             
0925   0540             ;----------------------------------------------------------------------------------------------------;
0926   0540             ; READ IDE DATA
0927   0540             ; pointer in D
0928   0540             ;----------------------------------------------------------------------------------------------------;
0929   0540             ide_read:
0930   0540 DA            push d
0931   0541             ide_read_loop:
0932   0541 1D D7 FF      mov al, [_ide_R7]  
0933   0544 87 80         and al, 80h                     ; BUSY FLAG
0934   0546 C7 41 05      jnz ide_read_loop               ; wait loop
0935   0549 1D D7 FF      mov al, [_ide_R7]
0936   054C 87 08         and al, %00001000               ; DRQ FLAG
0937   054E C6 59 05      jz ide_read_end
0938   0551 1D D0 FF      mov al, [_ide_R0]
0939   0554 3E            mov [d], al
0940   0555 79            inc d
0941   0556 0A 41 05      jmp ide_read_loop
0942   0559             ide_read_end:
0943   0559 E7            pop d
0944   055A 09            ret
0945   055B             
0946   055B             ;----------------------------------------------------------------------------------------------------;
0947   055B             ; WRITE IDE DATA
0948   055B             ; data pointer in D
0949   055B             ;----------------------------------------------------------------------------------------------------;
0950   055B             ide_write:
0951   055B DA            push d
0952   055C             ide_write_loop:
0953   055C 1D D7 FF      mov al, [_ide_R7]  
0954   055F 87 80         and al, 80h             ; BUSY FLAG
0955   0561 C7 5C 05      jnz ide_write_loop      ; wait loop
0956   0564 1D D7 FF      mov al, [_ide_R7]
0957   0567 87 08         and al, %00001000       ; DRQ FLAG
0958   0569 C6 74 05      jz ide_write_end
0959   056C 1E            mov al, [d]
0960   056D 3D D0 FF      mov [_ide_R0], al
0961   0570 79            inc d 
0962   0571 0A 5C 05      jmp ide_write_loop
0963   0574             ide_write_end:
0964   0574 E7            pop d
0965   0575 09            ret
0966   0576             
0967   0576             ;----------------------------------------------------------------------------------------------------;
0968   0576             ; wait for IDE to be ready
0969   0576             ;----------------------------------------------------------------------------------------------------;
0970   0576             ide_wait:
0971   0576 1D D7 FF      mov al, [_ide_R7]  
0972   0579 87 80         and al, 80h        ; BUSY FLAG
0973   057B C7 76 05      jnz ide_wait
0974   057E 09            ret
0975   057F             
0976   057F             ;----------------------------------------------------------------------------------------------------;
0977   057F             ; IO Syscall
0978   057F             ;----------------------------------------------------------------------------------------------------;
0979   057F             ; Baud  Divisor
0980   057F             ; 50    2304
0981   057F             ; 110   1047
0982   057F             ; 300    384
0983   057F             ; 600    192
0984   057F             ; 1200    96
0985   057F             ; 9600    12
0986   057F             ; 19200    6
0987   057F             ; 38400    3
0988   057F             syscall_io_jmp:
0989   057F B2 05         .dw syscall_io_putchar
0990   0581 BF 05         .dw syscall_io_getch
0991   0583 89 05         .dw syscall_io_uart_setup
0992   0585             syscall_io:
0993   0585 FD 0A 7F 05   jmp [syscall_io_jmp + al]
0994   0589             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0995   0589             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0996   0589             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0997   0589             syscall_io_uart_setup:
0998   0589 1D C2 17      mov al, [sys_uart0_lcr]
0999   058C 8B 80         or al, $80                ; set DLAB access bit
1000   058E 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
1001   0591 1D C5 17      mov al, [sys_uart0_div0]
1002   0594 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
1003   0597 1D C6 17      mov al, [sys_uart0_div1]
1004   059A 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
1005   059D             
1006   059D 1D C2 17      mov al, [sys_uart0_lcr]
1007   05A0 87 7F         and al, $7F               ; clear DLAB access bit 
1008   05A2 3D 83 FF      mov [_UART0_LCR], al
1009   05A5 1D C3 17      mov al, [sys_uart0_inten]
1010   05A8 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1011   05AB 1D C4 17      mov al, [sys_uart0_fifoen]
1012   05AE 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1013   05B1 06            sysret
1014   05B2             
1015   05B2             ; char in ah
1016   05B2             syscall_io_putchar:
1017   05B2             syscall_io_putchar_L0:
1018   05B2 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1019   05B5 87 20         and al, $20
1020   05B7 C6 B2 05      jz syscall_io_putchar_L0    
1021   05BA 1A            mov al, ah
1022   05BB 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1023   05BE 06            sysret
1024   05BF             
1025   05BF             ; char in ah
1026   05BF             ; al = sucess code
1027   05BF             syscall_io_getch:
1028   05BF D8            push b
1029   05C0 DA            push d
1030   05C1 FD 0C         sti
1031   05C3             syscall_io_getch_L0:  
1032   05C3 14 CF 17      mov a, [fifo_out]
1033   05C6 29 CD 17      mov b, [fifo_in]
1034   05C9 B0            cmp a, b
1035   05CA C6 C3 05      je syscall_io_getch_L0
1036   05CD 3C            mov d, a
1037   05CE 77            inc a
1038   05CF AF 1D 25      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1039   05D2 C7 D8 05      jne syscall_io_getch_cont
1040   05D5 10 1D 21      mov a, fifo  
1041   05D8             syscall_io_getch_cont:  
1042   05D8 42 CF 17      mov [fifo_out], a             ; update fifo pointer
1043   05DB 1E            mov al, [d]                   ; get char
1044   05DC 23            mov ah, al
1045   05DD 1D C1 17      mov al, [sys_echo_on]
1046   05E0 B9 01         cmp al, 1
1047   05E2 C7 F1 05      jne syscall_io_getch_noecho 
1048   05E5             ; here we just echo the char back to the console
1049   05E5             syscall_io_getch_echo_L0:
1050   05E5 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1051   05E8 87 20         and al, $20                 ; isolate Transmitter Empty
1052   05EA C6 E5 05      jz syscall_io_getch_echo_L0
1053   05ED 1A            mov al, ah
1054   05EE 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1055   05F1             syscall_io_getch_noecho:
1056   05F1 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1057   05F3 E7            pop d
1058   05F4 E5            pop b
1059   05F5 06            sysret
1060   05F6             
1061   05F6             ;------------------------------------------------------------------------------------------------------;
1062   05F6             ; FILE SYSTEM DATA
1063   05F6             ;------------------------------------------------------------------------------------------------------;
1064   05F6             ; infor for : IDE SERVICES INTERRUPT
1065   05F6             ; IDE read/write 512-byte sector
1066   05F6             ; al = option
1067   05F6             ; user buffer pointer in D
1068   05F6             ; AH = number of sectors
1069   05F6             ; CB = LBA bytes 3..0  
1070   05F6             ;------------------------------------------------------------------------------------------------------;
1071   05F6             ; FILE SYSTEM DATA STRUCTURE
1072   05F6             ;------------------------------------------------------------------------------------------------------;
1073   05F6             ; for a directory we have the header first, followed by metadata
1074   05F6             ; header 1 sector (512 bytes)
1075   05F6             ; metadata 1 sector (512 bytes)
1076   05F6             ; HEADER ENTRIES:
1077   05F6             ; filename (64)
1078   05F6             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1079   05F6             ;
1080   05F6             ; metadata entries:
1081   05F6             ; filename (24)
1082   05F6             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1083   05F6             ; LBA (2)
1084   05F6             ; size (2)
1085   05F6             ; day (1)
1086   05F6             ; month (1)
1087   05F6             ; year (1)
1088   05F6             ; packet size = 32 bytes
1089   05F6             ;
1090   05F6             ; first directory on disk is the root directory '/'
1091   05F6             file_system_jmptbl:
1092   05F6 61 06         .dw fs_mkfs                   ; 0
1093   05F8 00 00         .dw 0                         ; 1
1094   05FA C3 06         .dw fs_mkdir                  ; 2
1095   05FC 3C 0A         .dw fs_cd                     ; 3
1096   05FE 43 0A         .dw fs_ls                     ; 4
1097   0600 B9 0B         .dw fs_mktxt                  ; 5
1098   0602 84 0C         .dw fs_mkbin                  ; 6
1099   0604 4B 0D         .dw fs_pwd                    ; 7
1100   0606 68 0D         .dw fs_cat                    ; 8
1101   0608 C4 0D         .dw fs_rmdir                  ; 9
1102   060A 20 0E         .dw fs_rm                     ; 10
1103   060C 14 0B         .dw fs_starcom                ; 11
1104   060E 00 00         .dw 0                         ; 12
1105   0610 00 00         .dw 0                         ; 13
1106   0612 69 06         .dw fs_chmod                  ; 14
1107   0614 88 0E         .dw fs_mv                     ; 15
1108   0616 62 06         .dw fs_cd_root                ; 16
1109   0618 38 0A         .dw fs_get_curr_dirID         ; 17
1110   061A 14 08         .dw fs_dir_id_to_path         ; 18
1111   061C 7A 08         .dw fs_path_to_dir_id_user    ; 19
1112   061E 94 09         .dw fs_load_from_path_user    ; 20  
1113   0620 04 09         .dw fs_filepath_exists_user   ; 21
1114   0622             
1115   0622 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1115   0626 79 73 63 61 
1115   062A 6C 6C 5F 66 
1115   062E 69 6C 65 5F 
1115   0632 73 79 73 74 
1115   0636 65 6D 20 63 
1115   063A 61 6C 6C 65 
1115   063E 64 3A 20 00 
1116   0642             syscall_file_system:
1117   0642 DD            push bl
1118   0643 31 C0 17      mov bl, [sys_debug_mode]
1119   0646               ; debug block
1120   0646 C1 00         cmp bl, 0
1121   0648 EA            pop bl
1122   0649 C6 5D 06      je syscall_filesystem_jmp
1123   064C DA            push d
1124   064D DD            push bl
1125   064E 3B 22 06      mov d, s_syscall_fs_dbg0
1126   0651 07 97 12      call _puts
1127   0654 2F            mov bl, al
1128   0655 07 37 13      call print_u8x
1129   0658 07 44 12      call printnl
1130   065B EA            pop bl
1131   065C E7            pop d
1132   065D             syscall_filesystem_jmp:
1133   065D FD 0A F6 05   jmp [file_system_jmptbl + al]
1134   0661             
1135   0661             fs_mkfs:  
1136   0661 06            sysret  
1137   0662               
1138   0662             fs_cd_root:
1139   0662 10 20 00      mov a, root_id
1140   0665 42 D1 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1141   0668 06            sysret  
1142   0669             
1143   0669             ; filename in D (userspace data)
1144   0669             ; permission in BL
1145   0669             fs_chmod:
1146   0669 DD            push bl
1147   066A FD 4E         mov si, d
1148   066C FD 4F 1D 1F   mov di, user_data
1149   0670 38 80 00      mov c, 128
1150   0673 04            load                        ; load filename from user-space
1151   0674 14 D1 17      mov a, [current_dir_id]
1152   0677 77            inc a                       ; metadata sector
1153   0678 27            mov b, a
1154   0679 38 00 00      mov c, 0                    ; upper LBA = 0
1155   067C 22 01         mov ah, $01                  ; 1 sector
1156   067E 3B 1D 27      mov d, transient_area
1157   0681 07 F4 04      call ide_read_sect          ; read directory
1158   0684 FD 10         cla
1159   0686 42 C9 17      mov [index], a              ; reset file counter
1160   0689             fs_chmod_L1:
1161   0689 FD 4E         mov si, d
1162   068B FD 4F 1D 1F   mov di, user_data
1163   068F 07 DA 10      call _strcmp
1164   0692 C6 A9 06      je fs_chmod_found_entry
1165   0695 58 20 00      add d, 32
1166   0698 14 C9 17      mov a, [index]
1167   069B 77            inc a
1168   069C 42 C9 17      mov [index], a
1169   069F AF 10 00      cmp a, FST_FILES_PER_DIR
1170   06A2 C7 89 06      jne fs_chmod_L1
1171   06A5 EA            pop bl
1172   06A6 0A C2 06      jmp fs_chmod_not_found
1173   06A9             fs_chmod_found_entry:  
1174   06A9 FD 79         mov g, b                    ; save LBA
1175   06AB EA            pop bl                      ; retrieve saved permission value
1176   06AC 1F 18 00      mov al, [d + 24]            ; read file permissions
1177   06AF 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1178   06B1 8C            or al, bl                   ; set new permissions
1179   06B2 3F 18 00      mov [d + 24], al            ; write new permissions
1180   06B5 38 00 00      mov c, 0
1181   06B8 3B 1D 27      mov d, transient_area
1182   06BB 22 01         mov ah, $01                 ; disk write 1 sect
1183   06BD FD 27         mov b, g                    ; retrieve LBA
1184   06BF 07 1A 05      call ide_write_sect         ; write sector
1185   06C2             fs_chmod_not_found:
1186   06C2 06            sysret
1187   06C3             
1188   06C3             ;------------------------------------------------------------------------------------------------------;
1189   06C3             ; CREATE NEW DIRECTORY
1190   06C3             ;------------------------------------------------------------------------------------------------------;
1191   06C3             ; search list for NULL name entry. add new directory to list
1192   06C3             fs_mkdir:
1193   06C3 FD 4E         mov si, d
1194   06C5 FD 4F 1D 1F   mov di, user_data
1195   06C9 38 00 02      mov c, 512
1196   06CC 04            load                        ; load data from user-space
1197   06CD 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1198   06D0                                           ; when checking for NULL name, since root has a NULL name)
1199   06D0 38 00 00      mov c, 0                    ; upper LBA = 0
1200   06D3             fs_mkdir_L1:  
1201   06D3 22 01         mov ah, $01                  ; 1 sector
1202   06D5 3B 1D 27      mov d, transient_area
1203   06D8 07 F4 04      call ide_read_sect          ; read sector
1204   06DB BD 00         cmp byte[d], 0              ; check for NULL
1205   06DD C6 E6 06      je fs_mkdir_found_null
1206   06E0 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1207   06E3 0A D3 06      jmp fs_mkdir_L1
1208   06E6             fs_mkdir_found_null:
1209   06E6             ;create header file by grabbing dir name from parameter
1210   06E6 D8            push b                      ; save new directory's LBA
1211   06E7 38 40 00      mov c, 64
1212   06EA FD 4D 1D 1F   mov si, user_data
1213   06EE FD 4F 1D 27   mov di, transient_area
1214   06F2 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1215   06F4 14 D1 17      mov a, [current_dir_id]
1216   06F7 42 5D 27      mov [transient_area + 64], a    ; store parent directory LBA
1217   06FA 19 00         mov al, 0
1218   06FC FD 4F 1D 29   mov di, transient_area + 512
1219   0700 38 00 02      mov c, 512
1220   0703 FD F7         rep stosb                       ; clean buffer
1221   0705 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1222   0708             ; write directory entry sectors
1223   0708 3B 1D 27      mov d, transient_area
1224   070B 22 02         mov ah, $02                     ; disk write, 2 sectors
1225   070D 07 1A 05      call ide_write_sect             ; write sector
1226   0710             ; now we need to add the new directory to the list, insIDE the current directory
1227   0710 14 D1 17      mov a, [current_dir_id]
1228   0713 53 01 00      add a, 1
1229   0716 27            mov b, a                        ; metadata sector
1230   0717 38 00 00      mov c, 0
1231   071A FD 79         mov g, b                        ; save LBA
1232   071C 3B 1D 27      mov d, transient_area
1233   071F 22 01         mov ah, $01                  ; 1 sector
1234   0721 07 F4 04      call ide_read_sect              ; read metadata sector
1235   0724             fs_mkdir_L2:
1236   0724 BD 00         cmp byte[d], 0
1237   0726 C6 2F 07      je fs_mkdir_found_null2
1238   0729 58 20 00      add d, FST_ENTRY_SIZE
1239   072C 0A 24 07      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1240   072F             fs_mkdir_found_null2:
1241   072F FD 4D 1D 1F   mov si, user_data
1242   0733 FD 50         mov di, d
1243   0735 07 EF 10      call _strcpy                    ; copy directory name
1244   0738 58 18 00      add d, 24                       ; goto ATTRIBUTES
1245   073B 19 0B         mov al, %00001011               ; directory, no execute, write, read
1246   073D 3E            mov [d], al      
1247   073E 79            inc d
1248   073F E5            pop b
1249   0740 D8            push b                          ; push LBA back
1250   0741 FD 43         mov [d], b                      ; save LBA
1251   0743             ; set file creation date  
1252   0743 58 04 00      add d, 4
1253   0746 19 04         mov al, 4
1254   0748 05 01         syscall sys_rtc
1255   074A 1A            mov al, ah
1256   074B 3E            mov [d], al                     ; set day
1257   074C 79            inc d
1258   074D 19 05         mov al, 5
1259   074F 05 01         syscall sys_rtc
1260   0751 1A            mov al, ah
1261   0752 3E            mov [d], al                     ; set month
1262   0753 79            inc d
1263   0754 19 06         mov al, 6
1264   0756 05 01         syscall sys_rtc
1265   0758 1A            mov al, ah
1266   0759 3E            mov [d], al                     ; set year
1267   075A             ; write sector into disk for new directory entry
1268   075A FD 27         mov b, g
1269   075C 38 00 00      mov c, 0
1270   075F 3B 1D 27      mov d, transient_area
1271   0762 22 01         mov ah, $01                     ; disk write, 1 sector
1272   0764 07 1A 05      call ide_write_sect             ; write sector
1273   0767             
1274   0767             ; after adding the new directory's information to its parent directory's list
1275   0767             ; we need to now enter the new directory, and to it add two new directories!
1276   0767             ; which directories do we need to add ? '..' and '.' are the directories needed.
1277   0767             ; importantly, note that these two new directories are only entries in the list
1278   0767             ; and do not have actual physical entries in the disk as real directories.
1279   0767             ; i.e. they only exist as list entries in the new directory created so that
1280   0767             ; the new directory can reference its parent and itself.
1281   0767             ; We need to add both '..' and '.'
1282   0767             ; this first section is for '..' and on the section below we do the same for '.'
1283   0767 E4            pop a                         ; retrieve the new directory's LBA  
1284   0768 D7            push a                        ; and save again
1285   0769 53 01 00      add a, 1
1286   076C 27            mov b, a                      ; metadata sector
1287   076D 38 00 00      mov c, 0
1288   0770 FD 79         mov g, b                      ; save LBA
1289   0772 3B 1D 27      mov d, transient_area
1290   0775 22 01         mov ah, $01                  ; 1 sector
1291   0777 07 F4 04      call ide_read_sect            ; read metadata sector
1292   077A             fs_mkdir_L3:
1293   077A BD 00         cmp byte[d], 0
1294   077C C6 85 07      je fs_mkdir_found_null3
1295   077F 58 20 00      add d, FST_ENTRY_SIZE
1296   0782 0A 7A 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1297   0785             fs_mkdir_found_null3:
1298   0785 FD 4D F0 17   mov si, s_parent_dir
1299   0789 FD 50         mov di, d
1300   078B 07 EF 10      call _strcpy                  ; copy directory name
1301   078E 58 18 00      add d, 24                     ; goto ATTRIBUTES
1302   0791 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1303   0793 3E            mov [d], al      
1304   0794 79            inc d
1305   0795 29 D1 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1306   0798 FD 43         mov [d], b                    ; save LBA
1307   079A             ; set file creation date  
1308   079A 58 04 00      add d, 4
1309   079D 19 04         mov al, 4
1310   079F 05 01         syscall sys_rtc
1311   07A1 1A            mov al, ah
1312   07A2 3E            mov [d], al                   ; set day
1313   07A3 79            inc d
1314   07A4 19 05         mov al, 5
1315   07A6 05 01         syscall sys_rtc
1316   07A8 1A            mov al, ah
1317   07A9 3E            mov [d], al                   ; set month
1318   07AA 79            inc d
1319   07AB 19 06         mov al, 6
1320   07AD 05 01         syscall sys_rtc
1321   07AF 1A            mov al, ah
1322   07B0 3E            mov [d], al                   ; set year
1323   07B1             ; write sector into disk for new directory entry
1324   07B1 FD 27         mov b, g
1325   07B3 38 00 00      mov c, 0
1326   07B6 3B 1D 27      mov d, transient_area
1327   07B9 22 01         mov ah, $01                   ; disk write, 1 sector
1328   07BB 07 1A 05      call ide_write_sect           ; write sector
1329   07BE             ;;;;;;;;;;;;;
1330   07BE             ; like we did above for '..', we need to now add the '.' directory to the list.
1331   07BE             ;------------------------------------------------------------------------------------------------------;
1332   07BE E4            pop a                         ; retrieve the new directory's LBA  
1333   07BF D7            push a
1334   07C0 53 01 00      add a, 1
1335   07C3 27            mov b, a                      ; metadata sector
1336   07C4 38 00 00      mov c, 0
1337   07C7 FD 79         mov g, b                      ; save LBA
1338   07C9 3B 1D 27      mov d, transient_area
1339   07CC 22 01         mov ah, $01                  ; 1 sector
1340   07CE 07 F4 04      call ide_read_sect            ; read metadata sector
1341   07D1             fs_mkdir_L4:
1342   07D1 BD 00         cmp byte[d], 0
1343   07D3 C6 DC 07      je fs_mkdir_found_null4
1344   07D6 58 20 00      add d, FST_ENTRY_SIZE
1345   07D9 0A D1 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1346   07DC             fs_mkdir_found_null4:
1347   07DC FD 4D F3 17   mov si, s_current_dir
1348   07E0 FD 50         mov di, d
1349   07E2 07 EF 10      call _strcpy                  ; copy directory name
1350   07E5 58 18 00      add d, 24                     ; goto ATTRIBUTES
1351   07E8 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1352   07EA 3E            mov [d], al      
1353   07EB 79            inc d
1354   07EC E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1355   07ED FD 43         mov [d], b                    ; save LBA
1356   07EF             ; set file creation date  
1357   07EF 58 04 00      add d, 4
1358   07F2 19 04         mov al, 4
1359   07F4 05 01         syscall sys_rtc
1360   07F6 1A            mov al, ah
1361   07F7 3E            mov [d], al                   ; set day
1362   07F8 79            inc d
1363   07F9 19 05         mov al, 5
1364   07FB 05 01         syscall sys_rtc
1365   07FD 1A            mov al, ah
1366   07FE 3E            mov [d], al                   ; set month
1367   07FF 79            inc d
1368   0800 19 06         mov al, 6
1369   0802 05 01         syscall sys_rtc
1370   0804 1A            mov al, ah
1371   0805 3E            mov [d], al                   ; set year
1372   0806             ; write sector into disk for new directory entry
1373   0806 FD 27         mov b, g
1374   0808 38 00 00      mov c, 0
1375   080B 3B 1D 27      mov d, transient_area
1376   080E 22 01         mov ah, $01                   ; disk write, 1 sector
1377   0810 07 1A 05      call ide_write_sect           ; write sector
1378   0813             fs_mkdir_end:
1379   0813 06            sysret
1380   0814             
1381   0814             ;------------------------------------------------------------------------------------------------------;
1382   0814             ; get path from a given directory dirID
1383   0814             ; pseudo code:
1384   0814             ;  fs_dir_id_to_path(int dirID, char *D){
1385   0814             ;    if(dirID == 0){
1386   0814             ;      reverse path in D;
1387   0814             ;      return;
1388   0814             ;    }
1389   0814             ;    else{
1390   0814             ;      copy directory name to end of D;
1391   0814             ;      add '/' to end of D;
1392   0814             ;      parentID = get parent directory ID;
1393   0814             ;      fs_dir_id_to_path(parentID, D);
1394   0814             ;    }
1395   0814             ;  }
1396   0814             ; A = dirID
1397   0814             ; D = generated path string pointer
1398   0814             ;------------------------------------------------------------------------------------------------------;
1399   0814             ; sample path: /usr/bin
1400   0814             fs_dir_id_to_path:
1401   0814 3B 9D 1E      mov d, filename
1402   0817 19 00         mov al, 0
1403   0819 3E            mov [d], al                     ; initialize path string 
1404   081A 14 D1 17      mov a, [current_dir_id]
1405   081D 07 2A 08      call fs_dir_id_to_path_E0
1406   0820 3B 9D 1E      mov d, filename
1407   0823 07 83 10      call _strrev
1408   0826 07 97 12      call _puts
1409   0829 06            sysret
1410   082A             fs_dir_id_to_path_E0:
1411   082A 07 49 08      call get_dirname_from_dirID
1412   082D FD 4D F5 17   mov si, s_fslash
1413   0831 FD 50         mov di, d
1414   0833 07 FD 10      call _strcat                    ; add '/' to end of path
1415   0836 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1416   0839 C6 48 08      je fs_dir_id_to_path_root
1417   083C 07 66 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1418   083F AF 20 00      cmp a, root_id               ; check if we are at the root directory
1419   0842 C6 48 08      je fs_dir_id_to_path_root
1420   0845 07 2A 08      call fs_dir_id_to_path_E0     ; recursively call itself
1421   0848             fs_dir_id_to_path_root:
1422   0848 09            ret
1423   0849             
1424   0849             ;------------------------------------------------------------------------------------------------------;
1425   0849             ; in_puts:
1426   0849             ; A = directory ID
1427   0849             ; out_puts:
1428   0849             ; D = pointer to directory name string
1429   0849             ;------------------------------------------------------------------------------------------------------;
1430   0849             get_dirname_from_dirID:
1431   0849 D7            push a
1432   084A D8            push b
1433   084B DA            push d
1434   084C 27            mov b, a
1435   084D 38 00 00      mov c, 0                      ; upper LBA = 0
1436   0850 22 01         mov ah, $01                  ; 1 sector
1437   0852 3B 1D 25      mov d, transient_area - 512
1438   0855 07 F4 04      call ide_read_sect            ; read directory
1439   0858 07 83 10      call _strrev                  ; reverse dir name before copying
1440   085B FD 4E         mov si, d
1441   085D E7            pop d                         ; destination address = D value pushed at beginning
1442   085E FD 50         mov di, d
1443   0860 07 FD 10      call _strcat                  ; copy filename to D
1444   0863 E5            pop b
1445   0864 E4            pop a
1446   0865 09            ret
1447   0866             
1448   0866             ;------------------------------------------------------------------------------------------------------;
1449   0866             ; in_puts:
1450   0866             ; A = directory ID
1451   0866             ; out_puts:
1452   0866             ; A = parent directory ID
1453   0866             ;------------------------------------------------------------------------------------------------------;
1454   0866             get_parentID_from_dirID:
1455   0866 D8            push b
1456   0867 DA            push d
1457   0868 27            mov b, a
1458   0869 38 00 00      mov c, 0                      ; upper LBA = 0
1459   086C 22 01         mov ah, $01                  ; 1 sector
1460   086E 3B 1D 25      mov d, transient_area - 512
1461   0871 07 F4 04      call ide_read_sect            ; read directory
1462   0874 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1463   0877 E7            pop d
1464   0878 E5            pop b
1465   0879 09            ret
1466   087A             
1467   087A             ;------------------------------------------------------------------------------------------------------;
1468   087A             ; get dirID from a given path string
1469   087A             ; in_puts:
1470   087A             ; D = path pointer 
1471   087A             ; out_puts:
1472   087A             ; A = dirID
1473   087A             ; if dir non existent, A = FFFF (fail code)
1474   087A             ; /usr/local/bin    - absolute
1475   087A             ; local/bin/games    - relative
1476   087A             ;------------------------------------------------------------------------------------------------------;
1477   087A             fs_path_to_dir_id_user:
1478   087A FD 4E         mov si, d
1479   087C FD 4F 1D 1F   mov di, user_data
1480   0880 38 00 02      mov c, 512
1481   0883 04            load
1482   0884 07 88 08      call get_dirID_from_path
1483   0887 06            sysret
1484   0888             get_dirID_from_path:
1485   0888 26 1D 1F      mov b, user_data
1486   088B FD 42 BC 16   mov [prog], b                  ; token pointer set to path string
1487   088F 07 1D 15      call get_token
1488   0892 31 BF 16      mov bl, [tok]
1489   0895 C1 01         cmp bl, TOK_FSLASH
1490   0897 C6 A3 08      je get_dirID_from_path_abs 
1491   089A 14 D1 17      mov a, [current_dir_id]
1492   089D 07 A3 16      call _putback
1493   08A0 0A A6 08      jmp get_dirID_from_path_E0
1494   08A3             get_dirID_from_path_abs:
1495   08A3 10 20 00      mov a, root_id
1496   08A6             get_dirID_from_path_E0:
1497   08A6 07 1D 15      call get_token
1498   08A9 31 BE 16      mov bl, [toktyp]
1499   08AC C1 00         cmp bl, TOKTYP_IDENTIFIER
1500   08AE C7 FF 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1501   08B1             
1502   08B1 FD 4D C0 16   mov si, tokstr
1503   08B5 FD 4F 9D 1E   mov di, filename
1504   08B9 07 EF 10      call _strcpy        
1505   08BC 77            inc a                         ; metadata sector
1506   08BD 27            mov b, a
1507   08BE 38 00 00      mov c, 0                      ; upper LBA = 0
1508   08C1 22 01         mov ah, $01                  ; 1 sector
1509   08C3 3B 1D 27      mov d, transient_area
1510   08C6 07 F4 04      call ide_read_sect            ; read directory
1511   08C9 FD 10         cla
1512   08CB 42 C9 17      mov [index], a
1513   08CE             get_dirID_from_path_L1:
1514   08CE FD 4E         mov si, d
1515   08D0 FD 4F 9D 1E   mov di, filename
1516   08D4 07 DA 10      call _strcmp
1517   08D7 C6 ED 08      je get_dirID_from_path_name_equal  
1518   08DA 58 20 00      add d, 32
1519   08DD 14 C9 17      mov a, [index]
1520   08E0 77            inc a
1521   08E1 42 C9 17      mov [index], a
1522   08E4 AF 10 00      cmp a, FST_FILES_PER_DIR
1523   08E7 C6 00 09      je get_dirID_from_path_fail
1524   08EA 0A CE 08      jmp get_dirID_from_path_L1
1525   08ED             get_dirID_from_path_name_equal:
1526   08ED 58 19 00      add d, 25           
1527   08F0 15            mov a, [d]                    ; set result register A = dirID
1528   08F1 07 1D 15      call get_token
1529   08F4 31 BF 16      mov bl, [tok]
1530   08F7 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1531   08F9 C6 A6 08      je get_dirID_from_path_E0
1532   08FC 07 A3 16      call _putback
1533   08FF             get_dirID_from_path_end:
1534   08FF 09            ret
1535   0900             get_dirID_from_path_fail:
1536   0900 10 FF FF      mov A, $FFFF
1537   0903 09            ret
1538   0904             
1539   0904             
1540   0904             ;------------------------------------------------------------------------------------------------------;
1541   0904             ; check if file exists by a given path string
1542   0904             ; in_puts:
1543   0904             ; D = path pointer 
1544   0904             ; OUTPUTS:
1545   0904             ; A = success code, if file exists gives LBA, else, give 0
1546   0904             ; /usr/local/bin/ed
1547   0904             ;------------------------------------------------------------------------------------------------------;
1548   0904             fs_filepath_exists_user:
1549   0904 FD 4E         mov si, d
1550   0906 FD 4F 1D 1F   mov di, user_data
1551   090A 38 00 02      mov c, 512
1552   090D 04            load
1553   090E 07 12 09      call file_exists_by_path
1554   0911 06            sysret
1555   0912             file_exists_by_path:
1556   0912 26 1D 1F      mov b, user_data
1557   0915 FD 42 BC 16   mov [prog], b                   ; token pointer set to path string
1558   0919 07 1D 15      call get_token
1559   091C 31 BF 16      mov bl, [tok]
1560   091F C1 01         cmp bl, TOK_FSLASH
1561   0921 C6 2D 09      je  file_exists_by_path_abs
1562   0924 14 D1 17      mov a, [current_dir_id]
1563   0927 07 A3 16      call _putback
1564   092A 0A 30 09      jmp file_exists_by_path_E0
1565   092D             file_exists_by_path_abs:
1566   092D 10 20 00      mov a, root_id
1567   0930             file_exists_by_path_E0:
1568   0930 07 1D 15      call get_token
1569   0933 31 BE 16      mov bl, [toktyp]
1570   0936 C1 00         cmp bl, TOKTYP_IDENTIFIER
1571   0938 C7 90 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1572   093B FD 4D C0 16   mov si, tokstr
1573   093F FD 4F 9D 1E   mov di, filename
1574   0943 07 EF 10      call _strcpy        
1575   0946 77            inc a                           ; metadata sector
1576   0947 27            mov b, a
1577   0948 38 00 00      mov c, 0                        ; upper LBA = 0
1578   094B 22 01         mov ah, $01                  ; 1 sector
1579   094D 3B 1D 27      mov d, transient_area
1580   0950 07 F4 04      call ide_read_sect              ; read directory
1581   0953 FD 10         cla
1582   0955 42 C9 17      mov [index], a
1583   0958             file_exists_by_path_L1:
1584   0958 FD 4E         mov si, d
1585   095A FD 4F 9D 1E   mov di, filename
1586   095E 07 DA 10      call _strcmp
1587   0961 C6 77 09      je   file_exists_by_path_name_equal
1588   0964 58 20 00      add d, 32
1589   0967 14 C9 17      mov a, [index]
1590   096A 77            inc a
1591   096B 42 C9 17      mov [index], a
1592   096E AF 10 00      cmp a, FST_FILES_PER_DIR
1593   0971 C6 90 09      je file_exists_by_path_end
1594   0974 0A 58 09      jmp file_exists_by_path_L1
1595   0977             file_exists_by_path_name_equal:
1596   0977 33 18 00      mov bl, [d + 24]
1597   097A FD 87 38      and bl, %00111000               ; directory flag
1598   097D C1 08         cmp bl, %00001000               ; is dir?
1599   097F C6 86 09      je file_exists_by_path_isdir;
1600   0982             ; entry is a file
1601   0982 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1602   0985 09            ret
1603   0986             file_exists_by_path_isdir:
1604   0986 58 19 00      add d, 25           
1605   0989 15            mov a, [d]                      ; set result register A = dirID
1606   098A 07 1D 15      call get_token
1607   098D 0A 30 09      jmp file_exists_by_path_E0
1608   0990             file_exists_by_path_end:
1609   0990 10 00 00      mov a, 0                        ; return 0 because file was not found
1610   0993 09            ret
1611   0994             
1612   0994             ;------------------------------------------------------------------------------------------------------;
1613   0994             ; load file data from a given path string
1614   0994             ; inputs:
1615   0994             ; D = path pointer 
1616   0994             ; DI = userspace program data destination
1617   0994             ; /usr/local/bin/ed
1618   0994             ; ./ed
1619   0994             ;------------------------------------------------------------------------------------------------------;
1620   0994             fs_load_from_path_user:
1621   0994 E3            push di
1622   0995 FD 4E         mov si, d
1623   0997 FD 4F 1D 1F   mov di, user_data
1624   099B 38 00 02      mov c, 512
1625   099E 04            load
1626   099F 07 AC 09      call loadfile_from_path
1627   09A2 F0            pop di
1628   09A3 FD 4D 1D 27   mov si, transient_area
1629   09A7 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1630   09AA 03            store
1631   09AB 06            sysret
1632   09AC             loadfile_from_path:
1633   09AC 26 1D 1F      mov b, user_data
1634   09AF FD 42 BC 16   mov [prog], b                 ; token pointer set to path string
1635   09B3 07 1D 15      call get_token
1636   09B6 31 BF 16      mov bl, [tok]
1637   09B9 C1 01         cmp bl, TOK_FSLASH
1638   09BB C6 C7 09      je loadfile_from_path_abs 
1639   09BE 14 D1 17      mov a, [current_dir_id]
1640   09C1 07 A3 16      call _putback
1641   09C4 0A CA 09      jmp loadfile_from_path_E0
1642   09C7             loadfile_from_path_abs:
1643   09C7 10 20 00      mov a, root_id
1644   09CA             loadfile_from_path_E0:
1645   09CA 07 1D 15      call get_token
1646   09CD 31 BE 16      mov bl, [toktyp]
1647   09D0 C1 00         cmp bl, TOKTYP_IDENTIFIER
1648   09D2 C7 37 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1649   09D5 FD 4D C0 16   mov si, tokstr
1650   09D9 FD 4F 9D 1E   mov di, filename
1651   09DD 07 EF 10      call _strcpy        
1652   09E0 77            inc a                         ; metadata sector
1653   09E1 27            mov b, a
1654   09E2 38 00 00      mov c, 0                      ; upper LBA = 0
1655   09E5 22 01         mov ah, $01                  ; 1 sector
1656   09E7 3B 1D 27      mov d, transient_area
1657   09EA 07 F4 04      call ide_read_sect            ; read directory
1658   09ED FD 10         cla
1659   09EF 42 C9 17      mov [index], a
1660   09F2             loadfile_from_path_L1:
1661   09F2 FD 4E         mov si, d
1662   09F4 FD 4F 9D 1E   mov di, filename
1663   09F8 07 DA 10      call _strcmp
1664   09FB C6 11 0A      je loadfile_from_path_name_equal  
1665   09FE 58 20 00      add d, 32
1666   0A01 14 C9 17      mov a, [index]
1667   0A04 77            inc a
1668   0A05 42 C9 17      mov [index], a
1669   0A08 AF 10 00      cmp a, FST_FILES_PER_DIR
1670   0A0B C6 37 0A      je loadfile_from_path_end
1671   0A0E 0A F2 09      jmp loadfile_from_path_L1
1672   0A11             loadfile_from_path_name_equal:
1673   0A11 33 18 00      mov bl, [d + 24]
1674   0A14 FD 87 38      and bl, %00111000             ; directory flag
1675   0A17 C1 08         cmp bl, %00001000             ; is dir?
1676   0A19 C6 2D 0A      je loadfile_isdirectory  
1677   0A1C             ; entry is a file
1678   0A1C 2B 19 00      mov b, [d + 25]               ; get LBA
1679   0A1F FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1680   0A21 3B 1D 27      mov d, transient_area
1681   0A24 38 00 00      mov c, 0
1682   0A27 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1683   0A29 07 F4 04      call ide_read_sect            ; read sector
1684   0A2C 09            ret
1685   0A2D             loadfile_isdirectory:
1686   0A2D 58 19 00      add d, 25           
1687   0A30 15            mov a, [d]                    ; set result register A = dirID
1688   0A31 07 1D 15      call get_token
1689   0A34 0A CA 09      jmp loadfile_from_path_E0
1690   0A37             loadfile_from_path_end:
1691   0A37 09            ret
1692   0A38             
1693   0A38             ;------------------------------------------------------------------------------------------------------;
1694   0A38             ; return the ID of the current directory
1695   0A38             ; ID returned in B
1696   0A38             ;------------------------------------------------------------------------------------------------------;
1697   0A38             fs_get_curr_dirID:
1698   0A38 29 D1 17      mov b, [current_dir_id]
1699   0A3B 06            sysret
1700   0A3C             
1701   0A3C             ;------------------------------------------------------------------------------------------------------;
1702   0A3C             ; CD
1703   0A3C             ;------------------------------------------------------------------------------------------------------;
1704   0A3C             ; new dirID in B
1705   0A3C             fs_cd:
1706   0A3C FD 42 D1 17   mov [current_dir_id], b
1707   0A40 06            sysret  
1708   0A41             
1709   0A41             ;------------------------------------------------------------------------------------------------------;
1710   0A41             ; LS
1711   0A41             ; dirID in B
1712   0A41             ;------------------------------------------------------------------------------------------------------;
1713   0A41 00 00       ls_count:       .dw 0
1714   0A43             fs_ls:
1715   0A43 FD 77         inc b                        ; metadata sector
1716   0A45 38 00 00      mov c, 0                     ; upper LBA = 0
1717   0A48 22 01         mov ah, $01                  ; 1 sector
1718   0A4A 3B 1D 27      mov d, transient_area
1719   0A4D 07 F4 04      call ide_read_sect           ; read directory
1720   0A50 FD 10         cla
1721   0A52 42 C9 17      mov [index], a               ; reset entry index
1722   0A55 3D 41 0A      mov [ls_count], al           ; reset item count
1723   0A58             fs_ls_L1:
1724   0A58 BD 00         cmp byte [d], 0              ; check for NULL
1725   0A5A C6 F1 0A      je fs_ls_next
1726   0A5D             fs_ls_non_null:
1727   0A5D 1D 41 0A      mov al, [ls_count]
1728   0A60 7A            inc al
1729   0A61 3D 41 0A      mov [ls_count], al           ; increment item count
1730   0A64 1F 18 00      mov al, [d + 24]
1731   0A67 87 38         and al, %00111000
1732   0A69 FD A2 03      shr al, 3
1733   0A6C 22 00         mov ah, 0                    ; file type
1734   0A6E B7 FC 17      mov a, [a + file_type]      
1735   0A71 23            mov ah, al
1736   0A72 07 6B 11      call _putchar
1737   0A75 1F 18 00      mov al, [d + 24]
1738   0A78 87 01         and al, %00000001
1739   0A7A 22 00         mov ah, 0
1740   0A7C B7 F7 17      mov a, [a + file_attrib]     ; read
1741   0A7F 23            mov ah, al
1742   0A80 07 6B 11      call _putchar
1743   0A83 1F 18 00      mov al, [d + 24]
1744   0A86 87 02         and al, %00000010
1745   0A88 22 00         mov ah, 0
1746   0A8A B7 F7 17      mov a, [a + file_attrib]     ; write
1747   0A8D 23            mov ah, al
1748   0A8E 07 6B 11      call _putchar
1749   0A91 1F 18 00      mov al, [d + 24]
1750   0A94 87 04         and al, %00000100
1751   0A96 22 00         mov ah, 0
1752   0A98 B7 F7 17      mov a, [a + file_attrib]     ; execute
1753   0A9B 23            mov ah, al
1754   0A9C 07 6B 11      call _putchar
1755   0A9F 22 20         mov ah, $20
1756   0AA1 07 6B 11      call _putchar  
1757   0AA4 2B 1B 00      mov b, [d + 27]
1758   0AA7 07 F3 12      call print_u16x              ; filesize
1759   0AAA 22 20         mov ah, $20
1760   0AAC 07 6B 11      call _putchar  
1761   0AAF 2B 19 00      mov b, [d + 25]
1762   0AB2 07 F3 12      call print_u16x              ; dirID / LBA
1763   0AB5 22 20         mov ah, $20
1764   0AB7 07 6B 11      call _putchar
1765   0ABA             ; print date
1766   0ABA 33 1D 00      mov bl, [d + 29]             ; day
1767   0ABD 07 37 13      call print_u8x
1768   0AC0 22 20         mov ah, $20
1769   0AC2 07 6B 11      call _putchar  
1770   0AC5 1F 1E 00      mov al, [d + 30]             ; month
1771   0AC8 FD 9E 02      shl al, 2
1772   0ACB DA            push d
1773   0ACC 3B BB 18      mov d, s_months
1774   0ACF 22 00         mov ah, 0
1775   0AD1 59            add d, a
1776   0AD2 07 97 12      call _puts
1777   0AD5 E7            pop d
1778   0AD6 22 20         mov ah, $20
1779   0AD8 07 6B 11      call _putchar
1780   0ADB 2E 20         mov bl, $20
1781   0ADD 07 37 13      call print_u8x
1782   0AE0 33 1F 00      mov bl, [d + 31]             ; year
1783   0AE3 07 37 13      call print_u8x  
1784   0AE6 22 20         mov ah, $20
1785   0AE8 07 6B 11      call _putchar  
1786   0AEB 07 97 12      call _puts                   ; print filename  
1787   0AEE 07 44 12      call printnl
1788   0AF1             fs_ls_next:
1789   0AF1 14 C9 17      mov a, [index]
1790   0AF4 77            inc a
1791   0AF5 42 C9 17      mov [index], a
1792   0AF8 AF 10 00      cmp a, FST_FILES_PER_DIR
1793   0AFB C6 04 0B      je fs_ls_end
1794   0AFE 58 20 00      add d, 32      
1795   0B01 0A 58 0A      jmp fs_ls_L1  
1796   0B04             fs_ls_end:
1797   0B04 3B 0C 18      mov d, s_ls_total
1798   0B07 07 97 12      call _puts
1799   0B0A 1D 41 0A      mov al, [ls_count]
1800   0B0D 07 49 13      call print_u8d
1801   0B10 07 44 12      call printnl
1802   0B13 06            sysret
1803   0B14             
1804   0B14             
1805   0B14             ;------------------------------------------------------------------------------------------------------;
1806   0B14             ; CREATE NEW TEXTFILE
1807   0B14             ;------------------------------------------------------------------------------------------------------;
1808   0B14             ; file structure:
1809   0B14             ; 512 bytes header
1810   0B14             ; header used to tell whether the block is free
1811   0B14             ; d = content pointer in user space
1812   0B14             ; c = file size
1813   0B14             ; TODO: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1814   0B14             fs_starcom:
1815   0B14 FD 4E       	mov si, d
1816   0B16 FD 4F 1D 27 	mov di, transient_area
1817   0B1A 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1818   0B1D 04          	load					; load data from user-space
1819   0B1E 07 9F 0B    	call fs_find_empty_block	; look for empty data blocks
1820   0B21 D8          	push b				; save empty block LBA
1821   0B22 FD 79         mov g, b
1822   0B24             ;create header file by grabbing file name from parameter	
1823   0B24 3B 1D 29    	mov d, transient_area + 512			; pointer to file contents
1824   0B27 D9          	push c							; save length
1825   0B28 19 01       	mov al, 1
1826   0B2A 3D 1D 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1827   0B2D 3B 1D 27    	mov d, transient_area
1828   0B30 12            mov a, c
1829   0B31 26 00 02      mov b, 512
1830   0B34 AE            div a, b
1831   0B35 FD 77         inc b         ; inc b as the division will most likely have a remainder
1832   0B37 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1833   0B38 38 00 00    	mov c, 0      ; lba 
1834   0B3B FD 27         mov b, g      ; lba 
1835   0B3D 07 1A 05    	call ide_write_sect			; write sectors
1836   0B40             ; now we add the file to the current directory!
1837   0B40             fs_starcom_add_to_dir:	
1838   0B40 14 D1 17    	mov a, [current_dir_id]
1839   0B43 77          	inc a
1840   0B44 27          	mov b, a					; metadata sector
1841   0B45 38 00 00    	mov c, 0
1842   0B48 FD 79       	mov g, b					; save LBA
1843   0B4A 3B 1D 25    	mov d, scrap_sector
1844   0B4D 22 01       	mov ah, $01			  ; 1 sector
1845   0B4F 07 F4 04    	call ide_read_sect		; read metadata sector
1846   0B52             fs_starcom_add_to_dir_L2:
1847   0B52 BD 00       	cmp byte[d], 0
1848   0B54 C6 5D 0B    	je fs_starcom_add_to_dir_null
1849   0B57 58 20 00    	add d, FST_ENTRY_SIZE
1850   0B5A 0A 52 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1851   0B5D             fs_starcom_add_to_dir_null:
1852   0B5D FD 4D 1E 27 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1853   0B61 FD 50       	mov di, d
1854   0B63 07 EF 10    	call _strcpy			; copy file name
1855   0B66 58 18 00    	add d, 24			; skip name
1856   0B69 19 07       	mov al, %00000111	; type=file, execute, write, read
1857   0B6B 3E          	mov [d], al			
1858   0B6C 58 03 00    	add d, 3
1859   0B6F E4          	pop a
1860   0B70 5F 00 02      sub a, 512
1861   0B73 43          	mov [d], a ; file size
1862   0B74 63 02 00    	sub d, 2
1863   0B77 E5          	pop b				; get file LBA
1864   0B78 FD 43       	mov [d], b			; save LBA	
1865   0B7A             ; set file creation date	
1866   0B7A 58 04 00    	add d, 4
1867   0B7D 19 04       	mov al, 4
1868   0B7F 05 01       	syscall sys_rtc
1869   0B81 1A          	mov al, ah
1870   0B82 3E          	mov [d], al			; set day
1871   0B83 79          	inc d
1872   0B84 19 05       	mov al, 5
1873   0B86 05 01       	syscall sys_rtc
1874   0B88 1A          	mov al, ah
1875   0B89 3E          	mov [d], al			; set month
1876   0B8A 79          	inc d
1877   0B8B 19 06       	mov al, 6
1878   0B8D 05 01       	syscall sys_rtc
1879   0B8F 1A          	mov al, ah
1880   0B90 3E          	mov [d], al			; set year
1881   0B91             ; write sector into disk for new directory entry
1882   0B91 FD 27       	mov b, g
1883   0B93 38 00 00    	mov c, 0
1884   0B96 3B 1D 25    	mov d, scrap_sector
1885   0B99 22 01       	mov ah, $01			; disk write, 1 sector
1886   0B9B 07 1A 05    	call ide_write_sect		; write sector
1887   0B9E 06          	sysret
1888   0B9F             
1889   0B9F             ;------------------------------------------------------------------------------------------------------;
1890   0B9F             ; finds an empty data block
1891   0B9F             ; block LBA returned in B
1892   0B9F             ;------------------------------------------------------------------------------------------------------;
1893   0B9F             fs_find_empty_block:
1894   0B9F 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1895   0BA2 38 00 00      mov c, 0                ; upper LBA = 0
1896   0BA5             fs_find_empty_block_L1:  
1897   0BA5 22 01         mov ah, $01                  ; 1 sector
1898   0BA7 3B 1D 25      mov d, transient_area - 512
1899   0BAA 07 F4 04      call ide_read_sect      ; read sector
1900   0BAD BD 00         cmp byte [d], 0
1901   0BAF C6 B8 0B      je fs_find_empty_block_found_null
1902   0BB2 55 20 00      add b, FS_SECTORS_PER_FILE
1903   0BB5 0A A5 0B      jmp fs_find_empty_block_L1
1904   0BB8             fs_find_empty_block_found_null:
1905   0BB8 09            ret
1906   0BB9             
1907   0BB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1908   0BB9             ;; CREATE NEW TEXTFILE
1909   0BB9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1910   0BB9             ; search for first null block
1911   0BB9             fs_mktxt:
1912   0BB9 FD 4E       	mov si, d
1913   0BBB FD 4F 1D 1F 	mov di, user_data
1914   0BBF 38 00 01    	mov c, 256
1915   0BC2 04          	load					; load data from user-space
1916   0BC3             	
1917   0BC3 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1918   0BC6 38 00 00    	mov c, 0						; reset LBA to 0
1919   0BC9             fs_mktxt_L1:	
1920   0BC9 10 02 01    	mov a, $0102			; disk read
1921   0BCC 3B 1D 27    	mov d, transient_area
1922   0BCF 05 02       	syscall sys_ide ; read sector
1923   0BD1 1E          	mov al, [d]
1924   0BD2 B9 00       	cmp al, 0			; check for NULL
1925   0BD4 C6 DD 0B    	je fs_mktxt_found_null
1926   0BD7 55 20 00    	add b, FS_SECTORS_PER_FILE
1927   0BDA 0A C9 0B    	jmp fs_mktxt_L1
1928   0BDD             fs_mktxt_found_null:
1929   0BDD D8          	push b				; save LBA
1930   0BDE             ;create header file by grabbing file name from parameter	
1931   0BDE 3B ED 17    	mov d, s_dataentry
1932   0BE1 07 97 12    	call _puts
1933   0BE4 3B 1D 29    	mov d, transient_area + 512			; pointer to file contents
1934   0BE7 07 FD 11    	call _gettxt
1935   0BEA 07 CA 10    	call _strlen						; get length of file
1936   0BED D9          	push c							; save length
1937   0BEE 19 01       	mov al, 1
1938   0BF0 3D 1D 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1939   0BF3 10 00 00    	mov a, 0
1940   0BF6 42 C9 17    	mov [index], a
1941   0BF9 3B 1D 27    	mov d, transient_area
1942   0BFC 13          	mov a, d
1943   0BFD 42 CB 17    	mov [buffer_addr], a
1944   0C00             fs_mktxt_L2:
1945   0C00 38 00 00    	mov c, 0
1946   0C03 10 03 01    	mov a, $0103			; disk write, 1 sector
1947   0C06 05 02       	syscall sys_ide		; write sector
1948   0C08 14 C9 17    	mov a, [index]
1949   0C0B 77          	inc a
1950   0C0C 42 C9 17    	mov [index], a
1951   0C0F AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1952   0C12 C6 24 0C    	je fs_mktxt_add_to_dir
1953   0C15 FD 77       	inc b
1954   0C17 14 CB 17    	mov a, [buffer_addr]
1955   0C1A 53 00 02    	add a, 512
1956   0C1D 42 CB 17    	mov [buffer_addr], a
1957   0C20 3C          	mov d, a
1958   0C21 0A 00 0C    	jmp fs_mktxt_L2
1959   0C24             ; now we add the file to the current directory!
1960   0C24             fs_mktxt_add_to_dir:	
1961   0C24 14 D1 17    	mov a, [current_dir_id]
1962   0C27 77          	inc a
1963   0C28 27          	mov b, a					; metadata sector
1964   0C29 38 00 00    	mov c, 0
1965   0C2C FD 79       	mov g, b					; save LBA
1966   0C2E 3B 1D 27    	mov d, transient_area
1967   0C31 10 02 01    	mov a, $0102			; disk read
1968   0C34 05 02       	syscall sys_ide		; read metadata sector
1969   0C36             fs_mktxt_add_to_dir_L2:
1970   0C36 1E          	mov al, [d]
1971   0C37 B9 00       	cmp al, 0
1972   0C39 C6 42 0C    	je fs_mktxt_add_to_dir_null
1973   0C3C 58 20 00    	add d, FST_ENTRY_SIZE
1974   0C3F 0A 36 0C    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1975   0C42             fs_mktxt_add_to_dir_null:
1976   0C42 FD 4D 1D 1F 	mov si, user_data
1977   0C46 FD 50       	mov di, d
1978   0C48 07 EF 10    	call _strcpy			; copy file name
1979   0C4B 58 18 00    	add d, 24			; skip name
1980   0C4E 19 06       	mov al, %00000110		; no execute, write, read, not directory
1981   0C50 3E          	mov [d], al			
1982   0C51 58 03 00    	add d, 3
1983   0C54 E4          	pop a
1984   0C55 43          	mov [d], a
1985   0C56 63 02 00    	sub d, 2
1986   0C59 E5          	pop b				; get file LBA
1987   0C5A FD 43       	mov [d], b			; save LBA	
1988   0C5C             	
1989   0C5C             	; set file creation date	
1990   0C5C 58 04 00    	add d, 4
1991   0C5F 19 04       	mov al, 4
1992   0C61 05 01       	syscall sys_rtc
1993   0C63 1A          	mov al, ah
1994   0C64 3E          	mov [d], al			; set day
1995   0C65             	
1996   0C65 79          	inc d
1997   0C66 19 05       	mov al, 5
1998   0C68 05 01       	syscall sys_rtc
1999   0C6A 1A          	mov al, ah
2000   0C6B 3E          	mov [d], al			; set month
2001   0C6C             	
2002   0C6C 79          	inc d
2003   0C6D 19 06       	mov al, 6
2004   0C6F 05 01       	syscall sys_rtc
2005   0C71 1A          	mov al, ah
2006   0C72 3E          	mov [d], al			; set year
2007   0C73             	
2008   0C73             ; write sector into disk for new directory entry
2009   0C73 FD 27       	mov b, g
2010   0C75 38 00 00    	mov c, 0
2011   0C78 3B 1D 27    	mov d, transient_area
2012   0C7B 10 03 01    	mov a, $0103			; disk write, 1 sector
2013   0C7E 05 02       	syscall sys_ide		; write sector
2014   0C80 07 44 12    	call printnl
2015   0C83 06          	sysret
2016   0C84             
2017   0C84             
2018   0C84             
2019   0C84             ;------------------------------------------------------------------------------------------------------;
2020   0C84             ; create new binary file
2021   0C84             ;------------------------------------------------------------------------------------------------------;
2022   0C84             ; search for first null block
2023   0C84             fs_mkbin:
2024   0C84 19 00         mov al, 0
2025   0C86 3D C1 17      mov [sys_echo_on], al ; disable echo
2026   0C89 FD 4E         mov si, d
2027   0C8B FD 4F 1D 1F   mov di, user_data
2028   0C8F 38 00 02      mov c, 512
2029   0C92 04            load                          ; load data from user-space
2030   0C93 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2031   0C96 38 00 00      mov c, 0                      ; upper LBA = 0
2032   0C99             fs_mkbin_L1:  
2033   0C99 22 01         mov ah, $01                  ; 1 sector
2034   0C9B 3B 1D 27      mov d, transient_area
2035   0C9E 07 F4 04      call ide_read_sect            ; read sector
2036   0CA1 BD 00         cmp byte[d], 0                ; check for NULL
2037   0CA3 C6 AC 0C      je fs_mkbin_found_null
2038   0CA6 55 20 00      add b, FS_SECTORS_PER_FILE
2039   0CA9 0A 99 0C      jmp fs_mkbin_L1
2040   0CAC             fs_mkbin_found_null:
2041   0CAC D8            push b                        ; save LBA
2042   0CAD             ;create header file by grabbing file name from parameter
2043   0CAD FD 4F 1D 29   mov di, transient_area + 512  ; pointer to file contents
2044   0CB1 07 27 10      call _load_hex                ; load binary hex
2045   0CB4 D9            push c                        ; save size (nbr of bytes)
2046   0CB5 19 01         mov al, 1
2047   0CB7 3D 1D 27      mov [transient_area], al      ; mark sectors as USED (not NULL)
2048   0CBA FD 10         cla
2049   0CBC 42 C9 17      mov [index], a
2050   0CBF 3B 1D 27      mov d, transient_area
2051   0CC2 13            mov a, d
2052   0CC3 42 CB 17      mov [buffer_addr], a
2053   0CC6             fs_mkbin_L2:
2054   0CC6 38 00 00      mov c, 0
2055   0CC9 22 01         mov ah, $01                   ; disk write, 1 sector
2056   0CCB 07 1A 05      call ide_write_sect           ; write sector
2057   0CCE 14 C9 17      mov a, [index]
2058   0CD1 77            inc a
2059   0CD2 42 C9 17      mov [index], a
2060   0CD5 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2061   0CD8 C6 EA 0C      je fs_mkbin_add_to_dir
2062   0CDB FD 77         inc b
2063   0CDD 14 CB 17      mov a, [buffer_addr]
2064   0CE0 53 00 02      add a, 512
2065   0CE3 42 CB 17      mov [buffer_addr], a
2066   0CE6 3C            mov d, a
2067   0CE7 0A C6 0C      jmp fs_mkbin_L2
2068   0CEA             ; now we add the file to the current directory!
2069   0CEA             fs_mkbin_add_to_dir:  
2070   0CEA 14 D1 17      mov a, [current_dir_id]
2071   0CED 77            inc a
2072   0CEE 27            mov b, a                      ; metadata sector
2073   0CEF 38 00 00      mov c, 0
2074   0CF2 FD 79         mov g, b                      ; save LBA
2075   0CF4 3B 1D 27      mov d, transient_area
2076   0CF7 22 01         mov ah, $01                  ; 1 sector
2077   0CF9 07 F4 04      call ide_read_sect            ; read metadata sector
2078   0CFC             fs_mkbin_add_to_dir_L2:
2079   0CFC BD 00         cmp byte[d], 0
2080   0CFE C6 07 0D      je fs_mkbin_add_to_dir_null
2081   0D01 58 20 00      add d, FST_ENTRY_SIZE
2082   0D04 0A FC 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2083   0D07             fs_mkbin_add_to_dir_null:
2084   0D07 FD 4D 1D 1F   mov si, user_data
2085   0D0B FD 50         mov di, d
2086   0D0D 07 EF 10      call _strcpy                  ; copy file name
2087   0D10 58 18 00      add d, 24                     ; skip name
2088   0D13 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2089   0D15 3E            mov [d], al
2090   0D16 58 03 00      add d, 3
2091   0D19 E4            pop a
2092   0D1A 43            mov [d], a
2093   0D1B 63 02 00      sub d, 2
2094   0D1E E5            pop b                         ; get file LBA
2095   0D1F FD 43         mov [d], b                    ; save LBA
2096   0D21               ; set file creation date  
2097   0D21 58 04 00      add d, 4
2098   0D24 19 04         mov al, 4
2099   0D26 05 01         syscall sys_rtc
2100   0D28 1A            mov al, ah
2101   0D29 3E            mov [d], al                   ; set day
2102   0D2A 79            inc d
2103   0D2B 19 05         mov al, 5
2104   0D2D 05 01         syscall sys_rtc
2105   0D2F 1A            mov al, ah
2106   0D30 3E            mov [d], al                   ; set month
2107   0D31 79            inc d
2108   0D32 19 06         mov al, 6
2109   0D34 05 01         syscall sys_rtc
2110   0D36 1A            mov al, ah
2111   0D37 3E            mov [d], al                   ; set year
2112   0D38             ; write sector into disk for new directory entry
2113   0D38 FD 27         mov b, g
2114   0D3A 38 00 00      mov c, 0
2115   0D3D 3B 1D 27      mov d, transient_area
2116   0D40 22 01         mov ah, $01                   ; disk write, 1 sector
2117   0D42 07 1A 05      call ide_write_sect           ; write sector
2118   0D45 19 01         mov al, 1
2119   0D47 3D C1 17      mov [sys_echo_on], al ; enable echo
2120   0D4A 06            sysret
2121   0D4B             
2122   0D4B             ;------------------------------------------------------------------------------------------------------;
2123   0D4B             ; pwd - print working directory
2124   0D4B             ;------------------------------------------------------------------------------------------------------;    
2125   0D4B             fs_pwd:
2126   0D4B 3B 9D 1E      mov d, filename
2127   0D4E 19 00         mov al, 0
2128   0D50 3E            mov [d], al                   ; initialize path string 
2129   0D51 14 D1 17      mov a, [current_dir_id]
2130   0D54 07 2A 08      call fs_dir_id_to_path_E0
2131   0D57 3B 9D 1E      mov d, filename
2132   0D5A 07 83 10      call _strrev
2133   0D5D 07 97 12      call _puts
2134   0D60 07 44 12      call printnl
2135   0D63 06            sysret
2136   0D64             
2137   0D64             ;------------------------------------------------------------------------------------------------------;
2138   0D64             ; get current directory LBA
2139   0D64             ; A: returned LBA
2140   0D64             ;------------------------------------------------------------------------------------------------------;
2141   0D64             cmd_get_curr_dir_LBA:
2142   0D64 14 D1 17      mov a, [current_dir_id]
2143   0D67 06            sysret
2144   0D68             
2145   0D68             ;------------------------------------------------------------------------------------------------------;
2146   0D68             ; CAT
2147   0D68             ; userspace destination data pointer in D
2148   0D68             ; filename starts at D, but is overwritten after the read is made
2149   0D68             ;------------------------------------------------------------------------------------------------------;:
2150   0D68             fs_cat:
2151   0D68 DA            push d                              ; save userspace file data destination
2152   0D69 FD 4E         mov si, d
2153   0D6B FD 4F 1D 1F   mov di, user_data
2154   0D6F 38 00 02      mov c, 512
2155   0D72 04            load                                ; copy filename from user-space
2156   0D73 29 D1 17      mov b, [current_dir_id]
2157   0D76 FD 77         inc b                               ; metadata sector
2158   0D78 38 00 00      mov c, 0                            ; upper LBA = 0
2159   0D7B 22 01         mov ah, $01                  ; 1 sector
2160   0D7D 3B 1D 25      mov d, transient_area-512
2161   0D80 07 F4 04      call ide_read_sect                  ; read directory
2162   0D83 FD 10         cla
2163   0D85 42 C9 17      mov [index], a                      ; reset file counter
2164   0D88             fs_cat_L1:
2165   0D88 FD 4E         mov si, d
2166   0D8A FD 4F 1D 1F   mov di, user_data
2167   0D8E 07 DA 10      call _strcmp
2168   0D91 C6 A7 0D      je fs_cat_found_entry
2169   0D94 58 20 00      add d, 32
2170   0D97 14 C9 17      mov a, [index]
2171   0D9A 77            inc a
2172   0D9B 42 C9 17      mov [index], a
2173   0D9E AF 10 00      cmp a, FST_FILES_PER_DIR
2174   0DA1 C6 C2 0D      je fs_cat_not_found
2175   0DA4 0A 88 0D      jmp fs_cat_L1
2176   0DA7             fs_cat_found_entry:
2177   0DA7 58 19 00      add d, 25                           ; get to dirID of file in disk
2178   0DAA 2A            mov b, [d]                          ; get LBA
2179   0DAB FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2180   0DAD 3B 1D 27      mov d, transient_area  
2181   0DB0 38 00 00      mov c, 0
2182   0DB3 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2183   0DB5 07 F4 04      call ide_read_sect                  ; read sectors
2184   0DB8 F0            pop di                              ; write userspace file data destination to DI
2185   0DB9 FD 4D 1D 27   mov si, transient_area              ; data origin
2186   0DBD 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2187   0DC0 03            store
2188   0DC1 06            sysret
2189   0DC2             fs_cat_not_found:
2190   0DC2 E7            pop d
2191   0DC3 06            sysret
2192   0DC4             
2193   0DC4             ;------------------------------------------------------------------------------------------------------;
2194   0DC4             ; RMDIR - remove DIR by dirID
2195   0DC4             ;------------------------------------------------------------------------------------------------------;
2196   0DC4             ; deletes a directory entry in the given directory's file list 
2197   0DC4             ; also deletes the actual directory entry in the FST
2198   0DC4             ; synopsis: rmdir /usr/local/testdir
2199   0DC4             ; B = dirID
2200   0DC4             fs_rmdir:
2201   0DC4 FD 79         mov g, b
2202   0DC6 11            mov a, b
2203   0DC7 07 66 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2204   0DCA D7            push a                        ; save dirID
2205   0DCB             ; search for directory's entry in the parent's directory then and delete it
2206   0DCB 77            inc a                         ; metadata sector
2207   0DCC 27            mov b, a
2208   0DCD 38 00 00      mov c, 0                      ; upper LBA = 0
2209   0DD0 22 01         mov ah, $01          ;
2210   0DD2 3B 1D 27      mov d, transient_area
2211   0DD5 07 F4 04      call ide_read_sect            ; read directory
2212   0DD8 FD 10         cla
2213   0DDA 42 C9 17      mov [index], a                ; reset file counter
2214   0DDD FD 27         mov b, g                      ; retrieve directory's dirID
2215   0DDF             fs_rmdir_L1:
2216   0DDF 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2217   0DE2 B0            cmp a, b                      ; compare dirID's to find the directory
2218   0DE3 C6 F9 0D      je fs_rmdir_found_entry
2219   0DE6 58 20 00      add d, 32
2220   0DE9 14 C9 17      mov a, [index]
2221   0DEC 77            inc a
2222   0DED 42 C9 17      mov [index], a
2223   0DF0 AF 10 00      cmp a, FST_FILES_PER_DIR
2224   0DF3 C6 1E 0E      je fs_rmdir_not_found
2225   0DF6 0A DF 0D      jmp fs_rmdir_L1
2226   0DF9             fs_rmdir_found_entry:
2227   0DF9 FD 10         cla
2228   0DFB 3E            mov [d], al                   ; make filename NULL
2229   0DFC 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2230   0DFF E5            pop b
2231   0E00 FD 77         inc b                         ; metadata sector
2232   0E02 38 00 00      mov c, 0                      ; upper LBA = 0
2233   0E05 22 01         mov ah, $01          ; 
2234   0E07 3B 1D 27      mov d, transient_area
2235   0E0A 07 1A 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2236   0E0D             
2237   0E0D FD 27         mov b, g
2238   0E0F 3B 1D 27      mov d, transient_area  
2239   0E12 FD 10         cla
2240   0E14 3E            mov [d], al                   ; make directory's name header NULL for re-use
2241   0E15 38 00 00      mov c, 0
2242   0E18 22 01         mov ah, $01                   ; disk write 1 sect
2243   0E1A 07 1A 05      call ide_write_sect           ; delete directory given by dirID in B
2244   0E1D 06            sysret
2245   0E1E             fs_rmdir_not_found:
2246   0E1E E5            pop b
2247   0E1F 06            sysret
2248   0E20             
2249   0E20             ;------------------------------------------------------------------------------------------------------;
2250   0E20             ; RM - remove file
2251   0E20             ;------------------------------------------------------------------------------------------------------;
2252   0E20             ; frees up the data sectors for the file further down the disk
2253   0E20             ; deletes file entry in the directory's file list 
2254   0E20             fs_rm:
2255   0E20 FD 4E         mov si, d
2256   0E22 FD 4F 1D 1F   mov di, user_data
2257   0E26 38 00 02      mov c, 512
2258   0E29 04            load                          ; load data from user-space
2259   0E2A 14 D1 17      mov a, [current_dir_id]
2260   0E2D 77            inc a                         ; metadata sector
2261   0E2E 27            mov b, a
2262   0E2F 38 00 00      mov c, 0                      ; upper LBA = 0
2263   0E32 22 01         mov ah, $01                  ; 1 sector
2264   0E34 3B 1D 27      mov d, transient_area
2265   0E37 07 F4 04      call ide_read_sect            ; read directory
2266   0E3A 10 00 00      mov a, 0
2267   0E3D 42 C9 17      mov [index], a                ; reset file counter
2268   0E40             fs_rm_L1:
2269   0E40 FD 4E         mov si, d
2270   0E42 FD 4F 1D 1F   mov di, user_data
2271   0E46 07 DA 10      call _strcmp
2272   0E49 C6 5F 0E      je fs_rm_found_entry
2273   0E4C 58 20 00      add d, 32
2274   0E4F 14 C9 17      mov a, [index]
2275   0E52 77            inc a
2276   0E53 42 C9 17      mov [index], a
2277   0E56 AF 10 00      cmp a, FST_FILES_PER_DIR
2278   0E59 C6 87 0E      je fs_rm_not_found
2279   0E5C 0A 40 0E      jmp fs_rm_L1
2280   0E5F             fs_rm_found_entry:
2281   0E5F 2B 19 00      mov b, [d + 25]               ; get LBA
2282   0E62 FD 79         mov g, b                      ; save LBA
2283   0E64 19 00         mov al, 0
2284   0E66 3E            mov [d], al                   ; make file entry NULL
2285   0E67 14 D1 17      mov a, [current_dir_id]
2286   0E6A 77            inc a                         ; metadata sector
2287   0E6B 27            mov b, a
2288   0E6C 38 00 00      mov c, 0                      ; upper LBA = 0
2289   0E6F 22 01         mov ah, $01                   ; disk write
2290   0E71 3B 1D 27      mov d, transient_area
2291   0E74 07 1A 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2292   0E77 3B 1D 27      mov d, transient_area  
2293   0E7A 19 00         mov al, 0
2294   0E7C 3E            mov [d], al                   ; make file's data header NULL for re-use
2295   0E7D 38 00 00      mov c, 0
2296   0E80 FD 27         mov b, g                      ; get data header LBA
2297   0E82 22 01         mov ah, $01                   ; disk write 1 sect
2298   0E84 07 1A 05      call ide_write_sect           ; write sector
2299   0E87             fs_rm_not_found:  
2300   0E87 06            sysret  
2301   0E88             
2302   0E88             ;------------------------------------------------------------------------------------------------------;
2303   0E88             ; mv - move / change file name
2304   0E88             ;------------------------------------------------------------------------------------------------------;
2305   0E88             fs_mv:
2306   0E88 FD 4E         mov si, d
2307   0E8A FD 4F 1D 1F   mov di, user_data
2308   0E8E 38 00 02      mov c, 512
2309   0E91 04            load                          ; load data from user-space
2310   0E92 14 D1 17      mov a, [current_dir_id]
2311   0E95 77            inc a                         ; metadata sector
2312   0E96 27            mov b, a  
2313   0E97 38 00 00      mov c, 0                      ; upper LBA = 0
2314   0E9A 22 01         mov ah, $01                  ; 1 sector
2315   0E9C 3B 1D 27      mov d, transient_area
2316   0E9F 07 F4 04      call ide_read_sect            ; read directory
2317   0EA2 FD 10         cla
2318   0EA4 42 C9 17      mov [index], a                ; reset file counter
2319   0EA7             fs_mv_L1:
2320   0EA7 FD 4E         mov si, d
2321   0EA9 FD 4F 1D 1F   mov di, user_data
2322   0EAD 07 DA 10      call _strcmp
2323   0EB0 C6 C6 0E      je fs_mv_found_entry
2324   0EB3 58 20 00      add d, 32
2325   0EB6 14 C9 17      mov a, [index]
2326   0EB9 77            inc a
2327   0EBA 42 C9 17      mov [index], a
2328   0EBD AF 10 00      cmp a, FST_FILES_PER_DIR
2329   0EC0 C6 F8 0E      je fs_mv_not_found
2330   0EC3 0A A7 0E      jmp fs_mv_L1
2331   0EC6             fs_mv_found_entry:  
2332   0EC6 DA            push d
2333   0EC7 FD 4D 9D 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2334   0ECB FD 50         mov di, d
2335   0ECD 07 EF 10      call _strcpy  
2336   0ED0 38 00 00      mov c, 0
2337   0ED3 3B 1D 27      mov d, transient_area
2338   0ED6 22 01         mov ah, $01                   ; disk write 1 sect
2339   0ED8 07 1A 05      call ide_write_sect           ; write sector
2340   0EDB E7            pop d
2341   0EDC             ;; need to check whether its a dir or a file here ;;;
2342   0EDC 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2343   0EDF 22 01         mov ah, $01
2344   0EE1 3B 1D 27      mov d, transient_area
2345   0EE4 38 00 00      mov c, 0
2346   0EE7 07 F4 04      call ide_read_sect            ; read directory entry
2347   0EEA FD 4D 9D 1F   mov si, user_data + 128
2348   0EEE FD 50         mov di, d
2349   0EF0 07 EF 10      call _strcpy                  ; change directory's name
2350   0EF3 22 01         mov ah, $01
2351   0EF5 07 1A 05      call ide_write_sect           ; rewrite directory back to disk
2352   0EF8             fs_mv_not_found:
2353   0EF8 06            sysret
2354   0EF9             
2355   0EF9             
2356   0EF9             ;----------------------------------------------------------------------------------------------------;
2357   0EF9             ; Process Index in A
2358   0EF9             ;----------------------------------------------------------------------------------------------------;
2359   0EF9             find_free_proc:
2360   0EF9 FD 4D 8E 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2361   0EFD             find_free_proc_L0:
2362   0EFD F6            lodsb                               ; get process state
2363   0EFE B9 00         cmp al, 0
2364   0F00 C6 06 0F      je find_free_proc_free              ; if free, jump
2365   0F03 0A FD 0E      jmp find_free_proc_L0               ; else, goto next
2366   0F06             find_free_proc_free:
2367   0F06 4E            mov a, si
2368   0F07 5F 8E 1C      sub a, 1 + proc_availab_table       ; get process index
2369   0F0A 09            ret
2370   0F0B               
2371   0F0B             
2372   0F0B             ;----------------------------------------------------------------------------------------------------;
2373   0F0B             ; Process Index in AL
2374   0F0B             ;----------------------------------------------------------------------------------------------------;
2375   0F0B             proc_memory_map:
2376   0F0B 22 00         mov ah, 0
2377   0F0D 27            mov b, a                      ; page in BL, 0 in BH
2378   0F0E FD 9D 05      shl a, 5                      ; multiply by 32
2379   0F11 39            mov c, a                      ; save in C
2380   0F12 57 20 00      add c, 32
2381   0F15             proc_memory_map_L0:
2382   0F15 02            pagemap
2383   0F16 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2384   0F19 53 01 00      add a, 1                      ; increase both 
2385   0F1C B1            cmp a, c                      ; check to see if we reached the end of memory
2386   0F1D C7 15 0F      jne proc_memory_map_L0
2387   0F20 09            ret
2388   0F21               
2389   0F21             
2390   0F21             ;----------------------------------------------------------------------------------------------------;
2391   0F21             ; terminate process
2392   0F21             ;----------------------------------------------------------------------------------------------------;
2393   0F21             syscall_terminate_proc:
2394   0F21 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2395   0F24                                                    ; since they will not be used for anything here.
2396   0F24 1D C8 17      mov al, [active_proc_index]
2397   0F27 22 00         mov ah, 0  
2398   0F29 FD 9D 05      shl a, 5                             ; x32
2399   0F2C 53 9D 1C      add a, proc_names
2400   0F2F 3C            mov d, a
2401   0F30 19 00         mov al, 0
2402   0F32 3E            mov [d], al                           ; nullify process name
2403   0F33             
2404   0F33 1D C8 17      mov al, [active_proc_index]
2405   0F36 22 00         mov ah, 0  
2406   0F38 3C            mov d, a
2407   0F39 19 00         mov al, 0
2408   0F3B 3F 8D 1C      mov [d + proc_availab_table], al    ; make process empty again
2409   0F3E               
2410   0F3E 1D C7 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2411   0F41 80            dec al
2412   0F42 3D C7 17      mov [nbr_active_procs], al
2413   0F45             
2414   0F45             ; now load the shell process again
2415   0F45 19 02         mov al, 2                           ; next process = process 2 = shell
2416   0F47 3D C8 17      mov [active_proc_index], al         ; set next active proc
2417   0F4A             
2418   0F4A             ; calculate LUT entry for next process
2419   0F4A 22 00         mov ah, 0
2420   0F4C FD 99         shl a                               ; x2
2421   0F4E B7 17 10      mov a, [proc_table_convert + a]     ; get process state start index  
2422   0F51               
2423   0F51 4D            mov si, a                           ; source is proc state block
2424   0F52 48            mov a, sp
2425   0F53 5F 13 00      sub a, 19
2426   0F56 4F            mov di, a                           ; destination is kernel stack
2427   0F57             ; restore SP
2428   0F57 7D            dec a
2429   0F58 47            mov sp, a
2430   0F59 38 14 00      mov c, 20
2431   0F5C FD F5         rep movsb
2432   0F5E             ; set VM process
2433   0F5E 1D C8 17      mov al, [active_proc_index]
2434   0F61 01            setptb
2435   0F62                 
2436   0F62 4C            popa
2437   0F63 06            sysret
2438   0F64             
2439   0F64             ;----------------------------------------------------------------------------------------------------;
2440   0F64             ; pause process
2441   0F64             ;----------------------------------------------------------------------------------------------------;
2442   0F64             syscall_pause_proc:
2443   0F64             ; save all registers into kernel stack
2444   0F64 4B            pusha
2445   0F65 22 00         mov ah, 0
2446   0F67 1D C8 17      mov al, [active_proc_index]
2447   0F6A FD 99         shl a              ; x2
2448   0F6C B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index
2449   0F6F                 
2450   0F6F 4F            mov di, a
2451   0F70 48            mov a, sp
2452   0F71 77            inc a
2453   0F72 4D            mov si, a
2454   0F73 38 14 00      mov c, 20
2455   0F76 FD F5         rep movsb                         ; save process state!
2456   0F78             ; restore kernel stack position to point before interrupt arrived
2457   0F78 51 14 00      add sp, 20
2458   0F7B             ; now load the shell process again
2459   0F7B 19 02         mov al, 2                         ; next process = process 2 = shell
2460   0F7D 3D C8 17      mov [active_proc_index], al       ; set next active proc
2461   0F80             
2462   0F80             ; calculate LUT entry for next process
2463   0F80 22 00         mov ah, 0
2464   0F82 FD 99         shl a                             ; x2
2465   0F84 B7 17 10      mov a, [proc_table_convert + a]   ; get process state start index  
2466   0F87               
2467   0F87 4D            mov si, a                         ; source is proc state block
2468   0F88 48            mov a, sp
2469   0F89 5F 13 00      sub a, 19
2470   0F8C 4F            mov di, a                         ; destination is kernel stack
2471   0F8D             ; restore SP
2472   0F8D 7D            dec a
2473   0F8E 47            mov sp, a
2474   0F8F 38 14 00      mov c, 20
2475   0F92 FD F5         rep movsb
2476   0F94             ; set VM process
2477   0F94 1D C8 17      mov al, [active_proc_index]
2478   0F97 01            setptb
2479   0F98                 
2480   0F98 4C            popa
2481   0F99 06            sysret
2482   0F9A             
2483   0F9A             ;----------------------------------------------------------------------------------------------------;
2484   0F9A             ; create a new process
2485   0F9A             ; D = path of the process file to be createed
2486   0F9A             ; B = arguments ptr
2487   0F9A             ;----------------------------------------------------------------------------------------------------;
2488   0F9A             syscall_create_proc:
2489   0F9A             ; we save the active process first  
2490   0F9A 4B            pusha
2491   0F9B 22 00         mov ah, 0
2492   0F9D 1D C8 17      mov al, [active_proc_index]
2493   0FA0 FD 99         shl a              ; x2
2494   0FA2 B7 17 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2495   0FA5               
2496   0FA5 4F            mov di, a
2497   0FA6 48            mov a, sp
2498   0FA7 77            inc a
2499   0FA8 4D            mov si, a
2500   0FA9 38 14 00      mov c, 20
2501   0FAC FD F5         rep movsb                          ; save process state!
2502   0FAE             ; restore kernel stack position to point before interrupt arrived
2503   0FAE 51 14 00      add sp, 20
2504   0FB1               
2505   0FB1 FD 4E         mov si, d                          ; copy the file path
2506   0FB3 FD 4F 1D 1F   mov di, user_data
2507   0FB7 38 00 02      mov c, 512
2508   0FBA 04            load
2509   0FBB 11            mov a, b
2510   0FBC 4D            mov si, a                          ; copy the arguments
2511   0FBD FD 4F 1D 25   mov di, scrap_sector
2512   0FC1 38 00 02      mov c, 512
2513   0FC4 04            load
2514   0FC5 07 AC 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2515   0FC8                                                  ; the file data is loaded into transient_area
2516   0FC8             ; now we allocate a new process  
2517   0FC8 07 F9 0E      call find_free_proc                ; index in A
2518   0FCB 01            setptb 
2519   0FCC 07 0B 0F      call proc_memory_map               ; map process memory pages
2520   0FCF             ; copy arguments into process's memory
2521   0FCF FD 4D 1D 25   mov si, scrap_sector
2522   0FD3 FD 4F 00 00   mov di, 0
2523   0FD7 38 00 02      mov c, 512
2524   0FDA 03            store
2525   0FDB             ; now copy process binary data into process's memory
2526   0FDB FD 4D 1D 27   mov si, transient_area
2527   0FDF FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2528   0FE3 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2529   0FE6 03            store                              ; copy process data
2530   0FE7                 
2531   0FE7 07 F9 0E      call find_free_proc                ; index in A
2532   0FEA 3D C8 17      mov [active_proc_index], al        ; set new active process
2533   0FED FD 9D 05      shl a, 5                           ; x32
2534   0FF0 53 9D 1C      add a, proc_names
2535   0FF3 4F            mov di, a
2536   0FF4 FD 4D 1D 1F   mov si, user_data                  ; copy and store process filename
2537   0FF8 07 EF 10      call _strcpy
2538   0FFB               
2539   0FFB 07 F9 0E      call find_free_proc                ; index in A
2540   0FFE 3C            mov d, a
2541   0FFF 19 01         mov al, 1
2542   1001 3F 8D 1C      mov [d + proc_availab_table], al   ; make process busy
2543   1004               
2544   1004 1D C7 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2545   1007 7A            inc al
2546   1008 3D C7 17      mov [nbr_active_procs], al
2547   100B             ; launch process
2548   100B FD D7 FF FF   push word $FFFF 
2549   100F FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2550   1012 FD D7 00 04   push word text_org
2551   1016 06            sysret
2552   1017             
2553   1017             proc_table_convert:
2554   1017 4D 1B         .dw proc_state_table + 0
2555   1019 61 1B         .dw proc_state_table + 20
2556   101B 75 1B         .dw proc_state_table + 40
2557   101D 89 1B         .dw proc_state_table + 60
2558   101F 9D 1B         .dw proc_state_table + 80
2559   1021 B1 1B         .dw proc_state_table + 100
2560   1023 C5 1B         .dw proc_state_table + 120
2561   1025 D9 1B         .dw proc_state_table + 140
2562   1027               
2563   1027             ;----------------------------------------------------------------------------------------------;
2564   1027             ; GET HEX FILE
2565   1027             ; di = destination address
2566   1027             ; return length in bytes in C
2567   1027             ;----------------------------------------------------------------------------------------------;
2568   1027             _load_hex:
2569   1027 D7            push a
2570   1028 D8            push b
2571   1029 DA            push d
2572   102A E2            push si
2573   102B E3            push di
2574   102C 38 00 00      mov c, 0
2575   102F 50            mov a, di
2576   1030 3C            mov d, a          ; start of string data block
2577   1031 07 72 11      call _gets        ; get program string
2578   1034 4D            mov si, a
2579   1035             __load_hex_loop:
2580   1035 F6            lodsb             ; load from [SI] to AL
2581   1036 B9 00         cmp al, 0         ; check if ASCII 0
2582   1038 C6 46 10      jz __load_hex_ret
2583   103B 36            mov bh, al
2584   103C F6            lodsb
2585   103D 2F            mov bl, al
2586   103E 07 28 11      call _atoi        ; convert ASCII byte in B to int (to AL)
2587   1041 F7            stosb             ; store AL to [DI]
2588   1042 78            inc c
2589   1043 0A 35 10      jmp __load_hex_loop
2590   1046             __load_hex_ret:
2591   1046 F0            pop di
2592   1047 EF            pop si
2593   1048 E7            pop d
2594   1049 E5            pop b
2595   104A E4            pop a
2596   104B 09            ret
2597   104C             
2598   104C             ; synopsis: look inside a certain directory for files/directories
2599   104C             ; before calling this function, cd into required directory
2600   104C             ; for each entry inside directory:
2601   104C             ;  if entry is a file:
2602   104C             ;    compare filename to searched filename
2603   104C             ;    if filenames are the same, print filename
2604   104C             ;  else if entry is a directory:
2605   104C             ;    cd to the given directory
2606   104C             ;    recursively call cmd_find
2607   104C             ;    cd outside previous directory
2608   104C             ;  if current entry == last entry, return
2609   104C             ; endfor
2610   104C             f_find:
2611   104C 09            ret
2612   104D             
2613   104D             
2614   104D             ; ---------------------------------------------------------------------
2615   104D             ; kernel reset vector
2616   104D             ; ---------------------------------------------------------------------
2617   104D             kernel_reset_vector:  
2618   104D FD 49 FF F7   mov bp, STACK_BEGIN
2619   1051 FD 47 FF F7   mov sp, STACK_BEGIN
2620   1055               
2621   1055 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2622   1057 FD 0F         stomsk                        
2623   1059 FD 0C         sti  
2624   105B             
2625   105B 0C            lodstat
2626   105C 87 DF         and al, %11011111             ; disable display register loading
2627   105E 0D            stostat
2628   105F               
2629   105F             ; reset fifo pointers
2630   105F 10 1D 21      mov a, fifo
2631   1062 3B CD 17      mov d, fifo_in
2632   1065 43            mov [d], a
2633   1066 3B CF 17      mov d, fifo_out
2634   1069 43            mov [d], a  
2635   106A 19 02         mov al, 2
2636   106C 05 03         syscall sys_io                ; enable uart in interrupt mode
2637   106E               
2638   106E 3B 22 18      mov d, s_kernel_started
2639   1071 07 97 12      call _puts
2640   1074             
2641   1074 19 10         mov al, 16
2642   1076 05 04         syscall sys_filesystem        ; set root dirID
2643   1078             
2644   1078 3B 3F 18      mov d, s_prompt_init
2645   107B 07 97 12      call _puts
2646   107E 3B D3 17      mov d, s_init_path
2647   1081 05 05         syscall sys_create_proc       ; launch init as a new process
2648   1083             
2649   1083             
2650   1083             ; FILE INCLUDES
2651   1083             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  1083             BIOS_RESET_VECTOR .EQU  $01c0
0002+  1083             IDE_buffer       .EQU  $8204
0003+  1083             boot_origin      .EQU  $8004
0004+  1083             bios_uart        .EQU  $0002
0005+  1083             bios_ide         .EQU  $0003
2652   1083             .include "lib/stdio.asm"
0001+  1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1083             ; stdio.s
0003+  1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1083             .include "lib/string.asm"
0001++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1083             ; string.s
0003++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1083             
0005++ 1083             
0006++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1083             ; _strrev
0008++ 1083             ; reverse a string
0009++ 1083             ; D = string address
0010++ 1083             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1083             ; 01234
0012++ 1083             _strrev:
0013++ 1083 4B          	pusha
0014++ 1084 07 CA 10    	call _strlen	; length in C
0015++ 1087 12          	mov a, c
0016++ 1088 AF 01 00    	cmp a, 1
0017++ 108B D0 A5 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 108E 7D          	dec a
0019++ 108F FD 4E       	mov si, d	; beginning of string
0020++ 1091 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1093 59          	add d, a	; end of string
0022++ 1094 12          	mov a, c
0023++ 1095 FD 9B       	shr a		; divide by 2
0024++ 1097 39          	mov c, a	; C now counts the steps
0025++ 1098             _strrev_L0:
0026++ 1098 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1099 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 109A 3E          	mov [d], al	; store left char into right side
0029++ 109B 1B          	mov al, bl
0030++ 109C F7          	stosb		; store right-side char into left-side; increase DI
0031++ 109D 7E          	dec c
0032++ 109E 7F          	dec d
0033++ 109F C2 00 00    	cmp c, 0
0034++ 10A2 C7 98 10    	jne _strrev_L0
0035++ 10A5             _strrev_end:
0036++ 10A5 4C          	popa
0037++ 10A6 09          	ret
0038++ 10A7             	
0039++ 10A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10A7             ; _strchr
0041++ 10A7             ; search string in D for char in AL
0042++ 10A7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10A7             _strchr:
0044++ 10A7             _strchr_L0:
0045++ 10A7 32          	mov bl, [d]
0046++ 10A8 C1 00       	cmp bl, 0
0047++ 10AA C6 B5 10    	je _strchr_end
0048++ 10AD BA          	cmp al, bl
0049++ 10AE C6 B5 10    	je _strchr_end
0050++ 10B1 79          	inc d
0051++ 10B2 0A A7 10    	jmp _strchr_L0
0052++ 10B5             _strchr_end:
0053++ 10B5 1B          	mov al, bl
0054++ 10B6 09          	ret
0055++ 10B7             
0056++ 10B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10B7             ; _strstr
0058++ 10B7             ; find sub-string
0059++ 10B7             ; str1 in SI
0060++ 10B7             ; str2 in DI
0061++ 10B7             ; SI points to end of source string
0062++ 10B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10B7             _strstr:
0064++ 10B7 DB          	push al
0065++ 10B8 DA          	push d
0066++ 10B9 E3          	push di
0067++ 10BA             _strstr_loop:
0068++ 10BA F3          	cmpsb					; compare a byte of the strings
0069++ 10BB C7 C6 10    	jne _strstr_ret
0070++ 10BE FC 00 00    	lea d, [di + 0]
0071++ 10C1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10C3 C7 BA 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10C6             _strstr_ret:
0074++ 10C6 F0          	pop di
0075++ 10C7 E7          	pop d
0076++ 10C8 E8          	pop al
0077++ 10C9 09          	ret
0078++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10CA             ; length of null terminated string
0080++ 10CA             ; result in C
0081++ 10CA             ; pointer in D
0082++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10CA             _strlen:
0084++ 10CA DA          	push d
0085++ 10CB 38 00 00    	mov c, 0
0086++ 10CE             _strlen_L1:
0087++ 10CE BD 00       	cmp byte [d], 0
0088++ 10D0 C6 D8 10    	je _strlen_ret
0089++ 10D3 79          	inc d
0090++ 10D4 78          	inc c
0091++ 10D5 0A CE 10    	jmp _strlen_L1
0092++ 10D8             _strlen_ret:
0093++ 10D8 E7          	pop d
0094++ 10D9 09          	ret
0095++ 10DA             
0096++ 10DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10DA             ; STRCMP
0098++ 10DA             ; compare two strings
0099++ 10DA             ; str1 in SI
0100++ 10DA             ; str2 in DI
0101++ 10DA             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10DA             _strcmp:
0104++ 10DA DB          	push al
0105++ 10DB DA          	push d
0106++ 10DC E3          	push di
0107++ 10DD E2          	push si
0108++ 10DE             _strcmp_loop:
0109++ 10DE F3          	cmpsb					; compare a byte of the strings
0110++ 10DF C7 EA 10    	jne _strcmp_ret
0111++ 10E2 FB FF FF    	lea d, [si +- 1]
0112++ 10E5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10E7 C7 DE 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10EA             _strcmp_ret:
0115++ 10EA EF          	pop si
0116++ 10EB F0          	pop di
0117++ 10EC E7          	pop d
0118++ 10ED E8          	pop al
0119++ 10EE 09          	ret
0120++ 10EF             
0121++ 10EF             
0122++ 10EF             ; STRCPY
0123++ 10EF             ; copy null terminated string from SI to DI
0124++ 10EF             ; source in SI
0125++ 10EF             ; destination in DI
0126++ 10EF             _strcpy:
0127++ 10EF E2          	push si
0128++ 10F0 E3          	push di
0129++ 10F1 DB          	push al
0130++ 10F2             _strcpy_L1:
0131++ 10F2 F6          	lodsb
0132++ 10F3 F7          	stosb
0133++ 10F4 B9 00       	cmp al, 0
0134++ 10F6 C7 F2 10    	jne _strcpy_L1
0135++ 10F9             _strcpy_end:
0136++ 10F9 E8          	pop al
0137++ 10FA F0          	pop di
0138++ 10FB EF          	pop si
0139++ 10FC 09          	ret
0140++ 10FD             
0141++ 10FD             ; STRCAT
0142++ 10FD             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10FD             ; source in SI
0144++ 10FD             ; destination in DI
0145++ 10FD             _strcat:
0146++ 10FD E2          	push si
0147++ 10FE E3          	push di
0148++ 10FF D7          	push a
0149++ 1100 DA          	push d
0150++ 1101 50          	mov a, di
0151++ 1102 3C          	mov d, a
0152++ 1103             _strcat_goto_end_L1:
0153++ 1103 BD 00       	cmp byte[d], 0
0154++ 1105 C6 0C 11    	je _strcat_start
0155++ 1108 79          	inc d
0156++ 1109 0A 03 11    	jmp _strcat_goto_end_L1
0157++ 110C             _strcat_start:
0158++ 110C FD 50       	mov di, d
0159++ 110E             _strcat_L1:
0160++ 110E F6          	lodsb
0161++ 110F F7          	stosb
0162++ 1110 B9 00       	cmp al, 0
0163++ 1112 C7 0E 11    	jne _strcat_L1
0164++ 1115             _strcat_end:
0165++ 1115 E7          	pop d
0166++ 1116 E4          	pop a
0167++ 1117 F0          	pop di
0168++ 1118 EF          	pop si
0169++ 1119 09          	ret
0170++ 111A             
0171++ 111A             
0005+  111A             
0006+  111A             
0007+  111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  111A             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  111A             ; ASCII in BL
0010+  111A             ; result in AL
0011+  111A             ; ascii for F = 0100 0110
0012+  111A             ; ascii for 9 = 0011 1001
0013+  111A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  111A             hex_ascii_encode:
0015+  111A 1B            mov al, bl
0016+  111B 93 40         test al, $40        ; test if letter or number
0017+  111D C7 23 11      jnz hex_letter
0018+  1120 87 0F         and al, $0F        ; get number
0019+  1122 09            ret
0020+  1123             hex_letter:
0021+  1123 87 0F         and al, $0F        ; get letter
0022+  1125 6A 09         add al, 9
0023+  1127 09            ret
0024+  1128             
0025+  1128             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1128             ; ATOI
0027+  1128             ; 2 letter hex string in B
0028+  1128             ; 8bit integer returned in AL
0029+  1128             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1128             _atoi:
0031+  1128 D8            push b
0032+  1129 07 1A 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  112C 30            mov bl, bh
0034+  112D DB            push al          ; save a
0035+  112E 07 1A 11      call hex_ascii_encode
0036+  1131 EA            pop bl  
0037+  1132 FD 9E 04      shl al, 4
0038+  1135 8C            or al, bl
0039+  1136 E5            pop b
0040+  1137 09            ret  
0041+  1138             
0042+  1138             
0043+  1138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1138             ; scanf
0045+  1138             ; no need for explanations!
0046+  1138             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1138             scanf:
0048+  1138 09            ret
0049+  1139             
0050+  1139             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1139             ; ITOA
0052+  1139             ; 8bit value in BL
0053+  1139             ; 2 byte ASCII result in A
0054+  1139             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1139             _itoa:
0056+  1139 DA            push d
0057+  113A D8            push b
0058+  113B A7 00         mov bh, 0
0059+  113D FD A4 04      shr bl, 4  
0060+  1140 74            mov d, b
0061+  1141 1F D3 13      mov al, [d + s_hex_digits]
0062+  1144 23            mov ah, al
0063+  1145               
0064+  1145 E5            pop b
0065+  1146 D8            push b
0066+  1147 A7 00         mov bh, 0
0067+  1149 FD 87 0F      and bl, $0F
0068+  114C 74            mov d, b
0069+  114D 1F D3 13      mov al, [d + s_hex_digits]
0070+  1150 E5            pop b
0071+  1151 E7            pop d
0072+  1152 09            ret
0073+  1153             
0074+  1153             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1153             ; HEX STRING TO BINARY
0076+  1153             ; di = destination address
0077+  1153             ; si = source
0078+  1153             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1153             _hex_to_int:
0080+  1153             _hex_to_int_L1:
0081+  1153 F6            lodsb          ; load from [SI] to AL
0082+  1154 B9 00         cmp al, 0        ; check if ASCII 0
0083+  1156 C6 63 11      jz _hex_to_int_ret
0084+  1159 36            mov bh, al
0085+  115A F6            lodsb
0086+  115B 2F            mov bl, al
0087+  115C 07 28 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  115F F7            stosb          ; store AL to [DI]
0089+  1160 0A 53 11      jmp _hex_to_int_L1
0090+  1163             _hex_to_int_ret:
0091+  1163 09            ret    
0092+  1164             
0093+  1164             
0094+  1164             
0095+  1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1164             ; GETCHAR
0097+  1164             ; char in ah
0098+  1164             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1164             getch:
0100+  1164 DB            push al
0101+  1165             getch_retry:
0102+  1165 19 01         mov al, 1
0103+  1167 05 03         syscall sys_io      ; receive in AH
0104+  1169 E8            pop al
0105+  116A 09            ret
0106+  116B             
0107+  116B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  116B             ; PUTCHAR
0109+  116B             ; char in ah
0110+  116B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  116B             _putchar:
0112+  116B DB            push al
0113+  116C 19 00         mov al, 0
0114+  116E 05 03         syscall sys_io      ; char in AH
0115+  1170 E8            pop al
0116+  1171 09            ret
0117+  1172             
0118+  1172             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1172             ;; INPUT A STRING
0120+  1172             ;; terminates with null
0121+  1172             ;; pointer in D
0122+  1172             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1172             _gets:
0124+  1172 D7            push a
0125+  1173 DA            push d
0126+  1174             _gets_loop:
0127+  1174 19 01         mov al, 1
0128+  1176 05 03         syscall sys_io      ; receive in AH
0129+  1178 76 1B         cmp ah, 27
0130+  117A C6 9B 11      je _gets_ansi_esc
0131+  117D 76 0A         cmp ah, $0A        ; LF
0132+  117F C6 F7 11      je _gets_end
0133+  1182 76 0D         cmp ah, $0D        ; CR
0134+  1184 C6 F7 11      je _gets_end
0135+  1187 76 5C         cmp ah, $5C        ; '\\'
0136+  1189 C6 BD 11      je _gets_escape
0137+  118C 76 08         cmp ah, $08      ; check for backspace
0138+  118E C6 97 11      je _gets_backspace
0139+  1191 1A            mov al, ah
0140+  1192 3E            mov [d], al
0141+  1193 79            inc d
0142+  1194 0A 74 11      jmp _gets_loop
0143+  1197             _gets_backspace:
0144+  1197 7F            dec d
0145+  1198 0A 74 11      jmp _gets_loop
0146+  119B             _gets_ansi_esc:
0147+  119B 19 01         mov al, 1
0148+  119D 05 03         syscall sys_io        ; receive in AH without echo
0149+  119F 76 5B         cmp ah, '['
0150+  11A1 C7 74 11      jne _gets_loop
0151+  11A4 19 01         mov al, 1
0152+  11A6 05 03         syscall sys_io          ; receive in AH without echo
0153+  11A8 76 44         cmp ah, 'D'
0154+  11AA C6 B5 11      je _gets_left_arrow
0155+  11AD 76 43         cmp ah, 'C'
0156+  11AF C6 B9 11      je _gets_right_arrow
0157+  11B2 0A 74 11      jmp _gets_loop
0158+  11B5             _gets_left_arrow:
0159+  11B5 7F            dec d
0160+  11B6 0A 74 11      jmp _gets_loop
0161+  11B9             _gets_right_arrow:
0162+  11B9 79            inc d
0163+  11BA 0A 74 11      jmp _gets_loop
0164+  11BD             _gets_escape:
0165+  11BD 19 01         mov al, 1
0166+  11BF 05 03         syscall sys_io      ; receive in AH
0167+  11C1 76 6E         cmp ah, 'n'
0168+  11C3 C6 E2 11      je _gets_LF
0169+  11C6 76 72         cmp ah, 'r'
0170+  11C8 C6 E9 11      je _gets_CR
0171+  11CB 76 30         cmp ah, '0'
0172+  11CD C6 F0 11      je _gets_NULL
0173+  11D0 76 5C         cmp ah, $5C  ; '\'
0174+  11D2 C6 DB 11      je _gets_slash
0175+  11D5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  11D6 3E            mov [d], al
0177+  11D7 79            inc d
0178+  11D8 0A 74 11      jmp _gets_loop
0179+  11DB             _gets_slash:
0180+  11DB 19 5C         mov al, $5C
0181+  11DD 3E            mov [d], al
0182+  11DE 79            inc d
0183+  11DF 0A 74 11      jmp _gets_loop
0184+  11E2             _gets_LF:
0185+  11E2 19 0A         mov al, $0A
0186+  11E4 3E            mov [d], al
0187+  11E5 79            inc d
0188+  11E6 0A 74 11      jmp _gets_loop
0189+  11E9             _gets_CR:
0190+  11E9 19 0D         mov al, $0D
0191+  11EB 3E            mov [d], al
0192+  11EC 79            inc d
0193+  11ED 0A 74 11      jmp _gets_loop
0194+  11F0             _gets_NULL:
0195+  11F0 19 00         mov al, $00
0196+  11F2 3E            mov [d], al
0197+  11F3 79            inc d
0198+  11F4 0A 74 11      jmp _gets_loop
0199+  11F7             _gets_end:
0200+  11F7 19 00         mov al, 0
0201+  11F9 3E            mov [d], al        ; terminate string
0202+  11FA E7            pop d
0203+  11FB E4            pop a
0204+  11FC 09            ret
0205+  11FD             
0206+  11FD             
0207+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11FD             ;; INPUT TEXT
0209+  11FD             ;; terminated with CTRL+D
0210+  11FD             ;; pointer in D
0211+  11FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11FD             _gettxt:
0213+  11FD D7            push a
0214+  11FE DA            push d
0215+  11FF             _gettxt_loop:
0216+  11FF 19 01         mov al, 1
0217+  1201 05 03         syscall sys_io      ; receive in AH
0218+  1203 76 04         cmp ah, 4      ; EOT
0219+  1205 C6 3E 12      je _gettxt_end
0220+  1208 76 08         cmp ah, $08      ; check for backspace
0221+  120A C6 3A 12      je _gettxt_backspace
0222+  120D 76 5C         cmp ah, $5C        ; '\'
0223+  120F C6 18 12      je _gettxt_escape
0224+  1212 1A            mov al, ah
0225+  1213 3E            mov [d], al
0226+  1214 79            inc d
0227+  1215 0A FF 11      jmp _gettxt_loop
0228+  1218             _gettxt_escape:
0229+  1218 19 01         mov al, 1
0230+  121A 05 03         syscall sys_io      ; receive in AH
0231+  121C 76 6E         cmp ah, 'n'
0232+  121E C6 2C 12      je _gettxt_LF
0233+  1221 76 72         cmp ah, 'r'
0234+  1223 C6 33 12      je _gettxt_CR
0235+  1226 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1227 3E            mov [d], al
0237+  1228 79            inc d
0238+  1229 0A FF 11      jmp _gettxt_loop
0239+  122C             _gettxt_LF:
0240+  122C 19 0A         mov al, $0A
0241+  122E 3E            mov [d], al
0242+  122F 79            inc d
0243+  1230 0A FF 11      jmp _gettxt_loop
0244+  1233             _gettxt_CR:
0245+  1233 19 0D         mov al, $0D
0246+  1235 3E            mov [d], al
0247+  1236 79            inc d
0248+  1237 0A FF 11      jmp _gettxt_loop
0249+  123A             _gettxt_backspace:
0250+  123A 7F            dec d
0251+  123B 0A FF 11      jmp _gettxt_loop
0252+  123E             _gettxt_end:
0253+  123E 19 00         mov al, 0
0254+  1240 3E            mov [d], al        ; terminate string
0255+  1241 E7            pop d
0256+  1242 E4            pop a
0257+  1243 09            ret
0258+  1244             
0259+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1244             ; PRINT NEW LINE
0261+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1244             printnl:
0263+  1244 D7            push a
0264+  1245 10 00 0A      mov a, $0A00
0265+  1248 05 03         syscall sys_io
0266+  124A 10 00 0D      mov a, $0D00
0267+  124D 05 03         syscall sys_io
0268+  124F E4            pop a
0269+  1250 09            ret
0270+  1251             
0271+  1251             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1251             ; _strtoint
0273+  1251             ; 4 digit hex string number in d
0274+  1251             ; integer returned in A
0275+  1251             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1251             _strtointx:
0277+  1251 D8            push b
0278+  1252 32            mov bl, [d]
0279+  1253 37            mov bh, bl
0280+  1254 33 01 00      mov bl, [d + 1]
0281+  1257 07 28 11      call _atoi        ; convert to int in AL
0282+  125A 23            mov ah, al        ; move to AH
0283+  125B 33 02 00      mov bl, [d + 2]
0284+  125E 37            mov bh, bl
0285+  125F 33 03 00      mov bl, [d + 3]
0286+  1262 07 28 11      call _atoi        ; convert to int in AL
0287+  1265 E5            pop b
0288+  1266 09            ret
0289+  1267             
0290+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1267             ; _strtoint
0292+  1267             ; 5 digit base10 string number in d
0293+  1267             ; integer returned in A
0294+  1267             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1267             _strtoint:
0296+  1267 E2            push si
0297+  1268 D8            push b
0298+  1269 D9            push c
0299+  126A DA            push d
0300+  126B 07 CA 10      call _strlen      ; get string length in C
0301+  126E 7E            dec c
0302+  126F FD 4E         mov si, d
0303+  1271 12            mov a, c
0304+  1272 FD 99         shl a
0305+  1274 3B EB 13      mov d, table_power
0306+  1277 59            add d, a
0307+  1278 38 00 00      mov c, 0
0308+  127B             _strtoint_L0:
0309+  127B F6            lodsb      ; load ASCII to al
0310+  127C B9 00         cmp al, 0
0311+  127E C6 91 12      je _strtoint_end
0312+  1281 6F 30         sub al, $30    ; make into integer
0313+  1283 22 00         mov ah, 0
0314+  1285 2A            mov b, [d]
0315+  1286 AC            mul a, b      ; result in B since it fits in 16bits
0316+  1287 11            mov a, b
0317+  1288 28            mov b, c
0318+  1289 54            add a, b
0319+  128A 39            mov c, a
0320+  128B 63 02 00      sub d, 2
0321+  128E 0A 7B 12      jmp _strtoint_L0
0322+  1291             _strtoint_end:
0323+  1291 12            mov a, c
0324+  1292 E7            pop d
0325+  1293 E6            pop c
0326+  1294 E5            pop b
0327+  1295 EF            pop si
0328+  1296 09            ret
0329+  1297             
0330+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1297             ; PRINT NULL TERMINATED STRING
0332+  1297             ; pointer in D
0333+  1297             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1297             _puts:
0335+  1297 D7            push a
0336+  1298 DA            push d
0337+  1299             _puts_L1:
0338+  1299 1E            mov al, [d]
0339+  129A B9 00         cmp al, 0
0340+  129C C6 A8 12      jz _puts_END
0341+  129F 23            mov ah, al
0342+  12A0 19 00         mov al, 0
0343+  12A2 05 03         syscall sys_io
0344+  12A4 79            inc d
0345+  12A5 0A 99 12      jmp _puts_L1
0346+  12A8             _puts_END:
0347+  12A8 E7            pop d
0348+  12A9 E4            pop a
0349+  12AA 09            ret
0350+  12AB             
0351+  12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12AB             ; PRINT N SIZE STRING
0353+  12AB             ; pointer in D
0354+  12AB             ; size in C
0355+  12AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12AB             _putsn:
0357+  12AB DB            push al
0358+  12AC DA            push d
0359+  12AD D9            push c
0360+  12AE             _putsn_L0:
0361+  12AE 1E            mov al, [d]
0362+  12AF 23            mov ah, al
0363+  12B0 19 00         mov al, 0
0364+  12B2 05 03         syscall sys_io
0365+  12B4 79            inc d
0366+  12B5 7E            dec c  
0367+  12B6 C2 00 00      cmp c, 0
0368+  12B9 C7 AE 12      jne _putsn_L0
0369+  12BC             _putsn_end:
0370+  12BC E6            pop c
0371+  12BD E7            pop d
0372+  12BE E8            pop al
0373+  12BF 09            ret
0374+  12C0             
0375+  12C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  12C0             ; print 16bit decimal number
0377+  12C0             ; input number in A
0378+  12C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  12C0             print_u16d:
0380+  12C0 D7            push a
0381+  12C1 D8            push b
0382+  12C2 FD D8         push g
0383+  12C4 26 10 27      mov b, 10000
0384+  12C7 AE            div a, b      ; get 10000's coeff.
0385+  12C8 07 EC 12      call print_number
0386+  12CB 11            mov a, b
0387+  12CC 26 E8 03      mov b, 1000
0388+  12CF AE            div a, b      ; get 1000's coeff.
0389+  12D0 07 EC 12      call print_number
0390+  12D3 11            mov a, b
0391+  12D4 26 64 00      mov b, 100
0392+  12D7 AE            div a, b
0393+  12D8 07 EC 12      call print_number
0394+  12DB 11            mov a, b
0395+  12DC 26 0A 00      mov b, 10
0396+  12DF AE            div a, b
0397+  12E0 07 EC 12      call print_number
0398+  12E3 1B            mov al, bl      ; 1's coeff in bl
0399+  12E4 07 EC 12      call print_number
0400+  12E7 FD F1         pop g
0401+  12E9 E5            pop b
0402+  12EA E4            pop a
0403+  12EB 09            ret
0404+  12EC             
0405+  12EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12EC             ; print AL
0407+  12EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12EC             print_number:
0409+  12EC 6A 30         add al, $30
0410+  12EE 23            mov ah, al
0411+  12EF 07 6B 11      call _putchar
0412+  12F2 09            ret
0413+  12F3             
0414+  12F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12F3             ; PRINT 16BIT HEX INTEGER
0416+  12F3             ; integer value in reg B
0417+  12F3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12F3             print_u16x:
0419+  12F3 D7            push a
0420+  12F4 D8            push b
0421+  12F5 DD            push bl
0422+  12F6 30            mov bl, bh
0423+  12F7 07 39 11      call _itoa        ; convert bh to char in A
0424+  12FA 2F            mov bl, al        ; save al
0425+  12FB 19 00         mov al, 0
0426+  12FD 05 03         syscall sys_io        ; display AH
0427+  12FF 24            mov ah, bl        ; retrieve al
0428+  1300 19 00         mov al, 0
0429+  1302 05 03         syscall sys_io        ; display AL
0430+  1304             
0431+  1304 EA            pop bl
0432+  1305 07 39 11      call _itoa        ; convert bh to char in A
0433+  1308 2F            mov bl, al        ; save al
0434+  1309 19 00         mov al, 0
0435+  130B 05 03         syscall sys_io        ; display AH
0436+  130D 24            mov ah, bl        ; retrieve al
0437+  130E 19 00         mov al, 0
0438+  1310 05 03         syscall sys_io        ; display AL
0439+  1312             
0440+  1312 E5            pop b
0441+  1313 E4            pop a
0442+  1314 09            ret
0443+  1315             
0444+  1315             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1315             ; INPUT 16BIT HEX INTEGER
0446+  1315             ; read 16bit integer into A
0447+  1315             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1315             scan_u16x:
0449+  1315 F8 10 00      enter 16
0450+  1318 D8            push b
0451+  1319 DA            push d
0452+  131A             
0453+  131A FA F1 FF      lea d, [bp + -15]
0454+  131D 07 72 11      call _gets        ; get number
0455+  1320             
0456+  1320 32            mov bl, [d]
0457+  1321 37            mov bh, bl
0458+  1322 33 01 00      mov bl, [d + 1]
0459+  1325 07 28 11      call _atoi        ; convert to int in AL
0460+  1328 23            mov ah, al        ; move to AH
0461+  1329             
0462+  1329 33 02 00      mov bl, [d + 2]
0463+  132C 37            mov bh, bl
0464+  132D 33 03 00      mov bl, [d + 3]
0465+  1330 07 28 11      call _atoi        ; convert to int in AL
0466+  1333             
0467+  1333 E7            pop d
0468+  1334 E5            pop b
0469+  1335 F9            leave
0470+  1336 09            ret
0471+  1337             
0472+  1337             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1337             ; PRINT 8bit HEX INTEGER
0474+  1337             ; integer value in reg bl
0475+  1337             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1337             print_u8x:
0477+  1337 D7            push a
0478+  1338 DD            push bl
0479+  1339             
0480+  1339 07 39 11      call _itoa        ; convert bl to char in A
0481+  133C 2F            mov bl, al        ; save al
0482+  133D 19 00         mov al, 0
0483+  133F 05 03         syscall sys_io        ; display AH
0484+  1341 24            mov ah, bl        ; retrieve al
0485+  1342 19 00         mov al, 0
0486+  1344 05 03         syscall sys_io        ; display AL
0487+  1346             
0488+  1346 EA            pop bl
0489+  1347 E4            pop a
0490+  1348 09            ret
0491+  1349             
0492+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1349             ; print 8bit decimal unsigned number
0494+  1349             ; input number in AL
0495+  1349             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1349             print_u8d:
0497+  1349 D7            push a
0498+  134A D8            push b
0499+  134B FD D8         push g
0500+  134D 22 00         mov ah, 0
0501+  134F 26 64 00      mov b, 100
0502+  1352 AE            div a, b
0503+  1353 D8            push b      ; save remainder
0504+  1354 B9 00         cmp al, 0
0505+  1356 C6 60 13      je skip100
0506+  1359 6A 30         add al, $30
0507+  135B 23            mov ah, al
0508+  135C 19 00         mov al, 0
0509+  135E 05 03         syscall sys_io  ; print coeff
0510+  1360             skip100:
0511+  1360 E4            pop a
0512+  1361 22 00         mov ah, 0
0513+  1363 26 0A 00      mov b, 10
0514+  1366 AE            div a, b
0515+  1367 D8            push b      ; save remainder
0516+  1368 B9 00         cmp al, 0
0517+  136A C6 74 13      je skip10
0518+  136D 6A 30         add al, $30
0519+  136F 23            mov ah, al
0520+  1370 19 00         mov al, 0
0521+  1372 05 03         syscall sys_io  ; print coeff
0522+  1374             skip10:
0523+  1374 E4            pop a
0524+  1375 1B            mov al, bl
0525+  1376 6A 30         add al, $30
0526+  1378 23            mov ah, al
0527+  1379 19 00         mov al, 0
0528+  137B 05 03         syscall sys_io  ; print coeff
0529+  137D FD F1         pop g
0530+  137F E5            pop b
0531+  1380 E4            pop a
0532+  1381 09            ret
0533+  1382             
0534+  1382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1382             ; INPUT 8BIT HEX INTEGER
0536+  1382             ; read 8bit integer into AL
0537+  1382             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1382             scan_u8x:
0539+  1382 F8 04 00      enter 4
0540+  1385 D8            push b
0541+  1386 DA            push d
0542+  1387             
0543+  1387 FA FD FF      lea d, [bp + -3]
0544+  138A 07 72 11      call _gets        ; get number
0545+  138D             
0546+  138D 32            mov bl, [d]
0547+  138E 37            mov bh, bl
0548+  138F 33 01 00      mov bl, [d + 1]
0549+  1392 07 28 11      call _atoi        ; convert to int in AL
0550+  1395             
0551+  1395 E7            pop d
0552+  1396 E5            pop b
0553+  1397 F9            leave
0554+  1398 09            ret
0555+  1399             
0556+  1399             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1399             ; input decimal number
0558+  1399             ; result in A
0559+  1399             ; 655'\0'
0560+  1399             ; low--------high
0561+  1399             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1399             scan_u16d:
0563+  1399 F8 08 00      enter 8
0564+  139C E2            push si
0565+  139D D8            push b
0566+  139E D9            push c
0567+  139F DA            push d
0568+  13A0 FA F9 FF      lea d, [bp +- 7]
0569+  13A3 07 72 11      call _gets
0570+  13A6 07 CA 10      call _strlen      ; get string length in C
0571+  13A9 7E            dec c
0572+  13AA FD 4E         mov si, d
0573+  13AC 12            mov a, c
0574+  13AD FD 99         shl a
0575+  13AF 3B EB 13      mov d, table_power
0576+  13B2 59            add d, a
0577+  13B3 38 00 00      mov c, 0
0578+  13B6             mul_loop:
0579+  13B6 F6            lodsb      ; load ASCII to al
0580+  13B7 B9 00         cmp al, 0
0581+  13B9 C6 CC 13      je mul_exit
0582+  13BC 6F 30         sub al, $30    ; make into integer
0583+  13BE 22 00         mov ah, 0
0584+  13C0 2A            mov b, [d]
0585+  13C1 AC            mul a, b      ; result in B since it fits in 16bits
0586+  13C2 11            mov a, b
0587+  13C3 28            mov b, c
0588+  13C4 54            add a, b
0589+  13C5 39            mov c, a
0590+  13C6 63 02 00      sub d, 2
0591+  13C9 0A B6 13      jmp mul_loop
0592+  13CC             mul_exit:
0593+  13CC 12            mov a, c
0594+  13CD E7            pop d
0595+  13CE E6            pop c
0596+  13CF E5            pop b
0597+  13D0 EF            pop si
0598+  13D1 F9            leave
0599+  13D2 09            ret
0600+  13D3             
0601+  13D3             
0602+  13D3 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  13D7 34 35 36 37 
0602+  13DB 38 39 41 42 
0602+  13DF 43 44 45 46 
0603+  13E3 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  13E7 1B 5B 48 00 
0604+  13EB             
0605+  13EB             table_power:
0606+  13EB 01 00         .dw 1
0607+  13ED 0A 00         .dw 10
0608+  13EF 64 00         .dw 100
0609+  13F1 E8 03         .dw 1000
0610+  13F3 10 27         .dw 100002653   13F5             .include "lib/ctype.asm"
0001+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13F5             ; ctype.s
0003+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13F5             
0005+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13F5             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  13F5             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  13F5             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  13F5             ;; characters are supported.
0010+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13F5             ;; _isalnum 
0012+  13F5             ;; _isalpha 
0013+  13F5             ;; islower 
0014+  13F5             ;; isupper 
0015+  13F5             ;; _isdigit 
0016+  13F5             ;; isxdigit
0017+  13F5             ;; iscntrl 
0018+  13F5             ;; isgraph 
0019+  13F5             ;; _isspace 
0020+  13F5             ;; isblank 
0021+  13F5             ;; isprint 
0022+  13F5             ;; ispunct 
0023+  13F5             ;; tolower 
0024+  13F5             ;; toupper
0025+  13F5             
0026+  13F5             
0027+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13F5             ;; IS ALPHANUMERIC
0029+  13F5             ;; sets ZF according with result
0030+  13F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13F5             _isalnum:
0032+  13F5 07 12 14    	call _isalpha
0033+  13F8 C6 FE 13    	je _isalnum_exit
0034+  13FB 07 FF 13    	call _isdigit
0035+  13FE             _isalnum_exit:
0036+  13FE 09          	ret	
0037+  13FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13FF             ;; IS DIGIT
0039+  13FF             ;; sets ZF according with result
0040+  13FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13FF             _isdigit:
0042+  13FF DB          	push al
0043+  1400 B9 30       	cmp al, '0'
0044+  1402 C8 0E 14    	jlu _isdigit_false
0045+  1405 B9 39       	cmp al, '9'
0046+  1407 D1 0E 14    	jgu _isdigit_false
0047+  140A 87 00       	and al, 0	; set ZF
0048+  140C E8          	pop al
0049+  140D 09          	ret
0050+  140E             _isdigit_false:
0051+  140E 8B 01       	or al, 1	; clear ZF
0052+  1410 E8          	pop al
0053+  1411 09          	ret	
0054+  1412             	
0055+  1412             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1412             ;; IS ALPHA
0057+  1412             ;; sets ZF according with result
0058+  1412             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1412             _isalpha:
0060+  1412 DB          	push al
0061+  1413 B9 5F       	cmp al, '_'
0062+  1415 C6 35 14    	je _isalpha_true
0063+  1418 B9 2E       	cmp al, '.'
0064+  141A C6 35 14    	je _isalpha_true
0065+  141D B9 41       	cmp al, 'A'
0066+  141F C8 31 14    	jlu _isalpha_false
0067+  1422 B9 7A       	cmp al, 'z'
0068+  1424 D1 31 14    	jgu _isalpha_false
0069+  1427 B9 5A       	cmp al, 'Z'
0070+  1429 D0 35 14    	jleu _isalpha_true
0071+  142C B9 61       	cmp al, 'a'
0072+  142E C9 35 14    	jgeu _isalpha_true
0073+  1431             _isalpha_false:
0074+  1431 8B 01       	or al, 1	; clear ZF
0075+  1433 E8          	pop al
0076+  1434 09          	ret
0077+  1435             _isalpha_true:
0078+  1435 87 00       	and al, 0	; set ZF
0079+  1437 E8          	pop al
0080+  1438 09          	ret
0081+  1439             
0082+  1439             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1439             ;; IS PATH-ALPHA
0084+  1439             ;; sets ZF according with result
0085+  1439             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1439             ispath:
0087+  1439 DB          	push al
0088+  143A 07 FF 13    	call _isdigit
0089+  143D C6 67 14    	je ispath_true
0090+  1440 B9 5F       	cmp al, '_'
0091+  1442 C6 67 14    	je ispath_true
0092+  1445 B9 2F       	cmp al, '/'
0093+  1447 C6 67 14    	je ispath_true
0094+  144A B9 2E       	cmp al, '.'
0095+  144C C6 67 14    	je ispath_true
0096+  144F B9 41       	cmp al, 'A'
0097+  1451 C8 63 14    	jlu ispath_false
0098+  1454 B9 7A       	cmp al, 'z'
0099+  1456 D1 63 14    	jgu ispath_false
0100+  1459 B9 5A       	cmp al, 'Z'
0101+  145B D0 67 14    	jleu ispath_true
0102+  145E B9 61       	cmp al, 'a'
0103+  1460 C9 67 14    	jgeu ispath_true
0104+  1463             ispath_false:
0105+  1463 8B 01       	or al, 1	; clear ZF
0106+  1465 E8          	pop al
0107+  1466 09          	ret
0108+  1467             ispath_true:
0109+  1467 87 00       	and al, 0	; set ZF
0110+  1469 E8          	pop al
0111+  146A 09          	ret
0112+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  146B             ;; IS SPACE
0114+  146B             ;; sets ZF according with result
0115+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  146B             _isspace:
0117+  146B B9 20       	cmp al, $20		; ' '
0118+  146D C6 81 14    	je _isspace_exit
0119+  1470 B9 09       	cmp al, $09		; '\t'
0120+  1472 C6 81 14    	je _isspace_exit
0121+  1475 B9 0A       	cmp al, $0A		; '\n'
0122+  1477 C6 81 14    	je _isspace_exit
0123+  147A B9 0D       	cmp al, $0D		; '\r'
0124+  147C C6 81 14    	je _isspace_exit
0125+  147F B9 0B       	cmp al, $0B		; '\v'
0126+  1481             _isspace_exit:
0127+  1481 09          	ret	
0128+  1482             
0129+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1482             ; TO LOWER
0131+  1482             ; input in AL
0132+  1482             ; output in AL
0133+  1482             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1482             _to_lower:
0135+  1482 B9 5A       	cmp al, 'Z'
0136+  1484 D1 89 14    	jgu _to_lower_ret
0137+  1487 6A 20       	add al, $20				; convert to lower case
0138+  1489             _to_lower_ret:
0139+  1489 09          	ret
0140+  148A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  148A             ; TO UPPER
0142+  148A             ; input in AL
0143+  148A             ; output in AL
0144+  148A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  148A             _to_upper:
0146+  148A B9 61       	cmp al, 'a'
0147+  148C C8 91 14    	jlu _to_upper_ret
0148+  148F 6F 20       	sub al, $20			; convert to upper case
0149+  1491             _to_upper_ret:
0150+  1491 09          	ret
0151+  1492             
2654   1492             .include "lib/token.asm"
0001+  1492             TOKTYP_IDENTIFIER  .equ 0
0002+  1492             TOKTYP_KEYWORD     .equ 1
0003+  1492             TOKTYP_DELIMITER   .equ 2
0004+  1492             TOKTYP_STRING      .equ 3
0005+  1492             TOKTYP_CHAR        .equ 4
0006+  1492             TOKTYP_NUMERIC     .equ 5
0007+  1492             TOKTYP_END         .equ 6
0008+  1492             
0009+  1492             TOK_NULL           .equ 0
0010+  1492             TOK_FSLASH         .equ 1
0011+  1492             TOK_TIMES          .equ 2
0012+  1492             TOK_PLUS           .equ 3
0013+  1492             TOK_MINUS          .equ 4
0014+  1492             TOK_DOT            .equ 5
0015+  1492             TOK_SEMI           .equ 6
0016+  1492             TOK_ANGLE          .equ 7
0017+  1492             TOK_TILDE          .equ 8
0018+  1492             TOK_EQUAL          .equ 9
0019+  1492             TOK_COLON          .equ 10
0020+  1492             TOK_COMMA          .equ 11
0021+  1492             
0022+  1492             TOK_END            .equ 20
0023+  1492             
0024+  1492             
0025+  1492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1492             ;; read a full command argment from shell input buffer
0027+  1492             ;; argument is written into tokstr
0028+  1492             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1492             get_arg:
0030+  1492 D7            push a
0031+  1493 E2            push si
0032+  1494 E3            push di
0033+  1495 19 00         mov al, 0
0034+  1497 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0035+  149A 14 BC 16      mov a, [prog]
0036+  149D 4D            mov si, a
0037+  149E FD 4F C0 16   mov di, tokstr
0038+  14A2             get_arg_skip_spaces:
0039+  14A2 F6            lodsb
0040+  14A3 07 6B 14      call _isspace
0041+  14A6 C6 A2 14      je get_arg_skip_spaces
0042+  14A9             get_arg_L0:
0043+  14A9 B9 3B         cmp al, $3B        ; check if is ';'
0044+  14AB C6 B8 14      je get_arg_end
0045+  14AE B9 00         cmp al, 0
0046+  14B0 C6 B8 14      je get_arg_end      ; check if end of input
0047+  14B3 F7            stosb
0048+  14B4 F6            lodsb
0049+  14B5 0A A9 14      jmp get_arg_L0
0050+  14B8             get_arg_end:
0051+  14B8 19 00         mov al, 0
0052+  14BA F7            stosb
0053+  14BB D5 01 00      sub si, 1
0054+  14BE 4E            mov a, si
0055+  14BF 42 BC 16      mov [prog], a    ; update pointer
0056+  14C2 F0            pop di
0057+  14C3 EF            pop si
0058+  14C4 E4            pop a
0059+  14C5 09            ret
0060+  14C6             
0061+  14C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  14C6             ;; read a path formation from shell input buffer
0063+  14C6             ;; path is written into tokstr
0064+  14C6             ;; /usr/bin
0065+  14C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  14C6             get_path:
0067+  14C6 D7            push a
0068+  14C7 E2            push si
0069+  14C8 E3            push di
0070+  14C9 19 00         mov al, 0
0071+  14CB 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0072+  14CE 14 BC 16      mov a, [prog]
0073+  14D1 4D            mov si, a
0074+  14D2 FD 4F C0 16   mov di, tokstr
0075+  14D6             get_path_skip_spaces:
0076+  14D6 F6            lodsb
0077+  14D7 07 6B 14      call _isspace
0078+  14DA C6 D6 14      je get_path_skip_spaces
0079+  14DD             get_path_is_pathchar:
0080+  14DD F7            stosb
0081+  14DE F6            lodsb
0082+  14DF 07 F5 13      call _isalnum      ;check if is alphanumeric
0083+  14E2 C6 DD 14      je get_path_is_pathchar
0084+  14E5 B9 2F         cmp al, '/'        ; check if is '/'
0085+  14E7 C6 DD 14      je get_path_is_pathchar
0086+  14EA 19 00         mov al, 0
0087+  14EC F7            stosb
0088+  14ED D5 01 00      sub si, 1
0089+  14F0 4E            mov a, si
0090+  14F1 42 BC 16      mov [prog], a    ; update pointer
0091+  14F4             get_path_end:
0092+  14F4 F0            pop di
0093+  14F5 EF            pop si
0094+  14F6 E4            pop a
0095+  14F7 09            ret
0096+  14F8             
0097+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14F8             ;; read a line
0099+  14F8             ;; line is written into tokstr
0100+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14F8             get_line:
0102+  14F8 D7            push a
0103+  14F9 E2            push si
0104+  14FA E3            push di
0105+  14FB 19 00         mov al, 0
0106+  14FD 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0107+  1500 14 BC 16      mov a, [prog]
0108+  1503 4D            mov si, a
0109+  1504 FD 4F C0 16   mov di, tokstr
0110+  1508             get_line_L0:
0111+  1508 F6            lodsb
0112+  1509 B9 0A         cmp al, $0A    ; check for new line
0113+  150B C6 12 15      je get_line_exit
0114+  150E F7            stosb
0115+  150F 0A 08 15      jmp get_line_L0
0116+  1512             get_line_exit:
0117+  1512 19 00         mov al, 0
0118+  1514 F7            stosb
0119+  1515 4E            mov a, si
0120+  1516 42 BC 16      mov [prog], a    ; update pointer
0121+  1519 F0            pop di
0122+  151A EF            pop si
0123+  151B E4            pop a
0124+  151C 09            ret
0125+  151D             
0126+  151D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  151D             ;; token parser
0128+  151D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  151D             get_token:
0130+  151D D7            push a
0131+  151E DA            push d
0132+  151F E2            push si
0133+  1520 E3            push di
0134+  1521 19 00         mov al, 0
0135+  1523 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0136+  1526 19 00         mov al, TOK_NULL
0137+  1528 3D BF 16      mov [tok], al        ; nullify token
0138+  152B 14 BC 16      mov a, [prog]
0139+  152E 4D            mov si, a
0140+  152F FD 4F C0 16   mov di, tokstr
0141+  1533             get_tok_skip_spaces:
0142+  1533 F6            lodsb
0143+  1534 07 6B 14      call _isspace
0144+  1537 C6 33 15      je get_tok_skip_spaces
0145+  153A B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  153C C6 21 16      je get_token_end
0147+  153F B9 23         cmp al, '#'      ; comments!
0148+  1541 C6 4F 16      je get_tok_comment
0149+  1544 07 F5 13      call _isalnum
0150+  1547 C6 2E 16      jz is_alphanumeric
0151+  154A             ; other token types
0152+  154A             get_token_slash:
0153+  154A B9 2F         cmp al, '/'        ; check if '/'
0154+  154C C7 64 15      jne get_token_minus
0155+  154F F7            stosb          ; store '/' into token string
0156+  1550 19 00         mov al, 0
0157+  1552 F7            stosb          ; terminate token string
0158+  1553 19 01         mov al, TOK_FSLASH
0159+  1555 3D BF 16      mov [tok], al      
0160+  1558 19 02         mov al, TOKTYP_DELIMITER
0161+  155A 3D BE 16      mov [toktyp], al
0162+  155D 4E            mov a, si
0163+  155E 42 BC 16      mov [prog], a    ; update pointer
0164+  1561 0A 4A 16      jmp get_token_return
0165+  1564             get_token_minus:
0166+  1564 B9 2D         cmp al, '-'        ; check if '-'
0167+  1566 C7 7E 15      jne get_token_comma
0168+  1569 F7            stosb          ; store '-' into token string
0169+  156A 19 00         mov al, 0
0170+  156C F7            stosb          ; terminate token string
0171+  156D 19 04         mov al, TOK_MINUS
0172+  156F 3D BF 16      mov [tok], al      
0173+  1572 19 02         mov al, TOKTYP_DELIMITER
0174+  1574 3D BE 16      mov [toktyp], al
0175+  1577 4E            mov a, si
0176+  1578 42 BC 16      mov [prog], a    ; update pointer
0177+  157B 0A 4A 16      jmp get_token_return
0178+  157E             get_token_comma:
0179+  157E B9 2C         cmp al, ','        ; check if ','
0180+  1580 C7 98 15      jne get_token_semi
0181+  1583 F7            stosb          ; store ',' into token string
0182+  1584 19 00         mov al, 0
0183+  1586 F7            stosb          ; terminate token string
0184+  1587 19 0B         mov al, TOK_COMMA
0185+  1589 3D BF 16      mov [tok], al      
0186+  158C 19 02         mov al, TOKTYP_DELIMITER
0187+  158E 3D BE 16      mov [toktyp], al
0188+  1591 4E            mov a, si
0189+  1592 42 BC 16      mov [prog], a    ; update pointer
0190+  1595 0A 4A 16      jmp get_token_return
0191+  1598             get_token_semi:
0192+  1598 B9 3B         cmp al, $3B        ; check if ';'
0193+  159A C7 B2 15      jne get_token_colon
0194+  159D F7            stosb          ; store ';' into token string
0195+  159E 19 00         mov al, 0
0196+  15A0 F7            stosb          ; terminate token string
0197+  15A1 19 06         mov al, TOK_SEMI
0198+  15A3 3D BF 16      mov [tok], al      
0199+  15A6 19 02         mov al, TOKTYP_DELIMITER
0200+  15A8 3D BE 16      mov [toktyp], al
0201+  15AB 4E            mov a, si
0202+  15AC 42 BC 16      mov [prog], a    ; update pointer
0203+  15AF 0A 4A 16      jmp get_token_return
0204+  15B2             get_token_colon:
0205+  15B2 B9 3A         cmp al, $3A        ; check if ':'
0206+  15B4 C7 CC 15      jne get_token_angle
0207+  15B7 F7            stosb          ; store ':' into token string
0208+  15B8 19 00         mov al, 0
0209+  15BA F7            stosb          ; terminate token string
0210+  15BB 19 0A         mov al, TOK_COLON
0211+  15BD 3D BF 16      mov [tok], al      
0212+  15C0 19 02         mov al, TOKTYP_DELIMITER
0213+  15C2 3D BE 16      mov [toktyp], al
0214+  15C5 4E            mov a, si
0215+  15C6 42 BC 16      mov [prog], a    ; update pointer
0216+  15C9 0A 4A 16      jmp get_token_return
0217+  15CC             get_token_angle:
0218+  15CC B9 3E         cmp al, $3E        ; check if '>'
0219+  15CE C7 E6 15      jne get_token_tilde
0220+  15D1 F7            stosb          ; store '>' into token string
0221+  15D2 19 00         mov al, 0
0222+  15D4 F7            stosb          ; terminate token string
0223+  15D5 19 07         mov al, TOK_ANGLE
0224+  15D7 3D BF 16      mov [tok], al      
0225+  15DA 19 02         mov al, TOKTYP_DELIMITER
0226+  15DC 3D BE 16      mov [toktyp], al
0227+  15DF 4E            mov a, si
0228+  15E0 42 BC 16      mov [prog], a    ; update pointer
0229+  15E3 0A 4A 16      jmp get_token_return
0230+  15E6             get_token_tilde:
0231+  15E6 B9 7E         cmp al, '~'        ; check if '~'
0232+  15E8 C7 00 16      jne get_token_equal
0233+  15EB F7            stosb          ; store '~' into token string
0234+  15EC 19 00         mov al, 0
0235+  15EE F7            stosb          ; terminate token string
0236+  15EF 19 08         mov al, TOK_TILDE
0237+  15F1 3D BF 16      mov [tok], al      
0238+  15F4 19 02         mov al, TOKTYP_DELIMITER
0239+  15F6 3D BE 16      mov [toktyp], al
0240+  15F9 4E            mov a, si
0241+  15FA 42 BC 16      mov [prog], a    ; update pointer
0242+  15FD 0A 4A 16      jmp get_token_return
0243+  1600             get_token_equal:
0244+  1600 B9 3D         cmp al, '='        ; check if '='
0245+  1602 C7 1A 16      jne get_token_skip
0246+  1605 F7            stosb          ; store '=' into token string
0247+  1606 19 00         mov al, 0
0248+  1608 F7            stosb          ; terminate token string
0249+  1609 19 09         mov al, TOK_EQUAL
0250+  160B 3D BF 16      mov [tok], al      
0251+  160E 19 02         mov al, TOKTYP_DELIMITER
0252+  1610 3D BE 16      mov [toktyp], al
0253+  1613 4E            mov a, si
0254+  1614 42 BC 16      mov [prog], a    ; update pointer
0255+  1617 0A 4A 16      jmp get_token_return
0256+  161A             get_token_skip:
0257+  161A 4E            mov a, si
0258+  161B 42 BC 16      mov [prog], a    ; update pointer
0259+  161E 0A 4A 16      jmp get_token_return
0260+  1621             get_token_end:        ; end of file token
0261+  1621 19 14         mov al, TOK_END
0262+  1623 3D BF 16      mov [tok], al
0263+  1626 19 06         mov al, TOKTYP_END
0264+  1628 3D BE 16      mov [toktyp], al
0265+  162B 0A 4A 16      jmp get_token_return
0266+  162E             is_alphanumeric:
0267+  162E F7            stosb
0268+  162F F6            lodsb
0269+  1630 07 F5 13      call _isalnum      ;check if is alphanumeric
0270+  1633 C6 2E 16      jz is_alphanumeric
0271+  1636 B9 2E         cmp al, $2E        ; check if is '.'
0272+  1638 C6 2E 16      je is_alphanumeric
0273+  163B 19 00         mov al, 0
0274+  163D F7            stosb
0275+  163E 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1640 3D BE 16      mov [toktyp], al
0277+  1643 D5 01 00      sub si, 1
0278+  1646 4E            mov a, si
0279+  1647 42 BC 16      mov [prog], a    ; update pointer
0280+  164A             get_token_return:
0281+  164A F0            pop di
0282+  164B EF            pop si
0283+  164C E7            pop d
0284+  164D E4            pop a
0285+  164E 09            ret
0286+  164F             get_tok_comment:
0287+  164F F6            lodsb
0288+  1650 B9 0A         cmp al, $0A      ; new line
0289+  1652 C7 4F 16      jne get_tok_comment
0290+  1655 0A 33 15      jmp get_tok_skip_spaces
0291+  1658             
0292+  1658             
0293+  1658             get_number:
0294+  1658 D7            push a
0295+  1659 DA            push d
0296+  165A E2            push si
0297+  165B E3            push di
0298+  165C 19 00         mov al, 0
0299+  165E 3D C0 16      mov [tokstr], al      ; nullify tokstr string
0300+  1661 19 00         mov al, TOK_NULL
0301+  1663 3D BF 16      mov [tok], al        ; nullify token
0302+  1666 14 BC 16      mov a, [prog]
0303+  1669 4D            mov si, a
0304+  166A FD 4F C0 16   mov di, tokstr
0305+  166E             get_number_skip_spaces:
0306+  166E F6            lodsb
0307+  166F 07 6B 14      call _isspace
0308+  1672 C6 6E 16      je get_number_skip_spaces
0309+  1675 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  1677 C7 87 16      jne get_number_L0
0311+  167A 19 14         mov al, TOK_END
0312+  167C 3D BF 16      mov [tok], al
0313+  167F 19 06         mov al, TOKTYP_END
0314+  1681 3D BE 16      mov [toktyp], al
0315+  1684 0A 9E 16      jmp get_number_return
0316+  1687             get_number_L0:
0317+  1687 F7            stosb
0318+  1688 F6            lodsb
0319+  1689 07 FF 13      call _isdigit      ;check if is numeric
0320+  168C C6 87 16      jz get_number_L0
0321+  168F 19 00         mov al, 0
0322+  1691 F7            stosb
0323+  1692 19 05         mov al, TOKTYP_NUMERIC
0324+  1694 3D BE 16      mov [toktyp], al
0325+  1697 D5 01 00      sub si, 1
0326+  169A 4E            mov a, si
0327+  169B 42 BC 16      mov [prog], a    ; update pointer
0328+  169E             get_number_return:
0329+  169E F0            pop di
0330+  169F EF            pop si
0331+  16A0 E7            pop d
0332+  16A1 E4            pop a
0333+  16A2 09            ret
0334+  16A3             
0335+  16A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  16A3             ;; PUT BACK TOKEN
0337+  16A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  16A3             _putback:
0339+  16A3 D7            push a
0340+  16A4 E2            push si
0341+  16A5 FD 4D C0 16   mov si, tokstr  
0342+  16A9             _putback_loop:
0343+  16A9 F6            lodsb
0344+  16AA B9 00         cmp al, 0
0345+  16AC C6 B9 16      je _putback_end
0346+  16AF 14 BC 16      mov a, [prog]
0347+  16B2 7D            dec a
0348+  16B3 42 BC 16      mov [prog], a      ; update pointer
0349+  16B6 0A A9 16      jmp _putback_loop
0350+  16B9             _putback_end:
0351+  16B9 EF            pop si
0352+  16BA E4            pop a
0353+  16BB 09            ret
0354+  16BC             
0355+  16BC             
0356+  16BC             
0357+  16BC             
0358+  16BC 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  16BE             
0360+  16BE 00          toktyp:    .db 0          ; token type symbol
0361+  16BF 00          tok:       .db 0          ; current token symbol
0362+  16C0 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  16C4 00 00 00 00 
0362+  16C8 00 00 00 00 
0362+  16CC 00 00 00 00 
0362+  16D0 00 00 00 00 
0362+  16D4 00 00 00 00 
0362+  16D8 00 00 00 00 
0362+  16DC 00 00 00 00 
0362+  16E0 00 00 00 00 
0362+  16E4 00 00 00 00 
0362+  16E8 00 00 00 00 
0362+  16EC 00 00 00 00 
0362+  16F0 00 00 00 00 
0362+  16F4 00 00 00 00 
0362+  16F8 00 00 00 00 
0362+  16FC 00 00 00 00 
0362+  1700 00 00 00 00 
0362+  1704 00 00 00 00 
0362+  1708 00 00 00 00 
0362+  170C 00 00 00 00 
0362+  1710 00 00 00 00 
0362+  1714 00 00 00 00 
0362+  1718 00 00 00 00 
0362+  171C 00 00 00 00 
0362+  1720 00 00 00 00 
0362+  1724 00 00 00 00 
0362+  1728 00 00 00 00 
0362+  172C 00 00 00 00 
0362+  1730 00 00 00 00 
0362+  1734 00 00 00 00 
0362+  1738 00 00 00 00 
0362+  173C 00 00 00 00 
0362+  1740 00 00 00 00 
0362+  1744 00 00 00 00 
0362+  1748 00 00 00 00 
0362+  174C 00 00 00 00 
0362+  1750 00 00 00 00 
0362+  1754 00 00 00 00 
0362+  1758 00 00 00 00 
0362+  175C 00 00 00 00 
0362+  1760 00 00 00 00 
0362+  1764 00 00 00 00 
0362+  1768 00 00 00 00 
0362+  176C 00 00 00 00 
0362+  1770 00 00 00 00 
0362+  1774 00 00 00 00 
0362+  1778 00 00 00 00 
0362+  177C 00 00 00 00 
0362+  1780 00 00 00 00 
0362+  1784 00 00 00 00 
0362+  1788 00 00 00 00 
0362+  178C 00 00 00 00 
0362+  1790 00 00 00 00 
0362+  1794 00 00 00 00 
0362+  1798 00 00 00 00 
0362+  179C 00 00 00 00 
0362+  17A0 00 00 00 00 
0362+  17A4 00 00 00 00 
0362+  17A8 00 00 00 00 
0362+  17AC 00 00 00 00 
0362+  17B0 00 00 00 00 
0362+  17B4 00 00 00 00 
0362+  17B8 00 00 00 00 
0362+  17BC 00 00 00 00 
2655   17C0             
2656   17C0             ; kernel parameters
2657   17C0 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2658   17C1 01          sys_echo_on:        .db 1
2659   17C2 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2660   17C3 01          sys_uart0_inten:    .db 1
2661   17C4 00          sys_uart0_fifoen:   .db 0
2662   17C5 0C          sys_uart0_div0:     .db 12  ;
2663   17C6 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2664   17C7             ; Baud  Divisor
2665   17C7             ; 50    2304
2666   17C7             ; 110   1047
2667   17C7             ; 300    384
2668   17C7             ; 600    192
2669   17C7             ; 1200    96
2670   17C7             ; 9600    12
2671   17C7             ; 19200    6
2672   17C7             ; 38400    3
2673   17C7             
2674   17C7 00          nbr_active_procs:   .db 0
2675   17C8 01          active_proc_index:  .db 1
2676   17C9             
2677   17C9 00 00       index:              .dw 0
2678   17CB 00 00       buffer_addr:        .dw 0
2679   17CD             
2680   17CD 1D 21       fifo_in:            .dw fifo
2681   17CF 1D 21       fifo_out:           .dw fifo
2682   17D1             
2683   17D1             ; file system variables
2684   17D1 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2685   17D3 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2685   17D7 6E 2F 69 6E 
2685   17DB 69 74 00 
2686   17DE             
2687   17DE 73 6F 6C 61 s_uname:            .db "solarium v.1.0", 0
2687   17E2 72 69 75 6D 
2687   17E6 20 76 2E 31 
2687   17EA 2E 30 00 
2688   17ED 3E 20 00    s_dataentry:        .db "> ", 0
2689   17F0 2E 2E 00    s_parent_dir:       .db "..", 0
2690   17F3 2E 00       s_current_dir:      .db ".", 0
2691   17F5 2F 00       s_fslash:           .db "/", 0
2692   17F7 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2692   17FB 78 
2693   17FC 2D 64 63    file_type:          .db "-dc"
2694   17FF 70 69 64 20 s_ps_header:        .db "pid command\n", 0
2694   1803 63 6F 6D 6D 
2694   1807 61 6E 64 0A 
2694   180B 00 
2695   180C 74 6F 74 61 s_ls_total:         .db "total: ", 0
2695   1810 6C 3A 20 00 
2696   1814             
2697   1814 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2697   1818 20 65 6E 61 
2697   181C 62 6C 65 64 
2697   1820 0A 00 
2698   1822 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2698   1826 65 6C 20 73 
2698   182A 74 61 72 74 
2698   182E 65 64 28 76 
2698   1832 65 72 73 69 
2698   1836 6F 6E 20 31 
2698   183A 2E 30 29 0A 
2698   183E 00 
2699   183F 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2699   1843 74 69 6E 67 
2699   1847 20 69 6E 69 
2699   184B 74 0A 00 
2700   184E 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2700   1852 65 70 74 69 
2700   1856 6F 6E 3A 20 
2700   185A 70 72 69 76 
2700   185E 69 6C 65 67 
2700   1862 65 0A 00 
2701   1865 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2701   1869 65 70 74 69 
2701   186D 6F 6E 3A 20 
2701   1871 7A 65 72 6F 
2701   1875 20 64 69 76 
2701   1879 69 73 69 6F 
2701   187D 6E 0A 00 
2702   1880             
2703   1880 79 65 61 72 s_set_year:         .db "year: ", 0
2703   1884 3A 20 00 
2704   1887 6D 6F 6E 74 s_set_month:        .db "month: ", 0
2704   188B 68 3A 20 00 
2705   188F 64 61 79 3A s_set_day:          .db "day: ", 0
2705   1893 20 00 
2706   1895 77 65 65 6B s_set_week:         .db "weekday: ", 0
2706   1899 64 61 79 3A 
2706   189D 20 00 
2707   189F 68 6F 75 72 s_set_hours:        .db "hours: ", 0
2707   18A3 73 3A 20 00 
2708   18A7 6D 69 6E 75 s_set_minutes:      .db "minutes: ", 0
2708   18AB 74 65 73 3A 
2708   18AF 20 00 
2709   18B1 73 65 63 6F s_set_seconds:      .db "seconds: ", 0
2709   18B5 6E 64 73 3A 
2709   18B9 20 00 
2710   18BB             s_months:      
2711   18BB 20 20 20 00   .db "   ", 0
2712   18BF 4A 61 6E 00   .db "Jan", 0
2713   18C3 46 65 62 00   .db "Feb", 0
2714   18C7 4D 61 72 00   .db "Mar", 0
2715   18CB 41 70 72 00   .db "Apr", 0
2716   18CF 4D 61 79 00   .db "May", 0
2717   18D3 4A 75 6E 00   .db "Jun", 0
2718   18D7 4A 75 6C 00   .db "Jul", 0
2719   18DB 41 75 67 00   .db "Aug", 0
2720   18DF 53 65 70 00   .db "Sep", 0
2721   18E3 4F 63 74 00   .db "Oct", 0
2722   18E7 4E 6F 76 00   .db "Nov", 0
2723   18EB 44 65 63 00   .db "Dec", 0
2724   18EF             
2725   18EF             s_week:        
2726   18EF 53 75 6E 00   .db "Sun", 0 
2727   18F3 4D 6F 6E 00   .db "Mon", 0 
2728   18F7 54 75 65 00   .db "Tue", 0 
2729   18FB 57 65 64 00   .db "Wed", 0 
2730   18FF 54 68 75 00   .db "Thu", 0 
2731   1903 46 72 69 00   .db "Fri", 0 
2732   1907 53 61 74 00   .db "Sat", 0
2733   190B             
2734   190B             ; This is the format of a sector for the 128 byte per sector format.
2735   190B             ; Write the bracketed data 16 times per track.
2736   190B             ; The recommended single-density format with 128
2737   190B             ; bytes/sector is shown. In order to format a diskette,
2738   190B             ; the user issues the Write Track Command, and loads
2739   190B             ; the Data Register with the following values. For every
2740   190B             ; byte to be written, there is one Data Request.
2741   190B             fdc_128_bytes_per_sect:                                                                       
2742   190B FF FF FF FF fdc_40_FF:          .fill 40,  $FF    ; or 00                                                                                
2742   190F FF FF FF FF 
2742   1913 FF FF FF FF 
2742   1917 FF FF FF FF 
2742   191B FF FF FF FF 
2742   191F FF FF FF FF 
2742   1923 FF FF FF FF 
2742   1927 FF FF FF FF 
2742   192B FF FF FF FF 
2742   192F FF FF FF FF 
2743   1933 00 00 00 00 fdc_6_00_0:         .fill 6,   $00    ;                                                                            <--|        
2743   1937 00 00 
2744   1939 FE          fdc_id_fe:          .fill 1,   $FE    ; ID Address Mark                                                               |        
2745   193A 00          fdc_track:          .fill 1,   $00    ; Track Number                                                                  |                    
2746   193B 00          fdc_side:           .fill 1,   $00    ; Side Number 00 or 01                                                          |                
2747   193C 01          fdc_sector:         .fill 1,   $01    ; Sector Number  1 through 10                                                   |                              
2748   193D 00          fdc_length:         .fill 1,   $00    ; Sector Length                                                                 |                        
2749   193E F7          fdc_2_crc_0:        .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
2750   193F FF FF FF FF fdc_11_ff:          .fill 11,  $FF    ; or 00                                                                         |                      
2750   1943 FF FF FF FF 
2750   1947 FF FF FF 
2751   194A 00 00 00 00 fdc_6_00_1:         .fill 6,   $00    ;                                                                               |                        
2751   194E 00 00 
2752   1950 FB          fdc_data_addr:      .fill 1,   $FB    ; Data Address Mark                                                             |                                  
2753   1951 E5 E5 E5 E5 fdc_data:           .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
2753   1955 E5 E5 E5 E5 
2753   1959 E5 E5 E5 E5 
2753   195D E5 E5 E5 E5 
2753   1961 E5 E5 E5 E5 
2753   1965 E5 E5 E5 E5 
2753   1969 E5 E5 E5 E5 
2753   196D E5 E5 E5 E5 
2753   1971 E5 E5 E5 E5 
2753   1975 E5 E5 E5 E5 
2753   1979 E5 E5 E5 E5 
2753   197D E5 E5 E5 E5 
2753   1981 E5 E5 E5 E5 
2753   1985 E5 E5 E5 E5 
2753   1989 E5 E5 E5 E5 
2753   198D E5 E5 E5 E5 
2753   1991 E5 E5 E5 E5 
2753   1995 E5 E5 E5 E5 
2753   1999 E5 E5 E5 E5 
2753   199D E5 E5 E5 E5 
2753   19A1 E5 E5 E5 E5 
2753   19A5 E5 E5 E5 E5 
2753   19A9 E5 E5 E5 E5 
2753   19AD E5 E5 E5 E5 
2753   19B1 E5 E5 E5 E5 
2753   19B5 E5 E5 E5 E5 
2753   19B9 E5 E5 E5 E5 
2753   19BD E5 E5 E5 E5 
2753   19C1 E5 E5 E5 E5 
2753   19C5 E5 E5 E5 E5 
2753   19C9 E5 E5 E5 E5 
2753   19CD E5 E5 E5 E5 
2754   19D1 F7          fdc_2_crc_1:        .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
2755   19D2 FF FF FF FF fdc_10_ff:          .fill 10,  $FF    ; or 00                                                                      <--|                                                  
2755   19D6 FF FF FF FF 
2755   19DA FF FF 
2756   19DC FF FF FF FF fdc_369_ff:         .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2756   19E0 FF FF FF FF 
2756   19E4 FF FF FF FF 
2756   19E8 FF FF FF FF 
2756   19EC FF FF FF FF 
2756   19F0 FF FF FF FF 
2756   19F4 FF FF FF FF 
2756   19F8 FF FF FF FF 
2756   19FC FF FF FF FF 
2756   1A00 FF FF FF FF 
2756   1A04 FF FF FF FF 
2756   1A08 FF FF FF FF 
2756   1A0C FF FF FF FF 
2756   1A10 FF FF FF FF 
2756   1A14 FF FF FF FF 
2756   1A18 FF FF FF FF 
2756   1A1C FF FF FF FF 
2756   1A20 FF FF FF FF 
2756   1A24 FF FF FF FF 
2756   1A28 FF FF FF FF 
2756   1A2C FF FF FF FF 
2756   1A30 FF FF FF FF 
2756   1A34 FF FF FF FF 
2756   1A38 FF FF FF FF 
2756   1A3C FF FF FF FF 
2756   1A40 FF FF FF FF 
2756   1A44 FF FF FF FF 
2756   1A48 FF FF FF FF 
2756   1A4C FF FF FF FF 
2756   1A50 FF FF FF FF 
2756   1A54 FF FF FF FF 
2756   1A58 FF FF FF FF 
2756   1A5C FF FF FF FF 
2756   1A60 FF FF FF FF 
2756   1A64 FF FF FF FF 
2756   1A68 FF FF FF FF 
2756   1A6C FF FF FF FF 
2756   1A70 FF FF FF FF 
2756   1A74 FF FF FF FF 
2756   1A78 FF FF FF FF 
2756   1A7C FF FF FF FF 
2756   1A80 FF FF FF FF 
2756   1A84 FF FF FF FF 
2756   1A88 FF FF FF FF 
2756   1A8C FF FF FF FF 
2756   1A90 FF FF FF FF 
2756   1A94 FF FF FF FF 
2756   1A98 FF FF FF FF 
2756   1A9C FF FF FF FF 
2756   1AA0 FF FF FF FF 
2756   1AA4 FF FF FF FF 
2756   1AA8 FF FF FF FF 
2756   1AAC FF FF FF FF 
2756   1AB0 FF FF FF FF 
2756   1AB4 FF FF FF FF 
2756   1AB8 FF FF FF FF 
2756   1ABC FF FF FF FF 
2756   1AC0 FF FF FF FF 
2756   1AC4 FF FF FF FF 
2756   1AC8 FF FF FF FF 
2756   1ACC FF FF FF FF 
2756   1AD0 FF FF FF FF 
2756   1AD4 FF FF FF FF 
2756   1AD8 FF FF FF FF 
2756   1ADC FF FF FF FF 
2756   1AE0 FF FF FF FF 
2756   1AE4 FF FF FF FF 
2756   1AE8 FF FF FF FF 
2756   1AEC FF FF FF FF 
2756   1AF0 FF FF FF FF 
2756   1AF4 FF FF FF FF 
2756   1AF8 FF FF FF FF 
2756   1AFC FF FF FF FF 
2756   1B00 FF FF FF FF 
2756   1B04 FF FF FF FF 
2756   1B08 FF FF FF FF 
2756   1B0C FF FF FF FF 
2756   1B10 FF FF FF FF 
2756   1B14 FF FF FF FF 
2756   1B18 FF FF FF FF 
2756   1B1C FF FF FF FF 
2756   1B20 FF FF FF FF 
2756   1B24 FF FF FF FF 
2756   1B28 FF FF FF FF 
2756   1B2C FF FF FF FF 
2756   1B30 FF FF FF FF 
2756   1B34 FF FF FF FF 
2756   1B38 FF FF FF FF 
2756   1B3C FF FF FF FF 
2756   1B40 FF FF FF FF 
2756   1B44 FF FF FF FF 
2756   1B48 FF FF FF FF 
2756   1B4C FF 
2757   1B4D             
2758   1B4D 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2758   1B51 00 00 00 00 
2758   1B55 00 00 00 00 
2758   1B59 00 00 00 00 
2758   1B5D 00 00 00 00 
2758   1B61 00 00 00 00 
2758   1B65 00 00 00 00 
2758   1B69 00 00 00 00 
2758   1B6D 00 00 00 00 
2758   1B71 00 00 00 00 
2758   1B75 00 00 00 00 
2758   1B79 00 00 00 00 
2758   1B7D 00 00 00 00 
2758   1B81 00 00 00 00 
2758   1B85 00 00 00 00 
2758   1B89 00 00 00 00 
2758   1B8D 00 00 00 00 
2758   1B91 00 00 00 00 
2758   1B95 00 00 00 00 
2758   1B99 00 00 00 00 
2758   1B9D 00 00 00 00 
2758   1BA1 00 00 00 00 
2758   1BA5 00 00 00 00 
2758   1BA9 00 00 00 00 
2758   1BAD 00 00 00 00 
2758   1BB1 00 00 00 00 
2758   1BB5 00 00 00 00 
2758   1BB9 00 00 00 00 
2758   1BBD 00 00 00 00 
2758   1BC1 00 00 00 00 
2758   1BC5 00 00 00 00 
2758   1BC9 00 00 00 00 
2758   1BCD 00 00 00 00 
2758   1BD1 00 00 00 00 
2758   1BD5 00 00 00 00 
2758   1BD9 00 00 00 00 
2758   1BDD 00 00 00 00 
2758   1BE1 00 00 00 00 
2758   1BE5 00 00 00 00 
2758   1BE9 00 00 00 00 
2758   1BED 00 00 00 00 
2758   1BF1 00 00 00 00 
2758   1BF5 00 00 00 00 
2758   1BF9 00 00 00 00 
2758   1BFD 00 00 00 00 
2758   1C01 00 00 00 00 
2758   1C05 00 00 00 00 
2758   1C09 00 00 00 00 
2758   1C0D 00 00 00 00 
2758   1C11 00 00 00 00 
2758   1C15 00 00 00 00 
2758   1C19 00 00 00 00 
2758   1C1D 00 00 00 00 
2758   1C21 00 00 00 00 
2758   1C25 00 00 00 00 
2758   1C29 00 00 00 00 
2758   1C2D 00 00 00 00 
2758   1C31 00 00 00 00 
2758   1C35 00 00 00 00 
2758   1C39 00 00 00 00 
2758   1C3D 00 00 00 00 
2758   1C41 00 00 00 00 
2758   1C45 00 00 00 00 
2758   1C49 00 00 00 00 
2758   1C4D 00 00 00 00 
2758   1C51 00 00 00 00 
2758   1C55 00 00 00 00 
2758   1C59 00 00 00 00 
2758   1C5D 00 00 00 00 
2758   1C61 00 00 00 00 
2758   1C65 00 00 00 00 
2758   1C69 00 00 00 00 
2758   1C6D 00 00 00 00 
2758   1C71 00 00 00 00 
2758   1C75 00 00 00 00 
2758   1C79 00 00 00 00 
2758   1C7D 00 00 00 00 
2758   1C81 00 00 00 00 
2758   1C85 00 00 00 00 
2758   1C89 00 00 00 00 
2759   1C8D 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2759   1C91 00 00 00 00 
2759   1C95 00 00 00 00 
2759   1C99 00 00 00 00 
2760   1C9D 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2760   1CA1 00 00 00 00 
2760   1CA5 00 00 00 00 
2760   1CA9 00 00 00 00 
2760   1CAD 00 00 00 00 
2760   1CB1 00 00 00 00 
2760   1CB5 00 00 00 00 
2760   1CB9 00 00 00 00 
2760   1CBD 00 00 00 00 
2760   1CC1 00 00 00 00 
2760   1CC5 00 00 00 00 
2760   1CC9 00 00 00 00 
2760   1CCD 00 00 00 00 
2760   1CD1 00 00 00 00 
2760   1CD5 00 00 00 00 
2760   1CD9 00 00 00 00 
2760   1CDD 00 00 00 00 
2760   1CE1 00 00 00 00 
2760   1CE5 00 00 00 00 
2760   1CE9 00 00 00 00 
2760   1CED 00 00 00 00 
2760   1CF1 00 00 00 00 
2760   1CF5 00 00 00 00 
2760   1CF9 00 00 00 00 
2760   1CFD 00 00 00 00 
2760   1D01 00 00 00 00 
2760   1D05 00 00 00 00 
2760   1D09 00 00 00 00 
2760   1D0D 00 00 00 00 
2760   1D11 00 00 00 00 
2760   1D15 00 00 00 00 
2760   1D19 00 00 00 00 
2760   1D1D 00 00 00 00 
2760   1D21 00 00 00 00 
2760   1D25 00 00 00 00 
2760   1D29 00 00 00 00 
2760   1D2D 00 00 00 00 
2760   1D31 00 00 00 00 
2760   1D35 00 00 00 00 
2760   1D39 00 00 00 00 
2760   1D3D 00 00 00 00 
2760   1D41 00 00 00 00 
2760   1D45 00 00 00 00 
2760   1D49 00 00 00 00 
2760   1D4D 00 00 00 00 
2760   1D51 00 00 00 00 
2760   1D55 00 00 00 00 
2760   1D59 00 00 00 00 
2760   1D5D 00 00 00 00 
2760   1D61 00 00 00 00 
2760   1D65 00 00 00 00 
2760   1D69 00 00 00 00 
2760   1D6D 00 00 00 00 
2760   1D71 00 00 00 00 
2760   1D75 00 00 00 00 
2760   1D79 00 00 00 00 
2760   1D7D 00 00 00 00 
2760   1D81 00 00 00 00 
2760   1D85 00 00 00 00 
2760   1D89 00 00 00 00 
2760   1D8D 00 00 00 00 
2760   1D91 00 00 00 00 
2760   1D95 00 00 00 00 
2760   1D99 00 00 00 00 
2760   1D9D 00 00 00 00 
2760   1DA1 00 00 00 00 
2760   1DA5 00 00 00 00 
2760   1DA9 00 00 00 00 
2760   1DAD 00 00 00 00 
2760   1DB1 00 00 00 00 
2760   1DB5 00 00 00 00 
2760   1DB9 00 00 00 00 
2760   1DBD 00 00 00 00 
2760   1DC1 00 00 00 00 
2760   1DC5 00 00 00 00 
2760   1DC9 00 00 00 00 
2760   1DCD 00 00 00 00 
2760   1DD1 00 00 00 00 
2760   1DD5 00 00 00 00 
2760   1DD9 00 00 00 00 
2760   1DDD 00 00 00 00 
2760   1DE1 00 00 00 00 
2760   1DE5 00 00 00 00 
2760   1DE9 00 00 00 00 
2760   1DED 00 00 00 00 
2760   1DF1 00 00 00 00 
2760   1DF5 00 00 00 00 
2760   1DF9 00 00 00 00 
2760   1DFD 00 00 00 00 
2760   1E01 00 00 00 00 
2760   1E05 00 00 00 00 
2760   1E09 00 00 00 00 
2760   1E0D 00 00 00 00 
2760   1E11 00 00 00 00 
2760   1E15 00 00 00 00 
2760   1E19 00 00 00 00 
2760   1E1D 00 00 00 00 
2760   1E21 00 00 00 00 
2760   1E25 00 00 00 00 
2760   1E29 00 00 00 00 
2760   1E2D 00 00 00 00 
2760   1E31 00 00 00 00 
2760   1E35 00 00 00 00 
2760   1E39 00 00 00 00 
2760   1E3D 00 00 00 00 
2760   1E41 00 00 00 00 
2760   1E45 00 00 00 00 
2760   1E49 00 00 00 00 
2760   1E4D 00 00 00 00 
2760   1E51 00 00 00 00 
2760   1E55 00 00 00 00 
2760   1E59 00 00 00 00 
2760   1E5D 00 00 00 00 
2760   1E61 00 00 00 00 
2760   1E65 00 00 00 00 
2760   1E69 00 00 00 00 
2760   1E6D 00 00 00 00 
2760   1E71 00 00 00 00 
2760   1E75 00 00 00 00 
2760   1E79 00 00 00 00 
2760   1E7D 00 00 00 00 
2760   1E81 00 00 00 00 
2760   1E85 00 00 00 00 
2760   1E89 00 00 00 00 
2760   1E8D 00 00 00 00 
2760   1E91 00 00 00 00 
2760   1E95 00 00 00 00 
2760   1E99 00 00 00 00 
2761   1E9D 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2761   1EA1 00 00 00 00 
2761   1EA5 00 00 00 00 
2761   1EA9 00 00 00 00 
2761   1EAD 00 00 00 00 
2761   1EB1 00 00 00 00 
2761   1EB5 00 00 00 00 
2761   1EB9 00 00 00 00 
2761   1EBD 00 00 00 00 
2761   1EC1 00 00 00 00 
2761   1EC5 00 00 00 00 
2761   1EC9 00 00 00 00 
2761   1ECD 00 00 00 00 
2761   1ED1 00 00 00 00 
2761   1ED5 00 00 00 00 
2761   1ED9 00 00 00 00 
2761   1EDD 00 00 00 00 
2761   1EE1 00 00 00 00 
2761   1EE5 00 00 00 00 
2761   1EE9 00 00 00 00 
2761   1EED 00 00 00 00 
2761   1EF1 00 00 00 00 
2761   1EF5 00 00 00 00 
2761   1EF9 00 00 00 00 
2761   1EFD 00 00 00 00 
2761   1F01 00 00 00 00 
2761   1F05 00 00 00 00 
2761   1F09 00 00 00 00 
2761   1F0D 00 00 00 00 
2761   1F11 00 00 00 00 
2761   1F15 00 00 00 00 
2761   1F19 00 00 00 00 
2762   1F1D 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2762   1F21 00 00 00 00 
2762   1F25 00 00 00 00 
2762   1F29 00 00 00 00 
2762   1F2D 00 00 00 00 
2762   1F31 00 00 00 00 
2762   1F35 00 00 00 00 
2762   1F39 00 00 00 00 
2762   1F3D 00 00 00 00 
2762   1F41 00 00 00 00 
2762   1F45 00 00 00 00 
2762   1F49 00 00 00 00 
2762   1F4D 00 00 00 00 
2762   1F51 00 00 00 00 
2762   1F55 00 00 00 00 
2762   1F59 00 00 00 00 
2762   1F5D 00 00 00 00 
2762   1F61 00 00 00 00 
2762   1F65 00 00 00 00 
2762   1F69 00 00 00 00 
2762   1F6D 00 00 00 00 
2762   1F71 00 00 00 00 
2762   1F75 00 00 00 00 
2762   1F79 00 00 00 00 
2762   1F7D 00 00 00 00 
2762   1F81 00 00 00 00 
2762   1F85 00 00 00 00 
2762   1F89 00 00 00 00 
2762   1F8D 00 00 00 00 
2762   1F91 00 00 00 00 
2762   1F95 00 00 00 00 
2762   1F99 00 00 00 00 
2762   1F9D 00 00 00 00 
2762   1FA1 00 00 00 00 
2762   1FA5 00 00 00 00 
2762   1FA9 00 00 00 00 
2762   1FAD 00 00 00 00 
2762   1FB1 00 00 00 00 
2762   1FB5 00 00 00 00 
2762   1FB9 00 00 00 00 
2762   1FBD 00 00 00 00 
2762   1FC1 00 00 00 00 
2762   1FC5 00 00 00 00 
2762   1FC9 00 00 00 00 
2762   1FCD 00 00 00 00 
2762   1FD1 00 00 00 00 
2762   1FD5 00 00 00 00 
2762   1FD9 00 00 00 00 
2762   1FDD 00 00 00 00 
2762   1FE1 00 00 00 00 
2762   1FE5 00 00 00 00 
2762   1FE9 00 00 00 00 
2762   1FED 00 00 00 00 
2762   1FF1 00 00 00 00 
2762   1FF5 00 00 00 00 
2762   1FF9 00 00 00 00 
2762   1FFD 00 00 00 00 
2762   2001 00 00 00 00 
2762   2005 00 00 00 00 
2762   2009 00 00 00 00 
2762   200D 00 00 00 00 
2762   2011 00 00 00 00 
2762   2015 00 00 00 00 
2762   2019 00 00 00 00 
2762   201D 00 00 00 00 
2762   2021 00 00 00 00 
2762   2025 00 00 00 00 
2762   2029 00 00 00 00 
2762   202D 00 00 00 00 
2762   2031 00 00 00 00 
2762   2035 00 00 00 00 
2762   2039 00 00 00 00 
2762   203D 00 00 00 00 
2762   2041 00 00 00 00 
2762   2045 00 00 00 00 
2762   2049 00 00 00 00 
2762   204D 00 00 00 00 
2762   2051 00 00 00 00 
2762   2055 00 00 00 00 
2762   2059 00 00 00 00 
2762   205D 00 00 00 00 
2762   2061 00 00 00 00 
2762   2065 00 00 00 00 
2762   2069 00 00 00 00 
2762   206D 00 00 00 00 
2762   2071 00 00 00 00 
2762   2075 00 00 00 00 
2762   2079 00 00 00 00 
2762   207D 00 00 00 00 
2762   2081 00 00 00 00 
2762   2085 00 00 00 00 
2762   2089 00 00 00 00 
2762   208D 00 00 00 00 
2762   2091 00 00 00 00 
2762   2095 00 00 00 00 
2762   2099 00 00 00 00 
2762   209D 00 00 00 00 
2762   20A1 00 00 00 00 
2762   20A5 00 00 00 00 
2762   20A9 00 00 00 00 
2762   20AD 00 00 00 00 
2762   20B1 00 00 00 00 
2762   20B5 00 00 00 00 
2762   20B9 00 00 00 00 
2762   20BD 00 00 00 00 
2762   20C1 00 00 00 00 
2762   20C5 00 00 00 00 
2762   20C9 00 00 00 00 
2762   20CD 00 00 00 00 
2762   20D1 00 00 00 00 
2762   20D5 00 00 00 00 
2762   20D9 00 00 00 00 
2762   20DD 00 00 00 00 
2762   20E1 00 00 00 00 
2762   20E5 00 00 00 00 
2762   20E9 00 00 00 00 
2762   20ED 00 00 00 00 
2762   20F1 00 00 00 00 
2762   20F5 00 00 00 00 
2762   20F9 00 00 00 00 
2762   20FD 00 00 00 00 
2762   2101 00 00 00 00 
2762   2105 00 00 00 00 
2762   2109 00 00 00 00 
2762   210D 00 00 00 00 
2762   2111 00 00 00 00 
2762   2115 00 00 00 00 
2762   2119 00 00 00 00 
2763   211D FF FF FF FF fifo:               .fill FIFO_SIZE
2763   2121 FF FF FF FF 
2763   2125 FF FF FF FF 
2763   2129 FF FF FF FF 
2763   212D FF FF FF FF 
2763   2131 FF FF FF FF 
2763   2135 FF FF FF FF 
2763   2139 FF FF FF FF 
2763   213D FF FF FF FF 
2763   2141 FF FF FF FF 
2763   2145 FF FF FF FF 
2763   2149 FF FF FF FF 
2763   214D FF FF FF FF 
2763   2151 FF FF FF FF 
2763   2155 FF FF FF FF 
2763   2159 FF FF FF FF 
2763   215D FF FF FF FF 
2763   2161 FF FF FF FF 
2763   2165 FF FF FF FF 
2763   2169 FF FF FF FF 
2763   216D FF FF FF FF 
2763   2171 FF FF FF FF 
2763   2175 FF FF FF FF 
2763   2179 FF FF FF FF 
2763   217D FF FF FF FF 
2763   2181 FF FF FF FF 
2763   2185 FF FF FF FF 
2763   2189 FF FF FF FF 
2763   218D FF FF FF FF 
2763   2191 FF FF FF FF 
2763   2195 FF FF FF FF 
2763   2199 FF FF FF FF 
2763   219D FF FF FF FF 
2763   21A1 FF FF FF FF 
2763   21A5 FF FF FF FF 
2763   21A9 FF FF FF FF 
2763   21AD FF FF FF FF 
2763   21B1 FF FF FF FF 
2763   21B5 FF FF FF FF 
2763   21B9 FF FF FF FF 
2763   21BD FF FF FF FF 
2763   21C1 FF FF FF FF 
2763   21C5 FF FF FF FF 
2763   21C9 FF FF FF FF 
2763   21CD FF FF FF FF 
2763   21D1 FF FF FF FF 
2763   21D5 FF FF FF FF 
2763   21D9 FF FF FF FF 
2763   21DD FF FF FF FF 
2763   21E1 FF FF FF FF 
2763   21E5 FF FF FF FF 
2763   21E9 FF FF FF FF 
2763   21ED FF FF FF FF 
2763   21F1 FF FF FF FF 
2763   21F5 FF FF FF FF 
2763   21F9 FF FF FF FF 
2763   21FD FF FF FF FF 
2763   2201 FF FF FF FF 
2763   2205 FF FF FF FF 
2763   2209 FF FF FF FF 
2763   220D FF FF FF FF 
2763   2211 FF FF FF FF 
2763   2215 FF FF FF FF 
2763   2219 FF FF FF FF 
2763   221D FF FF FF FF 
2763   2221 FF FF FF FF 
2763   2225 FF FF FF FF 
2763   2229 FF FF FF FF 
2763   222D FF FF FF FF 
2763   2231 FF FF FF FF 
2763   2235 FF FF FF FF 
2763   2239 FF FF FF FF 
2763   223D FF FF FF FF 
2763   2241 FF FF FF FF 
2763   2245 FF FF FF FF 
2763   2249 FF FF FF FF 
2763   224D FF FF FF FF 
2763   2251 FF FF FF FF 
2763   2255 FF FF FF FF 
2763   2259 FF FF FF FF 
2763   225D FF FF FF FF 
2763   2261 FF FF FF FF 
2763   2265 FF FF FF FF 
2763   2269 FF FF FF FF 
2763   226D FF FF FF FF 
2763   2271 FF FF FF FF 
2763   2275 FF FF FF FF 
2763   2279 FF FF FF FF 
2763   227D FF FF FF FF 
2763   2281 FF FF FF FF 
2763   2285 FF FF FF FF 
2763   2289 FF FF FF FF 
2763   228D FF FF FF FF 
2763   2291 FF FF FF FF 
2763   2295 FF FF FF FF 
2763   2299 FF FF FF FF 
2763   229D FF FF FF FF 
2763   22A1 FF FF FF FF 
2763   22A5 FF FF FF FF 
2763   22A9 FF FF FF FF 
2763   22AD FF FF FF FF 
2763   22B1 FF FF FF FF 
2763   22B5 FF FF FF FF 
2763   22B9 FF FF FF FF 
2763   22BD FF FF FF FF 
2763   22C1 FF FF FF FF 
2763   22C5 FF FF FF FF 
2763   22C9 FF FF FF FF 
2763   22CD FF FF FF FF 
2763   22D1 FF FF FF FF 
2763   22D5 FF FF FF FF 
2763   22D9 FF FF FF FF 
2763   22DD FF FF FF FF 
2763   22E1 FF FF FF FF 
2763   22E5 FF FF FF FF 
2763   22E9 FF FF FF FF 
2763   22ED FF FF FF FF 
2763   22F1 FF FF FF FF 
2763   22F5 FF FF FF FF 
2763   22F9 FF FF FF FF 
2763   22FD FF FF FF FF 
2763   2301 FF FF FF FF 
2763   2305 FF FF FF FF 
2763   2309 FF FF FF FF 
2763   230D FF FF FF FF 
2763   2311 FF FF FF FF 
2763   2315 FF FF FF FF 
2763   2319 FF FF FF FF 
2763   231D FF FF FF FF 
2763   2321 FF FF FF FF 
2763   2325 FF FF FF FF 
2763   2329 FF FF FF FF 
2763   232D FF FF FF FF 
2763   2331 FF FF FF FF 
2763   2335 FF FF FF FF 
2763   2339 FF FF FF FF 
2763   233D FF FF FF FF 
2763   2341 FF FF FF FF 
2763   2345 FF FF FF FF 
2763   2349 FF FF FF FF 
2763   234D FF FF FF FF 
2763   2351 FF FF FF FF 
2763   2355 FF FF FF FF 
2763   2359 FF FF FF FF 
2763   235D FF FF FF FF 
2763   2361 FF FF FF FF 
2763   2365 FF FF FF FF 
2763   2369 FF FF FF FF 
2763   236D FF FF FF FF 
2763   2371 FF FF FF FF 
2763   2375 FF FF FF FF 
2763   2379 FF FF FF FF 
2763   237D FF FF FF FF 
2763   2381 FF FF FF FF 
2763   2385 FF FF FF FF 
2763   2389 FF FF FF FF 
2763   238D FF FF FF FF 
2763   2391 FF FF FF FF 
2763   2395 FF FF FF FF 
2763   2399 FF FF FF FF 
2763   239D FF FF FF FF 
2763   23A1 FF FF FF FF 
2763   23A5 FF FF FF FF 
2763   23A9 FF FF FF FF 
2763   23AD FF FF FF FF 
2763   23B1 FF FF FF FF 
2763   23B5 FF FF FF FF 
2763   23B9 FF FF FF FF 
2763   23BD FF FF FF FF 
2763   23C1 FF FF FF FF 
2763   23C5 FF FF FF FF 
2763   23C9 FF FF FF FF 
2763   23CD FF FF FF FF 
2763   23D1 FF FF FF FF 
2763   23D5 FF FF FF FF 
2763   23D9 FF FF FF FF 
2763   23DD FF FF FF FF 
2763   23E1 FF FF FF FF 
2763   23E5 FF FF FF FF 
2763   23E9 FF FF FF FF 
2763   23ED FF FF FF FF 
2763   23F1 FF FF FF FF 
2763   23F5 FF FF FF FF 
2763   23F9 FF FF FF FF 
2763   23FD FF FF FF FF 
2763   2401 FF FF FF FF 
2763   2405 FF FF FF FF 
2763   2409 FF FF FF FF 
2763   240D FF FF FF FF 
2763   2411 FF FF FF FF 
2763   2415 FF FF FF FF 
2763   2419 FF FF FF FF 
2763   241D FF FF FF FF 
2763   2421 FF FF FF FF 
2763   2425 FF FF FF FF 
2763   2429 FF FF FF FF 
2763   242D FF FF FF FF 
2763   2431 FF FF FF FF 
2763   2435 FF FF FF FF 
2763   2439 FF FF FF FF 
2763   243D FF FF FF FF 
2763   2441 FF FF FF FF 
2763   2445 FF FF FF FF 
2763   2449 FF FF FF FF 
2763   244D FF FF FF FF 
2763   2451 FF FF FF FF 
2763   2455 FF FF FF FF 
2763   2459 FF FF FF FF 
2763   245D FF FF FF FF 
2763   2461 FF FF FF FF 
2763   2465 FF FF FF FF 
2763   2469 FF FF FF FF 
2763   246D FF FF FF FF 
2763   2471 FF FF FF FF 
2763   2475 FF FF FF FF 
2763   2479 FF FF FF FF 
2763   247D FF FF FF FF 
2763   2481 FF FF FF FF 
2763   2485 FF FF FF FF 
2763   2489 FF FF FF FF 
2763   248D FF FF FF FF 
2763   2491 FF FF FF FF 
2763   2495 FF FF FF FF 
2763   2499 FF FF FF FF 
2763   249D FF FF FF FF 
2763   24A1 FF FF FF FF 
2763   24A5 FF FF FF FF 
2763   24A9 FF FF FF FF 
2763   24AD FF FF FF FF 
2763   24B1 FF FF FF FF 
2763   24B5 FF FF FF FF 
2763   24B9 FF FF FF FF 
2763   24BD FF FF FF FF 
2763   24C1 FF FF FF FF 
2763   24C5 FF FF FF FF 
2763   24C9 FF FF FF FF 
2763   24CD FF FF FF FF 
2763   24D1 FF FF FF FF 
2763   24D5 FF FF FF FF 
2763   24D9 FF FF FF FF 
2763   24DD FF FF FF FF 
2763   24E1 FF FF FF FF 
2763   24E5 FF FF FF FF 
2763   24E9 FF FF FF FF 
2763   24ED FF FF FF FF 
2763   24F1 FF FF FF FF 
2763   24F5 FF FF FF FF 
2763   24F9 FF FF FF FF 
2763   24FD FF FF FF FF 
2763   2501 FF FF FF FF 
2763   2505 FF FF FF FF 
2763   2509 FF FF FF FF 
2763   250D FF FF FF FF 
2763   2511 FF FF FF FF 
2763   2515 FF FF FF FF 
2763   2519 FF FF FF FF 
2764   251D             
2765   251D FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2765   2521 FF FF FF FF 
2765   2525 FF FF FF FF 
2765   2529 FF FF FF FF 
2765   252D FF FF FF FF 
2765   2531 FF FF FF FF 
2765   2535 FF FF FF FF 
2765   2539 FF FF FF FF 
2765   253D FF FF FF FF 
2765   2541 FF FF FF FF 
2765   2545 FF FF FF FF 
2765   2549 FF FF FF FF 
2765   254D FF FF FF FF 
2765   2551 FF FF FF FF 
2765   2555 FF FF FF FF 
2765   2559 FF FF FF FF 
2765   255D FF FF FF FF 
2765   2561 FF FF FF FF 
2765   2565 FF FF FF FF 
2765   2569 FF FF FF FF 
2765   256D FF FF FF FF 
2765   2571 FF FF FF FF 
2765   2575 FF FF FF FF 
2765   2579 FF FF FF FF 
2765   257D FF FF FF FF 
2765   2581 FF FF FF FF 
2765   2585 FF FF FF FF 
2765   2589 FF FF FF FF 
2765   258D FF FF FF FF 
2765   2591 FF FF FF FF 
2765   2595 FF FF FF FF 
2765   2599 FF FF FF FF 
2765   259D FF FF FF FF 
2765   25A1 FF FF FF FF 
2765   25A5 FF FF FF FF 
2765   25A9 FF FF FF FF 
2765   25AD FF FF FF FF 
2765   25B1 FF FF FF FF 
2765   25B5 FF FF FF FF 
2765   25B9 FF FF FF FF 
2765   25BD FF FF FF FF 
2765   25C1 FF FF FF FF 
2765   25C5 FF FF FF FF 
2765   25C9 FF FF FF FF 
2765   25CD FF FF FF FF 
2765   25D1 FF FF FF FF 
2765   25D5 FF FF FF FF 
2765   25D9 FF FF FF FF 
2765   25DD FF FF FF FF 
2765   25E1 FF FF FF FF 
2765   25E5 FF FF FF FF 
2765   25E9 FF FF FF FF 
2765   25ED FF FF FF FF 
2765   25F1 FF FF FF FF 
2765   25F5 FF FF FF FF 
2765   25F9 FF FF FF FF 
2765   25FD FF FF FF FF 
2765   2601 FF FF FF FF 
2765   2605 FF FF FF FF 
2765   2609 FF FF FF FF 
2765   260D FF FF FF FF 
2765   2611 FF FF FF FF 
2765   2615 FF FF FF FF 
2765   2619 FF FF FF FF 
2765   261D FF FF FF FF 
2765   2621 FF FF FF FF 
2765   2625 FF FF FF FF 
2765   2629 FF FF FF FF 
2765   262D FF FF FF FF 
2765   2631 FF FF FF FF 
2765   2635 FF FF FF FF 
2765   2639 FF FF FF FF 
2765   263D FF FF FF FF 
2765   2641 FF FF FF FF 
2765   2645 FF FF FF FF 
2765   2649 FF FF FF FF 
2765   264D FF FF FF FF 
2765   2651 FF FF FF FF 
2765   2655 FF FF FF FF 
2765   2659 FF FF FF FF 
2765   265D FF FF FF FF 
2765   2661 FF FF FF FF 
2765   2665 FF FF FF FF 
2765   2669 FF FF FF FF 
2765   266D FF FF FF FF 
2765   2671 FF FF FF FF 
2765   2675 FF FF FF FF 
2765   2679 FF FF FF FF 
2765   267D FF FF FF FF 
2765   2681 FF FF FF FF 
2765   2685 FF FF FF FF 
2765   2689 FF FF FF FF 
2765   268D FF FF FF FF 
2765   2691 FF FF FF FF 
2765   2695 FF FF FF FF 
2765   2699 FF FF FF FF 
2765   269D FF FF FF FF 
2765   26A1 FF FF FF FF 
2765   26A5 FF FF FF FF 
2765   26A9 FF FF FF FF 
2765   26AD FF FF FF FF 
2765   26B1 FF FF FF FF 
2765   26B5 FF FF FF FF 
2765   26B9 FF FF FF FF 
2765   26BD FF FF FF FF 
2765   26C1 FF FF FF FF 
2765   26C5 FF FF FF FF 
2765   26C9 FF FF FF FF 
2765   26CD FF FF FF FF 
2765   26D1 FF FF FF FF 
2765   26D5 FF FF FF FF 
2765   26D9 FF FF FF FF 
2765   26DD FF FF FF FF 
2765   26E1 FF FF FF FF 
2765   26E5 FF FF FF FF 
2765   26E9 FF FF FF FF 
2765   26ED FF FF FF FF 
2765   26F1 FF FF FF FF 
2765   26F5 FF FF FF FF 
2765   26F9 FF FF FF FF 
2765   26FD FF FF FF FF 
2765   2701 FF FF FF FF 
2765   2705 FF FF FF FF 
2765   2709 FF FF FF FF 
2765   270D FF FF FF FF 
2765   2711 FF FF FF FF 
2765   2715 FF FF FF FF 
2765   2719 FF FF FF FF 
2766   271D 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2767   271E             
2768   271E             
2769   271E             .end
tasm: Number of errors = 0
