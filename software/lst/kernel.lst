0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 3D 00       .dw int_1
0136   0004 3E 00       .dw int_2
0137   0006 3F 00       .dw int_3
0138   0008 40 00       .dw int_4
0139   000A 41 00       .dw int_5
0140   000C 42 00       .dw int_6
0141   000E 43 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 B1 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 66 03       .dw trap_privilege
0153   0014 83 04       .dw trap_div_zero
0154   0016 90 04       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 72 03       .dw syscall_break
0165   0022 91 04       .dw syscall_rtc
0166   0024 B4 05       .dw syscall_ide
0167   0026 74 06       .dw syscall_io
0168   0028 31 07       .dw syscall_file_system
0169   002A FE 0F       .dw syscall_create_proc
0170   002C 2B 03       .dw syscall_list_procs
0171   002E C3 04       .dw syscall_datetime
0172   0030 E7 02       .dw syscall_reboot
0173   0032 C8 0F       .dw syscall_pause_proc
0174   0034 F3 02       .dw syscall_resume_proc
0175   0036 85 0F       .dw syscall_terminate_proc
0176   0038 B3 02       .dw syscall_system
0177   003A 94 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; aliases for individual 'al' options for FDC system calls
0198   003C             fdc_al_restore      .equ 0
0199   003C             fdc_al_step         .equ 1
0200   003C             fdc_al_step_in      .equ 2
0201   003C             fdc_al_step_out     .equ 3
0202   003C             fdc_al_seek         .equ 4
0203   003C             fdc_al_format_128   .equ 5
0204   003C             fdc_al_format_512   .equ 6
0205   003C             fdc_al_read_addr    .equ 7
0206   003C             fdc_al_read_track   .equ 8
0207   003C             fdc_al_read_sect    .equ 9
0208   003C             fdc_al_write_sect   .equ 10
0209   003C             fdc_al_force_int    .equ 11
0210   003C             fdc_al_status0      .equ 12
0211   003C             fdc_al_status1      .equ 13
0212   003C             
0213   003C             ; ------------------------------------------------------------------------------------------------------------------;
0214   003C             ; alias exports
0215   003C             ; ------------------------------------------------------------------------------------------------------------------;
0216   003C             .export text_org
0217   003C             .export sys_break
0218   003C             .export sys_rtc
0219   003C             .export sys_ide
0220   003C             .export sys_io
0221   003C             .export sys_filesystem
0222   003C             .export sys_create_proc
0223   003C             .export sys_list_proc
0224   003C             .export sys_datetime
0225   003C             .export sys_reboot
0226   003C             .export sys_pause_proc
0227   003C             .export sys_resume_proc
0228   003C             .export sys_terminate_proc
0229   003C             .export sys_system
0230   003C             .export sys_fdc
0231   003C             
0232   003C             .export _fdc_config        
0233   003C             .export _fdc_status_0      
0234   003C             .export _fdc_stat_cmd     
0235   003C             
0236   003C             ; exports of aliases for individual 'al' options for FDC system calls
0237   003C             .export fdc_al_restore
0238   003C             .export fdc_al_step
0239   003C             .export fdc_al_step_in
0240   003C             .export fdc_al_step_out
0241   003C             .export fdc_al_seek
0242   003C             .export fdc_al_format_128
0243   003C             .export fdc_al_format_512
0244   003C             .export fdc_al_read_addr
0245   003C             .export fdc_al_read_track
0246   003C             .export fdc_al_read_sect
0247   003C             .export fdc_al_write_sect
0248   003C             .export fdc_al_force_int
0249   003C             .export fdc_al_status0
0250   003C             .export fdc_al_status1
0251   003C             
0252   003C             ; ------------------------------------------------------------------------------------------------------------------;
0253   003C             ; irqs' code block
0254   003C             ; ------------------------------------------------------------------------------------------------------------------;
0255   003C             ; 5.25" floppy drive controller irq
0256   003C             int_0_fdc:
0257   003C 06            sysret
0258   003D             int_1:
0259   003D 06            sysret
0260   003E             int_2:
0261   003E 06            sysret
0262   003F             int_3:
0263   003F 06            sysret
0264   0040             int_4:
0265   0040 06            sysret
0266   0041             int_5:
0267   0041 06            sysret
0268   0042             
0269   0042             ; timer irq
0270   0042             int_6:  
0271   0042 06            sysret
0272   0043             
0273   0043             ; ------------------------------------------------------------------------------------------------------------------;
0274   0043             ; uart0 interrupt
0275   0043             ; ------------------------------------------------------------------------------------------------------------------;
0276   0043             int_7_uart0:
0277   0043 D7            push a
0278   0044 DA            push d
0279   0045 E1            pushf
0280   0046 14 43 18      mov a, [fifo_in]
0281   0049 3C            mov d, a
0282   004A 1D 80 FF      mov al, [_uart0_data]       ; get character
0283   004D B9 03         cmp al, $03                 ; ctrl-c
0284   004F C6 6C 00      je ctrlc
0285   0052 B9 1A         cmp al, $1a                 ; ctrl-z
0286   0054 C6 72 00      je ctrlz
0287   0057 3E            mov [d], al                 ; add to fifo
0288   0058 14 43 18      mov a, [fifo_in]
0289   005B 77            inc a
0290   005C AF A4 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0291   005F C7 65 00      jne int_7_continue
0292   0062 10 A4 1F      mov a, fifo  
0293   0065             int_7_continue:  
0294   0065 42 43 18      mov [fifo_in], a            ; update fifo pointer
0295   0068 EE            popf
0296   0069 E7            pop d
0297   006A E4            pop a  
0298   006B 06            sysret
0299   006C             ctrlc:
0300   006C 51 05 00      add sp, 5
0301   006F 0A 85 0F      jmp syscall_terminate_proc
0302   0072             ctrlz:
0303   0072 EE            popf
0304   0073 E7            pop d
0305   0074 E4            pop a
0306   0075 0A C8 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0307   0078             
0308   0078             ; ------------------------------------------------------------------------------------------------------------------;
0309   0078             ; floppy drive syscalls
0310   0078             ; ------------------------------------------------------------------------------------------------------------------;
0311   0078             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0312   0078             ; fdc_40_ff:
0313   0078             ;   .fill 40,  $ff    ; or 00                                                                                
0314   0078             ; fdc_128_format_inner:
0315   0078             ;   .fill 6,   $00    ;                                                                            <--|        
0316   0078             ;   .fill 1,   $fe    ; id address mark                                                               |        
0317   0078             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0318   0078             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0319   0078             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0320   0078             ;   .fill 1,   $00    ; sector length                                                                 |                        
0321   0078             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0322   0078             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0323   0078             ;   .fill 6,   $00    ;                                                                               |                        
0324   0078             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0325   0078             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0326   0078             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0327   0078             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0328   0078             ; fdc_128_format_end:
0329   0078             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0330   0078             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331   0078             fdc_jmptbl:
0332   0078 A0 00         .dw syscall_fdc_restore
0333   007A AC 00         .dw syscall_fdc_step
0334   007C B4 00         .dw syscall_fdc_step_in
0335   007E BC 00         .dw syscall_fdc_step_out
0336   0080 C4 00         .dw syscall_fdc_seek
0337   0082 D2 00         .dw syscall_fdc_format_128
0338   0084 FC 00         .dw syscall_fdc_format_512
0339   0086 D0 00         .dw syscall_fdc_read_addr
0340   0088 26 01         .dw syscall_fdc_read_track
0341   008A 55 01         .dw syscall_fdc_read_sect
0342   008C 8D 01         .dw syscall_fdc_write_sect
0343   008E D1 00         .dw syscall_fdc_force_int
0344   0090 98 00         .dw syscall_fdc_status0
0345   0092 9C 00         .dw syscall_fdc_status1
0346   0094             syscall_fdc:
0347   0094 FD 0A 78 00   jmp [fdc_jmptbl + al]
0348   0098             
0349   0098             syscall_fdc_status0:
0350   0098 1D C1 FF      mov al, [_fdc_status_0]
0351   009B 06            sysret
0352   009C             
0353   009C             syscall_fdc_status1:
0354   009C 1D C8 FF      mov al, [_fdc_stat_cmd]
0355   009F 06            sysret
0356   00A0             
0357   00A0             syscall_fdc_restore:
0358   00A0 07 BF 01      call fdc_wait_not_busy
0359   00A3 F2 C8 FF 0A   mov byte [_fdc_stat_cmd], %00001010
0360   00A7 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0361   00AB 06            sysret
0362   00AC             
0363   00AC             syscall_fdc_step:
0364   00AC 07 BF 01      call fdc_wait_not_busy
0365   00AF F2 C8 FF 38   mov byte [_fdc_stat_cmd], %00111000
0366   00B3 06            sysret
0367   00B4             
0368   00B4             syscall_fdc_step_in:
0369   00B4 07 BF 01      call fdc_wait_not_busy
0370   00B7 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0371   00BB 06            sysret
0372   00BC             
0373   00BC             syscall_fdc_step_out:
0374   00BC 07 BF 01      call fdc_wait_not_busy
0375   00BF F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0376   00C3 06            sysret
0377   00C4             
0378   00C4             ; bl: desired track
0379   00C4             syscall_fdc_seek:
0380   00C4 07 BF 01      call fdc_wait_not_busy
0381   00C7 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to bl
0382   00CB F2 C8 FF 18   mov byte [_fdc_stat_cmd], %00011000 ; seek command
0383   00CF 06            sysret
0384   00D0             
0385   00D0             syscall_fdc_read_addr:
0386   00D0 06            sysret
0387   00D1             
0388   00D1             syscall_fdc_force_int:
0389   00D1 06            sysret
0390   00D2             
0391   00D2             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0392   00D2             ; in the ram formatting block because they are all set as 00 right now
0393   00D2             ; bl: track number
0394   00D2             syscall_fdc_format_128:
0395   00D2 07 CA 01      call fdc_format_mem_128
0396   00D5 07 BF 01      call fdc_wait_not_busy
0397   00D8 FD 3D C9 FF   mov [_fdc_track], bl
0398   00DC FD 4D A4 25   mov si, transient_area
0399   00E0 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0400   00E4 07 A2 02      call fdc_wait_64us
0401   00E7             fdc_format_drq_128:
0402   00E7 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0403   00EA 93 01         test al, $01                ; 4
0404   00EC C6 FB 00      jz fdc_format_end_128           ; 8
0405   00EF 93 02         test al, $02                ; 4
0406   00F1 C6 E7 00      jz fdc_format_drq_128           ; 8
0407   00F4 F6            lodsb                       ; 7
0408   00F5 3D CB FF      mov [_fdc_data], al         ; 10   
0409   00F8 0A E7 00      jmp fdc_format_drq_128
0410   00FB             fdc_format_end_128:
0411   00FB 06            sysret
0412   00FC             
0413   00FC             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0414   00FC             ; in the ram formatting block because they are all set as 00 right now
0415   00FC             ; bl: track number
0416   00FC             syscall_fdc_format_512:
0417   00FC 07 36 02      call fdc_format_mem_512
0418   00FF 07 BF 01      call fdc_wait_not_busy
0419   0102 FD 3D C9 FF   mov [_fdc_track], bl
0420   0106 FD 4D A4 25   mov si, transient_area
0421   010A F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0422   010E 07 A2 02      call fdc_wait_64us
0423   0111             fdc_format_drq_512:
0424   0111 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0425   0114 93 01         test al, $01                ; 4
0426   0116 C6 25 01      jz fdc_format_end_512           ; 8
0427   0119 93 02         test al, $02                ; 4
0428   011B C6 11 01      jz fdc_format_drq_512           ; 8
0429   011E F6            lodsb                       ; 7
0430   011F 3D CB FF      mov [_fdc_data], al         ; 10   
0431   0122 0A 11 01      jmp fdc_format_drq_512
0432   0125             fdc_format_end_512:
0433   0125 06            sysret
0434   0126             
0435   0126             ; di : destination in user space
0436   0126             ; a  : returns number of read bytes
0437   0126             syscall_fdc_read_track:
0438   0126 07 BF 01      call fdc_wait_not_busy
0439   0129 E3            push di
0440   012A FD 4F A4 25   mov di, transient_area
0441   012E F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0442   0132 07 A2 02      call fdc_wait_64us
0443   0135             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0444   0135 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0445   0138 93 01         test al, $01                ; check busy bit
0446   013A C6 49 01      jz fdc_read_track_end
0447   013D 93 02         test al, $02                ; check drq bit
0448   013F C6 35 01      jz fdc_read_track_l0
0449   0142 1D CB FF      mov al, [_fdc_data]     ; 
0450   0145 F7            stosb
0451   0146 0A 35 01      jmp fdc_read_track_l0
0452   0149             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0453   0149             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0454   0149             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0455   0149             fdc_read_track_end:
0456   0149 50            mov a, di
0457   014A 5F A4 25      sub a, transient_area
0458   014D F0            pop di
0459   014E FD 4D A4 25   mov si, transient_area
0460   0152 39            mov c, a  ; copy track over to user space
0461   0153 03            store
0462   0154 06            sysret
0463   0155             
0464   0155             ; sector in bl
0465   0155             ; track in bh
0466   0155             ; di = user space destination
0467   0155             syscall_fdc_read_sect:
0468   0155 07 BF 01      call fdc_wait_not_busy
0469   0158 E3            push di
0470   0159 FD 3D CA FF   mov [_fdc_sector], bl
0471   015D 30            mov bl, bh
0472   015E FD 3D C9 FF   mov [_fdc_track], bl
0473   0162 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0474   0166 07 A2 02      call fdc_wait_64us
0475   0169 FD 4F A4 25   mov di, transient_area
0476   016D             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0477   016D 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0478   0170 93 01         test al, $01                ; check drq bit
0479   0172 C6 81 01      jz fdc_read_sect_end
0480   0175 93 02         test al, $02                ; check drq bit
0481   0177 C6 6D 01      jz fdc_read_sect_l0
0482   017A 1D CB FF      mov al, [_fdc_data]     ; 
0483   017D F7            stosb
0484   017E 0A 6D 01      jmp fdc_read_sect_l0
0485   0181             fdc_read_sect_end:
0486   0181 50            mov a, di
0487   0182 5F A4 25      sub a, transient_area
0488   0185 F0            pop di
0489   0186 FD 4D A4 25   mov si, transient_area
0490   018A 39            mov c, a  ; copy sector over to user space
0491   018B 03            store
0492   018C 06            sysret
0493   018D             
0494   018D             ; sector size in c
0495   018D             ; sector in bl
0496   018D             ; track in bh
0497   018D             ; data pointer in si
0498   018D             syscall_fdc_write_sect:
0499   018D 07 BF 01      call fdc_wait_not_busy
0500   0190 D9            push c
0501   0191 FD 3D CA FF   mov [_fdc_sector], bl
0502   0195 30            mov bl, bh
0503   0196 FD 3D C9 FF   mov [_fdc_track], bl
0504   019A FD 4F A4 25   mov di, transient_area    ; si = data source, di = destination 
0505   019E 04            load                    ; transfer data to kernel space!
0506   019F FD 4D A4 25   mov si, transient_area
0507   01A3 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0508   01A7 07 A2 02      call fdc_wait_64us
0509   01AA             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0510   01AA 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0511   01AD 93 01         test al, $01                    ; 4
0512   01AF C6 BE 01      jz fdc_write_sect_end           ; 8
0513   01B2 93 02         test al, $02                    ; 4
0514   01B4 C6 AA 01      jz fdc_write_sect_l0            ; 8
0515   01B7 F6            lodsb                           ; 7
0516   01B8 3D CB FF      mov [_fdc_data], al             ; 10   
0517   01BB 0A AA 01      jmp fdc_write_sect_l0
0518   01BE             fdc_write_sect_end:
0519   01BE 06            sysret
0520   01BF             
0521   01BF             fdc_wait_not_busy:
0522   01BF DB            push al
0523   01C0 1D C8 FF      mov al, [_fdc_stat_cmd]   
0524   01C3 93 01         test al, $01               
0525   01C5 C7 BF 01      jnz fdc_wait_not_busy          
0526   01C8 E8            pop al
0527   01C9 09            ret
0528   01CA             
0529   01CA             fdc_format_mem_128:
0530   01CA 3B 01 00      mov d, 1
0531   01CD FD 4F A4 25   mov di, transient_area
0532   01D1             ; 40 * FF
0533   01D1 38 28 00      mov c, 40
0534   01D4 19 FF         mov al, $ff
0535   01D6             fdc_l0: 
0536   01D6 F7            stosb
0537   01D7 7E            dec c
0538   01D8 C7 D6 01      jnz fdc_l0
0539   01DB             ; 6 * 00
0540   01DB             fdc_inner_loop:
0541   01DB 38 06 00      mov c, 6
0542   01DE 19 00         mov al, $00
0543   01E0             fdc_l1:
0544   01E0 F7            stosb
0545   01E1 7E            dec c
0546   01E2 C7 E0 01      jnz fdc_l1
0547   01E5             ; FE address mark
0548   01E5             fdc_l2:
0549   01E5 19 FE         mov al, $fe
0550   01E7 F7            stosb
0551   01E8             ; track number
0552   01E8             fdc_l3:
0553   01E8 19 00         mov al, $00
0554   01EA F7            stosb
0555   01EB             ; side number
0556   01EB             fdc_l4:
0557   01EB 19 00         mov al, $00
0558   01ED F7            stosb
0559   01EE             ; sector number
0560   01EE             fdc_l5:
0561   01EE 13            mov a, d
0562   01EF F7            stosb
0563   01F0             ; sector length 128 bytes
0564   01F0             fdc_l6:
0565   01F0 19 00         mov al, $00
0566   01F2 F7            stosb
0567   01F3             ; 2 crc's
0568   01F3             fdc_l7:
0569   01F3 19 F7         mov al, $f7
0570   01F5 F7            stosb
0571   01F6             ; 11 times $ff
0572   01F6 38 0B 00      mov c, 11
0573   01F9 19 FF         mov al, $ff
0574   01FB             fdc_l8:
0575   01FB F7            stosb
0576   01FC 7E            dec c
0577   01FD C7 FB 01      jnz fdc_l8
0578   0200             ; 6 times 00
0579   0200 38 06 00      mov c, 6
0580   0203 19 00         mov al, $00
0581   0205             fdc_l9:
0582   0205 F7            stosb
0583   0206 7E            dec c
0584   0207 C7 05 02      jnz fdc_l9
0585   020A             ; FB data address mark
0586   020A 19 FB         mov al, $fb
0587   020C             fdc_l10:
0588   020C F7            stosb
0589   020D             ; 128 bytes sector data
0590   020D 38 80 00      mov c, 128
0591   0210 19 E5         mov al, $E5
0592   0212             fdc_l11:
0593   0212 F7            stosb
0594   0213 7E            dec c
0595   0214 C7 12 02      jnz fdc_l11
0596   0217             ; 2 crc's
0597   0217             fdc_l12:
0598   0217 19 F7         mov al, $f7
0599   0219 F7            stosb
0600   021A             ; 10 * $FF
0601   021A 38 0A 00      mov c, 10
0602   021D 19 FF         mov al, $ff
0603   021F             fdc_l13:
0604   021F F7            stosb
0605   0220 7E            dec c
0606   0221 C7 1F 02      jnz fdc_l13
0607   0224             ; check whether we did this 16 times
0608   0224 79            inc d
0609   0225 C5 11 00      cmp d, 17
0610   0228 C7 DB 01      jne fdc_inner_loop
0611   022B             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0612   022B 38 F4 01      mov c, 500
0613   022E 19 FF         mov al, $ff
0614   0230             fdc_format_footer:
0615   0230             fdc_footer_drq_loop:
0616   0230 F7            stosb
0617   0231 7E            dec c
0618   0232 C7 30 02      jnz fdc_footer_drq_loop
0619   0235 09            ret
0620   0236             
0621   0236             fdc_format_mem_512:
0622   0236 3B 01 00      mov d, 1
0623   0239 FD 4F A4 25   mov di, transient_area
0624   023D             ; 40 * FF
0625   023D 38 28 00      mov c, 40
0626   0240 19 FF         mov al, $ff
0627   0242             fdc_512_l0: 
0628   0242 F7            stosb
0629   0243 7E            dec c
0630   0244 C7 42 02      jnz fdc_512_l0
0631   0247             ; 6 * 00
0632   0247             fdc_512_inner_loop:
0633   0247 38 06 00      mov c, 6
0634   024A 19 00         mov al, $00
0635   024C             fdc_512_l1:
0636   024C F7            stosb
0637   024D 7E            dec c
0638   024E C7 4C 02      jnz fdc_512_l1
0639   0251             ; FE address mark
0640   0251             fdc_512_l2:
0641   0251 19 FE         mov al, $fe
0642   0253 F7            stosb
0643   0254             ; track number
0644   0254             fdc_512_l3:
0645   0254 19 00         mov al, $00
0646   0256 F7            stosb
0647   0257             ; side number
0648   0257             fdc_512_l4:
0649   0257 19 00         mov al, $00
0650   0259 F7            stosb
0651   025A             ; sector number
0652   025A             fdc_512_l5:
0653   025A 13            mov a, d
0654   025B F7            stosb
0655   025C             ; sector length 512 bytes
0656   025C             fdc_512_l6:
0657   025C 19 02         mov al, $02
0658   025E F7            stosb
0659   025F             ; 2 crc's
0660   025F             fdc_512_l7:
0661   025F 19 F7         mov al, $f7
0662   0261 F7            stosb
0663   0262             ; 11 times $ff
0664   0262 38 0B 00      mov c, 11
0665   0265 19 FF         mov al, $ff
0666   0267             fdc_512_l8:
0667   0267 F7            stosb
0668   0268 7E            dec c
0669   0269 C7 67 02      jnz fdc_512_l8
0670   026C             ; 6 times 00
0671   026C 38 06 00      mov c, 6
0672   026F 19 00         mov al, $00
0673   0271             fdc_512_l9:
0674   0271 F7            stosb
0675   0272 7E            dec c
0676   0273 C7 71 02      jnz fdc_512_l9
0677   0276             ; FB data address mark
0678   0276 19 FB         mov al, $fb
0679   0278             fdc_512_l10:
0680   0278 F7            stosb
0681   0279             ; 128 bytes sector data
0682   0279 38 00 02      mov c, 512
0683   027C 19 E5         mov al, $E5
0684   027E             fdc_512_l11:
0685   027E F7            stosb
0686   027F 7E            dec c
0687   0280 C7 7E 02      jnz fdc_512_l11
0688   0283             ; 2 crc's
0689   0283             fdc_512_l12:
0690   0283 19 F7         mov al, $f7
0691   0285 F7            stosb
0692   0286             ; 10 * $FF
0693   0286 38 0A 00      mov c, 10
0694   0289 19 FF         mov al, $ff
0695   028B             fdc_512_l13:
0696   028B F7            stosb
0697   028C 7E            dec c
0698   028D C7 8B 02      jnz fdc_512_l13
0699   0290             ; check whether we did this 16 times
0700   0290 79            inc d
0701   0291 C5 06 00      cmp d, 6
0702   0294 C7 47 02      jne fdc_512_inner_loop
0703   0297             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0704   0297 38 F4 01      mov c, 500
0705   029A 19 FF         mov al, $ff
0706   029C             fdc_512_format_footer:
0707   029C             fdc_512_footer_drq_loop:
0708   029C F7            stosb
0709   029D 7E            dec c
0710   029E C7 9C 02      jnz fdc_512_footer_drq_loop
0711   02A1 09            ret
0712   02A2             
0713   02A2             ; fetch is 2 cycles long when 'display_reg_load' is false.
0714   02A2             ; 64us amounts to 160 cycles of the 2.5mhz clock
0715   02A2             ; call u16 is 14 cycles long
0716   02A2             ; 160 - 5 - 14 = 
0717   02A2             fdc_wait_64us:
0718   02A2 3A 0D         mov cl, 13                       ; 5 cycles
0719   02A4             fdc_wait_64_loop:
0720   02A4 81            dec cl                           ; 3 cycles
0721   02A5 C7 A4 02      jnz fdc_wait_64_loop             ; 8 cycles
0722   02A8 09            ret
0723   02A9             
0724   02A9             ; ------------------------------------------------------------------------------------------------------------------;
0725   02A9             ; system syscalls
0726   02A9             ; ------------------------------------------------------------------------------------------------------------------;
0727   02A9             system_jmptbl:
0728   02A9 DF 02         .dw system_uname
0729   02AB E6 02         .dw system_whoami
0730   02AD B9 02         .dw system_setparam
0731   02AF BC 02         .dw system_bootloader_install
0732   02B1 B7 02         .dw system_getparam
0733   02B3             syscall_system:
0734   02B3 FD 0A A9 02   jmp [system_jmptbl + al]
0735   02B7             
0736   02B7             ; param register address in register d
0737   02B7             ; param value in register bl
0738   02B7             system_getparam:
0739   02B7 32            mov bl, [d]
0740   02B8 06            sysret
0741   02B9             
0742   02B9             ; param register address in register d
0743   02B9             ; param value in register bl
0744   02B9             system_setparam:
0745   02B9 FD 3E         mov [d], bl
0746   02BB 06            sysret
0747   02BC             
0748   02BC             ; kernel LBA address in 'b'
0749   02BC             system_bootloader_install:
0750   02BC D8            push b
0751   02BD 26 00 00      mov b, 0
0752   02C0 38 00 00      mov c, 0
0753   02C3 22 01         mov ah, $01                 ; 1 sector
0754   02C5 3B A4 25      mov d, transient_area
0755   02C8 07 E3 05      call ide_read_sect          ; read sector
0756   02CB E5            pop b
0757   02CC FD 44 FE 01   mov [d + 510], b            ; update LBA address
0758   02D0 26 00 00      mov b, 0
0759   02D3 38 00 00      mov c, 0
0760   02D6 22 01         mov ah, $01                 ; 1 sector
0761   02D8 3B A4 25      mov d, transient_area
0762   02DB 07 09 06      call ide_write_sect         ; write sector
0763   02DE 06            sysret
0764   02DF             
0765   02DF             system_uname:
0766   02DF 3B 54 18      mov d, s_uname
0767   02E2 07 0D 13      call _puts
0768   02E5 06            sysret
0769   02E6             
0770   02E6             system_whoami:
0771   02E6 06            sysret
0772   02E7             
0773   02E7             ; reboot system
0774   02E7             syscall_reboot:
0775   02E7 FD D7 FF FF   push word $ffff 
0776   02EB FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0777   02EE FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0778   02F2 06            sysret
0779   02F3             
0780   02F3             ;------------------------------------------------------------------------------------------------------;;
0781   02F3             ; switch to another process
0782   02F3             ; inputs:
0783   02F3             ; al = new process number
0784   02F3             ;------------------------------------------------------------------------------------------------------;;
0785   02F3             syscall_resume_proc:
0786   02F3 FD 78         mov g, a                            ; save the process number
0787   02F5 4B            pusha                               ; save all registers into kernel stack
0788   02F6 22 00         mov ah, 0
0789   02F8 1D 3E 18      mov al, [active_proc_index]
0790   02FB FD 99         shl a              ; x2
0791   02FD B7 7B 10      mov a, [proc_table_convert + a]     ; get process state start index
0792   0300 4F            mov di, a
0793   0301 48            mov a, sp
0794   0302 77            inc a
0795   0303 4D            mov si, a
0796   0304 38 14 00      mov c, 20
0797   0307 FD F5         rep movsb                           ; save process state!
0798   0309             ; restore kernel stack position to point before interrupt arrived
0799   0309 51 14 00      add sp, 20
0800   030C             ; now load the new process number!
0801   030C FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0802   030E 3D 3E 18      mov [active_proc_index], al         ; set new active proc
0803   0311             ; calculate lut entry for next process
0804   0311 22 00         mov ah, 0
0805   0313 FD 99         shl a                               ; x2
0806   0315 B7 7B 10      mov a, [proc_table_convert + a]     ; get process state start index  
0807   0318 4D            mov si, a                           ; source is proc state block
0808   0319 48            mov a, sp
0809   031A 5F 13 00      sub a, 19
0810   031D 4F            mov di, a                           ; destination is kernel stack
0811   031E             ; restore sp
0812   031E 7D            dec a
0813   031F 47            mov sp, a
0814   0320 38 14 00      mov c, 20
0815   0323 FD F5         rep movsb
0816   0325             ; set vm process
0817   0325 1D 3E 18      mov al, [active_proc_index]
0818   0328 01            setptb
0819   0329 4C            popa
0820   032A 06            sysret
0821   032B             
0822   032B             ;------------------------------------------------------------------------------------------------------;;
0823   032B             ; list processes
0824   032B             ;------------------------------------------------------------------------------------------------------;;
0825   032B             syscall_list_procs:
0826   032B 3B 75 18      mov d, s_ps_header
0827   032E 07 0D 13      call _puts
0828   0331 3B 15 1B      mov d, proc_availab_table + 1
0829   0334 38 01 00      mov c, 1
0830   0337             list_procs_l0:  
0831   0337 BD 01         cmp byte[d], 1
0832   0339 C7 5D 03      jne list_procs_next
0833   033C 2D            mov b, d
0834   033D 61 14 1B      sub b, proc_availab_table
0835   0340 FD 9F 05      shl b, 5
0836   0343 DA            push d
0837   0344 D8            push b
0838   0345 28            mov b, c
0839   0346 07 AD 13      call print_u8x
0840   0349 22 20         mov ah, ' '
0841   034B 07 E1 11      call _putchar
0842   034E 07 E1 11      call _putchar
0843   0351 E5            pop b
0844   0352 74            mov d, b
0845   0353 58 24 1B      add d, proc_names
0846   0356 07 0D 13      call _puts
0847   0359 07 BA 12      call printnl
0848   035C E7            pop d
0849   035D             list_procs_next:
0850   035D 79            inc d
0851   035E 78            inc c
0852   035F C2 09 00      cmp c, 9
0853   0362 C7 37 03      jne list_procs_l0
0854   0365             list_procs_end:
0855   0365 06            sysret
0856   0366             
0857   0366             ; ------------------------------------------------------------------------------------------------------------------;
0858   0366             ; exceptions code block
0859   0366             ; ------------------------------------------------------------------------------------------------------------------;
0860   0366             ; privilege exception
0861   0366             ; ------------------------------------------------------------------------------------------------------------------;
0862   0366             trap_privilege:
0863   0366 0A E7 02      jmp syscall_reboot
0864   0369 DA            push d
0865   036A 3B C4 18      mov d, s_priviledge
0866   036D 07 0D 13      call _puts
0867   0370 E7            pop d
0868   0371 06            sysret
0869   0372             
0870   0372             ; ------------------------------------------------------------------------------------------------------------------;
0871   0372             ; breakpoint
0872   0372             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0873   0372             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0874   0372             ; ------------------------------------------------------------------------------------------------------------------;
0875   0372             syscall_break:
0876   0372 4B            pusha
0877   0373             syscall_break_prompt:
0878   0373 3B 2D 04      mov d, s_break1
0879   0376 07 0D 13      call _puts
0880   0379 07 BA 12      call printnl
0881   037C 07 0F 14      call scan_u16d
0882   037F AF 00 00      cmp a, 0
0883   0382 C6 8D 03      je syscall_break_regs
0884   0385 AF 01 00      cmp a, 1
0885   0388 C6 B0 03      je syscall_break_mem
0886   038B             syscall_break_end:  
0887   038B 4C            popa
0888   038C 06            sysret
0889   038D             syscall_break_regs:
0890   038D 48            mov a, sp
0891   038E 53 0E 00      add a, 14               ; back-track 7 registers
0892   0391 3C            mov d, a
0893   0392 3A 07         mov cl, 7
0894   0394             syscall_regs_l0:
0895   0394 2A            mov b, [d]
0896   0395 FD AB         swp b
0897   0397 07 69 13      call print_u16x         ; print register value
0898   039A 07 BA 12      call printnl
0899   039D 63 02 00      sub d, 2
0900   03A0 71 01         sub cl, 1
0901   03A2 C3 00         cmp cl, 0
0902   03A4 C7 94 03      jne syscall_regs_l0
0903   03A7 0A 73 03      jmp syscall_break_prompt
0904   03AA 07 BA 12      call printnl
0905   03AD 0A 73 03      jmp syscall_break_prompt
0906   03B0             syscall_break_mem:
0907   03B0 07 BA 12      call printnl
0908   03B3 07 8B 13      call scan_u16x
0909   03B6 4D            mov si, a               ; data source from user space
0910   03B7 FD 4F A4 23   mov di, scrap_sector    ; destination in kernel space
0911   03BB 38 00 02      mov c, 512
0912   03BE 04            load                    ; transfer data to kernel space!
0913   03BF 3B A4 23      mov d, scrap_sector     ; dump pointer in d
0914   03C2 38 00 00      mov c, 0
0915   03C5             dump_loop:
0916   03C5 84            mov al, cl
0917   03C6 87 0F         and al, $0f
0918   03C8 C6 16 04      jz print_base
0919   03CB             back:
0920   03CB 1E            mov al, [d]             ; read byte
0921   03CC 2F            mov bl, al
0922   03CD 07 AD 13      call print_u8x
0923   03D0 10 00 20      mov a, $2000
0924   03D3 05 03         syscall sys_io          ; space
0925   03D5 84            mov al, cl
0926   03D6 87 0F         and al, $0f
0927   03D8 B9 0F         cmp al, $0f
0928   03DA C6 EB 03      je print_ascii
0929   03DD             back1:
0930   03DD 79            inc d
0931   03DE 78            inc c
0932   03DF C2 00 02      cmp c, 512
0933   03E2 C7 C5 03      jne dump_loop
0934   03E5 07 BA 12      call printnl
0935   03E8 0A 73 03      jmp syscall_break_prompt  ; go to syscall_break return point
0936   03EB             print_ascii:
0937   03EB 10 00 20      mov a, $2000
0938   03EE 05 03         syscall sys_io
0939   03F0 63 10 00      sub d, 16
0940   03F3 26 10 00      mov b, 16
0941   03F6             print_ascii_l:
0942   03F6 79            inc d
0943   03F7 1E            mov al, [d]               ; read byte
0944   03F8 B9 20         cmp al, $20
0945   03FA C8 02 04      jlu dot
0946   03FD B9 7E         cmp al, $7e
0947   03FF D0 0A 04      jleu ascii
0948   0402             dot:
0949   0402 10 00 2E      mov a, $2e00
0950   0405 05 03         syscall sys_io
0951   0407 0A 0F 04      jmp ascii_continue
0952   040A             ascii:
0953   040A 23            mov ah, al
0954   040B 19 00         mov al, 0
0955   040D 05 03         syscall sys_io
0956   040F             ascii_continue:
0957   040F FD A9 F6 03   loopb print_ascii_l
0958   0413 0A DD 03      jmp back1
0959   0416             print_base:
0960   0416 07 BA 12      call printnl
0961   0419 2D            mov b, d
0962   041A 61 A4 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0963   041D 07 69 13      call print_u16x          ; display row
0964   0420 10 00 3A      mov a, $3a00
0965   0423 05 03         syscall sys_io
0966   0425 10 00 20      mov a, $2000
0967   0428 05 03         syscall sys_io
0968   042A 0A CB 03      jmp back
0969   042D             
0970   042D             s_break1:  
0971   042D 0A 64 65 62   .db "\ndebugger entry point.\n"
0971   0431 75 67 67 65 
0971   0435 72 20 65 6E 
0971   0439 74 72 79 20 
0971   043D 70 6F 69 6E 
0971   0441 74 2E 0A 
0972   0444 30 2E 20 73   .db "0. show registers\n"
0972   0448 68 6F 77 20 
0972   044C 72 65 67 69 
0972   0450 73 74 65 72 
0972   0454 73 0A 
0973   0456 31 2E 20 73   .db "1. show 512b ram block\n"
0973   045A 68 6F 77 20 
0973   045E 35 31 32 62 
0973   0462 20 72 61 6D 
0973   0466 20 62 6C 6F 
0973   046A 63 6B 0A 
0974   046D 32 2E 20 63   .db "2. continue execution", 0
0974   0471 6F 6E 74 69 
0974   0475 6E 75 65 20 
0974   0479 65 78 65 63 
0974   047D 75 74 69 6F 
0974   0481 6E 00 
0975   0483             
0976   0483             ; ------------------------------------------------------------------------------------------------------------------;
0977   0483             ; divide by zero exception
0978   0483             ; ------------------------------------------------------------------------------------------------------------------;
0979   0483             trap_div_zero:
0980   0483 D7            push a
0981   0484 DA            push d
0982   0485 E1            pushf
0983   0486 3B DB 18      mov d, s_divzero
0984   0489 07 0D 13      call _puts
0985   048C EE            popf
0986   048D E7            pop d
0987   048E E4            pop a
0988   048F 06            sysret ; enable interrupts
0989   0490             
0990   0490             ; ------------------------------------------------------------------------------------------------------------------;
0991   0490             ; undefined opcode exception
0992   0490             ; ------------------------------------------------------------------------------------------------------------------;
0993   0490             trap_undef_opcode:
0994   0490 06            sysret
0995   0491             
0996   0491             ; ------------------------------------------------------------------------------------------------------------------;
0997   0491             ; real-time clock services syscall
0998   0491             ; rtc i/o bank = ffa0 to ffaf
0999   0491             ; ffa0 to ffa7 is scratch ram
1000   0491             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
1001   0491             ; al = 0..6 -> get
1002   0491             ; al = 7..d -> set
1003   0491             ; ------------------------------------------------------------------------------------------------------------------;
1004   0491             syscall_rtc:
1005   0491 DB            push al
1006   0492 DA            push d
1007   0493 B9 06         cmp al, 6
1008   0495 D1 AA 04      jgu syscall_rtc_set
1009   0498             syscall_rtc_get:
1010   0498 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
1011   049A 22 FF         mov ah, $ff    
1012   049C 3C            mov d, a                ; get to ffa9 + offset
1013   049D F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
1014   04A1 1E            mov al, [d]             ; get data
1015   04A2 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
1016   04A6 23            mov ah, al
1017   04A7 E7            pop d
1018   04A8 E8            pop al
1019   04A9 06            sysret
1020   04AA             syscall_rtc_set:
1021   04AA DD            push bl
1022   04AB 99            mov bl, ah              ; set data aside
1023   04AC 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
1024   04AE 22 FF         mov ah, $ff    
1025   04B0 3C            mov d, a                ; get to ffa9 + offset
1026   04B1 1B            mov al, bl              ; get data back
1027   04B2 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
1028   04B6 3E            mov [d], al             ; set data
1029   04B7 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
1030   04BB EA            pop bl
1031   04BC E7            pop d
1032   04BD E8            pop al
1033   04BE 06            sysret
1034   04BF             
1035   04BF             datetime_serv_tbl:
1036   04BF C7 04         .dw print_date
1037   04C1 3B 05         .dw set_date
1038   04C3             syscall_datetime:
1039   04C3 FD 0A BF 04   jmp [datetime_serv_tbl + al]      
1040   04C7             print_date:
1041   04C7 10 00 0D      mov a, $0d00           ; print carriage return char
1042   04CA 19 03         mov al, 3
1043   04CC 05 01         syscall sys_rtc        ; get week
1044   04CE 1A            mov al, ah
1045   04CF 22 00         mov ah, 0
1046   04D1 FD 9D 02      shl a, 2          
1047   04D4 3B 65 19      mov d, s_week
1048   04D7 59            add d, a
1049   04D8 07 0D 13      call _puts
1050   04DB 10 00 20      mov a, $2000
1051   04DE 05 03         syscall sys_io         ; display ' '
1052   04E0 19 04         mov al, 4
1053   04E2 05 01         syscall sys_rtc        ; get day
1054   04E4 99            mov bl, ah
1055   04E5 07 AD 13      call print_u8x
1056   04E8 10 00 20      mov a, $2000
1057   04EB 05 03         syscall sys_io         ; display ' '
1058   04ED             ; there is a problem with the month displaying
1059   04ED             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
1060   04ED             ; even though it is to be understood as bcd.
1061   04ED             ; when retrieving the value and adding the string table address offset the value will go overboard!  
1062   04ED 19 05         mov al, 05
1063   04EF 05 01         syscall sys_rtc        ; get month
1064   04F1 1A            mov al, ah
1065   04F2 22 00         mov ah, 0
1066   04F4 FD 9D 02      shl a, 2          
1067   04F7 3B 31 19      mov d, s_months
1068   04FA 59            add d, a
1069   04FB 07 0D 13      call _puts
1070   04FE 10 00 20      mov a, $2000
1071   0501 05 03         syscall sys_io         ; display ' '
1072   0503 2E 20         mov bl, $20
1073   0505 07 AD 13      call print_u8x         ; print 20 for year prefix
1074   0508 19 06         mov al, 06
1075   050A 05 01         syscall sys_rtc        ; get year
1076   050C 99            mov bl, ah
1077   050D 07 AD 13      call print_u8x
1078   0510 10 00 20      mov a, $2000  
1079   0513 05 03         syscall sys_io         ; display ' '
1080   0515 19 02         mov al, 2
1081   0517 05 01         syscall sys_rtc        ; get hours
1082   0519 99            mov bl, ah
1083   051A 07 AD 13      call print_u8x
1084   051D 10 00 3A      mov a, $3a00    
1085   0520 05 03         syscall sys_io         ; display ':'
1086   0522 19 01         mov al, 01
1087   0524 05 01         syscall sys_rtc        ; get minutes
1088   0526 99            mov bl, ah
1089   0527 07 AD 13      call print_u8x
1090   052A 10 00 3A      mov a, $3a00  
1091   052D 05 03         syscall sys_io         ; display ':'
1092   052F 19 00         mov al, 0
1093   0531 05 01         syscall sys_rtc        ; get seconds
1094   0533 99            mov bl, ah
1095   0534 07 AD 13      call print_u8x
1096   0537 07 BA 12      call printnl
1097   053A 06            sysret
1098   053B             set_date:
1099   053B 3B F6 18      mov d, s_set_year
1100   053E 07 0D 13      call _puts
1101   0541 07 F8 13      call scan_u8x          ; read integer into a
1102   0544 FD 9D 08      shl a, 8               ; only al used, move to ah
1103   0547 19 0D         mov al, 0dh            ; set rtc year
1104   0549 05 01         syscall sys_rtc        ; set rtc
1105   054B 3B FD 18      mov d, s_set_month
1106   054E 07 0D 13      call _puts
1107   0551 07 F8 13      call scan_u8x          ; read integer into a
1108   0554 FD 9D 08      shl a, 8               ; only al used, move to ah
1109   0557 19 0C         mov al, 0ch            ; set rtc month
1110   0559 05 01         syscall sys_rtc        ; set rtc
1111   055B 3B 05 19      mov d, s_set_day
1112   055E 07 0D 13      call _puts
1113   0561 07 F8 13      call scan_u8x          ; read integer into a
1114   0564 FD 9D 08      shl a, 8               ; only al used, move to ah
1115   0567 19 0B         mov al, 0bh            ; set rtc month
1116   0569 05 01         syscall sys_rtc        ; set rtc
1117   056B 3B 0B 19      mov d, s_set_week
1118   056E 07 0D 13      call _puts
1119   0571 07 F8 13      call scan_u8x          ; read integer into a
1120   0574 FD 9D 08      shl a, 8               ; only al used, move to ah
1121   0577 19 0A         mov al, 0ah            ; set rtc month
1122   0579 05 01         syscall sys_rtc        ; set rtc
1123   057B 3B 15 19      mov d, s_set_hours
1124   057E 07 0D 13      call _puts
1125   0581 07 F8 13      call scan_u8x          ; read integer into a
1126   0584 FD 9D 08      shl a, 8               ; only al used, move to ah
1127   0587 19 09         mov al, 09h            ; set rtc month
1128   0589 05 01         syscall sys_rtc        ; set rtc
1129   058B 3B 1D 19      mov d, s_set_minutes
1130   058E 07 0D 13      call _puts
1131   0591 07 F8 13      call scan_u8x          ; read integer into a
1132   0594 FD 9D 08      shl a, 8               ; only al used, move to ah
1133   0597 19 08         mov al, 08h            ; set rtc month
1134   0599 05 01         syscall sys_rtc        ; set rtc
1135   059B 3B 27 19      mov d, s_set_seconds
1136   059E 07 0D 13      call _puts
1137   05A1 07 F8 13      call scan_u8x          ; read integer into a
1138   05A4 FD 9D 08      shl a, 8               ; only al used, move to ah
1139   05A7 19 07         mov al, 07h            ; set rtc month
1140   05A9 05 01         syscall sys_rtc        ; set rtc
1141   05AB 06            sysret
1142   05AC             
1143   05AC             ; ------------------------------------------------------------------------------------------------------------------;
1144   05AC             ; ide services syscall
1145   05AC             ; al = option
1146   05AC             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1147   05AC             ; ide read/write sector
1148   05AC             ; 512 bytes
1149   05AC             ; user buffer pointer in d
1150   05AC             ; ah = number of sectors
1151   05AC             ; cb = lba bytes 3..0
1152   05AC             ; ------------------------------------------------------------------------------------------------------------------;
1153   05AC             ide_serv_tbl:
1154   05AC B8 05         .dw ide_reset
1155   05AE CC 05         .dw ide_sleep
1156   05B0 DB 05         .dw ide_read_sect_wrapper
1157   05B2 DF 05         .dw ide_write_sect_wrapper
1158   05B4             syscall_ide:
1159   05B4 FD 0A AC 05   jmp [ide_serv_tbl + al]    
1160   05B8             
1161   05B8             ide_reset:      
1162   05B8 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1163   05BC 07 65 06      call ide_wait                   ; wait for ide ready             
1164   05BF F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1165   05C3 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1166   05C7 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1167   05CB 06            sysret
1168   05CC             ide_sleep:
1169   05CC 07 65 06      call ide_wait                   ; wait for ide ready             
1170   05CF F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1171   05D3 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1172   05D7 07 65 06      call ide_wait                   ; wait for ide ready
1173   05DA 06            sysret
1174   05DB             ide_read_sect_wrapper:
1175   05DB 07 E3 05      call ide_read_sect
1176   05DE 06            sysret
1177   05DF             ide_write_sect_wrapper:
1178   05DF 07 09 06      call ide_write_sect
1179   05E2 06            sysret
1180   05E3             ide_read_sect:
1181   05E3 1A            mov al, ah
1182   05E4 24            mov ah, bl
1183   05E5 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1184   05E8 1C            mov al, bh
1185   05E9 3D D4 FF      mov [_ide_r4], al
1186   05EC 12            mov a, c
1187   05ED 3D D5 FF      mov [_ide_r5], al
1188   05F0 1A            mov al, ah
1189   05F1 87 0F         and al, %00001111
1190   05F3 8B E0         or al, %11100000                ; mode lba, master
1191   05F5 3D D6 FF      mov [_ide_r6], al
1192   05F8             ide_read_sect_wait:
1193   05F8 1D D7 FF      mov al, [_ide_r7]  
1194   05FB 87 80         and al, $80                     ; busy flag
1195   05FD C7 F8 05      jnz ide_read_sect_wait
1196   0600 19 20         mov al, $20
1197   0602 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1198   0605 07 2F 06      call ide_read  
1199   0608 09            ret
1200   0609             ide_write_sect:
1201   0609 1A            mov al, ah
1202   060A 24            mov ah, bl
1203   060B 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1204   060E 1C            mov al, bh
1205   060F 3D D4 FF      mov [_ide_r4], al
1206   0612 12            mov a, c
1207   0613 3D D5 FF      mov [_ide_r5], al
1208   0616 1A            mov al, ah
1209   0617 87 0F         and al, %00001111
1210   0619 8B E0         or al, %11100000                ; mode lba, master
1211   061B 3D D6 FF      mov [_ide_r6], al
1212   061E             ide_write_sect_wait:
1213   061E 1D D7 FF      mov al, [_ide_r7]  
1214   0621 87 80         and al, $80                     ; busy flag
1215   0623 C7 1E 06      jnz ide_write_sect_wait
1216   0626 19 30         mov al, $30
1217   0628 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1218   062B 07 4A 06      call ide_write      
1219   062E 09            ret
1220   062F             
1221   062F             ;----------------------------------------------------------------------------------------------------;
1222   062F             ; read ide data
1223   062F             ; pointer in d
1224   062F             ;----------------------------------------------------------------------------------------------------;
1225   062F             ide_read:
1226   062F DA            push d
1227   0630             ide_read_loop:
1228   0630 1D D7 FF      mov al, [_ide_r7]  
1229   0633 87 80         and al, 80h                     ; busy flag
1230   0635 C7 30 06      jnz ide_read_loop               ; wait loop
1231   0638 1D D7 FF      mov al, [_ide_r7]
1232   063B 87 08         and al, %00001000               ; drq flag
1233   063D C6 48 06      jz ide_read_end
1234   0640 1D D0 FF      mov al, [_ide_r0]
1235   0643 3E            mov [d], al
1236   0644 79            inc d
1237   0645 0A 30 06      jmp ide_read_loop
1238   0648             ide_read_end:
1239   0648 E7            pop d
1240   0649 09            ret
1241   064A             
1242   064A             ;----------------------------------------------------------------------------------------------------;
1243   064A             ; write ide data
1244   064A             ; data pointer in d
1245   064A             ;----------------------------------------------------------------------------------------------------;
1246   064A             ide_write:
1247   064A DA            push d
1248   064B             ide_write_loop:
1249   064B 1D D7 FF      mov al, [_ide_r7]  
1250   064E 87 80         and al, 80h             ; busy flag
1251   0650 C7 4B 06      jnz ide_write_loop      ; wait loop
1252   0653 1D D7 FF      mov al, [_ide_r7]
1253   0656 87 08         and al, %00001000       ; drq flag
1254   0658 C6 63 06      jz ide_write_end
1255   065B 1E            mov al, [d]
1256   065C 3D D0 FF      mov [_ide_r0], al
1257   065F 79            inc d 
1258   0660 0A 4B 06      jmp ide_write_loop
1259   0663             ide_write_end:
1260   0663 E7            pop d
1261   0664 09            ret
1262   0665             
1263   0665             ;----------------------------------------------------------------------------------------------------;
1264   0665             ; wait for ide to be ready
1265   0665             ;----------------------------------------------------------------------------------------------------;
1266   0665             ide_wait:
1267   0665 1D D7 FF      mov al, [_ide_r7]  
1268   0668 87 80         and al, 80h        ; busy flag
1269   066A C7 65 06      jnz ide_wait
1270   066D 09            ret
1271   066E             
1272   066E             ;----------------------------------------------------------------------------------------------------;
1273   066E             ; io syscall
1274   066E             ;----------------------------------------------------------------------------------------------------;
1275   066E             ; baud  divisor
1276   066E             ; 50    2304
1277   066E             ; 110   1047
1278   066E             ; 300    384
1279   066E             ; 600    192
1280   066E             ; 1200    96
1281   066E             ; 9600    12
1282   066E             ; 19200    6
1283   066E             ; 38400    3
1284   066E             syscall_io_jmp:
1285   066E A1 06         .dw syscall_io_putchar
1286   0670 AE 06         .dw syscall_io_getch
1287   0672 78 06         .dw syscall_io_uart_setup
1288   0674             syscall_io:
1289   0674 FD 0A 6E 06   jmp [syscall_io_jmp + al]
1290   0678             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1291   0678             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1292   0678             ; buffer, the transmitter holding register, or the interrupt enable register.
1293   0678             syscall_io_uart_setup:
1294   0678 1D 38 18      mov al, [sys_uart0_lcr]
1295   067B 8B 80         or al, $80                ; set dlab access bit
1296   067D 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1297   0680 1D 3B 18      mov al, [sys_uart0_div0]
1298   0683 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1299   0686 1D 3C 18      mov al, [sys_uart0_div1]
1300   0689 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1301   068C             
1302   068C 1D 38 18      mov al, [sys_uart0_lcr]
1303   068F 87 7F         and al, $7f               ; clear dlab access bit 
1304   0691 3D 83 FF      mov [_uart0_lcr], al
1305   0694 1D 39 18      mov al, [sys_uart0_inten]
1306   0697 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1307   069A 1D 3A 18      mov al, [sys_uart0_fifoen]
1308   069D 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1309   06A0 06            sysret
1310   06A1             
1311   06A1             ; char in ah
1312   06A1             syscall_io_putchar:
1313   06A1             syscall_io_putchar_l0:
1314   06A1 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1315   06A4 87 20         and al, $20
1316   06A6 C6 A1 06      jz syscall_io_putchar_l0    
1317   06A9 1A            mov al, ah
1318   06AA 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1319   06AD 06            sysret
1320   06AE             
1321   06AE             ; char in ah
1322   06AE             ; al = sucess code
1323   06AE             syscall_io_getch:
1324   06AE D8            push b
1325   06AF DA            push d
1326   06B0 FD 0C         sti
1327   06B2             syscall_io_getch_l0:  
1328   06B2 14 45 18      mov a, [fifo_out]
1329   06B5 29 43 18      mov b, [fifo_in]
1330   06B8 B0            cmp a, b
1331   06B9 C6 B2 06      je syscall_io_getch_l0
1332   06BC 3C            mov d, a
1333   06BD 77            inc a
1334   06BE AF A4 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1335   06C1 C7 C7 06      jne syscall_io_getch_cont
1336   06C4 10 A4 1F      mov a, fifo  
1337   06C7             syscall_io_getch_cont:  
1338   06C7 42 45 18      mov [fifo_out], a             ; update fifo pointer
1339   06CA 1E            mov al, [d]                   ; get char
1340   06CB 23            mov ah, al
1341   06CC 1D 37 18      mov al, [sys_echo_on]
1342   06CF B9 01         cmp al, 1
1343   06D1 C7 E0 06      jne syscall_io_getch_noecho 
1344   06D4             ; here we just echo the char back to the console
1345   06D4             syscall_io_getch_echo_l0:
1346   06D4 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1347   06D7 87 20         and al, $20                 ; isolate transmitter empty
1348   06D9 C6 D4 06      jz syscall_io_getch_echo_l0
1349   06DC 1A            mov al, ah
1350   06DD 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1351   06E0             syscall_io_getch_noecho:
1352   06E0 19 01         mov al, 1                    ; al = 1 means a char successfully received
1353   06E2 E7            pop d
1354   06E3 E5            pop b
1355   06E4 06            sysret
1356   06E5             
1357   06E5             ;------------------------------------------------------------------------------------------------------;
1358   06E5             ; file system data
1359   06E5             ;------------------------------------------------------------------------------------------------------;
1360   06E5             ; infor for : ide services interrupt
1361   06E5             ; ide read/write 512-byte sector
1362   06E5             ; al = option
1363   06E5             ; user buffer pointer in d
1364   06E5             ; ah = number of sectors
1365   06E5             ; cb = lba bytes 3..0  
1366   06E5             ;------------------------------------------------------------------------------------------------------;
1367   06E5             ; file system data structure
1368   06E5             ;------------------------------------------------------------------------------------------------------;
1369   06E5             ; for a directory we have the header first, followed by metadata
1370   06E5             ; header 1 sector (512 bytes)
1371   06E5             ; metadata 1 sector (512 bytes)
1372   06E5             ; header entries:
1373   06E5             ; filename (64)
1374   06E5             ; parent dir lba (2) -  to be used for faster backwards navigation...
1375   06E5             ;
1376   06E5             ; metadata entries:
1377   06E5             ; filename (24)
1378   06E5             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1379   06E5             ; lba (2)
1380   06E5             ; size (2)
1381   06E5             ; day (1)
1382   06E5             ; month (1)
1383   06E5             ; year (1)
1384   06E5             ; packet size = 32 bytes
1385   06E5             ;
1386   06E5             ; first directory on disk is the root directory '/'
1387   06E5             file_system_jmptbl:
1388   06E5 50 07         .dw fs_mkfs                   ; 0
1389   06E7 00 00         .dw 0                         ; 1
1390   06E9 B2 07         .dw fs_mkdir                  ; 2
1391   06EB 2B 0B         .dw fs_cd                     ; 3
1392   06ED 32 0B         .dw fs_ls                     ; 4
1393   06EF 1D 0C         .dw fs_mktxt                  ; 5
1394   06F1 E8 0C         .dw fs_mkbin                  ; 6
1395   06F3 AF 0D         .dw fs_pwd                    ; 7
1396   06F5 CC 0D         .dw fs_cat                    ; 8
1397   06F7 28 0E         .dw fs_rmdir                  ; 9
1398   06F9 84 0E         .dw fs_rm                     ; 10
1399   06FB 00 00         .dw 0                         ; 11
1400   06FD 00 00         .dw 0                         ; 12
1401   06FF 00 00         .dw 0                         ; 13
1402   0701 58 07         .dw fs_chmod                  ; 14
1403   0703 EC 0E         .dw fs_mv                     ; 15
1404   0705 51 07         .dw fs_cd_root                ; 16
1405   0707 27 0B         .dw fs_get_curr_dirid         ; 17
1406   0709 03 09         .dw fs_dir_id_to_path         ; 18
1407   070B 69 09         .dw fs_path_to_dir_id_user    ; 19
1408   070D 83 0A         .dw fs_load_from_path_user    ; 20  
1409   070F F3 09         .dw fs_filepath_exists_user   ; 21
1410   0711             
1411   0711 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1411   0715 79 73 63 61 
1411   0719 6C 6C 5F 66 
1411   071D 69 6C 65 5F 
1411   0721 73 79 73 74 
1411   0725 65 6D 20 63 
1411   0729 61 6C 6C 65 
1411   072D 64 3A 20 00 
1412   0731             syscall_file_system:
1413   0731 DD            push bl
1414   0732 31 36 18      mov bl, [sys_debug_mode]
1415   0735               ; debug block
1416   0735 C1 00         cmp bl, 0
1417   0737 EA            pop bl
1418   0738 C6 4C 07      je syscall_filesystem_jmp
1419   073B DA            push d
1420   073C DD            push bl
1421   073D 3B 11 07      mov d, s_syscall_fs_dbg0
1422   0740 07 0D 13      call _puts
1423   0743 2F            mov bl, al
1424   0744 07 AD 13      call print_u8x
1425   0747 07 BA 12      call printnl
1426   074A EA            pop bl
1427   074B E7            pop d
1428   074C             syscall_filesystem_jmp:
1429   074C FD 0A E5 06   jmp [file_system_jmptbl + al]
1430   0750             
1431   0750             fs_mkfs:  
1432   0750 06            sysret  
1433   0751               
1434   0751             fs_cd_root:
1435   0751 10 20 00      mov a, root_id
1436   0754 42 47 18      mov [current_dir_id], a      ; set current directory lba to root
1437   0757 06            sysret  
1438   0758             
1439   0758             ; filename in d (userspace data)
1440   0758             ; permission in bl
1441   0758             fs_chmod:
1442   0758 DD            push bl
1443   0759 FD 4E         mov si, d
1444   075B FD 4F A4 1D   mov di, user_data
1445   075F 38 80 00      mov c, 128
1446   0762 04            load                        ; load filename from user-space
1447   0763 14 47 18      mov a, [current_dir_id]
1448   0766 77            inc a                       ; metadata sector
1449   0767 27            mov b, a
1450   0768 38 00 00      mov c, 0                    ; upper lba = 0
1451   076B 22 01         mov ah, $01                  ; 1 sector
1452   076D 3B A4 25      mov d, transient_area
1453   0770 07 E3 05      call ide_read_sect          ; read directory
1454   0773 FD 10         cla
1455   0775 42 3F 18      mov [index], a              ; reset file counter
1456   0778             fs_chmod_l1:
1457   0778 FD 4E         mov si, d
1458   077A FD 4F A4 1D   mov di, user_data
1459   077E 07 50 11      call _strcmp
1460   0781 C6 98 07      je fs_chmod_found_entry
1461   0784 58 20 00      add d, 32
1462   0787 14 3F 18      mov a, [index]
1463   078A 77            inc a
1464   078B 42 3F 18      mov [index], a
1465   078E AF 10 00      cmp a, fst_files_per_dir
1466   0791 C7 78 07      jne fs_chmod_l1
1467   0794 EA            pop bl
1468   0795 0A B1 07      jmp fs_chmod_not_found
1469   0798             fs_chmod_found_entry:  
1470   0798 FD 79         mov g, b                    ; save lba
1471   079A EA            pop bl                      ; retrieve saved permission value
1472   079B 1F 18 00      mov al, [d + 24]            ; read file permissions
1473   079E 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1474   07A0 8C            or al, bl                   ; set new permissions
1475   07A1 3F 18 00      mov [d + 24], al            ; write new permissions
1476   07A4 38 00 00      mov c, 0
1477   07A7 3B A4 25      mov d, transient_area
1478   07AA 22 01         mov ah, $01                 ; disk write 1 sect
1479   07AC FD 27         mov b, g                    ; retrieve lba
1480   07AE 07 09 06      call ide_write_sect         ; write sector
1481   07B1             fs_chmod_not_found:
1482   07B1 06            sysret
1483   07B2             
1484   07B2             ;------------------------------------------------------------------------------------------------------;
1485   07B2             ; create new directory
1486   07B2             ;------------------------------------------------------------------------------------------------------;
1487   07B2             ; search list for null name entry. add new directory to list
1488   07B2             fs_mkdir:
1489   07B2 FD 4E         mov si, d
1490   07B4 FD 4F A4 1D   mov di, user_data
1491   07B8 38 00 02      mov c, 512
1492   07BB 04            load                        ; load data from user-space
1493   07BC 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1494   07BF                                           ; when checking for null name, since root has a null name)
1495   07BF 38 00 00      mov c, 0                    ; upper lba = 0
1496   07C2             fs_mkdir_l1:  
1497   07C2 22 01         mov ah, $01                  ; 1 sector
1498   07C4 3B A4 25      mov d, transient_area
1499   07C7 07 E3 05      call ide_read_sect          ; read sector
1500   07CA BD 00         cmp byte[d], 0              ; check for null
1501   07CC C6 D5 07      je fs_mkdir_found_null
1502   07CF 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1503   07D2 0A C2 07      jmp fs_mkdir_l1
1504   07D5             fs_mkdir_found_null:
1505   07D5             ;create header file by grabbing dir name from parameter
1506   07D5 D8            push b                      ; save new directory's lba
1507   07D6 38 40 00      mov c, 64
1508   07D9 FD 4D A4 1D   mov si, user_data
1509   07DD FD 4F A4 25   mov di, transient_area
1510   07E1 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1511   07E3 14 47 18      mov a, [current_dir_id]
1512   07E6 42 E4 25      mov [transient_area + 64], a    ; store parent directory lba
1513   07E9 19 00         mov al, 0
1514   07EB FD 4F A4 27   mov di, transient_area + 512
1515   07EF 38 00 02      mov c, 512
1516   07F2 FD F7         rep stosb                       ; clean buffer
1517   07F4 38 00 00      mov c, 0                        ; reset lba(c) to 0
1518   07F7             ; write directory entry sectors
1519   07F7 3B A4 25      mov d, transient_area
1520   07FA 22 02         mov ah, $02                     ; disk write, 2 sectors
1521   07FC 07 09 06      call ide_write_sect             ; write sector
1522   07FF             ; now we need to add the new directory to the list, inside the current directory
1523   07FF 14 47 18      mov a, [current_dir_id]
1524   0802 53 01 00      add a, 1
1525   0805 27            mov b, a                        ; metadata sector
1526   0806 38 00 00      mov c, 0
1527   0809 FD 79         mov g, b                        ; save lba
1528   080B 3B A4 25      mov d, transient_area
1529   080E 22 01         mov ah, $01                  ; 1 sector
1530   0810 07 E3 05      call ide_read_sect              ; read metadata sector
1531   0813             fs_mkdir_l2:
1532   0813 BD 00         cmp byte[d], 0
1533   0815 C6 1E 08      je fs_mkdir_found_null2
1534   0818 58 20 00      add d, fst_entry_size
1535   081B 0A 13 08      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1536   081E             fs_mkdir_found_null2:
1537   081E FD 4D A4 1D   mov si, user_data
1538   0822 FD 50         mov di, d
1539   0824 07 65 11      call _strcpy                    ; copy directory name
1540   0827 58 18 00      add d, 24                       ; goto attributes
1541   082A 19 0B         mov al, %00001011               ; directory, no execute, write, read
1542   082C 3E            mov [d], al      
1543   082D 79            inc d
1544   082E E5            pop b
1545   082F D8            push b                          ; push lba back
1546   0830 FD 43         mov [d], b                      ; save lba
1547   0832             ; set file creation date  
1548   0832 58 04 00      add d, 4
1549   0835 19 04         mov al, 4
1550   0837 05 01         syscall sys_rtc
1551   0839 1A            mov al, ah
1552   083A 3E            mov [d], al                     ; set day
1553   083B 79            inc d
1554   083C 19 05         mov al, 5
1555   083E 05 01         syscall sys_rtc
1556   0840 1A            mov al, ah
1557   0841 3E            mov [d], al                     ; set month
1558   0842 79            inc d
1559   0843 19 06         mov al, 6
1560   0845 05 01         syscall sys_rtc
1561   0847 1A            mov al, ah
1562   0848 3E            mov [d], al                     ; set year
1563   0849             ; write sector into disk for new directory entry
1564   0849 FD 27         mov b, g
1565   084B 38 00 00      mov c, 0
1566   084E 3B A4 25      mov d, transient_area
1567   0851 22 01         mov ah, $01                     ; disk write, 1 sector
1568   0853 07 09 06      call ide_write_sect             ; write sector
1569   0856             
1570   0856             ; after adding the new directory's information to its parent directory's list
1571   0856             ; we need to now enter the new directory, and to it add two new directories!
1572   0856             ; which directories do we need to add ? '..' and '.' are the directories needed.
1573   0856             ; importantly, note that these two new directories are only entries in the list
1574   0856             ; and do not have actual physical entries in the disk as real directories.
1575   0856             ; i.e. they only exist as list entries in the new directory created so that
1576   0856             ; the new directory can reference its parent and itself.
1577   0856             ; we need to add both '..' and '.'
1578   0856             ; this first section is for '..' and on the section below we do the same for '.'
1579   0856 E4            pop a                         ; retrieve the new directory's lba  
1580   0857 D7            push a                        ; and save again
1581   0858 53 01 00      add a, 1
1582   085B 27            mov b, a                      ; metadata sector
1583   085C 38 00 00      mov c, 0
1584   085F FD 79         mov g, b                      ; save lba
1585   0861 3B A4 25      mov d, transient_area
1586   0864 22 01         mov ah, $01                  ; 1 sector
1587   0866 07 E3 05      call ide_read_sect            ; read metadata sector
1588   0869             fs_mkdir_l3:
1589   0869 BD 00         cmp byte[d], 0
1590   086B C6 74 08      je fs_mkdir_found_null3
1591   086E 58 20 00      add d, fst_entry_size
1592   0871 0A 69 08      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1593   0874             fs_mkdir_found_null3:
1594   0874 FD 4D 66 18   mov si, s_parent_dir
1595   0878 FD 50         mov di, d
1596   087A 07 65 11      call _strcpy                  ; copy directory name
1597   087D 58 18 00      add d, 24                     ; goto attributes
1598   0880 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1599   0882 3E            mov [d], al      
1600   0883 79            inc d
1601   0884 29 47 18      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1602   0887 FD 43         mov [d], b                    ; save lba
1603   0889             ; set file creation date  
1604   0889 58 04 00      add d, 4
1605   088C 19 04         mov al, 4
1606   088E 05 01         syscall sys_rtc
1607   0890 1A            mov al, ah
1608   0891 3E            mov [d], al                   ; set day
1609   0892 79            inc d
1610   0893 19 05         mov al, 5
1611   0895 05 01         syscall sys_rtc
1612   0897 1A            mov al, ah
1613   0898 3E            mov [d], al                   ; set month
1614   0899 79            inc d
1615   089A 19 06         mov al, 6
1616   089C 05 01         syscall sys_rtc
1617   089E 1A            mov al, ah
1618   089F 3E            mov [d], al                   ; set year
1619   08A0             ; write sector into disk for new directory entry
1620   08A0 FD 27         mov b, g
1621   08A2 38 00 00      mov c, 0
1622   08A5 3B A4 25      mov d, transient_area
1623   08A8 22 01         mov ah, $01                   ; disk write, 1 sector
1624   08AA 07 09 06      call ide_write_sect           ; write sector
1625   08AD             ;;;;;;;;;;;;;
1626   08AD             ; like we did above for '..', we need to now add the '.' directory to the list.
1627   08AD             ;------------------------------------------------------------------------------------------------------;
1628   08AD E4            pop a                         ; retrieve the new directory's lba  
1629   08AE D7            push a
1630   08AF 53 01 00      add a, 1
1631   08B2 27            mov b, a                      ; metadata sector
1632   08B3 38 00 00      mov c, 0
1633   08B6 FD 79         mov g, b                      ; save lba
1634   08B8 3B A4 25      mov d, transient_area
1635   08BB 22 01         mov ah, $01                  ; 1 sector
1636   08BD 07 E3 05      call ide_read_sect            ; read metadata sector
1637   08C0             fs_mkdir_l4:
1638   08C0 BD 00         cmp byte[d], 0
1639   08C2 C6 CB 08      je fs_mkdir_found_null4
1640   08C5 58 20 00      add d, fst_entry_size
1641   08C8 0A C0 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1642   08CB             fs_mkdir_found_null4:
1643   08CB FD 4D 69 18   mov si, s_current_dir
1644   08CF FD 50         mov di, d
1645   08D1 07 65 11      call _strcpy                  ; copy directory name
1646   08D4 58 18 00      add d, 24                     ; goto attributes
1647   08D7 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1648   08D9 3E            mov [d], al      
1649   08DA 79            inc d
1650   08DB E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1651   08DC FD 43         mov [d], b                    ; save lba
1652   08DE             ; set file creation date  
1653   08DE 58 04 00      add d, 4
1654   08E1 19 04         mov al, 4
1655   08E3 05 01         syscall sys_rtc
1656   08E5 1A            mov al, ah
1657   08E6 3E            mov [d], al                   ; set day
1658   08E7 79            inc d
1659   08E8 19 05         mov al, 5
1660   08EA 05 01         syscall sys_rtc
1661   08EC 1A            mov al, ah
1662   08ED 3E            mov [d], al                   ; set month
1663   08EE 79            inc d
1664   08EF 19 06         mov al, 6
1665   08F1 05 01         syscall sys_rtc
1666   08F3 1A            mov al, ah
1667   08F4 3E            mov [d], al                   ; set year
1668   08F5             ; write sector into disk for new directory entry
1669   08F5 FD 27         mov b, g
1670   08F7 38 00 00      mov c, 0
1671   08FA 3B A4 25      mov d, transient_area
1672   08FD 22 01         mov ah, $01                   ; disk write, 1 sector
1673   08FF 07 09 06      call ide_write_sect           ; write sector
1674   0902             fs_mkdir_end:
1675   0902 06            sysret
1676   0903             
1677   0903             ;------------------------------------------------------------------------------------------------------;
1678   0903             ; get path from a given directory dirid
1679   0903             ; pseudo code:
1680   0903             ;  fs_dir_id_to_path(int dirid, char *d){
1681   0903             ;    if(dirid == 0){
1682   0903             ;      reverse path in d;
1683   0903             ;      return;
1684   0903             ;    }
1685   0903             ;    else{
1686   0903             ;      copy directory name to end of d;
1687   0903             ;      add '/' to end of d;
1688   0903             ;      parentid = get parent directory id;
1689   0903             ;      fs_dir_id_to_path(parentid, d);
1690   0903             ;    }
1691   0903             ;  }
1692   0903             ; a = dirid
1693   0903             ; d = generated path string pointer
1694   0903             ;------------------------------------------------------------------------------------------------------;
1695   0903             ; sample path: /usr/bin
1696   0903             fs_dir_id_to_path:
1697   0903 3B 24 1D      mov d, filename
1698   0906 19 00         mov al, 0
1699   0908 3E            mov [d], al                     ; initialize path string 
1700   0909 14 47 18      mov a, [current_dir_id]
1701   090C 07 19 09      call fs_dir_id_to_path_e0
1702   090F 3B 24 1D      mov d, filename
1703   0912 07 F9 10      call _strrev
1704   0915 07 0D 13      call _puts
1705   0918 06            sysret
1706   0919             fs_dir_id_to_path_e0:
1707   0919 07 38 09      call get_dirname_from_dirid
1708   091C FD 4D 6B 18   mov si, s_fslash
1709   0920 FD 50         mov di, d
1710   0922 07 73 11      call _strcat                    ; add '/' to end of path
1711   0925 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1712   0928 C6 37 09      je fs_dir_id_to_path_root
1713   092B 07 55 09      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1714   092E AF 20 00      cmp a, root_id               ; check if we are at the root directory
1715   0931 C6 37 09      je fs_dir_id_to_path_root
1716   0934 07 19 09      call fs_dir_id_to_path_e0     ; recursively call itself
1717   0937             fs_dir_id_to_path_root:
1718   0937 09            ret
1719   0938             
1720   0938             ;------------------------------------------------------------------------------------------------------;
1721   0938             ; in_puts:
1722   0938             ; a = directory id
1723   0938             ; out_puts:
1724   0938             ; d = pointer to directory name string
1725   0938             ;------------------------------------------------------------------------------------------------------;
1726   0938             get_dirname_from_dirid:
1727   0938 D7            push a
1728   0939 D8            push b
1729   093A DA            push d
1730   093B 27            mov b, a
1731   093C 38 00 00      mov c, 0                      ; upper lba = 0
1732   093F 22 01         mov ah, $01                  ; 1 sector
1733   0941 3B A4 23      mov d, transient_area - 512
1734   0944 07 E3 05      call ide_read_sect            ; read directory
1735   0947 07 F9 10      call _strrev                  ; reverse dir name before copying
1736   094A FD 4E         mov si, d
1737   094C E7            pop d                         ; destination address = d value pushed at beginning
1738   094D FD 50         mov di, d
1739   094F 07 73 11      call _strcat                  ; copy filename to d
1740   0952 E5            pop b
1741   0953 E4            pop a
1742   0954 09            ret
1743   0955             
1744   0955             ;------------------------------------------------------------------------------------------------------;
1745   0955             ; in_puts:
1746   0955             ; a = directory id
1747   0955             ; out_puts:
1748   0955             ; a = parent directory id
1749   0955             ;------------------------------------------------------------------------------------------------------;
1750   0955             get_parentid_from_dirid:
1751   0955 D8            push b
1752   0956 DA            push d
1753   0957 27            mov b, a
1754   0958 38 00 00      mov c, 0                      ; upper lba = 0
1755   095B 22 01         mov ah, $01                  ; 1 sector
1756   095D 3B A4 23      mov d, transient_area - 512
1757   0960 07 E3 05      call ide_read_sect            ; read directory
1758   0963 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1759   0966 E7            pop d
1760   0967 E5            pop b
1761   0968 09            ret
1762   0969             
1763   0969             ;------------------------------------------------------------------------------------------------------;
1764   0969             ; get dirid from a given path string
1765   0969             ; in_puts:
1766   0969             ; d = path pointer 
1767   0969             ; out_puts:
1768   0969             ; a = dirid
1769   0969             ; if dir non existent, a = ffff (fail code)
1770   0969             ; /usr/local/bin    - absolute
1771   0969             ; local/bin/games    - relative
1772   0969             ;------------------------------------------------------------------------------------------------------;
1773   0969             fs_path_to_dir_id_user:
1774   0969 FD 4E         mov si, d
1775   096B FD 4F A4 1D   mov di, user_data
1776   096F 38 00 02      mov c, 512
1777   0972 04            load
1778   0973 07 77 09      call get_dirid_from_path
1779   0976 06            sysret
1780   0977             get_dirid_from_path:
1781   0977 26 A4 1D      mov b, user_data
1782   097A FD 42 32 17   mov [prog], b                  ; token pointer set to path string
1783   097E 07 93 15      call get_token
1784   0981 31 35 17      mov bl, [tok]
1785   0984 C1 01         cmp bl, tok_fslash
1786   0986 C6 92 09      je get_dirid_from_path_abs 
1787   0989 14 47 18      mov a, [current_dir_id]
1788   098C 07 19 17      call _putback
1789   098F 0A 95 09      jmp get_dirid_from_path_e0
1790   0992             get_dirid_from_path_abs:
1791   0992 10 20 00      mov a, root_id
1792   0995             get_dirid_from_path_e0:
1793   0995 07 93 15      call get_token
1794   0998 31 34 17      mov bl, [toktyp]
1795   099B C1 00         cmp bl, toktyp_identifier
1796   099D C7 EE 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1797   09A0             
1798   09A0 FD 4D 36 17   mov si, tokstr
1799   09A4 FD 4F 24 1D   mov di, filename
1800   09A8 07 65 11      call _strcpy        
1801   09AB 77            inc a                         ; metadata sector
1802   09AC 27            mov b, a
1803   09AD 38 00 00      mov c, 0                      ; upper lba = 0
1804   09B0 22 01         mov ah, $01                  ; 1 sector
1805   09B2 3B A4 25      mov d, transient_area
1806   09B5 07 E3 05      call ide_read_sect            ; read directory
1807   09B8 FD 10         cla
1808   09BA 42 3F 18      mov [index], a
1809   09BD             get_dirid_from_path_l1:
1810   09BD FD 4E         mov si, d
1811   09BF FD 4F 24 1D   mov di, filename
1812   09C3 07 50 11      call _strcmp
1813   09C6 C6 DC 09      je get_dirid_from_path_name_equal  
1814   09C9 58 20 00      add d, 32
1815   09CC 14 3F 18      mov a, [index]
1816   09CF 77            inc a
1817   09D0 42 3F 18      mov [index], a
1818   09D3 AF 10 00      cmp a, fst_files_per_dir
1819   09D6 C6 EF 09      je get_dirid_from_path_fail
1820   09D9 0A BD 09      jmp get_dirid_from_path_l1
1821   09DC             get_dirid_from_path_name_equal:
1822   09DC 58 19 00      add d, 25           
1823   09DF 15            mov a, [d]                    ; set result register a = dirid
1824   09E0 07 93 15      call get_token
1825   09E3 31 35 17      mov bl, [tok]
1826   09E6 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1827   09E8 C6 95 09      je get_dirid_from_path_e0
1828   09EB 07 19 17      call _putback
1829   09EE             get_dirid_from_path_end:
1830   09EE 09            ret
1831   09EF             get_dirid_from_path_fail:
1832   09EF 10 FF FF      mov a, $ffff
1833   09F2 09            ret
1834   09F3             
1835   09F3             
1836   09F3             ;------------------------------------------------------------------------------------------------------;
1837   09F3             ; check if file exists by a given path string
1838   09F3             ; in_puts:
1839   09F3             ; d = path pointer 
1840   09F3             ; outputs:
1841   09F3             ; a = success code, if file exists gives lba, else, give 0
1842   09F3             ; /usr/local/bin/ed
1843   09F3             ;------------------------------------------------------------------------------------------------------;
1844   09F3             fs_filepath_exists_user:
1845   09F3 FD 4E         mov si, d
1846   09F5 FD 4F A4 1D   mov di, user_data
1847   09F9 38 00 02      mov c, 512
1848   09FC 04            load
1849   09FD 07 01 0A      call file_exists_by_path
1850   0A00 06            sysret
1851   0A01             file_exists_by_path:
1852   0A01 26 A4 1D      mov b, user_data
1853   0A04 FD 42 32 17   mov [prog], b                   ; token pointer set to path string
1854   0A08 07 93 15      call get_token
1855   0A0B 31 35 17      mov bl, [tok]
1856   0A0E C1 01         cmp bl, tok_fslash
1857   0A10 C6 1C 0A      je  file_exists_by_path_abs
1858   0A13 14 47 18      mov a, [current_dir_id]
1859   0A16 07 19 17      call _putback
1860   0A19 0A 1F 0A      jmp file_exists_by_path_e0
1861   0A1C             file_exists_by_path_abs:
1862   0A1C 10 20 00      mov a, root_id
1863   0A1F             file_exists_by_path_e0:
1864   0A1F 07 93 15      call get_token
1865   0A22 31 34 17      mov bl, [toktyp]
1866   0A25 C1 00         cmp bl, toktyp_identifier
1867   0A27 C7 7F 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1868   0A2A FD 4D 36 17   mov si, tokstr
1869   0A2E FD 4F 24 1D   mov di, filename
1870   0A32 07 65 11      call _strcpy        
1871   0A35 77            inc a                           ; metadata sector
1872   0A36 27            mov b, a
1873   0A37 38 00 00      mov c, 0                        ; upper lba = 0
1874   0A3A 22 01         mov ah, $01                  ; 1 sector
1875   0A3C 3B A4 25      mov d, transient_area
1876   0A3F 07 E3 05      call ide_read_sect              ; read directory
1877   0A42 FD 10         cla
1878   0A44 42 3F 18      mov [index], a
1879   0A47             file_exists_by_path_l1:
1880   0A47 FD 4E         mov si, d
1881   0A49 FD 4F 24 1D   mov di, filename
1882   0A4D 07 50 11      call _strcmp
1883   0A50 C6 66 0A      je   file_exists_by_path_name_equal
1884   0A53 58 20 00      add d, 32
1885   0A56 14 3F 18      mov a, [index]
1886   0A59 77            inc a
1887   0A5A 42 3F 18      mov [index], a
1888   0A5D AF 10 00      cmp a, fst_files_per_dir
1889   0A60 C6 7F 0A      je file_exists_by_path_end
1890   0A63 0A 47 0A      jmp file_exists_by_path_l1
1891   0A66             file_exists_by_path_name_equal:
1892   0A66 33 18 00      mov bl, [d + 24]
1893   0A69 FD 87 38      and bl, %00111000               ; directory flag
1894   0A6C C1 08         cmp bl, %00001000               ; is dir?
1895   0A6E C6 75 0A      je file_exists_by_path_isdir;
1896   0A71             ; entry is a file
1897   0A71 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1898   0A74 09            ret
1899   0A75             file_exists_by_path_isdir:
1900   0A75 58 19 00      add d, 25           
1901   0A78 15            mov a, [d]                      ; set result register a = dirid
1902   0A79 07 93 15      call get_token
1903   0A7C 0A 1F 0A      jmp file_exists_by_path_e0
1904   0A7F             file_exists_by_path_end:
1905   0A7F 10 00 00      mov a, 0                        ; return 0 because file was not found
1906   0A82 09            ret
1907   0A83             
1908   0A83             ;------------------------------------------------------------------------------------------------------;
1909   0A83             ; load file data from a given path string
1910   0A83             ; inputs:
1911   0A83             ; d = path pointer 
1912   0A83             ; di = userspace program data destination
1913   0A83             ; /usr/local/bin/ed
1914   0A83             ; ./ed
1915   0A83             ;------------------------------------------------------------------------------------------------------;
1916   0A83             fs_load_from_path_user:
1917   0A83 E3            push di
1918   0A84 FD 4E         mov si, d
1919   0A86 FD 4F A4 1D   mov di, user_data
1920   0A8A 38 00 02      mov c, 512
1921   0A8D 04            load
1922   0A8E 07 9B 0A      call loadfile_from_path
1923   0A91 F0            pop di
1924   0A92 FD 4D A4 25   mov si, transient_area
1925   0A96 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1926   0A99 03            store
1927   0A9A 06            sysret
1928   0A9B             loadfile_from_path:
1929   0A9B 26 A4 1D      mov b, user_data
1930   0A9E FD 42 32 17   mov [prog], b                 ; token pointer set to path string
1931   0AA2 07 93 15      call get_token
1932   0AA5 31 35 17      mov bl, [tok]
1933   0AA8 C1 01         cmp bl, tok_fslash
1934   0AAA C6 B6 0A      je loadfile_from_path_abs 
1935   0AAD 14 47 18      mov a, [current_dir_id]
1936   0AB0 07 19 17      call _putback
1937   0AB3 0A B9 0A      jmp loadfile_from_path_e0
1938   0AB6             loadfile_from_path_abs:
1939   0AB6 10 20 00      mov a, root_id
1940   0AB9             loadfile_from_path_e0:
1941   0AB9 07 93 15      call get_token
1942   0ABC 31 34 17      mov bl, [toktyp]
1943   0ABF C1 00         cmp bl, toktyp_identifier
1944   0AC1 C7 26 0B      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1945   0AC4 FD 4D 36 17   mov si, tokstr
1946   0AC8 FD 4F 24 1D   mov di, filename
1947   0ACC 07 65 11      call _strcpy        
1948   0ACF 77            inc a                         ; metadata sector
1949   0AD0 27            mov b, a
1950   0AD1 38 00 00      mov c, 0                      ; upper lba = 0
1951   0AD4 22 01         mov ah, $01                  ; 1 sector
1952   0AD6 3B A4 25      mov d, transient_area
1953   0AD9 07 E3 05      call ide_read_sect            ; read directory
1954   0ADC FD 10         cla
1955   0ADE 42 3F 18      mov [index], a
1956   0AE1             loadfile_from_path_l1:
1957   0AE1 FD 4E         mov si, d
1958   0AE3 FD 4F 24 1D   mov di, filename
1959   0AE7 07 50 11      call _strcmp
1960   0AEA C6 00 0B      je loadfile_from_path_name_equal  
1961   0AED 58 20 00      add d, 32
1962   0AF0 14 3F 18      mov a, [index]
1963   0AF3 77            inc a
1964   0AF4 42 3F 18      mov [index], a
1965   0AF7 AF 10 00      cmp a, fst_files_per_dir
1966   0AFA C6 26 0B      je loadfile_from_path_end
1967   0AFD 0A E1 0A      jmp loadfile_from_path_l1
1968   0B00             loadfile_from_path_name_equal:
1969   0B00 33 18 00      mov bl, [d + 24]
1970   0B03 FD 87 38      and bl, %00111000             ; directory flag
1971   0B06 C1 08         cmp bl, %00001000             ; is dir?
1972   0B08 C6 1C 0B      je loadfile_isdirectory  
1973   0B0B             ; entry is a file
1974   0B0B 2B 19 00      mov b, [d + 25]               ; get lba
1975   0B0E FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1976   0B10 3B A4 25      mov d, transient_area
1977   0B13 38 00 00      mov c, 0
1978   0B16 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1979   0B18 07 E3 05      call ide_read_sect            ; read sector
1980   0B1B 09            ret
1981   0B1C             loadfile_isdirectory:
1982   0B1C 58 19 00      add d, 25           
1983   0B1F 15            mov a, [d]                    ; set result register a = dirid
1984   0B20 07 93 15      call get_token
1985   0B23 0A B9 0A      jmp loadfile_from_path_e0
1986   0B26             loadfile_from_path_end:
1987   0B26 09            ret
1988   0B27             
1989   0B27             ;------------------------------------------------------------------------------------------------------;
1990   0B27             ; return the id of the current directory
1991   0B27             ; id returned in b
1992   0B27             ;------------------------------------------------------------------------------------------------------;
1993   0B27             fs_get_curr_dirid:
1994   0B27 29 47 18      mov b, [current_dir_id]
1995   0B2A 06            sysret
1996   0B2B             
1997   0B2B             ;------------------------------------------------------------------------------------------------------;
1998   0B2B             ; cd
1999   0B2B             ;------------------------------------------------------------------------------------------------------;
2000   0B2B             ; new dirid in b
2001   0B2B             fs_cd:
2002   0B2B FD 42 47 18   mov [current_dir_id], b
2003   0B2F 06            sysret  
2004   0B30             
2005   0B30             ;------------------------------------------------------------------------------------------------------;
2006   0B30             ; ls
2007   0B30             ; dirid in b
2008   0B30             ;------------------------------------------------------------------------------------------------------;
2009   0B30 00 00       ls_count:       .dw 0
2010   0B32             fs_ls:
2011   0B32 FD 77         inc b                        ; metadata sector
2012   0B34 38 00 00      mov c, 0                     ; upper lba = 0
2013   0B37 22 01         mov ah, $01                  ; 1 sector
2014   0B39 3B A4 25      mov d, transient_area
2015   0B3C 07 E3 05      call ide_read_sect           ; read directory
2016   0B3F FD 10         cla
2017   0B41 42 3F 18      mov [index], a               ; reset entry index
2018   0B44 3D 30 0B      mov [ls_count], al           ; reset item count
2019   0B47             fs_ls_l1:
2020   0B47 BD 00         cmp byte [d], 0              ; check for null
2021   0B49 C6 E0 0B      je fs_ls_next
2022   0B4C             fs_ls_non_null:
2023   0B4C 1D 30 0B      mov al, [ls_count]
2024   0B4F 7A            inc al
2025   0B50 3D 30 0B      mov [ls_count], al           ; increment item count
2026   0B53 1F 18 00      mov al, [d + 24]
2027   0B56 87 38         and al, %00111000
2028   0B58 FD A2 03      shr al, 3
2029   0B5B 22 00         mov ah, 0                    ; file type
2030   0B5D B7 72 18      mov a, [a + file_type]      
2031   0B60 23            mov ah, al
2032   0B61 07 E1 11      call _putchar
2033   0B64 1F 18 00      mov al, [d + 24]
2034   0B67 87 01         and al, %00000001
2035   0B69 22 00         mov ah, 0
2036   0B6B B7 6D 18      mov a, [a + file_attrib]     ; read
2037   0B6E 23            mov ah, al
2038   0B6F 07 E1 11      call _putchar
2039   0B72 1F 18 00      mov al, [d + 24]
2040   0B75 87 02         and al, %00000010
2041   0B77 22 00         mov ah, 0
2042   0B79 B7 6D 18      mov a, [a + file_attrib]     ; write
2043   0B7C 23            mov ah, al
2044   0B7D 07 E1 11      call _putchar
2045   0B80 1F 18 00      mov al, [d + 24]
2046   0B83 87 04         and al, %00000100
2047   0B85 22 00         mov ah, 0
2048   0B87 B7 6D 18      mov a, [a + file_attrib]     ; execute
2049   0B8A 23            mov ah, al
2050   0B8B 07 E1 11      call _putchar
2051   0B8E 22 20         mov ah, $20
2052   0B90 07 E1 11      call _putchar  
2053   0B93 2B 1B 00      mov b, [d + 27]
2054   0B96 07 69 13      call print_u16x              ; filesize
2055   0B99 22 20         mov ah, $20
2056   0B9B 07 E1 11      call _putchar  
2057   0B9E 2B 19 00      mov b, [d + 25]
2058   0BA1 07 69 13      call print_u16x              ; dirid / lba
2059   0BA4 22 20         mov ah, $20
2060   0BA6 07 E1 11      call _putchar
2061   0BA9             ; print date
2062   0BA9 33 1D 00      mov bl, [d + 29]             ; day
2063   0BAC 07 AD 13      call print_u8x
2064   0BAF 22 20         mov ah, $20
2065   0BB1 07 E1 11      call _putchar  
2066   0BB4 1F 1E 00      mov al, [d + 30]             ; month
2067   0BB7 FD 9E 02      shl al, 2
2068   0BBA DA            push d
2069   0BBB 3B 31 19      mov d, s_months
2070   0BBE 22 00         mov ah, 0
2071   0BC0 59            add d, a
2072   0BC1 07 0D 13      call _puts
2073   0BC4 E7            pop d
2074   0BC5 22 20         mov ah, $20
2075   0BC7 07 E1 11      call _putchar
2076   0BCA 2E 20         mov bl, $20
2077   0BCC 07 AD 13      call print_u8x
2078   0BCF 33 1F 00      mov bl, [d + 31]             ; year
2079   0BD2 07 AD 13      call print_u8x  
2080   0BD5 22 20         mov ah, $20
2081   0BD7 07 E1 11      call _putchar  
2082   0BDA 07 0D 13      call _puts                   ; print filename  
2083   0BDD 07 BA 12      call printnl
2084   0BE0             fs_ls_next:
2085   0BE0 14 3F 18      mov a, [index]
2086   0BE3 77            inc a
2087   0BE4 42 3F 18      mov [index], a
2088   0BE7 AF 10 00      cmp a, fst_files_per_dir
2089   0BEA C6 F3 0B      je fs_ls_end
2090   0BED 58 20 00      add d, 32      
2091   0BF0 0A 47 0B      jmp fs_ls_l1  
2092   0BF3             fs_ls_end:
2093   0BF3 3B 82 18      mov d, s_ls_total
2094   0BF6 07 0D 13      call _puts
2095   0BF9 1D 30 0B      mov al, [ls_count]
2096   0BFC 07 BF 13      call print_u8d
2097   0BFF 07 BA 12      call printnl
2098   0C02 06            sysret
2099   0C03             
2100   0C03             ;------------------------------------------------------------------------------------------------------;
2101   0C03             ; finds an empty data block
2102   0C03             ; block lba returned in b
2103   0C03             ;------------------------------------------------------------------------------------------------------;
2104   0C03             fs_find_empty_block:
2105   0C03 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2106   0C06 38 00 00      mov c, 0                ; upper lba = 0
2107   0C09             fs_find_empty_block_l1:  
2108   0C09 22 01         mov ah, $01                  ; 1 sector
2109   0C0B 3B A4 23      mov d, transient_area - 512
2110   0C0E 07 E3 05      call ide_read_sect      ; read sector
2111   0C11 BD 00         cmp byte [d], 0
2112   0C13 C6 1C 0C      je fs_find_empty_block_found_null
2113   0C16 55 20 00      add b, fs_sectors_per_file
2114   0C19 0A 09 0C      jmp fs_find_empty_block_l1
2115   0C1C             fs_find_empty_block_found_null:
2116   0C1C 09            ret
2117   0C1D             
2118   0C1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2119   0C1D             ;; create new textfile
2120   0C1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2121   0C1D             ; search for first null block
2122   0C1D             fs_mktxt:
2123   0C1D FD 4E       	mov si, d
2124   0C1F FD 4F A4 1D 	mov di, user_data
2125   0C23 38 00 01    	mov c, 256
2126   0C26 04          	load					; load data from user-space
2127   0C27             	
2128   0C27 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2129   0C2A 38 00 00    	mov c, 0						; reset lba to 0
2130   0C2D             fs_mktxt_l1:	
2131   0C2D 10 02 01    	mov a, $0102			; disk read
2132   0C30 3B A4 25    	mov d, transient_area
2133   0C33 05 02       	syscall sys_ide ; read sector
2134   0C35 1E          	mov al, [d]
2135   0C36 B9 00       	cmp al, 0			; check for null
2136   0C38 C6 41 0C    	je fs_mktxt_found_null
2137   0C3B 55 20 00    	add b, fs_sectors_per_file
2138   0C3E 0A 2D 0C    	jmp fs_mktxt_l1
2139   0C41             fs_mktxt_found_null:
2140   0C41 D8          	push b				; save lba
2141   0C42             ;create header file by grabbing file name from parameter	
2142   0C42 3B 63 18    	mov d, s_dataentry
2143   0C45 07 0D 13    	call _puts
2144   0C48 3B A4 27    	mov d, transient_area + 512			; pointer to file contents
2145   0C4B 07 73 12    	call _gettxt
2146   0C4E 07 40 11    	call _strlen						; get length of file
2147   0C51 D9          	push c							; save length
2148   0C52 19 01       	mov al, 1
2149   0C54 3D A4 25    	mov [transient_area], al					; mark sectors as used (not null)
2150   0C57 10 00 00    	mov a, 0
2151   0C5A 42 3F 18    	mov [index], a
2152   0C5D 3B A4 25    	mov d, transient_area
2153   0C60 13          	mov a, d
2154   0C61 42 41 18    	mov [buffer_addr], a
2155   0C64             fs_mktxt_l2:
2156   0C64 38 00 00    	mov c, 0
2157   0C67 10 03 01    	mov a, $0103			; disk write, 1 sector
2158   0C6A 05 02       	syscall sys_ide		; write sector
2159   0C6C 14 3F 18    	mov a, [index]
2160   0C6F 77          	inc a
2161   0C70 42 3F 18    	mov [index], a
2162   0C73 AF 20 00    	cmp a, fs_sectors_per_file
2163   0C76 C6 88 0C    	je fs_mktxt_add_to_dir
2164   0C79 FD 77       	inc b
2165   0C7B 14 41 18    	mov a, [buffer_addr]
2166   0C7E 53 00 02    	add a, 512
2167   0C81 42 41 18    	mov [buffer_addr], a
2168   0C84 3C          	mov d, a
2169   0C85 0A 64 0C    	jmp fs_mktxt_l2
2170   0C88             ; now we add the file to the current directory!
2171   0C88             fs_mktxt_add_to_dir:	
2172   0C88 14 47 18    	mov a, [current_dir_id]
2173   0C8B 77          	inc a
2174   0C8C 27          	mov b, a					; metadata sector
2175   0C8D 38 00 00    	mov c, 0
2176   0C90 FD 79       	mov g, b					; save lba
2177   0C92 3B A4 25    	mov d, transient_area
2178   0C95 10 02 01    	mov a, $0102			; disk read
2179   0C98 05 02       	syscall sys_ide		; read metadata sector
2180   0C9A             fs_mktxt_add_to_dir_l2:
2181   0C9A 1E          	mov al, [d]
2182   0C9B B9 00       	cmp al, 0
2183   0C9D C6 A6 0C    	je fs_mktxt_add_to_dir_null
2184   0CA0 58 20 00    	add d, fst_entry_size
2185   0CA3 0A 9A 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2186   0CA6             fs_mktxt_add_to_dir_null:
2187   0CA6 FD 4D A4 1D 	mov si, user_data
2188   0CAA FD 50       	mov di, d
2189   0CAC 07 65 11    	call _strcpy			; copy file name
2190   0CAF 58 18 00    	add d, 24			; skip name
2191   0CB2 19 06       	mov al, %00000110		; no execute, write, read, not directory
2192   0CB4 3E          	mov [d], al			
2193   0CB5 58 03 00    	add d, 3
2194   0CB8 E4          	pop a
2195   0CB9 43          	mov [d], a
2196   0CBA 63 02 00    	sub d, 2
2197   0CBD E5          	pop b				; get file lba
2198   0CBE FD 43       	mov [d], b			; save lba	
2199   0CC0             	
2200   0CC0             	; set file creation date	
2201   0CC0 58 04 00    	add d, 4
2202   0CC3 19 04       	mov al, 4
2203   0CC5 05 01       	syscall sys_rtc
2204   0CC7 1A          	mov al, ah
2205   0CC8 3E          	mov [d], al			; set day
2206   0CC9             	
2207   0CC9 79          	inc d
2208   0CCA 19 05       	mov al, 5
2209   0CCC 05 01       	syscall sys_rtc
2210   0CCE 1A          	mov al, ah
2211   0CCF 3E          	mov [d], al			; set month
2212   0CD0             	
2213   0CD0 79          	inc d
2214   0CD1 19 06       	mov al, 6
2215   0CD3 05 01       	syscall sys_rtc
2216   0CD5 1A          	mov al, ah
2217   0CD6 3E          	mov [d], al			; set year
2218   0CD7             	
2219   0CD7             ; write sector into disk for new directory entry
2220   0CD7 FD 27       	mov b, g
2221   0CD9 38 00 00    	mov c, 0
2222   0CDC 3B A4 25    	mov d, transient_area
2223   0CDF 10 03 01    	mov a, $0103			; disk write, 1 sector
2224   0CE2 05 02       	syscall sys_ide		; write sector
2225   0CE4 07 BA 12    	call printnl
2226   0CE7 06          	sysret
2227   0CE8             
2228   0CE8             
2229   0CE8             
2230   0CE8             ;------------------------------------------------------------------------------------------------------;
2231   0CE8             ; create new binary file
2232   0CE8             ;------------------------------------------------------------------------------------------------------;
2233   0CE8             ; search for first null block
2234   0CE8             fs_mkbin:
2235   0CE8 19 00         mov al, 0
2236   0CEA 3D 37 18      mov [sys_echo_on], al ; disable echo
2237   0CED FD 4E         mov si, d
2238   0CEF FD 4F A4 1D   mov di, user_data
2239   0CF3 38 00 02      mov c, 512
2240   0CF6 04            load                          ; load data from user-space
2241   0CF7 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2242   0CFA 38 00 00      mov c, 0                      ; upper lba = 0
2243   0CFD             fs_mkbin_l1:  
2244   0CFD 22 01         mov ah, $01                  ; 1 sector
2245   0CFF 3B A4 25      mov d, transient_area
2246   0D02 07 E3 05      call ide_read_sect            ; read sector
2247   0D05 BD 00         cmp byte[d], 0                ; check for null
2248   0D07 C6 10 0D      je fs_mkbin_found_null
2249   0D0A 55 20 00      add b, fs_sectors_per_file
2250   0D0D 0A FD 0C      jmp fs_mkbin_l1
2251   0D10             fs_mkbin_found_null:
2252   0D10 D8            push b                        ; save lba
2253   0D11             ;create header file by grabbing file name from parameter
2254   0D11 FD 4F A4 27   mov di, transient_area + 512  ; pointer to file contents
2255   0D15 07 8B 10      call _load_hex                ; load binary hex
2256   0D18 D9            push c                        ; save size (nbr of bytes)
2257   0D19 19 01         mov al, 1
2258   0D1B 3D A4 25      mov [transient_area], al      ; mark sectors as used (not null)
2259   0D1E FD 10         cla
2260   0D20 42 3F 18      mov [index], a
2261   0D23 3B A4 25      mov d, transient_area
2262   0D26 13            mov a, d
2263   0D27 42 41 18      mov [buffer_addr], a
2264   0D2A             fs_mkbin_l2:
2265   0D2A 38 00 00      mov c, 0
2266   0D2D 22 01         mov ah, $01                   ; disk write, 1 sector
2267   0D2F 07 09 06      call ide_write_sect           ; write sector
2268   0D32 14 3F 18      mov a, [index]
2269   0D35 77            inc a
2270   0D36 42 3F 18      mov [index], a
2271   0D39 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2272   0D3C C6 4E 0D      je fs_mkbin_add_to_dir
2273   0D3F FD 77         inc b
2274   0D41 14 41 18      mov a, [buffer_addr]
2275   0D44 53 00 02      add a, 512
2276   0D47 42 41 18      mov [buffer_addr], a
2277   0D4A 3C            mov d, a
2278   0D4B 0A 2A 0D      jmp fs_mkbin_l2
2279   0D4E             ; now we add the file to the current directory!
2280   0D4E             fs_mkbin_add_to_dir:  
2281   0D4E 14 47 18      mov a, [current_dir_id]
2282   0D51 77            inc a
2283   0D52 27            mov b, a                      ; metadata sector
2284   0D53 38 00 00      mov c, 0
2285   0D56 FD 79         mov g, b                      ; save lba
2286   0D58 3B A4 25      mov d, transient_area
2287   0D5B 22 01         mov ah, $01                  ; 1 sector
2288   0D5D 07 E3 05      call ide_read_sect            ; read metadata sector
2289   0D60             fs_mkbin_add_to_dir_l2:
2290   0D60 BD 00         cmp byte[d], 0
2291   0D62 C6 6B 0D      je fs_mkbin_add_to_dir_null
2292   0D65 58 20 00      add d, fst_entry_size
2293   0D68 0A 60 0D      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2294   0D6B             fs_mkbin_add_to_dir_null:
2295   0D6B FD 4D A4 1D   mov si, user_data
2296   0D6F FD 50         mov di, d
2297   0D71 07 65 11      call _strcpy                  ; copy file name
2298   0D74 58 18 00      add d, 24                     ; skip name
2299   0D77 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2300   0D79 3E            mov [d], al
2301   0D7A 58 03 00      add d, 3
2302   0D7D E4            pop a
2303   0D7E 43            mov [d], a
2304   0D7F 63 02 00      sub d, 2
2305   0D82 E5            pop b                         ; get file lba
2306   0D83 FD 43         mov [d], b                    ; save lba
2307   0D85               ; set file creation date  
2308   0D85 58 04 00      add d, 4
2309   0D88 19 04         mov al, 4
2310   0D8A 05 01         syscall sys_rtc
2311   0D8C 1A            mov al, ah
2312   0D8D 3E            mov [d], al                   ; set day
2313   0D8E 79            inc d
2314   0D8F 19 05         mov al, 5
2315   0D91 05 01         syscall sys_rtc
2316   0D93 1A            mov al, ah
2317   0D94 3E            mov [d], al                   ; set month
2318   0D95 79            inc d
2319   0D96 19 06         mov al, 6
2320   0D98 05 01         syscall sys_rtc
2321   0D9A 1A            mov al, ah
2322   0D9B 3E            mov [d], al                   ; set year
2323   0D9C             ; write sector into disk for new directory entry
2324   0D9C FD 27         mov b, g
2325   0D9E 38 00 00      mov c, 0
2326   0DA1 3B A4 25      mov d, transient_area
2327   0DA4 22 01         mov ah, $01                   ; disk write, 1 sector
2328   0DA6 07 09 06      call ide_write_sect           ; write sector
2329   0DA9 19 01         mov al, 1
2330   0DAB 3D 37 18      mov [sys_echo_on], al ; enable echo
2331   0DAE 06            sysret
2332   0DAF             
2333   0DAF             ;------------------------------------------------------------------------------------------------------;
2334   0DAF             ; pwd - print working directory
2335   0DAF             ;------------------------------------------------------------------------------------------------------;    
2336   0DAF             fs_pwd:
2337   0DAF 3B 24 1D      mov d, filename
2338   0DB2 19 00         mov al, 0
2339   0DB4 3E            mov [d], al                   ; initialize path string 
2340   0DB5 14 47 18      mov a, [current_dir_id]
2341   0DB8 07 19 09      call fs_dir_id_to_path_e0
2342   0DBB 3B 24 1D      mov d, filename
2343   0DBE 07 F9 10      call _strrev
2344   0DC1 07 0D 13      call _puts
2345   0DC4 07 BA 12      call printnl
2346   0DC7 06            sysret
2347   0DC8             
2348   0DC8             ;------------------------------------------------------------------------------------------------------;
2349   0DC8             ; get current directory lba
2350   0DC8             ; a: returned lba
2351   0DC8             ;------------------------------------------------------------------------------------------------------;
2352   0DC8             cmd_get_curr_dir_lba:
2353   0DC8 14 47 18      mov a, [current_dir_id]
2354   0DCB 06            sysret
2355   0DCC             
2356   0DCC             ;------------------------------------------------------------------------------------------------------;
2357   0DCC             ; cat
2358   0DCC             ; userspace destination data pointer in d
2359   0DCC             ; filename starts at d, but is overwritten after the read is made
2360   0DCC             ;------------------------------------------------------------------------------------------------------;:
2361   0DCC             fs_cat:
2362   0DCC DA            push d                              ; save userspace file data destination
2363   0DCD FD 4E         mov si, d
2364   0DCF FD 4F A4 1D   mov di, user_data
2365   0DD3 38 00 02      mov c, 512
2366   0DD6 04            load                                ; copy filename from user-space
2367   0DD7 29 47 18      mov b, [current_dir_id]
2368   0DDA FD 77         inc b                               ; metadata sector
2369   0DDC 38 00 00      mov c, 0                            ; upper lba = 0
2370   0DDF 22 01         mov ah, $01                  ; 1 sector
2371   0DE1 3B A4 23      mov d, transient_area-512
2372   0DE4 07 E3 05      call ide_read_sect                  ; read directory
2373   0DE7 FD 10         cla
2374   0DE9 42 3F 18      mov [index], a                      ; reset file counter
2375   0DEC             fs_cat_l1:
2376   0DEC FD 4E         mov si, d
2377   0DEE FD 4F A4 1D   mov di, user_data
2378   0DF2 07 50 11      call _strcmp
2379   0DF5 C6 0B 0E      je fs_cat_found_entry
2380   0DF8 58 20 00      add d, 32
2381   0DFB 14 3F 18      mov a, [index]
2382   0DFE 77            inc a
2383   0DFF 42 3F 18      mov [index], a
2384   0E02 AF 10 00      cmp a, fst_files_per_dir
2385   0E05 C6 26 0E      je fs_cat_not_found
2386   0E08 0A EC 0D      jmp fs_cat_l1
2387   0E0B             fs_cat_found_entry:
2388   0E0B 58 19 00      add d, 25                           ; get to dirid of file in disk
2389   0E0E 2A            mov b, [d]                          ; get lba
2390   0E0F FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2391   0E11 3B A4 25      mov d, transient_area  
2392   0E14 38 00 00      mov c, 0
2393   0E17 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2394   0E19 07 E3 05      call ide_read_sect                  ; read sectors
2395   0E1C F0            pop di                              ; write userspace file data destination to di
2396   0E1D FD 4D A4 25   mov si, transient_area              ; data origin
2397   0E21 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2398   0E24 03            store
2399   0E25 06            sysret
2400   0E26             fs_cat_not_found:
2401   0E26 E7            pop d
2402   0E27 06            sysret
2403   0E28             
2404   0E28             ;------------------------------------------------------------------------------------------------------;
2405   0E28             ; rmdir - remove dir by dirid
2406   0E28             ;------------------------------------------------------------------------------------------------------;
2407   0E28             ; deletes a directory entry in the given directory's file list 
2408   0E28             ; also deletes the actual directory entry in the fst
2409   0E28             ; synopsis: rmdir /usr/local/testdir
2410   0E28             ; b = dirid
2411   0E28             fs_rmdir:
2412   0E28 FD 79         mov g, b
2413   0E2A 11            mov a, b
2414   0E2B 07 55 09      call get_parentid_from_dirid  ; now get the directory's parent, in a
2415   0E2E D7            push a                        ; save dirid
2416   0E2F             ; search for directory's entry in the parent's directory then and delete it
2417   0E2F 77            inc a                         ; metadata sector
2418   0E30 27            mov b, a
2419   0E31 38 00 00      mov c, 0                      ; upper lba = 0
2420   0E34 22 01         mov ah, $01          ;
2421   0E36 3B A4 25      mov d, transient_area
2422   0E39 07 E3 05      call ide_read_sect            ; read directory
2423   0E3C FD 10         cla
2424   0E3E 42 3F 18      mov [index], a                ; reset file counter
2425   0E41 FD 27         mov b, g                      ; retrieve directory's dirid
2426   0E43             fs_rmdir_l1:
2427   0E43 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2428   0E46 B0            cmp a, b                      ; compare dirid's to find the directory
2429   0E47 C6 5D 0E      je fs_rmdir_found_entry
2430   0E4A 58 20 00      add d, 32
2431   0E4D 14 3F 18      mov a, [index]
2432   0E50 77            inc a
2433   0E51 42 3F 18      mov [index], a
2434   0E54 AF 10 00      cmp a, fst_files_per_dir
2435   0E57 C6 82 0E      je fs_rmdir_not_found
2436   0E5A 0A 43 0E      jmp fs_rmdir_l1
2437   0E5D             fs_rmdir_found_entry:
2438   0E5D FD 10         cla
2439   0E5F 3E            mov [d], al                   ; make filename null
2440   0E60 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2441   0E63 E5            pop b
2442   0E64 FD 77         inc b                         ; metadata sector
2443   0E66 38 00 00      mov c, 0                      ; upper lba = 0
2444   0E69 22 01         mov ah, $01          ; 
2445   0E6B 3B A4 25      mov d, transient_area
2446   0E6E 07 09 06      call ide_write_sect           ; write sector and erase file's entry in the current dir
2447   0E71             
2448   0E71 FD 27         mov b, g
2449   0E73 3B A4 25      mov d, transient_area  
2450   0E76 FD 10         cla
2451   0E78 3E            mov [d], al                   ; make directory's name header null for re-use
2452   0E79 38 00 00      mov c, 0
2453   0E7C 22 01         mov ah, $01                   ; disk write 1 sect
2454   0E7E 07 09 06      call ide_write_sect           ; delete directory given by dirid in b
2455   0E81 06            sysret
2456   0E82             fs_rmdir_not_found:
2457   0E82 E5            pop b
2458   0E83 06            sysret
2459   0E84             
2460   0E84             ;------------------------------------------------------------------------------------------------------;
2461   0E84             ; rm - remove file
2462   0E84             ;------------------------------------------------------------------------------------------------------;
2463   0E84             ; frees up the data sectors for the file further down the disk
2464   0E84             ; deletes file entry in the directory's file list 
2465   0E84             fs_rm:
2466   0E84 FD 4E         mov si, d
2467   0E86 FD 4F A4 1D   mov di, user_data
2468   0E8A 38 00 02      mov c, 512
2469   0E8D 04            load                          ; load data from user-space
2470   0E8E 14 47 18      mov a, [current_dir_id]
2471   0E91 77            inc a                         ; metadata sector
2472   0E92 27            mov b, a
2473   0E93 38 00 00      mov c, 0                      ; upper lba = 0
2474   0E96 22 01         mov ah, $01                  ; 1 sector
2475   0E98 3B A4 25      mov d, transient_area
2476   0E9B 07 E3 05      call ide_read_sect            ; read directory
2477   0E9E 10 00 00      mov a, 0
2478   0EA1 42 3F 18      mov [index], a                ; reset file counter
2479   0EA4             fs_rm_l1:
2480   0EA4 FD 4E         mov si, d
2481   0EA6 FD 4F A4 1D   mov di, user_data
2482   0EAA 07 50 11      call _strcmp
2483   0EAD C6 C3 0E      je fs_rm_found_entry
2484   0EB0 58 20 00      add d, 32
2485   0EB3 14 3F 18      mov a, [index]
2486   0EB6 77            inc a
2487   0EB7 42 3F 18      mov [index], a
2488   0EBA AF 10 00      cmp a, fst_files_per_dir
2489   0EBD C6 EB 0E      je fs_rm_not_found
2490   0EC0 0A A4 0E      jmp fs_rm_l1
2491   0EC3             fs_rm_found_entry:
2492   0EC3 2B 19 00      mov b, [d + 25]               ; get lba
2493   0EC6 FD 79         mov g, b                      ; save lba
2494   0EC8 19 00         mov al, 0
2495   0ECA 3E            mov [d], al                   ; make file entry null
2496   0ECB 14 47 18      mov a, [current_dir_id]
2497   0ECE 77            inc a                         ; metadata sector
2498   0ECF 27            mov b, a
2499   0ED0 38 00 00      mov c, 0                      ; upper lba = 0
2500   0ED3 22 01         mov ah, $01                   ; disk write
2501   0ED5 3B A4 25      mov d, transient_area
2502   0ED8 07 09 06      call ide_write_sect           ; write sector and erase file's entry in the current dir
2503   0EDB 3B A4 25      mov d, transient_area  
2504   0EDE 19 00         mov al, 0
2505   0EE0 3E            mov [d], al                   ; make file's data header null for re-use
2506   0EE1 38 00 00      mov c, 0
2507   0EE4 FD 27         mov b, g                      ; get data header lba
2508   0EE6 22 01         mov ah, $01                   ; disk write 1 sect
2509   0EE8 07 09 06      call ide_write_sect           ; write sector
2510   0EEB             fs_rm_not_found:  
2511   0EEB 06            sysret  
2512   0EEC             
2513   0EEC             ;------------------------------------------------------------------------------------------------------;
2514   0EEC             ; mv - move / change file name
2515   0EEC             ;------------------------------------------------------------------------------------------------------;
2516   0EEC             fs_mv:
2517   0EEC FD 4E         mov si, d
2518   0EEE FD 4F A4 1D   mov di, user_data
2519   0EF2 38 00 02      mov c, 512
2520   0EF5 04            load                          ; load data from user-space
2521   0EF6 14 47 18      mov a, [current_dir_id]
2522   0EF9 77            inc a                         ; metadata sector
2523   0EFA 27            mov b, a  
2524   0EFB 38 00 00      mov c, 0                      ; upper lba = 0
2525   0EFE 22 01         mov ah, $01                  ; 1 sector
2526   0F00 3B A4 25      mov d, transient_area
2527   0F03 07 E3 05      call ide_read_sect            ; read directory
2528   0F06 FD 10         cla
2529   0F08 42 3F 18      mov [index], a                ; reset file counter
2530   0F0B             fs_mv_l1:
2531   0F0B FD 4E         mov si, d
2532   0F0D FD 4F A4 1D   mov di, user_data
2533   0F11 07 50 11      call _strcmp
2534   0F14 C6 2A 0F      je fs_mv_found_entry
2535   0F17 58 20 00      add d, 32
2536   0F1A 14 3F 18      mov a, [index]
2537   0F1D 77            inc a
2538   0F1E 42 3F 18      mov [index], a
2539   0F21 AF 10 00      cmp a, fst_files_per_dir
2540   0F24 C6 5C 0F      je fs_mv_not_found
2541   0F27 0A 0B 0F      jmp fs_mv_l1
2542   0F2A             fs_mv_found_entry:  
2543   0F2A DA            push d
2544   0F2B FD 4D 24 1E   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2545   0F2F FD 50         mov di, d
2546   0F31 07 65 11      call _strcpy  
2547   0F34 38 00 00      mov c, 0
2548   0F37 3B A4 25      mov d, transient_area
2549   0F3A 22 01         mov ah, $01                   ; disk write 1 sect
2550   0F3C 07 09 06      call ide_write_sect           ; write sector
2551   0F3F E7            pop d
2552   0F40             ;; need to check whether its a dir or a file here ;;;
2553   0F40 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2554   0F43 22 01         mov ah, $01
2555   0F45 3B A4 25      mov d, transient_area
2556   0F48 38 00 00      mov c, 0
2557   0F4B 07 E3 05      call ide_read_sect            ; read directory entry
2558   0F4E FD 4D 24 1E   mov si, user_data + 128
2559   0F52 FD 50         mov di, d
2560   0F54 07 65 11      call _strcpy                  ; change directory's name
2561   0F57 22 01         mov ah, $01
2562   0F59 07 09 06      call ide_write_sect           ; rewrite directory back to disk
2563   0F5C             fs_mv_not_found:
2564   0F5C 06            sysret
2565   0F5D             
2566   0F5D             
2567   0F5D             ;----------------------------------------------------------------------------------------------------;
2568   0F5D             ; process index in a
2569   0F5D             ;----------------------------------------------------------------------------------------------------;
2570   0F5D             find_free_proc:
2571   0F5D FD 4D 15 1B   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2572   0F61             find_free_proc_l0:
2573   0F61 F6            lodsb                               ; get process state
2574   0F62 B9 00         cmp al, 0
2575   0F64 C6 6A 0F      je find_free_proc_free              ; if free, jump
2576   0F67 0A 61 0F      jmp find_free_proc_l0               ; else, goto next
2577   0F6A             find_free_proc_free:
2578   0F6A 4E            mov a, si
2579   0F6B 5F 15 1B      sub a, 1 + proc_availab_table       ; get process index
2580   0F6E 09            ret
2581   0F6F               
2582   0F6F             
2583   0F6F             ;----------------------------------------------------------------------------------------------------;
2584   0F6F             ; process index in al
2585   0F6F             ;----------------------------------------------------------------------------------------------------;
2586   0F6F             proc_memory_map:
2587   0F6F 22 00         mov ah, 0
2588   0F71 27            mov b, a                      ; page in bl, 0 in bh
2589   0F72 FD 9D 05      shl a, 5                      ; multiply by 32
2590   0F75 39            mov c, a                      ; save in c
2591   0F76 57 20 00      add c, 32
2592   0F79             proc_memory_map_l0:
2593   0F79 02            pagemap
2594   0F7A 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2595   0F7D 53 01 00      add a, 1                      ; increase both 
2596   0F80 B1            cmp a, c                      ; check to see if we reached the end of memory
2597   0F81 C7 79 0F      jne proc_memory_map_l0
2598   0F84 09            ret
2599   0F85               
2600   0F85             
2601   0F85             ;----------------------------------------------------------------------------------------------------;
2602   0F85             ; terminate process
2603   0F85             ;----------------------------------------------------------------------------------------------------;
2604   0F85             syscall_terminate_proc:
2605   0F85 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2606   0F88                                                    ; since they will not be used for anything here.
2607   0F88 1D 3E 18      mov al, [active_proc_index]
2608   0F8B 22 00         mov ah, 0  
2609   0F8D FD 9D 05      shl a, 5                             ; x32
2610   0F90 53 24 1B      add a, proc_names
2611   0F93 3C            mov d, a
2612   0F94 19 00         mov al, 0
2613   0F96 3E            mov [d], al                           ; nullify process name
2614   0F97             
2615   0F97 1D 3E 18      mov al, [active_proc_index]
2616   0F9A 22 00         mov ah, 0  
2617   0F9C 3C            mov d, a
2618   0F9D 19 00         mov al, 0
2619   0F9F 3F 14 1B      mov [d + proc_availab_table], al    ; make process empty again
2620   0FA2               
2621   0FA2 1D 3D 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2622   0FA5 80            dec al
2623   0FA6 3D 3D 18      mov [nbr_active_procs], al
2624   0FA9             
2625   0FA9             ; now load the shell process again
2626   0FA9 19 02         mov al, 2                           ; next process = process 2 = shell
2627   0FAB 3D 3E 18      mov [active_proc_index], al         ; set next active proc
2628   0FAE             
2629   0FAE             ; calculate lut entry for next process
2630   0FAE 22 00         mov ah, 0
2631   0FB0 FD 99         shl a                               ; x2
2632   0FB2 B7 7B 10      mov a, [proc_table_convert + a]     ; get process state start index  
2633   0FB5               
2634   0FB5 4D            mov si, a                           ; source is proc state block
2635   0FB6 48            mov a, sp
2636   0FB7 5F 13 00      sub a, 19
2637   0FBA 4F            mov di, a                           ; destination is kernel stack
2638   0FBB             ; restore sp
2639   0FBB 7D            dec a
2640   0FBC 47            mov sp, a
2641   0FBD 38 14 00      mov c, 20
2642   0FC0 FD F5         rep movsb
2643   0FC2             ; set vm process
2644   0FC2 1D 3E 18      mov al, [active_proc_index]
2645   0FC5 01            setptb
2646   0FC6                 
2647   0FC6 4C            popa
2648   0FC7 06            sysret
2649   0FC8             
2650   0FC8             ;----------------------------------------------------------------------------------------------------;
2651   0FC8             ; pause process
2652   0FC8             ;----------------------------------------------------------------------------------------------------;
2653   0FC8             syscall_pause_proc:
2654   0FC8             ; save all registers into kernel stack
2655   0FC8 4B            pusha
2656   0FC9 22 00         mov ah, 0
2657   0FCB 1D 3E 18      mov al, [active_proc_index]
2658   0FCE FD 99         shl a              ; x2
2659   0FD0 B7 7B 10      mov a, [proc_table_convert + a]   ; get process state start index
2660   0FD3                 
2661   0FD3 4F            mov di, a
2662   0FD4 48            mov a, sp
2663   0FD5 77            inc a
2664   0FD6 4D            mov si, a
2665   0FD7 38 14 00      mov c, 20
2666   0FDA FD F5         rep movsb                         ; save process state!
2667   0FDC             ; restore kernel stack position to point before interrupt arrived
2668   0FDC 51 14 00      add sp, 20
2669   0FDF             ; now load the shell process again
2670   0FDF 19 02         mov al, 2                         ; next process = process 2 = shell
2671   0FE1 3D 3E 18      mov [active_proc_index], al       ; set next active proc
2672   0FE4             
2673   0FE4             ; calculate lut entry for next process
2674   0FE4 22 00         mov ah, 0
2675   0FE6 FD 99         shl a                             ; x2
2676   0FE8 B7 7B 10      mov a, [proc_table_convert + a]   ; get process state start index  
2677   0FEB               
2678   0FEB 4D            mov si, a                         ; source is proc state block
2679   0FEC 48            mov a, sp
2680   0FED 5F 13 00      sub a, 19
2681   0FF0 4F            mov di, a                         ; destination is kernel stack
2682   0FF1             ; restore sp
2683   0FF1 7D            dec a
2684   0FF2 47            mov sp, a
2685   0FF3 38 14 00      mov c, 20
2686   0FF6 FD F5         rep movsb
2687   0FF8             ; set vm process
2688   0FF8 1D 3E 18      mov al, [active_proc_index]
2689   0FFB 01            setptb
2690   0FFC                 
2691   0FFC 4C            popa
2692   0FFD 06            sysret
2693   0FFE             
2694   0FFE             ;----------------------------------------------------------------------------------------------------;
2695   0FFE             ; create a new process
2696   0FFE             ; d = path of the process file to be createed
2697   0FFE             ; b = arguments ptr
2698   0FFE             ;----------------------------------------------------------------------------------------------------;
2699   0FFE             syscall_create_proc:
2700   0FFE             ; we save the active process first  
2701   0FFE 4B            pusha
2702   0FFF 22 00         mov ah, 0
2703   1001 1D 3E 18      mov al, [active_proc_index]
2704   1004 FD 99         shl a              ; x2
2705   1006 B7 7B 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2706   1009               
2707   1009 4F            mov di, a
2708   100A 48            mov a, sp
2709   100B 77            inc a
2710   100C 4D            mov si, a
2711   100D 38 14 00      mov c, 20
2712   1010 FD F5         rep movsb                          ; save process state!
2713   1012             ; restore kernel stack position to point before interrupt arrived
2714   1012 51 14 00      add sp, 20
2715   1015               
2716   1015 FD 4E         mov si, d                          ; copy the file path
2717   1017 FD 4F A4 1D   mov di, user_data
2718   101B 38 00 02      mov c, 512
2719   101E 04            load
2720   101F 11            mov a, b
2721   1020 4D            mov si, a                          ; copy the arguments
2722   1021 FD 4F A4 23   mov di, scrap_sector
2723   1025 38 00 02      mov c, 512
2724   1028 04            load
2725   1029 07 9B 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2726   102C                                                  ; the file data is loaded into transient_area
2727   102C             ; now we allocate a new process  
2728   102C 07 5D 0F      call find_free_proc                ; index in a
2729   102F 01            setptb 
2730   1030 07 6F 0F      call proc_memory_map               ; map process memory pages
2731   1033             ; copy arguments into process's memory
2732   1033 FD 4D A4 23   mov si, scrap_sector
2733   1037 FD 4F 00 00   mov di, 0
2734   103B 38 00 02      mov c, 512
2735   103E 03            store
2736   103F             ; now copy process binary data into process's memory
2737   103F FD 4D A4 25   mov si, transient_area
2738   1043 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2739   1047 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2740   104A 03            store                              ; copy process data
2741   104B                 
2742   104B 07 5D 0F      call find_free_proc                ; index in a
2743   104E 3D 3E 18      mov [active_proc_index], al        ; set new active process
2744   1051 FD 9D 05      shl a, 5                           ; x32
2745   1054 53 24 1B      add a, proc_names
2746   1057 4F            mov di, a
2747   1058 FD 4D A4 1D   mov si, user_data                  ; copy and store process filename
2748   105C 07 65 11      call _strcpy
2749   105F               
2750   105F 07 5D 0F      call find_free_proc                ; index in a
2751   1062 3C            mov d, a
2752   1063 19 01         mov al, 1
2753   1065 3F 14 1B      mov [d + proc_availab_table], al   ; make process busy
2754   1068               
2755   1068 1D 3D 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2756   106B 7A            inc al
2757   106C 3D 3D 18      mov [nbr_active_procs], al
2758   106F             ; launch process
2759   106F FD D7 FF FF   push word $ffff 
2760   1073 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2761   1076 FD D7 00 04   push word text_org
2762   107A 06            sysret
2763   107B             
2764   107B             proc_table_convert:
2765   107B D4 19         .dw proc_state_table + 0
2766   107D E8 19         .dw proc_state_table + 20
2767   107F FC 19         .dw proc_state_table + 40
2768   1081 10 1A         .dw proc_state_table + 60
2769   1083 24 1A         .dw proc_state_table + 80
2770   1085 38 1A         .dw proc_state_table + 100
2771   1087 4C 1A         .dw proc_state_table + 120
2772   1089 60 1A         .dw proc_state_table + 140
2773   108B               
2774   108B             ;----------------------------------------------------------------------------------------------;
2775   108B             ; get hex file
2776   108B             ; di = destination address
2777   108B             ; return length in bytes in c
2778   108B             ;----------------------------------------------------------------------------------------------;
2779   108B             _load_hex:
2780   108B D7            push a
2781   108C D8            push b
2782   108D DA            push d
2783   108E E2            push si
2784   108F E3            push di
2785   1090 38 00 00      mov c, 0
2786   1093 50            mov a, di
2787   1094 3C            mov d, a          ; start of string data block
2788   1095 07 E8 11      call _gets        ; get program string
2789   1098 4D            mov si, a
2790   1099             __load_hex_loop:
2791   1099 F6            lodsb             ; load from [si] to al
2792   109A B9 00         cmp al, 0         ; check if ascii 0
2793   109C C6 AA 10      jz __load_hex_ret
2794   109F 36            mov bh, al
2795   10A0 F6            lodsb
2796   10A1 2F            mov bl, al
2797   10A2 07 9E 11      call _atoi        ; convert ascii byte in b to int (to al)
2798   10A5 F7            stosb             ; store al to [di]
2799   10A6 78            inc c
2800   10A7 0A 99 10      jmp __load_hex_loop
2801   10AA             __load_hex_ret:
2802   10AA F0            pop di
2803   10AB EF            pop si
2804   10AC E7            pop d
2805   10AD E5            pop b
2806   10AE E4            pop a
2807   10AF 09            ret
2808   10B0             
2809   10B0             ; synopsis: look inside a certain directory for files/directories
2810   10B0             ; before calling this function, cd into required directory
2811   10B0             ; for each entry inside directory:
2812   10B0             ;  if entry is a file:
2813   10B0             ;    compare filename to searched filename
2814   10B0             ;    if filenames are the same, print filename
2815   10B0             ;  else if entry is a directory:
2816   10B0             ;    cd to the given directory
2817   10B0             ;    recursively call cmd_find
2818   10B0             ;    cd outside previous directory
2819   10B0             ;  if current entry == last entry, return
2820   10B0             ; endfor
2821   10B0             f_find:
2822   10B0 09            ret
2823   10B1             
2824   10B1             
2825   10B1             ; ---------------------------------------------------------------------
2826   10B1             ; kernel reset vector
2827   10B1             ; ---------------------------------------------------------------------
2828   10B1             kernel_reset_vector:  
2829   10B1 FD 49 FF F7   mov bp, stack_begin
2830   10B5 FD 47 FF F7   mov sp, stack_begin
2831   10B9               
2832   10B9 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2833   10BB FD 0F         stomsk                        
2834   10BD FD 0C         sti  
2835   10BF             
2836   10BF 0C            lodstat
2837   10C0 87 DF         and al, %11011111             ; disable display register loading
2838   10C2 0D            stostat
2839   10C3               
2840   10C3             ; reset fifo pointers
2841   10C3 10 A4 1F      mov a, fifo
2842   10C6 3B 43 18      mov d, fifo_in
2843   10C9 43            mov [d], a
2844   10CA 3B 45 18      mov d, fifo_out
2845   10CD 43            mov [d], a  
2846   10CE 19 02         mov al, 2
2847   10D0 05 03         syscall sys_io                ; enable uart in interrupt mode
2848   10D2             
2849   10D2 3B 98 18      mov d, s_kernel_started
2850   10D5 07 0D 13      call _puts
2851   10D8             
2852   10D8 3B 92 19      mov d, s_fdc_config
2853   10DB 07 0D 13      call _puts
2854   10DE F2 C0 FF 0E   mov byte [_fdc_config], %00001110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2855   10E2 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000     ; leave this restore command in order to clear BUSY flag
2856   10E6 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
2857   10EA             
2858   10EA 19 10         mov al, 16
2859   10EC 05 04         syscall sys_filesystem        ; set root dirid
2860   10EE             
2861   10EE 3B B5 18      mov d, s_prompt_init
2862   10F1 07 0D 13      call _puts
2863   10F4 3B 49 18      mov d, s_init_path
2864   10F7 05 05         syscall sys_create_proc       ; launch init as a new process
2865   10F9             
2866   10F9             
2867   10F9             ; file includes
2868   10F9             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  10F9             boot_origin      .EQU  $8004
0002+  10F9             bios_uart        .EQU  $0002
0003+  10F9             bios_ide         .EQU  $0003
0004+  10F9             bios_reset_vector .EQU  $01c0
0005+  10F9             ide_buffer       .EQU  $8204
2869   10F9             .include "lib/stdio.asm"
0001+  10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10F9             ; stdio.s
0003+  10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10F9             .include "lib/string.asm"
0001++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10F9             ; string.s
0003++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10F9             
0005++ 10F9             
0006++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10F9             ; _strrev
0008++ 10F9             ; reverse a string
0009++ 10F9             ; d = string address
0010++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10F9             ; 01234
0012++ 10F9             _strrev:
0013++ 10F9 4B          	pusha
0014++ 10FA 07 40 11    	call _strlen	; length in c
0015++ 10FD 12          	mov a, c
0016++ 10FE AF 01 00    	cmp a, 1
0017++ 1101 D0 1B 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1104 7D          	dec a
0019++ 1105 FD 4E       	mov si, d	; beginning of string
0020++ 1107 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1109 59          	add d, a	; end of string
0022++ 110A 12          	mov a, c
0023++ 110B FD 9B       	shr a		; divide by 2
0024++ 110D 39          	mov c, a	; c now counts the steps
0025++ 110E             _strrev_l0:
0026++ 110E 32          	mov bl, [d]	; save load right-side char into bl
0027++ 110F F6          	lodsb		; load left-side char into al; increase si
0028++ 1110 3E          	mov [d], al	; store left char into right side
0029++ 1111 1B          	mov al, bl
0030++ 1112 F7          	stosb		; store right-side char into left-side; increase di
0031++ 1113 7E          	dec c
0032++ 1114 7F          	dec d
0033++ 1115 C2 00 00    	cmp c, 0
0034++ 1118 C7 0E 11    	jne _strrev_l0
0035++ 111B             _strrev_end:
0036++ 111B 4C          	popa
0037++ 111C 09          	ret
0038++ 111D             	
0039++ 111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 111D             ; _strchr
0041++ 111D             ; search string in d for char in al
0042++ 111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 111D             _strchr:
0044++ 111D             _strchr_l0:
0045++ 111D 32          	mov bl, [d]
0046++ 111E C1 00       	cmp bl, 0
0047++ 1120 C6 2B 11    	je _strchr_end
0048++ 1123 BA          	cmp al, bl
0049++ 1124 C6 2B 11    	je _strchr_end
0050++ 1127 79          	inc d
0051++ 1128 0A 1D 11    	jmp _strchr_l0
0052++ 112B             _strchr_end:
0053++ 112B 1B          	mov al, bl
0054++ 112C 09          	ret
0055++ 112D             
0056++ 112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 112D             ; _strstr
0058++ 112D             ; find sub-string
0059++ 112D             ; str1 in si
0060++ 112D             ; str2 in di
0061++ 112D             ; si points to end of source string
0062++ 112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 112D             _strstr:
0064++ 112D DB          	push al
0065++ 112E DA          	push d
0066++ 112F E3          	push di
0067++ 1130             _strstr_loop:
0068++ 1130 F3          	cmpsb					; compare a byte of the strings
0069++ 1131 C7 3C 11    	jne _strstr_ret
0070++ 1134 FC 00 00    	lea d, [di + 0]
0071++ 1137 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1139 C7 30 11    	jne _strstr_loop				; equal chars but not at end
0073++ 113C             _strstr_ret:
0074++ 113C F0          	pop di
0075++ 113D E7          	pop d
0076++ 113E E8          	pop al
0077++ 113F 09          	ret
0078++ 1140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1140             ; length of null terminated string
0080++ 1140             ; result in c
0081++ 1140             ; pointer in d
0082++ 1140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1140             _strlen:
0084++ 1140 DA          	push d
0085++ 1141 38 00 00    	mov c, 0
0086++ 1144             _strlen_l1:
0087++ 1144 BD 00       	cmp byte [d], 0
0088++ 1146 C6 4E 11    	je _strlen_ret
0089++ 1149 79          	inc d
0090++ 114A 78          	inc c
0091++ 114B 0A 44 11    	jmp _strlen_l1
0092++ 114E             _strlen_ret:
0093++ 114E E7          	pop d
0094++ 114F 09          	ret
0095++ 1150             
0096++ 1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1150             ; strcmp
0098++ 1150             ; compare two strings
0099++ 1150             ; str1 in si
0100++ 1150             ; str2 in di
0101++ 1150             ; create a string compairon instrucion ?????
0102++ 1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1150             _strcmp:
0104++ 1150 DB          	push al
0105++ 1151 DA          	push d
0106++ 1152 E3          	push di
0107++ 1153 E2          	push si
0108++ 1154             _strcmp_loop:
0109++ 1154 F3          	cmpsb					; compare a byte of the strings
0110++ 1155 C7 60 11    	jne _strcmp_ret
0111++ 1158 FB FF FF    	lea d, [si +- 1]
0112++ 115B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 115D C7 54 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1160             _strcmp_ret:
0115++ 1160 EF          	pop si
0116++ 1161 F0          	pop di
0117++ 1162 E7          	pop d
0118++ 1163 E8          	pop al
0119++ 1164 09          	ret
0120++ 1165             
0121++ 1165             
0122++ 1165             ; strcpy
0123++ 1165             ; copy null terminated string from si to di
0124++ 1165             ; source in si
0125++ 1165             ; destination in di
0126++ 1165             _strcpy:
0127++ 1165 E2          	push si
0128++ 1166 E3          	push di
0129++ 1167 DB          	push al
0130++ 1168             _strcpy_l1:
0131++ 1168 F6          	lodsb
0132++ 1169 F7          	stosb
0133++ 116A B9 00       	cmp al, 0
0134++ 116C C7 68 11    	jne _strcpy_l1
0135++ 116F             _strcpy_end:
0136++ 116F E8          	pop al
0137++ 1170 F0          	pop di
0138++ 1171 EF          	pop si
0139++ 1172 09          	ret
0140++ 1173             
0141++ 1173             ; strcat
0142++ 1173             ; concatenate a null terminated string into string at di, from string at si
0143++ 1173             ; source in si
0144++ 1173             ; destination in di
0145++ 1173             _strcat:
0146++ 1173 E2          	push si
0147++ 1174 E3          	push di
0148++ 1175 D7          	push a
0149++ 1176 DA          	push d
0150++ 1177 50          	mov a, di
0151++ 1178 3C          	mov d, a
0152++ 1179             _strcat_goto_end_l1:
0153++ 1179 BD 00       	cmp byte[d], 0
0154++ 117B C6 82 11    	je _strcat_start
0155++ 117E 79          	inc d
0156++ 117F 0A 79 11    	jmp _strcat_goto_end_l1
0157++ 1182             _strcat_start:
0158++ 1182 FD 50       	mov di, d
0159++ 1184             _strcat_l1:
0160++ 1184 F6          	lodsb
0161++ 1185 F7          	stosb
0162++ 1186 B9 00       	cmp al, 0
0163++ 1188 C7 84 11    	jne _strcat_l1
0164++ 118B             _strcat_end:
0165++ 118B E7          	pop d
0166++ 118C E4          	pop a
0167++ 118D F0          	pop di
0168++ 118E EF          	pop si
0169++ 118F 09          	ret
0170++ 1190             
0171++ 1190             
0005+  1190             
0006+  1190             
0007+  1190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1190             ; convert ascii 'o'..'f' to integer 0..15
0009+  1190             ; ascii in bl
0010+  1190             ; result in al
0011+  1190             ; ascii for f = 0100 0110
0012+  1190             ; ascii for 9 = 0011 1001
0013+  1190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1190             hex_ascii_encode:
0015+  1190 1B            mov al, bl
0016+  1191 93 40         test al, $40        ; test if letter or number
0017+  1193 C7 99 11      jnz hex_letter
0018+  1196 87 0F         and al, $0f        ; get number
0019+  1198 09            ret
0020+  1199             hex_letter:
0021+  1199 87 0F         and al, $0f        ; get letter
0022+  119B 6A 09         add al, 9
0023+  119D 09            ret
0024+  119E             
0025+  119E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  119E             ; atoi
0027+  119E             ; 2 letter hex string in b
0028+  119E             ; 8bit integer returned in al
0029+  119E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  119E             _atoi:
0031+  119E D8            push b
0032+  119F 07 90 11      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  11A2 30            mov bl, bh
0034+  11A3 DB            push al          ; save a
0035+  11A4 07 90 11      call hex_ascii_encode
0036+  11A7 EA            pop bl  
0037+  11A8 FD 9E 04      shl al, 4
0038+  11AB 8C            or al, bl
0039+  11AC E5            pop b
0040+  11AD 09            ret  
0041+  11AE             
0042+  11AE             
0043+  11AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  11AE             ; scanf
0045+  11AE             ; no need for explanations!
0046+  11AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  11AE             scanf:
0048+  11AE 09            ret
0049+  11AF             
0050+  11AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  11AF             ; itoa
0052+  11AF             ; 8bit value in bl
0053+  11AF             ; 2 byte ascii result in a
0054+  11AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  11AF             _itoa:
0056+  11AF DA            push d
0057+  11B0 D8            push b
0058+  11B1 A7 00         mov bh, 0
0059+  11B3 FD A4 04      shr bl, 4  
0060+  11B6 74            mov d, b
0061+  11B7 1F 49 14      mov al, [d + s_hex_digits]
0062+  11BA 23            mov ah, al
0063+  11BB               
0064+  11BB E5            pop b
0065+  11BC D8            push b
0066+  11BD A7 00         mov bh, 0
0067+  11BF FD 87 0F      and bl, $0f
0068+  11C2 74            mov d, b
0069+  11C3 1F 49 14      mov al, [d + s_hex_digits]
0070+  11C6 E5            pop b
0071+  11C7 E7            pop d
0072+  11C8 09            ret
0073+  11C9             
0074+  11C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11C9             ; hex string to binary
0076+  11C9             ; di = destination address
0077+  11C9             ; si = source
0078+  11C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11C9             _hex_to_int:
0080+  11C9             _hex_to_int_l1:
0081+  11C9 F6            lodsb          ; load from [si] to al
0082+  11CA B9 00         cmp al, 0        ; check if ascii 0
0083+  11CC C6 D9 11      jz _hex_to_int_ret
0084+  11CF 36            mov bh, al
0085+  11D0 F6            lodsb
0086+  11D1 2F            mov bl, al
0087+  11D2 07 9E 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  11D5 F7            stosb          ; store al to [di]
0089+  11D6 0A C9 11      jmp _hex_to_int_l1
0090+  11D9             _hex_to_int_ret:
0091+  11D9 09            ret    
0092+  11DA             
0093+  11DA             
0094+  11DA             
0095+  11DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11DA             ; getchar
0097+  11DA             ; char in ah
0098+  11DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11DA             getch:
0100+  11DA DB            push al
0101+  11DB             getch_retry:
0102+  11DB 19 01         mov al, 1
0103+  11DD 05 03         syscall sys_io      ; receive in ah
0104+  11DF E8            pop al
0105+  11E0 09            ret
0106+  11E1             
0107+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11E1             ; putchar
0109+  11E1             ; char in ah
0110+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11E1             _putchar:
0112+  11E1 DB            push al
0113+  11E2 19 00         mov al, 0
0114+  11E4 05 03         syscall sys_io      ; char in ah
0115+  11E6 E8            pop al
0116+  11E7 09            ret
0117+  11E8             
0118+  11E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11E8             ;; input a string
0120+  11E8             ;; terminates with null
0121+  11E8             ;; pointer in d
0122+  11E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11E8             _gets:
0124+  11E8 D7            push a
0125+  11E9 DA            push d
0126+  11EA             _gets_loop:
0127+  11EA 19 01         mov al, 1
0128+  11EC 05 03         syscall sys_io      ; receive in ah
0129+  11EE 76 1B         cmp ah, 27
0130+  11F0 C6 11 12      je _gets_ansi_esc
0131+  11F3 76 0A         cmp ah, $0a        ; lf
0132+  11F5 C6 6D 12      je _gets_end
0133+  11F8 76 0D         cmp ah, $0d        ; cr
0134+  11FA C6 6D 12      je _gets_end
0135+  11FD 76 5C         cmp ah, $5c        ; '\\'
0136+  11FF C6 33 12      je _gets_escape
0137+  1202 76 08         cmp ah, $08      ; check for backspace
0138+  1204 C6 0D 12      je _gets_backspace
0139+  1207 1A            mov al, ah
0140+  1208 3E            mov [d], al
0141+  1209 79            inc d
0142+  120A 0A EA 11      jmp _gets_loop
0143+  120D             _gets_backspace:
0144+  120D 7F            dec d
0145+  120E 0A EA 11      jmp _gets_loop
0146+  1211             _gets_ansi_esc:
0147+  1211 19 01         mov al, 1
0148+  1213 05 03         syscall sys_io        ; receive in ah without echo
0149+  1215 76 5B         cmp ah, '['
0150+  1217 C7 EA 11      jne _gets_loop
0151+  121A 19 01         mov al, 1
0152+  121C 05 03         syscall sys_io          ; receive in ah without echo
0153+  121E 76 64         cmp ah, 'd'
0154+  1220 C6 2B 12      je _gets_left_arrow
0155+  1223 76 63         cmp ah, 'c'
0156+  1225 C6 2F 12      je _gets_right_arrow
0157+  1228 0A EA 11      jmp _gets_loop
0158+  122B             _gets_left_arrow:
0159+  122B 7F            dec d
0160+  122C 0A EA 11      jmp _gets_loop
0161+  122F             _gets_right_arrow:
0162+  122F 79            inc d
0163+  1230 0A EA 11      jmp _gets_loop
0164+  1233             _gets_escape:
0165+  1233 19 01         mov al, 1
0166+  1235 05 03         syscall sys_io      ; receive in ah
0167+  1237 76 6E         cmp ah, 'n'
0168+  1239 C6 58 12      je _gets_lf
0169+  123C 76 72         cmp ah, 'r'
0170+  123E C6 5F 12      je _gets_cr
0171+  1241 76 30         cmp ah, '0'
0172+  1243 C6 66 12      je _gets_null
0173+  1246 76 5C         cmp ah, $5c  ; '\'
0174+  1248 C6 51 12      je _gets_slash
0175+  124B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  124C 3E            mov [d], al
0177+  124D 79            inc d
0178+  124E 0A EA 11      jmp _gets_loop
0179+  1251             _gets_slash:
0180+  1251 19 5C         mov al, $5c
0181+  1253 3E            mov [d], al
0182+  1254 79            inc d
0183+  1255 0A EA 11      jmp _gets_loop
0184+  1258             _gets_lf:
0185+  1258 19 0A         mov al, $0a
0186+  125A 3E            mov [d], al
0187+  125B 79            inc d
0188+  125C 0A EA 11      jmp _gets_loop
0189+  125F             _gets_cr:
0190+  125F 19 0D         mov al, $0d
0191+  1261 3E            mov [d], al
0192+  1262 79            inc d
0193+  1263 0A EA 11      jmp _gets_loop
0194+  1266             _gets_null:
0195+  1266 19 00         mov al, $00
0196+  1268 3E            mov [d], al
0197+  1269 79            inc d
0198+  126A 0A EA 11      jmp _gets_loop
0199+  126D             _gets_end:
0200+  126D 19 00         mov al, 0
0201+  126F 3E            mov [d], al        ; terminate string
0202+  1270 E7            pop d
0203+  1271 E4            pop a
0204+  1272 09            ret
0205+  1273             
0206+  1273             
0207+  1273             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1273             ;; input text
0209+  1273             ;; terminated with ctrl+d
0210+  1273             ;; pointer in d
0211+  1273             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1273             _gettxt:
0213+  1273 D7            push a
0214+  1274 DA            push d
0215+  1275             _gettxt_loop:
0216+  1275 19 01         mov al, 1
0217+  1277 05 03         syscall sys_io      ; receive in ah
0218+  1279 76 04         cmp ah, 4      ; eot
0219+  127B C6 B4 12      je _gettxt_end
0220+  127E 76 08         cmp ah, $08      ; check for backspace
0221+  1280 C6 B0 12      je _gettxt_backspace
0222+  1283 76 5C         cmp ah, $5c        ; '\'
0223+  1285 C6 8E 12      je _gettxt_escape
0224+  1288 1A            mov al, ah
0225+  1289 3E            mov [d], al
0226+  128A 79            inc d
0227+  128B 0A 75 12      jmp _gettxt_loop
0228+  128E             _gettxt_escape:
0229+  128E 19 01         mov al, 1
0230+  1290 05 03         syscall sys_io      ; receive in ah
0231+  1292 76 6E         cmp ah, 'n'
0232+  1294 C6 A2 12      je _gettxt_lf
0233+  1297 76 72         cmp ah, 'r'
0234+  1299 C6 A9 12      je _gettxt_cr
0235+  129C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  129D 3E            mov [d], al
0237+  129E 79            inc d
0238+  129F 0A 75 12      jmp _gettxt_loop
0239+  12A2             _gettxt_lf:
0240+  12A2 19 0A         mov al, $0a
0241+  12A4 3E            mov [d], al
0242+  12A5 79            inc d
0243+  12A6 0A 75 12      jmp _gettxt_loop
0244+  12A9             _gettxt_cr:
0245+  12A9 19 0D         mov al, $0d
0246+  12AB 3E            mov [d], al
0247+  12AC 79            inc d
0248+  12AD 0A 75 12      jmp _gettxt_loop
0249+  12B0             _gettxt_backspace:
0250+  12B0 7F            dec d
0251+  12B1 0A 75 12      jmp _gettxt_loop
0252+  12B4             _gettxt_end:
0253+  12B4 19 00         mov al, 0
0254+  12B6 3E            mov [d], al        ; terminate string
0255+  12B7 E7            pop d
0256+  12B8 E4            pop a
0257+  12B9 09            ret
0258+  12BA             
0259+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  12BA             ; print new line
0261+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  12BA             printnl:
0263+  12BA D7            push a
0264+  12BB 10 00 0A      mov a, $0a00
0265+  12BE 05 03         syscall sys_io
0266+  12C0 10 00 0D      mov a, $0d00
0267+  12C3 05 03         syscall sys_io
0268+  12C5 E4            pop a
0269+  12C6 09            ret
0270+  12C7             
0271+  12C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  12C7             ; _strtoint
0273+  12C7             ; 4 digit hex string number in d
0274+  12C7             ; integer returned in a
0275+  12C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12C7             _strtointx:
0277+  12C7 D8            push b
0278+  12C8 32            mov bl, [d]
0279+  12C9 37            mov bh, bl
0280+  12CA 33 01 00      mov bl, [d + 1]
0281+  12CD 07 9E 11      call _atoi        ; convert to int in al
0282+  12D0 23            mov ah, al        ; move to ah
0283+  12D1 33 02 00      mov bl, [d + 2]
0284+  12D4 37            mov bh, bl
0285+  12D5 33 03 00      mov bl, [d + 3]
0286+  12D8 07 9E 11      call _atoi        ; convert to int in al
0287+  12DB E5            pop b
0288+  12DC 09            ret
0289+  12DD             
0290+  12DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  12DD             ; _strtoint
0292+  12DD             ; 5 digit base10 string number in d
0293+  12DD             ; integer returned in a
0294+  12DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  12DD             _strtoint:
0296+  12DD E2            push si
0297+  12DE D8            push b
0298+  12DF D9            push c
0299+  12E0 DA            push d
0300+  12E1 07 40 11      call _strlen      ; get string length in c
0301+  12E4 7E            dec c
0302+  12E5 FD 4E         mov si, d
0303+  12E7 12            mov a, c
0304+  12E8 FD 99         shl a
0305+  12EA 3B 61 14      mov d, table_power
0306+  12ED 59            add d, a
0307+  12EE 38 00 00      mov c, 0
0308+  12F1             _strtoint_l0:
0309+  12F1 F6            lodsb      ; load ascii to al
0310+  12F2 B9 00         cmp al, 0
0311+  12F4 C6 07 13      je _strtoint_end
0312+  12F7 6F 30         sub al, $30    ; make into integer
0313+  12F9 22 00         mov ah, 0
0314+  12FB 2A            mov b, [d]
0315+  12FC AC            mul a, b      ; result in b since it fits in 16bits
0316+  12FD 11            mov a, b
0317+  12FE 28            mov b, c
0318+  12FF 54            add a, b
0319+  1300 39            mov c, a
0320+  1301 63 02 00      sub d, 2
0321+  1304 0A F1 12      jmp _strtoint_l0
0322+  1307             _strtoint_end:
0323+  1307 12            mov a, c
0324+  1308 E7            pop d
0325+  1309 E6            pop c
0326+  130A E5            pop b
0327+  130B EF            pop si
0328+  130C 09            ret
0329+  130D             
0330+  130D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  130D             ; print null terminated string
0332+  130D             ; pointer in d
0333+  130D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  130D             _puts:
0335+  130D D7            push a
0336+  130E DA            push d
0337+  130F             _puts_l1:
0338+  130F 1E            mov al, [d]
0339+  1310 B9 00         cmp al, 0
0340+  1312 C6 1E 13      jz _puts_end
0341+  1315 23            mov ah, al
0342+  1316 19 00         mov al, 0
0343+  1318 05 03         syscall sys_io
0344+  131A 79            inc d
0345+  131B 0A 0F 13      jmp _puts_l1
0346+  131E             _puts_end:
0347+  131E E7            pop d
0348+  131F E4            pop a
0349+  1320 09            ret
0350+  1321             
0351+  1321             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1321             ; print n size string
0353+  1321             ; pointer in d
0354+  1321             ; size in c
0355+  1321             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1321             _putsn:
0357+  1321 DB            push al
0358+  1322 DA            push d
0359+  1323 D9            push c
0360+  1324             _putsn_l0:
0361+  1324 1E            mov al, [d]
0362+  1325 23            mov ah, al
0363+  1326 19 00         mov al, 0
0364+  1328 05 03         syscall sys_io
0365+  132A 79            inc d
0366+  132B 7E            dec c  
0367+  132C C2 00 00      cmp c, 0
0368+  132F C7 24 13      jne _putsn_l0
0369+  1332             _putsn_end:
0370+  1332 E6            pop c
0371+  1333 E7            pop d
0372+  1334 E8            pop al
0373+  1335 09            ret
0374+  1336             
0375+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1336             ; print 16bit decimal number
0377+  1336             ; input number in a
0378+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1336             print_u16d:
0380+  1336 D7            push a
0381+  1337 D8            push b
0382+  1338 FD D8         push g
0383+  133A 26 10 27      mov b, 10000
0384+  133D AE            div a, b      ; get 10000's coeff.
0385+  133E 07 62 13      call print_number
0386+  1341 11            mov a, b
0387+  1342 26 E8 03      mov b, 1000
0388+  1345 AE            div a, b      ; get 1000's coeff.
0389+  1346 07 62 13      call print_number
0390+  1349 11            mov a, b
0391+  134A 26 64 00      mov b, 100
0392+  134D AE            div a, b
0393+  134E 07 62 13      call print_number
0394+  1351 11            mov a, b
0395+  1352 26 0A 00      mov b, 10
0396+  1355 AE            div a, b
0397+  1356 07 62 13      call print_number
0398+  1359 1B            mov al, bl      ; 1's coeff in bl
0399+  135A 07 62 13      call print_number
0400+  135D FD F1         pop g
0401+  135F E5            pop b
0402+  1360 E4            pop a
0403+  1361 09            ret
0404+  1362             
0405+  1362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1362             ; print al
0407+  1362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1362             print_number:
0409+  1362 6A 30         add al, $30
0410+  1364 23            mov ah, al
0411+  1365 07 E1 11      call _putchar
0412+  1368 09            ret
0413+  1369             
0414+  1369             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1369             ; print 16bit hex integer
0416+  1369             ; integer value in reg b
0417+  1369             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1369             print_u16x:
0419+  1369 D7            push a
0420+  136A D8            push b
0421+  136B DD            push bl
0422+  136C 30            mov bl, bh
0423+  136D 07 AF 11      call _itoa        ; convert bh to char in a
0424+  1370 2F            mov bl, al        ; save al
0425+  1371 19 00         mov al, 0
0426+  1373 05 03         syscall sys_io        ; display ah
0427+  1375 24            mov ah, bl        ; retrieve al
0428+  1376 19 00         mov al, 0
0429+  1378 05 03         syscall sys_io        ; display al
0430+  137A             
0431+  137A EA            pop bl
0432+  137B 07 AF 11      call _itoa        ; convert bh to char in a
0433+  137E 2F            mov bl, al        ; save al
0434+  137F 19 00         mov al, 0
0435+  1381 05 03         syscall sys_io        ; display ah
0436+  1383 24            mov ah, bl        ; retrieve al
0437+  1384 19 00         mov al, 0
0438+  1386 05 03         syscall sys_io        ; display al
0439+  1388             
0440+  1388 E5            pop b
0441+  1389 E4            pop a
0442+  138A 09            ret
0443+  138B             
0444+  138B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  138B             ; input 16bit hex integer
0446+  138B             ; read 16bit integer into a
0447+  138B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  138B             scan_u16x:
0449+  138B F8 10 00      enter 16
0450+  138E D8            push b
0451+  138F DA            push d
0452+  1390             
0453+  1390 FA F1 FF      lea d, [bp + -15]
0454+  1393 07 E8 11      call _gets        ; get number
0455+  1396             
0456+  1396 32            mov bl, [d]
0457+  1397 37            mov bh, bl
0458+  1398 33 01 00      mov bl, [d + 1]
0459+  139B 07 9E 11      call _atoi        ; convert to int in al
0460+  139E 23            mov ah, al        ; move to ah
0461+  139F             
0462+  139F 33 02 00      mov bl, [d + 2]
0463+  13A2 37            mov bh, bl
0464+  13A3 33 03 00      mov bl, [d + 3]
0465+  13A6 07 9E 11      call _atoi        ; convert to int in al
0466+  13A9             
0467+  13A9 E7            pop d
0468+  13AA E5            pop b
0469+  13AB F9            leave
0470+  13AC 09            ret
0471+  13AD             
0472+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  13AD             ; print 8bit hex integer
0474+  13AD             ; integer value in reg bl
0475+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  13AD             print_u8x:
0477+  13AD D7            push a
0478+  13AE DD            push bl
0479+  13AF             
0480+  13AF 07 AF 11      call _itoa        ; convert bl to char in a
0481+  13B2 2F            mov bl, al        ; save al
0482+  13B3 19 00         mov al, 0
0483+  13B5 05 03         syscall sys_io        ; display ah
0484+  13B7 24            mov ah, bl        ; retrieve al
0485+  13B8 19 00         mov al, 0
0486+  13BA 05 03         syscall sys_io        ; display al
0487+  13BC             
0488+  13BC EA            pop bl
0489+  13BD E4            pop a
0490+  13BE 09            ret
0491+  13BF             
0492+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  13BF             ; print 8bit decimal unsigned number
0494+  13BF             ; input number in al
0495+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  13BF             print_u8d:
0497+  13BF D7            push a
0498+  13C0 D8            push b
0499+  13C1 FD D8         push g
0500+  13C3 22 00         mov ah, 0
0501+  13C5 26 64 00      mov b, 100
0502+  13C8 AE            div a, b
0503+  13C9 D8            push b      ; save remainder
0504+  13CA B9 00         cmp al, 0
0505+  13CC C6 D6 13      je skip100
0506+  13CF 6A 30         add al, $30
0507+  13D1 23            mov ah, al
0508+  13D2 19 00         mov al, 0
0509+  13D4 05 03         syscall sys_io  ; print coeff
0510+  13D6             skip100:
0511+  13D6 E4            pop a
0512+  13D7 22 00         mov ah, 0
0513+  13D9 26 0A 00      mov b, 10
0514+  13DC AE            div a, b
0515+  13DD D8            push b      ; save remainder
0516+  13DE B9 00         cmp al, 0
0517+  13E0 C6 EA 13      je skip10
0518+  13E3 6A 30         add al, $30
0519+  13E5 23            mov ah, al
0520+  13E6 19 00         mov al, 0
0521+  13E8 05 03         syscall sys_io  ; print coeff
0522+  13EA             skip10:
0523+  13EA E4            pop a
0524+  13EB 1B            mov al, bl
0525+  13EC 6A 30         add al, $30
0526+  13EE 23            mov ah, al
0527+  13EF 19 00         mov al, 0
0528+  13F1 05 03         syscall sys_io  ; print coeff
0529+  13F3 FD F1         pop g
0530+  13F5 E5            pop b
0531+  13F6 E4            pop a
0532+  13F7 09            ret
0533+  13F8             
0534+  13F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  13F8             ; input 8bit hex integer
0536+  13F8             ; read 8bit integer into al
0537+  13F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  13F8             scan_u8x:
0539+  13F8 F8 04 00      enter 4
0540+  13FB D8            push b
0541+  13FC DA            push d
0542+  13FD             
0543+  13FD FA FD FF      lea d, [bp + -3]
0544+  1400 07 E8 11      call _gets        ; get number
0545+  1403             
0546+  1403 32            mov bl, [d]
0547+  1404 37            mov bh, bl
0548+  1405 33 01 00      mov bl, [d + 1]
0549+  1408 07 9E 11      call _atoi        ; convert to int in al
0550+  140B             
0551+  140B E7            pop d
0552+  140C E5            pop b
0553+  140D F9            leave
0554+  140E 09            ret
0555+  140F             
0556+  140F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  140F             ; input decimal number
0558+  140F             ; result in a
0559+  140F             ; 655'\0'
0560+  140F             ; low--------high
0561+  140F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  140F             scan_u16d:
0563+  140F F8 08 00      enter 8
0564+  1412 E2            push si
0565+  1413 D8            push b
0566+  1414 D9            push c
0567+  1415 DA            push d
0568+  1416 FA F9 FF      lea d, [bp +- 7]
0569+  1419 07 E8 11      call _gets
0570+  141C 07 40 11      call _strlen      ; get string length in c
0571+  141F 7E            dec c
0572+  1420 FD 4E         mov si, d
0573+  1422 12            mov a, c
0574+  1423 FD 99         shl a
0575+  1425 3B 61 14      mov d, table_power
0576+  1428 59            add d, a
0577+  1429 38 00 00      mov c, 0
0578+  142C             mul_loop:
0579+  142C F6            lodsb      ; load ascii to al
0580+  142D B9 00         cmp al, 0
0581+  142F C6 42 14      je mul_exit
0582+  1432 6F 30         sub al, $30    ; make into integer
0583+  1434 22 00         mov ah, 0
0584+  1436 2A            mov b, [d]
0585+  1437 AC            mul a, b      ; result in b since it fits in 16bits
0586+  1438 11            mov a, b
0587+  1439 28            mov b, c
0588+  143A 54            add a, b
0589+  143B 39            mov c, a
0590+  143C 63 02 00      sub d, 2
0591+  143F 0A 2C 14      jmp mul_loop
0592+  1442             mul_exit:
0593+  1442 12            mov a, c
0594+  1443 E7            pop d
0595+  1444 E6            pop c
0596+  1445 E5            pop b
0597+  1446 EF            pop si
0598+  1447 F9            leave
0599+  1448 09            ret
0600+  1449             
0601+  1449             
0602+  1449 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  144D 34 35 36 37 
0602+  1451 38 39 61 62 
0602+  1455 63 64 65 66 
0603+  1459 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  145D 1B 5B 68 00 
0604+  1461             
0605+  1461             table_power:
0606+  1461 01 00         .dw 1
0607+  1463 0A 00         .dw 10
0608+  1465 64 00         .dw 100
0609+  1467 E8 03         .dw 1000
0610+  1469 10 27         .dw 100002870   146B             .include "lib/ctype.asm"
0001+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  146B             ; ctype.s
0003+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  146B             
0005+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  146B             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  146B             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  146B             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  146B             ;; characters are supported.
0010+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  146B             ;; _isalnum 
0012+  146B             ;; _isalpha 
0013+  146B             ;; islower 
0014+  146B             ;; isupper 
0015+  146B             ;; _isdigit 
0016+  146B             ;; isxdigit
0017+  146B             ;; iscntrl 
0018+  146B             ;; isgraph 
0019+  146B             ;; _isspace 
0020+  146B             ;; isblank 
0021+  146B             ;; isprint 
0022+  146B             ;; ispunct 
0023+  146B             ;; tolower 
0024+  146B             ;; toupper
0025+  146B             
0026+  146B             
0027+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  146B             ;; is alphanumeric
0029+  146B             ;; sets zf according with result
0030+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  146B             _isalnum:
0032+  146B 07 88 14    	call _isalpha
0033+  146E C6 74 14    	je _isalnum_exit
0034+  1471 07 75 14    	call _isdigit
0035+  1474             _isalnum_exit:
0036+  1474 09          	ret	
0037+  1475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1475             ;; is digit
0039+  1475             ;; sets zf according with result
0040+  1475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1475             _isdigit:
0042+  1475 DB          	push al
0043+  1476 B9 30       	cmp al, '0'
0044+  1478 C8 84 14    	jlu _isdigit_false
0045+  147B B9 39       	cmp al, '9'
0046+  147D D1 84 14    	jgu _isdigit_false
0047+  1480 87 00       	and al, 0	; set zf
0048+  1482 E8          	pop al
0049+  1483 09          	ret
0050+  1484             _isdigit_false:
0051+  1484 8B 01       	or al, 1	; clear zf
0052+  1486 E8          	pop al
0053+  1487 09          	ret	
0054+  1488             	
0055+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1488             ;; is alpha
0057+  1488             ;; sets zf according with result
0058+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1488             _isalpha:
0060+  1488 DB          	push al
0061+  1489 B9 5F       	cmp al, '_'
0062+  148B C6 AB 14    	je _isalpha_true
0063+  148E B9 2E       	cmp al, '.'
0064+  1490 C6 AB 14    	je _isalpha_true
0065+  1493 B9 61       	cmp al, 'a'
0066+  1495 C8 A7 14    	jlu _isalpha_false
0067+  1498 B9 7A       	cmp al, 'z'
0068+  149A D1 A7 14    	jgu _isalpha_false
0069+  149D B9 7A       	cmp al, 'z'
0070+  149F D0 AB 14    	jleu _isalpha_true
0071+  14A2 B9 61       	cmp al, 'a'
0072+  14A4 C9 AB 14    	jgeu _isalpha_true
0073+  14A7             _isalpha_false:
0074+  14A7 8B 01       	or al, 1	; clear zf
0075+  14A9 E8          	pop al
0076+  14AA 09          	ret
0077+  14AB             _isalpha_true:
0078+  14AB 87 00       	and al, 0	; set zf
0079+  14AD E8          	pop al
0080+  14AE 09          	ret
0081+  14AF             
0082+  14AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  14AF             ;; is path-alpha
0084+  14AF             ;; sets zf according with result
0085+  14AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  14AF             ispath:
0087+  14AF DB          	push al
0088+  14B0 07 75 14    	call _isdigit
0089+  14B3 C6 DD 14    	je ispath_true
0090+  14B6 B9 5F       	cmp al, '_'
0091+  14B8 C6 DD 14    	je ispath_true
0092+  14BB B9 2F       	cmp al, '/'
0093+  14BD C6 DD 14    	je ispath_true
0094+  14C0 B9 2E       	cmp al, '.'
0095+  14C2 C6 DD 14    	je ispath_true
0096+  14C5 B9 61       	cmp al, 'a'
0097+  14C7 C8 D9 14    	jlu ispath_false
0098+  14CA B9 7A       	cmp al, 'z'
0099+  14CC D1 D9 14    	jgu ispath_false
0100+  14CF B9 7A       	cmp al, 'z'
0101+  14D1 D0 DD 14    	jleu ispath_true
0102+  14D4 B9 61       	cmp al, 'a'
0103+  14D6 C9 DD 14    	jgeu ispath_true
0104+  14D9             ispath_false:
0105+  14D9 8B 01       	or al, 1	; clear zf
0106+  14DB E8          	pop al
0107+  14DC 09          	ret
0108+  14DD             ispath_true:
0109+  14DD 87 00       	and al, 0	; set zf
0110+  14DF E8          	pop al
0111+  14E0 09          	ret
0112+  14E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14E1             ;; is space
0114+  14E1             ;; sets zf according with result
0115+  14E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14E1             _isspace:
0117+  14E1 B9 20       	cmp al, $20		; ' '
0118+  14E3 C6 F7 14    	je _isspace_exit
0119+  14E6 B9 09       	cmp al, $09		; '\t'
0120+  14E8 C6 F7 14    	je _isspace_exit
0121+  14EB B9 0A       	cmp al, $0a		; '\n'
0122+  14ED C6 F7 14    	je _isspace_exit
0123+  14F0 B9 0D       	cmp al, $0d		; '\r'
0124+  14F2 C6 F7 14    	je _isspace_exit
0125+  14F5 B9 0B       	cmp al, $0b		; '\v'
0126+  14F7             _isspace_exit:
0127+  14F7 09          	ret	
0128+  14F8             
0129+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  14F8             ; to lower
0131+  14F8             ; input in al
0132+  14F8             ; output in al
0133+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  14F8             _to_lower:
0135+  14F8 B9 7A       	cmp al, 'z'
0136+  14FA D1 FF 14    	jgu _to_lower_ret
0137+  14FD 6A 20       	add al, $20				; convert to lower case
0138+  14FF             _to_lower_ret:
0139+  14FF 09          	ret
0140+  1500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1500             ; to upper
0142+  1500             ; input in al
0143+  1500             ; output in al
0144+  1500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1500             _to_upper:
0146+  1500 B9 61       	cmp al, 'a'
0147+  1502 C8 07 15    	jlu _to_upper_ret
0148+  1505 6F 20       	sub al, $20			; convert to upper case
0149+  1507             _to_upper_ret:
0150+  1507 09          	ret
0151+  1508             
2871   1508             .include "lib/token.asm"
0001+  1508             toktyp_identifier  .equ 0
0002+  1508             toktyp_keyword     .equ 1
0003+  1508             toktyp_delimiter   .equ 2
0004+  1508             toktyp_string      .equ 3
0005+  1508             toktyp_char        .equ 4
0006+  1508             toktyp_numeric     .equ 5
0007+  1508             toktyp_end         .equ 6
0008+  1508             
0009+  1508             tok_null           .equ 0
0010+  1508             tok_fslash         .equ 1
0011+  1508             tok_times          .equ 2
0012+  1508             tok_plus           .equ 3
0013+  1508             tok_minus          .equ 4
0014+  1508             tok_dot            .equ 5
0015+  1508             tok_semi           .equ 6
0016+  1508             tok_angle          .equ 7
0017+  1508             tok_tilde          .equ 8
0018+  1508             tok_equal          .equ 9
0019+  1508             tok_colon          .equ 10
0020+  1508             tok_comma          .equ 11
0021+  1508             
0022+  1508             tok_end            .equ 20
0023+  1508             
0024+  1508             
0025+  1508             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1508             ;; read a full command argment from shell input buffer
0027+  1508             ;; argument is written into tokstr
0028+  1508             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1508             get_arg:
0030+  1508 D7            push a
0031+  1509 E2            push si
0032+  150A E3            push di
0033+  150B 19 00         mov al, 0
0034+  150D 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0035+  1510 14 32 17      mov a, [prog]
0036+  1513 4D            mov si, a
0037+  1514 FD 4F 36 17   mov di, tokstr
0038+  1518             get_arg_skip_spaces:
0039+  1518 F6            lodsb
0040+  1519 07 E1 14      call _isspace
0041+  151C C6 18 15      je get_arg_skip_spaces
0042+  151F             get_arg_l0:
0043+  151F B9 3B         cmp al, $3b        ; check if is ';'
0044+  1521 C6 2E 15      je get_arg_end
0045+  1524 B9 00         cmp al, 0
0046+  1526 C6 2E 15      je get_arg_end      ; check if end of input
0047+  1529 F7            stosb
0048+  152A F6            lodsb
0049+  152B 0A 1F 15      jmp get_arg_l0
0050+  152E             get_arg_end:
0051+  152E 19 00         mov al, 0
0052+  1530 F7            stosb
0053+  1531 D5 01 00      sub si, 1
0054+  1534 4E            mov a, si
0055+  1535 42 32 17      mov [prog], a    ; update pointer
0056+  1538 F0            pop di
0057+  1539 EF            pop si
0058+  153A E4            pop a
0059+  153B 09            ret
0060+  153C             
0061+  153C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  153C             ;; read a path formation from shell input buffer
0063+  153C             ;; path is written into tokstr
0064+  153C             ;; /usr/bin
0065+  153C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  153C             get_path:
0067+  153C D7            push a
0068+  153D E2            push si
0069+  153E E3            push di
0070+  153F 19 00         mov al, 0
0071+  1541 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0072+  1544 14 32 17      mov a, [prog]
0073+  1547 4D            mov si, a
0074+  1548 FD 4F 36 17   mov di, tokstr
0075+  154C             get_path_skip_spaces:
0076+  154C F6            lodsb
0077+  154D 07 E1 14      call _isspace
0078+  1550 C6 4C 15      je get_path_skip_spaces
0079+  1553             get_path_is_pathchar:
0080+  1553 F7            stosb
0081+  1554 F6            lodsb
0082+  1555 07 6B 14      call _isalnum      ;check if is alphanumeric
0083+  1558 C6 53 15      je get_path_is_pathchar
0084+  155B B9 2F         cmp al, '/'        ; check if is '/'
0085+  155D C6 53 15      je get_path_is_pathchar
0086+  1560 19 00         mov al, 0
0087+  1562 F7            stosb
0088+  1563 D5 01 00      sub si, 1
0089+  1566 4E            mov a, si
0090+  1567 42 32 17      mov [prog], a    ; update pointer
0091+  156A             get_path_end:
0092+  156A F0            pop di
0093+  156B EF            pop si
0094+  156C E4            pop a
0095+  156D 09            ret
0096+  156E             
0097+  156E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  156E             ;; read a line
0099+  156E             ;; line is written into tokstr
0100+  156E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  156E             get_line:
0102+  156E D7            push a
0103+  156F E2            push si
0104+  1570 E3            push di
0105+  1571 19 00         mov al, 0
0106+  1573 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0107+  1576 14 32 17      mov a, [prog]
0108+  1579 4D            mov si, a
0109+  157A FD 4F 36 17   mov di, tokstr
0110+  157E             get_line_l0:
0111+  157E F6            lodsb
0112+  157F B9 0A         cmp al, $0a    ; check for new line
0113+  1581 C6 88 15      je get_line_exit
0114+  1584 F7            stosb
0115+  1585 0A 7E 15      jmp get_line_l0
0116+  1588             get_line_exit:
0117+  1588 19 00         mov al, 0
0118+  158A F7            stosb
0119+  158B 4E            mov a, si
0120+  158C 42 32 17      mov [prog], a    ; update pointer
0121+  158F F0            pop di
0122+  1590 EF            pop si
0123+  1591 E4            pop a
0124+  1592 09            ret
0125+  1593             
0126+  1593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1593             ;; token parser
0128+  1593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1593             get_token:
0130+  1593 D7            push a
0131+  1594 DA            push d
0132+  1595 E2            push si
0133+  1596 E3            push di
0134+  1597 19 00         mov al, 0
0135+  1599 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0136+  159C 19 00         mov al, tok_null
0137+  159E 3D 35 17      mov [tok], al        ; nullify token
0138+  15A1 14 32 17      mov a, [prog]
0139+  15A4 4D            mov si, a
0140+  15A5 FD 4F 36 17   mov di, tokstr
0141+  15A9             get_tok_skip_spaces:
0142+  15A9 F6            lodsb
0143+  15AA 07 E1 14      call _isspace
0144+  15AD C6 A9 15      je get_tok_skip_spaces
0145+  15B0 B9 00         cmp al, 0      ; check for end of input (null)
0146+  15B2 C6 97 16      je get_token_end
0147+  15B5 B9 23         cmp al, '#'      ; comments!
0148+  15B7 C6 C5 16      je get_tok_comment
0149+  15BA 07 6B 14      call _isalnum
0150+  15BD C6 A4 16      jz is_alphanumeric
0151+  15C0             ; other token types
0152+  15C0             get_token_slash:
0153+  15C0 B9 2F         cmp al, '/'        ; check if '/'
0154+  15C2 C7 DA 15      jne get_token_minus
0155+  15C5 F7            stosb          ; store '/' into token string
0156+  15C6 19 00         mov al, 0
0157+  15C8 F7            stosb          ; terminate token string
0158+  15C9 19 01         mov al, tok_fslash
0159+  15CB 3D 35 17      mov [tok], al      
0160+  15CE 19 02         mov al, toktyp_delimiter
0161+  15D0 3D 34 17      mov [toktyp], al
0162+  15D3 4E            mov a, si
0163+  15D4 42 32 17      mov [prog], a    ; update pointer
0164+  15D7 0A C0 16      jmp get_token_return
0165+  15DA             get_token_minus:
0166+  15DA B9 2D         cmp al, '-'        ; check if '-'
0167+  15DC C7 F4 15      jne get_token_comma
0168+  15DF F7            stosb          ; store '-' into token string
0169+  15E0 19 00         mov al, 0
0170+  15E2 F7            stosb          ; terminate token string
0171+  15E3 19 04         mov al, tok_minus
0172+  15E5 3D 35 17      mov [tok], al      
0173+  15E8 19 02         mov al, toktyp_delimiter
0174+  15EA 3D 34 17      mov [toktyp], al
0175+  15ED 4E            mov a, si
0176+  15EE 42 32 17      mov [prog], a    ; update pointer
0177+  15F1 0A C0 16      jmp get_token_return
0178+  15F4             get_token_comma:
0179+  15F4 B9 2C         cmp al, ','        ; check if ','
0180+  15F6 C7 0E 16      jne get_token_semi
0181+  15F9 F7            stosb          ; store ',' into token string
0182+  15FA 19 00         mov al, 0
0183+  15FC F7            stosb          ; terminate token string
0184+  15FD 19 0B         mov al, tok_comma
0185+  15FF 3D 35 17      mov [tok], al      
0186+  1602 19 02         mov al, toktyp_delimiter
0187+  1604 3D 34 17      mov [toktyp], al
0188+  1607 4E            mov a, si
0189+  1608 42 32 17      mov [prog], a    ; update pointer
0190+  160B 0A C0 16      jmp get_token_return
0191+  160E             get_token_semi:
0192+  160E B9 3B         cmp al, $3b        ; check if ';'
0193+  1610 C7 28 16      jne get_token_colon
0194+  1613 F7            stosb          ; store ';' into token string
0195+  1614 19 00         mov al, 0
0196+  1616 F7            stosb          ; terminate token string
0197+  1617 19 06         mov al, tok_semi
0198+  1619 3D 35 17      mov [tok], al      
0199+  161C 19 02         mov al, toktyp_delimiter
0200+  161E 3D 34 17      mov [toktyp], al
0201+  1621 4E            mov a, si
0202+  1622 42 32 17      mov [prog], a    ; update pointer
0203+  1625 0A C0 16      jmp get_token_return
0204+  1628             get_token_colon:
0205+  1628 B9 3A         cmp al, $3a        ; check if ':'
0206+  162A C7 42 16      jne get_token_angle
0207+  162D F7            stosb          ; store ':' into token string
0208+  162E 19 00         mov al, 0
0209+  1630 F7            stosb          ; terminate token string
0210+  1631 19 0A         mov al, tok_colon
0211+  1633 3D 35 17      mov [tok], al      
0212+  1636 19 02         mov al, toktyp_delimiter
0213+  1638 3D 34 17      mov [toktyp], al
0214+  163B 4E            mov a, si
0215+  163C 42 32 17      mov [prog], a    ; update pointer
0216+  163F 0A C0 16      jmp get_token_return
0217+  1642             get_token_angle:
0218+  1642 B9 3E         cmp al, $3e        ; check if '>'
0219+  1644 C7 5C 16      jne get_token_tilde
0220+  1647 F7            stosb          ; store '>' into token string
0221+  1648 19 00         mov al, 0
0222+  164A F7            stosb          ; terminate token string
0223+  164B 19 07         mov al, tok_angle
0224+  164D 3D 35 17      mov [tok], al      
0225+  1650 19 02         mov al, toktyp_delimiter
0226+  1652 3D 34 17      mov [toktyp], al
0227+  1655 4E            mov a, si
0228+  1656 42 32 17      mov [prog], a    ; update pointer
0229+  1659 0A C0 16      jmp get_token_return
0230+  165C             get_token_tilde:
0231+  165C B9 7E         cmp al, '~'        ; check if '~'
0232+  165E C7 76 16      jne get_token_equal
0233+  1661 F7            stosb          ; store '~' into token string
0234+  1662 19 00         mov al, 0
0235+  1664 F7            stosb          ; terminate token string
0236+  1665 19 08         mov al, tok_tilde
0237+  1667 3D 35 17      mov [tok], al      
0238+  166A 19 02         mov al, toktyp_delimiter
0239+  166C 3D 34 17      mov [toktyp], al
0240+  166F 4E            mov a, si
0241+  1670 42 32 17      mov [prog], a    ; update pointer
0242+  1673 0A C0 16      jmp get_token_return
0243+  1676             get_token_equal:
0244+  1676 B9 3D         cmp al, '='        ; check if '='
0245+  1678 C7 90 16      jne get_token_skip
0246+  167B F7            stosb          ; store '=' into token string
0247+  167C 19 00         mov al, 0
0248+  167E F7            stosb          ; terminate token string
0249+  167F 19 09         mov al, tok_equal
0250+  1681 3D 35 17      mov [tok], al      
0251+  1684 19 02         mov al, toktyp_delimiter
0252+  1686 3D 34 17      mov [toktyp], al
0253+  1689 4E            mov a, si
0254+  168A 42 32 17      mov [prog], a    ; update pointer
0255+  168D 0A C0 16      jmp get_token_return
0256+  1690             get_token_skip:
0257+  1690 4E            mov a, si
0258+  1691 42 32 17      mov [prog], a    ; update pointer
0259+  1694 0A C0 16      jmp get_token_return
0260+  1697             get_token_end:        ; end of file token
0261+  1697 19 14         mov al, tok_end
0262+  1699 3D 35 17      mov [tok], al
0263+  169C 19 06         mov al, toktyp_end
0264+  169E 3D 34 17      mov [toktyp], al
0265+  16A1 0A C0 16      jmp get_token_return
0266+  16A4             is_alphanumeric:
0267+  16A4 F7            stosb
0268+  16A5 F6            lodsb
0269+  16A6 07 6B 14      call _isalnum      ;check if is alphanumeric
0270+  16A9 C6 A4 16      jz is_alphanumeric
0271+  16AC B9 2E         cmp al, $2e        ; check if is '.'
0272+  16AE C6 A4 16      je is_alphanumeric
0273+  16B1 19 00         mov al, 0
0274+  16B3 F7            stosb
0275+  16B4 19 00         mov al, toktyp_identifier
0276+  16B6 3D 34 17      mov [toktyp], al
0277+  16B9 D5 01 00      sub si, 1
0278+  16BC 4E            mov a, si
0279+  16BD 42 32 17      mov [prog], a    ; update pointer
0280+  16C0             get_token_return:
0281+  16C0 F0            pop di
0282+  16C1 EF            pop si
0283+  16C2 E7            pop d
0284+  16C3 E4            pop a
0285+  16C4 09            ret
0286+  16C5             get_tok_comment:
0287+  16C5 F6            lodsb
0288+  16C6 B9 0A         cmp al, $0a      ; new line
0289+  16C8 C7 C5 16      jne get_tok_comment
0290+  16CB 0A A9 15      jmp get_tok_skip_spaces
0291+  16CE             
0292+  16CE             
0293+  16CE             get_number:
0294+  16CE D7            push a
0295+  16CF DA            push d
0296+  16D0 E2            push si
0297+  16D1 E3            push di
0298+  16D2 19 00         mov al, 0
0299+  16D4 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0300+  16D7 19 00         mov al, tok_null
0301+  16D9 3D 35 17      mov [tok], al        ; nullify token
0302+  16DC 14 32 17      mov a, [prog]
0303+  16DF 4D            mov si, a
0304+  16E0 FD 4F 36 17   mov di, tokstr
0305+  16E4             get_number_skip_spaces:
0306+  16E4 F6            lodsb
0307+  16E5 07 E1 14      call _isspace
0308+  16E8 C6 E4 16      je get_number_skip_spaces
0309+  16EB B9 00         cmp al, 0      ; check for end of input (null)
0310+  16ED C7 FD 16      jne get_number_l0
0311+  16F0 19 14         mov al, tok_end
0312+  16F2 3D 35 17      mov [tok], al
0313+  16F5 19 06         mov al, toktyp_end
0314+  16F7 3D 34 17      mov [toktyp], al
0315+  16FA 0A 14 17      jmp get_number_return
0316+  16FD             get_number_l0:
0317+  16FD F7            stosb
0318+  16FE F6            lodsb
0319+  16FF 07 75 14      call _isdigit      ;check if is numeric
0320+  1702 C6 FD 16      jz get_number_l0
0321+  1705 19 00         mov al, 0
0322+  1707 F7            stosb
0323+  1708 19 05         mov al, toktyp_numeric
0324+  170A 3D 34 17      mov [toktyp], al
0325+  170D D5 01 00      sub si, 1
0326+  1710 4E            mov a, si
0327+  1711 42 32 17      mov [prog], a    ; update pointer
0328+  1714             get_number_return:
0329+  1714 F0            pop di
0330+  1715 EF            pop si
0331+  1716 E7            pop d
0332+  1717 E4            pop a
0333+  1718 09            ret
0334+  1719             
0335+  1719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1719             ;; put back token
0337+  1719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1719             _putback:
0339+  1719 D7            push a
0340+  171A E2            push si
0341+  171B FD 4D 36 17   mov si, tokstr  
0342+  171F             _putback_loop:
0343+  171F F6            lodsb
0344+  1720 B9 00         cmp al, 0
0345+  1722 C6 2F 17      je _putback_end
0346+  1725 14 32 17      mov a, [prog]
0347+  1728 7D            dec a
0348+  1729 42 32 17      mov [prog], a      ; update pointer
0349+  172C 0A 1F 17      jmp _putback_loop
0350+  172F             _putback_end:
0351+  172F EF            pop si
0352+  1730 E4            pop a
0353+  1731 09            ret
0354+  1732             
0355+  1732             
0356+  1732             
0357+  1732             
0358+  1732 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1734             
0360+  1734 00          toktyp:    .db 0          ; token type symbol
0361+  1735 00          tok:       .db 0          ; current token symbol
0362+  1736 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  173A 00 00 00 00 
0362+  173E 00 00 00 00 
0362+  1742 00 00 00 00 
0362+  1746 00 00 00 00 
0362+  174A 00 00 00 00 
0362+  174E 00 00 00 00 
0362+  1752 00 00 00 00 
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
0362+  176E 00 00 00 00 
0362+  1772 00 00 00 00 
0362+  1776 00 00 00 00 
0362+  177A 00 00 00 00 
0362+  177E 00 00 00 00 
0362+  1782 00 00 00 00 
0362+  1786 00 00 00 00 
0362+  178A 00 00 00 00 
0362+  178E 00 00 00 00 
0362+  1792 00 00 00 00 
0362+  1796 00 00 00 00 
0362+  179A 00 00 00 00 
0362+  179E 00 00 00 00 
0362+  17A2 00 00 00 00 
0362+  17A6 00 00 00 00 
0362+  17AA 00 00 00 00 
0362+  17AE 00 00 00 00 
0362+  17B2 00 00 00 00 
0362+  17B6 00 00 00 00 
0362+  17BA 00 00 00 00 
0362+  17BE 00 00 00 00 
0362+  17C2 00 00 00 00 
0362+  17C6 00 00 00 00 
0362+  17CA 00 00 00 00 
0362+  17CE 00 00 00 00 
0362+  17D2 00 00 00 00 
0362+  17D6 00 00 00 00 
0362+  17DA 00 00 00 00 
0362+  17DE 00 00 00 00 
0362+  17E2 00 00 00 00 
0362+  17E6 00 00 00 00 
0362+  17EA 00 00 00 00 
0362+  17EE 00 00 00 00 
0362+  17F2 00 00 00 00 
0362+  17F6 00 00 00 00 
0362+  17FA 00 00 00 00 
0362+  17FE 00 00 00 00 
0362+  1802 00 00 00 00 
0362+  1806 00 00 00 00 
0362+  180A 00 00 00 00 
0362+  180E 00 00 00 00 
0362+  1812 00 00 00 00 
0362+  1816 00 00 00 00 
0362+  181A 00 00 00 00 
0362+  181E 00 00 00 00 
0362+  1822 00 00 00 00 
0362+  1826 00 00 00 00 
0362+  182A 00 00 00 00 
0362+  182E 00 00 00 00 
0362+  1832 00 00 00 00 
2872   1836             
2873   1836             ; kernel parameters
2874   1836             sys_debug_mode:
2875   1836 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2876   1837             sys_echo_on:
2877   1837 01            .db 1
2878   1838             sys_uart0_lcr:
2879   1838 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2880   1839             sys_uart0_inten:
2881   1839 01            .db 1
2882   183A             sys_uart0_fifoen:
2883   183A 00            .db 0
2884   183B             sys_uart0_div0:
2885   183B 03            .db 3
2886   183C             sys_uart0_div1:
2887   183C 00            .db 0   ; default baud = 38400
2888   183D             ; baud  divisor
2889   183D             ; 50    2304
2890   183D             ; 110   1047
2891   183D             ; 300    384
2892   183D             ; 600    192
2893   183D             ; 1200    96
2894   183D             ; 9600    12
2895   183D             ; 19200    6
2896   183D             ; 38400    3
2897   183D             
2898   183D             nbr_active_procs:
2899   183D 00            .db 0
2900   183E             active_proc_index:
2901   183E 01            .db 1
2902   183F             
2903   183F             index:
2904   183F 00 00         .dw 0
2905   1841             buffer_addr:
2906   1841 00 00         .dw 0
2907   1843             
2908   1843             fifo_in:
2909   1843 A4 1F         .dw fifo
2910   1845             fifo_out:
2911   1845 A4 1F         .dw fifo
2912   1847             
2913   1847             ; file system variables
2914   1847             current_dir_id:
2915   1847 00 00         .dw 0     ; keep dirid of current directory
2916   1849             s_init_path:
2917   1849 2F 73 62 69   .db "/sbin/init", 0
2917   184D 6E 2F 69 6E 
2917   1851 69 74 00 
2918   1854             
2919   1854             s_uname:
2920   1854 73 6F 6C 61   .db "solarium v.1.0", 0
2920   1858 72 69 75 6D 
2920   185C 20 76 2E 31 
2920   1860 2E 30 00 
2921   1863             s_dataentry:
2922   1863 3E 20 00      .db "> ", 0
2923   1866             s_parent_dir:
2924   1866 2E 2E 00      .db "..", 0
2925   1869             s_current_dir:
2926   1869 2E 00         .db ".", 0
2927   186B             s_fslash:
2928   186B 2F 00         .db "/", 0
2929   186D             file_attrib:
2930   186D 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2930   1871 78 
2931   1872             file_type:
2932   1872 2D 64 63      .db "-dc"
2933   1875             s_ps_header:
2934   1875 70 69 64 20   .db "pid command\n", 0
2934   1879 63 6F 6D 6D 
2934   187D 61 6E 64 0A 
2934   1881 00 
2935   1882             s_ls_total:
2936   1882 74 6F 74 61   .db "total: ", 0
2936   1886 6C 3A 20 00 
2937   188A             
2938   188A             s_int_en:
2939   188A 69 72 71 73   .db "irqs enabled\n", 0
2939   188E 20 65 6E 61 
2939   1892 62 6C 65 64 
2939   1896 0A 00 
2940   1898             s_kernel_started:
2941   1898 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2941   189C 65 6C 20 73 
2941   18A0 74 61 72 74 
2941   18A4 65 64 28 76 
2941   18A8 65 72 73 69 
2941   18AC 6F 6E 20 31 
2941   18B0 2E 30 29 0A 
2941   18B4 00 
2942   18B5             s_prompt_init:
2943   18B5 73 74 61 72   .db "starting init\n", 0
2943   18B9 74 69 6E 67 
2943   18BD 20 69 6E 69 
2943   18C1 74 0A 00 
2944   18C4             s_priviledge:
2945   18C4 0A 65 78 63   .db "\nexception: privilege\n", 0
2945   18C8 65 70 74 69 
2945   18CC 6F 6E 3A 20 
2945   18D0 70 72 69 76 
2945   18D4 69 6C 65 67 
2945   18D8 65 0A 00 
2946   18DB             s_divzero:
2947   18DB 0A 65 78 63   .db "\nexception: zero division\n", 0
2947   18DF 65 70 74 69 
2947   18E3 6F 6E 3A 20 
2947   18E7 7A 65 72 6F 
2947   18EB 20 64 69 76 
2947   18EF 69 73 69 6F 
2947   18F3 6E 0A 00 
2948   18F6             
2949   18F6             s_set_year:
2950   18F6 79 65 61 72   .db "year: ", 0
2950   18FA 3A 20 00 
2951   18FD             s_set_month:
2952   18FD 6D 6F 6E 74   .db "month: ", 0
2952   1901 68 3A 20 00 
2953   1905             s_set_day:
2954   1905 64 61 79 3A   .db "day: ", 0
2954   1909 20 00 
2955   190B             s_set_week:
2956   190B 77 65 65 6B   .db "weekday: ", 0
2956   190F 64 61 79 3A 
2956   1913 20 00 
2957   1915             s_set_hours:
2958   1915 68 6F 75 72   .db "hours: ", 0
2958   1919 73 3A 20 00 
2959   191D             s_set_minutes:
2960   191D 6D 69 6E 75   .db "minutes: ", 0
2960   1921 74 65 73 3A 
2960   1925 20 00 
2961   1927             s_set_seconds:
2962   1927 73 65 63 6F   .db "seconds: ", 0
2962   192B 6E 64 73 3A 
2962   192F 20 00 
2963   1931             s_months:      
2964   1931 20 20 20 00   .db "   ", 0
2965   1935 6A 61 6E 00   .db "jan", 0
2966   1939 66 65 62 00   .db "feb", 0
2967   193D 6D 61 72 00   .db "mar", 0
2968   1941 61 70 72 00   .db "apr", 0
2969   1945 6D 61 79 00   .db "may", 0
2970   1949 6A 75 6E 00   .db "jun", 0
2971   194D 6A 75 6C 00   .db "jul", 0
2972   1951 61 75 67 00   .db "aug", 0
2973   1955 73 65 70 00   .db "sep", 0
2974   1959 6F 63 74 00   .db "oct", 0
2975   195D 6E 6F 76 00   .db "nov", 0
2976   1961 64 65 63 00   .db "dec", 0
2977   1965             
2978   1965             s_week:        
2979   1965 73 75 6E 00   .db "sun", 0 
2980   1969 6D 6F 6E 00   .db "mon", 0 
2981   196D 74 75 65 00   .db "tue", 0 
2982   1971 77 65 64 00   .db "wed", 0 
2983   1975 74 68 75 00   .db "thu", 0 
2984   1979 66 72 69 00   .db "fri", 0 
2985   197D 73 61 74 00   .db "sat", 0
2986   1981             
2987   1981 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2987   1985 30 20 45 78 
2987   1989 65 63 75 74 
2987   198D 65 64 2E 0A 
2987   1991 00 
2988   1992             s_fdc_config:
2989   1992 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2989   1996 65 63 74 69 
2989   199A 6E 67 20 64 
2989   199E 69 73 6B 65 
2989   19A2 74 74 65 20 
2989   19A6 64 72 69 76 
2989   19AA 65 20 30 2C 
2989   19AE 20 73 69 64 
2989   19B2 65 20 30 2C 
2989   19B6 20 73 69 6E 
2989   19BA 67 6C 65 20 
2989   19BE 64 65 6E 73 
2989   19C2 69 74 79 2C 
2989   19C6 20 68 65 61 
2989   19CA 64 20 6C 6F 
2989   19CE 61 64 65 64 
2989   19D2 0A 00 
2990   19D4             
2991   19D4             proc_state_table:   
2992   19D4 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2992   19D8 00 00 00 00 
2992   19DC 00 00 00 00 
2992   19E0 00 00 00 00 
2992   19E4 00 00 00 00 
2992   19E8 00 00 00 00 
2992   19EC 00 00 00 00 
2992   19F0 00 00 00 00 
2992   19F4 00 00 00 00 
2992   19F8 00 00 00 00 
2992   19FC 00 00 00 00 
2992   1A00 00 00 00 00 
2992   1A04 00 00 00 00 
2992   1A08 00 00 00 00 
2992   1A0C 00 00 00 00 
2992   1A10 00 00 00 00 
2992   1A14 00 00 00 00 
2992   1A18 00 00 00 00 
2992   1A1C 00 00 00 00 
2992   1A20 00 00 00 00 
2992   1A24 00 00 00 00 
2992   1A28 00 00 00 00 
2992   1A2C 00 00 00 00 
2992   1A30 00 00 00 00 
2992   1A34 00 00 00 00 
2992   1A38 00 00 00 00 
2992   1A3C 00 00 00 00 
2992   1A40 00 00 00 00 
2992   1A44 00 00 00 00 
2992   1A48 00 00 00 00 
2992   1A4C 00 00 00 00 
2992   1A50 00 00 00 00 
2992   1A54 00 00 00 00 
2992   1A58 00 00 00 00 
2992   1A5C 00 00 00 00 
2992   1A60 00 00 00 00 
2992   1A64 00 00 00 00 
2992   1A68 00 00 00 00 
2992   1A6C 00 00 00 00 
2992   1A70 00 00 00 00 
2992   1A74 00 00 00 00 
2992   1A78 00 00 00 00 
2992   1A7C 00 00 00 00 
2992   1A80 00 00 00 00 
2992   1A84 00 00 00 00 
2992   1A88 00 00 00 00 
2992   1A8C 00 00 00 00 
2992   1A90 00 00 00 00 
2992   1A94 00 00 00 00 
2992   1A98 00 00 00 00 
2992   1A9C 00 00 00 00 
2992   1AA0 00 00 00 00 
2992   1AA4 00 00 00 00 
2992   1AA8 00 00 00 00 
2992   1AAC 00 00 00 00 
2992   1AB0 00 00 00 00 
2992   1AB4 00 00 00 00 
2992   1AB8 00 00 00 00 
2992   1ABC 00 00 00 00 
2992   1AC0 00 00 00 00 
2992   1AC4 00 00 00 00 
2992   1AC8 00 00 00 00 
2992   1ACC 00 00 00 00 
2992   1AD0 00 00 00 00 
2992   1AD4 00 00 00 00 
2992   1AD8 00 00 00 00 
2992   1ADC 00 00 00 00 
2992   1AE0 00 00 00 00 
2992   1AE4 00 00 00 00 
2992   1AE8 00 00 00 00 
2992   1AEC 00 00 00 00 
2992   1AF0 00 00 00 00 
2992   1AF4 00 00 00 00 
2992   1AF8 00 00 00 00 
2992   1AFC 00 00 00 00 
2992   1B00 00 00 00 00 
2992   1B04 00 00 00 00 
2992   1B08 00 00 00 00 
2992   1B0C 00 00 00 00 
2992   1B10 00 00 00 00 
2993   1B14             proc_availab_table: 
2994   1B14 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2994   1B18 00 00 00 00 
2994   1B1C 00 00 00 00 
2994   1B20 00 00 00 00 
2995   1B24             proc_names:
2996   1B24 00 00 00 00   .fill 16 * 32, 0  ; process names
2996   1B28 00 00 00 00 
2996   1B2C 00 00 00 00 
2996   1B30 00 00 00 00 
2996   1B34 00 00 00 00 
2996   1B38 00 00 00 00 
2996   1B3C 00 00 00 00 
2996   1B40 00 00 00 00 
2996   1B44 00 00 00 00 
2996   1B48 00 00 00 00 
2996   1B4C 00 00 00 00 
2996   1B50 00 00 00 00 
2996   1B54 00 00 00 00 
2996   1B58 00 00 00 00 
2996   1B5C 00 00 00 00 
2996   1B60 00 00 00 00 
2996   1B64 00 00 00 00 
2996   1B68 00 00 00 00 
2996   1B6C 00 00 00 00 
2996   1B70 00 00 00 00 
2996   1B74 00 00 00 00 
2996   1B78 00 00 00 00 
2996   1B7C 00 00 00 00 
2996   1B80 00 00 00 00 
2996   1B84 00 00 00 00 
2996   1B88 00 00 00 00 
2996   1B8C 00 00 00 00 
2996   1B90 00 00 00 00 
2996   1B94 00 00 00 00 
2996   1B98 00 00 00 00 
2996   1B9C 00 00 00 00 
2996   1BA0 00 00 00 00 
2996   1BA4 00 00 00 00 
2996   1BA8 00 00 00 00 
2996   1BAC 00 00 00 00 
2996   1BB0 00 00 00 00 
2996   1BB4 00 00 00 00 
2996   1BB8 00 00 00 00 
2996   1BBC 00 00 00 00 
2996   1BC0 00 00 00 00 
2996   1BC4 00 00 00 00 
2996   1BC8 00 00 00 00 
2996   1BCC 00 00 00 00 
2996   1BD0 00 00 00 00 
2996   1BD4 00 00 00 00 
2996   1BD8 00 00 00 00 
2996   1BDC 00 00 00 00 
2996   1BE0 00 00 00 00 
2996   1BE4 00 00 00 00 
2996   1BE8 00 00 00 00 
2996   1BEC 00 00 00 00 
2996   1BF0 00 00 00 00 
2996   1BF4 00 00 00 00 
2996   1BF8 00 00 00 00 
2996   1BFC 00 00 00 00 
2996   1C00 00 00 00 00 
2996   1C04 00 00 00 00 
2996   1C08 00 00 00 00 
2996   1C0C 00 00 00 00 
2996   1C10 00 00 00 00 
2996   1C14 00 00 00 00 
2996   1C18 00 00 00 00 
2996   1C1C 00 00 00 00 
2996   1C20 00 00 00 00 
2996   1C24 00 00 00 00 
2996   1C28 00 00 00 00 
2996   1C2C 00 00 00 00 
2996   1C30 00 00 00 00 
2996   1C34 00 00 00 00 
2996   1C38 00 00 00 00 
2996   1C3C 00 00 00 00 
2996   1C40 00 00 00 00 
2996   1C44 00 00 00 00 
2996   1C48 00 00 00 00 
2996   1C4C 00 00 00 00 
2996   1C50 00 00 00 00 
2996   1C54 00 00 00 00 
2996   1C58 00 00 00 00 
2996   1C5C 00 00 00 00 
2996   1C60 00 00 00 00 
2996   1C64 00 00 00 00 
2996   1C68 00 00 00 00 
2996   1C6C 00 00 00 00 
2996   1C70 00 00 00 00 
2996   1C74 00 00 00 00 
2996   1C78 00 00 00 00 
2996   1C7C 00 00 00 00 
2996   1C80 00 00 00 00 
2996   1C84 00 00 00 00 
2996   1C88 00 00 00 00 
2996   1C8C 00 00 00 00 
2996   1C90 00 00 00 00 
2996   1C94 00 00 00 00 
2996   1C98 00 00 00 00 
2996   1C9C 00 00 00 00 
2996   1CA0 00 00 00 00 
2996   1CA4 00 00 00 00 
2996   1CA8 00 00 00 00 
2996   1CAC 00 00 00 00 
2996   1CB0 00 00 00 00 
2996   1CB4 00 00 00 00 
2996   1CB8 00 00 00 00 
2996   1CBC 00 00 00 00 
2996   1CC0 00 00 00 00 
2996   1CC4 00 00 00 00 
2996   1CC8 00 00 00 00 
2996   1CCC 00 00 00 00 
2996   1CD0 00 00 00 00 
2996   1CD4 00 00 00 00 
2996   1CD8 00 00 00 00 
2996   1CDC 00 00 00 00 
2996   1CE0 00 00 00 00 
2996   1CE4 00 00 00 00 
2996   1CE8 00 00 00 00 
2996   1CEC 00 00 00 00 
2996   1CF0 00 00 00 00 
2996   1CF4 00 00 00 00 
2996   1CF8 00 00 00 00 
2996   1CFC 00 00 00 00 
2996   1D00 00 00 00 00 
2996   1D04 00 00 00 00 
2996   1D08 00 00 00 00 
2996   1D0C 00 00 00 00 
2996   1D10 00 00 00 00 
2996   1D14 00 00 00 00 
2996   1D18 00 00 00 00 
2996   1D1C 00 00 00 00 
2996   1D20 00 00 00 00 
2997   1D24             filename:
2998   1D24 00 00 00 00   .fill 128, 0      ; holds a path for file search
2998   1D28 00 00 00 00 
2998   1D2C 00 00 00 00 
2998   1D30 00 00 00 00 
2998   1D34 00 00 00 00 
2998   1D38 00 00 00 00 
2998   1D3C 00 00 00 00 
2998   1D40 00 00 00 00 
2998   1D44 00 00 00 00 
2998   1D48 00 00 00 00 
2998   1D4C 00 00 00 00 
2998   1D50 00 00 00 00 
2998   1D54 00 00 00 00 
2998   1D58 00 00 00 00 
2998   1D5C 00 00 00 00 
2998   1D60 00 00 00 00 
2998   1D64 00 00 00 00 
2998   1D68 00 00 00 00 
2998   1D6C 00 00 00 00 
2998   1D70 00 00 00 00 
2998   1D74 00 00 00 00 
2998   1D78 00 00 00 00 
2998   1D7C 00 00 00 00 
2998   1D80 00 00 00 00 
2998   1D84 00 00 00 00 
2998   1D88 00 00 00 00 
2998   1D8C 00 00 00 00 
2998   1D90 00 00 00 00 
2998   1D94 00 00 00 00 
2998   1D98 00 00 00 00 
2998   1D9C 00 00 00 00 
2998   1DA0 00 00 00 00 
2999   1DA4             user_data:
3000   1DA4 00 00 00 00   .fill 512, 0      ;  user space data
3000   1DA8 00 00 00 00 
3000   1DAC 00 00 00 00 
3000   1DB0 00 00 00 00 
3000   1DB4 00 00 00 00 
3000   1DB8 00 00 00 00 
3000   1DBC 00 00 00 00 
3000   1DC0 00 00 00 00 
3000   1DC4 00 00 00 00 
3000   1DC8 00 00 00 00 
3000   1DCC 00 00 00 00 
3000   1DD0 00 00 00 00 
3000   1DD4 00 00 00 00 
3000   1DD8 00 00 00 00 
3000   1DDC 00 00 00 00 
3000   1DE0 00 00 00 00 
3000   1DE4 00 00 00 00 
3000   1DE8 00 00 00 00 
3000   1DEC 00 00 00 00 
3000   1DF0 00 00 00 00 
3000   1DF4 00 00 00 00 
3000   1DF8 00 00 00 00 
3000   1DFC 00 00 00 00 
3000   1E00 00 00 00 00 
3000   1E04 00 00 00 00 
3000   1E08 00 00 00 00 
3000   1E0C 00 00 00 00 
3000   1E10 00 00 00 00 
3000   1E14 00 00 00 00 
3000   1E18 00 00 00 00 
3000   1E1C 00 00 00 00 
3000   1E20 00 00 00 00 
3000   1E24 00 00 00 00 
3000   1E28 00 00 00 00 
3000   1E2C 00 00 00 00 
3000   1E30 00 00 00 00 
3000   1E34 00 00 00 00 
3000   1E38 00 00 00 00 
3000   1E3C 00 00 00 00 
3000   1E40 00 00 00 00 
3000   1E44 00 00 00 00 
3000   1E48 00 00 00 00 
3000   1E4C 00 00 00 00 
3000   1E50 00 00 00 00 
3000   1E54 00 00 00 00 
3000   1E58 00 00 00 00 
3000   1E5C 00 00 00 00 
3000   1E60 00 00 00 00 
3000   1E64 00 00 00 00 
3000   1E68 00 00 00 00 
3000   1E6C 00 00 00 00 
3000   1E70 00 00 00 00 
3000   1E74 00 00 00 00 
3000   1E78 00 00 00 00 
3000   1E7C 00 00 00 00 
3000   1E80 00 00 00 00 
3000   1E84 00 00 00 00 
3000   1E88 00 00 00 00 
3000   1E8C 00 00 00 00 
3000   1E90 00 00 00 00 
3000   1E94 00 00 00 00 
3000   1E98 00 00 00 00 
3000   1E9C 00 00 00 00 
3000   1EA0 00 00 00 00 
3000   1EA4 00 00 00 00 
3000   1EA8 00 00 00 00 
3000   1EAC 00 00 00 00 
3000   1EB0 00 00 00 00 
3000   1EB4 00 00 00 00 
3000   1EB8 00 00 00 00 
3000   1EBC 00 00 00 00 
3000   1EC0 00 00 00 00 
3000   1EC4 00 00 00 00 
3000   1EC8 00 00 00 00 
3000   1ECC 00 00 00 00 
3000   1ED0 00 00 00 00 
3000   1ED4 00 00 00 00 
3000   1ED8 00 00 00 00 
3000   1EDC 00 00 00 00 
3000   1EE0 00 00 00 00 
3000   1EE4 00 00 00 00 
3000   1EE8 00 00 00 00 
3000   1EEC 00 00 00 00 
3000   1EF0 00 00 00 00 
3000   1EF4 00 00 00 00 
3000   1EF8 00 00 00 00 
3000   1EFC 00 00 00 00 
3000   1F00 00 00 00 00 
3000   1F04 00 00 00 00 
3000   1F08 00 00 00 00 
3000   1F0C 00 00 00 00 
3000   1F10 00 00 00 00 
3000   1F14 00 00 00 00 
3000   1F18 00 00 00 00 
3000   1F1C 00 00 00 00 
3000   1F20 00 00 00 00 
3000   1F24 00 00 00 00 
3000   1F28 00 00 00 00 
3000   1F2C 00 00 00 00 
3000   1F30 00 00 00 00 
3000   1F34 00 00 00 00 
3000   1F38 00 00 00 00 
3000   1F3C 00 00 00 00 
3000   1F40 00 00 00 00 
3000   1F44 00 00 00 00 
3000   1F48 00 00 00 00 
3000   1F4C 00 00 00 00 
3000   1F50 00 00 00 00 
3000   1F54 00 00 00 00 
3000   1F58 00 00 00 00 
3000   1F5C 00 00 00 00 
3000   1F60 00 00 00 00 
3000   1F64 00 00 00 00 
3000   1F68 00 00 00 00 
3000   1F6C 00 00 00 00 
3000   1F70 00 00 00 00 
3000   1F74 00 00 00 00 
3000   1F78 00 00 00 00 
3000   1F7C 00 00 00 00 
3000   1F80 00 00 00 00 
3000   1F84 00 00 00 00 
3000   1F88 00 00 00 00 
3000   1F8C 00 00 00 00 
3000   1F90 00 00 00 00 
3000   1F94 00 00 00 00 
3000   1F98 00 00 00 00 
3000   1F9C 00 00 00 00 
3000   1FA0 00 00 00 00 
3001   1FA4             fifo:
3002   1FA4 FF FF FF FF   .fill fifo_size
3002   1FA8 FF FF FF FF 
3002   1FAC FF FF FF FF 
3002   1FB0 FF FF FF FF 
3002   1FB4 FF FF FF FF 
3002   1FB8 FF FF FF FF 
3002   1FBC FF FF FF FF 
3002   1FC0 FF FF FF FF 
3002   1FC4 FF FF FF FF 
3002   1FC8 FF FF FF FF 
3002   1FCC FF FF FF FF 
3002   1FD0 FF FF FF FF 
3002   1FD4 FF FF FF FF 
3002   1FD8 FF FF FF FF 
3002   1FDC FF FF FF FF 
3002   1FE0 FF FF FF FF 
3002   1FE4 FF FF FF FF 
3002   1FE8 FF FF FF FF 
3002   1FEC FF FF FF FF 
3002   1FF0 FF FF FF FF 
3002   1FF4 FF FF FF FF 
3002   1FF8 FF FF FF FF 
3002   1FFC FF FF FF FF 
3002   2000 FF FF FF FF 
3002   2004 FF FF FF FF 
3002   2008 FF FF FF FF 
3002   200C FF FF FF FF 
3002   2010 FF FF FF FF 
3002   2014 FF FF FF FF 
3002   2018 FF FF FF FF 
3002   201C FF FF FF FF 
3002   2020 FF FF FF FF 
3002   2024 FF FF FF FF 
3002   2028 FF FF FF FF 
3002   202C FF FF FF FF 
3002   2030 FF FF FF FF 
3002   2034 FF FF FF FF 
3002   2038 FF FF FF FF 
3002   203C FF FF FF FF 
3002   2040 FF FF FF FF 
3002   2044 FF FF FF FF 
3002   2048 FF FF FF FF 
3002   204C FF FF FF FF 
3002   2050 FF FF FF FF 
3002   2054 FF FF FF FF 
3002   2058 FF FF FF FF 
3002   205C FF FF FF FF 
3002   2060 FF FF FF FF 
3002   2064 FF FF FF FF 
3002   2068 FF FF FF FF 
3002   206C FF FF FF FF 
3002   2070 FF FF FF FF 
3002   2074 FF FF FF FF 
3002   2078 FF FF FF FF 
3002   207C FF FF FF FF 
3002   2080 FF FF FF FF 
3002   2084 FF FF FF FF 
3002   2088 FF FF FF FF 
3002   208C FF FF FF FF 
3002   2090 FF FF FF FF 
3002   2094 FF FF FF FF 
3002   2098 FF FF FF FF 
3002   209C FF FF FF FF 
3002   20A0 FF FF FF FF 
3002   20A4 FF FF FF FF 
3002   20A8 FF FF FF FF 
3002   20AC FF FF FF FF 
3002   20B0 FF FF FF FF 
3002   20B4 FF FF FF FF 
3002   20B8 FF FF FF FF 
3002   20BC FF FF FF FF 
3002   20C0 FF FF FF FF 
3002   20C4 FF FF FF FF 
3002   20C8 FF FF FF FF 
3002   20CC FF FF FF FF 
3002   20D0 FF FF FF FF 
3002   20D4 FF FF FF FF 
3002   20D8 FF FF FF FF 
3002   20DC FF FF FF FF 
3002   20E0 FF FF FF FF 
3002   20E4 FF FF FF FF 
3002   20E8 FF FF FF FF 
3002   20EC FF FF FF FF 
3002   20F0 FF FF FF FF 
3002   20F4 FF FF FF FF 
3002   20F8 FF FF FF FF 
3002   20FC FF FF FF FF 
3002   2100 FF FF FF FF 
3002   2104 FF FF FF FF 
3002   2108 FF FF FF FF 
3002   210C FF FF FF FF 
3002   2110 FF FF FF FF 
3002   2114 FF FF FF FF 
3002   2118 FF FF FF FF 
3002   211C FF FF FF FF 
3002   2120 FF FF FF FF 
3002   2124 FF FF FF FF 
3002   2128 FF FF FF FF 
3002   212C FF FF FF FF 
3002   2130 FF FF FF FF 
3002   2134 FF FF FF FF 
3002   2138 FF FF FF FF 
3002   213C FF FF FF FF 
3002   2140 FF FF FF FF 
3002   2144 FF FF FF FF 
3002   2148 FF FF FF FF 
3002   214C FF FF FF FF 
3002   2150 FF FF FF FF 
3002   2154 FF FF FF FF 
3002   2158 FF FF FF FF 
3002   215C FF FF FF FF 
3002   2160 FF FF FF FF 
3002   2164 FF FF FF FF 
3002   2168 FF FF FF FF 
3002   216C FF FF FF FF 
3002   2170 FF FF FF FF 
3002   2174 FF FF FF FF 
3002   2178 FF FF FF FF 
3002   217C FF FF FF FF 
3002   2180 FF FF FF FF 
3002   2184 FF FF FF FF 
3002   2188 FF FF FF FF 
3002   218C FF FF FF FF 
3002   2190 FF FF FF FF 
3002   2194 FF FF FF FF 
3002   2198 FF FF FF FF 
3002   219C FF FF FF FF 
3002   21A0 FF FF FF FF 
3002   21A4 FF FF FF FF 
3002   21A8 FF FF FF FF 
3002   21AC FF FF FF FF 
3002   21B0 FF FF FF FF 
3002   21B4 FF FF FF FF 
3002   21B8 FF FF FF FF 
3002   21BC FF FF FF FF 
3002   21C0 FF FF FF FF 
3002   21C4 FF FF FF FF 
3002   21C8 FF FF FF FF 
3002   21CC FF FF FF FF 
3002   21D0 FF FF FF FF 
3002   21D4 FF FF FF FF 
3002   21D8 FF FF FF FF 
3002   21DC FF FF FF FF 
3002   21E0 FF FF FF FF 
3002   21E4 FF FF FF FF 
3002   21E8 FF FF FF FF 
3002   21EC FF FF FF FF 
3002   21F0 FF FF FF FF 
3002   21F4 FF FF FF FF 
3002   21F8 FF FF FF FF 
3002   21FC FF FF FF FF 
3002   2200 FF FF FF FF 
3002   2204 FF FF FF FF 
3002   2208 FF FF FF FF 
3002   220C FF FF FF FF 
3002   2210 FF FF FF FF 
3002   2214 FF FF FF FF 
3002   2218 FF FF FF FF 
3002   221C FF FF FF FF 
3002   2220 FF FF FF FF 
3002   2224 FF FF FF FF 
3002   2228 FF FF FF FF 
3002   222C FF FF FF FF 
3002   2230 FF FF FF FF 
3002   2234 FF FF FF FF 
3002   2238 FF FF FF FF 
3002   223C FF FF FF FF 
3002   2240 FF FF FF FF 
3002   2244 FF FF FF FF 
3002   2248 FF FF FF FF 
3002   224C FF FF FF FF 
3002   2250 FF FF FF FF 
3002   2254 FF FF FF FF 
3002   2258 FF FF FF FF 
3002   225C FF FF FF FF 
3002   2260 FF FF FF FF 
3002   2264 FF FF FF FF 
3002   2268 FF FF FF FF 
3002   226C FF FF FF FF 
3002   2270 FF FF FF FF 
3002   2274 FF FF FF FF 
3002   2278 FF FF FF FF 
3002   227C FF FF FF FF 
3002   2280 FF FF FF FF 
3002   2284 FF FF FF FF 
3002   2288 FF FF FF FF 
3002   228C FF FF FF FF 
3002   2290 FF FF FF FF 
3002   2294 FF FF FF FF 
3002   2298 FF FF FF FF 
3002   229C FF FF FF FF 
3002   22A0 FF FF FF FF 
3002   22A4 FF FF FF FF 
3002   22A8 FF FF FF FF 
3002   22AC FF FF FF FF 
3002   22B0 FF FF FF FF 
3002   22B4 FF FF FF FF 
3002   22B8 FF FF FF FF 
3002   22BC FF FF FF FF 
3002   22C0 FF FF FF FF 
3002   22C4 FF FF FF FF 
3002   22C8 FF FF FF FF 
3002   22CC FF FF FF FF 
3002   22D0 FF FF FF FF 
3002   22D4 FF FF FF FF 
3002   22D8 FF FF FF FF 
3002   22DC FF FF FF FF 
3002   22E0 FF FF FF FF 
3002   22E4 FF FF FF FF 
3002   22E8 FF FF FF FF 
3002   22EC FF FF FF FF 
3002   22F0 FF FF FF FF 
3002   22F4 FF FF FF FF 
3002   22F8 FF FF FF FF 
3002   22FC FF FF FF FF 
3002   2300 FF FF FF FF 
3002   2304 FF FF FF FF 
3002   2308 FF FF FF FF 
3002   230C FF FF FF FF 
3002   2310 FF FF FF FF 
3002   2314 FF FF FF FF 
3002   2318 FF FF FF FF 
3002   231C FF FF FF FF 
3002   2320 FF FF FF FF 
3002   2324 FF FF FF FF 
3002   2328 FF FF FF FF 
3002   232C FF FF FF FF 
3002   2330 FF FF FF FF 
3002   2334 FF FF FF FF 
3002   2338 FF FF FF FF 
3002   233C FF FF FF FF 
3002   2340 FF FF FF FF 
3002   2344 FF FF FF FF 
3002   2348 FF FF FF FF 
3002   234C FF FF FF FF 
3002   2350 FF FF FF FF 
3002   2354 FF FF FF FF 
3002   2358 FF FF FF FF 
3002   235C FF FF FF FF 
3002   2360 FF FF FF FF 
3002   2364 FF FF FF FF 
3002   2368 FF FF FF FF 
3002   236C FF FF FF FF 
3002   2370 FF FF FF FF 
3002   2374 FF FF FF FF 
3002   2378 FF FF FF FF 
3002   237C FF FF FF FF 
3002   2380 FF FF FF FF 
3002   2384 FF FF FF FF 
3002   2388 FF FF FF FF 
3002   238C FF FF FF FF 
3002   2390 FF FF FF FF 
3002   2394 FF FF FF FF 
3002   2398 FF FF FF FF 
3002   239C FF FF FF FF 
3002   23A0 FF FF FF FF 
3003   23A4             
3004   23A4             scrap_sector:
3005   23A4 FF FF FF FF   .fill 512         ; scrap sector
3005   23A8 FF FF FF FF 
3005   23AC FF FF FF FF 
3005   23B0 FF FF FF FF 
3005   23B4 FF FF FF FF 
3005   23B8 FF FF FF FF 
3005   23BC FF FF FF FF 
3005   23C0 FF FF FF FF 
3005   23C4 FF FF FF FF 
3005   23C8 FF FF FF FF 
3005   23CC FF FF FF FF 
3005   23D0 FF FF FF FF 
3005   23D4 FF FF FF FF 
3005   23D8 FF FF FF FF 
3005   23DC FF FF FF FF 
3005   23E0 FF FF FF FF 
3005   23E4 FF FF FF FF 
3005   23E8 FF FF FF FF 
3005   23EC FF FF FF FF 
3005   23F0 FF FF FF FF 
3005   23F4 FF FF FF FF 
3005   23F8 FF FF FF FF 
3005   23FC FF FF FF FF 
3005   2400 FF FF FF FF 
3005   2404 FF FF FF FF 
3005   2408 FF FF FF FF 
3005   240C FF FF FF FF 
3005   2410 FF FF FF FF 
3005   2414 FF FF FF FF 
3005   2418 FF FF FF FF 
3005   241C FF FF FF FF 
3005   2420 FF FF FF FF 
3005   2424 FF FF FF FF 
3005   2428 FF FF FF FF 
3005   242C FF FF FF FF 
3005   2430 FF FF FF FF 
3005   2434 FF FF FF FF 
3005   2438 FF FF FF FF 
3005   243C FF FF FF FF 
3005   2440 FF FF FF FF 
3005   2444 FF FF FF FF 
3005   2448 FF FF FF FF 
3005   244C FF FF FF FF 
3005   2450 FF FF FF FF 
3005   2454 FF FF FF FF 
3005   2458 FF FF FF FF 
3005   245C FF FF FF FF 
3005   2460 FF FF FF FF 
3005   2464 FF FF FF FF 
3005   2468 FF FF FF FF 
3005   246C FF FF FF FF 
3005   2470 FF FF FF FF 
3005   2474 FF FF FF FF 
3005   2478 FF FF FF FF 
3005   247C FF FF FF FF 
3005   2480 FF FF FF FF 
3005   2484 FF FF FF FF 
3005   2488 FF FF FF FF 
3005   248C FF FF FF FF 
3005   2490 FF FF FF FF 
3005   2494 FF FF FF FF 
3005   2498 FF FF FF FF 
3005   249C FF FF FF FF 
3005   24A0 FF FF FF FF 
3005   24A4 FF FF FF FF 
3005   24A8 FF FF FF FF 
3005   24AC FF FF FF FF 
3005   24B0 FF FF FF FF 
3005   24B4 FF FF FF FF 
3005   24B8 FF FF FF FF 
3005   24BC FF FF FF FF 
3005   24C0 FF FF FF FF 
3005   24C4 FF FF FF FF 
3005   24C8 FF FF FF FF 
3005   24CC FF FF FF FF 
3005   24D0 FF FF FF FF 
3005   24D4 FF FF FF FF 
3005   24D8 FF FF FF FF 
3005   24DC FF FF FF FF 
3005   24E0 FF FF FF FF 
3005   24E4 FF FF FF FF 
3005   24E8 FF FF FF FF 
3005   24EC FF FF FF FF 
3005   24F0 FF FF FF FF 
3005   24F4 FF FF FF FF 
3005   24F8 FF FF FF FF 
3005   24FC FF FF FF FF 
3005   2500 FF FF FF FF 
3005   2504 FF FF FF FF 
3005   2508 FF FF FF FF 
3005   250C FF FF FF FF 
3005   2510 FF FF FF FF 
3005   2514 FF FF FF FF 
3005   2518 FF FF FF FF 
3005   251C FF FF FF FF 
3005   2520 FF FF FF FF 
3005   2524 FF FF FF FF 
3005   2528 FF FF FF FF 
3005   252C FF FF FF FF 
3005   2530 FF FF FF FF 
3005   2534 FF FF FF FF 
3005   2538 FF FF FF FF 
3005   253C FF FF FF FF 
3005   2540 FF FF FF FF 
3005   2544 FF FF FF FF 
3005   2548 FF FF FF FF 
3005   254C FF FF FF FF 
3005   2550 FF FF FF FF 
3005   2554 FF FF FF FF 
3005   2558 FF FF FF FF 
3005   255C FF FF FF FF 
3005   2560 FF FF FF FF 
3005   2564 FF FF FF FF 
3005   2568 FF FF FF FF 
3005   256C FF FF FF FF 
3005   2570 FF FF FF FF 
3005   2574 FF FF FF FF 
3005   2578 FF FF FF FF 
3005   257C FF FF FF FF 
3005   2580 FF FF FF FF 
3005   2584 FF FF FF FF 
3005   2588 FF FF FF FF 
3005   258C FF FF FF FF 
3005   2590 FF FF FF FF 
3005   2594 FF FF FF FF 
3005   2598 FF FF FF FF 
3005   259C FF FF FF FF 
3005   25A0 FF FF FF FF 
3006   25A4             transient_area:
3007   25A4 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
3008   25A5             
3009   25A5             .end
tasm: Number of errors = 0
