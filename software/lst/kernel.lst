0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff88 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff88         ; data
0042   0000             _uart1_dlab_0     .equ $ff88         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff89         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff89         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff8a         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff8b         ; line control register
0047   0000             _uart1_lsr        .equ $ff8d         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             _stack_begin      .equ $f7ff         ; beginning of stack
0079   0000             _fifo_size        .equ 4096
0080   0000             
0081   0000             _mbr              .equ 446
0082   0000             _superblock       .equ 512
0083   0000             
0084   0000             text_org          .equ $400          ; code origin address for all user processes
0085   0000             
0086   0000             
0087   0000             ; ------------------------------------------------------------------------------------------------------------------;
0088   0000             ; DISK LAYOUT:
0089   0000             ; | Metadata               | Size (bytes)    | Blocks (2048 bytes)              |
0090   0000             ; | ---------------------- | --------------- | -------------------------------- |
0091   0000             ; | Bootloader/MBR         | 512 bytes       | 0.25 (1 sector)                  |
0092   0000             ; | Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0093   0000             ; | Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0094   0000             ; | Block Bitmap           | 16,384 bytes    | 8 blocks                         |
0095   0000             ; | Inode Bitmap           | 2,048 bytes     | 1 block                          |
0096   0000             ; | Inode Table            | 2,097,152 bytes | 1024 blocks                      |
0097   0000             ; 
0098   0000             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0099   0000             ; up to 4 partitions, each 16 bytes long
0100   0000             ; MBR:
0101   0000             ; Byte | Description
0102   0000             ; -----|----------------------------
0103   0000             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0104   0000             ; 1-3  | Start CHS (head, sector, cylinder)
0105   0000             ; 4    | Partition type (filesystem ID)
0106   0000             ;   0x83 = Linux native (ext2/3/4)
0107   0000             ;   0x07 = NTFS/exFAT
0108   0000             ;   0x0B = FAT32 CHS
0109   0000             ;   0x0C = FAT32 LBA
0110   0000             ;   0x05 = Extended partition
0111   0000             ; 5-7  | End CHS
0112   0000             ; 8-11 | Start LBA (little endian)
0113   0000             ; 12-15| Size in sectors (little endian)
0114   0000             ; 
0115   0000             ; 
0116   0000             ; SUPERBLOCK:
0117   0000             ; | Field                 | Description                              | Typical Size (bytes) | Notes                           |
0118   0000             ; | --------------------- | ---------------------------------------- | -------------------- | ------------------------------- |
0119   0000             ; | `s_inodes_count`      | Total number of inodes in the filesystem | 4                    | 32-bit unsigned int             |
0120   0000             ; | `s_blocks_count`      | Total number of data blocks              | 4                    | 32-bit unsigned int             |
0121   0000             ; | `s_free_inodes_count` | Number of free inodes                    | 4                    | 32-bit unsigned int             |
0122   0000             ; | `s_free_blocks_count` | Number of free blocks                    | 4                    | 32-bit unsigned int             |
0123   0000             ; | `s_first_data_block`  | Block number of the first data block     | 4                    | 32-bit unsigned int             |
0124   0000             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`  | 4                    | 32-bit unsigned int             |
0125   0000             ; | `s_inode_size`        | Size of each inode (in bytes)            | 2                    | 16-bit unsigned int             |
0126   0000             ; | `s_magic`             | Filesystem signature (`0xEF53`)          | 2                    | 16-bit unsigned int             |
0127   0000             ; | `s_mtime`             | Last mount time                          | 4                    | 32-bit unsigned int (Unix time) |
0128   0000             ; | `s_wtime`             | Last write time                          | 4                    | 32-bit unsigned int (Unix time) |
0129   0000             ; | `s_uuid`              | Unique ID of the filesystem              | 16                   | 128-bit UUID                    |
0130   0000             ; | `s_volume_name`       | Label of the filesystem                  | 16                   | Usually ASCII, padded           |
0131   0000             ; | `s_feature_flags`     | Compatibility flags                      | 4                    | 32-bit unsigned int             |
0132   0000             ; 
0133   0000             ; 
0134   0000             ; inode for root dir is #2, #0 and #1 not used
0135   0000             ; block size: 2048
0136   0000             
0137   0000             ; inode-table format:
0138   0000             ; | Field         | Size (bytes) | Description                                                                                  |
0139   0000             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0140   0000             ; | `mode`        | 2            | File type and permissions                                                                    |
0141   0000             ; | `uid`         | 2            | Owner user ID                                                                                |
0142   0000             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0143   0000             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0144   0000             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0145   0000             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0146   0000             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0147   0000             ; | `gid`         | 2            | Group ID                                                                                     |
0148   0000             ; | `links_count` | 2            | Number of hard links                                                                         |
0149   0000             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0150   0000             ; | `flags`       | 4            | File flags                                                                                   |
0151   0000             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0152   0000             
0153   0000             
0154   0000             ; file entry attributes
0155   0000             ; filename (24)
0156   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0157   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0158   0000             ; size (2)             : filesize
0159   0000             ; day (1)           
0160   0000             ; month (1)
0161   0000             ; year (1)
0162   0000             ; packet size = 32 bytes  : total packet size in bytes
0163   0000             
0164   0000             fst_entry_size      .equ 32  ; bytes
0165   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0166   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0167   0000             fst_nbr_directories .equ 64
0168   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0169   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0170   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0171   0000             fst_lba_start       .equ 32
0172   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0173   0000             
0174   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0175   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0176   0000                                         ; so that we know which blocks are free or taken
0177   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0178   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0179   0000             fs_lba_start        .equ (fst_lba_end + 1)
0180   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0181   0000             
0182   0000             root_id:            .equ fst_lba_start
0183   0000             
0184   0000             ; ------------------------------------------------------------------------------------------------------------------;
0185   0000             ; global system variables
0186   0000             ; ------------------------------------------------------------------------------------------------------------------;
0187   0000             
0188   0000             ; ------------------------------------------------------------------------------------------------------------------;
0189   0000             ; irq table
0190   0000             ; highest priority at lowest address
0191   0000             ; ------------------------------------------------------------------------------------------------------------------;
0192   0000 3C 00       .dw int_0_fdc
0193   0002 3D 00       .dw int_1
0194   0004 3E 00       .dw int_2
0195   0006 3F 00       .dw int_3
0196   0008 40 00       .dw int_4
0197   000A 41 00       .dw int_5_uart1
0198   000C 69 00       .dw int_6_timer
0199   000E 6A 00       .dw int_7_uart0
0200   0010             
0201   0010             ; ------------------------------------------------------------------------------------------------------------------;
0202   0010             ; kernel reset vector
0203   0010             ; ------------------------------------------------------------------------------------------------------------------;
0204   0010 C4 11       .dw kernel_reset_vector
0205   0012             
0206   0012             ; ------------------------------------------------------------------------------------------------------------------;
0207   0012             ; exception vector table
0208   0012             ; total of 7 entries, starting at address $0012
0209   0012             ; ------------------------------------------------------------------------------------------------------------------;
0210   0012 79 04       .dw trap_privilege
0211   0014 96 05       .dw trap_div_zero
0212   0016 A3 05       .dw trap_undef_opcode
0213   0018 00 00       .dw 0
0214   001A 00 00       .dw 0
0215   001C 00 00       .dw 0
0216   001E 00 00       .dw 0
0217   0020             
0218   0020             ; ------------------------------------------------------------------------------------------------------------------;
0219   0020             ; system call vector table
0220   0020             ; starts at address $0020
0221   0020             ; ------------------------------------------------------------------------------------------------------------------;
0222   0020 85 04       .dw syscall_break
0223   0022 A4 05       .dw syscall_rtc
0224   0024 C7 06       .dw syscall_ide
0225   0026 87 07       .dw syscall_io
0226   0028 44 08       .dw syscall_file_system
0227   002A 11 11       .dw syscall_create_proc
0228   002C 3E 04       .dw syscall_list_procs
0229   002E D6 05       .dw syscall_datetime
0230   0030 FA 03       .dw syscall_reboot
0231   0032 DB 10       .dw syscall_pause_proc
0232   0034 06 04       .dw syscall_resume_proc
0233   0036 98 10       .dw syscall_terminate_proc
0234   0038 C6 03       .dw syscall_system
0235   003A 05 01       .dw syscall_fdc
0236   003C             
0237   003C             ; ------------------------------------------------------------------------------------------------------------------;
0238   003C             ; system call aliases
0239   003C             ; ------------------------------------------------------------------------------------------------------------------;
0240   003C             sys_break            .equ 0
0241   003C             sys_rtc              .equ 1
0242   003C             sys_ide              .equ 2
0243   003C             sys_io               .equ 3
0244   003C             sys_filesystem       .equ 4
0245   003C             sys_create_proc      .equ 5
0246   003C             sys_list_proc        .equ 6
0247   003C             sys_datetime         .equ 7
0248   003C             sys_reboot           .equ 8
0249   003C             sys_pause_proc       .equ 9
0250   003C             sys_resume_proc      .equ 10
0251   003C             sys_terminate_proc   .equ 11
0252   003C             sys_system           .equ 12
0253   003C             sys_fdc              .equ 13
0254   003C             
0255   003C             ; aliases for individual 'al' options for FDC system calls
0256   003C             fdc_al_restore      .equ 0
0257   003C             fdc_al_step         .equ 1
0258   003C             fdc_al_step_in      .equ 2
0259   003C             fdc_al_step_out     .equ 3
0260   003C             fdc_al_seek         .equ 4
0261   003C             fdc_al_format_128   .equ 5
0262   003C             fdc_al_formatdisk_128   .equ 6
0263   003C             fdc_al_format_512   .equ 7
0264   003C             fdc_al_formatdisk_512   .equ 8
0265   003C             fdc_al_read_addr    .equ 9
0266   003C             fdc_al_read_track   .equ 10
0267   003C             fdc_al_read_sect    .equ 11
0268   003C             fdc_al_write_sect   .equ 12
0269   003C             fdc_al_force_int    .equ 13
0270   003C             fdc_al_status0      .equ 14
0271   003C             fdc_al_status1      .equ 15
0272   003C             
0273   003C             ; ------------------------------------------------------------------------------------------------------------------;
0274   003C             ; alias exports
0275   003C             ; ------------------------------------------------------------------------------------------------------------------;
0276   003C             .export text_org
0277   003C             .export sys_break
0278   003C             .export sys_rtc
0279   003C             .export sys_ide
0280   003C             .export sys_io
0281   003C             .export sys_filesystem
0282   003C             .export sys_create_proc
0283   003C             .export sys_list_proc
0284   003C             .export sys_datetime
0285   003C             .export sys_reboot
0286   003C             .export sys_pause_proc
0287   003C             .export sys_resume_proc
0288   003C             .export sys_terminate_proc
0289   003C             .export sys_system
0290   003C             .export sys_fdc
0291   003C             
0292   003C             .export _7seg_display
0293   003C             
0294   003C             .export _fdc_config        
0295   003C             .export _fdc_status_0      
0296   003C             .export _fdc_stat_cmd     
0297   003C             
0298   003C             ; exports of aliases for individual 'al' options for FDC system calls
0299   003C             .export fdc_al_restore
0300   003C             .export fdc_al_step
0301   003C             .export fdc_al_step_in
0302   003C             .export fdc_al_step_out
0303   003C             .export fdc_al_seek
0304   003C             .export fdc_al_format_128
0305   003C             .export fdc_al_formatdisk_128
0306   003C             .export fdc_al_format_512
0307   003C             .export fdc_al_formatdisk_512
0308   003C             .export fdc_al_read_addr
0309   003C             .export fdc_al_read_track
0310   003C             .export fdc_al_read_sect
0311   003C             .export fdc_al_write_sect
0312   003C             .export fdc_al_force_int
0313   003C             .export fdc_al_status0
0314   003C             .export fdc_al_status1
0315   003C             
0316   003C             ; ------------------------------------------------------------------------------------------------------------------;
0317   003C             ; irqs' code block
0318   003C             ; ------------------------------------------------------------------------------------------------------------------;
0319   003C             ; 5.25" floppy drive controller irq
0320   003C             int_0_fdc:
0321   003C 06            sysret
0322   003D             int_1:
0323   003D 06            sysret
0324   003E             int_2:
0325   003E 06            sysret
0326   003F             int_3:
0327   003F 06            sysret
0328   0040             int_4:
0329   0040 06            sysret
0330   0041             
0331   0041             int_5_uart1:
0332   0041 D7            push a
0333   0042 DA            push d
0334   0043 E1            pushf
0335   0044 1D 88 FF      mov al, [_uart1_data]       ; get character
0336   0047 B9 03         cmp al, $03                 ; ctrl-c
0337   0049 C6 92 00      je ctrlc
0338   004C B9 1A         cmp al, $1a                 ; ctrl-z
0339   004E C6 98 00      je ctrlz
0340   0051               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0341   0051 3B 56 19      mov d, fifo_in
0342   0054 FD 2A         mov d, [d]
0343   0056 3E            mov [d], al                 ; add to fifo
0344   0057 13            mov a, d
0345   0058 77            inc a
0346   0059 AF 8E 31      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0347   005C C7 62 00      jne int_5_continue
0348   005F 10 8E 21      mov a, fifo  
0349   0062             int_5_continue:  
0350   0062 42 56 19      mov [fifo_in], a            ; update fifo pointer
0351   0065 EE            popf
0352   0066 E7            pop d
0353   0067 E4            pop a  
0354   0068 06            sysret
0355   0069             
0356   0069             ; timer irq
0357   0069             int_6_timer:  
0358   0069 06            sysret
0359   006A             
0360   006A             ; ------------------------------------------------------------------------------------------------------------------;
0361   006A             ; uart0 interrupt
0362   006A             ; ------------------------------------------------------------------------------------------------------------------;
0363   006A             int_7_uart0:
0364   006A D7            push a
0365   006B DA            push d
0366   006C E1            pushf
0367   006D 1D 80 FF      mov al, [_uart0_data]       ; get character
0368   0070 B9 03         cmp al, $03                 ; ctrl-c
0369   0072 C6 92 00      je ctrlc
0370   0075 B9 1A         cmp al, $1a                 ; ctrl-z
0371   0077 C6 98 00      je ctrlz
0372   007A               ;mov [[d]], al              ; TODO: implement this double indirection instruction
0373   007A 3B 56 19      mov d, fifo_in
0374   007D FD 2A         mov d, [d]
0375   007F 3E            mov [d], al                 ; add to fifo
0376   0080 13            mov a, d
0377   0081 77            inc a
0378   0082 AF 8E 31      cmp a, fifo + _fifo_size     ; check if pointer reached the end of the fifo
0379   0085 C7 8B 00      jne int_7_continue
0380   0088 10 8E 21      mov a, fifo  
0381   008B             int_7_continue:  
0382   008B 42 56 19      mov [fifo_in], a            ; update fifo pointer
0383   008E EE            popf
0384   008F E7            pop d
0385   0090 E4            pop a  
0386   0091 06            sysret
0387   0092             
0388   0092             
0389   0092             ctrlc:
0390   0092 51 05 00      add sp, 5
0391   0095 0A 98 10      jmp syscall_terminate_proc
0392   0098             ctrlz:
0393   0098 51 05 00      add sp, 5
0394   009B 0A DB 10      jmp syscall_pause_proc      ; pause current process and go back to the shell
0395   009E             
0396   009E             ; ------------------------------------------------------------------------------------------------------------------;
0397   009E             ; ext2 file system
0398   009E             ; ------------------------------------------------------------------------------------------------------------------;
0399   009E             sys_mkfs:
0400   009E             ; master boot record
0401   009E F2 BE 01 80   mov byte[_mbr], $80
0402   00A2 B8 BF 01 00   mov word[_mbr + 1], $0000
0402   00A6 00 
0403   00A7 F2 C1 01 00   mov byte[_mbr + 3], $00
0404   00AB F2 C2 01 83   mov byte[_mbr + 4], $83  ; ext2
0405   00AF B8 C3 01 00   mov word[_mbr + 5], $0000   ;end CHS
0405   00B3 00 
0406   00B4 F2 C5 01 00   mov byte[_mbr + 7], $00    
0407   00B8 B8 C6 01 01   mov word[_mbr + 8], 1       ; start LBA of kernel
0407   00BC 00 
0408   00BD B8 C8 01 00   mov word[_mbr + 10], $0000
0408   00C1 00 
0409   00C2 B8 CA 01 00   mov word[_mbr + 12], $0000       ; size = 65536 sectors = 32MB
0409   00C6 00 
0410   00C7 B8 CB 01 01   mov word[_mbr + 13], $0001
0410   00CB 00 
0411   00CC             
0412   00CC             ; superblock
0413   00CC B8 00 02 00   mov word[_superblock], 2048
0413   00D0 00 
0414   00D1 B8 02 02 00   mov word[_superblock + 2], $0000
0414   00D5 00 
0415   00D6 B8 04 02 00   mov word[_superblock + 4], $2800
0415   00DA 00 
0416   00DB B8 06 02 00   mov word[_superblock + 6], $0000
0416   00DF 00 
0417   00E0             
0418   00E0             ; --- MBR signature ---
0419   00E0 B8 FE 01 55   mov word [510], $AA55          ; Must be present for BIOS to boot
0419   00E4 00 
0420   00E5             
0421   00E5             
0422   00E5             ; ------------------------------------------------------------------------------------------------------------------;
0423   00E5             ; floppy drive syscalls
0424   00E5             ; ------------------------------------------------------------------------------------------------------------------;
0425   00E5             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0426   00E5             ; fdc_40_ff:
0427   00E5             ;   .fill 40,  $ff    ; or 00                                                                                
0428   00E5             ; fdc_128_format_inner:
0429   00E5             ;   .fill 6,   $00    ;                                                                            <--|        
0430   00E5             ;   .fill 1,   $fe    ; id address mark                                                               |        
0431   00E5             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0432   00E5             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0433   00E5             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0434   00E5             ;   .fill 1,   $00    ; sector length                                                                 |                        
0435   00E5             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0436   00E5             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0437   00E5             ;   .fill 6,   $00    ;                                                                               |                        
0438   00E5             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0439   00E5             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0440   00E5             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0441   00E5             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0442   00E5             ; fdc_128_format_end:
0443   00E5             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0444   00E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445   00E5             fdc_jmptbl:
0446   00E5 11 01         .dw syscall_fdc_restore
0447   00E7 1D 01         .dw syscall_fdc_step
0448   00E9 25 01         .dw syscall_fdc_step_in
0449   00EB 2D 01         .dw syscall_fdc_step_out
0450   00ED 35 01         .dw syscall_fdc_seek
0451   00EF 43 01         .dw syscall_fdc_format_128
0452   00F1 97 01         .dw syscall_fdc_formatdisk_128
0453   00F3 6D 01         .dw syscall_fdc_format_512
0454   00F5 D9 01         .dw syscall_fdc_formatdisk_512
0455   00F7 41 01         .dw syscall_fdc_read_addr
0456   00F9 1B 02         .dw syscall_fdc_read_track
0457   00FB 4A 02         .dw syscall_fdc_read_sect
0458   00FD 82 02         .dw syscall_fdc_write_sect
0459   00FF 42 01         .dw syscall_fdc_force_int
0460   0101 09 01         .dw syscall_fdc_status0
0461   0103 0D 01         .dw syscall_fdc_status1
0462   0105             syscall_fdc:
0463   0105 FD 0A E5 00   jmp [fdc_jmptbl + al]
0464   0109             
0465   0109             syscall_fdc_status0:
0466   0109 1D C1 FF      mov al, [_fdc_status_0]
0467   010C 06            sysret
0468   010D             
0469   010D             syscall_fdc_status1:
0470   010D 1D C8 FF      mov al, [_fdc_stat_cmd]
0471   0110 06            sysret
0472   0111             
0473   0111             syscall_fdc_restore:
0474   0111 07 B3 02      call fdc_wait_not_busy
0475   0114 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011
0476   0118 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0477   011C 06            sysret
0478   011D             
0479   011D             syscall_fdc_step:
0480   011D 07 B3 02      call fdc_wait_not_busy
0481   0120 F2 C8 FF 3B   mov byte [_fdc_stat_cmd], %00111011
0482   0124 06            sysret
0483   0125             
0484   0125             syscall_fdc_step_in:
0485   0125 07 B3 02      call fdc_wait_not_busy
0486   0128 F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011
0487   012C 06            sysret
0488   012D             
0489   012D             syscall_fdc_step_out:
0490   012D 07 B3 02      call fdc_wait_not_busy
0491   0130 F2 C8 FF 7B   mov byte [_fdc_stat_cmd], %01111011
0492   0134 06            sysret
0493   0135             
0494   0135             ; bl: desired track
0495   0135             syscall_fdc_seek:
0496   0135 07 B3 02      call fdc_wait_not_busy
0497   0138 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to bl
0498   013C F2 C8 FF 1B   mov byte [_fdc_stat_cmd], %00011011 ; seek command
0499   0140 06            sysret
0500   0141             
0501   0141             syscall_fdc_read_addr:
0502   0141 06            sysret
0503   0142             
0504   0142             syscall_fdc_force_int:
0505   0142 06            sysret
0506   0143             
0507   0143             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0508   0143             ; in the ram formatting block because they are all set as 00 right now
0509   0143             ; bl: track number
0510   0143             syscall_fdc_format_128:
0511   0143 07 BE 02      call fdc_format_mem_128
0512   0146 07 B3 02      call fdc_wait_not_busy
0513   0149 FD 3D C9 FF   mov [_fdc_track], bl
0514   014D FD 4D 8E 33   mov si, transient_area
0515   0151 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0516   0155 07 94 03      call fdc_wait_64us
0517   0158             fdc_format_drq_128:
0518   0158 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0519   015B 93 01         test al, $01                ; 4
0520   015D C6 6C 01      jz fdc_format_end_128           ; 8
0521   0160 93 02         test al, $02                ; 4
0522   0162 C6 58 01      jz fdc_format_drq_128           ; 8
0523   0165 F6            lodsb                       ; 7
0524   0166 3D CB FF      mov [_fdc_data], al         ; 10   
0525   0169 0A 58 01      jmp fdc_format_drq_128
0526   016C             fdc_format_end_128:
0527   016C 06            sysret
0528   016D             
0529   016D             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0530   016D             ; in the ram formatting block because they are all set as 00 right now
0531   016D             ; bl: track number
0532   016D             syscall_fdc_format_512:
0533   016D 07 29 03      call fdc_format_mem_512
0534   0170 07 B3 02      call fdc_wait_not_busy
0535   0173 FD 3D C9 FF   mov [_fdc_track], bl
0536   0177 FD 4D 8E 33   mov si, transient_area
0537   017B F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0538   017F 07 94 03      call fdc_wait_64us
0539   0182             fdc_format_drq_512:
0540   0182 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0541   0185 93 01         test al, $01                ; 4
0542   0187 C6 96 01      jz fdc_format_end_512           ; 8
0543   018A 93 02         test al, $02                ; 4
0544   018C C6 82 01      jz fdc_format_drq_512           ; 8
0545   018F F6            lodsb                       ; 7
0546   0190 3D CB FF      mov [_fdc_data], al         ; 10   
0547   0193 0A 82 01      jmp fdc_format_drq_512
0548   0196             fdc_format_end_512:
0549   0196 06            sysret
0550   0197             
0551   0197             syscall_fdc_formatdisk_128:
0552   0197 2E 00         mov bl, 0
0553   0199             fdc_formatdisk128_l0:
0554   0199 07 BE 02      call fdc_format_mem_128
0555   019C 07 B3 02      call fdc_wait_not_busy
0556   019F FD 3D C9 FF   mov [_fdc_track], bl
0557   01A3 FD 4D 8E 33   mov si, transient_area
0558   01A7 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command
0559   01AB 07 94 03      call fdc_wait_64us
0560   01AE             fdc_formatdisk_drq_128:
0561   01AE 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0562   01B1 93 01         test al, $01                ; 4
0563   01B3 C6 C2 01      jz fdc_formatdisk_end_128           ; 8
0564   01B6 93 02         test al, $02                ; 4
0565   01B8 C6 AE 01      jz fdc_formatdisk_drq_128           ; 8
0566   01BB F6            lodsb                       ; 7
0567   01BC 3D CB FF      mov [_fdc_data], al         ; 10   
0568   01BF 0A AE 01      jmp fdc_formatdisk_drq_128
0569   01C2             fdc_formatdisk_end_128:
0570   01C2 07 B3 02      call fdc_wait_not_busy
0571   01C5 D8            push b
0572   01C6 26 08 00      mov b, 8
0573   01C9 07 9B 03      call wait_xs
0574   01CC F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011  ; step in
0575   01D0 E5            pop b
0576   01D1 6C 01         add bl, 1
0577   01D3 C1 28         cmp bl, 40
0578   01D5 C7 99 01      jne fdc_formatdisk128_l0
0579   01D8 06            sysret
0580   01D9             
0581   01D9             syscall_fdc_formatdisk_512:
0582   01D9 2E 00         mov bl, 0
0583   01DB             fdc_formatdisk512_l0:
0584   01DB 07 29 03      call fdc_format_mem_512
0585   01DE 07 B3 02      call fdc_wait_not_busy
0586   01E1 FD 3D C9 FF   mov [_fdc_track], bl
0587   01E5 FD 4D 8E 33   mov si, transient_area
0588   01E9 F2 C8 FF F2   mov byte [_fdc_stat_cmd], %11110010 ; write track command
0589   01ED 07 94 03      call fdc_wait_64us
0590   01F0             fdc_formatdisk_drq_512:
0591   01F0 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0592   01F3 93 01         test al, $01                ; 4
0593   01F5 C6 04 02      jz fdc_formatdisk_end_512           ; 8
0594   01F8 93 02         test al, $02                ; 4
0595   01FA C6 F0 01      jz fdc_formatdisk_drq_512           ; 8
0596   01FD F6            lodsb                       ; 7
0597   01FE 3D CB FF      mov [_fdc_data], al         ; 10   
0598   0201 0A F0 01      jmp fdc_formatdisk_drq_512
0599   0204             fdc_formatdisk_end_512:
0600   0204 07 B3 02      call fdc_wait_not_busy
0601   0207 D8            push b
0602   0208 26 08 00      mov b, 8
0603   020B 07 9B 03      call wait_xs
0604   020E F2 C8 FF 53   mov byte [_fdc_stat_cmd], %01010011   ; step in
0605   0212 E5            pop b
0606   0213 6C 01         add bl, 1
0607   0215 C1 28         cmp bl, 40
0608   0217 C7 DB 01      jne fdc_formatdisk512_l0
0609   021A 06            sysret
0610   021B             
0611   021B             ; di : destination in user space
0612   021B             ; a  : returns number of read bytes
0613   021B             syscall_fdc_read_track:
0614   021B 07 B3 02      call fdc_wait_not_busy
0615   021E E3            push di
0616   021F FD 4F 8E 33   mov di, transient_area
0617   0223 F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0618   0227 07 94 03      call fdc_wait_64us
0619   022A             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0620   022A 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0621   022D 93 01         test al, $01                ; check busy bit
0622   022F C6 3E 02      jz fdc_read_track_end
0623   0232 93 02         test al, $02                ; check drq bit
0624   0234 C6 2A 02      jz fdc_read_track_l0
0625   0237 1D CB FF      mov al, [_fdc_data]     ; 
0626   023A F7            stosb
0627   023B 0A 2A 02      jmp fdc_read_track_l0
0628   023E             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0629   023E             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0630   023E             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0631   023E             fdc_read_track_end:
0632   023E 50            mov a, di
0633   023F 5F 8E 33      sub a, transient_area
0634   0242 F0            pop di
0635   0243 FD 4D 8E 33   mov si, transient_area
0636   0247 39            mov c, a  ; copy track over to user space
0637   0248 03            store
0638   0249 06            sysret
0639   024A             
0640   024A             ; sector in bl
0641   024A             ; track in bh
0642   024A             ; di = user space destination
0643   024A             syscall_fdc_read_sect:
0644   024A 07 B3 02      call fdc_wait_not_busy
0645   024D E3            push di
0646   024E FD 3D CA FF   mov [_fdc_sector], bl
0647   0252 30            mov bl, bh
0648   0253 FD 3D C9 FF   mov [_fdc_track], bl
0649   0257 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0650   025B 07 94 03      call fdc_wait_64us
0651   025E FD 4F 8E 33   mov di, transient_area
0652   0262             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0653   0262 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0654   0265 93 01         test al, $01                ; check drq bit
0655   0267 C6 76 02      jz fdc_read_sect_end
0656   026A 93 02         test al, $02                ; check drq bit
0657   026C C6 62 02      jz fdc_read_sect_l0
0658   026F 1D CB FF      mov al, [_fdc_data]     ; 
0659   0272 F7            stosb
0660   0273 0A 62 02      jmp fdc_read_sect_l0
0661   0276             fdc_read_sect_end:
0662   0276 50            mov a, di
0663   0277 5F 8E 33      sub a, transient_area
0664   027A F0            pop di
0665   027B FD 4D 8E 33   mov si, transient_area
0666   027F 39            mov c, a  ; copy sector over to user space
0667   0280 03            store
0668   0281 06            sysret
0669   0282             
0670   0282             ; sector size in c
0671   0282             ; sector in bl
0672   0282             ; track in bh
0673   0282             ; data pointer in si
0674   0282             syscall_fdc_write_sect:
0675   0282 07 B3 02      call fdc_wait_not_busy
0676   0285 FD 3D CA FF   mov [_fdc_sector], bl
0677   0289 30            mov bl, bh
0678   028A FD 3D C9 FF   mov [_fdc_track], bl
0679   028E FD 4F 8E 33   mov di, transient_area    ; si = data source, di = destination 
0680   0292 04            load                    ; transfer data to kernel space!
0681   0293 FD 4D 8E 33   mov si, transient_area
0682   0297 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0683   029B 07 94 03      call fdc_wait_64us
0684   029E             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0685   029E 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0686   02A1 93 01         test al, $01                    ; 4
0687   02A3 C6 B2 02      jz fdc_write_sect_end           ; 8
0688   02A6 93 02         test al, $02                    ; 4
0689   02A8 C6 9E 02      jz fdc_write_sect_l0            ; 8
0690   02AB F6            lodsb                           ; 7
0691   02AC 3D CB FF      mov [_fdc_data], al             ; 10   
0692   02AF 0A 9E 02      jmp fdc_write_sect_l0
0693   02B2             fdc_write_sect_end:
0694   02B2 06            sysret
0695   02B3             
0696   02B3             fdc_wait_not_busy:
0697   02B3 DB            push al
0698   02B4             fdc_wait_not_busy_l0:
0699   02B4 1D C8 FF      mov al, [_fdc_stat_cmd]   
0700   02B7 93 01         test al, $01               
0701   02B9 C7 B4 02      jnz fdc_wait_not_busy_l0          
0702   02BC E8            pop al
0703   02BD 09            ret
0704   02BE             
0705   02BE             ; track number in bl
0706   02BE             fdc_format_mem_128:
0707   02BE 3B 01 00      mov d, 1
0708   02C1 FD 4F 8E 33   mov di, transient_area
0709   02C5             ; 40 * FF
0710   02C5 38 28 00      mov c, 40
0711   02C8 19 FF         mov al, $ff
0712   02CA             fdc_l0: 
0713   02CA F7            stosb
0714   02CB 7E            dec c
0715   02CC C7 CA 02      jnz fdc_l0
0716   02CF             ; 6 * 00
0717   02CF             fdc_inner_loop:
0718   02CF 38 06 00      mov c, 6
0719   02D2 19 00         mov al, $00
0720   02D4             fdc_l1:
0721   02D4 F7            stosb
0722   02D5 7E            dec c
0723   02D6 C7 D4 02      jnz fdc_l1
0724   02D9             ; FE address mark
0725   02D9             fdc_l2:
0726   02D9 19 FE         mov al, $fe
0727   02DB F7            stosb
0728   02DC             ; track number
0729   02DC             fdc_l3:
0730   02DC 1B            mov al, bl  ; track number in bl
0731   02DD F7            stosb
0732   02DE             ; side number
0733   02DE             fdc_l4:
0734   02DE 19 00         mov al, $00
0735   02E0 F7            stosb
0736   02E1             ; sector number
0737   02E1             fdc_l5:
0738   02E1 13            mov a, d
0739   02E2 F7            stosb
0740   02E3             ; sector length 128 bytes
0741   02E3             fdc_l6:
0742   02E3 19 00         mov al, $00
0743   02E5 F7            stosb
0744   02E6             ; 2 crc's
0745   02E6             fdc_l7:
0746   02E6 19 F7         mov al, $f7
0747   02E8 F7            stosb
0748   02E9             ; 11 times $ff
0749   02E9 38 0B 00      mov c, 11
0750   02EC 19 FF         mov al, $ff
0751   02EE             fdc_l8:
0752   02EE F7            stosb
0753   02EF 7E            dec c
0754   02F0 C7 EE 02      jnz fdc_l8
0755   02F3             ; 6 times 00
0756   02F3 38 06 00      mov c, 6
0757   02F6 19 00         mov al, $00
0758   02F8             fdc_l9:
0759   02F8 F7            stosb
0760   02F9 7E            dec c
0761   02FA C7 F8 02      jnz fdc_l9
0762   02FD             ; FB data address mark
0763   02FD 19 FB         mov al, $fb
0764   02FF             fdc_l10:
0765   02FF F7            stosb
0766   0300             ; 128 bytes sector data
0767   0300 38 80 00      mov c, 128
0768   0303 19 E5         mov al, $E5
0769   0305             fdc_l11:
0770   0305 F7            stosb
0771   0306 7E            dec c
0772   0307 C7 05 03      jnz fdc_l11
0773   030A             ; 2 crc's
0774   030A             fdc_l12:
0775   030A 19 F7         mov al, $f7
0776   030C F7            stosb
0777   030D             ; 10 * $FF
0778   030D 38 0A 00      mov c, 10
0779   0310 19 FF         mov al, $ff
0780   0312             fdc_l13:
0781   0312 F7            stosb
0782   0313 7E            dec c
0783   0314 C7 12 03      jnz fdc_l13
0784   0317             ; check whether we did this 16 times
0785   0317 79            inc d
0786   0318 C5 11 00      cmp d, 17
0787   031B C7 CF 02      jne fdc_inner_loop
0788   031E             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0789   031E 38 F4 01      mov c, 500
0790   0321 19 FF         mov al, $ff
0791   0323             fdc_format_footer:
0792   0323             fdc_footer_drq_loop:
0793   0323 F7            stosb
0794   0324 7E            dec c
0795   0325 C7 23 03      jnz fdc_footer_drq_loop
0796   0328 09            ret
0797   0329             
0798   0329             ; track number in bl
0799   0329             fdc_format_mem_512:
0800   0329 3B 01 00      mov d, 1
0801   032C FD 4F 8E 33   mov di, transient_area
0802   0330             ; 40 * FF
0803   0330 38 28 00      mov c, 40
0804   0333 19 FF         mov al, $ff
0805   0335             fdc_512_l0: 
0806   0335 F7            stosb
0807   0336 7E            dec c
0808   0337 C7 35 03      jnz fdc_512_l0
0809   033A             ; 6 * 00
0810   033A             fdc_512_inner_loop:
0811   033A 38 06 00      mov c, 6
0812   033D 19 00         mov al, $00
0813   033F             fdc_512_l1:
0814   033F F7            stosb
0815   0340 7E            dec c
0816   0341 C7 3F 03      jnz fdc_512_l1
0817   0344             ; FE address mark
0818   0344             fdc_512_l2:
0819   0344 19 FE         mov al, $fe
0820   0346 F7            stosb
0821   0347             ; track number
0822   0347             fdc_512_l3:
0823   0347 1B            mov al, bl ; track number was in bl
0824   0348 F7            stosb
0825   0349             ; side number
0826   0349             fdc_512_l4:
0827   0349 19 00         mov al, $00
0828   034B F7            stosb
0829   034C             ; sector number
0830   034C             fdc_512_l5:
0831   034C 13            mov a, d
0832   034D F7            stosb
0833   034E             ; sector length 512 bytes
0834   034E             fdc_512_l6:
0835   034E 19 02         mov al, $02
0836   0350 F7            stosb
0837   0351             ; 2 crc's
0838   0351             fdc_512_l7:
0839   0351 19 F7         mov al, $f7
0840   0353 F7            stosb
0841   0354             ; 11 times $ff
0842   0354 38 0B 00      mov c, 11
0843   0357 19 FF         mov al, $ff
0844   0359             fdc_512_l8:
0845   0359 F7            stosb
0846   035A 7E            dec c
0847   035B C7 59 03      jnz fdc_512_l8
0848   035E             ; 6 times 00
0849   035E 38 06 00      mov c, 6
0850   0361 19 00         mov al, $00
0851   0363             fdc_512_l9:
0852   0363 F7            stosb
0853   0364 7E            dec c
0854   0365 C7 63 03      jnz fdc_512_l9
0855   0368             ; FB data address mark
0856   0368 19 FB         mov al, $fb
0857   036A             fdc_512_l10:
0858   036A F7            stosb
0859   036B             ; 128 bytes sector data
0860   036B 38 00 02      mov c, 512
0861   036E 19 E5         mov al, $E5
0862   0370             fdc_512_l11:
0863   0370 F7            stosb
0864   0371 7E            dec c
0865   0372 C7 70 03      jnz fdc_512_l11
0866   0375             ; 2 crc's
0867   0375             fdc_512_l12:
0868   0375 19 F7         mov al, $f7
0869   0377 F7            stosb
0870   0378             ; 10 * $FF
0871   0378 38 0A 00      mov c, 10
0872   037B 19 FF         mov al, $ff
0873   037D             fdc_512_l13:
0874   037D F7            stosb
0875   037E 7E            dec c
0876   037F C7 7D 03      jnz fdc_512_l13
0877   0382             ; check whether we did this 16 times
0878   0382 79            inc d
0879   0383 C5 06 00      cmp d, 6
0880   0386 C7 3A 03      jne fdc_512_inner_loop
0881   0389             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0882   0389 38 F4 01      mov c, 500
0883   038C 19 FF         mov al, $ff
0884   038E             fdc_512_format_footer:
0885   038E             fdc_512_footer_drq_loop:
0886   038E F7            stosb
0887   038F 7E            dec c
0888   0390 C7 8E 03      jnz fdc_512_footer_drq_loop
0889   0393 09            ret
0890   0394             
0891   0394             ; fetch is 2 cycles long when 'display_reg_load' is false.
0892   0394             ; 64us amounts to 160 cycles of the 2.5mhz clock
0893   0394             ; call u16 is 14 cycles long
0894   0394             ; 160 - 5 - 14 = 
0895   0394             fdc_wait_64us:
0896   0394 3A 0D         mov cl, 13                       ; 5 cycles
0897   0396             fdc_wait_64_loop:
0898   0396 81            dec cl                           ; 3 cycles
0899   0397 C7 96 03      jnz fdc_wait_64_loop             ; 8 cycles
0900   039A 09            ret
0901   039B             
0902   039B             ; number of seconds in b
0903   039B             wait_xs:
0904   039B C0 00 00      cmp b, 0
0905   039E C6 A9 03      je wait_xs_end
0906   03A1 07 AA 03      call wait_1s
0907   03A4 FD 7D         dec b
0908   03A6 0A 9B 03      jmp wait_xs
0909   03A9             wait_xs_end:
0910   03A9 09            ret
0911   03AA             
0912   03AA             wait_1s:
0913   03AA DB            push al
0914   03AB D9            push c
0915   03AC 19 03         mov al, 3
0916   03AE             wait_1s_l0:
0917   03AE 38 FF FF      mov c, 65535                       
0918   03B1             wait_1s_l1:
0919   03B1 7E            dec c        ; 4
0920   03B2 C7 B1 03      jnz wait_1s_l1   ; 8
0921   03B5 80            dec al
0922   03B6 C7 AE 03      jnz wait_1s_l0
0923   03B9 E6            pop c
0924   03BA E8            pop al
0925   03BB 09            ret
0926   03BC             
0927   03BC             ; ------------------------------------------------------------------------------------------------------------------;
0928   03BC             ; system syscalls
0929   03BC             ; ------------------------------------------------------------------------------------------------------------------;
0930   03BC             system_jmptbl:
0931   03BC F2 03         .dw system_uname
0932   03BE F9 03         .dw system_whoami
0933   03C0 CC 03         .dw system_poke
0934   03C2 CF 03         .dw system_bootloader_install
0935   03C4 CA 03         .dw system_peek
0936   03C6             syscall_system:
0937   03C6 FD 0A BC 03   jmp [system_jmptbl + al]
0938   03CA             
0939   03CA             ; param register address in register d
0940   03CA             ; param value in register bl
0941   03CA             system_peek:
0942   03CA 32            mov bl, [d]
0943   03CB 06            sysret
0944   03CC             
0945   03CC             ; param register address in register d
0946   03CC             ; param value in register bl
0947   03CC             system_poke:
0948   03CC FD 3E         mov [d], bl
0949   03CE 06            sysret
0950   03CF             
0951   03CF             ; kernel LBA address in 'b'
0952   03CF             system_bootloader_install:
0953   03CF D8            push b
0954   03D0 26 00 00      mov b, 0
0955   03D3 38 00 00      mov c, 0
0956   03D6 22 01         mov ah, $01                 ; 1 sector
0957   03D8 3B 8E 33      mov d, transient_area
0958   03DB 07 F6 06      call ide_read_sect          ; read sector
0959   03DE E5            pop b
0960   03DF FD 44 FE 01   mov [d + 510], b            ; update LBA address
0961   03E3 26 00 00      mov b, 0
0962   03E6 38 00 00      mov c, 0
0963   03E9 22 01         mov ah, $01                 ; 1 sector
0964   03EB 3B 8E 33      mov d, transient_area
0965   03EE 07 1C 07      call ide_write_sect         ; write sector
0966   03F1 06            sysret
0967   03F2             
0968   03F2             system_uname:
0969   03F2 3B 67 19      mov d, s_uname
0970   03F5 07 20 14      call _puts
0971   03F8 06            sysret
0972   03F9             
0973   03F9             system_whoami:
0974   03F9 06            sysret
0975   03FA             
0976   03FA             ; reboot system
0977   03FA             syscall_reboot:
0978   03FA FD D7 FF FF   push word $ffff 
0979   03FE FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0980   0401 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0981   0405 06            sysret
0982   0406             
0983   0406             ;------------------------------------------------------------------------------------------------------;;
0984   0406             ; switch to another process
0985   0406             ; inputs:
0986   0406             ; al = new process number
0987   0406             ;------------------------------------------------------------------------------------------------------;;
0988   0406             syscall_resume_proc:
0989   0406 FD 78         mov g, a                            ; save the process number
0990   0408 4B            pusha                               ; save all registers into kernel stack
0991   0409 22 00         mov ah, 0
0992   040B 1D 51 19      mov al, [active_proc_index]
0993   040E FD 99         shl a              ; x2
0994   0410 B7 8E 11      mov a, [proc_table_convert + a]     ; get process state start index
0995   0413 4F            mov di, a
0996   0414 48            mov a, sp
0997   0415 77            inc a
0998   0416 4D            mov si, a
0999   0417 38 14 00      mov c, 20
1000   041A FD F5         rep movsb                           ; save process state!
1001   041C             ; restore kernel stack position to point before interrupt arrived
1002   041C 51 14 00      add sp, 20
1003   041F             ; now load the new process number!
1004   041F FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
1005   0421 3D 51 19      mov [active_proc_index], al         ; set new active proc
1006   0424             ; calculate lut entry for next process
1007   0424 22 00         mov ah, 0
1008   0426 FD 99         shl a                               ; x2
1009   0428 B7 8E 11      mov a, [proc_table_convert + a]     ; get process state start index  
1010   042B 4D            mov si, a                           ; source is proc state block
1011   042C 48            mov a, sp
1012   042D 5F 13 00      sub a, 19
1013   0430 4F            mov di, a                           ; destination is kernel stack
1014   0431             ; restore sp
1015   0431 7D            dec a
1016   0432 47            mov sp, a
1017   0433 38 14 00      mov c, 20
1018   0436 FD F5         rep movsb
1019   0438             ; set vm process
1020   0438 1D 51 19      mov al, [active_proc_index]
1021   043B 01            setptb
1022   043C 4C            popa
1023   043D 06            sysret
1024   043E             
1025   043E             ;------------------------------------------------------------------------------------------------------;;
1026   043E             ; list processes
1027   043E             ;------------------------------------------------------------------------------------------------------;;
1028   043E             syscall_list_procs:
1029   043E 3B 88 19      mov d, s_ps_header
1030   0441 07 20 14      call _puts
1031   0444 3B FF 1C      mov d, proc_availab_table + 1
1032   0447 38 01 00      mov c, 1
1033   044A             list_procs_l0:  
1034   044A BD 01         cmp byte[d], 1
1035   044C C7 70 04      jne list_procs_next
1036   044F 2D            mov b, d
1037   0450 61 FE 1C      sub b, proc_availab_table
1038   0453 FD 9F 05      shl b, 5
1039   0456 DA            push d
1040   0457 D8            push b
1041   0458 28            mov b, c
1042   0459 07 C0 14      call print_u8x
1043   045C 22 20         mov ah, ' '
1044   045E 07 F4 12      call _putchar
1045   0461 07 F4 12      call _putchar
1046   0464 E5            pop b
1047   0465 74            mov d, b
1048   0466 58 0E 1D      add d, proc_names
1049   0469 07 20 14      call _puts
1050   046C 07 CD 13      call printnl
1051   046F E7            pop d
1052   0470             list_procs_next:
1053   0470 79            inc d
1054   0471 78            inc c
1055   0472 C2 09 00      cmp c, 9
1056   0475 C7 4A 04      jne list_procs_l0
1057   0478             list_procs_end:
1058   0478 06            sysret
1059   0479             
1060   0479             ; ------------------------------------------------------------------------------------------------------------------;
1061   0479             ; exceptions code block
1062   0479             ; ------------------------------------------------------------------------------------------------------------------;
1063   0479             ; privilege exception
1064   0479             ; ------------------------------------------------------------------------------------------------------------------;
1065   0479             trap_privilege:
1066   0479 0A FA 03      jmp syscall_reboot
1067   047C DA            push d
1068   047D 3B AF 1A      mov d, s_priviledge
1069   0480 07 20 14      call _puts
1070   0483 E7            pop d
1071   0484 06            sysret
1072   0485             
1073   0485             ; ------------------------------------------------------------------------------------------------------------------;
1074   0485             ; breakpoint
1075   0485             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
1076   0485             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
1077   0485             ; ------------------------------------------------------------------------------------------------------------------;
1078   0485             syscall_break:
1079   0485 4B            pusha
1080   0486             syscall_break_prompt:
1081   0486 3B 40 05      mov d, s_break1
1082   0489 07 20 14      call _puts
1083   048C 07 CD 13      call printnl
1084   048F 07 22 15      call scan_u16d
1085   0492 AF 00 00      cmp a, 0
1086   0495 C6 A0 04      je syscall_break_regs
1087   0498 AF 01 00      cmp a, 1
1088   049B C6 C3 04      je syscall_break_mem
1089   049E             syscall_break_end:  
1090   049E 4C            popa
1091   049F 06            sysret
1092   04A0             syscall_break_regs:
1093   04A0 48            mov a, sp
1094   04A1 53 0E 00      add a, 14               ; back-track 7 registers
1095   04A4 3C            mov d, a
1096   04A5 3A 07         mov cl, 7
1097   04A7             syscall_regs_l0:
1098   04A7 2A            mov b, [d]
1099   04A8 FD AB         swp b
1100   04AA 07 7C 14      call print_u16x         ; print register value
1101   04AD 07 CD 13      call printnl
1102   04B0 63 02 00      sub d, 2
1103   04B3 71 01         sub cl, 1
1104   04B5 C3 00         cmp cl, 0
1105   04B7 C7 A7 04      jne syscall_regs_l0
1106   04BA 0A 86 04      jmp syscall_break_prompt
1107   04BD 07 CD 13      call printnl
1108   04C0 0A 86 04      jmp syscall_break_prompt
1109   04C3             syscall_break_mem:
1110   04C3 07 CD 13      call printnl
1111   04C6 07 9E 14      call scan_u16x
1112   04C9 4D            mov si, a               ; data source from user space
1113   04CA FD 4F 8E 31   mov di, scrap_sector    ; destination in kernel space
1114   04CE 38 00 02      mov c, 512
1115   04D1 04            load                    ; transfer data to kernel space!
1116   04D2 3B 8E 31      mov d, scrap_sector     ; dump pointer in d
1117   04D5 38 00 00      mov c, 0
1118   04D8             dump_loop:
1119   04D8 84            mov al, cl
1120   04D9 87 0F         and al, $0f
1121   04DB C6 29 05      jz print_base
1122   04DE             back:
1123   04DE 1E            mov al, [d]             ; read byte
1124   04DF 2F            mov bl, al
1125   04E0 07 C0 14      call print_u8x
1126   04E3 10 00 20      mov a, $2000
1127   04E6 05 03         syscall sys_io          ; space
1128   04E8 84            mov al, cl
1129   04E9 87 0F         and al, $0f
1130   04EB B9 0F         cmp al, $0f
1131   04ED C6 FE 04      je print_ascii
1132   04F0             back1:
1133   04F0 79            inc d
1134   04F1 78            inc c
1135   04F2 C2 00 02      cmp c, 512
1136   04F5 C7 D8 04      jne dump_loop
1137   04F8 07 CD 13      call printnl
1138   04FB 0A 86 04      jmp syscall_break_prompt  ; go to syscall_break return point
1139   04FE             print_ascii:
1140   04FE 10 00 20      mov a, $2000
1141   0501 05 03         syscall sys_io
1142   0503 63 10 00      sub d, 16
1143   0506 26 10 00      mov b, 16
1144   0509             print_ascii_l:
1145   0509 79            inc d
1146   050A 1E            mov al, [d]               ; read byte
1147   050B B9 20         cmp al, $20
1148   050D C8 15 05      jlu dot
1149   0510 B9 7E         cmp al, $7e
1150   0512 D0 1D 05      jleu ascii
1151   0515             dot:
1152   0515 10 00 2E      mov a, $2e00
1153   0518 05 03         syscall sys_io
1154   051A 0A 22 05      jmp ascii_continue
1155   051D             ascii:
1156   051D 23            mov ah, al
1157   051E 19 00         mov al, 0
1158   0520 05 03         syscall sys_io
1159   0522             ascii_continue:
1160   0522 FD A9 09 05   loopb print_ascii_l
1161   0526 0A F0 04      jmp back1
1162   0529             print_base:
1163   0529 07 CD 13      call printnl
1164   052C 2D            mov b, d
1165   052D 61 8E 31      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
1166   0530 07 7C 14      call print_u16x          ; display row
1167   0533 10 00 3A      mov a, $3a00
1168   0536 05 03         syscall sys_io
1169   0538 10 00 20      mov a, $2000
1170   053B 05 03         syscall sys_io
1171   053D 0A DE 04      jmp back
1172   0540             
1173   0540             s_break1:  
1174   0540 0A 64 65 62   .db "\ndebugger entry point.\n"
1174   0544 75 67 67 65 
1174   0548 72 20 65 6E 
1174   054C 74 72 79 20 
1174   0550 70 6F 69 6E 
1174   0554 74 2E 0A 
1175   0557 30 2E 20 73   .db "0. show registers\n"
1175   055B 68 6F 77 20 
1175   055F 72 65 67 69 
1175   0563 73 74 65 72 
1175   0567 73 0A 
1176   0569 31 2E 20 73   .db "1. show 512b ram block\n"
1176   056D 68 6F 77 20 
1176   0571 35 31 32 62 
1176   0575 20 72 61 6D 
1176   0579 20 62 6C 6F 
1176   057D 63 6B 0A 
1177   0580 32 2E 20 63   .db "2. continue execution", 0
1177   0584 6F 6E 74 69 
1177   0588 6E 75 65 20 
1177   058C 65 78 65 63 
1177   0590 75 74 69 6F 
1177   0594 6E 00 
1178   0596             
1179   0596             ; ------------------------------------------------------------------------------------------------------------------;
1180   0596             ; divide by zero exception
1181   0596             ; ------------------------------------------------------------------------------------------------------------------;
1182   0596             trap_div_zero:
1183   0596 D7            push a
1184   0597 DA            push d
1185   0598 E1            pushf
1186   0599 3B C6 1A      mov d, s_divzero
1187   059C 07 20 14      call _puts
1188   059F EE            popf
1189   05A0 E7            pop d
1190   05A1 E4            pop a
1191   05A2 06            sysret ; enable interrupts
1192   05A3             
1193   05A3             ; ------------------------------------------------------------------------------------------------------------------;
1194   05A3             ; undefined opcode exception
1195   05A3             ; ------------------------------------------------------------------------------------------------------------------;
1196   05A3             trap_undef_opcode:
1197   05A3 06            sysret
1198   05A4             
1199   05A4             ; ------------------------------------------------------------------------------------------------------------------;
1200   05A4             ; real-time clock services syscall
1201   05A4             ; rtc i/o bank = ffa0 to ffaf
1202   05A4             ; ffa0 to ffa7 is scratch ram
1203   05A4             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
1204   05A4             ; al = 0..6 -> get
1205   05A4             ; al = 7..d -> set
1206   05A4             ; ------------------------------------------------------------------------------------------------------------------;
1207   05A4             syscall_rtc:
1208   05A4 DB            push al
1209   05A5 DA            push d
1210   05A6 B9 06         cmp al, 6
1211   05A8 D1 BD 05      jgu syscall_rtc_set
1212   05AB             syscall_rtc_get:
1213   05AB 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
1214   05AD 22 FF         mov ah, $ff    
1215   05AF 3C            mov d, a                ; get to ffa9 + offset
1216   05B0 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
1217   05B4 1E            mov al, [d]             ; get data
1218   05B5 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
1219   05B9 23            mov ah, al
1220   05BA E7            pop d
1221   05BB E8            pop al
1222   05BC 06            sysret
1223   05BD             syscall_rtc_set:
1224   05BD DD            push bl
1225   05BE 99            mov bl, ah              ; set data aside
1226   05BF 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
1227   05C1 22 FF         mov ah, $ff    
1228   05C3 3C            mov d, a                ; get to ffa9 + offset
1229   05C4 1B            mov al, bl              ; get data back
1230   05C5 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
1231   05C9 3E            mov [d], al             ; set data
1232   05CA F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
1233   05CE EA            pop bl
1234   05CF E7            pop d
1235   05D0 E8            pop al
1236   05D1 06            sysret
1237   05D2             
1238   05D2             datetime_serv_tbl:
1239   05D2 DA 05         .dw print_date
1240   05D4 4E 06         .dw set_date
1241   05D6             syscall_datetime:
1242   05D6 FD 0A D2 05   jmp [datetime_serv_tbl + al]      
1243   05DA             print_date:
1244   05DA 10 00 0D      mov a, $0d00           ; print carriage return char
1245   05DD 19 03         mov al, 3
1246   05DF 05 01         syscall sys_rtc        ; get week
1247   05E1 1A            mov al, ah
1248   05E2 22 00         mov ah, 0
1249   05E4 FD 9D 02      shl a, 2          
1250   05E7 3B 50 1B      mov d, s_week
1251   05EA 59            add d, a
1252   05EB 07 20 14      call _puts
1253   05EE 10 00 20      mov a, $2000
1254   05F1 05 03         syscall sys_io         ; display ' '
1255   05F3 19 04         mov al, 4
1256   05F5 05 01         syscall sys_rtc        ; get day
1257   05F7 99            mov bl, ah
1258   05F8 07 C0 14      call print_u8x
1259   05FB 10 00 20      mov a, $2000
1260   05FE 05 03         syscall sys_io         ; display ' '
1261   0600             ; there is a problem with the month displaying
1262   0600             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
1263   0600             ; even though it is to be understood as bcd.
1264   0600             ; when retrieving the value and adding the string table address offset the value will go overboard!  
1265   0600 19 05         mov al, 05
1266   0602 05 01         syscall sys_rtc        ; get month
1267   0604 1A            mov al, ah
1268   0605 22 00         mov ah, 0
1269   0607 FD 9D 02      shl a, 2          
1270   060A 3B 1C 1B      mov d, s_months
1271   060D 59            add d, a
1272   060E 07 20 14      call _puts
1273   0611 10 00 20      mov a, $2000
1274   0614 05 03         syscall sys_io         ; display ' '
1275   0616 2E 20         mov bl, $20
1276   0618 07 C0 14      call print_u8x         ; print 20 for year prefix
1277   061B 19 06         mov al, 06
1278   061D 05 01         syscall sys_rtc        ; get year
1279   061F 99            mov bl, ah
1280   0620 07 C0 14      call print_u8x
1281   0623 10 00 20      mov a, $2000  
1282   0626 05 03         syscall sys_io         ; display ' '
1283   0628 19 02         mov al, 2
1284   062A 05 01         syscall sys_rtc        ; get hours
1285   062C 99            mov bl, ah
1286   062D 07 C0 14      call print_u8x
1287   0630 10 00 3A      mov a, $3a00    
1288   0633 05 03         syscall sys_io         ; display ':'
1289   0635 19 01         mov al, 01
1290   0637 05 01         syscall sys_rtc        ; get minutes
1291   0639 99            mov bl, ah
1292   063A 07 C0 14      call print_u8x
1293   063D 10 00 3A      mov a, $3a00  
1294   0640 05 03         syscall sys_io         ; display ':'
1295   0642 19 00         mov al, 0
1296   0644 05 01         syscall sys_rtc        ; get seconds
1297   0646 99            mov bl, ah
1298   0647 07 C0 14      call print_u8x
1299   064A 07 CD 13      call printnl
1300   064D 06            sysret
1301   064E             set_date:
1302   064E 3B E1 1A      mov d, s_set_year
1303   0651 07 20 14      call _puts
1304   0654 07 0B 15      call scan_u8x          ; read integer into a
1305   0657 FD 9D 08      shl a, 8               ; only al used, move to ah
1306   065A 19 0D         mov al, 0dh            ; set rtc year
1307   065C 05 01         syscall sys_rtc        ; set rtc
1308   065E 3B E8 1A      mov d, s_set_month
1309   0661 07 20 14      call _puts
1310   0664 07 0B 15      call scan_u8x          ; read integer into a
1311   0667 FD 9D 08      shl a, 8               ; only al used, move to ah
1312   066A 19 0C         mov al, 0ch            ; set rtc month
1313   066C 05 01         syscall sys_rtc        ; set rtc
1314   066E 3B F0 1A      mov d, s_set_day
1315   0671 07 20 14      call _puts
1316   0674 07 0B 15      call scan_u8x          ; read integer into a
1317   0677 FD 9D 08      shl a, 8               ; only al used, move to ah
1318   067A 19 0B         mov al, 0bh            ; set rtc month
1319   067C 05 01         syscall sys_rtc        ; set rtc
1320   067E 3B F6 1A      mov d, s_set_week
1321   0681 07 20 14      call _puts
1322   0684 07 0B 15      call scan_u8x          ; read integer into a
1323   0687 FD 9D 08      shl a, 8               ; only al used, move to ah
1324   068A 19 0A         mov al, 0ah            ; set rtc month
1325   068C 05 01         syscall sys_rtc        ; set rtc
1326   068E 3B 00 1B      mov d, s_set_hours
1327   0691 07 20 14      call _puts
1328   0694 07 0B 15      call scan_u8x          ; read integer into a
1329   0697 FD 9D 08      shl a, 8               ; only al used, move to ah
1330   069A 19 09         mov al, 09h            ; set rtc month
1331   069C 05 01         syscall sys_rtc        ; set rtc
1332   069E 3B 08 1B      mov d, s_set_minutes
1333   06A1 07 20 14      call _puts
1334   06A4 07 0B 15      call scan_u8x          ; read integer into a
1335   06A7 FD 9D 08      shl a, 8               ; only al used, move to ah
1336   06AA 19 08         mov al, 08h            ; set rtc month
1337   06AC 05 01         syscall sys_rtc        ; set rtc
1338   06AE 3B 12 1B      mov d, s_set_seconds
1339   06B1 07 20 14      call _puts
1340   06B4 07 0B 15      call scan_u8x          ; read integer into a
1341   06B7 FD 9D 08      shl a, 8               ; only al used, move to ah
1342   06BA 19 07         mov al, 07h            ; set rtc month
1343   06BC 05 01         syscall sys_rtc        ; set rtc
1344   06BE 06            sysret
1345   06BF             
1346   06BF             ; ------------------------------------------------------------------------------------------------------------------;
1347   06BF             ; ide services syscall
1348   06BF             ; al = option
1349   06BF             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1350   06BF             ; ide read/write sector
1351   06BF             ; 512 bytes
1352   06BF             ; user buffer pointer in d
1353   06BF             ; ah = number of sectors
1354   06BF             ; cb = lba bytes 3..0
1355   06BF             ; ------------------------------------------------------------------------------------------------------------------;
1356   06BF             ide_serv_tbl:
1357   06BF CB 06         .dw ide_reset
1358   06C1 DF 06         .dw ide_sleep
1359   06C3 EE 06         .dw ide_read_sect_wrapper
1360   06C5 F2 06         .dw ide_write_sect_wrapper
1361   06C7             syscall_ide:
1362   06C7 FD 0A BF 06   jmp [ide_serv_tbl + al]    
1363   06CB             
1364   06CB             ide_reset:      
1365   06CB F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1366   06CF 07 78 07      call ide_wait                   ; wait for ide ready             
1367   06D2 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1368   06D6 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1369   06DA F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1370   06DE 06            sysret
1371   06DF             ide_sleep:
1372   06DF 07 78 07      call ide_wait                   ; wait for ide ready             
1373   06E2 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1374   06E6 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1375   06EA 07 78 07      call ide_wait                   ; wait for ide ready
1376   06ED 06            sysret
1377   06EE             ide_read_sect_wrapper:
1378   06EE 07 F6 06      call ide_read_sect
1379   06F1 06            sysret
1380   06F2             ide_write_sect_wrapper:
1381   06F2 07 1C 07      call ide_write_sect
1382   06F5 06            sysret
1383   06F6             ide_read_sect:
1384   06F6 1A            mov al, ah
1385   06F7 24            mov ah, bl
1386   06F8 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1387   06FB 1C            mov al, bh
1388   06FC 3D D4 FF      mov [_ide_r4], al
1389   06FF 12            mov a, c
1390   0700 3D D5 FF      mov [_ide_r5], al
1391   0703 1A            mov al, ah
1392   0704 87 0F         and al, %00001111
1393   0706 8B E0         or al, %11100000                ; mode lba, master
1394   0708 3D D6 FF      mov [_ide_r6], al
1395   070B             ide_read_sect_wait:
1396   070B 1D D7 FF      mov al, [_ide_r7]  
1397   070E 87 80         and al, $80                     ; busy flag
1398   0710 C7 0B 07      jnz ide_read_sect_wait
1399   0713 19 20         mov al, $20
1400   0715 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1401   0718 07 42 07      call ide_read  
1402   071B 09            ret
1403   071C             ide_write_sect:
1404   071C 1A            mov al, ah
1405   071D 24            mov ah, bl
1406   071E 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1407   0721 1C            mov al, bh
1408   0722 3D D4 FF      mov [_ide_r4], al
1409   0725 12            mov a, c
1410   0726 3D D5 FF      mov [_ide_r5], al
1411   0729 1A            mov al, ah
1412   072A 87 0F         and al, %00001111
1413   072C 8B E0         or al, %11100000                ; mode lba, master
1414   072E 3D D6 FF      mov [_ide_r6], al
1415   0731             ide_write_sect_wait:
1416   0731 1D D7 FF      mov al, [_ide_r7]  
1417   0734 87 80         and al, $80                     ; busy flag
1418   0736 C7 31 07      jnz ide_write_sect_wait
1419   0739 19 30         mov al, $30
1420   073B 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1421   073E 07 5D 07      call ide_write      
1422   0741 09            ret
1423   0742             
1424   0742             ;----------------------------------------------------------------------------------------------------;
1425   0742             ; read ide data
1426   0742             ; pointer in d
1427   0742             ;----------------------------------------------------------------------------------------------------;
1428   0742             ide_read:
1429   0742 DA            push d
1430   0743             ide_read_loop:
1431   0743 1D D7 FF      mov al, [_ide_r7]  
1432   0746 87 80         and al, 80h                     ; busy flag
1433   0748 C7 43 07      jnz ide_read_loop               ; wait loop
1434   074B 1D D7 FF      mov al, [_ide_r7]
1435   074E 87 08         and al, %00001000               ; drq flag
1436   0750 C6 5B 07      jz ide_read_end
1437   0753 1D D0 FF      mov al, [_ide_r0]
1438   0756 3E            mov [d], al
1439   0757 79            inc d
1440   0758 0A 43 07      jmp ide_read_loop
1441   075B             ide_read_end:
1442   075B E7            pop d
1443   075C 09            ret
1444   075D             
1445   075D             ;----------------------------------------------------------------------------------------------------;
1446   075D             ; write ide data
1447   075D             ; data pointer in d
1448   075D             ;----------------------------------------------------------------------------------------------------;
1449   075D             ide_write:
1450   075D DA            push d
1451   075E             ide_write_loop:
1452   075E 1D D7 FF      mov al, [_ide_r7]  
1453   0761 87 80         and al, 80h             ; busy flag
1454   0763 C7 5E 07      jnz ide_write_loop      ; wait loop
1455   0766 1D D7 FF      mov al, [_ide_r7]
1456   0769 87 08         and al, %00001000       ; drq flag
1457   076B C6 76 07      jz ide_write_end
1458   076E 1E            mov al, [d]
1459   076F 3D D0 FF      mov [_ide_r0], al
1460   0772 79            inc d 
1461   0773 0A 5E 07      jmp ide_write_loop
1462   0776             ide_write_end:
1463   0776 E7            pop d
1464   0777 09            ret
1465   0778             
1466   0778             ;----------------------------------------------------------------------------------------------------;
1467   0778             ; wait for ide to be ready
1468   0778             ;----------------------------------------------------------------------------------------------------;
1469   0778             ide_wait:
1470   0778 1D D7 FF      mov al, [_ide_r7]  
1471   077B 87 80         and al, 80h        ; busy flag
1472   077D C7 78 07      jnz ide_wait
1473   0780 09            ret
1474   0781             
1475   0781             ;----------------------------------------------------------------------------------------------------;
1476   0781             ; io syscall
1477   0781             ;----------------------------------------------------------------------------------------------------;
1478   0781             ; baud  divisor
1479   0781             ; 50    2304
1480   0781             ; 110   1047
1481   0781             ; 300    384
1482   0781             ; 600    192
1483   0781             ; 1200    96
1484   0781             ; 9600    12
1485   0781             ; 19200    6
1486   0781             ; 38400    3
1487   0781             syscall_io_jmp:
1488   0781 B4 07         .dw syscall_io_putchar
1489   0783 C1 07         .dw syscall_io_getch
1490   0785 8B 07         .dw syscall_io_uart_setup
1491   0787             syscall_io:
1492   0787 FD 0A 81 07   jmp [syscall_io_jmp + al]
1493   078B             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1494   078B             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1495   078B             ; buffer, the transmitter holding register, or the interrupt enable register.
1496   078B             syscall_io_uart_setup:
1497   078B 1D 4B 19      mov al, [sys_uart1_lcr]
1498   078E 8B 80         or al, $80                ; set dlab access bit
1499   0790 3D 8B FF      mov [_uart1_lcr], al      ; 8 data, 2 stop, no parity by default
1500   0793 1D 4E 19      mov al, [sys_uart1_div0]
1501   0796 3D 88 FF      mov [_uart1_dlab_0], al   ; divisor latch byte 0
1502   0799 1D 4F 19      mov al, [sys_uart1_div1]
1503   079C 3D 89 FF      mov [_uart1_dlab_1], al   ; divisor latch byte 1      
1504   079F             
1505   079F 1D 4B 19      mov al, [sys_uart1_lcr]
1506   07A2 87 7F         and al, $7f               ; clear dlab access bit 
1507   07A4 3D 8B FF      mov [_uart1_lcr], al
1508   07A7 1D 4C 19      mov al, [sys_uart1_inten]
1509   07AA 3D 89 FF      mov [_uart1_ier], al      ; interrupts
1510   07AD 1D 4D 19      mov al, [sys_uart1_fifoen]
1511   07B0 3D 8A FF      mov [_uart1_fcr], al      ; fifo control
1512   07B3 06            sysret
1513   07B4             
1514   07B4             ; char in ah
1515   07B4             syscall_io_putchar:
1516   07B4             syscall_io_putchar_l0:
1517   07B4 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1518   07B7 87 20         and al, $20
1519   07B9 C6 B4 07      jz syscall_io_putchar_l0    
1520   07BC 1A            mov al, ah
1521   07BD 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1522   07C0 06            sysret
1523   07C1             
1524   07C1             ; char in ah
1525   07C1             ; al = sucess code
1526   07C1             syscall_io_getch:
1527   07C1 D8            push b
1528   07C2 DA            push d
1529   07C3 FD 0C         sti
1530   07C5             syscall_io_getch_l0:  
1531   07C5 14 58 19      mov a, [fifo_out]
1532   07C8 29 56 19      mov b, [fifo_in]
1533   07CB B0            cmp a, b
1534   07CC C6 C5 07      je syscall_io_getch_l0
1535   07CF 3C            mov d, a
1536   07D0 77            inc a
1537   07D1 AF 8E 31      cmp a, fifo + _fifo_size      ; check if pointer reached the end of the fifo
1538   07D4 C7 DA 07      jne syscall_io_getch_cont
1539   07D7 10 8E 21      mov a, fifo  
1540   07DA             syscall_io_getch_cont:  
1541   07DA 42 58 19      mov [fifo_out], a             ; update fifo pointer
1542   07DD 1E            mov al, [d]                   ; get char
1543   07DE 23            mov ah, al
1544   07DF 1D 4A 19      mov al, [sys_echo_on]
1545   07E2 B9 01         cmp al, 1
1546   07E4 C7 F3 07      jne syscall_io_getch_noecho 
1547   07E7             ; here we just echo the char back to the console
1548   07E7             syscall_io_getch_echo_l0:
1549   07E7 1D 8D FF      mov al, [_uart1_lsr]         ; read line status register
1550   07EA 87 20         and al, $20                 ; isolate transmitter empty
1551   07EC C6 E7 07      jz syscall_io_getch_echo_l0
1552   07EF 1A            mov al, ah
1553   07F0 3D 88 FF      mov [_uart1_data], al        ; write char to transmitter holding register
1554   07F3             syscall_io_getch_noecho:
1555   07F3 19 01         mov al, 1                    ; al = 1 means a char successfully received
1556   07F5 E7            pop d
1557   07F6 E5            pop b
1558   07F7 06            sysret
1559   07F8             
1560   07F8             ;------------------------------------------------------------------------------------------------------;
1561   07F8             ; file system data
1562   07F8             ;------------------------------------------------------------------------------------------------------;
1563   07F8             ; infor for : ide services interrupt
1564   07F8             ; ide read/write 512-byte sector
1565   07F8             ; al = option
1566   07F8             ; user buffer pointer in d
1567   07F8             ; ah = number of sectors
1568   07F8             ; cb = lba bytes 3..0  
1569   07F8             ;------------------------------------------------------------------------------------------------------;
1570   07F8             ; file system data structure
1571   07F8             ;------------------------------------------------------------------------------------------------------;
1572   07F8             ; for a directory we have the header first, followed by metadata
1573   07F8             ; header 1 sector (512 bytes)
1574   07F8             ; metadata 1 sector (512 bytes)
1575   07F8             ; header entries:
1576   07F8             ; filename (64)
1577   07F8             ; parent dir lba (2) -  to be used for faster backwards navigation...
1578   07F8             ;
1579   07F8             ; metadata entries:
1580   07F8             ; filename (24)
1581   07F8             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1582   07F8             ; lba (2)
1583   07F8             ; size (2)
1584   07F8             ; day (1)
1585   07F8             ; month (1)
1586   07F8             ; year (1)
1587   07F8             ; packet size = 32 bytes
1588   07F8             ;
1589   07F8             ; first directory on disk is the root directory '/'
1590   07F8             file_system_jmptbl:
1591   07F8 63 08         .dw fs_mkfs                   ; 0
1592   07FA 00 00         .dw 0                         ; 1
1593   07FC C5 08         .dw fs_mkdir                  ; 2
1594   07FE 3E 0C         .dw fs_cd                     ; 3
1595   0800 45 0C         .dw fs_ls                     ; 4
1596   0802 30 0D         .dw fs_mktxt                  ; 5
1597   0804 FB 0D         .dw fs_mkbin                  ; 6
1598   0806 C2 0E         .dw fs_pwd                    ; 7
1599   0808 DF 0E         .dw fs_cat                    ; 8
1600   080A 3B 0F         .dw fs_rmdir                  ; 9
1601   080C 97 0F         .dw fs_rm                     ; 10
1602   080E 00 00         .dw 0                         ; 11
1603   0810 00 00         .dw 0                         ; 12
1604   0812 00 00         .dw 0                         ; 13
1605   0814 6B 08         .dw fs_chmod                  ; 14
1606   0816 FF 0F         .dw fs_mv                     ; 15
1607   0818 64 08         .dw fs_cd_root                ; 16
1608   081A 3A 0C         .dw fs_get_curr_dirid         ; 17
1609   081C 16 0A         .dw fs_dir_id_to_path         ; 18
1610   081E 7C 0A         .dw fs_path_to_dir_id_user    ; 19
1611   0820 96 0B         .dw fs_load_from_path_user    ; 20  
1612   0822 06 0B         .dw fs_filepath_exists_user   ; 21
1613   0824             
1614   0824 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1614   0828 79 73 63 61 
1614   082C 6C 6C 5F 66 
1614   0830 69 6C 65 5F 
1614   0834 73 79 73 74 
1614   0838 65 6D 20 63 
1614   083C 61 6C 6C 65 
1614   0840 64 3A 20 00 
1615   0844             syscall_file_system:
1616   0844 DD            push bl
1617   0845 31 49 19      mov bl, [sys_debug_mode]
1618   0848               ; debug block
1619   0848 C1 00         cmp bl, 0
1620   084A EA            pop bl
1621   084B C6 5F 08      je syscall_filesystem_jmp
1622   084E DA            push d
1623   084F DD            push bl
1624   0850 3B 24 08      mov d, s_syscall_fs_dbg0
1625   0853 07 20 14      call _puts
1626   0856 2F            mov bl, al
1627   0857 07 C0 14      call print_u8x
1628   085A 07 CD 13      call printnl
1629   085D EA            pop bl
1630   085E E7            pop d
1631   085F             syscall_filesystem_jmp:
1632   085F FD 0A F8 07   jmp [file_system_jmptbl + al]
1633   0863             
1634   0863             fs_mkfs:  
1635   0863 06            sysret  
1636   0864               
1637   0864             fs_cd_root:
1638   0864 10 20 00      mov a, root_id
1639   0867 42 5A 19      mov [current_dir_id], a      ; set current directory lba to root
1640   086A 06            sysret  
1641   086B             
1642   086B             ; filename in d (userspace data)
1643   086B             ; permission in bl
1644   086B             fs_chmod:
1645   086B DD            push bl
1646   086C FD 4E         mov si, d
1647   086E FD 4F 8E 1F   mov di, user_data
1648   0872 38 80 00      mov c, 128
1649   0875 04            load                        ; load filename from user-space
1650   0876 14 5A 19      mov a, [current_dir_id]
1651   0879 77            inc a                       ; metadata sector
1652   087A 27            mov b, a
1653   087B 38 00 00      mov c, 0                    ; upper lba = 0
1654   087E 22 01         mov ah, $01                  ; 1 sector
1655   0880 3B 8E 33      mov d, transient_area
1656   0883 07 F6 06      call ide_read_sect          ; read directory
1657   0886 FD 10         cla
1658   0888 42 52 19      mov [index], a              ; reset file counter
1659   088B             fs_chmod_l1:
1660   088B FD 4E         mov si, d
1661   088D FD 4F 8E 1F   mov di, user_data
1662   0891 07 63 12      call _strcmp
1663   0894 C6 AB 08      je fs_chmod_found_entry
1664   0897 58 20 00      add d, 32
1665   089A 14 52 19      mov a, [index]
1666   089D 77            inc a
1667   089E 42 52 19      mov [index], a
1668   08A1 AF 10 00      cmp a, fst_files_per_dir
1669   08A4 C7 8B 08      jne fs_chmod_l1
1670   08A7 EA            pop bl
1671   08A8 0A C4 08      jmp fs_chmod_not_found
1672   08AB             fs_chmod_found_entry:  
1673   08AB FD 79         mov g, b                    ; save lba
1674   08AD EA            pop bl                      ; retrieve saved permission value
1675   08AE 1F 18 00      mov al, [d + 24]            ; read file permissions
1676   08B1 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1677   08B3 8C            or al, bl                   ; set new permissions
1678   08B4 3F 18 00      mov [d + 24], al            ; write new permissions
1679   08B7 38 00 00      mov c, 0
1680   08BA 3B 8E 33      mov d, transient_area
1681   08BD 22 01         mov ah, $01                 ; disk write 1 sect
1682   08BF FD 27         mov b, g                    ; retrieve lba
1683   08C1 07 1C 07      call ide_write_sect         ; write sector
1684   08C4             fs_chmod_not_found:
1685   08C4 06            sysret
1686   08C5             
1687   08C5             ;------------------------------------------------------------------------------------------------------;
1688   08C5             ; create new directory
1689   08C5             ;------------------------------------------------------------------------------------------------------;
1690   08C5             ; search list for null name entry. add new directory to list
1691   08C5             fs_mkdir:
1692   08C5 FD 4E         mov si, d
1693   08C7 FD 4F 8E 1F   mov di, user_data
1694   08CB 38 00 02      mov c, 512
1695   08CE 04            load                        ; load data from user-space
1696   08CF 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1697   08D2                                           ; when checking for null name, since root has a null name)
1698   08D2 38 00 00      mov c, 0                    ; upper lba = 0
1699   08D5             fs_mkdir_l1:  
1700   08D5 22 01         mov ah, $01                  ; 1 sector
1701   08D7 3B 8E 33      mov d, transient_area
1702   08DA 07 F6 06      call ide_read_sect          ; read sector
1703   08DD BD 00         cmp byte[d], 0              ; check for null
1704   08DF C6 E8 08      je fs_mkdir_found_null
1705   08E2 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1706   08E5 0A D5 08      jmp fs_mkdir_l1
1707   08E8             fs_mkdir_found_null:
1708   08E8             ;create header file by grabbing dir name from parameter
1709   08E8 D8            push b                      ; save new directory's lba
1710   08E9 38 40 00      mov c, 64
1711   08EC FD 4D 8E 1F   mov si, user_data
1712   08F0 FD 4F 8E 33   mov di, transient_area
1713   08F4 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1714   08F6 14 5A 19      mov a, [current_dir_id]
1715   08F9 42 CE 33      mov [transient_area + 64], a    ; store parent directory lba
1716   08FC 19 00         mov al, 0
1717   08FE FD 4F 8E 35   mov di, transient_area + 512
1718   0902 38 00 02      mov c, 512
1719   0905 FD F7         rep stosb                       ; clean buffer
1720   0907 38 00 00      mov c, 0                        ; reset lba(c) to 0
1721   090A             ; write directory entry sectors
1722   090A 3B 8E 33      mov d, transient_area
1723   090D 22 02         mov ah, $02                     ; disk write, 2 sectors
1724   090F 07 1C 07      call ide_write_sect             ; write sector
1725   0912             ; now we need to add the new directory to the list, inside the current directory
1726   0912 14 5A 19      mov a, [current_dir_id]
1727   0915 53 01 00      add a, 1
1728   0918 27            mov b, a                        ; metadata sector
1729   0919 38 00 00      mov c, 0
1730   091C FD 79         mov g, b                        ; save lba
1731   091E 3B 8E 33      mov d, transient_area
1732   0921 22 01         mov ah, $01                  ; 1 sector
1733   0923 07 F6 06      call ide_read_sect              ; read metadata sector
1734   0926             fs_mkdir_l2:
1735   0926 BD 00         cmp byte[d], 0
1736   0928 C6 31 09      je fs_mkdir_found_null2
1737   092B 58 20 00      add d, fst_entry_size
1738   092E 0A 26 09      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1739   0931             fs_mkdir_found_null2:
1740   0931 FD 4D 8E 1F   mov si, user_data
1741   0935 FD 50         mov di, d
1742   0937 07 78 12      call _strcpy                    ; copy directory name
1743   093A 58 18 00      add d, 24                       ; goto attributes
1744   093D 19 0B         mov al, %00001011               ; directory, no execute, write, read
1745   093F 3E            mov [d], al      
1746   0940 79            inc d
1747   0941 E5            pop b
1748   0942 D8            push b                          ; push lba back
1749   0943 FD 43         mov [d], b                      ; save lba
1750   0945             ; set file creation date  
1751   0945 58 04 00      add d, 4
1752   0948 19 04         mov al, 4
1753   094A 05 01         syscall sys_rtc
1754   094C 1A            mov al, ah
1755   094D 3E            mov [d], al                     ; set day
1756   094E 79            inc d
1757   094F 19 05         mov al, 5
1758   0951 05 01         syscall sys_rtc
1759   0953 1A            mov al, ah
1760   0954 3E            mov [d], al                     ; set month
1761   0955 79            inc d
1762   0956 19 06         mov al, 6
1763   0958 05 01         syscall sys_rtc
1764   095A 1A            mov al, ah
1765   095B 3E            mov [d], al                     ; set year
1766   095C             ; write sector into disk for new directory entry
1767   095C FD 27         mov b, g
1768   095E 38 00 00      mov c, 0
1769   0961 3B 8E 33      mov d, transient_area
1770   0964 22 01         mov ah, $01                     ; disk write, 1 sector
1771   0966 07 1C 07      call ide_write_sect             ; write sector
1772   0969             
1773   0969             ; after adding the new directory's information to its parent directory's list
1774   0969             ; we need to now enter the new directory, and to it add two new directories!
1775   0969             ; which directories do we need to add ? '..' and '.' are the directories needed.
1776   0969             ; importantly, note that these two new directories are only entries in the list
1777   0969             ; and do not have actual physical entries in the disk as real directories.
1778   0969             ; i.e. they only exist as list entries in the new directory created so that
1779   0969             ; the new directory can reference its parent and itself.
1780   0969             ; we need to add both '..' and '.'
1781   0969             ; this first section is for '..' and on the section below we do the same for '.'
1782   0969 E4            pop a                         ; retrieve the new directory's lba  
1783   096A D7            push a                        ; and save again
1784   096B 53 01 00      add a, 1
1785   096E 27            mov b, a                      ; metadata sector
1786   096F 38 00 00      mov c, 0
1787   0972 FD 79         mov g, b                      ; save lba
1788   0974 3B 8E 33      mov d, transient_area
1789   0977 22 01         mov ah, $01                  ; 1 sector
1790   0979 07 F6 06      call ide_read_sect            ; read metadata sector
1791   097C             fs_mkdir_l3:
1792   097C BD 00         cmp byte[d], 0
1793   097E C6 87 09      je fs_mkdir_found_null3
1794   0981 58 20 00      add d, fst_entry_size
1795   0984 0A 7C 09      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1796   0987             fs_mkdir_found_null3:
1797   0987 FD 4D 79 19   mov si, s_parent_dir
1798   098B FD 50         mov di, d
1799   098D 07 78 12      call _strcpy                  ; copy directory name
1800   0990 58 18 00      add d, 24                     ; goto attributes
1801   0993 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1802   0995 3E            mov [d], al      
1803   0996 79            inc d
1804   0997 29 5A 19      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1805   099A FD 43         mov [d], b                    ; save lba
1806   099C             ; set file creation date  
1807   099C 58 04 00      add d, 4
1808   099F 19 04         mov al, 4
1809   09A1 05 01         syscall sys_rtc
1810   09A3 1A            mov al, ah
1811   09A4 3E            mov [d], al                   ; set day
1812   09A5 79            inc d
1813   09A6 19 05         mov al, 5
1814   09A8 05 01         syscall sys_rtc
1815   09AA 1A            mov al, ah
1816   09AB 3E            mov [d], al                   ; set month
1817   09AC 79            inc d
1818   09AD 19 06         mov al, 6
1819   09AF 05 01         syscall sys_rtc
1820   09B1 1A            mov al, ah
1821   09B2 3E            mov [d], al                   ; set year
1822   09B3             ; write sector into disk for new directory entry
1823   09B3 FD 27         mov b, g
1824   09B5 38 00 00      mov c, 0
1825   09B8 3B 8E 33      mov d, transient_area
1826   09BB 22 01         mov ah, $01                   ; disk write, 1 sector
1827   09BD 07 1C 07      call ide_write_sect           ; write sector
1828   09C0             ;;;;;;;;;;;;;
1829   09C0             ; like we did above for '..', we need to now add the '.' directory to the list.
1830   09C0             ;------------------------------------------------------------------------------------------------------;
1831   09C0 E4            pop a                         ; retrieve the new directory's lba  
1832   09C1 D7            push a
1833   09C2 53 01 00      add a, 1
1834   09C5 27            mov b, a                      ; metadata sector
1835   09C6 38 00 00      mov c, 0
1836   09C9 FD 79         mov g, b                      ; save lba
1837   09CB 3B 8E 33      mov d, transient_area
1838   09CE 22 01         mov ah, $01                  ; 1 sector
1839   09D0 07 F6 06      call ide_read_sect            ; read metadata sector
1840   09D3             fs_mkdir_l4:
1841   09D3 BD 00         cmp byte[d], 0
1842   09D5 C6 DE 09      je fs_mkdir_found_null4
1843   09D8 58 20 00      add d, fst_entry_size
1844   09DB 0A D3 09      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1845   09DE             fs_mkdir_found_null4:
1846   09DE FD 4D 7C 19   mov si, s_current_dir
1847   09E2 FD 50         mov di, d
1848   09E4 07 78 12      call _strcpy                  ; copy directory name
1849   09E7 58 18 00      add d, 24                     ; goto attributes
1850   09EA 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1851   09EC 3E            mov [d], al      
1852   09ED 79            inc d
1853   09EE E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1854   09EF FD 43         mov [d], b                    ; save lba
1855   09F1             ; set file creation date  
1856   09F1 58 04 00      add d, 4
1857   09F4 19 04         mov al, 4
1858   09F6 05 01         syscall sys_rtc
1859   09F8 1A            mov al, ah
1860   09F9 3E            mov [d], al                   ; set day
1861   09FA 79            inc d
1862   09FB 19 05         mov al, 5
1863   09FD 05 01         syscall sys_rtc
1864   09FF 1A            mov al, ah
1865   0A00 3E            mov [d], al                   ; set month
1866   0A01 79            inc d
1867   0A02 19 06         mov al, 6
1868   0A04 05 01         syscall sys_rtc
1869   0A06 1A            mov al, ah
1870   0A07 3E            mov [d], al                   ; set year
1871   0A08             ; write sector into disk for new directory entry
1872   0A08 FD 27         mov b, g
1873   0A0A 38 00 00      mov c, 0
1874   0A0D 3B 8E 33      mov d, transient_area
1875   0A10 22 01         mov ah, $01                   ; disk write, 1 sector
1876   0A12 07 1C 07      call ide_write_sect           ; write sector
1877   0A15             fs_mkdir_end:
1878   0A15 06            sysret
1879   0A16             
1880   0A16             ;------------------------------------------------------------------------------------------------------;
1881   0A16             ; get path from a given directory dirid
1882   0A16             ; pseudo code:
1883   0A16             ;  fs_dir_id_to_path(int dirid, char *d){
1884   0A16             ;    if(dirid == 0){
1885   0A16             ;      reverse path in d;
1886   0A16             ;      return;
1887   0A16             ;    }
1888   0A16             ;    else{
1889   0A16             ;      copy directory name to end of d;
1890   0A16             ;      add '/' to end of d;
1891   0A16             ;      parentid = get parent directory id;
1892   0A16             ;      fs_dir_id_to_path(parentid, d);
1893   0A16             ;    }
1894   0A16             ;  }
1895   0A16             ; a = dirid
1896   0A16             ; d = generated path string pointer
1897   0A16             ;------------------------------------------------------------------------------------------------------;
1898   0A16             ; sample path: /usr/bin
1899   0A16             fs_dir_id_to_path:
1900   0A16 3B 0E 1F      mov d, filename
1901   0A19 19 00         mov al, 0
1902   0A1B 3E            mov [d], al                     ; initialize path string 
1903   0A1C 14 5A 19      mov a, [current_dir_id]
1904   0A1F 07 2C 0A      call fs_dir_id_to_path_e0
1905   0A22 3B 0E 1F      mov d, filename
1906   0A25 07 0C 12      call _strrev
1907   0A28 07 20 14      call _puts
1908   0A2B 06            sysret
1909   0A2C             fs_dir_id_to_path_e0:
1910   0A2C 07 4B 0A      call get_dirname_from_dirid
1911   0A2F FD 4D 7E 19   mov si, s_fslash
1912   0A33 FD 50         mov di, d
1913   0A35 07 86 12      call _strcat                    ; add '/' to end of path
1914   0A38 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1915   0A3B C6 4A 0A      je fs_dir_id_to_path_root
1916   0A3E 07 68 0A      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1917   0A41 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1918   0A44 C6 4A 0A      je fs_dir_id_to_path_root
1919   0A47 07 2C 0A      call fs_dir_id_to_path_e0     ; recursively call itself
1920   0A4A             fs_dir_id_to_path_root:
1921   0A4A 09            ret
1922   0A4B             
1923   0A4B             ;------------------------------------------------------------------------------------------------------;
1924   0A4B             ; in_puts:
1925   0A4B             ; a = directory id
1926   0A4B             ; out_puts:
1927   0A4B             ; d = pointer to directory name string
1928   0A4B             ;------------------------------------------------------------------------------------------------------;
1929   0A4B             get_dirname_from_dirid:
1930   0A4B D7            push a
1931   0A4C D8            push b
1932   0A4D DA            push d
1933   0A4E 27            mov b, a
1934   0A4F 38 00 00      mov c, 0                      ; upper lba = 0
1935   0A52 22 01         mov ah, $01                  ; 1 sector
1936   0A54 3B 8E 31      mov d, transient_area - 512
1937   0A57 07 F6 06      call ide_read_sect            ; read directory
1938   0A5A 07 0C 12      call _strrev                  ; reverse dir name before copying
1939   0A5D FD 4E         mov si, d
1940   0A5F E7            pop d                         ; destination address = d value pushed at beginning
1941   0A60 FD 50         mov di, d
1942   0A62 07 86 12      call _strcat                  ; copy filename to d
1943   0A65 E5            pop b
1944   0A66 E4            pop a
1945   0A67 09            ret
1946   0A68             
1947   0A68             ;------------------------------------------------------------------------------------------------------;
1948   0A68             ; in_puts:
1949   0A68             ; a = directory id
1950   0A68             ; out_puts:
1951   0A68             ; a = parent directory id
1952   0A68             ;------------------------------------------------------------------------------------------------------;
1953   0A68             get_parentid_from_dirid:
1954   0A68 D8            push b
1955   0A69 DA            push d
1956   0A6A 27            mov b, a
1957   0A6B 38 00 00      mov c, 0                      ; upper lba = 0
1958   0A6E 22 01         mov ah, $01                  ; 1 sector
1959   0A70 3B 8E 31      mov d, transient_area - 512
1960   0A73 07 F6 06      call ide_read_sect            ; read directory
1961   0A76 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1962   0A79 E7            pop d
1963   0A7A E5            pop b
1964   0A7B 09            ret
1965   0A7C             
1966   0A7C             ;------------------------------------------------------------------------------------------------------;
1967   0A7C             ; get dirid from a given path string
1968   0A7C             ; in_puts:
1969   0A7C             ; d = path pointer 
1970   0A7C             ; out_puts:
1971   0A7C             ; a = dirid
1972   0A7C             ; if dir non existent, a = ffff (fail code)
1973   0A7C             ; /usr/local/bin    - absolute
1974   0A7C             ; local/bin/games    - relative
1975   0A7C             ;------------------------------------------------------------------------------------------------------;
1976   0A7C             fs_path_to_dir_id_user:
1977   0A7C FD 4E         mov si, d
1978   0A7E FD 4F 8E 1F   mov di, user_data
1979   0A82 38 00 02      mov c, 512
1980   0A85 04            load
1981   0A86 07 8A 0A      call get_dirid_from_path
1982   0A89 06            sysret
1983   0A8A             get_dirid_from_path:
1984   0A8A 26 8E 1F      mov b, user_data
1985   0A8D FD 42 45 18   mov [prog], b                  ; token pointer set to path string
1986   0A91 07 A6 16      call get_token
1987   0A94 31 48 18      mov bl, [tok]
1988   0A97 C1 01         cmp bl, tok_fslash
1989   0A99 C6 A5 0A      je get_dirid_from_path_abs 
1990   0A9C 14 5A 19      mov a, [current_dir_id]
1991   0A9F 07 2C 18      call _putback
1992   0AA2 0A A8 0A      jmp get_dirid_from_path_e0
1993   0AA5             get_dirid_from_path_abs:
1994   0AA5 10 20 00      mov a, root_id
1995   0AA8             get_dirid_from_path_e0:
1996   0AA8 07 A6 16      call get_token
1997   0AAB 31 47 18      mov bl, [toktyp]
1998   0AAE C1 00         cmp bl, toktyp_identifier
1999   0AB0 C7 01 0B      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2000   0AB3             
2001   0AB3 FD 4D 49 18   mov si, tokstr
2002   0AB7 FD 4F 0E 1F   mov di, filename
2003   0ABB 07 78 12      call _strcpy        
2004   0ABE 77            inc a                         ; metadata sector
2005   0ABF 27            mov b, a
2006   0AC0 38 00 00      mov c, 0                      ; upper lba = 0
2007   0AC3 22 01         mov ah, $01                  ; 1 sector
2008   0AC5 3B 8E 33      mov d, transient_area
2009   0AC8 07 F6 06      call ide_read_sect            ; read directory
2010   0ACB FD 10         cla
2011   0ACD 42 52 19      mov [index], a
2012   0AD0             get_dirid_from_path_l1:
2013   0AD0 FD 4E         mov si, d
2014   0AD2 FD 4F 0E 1F   mov di, filename
2015   0AD6 07 63 12      call _strcmp
2016   0AD9 C6 EF 0A      je get_dirid_from_path_name_equal  
2017   0ADC 58 20 00      add d, 32
2018   0ADF 14 52 19      mov a, [index]
2019   0AE2 77            inc a
2020   0AE3 42 52 19      mov [index], a
2021   0AE6 AF 10 00      cmp a, fst_files_per_dir
2022   0AE9 C6 02 0B      je get_dirid_from_path_fail
2023   0AEC 0A D0 0A      jmp get_dirid_from_path_l1
2024   0AEF             get_dirid_from_path_name_equal:
2025   0AEF 58 19 00      add d, 25           
2026   0AF2 15            mov a, [d]                    ; set result register a = dirid
2027   0AF3 07 A6 16      call get_token
2028   0AF6 31 48 18      mov bl, [tok]
2029   0AF9 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
2030   0AFB C6 A8 0A      je get_dirid_from_path_e0
2031   0AFE 07 2C 18      call _putback
2032   0B01             get_dirid_from_path_end:
2033   0B01 09            ret
2034   0B02             get_dirid_from_path_fail:
2035   0B02 10 FF FF      mov a, $ffff
2036   0B05 09            ret
2037   0B06             
2038   0B06             
2039   0B06             ;------------------------------------------------------------------------------------------------------;
2040   0B06             ; check if file exists by a given path string
2041   0B06             ; in_puts:
2042   0B06             ; d = path pointer 
2043   0B06             ; outputs:
2044   0B06             ; a = success code, if file exists gives lba, else, give 0
2045   0B06             ; /usr/local/bin/ed
2046   0B06             ;------------------------------------------------------------------------------------------------------;
2047   0B06             fs_filepath_exists_user:
2048   0B06 FD 4E         mov si, d
2049   0B08 FD 4F 8E 1F   mov di, user_data
2050   0B0C 38 00 02      mov c, 512
2051   0B0F 04            load
2052   0B10 07 14 0B      call file_exists_by_path
2053   0B13 06            sysret
2054   0B14             file_exists_by_path:
2055   0B14 26 8E 1F      mov b, user_data
2056   0B17 FD 42 45 18   mov [prog], b                   ; token pointer set to path string
2057   0B1B 07 A6 16      call get_token
2058   0B1E 31 48 18      mov bl, [tok]
2059   0B21 C1 01         cmp bl, tok_fslash
2060   0B23 C6 2F 0B      je  file_exists_by_path_abs
2061   0B26 14 5A 19      mov a, [current_dir_id]
2062   0B29 07 2C 18      call _putback
2063   0B2C 0A 32 0B      jmp file_exists_by_path_e0
2064   0B2F             file_exists_by_path_abs:
2065   0B2F 10 20 00      mov a, root_id
2066   0B32             file_exists_by_path_e0:
2067   0B32 07 A6 16      call get_token
2068   0B35 31 47 18      mov bl, [toktyp]
2069   0B38 C1 00         cmp bl, toktyp_identifier
2070   0B3A C7 92 0B      jne file_exists_by_path_end     ; check if there are tokens after '/'
2071   0B3D FD 4D 49 18   mov si, tokstr
2072   0B41 FD 4F 0E 1F   mov di, filename
2073   0B45 07 78 12      call _strcpy        
2074   0B48 77            inc a                           ; metadata sector
2075   0B49 27            mov b, a
2076   0B4A 38 00 00      mov c, 0                        ; upper lba = 0
2077   0B4D 22 01         mov ah, $01                  ; 1 sector
2078   0B4F 3B 8E 33      mov d, transient_area
2079   0B52 07 F6 06      call ide_read_sect              ; read directory
2080   0B55 FD 10         cla
2081   0B57 42 52 19      mov [index], a
2082   0B5A             file_exists_by_path_l1:
2083   0B5A FD 4E         mov si, d
2084   0B5C FD 4F 0E 1F   mov di, filename
2085   0B60 07 63 12      call _strcmp
2086   0B63 C6 79 0B      je   file_exists_by_path_name_equal
2087   0B66 58 20 00      add d, 32
2088   0B69 14 52 19      mov a, [index]
2089   0B6C 77            inc a
2090   0B6D 42 52 19      mov [index], a
2091   0B70 AF 10 00      cmp a, fst_files_per_dir
2092   0B73 C6 92 0B      je file_exists_by_path_end
2093   0B76 0A 5A 0B      jmp file_exists_by_path_l1
2094   0B79             file_exists_by_path_name_equal:
2095   0B79 33 18 00      mov bl, [d + 24]
2096   0B7C FD 87 38      and bl, %00111000               ; directory flag
2097   0B7F C1 08         cmp bl, %00001000               ; is dir?
2098   0B81 C6 88 0B      je file_exists_by_path_isdir;
2099   0B84             ; entry is a file
2100   0B84 16 19 00      mov a, [d + 25]                 ; get and return lba of file
2101   0B87 09            ret
2102   0B88             file_exists_by_path_isdir:
2103   0B88 58 19 00      add d, 25           
2104   0B8B 15            mov a, [d]                      ; set result register a = dirid
2105   0B8C 07 A6 16      call get_token
2106   0B8F 0A 32 0B      jmp file_exists_by_path_e0
2107   0B92             file_exists_by_path_end:
2108   0B92 10 00 00      mov a, 0                        ; return 0 because file was not found
2109   0B95 09            ret
2110   0B96             
2111   0B96             ;------------------------------------------------------------------------------------------------------;
2112   0B96             ; load file data from a given path string
2113   0B96             ; inputs:
2114   0B96             ; d = path pointer 
2115   0B96             ; di = userspace program data destination
2116   0B96             ; /usr/local/bin/ed
2117   0B96             ; ./ed
2118   0B96             ;------------------------------------------------------------------------------------------------------;
2119   0B96             fs_load_from_path_user:
2120   0B96 E3            push di
2121   0B97 FD 4E         mov si, d
2122   0B99 FD 4F 8E 1F   mov di, user_data
2123   0B9D 38 00 02      mov c, 512
2124   0BA0 04            load
2125   0BA1 07 AE 0B      call loadfile_from_path
2126   0BA4 F0            pop di
2127   0BA5 FD 4D 8E 33   mov si, transient_area
2128   0BA9 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
2129   0BAC 03            store
2130   0BAD 06            sysret
2131   0BAE             loadfile_from_path:
2132   0BAE 26 8E 1F      mov b, user_data
2133   0BB1 FD 42 45 18   mov [prog], b                 ; token pointer set to path string
2134   0BB5 07 A6 16      call get_token
2135   0BB8 31 48 18      mov bl, [tok]
2136   0BBB C1 01         cmp bl, tok_fslash
2137   0BBD C6 C9 0B      je loadfile_from_path_abs 
2138   0BC0 14 5A 19      mov a, [current_dir_id]
2139   0BC3 07 2C 18      call _putback
2140   0BC6 0A CC 0B      jmp loadfile_from_path_e0
2141   0BC9             loadfile_from_path_abs:
2142   0BC9 10 20 00      mov a, root_id
2143   0BCC             loadfile_from_path_e0:
2144   0BCC 07 A6 16      call get_token
2145   0BCF 31 47 18      mov bl, [toktyp]
2146   0BD2 C1 00         cmp bl, toktyp_identifier
2147   0BD4 C7 39 0C      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2148   0BD7 FD 4D 49 18   mov si, tokstr
2149   0BDB FD 4F 0E 1F   mov di, filename
2150   0BDF 07 78 12      call _strcpy        
2151   0BE2 77            inc a                         ; metadata sector
2152   0BE3 27            mov b, a
2153   0BE4 38 00 00      mov c, 0                      ; upper lba = 0
2154   0BE7 22 01         mov ah, $01                  ; 1 sector
2155   0BE9 3B 8E 33      mov d, transient_area
2156   0BEC 07 F6 06      call ide_read_sect            ; read directory
2157   0BEF FD 10         cla
2158   0BF1 42 52 19      mov [index], a
2159   0BF4             loadfile_from_path_l1:
2160   0BF4 FD 4E         mov si, d
2161   0BF6 FD 4F 0E 1F   mov di, filename
2162   0BFA 07 63 12      call _strcmp
2163   0BFD C6 13 0C      je loadfile_from_path_name_equal  
2164   0C00 58 20 00      add d, 32
2165   0C03 14 52 19      mov a, [index]
2166   0C06 77            inc a
2167   0C07 42 52 19      mov [index], a
2168   0C0A AF 10 00      cmp a, fst_files_per_dir
2169   0C0D C6 39 0C      je loadfile_from_path_end
2170   0C10 0A F4 0B      jmp loadfile_from_path_l1
2171   0C13             loadfile_from_path_name_equal:
2172   0C13 33 18 00      mov bl, [d + 24]
2173   0C16 FD 87 38      and bl, %00111000             ; directory flag
2174   0C19 C1 08         cmp bl, %00001000             ; is dir?
2175   0C1B C6 2F 0C      je loadfile_isdirectory  
2176   0C1E             ; entry is a file
2177   0C1E 2B 19 00      mov b, [d + 25]               ; get lba
2178   0C21 FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
2179   0C23 3B 8E 33      mov d, transient_area
2180   0C26 38 00 00      mov c, 0
2181   0C29 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
2182   0C2B 07 F6 06      call ide_read_sect            ; read sector
2183   0C2E 09            ret
2184   0C2F             loadfile_isdirectory:
2185   0C2F 58 19 00      add d, 25           
2186   0C32 15            mov a, [d]                    ; set result register a = dirid
2187   0C33 07 A6 16      call get_token
2188   0C36 0A CC 0B      jmp loadfile_from_path_e0
2189   0C39             loadfile_from_path_end:
2190   0C39 09            ret
2191   0C3A             
2192   0C3A             ;------------------------------------------------------------------------------------------------------;
2193   0C3A             ; return the id of the current directory
2194   0C3A             ; id returned in b
2195   0C3A             ;------------------------------------------------------------------------------------------------------;
2196   0C3A             fs_get_curr_dirid:
2197   0C3A 29 5A 19      mov b, [current_dir_id]
2198   0C3D 06            sysret
2199   0C3E             
2200   0C3E             ;------------------------------------------------------------------------------------------------------;
2201   0C3E             ; cd
2202   0C3E             ;------------------------------------------------------------------------------------------------------;
2203   0C3E             ; new dirid in b
2204   0C3E             fs_cd:
2205   0C3E FD 42 5A 19   mov [current_dir_id], b
2206   0C42 06            sysret  
2207   0C43             
2208   0C43             ;------------------------------------------------------------------------------------------------------;
2209   0C43             ; ls
2210   0C43             ; dirid in b
2211   0C43             ;------------------------------------------------------------------------------------------------------;
2212   0C43 00 00       ls_count:       .dw 0
2213   0C45             fs_ls:
2214   0C45 FD 77         inc b                        ; metadata sector
2215   0C47 38 00 00      mov c, 0                     ; upper lba = 0
2216   0C4A 22 01         mov ah, $01                  ; 1 sector
2217   0C4C 3B 8E 33      mov d, transient_area
2218   0C4F 07 F6 06      call ide_read_sect           ; read directory
2219   0C52 FD 10         cla
2220   0C54 42 52 19      mov [index], a               ; reset entry index
2221   0C57 3D 43 0C      mov [ls_count], al           ; reset item count
2222   0C5A             fs_ls_l1:
2223   0C5A BD 00         cmp byte [d], 0              ; check for null
2224   0C5C C6 F3 0C      je fs_ls_next
2225   0C5F             fs_ls_non_null:
2226   0C5F 1D 43 0C      mov al, [ls_count]
2227   0C62 7A            inc al
2228   0C63 3D 43 0C      mov [ls_count], al           ; increment item count
2229   0C66 1F 18 00      mov al, [d + 24]
2230   0C69 87 38         and al, %00111000
2231   0C6B FD A2 03      shr al, 3
2232   0C6E 22 00         mov ah, 0                    ; file type
2233   0C70 B7 85 19      mov a, [a + file_type]      
2234   0C73 23            mov ah, al
2235   0C74 07 F4 12      call _putchar
2236   0C77 1F 18 00      mov al, [d + 24]
2237   0C7A 87 01         and al, %00000001
2238   0C7C 22 00         mov ah, 0
2239   0C7E B7 80 19      mov a, [a + file_attrib]     ; read
2240   0C81 23            mov ah, al
2241   0C82 07 F4 12      call _putchar
2242   0C85 1F 18 00      mov al, [d + 24]
2243   0C88 87 02         and al, %00000010
2244   0C8A 22 00         mov ah, 0
2245   0C8C B7 80 19      mov a, [a + file_attrib]     ; write
2246   0C8F 23            mov ah, al
2247   0C90 07 F4 12      call _putchar
2248   0C93 1F 18 00      mov al, [d + 24]
2249   0C96 87 04         and al, %00000100
2250   0C98 22 00         mov ah, 0
2251   0C9A B7 80 19      mov a, [a + file_attrib]     ; execute
2252   0C9D 23            mov ah, al
2253   0C9E 07 F4 12      call _putchar
2254   0CA1 22 20         mov ah, $20
2255   0CA3 07 F4 12      call _putchar  
2256   0CA6 2B 1B 00      mov b, [d + 27]
2257   0CA9 07 7C 14      call print_u16x              ; filesize
2258   0CAC 22 20         mov ah, $20
2259   0CAE 07 F4 12      call _putchar  
2260   0CB1 2B 19 00      mov b, [d + 25]
2261   0CB4 07 7C 14      call print_u16x              ; dirid / lba
2262   0CB7 22 20         mov ah, $20
2263   0CB9 07 F4 12      call _putchar
2264   0CBC             ; print date
2265   0CBC 33 1D 00      mov bl, [d + 29]             ; day
2266   0CBF 07 C0 14      call print_u8x
2267   0CC2 22 20         mov ah, $20
2268   0CC4 07 F4 12      call _putchar  
2269   0CC7 1F 1E 00      mov al, [d + 30]             ; month
2270   0CCA FD 9E 02      shl al, 2
2271   0CCD DA            push d
2272   0CCE 3B 1C 1B      mov d, s_months
2273   0CD1 22 00         mov ah, 0
2274   0CD3 59            add d, a
2275   0CD4 07 20 14      call _puts
2276   0CD7 E7            pop d
2277   0CD8 22 20         mov ah, $20
2278   0CDA 07 F4 12      call _putchar
2279   0CDD 2E 20         mov bl, $20
2280   0CDF 07 C0 14      call print_u8x
2281   0CE2 33 1F 00      mov bl, [d + 31]             ; year
2282   0CE5 07 C0 14      call print_u8x  
2283   0CE8 22 20         mov ah, $20
2284   0CEA 07 F4 12      call _putchar  
2285   0CED 07 20 14      call _puts                   ; print filename  
2286   0CF0 07 CD 13      call printnl
2287   0CF3             fs_ls_next:
2288   0CF3 14 52 19      mov a, [index]
2289   0CF6 77            inc a
2290   0CF7 42 52 19      mov [index], a
2291   0CFA AF 10 00      cmp a, fst_files_per_dir
2292   0CFD C6 06 0D      je fs_ls_end
2293   0D00 58 20 00      add d, 32      
2294   0D03 0A 5A 0C      jmp fs_ls_l1  
2295   0D06             fs_ls_end:
2296   0D06 3B 95 19      mov d, s_ls_total
2297   0D09 07 20 14      call _puts
2298   0D0C 1D 43 0C      mov al, [ls_count]
2299   0D0F 07 D2 14      call print_u8d
2300   0D12 07 CD 13      call printnl
2301   0D15 06            sysret
2302   0D16             
2303   0D16             ;------------------------------------------------------------------------------------------------------;
2304   0D16             ; finds an empty data block
2305   0D16             ; block lba returned in b
2306   0D16             ;------------------------------------------------------------------------------------------------------;
2307   0D16             fs_find_empty_block:
2308   0D16 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2309   0D19 38 00 00      mov c, 0                ; upper lba = 0
2310   0D1C             fs_find_empty_block_l1:  
2311   0D1C 22 01         mov ah, $01                  ; 1 sector
2312   0D1E 3B 8E 31      mov d, transient_area - 512
2313   0D21 07 F6 06      call ide_read_sect      ; read sector
2314   0D24 BD 00         cmp byte [d], 0
2315   0D26 C6 2F 0D      je fs_find_empty_block_found_null
2316   0D29 55 20 00      add b, fs_sectors_per_file
2317   0D2C 0A 1C 0D      jmp fs_find_empty_block_l1
2318   0D2F             fs_find_empty_block_found_null:
2319   0D2F 09            ret
2320   0D30             
2321   0D30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2322   0D30             ;; create new textfile
2323   0D30             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2324   0D30             ; search for first null block
2325   0D30             fs_mktxt:
2326   0D30 FD 4E       	mov si, d
2327   0D32 FD 4F 8E 1F 	mov di, user_data
2328   0D36 38 00 01    	mov c, 256
2329   0D39 04          	load					; load data from user-space
2330   0D3A             	
2331   0D3A 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2332   0D3D 38 00 00    	mov c, 0						; reset lba to 0
2333   0D40             fs_mktxt_l1:	
2334   0D40 10 02 01    	mov a, $0102			; disk read
2335   0D43 3B 8E 33    	mov d, transient_area
2336   0D46 05 02       	syscall sys_ide ; read sector
2337   0D48 1E          	mov al, [d]
2338   0D49 B9 00       	cmp al, 0			; check for null
2339   0D4B C6 54 0D    	je fs_mktxt_found_null
2340   0D4E 55 20 00    	add b, fs_sectors_per_file
2341   0D51 0A 40 0D    	jmp fs_mktxt_l1
2342   0D54             fs_mktxt_found_null:
2343   0D54 D8          	push b				; save lba
2344   0D55             ;create header file by grabbing file name from parameter	
2345   0D55 3B 76 19    	mov d, s_dataentry
2346   0D58 07 20 14    	call _puts
2347   0D5B 3B 8E 35    	mov d, transient_area + 512			; pointer to file contents
2348   0D5E 07 86 13    	call _gettxt
2349   0D61 07 53 12    	call _strlen						; get length of file
2350   0D64 D9          	push c							; save length
2351   0D65 19 01       	mov al, 1
2352   0D67 3D 8E 33    	mov [transient_area], al					; mark sectors as used (not null)
2353   0D6A 10 00 00    	mov a, 0
2354   0D6D 42 52 19    	mov [index], a
2355   0D70 3B 8E 33    	mov d, transient_area
2356   0D73 13          	mov a, d
2357   0D74 42 54 19    	mov [buffer_addr], a
2358   0D77             fs_mktxt_l2:
2359   0D77 38 00 00    	mov c, 0
2360   0D7A 10 03 01    	mov a, $0103			; disk write, 1 sector
2361   0D7D 05 02       	syscall sys_ide		; write sector
2362   0D7F 14 52 19    	mov a, [index]
2363   0D82 77          	inc a
2364   0D83 42 52 19    	mov [index], a
2365   0D86 AF 20 00    	cmp a, fs_sectors_per_file
2366   0D89 C6 9B 0D    	je fs_mktxt_add_to_dir
2367   0D8C FD 77       	inc b
2368   0D8E 14 54 19    	mov a, [buffer_addr]
2369   0D91 53 00 02    	add a, 512
2370   0D94 42 54 19    	mov [buffer_addr], a
2371   0D97 3C          	mov d, a
2372   0D98 0A 77 0D    	jmp fs_mktxt_l2
2373   0D9B             ; now we add the file to the current directory!
2374   0D9B             fs_mktxt_add_to_dir:	
2375   0D9B 14 5A 19    	mov a, [current_dir_id]
2376   0D9E 77          	inc a
2377   0D9F 27          	mov b, a					; metadata sector
2378   0DA0 38 00 00    	mov c, 0
2379   0DA3 FD 79       	mov g, b					; save lba
2380   0DA5 3B 8E 33    	mov d, transient_area
2381   0DA8 10 02 01    	mov a, $0102			; disk read
2382   0DAB 05 02       	syscall sys_ide		; read metadata sector
2383   0DAD             fs_mktxt_add_to_dir_l2:
2384   0DAD 1E          	mov al, [d]
2385   0DAE B9 00       	cmp al, 0
2386   0DB0 C6 B9 0D    	je fs_mktxt_add_to_dir_null
2387   0DB3 58 20 00    	add d, fst_entry_size
2388   0DB6 0A AD 0D    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2389   0DB9             fs_mktxt_add_to_dir_null:
2390   0DB9 FD 4D 8E 1F 	mov si, user_data
2391   0DBD FD 50       	mov di, d
2392   0DBF 07 78 12    	call _strcpy			; copy file name
2393   0DC2 58 18 00    	add d, 24			; skip name
2394   0DC5 19 06       	mov al, %00000110		; no execute, write, read, not directory
2395   0DC7 3E          	mov [d], al			
2396   0DC8 58 03 00    	add d, 3
2397   0DCB E4          	pop a
2398   0DCC 43          	mov [d], a
2399   0DCD 63 02 00    	sub d, 2
2400   0DD0 E5          	pop b				; get file lba
2401   0DD1 FD 43       	mov [d], b			; save lba	
2402   0DD3             	
2403   0DD3             	; set file creation date	
2404   0DD3 58 04 00    	add d, 4
2405   0DD6 19 04       	mov al, 4
2406   0DD8 05 01       	syscall sys_rtc
2407   0DDA 1A          	mov al, ah
2408   0DDB 3E          	mov [d], al			; set day
2409   0DDC             	
2410   0DDC 79          	inc d
2411   0DDD 19 05       	mov al, 5
2412   0DDF 05 01       	syscall sys_rtc
2413   0DE1 1A          	mov al, ah
2414   0DE2 3E          	mov [d], al			; set month
2415   0DE3             	
2416   0DE3 79          	inc d
2417   0DE4 19 06       	mov al, 6
2418   0DE6 05 01       	syscall sys_rtc
2419   0DE8 1A          	mov al, ah
2420   0DE9 3E          	mov [d], al			; set year
2421   0DEA             	
2422   0DEA             ; write sector into disk for new directory entry
2423   0DEA FD 27       	mov b, g
2424   0DEC 38 00 00    	mov c, 0
2425   0DEF 3B 8E 33    	mov d, transient_area
2426   0DF2 10 03 01    	mov a, $0103			; disk write, 1 sector
2427   0DF5 05 02       	syscall sys_ide		; write sector
2428   0DF7 07 CD 13    	call printnl
2429   0DFA 06          	sysret
2430   0DFB             
2431   0DFB             
2432   0DFB             
2433   0DFB             ;------------------------------------------------------------------------------------------------------;
2434   0DFB             ; create new binary file
2435   0DFB             ;------------------------------------------------------------------------------------------------------;
2436   0DFB             ; search for first null block
2437   0DFB             fs_mkbin:
2438   0DFB 19 00         mov al, 0
2439   0DFD 3D 4A 19      mov [sys_echo_on], al ; disable echo
2440   0E00 FD 4E         mov si, d
2441   0E02 FD 4F 8E 1F   mov di, user_data
2442   0E06 38 00 02      mov c, 512
2443   0E09 04            load                          ; load data from user-space
2444   0E0A 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2445   0E0D 38 00 00      mov c, 0                      ; upper lba = 0
2446   0E10             fs_mkbin_l1:  
2447   0E10 22 01         mov ah, $01                  ; 1 sector
2448   0E12 3B 8E 33      mov d, transient_area
2449   0E15 07 F6 06      call ide_read_sect            ; read sector
2450   0E18 BD 00         cmp byte[d], 0                ; check for null
2451   0E1A C6 23 0E      je fs_mkbin_found_null
2452   0E1D 55 20 00      add b, fs_sectors_per_file
2453   0E20 0A 10 0E      jmp fs_mkbin_l1
2454   0E23             fs_mkbin_found_null:
2455   0E23 D8            push b                        ; save lba
2456   0E24             ;create header file by grabbing file name from parameter
2457   0E24 FD 4F 8E 35   mov di, transient_area + 512  ; pointer to file contents
2458   0E28 07 9E 11      call _load_hex                ; load binary hex
2459   0E2B D9            push c                        ; save size (nbr of bytes)
2460   0E2C 19 01         mov al, 1
2461   0E2E 3D 8E 33      mov [transient_area], al      ; mark sectors as used (not null)
2462   0E31 FD 10         cla
2463   0E33 42 52 19      mov [index], a
2464   0E36 3B 8E 33      mov d, transient_area
2465   0E39 13            mov a, d
2466   0E3A 42 54 19      mov [buffer_addr], a
2467   0E3D             fs_mkbin_l2:
2468   0E3D 38 00 00      mov c, 0
2469   0E40 22 01         mov ah, $01                   ; disk write, 1 sector
2470   0E42 07 1C 07      call ide_write_sect           ; write sector
2471   0E45 14 52 19      mov a, [index]
2472   0E48 77            inc a
2473   0E49 42 52 19      mov [index], a
2474   0E4C AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2475   0E4F C6 61 0E      je fs_mkbin_add_to_dir
2476   0E52 FD 77         inc b
2477   0E54 14 54 19      mov a, [buffer_addr]
2478   0E57 53 00 02      add a, 512
2479   0E5A 42 54 19      mov [buffer_addr], a
2480   0E5D 3C            mov d, a
2481   0E5E 0A 3D 0E      jmp fs_mkbin_l2
2482   0E61             ; now we add the file to the current directory!
2483   0E61             fs_mkbin_add_to_dir:  
2484   0E61 14 5A 19      mov a, [current_dir_id]
2485   0E64 77            inc a
2486   0E65 27            mov b, a                      ; metadata sector
2487   0E66 38 00 00      mov c, 0
2488   0E69 FD 79         mov g, b                      ; save lba
2489   0E6B 3B 8E 33      mov d, transient_area
2490   0E6E 22 01         mov ah, $01                  ; 1 sector
2491   0E70 07 F6 06      call ide_read_sect            ; read metadata sector
2492   0E73             fs_mkbin_add_to_dir_l2:
2493   0E73 BD 00         cmp byte[d], 0
2494   0E75 C6 7E 0E      je fs_mkbin_add_to_dir_null
2495   0E78 58 20 00      add d, fst_entry_size
2496   0E7B 0A 73 0E      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2497   0E7E             fs_mkbin_add_to_dir_null:
2498   0E7E FD 4D 8E 1F   mov si, user_data
2499   0E82 FD 50         mov di, d
2500   0E84 07 78 12      call _strcpy                  ; copy file name
2501   0E87 58 18 00      add d, 24                     ; skip name
2502   0E8A 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2503   0E8C 3E            mov [d], al
2504   0E8D 58 03 00      add d, 3
2505   0E90 E4            pop a
2506   0E91 43            mov [d], a
2507   0E92 63 02 00      sub d, 2
2508   0E95 E5            pop b                         ; get file lba
2509   0E96 FD 43         mov [d], b                    ; save lba
2510   0E98               ; set file creation date  
2511   0E98 58 04 00      add d, 4
2512   0E9B 19 04         mov al, 4
2513   0E9D 05 01         syscall sys_rtc
2514   0E9F 1A            mov al, ah
2515   0EA0 3E            mov [d], al                   ; set day
2516   0EA1 79            inc d
2517   0EA2 19 05         mov al, 5
2518   0EA4 05 01         syscall sys_rtc
2519   0EA6 1A            mov al, ah
2520   0EA7 3E            mov [d], al                   ; set month
2521   0EA8 79            inc d
2522   0EA9 19 06         mov al, 6
2523   0EAB 05 01         syscall sys_rtc
2524   0EAD 1A            mov al, ah
2525   0EAE 3E            mov [d], al                   ; set year
2526   0EAF             ; write sector into disk for new directory entry
2527   0EAF FD 27         mov b, g
2528   0EB1 38 00 00      mov c, 0
2529   0EB4 3B 8E 33      mov d, transient_area
2530   0EB7 22 01         mov ah, $01                   ; disk write, 1 sector
2531   0EB9 07 1C 07      call ide_write_sect           ; write sector
2532   0EBC 19 01         mov al, 1
2533   0EBE 3D 4A 19      mov [sys_echo_on], al ; enable echo
2534   0EC1 06            sysret
2535   0EC2             
2536   0EC2             ;------------------------------------------------------------------------------------------------------;
2537   0EC2             ; pwd - print working directory
2538   0EC2             ;------------------------------------------------------------------------------------------------------;    
2539   0EC2             fs_pwd:
2540   0EC2 3B 0E 1F      mov d, filename
2541   0EC5 19 00         mov al, 0
2542   0EC7 3E            mov [d], al                   ; initialize path string 
2543   0EC8 14 5A 19      mov a, [current_dir_id]
2544   0ECB 07 2C 0A      call fs_dir_id_to_path_e0
2545   0ECE 3B 0E 1F      mov d, filename
2546   0ED1 07 0C 12      call _strrev
2547   0ED4 07 20 14      call _puts
2548   0ED7 07 CD 13      call printnl
2549   0EDA 06            sysret
2550   0EDB             
2551   0EDB             ;------------------------------------------------------------------------------------------------------;
2552   0EDB             ; get current directory lba
2553   0EDB             ; a: returned lba
2554   0EDB             ;------------------------------------------------------------------------------------------------------;
2555   0EDB             cmd_get_curr_dir_lba:
2556   0EDB 14 5A 19      mov a, [current_dir_id]
2557   0EDE 06            sysret
2558   0EDF             
2559   0EDF             ;------------------------------------------------------------------------------------------------------;
2560   0EDF             ; cat
2561   0EDF             ; userspace destination data pointer in d
2562   0EDF             ; filename starts at d, but is overwritten after the read is made
2563   0EDF             ;------------------------------------------------------------------------------------------------------;:
2564   0EDF             fs_cat:
2565   0EDF DA            push d                              ; save userspace file data destination
2566   0EE0 FD 4E         mov si, d
2567   0EE2 FD 4F 8E 1F   mov di, user_data
2568   0EE6 38 00 02      mov c, 512
2569   0EE9 04            load                                ; copy filename from user-space
2570   0EEA 29 5A 19      mov b, [current_dir_id]
2571   0EED FD 77         inc b                               ; metadata sector
2572   0EEF 38 00 00      mov c, 0                            ; upper lba = 0
2573   0EF2 22 01         mov ah, $01                  ; 1 sector
2574   0EF4 3B 8E 31      mov d, transient_area-512
2575   0EF7 07 F6 06      call ide_read_sect                  ; read directory
2576   0EFA FD 10         cla
2577   0EFC 42 52 19      mov [index], a                      ; reset file counter
2578   0EFF             fs_cat_l1:
2579   0EFF FD 4E         mov si, d
2580   0F01 FD 4F 8E 1F   mov di, user_data
2581   0F05 07 63 12      call _strcmp
2582   0F08 C6 1E 0F      je fs_cat_found_entry
2583   0F0B 58 20 00      add d, 32
2584   0F0E 14 52 19      mov a, [index]
2585   0F11 77            inc a
2586   0F12 42 52 19      mov [index], a
2587   0F15 AF 10 00      cmp a, fst_files_per_dir
2588   0F18 C6 39 0F      je fs_cat_not_found
2589   0F1B 0A FF 0E      jmp fs_cat_l1
2590   0F1E             fs_cat_found_entry:
2591   0F1E 58 19 00      add d, 25                           ; get to dirid of file in disk
2592   0F21 2A            mov b, [d]                          ; get lba
2593   0F22 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2594   0F24 3B 8E 33      mov d, transient_area  
2595   0F27 38 00 00      mov c, 0
2596   0F2A 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2597   0F2C 07 F6 06      call ide_read_sect                  ; read sectors
2598   0F2F F0            pop di                              ; write userspace file data destination to di
2599   0F30 FD 4D 8E 33   mov si, transient_area              ; data origin
2600   0F34 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2601   0F37 03            store
2602   0F38 06            sysret
2603   0F39             fs_cat_not_found:
2604   0F39 E7            pop d
2605   0F3A 06            sysret
2606   0F3B             
2607   0F3B             ;------------------------------------------------------------------------------------------------------;
2608   0F3B             ; rmdir - remove dir by dirid
2609   0F3B             ;------------------------------------------------------------------------------------------------------;
2610   0F3B             ; deletes a directory entry in the given directory's file list 
2611   0F3B             ; also deletes the actual directory entry in the fst
2612   0F3B             ; synopsis: rmdir /usr/local/testdir
2613   0F3B             ; b = dirid
2614   0F3B             fs_rmdir:
2615   0F3B FD 79         mov g, b
2616   0F3D 11            mov a, b
2617   0F3E 07 68 0A      call get_parentid_from_dirid  ; now get the directory's parent, in a
2618   0F41 D7            push a                        ; save dirid
2619   0F42             ; search for directory's entry in the parent's directory then and delete it
2620   0F42 77            inc a                         ; metadata sector
2621   0F43 27            mov b, a
2622   0F44 38 00 00      mov c, 0                      ; upper lba = 0
2623   0F47 22 01         mov ah, $01          ;
2624   0F49 3B 8E 33      mov d, transient_area
2625   0F4C 07 F6 06      call ide_read_sect            ; read directory
2626   0F4F FD 10         cla
2627   0F51 42 52 19      mov [index], a                ; reset file counter
2628   0F54 FD 27         mov b, g                      ; retrieve directory's dirid
2629   0F56             fs_rmdir_l1:
2630   0F56 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2631   0F59 B0            cmp a, b                      ; compare dirid's to find the directory
2632   0F5A C6 70 0F      je fs_rmdir_found_entry
2633   0F5D 58 20 00      add d, 32
2634   0F60 14 52 19      mov a, [index]
2635   0F63 77            inc a
2636   0F64 42 52 19      mov [index], a
2637   0F67 AF 10 00      cmp a, fst_files_per_dir
2638   0F6A C6 95 0F      je fs_rmdir_not_found
2639   0F6D 0A 56 0F      jmp fs_rmdir_l1
2640   0F70             fs_rmdir_found_entry:
2641   0F70 FD 10         cla
2642   0F72 3E            mov [d], al                   ; make filename null
2643   0F73 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2644   0F76 E5            pop b
2645   0F77 FD 77         inc b                         ; metadata sector
2646   0F79 38 00 00      mov c, 0                      ; upper lba = 0
2647   0F7C 22 01         mov ah, $01          ; 
2648   0F7E 3B 8E 33      mov d, transient_area
2649   0F81 07 1C 07      call ide_write_sect           ; write sector and erase file's entry in the current dir
2650   0F84             
2651   0F84 FD 27         mov b, g
2652   0F86 3B 8E 33      mov d, transient_area  
2653   0F89 FD 10         cla
2654   0F8B 3E            mov [d], al                   ; make directory's name header null for re-use
2655   0F8C 38 00 00      mov c, 0
2656   0F8F 22 01         mov ah, $01                   ; disk write 1 sect
2657   0F91 07 1C 07      call ide_write_sect           ; delete directory given by dirid in b
2658   0F94 06            sysret
2659   0F95             fs_rmdir_not_found:
2660   0F95 E5            pop b
2661   0F96 06            sysret
2662   0F97             
2663   0F97             ;------------------------------------------------------------------------------------------------------;
2664   0F97             ; rm - remove file
2665   0F97             ;------------------------------------------------------------------------------------------------------;
2666   0F97             ; frees up the data sectors for the file further down the disk
2667   0F97             ; deletes file entry in the directory's file list 
2668   0F97             fs_rm:
2669   0F97 FD 4E         mov si, d
2670   0F99 FD 4F 8E 1F   mov di, user_data
2671   0F9D 38 00 02      mov c, 512
2672   0FA0 04            load                          ; load data from user-space
2673   0FA1 14 5A 19      mov a, [current_dir_id]
2674   0FA4 77            inc a                         ; metadata sector
2675   0FA5 27            mov b, a
2676   0FA6 38 00 00      mov c, 0                      ; upper lba = 0
2677   0FA9 22 01         mov ah, $01                  ; 1 sector
2678   0FAB 3B 8E 33      mov d, transient_area
2679   0FAE 07 F6 06      call ide_read_sect            ; read directory
2680   0FB1 10 00 00      mov a, 0
2681   0FB4 42 52 19      mov [index], a                ; reset file counter
2682   0FB7             fs_rm_l1:
2683   0FB7 FD 4E         mov si, d
2684   0FB9 FD 4F 8E 1F   mov di, user_data
2685   0FBD 07 63 12      call _strcmp
2686   0FC0 C6 D6 0F      je fs_rm_found_entry
2687   0FC3 58 20 00      add d, 32
2688   0FC6 14 52 19      mov a, [index]
2689   0FC9 77            inc a
2690   0FCA 42 52 19      mov [index], a
2691   0FCD AF 10 00      cmp a, fst_files_per_dir
2692   0FD0 C6 FE 0F      je fs_rm_not_found
2693   0FD3 0A B7 0F      jmp fs_rm_l1
2694   0FD6             fs_rm_found_entry:
2695   0FD6 2B 19 00      mov b, [d + 25]               ; get lba
2696   0FD9 FD 79         mov g, b                      ; save lba
2697   0FDB 19 00         mov al, 0
2698   0FDD 3E            mov [d], al                   ; make file entry null
2699   0FDE 14 5A 19      mov a, [current_dir_id]
2700   0FE1 77            inc a                         ; metadata sector
2701   0FE2 27            mov b, a
2702   0FE3 38 00 00      mov c, 0                      ; upper lba = 0
2703   0FE6 22 01         mov ah, $01                   ; disk write
2704   0FE8 3B 8E 33      mov d, transient_area
2705   0FEB 07 1C 07      call ide_write_sect           ; write sector and erase file's entry in the current dir
2706   0FEE 3B 8E 33      mov d, transient_area  
2707   0FF1 19 00         mov al, 0
2708   0FF3 3E            mov [d], al                   ; make file's data header null for re-use
2709   0FF4 38 00 00      mov c, 0
2710   0FF7 FD 27         mov b, g                      ; get data header lba
2711   0FF9 22 01         mov ah, $01                   ; disk write 1 sect
2712   0FFB 07 1C 07      call ide_write_sect           ; write sector
2713   0FFE             fs_rm_not_found:  
2714   0FFE 06            sysret  
2715   0FFF             
2716   0FFF             ;------------------------------------------------------------------------------------------------------;
2717   0FFF             ; mv - move / change file name
2718   0FFF             ;------------------------------------------------------------------------------------------------------;
2719   0FFF             fs_mv:
2720   0FFF FD 4E         mov si, d
2721   1001 FD 4F 8E 1F   mov di, user_data
2722   1005 38 00 02      mov c, 512
2723   1008 04            load                          ; load data from user-space
2724   1009 14 5A 19      mov a, [current_dir_id]
2725   100C 77            inc a                         ; metadata sector
2726   100D 27            mov b, a  
2727   100E 38 00 00      mov c, 0                      ; upper lba = 0
2728   1011 22 01         mov ah, $01                  ; 1 sector
2729   1013 3B 8E 33      mov d, transient_area
2730   1016 07 F6 06      call ide_read_sect            ; read directory
2731   1019 FD 10         cla
2732   101B 42 52 19      mov [index], a                ; reset file counter
2733   101E             fs_mv_l1:
2734   101E FD 4E         mov si, d
2735   1020 FD 4F 8E 1F   mov di, user_data
2736   1024 07 63 12      call _strcmp
2737   1027 C6 3D 10      je fs_mv_found_entry
2738   102A 58 20 00      add d, 32
2739   102D 14 52 19      mov a, [index]
2740   1030 77            inc a
2741   1031 42 52 19      mov [index], a
2742   1034 AF 10 00      cmp a, fst_files_per_dir
2743   1037 C6 6F 10      je fs_mv_not_found
2744   103A 0A 1E 10      jmp fs_mv_l1
2745   103D             fs_mv_found_entry:  
2746   103D DA            push d
2747   103E FD 4D 0E 20   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2748   1042 FD 50         mov di, d
2749   1044 07 78 12      call _strcpy  
2750   1047 38 00 00      mov c, 0
2751   104A 3B 8E 33      mov d, transient_area
2752   104D 22 01         mov ah, $01                   ; disk write 1 sect
2753   104F 07 1C 07      call ide_write_sect           ; write sector
2754   1052 E7            pop d
2755   1053             ;; need to check whether its a dir or a file here ;;;
2756   1053 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2757   1056 22 01         mov ah, $01
2758   1058 3B 8E 33      mov d, transient_area
2759   105B 38 00 00      mov c, 0
2760   105E 07 F6 06      call ide_read_sect            ; read directory entry
2761   1061 FD 4D 0E 20   mov si, user_data + 128
2762   1065 FD 50         mov di, d
2763   1067 07 78 12      call _strcpy                  ; change directory's name
2764   106A 22 01         mov ah, $01
2765   106C 07 1C 07      call ide_write_sect           ; rewrite directory back to disk
2766   106F             fs_mv_not_found:
2767   106F 06            sysret
2768   1070             
2769   1070             
2770   1070             ;----------------------------------------------------------------------------------------------------;
2771   1070             ; process index in a
2772   1070             ;----------------------------------------------------------------------------------------------------;
2773   1070             find_free_proc:
2774   1070 FD 4D FF 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2775   1074             find_free_proc_l0:
2776   1074 F6            lodsb                               ; get process state
2777   1075 B9 00         cmp al, 0
2778   1077 C6 7D 10      je find_free_proc_free              ; if free, jump
2779   107A 0A 74 10      jmp find_free_proc_l0               ; else, goto next
2780   107D             find_free_proc_free:
2781   107D 4E            mov a, si
2782   107E 5F FF 1C      sub a, 1 + proc_availab_table       ; get process index
2783   1081 09            ret
2784   1082               
2785   1082             
2786   1082             ;----------------------------------------------------------------------------------------------------;
2787   1082             ; process index in al
2788   1082             ;----------------------------------------------------------------------------------------------------;
2789   1082             proc_memory_map:
2790   1082 22 00         mov ah, 0
2791   1084 27            mov b, a                      ; page in bl, 0 in bh
2792   1085 FD 9D 05      shl a, 5                      ; multiply by 32
2793   1088 39            mov c, a                      ; save in c
2794   1089 57 20 00      add c, 32
2795   108C             proc_memory_map_l0:
2796   108C 02            pagemap
2797   108D 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2798   1090 53 01 00      add a, 1                      ; increase both 
2799   1093 B1            cmp a, c                      ; check to see if we reached the end of memory
2800   1094 C7 8C 10      jne proc_memory_map_l0
2801   1097 09            ret
2802   1098               
2803   1098             
2804   1098             ;----------------------------------------------------------------------------------------------------;
2805   1098             ; terminate process
2806   1098             ;----------------------------------------------------------------------------------------------------;
2807   1098             syscall_terminate_proc:
2808   1098 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2809   109B                                                    ; since they will not be used for anything here.
2810   109B 1D 51 19      mov al, [active_proc_index]
2811   109E 22 00         mov ah, 0  
2812   10A0 FD 9D 05      shl a, 5                             ; x32
2813   10A3 53 0E 1D      add a, proc_names
2814   10A6 3C            mov d, a
2815   10A7 19 00         mov al, 0
2816   10A9 3E            mov [d], al                           ; nullify process name
2817   10AA             
2818   10AA 1D 51 19      mov al, [active_proc_index]
2819   10AD 22 00         mov ah, 0  
2820   10AF 3C            mov d, a
2821   10B0 19 00         mov al, 0
2822   10B2 3F FE 1C      mov [d + proc_availab_table], al    ; make process empty again
2823   10B5               
2824   10B5 1D 50 19      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2825   10B8 80            dec al
2826   10B9 3D 50 19      mov [nbr_active_procs], al
2827   10BC             
2828   10BC             ; now load the shell process again
2829   10BC 19 02         mov al, 2                           ; next process = process 2 = shell
2830   10BE 3D 51 19      mov [active_proc_index], al         ; set next active proc
2831   10C1             
2832   10C1             ; calculate lut entry for next process
2833   10C1 22 00         mov ah, 0
2834   10C3 FD 99         shl a                               ; x2
2835   10C5 B7 8E 11      mov a, [proc_table_convert + a]     ; get process state start index  
2836   10C8               
2837   10C8 4D            mov si, a                           ; source is proc state block
2838   10C9 48            mov a, sp
2839   10CA 5F 13 00      sub a, 19
2840   10CD 4F            mov di, a                           ; destination is kernel stack
2841   10CE             ; restore sp
2842   10CE 7D            dec a
2843   10CF 47            mov sp, a
2844   10D0 38 14 00      mov c, 20
2845   10D3 FD F5         rep movsb
2846   10D5             ; set vm process
2847   10D5 1D 51 19      mov al, [active_proc_index]
2848   10D8 01            setptb
2849   10D9                 
2850   10D9 4C            popa
2851   10DA 06            sysret
2852   10DB             
2853   10DB             ;----------------------------------------------------------------------------------------------------;
2854   10DB             ; pause process
2855   10DB             ;----------------------------------------------------------------------------------------------------;
2856   10DB             syscall_pause_proc:
2857   10DB             ; save all registers into kernel stack
2858   10DB 4B            pusha
2859   10DC 22 00         mov ah, 0
2860   10DE 1D 51 19      mov al, [active_proc_index]
2861   10E1 FD 99         shl a              ; x2
2862   10E3 B7 8E 11      mov a, [proc_table_convert + a]   ; get process state start index
2863   10E6                 
2864   10E6 4F            mov di, a
2865   10E7 48            mov a, sp
2866   10E8 77            inc a
2867   10E9 4D            mov si, a
2868   10EA 38 14 00      mov c, 20
2869   10ED FD F5         rep movsb                         ; save process state!
2870   10EF             ; restore kernel stack position to point before interrupt arrived
2871   10EF 51 14 00      add sp, 20
2872   10F2             ; now load the shell process again
2873   10F2 19 02         mov al, 2                         ; next process = process 2 = shell
2874   10F4 3D 51 19      mov [active_proc_index], al       ; set next active proc
2875   10F7             
2876   10F7             ; calculate lut entry for next process
2877   10F7 22 00         mov ah, 0
2878   10F9 FD 99         shl a                             ; x2
2879   10FB B7 8E 11      mov a, [proc_table_convert + a]   ; get process state start index  
2880   10FE               
2881   10FE 4D            mov si, a                         ; source is proc state block
2882   10FF 48            mov a, sp
2883   1100 5F 13 00      sub a, 19
2884   1103 4F            mov di, a                         ; destination is kernel stack
2885   1104             ; restore sp
2886   1104 7D            dec a
2887   1105 47            mov sp, a
2888   1106 38 14 00      mov c, 20
2889   1109 FD F5         rep movsb
2890   110B             ; set vm process
2891   110B 1D 51 19      mov al, [active_proc_index]
2892   110E 01            setptb
2893   110F                 
2894   110F 4C            popa
2895   1110 06            sysret
2896   1111             
2897   1111             ;----------------------------------------------------------------------------------------------------;
2898   1111             ; create a new process
2899   1111             ; d = path of the process file to be createed
2900   1111             ; b = arguments ptr
2901   1111             ;----------------------------------------------------------------------------------------------------;
2902   1111             syscall_create_proc:
2903   1111             ; we save the active process first  
2904   1111 4B            pusha
2905   1112 22 00         mov ah, 0
2906   1114 1D 51 19      mov al, [active_proc_index]
2907   1117 FD 99         shl a              ; x2
2908   1119 B7 8E 11      mov a, [proc_table_convert + a]    ; get process state table's start index
2909   111C               
2910   111C 4F            mov di, a
2911   111D 48            mov a, sp
2912   111E 77            inc a
2913   111F 4D            mov si, a
2914   1120 38 14 00      mov c, 20
2915   1123 FD F5         rep movsb                          ; save process state!
2916   1125             ; restore kernel stack position to point before interrupt arrived
2917   1125 51 14 00      add sp, 20
2918   1128               
2919   1128 FD 4E         mov si, d                          ; copy the file path
2920   112A FD 4F 8E 1F   mov di, user_data
2921   112E 38 00 02      mov c, 512
2922   1131 04            load
2923   1132 11            mov a, b
2924   1133 4D            mov si, a                          ; copy the arguments
2925   1134 FD 4F 8E 31   mov di, scrap_sector
2926   1138 38 00 02      mov c, 512
2927   113B 04            load
2928   113C 07 AE 0B      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2929   113F                                                  ; the file data is loaded into transient_area
2930   113F             ; now we allocate a new process  
2931   113F 07 70 10      call find_free_proc                ; index in a
2932   1142 01            setptb 
2933   1143 07 82 10      call proc_memory_map               ; map process memory pages
2934   1146             ; copy arguments into process's memory
2935   1146 FD 4D 8E 31   mov si, scrap_sector
2936   114A FD 4F 00 00   mov di, 0
2937   114E 38 00 02      mov c, 512
2938   1151 03            store
2939   1152             ; now copy process binary data into process's memory
2940   1152 FD 4D 8E 33   mov si, transient_area
2941   1156 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2942   115A 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2943   115D 03            store                              ; copy process data
2944   115E                 
2945   115E 07 70 10      call find_free_proc                ; index in a
2946   1161 3D 51 19      mov [active_proc_index], al        ; set new active process
2947   1164 FD 9D 05      shl a, 5                           ; x32
2948   1167 53 0E 1D      add a, proc_names
2949   116A 4F            mov di, a
2950   116B FD 4D 8E 1F   mov si, user_data                  ; copy and store process filename
2951   116F 07 78 12      call _strcpy
2952   1172               
2953   1172 07 70 10      call find_free_proc                ; index in a
2954   1175 3C            mov d, a
2955   1176 19 01         mov al, 1
2956   1178 3F FE 1C      mov [d + proc_availab_table], al   ; make process busy
2957   117B               
2958   117B 1D 50 19      mov al, [nbr_active_procs]         ; increase nbr of active processes
2959   117E 7A            inc al
2960   117F 3D 50 19      mov [nbr_active_procs], al
2961   1182             ; launch process
2962   1182 FD D7 FF FF   push word $ffff 
2963   1186 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2964   1189 FD D7 00 04   push word text_org
2965   118D 06            sysret
2966   118E             
2967   118E             proc_table_convert:
2968   118E BE 1B         .dw proc_state_table + 0
2969   1190 D2 1B         .dw proc_state_table + 20
2970   1192 E6 1B         .dw proc_state_table + 40
2971   1194 FA 1B         .dw proc_state_table + 60
2972   1196 0E 1C         .dw proc_state_table + 80
2973   1198 22 1C         .dw proc_state_table + 100
2974   119A 36 1C         .dw proc_state_table + 120
2975   119C 4A 1C         .dw proc_state_table + 140
2976   119E               
2977   119E             ;----------------------------------------------------------------------------------------------;
2978   119E             ; get hex file
2979   119E             ; di = destination address
2980   119E             ; return length in bytes in c
2981   119E             ;----------------------------------------------------------------------------------------------;
2982   119E             _load_hex:
2983   119E D7            push a
2984   119F D8            push b
2985   11A0 DA            push d
2986   11A1 E2            push si
2987   11A2 E3            push di
2988   11A3 38 00 00      mov c, 0
2989   11A6 50            mov a, di
2990   11A7 3C            mov d, a          ; start of string data block
2991   11A8 07 FB 12      call _gets        ; get program string
2992   11AB 4D            mov si, a
2993   11AC             __load_hex_loop:
2994   11AC F6            lodsb             ; load from [si] to al
2995   11AD B9 00         cmp al, 0         ; check if ascii 0
2996   11AF C6 BD 11      jz __load_hex_ret
2997   11B2 36            mov bh, al
2998   11B3 F6            lodsb
2999   11B4 2F            mov bl, al
3000   11B5 07 B1 12      call _atoi        ; convert ascii byte in b to int (to al)
3001   11B8 F7            stosb             ; store al to [di]
3002   11B9 78            inc c
3003   11BA 0A AC 11      jmp __load_hex_loop
3004   11BD             __load_hex_ret:
3005   11BD F0            pop di
3006   11BE EF            pop si
3007   11BF E7            pop d
3008   11C0 E5            pop b
3009   11C1 E4            pop a
3010   11C2 09            ret
3011   11C3             
3012   11C3             ; synopsis: look inside a certain directory for files/directories
3013   11C3             ; before calling this function, cd into required directory
3014   11C3             ; for each entry inside directory:
3015   11C3             ;  if entry is a file:
3016   11C3             ;    compare filename to searched filename
3017   11C3             ;    if filenames are the same, print filename
3018   11C3             ;  else if entry is a directory:
3019   11C3             ;    cd to the given directory
3020   11C3             ;    recursively call cmd_find
3021   11C3             ;    cd outside previous directory
3022   11C3             ;  if current entry == last entry, return
3023   11C3             ; endfor
3024   11C3             f_find:
3025   11C3 09            ret
3026   11C4             
3027   11C4             
3028   11C4             ; ---------------------------------------------------------------------
3029   11C4             ; kernel reset vector
3030   11C4             ; ---------------------------------------------------------------------
3031   11C4             kernel_reset_vector:  
3032   11C4 FD 49 FF F7   mov bp, _stack_begin
3033   11C8 FD 47 FF F7   mov sp, _stack_begin
3034   11CC               
3035   11CC 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
3036   11CE FD 0F         stomsk                        
3037   11D0 FD 0C         sti  
3038   11D2             
3039   11D2 0C            lodstat
3040   11D3 87 DF         and al, %11011111             ; disable display register loading
3041   11D5 0D            stostat
3042   11D6               
3043   11D6             ; reset fifo pointers
3044   11D6 10 8E 21      mov a, fifo
3045   11D9 3B 56 19      mov d, fifo_in
3046   11DC 43            mov [d], a
3047   11DD 3B 58 19      mov d, fifo_out
3048   11E0 43            mov [d], a  
3049   11E1 19 02         mov al, 2
3050   11E3 05 03         syscall sys_io                ; enable uart in interrupt mode
3051   11E5             
3052   11E5 3B AB 19      mov d, s_kernel_welcome
3053   11E8 07 20 14      call _puts
3054   11EB             
3055   11EB 3B 7D 1B      mov d, s_fdc_config
3056   11EE 07 20 14      call _puts
3057   11F1 F2 C0 FF 0D   mov byte [_fdc_config], %00001101  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
3058   11F5 F2 C8 FF 0B   mov byte [_fdc_stat_cmd], %00001011     ; leave this restore command in order to clear BUSY flag
3059   11F9 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
3060   11FD             
3061   11FD 19 10         mov al, 16
3062   11FF 05 04         syscall sys_filesystem        ; set root dirid
3063   1201             
3064   1201 3B A0 1A      mov d, s_prompt_init
3065   1204 07 20 14      call _puts
3066   1207 3B 5C 19      mov d, s_init_path
3067   120A 05 05         syscall sys_create_proc       ; launch init as a new process
3068   120C             
3069   120C             ; file includes
3070   120C             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  120C             boot_origin      .EQU  $8004
0002+  120C             bios_uart        .EQU  $0002
0003+  120C             bios_ide         .EQU  $0003
0004+  120C             bios_reset_vector .EQU  $01c0
0005+  120C             ide_buffer       .EQU  $8204
3071   120C             .include "lib/stdio.asm"
0001+  120C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  120C             ; stdio.s
0003+  120C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  120C             .include "lib/string.asm"
0001++ 120C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 120C             ; string.s
0003++ 120C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 120C             
0005++ 120C             
0006++ 120C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 120C             ; _strrev
0008++ 120C             ; reverse a string
0009++ 120C             ; d = string address
0010++ 120C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 120C             ; 01234
0012++ 120C             _strrev:
0013++ 120C 4B          	pusha
0014++ 120D 07 53 12    	call _strlen	; length in c
0015++ 1210 12          	mov a, c
0016++ 1211 AF 01 00    	cmp a, 1
0017++ 1214 D0 2E 12    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1217 7D          	dec a
0019++ 1218 FD 4E       	mov si, d	; beginning of string
0020++ 121A FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 121C 59          	add d, a	; end of string
0022++ 121D 12          	mov a, c
0023++ 121E FD 9B       	shr a		; divide by 2
0024++ 1220 39          	mov c, a	; c now counts the steps
0025++ 1221             _strrev_l0:
0026++ 1221 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1222 F6          	lodsb		; load left-side char into al; increase si
0028++ 1223 3E          	mov [d], al	; store left char into right side
0029++ 1224 1B          	mov al, bl
0030++ 1225 F7          	stosb		; store right-side char into left-side; increase di
0031++ 1226 7E          	dec c
0032++ 1227 7F          	dec d
0033++ 1228 C2 00 00    	cmp c, 0
0034++ 122B C7 21 12    	jne _strrev_l0
0035++ 122E             _strrev_end:
0036++ 122E 4C          	popa
0037++ 122F 09          	ret
0038++ 1230             	
0039++ 1230             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1230             ; _strchr
0041++ 1230             ; search string in d for char in al
0042++ 1230             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1230             _strchr:
0044++ 1230             _strchr_l0:
0045++ 1230 32          	mov bl, [d]
0046++ 1231 C1 00       	cmp bl, 0
0047++ 1233 C6 3E 12    	je _strchr_end
0048++ 1236 BA          	cmp al, bl
0049++ 1237 C6 3E 12    	je _strchr_end
0050++ 123A 79          	inc d
0051++ 123B 0A 30 12    	jmp _strchr_l0
0052++ 123E             _strchr_end:
0053++ 123E 1B          	mov al, bl
0054++ 123F 09          	ret
0055++ 1240             
0056++ 1240             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1240             ; _strstr
0058++ 1240             ; find sub-string
0059++ 1240             ; str1 in si
0060++ 1240             ; str2 in di
0061++ 1240             ; si points to end of source string
0062++ 1240             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1240             _strstr:
0064++ 1240 DB          	push al
0065++ 1241 DA          	push d
0066++ 1242 E3          	push di
0067++ 1243             _strstr_loop:
0068++ 1243 F3          	cmpsb					; compare a byte of the strings
0069++ 1244 C7 4F 12    	jne _strstr_ret
0070++ 1247 FC 00 00    	lea d, [di + 0]
0071++ 124A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 124C C7 43 12    	jne _strstr_loop				; equal chars but not at end
0073++ 124F             _strstr_ret:
0074++ 124F F0          	pop di
0075++ 1250 E7          	pop d
0076++ 1251 E8          	pop al
0077++ 1252 09          	ret
0078++ 1253             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1253             ; length of null terminated string
0080++ 1253             ; result in c
0081++ 1253             ; pointer in d
0082++ 1253             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1253             _strlen:
0084++ 1253 DA          	push d
0085++ 1254 38 00 00    	mov c, 0
0086++ 1257             _strlen_l1:
0087++ 1257 BD 00       	cmp byte [d], 0
0088++ 1259 C6 61 12    	je _strlen_ret
0089++ 125C 79          	inc d
0090++ 125D 78          	inc c
0091++ 125E 0A 57 12    	jmp _strlen_l1
0092++ 1261             _strlen_ret:
0093++ 1261 E7          	pop d
0094++ 1262 09          	ret
0095++ 1263             
0096++ 1263             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1263             ; strcmp
0098++ 1263             ; compare two strings
0099++ 1263             ; str1 in si
0100++ 1263             ; str2 in di
0101++ 1263             ; create a string compairon instrucion ?????
0102++ 1263             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1263             _strcmp:
0104++ 1263 DB          	push al
0105++ 1264 DA          	push d
0106++ 1265 E3          	push di
0107++ 1266 E2          	push si
0108++ 1267             _strcmp_loop:
0109++ 1267 F3          	cmpsb					; compare a byte of the strings
0110++ 1268 C7 73 12    	jne _strcmp_ret
0111++ 126B FB FF FF    	lea d, [si +- 1]
0112++ 126E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1270 C7 67 12    	jne _strcmp_loop				; equal chars but not at end
0114++ 1273             _strcmp_ret:
0115++ 1273 EF          	pop si
0116++ 1274 F0          	pop di
0117++ 1275 E7          	pop d
0118++ 1276 E8          	pop al
0119++ 1277 09          	ret
0120++ 1278             
0121++ 1278             
0122++ 1278             ; strcpy
0123++ 1278             ; copy null terminated string from si to di
0124++ 1278             ; source in si
0125++ 1278             ; destination in di
0126++ 1278             _strcpy:
0127++ 1278 E2          	push si
0128++ 1279 E3          	push di
0129++ 127A DB          	push al
0130++ 127B             _strcpy_l1:
0131++ 127B F6          	lodsb
0132++ 127C F7          	stosb
0133++ 127D B9 00       	cmp al, 0
0134++ 127F C7 7B 12    	jne _strcpy_l1
0135++ 1282             _strcpy_end:
0136++ 1282 E8          	pop al
0137++ 1283 F0          	pop di
0138++ 1284 EF          	pop si
0139++ 1285 09          	ret
0140++ 1286             
0141++ 1286             ; strcat
0142++ 1286             ; concatenate a null terminated string into string at di, from string at si
0143++ 1286             ; source in si
0144++ 1286             ; destination in di
0145++ 1286             _strcat:
0146++ 1286 E2          	push si
0147++ 1287 E3          	push di
0148++ 1288 D7          	push a
0149++ 1289 DA          	push d
0150++ 128A 50          	mov a, di
0151++ 128B 3C          	mov d, a
0152++ 128C             _strcat_goto_end_l1:
0153++ 128C BD 00       	cmp byte[d], 0
0154++ 128E C6 95 12    	je _strcat_start
0155++ 1291 79          	inc d
0156++ 1292 0A 8C 12    	jmp _strcat_goto_end_l1
0157++ 1295             _strcat_start:
0158++ 1295 FD 50       	mov di, d
0159++ 1297             _strcat_l1:
0160++ 1297 F6          	lodsb
0161++ 1298 F7          	stosb
0162++ 1299 B9 00       	cmp al, 0
0163++ 129B C7 97 12    	jne _strcat_l1
0164++ 129E             _strcat_end:
0165++ 129E E7          	pop d
0166++ 129F E4          	pop a
0167++ 12A0 F0          	pop di
0168++ 12A1 EF          	pop si
0169++ 12A2 09          	ret
0170++ 12A3             
0171++ 12A3             
0005+  12A3             
0006+  12A3             
0007+  12A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  12A3             ; convert ascii 'o'..'f' to integer 0..15
0009+  12A3             ; ascii in bl
0010+  12A3             ; result in al
0011+  12A3             ; ascii for f = 0100 0110
0012+  12A3             ; ascii for 9 = 0011 1001
0013+  12A3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  12A3             hex_ascii_encode:
0015+  12A3 1B            mov al, bl
0016+  12A4 93 40         test al, $40        ; test if letter or number
0017+  12A6 C7 AC 12      jnz hex_letter
0018+  12A9 87 0F         and al, $0f        ; get number
0019+  12AB 09            ret
0020+  12AC             hex_letter:
0021+  12AC 87 0F         and al, $0f        ; get letter
0022+  12AE 6A 09         add al, 9
0023+  12B0 09            ret
0024+  12B1             
0025+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  12B1             ; atoi
0027+  12B1             ; 2 letter hex string in b
0028+  12B1             ; 8bit integer returned in al
0029+  12B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  12B1             _atoi:
0031+  12B1 D8            push b
0032+  12B2 07 A3 12      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  12B5 30            mov bl, bh
0034+  12B6 DB            push al          ; save a
0035+  12B7 07 A3 12      call hex_ascii_encode
0036+  12BA EA            pop bl  
0037+  12BB FD 9E 04      shl al, 4
0038+  12BE 8C            or al, bl
0039+  12BF E5            pop b
0040+  12C0 09            ret  
0041+  12C1             
0042+  12C1             
0043+  12C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  12C1             ; scanf
0045+  12C1             ; no need for explanations!
0046+  12C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  12C1             scanf:
0048+  12C1 09            ret
0049+  12C2             
0050+  12C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  12C2             ; itoa
0052+  12C2             ; 8bit value in bl
0053+  12C2             ; 2 byte ascii result in a
0054+  12C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  12C2             _itoa:
0056+  12C2 DA            push d
0057+  12C3 D8            push b
0058+  12C4 A7 00         mov bh, 0
0059+  12C6 FD A4 04      shr bl, 4  
0060+  12C9 74            mov d, b
0061+  12CA 1F 5C 15      mov al, [d + s_hex_digits]
0062+  12CD 23            mov ah, al
0063+  12CE               
0064+  12CE E5            pop b
0065+  12CF D8            push b
0066+  12D0 A7 00         mov bh, 0
0067+  12D2 FD 87 0F      and bl, $0f
0068+  12D5 74            mov d, b
0069+  12D6 1F 5C 15      mov al, [d + s_hex_digits]
0070+  12D9 E5            pop b
0071+  12DA E7            pop d
0072+  12DB 09            ret
0073+  12DC             
0074+  12DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  12DC             ; hex string to binary
0076+  12DC             ; di = destination address
0077+  12DC             ; si = source
0078+  12DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  12DC             _hex_to_int:
0080+  12DC             _hex_to_int_l1:
0081+  12DC F6            lodsb          ; load from [si] to al
0082+  12DD B9 00         cmp al, 0        ; check if ascii 0
0083+  12DF C6 EC 12      jz _hex_to_int_ret
0084+  12E2 36            mov bh, al
0085+  12E3 F6            lodsb
0086+  12E4 2F            mov bl, al
0087+  12E5 07 B1 12      call _atoi        ; convert ascii byte in b to int (to al)
0088+  12E8 F7            stosb          ; store al to [di]
0089+  12E9 0A DC 12      jmp _hex_to_int_l1
0090+  12EC             _hex_to_int_ret:
0091+  12EC 09            ret    
0092+  12ED             
0093+  12ED             
0094+  12ED             
0095+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  12ED             ; getchar
0097+  12ED             ; char in ah
0098+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  12ED             getch:
0100+  12ED DB            push al
0101+  12EE             getch_retry:
0102+  12EE 19 01         mov al, 1
0103+  12F0 05 03         syscall sys_io      ; receive in ah
0104+  12F2 E8            pop al
0105+  12F3 09            ret
0106+  12F4             
0107+  12F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  12F4             ; putchar
0109+  12F4             ; char in ah
0110+  12F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  12F4             _putchar:
0112+  12F4 DB            push al
0113+  12F5 19 00         mov al, 0
0114+  12F7 05 03         syscall sys_io      ; char in ah
0115+  12F9 E8            pop al
0116+  12FA 09            ret
0117+  12FB             
0118+  12FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  12FB             ;; input a string
0120+  12FB             ;; terminates with null
0121+  12FB             ;; pointer in d
0122+  12FB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  12FB             _gets:
0124+  12FB D7            push a
0125+  12FC DA            push d
0126+  12FD             _gets_loop:
0127+  12FD 19 01         mov al, 1
0128+  12FF 05 03         syscall sys_io      ; receive in ah
0129+  1301 76 1B         cmp ah, 27
0130+  1303 C6 24 13      je _gets_ansi_esc
0131+  1306 76 0A         cmp ah, $0a        ; lf
0132+  1308 C6 80 13      je _gets_end
0133+  130B 76 0D         cmp ah, $0d        ; cr
0134+  130D C6 80 13      je _gets_end
0135+  1310 76 5C         cmp ah, $5c        ; '\\'
0136+  1312 C6 46 13      je _gets_escape
0137+  1315 76 08         cmp ah, $08      ; check for backspace
0138+  1317 C6 20 13      je _gets_backspace
0139+  131A 1A            mov al, ah
0140+  131B 3E            mov [d], al
0141+  131C 79            inc d
0142+  131D 0A FD 12      jmp _gets_loop
0143+  1320             _gets_backspace:
0144+  1320 7F            dec d
0145+  1321 0A FD 12      jmp _gets_loop
0146+  1324             _gets_ansi_esc:
0147+  1324 19 01         mov al, 1
0148+  1326 05 03         syscall sys_io        ; receive in ah without echo
0149+  1328 76 5B         cmp ah, '['
0150+  132A C7 FD 12      jne _gets_loop
0151+  132D 19 01         mov al, 1
0152+  132F 05 03         syscall sys_io          ; receive in ah without echo
0153+  1331 76 64         cmp ah, 'd'
0154+  1333 C6 3E 13      je _gets_left_arrow
0155+  1336 76 63         cmp ah, 'c'
0156+  1338 C6 42 13      je _gets_right_arrow
0157+  133B 0A FD 12      jmp _gets_loop
0158+  133E             _gets_left_arrow:
0159+  133E 7F            dec d
0160+  133F 0A FD 12      jmp _gets_loop
0161+  1342             _gets_right_arrow:
0162+  1342 79            inc d
0163+  1343 0A FD 12      jmp _gets_loop
0164+  1346             _gets_escape:
0165+  1346 19 01         mov al, 1
0166+  1348 05 03         syscall sys_io      ; receive in ah
0167+  134A 76 6E         cmp ah, 'n'
0168+  134C C6 6B 13      je _gets_lf
0169+  134F 76 72         cmp ah, 'r'
0170+  1351 C6 72 13      je _gets_cr
0171+  1354 76 30         cmp ah, '0'
0172+  1356 C6 79 13      je _gets_null
0173+  1359 76 5C         cmp ah, $5c  ; '\'
0174+  135B C6 64 13      je _gets_slash
0175+  135E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  135F 3E            mov [d], al
0177+  1360 79            inc d
0178+  1361 0A FD 12      jmp _gets_loop
0179+  1364             _gets_slash:
0180+  1364 19 5C         mov al, $5c
0181+  1366 3E            mov [d], al
0182+  1367 79            inc d
0183+  1368 0A FD 12      jmp _gets_loop
0184+  136B             _gets_lf:
0185+  136B 19 0A         mov al, $0a
0186+  136D 3E            mov [d], al
0187+  136E 79            inc d
0188+  136F 0A FD 12      jmp _gets_loop
0189+  1372             _gets_cr:
0190+  1372 19 0D         mov al, $0d
0191+  1374 3E            mov [d], al
0192+  1375 79            inc d
0193+  1376 0A FD 12      jmp _gets_loop
0194+  1379             _gets_null:
0195+  1379 19 00         mov al, $00
0196+  137B 3E            mov [d], al
0197+  137C 79            inc d
0198+  137D 0A FD 12      jmp _gets_loop
0199+  1380             _gets_end:
0200+  1380 19 00         mov al, 0
0201+  1382 3E            mov [d], al        ; terminate string
0202+  1383 E7            pop d
0203+  1384 E4            pop a
0204+  1385 09            ret
0205+  1386             
0206+  1386             
0207+  1386             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1386             ;; input text
0209+  1386             ;; terminated with ctrl+d
0210+  1386             ;; pointer in d
0211+  1386             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1386             _gettxt:
0213+  1386 D7            push a
0214+  1387 DA            push d
0215+  1388             _gettxt_loop:
0216+  1388 19 01         mov al, 1
0217+  138A 05 03         syscall sys_io      ; receive in ah
0218+  138C 76 04         cmp ah, 4      ; eot
0219+  138E C6 C7 13      je _gettxt_end
0220+  1391 76 08         cmp ah, $08      ; check for backspace
0221+  1393 C6 C3 13      je _gettxt_backspace
0222+  1396 76 5C         cmp ah, $5c        ; '\'
0223+  1398 C6 A1 13      je _gettxt_escape
0224+  139B 1A            mov al, ah
0225+  139C 3E            mov [d], al
0226+  139D 79            inc d
0227+  139E 0A 88 13      jmp _gettxt_loop
0228+  13A1             _gettxt_escape:
0229+  13A1 19 01         mov al, 1
0230+  13A3 05 03         syscall sys_io      ; receive in ah
0231+  13A5 76 6E         cmp ah, 'n'
0232+  13A7 C6 B5 13      je _gettxt_lf
0233+  13AA 76 72         cmp ah, 'r'
0234+  13AC C6 BC 13      je _gettxt_cr
0235+  13AF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  13B0 3E            mov [d], al
0237+  13B1 79            inc d
0238+  13B2 0A 88 13      jmp _gettxt_loop
0239+  13B5             _gettxt_lf:
0240+  13B5 19 0A         mov al, $0a
0241+  13B7 3E            mov [d], al
0242+  13B8 79            inc d
0243+  13B9 0A 88 13      jmp _gettxt_loop
0244+  13BC             _gettxt_cr:
0245+  13BC 19 0D         mov al, $0d
0246+  13BE 3E            mov [d], al
0247+  13BF 79            inc d
0248+  13C0 0A 88 13      jmp _gettxt_loop
0249+  13C3             _gettxt_backspace:
0250+  13C3 7F            dec d
0251+  13C4 0A 88 13      jmp _gettxt_loop
0252+  13C7             _gettxt_end:
0253+  13C7 19 00         mov al, 0
0254+  13C9 3E            mov [d], al        ; terminate string
0255+  13CA E7            pop d
0256+  13CB E4            pop a
0257+  13CC 09            ret
0258+  13CD             
0259+  13CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  13CD             ; print new line
0261+  13CD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  13CD             printnl:
0263+  13CD D7            push a
0264+  13CE 10 00 0A      mov a, $0a00
0265+  13D1 05 03         syscall sys_io
0266+  13D3 10 00 0D      mov a, $0d00
0267+  13D6 05 03         syscall sys_io
0268+  13D8 E4            pop a
0269+  13D9 09            ret
0270+  13DA             
0271+  13DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  13DA             ; _strtoint
0273+  13DA             ; 4 digit hex string number in d
0274+  13DA             ; integer returned in a
0275+  13DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  13DA             _strtointx:
0277+  13DA D8            push b
0278+  13DB 32            mov bl, [d]
0279+  13DC 37            mov bh, bl
0280+  13DD 33 01 00      mov bl, [d + 1]
0281+  13E0 07 B1 12      call _atoi        ; convert to int in al
0282+  13E3 23            mov ah, al        ; move to ah
0283+  13E4 33 02 00      mov bl, [d + 2]
0284+  13E7 37            mov bh, bl
0285+  13E8 33 03 00      mov bl, [d + 3]
0286+  13EB 07 B1 12      call _atoi        ; convert to int in al
0287+  13EE E5            pop b
0288+  13EF 09            ret
0289+  13F0             
0290+  13F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  13F0             ; _strtoint
0292+  13F0             ; 5 digit base10 string number in d
0293+  13F0             ; integer returned in a
0294+  13F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  13F0             _strtoint:
0296+  13F0 E2            push si
0297+  13F1 D8            push b
0298+  13F2 D9            push c
0299+  13F3 DA            push d
0300+  13F4 07 53 12      call _strlen      ; get string length in c
0301+  13F7 7E            dec c
0302+  13F8 FD 4E         mov si, d
0303+  13FA 12            mov a, c
0304+  13FB FD 99         shl a
0305+  13FD 3B 74 15      mov d, table_power
0306+  1400 59            add d, a
0307+  1401 38 00 00      mov c, 0
0308+  1404             _strtoint_l0:
0309+  1404 F6            lodsb      ; load ascii to al
0310+  1405 B9 00         cmp al, 0
0311+  1407 C6 1A 14      je _strtoint_end
0312+  140A 6F 30         sub al, $30    ; make into integer
0313+  140C 22 00         mov ah, 0
0314+  140E 2A            mov b, [d]
0315+  140F AC            mul a, b      ; result in b since it fits in 16bits
0316+  1410 11            mov a, b
0317+  1411 28            mov b, c
0318+  1412 54            add a, b
0319+  1413 39            mov c, a
0320+  1414 63 02 00      sub d, 2
0321+  1417 0A 04 14      jmp _strtoint_l0
0322+  141A             _strtoint_end:
0323+  141A 12            mov a, c
0324+  141B E7            pop d
0325+  141C E6            pop c
0326+  141D E5            pop b
0327+  141E EF            pop si
0328+  141F 09            ret
0329+  1420             
0330+  1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1420             ; print null terminated string
0332+  1420             ; pointer in d
0333+  1420             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1420             _puts:
0335+  1420 D7            push a
0336+  1421 DA            push d
0337+  1422             _puts_l1:
0338+  1422 1E            mov al, [d]
0339+  1423 B9 00         cmp al, 0
0340+  1425 C6 31 14      jz _puts_end
0341+  1428 23            mov ah, al
0342+  1429 19 00         mov al, 0
0343+  142B 05 03         syscall sys_io
0344+  142D 79            inc d
0345+  142E 0A 22 14      jmp _puts_l1
0346+  1431             _puts_end:
0347+  1431 E7            pop d
0348+  1432 E4            pop a
0349+  1433 09            ret
0350+  1434             
0351+  1434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1434             ; print n size string
0353+  1434             ; pointer in d
0354+  1434             ; size in c
0355+  1434             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1434             _putsn:
0357+  1434 DB            push al
0358+  1435 DA            push d
0359+  1436 D9            push c
0360+  1437             _putsn_l0:
0361+  1437 1E            mov al, [d]
0362+  1438 23            mov ah, al
0363+  1439 19 00         mov al, 0
0364+  143B 05 03         syscall sys_io
0365+  143D 79            inc d
0366+  143E 7E            dec c  
0367+  143F C2 00 00      cmp c, 0
0368+  1442 C7 37 14      jne _putsn_l0
0369+  1445             _putsn_end:
0370+  1445 E6            pop c
0371+  1446 E7            pop d
0372+  1447 E8            pop al
0373+  1448 09            ret
0374+  1449             
0375+  1449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1449             ; print 16bit decimal number
0377+  1449             ; input number in a
0378+  1449             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1449             print_u16d:
0380+  1449 D7            push a
0381+  144A D8            push b
0382+  144B FD D8         push g
0383+  144D 26 10 27      mov b, 10000
0384+  1450 AE            div a, b      ; get 10000's coeff.
0385+  1451 07 75 14      call print_number
0386+  1454 11            mov a, b
0387+  1455 26 E8 03      mov b, 1000
0388+  1458 AE            div a, b      ; get 1000's coeff.
0389+  1459 07 75 14      call print_number
0390+  145C 11            mov a, b
0391+  145D 26 64 00      mov b, 100
0392+  1460 AE            div a, b
0393+  1461 07 75 14      call print_number
0394+  1464 11            mov a, b
0395+  1465 26 0A 00      mov b, 10
0396+  1468 AE            div a, b
0397+  1469 07 75 14      call print_number
0398+  146C 1B            mov al, bl      ; 1's coeff in bl
0399+  146D 07 75 14      call print_number
0400+  1470 FD F1         pop g
0401+  1472 E5            pop b
0402+  1473 E4            pop a
0403+  1474 09            ret
0404+  1475             
0405+  1475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1475             ; print al
0407+  1475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1475             print_number:
0409+  1475 6A 30         add al, $30
0410+  1477 23            mov ah, al
0411+  1478 07 F4 12      call _putchar
0412+  147B 09            ret
0413+  147C             
0414+  147C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  147C             ; print 16bit hex integer
0416+  147C             ; integer value in reg b
0417+  147C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  147C             print_u16x:
0419+  147C D7            push a
0420+  147D D8            push b
0421+  147E DD            push bl
0422+  147F 30            mov bl, bh
0423+  1480 07 C2 12      call _itoa        ; convert bh to char in a
0424+  1483 2F            mov bl, al        ; save al
0425+  1484 19 00         mov al, 0
0426+  1486 05 03         syscall sys_io        ; display ah
0427+  1488 24            mov ah, bl        ; retrieve al
0428+  1489 19 00         mov al, 0
0429+  148B 05 03         syscall sys_io        ; display al
0430+  148D             
0431+  148D EA            pop bl
0432+  148E 07 C2 12      call _itoa        ; convert bh to char in a
0433+  1491 2F            mov bl, al        ; save al
0434+  1492 19 00         mov al, 0
0435+  1494 05 03         syscall sys_io        ; display ah
0436+  1496 24            mov ah, bl        ; retrieve al
0437+  1497 19 00         mov al, 0
0438+  1499 05 03         syscall sys_io        ; display al
0439+  149B             
0440+  149B E5            pop b
0441+  149C E4            pop a
0442+  149D 09            ret
0443+  149E             
0444+  149E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  149E             ; input 16bit hex integer
0446+  149E             ; read 16bit integer into a
0447+  149E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  149E             scan_u16x:
0449+  149E F8 10 00      enter 16
0450+  14A1 D8            push b
0451+  14A2 DA            push d
0452+  14A3             
0453+  14A3 FA F1 FF      lea d, [bp + -15]
0454+  14A6 07 FB 12      call _gets        ; get number
0455+  14A9             
0456+  14A9 32            mov bl, [d]
0457+  14AA 37            mov bh, bl
0458+  14AB 33 01 00      mov bl, [d + 1]
0459+  14AE 07 B1 12      call _atoi        ; convert to int in al
0460+  14B1 23            mov ah, al        ; move to ah
0461+  14B2             
0462+  14B2 33 02 00      mov bl, [d + 2]
0463+  14B5 37            mov bh, bl
0464+  14B6 33 03 00      mov bl, [d + 3]
0465+  14B9 07 B1 12      call _atoi        ; convert to int in al
0466+  14BC             
0467+  14BC E7            pop d
0468+  14BD E5            pop b
0469+  14BE F9            leave
0470+  14BF 09            ret
0471+  14C0             
0472+  14C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  14C0             ; print 8bit hex integer
0474+  14C0             ; integer value in reg bl
0475+  14C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  14C0             print_u8x:
0477+  14C0 D7            push a
0478+  14C1 DD            push bl
0479+  14C2             
0480+  14C2 07 C2 12      call _itoa        ; convert bl to char in a
0481+  14C5 2F            mov bl, al        ; save al
0482+  14C6 19 00         mov al, 0
0483+  14C8 05 03         syscall sys_io        ; display ah
0484+  14CA 24            mov ah, bl        ; retrieve al
0485+  14CB 19 00         mov al, 0
0486+  14CD 05 03         syscall sys_io        ; display al
0487+  14CF             
0488+  14CF EA            pop bl
0489+  14D0 E4            pop a
0490+  14D1 09            ret
0491+  14D2             
0492+  14D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  14D2             ; print 8bit decimal unsigned number
0494+  14D2             ; input number in al
0495+  14D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  14D2             print_u8d:
0497+  14D2 D7            push a
0498+  14D3 D8            push b
0499+  14D4 FD D8         push g
0500+  14D6 22 00         mov ah, 0
0501+  14D8 26 64 00      mov b, 100
0502+  14DB AE            div a, b
0503+  14DC D8            push b      ; save remainder
0504+  14DD B9 00         cmp al, 0
0505+  14DF C6 E9 14      je skip100
0506+  14E2 6A 30         add al, $30
0507+  14E4 23            mov ah, al
0508+  14E5 19 00         mov al, 0
0509+  14E7 05 03         syscall sys_io  ; print coeff
0510+  14E9             skip100:
0511+  14E9 E4            pop a
0512+  14EA 22 00         mov ah, 0
0513+  14EC 26 0A 00      mov b, 10
0514+  14EF AE            div a, b
0515+  14F0 D8            push b      ; save remainder
0516+  14F1 B9 00         cmp al, 0
0517+  14F3 C6 FD 14      je skip10
0518+  14F6 6A 30         add al, $30
0519+  14F8 23            mov ah, al
0520+  14F9 19 00         mov al, 0
0521+  14FB 05 03         syscall sys_io  ; print coeff
0522+  14FD             skip10:
0523+  14FD E4            pop a
0524+  14FE 1B            mov al, bl
0525+  14FF 6A 30         add al, $30
0526+  1501 23            mov ah, al
0527+  1502 19 00         mov al, 0
0528+  1504 05 03         syscall sys_io  ; print coeff
0529+  1506 FD F1         pop g
0530+  1508 E5            pop b
0531+  1509 E4            pop a
0532+  150A 09            ret
0533+  150B             
0534+  150B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  150B             ; input 8bit hex integer
0536+  150B             ; read 8bit integer into al
0537+  150B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  150B             scan_u8x:
0539+  150B F8 04 00      enter 4
0540+  150E D8            push b
0541+  150F DA            push d
0542+  1510             
0543+  1510 FA FD FF      lea d, [bp + -3]
0544+  1513 07 FB 12      call _gets        ; get number
0545+  1516             
0546+  1516 32            mov bl, [d]
0547+  1517 37            mov bh, bl
0548+  1518 33 01 00      mov bl, [d + 1]
0549+  151B 07 B1 12      call _atoi        ; convert to int in al
0550+  151E             
0551+  151E E7            pop d
0552+  151F E5            pop b
0553+  1520 F9            leave
0554+  1521 09            ret
0555+  1522             
0556+  1522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1522             ; input decimal number
0558+  1522             ; result in a
0559+  1522             ; 655'\0'
0560+  1522             ; low--------high
0561+  1522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1522             scan_u16d:
0563+  1522 F8 08 00      enter 8
0564+  1525 E2            push si
0565+  1526 D8            push b
0566+  1527 D9            push c
0567+  1528 DA            push d
0568+  1529 FA F9 FF      lea d, [bp +- 7]
0569+  152C 07 FB 12      call _gets
0570+  152F 07 53 12      call _strlen      ; get string length in c
0571+  1532 7E            dec c
0572+  1533 FD 4E         mov si, d
0573+  1535 12            mov a, c
0574+  1536 FD 99         shl a
0575+  1538 3B 74 15      mov d, table_power
0576+  153B 59            add d, a
0577+  153C 38 00 00      mov c, 0
0578+  153F             mul_loop:
0579+  153F F6            lodsb      ; load ascii to al
0580+  1540 B9 00         cmp al, 0
0581+  1542 C6 55 15      je mul_exit
0582+  1545 6F 30         sub al, $30    ; make into integer
0583+  1547 22 00         mov ah, 0
0584+  1549 2A            mov b, [d]
0585+  154A AC            mul a, b      ; result in b since it fits in 16bits
0586+  154B 11            mov a, b
0587+  154C 28            mov b, c
0588+  154D 54            add a, b
0589+  154E 39            mov c, a
0590+  154F 63 02 00      sub d, 2
0591+  1552 0A 3F 15      jmp mul_loop
0592+  1555             mul_exit:
0593+  1555 12            mov a, c
0594+  1556 E7            pop d
0595+  1557 E6            pop c
0596+  1558 E5            pop b
0597+  1559 EF            pop si
0598+  155A F9            leave
0599+  155B 09            ret
0600+  155C             
0601+  155C             
0602+  155C 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  1560 34 35 36 37 
0602+  1564 38 39 61 62 
0602+  1568 63 64 65 66 
0603+  156C 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  1570 1B 5B 68 00 
0604+  1574             
0605+  1574             table_power:
0606+  1574 01 00         .dw 1
0607+  1576 0A 00         .dw 10
0608+  1578 64 00         .dw 100
0609+  157A E8 03         .dw 1000
0610+  157C 10 27         .dw 100003072   157E             .include "lib/ctype.asm"
0001+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  157E             ; ctype.s
0003+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  157E             
0005+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  157E             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  157E             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  157E             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  157E             ;; characters are supported.
0010+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  157E             ;; _isalnum 
0012+  157E             ;; _isalpha 
0013+  157E             ;; islower 
0014+  157E             ;; isupper 
0015+  157E             ;; _isdigit 
0016+  157E             ;; isxdigit
0017+  157E             ;; iscntrl 
0018+  157E             ;; isgraph 
0019+  157E             ;; _isspace 
0020+  157E             ;; isblank 
0021+  157E             ;; isprint 
0022+  157E             ;; ispunct 
0023+  157E             ;; tolower 
0024+  157E             ;; toupper
0025+  157E             
0026+  157E             
0027+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  157E             ;; is alphanumeric
0029+  157E             ;; sets zf according with result
0030+  157E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  157E             _isalnum:
0032+  157E 07 9B 15    	call _isalpha
0033+  1581 C6 87 15    	je _isalnum_exit
0034+  1584 07 88 15    	call _isdigit
0035+  1587             _isalnum_exit:
0036+  1587 09          	ret	
0037+  1588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1588             ;; is digit
0039+  1588             ;; sets zf according with result
0040+  1588             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1588             _isdigit:
0042+  1588 DB          	push al
0043+  1589 B9 30       	cmp al, '0'
0044+  158B C8 97 15    	jlu _isdigit_false
0045+  158E B9 39       	cmp al, '9'
0046+  1590 D1 97 15    	jgu _isdigit_false
0047+  1593 87 00       	and al, 0	; set zf
0048+  1595 E8          	pop al
0049+  1596 09          	ret
0050+  1597             _isdigit_false:
0051+  1597 8B 01       	or al, 1	; clear zf
0052+  1599 E8          	pop al
0053+  159A 09          	ret	
0054+  159B             	
0055+  159B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  159B             ;; is alpha
0057+  159B             ;; sets zf according with result
0058+  159B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  159B             _isalpha:
0060+  159B DB          	push al
0061+  159C B9 5F       	cmp al, '_'
0062+  159E C6 BE 15    	je _isalpha_true
0063+  15A1 B9 2E       	cmp al, '.'
0064+  15A3 C6 BE 15    	je _isalpha_true
0065+  15A6 B9 61       	cmp al, 'a'
0066+  15A8 C8 BA 15    	jlu _isalpha_false
0067+  15AB B9 7A       	cmp al, 'z'
0068+  15AD D1 BA 15    	jgu _isalpha_false
0069+  15B0 B9 7A       	cmp al, 'z'
0070+  15B2 D0 BE 15    	jleu _isalpha_true
0071+  15B5 B9 61       	cmp al, 'a'
0072+  15B7 C9 BE 15    	jgeu _isalpha_true
0073+  15BA             _isalpha_false:
0074+  15BA 8B 01       	or al, 1	; clear zf
0075+  15BC E8          	pop al
0076+  15BD 09          	ret
0077+  15BE             _isalpha_true:
0078+  15BE 87 00       	and al, 0	; set zf
0079+  15C0 E8          	pop al
0080+  15C1 09          	ret
0081+  15C2             
0082+  15C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  15C2             ;; is path-alpha
0084+  15C2             ;; sets zf according with result
0085+  15C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  15C2             ispath:
0087+  15C2 DB          	push al
0088+  15C3 07 88 15    	call _isdigit
0089+  15C6 C6 F0 15    	je ispath_true
0090+  15C9 B9 5F       	cmp al, '_'
0091+  15CB C6 F0 15    	je ispath_true
0092+  15CE B9 2F       	cmp al, '/'
0093+  15D0 C6 F0 15    	je ispath_true
0094+  15D3 B9 2E       	cmp al, '.'
0095+  15D5 C6 F0 15    	je ispath_true
0096+  15D8 B9 61       	cmp al, 'a'
0097+  15DA C8 EC 15    	jlu ispath_false
0098+  15DD B9 7A       	cmp al, 'z'
0099+  15DF D1 EC 15    	jgu ispath_false
0100+  15E2 B9 7A       	cmp al, 'z'
0101+  15E4 D0 F0 15    	jleu ispath_true
0102+  15E7 B9 61       	cmp al, 'a'
0103+  15E9 C9 F0 15    	jgeu ispath_true
0104+  15EC             ispath_false:
0105+  15EC 8B 01       	or al, 1	; clear zf
0106+  15EE E8          	pop al
0107+  15EF 09          	ret
0108+  15F0             ispath_true:
0109+  15F0 87 00       	and al, 0	; set zf
0110+  15F2 E8          	pop al
0111+  15F3 09          	ret
0112+  15F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  15F4             ;; is space
0114+  15F4             ;; sets zf according with result
0115+  15F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  15F4             _isspace:
0117+  15F4 B9 20       	cmp al, $20		; ' '
0118+  15F6 C6 0A 16    	je _isspace_exit
0119+  15F9 B9 09       	cmp al, $09		; '\t'
0120+  15FB C6 0A 16    	je _isspace_exit
0121+  15FE B9 0A       	cmp al, $0a		; '\n'
0122+  1600 C6 0A 16    	je _isspace_exit
0123+  1603 B9 0D       	cmp al, $0d		; '\r'
0124+  1605 C6 0A 16    	je _isspace_exit
0125+  1608 B9 0B       	cmp al, $0b		; '\v'
0126+  160A             _isspace_exit:
0127+  160A 09          	ret	
0128+  160B             
0129+  160B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  160B             ; to lower
0131+  160B             ; input in al
0132+  160B             ; output in al
0133+  160B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  160B             _to_lower:
0135+  160B B9 7A       	cmp al, 'z'
0136+  160D D1 12 16    	jgu _to_lower_ret
0137+  1610 6A 20       	add al, $20				; convert to lower case
0138+  1612             _to_lower_ret:
0139+  1612 09          	ret
0140+  1613             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1613             ; to upper
0142+  1613             ; input in al
0143+  1613             ; output in al
0144+  1613             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1613             _to_upper:
0146+  1613 B9 61       	cmp al, 'a'
0147+  1615 C8 1A 16    	jlu _to_upper_ret
0148+  1618 6F 20       	sub al, $20			; convert to upper case
0149+  161A             _to_upper_ret:
0150+  161A 09          	ret
0151+  161B             
3073   161B             .include "lib/token.asm"
0001+  161B             toktyp_identifier  .equ 0
0002+  161B             toktyp_keyword     .equ 1
0003+  161B             toktyp_delimiter   .equ 2
0004+  161B             toktyp_string      .equ 3
0005+  161B             toktyp_char        .equ 4
0006+  161B             toktyp_numeric     .equ 5
0007+  161B             toktyp_end         .equ 6
0008+  161B             
0009+  161B             tok_null           .equ 0
0010+  161B             tok_fslash         .equ 1
0011+  161B             tok_times          .equ 2
0012+  161B             tok_plus           .equ 3
0013+  161B             tok_minus          .equ 4
0014+  161B             tok_dot            .equ 5
0015+  161B             tok_semi           .equ 6
0016+  161B             tok_angle          .equ 7
0017+  161B             tok_tilde          .equ 8
0018+  161B             tok_equal          .equ 9
0019+  161B             tok_colon          .equ 10
0020+  161B             tok_comma          .equ 11
0021+  161B             
0022+  161B             tok_end            .equ 20
0023+  161B             
0024+  161B             
0025+  161B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  161B             ;; read a full command argment from shell input buffer
0027+  161B             ;; argument is written into tokstr
0028+  161B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  161B             get_arg:
0030+  161B D7            push a
0031+  161C E2            push si
0032+  161D E3            push di
0033+  161E 19 00         mov al, 0
0034+  1620 3D 49 18      mov [tokstr], al      ; nullify tokstr string
0035+  1623 14 45 18      mov a, [prog]
0036+  1626 4D            mov si, a
0037+  1627 FD 4F 49 18   mov di, tokstr
0038+  162B             get_arg_skip_spaces:
0039+  162B F6            lodsb
0040+  162C 07 F4 15      call _isspace
0041+  162F C6 2B 16      je get_arg_skip_spaces
0042+  1632             get_arg_l0:
0043+  1632 B9 3B         cmp al, $3b        ; check if is ';'
0044+  1634 C6 41 16      je get_arg_end
0045+  1637 B9 00         cmp al, 0
0046+  1639 C6 41 16      je get_arg_end      ; check if end of input
0047+  163C F7            stosb
0048+  163D F6            lodsb
0049+  163E 0A 32 16      jmp get_arg_l0
0050+  1641             get_arg_end:
0051+  1641 19 00         mov al, 0
0052+  1643 F7            stosb
0053+  1644 D5 01 00      sub si, 1
0054+  1647 4E            mov a, si
0055+  1648 42 45 18      mov [prog], a    ; update pointer
0056+  164B F0            pop di
0057+  164C EF            pop si
0058+  164D E4            pop a
0059+  164E 09            ret
0060+  164F             
0061+  164F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  164F             ;; read a path formation from shell input buffer
0063+  164F             ;; path is written into tokstr
0064+  164F             ;; /usr/bin
0065+  164F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  164F             get_path:
0067+  164F D7            push a
0068+  1650 E2            push si
0069+  1651 E3            push di
0070+  1652 19 00         mov al, 0
0071+  1654 3D 49 18      mov [tokstr], al      ; nullify tokstr string
0072+  1657 14 45 18      mov a, [prog]
0073+  165A 4D            mov si, a
0074+  165B FD 4F 49 18   mov di, tokstr
0075+  165F             get_path_skip_spaces:
0076+  165F F6            lodsb
0077+  1660 07 F4 15      call _isspace
0078+  1663 C6 5F 16      je get_path_skip_spaces
0079+  1666             get_path_is_pathchar:
0080+  1666 F7            stosb
0081+  1667 F6            lodsb
0082+  1668 07 7E 15      call _isalnum      ;check if is alphanumeric
0083+  166B C6 66 16      je get_path_is_pathchar
0084+  166E B9 2F         cmp al, '/'        ; check if is '/'
0085+  1670 C6 66 16      je get_path_is_pathchar
0086+  1673 19 00         mov al, 0
0087+  1675 F7            stosb
0088+  1676 D5 01 00      sub si, 1
0089+  1679 4E            mov a, si
0090+  167A 42 45 18      mov [prog], a    ; update pointer
0091+  167D             get_path_end:
0092+  167D F0            pop di
0093+  167E EF            pop si
0094+  167F E4            pop a
0095+  1680 09            ret
0096+  1681             
0097+  1681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1681             ;; read a line
0099+  1681             ;; line is written into tokstr
0100+  1681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1681             get_line:
0102+  1681 D7            push a
0103+  1682 E2            push si
0104+  1683 E3            push di
0105+  1684 19 00         mov al, 0
0106+  1686 3D 49 18      mov [tokstr], al      ; nullify tokstr string
0107+  1689 14 45 18      mov a, [prog]
0108+  168C 4D            mov si, a
0109+  168D FD 4F 49 18   mov di, tokstr
0110+  1691             get_line_l0:
0111+  1691 F6            lodsb
0112+  1692 B9 0A         cmp al, $0a    ; check for new line
0113+  1694 C6 9B 16      je get_line_exit
0114+  1697 F7            stosb
0115+  1698 0A 91 16      jmp get_line_l0
0116+  169B             get_line_exit:
0117+  169B 19 00         mov al, 0
0118+  169D F7            stosb
0119+  169E 4E            mov a, si
0120+  169F 42 45 18      mov [prog], a    ; update pointer
0121+  16A2 F0            pop di
0122+  16A3 EF            pop si
0123+  16A4 E4            pop a
0124+  16A5 09            ret
0125+  16A6             
0126+  16A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  16A6             ;; token parser
0128+  16A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  16A6             get_token:
0130+  16A6 D7            push a
0131+  16A7 DA            push d
0132+  16A8 E2            push si
0133+  16A9 E3            push di
0134+  16AA 19 00         mov al, 0
0135+  16AC 3D 49 18      mov [tokstr], al      ; nullify tokstr string
0136+  16AF 19 00         mov al, tok_null
0137+  16B1 3D 48 18      mov [tok], al        ; nullify token
0138+  16B4 14 45 18      mov a, [prog]
0139+  16B7 4D            mov si, a
0140+  16B8 FD 4F 49 18   mov di, tokstr
0141+  16BC             get_tok_skip_spaces:
0142+  16BC F6            lodsb
0143+  16BD 07 F4 15      call _isspace
0144+  16C0 C6 BC 16      je get_tok_skip_spaces
0145+  16C3 B9 00         cmp al, 0      ; check for end of input (null)
0146+  16C5 C6 AA 17      je get_token_end
0147+  16C8 B9 23         cmp al, '#'      ; comments!
0148+  16CA C6 D8 17      je get_tok_comment
0149+  16CD 07 7E 15      call _isalnum
0150+  16D0 C6 B7 17      jz is_alphanumeric
0151+  16D3             ; other token types
0152+  16D3             get_token_slash:
0153+  16D3 B9 2F         cmp al, '/'        ; check if '/'
0154+  16D5 C7 ED 16      jne get_token_minus
0155+  16D8 F7            stosb          ; store '/' into token string
0156+  16D9 19 00         mov al, 0
0157+  16DB F7            stosb          ; terminate token string
0158+  16DC 19 01         mov al, tok_fslash
0159+  16DE 3D 48 18      mov [tok], al      
0160+  16E1 19 02         mov al, toktyp_delimiter
0161+  16E3 3D 47 18      mov [toktyp], al
0162+  16E6 4E            mov a, si
0163+  16E7 42 45 18      mov [prog], a    ; update pointer
0164+  16EA 0A D3 17      jmp get_token_return
0165+  16ED             get_token_minus:
0166+  16ED B9 2D         cmp al, '-'        ; check if '-'
0167+  16EF C7 07 17      jne get_token_comma
0168+  16F2 F7            stosb          ; store '-' into token string
0169+  16F3 19 00         mov al, 0
0170+  16F5 F7            stosb          ; terminate token string
0171+  16F6 19 04         mov al, tok_minus
0172+  16F8 3D 48 18      mov [tok], al      
0173+  16FB 19 02         mov al, toktyp_delimiter
0174+  16FD 3D 47 18      mov [toktyp], al
0175+  1700 4E            mov a, si
0176+  1701 42 45 18      mov [prog], a    ; update pointer
0177+  1704 0A D3 17      jmp get_token_return
0178+  1707             get_token_comma:
0179+  1707 B9 2C         cmp al, ','        ; check if ','
0180+  1709 C7 21 17      jne get_token_semi
0181+  170C F7            stosb          ; store ',' into token string
0182+  170D 19 00         mov al, 0
0183+  170F F7            stosb          ; terminate token string
0184+  1710 19 0B         mov al, tok_comma
0185+  1712 3D 48 18      mov [tok], al      
0186+  1715 19 02         mov al, toktyp_delimiter
0187+  1717 3D 47 18      mov [toktyp], al
0188+  171A 4E            mov a, si
0189+  171B 42 45 18      mov [prog], a    ; update pointer
0190+  171E 0A D3 17      jmp get_token_return
0191+  1721             get_token_semi:
0192+  1721 B9 3B         cmp al, $3b        ; check if ';'
0193+  1723 C7 3B 17      jne get_token_colon
0194+  1726 F7            stosb          ; store ';' into token string
0195+  1727 19 00         mov al, 0
0196+  1729 F7            stosb          ; terminate token string
0197+  172A 19 06         mov al, tok_semi
0198+  172C 3D 48 18      mov [tok], al      
0199+  172F 19 02         mov al, toktyp_delimiter
0200+  1731 3D 47 18      mov [toktyp], al
0201+  1734 4E            mov a, si
0202+  1735 42 45 18      mov [prog], a    ; update pointer
0203+  1738 0A D3 17      jmp get_token_return
0204+  173B             get_token_colon:
0205+  173B B9 3A         cmp al, $3a        ; check if ':'
0206+  173D C7 55 17      jne get_token_angle
0207+  1740 F7            stosb          ; store ':' into token string
0208+  1741 19 00         mov al, 0
0209+  1743 F7            stosb          ; terminate token string
0210+  1744 19 0A         mov al, tok_colon
0211+  1746 3D 48 18      mov [tok], al      
0212+  1749 19 02         mov al, toktyp_delimiter
0213+  174B 3D 47 18      mov [toktyp], al
0214+  174E 4E            mov a, si
0215+  174F 42 45 18      mov [prog], a    ; update pointer
0216+  1752 0A D3 17      jmp get_token_return
0217+  1755             get_token_angle:
0218+  1755 B9 3E         cmp al, $3e        ; check if '>'
0219+  1757 C7 6F 17      jne get_token_tilde
0220+  175A F7            stosb          ; store '>' into token string
0221+  175B 19 00         mov al, 0
0222+  175D F7            stosb          ; terminate token string
0223+  175E 19 07         mov al, tok_angle
0224+  1760 3D 48 18      mov [tok], al      
0225+  1763 19 02         mov al, toktyp_delimiter
0226+  1765 3D 47 18      mov [toktyp], al
0227+  1768 4E            mov a, si
0228+  1769 42 45 18      mov [prog], a    ; update pointer
0229+  176C 0A D3 17      jmp get_token_return
0230+  176F             get_token_tilde:
0231+  176F B9 7E         cmp al, '~'        ; check if '~'
0232+  1771 C7 89 17      jne get_token_equal
0233+  1774 F7            stosb          ; store '~' into token string
0234+  1775 19 00         mov al, 0
0235+  1777 F7            stosb          ; terminate token string
0236+  1778 19 08         mov al, tok_tilde
0237+  177A 3D 48 18      mov [tok], al      
0238+  177D 19 02         mov al, toktyp_delimiter
0239+  177F 3D 47 18      mov [toktyp], al
0240+  1782 4E            mov a, si
0241+  1783 42 45 18      mov [prog], a    ; update pointer
0242+  1786 0A D3 17      jmp get_token_return
0243+  1789             get_token_equal:
0244+  1789 B9 3D         cmp al, '='        ; check if '='
0245+  178B C7 A3 17      jne get_token_skip
0246+  178E F7            stosb          ; store '=' into token string
0247+  178F 19 00         mov al, 0
0248+  1791 F7            stosb          ; terminate token string
0249+  1792 19 09         mov al, tok_equal
0250+  1794 3D 48 18      mov [tok], al      
0251+  1797 19 02         mov al, toktyp_delimiter
0252+  1799 3D 47 18      mov [toktyp], al
0253+  179C 4E            mov a, si
0254+  179D 42 45 18      mov [prog], a    ; update pointer
0255+  17A0 0A D3 17      jmp get_token_return
0256+  17A3             get_token_skip:
0257+  17A3 4E            mov a, si
0258+  17A4 42 45 18      mov [prog], a    ; update pointer
0259+  17A7 0A D3 17      jmp get_token_return
0260+  17AA             get_token_end:        ; end of file token
0261+  17AA 19 14         mov al, tok_end
0262+  17AC 3D 48 18      mov [tok], al
0263+  17AF 19 06         mov al, toktyp_end
0264+  17B1 3D 47 18      mov [toktyp], al
0265+  17B4 0A D3 17      jmp get_token_return
0266+  17B7             is_alphanumeric:
0267+  17B7 F7            stosb
0268+  17B8 F6            lodsb
0269+  17B9 07 7E 15      call _isalnum      ;check if is alphanumeric
0270+  17BC C6 B7 17      jz is_alphanumeric
0271+  17BF B9 2E         cmp al, $2e        ; check if is '.'
0272+  17C1 C6 B7 17      je is_alphanumeric
0273+  17C4 19 00         mov al, 0
0274+  17C6 F7            stosb
0275+  17C7 19 00         mov al, toktyp_identifier
0276+  17C9 3D 47 18      mov [toktyp], al
0277+  17CC D5 01 00      sub si, 1
0278+  17CF 4E            mov a, si
0279+  17D0 42 45 18      mov [prog], a    ; update pointer
0280+  17D3             get_token_return:
0281+  17D3 F0            pop di
0282+  17D4 EF            pop si
0283+  17D5 E7            pop d
0284+  17D6 E4            pop a
0285+  17D7 09            ret
0286+  17D8             get_tok_comment:
0287+  17D8 F6            lodsb
0288+  17D9 B9 0A         cmp al, $0a      ; new line
0289+  17DB C7 D8 17      jne get_tok_comment
0290+  17DE 0A BC 16      jmp get_tok_skip_spaces
0291+  17E1             
0292+  17E1             
0293+  17E1             get_number:
0294+  17E1 D7            push a
0295+  17E2 DA            push d
0296+  17E3 E2            push si
0297+  17E4 E3            push di
0298+  17E5 19 00         mov al, 0
0299+  17E7 3D 49 18      mov [tokstr], al      ; nullify tokstr string
0300+  17EA 19 00         mov al, tok_null
0301+  17EC 3D 48 18      mov [tok], al        ; nullify token
0302+  17EF 14 45 18      mov a, [prog]
0303+  17F2 4D            mov si, a
0304+  17F3 FD 4F 49 18   mov di, tokstr
0305+  17F7             get_number_skip_spaces:
0306+  17F7 F6            lodsb
0307+  17F8 07 F4 15      call _isspace
0308+  17FB C6 F7 17      je get_number_skip_spaces
0309+  17FE B9 00         cmp al, 0      ; check for end of input (null)
0310+  1800 C7 10 18      jne get_number_l0
0311+  1803 19 14         mov al, tok_end
0312+  1805 3D 48 18      mov [tok], al
0313+  1808 19 06         mov al, toktyp_end
0314+  180A 3D 47 18      mov [toktyp], al
0315+  180D 0A 27 18      jmp get_number_return
0316+  1810             get_number_l0:
0317+  1810 F7            stosb
0318+  1811 F6            lodsb
0319+  1812 07 88 15      call _isdigit      ;check if is numeric
0320+  1815 C6 10 18      jz get_number_l0
0321+  1818 19 00         mov al, 0
0322+  181A F7            stosb
0323+  181B 19 05         mov al, toktyp_numeric
0324+  181D 3D 47 18      mov [toktyp], al
0325+  1820 D5 01 00      sub si, 1
0326+  1823 4E            mov a, si
0327+  1824 42 45 18      mov [prog], a    ; update pointer
0328+  1827             get_number_return:
0329+  1827 F0            pop di
0330+  1828 EF            pop si
0331+  1829 E7            pop d
0332+  182A E4            pop a
0333+  182B 09            ret
0334+  182C             
0335+  182C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  182C             ;; put back token
0337+  182C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  182C             _putback:
0339+  182C D7            push a
0340+  182D E2            push si
0341+  182E FD 4D 49 18   mov si, tokstr  
0342+  1832             _putback_loop:
0343+  1832 F6            lodsb
0344+  1833 B9 00         cmp al, 0
0345+  1835 C6 42 18      je _putback_end
0346+  1838 14 45 18      mov a, [prog]
0347+  183B 7D            dec a
0348+  183C 42 45 18      mov [prog], a      ; update pointer
0349+  183F 0A 32 18      jmp _putback_loop
0350+  1842             _putback_end:
0351+  1842 EF            pop si
0352+  1843 E4            pop a
0353+  1844 09            ret
0354+  1845             
0355+  1845             
0356+  1845             
0357+  1845             
0358+  1845 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1847             
0360+  1847 00          toktyp:    .db 0          ; token type symbol
0361+  1848 00          tok:       .db 0          ; current token symbol
0362+  1849 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  184D 00 00 00 00 
0362+  1851 00 00 00 00 
0362+  1855 00 00 00 00 
0362+  1859 00 00 00 00 
0362+  185D 00 00 00 00 
0362+  1861 00 00 00 00 
0362+  1865 00 00 00 00 
0362+  1869 00 00 00 00 
0362+  186D 00 00 00 00 
0362+  1871 00 00 00 00 
0362+  1875 00 00 00 00 
0362+  1879 00 00 00 00 
0362+  187D 00 00 00 00 
0362+  1881 00 00 00 00 
0362+  1885 00 00 00 00 
0362+  1889 00 00 00 00 
0362+  188D 00 00 00 00 
0362+  1891 00 00 00 00 
0362+  1895 00 00 00 00 
0362+  1899 00 00 00 00 
0362+  189D 00 00 00 00 
0362+  18A1 00 00 00 00 
0362+  18A5 00 00 00 00 
0362+  18A9 00 00 00 00 
0362+  18AD 00 00 00 00 
0362+  18B1 00 00 00 00 
0362+  18B5 00 00 00 00 
0362+  18B9 00 00 00 00 
0362+  18BD 00 00 00 00 
0362+  18C1 00 00 00 00 
0362+  18C5 00 00 00 00 
0362+  18C9 00 00 00 00 
0362+  18CD 00 00 00 00 
0362+  18D1 00 00 00 00 
0362+  18D5 00 00 00 00 
0362+  18D9 00 00 00 00 
0362+  18DD 00 00 00 00 
0362+  18E1 00 00 00 00 
0362+  18E5 00 00 00 00 
0362+  18E9 00 00 00 00 
0362+  18ED 00 00 00 00 
0362+  18F1 00 00 00 00 
0362+  18F5 00 00 00 00 
0362+  18F9 00 00 00 00 
0362+  18FD 00 00 00 00 
0362+  1901 00 00 00 00 
0362+  1905 00 00 00 00 
0362+  1909 00 00 00 00 
0362+  190D 00 00 00 00 
0362+  1911 00 00 00 00 
0362+  1915 00 00 00 00 
0362+  1919 00 00 00 00 
0362+  191D 00 00 00 00 
0362+  1921 00 00 00 00 
0362+  1925 00 00 00 00 
0362+  1929 00 00 00 00 
0362+  192D 00 00 00 00 
0362+  1931 00 00 00 00 
0362+  1935 00 00 00 00 
0362+  1939 00 00 00 00 
0362+  193D 00 00 00 00 
0362+  1941 00 00 00 00 
0362+  1945 00 00 00 00 
3074   1949             
3075   1949             ; kernel parameters
3076   1949             sys_debug_mode:
3077   1949 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
3078   194A             sys_echo_on:
3079   194A 01            .db 1
3080   194B             sys_uart1_lcr:
3081   194B 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
3082   194C             sys_uart1_inten:
3083   194C 01            .db 1
3084   194D             sys_uart1_fifoen:
3085   194D 00            .db 0
3086   194E             sys_uart1_div0:
3087   194E 03            .db 3
3088   194F             sys_uart1_div1:
3089   194F 00            .db 0   ; default baud = 38400
3090   1950             ; baud  divisor
3091   1950             ; 50    2304
3092   1950             ; 110   1047
3093   1950             ; 300    384
3094   1950             ; 600    192
3095   1950             ; 1200    96
3096   1950             ; 9600    12
3097   1950             ; 19200    6
3098   1950             ; 38400    3
3099   1950             
3100   1950             nbr_active_procs:
3101   1950 00            .db 0
3102   1951             active_proc_index:
3103   1951 01            .db 1
3104   1952             
3105   1952             index:
3106   1952 00 00         .dw 0
3107   1954             buffer_addr:
3108   1954 00 00         .dw 0
3109   1956             
3110   1956             fifo_in:
3111   1956 8E 21         .dw fifo
3112   1958             fifo_out:
3113   1958 8E 21         .dw fifo
3114   195A             
3115   195A             ; file system variables
3116   195A             current_dir_id:
3117   195A 00 00         .dw 0     ; keep dirid of current directory
3118   195C             s_init_path:
3119   195C 2F 73 62 69   .db "/sbin/init", 0
3119   1960 6E 2F 69 6E 
3119   1964 69 74 00 
3120   1967             
3121   1967             s_uname:
3122   1967 73 6F 6C 61   .db "solarium v.1.0", 0
3122   196B 72 69 75 6D 
3122   196F 20 76 2E 31 
3122   1973 2E 30 00 
3123   1976             s_dataentry:
3124   1976 3E 20 00      .db "> ", 0
3125   1979             s_parent_dir:
3126   1979 2E 2E 00      .db "..", 0
3127   197C             s_current_dir:
3128   197C 2E 00         .db ".", 0
3129   197E             s_fslash:
3130   197E 2F 00         .db "/", 0
3131   1980             file_attrib:
3132   1980 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
3132   1984 78 
3133   1985             file_type:
3134   1985 2D 64 63      .db "-dc"
3135   1988             s_ps_header:
3136   1988 70 69 64 20   .db "pid command\n", 0
3136   198C 63 6F 6D 6D 
3136   1990 61 6E 64 0A 
3136   1994 00 
3137   1995             s_ls_total:
3138   1995 74 6F 74 61   .db "total: ", 0
3138   1999 6C 3A 20 00 
3139   199D             
3140   199D             s_int_en:
3141   199D 69 72 71 73   .db "irqs enabled\n", 0
3141   19A1 20 65 6E 61 
3141   19A5 62 6C 65 64 
3141   19A9 0A 00 
3142   19AB             s_kernel_welcome:
3143   19AB 2A 2A 2A 2A   .db "************************************************\n"
3143   19AF 2A 2A 2A 2A 
3143   19B3 2A 2A 2A 2A 
3143   19B7 2A 2A 2A 2A 
3143   19BB 2A 2A 2A 2A 
3143   19BF 2A 2A 2A 2A 
3143   19C3 2A 2A 2A 2A 
3143   19C7 2A 2A 2A 2A 
3143   19CB 2A 2A 2A 2A 
3143   19CF 2A 2A 2A 2A 
3143   19D3 2A 2A 2A 2A 
3143   19D7 2A 2A 2A 2A 
3143   19DB 0A 
3144   19DC 2A 2A 2A 20   .db "*** Welcome to Solarium OS - Kernel ver. 1.0 ***\n"
3144   19E0 57 65 6C 63 
3144   19E4 6F 6D 65 20 
3144   19E8 74 6F 20 53 
3144   19EC 6F 6C 61 72 
3144   19F0 69 75 6D 20 
3144   19F4 4F 53 20 2D 
3144   19F8 20 4B 65 72 
3144   19FC 6E 65 6C 20 
3144   1A00 76 65 72 2E 
3144   1A04 20 31 2E 30 
3144   1A08 20 2A 2A 2A 
3144   1A0C 0A 
3145   1A0D 2A 2A 2A 20   .db "***                                          ***\n"
3145   1A11 20 20 20 20 
3145   1A15 20 20 20 20 
3145   1A19 20 20 20 20 
3145   1A1D 20 20 20 20 
3145   1A21 20 20 20 20 
3145   1A25 20 20 20 20 
3145   1A29 20 20 20 20 
3145   1A2D 20 20 20 20 
3145   1A31 20 20 20 20 
3145   1A35 20 20 20 20 
3145   1A39 20 2A 2A 2A 
3145   1A3D 0A 
3146   1A3E 2A 2A 2A 20   .db "*** type help for more information           ***\n"
3146   1A42 74 79 70 65 
3146   1A46 20 68 65 6C 
3146   1A4A 70 20 66 6F 
3146   1A4E 72 20 6D 6F 
3146   1A52 72 65 20 69 
3146   1A56 6E 66 6F 72 
3146   1A5A 6D 61 74 69 
3146   1A5E 6F 6E 20 20 
3146   1A62 20 20 20 20 
3146   1A66 20 20 20 20 
3146   1A6A 20 2A 2A 2A 
3146   1A6E 0A 
3147   1A6F 2A 2A 2A 2A   .db "************************************************\n"
3147   1A73 2A 2A 2A 2A 
3147   1A77 2A 2A 2A 2A 
3147   1A7B 2A 2A 2A 2A 
3147   1A7F 2A 2A 2A 2A 
3147   1A83 2A 2A 2A 2A 
3147   1A87 2A 2A 2A 2A 
3147   1A8B 2A 2A 2A 2A 
3147   1A8F 2A 2A 2A 2A 
3147   1A93 2A 2A 2A 2A 
3147   1A97 2A 2A 2A 2A 
3147   1A9B 2A 2A 2A 2A 
3147   1A9F 0A 
3148   1AA0             s_prompt_init:
3149   1AA0 73 74 61 72   .db "starting init\n", 0
3149   1AA4 74 69 6E 67 
3149   1AA8 20 69 6E 69 
3149   1AAC 74 0A 00 
3150   1AAF             s_priviledge:
3151   1AAF 0A 65 78 63   .db "\nexception: privilege\n", 0
3151   1AB3 65 70 74 69 
3151   1AB7 6F 6E 3A 20 
3151   1ABB 70 72 69 76 
3151   1ABF 69 6C 65 67 
3151   1AC3 65 0A 00 
3152   1AC6             s_divzero:
3153   1AC6 0A 65 78 63   .db "\nexception: zero division\n", 0
3153   1ACA 65 70 74 69 
3153   1ACE 6F 6E 3A 20 
3153   1AD2 7A 65 72 6F 
3153   1AD6 20 64 69 76 
3153   1ADA 69 73 69 6F 
3153   1ADE 6E 0A 00 
3154   1AE1             
3155   1AE1             s_set_year:
3156   1AE1 79 65 61 72   .db "year: ", 0
3156   1AE5 3A 20 00 
3157   1AE8             s_set_month:
3158   1AE8 6D 6F 6E 74   .db "month: ", 0
3158   1AEC 68 3A 20 00 
3159   1AF0             s_set_day:
3160   1AF0 64 61 79 3A   .db "day: ", 0
3160   1AF4 20 00 
3161   1AF6             s_set_week:
3162   1AF6 77 65 65 6B   .db "weekday: ", 0
3162   1AFA 64 61 79 3A 
3162   1AFE 20 00 
3163   1B00             s_set_hours:
3164   1B00 68 6F 75 72   .db "hours: ", 0
3164   1B04 73 3A 20 00 
3165   1B08             s_set_minutes:
3166   1B08 6D 69 6E 75   .db "minutes: ", 0
3166   1B0C 74 65 73 3A 
3166   1B10 20 00 
3167   1B12             s_set_seconds:
3168   1B12 73 65 63 6F   .db "seconds: ", 0
3168   1B16 6E 64 73 3A 
3168   1B1A 20 00 
3169   1B1C             s_months:      
3170   1B1C 20 20 20 00   .db "   ", 0
3171   1B20 6A 61 6E 00   .db "jan", 0
3172   1B24 66 65 62 00   .db "feb", 0
3173   1B28 6D 61 72 00   .db "mar", 0
3174   1B2C 61 70 72 00   .db "apr", 0
3175   1B30 6D 61 79 00   .db "may", 0
3176   1B34 6A 75 6E 00   .db "jun", 0
3177   1B38 6A 75 6C 00   .db "jul", 0
3178   1B3C 61 75 67 00   .db "aug", 0
3179   1B40 73 65 70 00   .db "sep", 0
3180   1B44 6F 63 74 00   .db "oct", 0
3181   1B48 6E 6F 76 00   .db "nov", 0
3182   1B4C 64 65 63 00   .db "dec", 0
3183   1B50             
3184   1B50             s_week:        
3185   1B50 73 75 6E 00   .db "sun", 0 
3186   1B54 6D 6F 6E 00   .db "mon", 0 
3187   1B58 74 75 65 00   .db "tue", 0 
3188   1B5C 77 65 64 00   .db "wed", 0 
3189   1B60 74 68 75 00   .db "thu", 0 
3190   1B64 66 72 69 00   .db "fri", 0 
3191   1B68 73 61 74 00   .db "sat", 0
3192   1B6C             
3193   1B6C 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
3193   1B70 30 20 45 78 
3193   1B74 65 63 75 74 
3193   1B78 65 64 2E 0A 
3193   1B7C 00 
3194   1B7D             s_fdc_config:
3195   1B7D 73 65 6C 65   .db "selecting diskette drive 0, side 0, single density, head loaded\n", 0
3195   1B81 63 74 69 6E 
3195   1B85 67 20 64 69 
3195   1B89 73 6B 65 74 
3195   1B8D 74 65 20 64 
3195   1B91 72 69 76 65 
3195   1B95 20 30 2C 20 
3195   1B99 73 69 64 65 
3195   1B9D 20 30 2C 20 
3195   1BA1 73 69 6E 67 
3195   1BA5 6C 65 20 64 
3195   1BA9 65 6E 73 69 
3195   1BAD 74 79 2C 20 
3195   1BB1 68 65 61 64 
3195   1BB5 20 6C 6F 61 
3195   1BB9 64 65 64 0A 
3195   1BBD 00 
3196   1BBE             
3197   1BBE             proc_state_table:   
3198   1BBE 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
3198   1BC2 00 00 00 00 
3198   1BC6 00 00 00 00 
3198   1BCA 00 00 00 00 
3198   1BCE 00 00 00 00 
3198   1BD2 00 00 00 00 
3198   1BD6 00 00 00 00 
3198   1BDA 00 00 00 00 
3198   1BDE 00 00 00 00 
3198   1BE2 00 00 00 00 
3198   1BE6 00 00 00 00 
3198   1BEA 00 00 00 00 
3198   1BEE 00 00 00 00 
3198   1BF2 00 00 00 00 
3198   1BF6 00 00 00 00 
3198   1BFA 00 00 00 00 
3198   1BFE 00 00 00 00 
3198   1C02 00 00 00 00 
3198   1C06 00 00 00 00 
3198   1C0A 00 00 00 00 
3198   1C0E 00 00 00 00 
3198   1C12 00 00 00 00 
3198   1C16 00 00 00 00 
3198   1C1A 00 00 00 00 
3198   1C1E 00 00 00 00 
3198   1C22 00 00 00 00 
3198   1C26 00 00 00 00 
3198   1C2A 00 00 00 00 
3198   1C2E 00 00 00 00 
3198   1C32 00 00 00 00 
3198   1C36 00 00 00 00 
3198   1C3A 00 00 00 00 
3198   1C3E 00 00 00 00 
3198   1C42 00 00 00 00 
3198   1C46 00 00 00 00 
3198   1C4A 00 00 00 00 
3198   1C4E 00 00 00 00 
3198   1C52 00 00 00 00 
3198   1C56 00 00 00 00 
3198   1C5A 00 00 00 00 
3198   1C5E 00 00 00 00 
3198   1C62 00 00 00 00 
3198   1C66 00 00 00 00 
3198   1C6A 00 00 00 00 
3198   1C6E 00 00 00 00 
3198   1C72 00 00 00 00 
3198   1C76 00 00 00 00 
3198   1C7A 00 00 00 00 
3198   1C7E 00 00 00 00 
3198   1C82 00 00 00 00 
3198   1C86 00 00 00 00 
3198   1C8A 00 00 00 00 
3198   1C8E 00 00 00 00 
3198   1C92 00 00 00 00 
3198   1C96 00 00 00 00 
3198   1C9A 00 00 00 00 
3198   1C9E 00 00 00 00 
3198   1CA2 00 00 00 00 
3198   1CA6 00 00 00 00 
3198   1CAA 00 00 00 00 
3198   1CAE 00 00 00 00 
3198   1CB2 00 00 00 00 
3198   1CB6 00 00 00 00 
3198   1CBA 00 00 00 00 
3198   1CBE 00 00 00 00 
3198   1CC2 00 00 00 00 
3198   1CC6 00 00 00 00 
3198   1CCA 00 00 00 00 
3198   1CCE 00 00 00 00 
3198   1CD2 00 00 00 00 
3198   1CD6 00 00 00 00 
3198   1CDA 00 00 00 00 
3198   1CDE 00 00 00 00 
3198   1CE2 00 00 00 00 
3198   1CE6 00 00 00 00 
3198   1CEA 00 00 00 00 
3198   1CEE 00 00 00 00 
3198   1CF2 00 00 00 00 
3198   1CF6 00 00 00 00 
3198   1CFA 00 00 00 00 
3199   1CFE             proc_availab_table: 
3200   1CFE 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
3200   1D02 00 00 00 00 
3200   1D06 00 00 00 00 
3200   1D0A 00 00 00 00 
3201   1D0E             proc_names:
3202   1D0E 00 00 00 00   .fill 16 * 32, 0  ; process names
3202   1D12 00 00 00 00 
3202   1D16 00 00 00 00 
3202   1D1A 00 00 00 00 
3202   1D1E 00 00 00 00 
3202   1D22 00 00 00 00 
3202   1D26 00 00 00 00 
3202   1D2A 00 00 00 00 
3202   1D2E 00 00 00 00 
3202   1D32 00 00 00 00 
3202   1D36 00 00 00 00 
3202   1D3A 00 00 00 00 
3202   1D3E 00 00 00 00 
3202   1D42 00 00 00 00 
3202   1D46 00 00 00 00 
3202   1D4A 00 00 00 00 
3202   1D4E 00 00 00 00 
3202   1D52 00 00 00 00 
3202   1D56 00 00 00 00 
3202   1D5A 00 00 00 00 
3202   1D5E 00 00 00 00 
3202   1D62 00 00 00 00 
3202   1D66 00 00 00 00 
3202   1D6A 00 00 00 00 
3202   1D6E 00 00 00 00 
3202   1D72 00 00 00 00 
3202   1D76 00 00 00 00 
3202   1D7A 00 00 00 00 
3202   1D7E 00 00 00 00 
3202   1D82 00 00 00 00 
3202   1D86 00 00 00 00 
3202   1D8A 00 00 00 00 
3202   1D8E 00 00 00 00 
3202   1D92 00 00 00 00 
3202   1D96 00 00 00 00 
3202   1D9A 00 00 00 00 
3202   1D9E 00 00 00 00 
3202   1DA2 00 00 00 00 
3202   1DA6 00 00 00 00 
3202   1DAA 00 00 00 00 
3202   1DAE 00 00 00 00 
3202   1DB2 00 00 00 00 
3202   1DB6 00 00 00 00 
3202   1DBA 00 00 00 00 
3202   1DBE 00 00 00 00 
3202   1DC2 00 00 00 00 
3202   1DC6 00 00 00 00 
3202   1DCA 00 00 00 00 
3202   1DCE 00 00 00 00 
3202   1DD2 00 00 00 00 
3202   1DD6 00 00 00 00 
3202   1DDA 00 00 00 00 
3202   1DDE 00 00 00 00 
3202   1DE2 00 00 00 00 
3202   1DE6 00 00 00 00 
3202   1DEA 00 00 00 00 
3202   1DEE 00 00 00 00 
3202   1DF2 00 00 00 00 
3202   1DF6 00 00 00 00 
3202   1DFA 00 00 00 00 
3202   1DFE 00 00 00 00 
3202   1E02 00 00 00 00 
3202   1E06 00 00 00 00 
3202   1E0A 00 00 00 00 
3202   1E0E 00 00 00 00 
3202   1E12 00 00 00 00 
3202   1E16 00 00 00 00 
3202   1E1A 00 00 00 00 
3202   1E1E 00 00 00 00 
3202   1E22 00 00 00 00 
3202   1E26 00 00 00 00 
3202   1E2A 00 00 00 00 
3202   1E2E 00 00 00 00 
3202   1E32 00 00 00 00 
3202   1E36 00 00 00 00 
3202   1E3A 00 00 00 00 
3202   1E3E 00 00 00 00 
3202   1E42 00 00 00 00 
3202   1E46 00 00 00 00 
3202   1E4A 00 00 00 00 
3202   1E4E 00 00 00 00 
3202   1E52 00 00 00 00 
3202   1E56 00 00 00 00 
3202   1E5A 00 00 00 00 
3202   1E5E 00 00 00 00 
3202   1E62 00 00 00 00 
3202   1E66 00 00 00 00 
3202   1E6A 00 00 00 00 
3202   1E6E 00 00 00 00 
3202   1E72 00 00 00 00 
3202   1E76 00 00 00 00 
3202   1E7A 00 00 00 00 
3202   1E7E 00 00 00 00 
3202   1E82 00 00 00 00 
3202   1E86 00 00 00 00 
3202   1E8A 00 00 00 00 
3202   1E8E 00 00 00 00 
3202   1E92 00 00 00 00 
3202   1E96 00 00 00 00 
3202   1E9A 00 00 00 00 
3202   1E9E 00 00 00 00 
3202   1EA2 00 00 00 00 
3202   1EA6 00 00 00 00 
3202   1EAA 00 00 00 00 
3202   1EAE 00 00 00 00 
3202   1EB2 00 00 00 00 
3202   1EB6 00 00 00 00 
3202   1EBA 00 00 00 00 
3202   1EBE 00 00 00 00 
3202   1EC2 00 00 00 00 
3202   1EC6 00 00 00 00 
3202   1ECA 00 00 00 00 
3202   1ECE 00 00 00 00 
3202   1ED2 00 00 00 00 
3202   1ED6 00 00 00 00 
3202   1EDA 00 00 00 00 
3202   1EDE 00 00 00 00 
3202   1EE2 00 00 00 00 
3202   1EE6 00 00 00 00 
3202   1EEA 00 00 00 00 
3202   1EEE 00 00 00 00 
3202   1EF2 00 00 00 00 
3202   1EF6 00 00 00 00 
3202   1EFA 00 00 00 00 
3202   1EFE 00 00 00 00 
3202   1F02 00 00 00 00 
3202   1F06 00 00 00 00 
3202   1F0A 00 00 00 00 
3203   1F0E             filename:
3204   1F0E 00 00 00 00   .fill 128, 0      ; holds a path for file search
3204   1F12 00 00 00 00 
3204   1F16 00 00 00 00 
3204   1F1A 00 00 00 00 
3204   1F1E 00 00 00 00 
3204   1F22 00 00 00 00 
3204   1F26 00 00 00 00 
3204   1F2A 00 00 00 00 
3204   1F2E 00 00 00 00 
3204   1F32 00 00 00 00 
3204   1F36 00 00 00 00 
3204   1F3A 00 00 00 00 
3204   1F3E 00 00 00 00 
3204   1F42 00 00 00 00 
3204   1F46 00 00 00 00 
3204   1F4A 00 00 00 00 
3204   1F4E 00 00 00 00 
3204   1F52 00 00 00 00 
3204   1F56 00 00 00 00 
3204   1F5A 00 00 00 00 
3204   1F5E 00 00 00 00 
3204   1F62 00 00 00 00 
3204   1F66 00 00 00 00 
3204   1F6A 00 00 00 00 
3204   1F6E 00 00 00 00 
3204   1F72 00 00 00 00 
3204   1F76 00 00 00 00 
3204   1F7A 00 00 00 00 
3204   1F7E 00 00 00 00 
3204   1F82 00 00 00 00 
3204   1F86 00 00 00 00 
3204   1F8A 00 00 00 00 
3205   1F8E             user_data:
3206   1F8E 00 00 00 00   .fill 512, 0      ;  user space data
3206   1F92 00 00 00 00 
3206   1F96 00 00 00 00 
3206   1F9A 00 00 00 00 
3206   1F9E 00 00 00 00 
3206   1FA2 00 00 00 00 
3206   1FA6 00 00 00 00 
3206   1FAA 00 00 00 00 
3206   1FAE 00 00 00 00 
3206   1FB2 00 00 00 00 
3206   1FB6 00 00 00 00 
3206   1FBA 00 00 00 00 
3206   1FBE 00 00 00 00 
3206   1FC2 00 00 00 00 
3206   1FC6 00 00 00 00 
3206   1FCA 00 00 00 00 
3206   1FCE 00 00 00 00 
3206   1FD2 00 00 00 00 
3206   1FD6 00 00 00 00 
3206   1FDA 00 00 00 00 
3206   1FDE 00 00 00 00 
3206   1FE2 00 00 00 00 
3206   1FE6 00 00 00 00 
3206   1FEA 00 00 00 00 
3206   1FEE 00 00 00 00 
3206   1FF2 00 00 00 00 
3206   1FF6 00 00 00 00 
3206   1FFA 00 00 00 00 
3206   1FFE 00 00 00 00 
3206   2002 00 00 00 00 
3206   2006 00 00 00 00 
3206   200A 00 00 00 00 
3206   200E 00 00 00 00 
3206   2012 00 00 00 00 
3206   2016 00 00 00 00 
3206   201A 00 00 00 00 
3206   201E 00 00 00 00 
3206   2022 00 00 00 00 
3206   2026 00 00 00 00 
3206   202A 00 00 00 00 
3206   202E 00 00 00 00 
3206   2032 00 00 00 00 
3206   2036 00 00 00 00 
3206   203A 00 00 00 00 
3206   203E 00 00 00 00 
3206   2042 00 00 00 00 
3206   2046 00 00 00 00 
3206   204A 00 00 00 00 
3206   204E 00 00 00 00 
3206   2052 00 00 00 00 
3206   2056 00 00 00 00 
3206   205A 00 00 00 00 
3206   205E 00 00 00 00 
3206   2062 00 00 00 00 
3206   2066 00 00 00 00 
3206   206A 00 00 00 00 
3206   206E 00 00 00 00 
3206   2072 00 00 00 00 
3206   2076 00 00 00 00 
3206   207A 00 00 00 00 
3206   207E 00 00 00 00 
3206   2082 00 00 00 00 
3206   2086 00 00 00 00 
3206   208A 00 00 00 00 
3206   208E 00 00 00 00 
3206   2092 00 00 00 00 
3206   2096 00 00 00 00 
3206   209A 00 00 00 00 
3206   209E 00 00 00 00 
3206   20A2 00 00 00 00 
3206   20A6 00 00 00 00 
3206   20AA 00 00 00 00 
3206   20AE 00 00 00 00 
3206   20B2 00 00 00 00 
3206   20B6 00 00 00 00 
3206   20BA 00 00 00 00 
3206   20BE 00 00 00 00 
3206   20C2 00 00 00 00 
3206   20C6 00 00 00 00 
3206   20CA 00 00 00 00 
3206   20CE 00 00 00 00 
3206   20D2 00 00 00 00 
3206   20D6 00 00 00 00 
3206   20DA 00 00 00 00 
3206   20DE 00 00 00 00 
3206   20E2 00 00 00 00 
3206   20E6 00 00 00 00 
3206   20EA 00 00 00 00 
3206   20EE 00 00 00 00 
3206   20F2 00 00 00 00 
3206   20F6 00 00 00 00 
3206   20FA 00 00 00 00 
3206   20FE 00 00 00 00 
3206   2102 00 00 00 00 
3206   2106 00 00 00 00 
3206   210A 00 00 00 00 
3206   210E 00 00 00 00 
3206   2112 00 00 00 00 
3206   2116 00 00 00 00 
3206   211A 00 00 00 00 
3206   211E 00 00 00 00 
3206   2122 00 00 00 00 
3206   2126 00 00 00 00 
3206   212A 00 00 00 00 
3206   212E 00 00 00 00 
3206   2132 00 00 00 00 
3206   2136 00 00 00 00 
3206   213A 00 00 00 00 
3206   213E 00 00 00 00 
3206   2142 00 00 00 00 
3206   2146 00 00 00 00 
3206   214A 00 00 00 00 
3206   214E 00 00 00 00 
3206   2152 00 00 00 00 
3206   2156 00 00 00 00 
3206   215A 00 00 00 00 
3206   215E 00 00 00 00 
3206   2162 00 00 00 00 
3206   2166 00 00 00 00 
3206   216A 00 00 00 00 
3206   216E 00 00 00 00 
3206   2172 00 00 00 00 
3206   2176 00 00 00 00 
3206   217A 00 00 00 00 
3206   217E 00 00 00 00 
3206   2182 00 00 00 00 
3206   2186 00 00 00 00 
3206   218A 00 00 00 00 
3207   218E             fifo:
3208   218E FF FF FF FF   .fill _fifo_size
3208   2192 FF FF FF FF 
3208   2196 FF FF FF FF 
3208   219A FF FF FF FF 
3208   219E FF FF FF FF 
3208   21A2 FF FF FF FF 
3208   21A6 FF FF FF FF 
3208   21AA FF FF FF FF 
3208   21AE FF FF FF FF 
3208   21B2 FF FF FF FF 
3208   21B6 FF FF FF FF 
3208   21BA FF FF FF FF 
3208   21BE FF FF FF FF 
3208   21C2 FF FF FF FF 
3208   21C6 FF FF FF FF 
3208   21CA FF FF FF FF 
3208   21CE FF FF FF FF 
3208   21D2 FF FF FF FF 
3208   21D6 FF FF FF FF 
3208   21DA FF FF FF FF 
3208   21DE FF FF FF FF 
3208   21E2 FF FF FF FF 
3208   21E6 FF FF FF FF 
3208   21EA FF FF FF FF 
3208   21EE FF FF FF FF 
3208   21F2 FF FF FF FF 
3208   21F6 FF FF FF FF 
3208   21FA FF FF FF FF 
3208   21FE FF FF FF FF 
3208   2202 FF FF FF FF 
3208   2206 FF FF FF FF 
3208   220A FF FF FF FF 
3208   220E FF FF FF FF 
3208   2212 FF FF FF FF 
3208   2216 FF FF FF FF 
3208   221A FF FF FF FF 
3208   221E FF FF FF FF 
3208   2222 FF FF FF FF 
3208   2226 FF FF FF FF 
3208   222A FF FF FF FF 
3208   222E FF FF FF FF 
3208   2232 FF FF FF FF 
3208   2236 FF FF FF FF 
3208   223A FF FF FF FF 
3208   223E FF FF FF FF 
3208   2242 FF FF FF FF 
3208   2246 FF FF FF FF 
3208   224A FF FF FF FF 
3208   224E FF FF FF FF 
3208   2252 FF FF FF FF 
3208   2256 FF FF FF FF 
3208   225A FF FF FF FF 
3208   225E FF FF FF FF 
3208   2262 FF FF FF FF 
3208   2266 FF FF FF FF 
3208   226A FF FF FF FF 
3208   226E FF FF FF FF 
3208   2272 FF FF FF FF 
3208   2276 FF FF FF FF 
3208   227A FF FF FF FF 
3208   227E FF FF FF FF 
3208   2282 FF FF FF FF 
3208   2286 FF FF FF FF 
3208   228A FF FF FF FF 
3208   228E FF FF FF FF 
3208   2292 FF FF FF FF 
3208   2296 FF FF FF FF 
3208   229A FF FF FF FF 
3208   229E FF FF FF FF 
3208   22A2 FF FF FF FF 
3208   22A6 FF FF FF FF 
3208   22AA FF FF FF FF 
3208   22AE FF FF FF FF 
3208   22B2 FF FF FF FF 
3208   22B6 FF FF FF FF 
3208   22BA FF FF FF FF 
3208   22BE FF FF FF FF 
3208   22C2 FF FF FF FF 
3208   22C6 FF FF FF FF 
3208   22CA FF FF FF FF 
3208   22CE FF FF FF FF 
3208   22D2 FF FF FF FF 
3208   22D6 FF FF FF FF 
3208   22DA FF FF FF FF 
3208   22DE FF FF FF FF 
3208   22E2 FF FF FF FF 
3208   22E6 FF FF FF FF 
3208   22EA FF FF FF FF 
3208   22EE FF FF FF FF 
3208   22F2 FF FF FF FF 
3208   22F6 FF FF FF FF 
3208   22FA FF FF FF FF 
3208   22FE FF FF FF FF 
3208   2302 FF FF FF FF 
3208   2306 FF FF FF FF 
3208   230A FF FF FF FF 
3208   230E FF FF FF FF 
3208   2312 FF FF FF FF 
3208   2316 FF FF FF FF 
3208   231A FF FF FF FF 
3208   231E FF FF FF FF 
3208   2322 FF FF FF FF 
3208   2326 FF FF FF FF 
3208   232A FF FF FF FF 
3208   232E FF FF FF FF 
3208   2332 FF FF FF FF 
3208   2336 FF FF FF FF 
3208   233A FF FF FF FF 
3208   233E FF FF FF FF 
3208   2342 FF FF FF FF 
3208   2346 FF FF FF FF 
3208   234A FF FF FF FF 
3208   234E FF FF FF FF 
3208   2352 FF FF FF FF 
3208   2356 FF FF FF FF 
3208   235A FF FF FF FF 
3208   235E FF FF FF FF 
3208   2362 FF FF FF FF 
3208   2366 FF FF FF FF 
3208   236A FF FF FF FF 
3208   236E FF FF FF FF 
3208   2372 FF FF FF FF 
3208   2376 FF FF FF FF 
3208   237A FF FF FF FF 
3208   237E FF FF FF FF 
3208   2382 FF FF FF FF 
3208   2386 FF FF FF FF 
3208   238A FF FF FF FF 
3208   238E FF FF FF FF 
3208   2392 FF FF FF FF 
3208   2396 FF FF FF FF 
3208   239A FF FF FF FF 
3208   239E FF FF FF FF 
3208   23A2 FF FF FF FF 
3208   23A6 FF FF FF FF 
3208   23AA FF FF FF FF 
3208   23AE FF FF FF FF 
3208   23B2 FF FF FF FF 
3208   23B6 FF FF FF FF 
3208   23BA FF FF FF FF 
3208   23BE FF FF FF FF 
3208   23C2 FF FF FF FF 
3208   23C6 FF FF FF FF 
3208   23CA FF FF FF FF 
3208   23CE FF FF FF FF 
3208   23D2 FF FF FF FF 
3208   23D6 FF FF FF FF 
3208   23DA FF FF FF FF 
3208   23DE FF FF FF FF 
3208   23E2 FF FF FF FF 
3208   23E6 FF FF FF FF 
3208   23EA FF FF FF FF 
3208   23EE FF FF FF FF 
3208   23F2 FF FF FF FF 
3208   23F6 FF FF FF FF 
3208   23FA FF FF FF FF 
3208   23FE FF FF FF FF 
3208   2402 FF FF FF FF 
3208   2406 FF FF FF FF 
3208   240A FF FF FF FF 
3208   240E FF FF FF FF 
3208   2412 FF FF FF FF 
3208   2416 FF FF FF FF 
3208   241A FF FF FF FF 
3208   241E FF FF FF FF 
3208   2422 FF FF FF FF 
3208   2426 FF FF FF FF 
3208   242A FF FF FF FF 
3208   242E FF FF FF FF 
3208   2432 FF FF FF FF 
3208   2436 FF FF FF FF 
3208   243A FF FF FF FF 
3208   243E FF FF FF FF 
3208   2442 FF FF FF FF 
3208   2446 FF FF FF FF 
3208   244A FF FF FF FF 
3208   244E FF FF FF FF 
3208   2452 FF FF FF FF 
3208   2456 FF FF FF FF 
3208   245A FF FF FF FF 
3208   245E FF FF FF FF 
3208   2462 FF FF FF FF 
3208   2466 FF FF FF FF 
3208   246A FF FF FF FF 
3208   246E FF FF FF FF 
3208   2472 FF FF FF FF 
3208   2476 FF FF FF FF 
3208   247A FF FF FF FF 
3208   247E FF FF FF FF 
3208   2482 FF FF FF FF 
3208   2486 FF FF FF FF 
3208   248A FF FF FF FF 
3208   248E FF FF FF FF 
3208   2492 FF FF FF FF 
3208   2496 FF FF FF FF 
3208   249A FF FF FF FF 
3208   249E FF FF FF FF 
3208   24A2 FF FF FF FF 
3208   24A6 FF FF FF FF 
3208   24AA FF FF FF FF 
3208   24AE FF FF FF FF 
3208   24B2 FF FF FF FF 
3208   24B6 FF FF FF FF 
3208   24BA FF FF FF FF 
3208   24BE FF FF FF FF 
3208   24C2 FF FF FF FF 
3208   24C6 FF FF FF FF 
3208   24CA FF FF FF FF 
3208   24CE FF FF FF FF 
3208   24D2 FF FF FF FF 
3208   24D6 FF FF FF FF 
3208   24DA FF FF FF FF 
3208   24DE FF FF FF FF 
3208   24E2 FF FF FF FF 
3208   24E6 FF FF FF FF 
3208   24EA FF FF FF FF 
3208   24EE FF FF FF FF 
3208   24F2 FF FF FF FF 
3208   24F6 FF FF FF FF 
3208   24FA FF FF FF FF 
3208   24FE FF FF FF FF 
3208   2502 FF FF FF FF 
3208   2506 FF FF FF FF 
3208   250A FF FF FF FF 
3208   250E FF FF FF FF 
3208   2512 FF FF FF FF 
3208   2516 FF FF FF FF 
3208   251A FF FF FF FF 
3208   251E FF FF FF FF 
3208   2522 FF FF FF FF 
3208   2526 FF FF FF FF 
3208   252A FF FF FF FF 
3208   252E FF FF FF FF 
3208   2532 FF FF FF FF 
3208   2536 FF FF FF FF 
3208   253A FF FF FF FF 
3208   253E FF FF FF FF 
3208   2542 FF FF FF FF 
3208   2546 FF FF FF FF 
3208   254A FF FF FF FF 
3208   254E FF FF FF FF 
3208   2552 FF FF FF FF 
3208   2556 FF FF FF FF 
3208   255A FF FF FF FF 
3208   255E FF FF FF FF 
3208   2562 FF FF FF FF 
3208   2566 FF FF FF FF 
3208   256A FF FF FF FF 
3208   256E FF FF FF FF 
3208   2572 FF FF FF FF 
3208   2576 FF FF FF FF 
3208   257A FF FF FF FF 
3208   257E FF FF FF FF 
3208   2582 FF FF FF FF 
3208   2586 FF FF FF FF 
3208   258A FF FF FF FF 
3208   258E FF FF FF FF 
3208   2592 FF FF FF FF 
3208   2596 FF FF FF FF 
3208   259A FF FF FF FF 
3208   259E FF FF FF FF 
3208   25A2 FF FF FF FF 
3208   25A6 FF FF FF FF 
3208   25AA FF FF FF FF 
3208   25AE FF FF FF FF 
3208   25B2 FF FF FF FF 
3208   25B6 FF FF FF FF 
3208   25BA FF FF FF FF 
3208   25BE FF FF FF FF 
3208   25C2 FF FF FF FF 
3208   25C6 FF FF FF FF 
3208   25CA FF FF FF FF 
3208   25CE FF FF FF FF 
3208   25D2 FF FF FF FF 
3208   25D6 FF FF FF FF 
3208   25DA FF FF FF FF 
3208   25DE FF FF FF FF 
3208   25E2 FF FF FF FF 
3208   25E6 FF FF FF FF 
3208   25EA FF FF FF FF 
3208   25EE FF FF FF FF 
3208   25F2 FF FF FF FF 
3208   25F6 FF FF FF FF 
3208   25FA FF FF FF FF 
3208   25FE FF FF FF FF 
3208   2602 FF FF FF FF 
3208   2606 FF FF FF FF 
3208   260A FF FF FF FF 
3208   260E FF FF FF FF 
3208   2612 FF FF FF FF 
3208   2616 FF FF FF FF 
3208   261A FF FF FF FF 
3208   261E FF FF FF FF 
3208   2622 FF FF FF FF 
3208   2626 FF FF FF FF 
3208   262A FF FF FF FF 
3208   262E FF FF FF FF 
3208   2632 FF FF FF FF 
3208   2636 FF FF FF FF 
3208   263A FF FF FF FF 
3208   263E FF FF FF FF 
3208   2642 FF FF FF FF 
3208   2646 FF FF FF FF 
3208   264A FF FF FF FF 
3208   264E FF FF FF FF 
3208   2652 FF FF FF FF 
3208   2656 FF FF FF FF 
3208   265A FF FF FF FF 
3208   265E FF FF FF FF 
3208   2662 FF FF FF FF 
3208   2666 FF FF FF FF 
3208   266A FF FF FF FF 
3208   266E FF FF FF FF 
3208   2672 FF FF FF FF 
3208   2676 FF FF FF FF 
3208   267A FF FF FF FF 
3208   267E FF FF FF FF 
3208   2682 FF FF FF FF 
3208   2686 FF FF FF FF 
3208   268A FF FF FF FF 
3208   268E FF FF FF FF 
3208   2692 FF FF FF FF 
3208   2696 FF FF FF FF 
3208   269A FF FF FF FF 
3208   269E FF FF FF FF 
3208   26A2 FF FF FF FF 
3208   26A6 FF FF FF FF 
3208   26AA FF FF FF FF 
3208   26AE FF FF FF FF 
3208   26B2 FF FF FF FF 
3208   26B6 FF FF FF FF 
3208   26BA FF FF FF FF 
3208   26BE FF FF FF FF 
3208   26C2 FF FF FF FF 
3208   26C6 FF FF FF FF 
3208   26CA FF FF FF FF 
3208   26CE FF FF FF FF 
3208   26D2 FF FF FF FF 
3208   26D6 FF FF FF FF 
3208   26DA FF FF FF FF 
3208   26DE FF FF FF FF 
3208   26E2 FF FF FF FF 
3208   26E6 FF FF FF FF 
3208   26EA FF FF FF FF 
3208   26EE FF FF FF FF 
3208   26F2 FF FF FF FF 
3208   26F6 FF FF FF FF 
3208   26FA FF FF FF FF 
3208   26FE FF FF FF FF 
3208   2702 FF FF FF FF 
3208   2706 FF FF FF FF 
3208   270A FF FF FF FF 
3208   270E FF FF FF FF 
3208   2712 FF FF FF FF 
3208   2716 FF FF FF FF 
3208   271A FF FF FF FF 
3208   271E FF FF FF FF 
3208   2722 FF FF FF FF 
3208   2726 FF FF FF FF 
3208   272A FF FF FF FF 
3208   272E FF FF FF FF 
3208   2732 FF FF FF FF 
3208   2736 FF FF FF FF 
3208   273A FF FF FF FF 
3208   273E FF FF FF FF 
3208   2742 FF FF FF FF 
3208   2746 FF FF FF FF 
3208   274A FF FF FF FF 
3208   274E FF FF FF FF 
3208   2752 FF FF FF FF 
3208   2756 FF FF FF FF 
3208   275A FF FF FF FF 
3208   275E FF FF FF FF 
3208   2762 FF FF FF FF 
3208   2766 FF FF FF FF 
3208   276A FF FF FF FF 
3208   276E FF FF FF FF 
3208   2772 FF FF FF FF 
3208   2776 FF FF FF FF 
3208   277A FF FF FF FF 
3208   277E FF FF FF FF 
3208   2782 FF FF FF FF 
3208   2786 FF FF FF FF 
3208   278A FF FF FF FF 
3208   278E FF FF FF FF 
3208   2792 FF FF FF FF 
3208   2796 FF FF FF FF 
3208   279A FF FF FF FF 
3208   279E FF FF FF FF 
3208   27A2 FF FF FF FF 
3208   27A6 FF FF FF FF 
3208   27AA FF FF FF FF 
3208   27AE FF FF FF FF 
3208   27B2 FF FF FF FF 
3208   27B6 FF FF FF FF 
3208   27BA FF FF FF FF 
3208   27BE FF FF FF FF 
3208   27C2 FF FF FF FF 
3208   27C6 FF FF FF FF 
3208   27CA FF FF FF FF 
3208   27CE FF FF FF FF 
3208   27D2 FF FF FF FF 
3208   27D6 FF FF FF FF 
3208   27DA FF FF FF FF 
3208   27DE FF FF FF FF 
3208   27E2 FF FF FF FF 
3208   27E6 FF FF FF FF 
3208   27EA FF FF FF FF 
3208   27EE FF FF FF FF 
3208   27F2 FF FF FF FF 
3208   27F6 FF FF FF FF 
3208   27FA FF FF FF FF 
3208   27FE FF FF FF FF 
3208   2802 FF FF FF FF 
3208   2806 FF FF FF FF 
3208   280A FF FF FF FF 
3208   280E FF FF FF FF 
3208   2812 FF FF FF FF 
3208   2816 FF FF FF FF 
3208   281A FF FF FF FF 
3208   281E FF FF FF FF 
3208   2822 FF FF FF FF 
3208   2826 FF FF FF FF 
3208   282A FF FF FF FF 
3208   282E FF FF FF FF 
3208   2832 FF FF FF FF 
3208   2836 FF FF FF FF 
3208   283A FF FF FF FF 
3208   283E FF FF FF FF 
3208   2842 FF FF FF FF 
3208   2846 FF FF FF FF 
3208   284A FF FF FF FF 
3208   284E FF FF FF FF 
3208   2852 FF FF FF FF 
3208   2856 FF FF FF FF 
3208   285A FF FF FF FF 
3208   285E FF FF FF FF 
3208   2862 FF FF FF FF 
3208   2866 FF FF FF FF 
3208   286A FF FF FF FF 
3208   286E FF FF FF FF 
3208   2872 FF FF FF FF 
3208   2876 FF FF FF FF 
3208   287A FF FF FF FF 
3208   287E FF FF FF FF 
3208   2882 FF FF FF FF 
3208   2886 FF FF FF FF 
3208   288A FF FF FF FF 
3208   288E FF FF FF FF 
3208   2892 FF FF FF FF 
3208   2896 FF FF FF FF 
3208   289A FF FF FF FF 
3208   289E FF FF FF FF 
3208   28A2 FF FF FF FF 
3208   28A6 FF FF FF FF 
3208   28AA FF FF FF FF 
3208   28AE FF FF FF FF 
3208   28B2 FF FF FF FF 
3208   28B6 FF FF FF FF 
3208   28BA FF FF FF FF 
3208   28BE FF FF FF FF 
3208   28C2 FF FF FF FF 
3208   28C6 FF FF FF FF 
3208   28CA FF FF FF FF 
3208   28CE FF FF FF FF 
3208   28D2 FF FF FF FF 
3208   28D6 FF FF FF FF 
3208   28DA FF FF FF FF 
3208   28DE FF FF FF FF 
3208   28E2 FF FF FF FF 
3208   28E6 FF FF FF FF 
3208   28EA FF FF FF FF 
3208   28EE FF FF FF FF 
3208   28F2 FF FF FF FF 
3208   28F6 FF FF FF FF 
3208   28FA FF FF FF FF 
3208   28FE FF FF FF FF 
3208   2902 FF FF FF FF 
3208   2906 FF FF FF FF 
3208   290A FF FF FF FF 
3208   290E FF FF FF FF 
3208   2912 FF FF FF FF 
3208   2916 FF FF FF FF 
3208   291A FF FF FF FF 
3208   291E FF FF FF FF 
3208   2922 FF FF FF FF 
3208   2926 FF FF FF FF 
3208   292A FF FF FF FF 
3208   292E FF FF FF FF 
3208   2932 FF FF FF FF 
3208   2936 FF FF FF FF 
3208   293A FF FF FF FF 
3208   293E FF FF FF FF 
3208   2942 FF FF FF FF 
3208   2946 FF FF FF FF 
3208   294A FF FF FF FF 
3208   294E FF FF FF FF 
3208   2952 FF FF FF FF 
3208   2956 FF FF FF FF 
3208   295A FF FF FF FF 
3208   295E FF FF FF FF 
3208   2962 FF FF FF FF 
3208   2966 FF FF FF FF 
3208   296A FF FF FF FF 
3208   296E FF FF FF FF 
3208   2972 FF FF FF FF 
3208   2976 FF FF FF FF 
3208   297A FF FF FF FF 
3208   297E FF FF FF FF 
3208   2982 FF FF FF FF 
3208   2986 FF FF FF FF 
3208   298A FF FF FF FF 
3208   298E FF FF FF FF 
3208   2992 FF FF FF FF 
3208   2996 FF FF FF FF 
3208   299A FF FF FF FF 
3208   299E FF FF FF FF 
3208   29A2 FF FF FF FF 
3208   29A6 FF FF FF FF 
3208   29AA FF FF FF FF 
3208   29AE FF FF FF FF 
3208   29B2 FF FF FF FF 
3208   29B6 FF FF FF FF 
3208   29BA FF FF FF FF 
3208   29BE FF FF FF FF 
3208   29C2 FF FF FF FF 
3208   29C6 FF FF FF FF 
3208   29CA FF FF FF FF 
3208   29CE FF FF FF FF 
3208   29D2 FF FF FF FF 
3208   29D6 FF FF FF FF 
3208   29DA FF FF FF FF 
3208   29DE FF FF FF FF 
3208   29E2 FF FF FF FF 
3208   29E6 FF FF FF FF 
3208   29EA FF FF FF FF 
3208   29EE FF FF FF FF 
3208   29F2 FF FF FF FF 
3208   29F6 FF FF FF FF 
3208   29FA FF FF FF FF 
3208   29FE FF FF FF FF 
3208   2A02 FF FF FF FF 
3208   2A06 FF FF FF FF 
3208   2A0A FF FF FF FF 
3208   2A0E FF FF FF FF 
3208   2A12 FF FF FF FF 
3208   2A16 FF FF FF FF 
3208   2A1A FF FF FF FF 
3208   2A1E FF FF FF FF 
3208   2A22 FF FF FF FF 
3208   2A26 FF FF FF FF 
3208   2A2A FF FF FF FF 
3208   2A2E FF FF FF FF 
3208   2A32 FF FF FF FF 
3208   2A36 FF FF FF FF 
3208   2A3A FF FF FF FF 
3208   2A3E FF FF FF FF 
3208   2A42 FF FF FF FF 
3208   2A46 FF FF FF FF 
3208   2A4A FF FF FF FF 
3208   2A4E FF FF FF FF 
3208   2A52 FF FF FF FF 
3208   2A56 FF FF FF FF 
3208   2A5A FF FF FF FF 
3208   2A5E FF FF FF FF 
3208   2A62 FF FF FF FF 
3208   2A66 FF FF FF FF 
3208   2A6A FF FF FF FF 
3208   2A6E FF FF FF FF 
3208   2A72 FF FF FF FF 
3208   2A76 FF FF FF FF 
3208   2A7A FF FF FF FF 
3208   2A7E FF FF FF FF 
3208   2A82 FF FF FF FF 
3208   2A86 FF FF FF FF 
3208   2A8A FF FF FF FF 
3208   2A8E FF FF FF FF 
3208   2A92 FF FF FF FF 
3208   2A96 FF FF FF FF 
3208   2A9A FF FF FF FF 
3208   2A9E FF FF FF FF 
3208   2AA2 FF FF FF FF 
3208   2AA6 FF FF FF FF 
3208   2AAA FF FF FF FF 
3208   2AAE FF FF FF FF 
3208   2AB2 FF FF FF FF 
3208   2AB6 FF FF FF FF 
3208   2ABA FF FF FF FF 
3208   2ABE FF FF FF FF 
3208   2AC2 FF FF FF FF 
3208   2AC6 FF FF FF FF 
3208   2ACA FF FF FF FF 
3208   2ACE FF FF FF FF 
3208   2AD2 FF FF FF FF 
3208   2AD6 FF FF FF FF 
3208   2ADA FF FF FF FF 
3208   2ADE FF FF FF FF 
3208   2AE2 FF FF FF FF 
3208   2AE6 FF FF FF FF 
3208   2AEA FF FF FF FF 
3208   2AEE FF FF FF FF 
3208   2AF2 FF FF FF FF 
3208   2AF6 FF FF FF FF 
3208   2AFA FF FF FF FF 
3208   2AFE FF FF FF FF 
3208   2B02 FF FF FF FF 
3208   2B06 FF FF FF FF 
3208   2B0A FF FF FF FF 
3208   2B0E FF FF FF FF 
3208   2B12 FF FF FF FF 
3208   2B16 FF FF FF FF 
3208   2B1A FF FF FF FF 
3208   2B1E FF FF FF FF 
3208   2B22 FF FF FF FF 
3208   2B26 FF FF FF FF 
3208   2B2A FF FF FF FF 
3208   2B2E FF FF FF FF 
3208   2B32 FF FF FF FF 
3208   2B36 FF FF FF FF 
3208   2B3A FF FF FF FF 
3208   2B3E FF FF FF FF 
3208   2B42 FF FF FF FF 
3208   2B46 FF FF FF FF 
3208   2B4A FF FF FF FF 
3208   2B4E FF FF FF FF 
3208   2B52 FF FF FF FF 
3208   2B56 FF FF FF FF 
3208   2B5A FF FF FF FF 
3208   2B5E FF FF FF FF 
3208   2B62 FF FF FF FF 
3208   2B66 FF FF FF FF 
3208   2B6A FF FF FF FF 
3208   2B6E FF FF FF FF 
3208   2B72 FF FF FF FF 
3208   2B76 FF FF FF FF 
3208   2B7A FF FF FF FF 
3208   2B7E FF FF FF FF 
3208   2B82 FF FF FF FF 
3208   2B86 FF FF FF FF 
3208   2B8A FF FF FF FF 
3208   2B8E FF FF FF FF 
3208   2B92 FF FF FF FF 
3208   2B96 FF FF FF FF 
3208   2B9A FF FF FF FF 
3208   2B9E FF FF FF FF 
3208   2BA2 FF FF FF FF 
3208   2BA6 FF FF FF FF 
3208   2BAA FF FF FF FF 
3208   2BAE FF FF FF FF 
3208   2BB2 FF FF FF FF 
3208   2BB6 FF FF FF FF 
3208   2BBA FF FF FF FF 
3208   2BBE FF FF FF FF 
3208   2BC2 FF FF FF FF 
3208   2BC6 FF FF FF FF 
3208   2BCA FF FF FF FF 
3208   2BCE FF FF FF FF 
3208   2BD2 FF FF FF FF 
3208   2BD6 FF FF FF FF 
3208   2BDA FF FF FF FF 
3208   2BDE FF FF FF FF 
3208   2BE2 FF FF FF FF 
3208   2BE6 FF FF FF FF 
3208   2BEA FF FF FF FF 
3208   2BEE FF FF FF FF 
3208   2BF2 FF FF FF FF 
3208   2BF6 FF FF FF FF 
3208   2BFA FF FF FF FF 
3208   2BFE FF FF FF FF 
3208   2C02 FF FF FF FF 
3208   2C06 FF FF FF FF 
3208   2C0A FF FF FF FF 
3208   2C0E FF FF FF FF 
3208   2C12 FF FF FF FF 
3208   2C16 FF FF FF FF 
3208   2C1A FF FF FF FF 
3208   2C1E FF FF FF FF 
3208   2C22 FF FF FF FF 
3208   2C26 FF FF FF FF 
3208   2C2A FF FF FF FF 
3208   2C2E FF FF FF FF 
3208   2C32 FF FF FF FF 
3208   2C36 FF FF FF FF 
3208   2C3A FF FF FF FF 
3208   2C3E FF FF FF FF 
3208   2C42 FF FF FF FF 
3208   2C46 FF FF FF FF 
3208   2C4A FF FF FF FF 
3208   2C4E FF FF FF FF 
3208   2C52 FF FF FF FF 
3208   2C56 FF FF FF FF 
3208   2C5A FF FF FF FF 
3208   2C5E FF FF FF FF 
3208   2C62 FF FF FF FF 
3208   2C66 FF FF FF FF 
3208   2C6A FF FF FF FF 
3208   2C6E FF FF FF FF 
3208   2C72 FF FF FF FF 
3208   2C76 FF FF FF FF 
3208   2C7A FF FF FF FF 
3208   2C7E FF FF FF FF 
3208   2C82 FF FF FF FF 
3208   2C86 FF FF FF FF 
3208   2C8A FF FF FF FF 
3208   2C8E FF FF FF FF 
3208   2C92 FF FF FF FF 
3208   2C96 FF FF FF FF 
3208   2C9A FF FF FF FF 
3208   2C9E FF FF FF FF 
3208   2CA2 FF FF FF FF 
3208   2CA6 FF FF FF FF 
3208   2CAA FF FF FF FF 
3208   2CAE FF FF FF FF 
3208   2CB2 FF FF FF FF 
3208   2CB6 FF FF FF FF 
3208   2CBA FF FF FF FF 
3208   2CBE FF FF FF FF 
3208   2CC2 FF FF FF FF 
3208   2CC6 FF FF FF FF 
3208   2CCA FF FF FF FF 
3208   2CCE FF FF FF FF 
3208   2CD2 FF FF FF FF 
3208   2CD6 FF FF FF FF 
3208   2CDA FF FF FF FF 
3208   2CDE FF FF FF FF 
3208   2CE2 FF FF FF FF 
3208   2CE6 FF FF FF FF 
3208   2CEA FF FF FF FF 
3208   2CEE FF FF FF FF 
3208   2CF2 FF FF FF FF 
3208   2CF6 FF FF FF FF 
3208   2CFA FF FF FF FF 
3208   2CFE FF FF FF FF 
3208   2D02 FF FF FF FF 
3208   2D06 FF FF FF FF 
3208   2D0A FF FF FF FF 
3208   2D0E FF FF FF FF 
3208   2D12 FF FF FF FF 
3208   2D16 FF FF FF FF 
3208   2D1A FF FF FF FF 
3208   2D1E FF FF FF FF 
3208   2D22 FF FF FF FF 
3208   2D26 FF FF FF FF 
3208   2D2A FF FF FF FF 
3208   2D2E FF FF FF FF 
3208   2D32 FF FF FF FF 
3208   2D36 FF FF FF FF 
3208   2D3A FF FF FF FF 
3208   2D3E FF FF FF FF 
3208   2D42 FF FF FF FF 
3208   2D46 FF FF FF FF 
3208   2D4A FF FF FF FF 
3208   2D4E FF FF FF FF 
3208   2D52 FF FF FF FF 
3208   2D56 FF FF FF FF 
3208   2D5A FF FF FF FF 
3208   2D5E FF FF FF FF 
3208   2D62 FF FF FF FF 
3208   2D66 FF FF FF FF 
3208   2D6A FF FF FF FF 
3208   2D6E FF FF FF FF 
3208   2D72 FF FF FF FF 
3208   2D76 FF FF FF FF 
3208   2D7A FF FF FF FF 
3208   2D7E FF FF FF FF 
3208   2D82 FF FF FF FF 
3208   2D86 FF FF FF FF 
3208   2D8A FF FF FF FF 
3208   2D8E FF FF FF FF 
3208   2D92 FF FF FF FF 
3208   2D96 FF FF FF FF 
3208   2D9A FF FF FF FF 
3208   2D9E FF FF FF FF 
3208   2DA2 FF FF FF FF 
3208   2DA6 FF FF FF FF 
3208   2DAA FF FF FF FF 
3208   2DAE FF FF FF FF 
3208   2DB2 FF FF FF FF 
3208   2DB6 FF FF FF FF 
3208   2DBA FF FF FF FF 
3208   2DBE FF FF FF FF 
3208   2DC2 FF FF FF FF 
3208   2DC6 FF FF FF FF 
3208   2DCA FF FF FF FF 
3208   2DCE FF FF FF FF 
3208   2DD2 FF FF FF FF 
3208   2DD6 FF FF FF FF 
3208   2DDA FF FF FF FF 
3208   2DDE FF FF FF FF 
3208   2DE2 FF FF FF FF 
3208   2DE6 FF FF FF FF 
3208   2DEA FF FF FF FF 
3208   2DEE FF FF FF FF 
3208   2DF2 FF FF FF FF 
3208   2DF6 FF FF FF FF 
3208   2DFA FF FF FF FF 
3208   2DFE FF FF FF FF 
3208   2E02 FF FF FF FF 
3208   2E06 FF FF FF FF 
3208   2E0A FF FF FF FF 
3208   2E0E FF FF FF FF 
3208   2E12 FF FF FF FF 
3208   2E16 FF FF FF FF 
3208   2E1A FF FF FF FF 
3208   2E1E FF FF FF FF 
3208   2E22 FF FF FF FF 
3208   2E26 FF FF FF FF 
3208   2E2A FF FF FF FF 
3208   2E2E FF FF FF FF 
3208   2E32 FF FF FF FF 
3208   2E36 FF FF FF FF 
3208   2E3A FF FF FF FF 
3208   2E3E FF FF FF FF 
3208   2E42 FF FF FF FF 
3208   2E46 FF FF FF FF 
3208   2E4A FF FF FF FF 
3208   2E4E FF FF FF FF 
3208   2E52 FF FF FF FF 
3208   2E56 FF FF FF FF 
3208   2E5A FF FF FF FF 
3208   2E5E FF FF FF FF 
3208   2E62 FF FF FF FF 
3208   2E66 FF FF FF FF 
3208   2E6A FF FF FF FF 
3208   2E6E FF FF FF FF 
3208   2E72 FF FF FF FF 
3208   2E76 FF FF FF FF 
3208   2E7A FF FF FF FF 
3208   2E7E FF FF FF FF 
3208   2E82 FF FF FF FF 
3208   2E86 FF FF FF FF 
3208   2E8A FF FF FF FF 
3208   2E8E FF FF FF FF 
3208   2E92 FF FF FF FF 
3208   2E96 FF FF FF FF 
3208   2E9A FF FF FF FF 
3208   2E9E FF FF FF FF 
3208   2EA2 FF FF FF FF 
3208   2EA6 FF FF FF FF 
3208   2EAA FF FF FF FF 
3208   2EAE FF FF FF FF 
3208   2EB2 FF FF FF FF 
3208   2EB6 FF FF FF FF 
3208   2EBA FF FF FF FF 
3208   2EBE FF FF FF FF 
3208   2EC2 FF FF FF FF 
3208   2EC6 FF FF FF FF 
3208   2ECA FF FF FF FF 
3208   2ECE FF FF FF FF 
3208   2ED2 FF FF FF FF 
3208   2ED6 FF FF FF FF 
3208   2EDA FF FF FF FF 
3208   2EDE FF FF FF FF 
3208   2EE2 FF FF FF FF 
3208   2EE6 FF FF FF FF 
3208   2EEA FF FF FF FF 
3208   2EEE FF FF FF FF 
3208   2EF2 FF FF FF FF 
3208   2EF6 FF FF FF FF 
3208   2EFA FF FF FF FF 
3208   2EFE FF FF FF FF 
3208   2F02 FF FF FF FF 
3208   2F06 FF FF FF FF 
3208   2F0A FF FF FF FF 
3208   2F0E FF FF FF FF 
3208   2F12 FF FF FF FF 
3208   2F16 FF FF FF FF 
3208   2F1A FF FF FF FF 
3208   2F1E FF FF FF FF 
3208   2F22 FF FF FF FF 
3208   2F26 FF FF FF FF 
3208   2F2A FF FF FF FF 
3208   2F2E FF FF FF FF 
3208   2F32 FF FF FF FF 
3208   2F36 FF FF FF FF 
3208   2F3A FF FF FF FF 
3208   2F3E FF FF FF FF 
3208   2F42 FF FF FF FF 
3208   2F46 FF FF FF FF 
3208   2F4A FF FF FF FF 
3208   2F4E FF FF FF FF 
3208   2F52 FF FF FF FF 
3208   2F56 FF FF FF FF 
3208   2F5A FF FF FF FF 
3208   2F5E FF FF FF FF 
3208   2F62 FF FF FF FF 
3208   2F66 FF FF FF FF 
3208   2F6A FF FF FF FF 
3208   2F6E FF FF FF FF 
3208   2F72 FF FF FF FF 
3208   2F76 FF FF FF FF 
3208   2F7A FF FF FF FF 
3208   2F7E FF FF FF FF 
3208   2F82 FF FF FF FF 
3208   2F86 FF FF FF FF 
3208   2F8A FF FF FF FF 
3208   2F8E FF FF FF FF 
3208   2F92 FF FF FF FF 
3208   2F96 FF FF FF FF 
3208   2F9A FF FF FF FF 
3208   2F9E FF FF FF FF 
3208   2FA2 FF FF FF FF 
3208   2FA6 FF FF FF FF 
3208   2FAA FF FF FF FF 
3208   2FAE FF FF FF FF 
3208   2FB2 FF FF FF FF 
3208   2FB6 FF FF FF FF 
3208   2FBA FF FF FF FF 
3208   2FBE FF FF FF FF 
3208   2FC2 FF FF FF FF 
3208   2FC6 FF FF FF FF 
3208   2FCA FF FF FF FF 
3208   2FCE FF FF FF FF 
3208   2FD2 FF FF FF FF 
3208   2FD6 FF FF FF FF 
3208   2FDA FF FF FF FF 
3208   2FDE FF FF FF FF 
3208   2FE2 FF FF FF FF 
3208   2FE6 FF FF FF FF 
3208   2FEA FF FF FF FF 
3208   2FEE FF FF FF FF 
3208   2FF2 FF FF FF FF 
3208   2FF6 FF FF FF FF 
3208   2FFA FF FF FF FF 
3208   2FFE FF FF FF FF 
3208   3002 FF FF FF FF 
3208   3006 FF FF FF FF 
3208   300A FF FF FF FF 
3208   300E FF FF FF FF 
3208   3012 FF FF FF FF 
3208   3016 FF FF FF FF 
3208   301A FF FF FF FF 
3208   301E FF FF FF FF 
3208   3022 FF FF FF FF 
3208   3026 FF FF FF FF 
3208   302A FF FF FF FF 
3208   302E FF FF FF FF 
3208   3032 FF FF FF FF 
3208   3036 FF FF FF FF 
3208   303A FF FF FF FF 
3208   303E FF FF FF FF 
3208   3042 FF FF FF FF 
3208   3046 FF FF FF FF 
3208   304A FF FF FF FF 
3208   304E FF FF FF FF 
3208   3052 FF FF FF FF 
3208   3056 FF FF FF FF 
3208   305A FF FF FF FF 
3208   305E FF FF FF FF 
3208   3062 FF FF FF FF 
3208   3066 FF FF FF FF 
3208   306A FF FF FF FF 
3208   306E FF FF FF FF 
3208   3072 FF FF FF FF 
3208   3076 FF FF FF FF 
3208   307A FF FF FF FF 
3208   307E FF FF FF FF 
3208   3082 FF FF FF FF 
3208   3086 FF FF FF FF 
3208   308A FF FF FF FF 
3208   308E FF FF FF FF 
3208   3092 FF FF FF FF 
3208   3096 FF FF FF FF 
3208   309A FF FF FF FF 
3208   309E FF FF FF FF 
3208   30A2 FF FF FF FF 
3208   30A6 FF FF FF FF 
3208   30AA FF FF FF FF 
3208   30AE FF FF FF FF 
3208   30B2 FF FF FF FF 
3208   30B6 FF FF FF FF 
3208   30BA FF FF FF FF 
3208   30BE FF FF FF FF 
3208   30C2 FF FF FF FF 
3208   30C6 FF FF FF FF 
3208   30CA FF FF FF FF 
3208   30CE FF FF FF FF 
3208   30D2 FF FF FF FF 
3208   30D6 FF FF FF FF 
3208   30DA FF FF FF FF 
3208   30DE FF FF FF FF 
3208   30E2 FF FF FF FF 
3208   30E6 FF FF FF FF 
3208   30EA FF FF FF FF 
3208   30EE FF FF FF FF 
3208   30F2 FF FF FF FF 
3208   30F6 FF FF FF FF 
3208   30FA FF FF FF FF 
3208   30FE FF FF FF FF 
3208   3102 FF FF FF FF 
3208   3106 FF FF FF FF 
3208   310A FF FF FF FF 
3208   310E FF FF FF FF 
3208   3112 FF FF FF FF 
3208   3116 FF FF FF FF 
3208   311A FF FF FF FF 
3208   311E FF FF FF FF 
3208   3122 FF FF FF FF 
3208   3126 FF FF FF FF 
3208   312A FF FF FF FF 
3208   312E FF FF FF FF 
3208   3132 FF FF FF FF 
3208   3136 FF FF FF FF 
3208   313A FF FF FF FF 
3208   313E FF FF FF FF 
3208   3142 FF FF FF FF 
3208   3146 FF FF FF FF 
3208   314A FF FF FF FF 
3208   314E FF FF FF FF 
3208   3152 FF FF FF FF 
3208   3156 FF FF FF FF 
3208   315A FF FF FF FF 
3208   315E FF FF FF FF 
3208   3162 FF FF FF FF 
3208   3166 FF FF FF FF 
3208   316A FF FF FF FF 
3208   316E FF FF FF FF 
3208   3172 FF FF FF FF 
3208   3176 FF FF FF FF 
3208   317A FF FF FF FF 
3208   317E FF FF FF FF 
3208   3182 FF FF FF FF 
3208   3186 FF FF FF FF 
3208   318A FF FF FF FF 
3209   318E             
3210   318E             scrap_sector:
3211   318E FF FF FF FF   .fill 512         ; scrap sector
3211   3192 FF FF FF FF 
3211   3196 FF FF FF FF 
3211   319A FF FF FF FF 
3211   319E FF FF FF FF 
3211   31A2 FF FF FF FF 
3211   31A6 FF FF FF FF 
3211   31AA FF FF FF FF 
3211   31AE FF FF FF FF 
3211   31B2 FF FF FF FF 
3211   31B6 FF FF FF FF 
3211   31BA FF FF FF FF 
3211   31BE FF FF FF FF 
3211   31C2 FF FF FF FF 
3211   31C6 FF FF FF FF 
3211   31CA FF FF FF FF 
3211   31CE FF FF FF FF 
3211   31D2 FF FF FF FF 
3211   31D6 FF FF FF FF 
3211   31DA FF FF FF FF 
3211   31DE FF FF FF FF 
3211   31E2 FF FF FF FF 
3211   31E6 FF FF FF FF 
3211   31EA FF FF FF FF 
3211   31EE FF FF FF FF 
3211   31F2 FF FF FF FF 
3211   31F6 FF FF FF FF 
3211   31FA FF FF FF FF 
3211   31FE FF FF FF FF 
3211   3202 FF FF FF FF 
3211   3206 FF FF FF FF 
3211   320A FF FF FF FF 
3211   320E FF FF FF FF 
3211   3212 FF FF FF FF 
3211   3216 FF FF FF FF 
3211   321A FF FF FF FF 
3211   321E FF FF FF FF 
3211   3222 FF FF FF FF 
3211   3226 FF FF FF FF 
3211   322A FF FF FF FF 
3211   322E FF FF FF FF 
3211   3232 FF FF FF FF 
3211   3236 FF FF FF FF 
3211   323A FF FF FF FF 
3211   323E FF FF FF FF 
3211   3242 FF FF FF FF 
3211   3246 FF FF FF FF 
3211   324A FF FF FF FF 
3211   324E FF FF FF FF 
3211   3252 FF FF FF FF 
3211   3256 FF FF FF FF 
3211   325A FF FF FF FF 
3211   325E FF FF FF FF 
3211   3262 FF FF FF FF 
3211   3266 FF FF FF FF 
3211   326A FF FF FF FF 
3211   326E FF FF FF FF 
3211   3272 FF FF FF FF 
3211   3276 FF FF FF FF 
3211   327A FF FF FF FF 
3211   327E FF FF FF FF 
3211   3282 FF FF FF FF 
3211   3286 FF FF FF FF 
3211   328A FF FF FF FF 
3211   328E FF FF FF FF 
3211   3292 FF FF FF FF 
3211   3296 FF FF FF FF 
3211   329A FF FF FF FF 
3211   329E FF FF FF FF 
3211   32A2 FF FF FF FF 
3211   32A6 FF FF FF FF 
3211   32AA FF FF FF FF 
3211   32AE FF FF FF FF 
3211   32B2 FF FF FF FF 
3211   32B6 FF FF FF FF 
3211   32BA FF FF FF FF 
3211   32BE FF FF FF FF 
3211   32C2 FF FF FF FF 
3211   32C6 FF FF FF FF 
3211   32CA FF FF FF FF 
3211   32CE FF FF FF FF 
3211   32D2 FF FF FF FF 
3211   32D6 FF FF FF FF 
3211   32DA FF FF FF FF 
3211   32DE FF FF FF FF 
3211   32E2 FF FF FF FF 
3211   32E6 FF FF FF FF 
3211   32EA FF FF FF FF 
3211   32EE FF FF FF FF 
3211   32F2 FF FF FF FF 
3211   32F6 FF FF FF FF 
3211   32FA FF FF FF FF 
3211   32FE FF FF FF FF 
3211   3302 FF FF FF FF 
3211   3306 FF FF FF FF 
3211   330A FF FF FF FF 
3211   330E FF FF FF FF 
3211   3312 FF FF FF FF 
3211   3316 FF FF FF FF 
3211   331A FF FF FF FF 
3211   331E FF FF FF FF 
3211   3322 FF FF FF FF 
3211   3326 FF FF FF FF 
3211   332A FF FF FF FF 
3211   332E FF FF FF FF 
3211   3332 FF FF FF FF 
3211   3336 FF FF FF FF 
3211   333A FF FF FF FF 
3211   333E FF FF FF FF 
3211   3342 FF FF FF FF 
3211   3346 FF FF FF FF 
3211   334A FF FF FF FF 
3211   334E FF FF FF FF 
3211   3352 FF FF FF FF 
3211   3356 FF FF FF FF 
3211   335A FF FF FF FF 
3211   335E FF FF FF FF 
3211   3362 FF FF FF FF 
3211   3366 FF FF FF FF 
3211   336A FF FF FF FF 
3211   336E FF FF FF FF 
3211   3372 FF FF FF FF 
3211   3376 FF FF FF FF 
3211   337A FF FF FF FF 
3211   337E FF FF FF FF 
3211   3382 FF FF FF FF 
3211   3386 FF FF FF FF 
3211   338A FF FF FF FF 
3212   338E             transient_area:
3213   338E 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
3214   338F             
3215   338F             .end
tasm: Number of errors = 0
