0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 3D 00       .dw int_1
0136   0004 3E 00       .dw int_2
0137   0006 3F 00       .dw int_3
0138   0008 40 00       .dw int_4
0139   000A 41 00       .dw int_5
0140   000C 42 00       .dw int_6
0141   000E 43 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 1B 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 D0 02       .dw trap_privilege
0153   0014 ED 03       .dw trap_div_zero
0154   0016 FA 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 DC 02       .dw syscall_break
0165   0022 FB 03       .dw syscall_rtc
0166   0024 1E 05       .dw syscall_ide
0167   0026 DE 05       .dw syscall_io
0168   0028 9B 06       .dw syscall_file_system
0169   002A 68 0F       .dw syscall_create_proc
0170   002C 95 02       .dw syscall_list_procs
0171   002E 2D 04       .dw syscall_datetime
0172   0030 51 02       .dw syscall_reboot
0173   0032 32 0F       .dw syscall_pause_proc
0174   0034 5D 02       .dw syscall_resume_proc
0175   0036 EF 0E       .dw syscall_terminate_proc
0176   0038 1D 02       .dw syscall_system
0177   003A 92 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; aliases for individual 'al' options for FDC system calls
0198   003C             fdc_al_restore      .equ 0
0199   003C             fdc_al_step         .equ 1
0200   003C             fdc_al_step_in      .equ 2
0201   003C             fdc_al_step_out     .equ 3
0202   003C             fdc_al_seek         .equ 4
0203   003C             fdc_al_format       .equ 5
0204   003C             fdc_al_read_addr    .equ 6
0205   003C             fdc_al_read_track   .equ 7
0206   003C             fdc_al_read_sect    .equ 8
0207   003C             fdc_al_write_sect   .equ 9
0208   003C             fdc_al_force_int    .equ 10
0209   003C             fdc_al_status0      .equ 11
0210   003C             fdc_al_status1      .equ 12
0211   003C             
0212   003C             ; ------------------------------------------------------------------------------------------------------------------;
0213   003C             ; alias exports
0214   003C             ; ------------------------------------------------------------------------------------------------------------------;
0215   003C             .export text_org
0216   003C             .export sys_break
0217   003C             .export sys_rtc
0218   003C             .export sys_ide
0219   003C             .export sys_io
0220   003C             .export sys_filesystem
0221   003C             .export sys_create_proc
0222   003C             .export sys_list_proc
0223   003C             .export sys_datetime
0224   003C             .export sys_reboot
0225   003C             .export sys_pause_proc
0226   003C             .export sys_resume_proc
0227   003C             .export sys_terminate_proc
0228   003C             .export sys_system
0229   003C             .export sys_fdc
0230   003C             
0231   003C             .export _fdc_config        
0232   003C             .export _fdc_status_0      
0233   003C             .export _fdc_stat_cmd     
0234   003C             
0235   003C             ; exports of aliases for individual 'al' options for FDC system calls
0236   003C             .export fdc_al_restore
0237   003C             .export fdc_al_step
0238   003C             .export fdc_al_step_in
0239   003C             .export fdc_al_step_out
0240   003C             .export fdc_al_seek
0241   003C             .export fdc_al_format
0242   003C             .export fdc_al_read_addr
0243   003C             .export fdc_al_read_track
0244   003C             .export fdc_al_read_sect
0245   003C             .export fdc_al_write_sect
0246   003C             .export fdc_al_force_int
0247   003C             .export fdc_al_status0
0248   003C             .export fdc_al_status1
0249   003C             
0250   003C             ; ------------------------------------------------------------------------------------------------------------------;
0251   003C             ; irqs' code block
0252   003C             ; ------------------------------------------------------------------------------------------------------------------;
0253   003C             ; 5.25" floppy drive controller irq
0254   003C             int_0_fdc:
0255   003C 06            sysret
0256   003D             int_1:
0257   003D 06            sysret
0258   003E             int_2:
0259   003E 06            sysret
0260   003F             int_3:
0261   003F 06            sysret
0262   0040             int_4:
0263   0040 06            sysret
0264   0041             int_5:
0265   0041 06            sysret
0266   0042             
0267   0042             ; timer irq
0268   0042             int_6:  
0269   0042 06            sysret
0270   0043             
0271   0043             ; ------------------------------------------------------------------------------------------------------------------;
0272   0043             ; uart0 interrupt
0273   0043             ; ------------------------------------------------------------------------------------------------------------------;
0274   0043             int_7_uart0:
0275   0043 D7            push a
0276   0044 DA            push d
0277   0045 E1            pushf
0278   0046 14 AD 17      mov a, [fifo_in]
0279   0049 3C            mov d, a
0280   004A 1D 80 FF      mov al, [_uart0_data]       ; get character
0281   004D B9 03         cmp al, $03                 ; ctrl-c
0282   004F C6 6C 00      je ctrlc
0283   0052 B9 1A         cmp al, $1a                 ; ctrl-z
0284   0054 C6 72 00      je ctrlz
0285   0057 3E            mov [d], al                 ; add to fifo
0286   0058 14 AD 17      mov a, [fifo_in]
0287   005B 77            inc a
0288   005C AF 0E 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0289   005F C7 65 00      jne int_7_continue
0290   0062 10 0E 1F      mov a, fifo  
0291   0065             int_7_continue:  
0292   0065 42 AD 17      mov [fifo_in], a            ; update fifo pointer
0293   0068 EE            popf
0294   0069 E7            pop d
0295   006A E4            pop a  
0296   006B 06            sysret
0297   006C             ctrlc:
0298   006C 51 05 00      add sp, 5
0299   006F 0A EF 0E      jmp syscall_terminate_proc
0300   0072             ctrlz:
0301   0072 EE            popf
0302   0073 E7            pop d
0303   0074 E4            pop a
0304   0075 0A 32 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0305   0078             
0306   0078             ; ------------------------------------------------------------------------------------------------------------------;
0307   0078             ; floppy drive syscalls
0308   0078             ; ------------------------------------------------------------------------------------------------------------------;
0309   0078             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0310   0078             ; fdc_40_ff:
0311   0078             ;   .fill 40,  $ff    ; or 00                                                                                
0312   0078             ; fdc_128_format_inner:
0313   0078             ;   .fill 6,   $00    ;                                                                            <--|        
0314   0078             ;   .fill 1,   $fe    ; id address mark                                                               |        
0315   0078             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0316   0078             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0317   0078             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0318   0078             ;   .fill 1,   $00    ; sector length                                                                 |                        
0319   0078             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0320   0078             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0321   0078             ;   .fill 6,   $00    ;                                                                               |                        
0322   0078             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0323   0078             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0324   0078             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0325   0078             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0326   0078             ; fdc_128_format_end:
0327   0078             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0328   0078             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0329   0078             fdc_jmptbl:
0330   0078 9E 00         .dw syscall_fdc_restore
0331   007A AA 00         .dw syscall_fdc_step
0332   007C B2 00         .dw syscall_fdc_step_in
0333   007E BA 00         .dw syscall_fdc_step_out
0334   0080 C2 00         .dw syscall_fdc_seek
0335   0082 D0 00         .dw syscall_fdc_format
0336   0084 CE 00         .dw syscall_fdc_read_addr
0337   0086 FA 00         .dw syscall_fdc_read_track
0338   0088 29 01         .dw syscall_fdc_read_sect
0339   008A 61 01         .dw syscall_fdc_write_sect
0340   008C CF 00         .dw syscall_fdc_force_int
0341   008E 96 00         .dw syscall_fdc_status0
0342   0090 9A 00         .dw syscall_fdc_status1
0343   0092             syscall_fdc:
0344   0092 FD 0A 78 00   jmp [fdc_jmptbl + al]
0345   0096             
0346   0096             syscall_fdc_status0:
0347   0096 1D C1 FF      mov al, [_fdc_status_0]
0348   0099 06            sysret
0349   009A             
0350   009A             syscall_fdc_status1:
0351   009A 1D C8 FF      mov al, [_fdc_stat_cmd]
0352   009D 06            sysret
0353   009E             
0354   009E             syscall_fdc_restore:
0355   009E 07 95 01      call fdc_wait_not_busy
0356   00A1 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0357   00A5 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0358   00A9 06            sysret
0359   00AA             
0360   00AA             syscall_fdc_step:
0361   00AA 07 95 01      call fdc_wait_not_busy
0362   00AD F2 C8 FF 38   mov byte [_fdc_stat_cmd], %00111000
0363   00B1 06            sysret
0364   00B2             
0365   00B2             syscall_fdc_step_in:
0366   00B2 07 95 01      call fdc_wait_not_busy
0367   00B5 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0368   00B9 06            sysret
0369   00BA             
0370   00BA             syscall_fdc_step_out:
0371   00BA 07 95 01      call fdc_wait_not_busy
0372   00BD F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0373   00C1 06            sysret
0374   00C2             
0375   00C2             ; bl: desired track
0376   00C2             syscall_fdc_seek:
0377   00C2 07 95 01      call fdc_wait_not_busy
0378   00C5 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to 39
0379   00C9 F2 C8 FF 18   mov byte [_fdc_stat_cmd], %00011000 ; seek command
0380   00CD 06            sysret
0381   00CE             
0382   00CE             syscall_fdc_read_addr:
0383   00CE 06            sysret
0384   00CF             
0385   00CF             syscall_fdc_force_int:
0386   00CF 06            sysret
0387   00D0             
0388   00D0             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0389   00D0             ; in the ram formatting block because they are all set as 00 right now
0390   00D0             ; bl: track number
0391   00D0             syscall_fdc_format:
0392   00D0 07 A0 01      call fdc_format_mem
0393   00D3 07 95 01      call fdc_wait_not_busy
0394   00D6 FD 3D C9 FF   mov [_fdc_track], bl
0395   00DA FD 4D 0E 25   mov si, transient_area
0396   00DE F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0397   00E2 07 0C 02      call fdc_wait_64us
0398   00E5             fdc_format_drq:
0399   00E5 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0400   00E8 93 01         test al, $01                ; 4
0401   00EA C6 F9 00      jz fdc_format_end           ; 8
0402   00ED 93 02         test al, $02                ; 4
0403   00EF C6 E5 00      jz fdc_format_drq           ; 8
0404   00F2 F6            lodsb                       ; 7
0405   00F3 3D CB FF      mov [_fdc_data], al         ; 10   
0406   00F6 0A E5 00      jmp fdc_format_drq
0407   00F9             fdc_format_end:
0408   00F9 06            sysret
0409   00FA             
0410   00FA             ; di : destination in user space
0411   00FA             ; a  : returns number of read bytes
0412   00FA             syscall_fdc_read_track:
0413   00FA 07 95 01      call fdc_wait_not_busy
0414   00FD E3            push di
0415   00FE FD 4F 0E 25   mov di, transient_area
0416   0102 F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0417   0106 07 0C 02      call fdc_wait_64us
0418   0109             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0419   0109 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0420   010C 93 01         test al, $01                ; check busy bit
0421   010E C6 1D 01      jz fdc_read_track_end
0422   0111 93 02         test al, $02                ; check drq bit
0423   0113 C6 09 01      jz fdc_read_track_l0
0424   0116 1D CB FF      mov al, [_fdc_data]     ; 
0425   0119 F7            stosb
0426   011A 0A 09 01      jmp fdc_read_track_l0
0427   011D             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0428   011D             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0429   011D             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0430   011D             fdc_read_track_end:
0431   011D 50            mov a, di
0432   011E 5F 0E 25      sub a, transient_area
0433   0121 F0            pop di
0434   0122 FD 4D 0E 25   mov si, transient_area
0435   0126 39            mov c, a  ; copy track over to user space
0436   0127 03            store
0437   0128 06            sysret
0438   0129             
0439   0129             ; sector in bl
0440   0129             ; track in bh
0441   0129             ; di = user space destination
0442   0129             syscall_fdc_read_sect:
0443   0129 07 95 01      call fdc_wait_not_busy
0444   012C E3            push di
0445   012D FD 3D CA FF   mov [_fdc_sector], bl
0446   0131 30            mov bl, bh
0447   0132 FD 3D C9 FF   mov [_fdc_track], bl
0448   0136 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0449   013A 07 0C 02      call fdc_wait_64us
0450   013D FD 4F 0E 25   mov di, transient_area
0451   0141             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0452   0141 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0453   0144 93 01         test al, $01                ; check drq bit
0454   0146 C6 55 01      jz fdc_read_sect_end
0455   0149 93 02         test al, $02                ; check drq bit
0456   014B C6 41 01      jz fdc_read_sect_l0
0457   014E 1D CB FF      mov al, [_fdc_data]     ; 
0458   0151 F7            stosb
0459   0152 0A 41 01      jmp fdc_read_sect_l0
0460   0155             fdc_read_sect_end:
0461   0155 50            mov a, di
0462   0156 5F 0E 25      sub a, transient_area
0463   0159 F0            pop di
0464   015A FD 4D 0E 25   mov si, transient_area
0465   015E 39            mov c, a  ; copy sector over to user space
0466   015F 03            store
0467   0160 06            sysret
0468   0161             
0469   0161             ; sector in al
0470   0161             ; track in ah
0471   0161             ; data pointer in si
0472   0161             syscall_fdc_write_sect:
0473   0161 07 95 01      call fdc_wait_not_busy
0474   0164 FD 3D CA FF   mov [_fdc_sector], bl
0475   0168 30            mov bl, bh
0476   0169 FD 3D C9 FF   mov [_fdc_track], bl
0477   016D FD 4F 0E 25   mov di, transient_area    ; si = data source, di = destination 
0478   0171 38 80 00      mov c, 128
0479   0174 04            load                    ; transfer data to kernel space!
0480   0175 FD 4D 0E 25   mov si, transient_area
0481   0179 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0482   017D 07 0C 02      call fdc_wait_64us
0483   0180             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0484   0180 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0485   0183 93 01         test al, $01                    ; 4
0486   0185 C6 94 01      jz fdc_write_sect_end           ; 8
0487   0188 93 02         test al, $02                    ; 4
0488   018A C6 80 01      jz fdc_write_sect_l0            ; 8
0489   018D F6            lodsb                           ; 7
0490   018E 3D CB FF      mov [_fdc_data], al             ; 10   
0491   0191 0A 80 01      jmp fdc_write_sect_l0
0492   0194             fdc_write_sect_end:
0493   0194 06            sysret
0494   0195             
0495   0195             fdc_wait_not_busy:
0496   0195 DB            push al
0497   0196 1D C8 FF      mov al, [_fdc_stat_cmd]   
0498   0199 93 01         test al, $01               
0499   019B C7 95 01      jnz fdc_wait_not_busy          
0500   019E E8            pop al
0501   019F 09            ret
0502   01A0             
0503   01A0             fdc_format_mem:
0504   01A0 3B 01 00      mov d, 1
0505   01A3 FD 4F 0E 25   mov di, transient_area
0506   01A7             ; 40 * FF
0507   01A7 38 28 00      mov c, 40
0508   01AA 19 FF         mov al, $ff
0509   01AC             fdc_l0: 
0510   01AC F7            stosb
0511   01AD 7E            dec c
0512   01AE C7 AC 01      jnz fdc_l0
0513   01B1             ; 6 * 00
0514   01B1             fdc_inner_loop:
0515   01B1 38 06 00      mov c, 6
0516   01B4 19 00         mov al, $00
0517   01B6             fdc_l1:
0518   01B6 F7            stosb
0519   01B7 7E            dec c
0520   01B8 C7 B6 01      jnz fdc_l1
0521   01BB             ; FE address mark
0522   01BB             fdc_l2:
0523   01BB 19 FE         mov al, $fe
0524   01BD F7            stosb
0525   01BE             ; track number
0526   01BE             fdc_l3:
0527   01BE 19 00         mov al, $00
0528   01C0 F7            stosb
0529   01C1             ; side number
0530   01C1             fdc_l4:
0531   01C1 19 00         mov al, $00
0532   01C3 F7            stosb
0533   01C4             ; sector number
0534   01C4             fdc_l5:
0535   01C4 13            mov a, d
0536   01C5 F7            stosb
0537   01C6             ; sector length 128 bytes
0538   01C6             fdc_l6:
0539   01C6 19 00         mov al, $00
0540   01C8 F7            stosb
0541   01C9             ; 2 crc's
0542   01C9             fdc_l7:
0543   01C9 19 F7         mov al, $f7
0544   01CB F7            stosb
0545   01CC             ; 11 times $ff
0546   01CC 38 0B 00      mov c, 11
0547   01CF 19 FF         mov al, $ff
0548   01D1             fdc_l8:
0549   01D1 F7            stosb
0550   01D2 7E            dec c
0551   01D3 C7 D1 01      jnz fdc_l8
0552   01D6             ; 6 times 00
0553   01D6 38 06 00      mov c, 6
0554   01D9 19 00         mov al, $00
0555   01DB             fdc_l9:
0556   01DB F7            stosb
0557   01DC 7E            dec c
0558   01DD C7 DB 01      jnz fdc_l9
0559   01E0             ; FB data address mark
0560   01E0 19 FB         mov al, $fb
0561   01E2             fdc_l10:
0562   01E2 F7            stosb
0563   01E3             ; 128 bytes sector data
0564   01E3 38 80 00      mov c, 128
0565   01E6 19 E5         mov al, $E5
0566   01E8             fdc_l11:
0567   01E8 F7            stosb
0568   01E9 7E            dec c
0569   01EA C7 E8 01      jnz fdc_l11
0570   01ED             ; 2 crc's
0571   01ED             fdc_l12:
0572   01ED 19 F7         mov al, $f7
0573   01EF F7            stosb
0574   01F0             ; 10 * $FF
0575   01F0 38 0A 00      mov c, 10
0576   01F3 19 FF         mov al, $ff
0577   01F5             fdc_l13:
0578   01F5 F7            stosb
0579   01F6 7E            dec c
0580   01F7 C7 F5 01      jnz fdc_l13
0581   01FA             ; check whether we did this 16 times
0582   01FA 79            inc d
0583   01FB C5 11 00      cmp d, 17
0584   01FE C7 B1 01      jne fdc_inner_loop
0585   0201             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0586   0201 38 F4 01      mov c, 500
0587   0204 19 FF         mov al, $ff
0588   0206             fdc_format_footer:
0589   0206             fdc_footer_drq_loop:
0590   0206 F7            stosb
0591   0207 7E            dec c
0592   0208 C7 06 02      jnz fdc_footer_drq_loop
0593   020B 09            ret
0594   020C             
0595   020C             ; fetch is 2 cycles long when 'display_reg_load' is false.
0596   020C             ; 64us amounts to 160 cycles of the 2.5mhz clock
0597   020C             ; call u16 is 14 cycles long
0598   020C             ; 160 - 5 - 14 = 
0599   020C             fdc_wait_64us:
0600   020C 3A 0D         mov cl, 13                       ; 5 cycles
0601   020E             fdc_wait_64_loop:
0602   020E 81            dec cl                           ; 3 cycles
0603   020F C7 0E 02      jnz fdc_wait_64_loop             ; 8 cycles
0604   0212 09            ret
0605   0213             
0606   0213             ; ------------------------------------------------------------------------------------------------------------------;
0607   0213             ; system syscalls
0608   0213             ; ------------------------------------------------------------------------------------------------------------------;
0609   0213             system_jmptbl:
0610   0213 49 02         .dw system_uname
0611   0215 50 02         .dw system_whoami
0612   0217 23 02         .dw system_setparam
0613   0219 26 02         .dw system_bootloader_install
0614   021B 21 02         .dw system_getparam
0615   021D             syscall_system:
0616   021D FD 0A 13 02   jmp [system_jmptbl + al]
0617   0221             
0618   0221             ; param register address in register d
0619   0221             ; param value in register bl
0620   0221             system_getparam:
0621   0221 32            mov bl, [d]
0622   0222 06            sysret
0623   0223             
0624   0223             ; param register address in register d
0625   0223             ; param value in register bl
0626   0223             system_setparam:
0627   0223 FD 3E         mov [d], bl
0628   0225 06            sysret
0629   0226             
0630   0226             ; kernel LBA address in 'b'
0631   0226             system_bootloader_install:
0632   0226 D8            push b
0633   0227 26 00 00      mov b, 0
0634   022A 38 00 00      mov c, 0
0635   022D 22 01         mov ah, $01                 ; 1 sector
0636   022F 3B 0E 25      mov d, transient_area
0637   0232 07 4D 05      call ide_read_sect          ; read sector
0638   0235 E5            pop b
0639   0236 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0640   023A 26 00 00      mov b, 0
0641   023D 38 00 00      mov c, 0
0642   0240 22 01         mov ah, $01                 ; 1 sector
0643   0242 3B 0E 25      mov d, transient_area
0644   0245 07 73 05      call ide_write_sect         ; write sector
0645   0248 06            sysret
0646   0249             
0647   0249             system_uname:
0648   0249 3B BE 17      mov d, s_uname
0649   024C 07 77 12      call _puts
0650   024F 06            sysret
0651   0250             
0652   0250             system_whoami:
0653   0250 06            sysret
0654   0251             
0655   0251             ; reboot system
0656   0251             syscall_reboot:
0657   0251 FD D7 FF FF   push word $ffff 
0658   0255 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0659   0258 FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0660   025C 06            sysret
0661   025D             
0662   025D             ;------------------------------------------------------------------------------------------------------;;
0663   025D             ; switch to another process
0664   025D             ; inputs:
0665   025D             ; al = new process number
0666   025D             ;------------------------------------------------------------------------------------------------------;;
0667   025D             syscall_resume_proc:
0668   025D FD 78         mov g, a                            ; save the process number
0669   025F 4B            pusha                               ; save all registers into kernel stack
0670   0260 22 00         mov ah, 0
0671   0262 1D A8 17      mov al, [active_proc_index]
0672   0265 FD 99         shl a              ; x2
0673   0267 B7 E5 0F      mov a, [proc_table_convert + a]     ; get process state start index
0674   026A 4F            mov di, a
0675   026B 48            mov a, sp
0676   026C 77            inc a
0677   026D 4D            mov si, a
0678   026E 38 14 00      mov c, 20
0679   0271 FD F5         rep movsb                           ; save process state!
0680   0273             ; restore kernel stack position to point before interrupt arrived
0681   0273 51 14 00      add sp, 20
0682   0276             ; now load the new process number!
0683   0276 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0684   0278 3D A8 17      mov [active_proc_index], al         ; set new active proc
0685   027B             ; calculate lut entry for next process
0686   027B 22 00         mov ah, 0
0687   027D FD 99         shl a                               ; x2
0688   027F B7 E5 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0689   0282 4D            mov si, a                           ; source is proc state block
0690   0283 48            mov a, sp
0691   0284 5F 13 00      sub a, 19
0692   0287 4F            mov di, a                           ; destination is kernel stack
0693   0288             ; restore sp
0694   0288 7D            dec a
0695   0289 47            mov sp, a
0696   028A 38 14 00      mov c, 20
0697   028D FD F5         rep movsb
0698   028F             ; set vm process
0699   028F 1D A8 17      mov al, [active_proc_index]
0700   0292 01            setptb
0701   0293 4C            popa
0702   0294 06            sysret
0703   0295             
0704   0295             ;------------------------------------------------------------------------------------------------------;;
0705   0295             ; list processes
0706   0295             ;------------------------------------------------------------------------------------------------------;;
0707   0295             syscall_list_procs:
0708   0295 3B DF 17      mov d, s_ps_header
0709   0298 07 77 12      call _puts
0710   029B 3B 7F 1A      mov d, proc_availab_table + 1
0711   029E 38 01 00      mov c, 1
0712   02A1             list_procs_l0:  
0713   02A1 BD 01         cmp byte[d], 1
0714   02A3 C7 C7 02      jne list_procs_next
0715   02A6 2D            mov b, d
0716   02A7 61 7E 1A      sub b, proc_availab_table
0717   02AA FD 9F 05      shl b, 5
0718   02AD DA            push d
0719   02AE D8            push b
0720   02AF 28            mov b, c
0721   02B0 07 17 13      call print_u8x
0722   02B3 22 20         mov ah, ' '
0723   02B5 07 4B 11      call _putchar
0724   02B8 07 4B 11      call _putchar
0725   02BB E5            pop b
0726   02BC 74            mov d, b
0727   02BD 58 8E 1A      add d, proc_names
0728   02C0 07 77 12      call _puts
0729   02C3 07 24 12      call printnl
0730   02C6 E7            pop d
0731   02C7             list_procs_next:
0732   02C7 79            inc d
0733   02C8 78            inc c
0734   02C9 C2 09 00      cmp c, 9
0735   02CC C7 A1 02      jne list_procs_l0
0736   02CF             list_procs_end:
0737   02CF 06            sysret
0738   02D0             
0739   02D0             ; ------------------------------------------------------------------------------------------------------------------;
0740   02D0             ; exceptions code block
0741   02D0             ; ------------------------------------------------------------------------------------------------------------------;
0742   02D0             ; privilege exception
0743   02D0             ; ------------------------------------------------------------------------------------------------------------------;
0744   02D0             trap_privilege:
0745   02D0 0A 51 02      jmp syscall_reboot
0746   02D3 DA            push d
0747   02D4 3B 2E 18      mov d, s_priviledge
0748   02D7 07 77 12      call _puts
0749   02DA E7            pop d
0750   02DB 06            sysret
0751   02DC             
0752   02DC             ; ------------------------------------------------------------------------------------------------------------------;
0753   02DC             ; breakpoint
0754   02DC             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0755   02DC             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0756   02DC             ; ------------------------------------------------------------------------------------------------------------------;
0757   02DC             syscall_break:
0758   02DC 4B            pusha
0759   02DD             syscall_break_prompt:
0760   02DD 3B 97 03      mov d, s_break1
0761   02E0 07 77 12      call _puts
0762   02E3 07 24 12      call printnl
0763   02E6 07 79 13      call scan_u16d
0764   02E9 AF 00 00      cmp a, 0
0765   02EC C6 F7 02      je syscall_break_regs
0766   02EF AF 01 00      cmp a, 1
0767   02F2 C6 1A 03      je syscall_break_mem
0768   02F5             syscall_break_end:  
0769   02F5 4C            popa
0770   02F6 06            sysret
0771   02F7             syscall_break_regs:
0772   02F7 48            mov a, sp
0773   02F8 53 0E 00      add a, 14               ; back-track 7 registers
0774   02FB 3C            mov d, a
0775   02FC 3A 07         mov cl, 7
0776   02FE             syscall_regs_l0:
0777   02FE 2A            mov b, [d]
0778   02FF FD AB         swp b
0779   0301 07 D3 12      call print_u16x         ; print register value
0780   0304 07 24 12      call printnl
0781   0307 63 02 00      sub d, 2
0782   030A 71 01         sub cl, 1
0783   030C C3 00         cmp cl, 0
0784   030E C7 FE 02      jne syscall_regs_l0
0785   0311 0A DD 02      jmp syscall_break_prompt
0786   0314 07 24 12      call printnl
0787   0317 0A DD 02      jmp syscall_break_prompt
0788   031A             syscall_break_mem:
0789   031A 07 24 12      call printnl
0790   031D 07 F5 12      call scan_u16x
0791   0320 4D            mov si, a               ; data source from user space
0792   0321 FD 4F 0E 23   mov di, scrap_sector    ; destination in kernel space
0793   0325 38 00 02      mov c, 512
0794   0328 04            load                    ; transfer data to kernel space!
0795   0329 3B 0E 23      mov d, scrap_sector     ; dump pointer in d
0796   032C 38 00 00      mov c, 0
0797   032F             dump_loop:
0798   032F 84            mov al, cl
0799   0330 87 0F         and al, $0f
0800   0332 C6 80 03      jz print_base
0801   0335             back:
0802   0335 1E            mov al, [d]             ; read byte
0803   0336 2F            mov bl, al
0804   0337 07 17 13      call print_u8x
0805   033A 10 00 20      mov a, $2000
0806   033D 05 03         syscall sys_io          ; space
0807   033F 84            mov al, cl
0808   0340 87 0F         and al, $0f
0809   0342 B9 0F         cmp al, $0f
0810   0344 C6 55 03      je print_ascii
0811   0347             back1:
0812   0347 79            inc d
0813   0348 78            inc c
0814   0349 C2 00 02      cmp c, 512
0815   034C C7 2F 03      jne dump_loop
0816   034F 07 24 12      call printnl
0817   0352 0A DD 02      jmp syscall_break_prompt  ; go to syscall_break return point
0818   0355             print_ascii:
0819   0355 10 00 20      mov a, $2000
0820   0358 05 03         syscall sys_io
0821   035A 63 10 00      sub d, 16
0822   035D 26 10 00      mov b, 16
0823   0360             print_ascii_l:
0824   0360 79            inc d
0825   0361 1E            mov al, [d]               ; read byte
0826   0362 B9 20         cmp al, $20
0827   0364 C8 6C 03      jlu dot
0828   0367 B9 7E         cmp al, $7e
0829   0369 D0 74 03      jleu ascii
0830   036C             dot:
0831   036C 10 00 2E      mov a, $2e00
0832   036F 05 03         syscall sys_io
0833   0371 0A 79 03      jmp ascii_continue
0834   0374             ascii:
0835   0374 23            mov ah, al
0836   0375 19 00         mov al, 0
0837   0377 05 03         syscall sys_io
0838   0379             ascii_continue:
0839   0379 FD A9 60 03   loopb print_ascii_l
0840   037D 0A 47 03      jmp back1
0841   0380             print_base:
0842   0380 07 24 12      call printnl
0843   0383 2D            mov b, d
0844   0384 61 0E 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0845   0387 07 D3 12      call print_u16x          ; display row
0846   038A 10 00 3A      mov a, $3a00
0847   038D 05 03         syscall sys_io
0848   038F 10 00 20      mov a, $2000
0849   0392 05 03         syscall sys_io
0850   0394 0A 35 03      jmp back
0851   0397             
0852   0397             s_break1:  
0853   0397 0A 64 65 62   .db "\ndebugger entry point.\n"
0853   039B 75 67 67 65 
0853   039F 72 20 65 6E 
0853   03A3 74 72 79 20 
0853   03A7 70 6F 69 6E 
0853   03AB 74 2E 0A 
0854   03AE 30 2E 20 73   .db "0. show registers\n"
0854   03B2 68 6F 77 20 
0854   03B6 72 65 67 69 
0854   03BA 73 74 65 72 
0854   03BE 73 0A 
0855   03C0 31 2E 20 73   .db "1. show 512b ram block\n"
0855   03C4 68 6F 77 20 
0855   03C8 35 31 32 62 
0855   03CC 20 72 61 6D 
0855   03D0 20 62 6C 6F 
0855   03D4 63 6B 0A 
0856   03D7 32 2E 20 63   .db "2. continue execution", 0
0856   03DB 6F 6E 74 69 
0856   03DF 6E 75 65 20 
0856   03E3 65 78 65 63 
0856   03E7 75 74 69 6F 
0856   03EB 6E 00 
0857   03ED             
0858   03ED             ; ------------------------------------------------------------------------------------------------------------------;
0859   03ED             ; divide by zero exception
0860   03ED             ; ------------------------------------------------------------------------------------------------------------------;
0861   03ED             trap_div_zero:
0862   03ED D7            push a
0863   03EE DA            push d
0864   03EF E1            pushf
0865   03F0 3B 45 18      mov d, s_divzero
0866   03F3 07 77 12      call _puts
0867   03F6 EE            popf
0868   03F7 E7            pop d
0869   03F8 E4            pop a
0870   03F9 06            sysret ; enable interrupts
0871   03FA             
0872   03FA             ; ------------------------------------------------------------------------------------------------------------------;
0873   03FA             ; undefined opcode exception
0874   03FA             ; ------------------------------------------------------------------------------------------------------------------;
0875   03FA             trap_undef_opcode:
0876   03FA 06            sysret
0877   03FB             
0878   03FB             ; ------------------------------------------------------------------------------------------------------------------;
0879   03FB             ; real-time clock services syscall
0880   03FB             ; rtc i/o bank = ffa0 to ffaf
0881   03FB             ; ffa0 to ffa7 is scratch ram
0882   03FB             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0883   03FB             ; al = 0..6 -> get
0884   03FB             ; al = 7..d -> set
0885   03FB             ; ------------------------------------------------------------------------------------------------------------------;
0886   03FB             syscall_rtc:
0887   03FB DB            push al
0888   03FC DA            push d
0889   03FD B9 06         cmp al, 6
0890   03FF D1 14 04      jgu syscall_rtc_set
0891   0402             syscall_rtc_get:
0892   0402 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0893   0404 22 FF         mov ah, $ff    
0894   0406 3C            mov d, a                ; get to ffa9 + offset
0895   0407 F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0896   040B 1E            mov al, [d]             ; get data
0897   040C F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0898   0410 23            mov ah, al
0899   0411 E7            pop d
0900   0412 E8            pop al
0901   0413 06            sysret
0902   0414             syscall_rtc_set:
0903   0414 DD            push bl
0904   0415 99            mov bl, ah              ; set data aside
0905   0416 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0906   0418 22 FF         mov ah, $ff    
0907   041A 3C            mov d, a                ; get to ffa9 + offset
0908   041B 1B            mov al, bl              ; get data back
0909   041C F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0910   0420 3E            mov [d], al             ; set data
0911   0421 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0912   0425 EA            pop bl
0913   0426 E7            pop d
0914   0427 E8            pop al
0915   0428 06            sysret
0916   0429             
0917   0429             datetime_serv_tbl:
0918   0429 31 04         .dw print_date
0919   042B A5 04         .dw set_date
0920   042D             syscall_datetime:
0921   042D FD 0A 29 04   jmp [datetime_serv_tbl + al]      
0922   0431             print_date:
0923   0431 10 00 0D      mov a, $0d00           ; print carriage return char
0924   0434 19 03         mov al, 3
0925   0436 05 01         syscall sys_rtc        ; get week
0926   0438 1A            mov al, ah
0927   0439 22 00         mov ah, 0
0928   043B FD 9D 02      shl a, 2          
0929   043E 3B CF 18      mov d, s_week
0930   0441 59            add d, a
0931   0442 07 77 12      call _puts
0932   0445 10 00 20      mov a, $2000
0933   0448 05 03         syscall sys_io         ; display ' '
0934   044A 19 04         mov al, 4
0935   044C 05 01         syscall sys_rtc        ; get day
0936   044E 99            mov bl, ah
0937   044F 07 17 13      call print_u8x
0938   0452 10 00 20      mov a, $2000
0939   0455 05 03         syscall sys_io         ; display ' '
0940   0457             ; there is a problem with the month displaying
0941   0457             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0942   0457             ; even though it is to be understood as bcd.
0943   0457             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0944   0457 19 05         mov al, 05
0945   0459 05 01         syscall sys_rtc        ; get month
0946   045B 1A            mov al, ah
0947   045C 22 00         mov ah, 0
0948   045E FD 9D 02      shl a, 2          
0949   0461 3B 9B 18      mov d, s_months
0950   0464 59            add d, a
0951   0465 07 77 12      call _puts
0952   0468 10 00 20      mov a, $2000
0953   046B 05 03         syscall sys_io         ; display ' '
0954   046D 2E 20         mov bl, $20
0955   046F 07 17 13      call print_u8x         ; print 20 for year prefix
0956   0472 19 06         mov al, 06
0957   0474 05 01         syscall sys_rtc        ; get year
0958   0476 99            mov bl, ah
0959   0477 07 17 13      call print_u8x
0960   047A 10 00 20      mov a, $2000  
0961   047D 05 03         syscall sys_io         ; display ' '
0962   047F 19 02         mov al, 2
0963   0481 05 01         syscall sys_rtc        ; get hours
0964   0483 99            mov bl, ah
0965   0484 07 17 13      call print_u8x
0966   0487 10 00 3A      mov a, $3a00    
0967   048A 05 03         syscall sys_io         ; display ':'
0968   048C 19 01         mov al, 01
0969   048E 05 01         syscall sys_rtc        ; get minutes
0970   0490 99            mov bl, ah
0971   0491 07 17 13      call print_u8x
0972   0494 10 00 3A      mov a, $3a00  
0973   0497 05 03         syscall sys_io         ; display ':'
0974   0499 19 00         mov al, 0
0975   049B 05 01         syscall sys_rtc        ; get seconds
0976   049D 99            mov bl, ah
0977   049E 07 17 13      call print_u8x
0978   04A1 07 24 12      call printnl
0979   04A4 06            sysret
0980   04A5             set_date:
0981   04A5 3B 60 18      mov d, s_set_year
0982   04A8 07 77 12      call _puts
0983   04AB 07 62 13      call scan_u8x          ; read integer into a
0984   04AE FD 9D 08      shl a, 8               ; only al used, move to ah
0985   04B1 19 0D         mov al, 0dh            ; set rtc year
0986   04B3 05 01         syscall sys_rtc        ; set rtc
0987   04B5 3B 67 18      mov d, s_set_month
0988   04B8 07 77 12      call _puts
0989   04BB 07 62 13      call scan_u8x          ; read integer into a
0990   04BE FD 9D 08      shl a, 8               ; only al used, move to ah
0991   04C1 19 0C         mov al, 0ch            ; set rtc month
0992   04C3 05 01         syscall sys_rtc        ; set rtc
0993   04C5 3B 6F 18      mov d, s_set_day
0994   04C8 07 77 12      call _puts
0995   04CB 07 62 13      call scan_u8x          ; read integer into a
0996   04CE FD 9D 08      shl a, 8               ; only al used, move to ah
0997   04D1 19 0B         mov al, 0bh            ; set rtc month
0998   04D3 05 01         syscall sys_rtc        ; set rtc
0999   04D5 3B 75 18      mov d, s_set_week
1000   04D8 07 77 12      call _puts
1001   04DB 07 62 13      call scan_u8x          ; read integer into a
1002   04DE FD 9D 08      shl a, 8               ; only al used, move to ah
1003   04E1 19 0A         mov al, 0ah            ; set rtc month
1004   04E3 05 01         syscall sys_rtc        ; set rtc
1005   04E5 3B 7F 18      mov d, s_set_hours
1006   04E8 07 77 12      call _puts
1007   04EB 07 62 13      call scan_u8x          ; read integer into a
1008   04EE FD 9D 08      shl a, 8               ; only al used, move to ah
1009   04F1 19 09         mov al, 09h            ; set rtc month
1010   04F3 05 01         syscall sys_rtc        ; set rtc
1011   04F5 3B 87 18      mov d, s_set_minutes
1012   04F8 07 77 12      call _puts
1013   04FB 07 62 13      call scan_u8x          ; read integer into a
1014   04FE FD 9D 08      shl a, 8               ; only al used, move to ah
1015   0501 19 08         mov al, 08h            ; set rtc month
1016   0503 05 01         syscall sys_rtc        ; set rtc
1017   0505 3B 91 18      mov d, s_set_seconds
1018   0508 07 77 12      call _puts
1019   050B 07 62 13      call scan_u8x          ; read integer into a
1020   050E FD 9D 08      shl a, 8               ; only al used, move to ah
1021   0511 19 07         mov al, 07h            ; set rtc month
1022   0513 05 01         syscall sys_rtc        ; set rtc
1023   0515 06            sysret
1024   0516             
1025   0516             ; ------------------------------------------------------------------------------------------------------------------;
1026   0516             ; ide services syscall
1027   0516             ; al = option
1028   0516             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1029   0516             ; ide read/write sector
1030   0516             ; 512 bytes
1031   0516             ; user buffer pointer in d
1032   0516             ; ah = number of sectors
1033   0516             ; cb = lba bytes 3..0
1034   0516             ; ------------------------------------------------------------------------------------------------------------------;
1035   0516             ide_serv_tbl:
1036   0516 22 05         .dw ide_reset
1037   0518 36 05         .dw ide_sleep
1038   051A 45 05         .dw ide_read_sect_wrapper
1039   051C 49 05         .dw ide_write_sect_wrapper
1040   051E             syscall_ide:
1041   051E FD 0A 16 05   jmp [ide_serv_tbl + al]    
1042   0522             
1043   0522             ide_reset:      
1044   0522 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1045   0526 07 CF 05      call ide_wait                   ; wait for ide ready             
1046   0529 F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1047   052D F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1048   0531 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1049   0535 06            sysret
1050   0536             ide_sleep:
1051   0536 07 CF 05      call ide_wait                   ; wait for ide ready             
1052   0539 F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1053   053D F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1054   0541 07 CF 05      call ide_wait                   ; wait for ide ready
1055   0544 06            sysret
1056   0545             ide_read_sect_wrapper:
1057   0545 07 4D 05      call ide_read_sect
1058   0548 06            sysret
1059   0549             ide_write_sect_wrapper:
1060   0549 07 73 05      call ide_write_sect
1061   054C 06            sysret
1062   054D             ide_read_sect:
1063   054D 1A            mov al, ah
1064   054E 24            mov ah, bl
1065   054F 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1066   0552 1C            mov al, bh
1067   0553 3D D4 FF      mov [_ide_r4], al
1068   0556 12            mov a, c
1069   0557 3D D5 FF      mov [_ide_r5], al
1070   055A 1A            mov al, ah
1071   055B 87 0F         and al, %00001111
1072   055D 8B E0         or al, %11100000                ; mode lba, master
1073   055F 3D D6 FF      mov [_ide_r6], al
1074   0562             ide_read_sect_wait:
1075   0562 1D D7 FF      mov al, [_ide_r7]  
1076   0565 87 80         and al, $80                     ; busy flag
1077   0567 C7 62 05      jnz ide_read_sect_wait
1078   056A 19 20         mov al, $20
1079   056C 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1080   056F 07 99 05      call ide_read  
1081   0572 09            ret
1082   0573             ide_write_sect:
1083   0573 1A            mov al, ah
1084   0574 24            mov ah, bl
1085   0575 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1086   0578 1C            mov al, bh
1087   0579 3D D4 FF      mov [_ide_r4], al
1088   057C 12            mov a, c
1089   057D 3D D5 FF      mov [_ide_r5], al
1090   0580 1A            mov al, ah
1091   0581 87 0F         and al, %00001111
1092   0583 8B E0         or al, %11100000                ; mode lba, master
1093   0585 3D D6 FF      mov [_ide_r6], al
1094   0588             ide_write_sect_wait:
1095   0588 1D D7 FF      mov al, [_ide_r7]  
1096   058B 87 80         and al, $80                     ; busy flag
1097   058D C7 88 05      jnz ide_write_sect_wait
1098   0590 19 30         mov al, $30
1099   0592 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1100   0595 07 B4 05      call ide_write      
1101   0598 09            ret
1102   0599             
1103   0599             ;----------------------------------------------------------------------------------------------------;
1104   0599             ; read ide data
1105   0599             ; pointer in d
1106   0599             ;----------------------------------------------------------------------------------------------------;
1107   0599             ide_read:
1108   0599 DA            push d
1109   059A             ide_read_loop:
1110   059A 1D D7 FF      mov al, [_ide_r7]  
1111   059D 87 80         and al, 80h                     ; busy flag
1112   059F C7 9A 05      jnz ide_read_loop               ; wait loop
1113   05A2 1D D7 FF      mov al, [_ide_r7]
1114   05A5 87 08         and al, %00001000               ; drq flag
1115   05A7 C6 B2 05      jz ide_read_end
1116   05AA 1D D0 FF      mov al, [_ide_r0]
1117   05AD 3E            mov [d], al
1118   05AE 79            inc d
1119   05AF 0A 9A 05      jmp ide_read_loop
1120   05B2             ide_read_end:
1121   05B2 E7            pop d
1122   05B3 09            ret
1123   05B4             
1124   05B4             ;----------------------------------------------------------------------------------------------------;
1125   05B4             ; write ide data
1126   05B4             ; data pointer in d
1127   05B4             ;----------------------------------------------------------------------------------------------------;
1128   05B4             ide_write:
1129   05B4 DA            push d
1130   05B5             ide_write_loop:
1131   05B5 1D D7 FF      mov al, [_ide_r7]  
1132   05B8 87 80         and al, 80h             ; busy flag
1133   05BA C7 B5 05      jnz ide_write_loop      ; wait loop
1134   05BD 1D D7 FF      mov al, [_ide_r7]
1135   05C0 87 08         and al, %00001000       ; drq flag
1136   05C2 C6 CD 05      jz ide_write_end
1137   05C5 1E            mov al, [d]
1138   05C6 3D D0 FF      mov [_ide_r0], al
1139   05C9 79            inc d 
1140   05CA 0A B5 05      jmp ide_write_loop
1141   05CD             ide_write_end:
1142   05CD E7            pop d
1143   05CE 09            ret
1144   05CF             
1145   05CF             ;----------------------------------------------------------------------------------------------------;
1146   05CF             ; wait for ide to be ready
1147   05CF             ;----------------------------------------------------------------------------------------------------;
1148   05CF             ide_wait:
1149   05CF 1D D7 FF      mov al, [_ide_r7]  
1150   05D2 87 80         and al, 80h        ; busy flag
1151   05D4 C7 CF 05      jnz ide_wait
1152   05D7 09            ret
1153   05D8             
1154   05D8             ;----------------------------------------------------------------------------------------------------;
1155   05D8             ; io syscall
1156   05D8             ;----------------------------------------------------------------------------------------------------;
1157   05D8             ; baud  divisor
1158   05D8             ; 50    2304
1159   05D8             ; 110   1047
1160   05D8             ; 300    384
1161   05D8             ; 600    192
1162   05D8             ; 1200    96
1163   05D8             ; 9600    12
1164   05D8             ; 19200    6
1165   05D8             ; 38400    3
1166   05D8             syscall_io_jmp:
1167   05D8 0B 06         .dw syscall_io_putchar
1168   05DA 18 06         .dw syscall_io_getch
1169   05DC E2 05         .dw syscall_io_uart_setup
1170   05DE             syscall_io:
1171   05DE FD 0A D8 05   jmp [syscall_io_jmp + al]
1172   05E2             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1173   05E2             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1174   05E2             ; buffer, the transmitter holding register, or the interrupt enable register.
1175   05E2             syscall_io_uart_setup:
1176   05E2 1D A2 17      mov al, [sys_uart0_lcr]
1177   05E5 8B 80         or al, $80                ; set dlab access bit
1178   05E7 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1179   05EA 1D A5 17      mov al, [sys_uart0_div0]
1180   05ED 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1181   05F0 1D A6 17      mov al, [sys_uart0_div1]
1182   05F3 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1183   05F6             
1184   05F6 1D A2 17      mov al, [sys_uart0_lcr]
1185   05F9 87 7F         and al, $7f               ; clear dlab access bit 
1186   05FB 3D 83 FF      mov [_uart0_lcr], al
1187   05FE 1D A3 17      mov al, [sys_uart0_inten]
1188   0601 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1189   0604 1D A4 17      mov al, [sys_uart0_fifoen]
1190   0607 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1191   060A 06            sysret
1192   060B             
1193   060B             ; char in ah
1194   060B             syscall_io_putchar:
1195   060B             syscall_io_putchar_l0:
1196   060B 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1197   060E 87 20         and al, $20
1198   0610 C6 0B 06      jz syscall_io_putchar_l0    
1199   0613 1A            mov al, ah
1200   0614 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1201   0617 06            sysret
1202   0618             
1203   0618             ; char in ah
1204   0618             ; al = sucess code
1205   0618             syscall_io_getch:
1206   0618 D8            push b
1207   0619 DA            push d
1208   061A FD 0C         sti
1209   061C             syscall_io_getch_l0:  
1210   061C 14 AF 17      mov a, [fifo_out]
1211   061F 29 AD 17      mov b, [fifo_in]
1212   0622 B0            cmp a, b
1213   0623 C6 1C 06      je syscall_io_getch_l0
1214   0626 3C            mov d, a
1215   0627 77            inc a
1216   0628 AF 0E 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1217   062B C7 31 06      jne syscall_io_getch_cont
1218   062E 10 0E 1F      mov a, fifo  
1219   0631             syscall_io_getch_cont:  
1220   0631 42 AF 17      mov [fifo_out], a             ; update fifo pointer
1221   0634 1E            mov al, [d]                   ; get char
1222   0635 23            mov ah, al
1223   0636 1D A1 17      mov al, [sys_echo_on]
1224   0639 B9 01         cmp al, 1
1225   063B C7 4A 06      jne syscall_io_getch_noecho 
1226   063E             ; here we just echo the char back to the console
1227   063E             syscall_io_getch_echo_l0:
1228   063E 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1229   0641 87 20         and al, $20                 ; isolate transmitter empty
1230   0643 C6 3E 06      jz syscall_io_getch_echo_l0
1231   0646 1A            mov al, ah
1232   0647 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1233   064A             syscall_io_getch_noecho:
1234   064A 19 01         mov al, 1                    ; al = 1 means a char successfully received
1235   064C E7            pop d
1236   064D E5            pop b
1237   064E 06            sysret
1238   064F             
1239   064F             ;------------------------------------------------------------------------------------------------------;
1240   064F             ; file system data
1241   064F             ;------------------------------------------------------------------------------------------------------;
1242   064F             ; infor for : ide services interrupt
1243   064F             ; ide read/write 512-byte sector
1244   064F             ; al = option
1245   064F             ; user buffer pointer in d
1246   064F             ; ah = number of sectors
1247   064F             ; cb = lba bytes 3..0  
1248   064F             ;------------------------------------------------------------------------------------------------------;
1249   064F             ; file system data structure
1250   064F             ;------------------------------------------------------------------------------------------------------;
1251   064F             ; for a directory we have the header first, followed by metadata
1252   064F             ; header 1 sector (512 bytes)
1253   064F             ; metadata 1 sector (512 bytes)
1254   064F             ; header entries:
1255   064F             ; filename (64)
1256   064F             ; parent dir lba (2) -  to be used for faster backwards navigation...
1257   064F             ;
1258   064F             ; metadata entries:
1259   064F             ; filename (24)
1260   064F             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1261   064F             ; lba (2)
1262   064F             ; size (2)
1263   064F             ; day (1)
1264   064F             ; month (1)
1265   064F             ; year (1)
1266   064F             ; packet size = 32 bytes
1267   064F             ;
1268   064F             ; first directory on disk is the root directory '/'
1269   064F             file_system_jmptbl:
1270   064F BA 06         .dw fs_mkfs                   ; 0
1271   0651 00 00         .dw 0                         ; 1
1272   0653 1C 07         .dw fs_mkdir                  ; 2
1273   0655 95 0A         .dw fs_cd                     ; 3
1274   0657 9C 0A         .dw fs_ls                     ; 4
1275   0659 87 0B         .dw fs_mktxt                  ; 5
1276   065B 52 0C         .dw fs_mkbin                  ; 6
1277   065D 19 0D         .dw fs_pwd                    ; 7
1278   065F 36 0D         .dw fs_cat                    ; 8
1279   0661 92 0D         .dw fs_rmdir                  ; 9
1280   0663 EE 0D         .dw fs_rm                     ; 10
1281   0665 00 00         .dw 0                         ; 11
1282   0667 00 00         .dw 0                         ; 12
1283   0669 00 00         .dw 0                         ; 13
1284   066B C2 06         .dw fs_chmod                  ; 14
1285   066D 56 0E         .dw fs_mv                     ; 15
1286   066F BB 06         .dw fs_cd_root                ; 16
1287   0671 91 0A         .dw fs_get_curr_dirid         ; 17
1288   0673 6D 08         .dw fs_dir_id_to_path         ; 18
1289   0675 D3 08         .dw fs_path_to_dir_id_user    ; 19
1290   0677 ED 09         .dw fs_load_from_path_user    ; 20  
1291   0679 5D 09         .dw fs_filepath_exists_user   ; 21
1292   067B             
1293   067B 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1293   067F 79 73 63 61 
1293   0683 6C 6C 5F 66 
1293   0687 69 6C 65 5F 
1293   068B 73 79 73 74 
1293   068F 65 6D 20 63 
1293   0693 61 6C 6C 65 
1293   0697 64 3A 20 00 
1294   069B             syscall_file_system:
1295   069B DD            push bl
1296   069C 31 A0 17      mov bl, [sys_debug_mode]
1297   069F               ; debug block
1298   069F C1 00         cmp bl, 0
1299   06A1 EA            pop bl
1300   06A2 C6 B6 06      je syscall_filesystem_jmp
1301   06A5 DA            push d
1302   06A6 DD            push bl
1303   06A7 3B 7B 06      mov d, s_syscall_fs_dbg0
1304   06AA 07 77 12      call _puts
1305   06AD 2F            mov bl, al
1306   06AE 07 17 13      call print_u8x
1307   06B1 07 24 12      call printnl
1308   06B4 EA            pop bl
1309   06B5 E7            pop d
1310   06B6             syscall_filesystem_jmp:
1311   06B6 FD 0A 4F 06   jmp [file_system_jmptbl + al]
1312   06BA             
1313   06BA             fs_mkfs:  
1314   06BA 06            sysret  
1315   06BB               
1316   06BB             fs_cd_root:
1317   06BB 10 20 00      mov a, root_id
1318   06BE 42 B1 17      mov [current_dir_id], a      ; set current directory lba to root
1319   06C1 06            sysret  
1320   06C2             
1321   06C2             ; filename in d (userspace data)
1322   06C2             ; permission in bl
1323   06C2             fs_chmod:
1324   06C2 DD            push bl
1325   06C3 FD 4E         mov si, d
1326   06C5 FD 4F 0E 1D   mov di, user_data
1327   06C9 38 80 00      mov c, 128
1328   06CC 04            load                        ; load filename from user-space
1329   06CD 14 B1 17      mov a, [current_dir_id]
1330   06D0 77            inc a                       ; metadata sector
1331   06D1 27            mov b, a
1332   06D2 38 00 00      mov c, 0                    ; upper lba = 0
1333   06D5 22 01         mov ah, $01                  ; 1 sector
1334   06D7 3B 0E 25      mov d, transient_area
1335   06DA 07 4D 05      call ide_read_sect          ; read directory
1336   06DD FD 10         cla
1337   06DF 42 A9 17      mov [index], a              ; reset file counter
1338   06E2             fs_chmod_l1:
1339   06E2 FD 4E         mov si, d
1340   06E4 FD 4F 0E 1D   mov di, user_data
1341   06E8 07 BA 10      call _strcmp
1342   06EB C6 02 07      je fs_chmod_found_entry
1343   06EE 58 20 00      add d, 32
1344   06F1 14 A9 17      mov a, [index]
1345   06F4 77            inc a
1346   06F5 42 A9 17      mov [index], a
1347   06F8 AF 10 00      cmp a, fst_files_per_dir
1348   06FB C7 E2 06      jne fs_chmod_l1
1349   06FE EA            pop bl
1350   06FF 0A 1B 07      jmp fs_chmod_not_found
1351   0702             fs_chmod_found_entry:  
1352   0702 FD 79         mov g, b                    ; save lba
1353   0704 EA            pop bl                      ; retrieve saved permission value
1354   0705 1F 18 00      mov al, [d + 24]            ; read file permissions
1355   0708 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1356   070A 8C            or al, bl                   ; set new permissions
1357   070B 3F 18 00      mov [d + 24], al            ; write new permissions
1358   070E 38 00 00      mov c, 0
1359   0711 3B 0E 25      mov d, transient_area
1360   0714 22 01         mov ah, $01                 ; disk write 1 sect
1361   0716 FD 27         mov b, g                    ; retrieve lba
1362   0718 07 73 05      call ide_write_sect         ; write sector
1363   071B             fs_chmod_not_found:
1364   071B 06            sysret
1365   071C             
1366   071C             ;------------------------------------------------------------------------------------------------------;
1367   071C             ; create new directory
1368   071C             ;------------------------------------------------------------------------------------------------------;
1369   071C             ; search list for null name entry. add new directory to list
1370   071C             fs_mkdir:
1371   071C FD 4E         mov si, d
1372   071E FD 4F 0E 1D   mov di, user_data
1373   0722 38 00 02      mov c, 512
1374   0725 04            load                        ; load data from user-space
1375   0726 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1376   0729                                           ; when checking for null name, since root has a null name)
1377   0729 38 00 00      mov c, 0                    ; upper lba = 0
1378   072C             fs_mkdir_l1:  
1379   072C 22 01         mov ah, $01                  ; 1 sector
1380   072E 3B 0E 25      mov d, transient_area
1381   0731 07 4D 05      call ide_read_sect          ; read sector
1382   0734 BD 00         cmp byte[d], 0              ; check for null
1383   0736 C6 3F 07      je fs_mkdir_found_null
1384   0739 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1385   073C 0A 2C 07      jmp fs_mkdir_l1
1386   073F             fs_mkdir_found_null:
1387   073F             ;create header file by grabbing dir name from parameter
1388   073F D8            push b                      ; save new directory's lba
1389   0740 38 40 00      mov c, 64
1390   0743 FD 4D 0E 1D   mov si, user_data
1391   0747 FD 4F 0E 25   mov di, transient_area
1392   074B FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1393   074D 14 B1 17      mov a, [current_dir_id]
1394   0750 42 4E 25      mov [transient_area + 64], a    ; store parent directory lba
1395   0753 19 00         mov al, 0
1396   0755 FD 4F 0E 27   mov di, transient_area + 512
1397   0759 38 00 02      mov c, 512
1398   075C FD F7         rep stosb                       ; clean buffer
1399   075E 38 00 00      mov c, 0                        ; reset lba(c) to 0
1400   0761             ; write directory entry sectors
1401   0761 3B 0E 25      mov d, transient_area
1402   0764 22 02         mov ah, $02                     ; disk write, 2 sectors
1403   0766 07 73 05      call ide_write_sect             ; write sector
1404   0769             ; now we need to add the new directory to the list, inside the current directory
1405   0769 14 B1 17      mov a, [current_dir_id]
1406   076C 53 01 00      add a, 1
1407   076F 27            mov b, a                        ; metadata sector
1408   0770 38 00 00      mov c, 0
1409   0773 FD 79         mov g, b                        ; save lba
1410   0775 3B 0E 25      mov d, transient_area
1411   0778 22 01         mov ah, $01                  ; 1 sector
1412   077A 07 4D 05      call ide_read_sect              ; read metadata sector
1413   077D             fs_mkdir_l2:
1414   077D BD 00         cmp byte[d], 0
1415   077F C6 88 07      je fs_mkdir_found_null2
1416   0782 58 20 00      add d, fst_entry_size
1417   0785 0A 7D 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1418   0788             fs_mkdir_found_null2:
1419   0788 FD 4D 0E 1D   mov si, user_data
1420   078C FD 50         mov di, d
1421   078E 07 CF 10      call _strcpy                    ; copy directory name
1422   0791 58 18 00      add d, 24                       ; goto attributes
1423   0794 19 0B         mov al, %00001011               ; directory, no execute, write, read
1424   0796 3E            mov [d], al      
1425   0797 79            inc d
1426   0798 E5            pop b
1427   0799 D8            push b                          ; push lba back
1428   079A FD 43         mov [d], b                      ; save lba
1429   079C             ; set file creation date  
1430   079C 58 04 00      add d, 4
1431   079F 19 04         mov al, 4
1432   07A1 05 01         syscall sys_rtc
1433   07A3 1A            mov al, ah
1434   07A4 3E            mov [d], al                     ; set day
1435   07A5 79            inc d
1436   07A6 19 05         mov al, 5
1437   07A8 05 01         syscall sys_rtc
1438   07AA 1A            mov al, ah
1439   07AB 3E            mov [d], al                     ; set month
1440   07AC 79            inc d
1441   07AD 19 06         mov al, 6
1442   07AF 05 01         syscall sys_rtc
1443   07B1 1A            mov al, ah
1444   07B2 3E            mov [d], al                     ; set year
1445   07B3             ; write sector into disk for new directory entry
1446   07B3 FD 27         mov b, g
1447   07B5 38 00 00      mov c, 0
1448   07B8 3B 0E 25      mov d, transient_area
1449   07BB 22 01         mov ah, $01                     ; disk write, 1 sector
1450   07BD 07 73 05      call ide_write_sect             ; write sector
1451   07C0             
1452   07C0             ; after adding the new directory's information to its parent directory's list
1453   07C0             ; we need to now enter the new directory, and to it add two new directories!
1454   07C0             ; which directories do we need to add ? '..' and '.' are the directories needed.
1455   07C0             ; importantly, note that these two new directories are only entries in the list
1456   07C0             ; and do not have actual physical entries in the disk as real directories.
1457   07C0             ; i.e. they only exist as list entries in the new directory created so that
1458   07C0             ; the new directory can reference its parent and itself.
1459   07C0             ; we need to add both '..' and '.'
1460   07C0             ; this first section is for '..' and on the section below we do the same for '.'
1461   07C0 E4            pop a                         ; retrieve the new directory's lba  
1462   07C1 D7            push a                        ; and save again
1463   07C2 53 01 00      add a, 1
1464   07C5 27            mov b, a                      ; metadata sector
1465   07C6 38 00 00      mov c, 0
1466   07C9 FD 79         mov g, b                      ; save lba
1467   07CB 3B 0E 25      mov d, transient_area
1468   07CE 22 01         mov ah, $01                  ; 1 sector
1469   07D0 07 4D 05      call ide_read_sect            ; read metadata sector
1470   07D3             fs_mkdir_l3:
1471   07D3 BD 00         cmp byte[d], 0
1472   07D5 C6 DE 07      je fs_mkdir_found_null3
1473   07D8 58 20 00      add d, fst_entry_size
1474   07DB 0A D3 07      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1475   07DE             fs_mkdir_found_null3:
1476   07DE FD 4D D0 17   mov si, s_parent_dir
1477   07E2 FD 50         mov di, d
1478   07E4 07 CF 10      call _strcpy                  ; copy directory name
1479   07E7 58 18 00      add d, 24                     ; goto attributes
1480   07EA 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1481   07EC 3E            mov [d], al      
1482   07ED 79            inc d
1483   07EE 29 B1 17      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1484   07F1 FD 43         mov [d], b                    ; save lba
1485   07F3             ; set file creation date  
1486   07F3 58 04 00      add d, 4
1487   07F6 19 04         mov al, 4
1488   07F8 05 01         syscall sys_rtc
1489   07FA 1A            mov al, ah
1490   07FB 3E            mov [d], al                   ; set day
1491   07FC 79            inc d
1492   07FD 19 05         mov al, 5
1493   07FF 05 01         syscall sys_rtc
1494   0801 1A            mov al, ah
1495   0802 3E            mov [d], al                   ; set month
1496   0803 79            inc d
1497   0804 19 06         mov al, 6
1498   0806 05 01         syscall sys_rtc
1499   0808 1A            mov al, ah
1500   0809 3E            mov [d], al                   ; set year
1501   080A             ; write sector into disk for new directory entry
1502   080A FD 27         mov b, g
1503   080C 38 00 00      mov c, 0
1504   080F 3B 0E 25      mov d, transient_area
1505   0812 22 01         mov ah, $01                   ; disk write, 1 sector
1506   0814 07 73 05      call ide_write_sect           ; write sector
1507   0817             ;;;;;;;;;;;;;
1508   0817             ; like we did above for '..', we need to now add the '.' directory to the list.
1509   0817             ;------------------------------------------------------------------------------------------------------;
1510   0817 E4            pop a                         ; retrieve the new directory's lba  
1511   0818 D7            push a
1512   0819 53 01 00      add a, 1
1513   081C 27            mov b, a                      ; metadata sector
1514   081D 38 00 00      mov c, 0
1515   0820 FD 79         mov g, b                      ; save lba
1516   0822 3B 0E 25      mov d, transient_area
1517   0825 22 01         mov ah, $01                  ; 1 sector
1518   0827 07 4D 05      call ide_read_sect            ; read metadata sector
1519   082A             fs_mkdir_l4:
1520   082A BD 00         cmp byte[d], 0
1521   082C C6 35 08      je fs_mkdir_found_null4
1522   082F 58 20 00      add d, fst_entry_size
1523   0832 0A 2A 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1524   0835             fs_mkdir_found_null4:
1525   0835 FD 4D D3 17   mov si, s_current_dir
1526   0839 FD 50         mov di, d
1527   083B 07 CF 10      call _strcpy                  ; copy directory name
1528   083E 58 18 00      add d, 24                     ; goto attributes
1529   0841 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1530   0843 3E            mov [d], al      
1531   0844 79            inc d
1532   0845 E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1533   0846 FD 43         mov [d], b                    ; save lba
1534   0848             ; set file creation date  
1535   0848 58 04 00      add d, 4
1536   084B 19 04         mov al, 4
1537   084D 05 01         syscall sys_rtc
1538   084F 1A            mov al, ah
1539   0850 3E            mov [d], al                   ; set day
1540   0851 79            inc d
1541   0852 19 05         mov al, 5
1542   0854 05 01         syscall sys_rtc
1543   0856 1A            mov al, ah
1544   0857 3E            mov [d], al                   ; set month
1545   0858 79            inc d
1546   0859 19 06         mov al, 6
1547   085B 05 01         syscall sys_rtc
1548   085D 1A            mov al, ah
1549   085E 3E            mov [d], al                   ; set year
1550   085F             ; write sector into disk for new directory entry
1551   085F FD 27         mov b, g
1552   0861 38 00 00      mov c, 0
1553   0864 3B 0E 25      mov d, transient_area
1554   0867 22 01         mov ah, $01                   ; disk write, 1 sector
1555   0869 07 73 05      call ide_write_sect           ; write sector
1556   086C             fs_mkdir_end:
1557   086C 06            sysret
1558   086D             
1559   086D             ;------------------------------------------------------------------------------------------------------;
1560   086D             ; get path from a given directory dirid
1561   086D             ; pseudo code:
1562   086D             ;  fs_dir_id_to_path(int dirid, char *d){
1563   086D             ;    if(dirid == 0){
1564   086D             ;      reverse path in d;
1565   086D             ;      return;
1566   086D             ;    }
1567   086D             ;    else{
1568   086D             ;      copy directory name to end of d;
1569   086D             ;      add '/' to end of d;
1570   086D             ;      parentid = get parent directory id;
1571   086D             ;      fs_dir_id_to_path(parentid, d);
1572   086D             ;    }
1573   086D             ;  }
1574   086D             ; a = dirid
1575   086D             ; d = generated path string pointer
1576   086D             ;------------------------------------------------------------------------------------------------------;
1577   086D             ; sample path: /usr/bin
1578   086D             fs_dir_id_to_path:
1579   086D 3B 8E 1C      mov d, filename
1580   0870 19 00         mov al, 0
1581   0872 3E            mov [d], al                     ; initialize path string 
1582   0873 14 B1 17      mov a, [current_dir_id]
1583   0876 07 83 08      call fs_dir_id_to_path_e0
1584   0879 3B 8E 1C      mov d, filename
1585   087C 07 63 10      call _strrev
1586   087F 07 77 12      call _puts
1587   0882 06            sysret
1588   0883             fs_dir_id_to_path_e0:
1589   0883 07 A2 08      call get_dirname_from_dirid
1590   0886 FD 4D D5 17   mov si, s_fslash
1591   088A FD 50         mov di, d
1592   088C 07 DD 10      call _strcat                    ; add '/' to end of path
1593   088F AF 20 00      cmp a, root_id               ; check if we are at the root directory
1594   0892 C6 A1 08      je fs_dir_id_to_path_root
1595   0895 07 BF 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1596   0898 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1597   089B C6 A1 08      je fs_dir_id_to_path_root
1598   089E 07 83 08      call fs_dir_id_to_path_e0     ; recursively call itself
1599   08A1             fs_dir_id_to_path_root:
1600   08A1 09            ret
1601   08A2             
1602   08A2             ;------------------------------------------------------------------------------------------------------;
1603   08A2             ; in_puts:
1604   08A2             ; a = directory id
1605   08A2             ; out_puts:
1606   08A2             ; d = pointer to directory name string
1607   08A2             ;------------------------------------------------------------------------------------------------------;
1608   08A2             get_dirname_from_dirid:
1609   08A2 D7            push a
1610   08A3 D8            push b
1611   08A4 DA            push d
1612   08A5 27            mov b, a
1613   08A6 38 00 00      mov c, 0                      ; upper lba = 0
1614   08A9 22 01         mov ah, $01                  ; 1 sector
1615   08AB 3B 0E 23      mov d, transient_area - 512
1616   08AE 07 4D 05      call ide_read_sect            ; read directory
1617   08B1 07 63 10      call _strrev                  ; reverse dir name before copying
1618   08B4 FD 4E         mov si, d
1619   08B6 E7            pop d                         ; destination address = d value pushed at beginning
1620   08B7 FD 50         mov di, d
1621   08B9 07 DD 10      call _strcat                  ; copy filename to d
1622   08BC E5            pop b
1623   08BD E4            pop a
1624   08BE 09            ret
1625   08BF             
1626   08BF             ;------------------------------------------------------------------------------------------------------;
1627   08BF             ; in_puts:
1628   08BF             ; a = directory id
1629   08BF             ; out_puts:
1630   08BF             ; a = parent directory id
1631   08BF             ;------------------------------------------------------------------------------------------------------;
1632   08BF             get_parentid_from_dirid:
1633   08BF D8            push b
1634   08C0 DA            push d
1635   08C1 27            mov b, a
1636   08C2 38 00 00      mov c, 0                      ; upper lba = 0
1637   08C5 22 01         mov ah, $01                  ; 1 sector
1638   08C7 3B 0E 23      mov d, transient_area - 512
1639   08CA 07 4D 05      call ide_read_sect            ; read directory
1640   08CD 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1641   08D0 E7            pop d
1642   08D1 E5            pop b
1643   08D2 09            ret
1644   08D3             
1645   08D3             ;------------------------------------------------------------------------------------------------------;
1646   08D3             ; get dirid from a given path string
1647   08D3             ; in_puts:
1648   08D3             ; d = path pointer 
1649   08D3             ; out_puts:
1650   08D3             ; a = dirid
1651   08D3             ; if dir non existent, a = ffff (fail code)
1652   08D3             ; /usr/local/bin    - absolute
1653   08D3             ; local/bin/games    - relative
1654   08D3             ;------------------------------------------------------------------------------------------------------;
1655   08D3             fs_path_to_dir_id_user:
1656   08D3 FD 4E         mov si, d
1657   08D5 FD 4F 0E 1D   mov di, user_data
1658   08D9 38 00 02      mov c, 512
1659   08DC 04            load
1660   08DD 07 E1 08      call get_dirid_from_path
1661   08E0 06            sysret
1662   08E1             get_dirid_from_path:
1663   08E1 26 0E 1D      mov b, user_data
1664   08E4 FD 42 9C 16   mov [prog], b                  ; token pointer set to path string
1665   08E8 07 FD 14      call get_token
1666   08EB 31 9F 16      mov bl, [tok]
1667   08EE C1 01         cmp bl, tok_fslash
1668   08F0 C6 FC 08      je get_dirid_from_path_abs 
1669   08F3 14 B1 17      mov a, [current_dir_id]
1670   08F6 07 83 16      call _putback
1671   08F9 0A FF 08      jmp get_dirid_from_path_e0
1672   08FC             get_dirid_from_path_abs:
1673   08FC 10 20 00      mov a, root_id
1674   08FF             get_dirid_from_path_e0:
1675   08FF 07 FD 14      call get_token
1676   0902 31 9E 16      mov bl, [toktyp]
1677   0905 C1 00         cmp bl, toktyp_identifier
1678   0907 C7 58 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1679   090A             
1680   090A FD 4D A0 16   mov si, tokstr
1681   090E FD 4F 8E 1C   mov di, filename
1682   0912 07 CF 10      call _strcpy        
1683   0915 77            inc a                         ; metadata sector
1684   0916 27            mov b, a
1685   0917 38 00 00      mov c, 0                      ; upper lba = 0
1686   091A 22 01         mov ah, $01                  ; 1 sector
1687   091C 3B 0E 25      mov d, transient_area
1688   091F 07 4D 05      call ide_read_sect            ; read directory
1689   0922 FD 10         cla
1690   0924 42 A9 17      mov [index], a
1691   0927             get_dirid_from_path_l1:
1692   0927 FD 4E         mov si, d
1693   0929 FD 4F 8E 1C   mov di, filename
1694   092D 07 BA 10      call _strcmp
1695   0930 C6 46 09      je get_dirid_from_path_name_equal  
1696   0933 58 20 00      add d, 32
1697   0936 14 A9 17      mov a, [index]
1698   0939 77            inc a
1699   093A 42 A9 17      mov [index], a
1700   093D AF 10 00      cmp a, fst_files_per_dir
1701   0940 C6 59 09      je get_dirid_from_path_fail
1702   0943 0A 27 09      jmp get_dirid_from_path_l1
1703   0946             get_dirid_from_path_name_equal:
1704   0946 58 19 00      add d, 25           
1705   0949 15            mov a, [d]                    ; set result register a = dirid
1706   094A 07 FD 14      call get_token
1707   094D 31 9F 16      mov bl, [tok]
1708   0950 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1709   0952 C6 FF 08      je get_dirid_from_path_e0
1710   0955 07 83 16      call _putback
1711   0958             get_dirid_from_path_end:
1712   0958 09            ret
1713   0959             get_dirid_from_path_fail:
1714   0959 10 FF FF      mov a, $ffff
1715   095C 09            ret
1716   095D             
1717   095D             
1718   095D             ;------------------------------------------------------------------------------------------------------;
1719   095D             ; check if file exists by a given path string
1720   095D             ; in_puts:
1721   095D             ; d = path pointer 
1722   095D             ; outputs:
1723   095D             ; a = success code, if file exists gives lba, else, give 0
1724   095D             ; /usr/local/bin/ed
1725   095D             ;------------------------------------------------------------------------------------------------------;
1726   095D             fs_filepath_exists_user:
1727   095D FD 4E         mov si, d
1728   095F FD 4F 0E 1D   mov di, user_data
1729   0963 38 00 02      mov c, 512
1730   0966 04            load
1731   0967 07 6B 09      call file_exists_by_path
1732   096A 06            sysret
1733   096B             file_exists_by_path:
1734   096B 26 0E 1D      mov b, user_data
1735   096E FD 42 9C 16   mov [prog], b                   ; token pointer set to path string
1736   0972 07 FD 14      call get_token
1737   0975 31 9F 16      mov bl, [tok]
1738   0978 C1 01         cmp bl, tok_fslash
1739   097A C6 86 09      je  file_exists_by_path_abs
1740   097D 14 B1 17      mov a, [current_dir_id]
1741   0980 07 83 16      call _putback
1742   0983 0A 89 09      jmp file_exists_by_path_e0
1743   0986             file_exists_by_path_abs:
1744   0986 10 20 00      mov a, root_id
1745   0989             file_exists_by_path_e0:
1746   0989 07 FD 14      call get_token
1747   098C 31 9E 16      mov bl, [toktyp]
1748   098F C1 00         cmp bl, toktyp_identifier
1749   0991 C7 E9 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1750   0994 FD 4D A0 16   mov si, tokstr
1751   0998 FD 4F 8E 1C   mov di, filename
1752   099C 07 CF 10      call _strcpy        
1753   099F 77            inc a                           ; metadata sector
1754   09A0 27            mov b, a
1755   09A1 38 00 00      mov c, 0                        ; upper lba = 0
1756   09A4 22 01         mov ah, $01                  ; 1 sector
1757   09A6 3B 0E 25      mov d, transient_area
1758   09A9 07 4D 05      call ide_read_sect              ; read directory
1759   09AC FD 10         cla
1760   09AE 42 A9 17      mov [index], a
1761   09B1             file_exists_by_path_l1:
1762   09B1 FD 4E         mov si, d
1763   09B3 FD 4F 8E 1C   mov di, filename
1764   09B7 07 BA 10      call _strcmp
1765   09BA C6 D0 09      je   file_exists_by_path_name_equal
1766   09BD 58 20 00      add d, 32
1767   09C0 14 A9 17      mov a, [index]
1768   09C3 77            inc a
1769   09C4 42 A9 17      mov [index], a
1770   09C7 AF 10 00      cmp a, fst_files_per_dir
1771   09CA C6 E9 09      je file_exists_by_path_end
1772   09CD 0A B1 09      jmp file_exists_by_path_l1
1773   09D0             file_exists_by_path_name_equal:
1774   09D0 33 18 00      mov bl, [d + 24]
1775   09D3 FD 87 38      and bl, %00111000               ; directory flag
1776   09D6 C1 08         cmp bl, %00001000               ; is dir?
1777   09D8 C6 DF 09      je file_exists_by_path_isdir;
1778   09DB             ; entry is a file
1779   09DB 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1780   09DE 09            ret
1781   09DF             file_exists_by_path_isdir:
1782   09DF 58 19 00      add d, 25           
1783   09E2 15            mov a, [d]                      ; set result register a = dirid
1784   09E3 07 FD 14      call get_token
1785   09E6 0A 89 09      jmp file_exists_by_path_e0
1786   09E9             file_exists_by_path_end:
1787   09E9 10 00 00      mov a, 0                        ; return 0 because file was not found
1788   09EC 09            ret
1789   09ED             
1790   09ED             ;------------------------------------------------------------------------------------------------------;
1791   09ED             ; load file data from a given path string
1792   09ED             ; inputs:
1793   09ED             ; d = path pointer 
1794   09ED             ; di = userspace program data destination
1795   09ED             ; /usr/local/bin/ed
1796   09ED             ; ./ed
1797   09ED             ;------------------------------------------------------------------------------------------------------;
1798   09ED             fs_load_from_path_user:
1799   09ED E3            push di
1800   09EE FD 4E         mov si, d
1801   09F0 FD 4F 0E 1D   mov di, user_data
1802   09F4 38 00 02      mov c, 512
1803   09F7 04            load
1804   09F8 07 05 0A      call loadfile_from_path
1805   09FB F0            pop di
1806   09FC FD 4D 0E 25   mov si, transient_area
1807   0A00 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1808   0A03 03            store
1809   0A04 06            sysret
1810   0A05             loadfile_from_path:
1811   0A05 26 0E 1D      mov b, user_data
1812   0A08 FD 42 9C 16   mov [prog], b                 ; token pointer set to path string
1813   0A0C 07 FD 14      call get_token
1814   0A0F 31 9F 16      mov bl, [tok]
1815   0A12 C1 01         cmp bl, tok_fslash
1816   0A14 C6 20 0A      je loadfile_from_path_abs 
1817   0A17 14 B1 17      mov a, [current_dir_id]
1818   0A1A 07 83 16      call _putback
1819   0A1D 0A 23 0A      jmp loadfile_from_path_e0
1820   0A20             loadfile_from_path_abs:
1821   0A20 10 20 00      mov a, root_id
1822   0A23             loadfile_from_path_e0:
1823   0A23 07 FD 14      call get_token
1824   0A26 31 9E 16      mov bl, [toktyp]
1825   0A29 C1 00         cmp bl, toktyp_identifier
1826   0A2B C7 90 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1827   0A2E FD 4D A0 16   mov si, tokstr
1828   0A32 FD 4F 8E 1C   mov di, filename
1829   0A36 07 CF 10      call _strcpy        
1830   0A39 77            inc a                         ; metadata sector
1831   0A3A 27            mov b, a
1832   0A3B 38 00 00      mov c, 0                      ; upper lba = 0
1833   0A3E 22 01         mov ah, $01                  ; 1 sector
1834   0A40 3B 0E 25      mov d, transient_area
1835   0A43 07 4D 05      call ide_read_sect            ; read directory
1836   0A46 FD 10         cla
1837   0A48 42 A9 17      mov [index], a
1838   0A4B             loadfile_from_path_l1:
1839   0A4B FD 4E         mov si, d
1840   0A4D FD 4F 8E 1C   mov di, filename
1841   0A51 07 BA 10      call _strcmp
1842   0A54 C6 6A 0A      je loadfile_from_path_name_equal  
1843   0A57 58 20 00      add d, 32
1844   0A5A 14 A9 17      mov a, [index]
1845   0A5D 77            inc a
1846   0A5E 42 A9 17      mov [index], a
1847   0A61 AF 10 00      cmp a, fst_files_per_dir
1848   0A64 C6 90 0A      je loadfile_from_path_end
1849   0A67 0A 4B 0A      jmp loadfile_from_path_l1
1850   0A6A             loadfile_from_path_name_equal:
1851   0A6A 33 18 00      mov bl, [d + 24]
1852   0A6D FD 87 38      and bl, %00111000             ; directory flag
1853   0A70 C1 08         cmp bl, %00001000             ; is dir?
1854   0A72 C6 86 0A      je loadfile_isdirectory  
1855   0A75             ; entry is a file
1856   0A75 2B 19 00      mov b, [d + 25]               ; get lba
1857   0A78 FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1858   0A7A 3B 0E 25      mov d, transient_area
1859   0A7D 38 00 00      mov c, 0
1860   0A80 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1861   0A82 07 4D 05      call ide_read_sect            ; read sector
1862   0A85 09            ret
1863   0A86             loadfile_isdirectory:
1864   0A86 58 19 00      add d, 25           
1865   0A89 15            mov a, [d]                    ; set result register a = dirid
1866   0A8A 07 FD 14      call get_token
1867   0A8D 0A 23 0A      jmp loadfile_from_path_e0
1868   0A90             loadfile_from_path_end:
1869   0A90 09            ret
1870   0A91             
1871   0A91             ;------------------------------------------------------------------------------------------------------;
1872   0A91             ; return the id of the current directory
1873   0A91             ; id returned in b
1874   0A91             ;------------------------------------------------------------------------------------------------------;
1875   0A91             fs_get_curr_dirid:
1876   0A91 29 B1 17      mov b, [current_dir_id]
1877   0A94 06            sysret
1878   0A95             
1879   0A95             ;------------------------------------------------------------------------------------------------------;
1880   0A95             ; cd
1881   0A95             ;------------------------------------------------------------------------------------------------------;
1882   0A95             ; new dirid in b
1883   0A95             fs_cd:
1884   0A95 FD 42 B1 17   mov [current_dir_id], b
1885   0A99 06            sysret  
1886   0A9A             
1887   0A9A             ;------------------------------------------------------------------------------------------------------;
1888   0A9A             ; ls
1889   0A9A             ; dirid in b
1890   0A9A             ;------------------------------------------------------------------------------------------------------;
1891   0A9A 00 00       ls_count:       .dw 0
1892   0A9C             fs_ls:
1893   0A9C FD 77         inc b                        ; metadata sector
1894   0A9E 38 00 00      mov c, 0                     ; upper lba = 0
1895   0AA1 22 01         mov ah, $01                  ; 1 sector
1896   0AA3 3B 0E 25      mov d, transient_area
1897   0AA6 07 4D 05      call ide_read_sect           ; read directory
1898   0AA9 FD 10         cla
1899   0AAB 42 A9 17      mov [index], a               ; reset entry index
1900   0AAE 3D 9A 0A      mov [ls_count], al           ; reset item count
1901   0AB1             fs_ls_l1:
1902   0AB1 BD 00         cmp byte [d], 0              ; check for null
1903   0AB3 C6 4A 0B      je fs_ls_next
1904   0AB6             fs_ls_non_null:
1905   0AB6 1D 9A 0A      mov al, [ls_count]
1906   0AB9 7A            inc al
1907   0ABA 3D 9A 0A      mov [ls_count], al           ; increment item count
1908   0ABD 1F 18 00      mov al, [d + 24]
1909   0AC0 87 38         and al, %00111000
1910   0AC2 FD A2 03      shr al, 3
1911   0AC5 22 00         mov ah, 0                    ; file type
1912   0AC7 B7 DC 17      mov a, [a + file_type]      
1913   0ACA 23            mov ah, al
1914   0ACB 07 4B 11      call _putchar
1915   0ACE 1F 18 00      mov al, [d + 24]
1916   0AD1 87 01         and al, %00000001
1917   0AD3 22 00         mov ah, 0
1918   0AD5 B7 D7 17      mov a, [a + file_attrib]     ; read
1919   0AD8 23            mov ah, al
1920   0AD9 07 4B 11      call _putchar
1921   0ADC 1F 18 00      mov al, [d + 24]
1922   0ADF 87 02         and al, %00000010
1923   0AE1 22 00         mov ah, 0
1924   0AE3 B7 D7 17      mov a, [a + file_attrib]     ; write
1925   0AE6 23            mov ah, al
1926   0AE7 07 4B 11      call _putchar
1927   0AEA 1F 18 00      mov al, [d + 24]
1928   0AED 87 04         and al, %00000100
1929   0AEF 22 00         mov ah, 0
1930   0AF1 B7 D7 17      mov a, [a + file_attrib]     ; execute
1931   0AF4 23            mov ah, al
1932   0AF5 07 4B 11      call _putchar
1933   0AF8 22 20         mov ah, $20
1934   0AFA 07 4B 11      call _putchar  
1935   0AFD 2B 1B 00      mov b, [d + 27]
1936   0B00 07 D3 12      call print_u16x              ; filesize
1937   0B03 22 20         mov ah, $20
1938   0B05 07 4B 11      call _putchar  
1939   0B08 2B 19 00      mov b, [d + 25]
1940   0B0B 07 D3 12      call print_u16x              ; dirid / lba
1941   0B0E 22 20         mov ah, $20
1942   0B10 07 4B 11      call _putchar
1943   0B13             ; print date
1944   0B13 33 1D 00      mov bl, [d + 29]             ; day
1945   0B16 07 17 13      call print_u8x
1946   0B19 22 20         mov ah, $20
1947   0B1B 07 4B 11      call _putchar  
1948   0B1E 1F 1E 00      mov al, [d + 30]             ; month
1949   0B21 FD 9E 02      shl al, 2
1950   0B24 DA            push d
1951   0B25 3B 9B 18      mov d, s_months
1952   0B28 22 00         mov ah, 0
1953   0B2A 59            add d, a
1954   0B2B 07 77 12      call _puts
1955   0B2E E7            pop d
1956   0B2F 22 20         mov ah, $20
1957   0B31 07 4B 11      call _putchar
1958   0B34 2E 20         mov bl, $20
1959   0B36 07 17 13      call print_u8x
1960   0B39 33 1F 00      mov bl, [d + 31]             ; year
1961   0B3C 07 17 13      call print_u8x  
1962   0B3F 22 20         mov ah, $20
1963   0B41 07 4B 11      call _putchar  
1964   0B44 07 77 12      call _puts                   ; print filename  
1965   0B47 07 24 12      call printnl
1966   0B4A             fs_ls_next:
1967   0B4A 14 A9 17      mov a, [index]
1968   0B4D 77            inc a
1969   0B4E 42 A9 17      mov [index], a
1970   0B51 AF 10 00      cmp a, fst_files_per_dir
1971   0B54 C6 5D 0B      je fs_ls_end
1972   0B57 58 20 00      add d, 32      
1973   0B5A 0A B1 0A      jmp fs_ls_l1  
1974   0B5D             fs_ls_end:
1975   0B5D 3B EC 17      mov d, s_ls_total
1976   0B60 07 77 12      call _puts
1977   0B63 1D 9A 0A      mov al, [ls_count]
1978   0B66 07 29 13      call print_u8d
1979   0B69 07 24 12      call printnl
1980   0B6C 06            sysret
1981   0B6D             
1982   0B6D             ;------------------------------------------------------------------------------------------------------;
1983   0B6D             ; finds an empty data block
1984   0B6D             ; block lba returned in b
1985   0B6D             ;------------------------------------------------------------------------------------------------------;
1986   0B6D             fs_find_empty_block:
1987   0B6D 26 A0 00      mov b, fs_lba_start     ; raw files starting block
1988   0B70 38 00 00      mov c, 0                ; upper lba = 0
1989   0B73             fs_find_empty_block_l1:  
1990   0B73 22 01         mov ah, $01                  ; 1 sector
1991   0B75 3B 0E 23      mov d, transient_area - 512
1992   0B78 07 4D 05      call ide_read_sect      ; read sector
1993   0B7B BD 00         cmp byte [d], 0
1994   0B7D C6 86 0B      je fs_find_empty_block_found_null
1995   0B80 55 20 00      add b, fs_sectors_per_file
1996   0B83 0A 73 0B      jmp fs_find_empty_block_l1
1997   0B86             fs_find_empty_block_found_null:
1998   0B86 09            ret
1999   0B87             
2000   0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2001   0B87             ;; create new textfile
2002   0B87             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2003   0B87             ; search for first null block
2004   0B87             fs_mktxt:
2005   0B87 FD 4E       	mov si, d
2006   0B89 FD 4F 0E 1D 	mov di, user_data
2007   0B8D 38 00 01    	mov c, 256
2008   0B90 04          	load					; load data from user-space
2009   0B91             	
2010   0B91 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2011   0B94 38 00 00    	mov c, 0						; reset lba to 0
2012   0B97             fs_mktxt_l1:	
2013   0B97 10 02 01    	mov a, $0102			; disk read
2014   0B9A 3B 0E 25    	mov d, transient_area
2015   0B9D 05 02       	syscall sys_ide ; read sector
2016   0B9F 1E          	mov al, [d]
2017   0BA0 B9 00       	cmp al, 0			; check for null
2018   0BA2 C6 AB 0B    	je fs_mktxt_found_null
2019   0BA5 55 20 00    	add b, fs_sectors_per_file
2020   0BA8 0A 97 0B    	jmp fs_mktxt_l1
2021   0BAB             fs_mktxt_found_null:
2022   0BAB D8          	push b				; save lba
2023   0BAC             ;create header file by grabbing file name from parameter	
2024   0BAC 3B CD 17    	mov d, s_dataentry
2025   0BAF 07 77 12    	call _puts
2026   0BB2 3B 0E 27    	mov d, transient_area + 512			; pointer to file contents
2027   0BB5 07 DD 11    	call _gettxt
2028   0BB8 07 AA 10    	call _strlen						; get length of file
2029   0BBB D9          	push c							; save length
2030   0BBC 19 01       	mov al, 1
2031   0BBE 3D 0E 25    	mov [transient_area], al					; mark sectors as used (not null)
2032   0BC1 10 00 00    	mov a, 0
2033   0BC4 42 A9 17    	mov [index], a
2034   0BC7 3B 0E 25    	mov d, transient_area
2035   0BCA 13          	mov a, d
2036   0BCB 42 AB 17    	mov [buffer_addr], a
2037   0BCE             fs_mktxt_l2:
2038   0BCE 38 00 00    	mov c, 0
2039   0BD1 10 03 01    	mov a, $0103			; disk write, 1 sector
2040   0BD4 05 02       	syscall sys_ide		; write sector
2041   0BD6 14 A9 17    	mov a, [index]
2042   0BD9 77          	inc a
2043   0BDA 42 A9 17    	mov [index], a
2044   0BDD AF 20 00    	cmp a, fs_sectors_per_file
2045   0BE0 C6 F2 0B    	je fs_mktxt_add_to_dir
2046   0BE3 FD 77       	inc b
2047   0BE5 14 AB 17    	mov a, [buffer_addr]
2048   0BE8 53 00 02    	add a, 512
2049   0BEB 42 AB 17    	mov [buffer_addr], a
2050   0BEE 3C          	mov d, a
2051   0BEF 0A CE 0B    	jmp fs_mktxt_l2
2052   0BF2             ; now we add the file to the current directory!
2053   0BF2             fs_mktxt_add_to_dir:	
2054   0BF2 14 B1 17    	mov a, [current_dir_id]
2055   0BF5 77          	inc a
2056   0BF6 27          	mov b, a					; metadata sector
2057   0BF7 38 00 00    	mov c, 0
2058   0BFA FD 79       	mov g, b					; save lba
2059   0BFC 3B 0E 25    	mov d, transient_area
2060   0BFF 10 02 01    	mov a, $0102			; disk read
2061   0C02 05 02       	syscall sys_ide		; read metadata sector
2062   0C04             fs_mktxt_add_to_dir_l2:
2063   0C04 1E          	mov al, [d]
2064   0C05 B9 00       	cmp al, 0
2065   0C07 C6 10 0C    	je fs_mktxt_add_to_dir_null
2066   0C0A 58 20 00    	add d, fst_entry_size
2067   0C0D 0A 04 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2068   0C10             fs_mktxt_add_to_dir_null:
2069   0C10 FD 4D 0E 1D 	mov si, user_data
2070   0C14 FD 50       	mov di, d
2071   0C16 07 CF 10    	call _strcpy			; copy file name
2072   0C19 58 18 00    	add d, 24			; skip name
2073   0C1C 19 06       	mov al, %00000110		; no execute, write, read, not directory
2074   0C1E 3E          	mov [d], al			
2075   0C1F 58 03 00    	add d, 3
2076   0C22 E4          	pop a
2077   0C23 43          	mov [d], a
2078   0C24 63 02 00    	sub d, 2
2079   0C27 E5          	pop b				; get file lba
2080   0C28 FD 43       	mov [d], b			; save lba	
2081   0C2A             	
2082   0C2A             	; set file creation date	
2083   0C2A 58 04 00    	add d, 4
2084   0C2D 19 04       	mov al, 4
2085   0C2F 05 01       	syscall sys_rtc
2086   0C31 1A          	mov al, ah
2087   0C32 3E          	mov [d], al			; set day
2088   0C33             	
2089   0C33 79          	inc d
2090   0C34 19 05       	mov al, 5
2091   0C36 05 01       	syscall sys_rtc
2092   0C38 1A          	mov al, ah
2093   0C39 3E          	mov [d], al			; set month
2094   0C3A             	
2095   0C3A 79          	inc d
2096   0C3B 19 06       	mov al, 6
2097   0C3D 05 01       	syscall sys_rtc
2098   0C3F 1A          	mov al, ah
2099   0C40 3E          	mov [d], al			; set year
2100   0C41             	
2101   0C41             ; write sector into disk for new directory entry
2102   0C41 FD 27       	mov b, g
2103   0C43 38 00 00    	mov c, 0
2104   0C46 3B 0E 25    	mov d, transient_area
2105   0C49 10 03 01    	mov a, $0103			; disk write, 1 sector
2106   0C4C 05 02       	syscall sys_ide		; write sector
2107   0C4E 07 24 12    	call printnl
2108   0C51 06          	sysret
2109   0C52             
2110   0C52             
2111   0C52             
2112   0C52             ;------------------------------------------------------------------------------------------------------;
2113   0C52             ; create new binary file
2114   0C52             ;------------------------------------------------------------------------------------------------------;
2115   0C52             ; search for first null block
2116   0C52             fs_mkbin:
2117   0C52 19 00         mov al, 0
2118   0C54 3D A1 17      mov [sys_echo_on], al ; disable echo
2119   0C57 FD 4E         mov si, d
2120   0C59 FD 4F 0E 1D   mov di, user_data
2121   0C5D 38 00 02      mov c, 512
2122   0C60 04            load                          ; load data from user-space
2123   0C61 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2124   0C64 38 00 00      mov c, 0                      ; upper lba = 0
2125   0C67             fs_mkbin_l1:  
2126   0C67 22 01         mov ah, $01                  ; 1 sector
2127   0C69 3B 0E 25      mov d, transient_area
2128   0C6C 07 4D 05      call ide_read_sect            ; read sector
2129   0C6F BD 00         cmp byte[d], 0                ; check for null
2130   0C71 C6 7A 0C      je fs_mkbin_found_null
2131   0C74 55 20 00      add b, fs_sectors_per_file
2132   0C77 0A 67 0C      jmp fs_mkbin_l1
2133   0C7A             fs_mkbin_found_null:
2134   0C7A D8            push b                        ; save lba
2135   0C7B             ;create header file by grabbing file name from parameter
2136   0C7B FD 4F 0E 27   mov di, transient_area + 512  ; pointer to file contents
2137   0C7F 07 F5 0F      call _load_hex                ; load binary hex
2138   0C82 D9            push c                        ; save size (nbr of bytes)
2139   0C83 19 01         mov al, 1
2140   0C85 3D 0E 25      mov [transient_area], al      ; mark sectors as used (not null)
2141   0C88 FD 10         cla
2142   0C8A 42 A9 17      mov [index], a
2143   0C8D 3B 0E 25      mov d, transient_area
2144   0C90 13            mov a, d
2145   0C91 42 AB 17      mov [buffer_addr], a
2146   0C94             fs_mkbin_l2:
2147   0C94 38 00 00      mov c, 0
2148   0C97 22 01         mov ah, $01                   ; disk write, 1 sector
2149   0C99 07 73 05      call ide_write_sect           ; write sector
2150   0C9C 14 A9 17      mov a, [index]
2151   0C9F 77            inc a
2152   0CA0 42 A9 17      mov [index], a
2153   0CA3 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2154   0CA6 C6 B8 0C      je fs_mkbin_add_to_dir
2155   0CA9 FD 77         inc b
2156   0CAB 14 AB 17      mov a, [buffer_addr]
2157   0CAE 53 00 02      add a, 512
2158   0CB1 42 AB 17      mov [buffer_addr], a
2159   0CB4 3C            mov d, a
2160   0CB5 0A 94 0C      jmp fs_mkbin_l2
2161   0CB8             ; now we add the file to the current directory!
2162   0CB8             fs_mkbin_add_to_dir:  
2163   0CB8 14 B1 17      mov a, [current_dir_id]
2164   0CBB 77            inc a
2165   0CBC 27            mov b, a                      ; metadata sector
2166   0CBD 38 00 00      mov c, 0
2167   0CC0 FD 79         mov g, b                      ; save lba
2168   0CC2 3B 0E 25      mov d, transient_area
2169   0CC5 22 01         mov ah, $01                  ; 1 sector
2170   0CC7 07 4D 05      call ide_read_sect            ; read metadata sector
2171   0CCA             fs_mkbin_add_to_dir_l2:
2172   0CCA BD 00         cmp byte[d], 0
2173   0CCC C6 D5 0C      je fs_mkbin_add_to_dir_null
2174   0CCF 58 20 00      add d, fst_entry_size
2175   0CD2 0A CA 0C      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2176   0CD5             fs_mkbin_add_to_dir_null:
2177   0CD5 FD 4D 0E 1D   mov si, user_data
2178   0CD9 FD 50         mov di, d
2179   0CDB 07 CF 10      call _strcpy                  ; copy file name
2180   0CDE 58 18 00      add d, 24                     ; skip name
2181   0CE1 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2182   0CE3 3E            mov [d], al
2183   0CE4 58 03 00      add d, 3
2184   0CE7 E4            pop a
2185   0CE8 43            mov [d], a
2186   0CE9 63 02 00      sub d, 2
2187   0CEC E5            pop b                         ; get file lba
2188   0CED FD 43         mov [d], b                    ; save lba
2189   0CEF               ; set file creation date  
2190   0CEF 58 04 00      add d, 4
2191   0CF2 19 04         mov al, 4
2192   0CF4 05 01         syscall sys_rtc
2193   0CF6 1A            mov al, ah
2194   0CF7 3E            mov [d], al                   ; set day
2195   0CF8 79            inc d
2196   0CF9 19 05         mov al, 5
2197   0CFB 05 01         syscall sys_rtc
2198   0CFD 1A            mov al, ah
2199   0CFE 3E            mov [d], al                   ; set month
2200   0CFF 79            inc d
2201   0D00 19 06         mov al, 6
2202   0D02 05 01         syscall sys_rtc
2203   0D04 1A            mov al, ah
2204   0D05 3E            mov [d], al                   ; set year
2205   0D06             ; write sector into disk for new directory entry
2206   0D06 FD 27         mov b, g
2207   0D08 38 00 00      mov c, 0
2208   0D0B 3B 0E 25      mov d, transient_area
2209   0D0E 22 01         mov ah, $01                   ; disk write, 1 sector
2210   0D10 07 73 05      call ide_write_sect           ; write sector
2211   0D13 19 01         mov al, 1
2212   0D15 3D A1 17      mov [sys_echo_on], al ; enable echo
2213   0D18 06            sysret
2214   0D19             
2215   0D19             ;------------------------------------------------------------------------------------------------------;
2216   0D19             ; pwd - print working directory
2217   0D19             ;------------------------------------------------------------------------------------------------------;    
2218   0D19             fs_pwd:
2219   0D19 3B 8E 1C      mov d, filename
2220   0D1C 19 00         mov al, 0
2221   0D1E 3E            mov [d], al                   ; initialize path string 
2222   0D1F 14 B1 17      mov a, [current_dir_id]
2223   0D22 07 83 08      call fs_dir_id_to_path_e0
2224   0D25 3B 8E 1C      mov d, filename
2225   0D28 07 63 10      call _strrev
2226   0D2B 07 77 12      call _puts
2227   0D2E 07 24 12      call printnl
2228   0D31 06            sysret
2229   0D32             
2230   0D32             ;------------------------------------------------------------------------------------------------------;
2231   0D32             ; get current directory lba
2232   0D32             ; a: returned lba
2233   0D32             ;------------------------------------------------------------------------------------------------------;
2234   0D32             cmd_get_curr_dir_lba:
2235   0D32 14 B1 17      mov a, [current_dir_id]
2236   0D35 06            sysret
2237   0D36             
2238   0D36             ;------------------------------------------------------------------------------------------------------;
2239   0D36             ; cat
2240   0D36             ; userspace destination data pointer in d
2241   0D36             ; filename starts at d, but is overwritten after the read is made
2242   0D36             ;------------------------------------------------------------------------------------------------------;:
2243   0D36             fs_cat:
2244   0D36 DA            push d                              ; save userspace file data destination
2245   0D37 FD 4E         mov si, d
2246   0D39 FD 4F 0E 1D   mov di, user_data
2247   0D3D 38 00 02      mov c, 512
2248   0D40 04            load                                ; copy filename from user-space
2249   0D41 29 B1 17      mov b, [current_dir_id]
2250   0D44 FD 77         inc b                               ; metadata sector
2251   0D46 38 00 00      mov c, 0                            ; upper lba = 0
2252   0D49 22 01         mov ah, $01                  ; 1 sector
2253   0D4B 3B 0E 23      mov d, transient_area-512
2254   0D4E 07 4D 05      call ide_read_sect                  ; read directory
2255   0D51 FD 10         cla
2256   0D53 42 A9 17      mov [index], a                      ; reset file counter
2257   0D56             fs_cat_l1:
2258   0D56 FD 4E         mov si, d
2259   0D58 FD 4F 0E 1D   mov di, user_data
2260   0D5C 07 BA 10      call _strcmp
2261   0D5F C6 75 0D      je fs_cat_found_entry
2262   0D62 58 20 00      add d, 32
2263   0D65 14 A9 17      mov a, [index]
2264   0D68 77            inc a
2265   0D69 42 A9 17      mov [index], a
2266   0D6C AF 10 00      cmp a, fst_files_per_dir
2267   0D6F C6 90 0D      je fs_cat_not_found
2268   0D72 0A 56 0D      jmp fs_cat_l1
2269   0D75             fs_cat_found_entry:
2270   0D75 58 19 00      add d, 25                           ; get to dirid of file in disk
2271   0D78 2A            mov b, [d]                          ; get lba
2272   0D79 FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2273   0D7B 3B 0E 25      mov d, transient_area  
2274   0D7E 38 00 00      mov c, 0
2275   0D81 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2276   0D83 07 4D 05      call ide_read_sect                  ; read sectors
2277   0D86 F0            pop di                              ; write userspace file data destination to di
2278   0D87 FD 4D 0E 25   mov si, transient_area              ; data origin
2279   0D8B 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2280   0D8E 03            store
2281   0D8F 06            sysret
2282   0D90             fs_cat_not_found:
2283   0D90 E7            pop d
2284   0D91 06            sysret
2285   0D92             
2286   0D92             ;------------------------------------------------------------------------------------------------------;
2287   0D92             ; rmdir - remove dir by dirid
2288   0D92             ;------------------------------------------------------------------------------------------------------;
2289   0D92             ; deletes a directory entry in the given directory's file list 
2290   0D92             ; also deletes the actual directory entry in the fst
2291   0D92             ; synopsis: rmdir /usr/local/testdir
2292   0D92             ; b = dirid
2293   0D92             fs_rmdir:
2294   0D92 FD 79         mov g, b
2295   0D94 11            mov a, b
2296   0D95 07 BF 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2297   0D98 D7            push a                        ; save dirid
2298   0D99             ; search for directory's entry in the parent's directory then and delete it
2299   0D99 77            inc a                         ; metadata sector
2300   0D9A 27            mov b, a
2301   0D9B 38 00 00      mov c, 0                      ; upper lba = 0
2302   0D9E 22 01         mov ah, $01          ;
2303   0DA0 3B 0E 25      mov d, transient_area
2304   0DA3 07 4D 05      call ide_read_sect            ; read directory
2305   0DA6 FD 10         cla
2306   0DA8 42 A9 17      mov [index], a                ; reset file counter
2307   0DAB FD 27         mov b, g                      ; retrieve directory's dirid
2308   0DAD             fs_rmdir_l1:
2309   0DAD 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2310   0DB0 B0            cmp a, b                      ; compare dirid's to find the directory
2311   0DB1 C6 C7 0D      je fs_rmdir_found_entry
2312   0DB4 58 20 00      add d, 32
2313   0DB7 14 A9 17      mov a, [index]
2314   0DBA 77            inc a
2315   0DBB 42 A9 17      mov [index], a
2316   0DBE AF 10 00      cmp a, fst_files_per_dir
2317   0DC1 C6 EC 0D      je fs_rmdir_not_found
2318   0DC4 0A AD 0D      jmp fs_rmdir_l1
2319   0DC7             fs_rmdir_found_entry:
2320   0DC7 FD 10         cla
2321   0DC9 3E            mov [d], al                   ; make filename null
2322   0DCA 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2323   0DCD E5            pop b
2324   0DCE FD 77         inc b                         ; metadata sector
2325   0DD0 38 00 00      mov c, 0                      ; upper lba = 0
2326   0DD3 22 01         mov ah, $01          ; 
2327   0DD5 3B 0E 25      mov d, transient_area
2328   0DD8 07 73 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2329   0DDB             
2330   0DDB FD 27         mov b, g
2331   0DDD 3B 0E 25      mov d, transient_area  
2332   0DE0 FD 10         cla
2333   0DE2 3E            mov [d], al                   ; make directory's name header null for re-use
2334   0DE3 38 00 00      mov c, 0
2335   0DE6 22 01         mov ah, $01                   ; disk write 1 sect
2336   0DE8 07 73 05      call ide_write_sect           ; delete directory given by dirid in b
2337   0DEB 06            sysret
2338   0DEC             fs_rmdir_not_found:
2339   0DEC E5            pop b
2340   0DED 06            sysret
2341   0DEE             
2342   0DEE             ;------------------------------------------------------------------------------------------------------;
2343   0DEE             ; rm - remove file
2344   0DEE             ;------------------------------------------------------------------------------------------------------;
2345   0DEE             ; frees up the data sectors for the file further down the disk
2346   0DEE             ; deletes file entry in the directory's file list 
2347   0DEE             fs_rm:
2348   0DEE FD 4E         mov si, d
2349   0DF0 FD 4F 0E 1D   mov di, user_data
2350   0DF4 38 00 02      mov c, 512
2351   0DF7 04            load                          ; load data from user-space
2352   0DF8 14 B1 17      mov a, [current_dir_id]
2353   0DFB 77            inc a                         ; metadata sector
2354   0DFC 27            mov b, a
2355   0DFD 38 00 00      mov c, 0                      ; upper lba = 0
2356   0E00 22 01         mov ah, $01                  ; 1 sector
2357   0E02 3B 0E 25      mov d, transient_area
2358   0E05 07 4D 05      call ide_read_sect            ; read directory
2359   0E08 10 00 00      mov a, 0
2360   0E0B 42 A9 17      mov [index], a                ; reset file counter
2361   0E0E             fs_rm_l1:
2362   0E0E FD 4E         mov si, d
2363   0E10 FD 4F 0E 1D   mov di, user_data
2364   0E14 07 BA 10      call _strcmp
2365   0E17 C6 2D 0E      je fs_rm_found_entry
2366   0E1A 58 20 00      add d, 32
2367   0E1D 14 A9 17      mov a, [index]
2368   0E20 77            inc a
2369   0E21 42 A9 17      mov [index], a
2370   0E24 AF 10 00      cmp a, fst_files_per_dir
2371   0E27 C6 55 0E      je fs_rm_not_found
2372   0E2A 0A 0E 0E      jmp fs_rm_l1
2373   0E2D             fs_rm_found_entry:
2374   0E2D 2B 19 00      mov b, [d + 25]               ; get lba
2375   0E30 FD 79         mov g, b                      ; save lba
2376   0E32 19 00         mov al, 0
2377   0E34 3E            mov [d], al                   ; make file entry null
2378   0E35 14 B1 17      mov a, [current_dir_id]
2379   0E38 77            inc a                         ; metadata sector
2380   0E39 27            mov b, a
2381   0E3A 38 00 00      mov c, 0                      ; upper lba = 0
2382   0E3D 22 01         mov ah, $01                   ; disk write
2383   0E3F 3B 0E 25      mov d, transient_area
2384   0E42 07 73 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2385   0E45 3B 0E 25      mov d, transient_area  
2386   0E48 19 00         mov al, 0
2387   0E4A 3E            mov [d], al                   ; make file's data header null for re-use
2388   0E4B 38 00 00      mov c, 0
2389   0E4E FD 27         mov b, g                      ; get data header lba
2390   0E50 22 01         mov ah, $01                   ; disk write 1 sect
2391   0E52 07 73 05      call ide_write_sect           ; write sector
2392   0E55             fs_rm_not_found:  
2393   0E55 06            sysret  
2394   0E56             
2395   0E56             ;------------------------------------------------------------------------------------------------------;
2396   0E56             ; mv - move / change file name
2397   0E56             ;------------------------------------------------------------------------------------------------------;
2398   0E56             fs_mv:
2399   0E56 FD 4E         mov si, d
2400   0E58 FD 4F 0E 1D   mov di, user_data
2401   0E5C 38 00 02      mov c, 512
2402   0E5F 04            load                          ; load data from user-space
2403   0E60 14 B1 17      mov a, [current_dir_id]
2404   0E63 77            inc a                         ; metadata sector
2405   0E64 27            mov b, a  
2406   0E65 38 00 00      mov c, 0                      ; upper lba = 0
2407   0E68 22 01         mov ah, $01                  ; 1 sector
2408   0E6A 3B 0E 25      mov d, transient_area
2409   0E6D 07 4D 05      call ide_read_sect            ; read directory
2410   0E70 FD 10         cla
2411   0E72 42 A9 17      mov [index], a                ; reset file counter
2412   0E75             fs_mv_l1:
2413   0E75 FD 4E         mov si, d
2414   0E77 FD 4F 0E 1D   mov di, user_data
2415   0E7B 07 BA 10      call _strcmp
2416   0E7E C6 94 0E      je fs_mv_found_entry
2417   0E81 58 20 00      add d, 32
2418   0E84 14 A9 17      mov a, [index]
2419   0E87 77            inc a
2420   0E88 42 A9 17      mov [index], a
2421   0E8B AF 10 00      cmp a, fst_files_per_dir
2422   0E8E C6 C6 0E      je fs_mv_not_found
2423   0E91 0A 75 0E      jmp fs_mv_l1
2424   0E94             fs_mv_found_entry:  
2425   0E94 DA            push d
2426   0E95 FD 4D 8E 1D   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2427   0E99 FD 50         mov di, d
2428   0E9B 07 CF 10      call _strcpy  
2429   0E9E 38 00 00      mov c, 0
2430   0EA1 3B 0E 25      mov d, transient_area
2431   0EA4 22 01         mov ah, $01                   ; disk write 1 sect
2432   0EA6 07 73 05      call ide_write_sect           ; write sector
2433   0EA9 E7            pop d
2434   0EAA             ;; need to check whether its a dir or a file here ;;;
2435   0EAA 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2436   0EAD 22 01         mov ah, $01
2437   0EAF 3B 0E 25      mov d, transient_area
2438   0EB2 38 00 00      mov c, 0
2439   0EB5 07 4D 05      call ide_read_sect            ; read directory entry
2440   0EB8 FD 4D 8E 1D   mov si, user_data + 128
2441   0EBC FD 50         mov di, d
2442   0EBE 07 CF 10      call _strcpy                  ; change directory's name
2443   0EC1 22 01         mov ah, $01
2444   0EC3 07 73 05      call ide_write_sect           ; rewrite directory back to disk
2445   0EC6             fs_mv_not_found:
2446   0EC6 06            sysret
2447   0EC7             
2448   0EC7             
2449   0EC7             ;----------------------------------------------------------------------------------------------------;
2450   0EC7             ; process index in a
2451   0EC7             ;----------------------------------------------------------------------------------------------------;
2452   0EC7             find_free_proc:
2453   0EC7 FD 4D 7F 1A   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2454   0ECB             find_free_proc_l0:
2455   0ECB F6            lodsb                               ; get process state
2456   0ECC B9 00         cmp al, 0
2457   0ECE C6 D4 0E      je find_free_proc_free              ; if free, jump
2458   0ED1 0A CB 0E      jmp find_free_proc_l0               ; else, goto next
2459   0ED4             find_free_proc_free:
2460   0ED4 4E            mov a, si
2461   0ED5 5F 7F 1A      sub a, 1 + proc_availab_table       ; get process index
2462   0ED8 09            ret
2463   0ED9               
2464   0ED9             
2465   0ED9             ;----------------------------------------------------------------------------------------------------;
2466   0ED9             ; process index in al
2467   0ED9             ;----------------------------------------------------------------------------------------------------;
2468   0ED9             proc_memory_map:
2469   0ED9 22 00         mov ah, 0
2470   0EDB 27            mov b, a                      ; page in bl, 0 in bh
2471   0EDC FD 9D 05      shl a, 5                      ; multiply by 32
2472   0EDF 39            mov c, a                      ; save in c
2473   0EE0 57 20 00      add c, 32
2474   0EE3             proc_memory_map_l0:
2475   0EE3 02            pagemap
2476   0EE4 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2477   0EE7 53 01 00      add a, 1                      ; increase both 
2478   0EEA B1            cmp a, c                      ; check to see if we reached the end of memory
2479   0EEB C7 E3 0E      jne proc_memory_map_l0
2480   0EEE 09            ret
2481   0EEF               
2482   0EEF             
2483   0EEF             ;----------------------------------------------------------------------------------------------------;
2484   0EEF             ; terminate process
2485   0EEF             ;----------------------------------------------------------------------------------------------------;
2486   0EEF             syscall_terminate_proc:
2487   0EEF 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2488   0EF2                                                    ; since they will not be used for anything here.
2489   0EF2 1D A8 17      mov al, [active_proc_index]
2490   0EF5 22 00         mov ah, 0  
2491   0EF7 FD 9D 05      shl a, 5                             ; x32
2492   0EFA 53 8E 1A      add a, proc_names
2493   0EFD 3C            mov d, a
2494   0EFE 19 00         mov al, 0
2495   0F00 3E            mov [d], al                           ; nullify process name
2496   0F01             
2497   0F01 1D A8 17      mov al, [active_proc_index]
2498   0F04 22 00         mov ah, 0  
2499   0F06 3C            mov d, a
2500   0F07 19 00         mov al, 0
2501   0F09 3F 7E 1A      mov [d + proc_availab_table], al    ; make process empty again
2502   0F0C               
2503   0F0C 1D A7 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2504   0F0F 80            dec al
2505   0F10 3D A7 17      mov [nbr_active_procs], al
2506   0F13             
2507   0F13             ; now load the shell process again
2508   0F13 19 02         mov al, 2                           ; next process = process 2 = shell
2509   0F15 3D A8 17      mov [active_proc_index], al         ; set next active proc
2510   0F18             
2511   0F18             ; calculate lut entry for next process
2512   0F18 22 00         mov ah, 0
2513   0F1A FD 99         shl a                               ; x2
2514   0F1C B7 E5 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2515   0F1F               
2516   0F1F 4D            mov si, a                           ; source is proc state block
2517   0F20 48            mov a, sp
2518   0F21 5F 13 00      sub a, 19
2519   0F24 4F            mov di, a                           ; destination is kernel stack
2520   0F25             ; restore sp
2521   0F25 7D            dec a
2522   0F26 47            mov sp, a
2523   0F27 38 14 00      mov c, 20
2524   0F2A FD F5         rep movsb
2525   0F2C             ; set vm process
2526   0F2C 1D A8 17      mov al, [active_proc_index]
2527   0F2F 01            setptb
2528   0F30                 
2529   0F30 4C            popa
2530   0F31 06            sysret
2531   0F32             
2532   0F32             ;----------------------------------------------------------------------------------------------------;
2533   0F32             ; pause process
2534   0F32             ;----------------------------------------------------------------------------------------------------;
2535   0F32             syscall_pause_proc:
2536   0F32             ; save all registers into kernel stack
2537   0F32 4B            pusha
2538   0F33 22 00         mov ah, 0
2539   0F35 1D A8 17      mov al, [active_proc_index]
2540   0F38 FD 99         shl a              ; x2
2541   0F3A B7 E5 0F      mov a, [proc_table_convert + a]   ; get process state start index
2542   0F3D                 
2543   0F3D 4F            mov di, a
2544   0F3E 48            mov a, sp
2545   0F3F 77            inc a
2546   0F40 4D            mov si, a
2547   0F41 38 14 00      mov c, 20
2548   0F44 FD F5         rep movsb                         ; save process state!
2549   0F46             ; restore kernel stack position to point before interrupt arrived
2550   0F46 51 14 00      add sp, 20
2551   0F49             ; now load the shell process again
2552   0F49 19 02         mov al, 2                         ; next process = process 2 = shell
2553   0F4B 3D A8 17      mov [active_proc_index], al       ; set next active proc
2554   0F4E             
2555   0F4E             ; calculate lut entry for next process
2556   0F4E 22 00         mov ah, 0
2557   0F50 FD 99         shl a                             ; x2
2558   0F52 B7 E5 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2559   0F55               
2560   0F55 4D            mov si, a                         ; source is proc state block
2561   0F56 48            mov a, sp
2562   0F57 5F 13 00      sub a, 19
2563   0F5A 4F            mov di, a                         ; destination is kernel stack
2564   0F5B             ; restore sp
2565   0F5B 7D            dec a
2566   0F5C 47            mov sp, a
2567   0F5D 38 14 00      mov c, 20
2568   0F60 FD F5         rep movsb
2569   0F62             ; set vm process
2570   0F62 1D A8 17      mov al, [active_proc_index]
2571   0F65 01            setptb
2572   0F66                 
2573   0F66 4C            popa
2574   0F67 06            sysret
2575   0F68             
2576   0F68             ;----------------------------------------------------------------------------------------------------;
2577   0F68             ; create a new process
2578   0F68             ; d = path of the process file to be createed
2579   0F68             ; b = arguments ptr
2580   0F68             ;----------------------------------------------------------------------------------------------------;
2581   0F68             syscall_create_proc:
2582   0F68             ; we save the active process first  
2583   0F68 4B            pusha
2584   0F69 22 00         mov ah, 0
2585   0F6B 1D A8 17      mov al, [active_proc_index]
2586   0F6E FD 99         shl a              ; x2
2587   0F70 B7 E5 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2588   0F73               
2589   0F73 4F            mov di, a
2590   0F74 48            mov a, sp
2591   0F75 77            inc a
2592   0F76 4D            mov si, a
2593   0F77 38 14 00      mov c, 20
2594   0F7A FD F5         rep movsb                          ; save process state!
2595   0F7C             ; restore kernel stack position to point before interrupt arrived
2596   0F7C 51 14 00      add sp, 20
2597   0F7F               
2598   0F7F FD 4E         mov si, d                          ; copy the file path
2599   0F81 FD 4F 0E 1D   mov di, user_data
2600   0F85 38 00 02      mov c, 512
2601   0F88 04            load
2602   0F89 11            mov a, b
2603   0F8A 4D            mov si, a                          ; copy the arguments
2604   0F8B FD 4F 0E 23   mov di, scrap_sector
2605   0F8F 38 00 02      mov c, 512
2606   0F92 04            load
2607   0F93 07 05 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2608   0F96                                                  ; the file data is loaded into transient_area
2609   0F96             ; now we allocate a new process  
2610   0F96 07 C7 0E      call find_free_proc                ; index in a
2611   0F99 01            setptb 
2612   0F9A 07 D9 0E      call proc_memory_map               ; map process memory pages
2613   0F9D             ; copy arguments into process's memory
2614   0F9D FD 4D 0E 23   mov si, scrap_sector
2615   0FA1 FD 4F 00 00   mov di, 0
2616   0FA5 38 00 02      mov c, 512
2617   0FA8 03            store
2618   0FA9             ; now copy process binary data into process's memory
2619   0FA9 FD 4D 0E 25   mov si, transient_area
2620   0FAD FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2621   0FB1 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2622   0FB4 03            store                              ; copy process data
2623   0FB5                 
2624   0FB5 07 C7 0E      call find_free_proc                ; index in a
2625   0FB8 3D A8 17      mov [active_proc_index], al        ; set new active process
2626   0FBB FD 9D 05      shl a, 5                           ; x32
2627   0FBE 53 8E 1A      add a, proc_names
2628   0FC1 4F            mov di, a
2629   0FC2 FD 4D 0E 1D   mov si, user_data                  ; copy and store process filename
2630   0FC6 07 CF 10      call _strcpy
2631   0FC9               
2632   0FC9 07 C7 0E      call find_free_proc                ; index in a
2633   0FCC 3C            mov d, a
2634   0FCD 19 01         mov al, 1
2635   0FCF 3F 7E 1A      mov [d + proc_availab_table], al   ; make process busy
2636   0FD2               
2637   0FD2 1D A7 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2638   0FD5 7A            inc al
2639   0FD6 3D A7 17      mov [nbr_active_procs], al
2640   0FD9             ; launch process
2641   0FD9 FD D7 FF FF   push word $ffff 
2642   0FDD FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2643   0FE0 FD D7 00 04   push word text_org
2644   0FE4 06            sysret
2645   0FE5             
2646   0FE5             proc_table_convert:
2647   0FE5 3E 19         .dw proc_state_table + 0
2648   0FE7 52 19         .dw proc_state_table + 20
2649   0FE9 66 19         .dw proc_state_table + 40
2650   0FEB 7A 19         .dw proc_state_table + 60
2651   0FED 8E 19         .dw proc_state_table + 80
2652   0FEF A2 19         .dw proc_state_table + 100
2653   0FF1 B6 19         .dw proc_state_table + 120
2654   0FF3 CA 19         .dw proc_state_table + 140
2655   0FF5               
2656   0FF5             ;----------------------------------------------------------------------------------------------;
2657   0FF5             ; get hex file
2658   0FF5             ; di = destination address
2659   0FF5             ; return length in bytes in c
2660   0FF5             ;----------------------------------------------------------------------------------------------;
2661   0FF5             _load_hex:
2662   0FF5 D7            push a
2663   0FF6 D8            push b
2664   0FF7 DA            push d
2665   0FF8 E2            push si
2666   0FF9 E3            push di
2667   0FFA 38 00 00      mov c, 0
2668   0FFD 50            mov a, di
2669   0FFE 3C            mov d, a          ; start of string data block
2670   0FFF 07 52 11      call _gets        ; get program string
2671   1002 4D            mov si, a
2672   1003             __load_hex_loop:
2673   1003 F6            lodsb             ; load from [si] to al
2674   1004 B9 00         cmp al, 0         ; check if ascii 0
2675   1006 C6 14 10      jz __load_hex_ret
2676   1009 36            mov bh, al
2677   100A F6            lodsb
2678   100B 2F            mov bl, al
2679   100C 07 08 11      call _atoi        ; convert ascii byte in b to int (to al)
2680   100F F7            stosb             ; store al to [di]
2681   1010 78            inc c
2682   1011 0A 03 10      jmp __load_hex_loop
2683   1014             __load_hex_ret:
2684   1014 F0            pop di
2685   1015 EF            pop si
2686   1016 E7            pop d
2687   1017 E5            pop b
2688   1018 E4            pop a
2689   1019 09            ret
2690   101A             
2691   101A             ; synopsis: look inside a certain directory for files/directories
2692   101A             ; before calling this function, cd into required directory
2693   101A             ; for each entry inside directory:
2694   101A             ;  if entry is a file:
2695   101A             ;    compare filename to searched filename
2696   101A             ;    if filenames are the same, print filename
2697   101A             ;  else if entry is a directory:
2698   101A             ;    cd to the given directory
2699   101A             ;    recursively call cmd_find
2700   101A             ;    cd outside previous directory
2701   101A             ;  if current entry == last entry, return
2702   101A             ; endfor
2703   101A             f_find:
2704   101A 09            ret
2705   101B             
2706   101B             
2707   101B             ; ---------------------------------------------------------------------
2708   101B             ; kernel reset vector
2709   101B             ; ---------------------------------------------------------------------
2710   101B             kernel_reset_vector:  
2711   101B FD 49 FF F7   mov bp, stack_begin
2712   101F FD 47 FF F7   mov sp, stack_begin
2713   1023               
2714   1023 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2715   1025 FD 0F         stomsk                        
2716   1027 FD 0C         sti  
2717   1029             
2718   1029 0C            lodstat
2719   102A 87 DF         and al, %11011111             ; disable display register loading
2720   102C 0D            stostat
2721   102D               
2722   102D             ; reset fifo pointers
2723   102D 10 0E 1F      mov a, fifo
2724   1030 3B AD 17      mov d, fifo_in
2725   1033 43            mov [d], a
2726   1034 3B AF 17      mov d, fifo_out
2727   1037 43            mov [d], a  
2728   1038 19 02         mov al, 2
2729   103A 05 03         syscall sys_io                ; enable uart in interrupt mode
2730   103C             
2731   103C 3B 02 18      mov d, s_kernel_started
2732   103F 07 77 12      call _puts
2733   1042             
2734   1042 3B FC 18      mov d, s_fdc_config
2735   1045 07 77 12      call _puts
2736   1048 F2 C0 FF 0E   mov byte [_fdc_config], %00001110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2737   104C F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000     ; leave this restore command in order to clear BUSY flag
2738   1050 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
2739   1054             
2740   1054 19 10         mov al, 16
2741   1056 05 04         syscall sys_filesystem        ; set root dirid
2742   1058             
2743   1058 3B 1F 18      mov d, s_prompt_init
2744   105B 07 77 12      call _puts
2745   105E 3B B3 17      mov d, s_init_path
2746   1061 05 05         syscall sys_create_proc       ; launch init as a new process
2747   1063             
2748   1063             
2749   1063             ; file includes
2750   1063             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1063             boot_origin      .EQU  $8004
0002+  1063             bios_uart        .EQU  $0002
0003+  1063             bios_ide         .EQU  $0003
0004+  1063             bios_reset_vector .EQU  $01c0
0005+  1063             ide_buffer       .EQU  $8204
2751   1063             .include "lib/stdio.asm"
0001+  1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1063             ; stdio.s
0003+  1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1063             .include "lib/string.asm"
0001++ 1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1063             ; string.s
0003++ 1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1063             
0005++ 1063             
0006++ 1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1063             ; _strrev
0008++ 1063             ; reverse a string
0009++ 1063             ; d = string address
0010++ 1063             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1063             ; 01234
0012++ 1063             _strrev:
0013++ 1063 4B          	pusha
0014++ 1064 07 AA 10    	call _strlen	; length in c
0015++ 1067 12          	mov a, c
0016++ 1068 AF 01 00    	cmp a, 1
0017++ 106B D0 85 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 106E 7D          	dec a
0019++ 106F FD 4E       	mov si, d	; beginning of string
0020++ 1071 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1073 59          	add d, a	; end of string
0022++ 1074 12          	mov a, c
0023++ 1075 FD 9B       	shr a		; divide by 2
0024++ 1077 39          	mov c, a	; c now counts the steps
0025++ 1078             _strrev_l0:
0026++ 1078 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1079 F6          	lodsb		; load left-side char into al; increase si
0028++ 107A 3E          	mov [d], al	; store left char into right side
0029++ 107B 1B          	mov al, bl
0030++ 107C F7          	stosb		; store right-side char into left-side; increase di
0031++ 107D 7E          	dec c
0032++ 107E 7F          	dec d
0033++ 107F C2 00 00    	cmp c, 0
0034++ 1082 C7 78 10    	jne _strrev_l0
0035++ 1085             _strrev_end:
0036++ 1085 4C          	popa
0037++ 1086 09          	ret
0038++ 1087             	
0039++ 1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1087             ; _strchr
0041++ 1087             ; search string in d for char in al
0042++ 1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1087             _strchr:
0044++ 1087             _strchr_l0:
0045++ 1087 32          	mov bl, [d]
0046++ 1088 C1 00       	cmp bl, 0
0047++ 108A C6 95 10    	je _strchr_end
0048++ 108D BA          	cmp al, bl
0049++ 108E C6 95 10    	je _strchr_end
0050++ 1091 79          	inc d
0051++ 1092 0A 87 10    	jmp _strchr_l0
0052++ 1095             _strchr_end:
0053++ 1095 1B          	mov al, bl
0054++ 1096 09          	ret
0055++ 1097             
0056++ 1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1097             ; _strstr
0058++ 1097             ; find sub-string
0059++ 1097             ; str1 in si
0060++ 1097             ; str2 in di
0061++ 1097             ; si points to end of source string
0062++ 1097             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1097             _strstr:
0064++ 1097 DB          	push al
0065++ 1098 DA          	push d
0066++ 1099 E3          	push di
0067++ 109A             _strstr_loop:
0068++ 109A F3          	cmpsb					; compare a byte of the strings
0069++ 109B C7 A6 10    	jne _strstr_ret
0070++ 109E FC 00 00    	lea d, [di + 0]
0071++ 10A1 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10A3 C7 9A 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10A6             _strstr_ret:
0074++ 10A6 F0          	pop di
0075++ 10A7 E7          	pop d
0076++ 10A8 E8          	pop al
0077++ 10A9 09          	ret
0078++ 10AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10AA             ; length of null terminated string
0080++ 10AA             ; result in c
0081++ 10AA             ; pointer in d
0082++ 10AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10AA             _strlen:
0084++ 10AA DA          	push d
0085++ 10AB 38 00 00    	mov c, 0
0086++ 10AE             _strlen_l1:
0087++ 10AE BD 00       	cmp byte [d], 0
0088++ 10B0 C6 B8 10    	je _strlen_ret
0089++ 10B3 79          	inc d
0090++ 10B4 78          	inc c
0091++ 10B5 0A AE 10    	jmp _strlen_l1
0092++ 10B8             _strlen_ret:
0093++ 10B8 E7          	pop d
0094++ 10B9 09          	ret
0095++ 10BA             
0096++ 10BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10BA             ; strcmp
0098++ 10BA             ; compare two strings
0099++ 10BA             ; str1 in si
0100++ 10BA             ; str2 in di
0101++ 10BA             ; create a string compairon instrucion ?????
0102++ 10BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10BA             _strcmp:
0104++ 10BA DB          	push al
0105++ 10BB DA          	push d
0106++ 10BC E3          	push di
0107++ 10BD E2          	push si
0108++ 10BE             _strcmp_loop:
0109++ 10BE F3          	cmpsb					; compare a byte of the strings
0110++ 10BF C7 CA 10    	jne _strcmp_ret
0111++ 10C2 FB FF FF    	lea d, [si +- 1]
0112++ 10C5 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10C7 C7 BE 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10CA             _strcmp_ret:
0115++ 10CA EF          	pop si
0116++ 10CB F0          	pop di
0117++ 10CC E7          	pop d
0118++ 10CD E8          	pop al
0119++ 10CE 09          	ret
0120++ 10CF             
0121++ 10CF             
0122++ 10CF             ; strcpy
0123++ 10CF             ; copy null terminated string from si to di
0124++ 10CF             ; source in si
0125++ 10CF             ; destination in di
0126++ 10CF             _strcpy:
0127++ 10CF E2          	push si
0128++ 10D0 E3          	push di
0129++ 10D1 DB          	push al
0130++ 10D2             _strcpy_l1:
0131++ 10D2 F6          	lodsb
0132++ 10D3 F7          	stosb
0133++ 10D4 B9 00       	cmp al, 0
0134++ 10D6 C7 D2 10    	jne _strcpy_l1
0135++ 10D9             _strcpy_end:
0136++ 10D9 E8          	pop al
0137++ 10DA F0          	pop di
0138++ 10DB EF          	pop si
0139++ 10DC 09          	ret
0140++ 10DD             
0141++ 10DD             ; strcat
0142++ 10DD             ; concatenate a null terminated string into string at di, from string at si
0143++ 10DD             ; source in si
0144++ 10DD             ; destination in di
0145++ 10DD             _strcat:
0146++ 10DD E2          	push si
0147++ 10DE E3          	push di
0148++ 10DF D7          	push a
0149++ 10E0 DA          	push d
0150++ 10E1 50          	mov a, di
0151++ 10E2 3C          	mov d, a
0152++ 10E3             _strcat_goto_end_l1:
0153++ 10E3 BD 00       	cmp byte[d], 0
0154++ 10E5 C6 EC 10    	je _strcat_start
0155++ 10E8 79          	inc d
0156++ 10E9 0A E3 10    	jmp _strcat_goto_end_l1
0157++ 10EC             _strcat_start:
0158++ 10EC FD 50       	mov di, d
0159++ 10EE             _strcat_l1:
0160++ 10EE F6          	lodsb
0161++ 10EF F7          	stosb
0162++ 10F0 B9 00       	cmp al, 0
0163++ 10F2 C7 EE 10    	jne _strcat_l1
0164++ 10F5             _strcat_end:
0165++ 10F5 E7          	pop d
0166++ 10F6 E4          	pop a
0167++ 10F7 F0          	pop di
0168++ 10F8 EF          	pop si
0169++ 10F9 09          	ret
0170++ 10FA             
0171++ 10FA             
0005+  10FA             
0006+  10FA             
0007+  10FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10FA             ; convert ascii 'o'..'f' to integer 0..15
0009+  10FA             ; ascii in bl
0010+  10FA             ; result in al
0011+  10FA             ; ascii for f = 0100 0110
0012+  10FA             ; ascii for 9 = 0011 1001
0013+  10FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10FA             hex_ascii_encode:
0015+  10FA 1B            mov al, bl
0016+  10FB 93 40         test al, $40        ; test if letter or number
0017+  10FD C7 03 11      jnz hex_letter
0018+  1100 87 0F         and al, $0f        ; get number
0019+  1102 09            ret
0020+  1103             hex_letter:
0021+  1103 87 0F         and al, $0f        ; get letter
0022+  1105 6A 09         add al, 9
0023+  1107 09            ret
0024+  1108             
0025+  1108             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1108             ; atoi
0027+  1108             ; 2 letter hex string in b
0028+  1108             ; 8bit integer returned in al
0029+  1108             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1108             _atoi:
0031+  1108 D8            push b
0032+  1109 07 FA 10      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  110C 30            mov bl, bh
0034+  110D DB            push al          ; save a
0035+  110E 07 FA 10      call hex_ascii_encode
0036+  1111 EA            pop bl  
0037+  1112 FD 9E 04      shl al, 4
0038+  1115 8C            or al, bl
0039+  1116 E5            pop b
0040+  1117 09            ret  
0041+  1118             
0042+  1118             
0043+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1118             ; scanf
0045+  1118             ; no need for explanations!
0046+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1118             scanf:
0048+  1118 09            ret
0049+  1119             
0050+  1119             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1119             ; itoa
0052+  1119             ; 8bit value in bl
0053+  1119             ; 2 byte ascii result in a
0054+  1119             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1119             _itoa:
0056+  1119 DA            push d
0057+  111A D8            push b
0058+  111B A7 00         mov bh, 0
0059+  111D FD A4 04      shr bl, 4  
0060+  1120 74            mov d, b
0061+  1121 1F B3 13      mov al, [d + s_hex_digits]
0062+  1124 23            mov ah, al
0063+  1125               
0064+  1125 E5            pop b
0065+  1126 D8            push b
0066+  1127 A7 00         mov bh, 0
0067+  1129 FD 87 0F      and bl, $0f
0068+  112C 74            mov d, b
0069+  112D 1F B3 13      mov al, [d + s_hex_digits]
0070+  1130 E5            pop b
0071+  1131 E7            pop d
0072+  1132 09            ret
0073+  1133             
0074+  1133             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1133             ; hex string to binary
0076+  1133             ; di = destination address
0077+  1133             ; si = source
0078+  1133             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1133             _hex_to_int:
0080+  1133             _hex_to_int_l1:
0081+  1133 F6            lodsb          ; load from [si] to al
0082+  1134 B9 00         cmp al, 0        ; check if ascii 0
0083+  1136 C6 43 11      jz _hex_to_int_ret
0084+  1139 36            mov bh, al
0085+  113A F6            lodsb
0086+  113B 2F            mov bl, al
0087+  113C 07 08 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  113F F7            stosb          ; store al to [di]
0089+  1140 0A 33 11      jmp _hex_to_int_l1
0090+  1143             _hex_to_int_ret:
0091+  1143 09            ret    
0092+  1144             
0093+  1144             
0094+  1144             
0095+  1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1144             ; getchar
0097+  1144             ; char in ah
0098+  1144             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1144             getch:
0100+  1144 DB            push al
0101+  1145             getch_retry:
0102+  1145 19 01         mov al, 1
0103+  1147 05 03         syscall sys_io      ; receive in ah
0104+  1149 E8            pop al
0105+  114A 09            ret
0106+  114B             
0107+  114B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  114B             ; putchar
0109+  114B             ; char in ah
0110+  114B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  114B             _putchar:
0112+  114B DB            push al
0113+  114C 19 00         mov al, 0
0114+  114E 05 03         syscall sys_io      ; char in ah
0115+  1150 E8            pop al
0116+  1151 09            ret
0117+  1152             
0118+  1152             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  1152             ;; input a string
0120+  1152             ;; terminates with null
0121+  1152             ;; pointer in d
0122+  1152             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  1152             _gets:
0124+  1152 D7            push a
0125+  1153 DA            push d
0126+  1154             _gets_loop:
0127+  1154 19 01         mov al, 1
0128+  1156 05 03         syscall sys_io      ; receive in ah
0129+  1158 76 1B         cmp ah, 27
0130+  115A C6 7B 11      je _gets_ansi_esc
0131+  115D 76 0A         cmp ah, $0a        ; lf
0132+  115F C6 D7 11      je _gets_end
0133+  1162 76 0D         cmp ah, $0d        ; cr
0134+  1164 C6 D7 11      je _gets_end
0135+  1167 76 5C         cmp ah, $5c        ; '\\'
0136+  1169 C6 9D 11      je _gets_escape
0137+  116C 76 08         cmp ah, $08      ; check for backspace
0138+  116E C6 77 11      je _gets_backspace
0139+  1171 1A            mov al, ah
0140+  1172 3E            mov [d], al
0141+  1173 79            inc d
0142+  1174 0A 54 11      jmp _gets_loop
0143+  1177             _gets_backspace:
0144+  1177 7F            dec d
0145+  1178 0A 54 11      jmp _gets_loop
0146+  117B             _gets_ansi_esc:
0147+  117B 19 01         mov al, 1
0148+  117D 05 03         syscall sys_io        ; receive in ah without echo
0149+  117F 76 5B         cmp ah, '['
0150+  1181 C7 54 11      jne _gets_loop
0151+  1184 19 01         mov al, 1
0152+  1186 05 03         syscall sys_io          ; receive in ah without echo
0153+  1188 76 64         cmp ah, 'd'
0154+  118A C6 95 11      je _gets_left_arrow
0155+  118D 76 63         cmp ah, 'c'
0156+  118F C6 99 11      je _gets_right_arrow
0157+  1192 0A 54 11      jmp _gets_loop
0158+  1195             _gets_left_arrow:
0159+  1195 7F            dec d
0160+  1196 0A 54 11      jmp _gets_loop
0161+  1199             _gets_right_arrow:
0162+  1199 79            inc d
0163+  119A 0A 54 11      jmp _gets_loop
0164+  119D             _gets_escape:
0165+  119D 19 01         mov al, 1
0166+  119F 05 03         syscall sys_io      ; receive in ah
0167+  11A1 76 6E         cmp ah, 'n'
0168+  11A3 C6 C2 11      je _gets_lf
0169+  11A6 76 72         cmp ah, 'r'
0170+  11A8 C6 C9 11      je _gets_cr
0171+  11AB 76 30         cmp ah, '0'
0172+  11AD C6 D0 11      je _gets_null
0173+  11B0 76 5C         cmp ah, $5c  ; '\'
0174+  11B2 C6 BB 11      je _gets_slash
0175+  11B5 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  11B6 3E            mov [d], al
0177+  11B7 79            inc d
0178+  11B8 0A 54 11      jmp _gets_loop
0179+  11BB             _gets_slash:
0180+  11BB 19 5C         mov al, $5c
0181+  11BD 3E            mov [d], al
0182+  11BE 79            inc d
0183+  11BF 0A 54 11      jmp _gets_loop
0184+  11C2             _gets_lf:
0185+  11C2 19 0A         mov al, $0a
0186+  11C4 3E            mov [d], al
0187+  11C5 79            inc d
0188+  11C6 0A 54 11      jmp _gets_loop
0189+  11C9             _gets_cr:
0190+  11C9 19 0D         mov al, $0d
0191+  11CB 3E            mov [d], al
0192+  11CC 79            inc d
0193+  11CD 0A 54 11      jmp _gets_loop
0194+  11D0             _gets_null:
0195+  11D0 19 00         mov al, $00
0196+  11D2 3E            mov [d], al
0197+  11D3 79            inc d
0198+  11D4 0A 54 11      jmp _gets_loop
0199+  11D7             _gets_end:
0200+  11D7 19 00         mov al, 0
0201+  11D9 3E            mov [d], al        ; terminate string
0202+  11DA E7            pop d
0203+  11DB E4            pop a
0204+  11DC 09            ret
0205+  11DD             
0206+  11DD             
0207+  11DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11DD             ;; input text
0209+  11DD             ;; terminated with ctrl+d
0210+  11DD             ;; pointer in d
0211+  11DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11DD             _gettxt:
0213+  11DD D7            push a
0214+  11DE DA            push d
0215+  11DF             _gettxt_loop:
0216+  11DF 19 01         mov al, 1
0217+  11E1 05 03         syscall sys_io      ; receive in ah
0218+  11E3 76 04         cmp ah, 4      ; eot
0219+  11E5 C6 1E 12      je _gettxt_end
0220+  11E8 76 08         cmp ah, $08      ; check for backspace
0221+  11EA C6 1A 12      je _gettxt_backspace
0222+  11ED 76 5C         cmp ah, $5c        ; '\'
0223+  11EF C6 F8 11      je _gettxt_escape
0224+  11F2 1A            mov al, ah
0225+  11F3 3E            mov [d], al
0226+  11F4 79            inc d
0227+  11F5 0A DF 11      jmp _gettxt_loop
0228+  11F8             _gettxt_escape:
0229+  11F8 19 01         mov al, 1
0230+  11FA 05 03         syscall sys_io      ; receive in ah
0231+  11FC 76 6E         cmp ah, 'n'
0232+  11FE C6 0C 12      je _gettxt_lf
0233+  1201 76 72         cmp ah, 'r'
0234+  1203 C6 13 12      je _gettxt_cr
0235+  1206 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1207 3E            mov [d], al
0237+  1208 79            inc d
0238+  1209 0A DF 11      jmp _gettxt_loop
0239+  120C             _gettxt_lf:
0240+  120C 19 0A         mov al, $0a
0241+  120E 3E            mov [d], al
0242+  120F 79            inc d
0243+  1210 0A DF 11      jmp _gettxt_loop
0244+  1213             _gettxt_cr:
0245+  1213 19 0D         mov al, $0d
0246+  1215 3E            mov [d], al
0247+  1216 79            inc d
0248+  1217 0A DF 11      jmp _gettxt_loop
0249+  121A             _gettxt_backspace:
0250+  121A 7F            dec d
0251+  121B 0A DF 11      jmp _gettxt_loop
0252+  121E             _gettxt_end:
0253+  121E 19 00         mov al, 0
0254+  1220 3E            mov [d], al        ; terminate string
0255+  1221 E7            pop d
0256+  1222 E4            pop a
0257+  1223 09            ret
0258+  1224             
0259+  1224             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1224             ; print new line
0261+  1224             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1224             printnl:
0263+  1224 D7            push a
0264+  1225 10 00 0A      mov a, $0a00
0265+  1228 05 03         syscall sys_io
0266+  122A 10 00 0D      mov a, $0d00
0267+  122D 05 03         syscall sys_io
0268+  122F E4            pop a
0269+  1230 09            ret
0270+  1231             
0271+  1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1231             ; _strtoint
0273+  1231             ; 4 digit hex string number in d
0274+  1231             ; integer returned in a
0275+  1231             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1231             _strtointx:
0277+  1231 D8            push b
0278+  1232 32            mov bl, [d]
0279+  1233 37            mov bh, bl
0280+  1234 33 01 00      mov bl, [d + 1]
0281+  1237 07 08 11      call _atoi        ; convert to int in al
0282+  123A 23            mov ah, al        ; move to ah
0283+  123B 33 02 00      mov bl, [d + 2]
0284+  123E 37            mov bh, bl
0285+  123F 33 03 00      mov bl, [d + 3]
0286+  1242 07 08 11      call _atoi        ; convert to int in al
0287+  1245 E5            pop b
0288+  1246 09            ret
0289+  1247             
0290+  1247             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1247             ; _strtoint
0292+  1247             ; 5 digit base10 string number in d
0293+  1247             ; integer returned in a
0294+  1247             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1247             _strtoint:
0296+  1247 E2            push si
0297+  1248 D8            push b
0298+  1249 D9            push c
0299+  124A DA            push d
0300+  124B 07 AA 10      call _strlen      ; get string length in c
0301+  124E 7E            dec c
0302+  124F FD 4E         mov si, d
0303+  1251 12            mov a, c
0304+  1252 FD 99         shl a
0305+  1254 3B CB 13      mov d, table_power
0306+  1257 59            add d, a
0307+  1258 38 00 00      mov c, 0
0308+  125B             _strtoint_l0:
0309+  125B F6            lodsb      ; load ascii to al
0310+  125C B9 00         cmp al, 0
0311+  125E C6 71 12      je _strtoint_end
0312+  1261 6F 30         sub al, $30    ; make into integer
0313+  1263 22 00         mov ah, 0
0314+  1265 2A            mov b, [d]
0315+  1266 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1267 11            mov a, b
0317+  1268 28            mov b, c
0318+  1269 54            add a, b
0319+  126A 39            mov c, a
0320+  126B 63 02 00      sub d, 2
0321+  126E 0A 5B 12      jmp _strtoint_l0
0322+  1271             _strtoint_end:
0323+  1271 12            mov a, c
0324+  1272 E7            pop d
0325+  1273 E6            pop c
0326+  1274 E5            pop b
0327+  1275 EF            pop si
0328+  1276 09            ret
0329+  1277             
0330+  1277             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1277             ; print null terminated string
0332+  1277             ; pointer in d
0333+  1277             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1277             _puts:
0335+  1277 D7            push a
0336+  1278 DA            push d
0337+  1279             _puts_l1:
0338+  1279 1E            mov al, [d]
0339+  127A B9 00         cmp al, 0
0340+  127C C6 88 12      jz _puts_end
0341+  127F 23            mov ah, al
0342+  1280 19 00         mov al, 0
0343+  1282 05 03         syscall sys_io
0344+  1284 79            inc d
0345+  1285 0A 79 12      jmp _puts_l1
0346+  1288             _puts_end:
0347+  1288 E7            pop d
0348+  1289 E4            pop a
0349+  128A 09            ret
0350+  128B             
0351+  128B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  128B             ; print n size string
0353+  128B             ; pointer in d
0354+  128B             ; size in c
0355+  128B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  128B             _putsn:
0357+  128B DB            push al
0358+  128C DA            push d
0359+  128D D9            push c
0360+  128E             _putsn_l0:
0361+  128E 1E            mov al, [d]
0362+  128F 23            mov ah, al
0363+  1290 19 00         mov al, 0
0364+  1292 05 03         syscall sys_io
0365+  1294 79            inc d
0366+  1295 7E            dec c  
0367+  1296 C2 00 00      cmp c, 0
0368+  1299 C7 8E 12      jne _putsn_l0
0369+  129C             _putsn_end:
0370+  129C E6            pop c
0371+  129D E7            pop d
0372+  129E E8            pop al
0373+  129F 09            ret
0374+  12A0             
0375+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  12A0             ; print 16bit decimal number
0377+  12A0             ; input number in a
0378+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  12A0             print_u16d:
0380+  12A0 D7            push a
0381+  12A1 D8            push b
0382+  12A2 FD D8         push g
0383+  12A4 26 10 27      mov b, 10000
0384+  12A7 AE            div a, b      ; get 10000's coeff.
0385+  12A8 07 CC 12      call print_number
0386+  12AB 11            mov a, b
0387+  12AC 26 E8 03      mov b, 1000
0388+  12AF AE            div a, b      ; get 1000's coeff.
0389+  12B0 07 CC 12      call print_number
0390+  12B3 11            mov a, b
0391+  12B4 26 64 00      mov b, 100
0392+  12B7 AE            div a, b
0393+  12B8 07 CC 12      call print_number
0394+  12BB 11            mov a, b
0395+  12BC 26 0A 00      mov b, 10
0396+  12BF AE            div a, b
0397+  12C0 07 CC 12      call print_number
0398+  12C3 1B            mov al, bl      ; 1's coeff in bl
0399+  12C4 07 CC 12      call print_number
0400+  12C7 FD F1         pop g
0401+  12C9 E5            pop b
0402+  12CA E4            pop a
0403+  12CB 09            ret
0404+  12CC             
0405+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12CC             ; print al
0407+  12CC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12CC             print_number:
0409+  12CC 6A 30         add al, $30
0410+  12CE 23            mov ah, al
0411+  12CF 07 4B 11      call _putchar
0412+  12D2 09            ret
0413+  12D3             
0414+  12D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12D3             ; print 16bit hex integer
0416+  12D3             ; integer value in reg b
0417+  12D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12D3             print_u16x:
0419+  12D3 D7            push a
0420+  12D4 D8            push b
0421+  12D5 DD            push bl
0422+  12D6 30            mov bl, bh
0423+  12D7 07 19 11      call _itoa        ; convert bh to char in a
0424+  12DA 2F            mov bl, al        ; save al
0425+  12DB 19 00         mov al, 0
0426+  12DD 05 03         syscall sys_io        ; display ah
0427+  12DF 24            mov ah, bl        ; retrieve al
0428+  12E0 19 00         mov al, 0
0429+  12E2 05 03         syscall sys_io        ; display al
0430+  12E4             
0431+  12E4 EA            pop bl
0432+  12E5 07 19 11      call _itoa        ; convert bh to char in a
0433+  12E8 2F            mov bl, al        ; save al
0434+  12E9 19 00         mov al, 0
0435+  12EB 05 03         syscall sys_io        ; display ah
0436+  12ED 24            mov ah, bl        ; retrieve al
0437+  12EE 19 00         mov al, 0
0438+  12F0 05 03         syscall sys_io        ; display al
0439+  12F2             
0440+  12F2 E5            pop b
0441+  12F3 E4            pop a
0442+  12F4 09            ret
0443+  12F5             
0444+  12F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12F5             ; input 16bit hex integer
0446+  12F5             ; read 16bit integer into a
0447+  12F5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12F5             scan_u16x:
0449+  12F5 F8 10 00      enter 16
0450+  12F8 D8            push b
0451+  12F9 DA            push d
0452+  12FA             
0453+  12FA FA F1 FF      lea d, [bp + -15]
0454+  12FD 07 52 11      call _gets        ; get number
0455+  1300             
0456+  1300 32            mov bl, [d]
0457+  1301 37            mov bh, bl
0458+  1302 33 01 00      mov bl, [d + 1]
0459+  1305 07 08 11      call _atoi        ; convert to int in al
0460+  1308 23            mov ah, al        ; move to ah
0461+  1309             
0462+  1309 33 02 00      mov bl, [d + 2]
0463+  130C 37            mov bh, bl
0464+  130D 33 03 00      mov bl, [d + 3]
0465+  1310 07 08 11      call _atoi        ; convert to int in al
0466+  1313             
0467+  1313 E7            pop d
0468+  1314 E5            pop b
0469+  1315 F9            leave
0470+  1316 09            ret
0471+  1317             
0472+  1317             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1317             ; print 8bit hex integer
0474+  1317             ; integer value in reg bl
0475+  1317             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1317             print_u8x:
0477+  1317 D7            push a
0478+  1318 DD            push bl
0479+  1319             
0480+  1319 07 19 11      call _itoa        ; convert bl to char in a
0481+  131C 2F            mov bl, al        ; save al
0482+  131D 19 00         mov al, 0
0483+  131F 05 03         syscall sys_io        ; display ah
0484+  1321 24            mov ah, bl        ; retrieve al
0485+  1322 19 00         mov al, 0
0486+  1324 05 03         syscall sys_io        ; display al
0487+  1326             
0488+  1326 EA            pop bl
0489+  1327 E4            pop a
0490+  1328 09            ret
0491+  1329             
0492+  1329             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1329             ; print 8bit decimal unsigned number
0494+  1329             ; input number in al
0495+  1329             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1329             print_u8d:
0497+  1329 D7            push a
0498+  132A D8            push b
0499+  132B FD D8         push g
0500+  132D 22 00         mov ah, 0
0501+  132F 26 64 00      mov b, 100
0502+  1332 AE            div a, b
0503+  1333 D8            push b      ; save remainder
0504+  1334 B9 00         cmp al, 0
0505+  1336 C6 40 13      je skip100
0506+  1339 6A 30         add al, $30
0507+  133B 23            mov ah, al
0508+  133C 19 00         mov al, 0
0509+  133E 05 03         syscall sys_io  ; print coeff
0510+  1340             skip100:
0511+  1340 E4            pop a
0512+  1341 22 00         mov ah, 0
0513+  1343 26 0A 00      mov b, 10
0514+  1346 AE            div a, b
0515+  1347 D8            push b      ; save remainder
0516+  1348 B9 00         cmp al, 0
0517+  134A C6 54 13      je skip10
0518+  134D 6A 30         add al, $30
0519+  134F 23            mov ah, al
0520+  1350 19 00         mov al, 0
0521+  1352 05 03         syscall sys_io  ; print coeff
0522+  1354             skip10:
0523+  1354 E4            pop a
0524+  1355 1B            mov al, bl
0525+  1356 6A 30         add al, $30
0526+  1358 23            mov ah, al
0527+  1359 19 00         mov al, 0
0528+  135B 05 03         syscall sys_io  ; print coeff
0529+  135D FD F1         pop g
0530+  135F E5            pop b
0531+  1360 E4            pop a
0532+  1361 09            ret
0533+  1362             
0534+  1362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  1362             ; input 8bit hex integer
0536+  1362             ; read 8bit integer into al
0537+  1362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  1362             scan_u8x:
0539+  1362 F8 04 00      enter 4
0540+  1365 D8            push b
0541+  1366 DA            push d
0542+  1367             
0543+  1367 FA FD FF      lea d, [bp + -3]
0544+  136A 07 52 11      call _gets        ; get number
0545+  136D             
0546+  136D 32            mov bl, [d]
0547+  136E 37            mov bh, bl
0548+  136F 33 01 00      mov bl, [d + 1]
0549+  1372 07 08 11      call _atoi        ; convert to int in al
0550+  1375             
0551+  1375 E7            pop d
0552+  1376 E5            pop b
0553+  1377 F9            leave
0554+  1378 09            ret
0555+  1379             
0556+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1379             ; input decimal number
0558+  1379             ; result in a
0559+  1379             ; 655'\0'
0560+  1379             ; low--------high
0561+  1379             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1379             scan_u16d:
0563+  1379 F8 08 00      enter 8
0564+  137C E2            push si
0565+  137D D8            push b
0566+  137E D9            push c
0567+  137F DA            push d
0568+  1380 FA F9 FF      lea d, [bp +- 7]
0569+  1383 07 52 11      call _gets
0570+  1386 07 AA 10      call _strlen      ; get string length in c
0571+  1389 7E            dec c
0572+  138A FD 4E         mov si, d
0573+  138C 12            mov a, c
0574+  138D FD 99         shl a
0575+  138F 3B CB 13      mov d, table_power
0576+  1392 59            add d, a
0577+  1393 38 00 00      mov c, 0
0578+  1396             mul_loop:
0579+  1396 F6            lodsb      ; load ascii to al
0580+  1397 B9 00         cmp al, 0
0581+  1399 C6 AC 13      je mul_exit
0582+  139C 6F 30         sub al, $30    ; make into integer
0583+  139E 22 00         mov ah, 0
0584+  13A0 2A            mov b, [d]
0585+  13A1 AC            mul a, b      ; result in b since it fits in 16bits
0586+  13A2 11            mov a, b
0587+  13A3 28            mov b, c
0588+  13A4 54            add a, b
0589+  13A5 39            mov c, a
0590+  13A6 63 02 00      sub d, 2
0591+  13A9 0A 96 13      jmp mul_loop
0592+  13AC             mul_exit:
0593+  13AC 12            mov a, c
0594+  13AD E7            pop d
0595+  13AE E6            pop c
0596+  13AF E5            pop b
0597+  13B0 EF            pop si
0598+  13B1 F9            leave
0599+  13B2 09            ret
0600+  13B3             
0601+  13B3             
0602+  13B3 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  13B7 34 35 36 37 
0602+  13BB 38 39 61 62 
0602+  13BF 63 64 65 66 
0603+  13C3 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  13C7 1B 5B 68 00 
0604+  13CB             
0605+  13CB             table_power:
0606+  13CB 01 00         .dw 1
0607+  13CD 0A 00         .dw 10
0608+  13CF 64 00         .dw 100
0609+  13D1 E8 03         .dw 1000
0610+  13D3 10 27         .dw 100002752   13D5             .include "lib/ctype.asm"
0001+  13D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13D5             ; ctype.s
0003+  13D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13D5             
0005+  13D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13D5             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  13D5             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  13D5             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  13D5             ;; characters are supported.
0010+  13D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13D5             ;; _isalnum 
0012+  13D5             ;; _isalpha 
0013+  13D5             ;; islower 
0014+  13D5             ;; isupper 
0015+  13D5             ;; _isdigit 
0016+  13D5             ;; isxdigit
0017+  13D5             ;; iscntrl 
0018+  13D5             ;; isgraph 
0019+  13D5             ;; _isspace 
0020+  13D5             ;; isblank 
0021+  13D5             ;; isprint 
0022+  13D5             ;; ispunct 
0023+  13D5             ;; tolower 
0024+  13D5             ;; toupper
0025+  13D5             
0026+  13D5             
0027+  13D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13D5             ;; is alphanumeric
0029+  13D5             ;; sets zf according with result
0030+  13D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13D5             _isalnum:
0032+  13D5 07 F2 13    	call _isalpha
0033+  13D8 C6 DE 13    	je _isalnum_exit
0034+  13DB 07 DF 13    	call _isdigit
0035+  13DE             _isalnum_exit:
0036+  13DE 09          	ret	
0037+  13DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13DF             ;; is digit
0039+  13DF             ;; sets zf according with result
0040+  13DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13DF             _isdigit:
0042+  13DF DB          	push al
0043+  13E0 B9 30       	cmp al, '0'
0044+  13E2 C8 EE 13    	jlu _isdigit_false
0045+  13E5 B9 39       	cmp al, '9'
0046+  13E7 D1 EE 13    	jgu _isdigit_false
0047+  13EA 87 00       	and al, 0	; set zf
0048+  13EC E8          	pop al
0049+  13ED 09          	ret
0050+  13EE             _isdigit_false:
0051+  13EE 8B 01       	or al, 1	; clear zf
0052+  13F0 E8          	pop al
0053+  13F1 09          	ret	
0054+  13F2             	
0055+  13F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13F2             ;; is alpha
0057+  13F2             ;; sets zf according with result
0058+  13F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13F2             _isalpha:
0060+  13F2 DB          	push al
0061+  13F3 B9 5F       	cmp al, '_'
0062+  13F5 C6 15 14    	je _isalpha_true
0063+  13F8 B9 2E       	cmp al, '.'
0064+  13FA C6 15 14    	je _isalpha_true
0065+  13FD B9 61       	cmp al, 'a'
0066+  13FF C8 11 14    	jlu _isalpha_false
0067+  1402 B9 7A       	cmp al, 'z'
0068+  1404 D1 11 14    	jgu _isalpha_false
0069+  1407 B9 7A       	cmp al, 'z'
0070+  1409 D0 15 14    	jleu _isalpha_true
0071+  140C B9 61       	cmp al, 'a'
0072+  140E C9 15 14    	jgeu _isalpha_true
0073+  1411             _isalpha_false:
0074+  1411 8B 01       	or al, 1	; clear zf
0075+  1413 E8          	pop al
0076+  1414 09          	ret
0077+  1415             _isalpha_true:
0078+  1415 87 00       	and al, 0	; set zf
0079+  1417 E8          	pop al
0080+  1418 09          	ret
0081+  1419             
0082+  1419             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1419             ;; is path-alpha
0084+  1419             ;; sets zf according with result
0085+  1419             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1419             ispath:
0087+  1419 DB          	push al
0088+  141A 07 DF 13    	call _isdigit
0089+  141D C6 47 14    	je ispath_true
0090+  1420 B9 5F       	cmp al, '_'
0091+  1422 C6 47 14    	je ispath_true
0092+  1425 B9 2F       	cmp al, '/'
0093+  1427 C6 47 14    	je ispath_true
0094+  142A B9 2E       	cmp al, '.'
0095+  142C C6 47 14    	je ispath_true
0096+  142F B9 61       	cmp al, 'a'
0097+  1431 C8 43 14    	jlu ispath_false
0098+  1434 B9 7A       	cmp al, 'z'
0099+  1436 D1 43 14    	jgu ispath_false
0100+  1439 B9 7A       	cmp al, 'z'
0101+  143B D0 47 14    	jleu ispath_true
0102+  143E B9 61       	cmp al, 'a'
0103+  1440 C9 47 14    	jgeu ispath_true
0104+  1443             ispath_false:
0105+  1443 8B 01       	or al, 1	; clear zf
0106+  1445 E8          	pop al
0107+  1446 09          	ret
0108+  1447             ispath_true:
0109+  1447 87 00       	and al, 0	; set zf
0110+  1449 E8          	pop al
0111+  144A 09          	ret
0112+  144B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  144B             ;; is space
0114+  144B             ;; sets zf according with result
0115+  144B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  144B             _isspace:
0117+  144B B9 20       	cmp al, $20		; ' '
0118+  144D C6 61 14    	je _isspace_exit
0119+  1450 B9 09       	cmp al, $09		; '\t'
0120+  1452 C6 61 14    	je _isspace_exit
0121+  1455 B9 0A       	cmp al, $0a		; '\n'
0122+  1457 C6 61 14    	je _isspace_exit
0123+  145A B9 0D       	cmp al, $0d		; '\r'
0124+  145C C6 61 14    	je _isspace_exit
0125+  145F B9 0B       	cmp al, $0b		; '\v'
0126+  1461             _isspace_exit:
0127+  1461 09          	ret	
0128+  1462             
0129+  1462             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  1462             ; to lower
0131+  1462             ; input in al
0132+  1462             ; output in al
0133+  1462             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  1462             _to_lower:
0135+  1462 B9 7A       	cmp al, 'z'
0136+  1464 D1 69 14    	jgu _to_lower_ret
0137+  1467 6A 20       	add al, $20				; convert to lower case
0138+  1469             _to_lower_ret:
0139+  1469 09          	ret
0140+  146A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  146A             ; to upper
0142+  146A             ; input in al
0143+  146A             ; output in al
0144+  146A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  146A             _to_upper:
0146+  146A B9 61       	cmp al, 'a'
0147+  146C C8 71 14    	jlu _to_upper_ret
0148+  146F 6F 20       	sub al, $20			; convert to upper case
0149+  1471             _to_upper_ret:
0150+  1471 09          	ret
0151+  1472             
2753   1472             .include "lib/token.asm"
0001+  1472             toktyp_identifier  .equ 0
0002+  1472             toktyp_keyword     .equ 1
0003+  1472             toktyp_delimiter   .equ 2
0004+  1472             toktyp_string      .equ 3
0005+  1472             toktyp_char        .equ 4
0006+  1472             toktyp_numeric     .equ 5
0007+  1472             toktyp_end         .equ 6
0008+  1472             
0009+  1472             tok_null           .equ 0
0010+  1472             tok_fslash         .equ 1
0011+  1472             tok_times          .equ 2
0012+  1472             tok_plus           .equ 3
0013+  1472             tok_minus          .equ 4
0014+  1472             tok_dot            .equ 5
0015+  1472             tok_semi           .equ 6
0016+  1472             tok_angle          .equ 7
0017+  1472             tok_tilde          .equ 8
0018+  1472             tok_equal          .equ 9
0019+  1472             tok_colon          .equ 10
0020+  1472             tok_comma          .equ 11
0021+  1472             
0022+  1472             tok_end            .equ 20
0023+  1472             
0024+  1472             
0025+  1472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1472             ;; read a full command argment from shell input buffer
0027+  1472             ;; argument is written into tokstr
0028+  1472             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1472             get_arg:
0030+  1472 D7            push a
0031+  1473 E2            push si
0032+  1474 E3            push di
0033+  1475 19 00         mov al, 0
0034+  1477 3D A0 16      mov [tokstr], al      ; nullify tokstr string
0035+  147A 14 9C 16      mov a, [prog]
0036+  147D 4D            mov si, a
0037+  147E FD 4F A0 16   mov di, tokstr
0038+  1482             get_arg_skip_spaces:
0039+  1482 F6            lodsb
0040+  1483 07 4B 14      call _isspace
0041+  1486 C6 82 14      je get_arg_skip_spaces
0042+  1489             get_arg_l0:
0043+  1489 B9 3B         cmp al, $3b        ; check if is ';'
0044+  148B C6 98 14      je get_arg_end
0045+  148E B9 00         cmp al, 0
0046+  1490 C6 98 14      je get_arg_end      ; check if end of input
0047+  1493 F7            stosb
0048+  1494 F6            lodsb
0049+  1495 0A 89 14      jmp get_arg_l0
0050+  1498             get_arg_end:
0051+  1498 19 00         mov al, 0
0052+  149A F7            stosb
0053+  149B D5 01 00      sub si, 1
0054+  149E 4E            mov a, si
0055+  149F 42 9C 16      mov [prog], a    ; update pointer
0056+  14A2 F0            pop di
0057+  14A3 EF            pop si
0058+  14A4 E4            pop a
0059+  14A5 09            ret
0060+  14A6             
0061+  14A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  14A6             ;; read a path formation from shell input buffer
0063+  14A6             ;; path is written into tokstr
0064+  14A6             ;; /usr/bin
0065+  14A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  14A6             get_path:
0067+  14A6 D7            push a
0068+  14A7 E2            push si
0069+  14A8 E3            push di
0070+  14A9 19 00         mov al, 0
0071+  14AB 3D A0 16      mov [tokstr], al      ; nullify tokstr string
0072+  14AE 14 9C 16      mov a, [prog]
0073+  14B1 4D            mov si, a
0074+  14B2 FD 4F A0 16   mov di, tokstr
0075+  14B6             get_path_skip_spaces:
0076+  14B6 F6            lodsb
0077+  14B7 07 4B 14      call _isspace
0078+  14BA C6 B6 14      je get_path_skip_spaces
0079+  14BD             get_path_is_pathchar:
0080+  14BD F7            stosb
0081+  14BE F6            lodsb
0082+  14BF 07 D5 13      call _isalnum      ;check if is alphanumeric
0083+  14C2 C6 BD 14      je get_path_is_pathchar
0084+  14C5 B9 2F         cmp al, '/'        ; check if is '/'
0085+  14C7 C6 BD 14      je get_path_is_pathchar
0086+  14CA 19 00         mov al, 0
0087+  14CC F7            stosb
0088+  14CD D5 01 00      sub si, 1
0089+  14D0 4E            mov a, si
0090+  14D1 42 9C 16      mov [prog], a    ; update pointer
0091+  14D4             get_path_end:
0092+  14D4 F0            pop di
0093+  14D5 EF            pop si
0094+  14D6 E4            pop a
0095+  14D7 09            ret
0096+  14D8             
0097+  14D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14D8             ;; read a line
0099+  14D8             ;; line is written into tokstr
0100+  14D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14D8             get_line:
0102+  14D8 D7            push a
0103+  14D9 E2            push si
0104+  14DA E3            push di
0105+  14DB 19 00         mov al, 0
0106+  14DD 3D A0 16      mov [tokstr], al      ; nullify tokstr string
0107+  14E0 14 9C 16      mov a, [prog]
0108+  14E3 4D            mov si, a
0109+  14E4 FD 4F A0 16   mov di, tokstr
0110+  14E8             get_line_l0:
0111+  14E8 F6            lodsb
0112+  14E9 B9 0A         cmp al, $0a    ; check for new line
0113+  14EB C6 F2 14      je get_line_exit
0114+  14EE F7            stosb
0115+  14EF 0A E8 14      jmp get_line_l0
0116+  14F2             get_line_exit:
0117+  14F2 19 00         mov al, 0
0118+  14F4 F7            stosb
0119+  14F5 4E            mov a, si
0120+  14F6 42 9C 16      mov [prog], a    ; update pointer
0121+  14F9 F0            pop di
0122+  14FA EF            pop si
0123+  14FB E4            pop a
0124+  14FC 09            ret
0125+  14FD             
0126+  14FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14FD             ;; token parser
0128+  14FD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14FD             get_token:
0130+  14FD D7            push a
0131+  14FE DA            push d
0132+  14FF E2            push si
0133+  1500 E3            push di
0134+  1501 19 00         mov al, 0
0135+  1503 3D A0 16      mov [tokstr], al      ; nullify tokstr string
0136+  1506 19 00         mov al, tok_null
0137+  1508 3D 9F 16      mov [tok], al        ; nullify token
0138+  150B 14 9C 16      mov a, [prog]
0139+  150E 4D            mov si, a
0140+  150F FD 4F A0 16   mov di, tokstr
0141+  1513             get_tok_skip_spaces:
0142+  1513 F6            lodsb
0143+  1514 07 4B 14      call _isspace
0144+  1517 C6 13 15      je get_tok_skip_spaces
0145+  151A B9 00         cmp al, 0      ; check for end of input (null)
0146+  151C C6 01 16      je get_token_end
0147+  151F B9 23         cmp al, '#'      ; comments!
0148+  1521 C6 2F 16      je get_tok_comment
0149+  1524 07 D5 13      call _isalnum
0150+  1527 C6 0E 16      jz is_alphanumeric
0151+  152A             ; other token types
0152+  152A             get_token_slash:
0153+  152A B9 2F         cmp al, '/'        ; check if '/'
0154+  152C C7 44 15      jne get_token_minus
0155+  152F F7            stosb          ; store '/' into token string
0156+  1530 19 00         mov al, 0
0157+  1532 F7            stosb          ; terminate token string
0158+  1533 19 01         mov al, tok_fslash
0159+  1535 3D 9F 16      mov [tok], al      
0160+  1538 19 02         mov al, toktyp_delimiter
0161+  153A 3D 9E 16      mov [toktyp], al
0162+  153D 4E            mov a, si
0163+  153E 42 9C 16      mov [prog], a    ; update pointer
0164+  1541 0A 2A 16      jmp get_token_return
0165+  1544             get_token_minus:
0166+  1544 B9 2D         cmp al, '-'        ; check if '-'
0167+  1546 C7 5E 15      jne get_token_comma
0168+  1549 F7            stosb          ; store '-' into token string
0169+  154A 19 00         mov al, 0
0170+  154C F7            stosb          ; terminate token string
0171+  154D 19 04         mov al, tok_minus
0172+  154F 3D 9F 16      mov [tok], al      
0173+  1552 19 02         mov al, toktyp_delimiter
0174+  1554 3D 9E 16      mov [toktyp], al
0175+  1557 4E            mov a, si
0176+  1558 42 9C 16      mov [prog], a    ; update pointer
0177+  155B 0A 2A 16      jmp get_token_return
0178+  155E             get_token_comma:
0179+  155E B9 2C         cmp al, ','        ; check if ','
0180+  1560 C7 78 15      jne get_token_semi
0181+  1563 F7            stosb          ; store ',' into token string
0182+  1564 19 00         mov al, 0
0183+  1566 F7            stosb          ; terminate token string
0184+  1567 19 0B         mov al, tok_comma
0185+  1569 3D 9F 16      mov [tok], al      
0186+  156C 19 02         mov al, toktyp_delimiter
0187+  156E 3D 9E 16      mov [toktyp], al
0188+  1571 4E            mov a, si
0189+  1572 42 9C 16      mov [prog], a    ; update pointer
0190+  1575 0A 2A 16      jmp get_token_return
0191+  1578             get_token_semi:
0192+  1578 B9 3B         cmp al, $3b        ; check if ';'
0193+  157A C7 92 15      jne get_token_colon
0194+  157D F7            stosb          ; store ';' into token string
0195+  157E 19 00         mov al, 0
0196+  1580 F7            stosb          ; terminate token string
0197+  1581 19 06         mov al, tok_semi
0198+  1583 3D 9F 16      mov [tok], al      
0199+  1586 19 02         mov al, toktyp_delimiter
0200+  1588 3D 9E 16      mov [toktyp], al
0201+  158B 4E            mov a, si
0202+  158C 42 9C 16      mov [prog], a    ; update pointer
0203+  158F 0A 2A 16      jmp get_token_return
0204+  1592             get_token_colon:
0205+  1592 B9 3A         cmp al, $3a        ; check if ':'
0206+  1594 C7 AC 15      jne get_token_angle
0207+  1597 F7            stosb          ; store ':' into token string
0208+  1598 19 00         mov al, 0
0209+  159A F7            stosb          ; terminate token string
0210+  159B 19 0A         mov al, tok_colon
0211+  159D 3D 9F 16      mov [tok], al      
0212+  15A0 19 02         mov al, toktyp_delimiter
0213+  15A2 3D 9E 16      mov [toktyp], al
0214+  15A5 4E            mov a, si
0215+  15A6 42 9C 16      mov [prog], a    ; update pointer
0216+  15A9 0A 2A 16      jmp get_token_return
0217+  15AC             get_token_angle:
0218+  15AC B9 3E         cmp al, $3e        ; check if '>'
0219+  15AE C7 C6 15      jne get_token_tilde
0220+  15B1 F7            stosb          ; store '>' into token string
0221+  15B2 19 00         mov al, 0
0222+  15B4 F7            stosb          ; terminate token string
0223+  15B5 19 07         mov al, tok_angle
0224+  15B7 3D 9F 16      mov [tok], al      
0225+  15BA 19 02         mov al, toktyp_delimiter
0226+  15BC 3D 9E 16      mov [toktyp], al
0227+  15BF 4E            mov a, si
0228+  15C0 42 9C 16      mov [prog], a    ; update pointer
0229+  15C3 0A 2A 16      jmp get_token_return
0230+  15C6             get_token_tilde:
0231+  15C6 B9 7E         cmp al, '~'        ; check if '~'
0232+  15C8 C7 E0 15      jne get_token_equal
0233+  15CB F7            stosb          ; store '~' into token string
0234+  15CC 19 00         mov al, 0
0235+  15CE F7            stosb          ; terminate token string
0236+  15CF 19 08         mov al, tok_tilde
0237+  15D1 3D 9F 16      mov [tok], al      
0238+  15D4 19 02         mov al, toktyp_delimiter
0239+  15D6 3D 9E 16      mov [toktyp], al
0240+  15D9 4E            mov a, si
0241+  15DA 42 9C 16      mov [prog], a    ; update pointer
0242+  15DD 0A 2A 16      jmp get_token_return
0243+  15E0             get_token_equal:
0244+  15E0 B9 3D         cmp al, '='        ; check if '='
0245+  15E2 C7 FA 15      jne get_token_skip
0246+  15E5 F7            stosb          ; store '=' into token string
0247+  15E6 19 00         mov al, 0
0248+  15E8 F7            stosb          ; terminate token string
0249+  15E9 19 09         mov al, tok_equal
0250+  15EB 3D 9F 16      mov [tok], al      
0251+  15EE 19 02         mov al, toktyp_delimiter
0252+  15F0 3D 9E 16      mov [toktyp], al
0253+  15F3 4E            mov a, si
0254+  15F4 42 9C 16      mov [prog], a    ; update pointer
0255+  15F7 0A 2A 16      jmp get_token_return
0256+  15FA             get_token_skip:
0257+  15FA 4E            mov a, si
0258+  15FB 42 9C 16      mov [prog], a    ; update pointer
0259+  15FE 0A 2A 16      jmp get_token_return
0260+  1601             get_token_end:        ; end of file token
0261+  1601 19 14         mov al, tok_end
0262+  1603 3D 9F 16      mov [tok], al
0263+  1606 19 06         mov al, toktyp_end
0264+  1608 3D 9E 16      mov [toktyp], al
0265+  160B 0A 2A 16      jmp get_token_return
0266+  160E             is_alphanumeric:
0267+  160E F7            stosb
0268+  160F F6            lodsb
0269+  1610 07 D5 13      call _isalnum      ;check if is alphanumeric
0270+  1613 C6 0E 16      jz is_alphanumeric
0271+  1616 B9 2E         cmp al, $2e        ; check if is '.'
0272+  1618 C6 0E 16      je is_alphanumeric
0273+  161B 19 00         mov al, 0
0274+  161D F7            stosb
0275+  161E 19 00         mov al, toktyp_identifier
0276+  1620 3D 9E 16      mov [toktyp], al
0277+  1623 D5 01 00      sub si, 1
0278+  1626 4E            mov a, si
0279+  1627 42 9C 16      mov [prog], a    ; update pointer
0280+  162A             get_token_return:
0281+  162A F0            pop di
0282+  162B EF            pop si
0283+  162C E7            pop d
0284+  162D E4            pop a
0285+  162E 09            ret
0286+  162F             get_tok_comment:
0287+  162F F6            lodsb
0288+  1630 B9 0A         cmp al, $0a      ; new line
0289+  1632 C7 2F 16      jne get_tok_comment
0290+  1635 0A 13 15      jmp get_tok_skip_spaces
0291+  1638             
0292+  1638             
0293+  1638             get_number:
0294+  1638 D7            push a
0295+  1639 DA            push d
0296+  163A E2            push si
0297+  163B E3            push di
0298+  163C 19 00         mov al, 0
0299+  163E 3D A0 16      mov [tokstr], al      ; nullify tokstr string
0300+  1641 19 00         mov al, tok_null
0301+  1643 3D 9F 16      mov [tok], al        ; nullify token
0302+  1646 14 9C 16      mov a, [prog]
0303+  1649 4D            mov si, a
0304+  164A FD 4F A0 16   mov di, tokstr
0305+  164E             get_number_skip_spaces:
0306+  164E F6            lodsb
0307+  164F 07 4B 14      call _isspace
0308+  1652 C6 4E 16      je get_number_skip_spaces
0309+  1655 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1657 C7 67 16      jne get_number_l0
0311+  165A 19 14         mov al, tok_end
0312+  165C 3D 9F 16      mov [tok], al
0313+  165F 19 06         mov al, toktyp_end
0314+  1661 3D 9E 16      mov [toktyp], al
0315+  1664 0A 7E 16      jmp get_number_return
0316+  1667             get_number_l0:
0317+  1667 F7            stosb
0318+  1668 F6            lodsb
0319+  1669 07 DF 13      call _isdigit      ;check if is numeric
0320+  166C C6 67 16      jz get_number_l0
0321+  166F 19 00         mov al, 0
0322+  1671 F7            stosb
0323+  1672 19 05         mov al, toktyp_numeric
0324+  1674 3D 9E 16      mov [toktyp], al
0325+  1677 D5 01 00      sub si, 1
0326+  167A 4E            mov a, si
0327+  167B 42 9C 16      mov [prog], a    ; update pointer
0328+  167E             get_number_return:
0329+  167E F0            pop di
0330+  167F EF            pop si
0331+  1680 E7            pop d
0332+  1681 E4            pop a
0333+  1682 09            ret
0334+  1683             
0335+  1683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1683             ;; put back token
0337+  1683             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1683             _putback:
0339+  1683 D7            push a
0340+  1684 E2            push si
0341+  1685 FD 4D A0 16   mov si, tokstr  
0342+  1689             _putback_loop:
0343+  1689 F6            lodsb
0344+  168A B9 00         cmp al, 0
0345+  168C C6 99 16      je _putback_end
0346+  168F 14 9C 16      mov a, [prog]
0347+  1692 7D            dec a
0348+  1693 42 9C 16      mov [prog], a      ; update pointer
0349+  1696 0A 89 16      jmp _putback_loop
0350+  1699             _putback_end:
0351+  1699 EF            pop si
0352+  169A E4            pop a
0353+  169B 09            ret
0354+  169C             
0355+  169C             
0356+  169C             
0357+  169C             
0358+  169C 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  169E             
0360+  169E 00          toktyp:    .db 0          ; token type symbol
0361+  169F 00          tok:       .db 0          ; current token symbol
0362+  16A0 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  16A4 00 00 00 00 
0362+  16A8 00 00 00 00 
0362+  16AC 00 00 00 00 
0362+  16B0 00 00 00 00 
0362+  16B4 00 00 00 00 
0362+  16B8 00 00 00 00 
0362+  16BC 00 00 00 00 
0362+  16C0 00 00 00 00 
0362+  16C4 00 00 00 00 
0362+  16C8 00 00 00 00 
0362+  16CC 00 00 00 00 
0362+  16D0 00 00 00 00 
0362+  16D4 00 00 00 00 
0362+  16D8 00 00 00 00 
0362+  16DC 00 00 00 00 
0362+  16E0 00 00 00 00 
0362+  16E4 00 00 00 00 
0362+  16E8 00 00 00 00 
0362+  16EC 00 00 00 00 
0362+  16F0 00 00 00 00 
0362+  16F4 00 00 00 00 
0362+  16F8 00 00 00 00 
0362+  16FC 00 00 00 00 
0362+  1700 00 00 00 00 
0362+  1704 00 00 00 00 
0362+  1708 00 00 00 00 
0362+  170C 00 00 00 00 
0362+  1710 00 00 00 00 
0362+  1714 00 00 00 00 
0362+  1718 00 00 00 00 
0362+  171C 00 00 00 00 
0362+  1720 00 00 00 00 
0362+  1724 00 00 00 00 
0362+  1728 00 00 00 00 
0362+  172C 00 00 00 00 
0362+  1730 00 00 00 00 
0362+  1734 00 00 00 00 
0362+  1738 00 00 00 00 
0362+  173C 00 00 00 00 
0362+  1740 00 00 00 00 
0362+  1744 00 00 00 00 
0362+  1748 00 00 00 00 
0362+  174C 00 00 00 00 
0362+  1750 00 00 00 00 
0362+  1754 00 00 00 00 
0362+  1758 00 00 00 00 
0362+  175C 00 00 00 00 
0362+  1760 00 00 00 00 
0362+  1764 00 00 00 00 
0362+  1768 00 00 00 00 
0362+  176C 00 00 00 00 
0362+  1770 00 00 00 00 
0362+  1774 00 00 00 00 
0362+  1778 00 00 00 00 
0362+  177C 00 00 00 00 
0362+  1780 00 00 00 00 
0362+  1784 00 00 00 00 
0362+  1788 00 00 00 00 
0362+  178C 00 00 00 00 
0362+  1790 00 00 00 00 
0362+  1794 00 00 00 00 
0362+  1798 00 00 00 00 
0362+  179C 00 00 00 00 
2754   17A0             
2755   17A0             ; kernel parameters
2756   17A0             sys_debug_mode:
2757   17A0 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2758   17A1             sys_echo_on:
2759   17A1 01            .db 1
2760   17A2             sys_uart0_lcr:
2761   17A2 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2762   17A3             sys_uart0_inten:
2763   17A3 01            .db 1
2764   17A4             sys_uart0_fifoen:
2765   17A4 00            .db 0
2766   17A5             sys_uart0_div0:
2767   17A5 03            .db 3
2768   17A6             sys_uart0_div1:
2769   17A6 00            .db 0   ; default baud = 38400
2770   17A7             ; baud  divisor
2771   17A7             ; 50    2304
2772   17A7             ; 110   1047
2773   17A7             ; 300    384
2774   17A7             ; 600    192
2775   17A7             ; 1200    96
2776   17A7             ; 9600    12
2777   17A7             ; 19200    6
2778   17A7             ; 38400    3
2779   17A7             
2780   17A7             nbr_active_procs:
2781   17A7 00            .db 0
2782   17A8             active_proc_index:
2783   17A8 01            .db 1
2784   17A9             
2785   17A9             index:
2786   17A9 00 00         .dw 0
2787   17AB             buffer_addr:
2788   17AB 00 00         .dw 0
2789   17AD             
2790   17AD             fifo_in:
2791   17AD 0E 1F         .dw fifo
2792   17AF             fifo_out:
2793   17AF 0E 1F         .dw fifo
2794   17B1             
2795   17B1             ; file system variables
2796   17B1             current_dir_id:
2797   17B1 00 00         .dw 0     ; keep dirid of current directory
2798   17B3             s_init_path:
2799   17B3 2F 73 62 69   .db "/sbin/init", 0
2799   17B7 6E 2F 69 6E 
2799   17BB 69 74 00 
2800   17BE             
2801   17BE             s_uname:
2802   17BE 73 6F 6C 61   .db "solarium v.1.0", 0
2802   17C2 72 69 75 6D 
2802   17C6 20 76 2E 31 
2802   17CA 2E 30 00 
2803   17CD             s_dataentry:
2804   17CD 3E 20 00      .db "> ", 0
2805   17D0             s_parent_dir:
2806   17D0 2E 2E 00      .db "..", 0
2807   17D3             s_current_dir:
2808   17D3 2E 00         .db ".", 0
2809   17D5             s_fslash:
2810   17D5 2F 00         .db "/", 0
2811   17D7             file_attrib:
2812   17D7 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2812   17DB 78 
2813   17DC             file_type:
2814   17DC 2D 64 63      .db "-dc"
2815   17DF             s_ps_header:
2816   17DF 70 69 64 20   .db "pid command\n", 0
2816   17E3 63 6F 6D 6D 
2816   17E7 61 6E 64 0A 
2816   17EB 00 
2817   17EC             s_ls_total:
2818   17EC 74 6F 74 61   .db "total: ", 0
2818   17F0 6C 3A 20 00 
2819   17F4             
2820   17F4             s_int_en:
2821   17F4 69 72 71 73   .db "irqs enabled\n", 0
2821   17F8 20 65 6E 61 
2821   17FC 62 6C 65 64 
2821   1800 0A 00 
2822   1802             s_kernel_started:
2823   1802 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2823   1806 65 6C 20 73 
2823   180A 74 61 72 74 
2823   180E 65 64 28 76 
2823   1812 65 72 73 69 
2823   1816 6F 6E 20 31 
2823   181A 2E 30 29 0A 
2823   181E 00 
2824   181F             s_prompt_init:
2825   181F 73 74 61 72   .db "starting init\n", 0
2825   1823 74 69 6E 67 
2825   1827 20 69 6E 69 
2825   182B 74 0A 00 
2826   182E             s_priviledge:
2827   182E 0A 65 78 63   .db "\nexception: privilege\n", 0
2827   1832 65 70 74 69 
2827   1836 6F 6E 3A 20 
2827   183A 70 72 69 76 
2827   183E 69 6C 65 67 
2827   1842 65 0A 00 
2828   1845             s_divzero:
2829   1845 0A 65 78 63   .db "\nexception: zero division\n", 0
2829   1849 65 70 74 69 
2829   184D 6F 6E 3A 20 
2829   1851 7A 65 72 6F 
2829   1855 20 64 69 76 
2829   1859 69 73 69 6F 
2829   185D 6E 0A 00 
2830   1860             
2831   1860             s_set_year:
2832   1860 79 65 61 72   .db "year: ", 0
2832   1864 3A 20 00 
2833   1867             s_set_month:
2834   1867 6D 6F 6E 74   .db "month: ", 0
2834   186B 68 3A 20 00 
2835   186F             s_set_day:
2836   186F 64 61 79 3A   .db "day: ", 0
2836   1873 20 00 
2837   1875             s_set_week:
2838   1875 77 65 65 6B   .db "weekday: ", 0
2838   1879 64 61 79 3A 
2838   187D 20 00 
2839   187F             s_set_hours:
2840   187F 68 6F 75 72   .db "hours: ", 0
2840   1883 73 3A 20 00 
2841   1887             s_set_minutes:
2842   1887 6D 69 6E 75   .db "minutes: ", 0
2842   188B 74 65 73 3A 
2842   188F 20 00 
2843   1891             s_set_seconds:
2844   1891 73 65 63 6F   .db "seconds: ", 0
2844   1895 6E 64 73 3A 
2844   1899 20 00 
2845   189B             s_months:      
2846   189B 20 20 20 00   .db "   ", 0
2847   189F 6A 61 6E 00   .db "jan", 0
2848   18A3 66 65 62 00   .db "feb", 0
2849   18A7 6D 61 72 00   .db "mar", 0
2850   18AB 61 70 72 00   .db "apr", 0
2851   18AF 6D 61 79 00   .db "may", 0
2852   18B3 6A 75 6E 00   .db "jun", 0
2853   18B7 6A 75 6C 00   .db "jul", 0
2854   18BB 61 75 67 00   .db "aug", 0
2855   18BF 73 65 70 00   .db "sep", 0
2856   18C3 6F 63 74 00   .db "oct", 0
2857   18C7 6E 6F 76 00   .db "nov", 0
2858   18CB 64 65 63 00   .db "dec", 0
2859   18CF             
2860   18CF             s_week:        
2861   18CF 73 75 6E 00   .db "sun", 0 
2862   18D3 6D 6F 6E 00   .db "mon", 0 
2863   18D7 74 75 65 00   .db "tue", 0 
2864   18DB 77 65 64 00   .db "wed", 0 
2865   18DF 74 68 75 00   .db "thu", 0 
2866   18E3 66 72 69 00   .db "fri", 0 
2867   18E7 73 61 74 00   .db "sat", 0
2868   18EB             
2869   18EB 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2869   18EF 30 20 45 78 
2869   18F3 65 63 75 74 
2869   18F7 65 64 2E 0A 
2869   18FB 00 
2870   18FC             s_fdc_config:
2871   18FC 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2871   1900 65 63 74 69 
2871   1904 6E 67 20 64 
2871   1908 69 73 6B 65 
2871   190C 74 74 65 20 
2871   1910 64 72 69 76 
2871   1914 65 20 30 2C 
2871   1918 20 73 69 64 
2871   191C 65 20 30 2C 
2871   1920 20 73 69 6E 
2871   1924 67 6C 65 20 
2871   1928 64 65 6E 73 
2871   192C 69 74 79 2C 
2871   1930 20 68 65 61 
2871   1934 64 20 6C 6F 
2871   1938 61 64 65 64 
2871   193C 0A 00 
2872   193E             
2873   193E             proc_state_table:   
2874   193E 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2874   1942 00 00 00 00 
2874   1946 00 00 00 00 
2874   194A 00 00 00 00 
2874   194E 00 00 00 00 
2874   1952 00 00 00 00 
2874   1956 00 00 00 00 
2874   195A 00 00 00 00 
2874   195E 00 00 00 00 
2874   1962 00 00 00 00 
2874   1966 00 00 00 00 
2874   196A 00 00 00 00 
2874   196E 00 00 00 00 
2874   1972 00 00 00 00 
2874   1976 00 00 00 00 
2874   197A 00 00 00 00 
2874   197E 00 00 00 00 
2874   1982 00 00 00 00 
2874   1986 00 00 00 00 
2874   198A 00 00 00 00 
2874   198E 00 00 00 00 
2874   1992 00 00 00 00 
2874   1996 00 00 00 00 
2874   199A 00 00 00 00 
2874   199E 00 00 00 00 
2874   19A2 00 00 00 00 
2874   19A6 00 00 00 00 
2874   19AA 00 00 00 00 
2874   19AE 00 00 00 00 
2874   19B2 00 00 00 00 
2874   19B6 00 00 00 00 
2874   19BA 00 00 00 00 
2874   19BE 00 00 00 00 
2874   19C2 00 00 00 00 
2874   19C6 00 00 00 00 
2874   19CA 00 00 00 00 
2874   19CE 00 00 00 00 
2874   19D2 00 00 00 00 
2874   19D6 00 00 00 00 
2874   19DA 00 00 00 00 
2874   19DE 00 00 00 00 
2874   19E2 00 00 00 00 
2874   19E6 00 00 00 00 
2874   19EA 00 00 00 00 
2874   19EE 00 00 00 00 
2874   19F2 00 00 00 00 
2874   19F6 00 00 00 00 
2874   19FA 00 00 00 00 
2874   19FE 00 00 00 00 
2874   1A02 00 00 00 00 
2874   1A06 00 00 00 00 
2874   1A0A 00 00 00 00 
2874   1A0E 00 00 00 00 
2874   1A12 00 00 00 00 
2874   1A16 00 00 00 00 
2874   1A1A 00 00 00 00 
2874   1A1E 00 00 00 00 
2874   1A22 00 00 00 00 
2874   1A26 00 00 00 00 
2874   1A2A 00 00 00 00 
2874   1A2E 00 00 00 00 
2874   1A32 00 00 00 00 
2874   1A36 00 00 00 00 
2874   1A3A 00 00 00 00 
2874   1A3E 00 00 00 00 
2874   1A42 00 00 00 00 
2874   1A46 00 00 00 00 
2874   1A4A 00 00 00 00 
2874   1A4E 00 00 00 00 
2874   1A52 00 00 00 00 
2874   1A56 00 00 00 00 
2874   1A5A 00 00 00 00 
2874   1A5E 00 00 00 00 
2874   1A62 00 00 00 00 
2874   1A66 00 00 00 00 
2874   1A6A 00 00 00 00 
2874   1A6E 00 00 00 00 
2874   1A72 00 00 00 00 
2874   1A76 00 00 00 00 
2874   1A7A 00 00 00 00 
2875   1A7E             proc_availab_table: 
2876   1A7E 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2876   1A82 00 00 00 00 
2876   1A86 00 00 00 00 
2876   1A8A 00 00 00 00 
2877   1A8E             proc_names:
2878   1A8E 00 00 00 00   .fill 16 * 32, 0  ; process names
2878   1A92 00 00 00 00 
2878   1A96 00 00 00 00 
2878   1A9A 00 00 00 00 
2878   1A9E 00 00 00 00 
2878   1AA2 00 00 00 00 
2878   1AA6 00 00 00 00 
2878   1AAA 00 00 00 00 
2878   1AAE 00 00 00 00 
2878   1AB2 00 00 00 00 
2878   1AB6 00 00 00 00 
2878   1ABA 00 00 00 00 
2878   1ABE 00 00 00 00 
2878   1AC2 00 00 00 00 
2878   1AC6 00 00 00 00 
2878   1ACA 00 00 00 00 
2878   1ACE 00 00 00 00 
2878   1AD2 00 00 00 00 
2878   1AD6 00 00 00 00 
2878   1ADA 00 00 00 00 
2878   1ADE 00 00 00 00 
2878   1AE2 00 00 00 00 
2878   1AE6 00 00 00 00 
2878   1AEA 00 00 00 00 
2878   1AEE 00 00 00 00 
2878   1AF2 00 00 00 00 
2878   1AF6 00 00 00 00 
2878   1AFA 00 00 00 00 
2878   1AFE 00 00 00 00 
2878   1B02 00 00 00 00 
2878   1B06 00 00 00 00 
2878   1B0A 00 00 00 00 
2878   1B0E 00 00 00 00 
2878   1B12 00 00 00 00 
2878   1B16 00 00 00 00 
2878   1B1A 00 00 00 00 
2878   1B1E 00 00 00 00 
2878   1B22 00 00 00 00 
2878   1B26 00 00 00 00 
2878   1B2A 00 00 00 00 
2878   1B2E 00 00 00 00 
2878   1B32 00 00 00 00 
2878   1B36 00 00 00 00 
2878   1B3A 00 00 00 00 
2878   1B3E 00 00 00 00 
2878   1B42 00 00 00 00 
2878   1B46 00 00 00 00 
2878   1B4A 00 00 00 00 
2878   1B4E 00 00 00 00 
2878   1B52 00 00 00 00 
2878   1B56 00 00 00 00 
2878   1B5A 00 00 00 00 
2878   1B5E 00 00 00 00 
2878   1B62 00 00 00 00 
2878   1B66 00 00 00 00 
2878   1B6A 00 00 00 00 
2878   1B6E 00 00 00 00 
2878   1B72 00 00 00 00 
2878   1B76 00 00 00 00 
2878   1B7A 00 00 00 00 
2878   1B7E 00 00 00 00 
2878   1B82 00 00 00 00 
2878   1B86 00 00 00 00 
2878   1B8A 00 00 00 00 
2878   1B8E 00 00 00 00 
2878   1B92 00 00 00 00 
2878   1B96 00 00 00 00 
2878   1B9A 00 00 00 00 
2878   1B9E 00 00 00 00 
2878   1BA2 00 00 00 00 
2878   1BA6 00 00 00 00 
2878   1BAA 00 00 00 00 
2878   1BAE 00 00 00 00 
2878   1BB2 00 00 00 00 
2878   1BB6 00 00 00 00 
2878   1BBA 00 00 00 00 
2878   1BBE 00 00 00 00 
2878   1BC2 00 00 00 00 
2878   1BC6 00 00 00 00 
2878   1BCA 00 00 00 00 
2878   1BCE 00 00 00 00 
2878   1BD2 00 00 00 00 
2878   1BD6 00 00 00 00 
2878   1BDA 00 00 00 00 
2878   1BDE 00 00 00 00 
2878   1BE2 00 00 00 00 
2878   1BE6 00 00 00 00 
2878   1BEA 00 00 00 00 
2878   1BEE 00 00 00 00 
2878   1BF2 00 00 00 00 
2878   1BF6 00 00 00 00 
2878   1BFA 00 00 00 00 
2878   1BFE 00 00 00 00 
2878   1C02 00 00 00 00 
2878   1C06 00 00 00 00 
2878   1C0A 00 00 00 00 
2878   1C0E 00 00 00 00 
2878   1C12 00 00 00 00 
2878   1C16 00 00 00 00 
2878   1C1A 00 00 00 00 
2878   1C1E 00 00 00 00 
2878   1C22 00 00 00 00 
2878   1C26 00 00 00 00 
2878   1C2A 00 00 00 00 
2878   1C2E 00 00 00 00 
2878   1C32 00 00 00 00 
2878   1C36 00 00 00 00 
2878   1C3A 00 00 00 00 
2878   1C3E 00 00 00 00 
2878   1C42 00 00 00 00 
2878   1C46 00 00 00 00 
2878   1C4A 00 00 00 00 
2878   1C4E 00 00 00 00 
2878   1C52 00 00 00 00 
2878   1C56 00 00 00 00 
2878   1C5A 00 00 00 00 
2878   1C5E 00 00 00 00 
2878   1C62 00 00 00 00 
2878   1C66 00 00 00 00 
2878   1C6A 00 00 00 00 
2878   1C6E 00 00 00 00 
2878   1C72 00 00 00 00 
2878   1C76 00 00 00 00 
2878   1C7A 00 00 00 00 
2878   1C7E 00 00 00 00 
2878   1C82 00 00 00 00 
2878   1C86 00 00 00 00 
2878   1C8A 00 00 00 00 
2879   1C8E             filename:
2880   1C8E 00 00 00 00   .fill 128, 0      ; holds a path for file search
2880   1C92 00 00 00 00 
2880   1C96 00 00 00 00 
2880   1C9A 00 00 00 00 
2880   1C9E 00 00 00 00 
2880   1CA2 00 00 00 00 
2880   1CA6 00 00 00 00 
2880   1CAA 00 00 00 00 
2880   1CAE 00 00 00 00 
2880   1CB2 00 00 00 00 
2880   1CB6 00 00 00 00 
2880   1CBA 00 00 00 00 
2880   1CBE 00 00 00 00 
2880   1CC2 00 00 00 00 
2880   1CC6 00 00 00 00 
2880   1CCA 00 00 00 00 
2880   1CCE 00 00 00 00 
2880   1CD2 00 00 00 00 
2880   1CD6 00 00 00 00 
2880   1CDA 00 00 00 00 
2880   1CDE 00 00 00 00 
2880   1CE2 00 00 00 00 
2880   1CE6 00 00 00 00 
2880   1CEA 00 00 00 00 
2880   1CEE 00 00 00 00 
2880   1CF2 00 00 00 00 
2880   1CF6 00 00 00 00 
2880   1CFA 00 00 00 00 
2880   1CFE 00 00 00 00 
2880   1D02 00 00 00 00 
2880   1D06 00 00 00 00 
2880   1D0A 00 00 00 00 
2881   1D0E             user_data:
2882   1D0E 00 00 00 00   .fill 512, 0      ;  user space data
2882   1D12 00 00 00 00 
2882   1D16 00 00 00 00 
2882   1D1A 00 00 00 00 
2882   1D1E 00 00 00 00 
2882   1D22 00 00 00 00 
2882   1D26 00 00 00 00 
2882   1D2A 00 00 00 00 
2882   1D2E 00 00 00 00 
2882   1D32 00 00 00 00 
2882   1D36 00 00 00 00 
2882   1D3A 00 00 00 00 
2882   1D3E 00 00 00 00 
2882   1D42 00 00 00 00 
2882   1D46 00 00 00 00 
2882   1D4A 00 00 00 00 
2882   1D4E 00 00 00 00 
2882   1D52 00 00 00 00 
2882   1D56 00 00 00 00 
2882   1D5A 00 00 00 00 
2882   1D5E 00 00 00 00 
2882   1D62 00 00 00 00 
2882   1D66 00 00 00 00 
2882   1D6A 00 00 00 00 
2882   1D6E 00 00 00 00 
2882   1D72 00 00 00 00 
2882   1D76 00 00 00 00 
2882   1D7A 00 00 00 00 
2882   1D7E 00 00 00 00 
2882   1D82 00 00 00 00 
2882   1D86 00 00 00 00 
2882   1D8A 00 00 00 00 
2882   1D8E 00 00 00 00 
2882   1D92 00 00 00 00 
2882   1D96 00 00 00 00 
2882   1D9A 00 00 00 00 
2882   1D9E 00 00 00 00 
2882   1DA2 00 00 00 00 
2882   1DA6 00 00 00 00 
2882   1DAA 00 00 00 00 
2882   1DAE 00 00 00 00 
2882   1DB2 00 00 00 00 
2882   1DB6 00 00 00 00 
2882   1DBA 00 00 00 00 
2882   1DBE 00 00 00 00 
2882   1DC2 00 00 00 00 
2882   1DC6 00 00 00 00 
2882   1DCA 00 00 00 00 
2882   1DCE 00 00 00 00 
2882   1DD2 00 00 00 00 
2882   1DD6 00 00 00 00 
2882   1DDA 00 00 00 00 
2882   1DDE 00 00 00 00 
2882   1DE2 00 00 00 00 
2882   1DE6 00 00 00 00 
2882   1DEA 00 00 00 00 
2882   1DEE 00 00 00 00 
2882   1DF2 00 00 00 00 
2882   1DF6 00 00 00 00 
2882   1DFA 00 00 00 00 
2882   1DFE 00 00 00 00 
2882   1E02 00 00 00 00 
2882   1E06 00 00 00 00 
2882   1E0A 00 00 00 00 
2882   1E0E 00 00 00 00 
2882   1E12 00 00 00 00 
2882   1E16 00 00 00 00 
2882   1E1A 00 00 00 00 
2882   1E1E 00 00 00 00 
2882   1E22 00 00 00 00 
2882   1E26 00 00 00 00 
2882   1E2A 00 00 00 00 
2882   1E2E 00 00 00 00 
2882   1E32 00 00 00 00 
2882   1E36 00 00 00 00 
2882   1E3A 00 00 00 00 
2882   1E3E 00 00 00 00 
2882   1E42 00 00 00 00 
2882   1E46 00 00 00 00 
2882   1E4A 00 00 00 00 
2882   1E4E 00 00 00 00 
2882   1E52 00 00 00 00 
2882   1E56 00 00 00 00 
2882   1E5A 00 00 00 00 
2882   1E5E 00 00 00 00 
2882   1E62 00 00 00 00 
2882   1E66 00 00 00 00 
2882   1E6A 00 00 00 00 
2882   1E6E 00 00 00 00 
2882   1E72 00 00 00 00 
2882   1E76 00 00 00 00 
2882   1E7A 00 00 00 00 
2882   1E7E 00 00 00 00 
2882   1E82 00 00 00 00 
2882   1E86 00 00 00 00 
2882   1E8A 00 00 00 00 
2882   1E8E 00 00 00 00 
2882   1E92 00 00 00 00 
2882   1E96 00 00 00 00 
2882   1E9A 00 00 00 00 
2882   1E9E 00 00 00 00 
2882   1EA2 00 00 00 00 
2882   1EA6 00 00 00 00 
2882   1EAA 00 00 00 00 
2882   1EAE 00 00 00 00 
2882   1EB2 00 00 00 00 
2882   1EB6 00 00 00 00 
2882   1EBA 00 00 00 00 
2882   1EBE 00 00 00 00 
2882   1EC2 00 00 00 00 
2882   1EC6 00 00 00 00 
2882   1ECA 00 00 00 00 
2882   1ECE 00 00 00 00 
2882   1ED2 00 00 00 00 
2882   1ED6 00 00 00 00 
2882   1EDA 00 00 00 00 
2882   1EDE 00 00 00 00 
2882   1EE2 00 00 00 00 
2882   1EE6 00 00 00 00 
2882   1EEA 00 00 00 00 
2882   1EEE 00 00 00 00 
2882   1EF2 00 00 00 00 
2882   1EF6 00 00 00 00 
2882   1EFA 00 00 00 00 
2882   1EFE 00 00 00 00 
2882   1F02 00 00 00 00 
2882   1F06 00 00 00 00 
2882   1F0A 00 00 00 00 
2883   1F0E             fifo:
2884   1F0E FF FF FF FF   .fill fifo_size
2884   1F12 FF FF FF FF 
2884   1F16 FF FF FF FF 
2884   1F1A FF FF FF FF 
2884   1F1E FF FF FF FF 
2884   1F22 FF FF FF FF 
2884   1F26 FF FF FF FF 
2884   1F2A FF FF FF FF 
2884   1F2E FF FF FF FF 
2884   1F32 FF FF FF FF 
2884   1F36 FF FF FF FF 
2884   1F3A FF FF FF FF 
2884   1F3E FF FF FF FF 
2884   1F42 FF FF FF FF 
2884   1F46 FF FF FF FF 
2884   1F4A FF FF FF FF 
2884   1F4E FF FF FF FF 
2884   1F52 FF FF FF FF 
2884   1F56 FF FF FF FF 
2884   1F5A FF FF FF FF 
2884   1F5E FF FF FF FF 
2884   1F62 FF FF FF FF 
2884   1F66 FF FF FF FF 
2884   1F6A FF FF FF FF 
2884   1F6E FF FF FF FF 
2884   1F72 FF FF FF FF 
2884   1F76 FF FF FF FF 
2884   1F7A FF FF FF FF 
2884   1F7E FF FF FF FF 
2884   1F82 FF FF FF FF 
2884   1F86 FF FF FF FF 
2884   1F8A FF FF FF FF 
2884   1F8E FF FF FF FF 
2884   1F92 FF FF FF FF 
2884   1F96 FF FF FF FF 
2884   1F9A FF FF FF FF 
2884   1F9E FF FF FF FF 
2884   1FA2 FF FF FF FF 
2884   1FA6 FF FF FF FF 
2884   1FAA FF FF FF FF 
2884   1FAE FF FF FF FF 
2884   1FB2 FF FF FF FF 
2884   1FB6 FF FF FF FF 
2884   1FBA FF FF FF FF 
2884   1FBE FF FF FF FF 
2884   1FC2 FF FF FF FF 
2884   1FC6 FF FF FF FF 
2884   1FCA FF FF FF FF 
2884   1FCE FF FF FF FF 
2884   1FD2 FF FF FF FF 
2884   1FD6 FF FF FF FF 
2884   1FDA FF FF FF FF 
2884   1FDE FF FF FF FF 
2884   1FE2 FF FF FF FF 
2884   1FE6 FF FF FF FF 
2884   1FEA FF FF FF FF 
2884   1FEE FF FF FF FF 
2884   1FF2 FF FF FF FF 
2884   1FF6 FF FF FF FF 
2884   1FFA FF FF FF FF 
2884   1FFE FF FF FF FF 
2884   2002 FF FF FF FF 
2884   2006 FF FF FF FF 
2884   200A FF FF FF FF 
2884   200E FF FF FF FF 
2884   2012 FF FF FF FF 
2884   2016 FF FF FF FF 
2884   201A FF FF FF FF 
2884   201E FF FF FF FF 
2884   2022 FF FF FF FF 
2884   2026 FF FF FF FF 
2884   202A FF FF FF FF 
2884   202E FF FF FF FF 
2884   2032 FF FF FF FF 
2884   2036 FF FF FF FF 
2884   203A FF FF FF FF 
2884   203E FF FF FF FF 
2884   2042 FF FF FF FF 
2884   2046 FF FF FF FF 
2884   204A FF FF FF FF 
2884   204E FF FF FF FF 
2884   2052 FF FF FF FF 
2884   2056 FF FF FF FF 
2884   205A FF FF FF FF 
2884   205E FF FF FF FF 
2884   2062 FF FF FF FF 
2884   2066 FF FF FF FF 
2884   206A FF FF FF FF 
2884   206E FF FF FF FF 
2884   2072 FF FF FF FF 
2884   2076 FF FF FF FF 
2884   207A FF FF FF FF 
2884   207E FF FF FF FF 
2884   2082 FF FF FF FF 
2884   2086 FF FF FF FF 
2884   208A FF FF FF FF 
2884   208E FF FF FF FF 
2884   2092 FF FF FF FF 
2884   2096 FF FF FF FF 
2884   209A FF FF FF FF 
2884   209E FF FF FF FF 
2884   20A2 FF FF FF FF 
2884   20A6 FF FF FF FF 
2884   20AA FF FF FF FF 
2884   20AE FF FF FF FF 
2884   20B2 FF FF FF FF 
2884   20B6 FF FF FF FF 
2884   20BA FF FF FF FF 
2884   20BE FF FF FF FF 
2884   20C2 FF FF FF FF 
2884   20C6 FF FF FF FF 
2884   20CA FF FF FF FF 
2884   20CE FF FF FF FF 
2884   20D2 FF FF FF FF 
2884   20D6 FF FF FF FF 
2884   20DA FF FF FF FF 
2884   20DE FF FF FF FF 
2884   20E2 FF FF FF FF 
2884   20E6 FF FF FF FF 
2884   20EA FF FF FF FF 
2884   20EE FF FF FF FF 
2884   20F2 FF FF FF FF 
2884   20F6 FF FF FF FF 
2884   20FA FF FF FF FF 
2884   20FE FF FF FF FF 
2884   2102 FF FF FF FF 
2884   2106 FF FF FF FF 
2884   210A FF FF FF FF 
2884   210E FF FF FF FF 
2884   2112 FF FF FF FF 
2884   2116 FF FF FF FF 
2884   211A FF FF FF FF 
2884   211E FF FF FF FF 
2884   2122 FF FF FF FF 
2884   2126 FF FF FF FF 
2884   212A FF FF FF FF 
2884   212E FF FF FF FF 
2884   2132 FF FF FF FF 
2884   2136 FF FF FF FF 
2884   213A FF FF FF FF 
2884   213E FF FF FF FF 
2884   2142 FF FF FF FF 
2884   2146 FF FF FF FF 
2884   214A FF FF FF FF 
2884   214E FF FF FF FF 
2884   2152 FF FF FF FF 
2884   2156 FF FF FF FF 
2884   215A FF FF FF FF 
2884   215E FF FF FF FF 
2884   2162 FF FF FF FF 
2884   2166 FF FF FF FF 
2884   216A FF FF FF FF 
2884   216E FF FF FF FF 
2884   2172 FF FF FF FF 
2884   2176 FF FF FF FF 
2884   217A FF FF FF FF 
2884   217E FF FF FF FF 
2884   2182 FF FF FF FF 
2884   2186 FF FF FF FF 
2884   218A FF FF FF FF 
2884   218E FF FF FF FF 
2884   2192 FF FF FF FF 
2884   2196 FF FF FF FF 
2884   219A FF FF FF FF 
2884   219E FF FF FF FF 
2884   21A2 FF FF FF FF 
2884   21A6 FF FF FF FF 
2884   21AA FF FF FF FF 
2884   21AE FF FF FF FF 
2884   21B2 FF FF FF FF 
2884   21B6 FF FF FF FF 
2884   21BA FF FF FF FF 
2884   21BE FF FF FF FF 
2884   21C2 FF FF FF FF 
2884   21C6 FF FF FF FF 
2884   21CA FF FF FF FF 
2884   21CE FF FF FF FF 
2884   21D2 FF FF FF FF 
2884   21D6 FF FF FF FF 
2884   21DA FF FF FF FF 
2884   21DE FF FF FF FF 
2884   21E2 FF FF FF FF 
2884   21E6 FF FF FF FF 
2884   21EA FF FF FF FF 
2884   21EE FF FF FF FF 
2884   21F2 FF FF FF FF 
2884   21F6 FF FF FF FF 
2884   21FA FF FF FF FF 
2884   21FE FF FF FF FF 
2884   2202 FF FF FF FF 
2884   2206 FF FF FF FF 
2884   220A FF FF FF FF 
2884   220E FF FF FF FF 
2884   2212 FF FF FF FF 
2884   2216 FF FF FF FF 
2884   221A FF FF FF FF 
2884   221E FF FF FF FF 
2884   2222 FF FF FF FF 
2884   2226 FF FF FF FF 
2884   222A FF FF FF FF 
2884   222E FF FF FF FF 
2884   2232 FF FF FF FF 
2884   2236 FF FF FF FF 
2884   223A FF FF FF FF 
2884   223E FF FF FF FF 
2884   2242 FF FF FF FF 
2884   2246 FF FF FF FF 
2884   224A FF FF FF FF 
2884   224E FF FF FF FF 
2884   2252 FF FF FF FF 
2884   2256 FF FF FF FF 
2884   225A FF FF FF FF 
2884   225E FF FF FF FF 
2884   2262 FF FF FF FF 
2884   2266 FF FF FF FF 
2884   226A FF FF FF FF 
2884   226E FF FF FF FF 
2884   2272 FF FF FF FF 
2884   2276 FF FF FF FF 
2884   227A FF FF FF FF 
2884   227E FF FF FF FF 
2884   2282 FF FF FF FF 
2884   2286 FF FF FF FF 
2884   228A FF FF FF FF 
2884   228E FF FF FF FF 
2884   2292 FF FF FF FF 
2884   2296 FF FF FF FF 
2884   229A FF FF FF FF 
2884   229E FF FF FF FF 
2884   22A2 FF FF FF FF 
2884   22A6 FF FF FF FF 
2884   22AA FF FF FF FF 
2884   22AE FF FF FF FF 
2884   22B2 FF FF FF FF 
2884   22B6 FF FF FF FF 
2884   22BA FF FF FF FF 
2884   22BE FF FF FF FF 
2884   22C2 FF FF FF FF 
2884   22C6 FF FF FF FF 
2884   22CA FF FF FF FF 
2884   22CE FF FF FF FF 
2884   22D2 FF FF FF FF 
2884   22D6 FF FF FF FF 
2884   22DA FF FF FF FF 
2884   22DE FF FF FF FF 
2884   22E2 FF FF FF FF 
2884   22E6 FF FF FF FF 
2884   22EA FF FF FF FF 
2884   22EE FF FF FF FF 
2884   22F2 FF FF FF FF 
2884   22F6 FF FF FF FF 
2884   22FA FF FF FF FF 
2884   22FE FF FF FF FF 
2884   2302 FF FF FF FF 
2884   2306 FF FF FF FF 
2884   230A FF FF FF FF 
2885   230E             
2886   230E             scrap_sector:
2887   230E FF FF FF FF   .fill 512         ; scrap sector
2887   2312 FF FF FF FF 
2887   2316 FF FF FF FF 
2887   231A FF FF FF FF 
2887   231E FF FF FF FF 
2887   2322 FF FF FF FF 
2887   2326 FF FF FF FF 
2887   232A FF FF FF FF 
2887   232E FF FF FF FF 
2887   2332 FF FF FF FF 
2887   2336 FF FF FF FF 
2887   233A FF FF FF FF 
2887   233E FF FF FF FF 
2887   2342 FF FF FF FF 
2887   2346 FF FF FF FF 
2887   234A FF FF FF FF 
2887   234E FF FF FF FF 
2887   2352 FF FF FF FF 
2887   2356 FF FF FF FF 
2887   235A FF FF FF FF 
2887   235E FF FF FF FF 
2887   2362 FF FF FF FF 
2887   2366 FF FF FF FF 
2887   236A FF FF FF FF 
2887   236E FF FF FF FF 
2887   2372 FF FF FF FF 
2887   2376 FF FF FF FF 
2887   237A FF FF FF FF 
2887   237E FF FF FF FF 
2887   2382 FF FF FF FF 
2887   2386 FF FF FF FF 
2887   238A FF FF FF FF 
2887   238E FF FF FF FF 
2887   2392 FF FF FF FF 
2887   2396 FF FF FF FF 
2887   239A FF FF FF FF 
2887   239E FF FF FF FF 
2887   23A2 FF FF FF FF 
2887   23A6 FF FF FF FF 
2887   23AA FF FF FF FF 
2887   23AE FF FF FF FF 
2887   23B2 FF FF FF FF 
2887   23B6 FF FF FF FF 
2887   23BA FF FF FF FF 
2887   23BE FF FF FF FF 
2887   23C2 FF FF FF FF 
2887   23C6 FF FF FF FF 
2887   23CA FF FF FF FF 
2887   23CE FF FF FF FF 
2887   23D2 FF FF FF FF 
2887   23D6 FF FF FF FF 
2887   23DA FF FF FF FF 
2887   23DE FF FF FF FF 
2887   23E2 FF FF FF FF 
2887   23E6 FF FF FF FF 
2887   23EA FF FF FF FF 
2887   23EE FF FF FF FF 
2887   23F2 FF FF FF FF 
2887   23F6 FF FF FF FF 
2887   23FA FF FF FF FF 
2887   23FE FF FF FF FF 
2887   2402 FF FF FF FF 
2887   2406 FF FF FF FF 
2887   240A FF FF FF FF 
2887   240E FF FF FF FF 
2887   2412 FF FF FF FF 
2887   2416 FF FF FF FF 
2887   241A FF FF FF FF 
2887   241E FF FF FF FF 
2887   2422 FF FF FF FF 
2887   2426 FF FF FF FF 
2887   242A FF FF FF FF 
2887   242E FF FF FF FF 
2887   2432 FF FF FF FF 
2887   2436 FF FF FF FF 
2887   243A FF FF FF FF 
2887   243E FF FF FF FF 
2887   2442 FF FF FF FF 
2887   2446 FF FF FF FF 
2887   244A FF FF FF FF 
2887   244E FF FF FF FF 
2887   2452 FF FF FF FF 
2887   2456 FF FF FF FF 
2887   245A FF FF FF FF 
2887   245E FF FF FF FF 
2887   2462 FF FF FF FF 
2887   2466 FF FF FF FF 
2887   246A FF FF FF FF 
2887   246E FF FF FF FF 
2887   2472 FF FF FF FF 
2887   2476 FF FF FF FF 
2887   247A FF FF FF FF 
2887   247E FF FF FF FF 
2887   2482 FF FF FF FF 
2887   2486 FF FF FF FF 
2887   248A FF FF FF FF 
2887   248E FF FF FF FF 
2887   2492 FF FF FF FF 
2887   2496 FF FF FF FF 
2887   249A FF FF FF FF 
2887   249E FF FF FF FF 
2887   24A2 FF FF FF FF 
2887   24A6 FF FF FF FF 
2887   24AA FF FF FF FF 
2887   24AE FF FF FF FF 
2887   24B2 FF FF FF FF 
2887   24B6 FF FF FF FF 
2887   24BA FF FF FF FF 
2887   24BE FF FF FF FF 
2887   24C2 FF FF FF FF 
2887   24C6 FF FF FF FF 
2887   24CA FF FF FF FF 
2887   24CE FF FF FF FF 
2887   24D2 FF FF FF FF 
2887   24D6 FF FF FF FF 
2887   24DA FF FF FF FF 
2887   24DE FF FF FF FF 
2887   24E2 FF FF FF FF 
2887   24E6 FF FF FF FF 
2887   24EA FF FF FF FF 
2887   24EE FF FF FF FF 
2887   24F2 FF FF FF FF 
2887   24F6 FF FF FF FF 
2887   24FA FF FF FF FF 
2887   24FE FF FF FF FF 
2887   2502 FF FF FF FF 
2887   2506 FF FF FF FF 
2887   250A FF FF FF FF 
2888   250E             transient_area:
2889   250E 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2890   250F             
2891   250F             .end
tasm: Number of errors = 0
