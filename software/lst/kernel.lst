0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; for the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; file entry attributes
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             fst_entry_size      .equ 32  ; bytes
0107   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0108   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0109   0000             fst_nbr_directories .equ 64
0110   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0112   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0113   0000             fst_lba_start       .equ 32
0114   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0115   0000             
0116   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0117   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0118   0000                                         ; so that we know which blocks are free or taken
0119   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0120   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0121   0000             fs_lba_start        .equ (fst_lba_end + 1)
0122   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0123   0000             
0124   0000             root_id:            .equ fst_lba_start
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; global system variables
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; irq table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 48 00       .dw int_6
0141   000E 49 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 F0 0F       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 A5 02       .dw trap_privilege
0153   0014 C2 03       .dw trap_div_zero
0154   0016 CF 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 B1 02       .dw syscall_break
0165   0022 D0 03       .dw syscall_rtc
0166   0024 F3 04       .dw syscall_ide
0167   0026 B3 05       .dw syscall_io
0168   0028 70 06       .dw syscall_file_system
0169   002A 3D 0F       .dw syscall_create_proc
0170   002C 6A 02       .dw syscall_list_procs
0171   002E 02 04       .dw syscall_datetime
0172   0030 26 02       .dw syscall_reboot
0173   0032 07 0F       .dw syscall_pause_proc
0174   0034 32 02       .dw syscall_resume_proc
0175   0036 C4 0E       .dw syscall_terminate_proc
0176   0038 F2 01       .dw syscall_system
0177   003A 98 00       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; aliases for individual 'al' options for FDC system calls
0198   003C             fdc_al_restore      .equ 0
0199   003C             fdc_al_step         .equ 1
0200   003C             fdc_al_step_in      .equ 2
0201   003C             fdc_al_step_out     .equ 3
0202   003C             fdc_al_seek         .equ 4
0203   003C             fdc_al_format       .equ 5
0204   003C             fdc_al_read_addr    .equ 6
0205   003C             fdc_al_read_track   .equ 7
0206   003C             fdc_al_read_sect    .equ 8
0207   003C             fdc_al_write_sect   .equ 9
0208   003C             fdc_al_force_int    .equ 10
0209   003C             fdc_al_status0      .equ 11
0210   003C             fdc_al_status1      .equ 12
0211   003C             
0212   003C             ; ------------------------------------------------------------------------------------------------------------------;
0213   003C             ; alias exports
0214   003C             ; ------------------------------------------------------------------------------------------------------------------;
0215   003C             .export text_org
0216   003C             .export sys_break
0217   003C             .export sys_rtc
0218   003C             .export sys_ide
0219   003C             .export sys_io
0220   003C             .export sys_filesystem
0221   003C             .export sys_create_proc
0222   003C             .export sys_list_proc
0223   003C             .export sys_datetime
0224   003C             .export sys_reboot
0225   003C             .export sys_pause_proc
0226   003C             .export sys_resume_proc
0227   003C             .export sys_terminate_proc
0228   003C             .export sys_system
0229   003C             .export sys_fdc
0230   003C             
0231   003C             ; exports of aliases for individual 'al' options for FDC system calls
0232   003C             .export fdc_al_restore
0233   003C             .export fdc_al_step
0234   003C             .export fdc_al_step_in
0235   003C             .export fdc_al_step_out
0236   003C             .export fdc_al_seek
0237   003C             .export fdc_al_format
0238   003C             .export fdc_al_read_addr
0239   003C             .export fdc_al_read_track
0240   003C             .export fdc_al_read_sect
0241   003C             .export fdc_al_write_sect
0242   003C             .export fdc_al_force_int
0243   003C             .export fdc_al_status0
0244   003C             .export fdc_al_status1
0245   003C             
0246   003C             ; ------------------------------------------------------------------------------------------------------------------;
0247   003C             ; irqs' code block
0248   003C             ; ------------------------------------------------------------------------------------------------------------------;
0249   003C             ; 5.25" floppy drive controller irq
0250   003C             int_0_fdc:
0251   003C 3B B8 18      mov d, s_fdc_irq
0252   003F 07 44 12      call _puts
0253   0042 06            sysret
0254   0043             int_1:
0255   0043 06            sysret
0256   0044             int_2:
0257   0044 06            sysret
0258   0045             int_3:
0259   0045 06            sysret
0260   0046             int_4:
0261   0046 06            sysret
0262   0047             int_5:
0263   0047 06            sysret
0264   0048             
0265   0048             ; timer irq
0266   0048             int_6:  
0267   0048 06            sysret
0268   0049             
0269   0049             ; ------------------------------------------------------------------------------------------------------------------;
0270   0049             ; uart0 interrupt
0271   0049             ; ------------------------------------------------------------------------------------------------------------------;
0272   0049             int_7_uart0:
0273   0049 D7            push a
0274   004A DA            push d
0275   004B E1            pushf
0276   004C 14 7A 17      mov a, [fifo_in]
0277   004F 3C            mov d, a
0278   0050 1D 80 FF      mov al, [_uart0_data]       ; get character
0279   0053 B9 03         cmp al, $03                 ; ctrl-c
0280   0055 C6 72 00      je ctrlc
0281   0058 B9 1A         cmp al, $1a                 ; ctrl-z
0282   005A C6 78 00      je ctrlz
0283   005D 3E            mov [d], al                 ; add to fifo
0284   005E 14 7A 17      mov a, [fifo_in]
0285   0061 77            inc a
0286   0062 AF DB 22      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0287   0065 C7 6B 00      jne int_7_continue
0288   0068 10 DB 1E      mov a, fifo  
0289   006B             int_7_continue:  
0290   006B 42 7A 17      mov [fifo_in], a            ; update fifo pointer
0291   006E EE            popf
0292   006F E7            pop d
0293   0070 E4            pop a  
0294   0071 06            sysret
0295   0072             ctrlc:
0296   0072 51 05 00      add sp, 5
0297   0075 0A C4 0E      jmp syscall_terminate_proc
0298   0078             ctrlz:
0299   0078 EE            popf
0300   0079 E7            pop d
0301   007A E4            pop a
0302   007B 0A 07 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0303   007E             
0304   007E             ; ------------------------------------------------------------------------------------------------------------------;
0305   007E             ; floppy drive syscalls
0306   007E             ; ------------------------------------------------------------------------------------------------------------------;
0307   007E             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0308   007E             ; fdc_40_ff:
0309   007E             ;   .fill 40,  $ff    ; or 00                                                                                
0310   007E             ; fdc_128_format_inner:
0311   007E             ;   .fill 6,   $00    ;                                                                            <--|        
0312   007E             ;   .fill 1,   $fe    ; id address mark                                                               |        
0313   007E             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0314   007E             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0315   007E             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0316   007E             ;   .fill 1,   $00    ; sector length                                                                 |                        
0317   007E             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0318   007E             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0319   007E             ;   .fill 6,   $00    ;                                                                               |                        
0320   007E             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0321   007E             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0322   007E             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0323   007E             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0324   007E             ; fdc_128_format_end:
0325   007E             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0326   007E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0327   007E             fdc_jmptbl:
0328   007E A4 00         .dw syscall_fdc_restore
0329   0080 A9 00         .dw syscall_fdc_step
0330   0082 AA 00         .dw syscall_fdc_step_in
0331   0084 AF 00         .dw syscall_fdc_step_out
0332   0086 B4 00         .dw syscall_fdc_seek
0333   0088 B7 00         .dw syscall_fdc_format
0334   008A B5 00         .dw syscall_fdc_read_addr
0335   008C DF 00         .dw syscall_fdc_read_track
0336   008E 0B 01         .dw syscall_fdc_read_sect
0337   0090 40 01         .dw syscall_fdc_write_sect
0338   0092 B6 00         .dw syscall_fdc_force_int
0339   0094 9C 00         .dw syscall_fdc_status0
0340   0096 A0 00         .dw syscall_fdc_status1
0341   0098             syscall_fdc:
0342   0098 FD 0A 7E 00   jmp [fdc_jmptbl + al]
0343   009C             
0344   009C             syscall_fdc_status0:
0345   009C 1D C1 FF      mov al, [_fdc_status_0]
0346   009F 06            sysret
0347   00A0             syscall_fdc_status1:
0348   00A0 1D C8 FF      mov al, [_fdc_stat_cmd]
0349   00A3 06            sysret
0350   00A4             syscall_fdc_restore:
0351   00A4 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000
0352   00A8 06            sysret
0353   00A9             
0354   00A9             syscall_fdc_step:
0355   00A9 06            sysret
0356   00AA             
0357   00AA             syscall_fdc_step_in:
0358   00AA F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0359   00AE 06            sysret
0360   00AF             
0361   00AF             syscall_fdc_step_out:
0362   00AF F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0363   00B3 06            sysret
0364   00B4             
0365   00B4             syscall_fdc_seek:
0366   00B4 06            sysret
0367   00B5             
0368   00B5             syscall_fdc_read_addr:
0369   00B5 06            sysret
0370   00B6             
0371   00B6             syscall_fdc_force_int:
0372   00B6 06            sysret
0373   00B7             
0374   00B7             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0375   00B7             ; in the ram formatting block because they are all set as 00 right now
0376   00B7             ; bl: track number
0377   00B7             syscall_fdc_format:
0378   00B7 FD 3D C9 FF   mov [_fdc_track], bl
0379   00BB F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0380   00BF FD 4D DB 24   mov si, transient_area
0381   00C3 F6            lodsb
0382   00C4 3D CB FF      mov [_fdc_data], al      ; 10   
0383   00C7 07 E1 01      call fdc_wait_64us
0384   00CA             fdc_format_drq:
0385   00CA 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0386   00CD 93 01         test al, $01                ; 4
0387   00CF C6 DE 00      jz fdc_format_end           ; 8
0388   00D2 93 02         test al, $02                ; 4
0389   00D4 C6 CA 00      jz fdc_format_drq           ; 8
0390   00D7 F6            lodsb                       ; 7
0391   00D8 3D CB FF      mov [_fdc_data], al         ; 10   
0392   00DB 0A CA 00      jmp fdc_format_drq
0393   00DE             fdc_format_end:
0394   00DE 06            sysret
0395   00DF             
0396   00DF             ; di : destination in user space
0397   00DF             ; a  : returns number of read bytes
0398   00DF             syscall_fdc_read_track:
0399   00DF E3            push di
0400   00E0 FD 4F DB 24   mov di, transient_area
0401   00E4 F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0402   00E8 07 E1 01      call fdc_wait_64us
0403   00EB             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0404   00EB 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0405   00EE 93 01         test al, $01                ; check busy bit
0406   00F0 C6 FF 00      jz fdc_read_track_end
0407   00F3 93 02         test al, $02                ; check drq bit
0408   00F5 C6 EB 00      jz fdc_read_track_l0
0409   00F8 1D CB FF      mov al, [_fdc_data]     ; 
0410   00FB F7            stosb
0411   00FC 0A EB 00      jmp fdc_read_track_l0
0412   00FF             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0413   00FF             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0414   00FF             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0415   00FF             fdc_read_track_end:
0416   00FF 50            mov a, di
0417   0100 5F DB 24      sub a, transient_area
0418   0103 F0            pop di
0419   0104 FD 4D DB 24   mov si, transient_area
0420   0108 39            mov c, a  ; copy track over to user space
0421   0109 03            store
0422   010A 06            sysret
0423   010B             
0424   010B             ; sector in bl
0425   010B             ; track in bh
0426   010B             ; di = user space destination
0427   010B             syscall_fdc_read_sect:
0428   010B E3            push di
0429   010C FD 3D CA FF   mov [_fdc_sector], bl
0430   0110 30            mov bl, bh
0431   0111 FD 3D C9 FF   mov [_fdc_track], bl
0432   0115 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0433   0119 07 E1 01      call fdc_wait_64us
0434   011C FD 4F DB 24   mov di, transient_area
0435   0120             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0436   0120 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0437   0123 93 01         test al, $01                ; check drq bit
0438   0125 C6 34 01      jz fdc_read_sect_end
0439   0128 93 02         test al, $02                ; check drq bit
0440   012A C6 20 01      jz fdc_read_sect_l0
0441   012D 1D CB FF      mov al, [_fdc_data]     ; 
0442   0130 F7            stosb
0443   0131 0A 20 01      jmp fdc_read_sect_l0
0444   0134             fdc_read_sect_end:
0445   0134 50            mov a, di
0446   0135 5F DB 24      sub a, transient_area
0447   0138 F0            pop di
0448   0139 FD 4D DB 24   mov si, transient_area
0449   013D 39            mov c, a  ; copy sector over to user space
0450   013E 03            store
0451   013F 06            sysret
0452   0140             
0453   0140             ; sector in al
0454   0140             ; track in ah
0455   0140             ; data pointer in si
0456   0140             syscall_fdc_write_sect:
0457   0140 FD 3D CA FF   mov [_fdc_sector], bl
0458   0144 30            mov bl, bh
0459   0145 FD 3D C9 FF   mov [_fdc_track], bl
0460   0149 FD 4F DB 24   mov di, transient_area    ; si = data source, di = destination 
0461   014D 38 80 00      mov c, 128
0462   0150 04            load                    ; transfer data to kernel space!
0463   0151 FD 4D DB 24   mov si, transient_area
0464   0155 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0465   0159 F6            lodsb                      
0466   015A 3D CB FF      mov [_fdc_data], al      
0467   015D 07 E1 01      call fdc_wait_64us
0468   0160             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0469   0160 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0470   0163 93 01         test al, $01                    ; 4
0471   0165 C6 74 01      jz fdc_write_sect_end           ; 8
0472   0168 93 02         test al, $02                    ; 4
0473   016A C6 60 01      jz fdc_write_sect_l0            ; 8
0474   016D F6            lodsb                           ; 7
0475   016E 3D CB FF      mov [_fdc_data], al             ; 10   
0476   0171 0A 60 01      jmp fdc_write_sect_l0
0477   0174             fdc_write_sect_end:
0478   0174 06            sysret
0479   0175             
0480   0175             fdc_format_mem:
0481   0175 3B 01 00      mov d, 1
0482   0178 FD 4F DB 24   mov di, transient_area
0483   017C             ; 40 * FF
0484   017C 38 28 00      mov c, 40
0485   017F 19 FF         mov al, $ff
0486   0181             fdc_l0: 
0487   0181 F7            stosb
0488   0182 7E            dec c
0489   0183 C7 81 01      jnz fdc_l0
0490   0186             ; 6 * 00
0491   0186             fdc_inner_loop:
0492   0186 38 06 00      mov c, 6
0493   0189 19 00         mov al, $00
0494   018B             fdc_l1:
0495   018B F7            stosb
0496   018C 7E            dec c
0497   018D C7 8B 01      jnz fdc_l1
0498   0190             ; FE address mark
0499   0190             fdc_l2:
0500   0190 19 FE         mov al, $fe
0501   0192 F7            stosb
0502   0193             ; track number
0503   0193             fdc_l3:
0504   0193 19 00         mov al, $00
0505   0195 F7            stosb
0506   0196             ; side number
0507   0196             fdc_l4:
0508   0196 19 00         mov al, $00
0509   0198 F7            stosb
0510   0199             ; sector number
0511   0199             fdc_l5:
0512   0199 13            mov a, d
0513   019A F7            stosb
0514   019B             ; sector length 128 bytes
0515   019B             fdc_l6:
0516   019B 19 00         mov al, $00
0517   019D F7            stosb
0518   019E             ; 2 crc's
0519   019E             fdc_l7:
0520   019E 19 F7         mov al, $f7
0521   01A0 F7            stosb
0522   01A1             ; 11 times $ff
0523   01A1 38 0B 00      mov c, 11
0524   01A4 19 FF         mov al, $ff
0525   01A6             fdc_l8:
0526   01A6 F7            stosb
0527   01A7 7E            dec c
0528   01A8 C7 A6 01      jnz fdc_l8
0529   01AB             ; 6 times 00
0530   01AB 38 06 00      mov c, 6
0531   01AE 19 00         mov al, $00
0532   01B0             fdc_l9:
0533   01B0 F7            stosb
0534   01B1 7E            dec c
0535   01B2 C7 B0 01      jnz fdc_l9
0536   01B5             ; FB data address mark
0537   01B5 19 FB         mov al, $fb
0538   01B7             fdc_l10:
0539   01B7 F7            stosb
0540   01B8             ; 128 bytes sector data
0541   01B8 38 80 00      mov c, 128
0542   01BB 19 E5         mov al, $E5
0543   01BD             fdc_l11:
0544   01BD F7            stosb
0545   01BE 7E            dec c
0546   01BF C7 BD 01      jnz fdc_l11
0547   01C2             ; 2 crc's
0548   01C2             fdc_l12:
0549   01C2 19 F7         mov al, $f7
0550   01C4 F7            stosb
0551   01C5             ; 10 * $FF
0552   01C5 38 0A 00      mov c, 10
0553   01C8 19 FF         mov al, $ff
0554   01CA             fdc_l13:
0555   01CA F7            stosb
0556   01CB 7E            dec c
0557   01CC C7 CA 01      jnz fdc_l13
0558   01CF             ; check whether we did this 16 times
0559   01CF 79            inc d
0560   01D0 C5 11 00      cmp d, 17
0561   01D3 C7 86 01      jne fdc_inner_loop
0562   01D6             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0563   01D6 38 F4 01      mov c, 500
0564   01D9 19 FF         mov al, $ff
0565   01DB             fdc_format_footer:
0566   01DB             fdc_footer_drq_loop:
0567   01DB F7            stosb
0568   01DC 7E            dec c
0569   01DD C7 DB 01      jnz fdc_footer_drq_loop
0570   01E0 09            ret
0571   01E1             
0572   01E1             ; fetch is 2 cycles long when 'display_reg_load' is false.
0573   01E1             ; 64us amounts to 160 cycles of the 2.5mhz clock
0574   01E1             ; call u16 is 14 cycles long
0575   01E1             ; 160 - 5 - 14 = 
0576   01E1             fdc_wait_64us:
0577   01E1 3A 0D         mov cl, 13                       ; 5 cycles
0578   01E3             fdc_wait_64_loop:
0579   01E3 81            dec cl                           ; 3 cycles
0580   01E4 C7 E3 01      jnz fdc_wait_64_loop             ; 8 cycles
0581   01E7 09            ret
0582   01E8             
0583   01E8             ; ------------------------------------------------------------------------------------------------------------------;
0584   01E8             ; system syscalls
0585   01E8             ; ------------------------------------------------------------------------------------------------------------------;
0586   01E8             system_jmptbl:
0587   01E8 1E 02         .dw system_uname
0588   01EA 25 02         .dw system_whoami
0589   01EC F8 01         .dw system_setparam
0590   01EE FB 01         .dw system_bootloader_install
0591   01F0 F6 01         .dw system_getparam
0592   01F2             syscall_system:
0593   01F2 FD 0A E8 01   jmp [system_jmptbl + al]
0594   01F6             
0595   01F6             ; param register address in register d
0596   01F6             ; param value in register bl
0597   01F6             system_getparam:
0598   01F6 32            mov bl, [d]
0599   01F7 06            sysret
0600   01F8             
0601   01F8             ; param register address in register d
0602   01F8             ; param value in register bl
0603   01F8             system_setparam:
0604   01F8 FD 3E         mov [d], bl
0605   01FA 06            sysret
0606   01FB             
0607   01FB             ; kernel LBA address in 'b'
0608   01FB             system_bootloader_install:
0609   01FB D8            push b
0610   01FC 26 00 00      mov b, 0
0611   01FF 38 00 00      mov c, 0
0612   0202 22 01         mov ah, $01                 ; 1 sector
0613   0204 3B DB 24      mov d, transient_area
0614   0207 07 22 05      call ide_read_sect          ; read sector
0615   020A E5            pop b
0616   020B FD 44 FE 01   mov [d + 510], b            ; update LBA address
0617   020F 26 00 00      mov b, 0
0618   0212 38 00 00      mov c, 0
0619   0215 22 01         mov ah, $01                 ; 1 sector
0620   0217 3B DB 24      mov d, transient_area
0621   021A 07 48 05      call ide_write_sect         ; write sector
0622   021D 06            sysret
0623   021E             
0624   021E             system_uname:
0625   021E 3B 8B 17      mov d, s_uname
0626   0221 07 44 12      call _puts
0627   0224 06            sysret
0628   0225             
0629   0225             system_whoami:
0630   0225 06            sysret
0631   0226             
0632   0226             ; reboot system
0633   0226             syscall_reboot:
0634   0226 FD D7 FF FF   push word $ffff 
0635   022A FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0636   022D FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0637   0231 06            sysret
0638   0232             
0639   0232             ;------------------------------------------------------------------------------------------------------;;
0640   0232             ; switch to another process
0641   0232             ; inputs:
0642   0232             ; al = new process number
0643   0232             ;------------------------------------------------------------------------------------------------------;;
0644   0232             syscall_resume_proc:
0645   0232 FD 78         mov g, a                            ; save the process number
0646   0234 4B            pusha                               ; save all registers into kernel stack
0647   0235 22 00         mov ah, 0
0648   0237 1D 75 17      mov al, [active_proc_index]
0649   023A FD 99         shl a              ; x2
0650   023C B7 BA 0F      mov a, [proc_table_convert + a]     ; get process state start index
0651   023F 4F            mov di, a
0652   0240 48            mov a, sp
0653   0241 77            inc a
0654   0242 4D            mov si, a
0655   0243 38 14 00      mov c, 20
0656   0246 FD F5         rep movsb                           ; save process state!
0657   0248             ; restore kernel stack position to point before interrupt arrived
0658   0248 51 14 00      add sp, 20
0659   024B             ; now load the new process number!
0660   024B FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0661   024D 3D 75 17      mov [active_proc_index], al         ; set new active proc
0662   0250             ; calculate lut entry for next process
0663   0250 22 00         mov ah, 0
0664   0252 FD 99         shl a                               ; x2
0665   0254 B7 BA 0F      mov a, [proc_table_convert + a]     ; get process state start index  
0666   0257 4D            mov si, a                           ; source is proc state block
0667   0258 48            mov a, sp
0668   0259 5F 13 00      sub a, 19
0669   025C 4F            mov di, a                           ; destination is kernel stack
0670   025D             ; restore sp
0671   025D 7D            dec a
0672   025E 47            mov sp, a
0673   025F 38 14 00      mov c, 20
0674   0262 FD F5         rep movsb
0675   0264             ; set vm process
0676   0264 1D 75 17      mov al, [active_proc_index]
0677   0267 01            setptb
0678   0268 4C            popa
0679   0269 06            sysret
0680   026A             
0681   026A             ;------------------------------------------------------------------------------------------------------;;
0682   026A             ; list processes
0683   026A             ;------------------------------------------------------------------------------------------------------;;
0684   026A             syscall_list_procs:
0685   026A 3B AC 17      mov d, s_ps_header
0686   026D 07 44 12      call _puts
0687   0270 3B 4C 1A      mov d, proc_availab_table + 1
0688   0273 38 01 00      mov c, 1
0689   0276             list_procs_l0:  
0690   0276 BD 01         cmp byte[d], 1
0691   0278 C7 9C 02      jne list_procs_next
0692   027B 2D            mov b, d
0693   027C 61 4B 1A      sub b, proc_availab_table
0694   027F FD 9F 05      shl b, 5
0695   0282 DA            push d
0696   0283 D8            push b
0697   0284 28            mov b, c
0698   0285 07 E4 12      call print_u8x
0699   0288 22 20         mov ah, ' '
0700   028A 07 18 11      call _putchar
0701   028D 07 18 11      call _putchar
0702   0290 E5            pop b
0703   0291 74            mov d, b
0704   0292 58 5B 1A      add d, proc_names
0705   0295 07 44 12      call _puts
0706   0298 07 F1 11      call printnl
0707   029B E7            pop d
0708   029C             list_procs_next:
0709   029C 79            inc d
0710   029D 78            inc c
0711   029E C2 09 00      cmp c, 9
0712   02A1 C7 76 02      jne list_procs_l0
0713   02A4             list_procs_end:
0714   02A4 06            sysret
0715   02A5             
0716   02A5             ; ------------------------------------------------------------------------------------------------------------------;
0717   02A5             ; exceptions code block
0718   02A5             ; ------------------------------------------------------------------------------------------------------------------;
0719   02A5             ; privilege exception
0720   02A5             ; ------------------------------------------------------------------------------------------------------------------;
0721   02A5             trap_privilege:
0722   02A5 0A 26 02      jmp syscall_reboot
0723   02A8 DA            push d
0724   02A9 3B FB 17      mov d, s_priviledge
0725   02AC 07 44 12      call _puts
0726   02AF E7            pop d
0727   02B0 06            sysret
0728   02B1             
0729   02B1             ; ------------------------------------------------------------------------------------------------------------------;
0730   02B1             ; breakpoint
0731   02B1             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0732   02B1             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0733   02B1             ; ------------------------------------------------------------------------------------------------------------------;
0734   02B1             syscall_break:
0735   02B1 4B            pusha
0736   02B2             syscall_break_prompt:
0737   02B2 3B 6C 03      mov d, s_break1
0738   02B5 07 44 12      call _puts
0739   02B8 07 F1 11      call printnl
0740   02BB 07 46 13      call scan_u16d
0741   02BE AF 00 00      cmp a, 0
0742   02C1 C6 CC 02      je syscall_break_regs
0743   02C4 AF 01 00      cmp a, 1
0744   02C7 C6 EF 02      je syscall_break_mem
0745   02CA             syscall_break_end:  
0746   02CA 4C            popa
0747   02CB 06            sysret
0748   02CC             syscall_break_regs:
0749   02CC 48            mov a, sp
0750   02CD 53 0E 00      add a, 14               ; back-track 7 registers
0751   02D0 3C            mov d, a
0752   02D1 3A 07         mov cl, 7
0753   02D3             syscall_regs_l0:
0754   02D3 2A            mov b, [d]
0755   02D4 FD AB         swp b
0756   02D6 07 A0 12      call print_u16x         ; print register value
0757   02D9 07 F1 11      call printnl
0758   02DC 63 02 00      sub d, 2
0759   02DF 71 01         sub cl, 1
0760   02E1 C3 00         cmp cl, 0
0761   02E3 C7 D3 02      jne syscall_regs_l0
0762   02E6 0A B2 02      jmp syscall_break_prompt
0763   02E9 07 F1 11      call printnl
0764   02EC 0A B2 02      jmp syscall_break_prompt
0765   02EF             syscall_break_mem:
0766   02EF 07 F1 11      call printnl
0767   02F2 07 C2 12      call scan_u16x
0768   02F5 4D            mov si, a               ; data source from user space
0769   02F6 FD 4F DB 22   mov di, scrap_sector    ; destination in kernel space
0770   02FA 38 00 02      mov c, 512
0771   02FD 04            load                    ; transfer data to kernel space!
0772   02FE 3B DB 22      mov d, scrap_sector     ; dump pointer in d
0773   0301 38 00 00      mov c, 0
0774   0304             dump_loop:
0775   0304 84            mov al, cl
0776   0305 87 0F         and al, $0f
0777   0307 C6 55 03      jz print_base
0778   030A             back:
0779   030A 1E            mov al, [d]             ; read byte
0780   030B 2F            mov bl, al
0781   030C 07 E4 12      call print_u8x
0782   030F 10 00 20      mov a, $2000
0783   0312 05 03         syscall sys_io          ; space
0784   0314 84            mov al, cl
0785   0315 87 0F         and al, $0f
0786   0317 B9 0F         cmp al, $0f
0787   0319 C6 2A 03      je print_ascii
0788   031C             back1:
0789   031C 79            inc d
0790   031D 78            inc c
0791   031E C2 00 02      cmp c, 512
0792   0321 C7 04 03      jne dump_loop
0793   0324 07 F1 11      call printnl
0794   0327 0A B2 02      jmp syscall_break_prompt  ; go to syscall_break return point
0795   032A             print_ascii:
0796   032A 10 00 20      mov a, $2000
0797   032D 05 03         syscall sys_io
0798   032F 63 10 00      sub d, 16
0799   0332 26 10 00      mov b, 16
0800   0335             print_ascii_l:
0801   0335 79            inc d
0802   0336 1E            mov al, [d]               ; read byte
0803   0337 B9 20         cmp al, $20
0804   0339 C8 41 03      jlu dot
0805   033C B9 7E         cmp al, $7e
0806   033E D0 49 03      jleu ascii
0807   0341             dot:
0808   0341 10 00 2E      mov a, $2e00
0809   0344 05 03         syscall sys_io
0810   0346 0A 4E 03      jmp ascii_continue
0811   0349             ascii:
0812   0349 23            mov ah, al
0813   034A 19 00         mov al, 0
0814   034C 05 03         syscall sys_io
0815   034E             ascii_continue:
0816   034E FD A9 35 03   loopb print_ascii_l
0817   0352 0A 1C 03      jmp back1
0818   0355             print_base:
0819   0355 07 F1 11      call printnl
0820   0358 2D            mov b, d
0821   0359 61 DB 22      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0822   035C 07 A0 12      call print_u16x          ; display row
0823   035F 10 00 3A      mov a, $3a00
0824   0362 05 03         syscall sys_io
0825   0364 10 00 20      mov a, $2000
0826   0367 05 03         syscall sys_io
0827   0369 0A 0A 03      jmp back
0828   036C             
0829   036C             s_break1:  
0830   036C 0A 64 65 62   .db "\ndebugger entry point.\n"
0830   0370 75 67 67 65 
0830   0374 72 20 65 6E 
0830   0378 74 72 79 20 
0830   037C 70 6F 69 6E 
0830   0380 74 2E 0A 
0831   0383 30 2E 20 73   .db "0. show registers\n"
0831   0387 68 6F 77 20 
0831   038B 72 65 67 69 
0831   038F 73 74 65 72 
0831   0393 73 0A 
0832   0395 31 2E 20 73   .db "1. show 512b ram block\n"
0832   0399 68 6F 77 20 
0832   039D 35 31 32 62 
0832   03A1 20 72 61 6D 
0832   03A5 20 62 6C 6F 
0832   03A9 63 6B 0A 
0833   03AC 32 2E 20 63   .db "2. continue execution", 0
0833   03B0 6F 6E 74 69 
0833   03B4 6E 75 65 20 
0833   03B8 65 78 65 63 
0833   03BC 75 74 69 6F 
0833   03C0 6E 00 
0834   03C2             
0835   03C2             ; ------------------------------------------------------------------------------------------------------------------;
0836   03C2             ; divide by zero exception
0837   03C2             ; ------------------------------------------------------------------------------------------------------------------;
0838   03C2             trap_div_zero:
0839   03C2 D7            push a
0840   03C3 DA            push d
0841   03C4 E1            pushf
0842   03C5 3B 12 18      mov d, s_divzero
0843   03C8 07 44 12      call _puts
0844   03CB EE            popf
0845   03CC E7            pop d
0846   03CD E4            pop a
0847   03CE 06            sysret ; enable interrupts
0848   03CF             
0849   03CF             ; ------------------------------------------------------------------------------------------------------------------;
0850   03CF             ; undefined opcode exception
0851   03CF             ; ------------------------------------------------------------------------------------------------------------------;
0852   03CF             trap_undef_opcode:
0853   03CF 06            sysret
0854   03D0             
0855   03D0             ; ------------------------------------------------------------------------------------------------------------------;
0856   03D0             ; real-time clock services syscall
0857   03D0             ; rtc i/o bank = ffa0 to ffaf
0858   03D0             ; ffa0 to ffa7 is scratch ram
0859   03D0             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
0860   03D0             ; al = 0..6 -> get
0861   03D0             ; al = 7..d -> set
0862   03D0             ; ------------------------------------------------------------------------------------------------------------------;
0863   03D0             syscall_rtc:
0864   03D0 DB            push al
0865   03D1 DA            push d
0866   03D2 B9 06         cmp al, 6
0867   03D4 D1 E9 03      jgu syscall_rtc_set
0868   03D7             syscall_rtc_get:
0869   03D7 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
0870   03D9 22 FF         mov ah, $ff    
0871   03DB 3C            mov d, a                ; get to ffa9 + offset
0872   03DC F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
0873   03E0 1E            mov al, [d]             ; get data
0874   03E1 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
0875   03E5 23            mov ah, al
0876   03E6 E7            pop d
0877   03E7 E8            pop al
0878   03E8 06            sysret
0879   03E9             syscall_rtc_set:
0880   03E9 DD            push bl
0881   03EA 99            mov bl, ah              ; set data aside
0882   03EB 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
0883   03ED 22 FF         mov ah, $ff    
0884   03EF 3C            mov d, a                ; get to ffa9 + offset
0885   03F0 1B            mov al, bl              ; get data back
0886   03F1 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
0887   03F5 3E            mov [d], al             ; set data
0888   03F6 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
0889   03FA EA            pop bl
0890   03FB E7            pop d
0891   03FC E8            pop al
0892   03FD 06            sysret
0893   03FE             
0894   03FE             datetime_serv_tbl:
0895   03FE 06 04         .dw print_date
0896   0400 7A 04         .dw set_date
0897   0402             syscall_datetime:
0898   0402 FD 0A FE 03   jmp [datetime_serv_tbl + al]      
0899   0406             print_date:
0900   0406 10 00 0D      mov a, $0d00           ; print carriage return char
0901   0409 19 03         mov al, 3
0902   040B 05 01         syscall sys_rtc        ; get week
0903   040D 1A            mov al, ah
0904   040E 22 00         mov ah, 0
0905   0410 FD 9D 02      shl a, 2          
0906   0413 3B 9C 18      mov d, s_week
0907   0416 59            add d, a
0908   0417 07 44 12      call _puts
0909   041A 10 00 20      mov a, $2000
0910   041D 05 03         syscall sys_io         ; display ' '
0911   041F 19 04         mov al, 4
0912   0421 05 01         syscall sys_rtc        ; get day
0913   0423 99            mov bl, ah
0914   0424 07 E4 12      call print_u8x
0915   0427 10 00 20      mov a, $2000
0916   042A 05 03         syscall sys_io         ; display ' '
0917   042C             ; there is a problem with the month displaying
0918   042C             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
0919   042C             ; even though it is to be understood as bcd.
0920   042C             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0921   042C 19 05         mov al, 05
0922   042E 05 01         syscall sys_rtc        ; get month
0923   0430 1A            mov al, ah
0924   0431 22 00         mov ah, 0
0925   0433 FD 9D 02      shl a, 2          
0926   0436 3B 68 18      mov d, s_months
0927   0439 59            add d, a
0928   043A 07 44 12      call _puts
0929   043D 10 00 20      mov a, $2000
0930   0440 05 03         syscall sys_io         ; display ' '
0931   0442 2E 20         mov bl, $20
0932   0444 07 E4 12      call print_u8x         ; print 20 for year prefix
0933   0447 19 06         mov al, 06
0934   0449 05 01         syscall sys_rtc        ; get year
0935   044B 99            mov bl, ah
0936   044C 07 E4 12      call print_u8x
0937   044F 10 00 20      mov a, $2000  
0938   0452 05 03         syscall sys_io         ; display ' '
0939   0454 19 02         mov al, 2
0940   0456 05 01         syscall sys_rtc        ; get hours
0941   0458 99            mov bl, ah
0942   0459 07 E4 12      call print_u8x
0943   045C 10 00 3A      mov a, $3a00    
0944   045F 05 03         syscall sys_io         ; display ':'
0945   0461 19 01         mov al, 01
0946   0463 05 01         syscall sys_rtc        ; get minutes
0947   0465 99            mov bl, ah
0948   0466 07 E4 12      call print_u8x
0949   0469 10 00 3A      mov a, $3a00  
0950   046C 05 03         syscall sys_io         ; display ':'
0951   046E 19 00         mov al, 0
0952   0470 05 01         syscall sys_rtc        ; get seconds
0953   0472 99            mov bl, ah
0954   0473 07 E4 12      call print_u8x
0955   0476 07 F1 11      call printnl
0956   0479 06            sysret
0957   047A             set_date:
0958   047A 3B 2D 18      mov d, s_set_year
0959   047D 07 44 12      call _puts
0960   0480 07 2F 13      call scan_u8x          ; read integer into a
0961   0483 FD 9D 08      shl a, 8               ; only al used, move to ah
0962   0486 19 0D         mov al, 0dh            ; set rtc year
0963   0488 05 01         syscall sys_rtc        ; set rtc
0964   048A 3B 34 18      mov d, s_set_month
0965   048D 07 44 12      call _puts
0966   0490 07 2F 13      call scan_u8x          ; read integer into a
0967   0493 FD 9D 08      shl a, 8               ; only al used, move to ah
0968   0496 19 0C         mov al, 0ch            ; set rtc month
0969   0498 05 01         syscall sys_rtc        ; set rtc
0970   049A 3B 3C 18      mov d, s_set_day
0971   049D 07 44 12      call _puts
0972   04A0 07 2F 13      call scan_u8x          ; read integer into a
0973   04A3 FD 9D 08      shl a, 8               ; only al used, move to ah
0974   04A6 19 0B         mov al, 0bh            ; set rtc month
0975   04A8 05 01         syscall sys_rtc        ; set rtc
0976   04AA 3B 42 18      mov d, s_set_week
0977   04AD 07 44 12      call _puts
0978   04B0 07 2F 13      call scan_u8x          ; read integer into a
0979   04B3 FD 9D 08      shl a, 8               ; only al used, move to ah
0980   04B6 19 0A         mov al, 0ah            ; set rtc month
0981   04B8 05 01         syscall sys_rtc        ; set rtc
0982   04BA 3B 4C 18      mov d, s_set_hours
0983   04BD 07 44 12      call _puts
0984   04C0 07 2F 13      call scan_u8x          ; read integer into a
0985   04C3 FD 9D 08      shl a, 8               ; only al used, move to ah
0986   04C6 19 09         mov al, 09h            ; set rtc month
0987   04C8 05 01         syscall sys_rtc        ; set rtc
0988   04CA 3B 54 18      mov d, s_set_minutes
0989   04CD 07 44 12      call _puts
0990   04D0 07 2F 13      call scan_u8x          ; read integer into a
0991   04D3 FD 9D 08      shl a, 8               ; only al used, move to ah
0992   04D6 19 08         mov al, 08h            ; set rtc month
0993   04D8 05 01         syscall sys_rtc        ; set rtc
0994   04DA 3B 5E 18      mov d, s_set_seconds
0995   04DD 07 44 12      call _puts
0996   04E0 07 2F 13      call scan_u8x          ; read integer into a
0997   04E3 FD 9D 08      shl a, 8               ; only al used, move to ah
0998   04E6 19 07         mov al, 07h            ; set rtc month
0999   04E8 05 01         syscall sys_rtc        ; set rtc
1000   04EA 06            sysret
1001   04EB             
1002   04EB             ; ------------------------------------------------------------------------------------------------------------------;
1003   04EB             ; ide services syscall
1004   04EB             ; al = option
1005   04EB             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1006   04EB             ; ide read/write sector
1007   04EB             ; 512 bytes
1008   04EB             ; user buffer pointer in d
1009   04EB             ; ah = number of sectors
1010   04EB             ; cb = lba bytes 3..0
1011   04EB             ; ------------------------------------------------------------------------------------------------------------------;
1012   04EB             ide_serv_tbl:
1013   04EB F7 04         .dw ide_reset
1014   04ED 0B 05         .dw ide_sleep
1015   04EF 1A 05         .dw ide_read_sect_wrapper
1016   04F1 1E 05         .dw ide_write_sect_wrapper
1017   04F3             syscall_ide:
1018   04F3 FD 0A EB 04   jmp [ide_serv_tbl + al]    
1019   04F7             
1020   04F7             ide_reset:      
1021   04F7 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1022   04FB 07 A4 05      call ide_wait                   ; wait for ide ready             
1023   04FE F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1024   0502 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1025   0506 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1026   050A 06            sysret
1027   050B             ide_sleep:
1028   050B 07 A4 05      call ide_wait                   ; wait for ide ready             
1029   050E F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1030   0512 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1031   0516 07 A4 05      call ide_wait                   ; wait for ide ready
1032   0519 06            sysret
1033   051A             ide_read_sect_wrapper:
1034   051A 07 22 05      call ide_read_sect
1035   051D 06            sysret
1036   051E             ide_write_sect_wrapper:
1037   051E 07 48 05      call ide_write_sect
1038   0521 06            sysret
1039   0522             ide_read_sect:
1040   0522 1A            mov al, ah
1041   0523 24            mov ah, bl
1042   0524 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1043   0527 1C            mov al, bh
1044   0528 3D D4 FF      mov [_ide_r4], al
1045   052B 12            mov a, c
1046   052C 3D D5 FF      mov [_ide_r5], al
1047   052F 1A            mov al, ah
1048   0530 87 0F         and al, %00001111
1049   0532 8B E0         or al, %11100000                ; mode lba, master
1050   0534 3D D6 FF      mov [_ide_r6], al
1051   0537             ide_read_sect_wait:
1052   0537 1D D7 FF      mov al, [_ide_r7]  
1053   053A 87 80         and al, $80                     ; busy flag
1054   053C C7 37 05      jnz ide_read_sect_wait
1055   053F 19 20         mov al, $20
1056   0541 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1057   0544 07 6E 05      call ide_read  
1058   0547 09            ret
1059   0548             ide_write_sect:
1060   0548 1A            mov al, ah
1061   0549 24            mov ah, bl
1062   054A 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1063   054D 1C            mov al, bh
1064   054E 3D D4 FF      mov [_ide_r4], al
1065   0551 12            mov a, c
1066   0552 3D D5 FF      mov [_ide_r5], al
1067   0555 1A            mov al, ah
1068   0556 87 0F         and al, %00001111
1069   0558 8B E0         or al, %11100000                ; mode lba, master
1070   055A 3D D6 FF      mov [_ide_r6], al
1071   055D             ide_write_sect_wait:
1072   055D 1D D7 FF      mov al, [_ide_r7]  
1073   0560 87 80         and al, $80                     ; busy flag
1074   0562 C7 5D 05      jnz ide_write_sect_wait
1075   0565 19 30         mov al, $30
1076   0567 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1077   056A 07 89 05      call ide_write      
1078   056D 09            ret
1079   056E             
1080   056E             ;----------------------------------------------------------------------------------------------------;
1081   056E             ; read ide data
1082   056E             ; pointer in d
1083   056E             ;----------------------------------------------------------------------------------------------------;
1084   056E             ide_read:
1085   056E DA            push d
1086   056F             ide_read_loop:
1087   056F 1D D7 FF      mov al, [_ide_r7]  
1088   0572 87 80         and al, 80h                     ; busy flag
1089   0574 C7 6F 05      jnz ide_read_loop               ; wait loop
1090   0577 1D D7 FF      mov al, [_ide_r7]
1091   057A 87 08         and al, %00001000               ; drq flag
1092   057C C6 87 05      jz ide_read_end
1093   057F 1D D0 FF      mov al, [_ide_r0]
1094   0582 3E            mov [d], al
1095   0583 79            inc d
1096   0584 0A 6F 05      jmp ide_read_loop
1097   0587             ide_read_end:
1098   0587 E7            pop d
1099   0588 09            ret
1100   0589             
1101   0589             ;----------------------------------------------------------------------------------------------------;
1102   0589             ; write ide data
1103   0589             ; data pointer in d
1104   0589             ;----------------------------------------------------------------------------------------------------;
1105   0589             ide_write:
1106   0589 DA            push d
1107   058A             ide_write_loop:
1108   058A 1D D7 FF      mov al, [_ide_r7]  
1109   058D 87 80         and al, 80h             ; busy flag
1110   058F C7 8A 05      jnz ide_write_loop      ; wait loop
1111   0592 1D D7 FF      mov al, [_ide_r7]
1112   0595 87 08         and al, %00001000       ; drq flag
1113   0597 C6 A2 05      jz ide_write_end
1114   059A 1E            mov al, [d]
1115   059B 3D D0 FF      mov [_ide_r0], al
1116   059E 79            inc d 
1117   059F 0A 8A 05      jmp ide_write_loop
1118   05A2             ide_write_end:
1119   05A2 E7            pop d
1120   05A3 09            ret
1121   05A4             
1122   05A4             ;----------------------------------------------------------------------------------------------------;
1123   05A4             ; wait for ide to be ready
1124   05A4             ;----------------------------------------------------------------------------------------------------;
1125   05A4             ide_wait:
1126   05A4 1D D7 FF      mov al, [_ide_r7]  
1127   05A7 87 80         and al, 80h        ; busy flag
1128   05A9 C7 A4 05      jnz ide_wait
1129   05AC 09            ret
1130   05AD             
1131   05AD             ;----------------------------------------------------------------------------------------------------;
1132   05AD             ; io syscall
1133   05AD             ;----------------------------------------------------------------------------------------------------;
1134   05AD             ; baud  divisor
1135   05AD             ; 50    2304
1136   05AD             ; 110   1047
1137   05AD             ; 300    384
1138   05AD             ; 600    192
1139   05AD             ; 1200    96
1140   05AD             ; 9600    12
1141   05AD             ; 19200    6
1142   05AD             ; 38400    3
1143   05AD             syscall_io_jmp:
1144   05AD E0 05         .dw syscall_io_putchar
1145   05AF ED 05         .dw syscall_io_getch
1146   05B1 B7 05         .dw syscall_io_uart_setup
1147   05B3             syscall_io:
1148   05B3 FD 0A AD 05   jmp [syscall_io_jmp + al]
1149   05B7             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1150   05B7             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1151   05B7             ; buffer, the transmitter holding register, or the interrupt enable register.
1152   05B7             syscall_io_uart_setup:
1153   05B7 1D 6F 17      mov al, [sys_uart0_lcr]
1154   05BA 8B 80         or al, $80                ; set dlab access bit
1155   05BC 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1156   05BF 1D 72 17      mov al, [sys_uart0_div0]
1157   05C2 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1158   05C5 1D 73 17      mov al, [sys_uart0_div1]
1159   05C8 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1160   05CB             
1161   05CB 1D 6F 17      mov al, [sys_uart0_lcr]
1162   05CE 87 7F         and al, $7f               ; clear dlab access bit 
1163   05D0 3D 83 FF      mov [_uart0_lcr], al
1164   05D3 1D 70 17      mov al, [sys_uart0_inten]
1165   05D6 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1166   05D9 1D 71 17      mov al, [sys_uart0_fifoen]
1167   05DC 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1168   05DF 06            sysret
1169   05E0             
1170   05E0             ; char in ah
1171   05E0             syscall_io_putchar:
1172   05E0             syscall_io_putchar_l0:
1173   05E0 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1174   05E3 87 20         and al, $20
1175   05E5 C6 E0 05      jz syscall_io_putchar_l0    
1176   05E8 1A            mov al, ah
1177   05E9 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1178   05EC 06            sysret
1179   05ED             
1180   05ED             ; char in ah
1181   05ED             ; al = sucess code
1182   05ED             syscall_io_getch:
1183   05ED D8            push b
1184   05EE DA            push d
1185   05EF FD 0C         sti
1186   05F1             syscall_io_getch_l0:  
1187   05F1 14 7C 17      mov a, [fifo_out]
1188   05F4 29 7A 17      mov b, [fifo_in]
1189   05F7 B0            cmp a, b
1190   05F8 C6 F1 05      je syscall_io_getch_l0
1191   05FB 3C            mov d, a
1192   05FC 77            inc a
1193   05FD AF DB 22      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1194   0600 C7 06 06      jne syscall_io_getch_cont
1195   0603 10 DB 1E      mov a, fifo  
1196   0606             syscall_io_getch_cont:  
1197   0606 42 7C 17      mov [fifo_out], a             ; update fifo pointer
1198   0609 1E            mov al, [d]                   ; get char
1199   060A 23            mov ah, al
1200   060B 1D 6E 17      mov al, [sys_echo_on]
1201   060E B9 01         cmp al, 1
1202   0610 C7 1F 06      jne syscall_io_getch_noecho 
1203   0613             ; here we just echo the char back to the console
1204   0613             syscall_io_getch_echo_l0:
1205   0613 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1206   0616 87 20         and al, $20                 ; isolate transmitter empty
1207   0618 C6 13 06      jz syscall_io_getch_echo_l0
1208   061B 1A            mov al, ah
1209   061C 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1210   061F             syscall_io_getch_noecho:
1211   061F 19 01         mov al, 1                    ; al = 1 means a char successfully received
1212   0621 E7            pop d
1213   0622 E5            pop b
1214   0623 06            sysret
1215   0624             
1216   0624             ;------------------------------------------------------------------------------------------------------;
1217   0624             ; file system data
1218   0624             ;------------------------------------------------------------------------------------------------------;
1219   0624             ; infor for : ide services interrupt
1220   0624             ; ide read/write 512-byte sector
1221   0624             ; al = option
1222   0624             ; user buffer pointer in d
1223   0624             ; ah = number of sectors
1224   0624             ; cb = lba bytes 3..0  
1225   0624             ;------------------------------------------------------------------------------------------------------;
1226   0624             ; file system data structure
1227   0624             ;------------------------------------------------------------------------------------------------------;
1228   0624             ; for a directory we have the header first, followed by metadata
1229   0624             ; header 1 sector (512 bytes)
1230   0624             ; metadata 1 sector (512 bytes)
1231   0624             ; header entries:
1232   0624             ; filename (64)
1233   0624             ; parent dir lba (2) -  to be used for faster backwards navigation...
1234   0624             ;
1235   0624             ; metadata entries:
1236   0624             ; filename (24)
1237   0624             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1238   0624             ; lba (2)
1239   0624             ; size (2)
1240   0624             ; day (1)
1241   0624             ; month (1)
1242   0624             ; year (1)
1243   0624             ; packet size = 32 bytes
1244   0624             ;
1245   0624             ; first directory on disk is the root directory '/'
1246   0624             file_system_jmptbl:
1247   0624 8F 06         .dw fs_mkfs                   ; 0
1248   0626 00 00         .dw 0                         ; 1
1249   0628 F1 06         .dw fs_mkdir                  ; 2
1250   062A 6A 0A         .dw fs_cd                     ; 3
1251   062C 71 0A         .dw fs_ls                     ; 4
1252   062E 5C 0B         .dw fs_mktxt                  ; 5
1253   0630 27 0C         .dw fs_mkbin                  ; 6
1254   0632 EE 0C         .dw fs_pwd                    ; 7
1255   0634 0B 0D         .dw fs_cat                    ; 8
1256   0636 67 0D         .dw fs_rmdir                  ; 9
1257   0638 C3 0D         .dw fs_rm                     ; 10
1258   063A 00 00         .dw 0                         ; 11
1259   063C 00 00         .dw 0                         ; 12
1260   063E 00 00         .dw 0                         ; 13
1261   0640 97 06         .dw fs_chmod                  ; 14
1262   0642 2B 0E         .dw fs_mv                     ; 15
1263   0644 90 06         .dw fs_cd_root                ; 16
1264   0646 66 0A         .dw fs_get_curr_dirid         ; 17
1265   0648 42 08         .dw fs_dir_id_to_path         ; 18
1266   064A A8 08         .dw fs_path_to_dir_id_user    ; 19
1267   064C C2 09         .dw fs_load_from_path_user    ; 20  
1268   064E 32 09         .dw fs_filepath_exists_user   ; 21
1269   0650             
1270   0650 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1270   0654 79 73 63 61 
1270   0658 6C 6C 5F 66 
1270   065C 69 6C 65 5F 
1270   0660 73 79 73 74 
1270   0664 65 6D 20 63 
1270   0668 61 6C 6C 65 
1270   066C 64 3A 20 00 
1271   0670             syscall_file_system:
1272   0670 DD            push bl
1273   0671 31 6D 17      mov bl, [sys_debug_mode]
1274   0674               ; debug block
1275   0674 C1 00         cmp bl, 0
1276   0676 EA            pop bl
1277   0677 C6 8B 06      je syscall_filesystem_jmp
1278   067A DA            push d
1279   067B DD            push bl
1280   067C 3B 50 06      mov d, s_syscall_fs_dbg0
1281   067F 07 44 12      call _puts
1282   0682 2F            mov bl, al
1283   0683 07 E4 12      call print_u8x
1284   0686 07 F1 11      call printnl
1285   0689 EA            pop bl
1286   068A E7            pop d
1287   068B             syscall_filesystem_jmp:
1288   068B FD 0A 24 06   jmp [file_system_jmptbl + al]
1289   068F             
1290   068F             fs_mkfs:  
1291   068F 06            sysret  
1292   0690               
1293   0690             fs_cd_root:
1294   0690 10 20 00      mov a, root_id
1295   0693 42 7E 17      mov [current_dir_id], a      ; set current directory lba to root
1296   0696 06            sysret  
1297   0697             
1298   0697             ; filename in d (userspace data)
1299   0697             ; permission in bl
1300   0697             fs_chmod:
1301   0697 DD            push bl
1302   0698 FD 4E         mov si, d
1303   069A FD 4F DB 1C   mov di, user_data
1304   069E 38 80 00      mov c, 128
1305   06A1 04            load                        ; load filename from user-space
1306   06A2 14 7E 17      mov a, [current_dir_id]
1307   06A5 77            inc a                       ; metadata sector
1308   06A6 27            mov b, a
1309   06A7 38 00 00      mov c, 0                    ; upper lba = 0
1310   06AA 22 01         mov ah, $01                  ; 1 sector
1311   06AC 3B DB 24      mov d, transient_area
1312   06AF 07 22 05      call ide_read_sect          ; read directory
1313   06B2 FD 10         cla
1314   06B4 42 76 17      mov [index], a              ; reset file counter
1315   06B7             fs_chmod_l1:
1316   06B7 FD 4E         mov si, d
1317   06B9 FD 4F DB 1C   mov di, user_data
1318   06BD 07 87 10      call _strcmp
1319   06C0 C6 D7 06      je fs_chmod_found_entry
1320   06C3 58 20 00      add d, 32
1321   06C6 14 76 17      mov a, [index]
1322   06C9 77            inc a
1323   06CA 42 76 17      mov [index], a
1324   06CD AF 10 00      cmp a, fst_files_per_dir
1325   06D0 C7 B7 06      jne fs_chmod_l1
1326   06D3 EA            pop bl
1327   06D4 0A F0 06      jmp fs_chmod_not_found
1328   06D7             fs_chmod_found_entry:  
1329   06D7 FD 79         mov g, b                    ; save lba
1330   06D9 EA            pop bl                      ; retrieve saved permission value
1331   06DA 1F 18 00      mov al, [d + 24]            ; read file permissions
1332   06DD 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1333   06DF 8C            or al, bl                   ; set new permissions
1334   06E0 3F 18 00      mov [d + 24], al            ; write new permissions
1335   06E3 38 00 00      mov c, 0
1336   06E6 3B DB 24      mov d, transient_area
1337   06E9 22 01         mov ah, $01                 ; disk write 1 sect
1338   06EB FD 27         mov b, g                    ; retrieve lba
1339   06ED 07 48 05      call ide_write_sect         ; write sector
1340   06F0             fs_chmod_not_found:
1341   06F0 06            sysret
1342   06F1             
1343   06F1             ;------------------------------------------------------------------------------------------------------;
1344   06F1             ; create new directory
1345   06F1             ;------------------------------------------------------------------------------------------------------;
1346   06F1             ; search list for null name entry. add new directory to list
1347   06F1             fs_mkdir:
1348   06F1 FD 4E         mov si, d
1349   06F3 FD 4F DB 1C   mov di, user_data
1350   06F7 38 00 02      mov c, 512
1351   06FA 04            load                        ; load data from user-space
1352   06FB 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1353   06FE                                           ; when checking for null name, since root has a null name)
1354   06FE 38 00 00      mov c, 0                    ; upper lba = 0
1355   0701             fs_mkdir_l1:  
1356   0701 22 01         mov ah, $01                  ; 1 sector
1357   0703 3B DB 24      mov d, transient_area
1358   0706 07 22 05      call ide_read_sect          ; read sector
1359   0709 BD 00         cmp byte[d], 0              ; check for null
1360   070B C6 14 07      je fs_mkdir_found_null
1361   070E 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1362   0711 0A 01 07      jmp fs_mkdir_l1
1363   0714             fs_mkdir_found_null:
1364   0714             ;create header file by grabbing dir name from parameter
1365   0714 D8            push b                      ; save new directory's lba
1366   0715 38 40 00      mov c, 64
1367   0718 FD 4D DB 1C   mov si, user_data
1368   071C FD 4F DB 24   mov di, transient_area
1369   0720 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1370   0722 14 7E 17      mov a, [current_dir_id]
1371   0725 42 1B 25      mov [transient_area + 64], a    ; store parent directory lba
1372   0728 19 00         mov al, 0
1373   072A FD 4F DB 26   mov di, transient_area + 512
1374   072E 38 00 02      mov c, 512
1375   0731 FD F7         rep stosb                       ; clean buffer
1376   0733 38 00 00      mov c, 0                        ; reset lba(c) to 0
1377   0736             ; write directory entry sectors
1378   0736 3B DB 24      mov d, transient_area
1379   0739 22 02         mov ah, $02                     ; disk write, 2 sectors
1380   073B 07 48 05      call ide_write_sect             ; write sector
1381   073E             ; now we need to add the new directory to the list, inside the current directory
1382   073E 14 7E 17      mov a, [current_dir_id]
1383   0741 53 01 00      add a, 1
1384   0744 27            mov b, a                        ; metadata sector
1385   0745 38 00 00      mov c, 0
1386   0748 FD 79         mov g, b                        ; save lba
1387   074A 3B DB 24      mov d, transient_area
1388   074D 22 01         mov ah, $01                  ; 1 sector
1389   074F 07 22 05      call ide_read_sect              ; read metadata sector
1390   0752             fs_mkdir_l2:
1391   0752 BD 00         cmp byte[d], 0
1392   0754 C6 5D 07      je fs_mkdir_found_null2
1393   0757 58 20 00      add d, fst_entry_size
1394   075A 0A 52 07      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1395   075D             fs_mkdir_found_null2:
1396   075D FD 4D DB 1C   mov si, user_data
1397   0761 FD 50         mov di, d
1398   0763 07 9C 10      call _strcpy                    ; copy directory name
1399   0766 58 18 00      add d, 24                       ; goto attributes
1400   0769 19 0B         mov al, %00001011               ; directory, no execute, write, read
1401   076B 3E            mov [d], al      
1402   076C 79            inc d
1403   076D E5            pop b
1404   076E D8            push b                          ; push lba back
1405   076F FD 43         mov [d], b                      ; save lba
1406   0771             ; set file creation date  
1407   0771 58 04 00      add d, 4
1408   0774 19 04         mov al, 4
1409   0776 05 01         syscall sys_rtc
1410   0778 1A            mov al, ah
1411   0779 3E            mov [d], al                     ; set day
1412   077A 79            inc d
1413   077B 19 05         mov al, 5
1414   077D 05 01         syscall sys_rtc
1415   077F 1A            mov al, ah
1416   0780 3E            mov [d], al                     ; set month
1417   0781 79            inc d
1418   0782 19 06         mov al, 6
1419   0784 05 01         syscall sys_rtc
1420   0786 1A            mov al, ah
1421   0787 3E            mov [d], al                     ; set year
1422   0788             ; write sector into disk for new directory entry
1423   0788 FD 27         mov b, g
1424   078A 38 00 00      mov c, 0
1425   078D 3B DB 24      mov d, transient_area
1426   0790 22 01         mov ah, $01                     ; disk write, 1 sector
1427   0792 07 48 05      call ide_write_sect             ; write sector
1428   0795             
1429   0795             ; after adding the new directory's information to its parent directory's list
1430   0795             ; we need to now enter the new directory, and to it add two new directories!
1431   0795             ; which directories do we need to add ? '..' and '.' are the directories needed.
1432   0795             ; importantly, note that these two new directories are only entries in the list
1433   0795             ; and do not have actual physical entries in the disk as real directories.
1434   0795             ; i.e. they only exist as list entries in the new directory created so that
1435   0795             ; the new directory can reference its parent and itself.
1436   0795             ; we need to add both '..' and '.'
1437   0795             ; this first section is for '..' and on the section below we do the same for '.'
1438   0795 E4            pop a                         ; retrieve the new directory's lba  
1439   0796 D7            push a                        ; and save again
1440   0797 53 01 00      add a, 1
1441   079A 27            mov b, a                      ; metadata sector
1442   079B 38 00 00      mov c, 0
1443   079E FD 79         mov g, b                      ; save lba
1444   07A0 3B DB 24      mov d, transient_area
1445   07A3 22 01         mov ah, $01                  ; 1 sector
1446   07A5 07 22 05      call ide_read_sect            ; read metadata sector
1447   07A8             fs_mkdir_l3:
1448   07A8 BD 00         cmp byte[d], 0
1449   07AA C6 B3 07      je fs_mkdir_found_null3
1450   07AD 58 20 00      add d, fst_entry_size
1451   07B0 0A A8 07      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1452   07B3             fs_mkdir_found_null3:
1453   07B3 FD 4D 9D 17   mov si, s_parent_dir
1454   07B7 FD 50         mov di, d
1455   07B9 07 9C 10      call _strcpy                  ; copy directory name
1456   07BC 58 18 00      add d, 24                     ; goto attributes
1457   07BF 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1458   07C1 3E            mov [d], al      
1459   07C2 79            inc d
1460   07C3 29 7E 17      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1461   07C6 FD 43         mov [d], b                    ; save lba
1462   07C8             ; set file creation date  
1463   07C8 58 04 00      add d, 4
1464   07CB 19 04         mov al, 4
1465   07CD 05 01         syscall sys_rtc
1466   07CF 1A            mov al, ah
1467   07D0 3E            mov [d], al                   ; set day
1468   07D1 79            inc d
1469   07D2 19 05         mov al, 5
1470   07D4 05 01         syscall sys_rtc
1471   07D6 1A            mov al, ah
1472   07D7 3E            mov [d], al                   ; set month
1473   07D8 79            inc d
1474   07D9 19 06         mov al, 6
1475   07DB 05 01         syscall sys_rtc
1476   07DD 1A            mov al, ah
1477   07DE 3E            mov [d], al                   ; set year
1478   07DF             ; write sector into disk for new directory entry
1479   07DF FD 27         mov b, g
1480   07E1 38 00 00      mov c, 0
1481   07E4 3B DB 24      mov d, transient_area
1482   07E7 22 01         mov ah, $01                   ; disk write, 1 sector
1483   07E9 07 48 05      call ide_write_sect           ; write sector
1484   07EC             ;;;;;;;;;;;;;
1485   07EC             ; like we did above for '..', we need to now add the '.' directory to the list.
1486   07EC             ;------------------------------------------------------------------------------------------------------;
1487   07EC E4            pop a                         ; retrieve the new directory's lba  
1488   07ED D7            push a
1489   07EE 53 01 00      add a, 1
1490   07F1 27            mov b, a                      ; metadata sector
1491   07F2 38 00 00      mov c, 0
1492   07F5 FD 79         mov g, b                      ; save lba
1493   07F7 3B DB 24      mov d, transient_area
1494   07FA 22 01         mov ah, $01                  ; 1 sector
1495   07FC 07 22 05      call ide_read_sect            ; read metadata sector
1496   07FF             fs_mkdir_l4:
1497   07FF BD 00         cmp byte[d], 0
1498   0801 C6 0A 08      je fs_mkdir_found_null4
1499   0804 58 20 00      add d, fst_entry_size
1500   0807 0A FF 07      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1501   080A             fs_mkdir_found_null4:
1502   080A FD 4D A0 17   mov si, s_current_dir
1503   080E FD 50         mov di, d
1504   0810 07 9C 10      call _strcpy                  ; copy directory name
1505   0813 58 18 00      add d, 24                     ; goto attributes
1506   0816 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1507   0818 3E            mov [d], al      
1508   0819 79            inc d
1509   081A E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1510   081B FD 43         mov [d], b                    ; save lba
1511   081D             ; set file creation date  
1512   081D 58 04 00      add d, 4
1513   0820 19 04         mov al, 4
1514   0822 05 01         syscall sys_rtc
1515   0824 1A            mov al, ah
1516   0825 3E            mov [d], al                   ; set day
1517   0826 79            inc d
1518   0827 19 05         mov al, 5
1519   0829 05 01         syscall sys_rtc
1520   082B 1A            mov al, ah
1521   082C 3E            mov [d], al                   ; set month
1522   082D 79            inc d
1523   082E 19 06         mov al, 6
1524   0830 05 01         syscall sys_rtc
1525   0832 1A            mov al, ah
1526   0833 3E            mov [d], al                   ; set year
1527   0834             ; write sector into disk for new directory entry
1528   0834 FD 27         mov b, g
1529   0836 38 00 00      mov c, 0
1530   0839 3B DB 24      mov d, transient_area
1531   083C 22 01         mov ah, $01                   ; disk write, 1 sector
1532   083E 07 48 05      call ide_write_sect           ; write sector
1533   0841             fs_mkdir_end:
1534   0841 06            sysret
1535   0842             
1536   0842             ;------------------------------------------------------------------------------------------------------;
1537   0842             ; get path from a given directory dirid
1538   0842             ; pseudo code:
1539   0842             ;  fs_dir_id_to_path(int dirid, char *d){
1540   0842             ;    if(dirid == 0){
1541   0842             ;      reverse path in d;
1542   0842             ;      return;
1543   0842             ;    }
1544   0842             ;    else{
1545   0842             ;      copy directory name to end of d;
1546   0842             ;      add '/' to end of d;
1547   0842             ;      parentid = get parent directory id;
1548   0842             ;      fs_dir_id_to_path(parentid, d);
1549   0842             ;    }
1550   0842             ;  }
1551   0842             ; a = dirid
1552   0842             ; d = generated path string pointer
1553   0842             ;------------------------------------------------------------------------------------------------------;
1554   0842             ; sample path: /usr/bin
1555   0842             fs_dir_id_to_path:
1556   0842 3B 5B 1C      mov d, filename
1557   0845 19 00         mov al, 0
1558   0847 3E            mov [d], al                     ; initialize path string 
1559   0848 14 7E 17      mov a, [current_dir_id]
1560   084B 07 58 08      call fs_dir_id_to_path_e0
1561   084E 3B 5B 1C      mov d, filename
1562   0851 07 30 10      call _strrev
1563   0854 07 44 12      call _puts
1564   0857 06            sysret
1565   0858             fs_dir_id_to_path_e0:
1566   0858 07 77 08      call get_dirname_from_dirid
1567   085B FD 4D A2 17   mov si, s_fslash
1568   085F FD 50         mov di, d
1569   0861 07 AA 10      call _strcat                    ; add '/' to end of path
1570   0864 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1571   0867 C6 76 08      je fs_dir_id_to_path_root
1572   086A 07 94 08      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1573   086D AF 20 00      cmp a, root_id               ; check if we are at the root directory
1574   0870 C6 76 08      je fs_dir_id_to_path_root
1575   0873 07 58 08      call fs_dir_id_to_path_e0     ; recursively call itself
1576   0876             fs_dir_id_to_path_root:
1577   0876 09            ret
1578   0877             
1579   0877             ;------------------------------------------------------------------------------------------------------;
1580   0877             ; in_puts:
1581   0877             ; a = directory id
1582   0877             ; out_puts:
1583   0877             ; d = pointer to directory name string
1584   0877             ;------------------------------------------------------------------------------------------------------;
1585   0877             get_dirname_from_dirid:
1586   0877 D7            push a
1587   0878 D8            push b
1588   0879 DA            push d
1589   087A 27            mov b, a
1590   087B 38 00 00      mov c, 0                      ; upper lba = 0
1591   087E 22 01         mov ah, $01                  ; 1 sector
1592   0880 3B DB 22      mov d, transient_area - 512
1593   0883 07 22 05      call ide_read_sect            ; read directory
1594   0886 07 30 10      call _strrev                  ; reverse dir name before copying
1595   0889 FD 4E         mov si, d
1596   088B E7            pop d                         ; destination address = d value pushed at beginning
1597   088C FD 50         mov di, d
1598   088E 07 AA 10      call _strcat                  ; copy filename to d
1599   0891 E5            pop b
1600   0892 E4            pop a
1601   0893 09            ret
1602   0894             
1603   0894             ;------------------------------------------------------------------------------------------------------;
1604   0894             ; in_puts:
1605   0894             ; a = directory id
1606   0894             ; out_puts:
1607   0894             ; a = parent directory id
1608   0894             ;------------------------------------------------------------------------------------------------------;
1609   0894             get_parentid_from_dirid:
1610   0894 D8            push b
1611   0895 DA            push d
1612   0896 27            mov b, a
1613   0897 38 00 00      mov c, 0                      ; upper lba = 0
1614   089A 22 01         mov ah, $01                  ; 1 sector
1615   089C 3B DB 22      mov d, transient_area - 512
1616   089F 07 22 05      call ide_read_sect            ; read directory
1617   08A2 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1618   08A5 E7            pop d
1619   08A6 E5            pop b
1620   08A7 09            ret
1621   08A8             
1622   08A8             ;------------------------------------------------------------------------------------------------------;
1623   08A8             ; get dirid from a given path string
1624   08A8             ; in_puts:
1625   08A8             ; d = path pointer 
1626   08A8             ; out_puts:
1627   08A8             ; a = dirid
1628   08A8             ; if dir non existent, a = ffff (fail code)
1629   08A8             ; /usr/local/bin    - absolute
1630   08A8             ; local/bin/games    - relative
1631   08A8             ;------------------------------------------------------------------------------------------------------;
1632   08A8             fs_path_to_dir_id_user:
1633   08A8 FD 4E         mov si, d
1634   08AA FD 4F DB 1C   mov di, user_data
1635   08AE 38 00 02      mov c, 512
1636   08B1 04            load
1637   08B2 07 B6 08      call get_dirid_from_path
1638   08B5 06            sysret
1639   08B6             get_dirid_from_path:
1640   08B6 26 DB 1C      mov b, user_data
1641   08B9 FD 42 69 16   mov [prog], b                  ; token pointer set to path string
1642   08BD 07 CA 14      call get_token
1643   08C0 31 6C 16      mov bl, [tok]
1644   08C3 C1 01         cmp bl, tok_fslash
1645   08C5 C6 D1 08      je get_dirid_from_path_abs 
1646   08C8 14 7E 17      mov a, [current_dir_id]
1647   08CB 07 50 16      call _putback
1648   08CE 0A D4 08      jmp get_dirid_from_path_e0
1649   08D1             get_dirid_from_path_abs:
1650   08D1 10 20 00      mov a, root_id
1651   08D4             get_dirid_from_path_e0:
1652   08D4 07 CA 14      call get_token
1653   08D7 31 6B 16      mov bl, [toktyp]
1654   08DA C1 00         cmp bl, toktyp_identifier
1655   08DC C7 2D 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1656   08DF             
1657   08DF FD 4D 6D 16   mov si, tokstr
1658   08E3 FD 4F 5B 1C   mov di, filename
1659   08E7 07 9C 10      call _strcpy        
1660   08EA 77            inc a                         ; metadata sector
1661   08EB 27            mov b, a
1662   08EC 38 00 00      mov c, 0                      ; upper lba = 0
1663   08EF 22 01         mov ah, $01                  ; 1 sector
1664   08F1 3B DB 24      mov d, transient_area
1665   08F4 07 22 05      call ide_read_sect            ; read directory
1666   08F7 FD 10         cla
1667   08F9 42 76 17      mov [index], a
1668   08FC             get_dirid_from_path_l1:
1669   08FC FD 4E         mov si, d
1670   08FE FD 4F 5B 1C   mov di, filename
1671   0902 07 87 10      call _strcmp
1672   0905 C6 1B 09      je get_dirid_from_path_name_equal  
1673   0908 58 20 00      add d, 32
1674   090B 14 76 17      mov a, [index]
1675   090E 77            inc a
1676   090F 42 76 17      mov [index], a
1677   0912 AF 10 00      cmp a, fst_files_per_dir
1678   0915 C6 2E 09      je get_dirid_from_path_fail
1679   0918 0A FC 08      jmp get_dirid_from_path_l1
1680   091B             get_dirid_from_path_name_equal:
1681   091B 58 19 00      add d, 25           
1682   091E 15            mov a, [d]                    ; set result register a = dirid
1683   091F 07 CA 14      call get_token
1684   0922 31 6C 16      mov bl, [tok]
1685   0925 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1686   0927 C6 D4 08      je get_dirid_from_path_e0
1687   092A 07 50 16      call _putback
1688   092D             get_dirid_from_path_end:
1689   092D 09            ret
1690   092E             get_dirid_from_path_fail:
1691   092E 10 FF FF      mov a, $ffff
1692   0931 09            ret
1693   0932             
1694   0932             
1695   0932             ;------------------------------------------------------------------------------------------------------;
1696   0932             ; check if file exists by a given path string
1697   0932             ; in_puts:
1698   0932             ; d = path pointer 
1699   0932             ; outputs:
1700   0932             ; a = success code, if file exists gives lba, else, give 0
1701   0932             ; /usr/local/bin/ed
1702   0932             ;------------------------------------------------------------------------------------------------------;
1703   0932             fs_filepath_exists_user:
1704   0932 FD 4E         mov si, d
1705   0934 FD 4F DB 1C   mov di, user_data
1706   0938 38 00 02      mov c, 512
1707   093B 04            load
1708   093C 07 40 09      call file_exists_by_path
1709   093F 06            sysret
1710   0940             file_exists_by_path:
1711   0940 26 DB 1C      mov b, user_data
1712   0943 FD 42 69 16   mov [prog], b                   ; token pointer set to path string
1713   0947 07 CA 14      call get_token
1714   094A 31 6C 16      mov bl, [tok]
1715   094D C1 01         cmp bl, tok_fslash
1716   094F C6 5B 09      je  file_exists_by_path_abs
1717   0952 14 7E 17      mov a, [current_dir_id]
1718   0955 07 50 16      call _putback
1719   0958 0A 5E 09      jmp file_exists_by_path_e0
1720   095B             file_exists_by_path_abs:
1721   095B 10 20 00      mov a, root_id
1722   095E             file_exists_by_path_e0:
1723   095E 07 CA 14      call get_token
1724   0961 31 6B 16      mov bl, [toktyp]
1725   0964 C1 00         cmp bl, toktyp_identifier
1726   0966 C7 BE 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1727   0969 FD 4D 6D 16   mov si, tokstr
1728   096D FD 4F 5B 1C   mov di, filename
1729   0971 07 9C 10      call _strcpy        
1730   0974 77            inc a                           ; metadata sector
1731   0975 27            mov b, a
1732   0976 38 00 00      mov c, 0                        ; upper lba = 0
1733   0979 22 01         mov ah, $01                  ; 1 sector
1734   097B 3B DB 24      mov d, transient_area
1735   097E 07 22 05      call ide_read_sect              ; read directory
1736   0981 FD 10         cla
1737   0983 42 76 17      mov [index], a
1738   0986             file_exists_by_path_l1:
1739   0986 FD 4E         mov si, d
1740   0988 FD 4F 5B 1C   mov di, filename
1741   098C 07 87 10      call _strcmp
1742   098F C6 A5 09      je   file_exists_by_path_name_equal
1743   0992 58 20 00      add d, 32
1744   0995 14 76 17      mov a, [index]
1745   0998 77            inc a
1746   0999 42 76 17      mov [index], a
1747   099C AF 10 00      cmp a, fst_files_per_dir
1748   099F C6 BE 09      je file_exists_by_path_end
1749   09A2 0A 86 09      jmp file_exists_by_path_l1
1750   09A5             file_exists_by_path_name_equal:
1751   09A5 33 18 00      mov bl, [d + 24]
1752   09A8 FD 87 38      and bl, %00111000               ; directory flag
1753   09AB C1 08         cmp bl, %00001000               ; is dir?
1754   09AD C6 B4 09      je file_exists_by_path_isdir;
1755   09B0             ; entry is a file
1756   09B0 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1757   09B3 09            ret
1758   09B4             file_exists_by_path_isdir:
1759   09B4 58 19 00      add d, 25           
1760   09B7 15            mov a, [d]                      ; set result register a = dirid
1761   09B8 07 CA 14      call get_token
1762   09BB 0A 5E 09      jmp file_exists_by_path_e0
1763   09BE             file_exists_by_path_end:
1764   09BE 10 00 00      mov a, 0                        ; return 0 because file was not found
1765   09C1 09            ret
1766   09C2             
1767   09C2             ;------------------------------------------------------------------------------------------------------;
1768   09C2             ; load file data from a given path string
1769   09C2             ; inputs:
1770   09C2             ; d = path pointer 
1771   09C2             ; di = userspace program data destination
1772   09C2             ; /usr/local/bin/ed
1773   09C2             ; ./ed
1774   09C2             ;------------------------------------------------------------------------------------------------------;
1775   09C2             fs_load_from_path_user:
1776   09C2 E3            push di
1777   09C3 FD 4E         mov si, d
1778   09C5 FD 4F DB 1C   mov di, user_data
1779   09C9 38 00 02      mov c, 512
1780   09CC 04            load
1781   09CD 07 DA 09      call loadfile_from_path
1782   09D0 F0            pop di
1783   09D1 FD 4D DB 24   mov si, transient_area
1784   09D5 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1785   09D8 03            store
1786   09D9 06            sysret
1787   09DA             loadfile_from_path:
1788   09DA 26 DB 1C      mov b, user_data
1789   09DD FD 42 69 16   mov [prog], b                 ; token pointer set to path string
1790   09E1 07 CA 14      call get_token
1791   09E4 31 6C 16      mov bl, [tok]
1792   09E7 C1 01         cmp bl, tok_fslash
1793   09E9 C6 F5 09      je loadfile_from_path_abs 
1794   09EC 14 7E 17      mov a, [current_dir_id]
1795   09EF 07 50 16      call _putback
1796   09F2 0A F8 09      jmp loadfile_from_path_e0
1797   09F5             loadfile_from_path_abs:
1798   09F5 10 20 00      mov a, root_id
1799   09F8             loadfile_from_path_e0:
1800   09F8 07 CA 14      call get_token
1801   09FB 31 6B 16      mov bl, [toktyp]
1802   09FE C1 00         cmp bl, toktyp_identifier
1803   0A00 C7 65 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1804   0A03 FD 4D 6D 16   mov si, tokstr
1805   0A07 FD 4F 5B 1C   mov di, filename
1806   0A0B 07 9C 10      call _strcpy        
1807   0A0E 77            inc a                         ; metadata sector
1808   0A0F 27            mov b, a
1809   0A10 38 00 00      mov c, 0                      ; upper lba = 0
1810   0A13 22 01         mov ah, $01                  ; 1 sector
1811   0A15 3B DB 24      mov d, transient_area
1812   0A18 07 22 05      call ide_read_sect            ; read directory
1813   0A1B FD 10         cla
1814   0A1D 42 76 17      mov [index], a
1815   0A20             loadfile_from_path_l1:
1816   0A20 FD 4E         mov si, d
1817   0A22 FD 4F 5B 1C   mov di, filename
1818   0A26 07 87 10      call _strcmp
1819   0A29 C6 3F 0A      je loadfile_from_path_name_equal  
1820   0A2C 58 20 00      add d, 32
1821   0A2F 14 76 17      mov a, [index]
1822   0A32 77            inc a
1823   0A33 42 76 17      mov [index], a
1824   0A36 AF 10 00      cmp a, fst_files_per_dir
1825   0A39 C6 65 0A      je loadfile_from_path_end
1826   0A3C 0A 20 0A      jmp loadfile_from_path_l1
1827   0A3F             loadfile_from_path_name_equal:
1828   0A3F 33 18 00      mov bl, [d + 24]
1829   0A42 FD 87 38      and bl, %00111000             ; directory flag
1830   0A45 C1 08         cmp bl, %00001000             ; is dir?
1831   0A47 C6 5B 0A      je loadfile_isdirectory  
1832   0A4A             ; entry is a file
1833   0A4A 2B 19 00      mov b, [d + 25]               ; get lba
1834   0A4D FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
1835   0A4F 3B DB 24      mov d, transient_area
1836   0A52 38 00 00      mov c, 0
1837   0A55 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
1838   0A57 07 22 05      call ide_read_sect            ; read sector
1839   0A5A 09            ret
1840   0A5B             loadfile_isdirectory:
1841   0A5B 58 19 00      add d, 25           
1842   0A5E 15            mov a, [d]                    ; set result register a = dirid
1843   0A5F 07 CA 14      call get_token
1844   0A62 0A F8 09      jmp loadfile_from_path_e0
1845   0A65             loadfile_from_path_end:
1846   0A65 09            ret
1847   0A66             
1848   0A66             ;------------------------------------------------------------------------------------------------------;
1849   0A66             ; return the id of the current directory
1850   0A66             ; id returned in b
1851   0A66             ;------------------------------------------------------------------------------------------------------;
1852   0A66             fs_get_curr_dirid:
1853   0A66 29 7E 17      mov b, [current_dir_id]
1854   0A69 06            sysret
1855   0A6A             
1856   0A6A             ;------------------------------------------------------------------------------------------------------;
1857   0A6A             ; cd
1858   0A6A             ;------------------------------------------------------------------------------------------------------;
1859   0A6A             ; new dirid in b
1860   0A6A             fs_cd:
1861   0A6A FD 42 7E 17   mov [current_dir_id], b
1862   0A6E 06            sysret  
1863   0A6F             
1864   0A6F             ;------------------------------------------------------------------------------------------------------;
1865   0A6F             ; ls
1866   0A6F             ; dirid in b
1867   0A6F             ;------------------------------------------------------------------------------------------------------;
1868   0A6F 00 00       ls_count:       .dw 0
1869   0A71             fs_ls:
1870   0A71 FD 77         inc b                        ; metadata sector
1871   0A73 38 00 00      mov c, 0                     ; upper lba = 0
1872   0A76 22 01         mov ah, $01                  ; 1 sector
1873   0A78 3B DB 24      mov d, transient_area
1874   0A7B 07 22 05      call ide_read_sect           ; read directory
1875   0A7E FD 10         cla
1876   0A80 42 76 17      mov [index], a               ; reset entry index
1877   0A83 3D 6F 0A      mov [ls_count], al           ; reset item count
1878   0A86             fs_ls_l1:
1879   0A86 BD 00         cmp byte [d], 0              ; check for null
1880   0A88 C6 1F 0B      je fs_ls_next
1881   0A8B             fs_ls_non_null:
1882   0A8B 1D 6F 0A      mov al, [ls_count]
1883   0A8E 7A            inc al
1884   0A8F 3D 6F 0A      mov [ls_count], al           ; increment item count
1885   0A92 1F 18 00      mov al, [d + 24]
1886   0A95 87 38         and al, %00111000
1887   0A97 FD A2 03      shr al, 3
1888   0A9A 22 00         mov ah, 0                    ; file type
1889   0A9C B7 A9 17      mov a, [a + file_type]      
1890   0A9F 23            mov ah, al
1891   0AA0 07 18 11      call _putchar
1892   0AA3 1F 18 00      mov al, [d + 24]
1893   0AA6 87 01         and al, %00000001
1894   0AA8 22 00         mov ah, 0
1895   0AAA B7 A4 17      mov a, [a + file_attrib]     ; read
1896   0AAD 23            mov ah, al
1897   0AAE 07 18 11      call _putchar
1898   0AB1 1F 18 00      mov al, [d + 24]
1899   0AB4 87 02         and al, %00000010
1900   0AB6 22 00         mov ah, 0
1901   0AB8 B7 A4 17      mov a, [a + file_attrib]     ; write
1902   0ABB 23            mov ah, al
1903   0ABC 07 18 11      call _putchar
1904   0ABF 1F 18 00      mov al, [d + 24]
1905   0AC2 87 04         and al, %00000100
1906   0AC4 22 00         mov ah, 0
1907   0AC6 B7 A4 17      mov a, [a + file_attrib]     ; execute
1908   0AC9 23            mov ah, al
1909   0ACA 07 18 11      call _putchar
1910   0ACD 22 20         mov ah, $20
1911   0ACF 07 18 11      call _putchar  
1912   0AD2 2B 1B 00      mov b, [d + 27]
1913   0AD5 07 A0 12      call print_u16x              ; filesize
1914   0AD8 22 20         mov ah, $20
1915   0ADA 07 18 11      call _putchar  
1916   0ADD 2B 19 00      mov b, [d + 25]
1917   0AE0 07 A0 12      call print_u16x              ; dirid / lba
1918   0AE3 22 20         mov ah, $20
1919   0AE5 07 18 11      call _putchar
1920   0AE8             ; print date
1921   0AE8 33 1D 00      mov bl, [d + 29]             ; day
1922   0AEB 07 E4 12      call print_u8x
1923   0AEE 22 20         mov ah, $20
1924   0AF0 07 18 11      call _putchar  
1925   0AF3 1F 1E 00      mov al, [d + 30]             ; month
1926   0AF6 FD 9E 02      shl al, 2
1927   0AF9 DA            push d
1928   0AFA 3B 68 18      mov d, s_months
1929   0AFD 22 00         mov ah, 0
1930   0AFF 59            add d, a
1931   0B00 07 44 12      call _puts
1932   0B03 E7            pop d
1933   0B04 22 20         mov ah, $20
1934   0B06 07 18 11      call _putchar
1935   0B09 2E 20         mov bl, $20
1936   0B0B 07 E4 12      call print_u8x
1937   0B0E 33 1F 00      mov bl, [d + 31]             ; year
1938   0B11 07 E4 12      call print_u8x  
1939   0B14 22 20         mov ah, $20
1940   0B16 07 18 11      call _putchar  
1941   0B19 07 44 12      call _puts                   ; print filename  
1942   0B1C 07 F1 11      call printnl
1943   0B1F             fs_ls_next:
1944   0B1F 14 76 17      mov a, [index]
1945   0B22 77            inc a
1946   0B23 42 76 17      mov [index], a
1947   0B26 AF 10 00      cmp a, fst_files_per_dir
1948   0B29 C6 32 0B      je fs_ls_end
1949   0B2C 58 20 00      add d, 32      
1950   0B2F 0A 86 0A      jmp fs_ls_l1  
1951   0B32             fs_ls_end:
1952   0B32 3B B9 17      mov d, s_ls_total
1953   0B35 07 44 12      call _puts
1954   0B38 1D 6F 0A      mov al, [ls_count]
1955   0B3B 07 F6 12      call print_u8d
1956   0B3E 07 F1 11      call printnl
1957   0B41 06            sysret
1958   0B42             
1959   0B42             ;------------------------------------------------------------------------------------------------------;
1960   0B42             ; finds an empty data block
1961   0B42             ; block lba returned in b
1962   0B42             ;------------------------------------------------------------------------------------------------------;
1963   0B42             fs_find_empty_block:
1964   0B42 26 A0 00      mov b, fs_lba_start     ; raw files starting block
1965   0B45 38 00 00      mov c, 0                ; upper lba = 0
1966   0B48             fs_find_empty_block_l1:  
1967   0B48 22 01         mov ah, $01                  ; 1 sector
1968   0B4A 3B DB 22      mov d, transient_area - 512
1969   0B4D 07 22 05      call ide_read_sect      ; read sector
1970   0B50 BD 00         cmp byte [d], 0
1971   0B52 C6 5B 0B      je fs_find_empty_block_found_null
1972   0B55 55 20 00      add b, fs_sectors_per_file
1973   0B58 0A 48 0B      jmp fs_find_empty_block_l1
1974   0B5B             fs_find_empty_block_found_null:
1975   0B5B 09            ret
1976   0B5C             
1977   0B5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1978   0B5C             ;; create new textfile
1979   0B5C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1980   0B5C             ; search for first null block
1981   0B5C             fs_mktxt:
1982   0B5C FD 4E       	mov si, d
1983   0B5E FD 4F DB 1C 	mov di, user_data
1984   0B62 38 00 01    	mov c, 256
1985   0B65 04          	load					; load data from user-space
1986   0B66             	
1987   0B66 26 A0 00    	mov b, fs_lba_start		; raw files starting block
1988   0B69 38 00 00    	mov c, 0						; reset lba to 0
1989   0B6C             fs_mktxt_l1:	
1990   0B6C 10 02 01    	mov a, $0102			; disk read
1991   0B6F 3B DB 24    	mov d, transient_area
1992   0B72 05 02       	syscall sys_ide ; read sector
1993   0B74 1E          	mov al, [d]
1994   0B75 B9 00       	cmp al, 0			; check for null
1995   0B77 C6 80 0B    	je fs_mktxt_found_null
1996   0B7A 55 20 00    	add b, fs_sectors_per_file
1997   0B7D 0A 6C 0B    	jmp fs_mktxt_l1
1998   0B80             fs_mktxt_found_null:
1999   0B80 D8          	push b				; save lba
2000   0B81             ;create header file by grabbing file name from parameter	
2001   0B81 3B 9A 17    	mov d, s_dataentry
2002   0B84 07 44 12    	call _puts
2003   0B87 3B DB 26    	mov d, transient_area + 512			; pointer to file contents
2004   0B8A 07 AA 11    	call _gettxt
2005   0B8D 07 77 10    	call _strlen						; get length of file
2006   0B90 D9          	push c							; save length
2007   0B91 19 01       	mov al, 1
2008   0B93 3D DB 24    	mov [transient_area], al					; mark sectors as used (not null)
2009   0B96 10 00 00    	mov a, 0
2010   0B99 42 76 17    	mov [index], a
2011   0B9C 3B DB 24    	mov d, transient_area
2012   0B9F 13          	mov a, d
2013   0BA0 42 78 17    	mov [buffer_addr], a
2014   0BA3             fs_mktxt_l2:
2015   0BA3 38 00 00    	mov c, 0
2016   0BA6 10 03 01    	mov a, $0103			; disk write, 1 sector
2017   0BA9 05 02       	syscall sys_ide		; write sector
2018   0BAB 14 76 17    	mov a, [index]
2019   0BAE 77          	inc a
2020   0BAF 42 76 17    	mov [index], a
2021   0BB2 AF 20 00    	cmp a, fs_sectors_per_file
2022   0BB5 C6 C7 0B    	je fs_mktxt_add_to_dir
2023   0BB8 FD 77       	inc b
2024   0BBA 14 78 17    	mov a, [buffer_addr]
2025   0BBD 53 00 02    	add a, 512
2026   0BC0 42 78 17    	mov [buffer_addr], a
2027   0BC3 3C          	mov d, a
2028   0BC4 0A A3 0B    	jmp fs_mktxt_l2
2029   0BC7             ; now we add the file to the current directory!
2030   0BC7             fs_mktxt_add_to_dir:	
2031   0BC7 14 7E 17    	mov a, [current_dir_id]
2032   0BCA 77          	inc a
2033   0BCB 27          	mov b, a					; metadata sector
2034   0BCC 38 00 00    	mov c, 0
2035   0BCF FD 79       	mov g, b					; save lba
2036   0BD1 3B DB 24    	mov d, transient_area
2037   0BD4 10 02 01    	mov a, $0102			; disk read
2038   0BD7 05 02       	syscall sys_ide		; read metadata sector
2039   0BD9             fs_mktxt_add_to_dir_l2:
2040   0BD9 1E          	mov al, [d]
2041   0BDA B9 00       	cmp al, 0
2042   0BDC C6 E5 0B    	je fs_mktxt_add_to_dir_null
2043   0BDF 58 20 00    	add d, fst_entry_size
2044   0BE2 0A D9 0B    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2045   0BE5             fs_mktxt_add_to_dir_null:
2046   0BE5 FD 4D DB 1C 	mov si, user_data
2047   0BE9 FD 50       	mov di, d
2048   0BEB 07 9C 10    	call _strcpy			; copy file name
2049   0BEE 58 18 00    	add d, 24			; skip name
2050   0BF1 19 06       	mov al, %00000110		; no execute, write, read, not directory
2051   0BF3 3E          	mov [d], al			
2052   0BF4 58 03 00    	add d, 3
2053   0BF7 E4          	pop a
2054   0BF8 43          	mov [d], a
2055   0BF9 63 02 00    	sub d, 2
2056   0BFC E5          	pop b				; get file lba
2057   0BFD FD 43       	mov [d], b			; save lba	
2058   0BFF             	
2059   0BFF             	; set file creation date	
2060   0BFF 58 04 00    	add d, 4
2061   0C02 19 04       	mov al, 4
2062   0C04 05 01       	syscall sys_rtc
2063   0C06 1A          	mov al, ah
2064   0C07 3E          	mov [d], al			; set day
2065   0C08             	
2066   0C08 79          	inc d
2067   0C09 19 05       	mov al, 5
2068   0C0B 05 01       	syscall sys_rtc
2069   0C0D 1A          	mov al, ah
2070   0C0E 3E          	mov [d], al			; set month
2071   0C0F             	
2072   0C0F 79          	inc d
2073   0C10 19 06       	mov al, 6
2074   0C12 05 01       	syscall sys_rtc
2075   0C14 1A          	mov al, ah
2076   0C15 3E          	mov [d], al			; set year
2077   0C16             	
2078   0C16             ; write sector into disk for new directory entry
2079   0C16 FD 27       	mov b, g
2080   0C18 38 00 00    	mov c, 0
2081   0C1B 3B DB 24    	mov d, transient_area
2082   0C1E 10 03 01    	mov a, $0103			; disk write, 1 sector
2083   0C21 05 02       	syscall sys_ide		; write sector
2084   0C23 07 F1 11    	call printnl
2085   0C26 06          	sysret
2086   0C27             
2087   0C27             
2088   0C27             
2089   0C27             ;------------------------------------------------------------------------------------------------------;
2090   0C27             ; create new binary file
2091   0C27             ;------------------------------------------------------------------------------------------------------;
2092   0C27             ; search for first null block
2093   0C27             fs_mkbin:
2094   0C27 19 00         mov al, 0
2095   0C29 3D 6E 17      mov [sys_echo_on], al ; disable echo
2096   0C2C FD 4E         mov si, d
2097   0C2E FD 4F DB 1C   mov di, user_data
2098   0C32 38 00 02      mov c, 512
2099   0C35 04            load                          ; load data from user-space
2100   0C36 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2101   0C39 38 00 00      mov c, 0                      ; upper lba = 0
2102   0C3C             fs_mkbin_l1:  
2103   0C3C 22 01         mov ah, $01                  ; 1 sector
2104   0C3E 3B DB 24      mov d, transient_area
2105   0C41 07 22 05      call ide_read_sect            ; read sector
2106   0C44 BD 00         cmp byte[d], 0                ; check for null
2107   0C46 C6 4F 0C      je fs_mkbin_found_null
2108   0C49 55 20 00      add b, fs_sectors_per_file
2109   0C4C 0A 3C 0C      jmp fs_mkbin_l1
2110   0C4F             fs_mkbin_found_null:
2111   0C4F D8            push b                        ; save lba
2112   0C50             ;create header file by grabbing file name from parameter
2113   0C50 FD 4F DB 26   mov di, transient_area + 512  ; pointer to file contents
2114   0C54 07 CA 0F      call _load_hex                ; load binary hex
2115   0C57 D9            push c                        ; save size (nbr of bytes)
2116   0C58 19 01         mov al, 1
2117   0C5A 3D DB 24      mov [transient_area], al      ; mark sectors as used (not null)
2118   0C5D FD 10         cla
2119   0C5F 42 76 17      mov [index], a
2120   0C62 3B DB 24      mov d, transient_area
2121   0C65 13            mov a, d
2122   0C66 42 78 17      mov [buffer_addr], a
2123   0C69             fs_mkbin_l2:
2124   0C69 38 00 00      mov c, 0
2125   0C6C 22 01         mov ah, $01                   ; disk write, 1 sector
2126   0C6E 07 48 05      call ide_write_sect           ; write sector
2127   0C71 14 76 17      mov a, [index]
2128   0C74 77            inc a
2129   0C75 42 76 17      mov [index], a
2130   0C78 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2131   0C7B C6 8D 0C      je fs_mkbin_add_to_dir
2132   0C7E FD 77         inc b
2133   0C80 14 78 17      mov a, [buffer_addr]
2134   0C83 53 00 02      add a, 512
2135   0C86 42 78 17      mov [buffer_addr], a
2136   0C89 3C            mov d, a
2137   0C8A 0A 69 0C      jmp fs_mkbin_l2
2138   0C8D             ; now we add the file to the current directory!
2139   0C8D             fs_mkbin_add_to_dir:  
2140   0C8D 14 7E 17      mov a, [current_dir_id]
2141   0C90 77            inc a
2142   0C91 27            mov b, a                      ; metadata sector
2143   0C92 38 00 00      mov c, 0
2144   0C95 FD 79         mov g, b                      ; save lba
2145   0C97 3B DB 24      mov d, transient_area
2146   0C9A 22 01         mov ah, $01                  ; 1 sector
2147   0C9C 07 22 05      call ide_read_sect            ; read metadata sector
2148   0C9F             fs_mkbin_add_to_dir_l2:
2149   0C9F BD 00         cmp byte[d], 0
2150   0CA1 C6 AA 0C      je fs_mkbin_add_to_dir_null
2151   0CA4 58 20 00      add d, fst_entry_size
2152   0CA7 0A 9F 0C      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2153   0CAA             fs_mkbin_add_to_dir_null:
2154   0CAA FD 4D DB 1C   mov si, user_data
2155   0CAE FD 50         mov di, d
2156   0CB0 07 9C 10      call _strcpy                  ; copy file name
2157   0CB3 58 18 00      add d, 24                     ; skip name
2158   0CB6 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2159   0CB8 3E            mov [d], al
2160   0CB9 58 03 00      add d, 3
2161   0CBC E4            pop a
2162   0CBD 43            mov [d], a
2163   0CBE 63 02 00      sub d, 2
2164   0CC1 E5            pop b                         ; get file lba
2165   0CC2 FD 43         mov [d], b                    ; save lba
2166   0CC4               ; set file creation date  
2167   0CC4 58 04 00      add d, 4
2168   0CC7 19 04         mov al, 4
2169   0CC9 05 01         syscall sys_rtc
2170   0CCB 1A            mov al, ah
2171   0CCC 3E            mov [d], al                   ; set day
2172   0CCD 79            inc d
2173   0CCE 19 05         mov al, 5
2174   0CD0 05 01         syscall sys_rtc
2175   0CD2 1A            mov al, ah
2176   0CD3 3E            mov [d], al                   ; set month
2177   0CD4 79            inc d
2178   0CD5 19 06         mov al, 6
2179   0CD7 05 01         syscall sys_rtc
2180   0CD9 1A            mov al, ah
2181   0CDA 3E            mov [d], al                   ; set year
2182   0CDB             ; write sector into disk for new directory entry
2183   0CDB FD 27         mov b, g
2184   0CDD 38 00 00      mov c, 0
2185   0CE0 3B DB 24      mov d, transient_area
2186   0CE3 22 01         mov ah, $01                   ; disk write, 1 sector
2187   0CE5 07 48 05      call ide_write_sect           ; write sector
2188   0CE8 19 01         mov al, 1
2189   0CEA 3D 6E 17      mov [sys_echo_on], al ; enable echo
2190   0CED 06            sysret
2191   0CEE             
2192   0CEE             ;------------------------------------------------------------------------------------------------------;
2193   0CEE             ; pwd - print working directory
2194   0CEE             ;------------------------------------------------------------------------------------------------------;    
2195   0CEE             fs_pwd:
2196   0CEE 3B 5B 1C      mov d, filename
2197   0CF1 19 00         mov al, 0
2198   0CF3 3E            mov [d], al                   ; initialize path string 
2199   0CF4 14 7E 17      mov a, [current_dir_id]
2200   0CF7 07 58 08      call fs_dir_id_to_path_e0
2201   0CFA 3B 5B 1C      mov d, filename
2202   0CFD 07 30 10      call _strrev
2203   0D00 07 44 12      call _puts
2204   0D03 07 F1 11      call printnl
2205   0D06 06            sysret
2206   0D07             
2207   0D07             ;------------------------------------------------------------------------------------------------------;
2208   0D07             ; get current directory lba
2209   0D07             ; a: returned lba
2210   0D07             ;------------------------------------------------------------------------------------------------------;
2211   0D07             cmd_get_curr_dir_lba:
2212   0D07 14 7E 17      mov a, [current_dir_id]
2213   0D0A 06            sysret
2214   0D0B             
2215   0D0B             ;------------------------------------------------------------------------------------------------------;
2216   0D0B             ; cat
2217   0D0B             ; userspace destination data pointer in d
2218   0D0B             ; filename starts at d, but is overwritten after the read is made
2219   0D0B             ;------------------------------------------------------------------------------------------------------;:
2220   0D0B             fs_cat:
2221   0D0B DA            push d                              ; save userspace file data destination
2222   0D0C FD 4E         mov si, d
2223   0D0E FD 4F DB 1C   mov di, user_data
2224   0D12 38 00 02      mov c, 512
2225   0D15 04            load                                ; copy filename from user-space
2226   0D16 29 7E 17      mov b, [current_dir_id]
2227   0D19 FD 77         inc b                               ; metadata sector
2228   0D1B 38 00 00      mov c, 0                            ; upper lba = 0
2229   0D1E 22 01         mov ah, $01                  ; 1 sector
2230   0D20 3B DB 22      mov d, transient_area-512
2231   0D23 07 22 05      call ide_read_sect                  ; read directory
2232   0D26 FD 10         cla
2233   0D28 42 76 17      mov [index], a                      ; reset file counter
2234   0D2B             fs_cat_l1:
2235   0D2B FD 4E         mov si, d
2236   0D2D FD 4F DB 1C   mov di, user_data
2237   0D31 07 87 10      call _strcmp
2238   0D34 C6 4A 0D      je fs_cat_found_entry
2239   0D37 58 20 00      add d, 32
2240   0D3A 14 76 17      mov a, [index]
2241   0D3D 77            inc a
2242   0D3E 42 76 17      mov [index], a
2243   0D41 AF 10 00      cmp a, fst_files_per_dir
2244   0D44 C6 65 0D      je fs_cat_not_found
2245   0D47 0A 2B 0D      jmp fs_cat_l1
2246   0D4A             fs_cat_found_entry:
2247   0D4A 58 19 00      add d, 25                           ; get to dirid of file in disk
2248   0D4D 2A            mov b, [d]                          ; get lba
2249   0D4E FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2250   0D50 3B DB 24      mov d, transient_area  
2251   0D53 38 00 00      mov c, 0
2252   0D56 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2253   0D58 07 22 05      call ide_read_sect                  ; read sectors
2254   0D5B F0            pop di                              ; write userspace file data destination to di
2255   0D5C FD 4D DB 24   mov si, transient_area              ; data origin
2256   0D60 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2257   0D63 03            store
2258   0D64 06            sysret
2259   0D65             fs_cat_not_found:
2260   0D65 E7            pop d
2261   0D66 06            sysret
2262   0D67             
2263   0D67             ;------------------------------------------------------------------------------------------------------;
2264   0D67             ; rmdir - remove dir by dirid
2265   0D67             ;------------------------------------------------------------------------------------------------------;
2266   0D67             ; deletes a directory entry in the given directory's file list 
2267   0D67             ; also deletes the actual directory entry in the fst
2268   0D67             ; synopsis: rmdir /usr/local/testdir
2269   0D67             ; b = dirid
2270   0D67             fs_rmdir:
2271   0D67 FD 79         mov g, b
2272   0D69 11            mov a, b
2273   0D6A 07 94 08      call get_parentid_from_dirid  ; now get the directory's parent, in a
2274   0D6D D7            push a                        ; save dirid
2275   0D6E             ; search for directory's entry in the parent's directory then and delete it
2276   0D6E 77            inc a                         ; metadata sector
2277   0D6F 27            mov b, a
2278   0D70 38 00 00      mov c, 0                      ; upper lba = 0
2279   0D73 22 01         mov ah, $01          ;
2280   0D75 3B DB 24      mov d, transient_area
2281   0D78 07 22 05      call ide_read_sect            ; read directory
2282   0D7B FD 10         cla
2283   0D7D 42 76 17      mov [index], a                ; reset file counter
2284   0D80 FD 27         mov b, g                      ; retrieve directory's dirid
2285   0D82             fs_rmdir_l1:
2286   0D82 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2287   0D85 B0            cmp a, b                      ; compare dirid's to find the directory
2288   0D86 C6 9C 0D      je fs_rmdir_found_entry
2289   0D89 58 20 00      add d, 32
2290   0D8C 14 76 17      mov a, [index]
2291   0D8F 77            inc a
2292   0D90 42 76 17      mov [index], a
2293   0D93 AF 10 00      cmp a, fst_files_per_dir
2294   0D96 C6 C1 0D      je fs_rmdir_not_found
2295   0D99 0A 82 0D      jmp fs_rmdir_l1
2296   0D9C             fs_rmdir_found_entry:
2297   0D9C FD 10         cla
2298   0D9E 3E            mov [d], al                   ; make filename null
2299   0D9F 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2300   0DA2 E5            pop b
2301   0DA3 FD 77         inc b                         ; metadata sector
2302   0DA5 38 00 00      mov c, 0                      ; upper lba = 0
2303   0DA8 22 01         mov ah, $01          ; 
2304   0DAA 3B DB 24      mov d, transient_area
2305   0DAD 07 48 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2306   0DB0             
2307   0DB0 FD 27         mov b, g
2308   0DB2 3B DB 24      mov d, transient_area  
2309   0DB5 FD 10         cla
2310   0DB7 3E            mov [d], al                   ; make directory's name header null for re-use
2311   0DB8 38 00 00      mov c, 0
2312   0DBB 22 01         mov ah, $01                   ; disk write 1 sect
2313   0DBD 07 48 05      call ide_write_sect           ; delete directory given by dirid in b
2314   0DC0 06            sysret
2315   0DC1             fs_rmdir_not_found:
2316   0DC1 E5            pop b
2317   0DC2 06            sysret
2318   0DC3             
2319   0DC3             ;------------------------------------------------------------------------------------------------------;
2320   0DC3             ; rm - remove file
2321   0DC3             ;------------------------------------------------------------------------------------------------------;
2322   0DC3             ; frees up the data sectors for the file further down the disk
2323   0DC3             ; deletes file entry in the directory's file list 
2324   0DC3             fs_rm:
2325   0DC3 FD 4E         mov si, d
2326   0DC5 FD 4F DB 1C   mov di, user_data
2327   0DC9 38 00 02      mov c, 512
2328   0DCC 04            load                          ; load data from user-space
2329   0DCD 14 7E 17      mov a, [current_dir_id]
2330   0DD0 77            inc a                         ; metadata sector
2331   0DD1 27            mov b, a
2332   0DD2 38 00 00      mov c, 0                      ; upper lba = 0
2333   0DD5 22 01         mov ah, $01                  ; 1 sector
2334   0DD7 3B DB 24      mov d, transient_area
2335   0DDA 07 22 05      call ide_read_sect            ; read directory
2336   0DDD 10 00 00      mov a, 0
2337   0DE0 42 76 17      mov [index], a                ; reset file counter
2338   0DE3             fs_rm_l1:
2339   0DE3 FD 4E         mov si, d
2340   0DE5 FD 4F DB 1C   mov di, user_data
2341   0DE9 07 87 10      call _strcmp
2342   0DEC C6 02 0E      je fs_rm_found_entry
2343   0DEF 58 20 00      add d, 32
2344   0DF2 14 76 17      mov a, [index]
2345   0DF5 77            inc a
2346   0DF6 42 76 17      mov [index], a
2347   0DF9 AF 10 00      cmp a, fst_files_per_dir
2348   0DFC C6 2A 0E      je fs_rm_not_found
2349   0DFF 0A E3 0D      jmp fs_rm_l1
2350   0E02             fs_rm_found_entry:
2351   0E02 2B 19 00      mov b, [d + 25]               ; get lba
2352   0E05 FD 79         mov g, b                      ; save lba
2353   0E07 19 00         mov al, 0
2354   0E09 3E            mov [d], al                   ; make file entry null
2355   0E0A 14 7E 17      mov a, [current_dir_id]
2356   0E0D 77            inc a                         ; metadata sector
2357   0E0E 27            mov b, a
2358   0E0F 38 00 00      mov c, 0                      ; upper lba = 0
2359   0E12 22 01         mov ah, $01                   ; disk write
2360   0E14 3B DB 24      mov d, transient_area
2361   0E17 07 48 05      call ide_write_sect           ; write sector and erase file's entry in the current dir
2362   0E1A 3B DB 24      mov d, transient_area  
2363   0E1D 19 00         mov al, 0
2364   0E1F 3E            mov [d], al                   ; make file's data header null for re-use
2365   0E20 38 00 00      mov c, 0
2366   0E23 FD 27         mov b, g                      ; get data header lba
2367   0E25 22 01         mov ah, $01                   ; disk write 1 sect
2368   0E27 07 48 05      call ide_write_sect           ; write sector
2369   0E2A             fs_rm_not_found:  
2370   0E2A 06            sysret  
2371   0E2B             
2372   0E2B             ;------------------------------------------------------------------------------------------------------;
2373   0E2B             ; mv - move / change file name
2374   0E2B             ;------------------------------------------------------------------------------------------------------;
2375   0E2B             fs_mv:
2376   0E2B FD 4E         mov si, d
2377   0E2D FD 4F DB 1C   mov di, user_data
2378   0E31 38 00 02      mov c, 512
2379   0E34 04            load                          ; load data from user-space
2380   0E35 14 7E 17      mov a, [current_dir_id]
2381   0E38 77            inc a                         ; metadata sector
2382   0E39 27            mov b, a  
2383   0E3A 38 00 00      mov c, 0                      ; upper lba = 0
2384   0E3D 22 01         mov ah, $01                  ; 1 sector
2385   0E3F 3B DB 24      mov d, transient_area
2386   0E42 07 22 05      call ide_read_sect            ; read directory
2387   0E45 FD 10         cla
2388   0E47 42 76 17      mov [index], a                ; reset file counter
2389   0E4A             fs_mv_l1:
2390   0E4A FD 4E         mov si, d
2391   0E4C FD 4F DB 1C   mov di, user_data
2392   0E50 07 87 10      call _strcmp
2393   0E53 C6 69 0E      je fs_mv_found_entry
2394   0E56 58 20 00      add d, 32
2395   0E59 14 76 17      mov a, [index]
2396   0E5C 77            inc a
2397   0E5D 42 76 17      mov [index], a
2398   0E60 AF 10 00      cmp a, fst_files_per_dir
2399   0E63 C6 9B 0E      je fs_mv_not_found
2400   0E66 0A 4A 0E      jmp fs_mv_l1
2401   0E69             fs_mv_found_entry:  
2402   0E69 DA            push d
2403   0E6A FD 4D 5B 1D   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2404   0E6E FD 50         mov di, d
2405   0E70 07 9C 10      call _strcpy  
2406   0E73 38 00 00      mov c, 0
2407   0E76 3B DB 24      mov d, transient_area
2408   0E79 22 01         mov ah, $01                   ; disk write 1 sect
2409   0E7B 07 48 05      call ide_write_sect           ; write sector
2410   0E7E E7            pop d
2411   0E7F             ;; need to check whether its a dir or a file here ;;;
2412   0E7F 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2413   0E82 22 01         mov ah, $01
2414   0E84 3B DB 24      mov d, transient_area
2415   0E87 38 00 00      mov c, 0
2416   0E8A 07 22 05      call ide_read_sect            ; read directory entry
2417   0E8D FD 4D 5B 1D   mov si, user_data + 128
2418   0E91 FD 50         mov di, d
2419   0E93 07 9C 10      call _strcpy                  ; change directory's name
2420   0E96 22 01         mov ah, $01
2421   0E98 07 48 05      call ide_write_sect           ; rewrite directory back to disk
2422   0E9B             fs_mv_not_found:
2423   0E9B 06            sysret
2424   0E9C             
2425   0E9C             
2426   0E9C             ;----------------------------------------------------------------------------------------------------;
2427   0E9C             ; process index in a
2428   0E9C             ;----------------------------------------------------------------------------------------------------;
2429   0E9C             find_free_proc:
2430   0E9C FD 4D 4C 1A   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2431   0EA0             find_free_proc_l0:
2432   0EA0 F6            lodsb                               ; get process state
2433   0EA1 B9 00         cmp al, 0
2434   0EA3 C6 A9 0E      je find_free_proc_free              ; if free, jump
2435   0EA6 0A A0 0E      jmp find_free_proc_l0               ; else, goto next
2436   0EA9             find_free_proc_free:
2437   0EA9 4E            mov a, si
2438   0EAA 5F 4C 1A      sub a, 1 + proc_availab_table       ; get process index
2439   0EAD 09            ret
2440   0EAE               
2441   0EAE             
2442   0EAE             ;----------------------------------------------------------------------------------------------------;
2443   0EAE             ; process index in al
2444   0EAE             ;----------------------------------------------------------------------------------------------------;
2445   0EAE             proc_memory_map:
2446   0EAE 22 00         mov ah, 0
2447   0EB0 27            mov b, a                      ; page in bl, 0 in bh
2448   0EB1 FD 9D 05      shl a, 5                      ; multiply by 32
2449   0EB4 39            mov c, a                      ; save in c
2450   0EB5 57 20 00      add c, 32
2451   0EB8             proc_memory_map_l0:
2452   0EB8 02            pagemap
2453   0EB9 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2454   0EBC 53 01 00      add a, 1                      ; increase both 
2455   0EBF B1            cmp a, c                      ; check to see if we reached the end of memory
2456   0EC0 C7 B8 0E      jne proc_memory_map_l0
2457   0EC3 09            ret
2458   0EC4               
2459   0EC4             
2460   0EC4             ;----------------------------------------------------------------------------------------------------;
2461   0EC4             ; terminate process
2462   0EC4             ;----------------------------------------------------------------------------------------------------;
2463   0EC4             syscall_terminate_proc:
2464   0EC4 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2465   0EC7                                                    ; since they will not be used for anything here.
2466   0EC7 1D 75 17      mov al, [active_proc_index]
2467   0ECA 22 00         mov ah, 0  
2468   0ECC FD 9D 05      shl a, 5                             ; x32
2469   0ECF 53 5B 1A      add a, proc_names
2470   0ED2 3C            mov d, a
2471   0ED3 19 00         mov al, 0
2472   0ED5 3E            mov [d], al                           ; nullify process name
2473   0ED6             
2474   0ED6 1D 75 17      mov al, [active_proc_index]
2475   0ED9 22 00         mov ah, 0  
2476   0EDB 3C            mov d, a
2477   0EDC 19 00         mov al, 0
2478   0EDE 3F 4B 1A      mov [d + proc_availab_table], al    ; make process empty again
2479   0EE1               
2480   0EE1 1D 74 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2481   0EE4 80            dec al
2482   0EE5 3D 74 17      mov [nbr_active_procs], al
2483   0EE8             
2484   0EE8             ; now load the shell process again
2485   0EE8 19 02         mov al, 2                           ; next process = process 2 = shell
2486   0EEA 3D 75 17      mov [active_proc_index], al         ; set next active proc
2487   0EED             
2488   0EED             ; calculate lut entry for next process
2489   0EED 22 00         mov ah, 0
2490   0EEF FD 99         shl a                               ; x2
2491   0EF1 B7 BA 0F      mov a, [proc_table_convert + a]     ; get process state start index  
2492   0EF4               
2493   0EF4 4D            mov si, a                           ; source is proc state block
2494   0EF5 48            mov a, sp
2495   0EF6 5F 13 00      sub a, 19
2496   0EF9 4F            mov di, a                           ; destination is kernel stack
2497   0EFA             ; restore sp
2498   0EFA 7D            dec a
2499   0EFB 47            mov sp, a
2500   0EFC 38 14 00      mov c, 20
2501   0EFF FD F5         rep movsb
2502   0F01             ; set vm process
2503   0F01 1D 75 17      mov al, [active_proc_index]
2504   0F04 01            setptb
2505   0F05                 
2506   0F05 4C            popa
2507   0F06 06            sysret
2508   0F07             
2509   0F07             ;----------------------------------------------------------------------------------------------------;
2510   0F07             ; pause process
2511   0F07             ;----------------------------------------------------------------------------------------------------;
2512   0F07             syscall_pause_proc:
2513   0F07             ; save all registers into kernel stack
2514   0F07 4B            pusha
2515   0F08 22 00         mov ah, 0
2516   0F0A 1D 75 17      mov al, [active_proc_index]
2517   0F0D FD 99         shl a              ; x2
2518   0F0F B7 BA 0F      mov a, [proc_table_convert + a]   ; get process state start index
2519   0F12                 
2520   0F12 4F            mov di, a
2521   0F13 48            mov a, sp
2522   0F14 77            inc a
2523   0F15 4D            mov si, a
2524   0F16 38 14 00      mov c, 20
2525   0F19 FD F5         rep movsb                         ; save process state!
2526   0F1B             ; restore kernel stack position to point before interrupt arrived
2527   0F1B 51 14 00      add sp, 20
2528   0F1E             ; now load the shell process again
2529   0F1E 19 02         mov al, 2                         ; next process = process 2 = shell
2530   0F20 3D 75 17      mov [active_proc_index], al       ; set next active proc
2531   0F23             
2532   0F23             ; calculate lut entry for next process
2533   0F23 22 00         mov ah, 0
2534   0F25 FD 99         shl a                             ; x2
2535   0F27 B7 BA 0F      mov a, [proc_table_convert + a]   ; get process state start index  
2536   0F2A               
2537   0F2A 4D            mov si, a                         ; source is proc state block
2538   0F2B 48            mov a, sp
2539   0F2C 5F 13 00      sub a, 19
2540   0F2F 4F            mov di, a                         ; destination is kernel stack
2541   0F30             ; restore sp
2542   0F30 7D            dec a
2543   0F31 47            mov sp, a
2544   0F32 38 14 00      mov c, 20
2545   0F35 FD F5         rep movsb
2546   0F37             ; set vm process
2547   0F37 1D 75 17      mov al, [active_proc_index]
2548   0F3A 01            setptb
2549   0F3B                 
2550   0F3B 4C            popa
2551   0F3C 06            sysret
2552   0F3D             
2553   0F3D             ;----------------------------------------------------------------------------------------------------;
2554   0F3D             ; create a new process
2555   0F3D             ; d = path of the process file to be createed
2556   0F3D             ; b = arguments ptr
2557   0F3D             ;----------------------------------------------------------------------------------------------------;
2558   0F3D             syscall_create_proc:
2559   0F3D             ; we save the active process first  
2560   0F3D 4B            pusha
2561   0F3E 22 00         mov ah, 0
2562   0F40 1D 75 17      mov al, [active_proc_index]
2563   0F43 FD 99         shl a              ; x2
2564   0F45 B7 BA 0F      mov a, [proc_table_convert + a]    ; get process state table's start index
2565   0F48               
2566   0F48 4F            mov di, a
2567   0F49 48            mov a, sp
2568   0F4A 77            inc a
2569   0F4B 4D            mov si, a
2570   0F4C 38 14 00      mov c, 20
2571   0F4F FD F5         rep movsb                          ; save process state!
2572   0F51             ; restore kernel stack position to point before interrupt arrived
2573   0F51 51 14 00      add sp, 20
2574   0F54               
2575   0F54 FD 4E         mov si, d                          ; copy the file path
2576   0F56 FD 4F DB 1C   mov di, user_data
2577   0F5A 38 00 02      mov c, 512
2578   0F5D 04            load
2579   0F5E 11            mov a, b
2580   0F5F 4D            mov si, a                          ; copy the arguments
2581   0F60 FD 4F DB 22   mov di, scrap_sector
2582   0F64 38 00 02      mov c, 512
2583   0F67 04            load
2584   0F68 07 DA 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2585   0F6B                                                  ; the file data is loaded into transient_area
2586   0F6B             ; now we allocate a new process  
2587   0F6B 07 9C 0E      call find_free_proc                ; index in a
2588   0F6E 01            setptb 
2589   0F6F 07 AE 0E      call proc_memory_map               ; map process memory pages
2590   0F72             ; copy arguments into process's memory
2591   0F72 FD 4D DB 22   mov si, scrap_sector
2592   0F76 FD 4F 00 00   mov di, 0
2593   0F7A 38 00 02      mov c, 512
2594   0F7D 03            store
2595   0F7E             ; now copy process binary data into process's memory
2596   0F7E FD 4D DB 24   mov si, transient_area
2597   0F82 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2598   0F86 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2599   0F89 03            store                              ; copy process data
2600   0F8A                 
2601   0F8A 07 9C 0E      call find_free_proc                ; index in a
2602   0F8D 3D 75 17      mov [active_proc_index], al        ; set new active process
2603   0F90 FD 9D 05      shl a, 5                           ; x32
2604   0F93 53 5B 1A      add a, proc_names
2605   0F96 4F            mov di, a
2606   0F97 FD 4D DB 1C   mov si, user_data                  ; copy and store process filename
2607   0F9B 07 9C 10      call _strcpy
2608   0F9E               
2609   0F9E 07 9C 0E      call find_free_proc                ; index in a
2610   0FA1 3C            mov d, a
2611   0FA2 19 01         mov al, 1
2612   0FA4 3F 4B 1A      mov [d + proc_availab_table], al   ; make process busy
2613   0FA7               
2614   0FA7 1D 74 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2615   0FAA 7A            inc al
2616   0FAB 3D 74 17      mov [nbr_active_procs], al
2617   0FAE             ; launch process
2618   0FAE FD D7 FF FF   push word $ffff 
2619   0FB2 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2620   0FB5 FD D7 00 04   push word text_org
2621   0FB9 06            sysret
2622   0FBA             
2623   0FBA             proc_table_convert:
2624   0FBA 0B 19         .dw proc_state_table + 0
2625   0FBC 1F 19         .dw proc_state_table + 20
2626   0FBE 33 19         .dw proc_state_table + 40
2627   0FC0 47 19         .dw proc_state_table + 60
2628   0FC2 5B 19         .dw proc_state_table + 80
2629   0FC4 6F 19         .dw proc_state_table + 100
2630   0FC6 83 19         .dw proc_state_table + 120
2631   0FC8 97 19         .dw proc_state_table + 140
2632   0FCA               
2633   0FCA             ;----------------------------------------------------------------------------------------------;
2634   0FCA             ; get hex file
2635   0FCA             ; di = destination address
2636   0FCA             ; return length in bytes in c
2637   0FCA             ;----------------------------------------------------------------------------------------------;
2638   0FCA             _load_hex:
2639   0FCA D7            push a
2640   0FCB D8            push b
2641   0FCC DA            push d
2642   0FCD E2            push si
2643   0FCE E3            push di
2644   0FCF 38 00 00      mov c, 0
2645   0FD2 50            mov a, di
2646   0FD3 3C            mov d, a          ; start of string data block
2647   0FD4 07 1F 11      call _gets        ; get program string
2648   0FD7 4D            mov si, a
2649   0FD8             __load_hex_loop:
2650   0FD8 F6            lodsb             ; load from [si] to al
2651   0FD9 B9 00         cmp al, 0         ; check if ascii 0
2652   0FDB C6 E9 0F      jz __load_hex_ret
2653   0FDE 36            mov bh, al
2654   0FDF F6            lodsb
2655   0FE0 2F            mov bl, al
2656   0FE1 07 D5 10      call _atoi        ; convert ascii byte in b to int (to al)
2657   0FE4 F7            stosb             ; store al to [di]
2658   0FE5 78            inc c
2659   0FE6 0A D8 0F      jmp __load_hex_loop
2660   0FE9             __load_hex_ret:
2661   0FE9 F0            pop di
2662   0FEA EF            pop si
2663   0FEB E7            pop d
2664   0FEC E5            pop b
2665   0FED E4            pop a
2666   0FEE 09            ret
2667   0FEF             
2668   0FEF             ; synopsis: look inside a certain directory for files/directories
2669   0FEF             ; before calling this function, cd into required directory
2670   0FEF             ; for each entry inside directory:
2671   0FEF             ;  if entry is a file:
2672   0FEF             ;    compare filename to searched filename
2673   0FEF             ;    if filenames are the same, print filename
2674   0FEF             ;  else if entry is a directory:
2675   0FEF             ;    cd to the given directory
2676   0FEF             ;    recursively call cmd_find
2677   0FEF             ;    cd outside previous directory
2678   0FEF             ;  if current entry == last entry, return
2679   0FEF             ; endfor
2680   0FEF             f_find:
2681   0FEF 09            ret
2682   0FF0             
2683   0FF0             
2684   0FF0             ; ---------------------------------------------------------------------
2685   0FF0             ; kernel reset vector
2686   0FF0             ; ---------------------------------------------------------------------
2687   0FF0             kernel_reset_vector:  
2688   0FF0 FD 49 FF F7   mov bp, stack_begin
2689   0FF4 FD 47 FF F7   mov sp, stack_begin
2690   0FF8               
2691   0FF8 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2692   0FFA FD 0F         stomsk                        
2693   0FFC FD 0C         sti  
2694   0FFE             
2695   0FFE 0C            lodstat
2696   0FFF 87 DF         and al, %11011111             ; disable display register loading
2697   1001 0D            stostat
2698   1002               
2699   1002             ; reset fifo pointers
2700   1002 10 DB 1E      mov a, fifo
2701   1005 3B 7A 17      mov d, fifo_in
2702   1008 43            mov [d], a
2703   1009 3B 7C 17      mov d, fifo_out
2704   100C 43            mov [d], a  
2705   100D 19 02         mov al, 2
2706   100F 05 03         syscall sys_io                ; enable uart in interrupt mode
2707   1011             
2708   1011 3B C9 18      mov d, s_fdc_config
2709   1014 07 44 12      call _puts
2710   1017 F2 C0 FF 1E   mov byte [_fdc_config], %00011110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2711   101B               
2712   101B 3B CF 17      mov d, s_kernel_started
2713   101E 07 44 12      call _puts
2714   1021             
2715   1021 19 10         mov al, 16
2716   1023 05 04         syscall sys_filesystem        ; set root dirid
2717   1025             
2718   1025 3B EC 17      mov d, s_prompt_init
2719   1028 07 44 12      call _puts
2720   102B 3B 80 17      mov d, s_init_path
2721   102E 05 05         syscall sys_create_proc       ; launch init as a new process
2722   1030             
2723   1030             
2724   1030             ; file includes
2725   1030             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  1030             boot_origin      .EQU  $8004
0002+  1030             bios_uart        .EQU  $0002
0003+  1030             bios_ide         .EQU  $0003
0004+  1030             bios_reset_vector .EQU  $01c0
0005+  1030             ide_buffer       .EQU  $8204
2726   1030             .include "lib/stdio.asm"
0001+  1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1030             ; stdio.s
0003+  1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1030             .include "lib/string.asm"
0001++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 1030             ; string.s
0003++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 1030             
0005++ 1030             
0006++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 1030             ; _strrev
0008++ 1030             ; reverse a string
0009++ 1030             ; d = string address
0010++ 1030             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 1030             ; 01234
0012++ 1030             _strrev:
0013++ 1030 4B          	pusha
0014++ 1031 07 77 10    	call _strlen	; length in c
0015++ 1034 12          	mov a, c
0016++ 1035 AF 01 00    	cmp a, 1
0017++ 1038 D0 52 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 103B 7D          	dec a
0019++ 103C FD 4E       	mov si, d	; beginning of string
0020++ 103E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1040 59          	add d, a	; end of string
0022++ 1041 12          	mov a, c
0023++ 1042 FD 9B       	shr a		; divide by 2
0024++ 1044 39          	mov c, a	; c now counts the steps
0025++ 1045             _strrev_l0:
0026++ 1045 32          	mov bl, [d]	; save load right-side char into bl
0027++ 1046 F6          	lodsb		; load left-side char into al; increase si
0028++ 1047 3E          	mov [d], al	; store left char into right side
0029++ 1048 1B          	mov al, bl
0030++ 1049 F7          	stosb		; store right-side char into left-side; increase di
0031++ 104A 7E          	dec c
0032++ 104B 7F          	dec d
0033++ 104C C2 00 00    	cmp c, 0
0034++ 104F C7 45 10    	jne _strrev_l0
0035++ 1052             _strrev_end:
0036++ 1052 4C          	popa
0037++ 1053 09          	ret
0038++ 1054             	
0039++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 1054             ; _strchr
0041++ 1054             ; search string in d for char in al
0042++ 1054             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 1054             _strchr:
0044++ 1054             _strchr_l0:
0045++ 1054 32          	mov bl, [d]
0046++ 1055 C1 00       	cmp bl, 0
0047++ 1057 C6 62 10    	je _strchr_end
0048++ 105A BA          	cmp al, bl
0049++ 105B C6 62 10    	je _strchr_end
0050++ 105E 79          	inc d
0051++ 105F 0A 54 10    	jmp _strchr_l0
0052++ 1062             _strchr_end:
0053++ 1062 1B          	mov al, bl
0054++ 1063 09          	ret
0055++ 1064             
0056++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1064             ; _strstr
0058++ 1064             ; find sub-string
0059++ 1064             ; str1 in si
0060++ 1064             ; str2 in di
0061++ 1064             ; si points to end of source string
0062++ 1064             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1064             _strstr:
0064++ 1064 DB          	push al
0065++ 1065 DA          	push d
0066++ 1066 E3          	push di
0067++ 1067             _strstr_loop:
0068++ 1067 F3          	cmpsb					; compare a byte of the strings
0069++ 1068 C7 73 10    	jne _strstr_ret
0070++ 106B FC 00 00    	lea d, [di + 0]
0071++ 106E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1070 C7 67 10    	jne _strstr_loop				; equal chars but not at end
0073++ 1073             _strstr_ret:
0074++ 1073 F0          	pop di
0075++ 1074 E7          	pop d
0076++ 1075 E8          	pop al
0077++ 1076 09          	ret
0078++ 1077             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1077             ; length of null terminated string
0080++ 1077             ; result in c
0081++ 1077             ; pointer in d
0082++ 1077             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1077             _strlen:
0084++ 1077 DA          	push d
0085++ 1078 38 00 00    	mov c, 0
0086++ 107B             _strlen_l1:
0087++ 107B BD 00       	cmp byte [d], 0
0088++ 107D C6 85 10    	je _strlen_ret
0089++ 1080 79          	inc d
0090++ 1081 78          	inc c
0091++ 1082 0A 7B 10    	jmp _strlen_l1
0092++ 1085             _strlen_ret:
0093++ 1085 E7          	pop d
0094++ 1086 09          	ret
0095++ 1087             
0096++ 1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1087             ; strcmp
0098++ 1087             ; compare two strings
0099++ 1087             ; str1 in si
0100++ 1087             ; str2 in di
0101++ 1087             ; create a string compairon instrucion ?????
0102++ 1087             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1087             _strcmp:
0104++ 1087 DB          	push al
0105++ 1088 DA          	push d
0106++ 1089 E3          	push di
0107++ 108A E2          	push si
0108++ 108B             _strcmp_loop:
0109++ 108B F3          	cmpsb					; compare a byte of the strings
0110++ 108C C7 97 10    	jne _strcmp_ret
0111++ 108F FB FF FF    	lea d, [si +- 1]
0112++ 1092 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1094 C7 8B 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 1097             _strcmp_ret:
0115++ 1097 EF          	pop si
0116++ 1098 F0          	pop di
0117++ 1099 E7          	pop d
0118++ 109A E8          	pop al
0119++ 109B 09          	ret
0120++ 109C             
0121++ 109C             
0122++ 109C             ; strcpy
0123++ 109C             ; copy null terminated string from si to di
0124++ 109C             ; source in si
0125++ 109C             ; destination in di
0126++ 109C             _strcpy:
0127++ 109C E2          	push si
0128++ 109D E3          	push di
0129++ 109E DB          	push al
0130++ 109F             _strcpy_l1:
0131++ 109F F6          	lodsb
0132++ 10A0 F7          	stosb
0133++ 10A1 B9 00       	cmp al, 0
0134++ 10A3 C7 9F 10    	jne _strcpy_l1
0135++ 10A6             _strcpy_end:
0136++ 10A6 E8          	pop al
0137++ 10A7 F0          	pop di
0138++ 10A8 EF          	pop si
0139++ 10A9 09          	ret
0140++ 10AA             
0141++ 10AA             ; strcat
0142++ 10AA             ; concatenate a null terminated string into string at di, from string at si
0143++ 10AA             ; source in si
0144++ 10AA             ; destination in di
0145++ 10AA             _strcat:
0146++ 10AA E2          	push si
0147++ 10AB E3          	push di
0148++ 10AC D7          	push a
0149++ 10AD DA          	push d
0150++ 10AE 50          	mov a, di
0151++ 10AF 3C          	mov d, a
0152++ 10B0             _strcat_goto_end_l1:
0153++ 10B0 BD 00       	cmp byte[d], 0
0154++ 10B2 C6 B9 10    	je _strcat_start
0155++ 10B5 79          	inc d
0156++ 10B6 0A B0 10    	jmp _strcat_goto_end_l1
0157++ 10B9             _strcat_start:
0158++ 10B9 FD 50       	mov di, d
0159++ 10BB             _strcat_l1:
0160++ 10BB F6          	lodsb
0161++ 10BC F7          	stosb
0162++ 10BD B9 00       	cmp al, 0
0163++ 10BF C7 BB 10    	jne _strcat_l1
0164++ 10C2             _strcat_end:
0165++ 10C2 E7          	pop d
0166++ 10C3 E4          	pop a
0167++ 10C4 F0          	pop di
0168++ 10C5 EF          	pop si
0169++ 10C6 09          	ret
0170++ 10C7             
0171++ 10C7             
0005+  10C7             
0006+  10C7             
0007+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  10C7             ; convert ascii 'o'..'f' to integer 0..15
0009+  10C7             ; ascii in bl
0010+  10C7             ; result in al
0011+  10C7             ; ascii for f = 0100 0110
0012+  10C7             ; ascii for 9 = 0011 1001
0013+  10C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  10C7             hex_ascii_encode:
0015+  10C7 1B            mov al, bl
0016+  10C8 93 40         test al, $40        ; test if letter or number
0017+  10CA C7 D0 10      jnz hex_letter
0018+  10CD 87 0F         and al, $0f        ; get number
0019+  10CF 09            ret
0020+  10D0             hex_letter:
0021+  10D0 87 0F         and al, $0f        ; get letter
0022+  10D2 6A 09         add al, 9
0023+  10D4 09            ret
0024+  10D5             
0025+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  10D5             ; atoi
0027+  10D5             ; 2 letter hex string in b
0028+  10D5             ; 8bit integer returned in al
0029+  10D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  10D5             _atoi:
0031+  10D5 D8            push b
0032+  10D6 07 C7 10      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  10D9 30            mov bl, bh
0034+  10DA DB            push al          ; save a
0035+  10DB 07 C7 10      call hex_ascii_encode
0036+  10DE EA            pop bl  
0037+  10DF FD 9E 04      shl al, 4
0038+  10E2 8C            or al, bl
0039+  10E3 E5            pop b
0040+  10E4 09            ret  
0041+  10E5             
0042+  10E5             
0043+  10E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  10E5             ; scanf
0045+  10E5             ; no need for explanations!
0046+  10E5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  10E5             scanf:
0048+  10E5 09            ret
0049+  10E6             
0050+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  10E6             ; itoa
0052+  10E6             ; 8bit value in bl
0053+  10E6             ; 2 byte ascii result in a
0054+  10E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  10E6             _itoa:
0056+  10E6 DA            push d
0057+  10E7 D8            push b
0058+  10E8 A7 00         mov bh, 0
0059+  10EA FD A4 04      shr bl, 4  
0060+  10ED 74            mov d, b
0061+  10EE 1F 80 13      mov al, [d + s_hex_digits]
0062+  10F1 23            mov ah, al
0063+  10F2               
0064+  10F2 E5            pop b
0065+  10F3 D8            push b
0066+  10F4 A7 00         mov bh, 0
0067+  10F6 FD 87 0F      and bl, $0f
0068+  10F9 74            mov d, b
0069+  10FA 1F 80 13      mov al, [d + s_hex_digits]
0070+  10FD E5            pop b
0071+  10FE E7            pop d
0072+  10FF 09            ret
0073+  1100             
0074+  1100             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  1100             ; hex string to binary
0076+  1100             ; di = destination address
0077+  1100             ; si = source
0078+  1100             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  1100             _hex_to_int:
0080+  1100             _hex_to_int_l1:
0081+  1100 F6            lodsb          ; load from [si] to al
0082+  1101 B9 00         cmp al, 0        ; check if ascii 0
0083+  1103 C6 10 11      jz _hex_to_int_ret
0084+  1106 36            mov bh, al
0085+  1107 F6            lodsb
0086+  1108 2F            mov bl, al
0087+  1109 07 D5 10      call _atoi        ; convert ascii byte in b to int (to al)
0088+  110C F7            stosb          ; store al to [di]
0089+  110D 0A 00 11      jmp _hex_to_int_l1
0090+  1110             _hex_to_int_ret:
0091+  1110 09            ret    
0092+  1111             
0093+  1111             
0094+  1111             
0095+  1111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  1111             ; getchar
0097+  1111             ; char in ah
0098+  1111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  1111             getch:
0100+  1111 DB            push al
0101+  1112             getch_retry:
0102+  1112 19 01         mov al, 1
0103+  1114 05 03         syscall sys_io      ; receive in ah
0104+  1116 E8            pop al
0105+  1117 09            ret
0106+  1118             
0107+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1118             ; putchar
0109+  1118             ; char in ah
0110+  1118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1118             _putchar:
0112+  1118 DB            push al
0113+  1119 19 00         mov al, 0
0114+  111B 05 03         syscall sys_io      ; char in ah
0115+  111D E8            pop al
0116+  111E 09            ret
0117+  111F             
0118+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  111F             ;; input a string
0120+  111F             ;; terminates with null
0121+  111F             ;; pointer in d
0122+  111F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  111F             _gets:
0124+  111F D7            push a
0125+  1120 DA            push d
0126+  1121             _gets_loop:
0127+  1121 19 01         mov al, 1
0128+  1123 05 03         syscall sys_io      ; receive in ah
0129+  1125 76 1B         cmp ah, 27
0130+  1127 C6 48 11      je _gets_ansi_esc
0131+  112A 76 0A         cmp ah, $0a        ; lf
0132+  112C C6 A4 11      je _gets_end
0133+  112F 76 0D         cmp ah, $0d        ; cr
0134+  1131 C6 A4 11      je _gets_end
0135+  1134 76 5C         cmp ah, $5c        ; '\\'
0136+  1136 C6 6A 11      je _gets_escape
0137+  1139 76 08         cmp ah, $08      ; check for backspace
0138+  113B C6 44 11      je _gets_backspace
0139+  113E 1A            mov al, ah
0140+  113F 3E            mov [d], al
0141+  1140 79            inc d
0142+  1141 0A 21 11      jmp _gets_loop
0143+  1144             _gets_backspace:
0144+  1144 7F            dec d
0145+  1145 0A 21 11      jmp _gets_loop
0146+  1148             _gets_ansi_esc:
0147+  1148 19 01         mov al, 1
0148+  114A 05 03         syscall sys_io        ; receive in ah without echo
0149+  114C 76 5B         cmp ah, '['
0150+  114E C7 21 11      jne _gets_loop
0151+  1151 19 01         mov al, 1
0152+  1153 05 03         syscall sys_io          ; receive in ah without echo
0153+  1155 76 64         cmp ah, 'd'
0154+  1157 C6 62 11      je _gets_left_arrow
0155+  115A 76 63         cmp ah, 'c'
0156+  115C C6 66 11      je _gets_right_arrow
0157+  115F 0A 21 11      jmp _gets_loop
0158+  1162             _gets_left_arrow:
0159+  1162 7F            dec d
0160+  1163 0A 21 11      jmp _gets_loop
0161+  1166             _gets_right_arrow:
0162+  1166 79            inc d
0163+  1167 0A 21 11      jmp _gets_loop
0164+  116A             _gets_escape:
0165+  116A 19 01         mov al, 1
0166+  116C 05 03         syscall sys_io      ; receive in ah
0167+  116E 76 6E         cmp ah, 'n'
0168+  1170 C6 8F 11      je _gets_lf
0169+  1173 76 72         cmp ah, 'r'
0170+  1175 C6 96 11      je _gets_cr
0171+  1178 76 30         cmp ah, '0'
0172+  117A C6 9D 11      je _gets_null
0173+  117D 76 5C         cmp ah, $5c  ; '\'
0174+  117F C6 88 11      je _gets_slash
0175+  1182 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1183 3E            mov [d], al
0177+  1184 79            inc d
0178+  1185 0A 21 11      jmp _gets_loop
0179+  1188             _gets_slash:
0180+  1188 19 5C         mov al, $5c
0181+  118A 3E            mov [d], al
0182+  118B 79            inc d
0183+  118C 0A 21 11      jmp _gets_loop
0184+  118F             _gets_lf:
0185+  118F 19 0A         mov al, $0a
0186+  1191 3E            mov [d], al
0187+  1192 79            inc d
0188+  1193 0A 21 11      jmp _gets_loop
0189+  1196             _gets_cr:
0190+  1196 19 0D         mov al, $0d
0191+  1198 3E            mov [d], al
0192+  1199 79            inc d
0193+  119A 0A 21 11      jmp _gets_loop
0194+  119D             _gets_null:
0195+  119D 19 00         mov al, $00
0196+  119F 3E            mov [d], al
0197+  11A0 79            inc d
0198+  11A1 0A 21 11      jmp _gets_loop
0199+  11A4             _gets_end:
0200+  11A4 19 00         mov al, 0
0201+  11A6 3E            mov [d], al        ; terminate string
0202+  11A7 E7            pop d
0203+  11A8 E4            pop a
0204+  11A9 09            ret
0205+  11AA             
0206+  11AA             
0207+  11AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11AA             ;; input text
0209+  11AA             ;; terminated with ctrl+d
0210+  11AA             ;; pointer in d
0211+  11AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11AA             _gettxt:
0213+  11AA D7            push a
0214+  11AB DA            push d
0215+  11AC             _gettxt_loop:
0216+  11AC 19 01         mov al, 1
0217+  11AE 05 03         syscall sys_io      ; receive in ah
0218+  11B0 76 04         cmp ah, 4      ; eot
0219+  11B2 C6 EB 11      je _gettxt_end
0220+  11B5 76 08         cmp ah, $08      ; check for backspace
0221+  11B7 C6 E7 11      je _gettxt_backspace
0222+  11BA 76 5C         cmp ah, $5c        ; '\'
0223+  11BC C6 C5 11      je _gettxt_escape
0224+  11BF 1A            mov al, ah
0225+  11C0 3E            mov [d], al
0226+  11C1 79            inc d
0227+  11C2 0A AC 11      jmp _gettxt_loop
0228+  11C5             _gettxt_escape:
0229+  11C5 19 01         mov al, 1
0230+  11C7 05 03         syscall sys_io      ; receive in ah
0231+  11C9 76 6E         cmp ah, 'n'
0232+  11CB C6 D9 11      je _gettxt_lf
0233+  11CE 76 72         cmp ah, 'r'
0234+  11D0 C6 E0 11      je _gettxt_cr
0235+  11D3 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  11D4 3E            mov [d], al
0237+  11D5 79            inc d
0238+  11D6 0A AC 11      jmp _gettxt_loop
0239+  11D9             _gettxt_lf:
0240+  11D9 19 0A         mov al, $0a
0241+  11DB 3E            mov [d], al
0242+  11DC 79            inc d
0243+  11DD 0A AC 11      jmp _gettxt_loop
0244+  11E0             _gettxt_cr:
0245+  11E0 19 0D         mov al, $0d
0246+  11E2 3E            mov [d], al
0247+  11E3 79            inc d
0248+  11E4 0A AC 11      jmp _gettxt_loop
0249+  11E7             _gettxt_backspace:
0250+  11E7 7F            dec d
0251+  11E8 0A AC 11      jmp _gettxt_loop
0252+  11EB             _gettxt_end:
0253+  11EB 19 00         mov al, 0
0254+  11ED 3E            mov [d], al        ; terminate string
0255+  11EE E7            pop d
0256+  11EF E4            pop a
0257+  11F0 09            ret
0258+  11F1             
0259+  11F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  11F1             ; print new line
0261+  11F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  11F1             printnl:
0263+  11F1 D7            push a
0264+  11F2 10 00 0A      mov a, $0a00
0265+  11F5 05 03         syscall sys_io
0266+  11F7 10 00 0D      mov a, $0d00
0267+  11FA 05 03         syscall sys_io
0268+  11FC E4            pop a
0269+  11FD 09            ret
0270+  11FE             
0271+  11FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  11FE             ; _strtoint
0273+  11FE             ; 4 digit hex string number in d
0274+  11FE             ; integer returned in a
0275+  11FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  11FE             _strtointx:
0277+  11FE D8            push b
0278+  11FF 32            mov bl, [d]
0279+  1200 37            mov bh, bl
0280+  1201 33 01 00      mov bl, [d + 1]
0281+  1204 07 D5 10      call _atoi        ; convert to int in al
0282+  1207 23            mov ah, al        ; move to ah
0283+  1208 33 02 00      mov bl, [d + 2]
0284+  120B 37            mov bh, bl
0285+  120C 33 03 00      mov bl, [d + 3]
0286+  120F 07 D5 10      call _atoi        ; convert to int in al
0287+  1212 E5            pop b
0288+  1213 09            ret
0289+  1214             
0290+  1214             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1214             ; _strtoint
0292+  1214             ; 5 digit base10 string number in d
0293+  1214             ; integer returned in a
0294+  1214             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1214             _strtoint:
0296+  1214 E2            push si
0297+  1215 D8            push b
0298+  1216 D9            push c
0299+  1217 DA            push d
0300+  1218 07 77 10      call _strlen      ; get string length in c
0301+  121B 7E            dec c
0302+  121C FD 4E         mov si, d
0303+  121E 12            mov a, c
0304+  121F FD 99         shl a
0305+  1221 3B 98 13      mov d, table_power
0306+  1224 59            add d, a
0307+  1225 38 00 00      mov c, 0
0308+  1228             _strtoint_l0:
0309+  1228 F6            lodsb      ; load ascii to al
0310+  1229 B9 00         cmp al, 0
0311+  122B C6 3E 12      je _strtoint_end
0312+  122E 6F 30         sub al, $30    ; make into integer
0313+  1230 22 00         mov ah, 0
0314+  1232 2A            mov b, [d]
0315+  1233 AC            mul a, b      ; result in b since it fits in 16bits
0316+  1234 11            mov a, b
0317+  1235 28            mov b, c
0318+  1236 54            add a, b
0319+  1237 39            mov c, a
0320+  1238 63 02 00      sub d, 2
0321+  123B 0A 28 12      jmp _strtoint_l0
0322+  123E             _strtoint_end:
0323+  123E 12            mov a, c
0324+  123F E7            pop d
0325+  1240 E6            pop c
0326+  1241 E5            pop b
0327+  1242 EF            pop si
0328+  1243 09            ret
0329+  1244             
0330+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1244             ; print null terminated string
0332+  1244             ; pointer in d
0333+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1244             _puts:
0335+  1244 D7            push a
0336+  1245 DA            push d
0337+  1246             _puts_l1:
0338+  1246 1E            mov al, [d]
0339+  1247 B9 00         cmp al, 0
0340+  1249 C6 55 12      jz _puts_end
0341+  124C 23            mov ah, al
0342+  124D 19 00         mov al, 0
0343+  124F 05 03         syscall sys_io
0344+  1251 79            inc d
0345+  1252 0A 46 12      jmp _puts_l1
0346+  1255             _puts_end:
0347+  1255 E7            pop d
0348+  1256 E4            pop a
0349+  1257 09            ret
0350+  1258             
0351+  1258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1258             ; print n size string
0353+  1258             ; pointer in d
0354+  1258             ; size in c
0355+  1258             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1258             _putsn:
0357+  1258 DB            push al
0358+  1259 DA            push d
0359+  125A D9            push c
0360+  125B             _putsn_l0:
0361+  125B 1E            mov al, [d]
0362+  125C 23            mov ah, al
0363+  125D 19 00         mov al, 0
0364+  125F 05 03         syscall sys_io
0365+  1261 79            inc d
0366+  1262 7E            dec c  
0367+  1263 C2 00 00      cmp c, 0
0368+  1266 C7 5B 12      jne _putsn_l0
0369+  1269             _putsn_end:
0370+  1269 E6            pop c
0371+  126A E7            pop d
0372+  126B E8            pop al
0373+  126C 09            ret
0374+  126D             
0375+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  126D             ; print 16bit decimal number
0377+  126D             ; input number in a
0378+  126D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  126D             print_u16d:
0380+  126D D7            push a
0381+  126E D8            push b
0382+  126F FD D8         push g
0383+  1271 26 10 27      mov b, 10000
0384+  1274 AE            div a, b      ; get 10000's coeff.
0385+  1275 07 99 12      call print_number
0386+  1278 11            mov a, b
0387+  1279 26 E8 03      mov b, 1000
0388+  127C AE            div a, b      ; get 1000's coeff.
0389+  127D 07 99 12      call print_number
0390+  1280 11            mov a, b
0391+  1281 26 64 00      mov b, 100
0392+  1284 AE            div a, b
0393+  1285 07 99 12      call print_number
0394+  1288 11            mov a, b
0395+  1289 26 0A 00      mov b, 10
0396+  128C AE            div a, b
0397+  128D 07 99 12      call print_number
0398+  1290 1B            mov al, bl      ; 1's coeff in bl
0399+  1291 07 99 12      call print_number
0400+  1294 FD F1         pop g
0401+  1296 E5            pop b
0402+  1297 E4            pop a
0403+  1298 09            ret
0404+  1299             
0405+  1299             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1299             ; print al
0407+  1299             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1299             print_number:
0409+  1299 6A 30         add al, $30
0410+  129B 23            mov ah, al
0411+  129C 07 18 11      call _putchar
0412+  129F 09            ret
0413+  12A0             
0414+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12A0             ; print 16bit hex integer
0416+  12A0             ; integer value in reg b
0417+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12A0             print_u16x:
0419+  12A0 D7            push a
0420+  12A1 D8            push b
0421+  12A2 DD            push bl
0422+  12A3 30            mov bl, bh
0423+  12A4 07 E6 10      call _itoa        ; convert bh to char in a
0424+  12A7 2F            mov bl, al        ; save al
0425+  12A8 19 00         mov al, 0
0426+  12AA 05 03         syscall sys_io        ; display ah
0427+  12AC 24            mov ah, bl        ; retrieve al
0428+  12AD 19 00         mov al, 0
0429+  12AF 05 03         syscall sys_io        ; display al
0430+  12B1             
0431+  12B1 EA            pop bl
0432+  12B2 07 E6 10      call _itoa        ; convert bh to char in a
0433+  12B5 2F            mov bl, al        ; save al
0434+  12B6 19 00         mov al, 0
0435+  12B8 05 03         syscall sys_io        ; display ah
0436+  12BA 24            mov ah, bl        ; retrieve al
0437+  12BB 19 00         mov al, 0
0438+  12BD 05 03         syscall sys_io        ; display al
0439+  12BF             
0440+  12BF E5            pop b
0441+  12C0 E4            pop a
0442+  12C1 09            ret
0443+  12C2             
0444+  12C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  12C2             ; input 16bit hex integer
0446+  12C2             ; read 16bit integer into a
0447+  12C2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  12C2             scan_u16x:
0449+  12C2 F8 10 00      enter 16
0450+  12C5 D8            push b
0451+  12C6 DA            push d
0452+  12C7             
0453+  12C7 FA F1 FF      lea d, [bp + -15]
0454+  12CA 07 1F 11      call _gets        ; get number
0455+  12CD             
0456+  12CD 32            mov bl, [d]
0457+  12CE 37            mov bh, bl
0458+  12CF 33 01 00      mov bl, [d + 1]
0459+  12D2 07 D5 10      call _atoi        ; convert to int in al
0460+  12D5 23            mov ah, al        ; move to ah
0461+  12D6             
0462+  12D6 33 02 00      mov bl, [d + 2]
0463+  12D9 37            mov bh, bl
0464+  12DA 33 03 00      mov bl, [d + 3]
0465+  12DD 07 D5 10      call _atoi        ; convert to int in al
0466+  12E0             
0467+  12E0 E7            pop d
0468+  12E1 E5            pop b
0469+  12E2 F9            leave
0470+  12E3 09            ret
0471+  12E4             
0472+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  12E4             ; print 8bit hex integer
0474+  12E4             ; integer value in reg bl
0475+  12E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  12E4             print_u8x:
0477+  12E4 D7            push a
0478+  12E5 DD            push bl
0479+  12E6             
0480+  12E6 07 E6 10      call _itoa        ; convert bl to char in a
0481+  12E9 2F            mov bl, al        ; save al
0482+  12EA 19 00         mov al, 0
0483+  12EC 05 03         syscall sys_io        ; display ah
0484+  12EE 24            mov ah, bl        ; retrieve al
0485+  12EF 19 00         mov al, 0
0486+  12F1 05 03         syscall sys_io        ; display al
0487+  12F3             
0488+  12F3 EA            pop bl
0489+  12F4 E4            pop a
0490+  12F5 09            ret
0491+  12F6             
0492+  12F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  12F6             ; print 8bit decimal unsigned number
0494+  12F6             ; input number in al
0495+  12F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  12F6             print_u8d:
0497+  12F6 D7            push a
0498+  12F7 D8            push b
0499+  12F8 FD D8         push g
0500+  12FA 22 00         mov ah, 0
0501+  12FC 26 64 00      mov b, 100
0502+  12FF AE            div a, b
0503+  1300 D8            push b      ; save remainder
0504+  1301 B9 00         cmp al, 0
0505+  1303 C6 0D 13      je skip100
0506+  1306 6A 30         add al, $30
0507+  1308 23            mov ah, al
0508+  1309 19 00         mov al, 0
0509+  130B 05 03         syscall sys_io  ; print coeff
0510+  130D             skip100:
0511+  130D E4            pop a
0512+  130E 22 00         mov ah, 0
0513+  1310 26 0A 00      mov b, 10
0514+  1313 AE            div a, b
0515+  1314 D8            push b      ; save remainder
0516+  1315 B9 00         cmp al, 0
0517+  1317 C6 21 13      je skip10
0518+  131A 6A 30         add al, $30
0519+  131C 23            mov ah, al
0520+  131D 19 00         mov al, 0
0521+  131F 05 03         syscall sys_io  ; print coeff
0522+  1321             skip10:
0523+  1321 E4            pop a
0524+  1322 1B            mov al, bl
0525+  1323 6A 30         add al, $30
0526+  1325 23            mov ah, al
0527+  1326 19 00         mov al, 0
0528+  1328 05 03         syscall sys_io  ; print coeff
0529+  132A FD F1         pop g
0530+  132C E5            pop b
0531+  132D E4            pop a
0532+  132E 09            ret
0533+  132F             
0534+  132F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  132F             ; input 8bit hex integer
0536+  132F             ; read 8bit integer into al
0537+  132F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  132F             scan_u8x:
0539+  132F F8 04 00      enter 4
0540+  1332 D8            push b
0541+  1333 DA            push d
0542+  1334             
0543+  1334 FA FD FF      lea d, [bp + -3]
0544+  1337 07 1F 11      call _gets        ; get number
0545+  133A             
0546+  133A 32            mov bl, [d]
0547+  133B 37            mov bh, bl
0548+  133C 33 01 00      mov bl, [d + 1]
0549+  133F 07 D5 10      call _atoi        ; convert to int in al
0550+  1342             
0551+  1342 E7            pop d
0552+  1343 E5            pop b
0553+  1344 F9            leave
0554+  1345 09            ret
0555+  1346             
0556+  1346             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1346             ; input decimal number
0558+  1346             ; result in a
0559+  1346             ; 655'\0'
0560+  1346             ; low--------high
0561+  1346             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1346             scan_u16d:
0563+  1346 F8 08 00      enter 8
0564+  1349 E2            push si
0565+  134A D8            push b
0566+  134B D9            push c
0567+  134C DA            push d
0568+  134D FA F9 FF      lea d, [bp +- 7]
0569+  1350 07 1F 11      call _gets
0570+  1353 07 77 10      call _strlen      ; get string length in c
0571+  1356 7E            dec c
0572+  1357 FD 4E         mov si, d
0573+  1359 12            mov a, c
0574+  135A FD 99         shl a
0575+  135C 3B 98 13      mov d, table_power
0576+  135F 59            add d, a
0577+  1360 38 00 00      mov c, 0
0578+  1363             mul_loop:
0579+  1363 F6            lodsb      ; load ascii to al
0580+  1364 B9 00         cmp al, 0
0581+  1366 C6 79 13      je mul_exit
0582+  1369 6F 30         sub al, $30    ; make into integer
0583+  136B 22 00         mov ah, 0
0584+  136D 2A            mov b, [d]
0585+  136E AC            mul a, b      ; result in b since it fits in 16bits
0586+  136F 11            mov a, b
0587+  1370 28            mov b, c
0588+  1371 54            add a, b
0589+  1372 39            mov c, a
0590+  1373 63 02 00      sub d, 2
0591+  1376 0A 63 13      jmp mul_loop
0592+  1379             mul_exit:
0593+  1379 12            mov a, c
0594+  137A E7            pop d
0595+  137B E6            pop c
0596+  137C E5            pop b
0597+  137D EF            pop si
0598+  137E F9            leave
0599+  137F 09            ret
0600+  1380             
0601+  1380             
0602+  1380 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  1384 34 35 36 37 
0602+  1388 38 39 61 62 
0602+  138C 63 64 65 66 
0603+  1390 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  1394 1B 5B 68 00 
0604+  1398             
0605+  1398             table_power:
0606+  1398 01 00         .dw 1
0607+  139A 0A 00         .dw 10
0608+  139C 64 00         .dw 100
0609+  139E E8 03         .dw 1000
0610+  13A0 10 27         .dw 100002727   13A2             .include "lib/ctype.asm"
0001+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13A2             ; ctype.s
0003+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13A2             
0005+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13A2             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  13A2             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  13A2             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  13A2             ;; characters are supported.
0010+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13A2             ;; _isalnum 
0012+  13A2             ;; _isalpha 
0013+  13A2             ;; islower 
0014+  13A2             ;; isupper 
0015+  13A2             ;; _isdigit 
0016+  13A2             ;; isxdigit
0017+  13A2             ;; iscntrl 
0018+  13A2             ;; isgraph 
0019+  13A2             ;; _isspace 
0020+  13A2             ;; isblank 
0021+  13A2             ;; isprint 
0022+  13A2             ;; ispunct 
0023+  13A2             ;; tolower 
0024+  13A2             ;; toupper
0025+  13A2             
0026+  13A2             
0027+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13A2             ;; is alphanumeric
0029+  13A2             ;; sets zf according with result
0030+  13A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13A2             _isalnum:
0032+  13A2 07 BF 13    	call _isalpha
0033+  13A5 C6 AB 13    	je _isalnum_exit
0034+  13A8 07 AC 13    	call _isdigit
0035+  13AB             _isalnum_exit:
0036+  13AB 09          	ret	
0037+  13AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13AC             ;; is digit
0039+  13AC             ;; sets zf according with result
0040+  13AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13AC             _isdigit:
0042+  13AC DB          	push al
0043+  13AD B9 30       	cmp al, '0'
0044+  13AF C8 BB 13    	jlu _isdigit_false
0045+  13B2 B9 39       	cmp al, '9'
0046+  13B4 D1 BB 13    	jgu _isdigit_false
0047+  13B7 87 00       	and al, 0	; set zf
0048+  13B9 E8          	pop al
0049+  13BA 09          	ret
0050+  13BB             _isdigit_false:
0051+  13BB 8B 01       	or al, 1	; clear zf
0052+  13BD E8          	pop al
0053+  13BE 09          	ret	
0054+  13BF             	
0055+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  13BF             ;; is alpha
0057+  13BF             ;; sets zf according with result
0058+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  13BF             _isalpha:
0060+  13BF DB          	push al
0061+  13C0 B9 5F       	cmp al, '_'
0062+  13C2 C6 E2 13    	je _isalpha_true
0063+  13C5 B9 2E       	cmp al, '.'
0064+  13C7 C6 E2 13    	je _isalpha_true
0065+  13CA B9 61       	cmp al, 'a'
0066+  13CC C8 DE 13    	jlu _isalpha_false
0067+  13CF B9 7A       	cmp al, 'z'
0068+  13D1 D1 DE 13    	jgu _isalpha_false
0069+  13D4 B9 7A       	cmp al, 'z'
0070+  13D6 D0 E2 13    	jleu _isalpha_true
0071+  13D9 B9 61       	cmp al, 'a'
0072+  13DB C9 E2 13    	jgeu _isalpha_true
0073+  13DE             _isalpha_false:
0074+  13DE 8B 01       	or al, 1	; clear zf
0075+  13E0 E8          	pop al
0076+  13E1 09          	ret
0077+  13E2             _isalpha_true:
0078+  13E2 87 00       	and al, 0	; set zf
0079+  13E4 E8          	pop al
0080+  13E5 09          	ret
0081+  13E6             
0082+  13E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  13E6             ;; is path-alpha
0084+  13E6             ;; sets zf according with result
0085+  13E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  13E6             ispath:
0087+  13E6 DB          	push al
0088+  13E7 07 AC 13    	call _isdigit
0089+  13EA C6 14 14    	je ispath_true
0090+  13ED B9 5F       	cmp al, '_'
0091+  13EF C6 14 14    	je ispath_true
0092+  13F2 B9 2F       	cmp al, '/'
0093+  13F4 C6 14 14    	je ispath_true
0094+  13F7 B9 2E       	cmp al, '.'
0095+  13F9 C6 14 14    	je ispath_true
0096+  13FC B9 61       	cmp al, 'a'
0097+  13FE C8 10 14    	jlu ispath_false
0098+  1401 B9 7A       	cmp al, 'z'
0099+  1403 D1 10 14    	jgu ispath_false
0100+  1406 B9 7A       	cmp al, 'z'
0101+  1408 D0 14 14    	jleu ispath_true
0102+  140B B9 61       	cmp al, 'a'
0103+  140D C9 14 14    	jgeu ispath_true
0104+  1410             ispath_false:
0105+  1410 8B 01       	or al, 1	; clear zf
0106+  1412 E8          	pop al
0107+  1413 09          	ret
0108+  1414             ispath_true:
0109+  1414 87 00       	and al, 0	; set zf
0110+  1416 E8          	pop al
0111+  1417 09          	ret
0112+  1418             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1418             ;; is space
0114+  1418             ;; sets zf according with result
0115+  1418             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1418             _isspace:
0117+  1418 B9 20       	cmp al, $20		; ' '
0118+  141A C6 2E 14    	je _isspace_exit
0119+  141D B9 09       	cmp al, $09		; '\t'
0120+  141F C6 2E 14    	je _isspace_exit
0121+  1422 B9 0A       	cmp al, $0a		; '\n'
0122+  1424 C6 2E 14    	je _isspace_exit
0123+  1427 B9 0D       	cmp al, $0d		; '\r'
0124+  1429 C6 2E 14    	je _isspace_exit
0125+  142C B9 0B       	cmp al, $0b		; '\v'
0126+  142E             _isspace_exit:
0127+  142E 09          	ret	
0128+  142F             
0129+  142F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  142F             ; to lower
0131+  142F             ; input in al
0132+  142F             ; output in al
0133+  142F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  142F             _to_lower:
0135+  142F B9 7A       	cmp al, 'z'
0136+  1431 D1 36 14    	jgu _to_lower_ret
0137+  1434 6A 20       	add al, $20				; convert to lower case
0138+  1436             _to_lower_ret:
0139+  1436 09          	ret
0140+  1437             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1437             ; to upper
0142+  1437             ; input in al
0143+  1437             ; output in al
0144+  1437             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1437             _to_upper:
0146+  1437 B9 61       	cmp al, 'a'
0147+  1439 C8 3E 14    	jlu _to_upper_ret
0148+  143C 6F 20       	sub al, $20			; convert to upper case
0149+  143E             _to_upper_ret:
0150+  143E 09          	ret
0151+  143F             
2728   143F             .include "lib/token.asm"
0001+  143F             toktyp_identifier  .equ 0
0002+  143F             toktyp_keyword     .equ 1
0003+  143F             toktyp_delimiter   .equ 2
0004+  143F             toktyp_string      .equ 3
0005+  143F             toktyp_char        .equ 4
0006+  143F             toktyp_numeric     .equ 5
0007+  143F             toktyp_end         .equ 6
0008+  143F             
0009+  143F             tok_null           .equ 0
0010+  143F             tok_fslash         .equ 1
0011+  143F             tok_times          .equ 2
0012+  143F             tok_plus           .equ 3
0013+  143F             tok_minus          .equ 4
0014+  143F             tok_dot            .equ 5
0015+  143F             tok_semi           .equ 6
0016+  143F             tok_angle          .equ 7
0017+  143F             tok_tilde          .equ 8
0018+  143F             tok_equal          .equ 9
0019+  143F             tok_colon          .equ 10
0020+  143F             tok_comma          .equ 11
0021+  143F             
0022+  143F             tok_end            .equ 20
0023+  143F             
0024+  143F             
0025+  143F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  143F             ;; read a full command argment from shell input buffer
0027+  143F             ;; argument is written into tokstr
0028+  143F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  143F             get_arg:
0030+  143F D7            push a
0031+  1440 E2            push si
0032+  1441 E3            push di
0033+  1442 19 00         mov al, 0
0034+  1444 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0035+  1447 14 69 16      mov a, [prog]
0036+  144A 4D            mov si, a
0037+  144B FD 4F 6D 16   mov di, tokstr
0038+  144F             get_arg_skip_spaces:
0039+  144F F6            lodsb
0040+  1450 07 18 14      call _isspace
0041+  1453 C6 4F 14      je get_arg_skip_spaces
0042+  1456             get_arg_l0:
0043+  1456 B9 3B         cmp al, $3b        ; check if is ';'
0044+  1458 C6 65 14      je get_arg_end
0045+  145B B9 00         cmp al, 0
0046+  145D C6 65 14      je get_arg_end      ; check if end of input
0047+  1460 F7            stosb
0048+  1461 F6            lodsb
0049+  1462 0A 56 14      jmp get_arg_l0
0050+  1465             get_arg_end:
0051+  1465 19 00         mov al, 0
0052+  1467 F7            stosb
0053+  1468 D5 01 00      sub si, 1
0054+  146B 4E            mov a, si
0055+  146C 42 69 16      mov [prog], a    ; update pointer
0056+  146F F0            pop di
0057+  1470 EF            pop si
0058+  1471 E4            pop a
0059+  1472 09            ret
0060+  1473             
0061+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1473             ;; read a path formation from shell input buffer
0063+  1473             ;; path is written into tokstr
0064+  1473             ;; /usr/bin
0065+  1473             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1473             get_path:
0067+  1473 D7            push a
0068+  1474 E2            push si
0069+  1475 E3            push di
0070+  1476 19 00         mov al, 0
0071+  1478 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0072+  147B 14 69 16      mov a, [prog]
0073+  147E 4D            mov si, a
0074+  147F FD 4F 6D 16   mov di, tokstr
0075+  1483             get_path_skip_spaces:
0076+  1483 F6            lodsb
0077+  1484 07 18 14      call _isspace
0078+  1487 C6 83 14      je get_path_skip_spaces
0079+  148A             get_path_is_pathchar:
0080+  148A F7            stosb
0081+  148B F6            lodsb
0082+  148C 07 A2 13      call _isalnum      ;check if is alphanumeric
0083+  148F C6 8A 14      je get_path_is_pathchar
0084+  1492 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1494 C6 8A 14      je get_path_is_pathchar
0086+  1497 19 00         mov al, 0
0087+  1499 F7            stosb
0088+  149A D5 01 00      sub si, 1
0089+  149D 4E            mov a, si
0090+  149E 42 69 16      mov [prog], a    ; update pointer
0091+  14A1             get_path_end:
0092+  14A1 F0            pop di
0093+  14A2 EF            pop si
0094+  14A3 E4            pop a
0095+  14A4 09            ret
0096+  14A5             
0097+  14A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14A5             ;; read a line
0099+  14A5             ;; line is written into tokstr
0100+  14A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14A5             get_line:
0102+  14A5 D7            push a
0103+  14A6 E2            push si
0104+  14A7 E3            push di
0105+  14A8 19 00         mov al, 0
0106+  14AA 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0107+  14AD 14 69 16      mov a, [prog]
0108+  14B0 4D            mov si, a
0109+  14B1 FD 4F 6D 16   mov di, tokstr
0110+  14B5             get_line_l0:
0111+  14B5 F6            lodsb
0112+  14B6 B9 0A         cmp al, $0a    ; check for new line
0113+  14B8 C6 BF 14      je get_line_exit
0114+  14BB F7            stosb
0115+  14BC 0A B5 14      jmp get_line_l0
0116+  14BF             get_line_exit:
0117+  14BF 19 00         mov al, 0
0118+  14C1 F7            stosb
0119+  14C2 4E            mov a, si
0120+  14C3 42 69 16      mov [prog], a    ; update pointer
0121+  14C6 F0            pop di
0122+  14C7 EF            pop si
0123+  14C8 E4            pop a
0124+  14C9 09            ret
0125+  14CA             
0126+  14CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  14CA             ;; token parser
0128+  14CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  14CA             get_token:
0130+  14CA D7            push a
0131+  14CB DA            push d
0132+  14CC E2            push si
0133+  14CD E3            push di
0134+  14CE 19 00         mov al, 0
0135+  14D0 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0136+  14D3 19 00         mov al, tok_null
0137+  14D5 3D 6C 16      mov [tok], al        ; nullify token
0138+  14D8 14 69 16      mov a, [prog]
0139+  14DB 4D            mov si, a
0140+  14DC FD 4F 6D 16   mov di, tokstr
0141+  14E0             get_tok_skip_spaces:
0142+  14E0 F6            lodsb
0143+  14E1 07 18 14      call _isspace
0144+  14E4 C6 E0 14      je get_tok_skip_spaces
0145+  14E7 B9 00         cmp al, 0      ; check for end of input (null)
0146+  14E9 C6 CE 15      je get_token_end
0147+  14EC B9 23         cmp al, '#'      ; comments!
0148+  14EE C6 FC 15      je get_tok_comment
0149+  14F1 07 A2 13      call _isalnum
0150+  14F4 C6 DB 15      jz is_alphanumeric
0151+  14F7             ; other token types
0152+  14F7             get_token_slash:
0153+  14F7 B9 2F         cmp al, '/'        ; check if '/'
0154+  14F9 C7 11 15      jne get_token_minus
0155+  14FC F7            stosb          ; store '/' into token string
0156+  14FD 19 00         mov al, 0
0157+  14FF F7            stosb          ; terminate token string
0158+  1500 19 01         mov al, tok_fslash
0159+  1502 3D 6C 16      mov [tok], al      
0160+  1505 19 02         mov al, toktyp_delimiter
0161+  1507 3D 6B 16      mov [toktyp], al
0162+  150A 4E            mov a, si
0163+  150B 42 69 16      mov [prog], a    ; update pointer
0164+  150E 0A F7 15      jmp get_token_return
0165+  1511             get_token_minus:
0166+  1511 B9 2D         cmp al, '-'        ; check if '-'
0167+  1513 C7 2B 15      jne get_token_comma
0168+  1516 F7            stosb          ; store '-' into token string
0169+  1517 19 00         mov al, 0
0170+  1519 F7            stosb          ; terminate token string
0171+  151A 19 04         mov al, tok_minus
0172+  151C 3D 6C 16      mov [tok], al      
0173+  151F 19 02         mov al, toktyp_delimiter
0174+  1521 3D 6B 16      mov [toktyp], al
0175+  1524 4E            mov a, si
0176+  1525 42 69 16      mov [prog], a    ; update pointer
0177+  1528 0A F7 15      jmp get_token_return
0178+  152B             get_token_comma:
0179+  152B B9 2C         cmp al, ','        ; check if ','
0180+  152D C7 45 15      jne get_token_semi
0181+  1530 F7            stosb          ; store ',' into token string
0182+  1531 19 00         mov al, 0
0183+  1533 F7            stosb          ; terminate token string
0184+  1534 19 0B         mov al, tok_comma
0185+  1536 3D 6C 16      mov [tok], al      
0186+  1539 19 02         mov al, toktyp_delimiter
0187+  153B 3D 6B 16      mov [toktyp], al
0188+  153E 4E            mov a, si
0189+  153F 42 69 16      mov [prog], a    ; update pointer
0190+  1542 0A F7 15      jmp get_token_return
0191+  1545             get_token_semi:
0192+  1545 B9 3B         cmp al, $3b        ; check if ';'
0193+  1547 C7 5F 15      jne get_token_colon
0194+  154A F7            stosb          ; store ';' into token string
0195+  154B 19 00         mov al, 0
0196+  154D F7            stosb          ; terminate token string
0197+  154E 19 06         mov al, tok_semi
0198+  1550 3D 6C 16      mov [tok], al      
0199+  1553 19 02         mov al, toktyp_delimiter
0200+  1555 3D 6B 16      mov [toktyp], al
0201+  1558 4E            mov a, si
0202+  1559 42 69 16      mov [prog], a    ; update pointer
0203+  155C 0A F7 15      jmp get_token_return
0204+  155F             get_token_colon:
0205+  155F B9 3A         cmp al, $3a        ; check if ':'
0206+  1561 C7 79 15      jne get_token_angle
0207+  1564 F7            stosb          ; store ':' into token string
0208+  1565 19 00         mov al, 0
0209+  1567 F7            stosb          ; terminate token string
0210+  1568 19 0A         mov al, tok_colon
0211+  156A 3D 6C 16      mov [tok], al      
0212+  156D 19 02         mov al, toktyp_delimiter
0213+  156F 3D 6B 16      mov [toktyp], al
0214+  1572 4E            mov a, si
0215+  1573 42 69 16      mov [prog], a    ; update pointer
0216+  1576 0A F7 15      jmp get_token_return
0217+  1579             get_token_angle:
0218+  1579 B9 3E         cmp al, $3e        ; check if '>'
0219+  157B C7 93 15      jne get_token_tilde
0220+  157E F7            stosb          ; store '>' into token string
0221+  157F 19 00         mov al, 0
0222+  1581 F7            stosb          ; terminate token string
0223+  1582 19 07         mov al, tok_angle
0224+  1584 3D 6C 16      mov [tok], al      
0225+  1587 19 02         mov al, toktyp_delimiter
0226+  1589 3D 6B 16      mov [toktyp], al
0227+  158C 4E            mov a, si
0228+  158D 42 69 16      mov [prog], a    ; update pointer
0229+  1590 0A F7 15      jmp get_token_return
0230+  1593             get_token_tilde:
0231+  1593 B9 7E         cmp al, '~'        ; check if '~'
0232+  1595 C7 AD 15      jne get_token_equal
0233+  1598 F7            stosb          ; store '~' into token string
0234+  1599 19 00         mov al, 0
0235+  159B F7            stosb          ; terminate token string
0236+  159C 19 08         mov al, tok_tilde
0237+  159E 3D 6C 16      mov [tok], al      
0238+  15A1 19 02         mov al, toktyp_delimiter
0239+  15A3 3D 6B 16      mov [toktyp], al
0240+  15A6 4E            mov a, si
0241+  15A7 42 69 16      mov [prog], a    ; update pointer
0242+  15AA 0A F7 15      jmp get_token_return
0243+  15AD             get_token_equal:
0244+  15AD B9 3D         cmp al, '='        ; check if '='
0245+  15AF C7 C7 15      jne get_token_skip
0246+  15B2 F7            stosb          ; store '=' into token string
0247+  15B3 19 00         mov al, 0
0248+  15B5 F7            stosb          ; terminate token string
0249+  15B6 19 09         mov al, tok_equal
0250+  15B8 3D 6C 16      mov [tok], al      
0251+  15BB 19 02         mov al, toktyp_delimiter
0252+  15BD 3D 6B 16      mov [toktyp], al
0253+  15C0 4E            mov a, si
0254+  15C1 42 69 16      mov [prog], a    ; update pointer
0255+  15C4 0A F7 15      jmp get_token_return
0256+  15C7             get_token_skip:
0257+  15C7 4E            mov a, si
0258+  15C8 42 69 16      mov [prog], a    ; update pointer
0259+  15CB 0A F7 15      jmp get_token_return
0260+  15CE             get_token_end:        ; end of file token
0261+  15CE 19 14         mov al, tok_end
0262+  15D0 3D 6C 16      mov [tok], al
0263+  15D3 19 06         mov al, toktyp_end
0264+  15D5 3D 6B 16      mov [toktyp], al
0265+  15D8 0A F7 15      jmp get_token_return
0266+  15DB             is_alphanumeric:
0267+  15DB F7            stosb
0268+  15DC F6            lodsb
0269+  15DD 07 A2 13      call _isalnum      ;check if is alphanumeric
0270+  15E0 C6 DB 15      jz is_alphanumeric
0271+  15E3 B9 2E         cmp al, $2e        ; check if is '.'
0272+  15E5 C6 DB 15      je is_alphanumeric
0273+  15E8 19 00         mov al, 0
0274+  15EA F7            stosb
0275+  15EB 19 00         mov al, toktyp_identifier
0276+  15ED 3D 6B 16      mov [toktyp], al
0277+  15F0 D5 01 00      sub si, 1
0278+  15F3 4E            mov a, si
0279+  15F4 42 69 16      mov [prog], a    ; update pointer
0280+  15F7             get_token_return:
0281+  15F7 F0            pop di
0282+  15F8 EF            pop si
0283+  15F9 E7            pop d
0284+  15FA E4            pop a
0285+  15FB 09            ret
0286+  15FC             get_tok_comment:
0287+  15FC F6            lodsb
0288+  15FD B9 0A         cmp al, $0a      ; new line
0289+  15FF C7 FC 15      jne get_tok_comment
0290+  1602 0A E0 14      jmp get_tok_skip_spaces
0291+  1605             
0292+  1605             
0293+  1605             get_number:
0294+  1605 D7            push a
0295+  1606 DA            push d
0296+  1607 E2            push si
0297+  1608 E3            push di
0298+  1609 19 00         mov al, 0
0299+  160B 3D 6D 16      mov [tokstr], al      ; nullify tokstr string
0300+  160E 19 00         mov al, tok_null
0301+  1610 3D 6C 16      mov [tok], al        ; nullify token
0302+  1613 14 69 16      mov a, [prog]
0303+  1616 4D            mov si, a
0304+  1617 FD 4F 6D 16   mov di, tokstr
0305+  161B             get_number_skip_spaces:
0306+  161B F6            lodsb
0307+  161C 07 18 14      call _isspace
0308+  161F C6 1B 16      je get_number_skip_spaces
0309+  1622 B9 00         cmp al, 0      ; check for end of input (null)
0310+  1624 C7 34 16      jne get_number_l0
0311+  1627 19 14         mov al, tok_end
0312+  1629 3D 6C 16      mov [tok], al
0313+  162C 19 06         mov al, toktyp_end
0314+  162E 3D 6B 16      mov [toktyp], al
0315+  1631 0A 4B 16      jmp get_number_return
0316+  1634             get_number_l0:
0317+  1634 F7            stosb
0318+  1635 F6            lodsb
0319+  1636 07 AC 13      call _isdigit      ;check if is numeric
0320+  1639 C6 34 16      jz get_number_l0
0321+  163C 19 00         mov al, 0
0322+  163E F7            stosb
0323+  163F 19 05         mov al, toktyp_numeric
0324+  1641 3D 6B 16      mov [toktyp], al
0325+  1644 D5 01 00      sub si, 1
0326+  1647 4E            mov a, si
0327+  1648 42 69 16      mov [prog], a    ; update pointer
0328+  164B             get_number_return:
0329+  164B F0            pop di
0330+  164C EF            pop si
0331+  164D E7            pop d
0332+  164E E4            pop a
0333+  164F 09            ret
0334+  1650             
0335+  1650             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1650             ;; put back token
0337+  1650             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1650             _putback:
0339+  1650 D7            push a
0340+  1651 E2            push si
0341+  1652 FD 4D 6D 16   mov si, tokstr  
0342+  1656             _putback_loop:
0343+  1656 F6            lodsb
0344+  1657 B9 00         cmp al, 0
0345+  1659 C6 66 16      je _putback_end
0346+  165C 14 69 16      mov a, [prog]
0347+  165F 7D            dec a
0348+  1660 42 69 16      mov [prog], a      ; update pointer
0349+  1663 0A 56 16      jmp _putback_loop
0350+  1666             _putback_end:
0351+  1666 EF            pop si
0352+  1667 E4            pop a
0353+  1668 09            ret
0354+  1669             
0355+  1669             
0356+  1669             
0357+  1669             
0358+  1669 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  166B             
0360+  166B 00          toktyp:    .db 0          ; token type symbol
0361+  166C 00          tok:       .db 0          ; current token symbol
0362+  166D 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1671 00 00 00 00 
0362+  1675 00 00 00 00 
0362+  1679 00 00 00 00 
0362+  167D 00 00 00 00 
0362+  1681 00 00 00 00 
0362+  1685 00 00 00 00 
0362+  1689 00 00 00 00 
0362+  168D 00 00 00 00 
0362+  1691 00 00 00 00 
0362+  1695 00 00 00 00 
0362+  1699 00 00 00 00 
0362+  169D 00 00 00 00 
0362+  16A1 00 00 00 00 
0362+  16A5 00 00 00 00 
0362+  16A9 00 00 00 00 
0362+  16AD 00 00 00 00 
0362+  16B1 00 00 00 00 
0362+  16B5 00 00 00 00 
0362+  16B9 00 00 00 00 
0362+  16BD 00 00 00 00 
0362+  16C1 00 00 00 00 
0362+  16C5 00 00 00 00 
0362+  16C9 00 00 00 00 
0362+  16CD 00 00 00 00 
0362+  16D1 00 00 00 00 
0362+  16D5 00 00 00 00 
0362+  16D9 00 00 00 00 
0362+  16DD 00 00 00 00 
0362+  16E1 00 00 00 00 
0362+  16E5 00 00 00 00 
0362+  16E9 00 00 00 00 
0362+  16ED 00 00 00 00 
0362+  16F1 00 00 00 00 
0362+  16F5 00 00 00 00 
0362+  16F9 00 00 00 00 
0362+  16FD 00 00 00 00 
0362+  1701 00 00 00 00 
0362+  1705 00 00 00 00 
0362+  1709 00 00 00 00 
0362+  170D 00 00 00 00 
0362+  1711 00 00 00 00 
0362+  1715 00 00 00 00 
0362+  1719 00 00 00 00 
0362+  171D 00 00 00 00 
0362+  1721 00 00 00 00 
0362+  1725 00 00 00 00 
0362+  1729 00 00 00 00 
0362+  172D 00 00 00 00 
0362+  1731 00 00 00 00 
0362+  1735 00 00 00 00 
0362+  1739 00 00 00 00 
0362+  173D 00 00 00 00 
0362+  1741 00 00 00 00 
0362+  1745 00 00 00 00 
0362+  1749 00 00 00 00 
0362+  174D 00 00 00 00 
0362+  1751 00 00 00 00 
0362+  1755 00 00 00 00 
0362+  1759 00 00 00 00 
0362+  175D 00 00 00 00 
0362+  1761 00 00 00 00 
0362+  1765 00 00 00 00 
0362+  1769 00 00 00 00 
2729   176D             
2730   176D             ; kernel parameters
2731   176D             sys_debug_mode:
2732   176D 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2733   176E             sys_echo_on:
2734   176E 01            .db 1
2735   176F             sys_uart0_lcr:
2736   176F 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2737   1770             sys_uart0_inten:
2738   1770 01            .db 1
2739   1771             sys_uart0_fifoen:
2740   1771 00            .db 0
2741   1772             sys_uart0_div0:
2742   1772 03            .db 3
2743   1773             sys_uart0_div1:
2744   1773 00            .db 0   ; default baud = 38400
2745   1774             ; baud  divisor
2746   1774             ; 50    2304
2747   1774             ; 110   1047
2748   1774             ; 300    384
2749   1774             ; 600    192
2750   1774             ; 1200    96
2751   1774             ; 9600    12
2752   1774             ; 19200    6
2753   1774             ; 38400    3
2754   1774             
2755   1774             nbr_active_procs:
2756   1774 00            .db 0
2757   1775             active_proc_index:
2758   1775 01            .db 1
2759   1776             
2760   1776             index:
2761   1776 00 00         .dw 0
2762   1778             buffer_addr:
2763   1778 00 00         .dw 0
2764   177A             
2765   177A             fifo_in:
2766   177A DB 1E         .dw fifo
2767   177C             fifo_out:
2768   177C DB 1E         .dw fifo
2769   177E             
2770   177E             ; file system variables
2771   177E             current_dir_id:
2772   177E 00 00         .dw 0     ; keep dirid of current directory
2773   1780             s_init_path:
2774   1780 2F 73 62 69   .db "/sbin/init", 0
2774   1784 6E 2F 69 6E 
2774   1788 69 74 00 
2775   178B             
2776   178B             s_uname:
2777   178B 73 6F 6C 61   .db "solarium v.1.0", 0
2777   178F 72 69 75 6D 
2777   1793 20 76 2E 31 
2777   1797 2E 30 00 
2778   179A             s_dataentry:
2779   179A 3E 20 00      .db "> ", 0
2780   179D             s_parent_dir:
2781   179D 2E 2E 00      .db "..", 0
2782   17A0             s_current_dir:
2783   17A0 2E 00         .db ".", 0
2784   17A2             s_fslash:
2785   17A2 2F 00         .db "/", 0
2786   17A4             file_attrib:
2787   17A4 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2787   17A8 78 
2788   17A9             file_type:
2789   17A9 2D 64 63      .db "-dc"
2790   17AC             s_ps_header:
2791   17AC 70 69 64 20   .db "pid command\n", 0
2791   17B0 63 6F 6D 6D 
2791   17B4 61 6E 64 0A 
2791   17B8 00 
2792   17B9             s_ls_total:
2793   17B9 74 6F 74 61   .db "total: ", 0
2793   17BD 6C 3A 20 00 
2794   17C1             
2795   17C1             s_int_en:
2796   17C1 69 72 71 73   .db "irqs enabled\n", 0
2796   17C5 20 65 6E 61 
2796   17C9 62 6C 65 64 
2796   17CD 0A 00 
2797   17CF             s_kernel_started:
2798   17CF 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2798   17D3 65 6C 20 73 
2798   17D7 74 61 72 74 
2798   17DB 65 64 28 76 
2798   17DF 65 72 73 69 
2798   17E3 6F 6E 20 31 
2798   17E7 2E 30 29 0A 
2798   17EB 00 
2799   17EC             s_prompt_init:
2800   17EC 73 74 61 72   .db "starting init\n", 0
2800   17F0 74 69 6E 67 
2800   17F4 20 69 6E 69 
2800   17F8 74 0A 00 
2801   17FB             s_priviledge:
2802   17FB 0A 65 78 63   .db "\nexception: privilege\n", 0
2802   17FF 65 70 74 69 
2802   1803 6F 6E 3A 20 
2802   1807 70 72 69 76 
2802   180B 69 6C 65 67 
2802   180F 65 0A 00 
2803   1812             s_divzero:
2804   1812 0A 65 78 63   .db "\nexception: zero division\n", 0
2804   1816 65 70 74 69 
2804   181A 6F 6E 3A 20 
2804   181E 7A 65 72 6F 
2804   1822 20 64 69 76 
2804   1826 69 73 69 6F 
2804   182A 6E 0A 00 
2805   182D             
2806   182D             s_set_year:
2807   182D 79 65 61 72   .db "year: ", 0
2807   1831 3A 20 00 
2808   1834             s_set_month:
2809   1834 6D 6F 6E 74   .db "month: ", 0
2809   1838 68 3A 20 00 
2810   183C             s_set_day:
2811   183C 64 61 79 3A   .db "day: ", 0
2811   1840 20 00 
2812   1842             s_set_week:
2813   1842 77 65 65 6B   .db "weekday: ", 0
2813   1846 64 61 79 3A 
2813   184A 20 00 
2814   184C             s_set_hours:
2815   184C 68 6F 75 72   .db "hours: ", 0
2815   1850 73 3A 20 00 
2816   1854             s_set_minutes:
2817   1854 6D 69 6E 75   .db "minutes: ", 0
2817   1858 74 65 73 3A 
2817   185C 20 00 
2818   185E             s_set_seconds:
2819   185E 73 65 63 6F   .db "seconds: ", 0
2819   1862 6E 64 73 3A 
2819   1866 20 00 
2820   1868             s_months:      
2821   1868 20 20 20 00   .db "   ", 0
2822   186C 6A 61 6E 00   .db "jan", 0
2823   1870 66 65 62 00   .db "feb", 0
2824   1874 6D 61 72 00   .db "mar", 0
2825   1878 61 70 72 00   .db "apr", 0
2826   187C 6D 61 79 00   .db "may", 0
2827   1880 6A 75 6E 00   .db "jun", 0
2828   1884 6A 75 6C 00   .db "jul", 0
2829   1888 61 75 67 00   .db "aug", 0
2830   188C 73 65 70 00   .db "sep", 0
2831   1890 6F 63 74 00   .db "oct", 0
2832   1894 6E 6F 76 00   .db "nov", 0
2833   1898 64 65 63 00   .db "dec", 0
2834   189C             
2835   189C             s_week:        
2836   189C 73 75 6E 00   .db "sun", 0 
2837   18A0 6D 6F 6E 00   .db "mon", 0 
2838   18A4 74 75 65 00   .db "tue", 0 
2839   18A8 77 65 64 00   .db "wed", 0 
2840   18AC 74 68 75 00   .db "thu", 0 
2841   18B0 66 72 69 00   .db "fri", 0 
2842   18B4 73 61 74 00   .db "sat", 0
2843   18B8             
2844   18B8 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
2844   18BC 30 20 45 78 
2844   18C0 65 63 75 74 
2844   18C4 65 64 2E 0A 
2844   18C8 00 
2845   18C9             s_fdc_config:
2846   18C9 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
2846   18CD 65 63 74 69 
2846   18D1 6E 67 20 64 
2846   18D5 69 73 6B 65 
2846   18D9 74 74 65 20 
2846   18DD 64 72 69 76 
2846   18E1 65 20 30 2C 
2846   18E5 20 73 69 64 
2846   18E9 65 20 30 2C 
2846   18ED 20 73 69 6E 
2846   18F1 67 6C 65 20 
2846   18F5 64 65 6E 73 
2846   18F9 69 74 79 2C 
2846   18FD 20 68 65 61 
2846   1901 64 20 6C 6F 
2846   1905 61 64 65 64 
2846   1909 0A 00 
2847   190B             
2848   190B             proc_state_table:   
2849   190B 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2849   190F 00 00 00 00 
2849   1913 00 00 00 00 
2849   1917 00 00 00 00 
2849   191B 00 00 00 00 
2849   191F 00 00 00 00 
2849   1923 00 00 00 00 
2849   1927 00 00 00 00 
2849   192B 00 00 00 00 
2849   192F 00 00 00 00 
2849   1933 00 00 00 00 
2849   1937 00 00 00 00 
2849   193B 00 00 00 00 
2849   193F 00 00 00 00 
2849   1943 00 00 00 00 
2849   1947 00 00 00 00 
2849   194B 00 00 00 00 
2849   194F 00 00 00 00 
2849   1953 00 00 00 00 
2849   1957 00 00 00 00 
2849   195B 00 00 00 00 
2849   195F 00 00 00 00 
2849   1963 00 00 00 00 
2849   1967 00 00 00 00 
2849   196B 00 00 00 00 
2849   196F 00 00 00 00 
2849   1973 00 00 00 00 
2849   1977 00 00 00 00 
2849   197B 00 00 00 00 
2849   197F 00 00 00 00 
2849   1983 00 00 00 00 
2849   1987 00 00 00 00 
2849   198B 00 00 00 00 
2849   198F 00 00 00 00 
2849   1993 00 00 00 00 
2849   1997 00 00 00 00 
2849   199B 00 00 00 00 
2849   199F 00 00 00 00 
2849   19A3 00 00 00 00 
2849   19A7 00 00 00 00 
2849   19AB 00 00 00 00 
2849   19AF 00 00 00 00 
2849   19B3 00 00 00 00 
2849   19B7 00 00 00 00 
2849   19BB 00 00 00 00 
2849   19BF 00 00 00 00 
2849   19C3 00 00 00 00 
2849   19C7 00 00 00 00 
2849   19CB 00 00 00 00 
2849   19CF 00 00 00 00 
2849   19D3 00 00 00 00 
2849   19D7 00 00 00 00 
2849   19DB 00 00 00 00 
2849   19DF 00 00 00 00 
2849   19E3 00 00 00 00 
2849   19E7 00 00 00 00 
2849   19EB 00 00 00 00 
2849   19EF 00 00 00 00 
2849   19F3 00 00 00 00 
2849   19F7 00 00 00 00 
2849   19FB 00 00 00 00 
2849   19FF 00 00 00 00 
2849   1A03 00 00 00 00 
2849   1A07 00 00 00 00 
2849   1A0B 00 00 00 00 
2849   1A0F 00 00 00 00 
2849   1A13 00 00 00 00 
2849   1A17 00 00 00 00 
2849   1A1B 00 00 00 00 
2849   1A1F 00 00 00 00 
2849   1A23 00 00 00 00 
2849   1A27 00 00 00 00 
2849   1A2B 00 00 00 00 
2849   1A2F 00 00 00 00 
2849   1A33 00 00 00 00 
2849   1A37 00 00 00 00 
2849   1A3B 00 00 00 00 
2849   1A3F 00 00 00 00 
2849   1A43 00 00 00 00 
2849   1A47 00 00 00 00 
2850   1A4B             proc_availab_table: 
2851   1A4B 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2851   1A4F 00 00 00 00 
2851   1A53 00 00 00 00 
2851   1A57 00 00 00 00 
2852   1A5B             proc_names:
2853   1A5B 00 00 00 00   .fill 16 * 32, 0  ; process names
2853   1A5F 00 00 00 00 
2853   1A63 00 00 00 00 
2853   1A67 00 00 00 00 
2853   1A6B 00 00 00 00 
2853   1A6F 00 00 00 00 
2853   1A73 00 00 00 00 
2853   1A77 00 00 00 00 
2853   1A7B 00 00 00 00 
2853   1A7F 00 00 00 00 
2853   1A83 00 00 00 00 
2853   1A87 00 00 00 00 
2853   1A8B 00 00 00 00 
2853   1A8F 00 00 00 00 
2853   1A93 00 00 00 00 
2853   1A97 00 00 00 00 
2853   1A9B 00 00 00 00 
2853   1A9F 00 00 00 00 
2853   1AA3 00 00 00 00 
2853   1AA7 00 00 00 00 
2853   1AAB 00 00 00 00 
2853   1AAF 00 00 00 00 
2853   1AB3 00 00 00 00 
2853   1AB7 00 00 00 00 
2853   1ABB 00 00 00 00 
2853   1ABF 00 00 00 00 
2853   1AC3 00 00 00 00 
2853   1AC7 00 00 00 00 
2853   1ACB 00 00 00 00 
2853   1ACF 00 00 00 00 
2853   1AD3 00 00 00 00 
2853   1AD7 00 00 00 00 
2853   1ADB 00 00 00 00 
2853   1ADF 00 00 00 00 
2853   1AE3 00 00 00 00 
2853   1AE7 00 00 00 00 
2853   1AEB 00 00 00 00 
2853   1AEF 00 00 00 00 
2853   1AF3 00 00 00 00 
2853   1AF7 00 00 00 00 
2853   1AFB 00 00 00 00 
2853   1AFF 00 00 00 00 
2853   1B03 00 00 00 00 
2853   1B07 00 00 00 00 
2853   1B0B 00 00 00 00 
2853   1B0F 00 00 00 00 
2853   1B13 00 00 00 00 
2853   1B17 00 00 00 00 
2853   1B1B 00 00 00 00 
2853   1B1F 00 00 00 00 
2853   1B23 00 00 00 00 
2853   1B27 00 00 00 00 
2853   1B2B 00 00 00 00 
2853   1B2F 00 00 00 00 
2853   1B33 00 00 00 00 
2853   1B37 00 00 00 00 
2853   1B3B 00 00 00 00 
2853   1B3F 00 00 00 00 
2853   1B43 00 00 00 00 
2853   1B47 00 00 00 00 
2853   1B4B 00 00 00 00 
2853   1B4F 00 00 00 00 
2853   1B53 00 00 00 00 
2853   1B57 00 00 00 00 
2853   1B5B 00 00 00 00 
2853   1B5F 00 00 00 00 
2853   1B63 00 00 00 00 
2853   1B67 00 00 00 00 
2853   1B6B 00 00 00 00 
2853   1B6F 00 00 00 00 
2853   1B73 00 00 00 00 
2853   1B77 00 00 00 00 
2853   1B7B 00 00 00 00 
2853   1B7F 00 00 00 00 
2853   1B83 00 00 00 00 
2853   1B87 00 00 00 00 
2853   1B8B 00 00 00 00 
2853   1B8F 00 00 00 00 
2853   1B93 00 00 00 00 
2853   1B97 00 00 00 00 
2853   1B9B 00 00 00 00 
2853   1B9F 00 00 00 00 
2853   1BA3 00 00 00 00 
2853   1BA7 00 00 00 00 
2853   1BAB 00 00 00 00 
2853   1BAF 00 00 00 00 
2853   1BB3 00 00 00 00 
2853   1BB7 00 00 00 00 
2853   1BBB 00 00 00 00 
2853   1BBF 00 00 00 00 
2853   1BC3 00 00 00 00 
2853   1BC7 00 00 00 00 
2853   1BCB 00 00 00 00 
2853   1BCF 00 00 00 00 
2853   1BD3 00 00 00 00 
2853   1BD7 00 00 00 00 
2853   1BDB 00 00 00 00 
2853   1BDF 00 00 00 00 
2853   1BE3 00 00 00 00 
2853   1BE7 00 00 00 00 
2853   1BEB 00 00 00 00 
2853   1BEF 00 00 00 00 
2853   1BF3 00 00 00 00 
2853   1BF7 00 00 00 00 
2853   1BFB 00 00 00 00 
2853   1BFF 00 00 00 00 
2853   1C03 00 00 00 00 
2853   1C07 00 00 00 00 
2853   1C0B 00 00 00 00 
2853   1C0F 00 00 00 00 
2853   1C13 00 00 00 00 
2853   1C17 00 00 00 00 
2853   1C1B 00 00 00 00 
2853   1C1F 00 00 00 00 
2853   1C23 00 00 00 00 
2853   1C27 00 00 00 00 
2853   1C2B 00 00 00 00 
2853   1C2F 00 00 00 00 
2853   1C33 00 00 00 00 
2853   1C37 00 00 00 00 
2853   1C3B 00 00 00 00 
2853   1C3F 00 00 00 00 
2853   1C43 00 00 00 00 
2853   1C47 00 00 00 00 
2853   1C4B 00 00 00 00 
2853   1C4F 00 00 00 00 
2853   1C53 00 00 00 00 
2853   1C57 00 00 00 00 
2854   1C5B             filename:
2855   1C5B 00 00 00 00   .fill 128, 0      ; holds a path for file search
2855   1C5F 00 00 00 00 
2855   1C63 00 00 00 00 
2855   1C67 00 00 00 00 
2855   1C6B 00 00 00 00 
2855   1C6F 00 00 00 00 
2855   1C73 00 00 00 00 
2855   1C77 00 00 00 00 
2855   1C7B 00 00 00 00 
2855   1C7F 00 00 00 00 
2855   1C83 00 00 00 00 
2855   1C87 00 00 00 00 
2855   1C8B 00 00 00 00 
2855   1C8F 00 00 00 00 
2855   1C93 00 00 00 00 
2855   1C97 00 00 00 00 
2855   1C9B 00 00 00 00 
2855   1C9F 00 00 00 00 
2855   1CA3 00 00 00 00 
2855   1CA7 00 00 00 00 
2855   1CAB 00 00 00 00 
2855   1CAF 00 00 00 00 
2855   1CB3 00 00 00 00 
2855   1CB7 00 00 00 00 
2855   1CBB 00 00 00 00 
2855   1CBF 00 00 00 00 
2855   1CC3 00 00 00 00 
2855   1CC7 00 00 00 00 
2855   1CCB 00 00 00 00 
2855   1CCF 00 00 00 00 
2855   1CD3 00 00 00 00 
2855   1CD7 00 00 00 00 
2856   1CDB             user_data:
2857   1CDB 00 00 00 00   .fill 512, 0      ;  user space data
2857   1CDF 00 00 00 00 
2857   1CE3 00 00 00 00 
2857   1CE7 00 00 00 00 
2857   1CEB 00 00 00 00 
2857   1CEF 00 00 00 00 
2857   1CF3 00 00 00 00 
2857   1CF7 00 00 00 00 
2857   1CFB 00 00 00 00 
2857   1CFF 00 00 00 00 
2857   1D03 00 00 00 00 
2857   1D07 00 00 00 00 
2857   1D0B 00 00 00 00 
2857   1D0F 00 00 00 00 
2857   1D13 00 00 00 00 
2857   1D17 00 00 00 00 
2857   1D1B 00 00 00 00 
2857   1D1F 00 00 00 00 
2857   1D23 00 00 00 00 
2857   1D27 00 00 00 00 
2857   1D2B 00 00 00 00 
2857   1D2F 00 00 00 00 
2857   1D33 00 00 00 00 
2857   1D37 00 00 00 00 
2857   1D3B 00 00 00 00 
2857   1D3F 00 00 00 00 
2857   1D43 00 00 00 00 
2857   1D47 00 00 00 00 
2857   1D4B 00 00 00 00 
2857   1D4F 00 00 00 00 
2857   1D53 00 00 00 00 
2857   1D57 00 00 00 00 
2857   1D5B 00 00 00 00 
2857   1D5F 00 00 00 00 
2857   1D63 00 00 00 00 
2857   1D67 00 00 00 00 
2857   1D6B 00 00 00 00 
2857   1D6F 00 00 00 00 
2857   1D73 00 00 00 00 
2857   1D77 00 00 00 00 
2857   1D7B 00 00 00 00 
2857   1D7F 00 00 00 00 
2857   1D83 00 00 00 00 
2857   1D87 00 00 00 00 
2857   1D8B 00 00 00 00 
2857   1D8F 00 00 00 00 
2857   1D93 00 00 00 00 
2857   1D97 00 00 00 00 
2857   1D9B 00 00 00 00 
2857   1D9F 00 00 00 00 
2857   1DA3 00 00 00 00 
2857   1DA7 00 00 00 00 
2857   1DAB 00 00 00 00 
2857   1DAF 00 00 00 00 
2857   1DB3 00 00 00 00 
2857   1DB7 00 00 00 00 
2857   1DBB 00 00 00 00 
2857   1DBF 00 00 00 00 
2857   1DC3 00 00 00 00 
2857   1DC7 00 00 00 00 
2857   1DCB 00 00 00 00 
2857   1DCF 00 00 00 00 
2857   1DD3 00 00 00 00 
2857   1DD7 00 00 00 00 
2857   1DDB 00 00 00 00 
2857   1DDF 00 00 00 00 
2857   1DE3 00 00 00 00 
2857   1DE7 00 00 00 00 
2857   1DEB 00 00 00 00 
2857   1DEF 00 00 00 00 
2857   1DF3 00 00 00 00 
2857   1DF7 00 00 00 00 
2857   1DFB 00 00 00 00 
2857   1DFF 00 00 00 00 
2857   1E03 00 00 00 00 
2857   1E07 00 00 00 00 
2857   1E0B 00 00 00 00 
2857   1E0F 00 00 00 00 
2857   1E13 00 00 00 00 
2857   1E17 00 00 00 00 
2857   1E1B 00 00 00 00 
2857   1E1F 00 00 00 00 
2857   1E23 00 00 00 00 
2857   1E27 00 00 00 00 
2857   1E2B 00 00 00 00 
2857   1E2F 00 00 00 00 
2857   1E33 00 00 00 00 
2857   1E37 00 00 00 00 
2857   1E3B 00 00 00 00 
2857   1E3F 00 00 00 00 
2857   1E43 00 00 00 00 
2857   1E47 00 00 00 00 
2857   1E4B 00 00 00 00 
2857   1E4F 00 00 00 00 
2857   1E53 00 00 00 00 
2857   1E57 00 00 00 00 
2857   1E5B 00 00 00 00 
2857   1E5F 00 00 00 00 
2857   1E63 00 00 00 00 
2857   1E67 00 00 00 00 
2857   1E6B 00 00 00 00 
2857   1E6F 00 00 00 00 
2857   1E73 00 00 00 00 
2857   1E77 00 00 00 00 
2857   1E7B 00 00 00 00 
2857   1E7F 00 00 00 00 
2857   1E83 00 00 00 00 
2857   1E87 00 00 00 00 
2857   1E8B 00 00 00 00 
2857   1E8F 00 00 00 00 
2857   1E93 00 00 00 00 
2857   1E97 00 00 00 00 
2857   1E9B 00 00 00 00 
2857   1E9F 00 00 00 00 
2857   1EA3 00 00 00 00 
2857   1EA7 00 00 00 00 
2857   1EAB 00 00 00 00 
2857   1EAF 00 00 00 00 
2857   1EB3 00 00 00 00 
2857   1EB7 00 00 00 00 
2857   1EBB 00 00 00 00 
2857   1EBF 00 00 00 00 
2857   1EC3 00 00 00 00 
2857   1EC7 00 00 00 00 
2857   1ECB 00 00 00 00 
2857   1ECF 00 00 00 00 
2857   1ED3 00 00 00 00 
2857   1ED7 00 00 00 00 
2858   1EDB             fifo:
2859   1EDB FF FF FF FF   .fill fifo_size
2859   1EDF FF FF FF FF 
2859   1EE3 FF FF FF FF 
2859   1EE7 FF FF FF FF 
2859   1EEB FF FF FF FF 
2859   1EEF FF FF FF FF 
2859   1EF3 FF FF FF FF 
2859   1EF7 FF FF FF FF 
2859   1EFB FF FF FF FF 
2859   1EFF FF FF FF FF 
2859   1F03 FF FF FF FF 
2859   1F07 FF FF FF FF 
2859   1F0B FF FF FF FF 
2859   1F0F FF FF FF FF 
2859   1F13 FF FF FF FF 
2859   1F17 FF FF FF FF 
2859   1F1B FF FF FF FF 
2859   1F1F FF FF FF FF 
2859   1F23 FF FF FF FF 
2859   1F27 FF FF FF FF 
2859   1F2B FF FF FF FF 
2859   1F2F FF FF FF FF 
2859   1F33 FF FF FF FF 
2859   1F37 FF FF FF FF 
2859   1F3B FF FF FF FF 
2859   1F3F FF FF FF FF 
2859   1F43 FF FF FF FF 
2859   1F47 FF FF FF FF 
2859   1F4B FF FF FF FF 
2859   1F4F FF FF FF FF 
2859   1F53 FF FF FF FF 
2859   1F57 FF FF FF FF 
2859   1F5B FF FF FF FF 
2859   1F5F FF FF FF FF 
2859   1F63 FF FF FF FF 
2859   1F67 FF FF FF FF 
2859   1F6B FF FF FF FF 
2859   1F6F FF FF FF FF 
2859   1F73 FF FF FF FF 
2859   1F77 FF FF FF FF 
2859   1F7B FF FF FF FF 
2859   1F7F FF FF FF FF 
2859   1F83 FF FF FF FF 
2859   1F87 FF FF FF FF 
2859   1F8B FF FF FF FF 
2859   1F8F FF FF FF FF 
2859   1F93 FF FF FF FF 
2859   1F97 FF FF FF FF 
2859   1F9B FF FF FF FF 
2859   1F9F FF FF FF FF 
2859   1FA3 FF FF FF FF 
2859   1FA7 FF FF FF FF 
2859   1FAB FF FF FF FF 
2859   1FAF FF FF FF FF 
2859   1FB3 FF FF FF FF 
2859   1FB7 FF FF FF FF 
2859   1FBB FF FF FF FF 
2859   1FBF FF FF FF FF 
2859   1FC3 FF FF FF FF 
2859   1FC7 FF FF FF FF 
2859   1FCB FF FF FF FF 
2859   1FCF FF FF FF FF 
2859   1FD3 FF FF FF FF 
2859   1FD7 FF FF FF FF 
2859   1FDB FF FF FF FF 
2859   1FDF FF FF FF FF 
2859   1FE3 FF FF FF FF 
2859   1FE7 FF FF FF FF 
2859   1FEB FF FF FF FF 
2859   1FEF FF FF FF FF 
2859   1FF3 FF FF FF FF 
2859   1FF7 FF FF FF FF 
2859   1FFB FF FF FF FF 
2859   1FFF FF FF FF FF 
2859   2003 FF FF FF FF 
2859   2007 FF FF FF FF 
2859   200B FF FF FF FF 
2859   200F FF FF FF FF 
2859   2013 FF FF FF FF 
2859   2017 FF FF FF FF 
2859   201B FF FF FF FF 
2859   201F FF FF FF FF 
2859   2023 FF FF FF FF 
2859   2027 FF FF FF FF 
2859   202B FF FF FF FF 
2859   202F FF FF FF FF 
2859   2033 FF FF FF FF 
2859   2037 FF FF FF FF 
2859   203B FF FF FF FF 
2859   203F FF FF FF FF 
2859   2043 FF FF FF FF 
2859   2047 FF FF FF FF 
2859   204B FF FF FF FF 
2859   204F FF FF FF FF 
2859   2053 FF FF FF FF 
2859   2057 FF FF FF FF 
2859   205B FF FF FF FF 
2859   205F FF FF FF FF 
2859   2063 FF FF FF FF 
2859   2067 FF FF FF FF 
2859   206B FF FF FF FF 
2859   206F FF FF FF FF 
2859   2073 FF FF FF FF 
2859   2077 FF FF FF FF 
2859   207B FF FF FF FF 
2859   207F FF FF FF FF 
2859   2083 FF FF FF FF 
2859   2087 FF FF FF FF 
2859   208B FF FF FF FF 
2859   208F FF FF FF FF 
2859   2093 FF FF FF FF 
2859   2097 FF FF FF FF 
2859   209B FF FF FF FF 
2859   209F FF FF FF FF 
2859   20A3 FF FF FF FF 
2859   20A7 FF FF FF FF 
2859   20AB FF FF FF FF 
2859   20AF FF FF FF FF 
2859   20B3 FF FF FF FF 
2859   20B7 FF FF FF FF 
2859   20BB FF FF FF FF 
2859   20BF FF FF FF FF 
2859   20C3 FF FF FF FF 
2859   20C7 FF FF FF FF 
2859   20CB FF FF FF FF 
2859   20CF FF FF FF FF 
2859   20D3 FF FF FF FF 
2859   20D7 FF FF FF FF 
2859   20DB FF FF FF FF 
2859   20DF FF FF FF FF 
2859   20E3 FF FF FF FF 
2859   20E7 FF FF FF FF 
2859   20EB FF FF FF FF 
2859   20EF FF FF FF FF 
2859   20F3 FF FF FF FF 
2859   20F7 FF FF FF FF 
2859   20FB FF FF FF FF 
2859   20FF FF FF FF FF 
2859   2103 FF FF FF FF 
2859   2107 FF FF FF FF 
2859   210B FF FF FF FF 
2859   210F FF FF FF FF 
2859   2113 FF FF FF FF 
2859   2117 FF FF FF FF 
2859   211B FF FF FF FF 
2859   211F FF FF FF FF 
2859   2123 FF FF FF FF 
2859   2127 FF FF FF FF 
2859   212B FF FF FF FF 
2859   212F FF FF FF FF 
2859   2133 FF FF FF FF 
2859   2137 FF FF FF FF 
2859   213B FF FF FF FF 
2859   213F FF FF FF FF 
2859   2143 FF FF FF FF 
2859   2147 FF FF FF FF 
2859   214B FF FF FF FF 
2859   214F FF FF FF FF 
2859   2153 FF FF FF FF 
2859   2157 FF FF FF FF 
2859   215B FF FF FF FF 
2859   215F FF FF FF FF 
2859   2163 FF FF FF FF 
2859   2167 FF FF FF FF 
2859   216B FF FF FF FF 
2859   216F FF FF FF FF 
2859   2173 FF FF FF FF 
2859   2177 FF FF FF FF 
2859   217B FF FF FF FF 
2859   217F FF FF FF FF 
2859   2183 FF FF FF FF 
2859   2187 FF FF FF FF 
2859   218B FF FF FF FF 
2859   218F FF FF FF FF 
2859   2193 FF FF FF FF 
2859   2197 FF FF FF FF 
2859   219B FF FF FF FF 
2859   219F FF FF FF FF 
2859   21A3 FF FF FF FF 
2859   21A7 FF FF FF FF 
2859   21AB FF FF FF FF 
2859   21AF FF FF FF FF 
2859   21B3 FF FF FF FF 
2859   21B7 FF FF FF FF 
2859   21BB FF FF FF FF 
2859   21BF FF FF FF FF 
2859   21C3 FF FF FF FF 
2859   21C7 FF FF FF FF 
2859   21CB FF FF FF FF 
2859   21CF FF FF FF FF 
2859   21D3 FF FF FF FF 
2859   21D7 FF FF FF FF 
2859   21DB FF FF FF FF 
2859   21DF FF FF FF FF 
2859   21E3 FF FF FF FF 
2859   21E7 FF FF FF FF 
2859   21EB FF FF FF FF 
2859   21EF FF FF FF FF 
2859   21F3 FF FF FF FF 
2859   21F7 FF FF FF FF 
2859   21FB FF FF FF FF 
2859   21FF FF FF FF FF 
2859   2203 FF FF FF FF 
2859   2207 FF FF FF FF 
2859   220B FF FF FF FF 
2859   220F FF FF FF FF 
2859   2213 FF FF FF FF 
2859   2217 FF FF FF FF 
2859   221B FF FF FF FF 
2859   221F FF FF FF FF 
2859   2223 FF FF FF FF 
2859   2227 FF FF FF FF 
2859   222B FF FF FF FF 
2859   222F FF FF FF FF 
2859   2233 FF FF FF FF 
2859   2237 FF FF FF FF 
2859   223B FF FF FF FF 
2859   223F FF FF FF FF 
2859   2243 FF FF FF FF 
2859   2247 FF FF FF FF 
2859   224B FF FF FF FF 
2859   224F FF FF FF FF 
2859   2253 FF FF FF FF 
2859   2257 FF FF FF FF 
2859   225B FF FF FF FF 
2859   225F FF FF FF FF 
2859   2263 FF FF FF FF 
2859   2267 FF FF FF FF 
2859   226B FF FF FF FF 
2859   226F FF FF FF FF 
2859   2273 FF FF FF FF 
2859   2277 FF FF FF FF 
2859   227B FF FF FF FF 
2859   227F FF FF FF FF 
2859   2283 FF FF FF FF 
2859   2287 FF FF FF FF 
2859   228B FF FF FF FF 
2859   228F FF FF FF FF 
2859   2293 FF FF FF FF 
2859   2297 FF FF FF FF 
2859   229B FF FF FF FF 
2859   229F FF FF FF FF 
2859   22A3 FF FF FF FF 
2859   22A7 FF FF FF FF 
2859   22AB FF FF FF FF 
2859   22AF FF FF FF FF 
2859   22B3 FF FF FF FF 
2859   22B7 FF FF FF FF 
2859   22BB FF FF FF FF 
2859   22BF FF FF FF FF 
2859   22C3 FF FF FF FF 
2859   22C7 FF FF FF FF 
2859   22CB FF FF FF FF 
2859   22CF FF FF FF FF 
2859   22D3 FF FF FF FF 
2859   22D7 FF FF FF FF 
2860   22DB             
2861   22DB             scrap_sector:
2862   22DB FF FF FF FF   .fill 512         ; scrap sector
2862   22DF FF FF FF FF 
2862   22E3 FF FF FF FF 
2862   22E7 FF FF FF FF 
2862   22EB FF FF FF FF 
2862   22EF FF FF FF FF 
2862   22F3 FF FF FF FF 
2862   22F7 FF FF FF FF 
2862   22FB FF FF FF FF 
2862   22FF FF FF FF FF 
2862   2303 FF FF FF FF 
2862   2307 FF FF FF FF 
2862   230B FF FF FF FF 
2862   230F FF FF FF FF 
2862   2313 FF FF FF FF 
2862   2317 FF FF FF FF 
2862   231B FF FF FF FF 
2862   231F FF FF FF FF 
2862   2323 FF FF FF FF 
2862   2327 FF FF FF FF 
2862   232B FF FF FF FF 
2862   232F FF FF FF FF 
2862   2333 FF FF FF FF 
2862   2337 FF FF FF FF 
2862   233B FF FF FF FF 
2862   233F FF FF FF FF 
2862   2343 FF FF FF FF 
2862   2347 FF FF FF FF 
2862   234B FF FF FF FF 
2862   234F FF FF FF FF 
2862   2353 FF FF FF FF 
2862   2357 FF FF FF FF 
2862   235B FF FF FF FF 
2862   235F FF FF FF FF 
2862   2363 FF FF FF FF 
2862   2367 FF FF FF FF 
2862   236B FF FF FF FF 
2862   236F FF FF FF FF 
2862   2373 FF FF FF FF 
2862   2377 FF FF FF FF 
2862   237B FF FF FF FF 
2862   237F FF FF FF FF 
2862   2383 FF FF FF FF 
2862   2387 FF FF FF FF 
2862   238B FF FF FF FF 
2862   238F FF FF FF FF 
2862   2393 FF FF FF FF 
2862   2397 FF FF FF FF 
2862   239B FF FF FF FF 
2862   239F FF FF FF FF 
2862   23A3 FF FF FF FF 
2862   23A7 FF FF FF FF 
2862   23AB FF FF FF FF 
2862   23AF FF FF FF FF 
2862   23B3 FF FF FF FF 
2862   23B7 FF FF FF FF 
2862   23BB FF FF FF FF 
2862   23BF FF FF FF FF 
2862   23C3 FF FF FF FF 
2862   23C7 FF FF FF FF 
2862   23CB FF FF FF FF 
2862   23CF FF FF FF FF 
2862   23D3 FF FF FF FF 
2862   23D7 FF FF FF FF 
2862   23DB FF FF FF FF 
2862   23DF FF FF FF FF 
2862   23E3 FF FF FF FF 
2862   23E7 FF FF FF FF 
2862   23EB FF FF FF FF 
2862   23EF FF FF FF FF 
2862   23F3 FF FF FF FF 
2862   23F7 FF FF FF FF 
2862   23FB FF FF FF FF 
2862   23FF FF FF FF FF 
2862   2403 FF FF FF FF 
2862   2407 FF FF FF FF 
2862   240B FF FF FF FF 
2862   240F FF FF FF FF 
2862   2413 FF FF FF FF 
2862   2417 FF FF FF FF 
2862   241B FF FF FF FF 
2862   241F FF FF FF FF 
2862   2423 FF FF FF FF 
2862   2427 FF FF FF FF 
2862   242B FF FF FF FF 
2862   242F FF FF FF FF 
2862   2433 FF FF FF FF 
2862   2437 FF FF FF FF 
2862   243B FF FF FF FF 
2862   243F FF FF FF FF 
2862   2443 FF FF FF FF 
2862   2447 FF FF FF FF 
2862   244B FF FF FF FF 
2862   244F FF FF FF FF 
2862   2453 FF FF FF FF 
2862   2457 FF FF FF FF 
2862   245B FF FF FF FF 
2862   245F FF FF FF FF 
2862   2463 FF FF FF FF 
2862   2467 FF FF FF FF 
2862   246B FF FF FF FF 
2862   246F FF FF FF FF 
2862   2473 FF FF FF FF 
2862   2477 FF FF FF FF 
2862   247B FF FF FF FF 
2862   247F FF FF FF FF 
2862   2483 FF FF FF FF 
2862   2487 FF FF FF FF 
2862   248B FF FF FF FF 
2862   248F FF FF FF FF 
2862   2493 FF FF FF FF 
2862   2497 FF FF FF FF 
2862   249B FF FF FF FF 
2862   249F FF FF FF FF 
2862   24A3 FF FF FF FF 
2862   24A7 FF FF FF FF 
2862   24AB FF FF FF FF 
2862   24AF FF FF FF FF 
2862   24B3 FF FF FF FF 
2862   24B7 FF FF FF FF 
2862   24BB FF FF FF FF 
2862   24BF FF FF FF FF 
2862   24C3 FF FF FF FF 
2862   24C7 FF FF FF FF 
2862   24CB FF FF FF FF 
2862   24CF FF FF FF FF 
2862   24D3 FF FF FF FF 
2862   24D7 FF FF FF FF 
2863   24DB             transient_area:
2864   24DB 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2865   24DC             
2866   24DC             .end
tasm: Number of errors = 0
