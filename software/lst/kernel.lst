0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; For the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; FILE ENTRY ATTRIBUTES
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0107   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0108   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0109   0000             FST_NBR_DIRECTORIES     .equ 64
0110   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0112   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0113   0000             FST_LBA_START           .equ 32
0114   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0115   0000             
0116   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0117   0000             FS_SECTORS_PER_FILE     .equ 32 ; the first sector is always a header with a NULL parameter (first byte)
0118   0000                                             ; so that we know which blocks are free or taken
0119   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0120   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0121   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0122   0000             FS_LBA_END              .equ (FS_LBA_START + FS_TOTAL_SECTORS - 1)
0123   0000             
0124   0000             root_id:                .equ FST_LBA_START
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; GLOBAL SYSTEM VARIABLES
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; IRQ table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 48 00       .dw int_1
0136   0004 49 00       .dw int_2
0137   0006 4A 00       .dw int_3
0138   0008 4B 00       .dw int_4
0139   000A 4C 00       .dw int_5
0140   000C 5E 00       .dw int_6
0141   000E AA 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 94 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 8C 02       .dw trap_privilege
0153   0014 A9 03       .dw trap_div_zero
0154   0016 B6 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 98 02       .dw syscall_break
0165   0022 B7 03       .dw syscall_rtc
0166   0024 F1 04       .dw syscall_ide
0167   0026 CC 05       .dw syscall_io
0168   0028 89 06       .dw syscall_file_system
0169   002A E1 0F       .dw syscall_create_proc
0170   002C 51 02       .dw syscall_list_procs
0171   002E E9 03       .dw syscall_datetime
0172   0030 0D 02       .dw syscall_reboot
0173   0032 AB 0F       .dw syscall_pause_proc
0174   0034 19 02       .dw syscall_resume_proc
0175   0036 68 0F       .dw syscall_terminate_proc
0176   0038 E9 00       .dw syscall_system
0177   003A 25 01       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; IRQs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" Floppy Drive Controller IRQ
0220   003C             int_0_fdc:
0221   003C 3B 4D 00      mov d, s_fdc_irq
0222   003F 07 DE 12      call _puts
0223   0042 19 01         mov al, 1
0224   0044 3D 94 1B      mov [fdc_irq_event], al
0225   0047 06            sysret
0226   0048             int_1:
0227   0048 06            sysret
0228   0049             int_2:
0229   0049 06            sysret
0230   004A             int_3:
0231   004A 06            sysret
0232   004B             int_4:
0233   004B 06            sysret
0234   004C             int_5:
0235   004C 06            sysret
0236   004D             
0237   004D 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0237   0051 30 20 45 78 
0237   0055 65 63 75 74 
0237   0059 65 64 2E 0A 
0237   005D 00 
0238   005E             
0239   005E             ; ------------------------------------------------------------------------------------------------------------------;
0240   005E             ; process swapping
0241   005E             ; ------------------------------------------------------------------------------------------------------------------;
0242   005E             int_6:  
0243   005E 4B            pusha                             ; save all registers into kernel stack
0244   005F 22 00         mov ah, 0
0245   0061 1D 0F 18      mov al, [active_proc_index]
0246   0064 FD 99         shl a                             ; x2
0247   0066 B7 5E 10      mov a, [proc_table_convert + a]   ; get process state start index
0248   0069 4F            mov di, a
0249   006A 48            mov a, sp
0250   006B 77            inc a
0251   006C 4D            mov si, a
0252   006D 38 14 00      mov c, 20
0253   0070 FD F5         rep movsb                         ; save process state!
0254   0072             ; restore kernel stack position to point before interrupt arrived
0255   0072 51 14 00      add sp, 20
0256   0075             ; now load next process in queue
0257   0075 1D 0F 18      mov al, [active_proc_index]
0258   0078 31 0E 18      mov bl, [nbr_active_procs]
0259   007B BA            cmp al, bl
0260   007C C6 83 00      je int6_cycle_back
0261   007F 7A            inc al                            ; next process is next in the series
0262   0080 0A 85 00      jmp int6_continue
0263   0083             int6_cycle_back:
0264   0083 19 01         mov al, 1                         ; next process = process 1
0265   0085             int6_continue:
0266   0085 3D 0F 18      mov [active_proc_index], al       ; set next active proc
0267   0088             
0268   0088             ; calculate LUT entry for next process
0269   0088 22 00         mov ah, 0
0270   008A FD 99         shl a                             ; x2
0271   008C B7 5E 10      mov a, [proc_table_convert + a]   ; get process state start index  
0272   008F               
0273   008F 4D            mov si, a                         ; source is proc state block
0274   0090 48            mov a, sp
0275   0091 5F 13 00      sub a, 19
0276   0094 4F            mov di, a                         ; destination is kernel stack
0277   0095             ; restore SP
0278   0095 7D            dec a
0279   0096 47            mov sp, a
0280   0097 38 14 00      mov c, 20
0281   009A FD F5         rep movsb
0282   009C             ; set VM process
0283   009C 1D 0F 18      mov al, [active_proc_index]
0284   009F 01            setptb
0285   00A0 F2 E0 FF 00   mov byte[_TIMER_C_0], 0           ; load counter 0 low byte
0286   00A4 F2 E0 FF 10   mov byte[_TIMER_C_0], $10         ; load counter 0 high byte
0287   00A8 4C            popa
0288   00A9 06            sysret
0289   00AA             
0290   00AA             ; ------------------------------------------------------------------------------------------------------------------;
0291   00AA             ; UART0 Interrupt
0292   00AA             ; ------------------------------------------------------------------------------------------------------------------;
0293   00AA             int_7_uart0:
0294   00AA D7            push a
0295   00AB DA            push d
0296   00AC E1            pushf
0297   00AD 14 14 18      mov a, [fifo_in]
0298   00B0 3C            mov d, a
0299   00B1 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0300   00B4 B9 03         cmp al, $03                 ; CTRL-C
0301   00B6 C6 D3 00      je CTRLC
0302   00B9 B9 1A         cmp al, $1A                 ; CTRL-Z
0303   00BB C6 D9 00      je CTRLZ
0304   00BE 3E            mov [d], al                 ; add to fifo
0305   00BF 14 14 18      mov a, [fifo_in]
0306   00C2 77            inc a
0307   00C3 AF 65 25      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0308   00C6 C7 CC 00      jne int_7_continue
0309   00C9 10 65 21      mov a, fifo  
0310   00CC             int_7_continue:  
0311   00CC 42 14 18      mov [fifo_in], a            ; update fifo pointer
0312   00CF EE            popf
0313   00D0 E7            pop d
0314   00D1 E4            pop a  
0315   00D2 06            sysret
0316   00D3             CTRLC:
0317   00D3 51 05 00      add sp, 5
0318   00D6 0A 68 0F      jmp syscall_terminate_proc
0319   00D9             CTRLZ:
0320   00D9 EE            popf
0321   00DA E7            pop d
0322   00DB E4            pop a
0323   00DC 0A AB 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0324   00DF             
0325   00DF             ; ------------------------------------------------------------------------------------------------------------------;
0326   00DF             ; system syscalls
0327   00DF             ; ------------------------------------------------------------------------------------------------------------------;
0328   00DF             system_jmptbl:
0329   00DF 15 01         .dw system_uname
0330   00E1 1C 01         .dw system_whoami
0331   00E3 EF 00         .dw system_setparam
0332   00E5 F2 00         .dw system_bootloader_install
0333   00E7 ED 00         .dw system_getparam
0334   00E9             syscall_system:
0335   00E9 FD 0A DF 00   jmp [system_jmptbl + al]
0336   00ED             
0337   00ED             ; param register address in register d
0338   00ED             ; param value in register bl
0339   00ED             system_getparam:
0340   00ED 32            mov bl, [d]
0341   00EE 06            sysret
0342   00EF             
0343   00EF             ; param register address in register d
0344   00EF             ; param value in register bl
0345   00EF             system_setparam:
0346   00EF FD 3E         mov [d], bl
0347   00F1 06            sysret
0348   00F2             
0349   00F2             ; kernel LBA address in 'b'
0350   00F2             system_bootloader_install:
0351   00F2 D8            push b
0352   00F3 26 00 00      mov b, 0
0353   00F6 38 00 00      mov c, 0
0354   00F9 22 01         mov ah, $01                 ; 1 sector
0355   00FB 3B 65 27      mov d, transient_area
0356   00FE 07 3B 05      call ide_read_sect          ; read sector
0357   0101 E5            pop b
0358   0102 FD 44 FE 01   mov [d + 510], b            ; update LBA address
0359   0106 26 00 00      mov b, 0
0360   0109 38 00 00      mov c, 0
0361   010C 22 01         mov ah, $01                 ; 1 sector
0362   010E 3B 65 27      mov d, transient_area
0363   0111 07 61 05      call ide_write_sect         ; write sector
0364   0114 06            sysret
0365   0115             
0366   0115             system_uname:
0367   0115 3B 25 18      mov d, s_uname
0368   0118 07 DE 12      call _puts
0369   011B 06            sysret
0370   011C             
0371   011C             system_whoami:
0372   011C 06            sysret
0373   011D             
0374   011D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0375   011D             ; floppy drive system calls
0376   011D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0377   011D             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0378   011D             ; fdc_40_FF:
0379   011D             ;   .fill 40,  $FF    ; or 00                                                                                
0380   011D             ; fdc_128_format_inner:
0381   011D             ;   .fill 6,   $00    ;                                                                            <--|        
0382   011D             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0383   011D             ;   .fill 1,   $00    ; Track Number  0 thru 76(4C)                                                   |                    
0384   011D             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0385   011D             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0386   011D             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0387   011D             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0388   011D             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0389   011D             ;   .fill 6,   $00    ;                                                                               |                        
0390   011D             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0391   011D             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0392   011D             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0393   011D             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0394   011D             ; fdc_128_format_end:
0395   011D             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0396   011D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0397   011D             ; _FDC_CONFIG       .equ $FFC0 
0398   011D             ; _FDC_STATUS_1     .equ $FFC1
0399   011D             ; _FDC_WD_STAT_CMD  .equ $FFC8
0400   011D             ; _FDC_WD_TRACK     .equ $FFC9
0401   011D             ; _FDC_WD_SECTOR    .equ $FFCA
0402   011D             ; _FDC_WD_DATA      .equ $FFCB
0403   011D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0404   011D             fdc_jmptbl:
0405   011D 42 01         .dw syscall_fdc_format
0406   011F 29 01         .dw syscall_fdc_status1
0407   0121 33 01         .dw syscall_fdc_status2
0408   0123 3D 01         .dw syscall_fdc_cmd
0409   0125             syscall_fdc:
0410   0125 FD 0A 1D 01   jmp [fdc_jmptbl + al]
0411   0129             ; bl: status
0412   0129             syscall_fdc_status1:
0413   0129 3B FF 01      mov d, s_fdc_status
0414   012C 07 DE 12      call _puts
0415   012F 31 C8 FF      mov bl, [_FDC_WD_STAT_CMD]
0416   0132 06            sysret
0417   0133             ; bl: status
0418   0133             syscall_fdc_status2:
0419   0133 3B FF 01      mov d, s_fdc_status
0420   0136 07 DE 12      call _puts
0421   0139 31 C1 FF      mov bl, [_FDC_STATUS_1]
0422   013C 06            sysret
0423   013D             ; issue a fdc command
0424   013D             ; bl: command
0425   013D             syscall_fdc_cmd:
0426   013D FD 3D C8 FF   mov [_FDC_WD_STAT_CMD], bl
0427   0141 06            sysret
0428   0142             
0429   0142             ; bl: track number
0430   0142             syscall_fdc_format:
0431   0142 FD 3D 81 19   mov [fdc_128_format_track], bl  ; write track number to formatting data block
0432   0146 19 00         mov al, 0
0433   0148 3D 83 19      mov [fdc_128_format_sect], al   ; reset sector variable to 0
0434   014B 19 80         mov al, %10000000               ; mask out fdc interrupt for now because we are trying to format without using irqs. an irq would consume too much time during formatting
0435   014D FD 0F         stomsk                        
0436   014F 3B D3 01      mov d, s_format_begin
0437   0152 07 DE 12      call _puts
0438   0155             fdc_header_loop_start:
0439   0155 3A 28         mov cl, 40
0440   0157 2E FF         mov bl, $FF                     ; load format byte
0441   0159 19 F6         mov al, %11110110               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0442   015B 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0443   015E             ; write the first data block for formatting which is 40 bytes of 0xFF:
0444   015E 07 B1 01      call fdc_wait_64us              ; after issuing write track command, need to wait 64us before reading the status register 
0445   0161             fdc_drq_loop: ; for each byte, we need to wait for DRQ to be high
0446   0161 1D C1 FF      mov al, [_FDC_STATUS_1]
0447   0164 87 01         and al, $01                ; check drq bit
0448   0166 C6 61 01      jz fdc_drq_loop
0449   0169 FD 3D CB FF   mov [_FDC_WD_DATA], bl     ; send data byte to wd1770
0450   016D 81            dec cl
0451   016E C7 61 01      jnz fdc_drq_loop
0452   0171             ; start inner data block loop. this block is written 16 times
0453   0171             fdc_inner_loop:
0454   0171 FD 4D 7A 19   mov si, fdc_128_format_inner
0455   0175 3A A9         mov cl, 169                 ; the inner format data block has 169 bytes total
0456   0177             fdc_drq_loop1:
0457   0177 1D C1 FF      mov al, [_FDC_STATUS_1]
0458   017A 87 01         and al, $01                ; check drq bit
0459   017C C6 77 01      jz fdc_drq_loop1
0460   017F F6            lodsb                      ; load format byte
0461   0180 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0462   0183 81            dec cl
0463   0184 C7 77 01      jnz fdc_drq_loop1          ; test whether entire data block was written
0464   0187 1D 83 19      mov al, [fdc_128_format_sect] ; update the sector number variable in the format data block
0465   018A 7A            inc al
0466   018B B9 10         cmp al, 16
0467   018D C7 71 01      jne fdc_inner_loop         ; test whether data block was written 16 times
0468   0190             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0469   0190             fdc_format_footer:
0470   0190 2E FF         mov bl, $FF                ; load format byte
0471   0192             fdc_footer_drq_loop:
0472   0192 1D C1 FF      mov al, [_FDC_STATUS_1]
0473   0195 87 01         and al, $01                ; check drq bit
0474   0197 C6 92 01      jz fdc_footer_drq_loop
0475   019A FD 3D CB FF   mov [_FDC_WD_DATA], bl     ; send data byte to wd1770
0476   019E 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]
0477   01A1 87 01         and al, $01                ; check busy bit
0478   01A3 C7 92 01      jnz fdc_footer_drq_loop    ; if busy == 1, command is not finished, so loop again
0479   01A6             fdc_format_done:
0480   01A6 3B EC 01      mov d, s_format_done
0481   01A9 07 DE 12      call _puts
0482   01AC 19 FF         mov al, $FF           ; re-enable all irqs
0483   01AE FD 0F         stomsk                        
0484   01B0 06            sysret
0485   01B1             
0486   01B1             ; fetch is 2 cycles long when 'display_reg_load' is false.
0487   01B1             ; mov cl, 14 is 5 cycles long (2 to fetch, and 3 execution)
0488   01B1             ; 64us amounts to 160 cycles of the 2.5MHz clock
0489   01B1             ; so we need to wait for 155 cycles after mov cl, 14
0490   01B1             ; and since dec cl, and jnz amount to 11 cycles, we need to loop there 14 times: 14*11 = 154
0491   01B1             ; and 154 + 5 = 159
0492   01B1             fdc_wait_64us:
0493   01B1 3A 0E         mov cl, 14                       ; 5 cycles
0494   01B3             fdc_wait_64_loop:
0495   01B3 81            dec cl                           ; 3 cycles
0496   01B4 C7 B3 01      jnz fdc_wait_64_loop             ; 8 cycles
0497   01B7 09            ret
0498   01B8             
0499   01B8 0A 73 65 6E s_send_write_cmd: .db "\nsending write command...\n", 0
0499   01BC 64 69 6E 67 
0499   01C0 20 77 72 69 
0499   01C4 74 65 20 63 
0499   01C8 6F 6D 6D 61 
0499   01CC 6E 64 2E 2E 
0499   01D0 2E 0A 00 
0500   01D3 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0500   01D7 6D 61 74 74 
0500   01DB 69 6E 67 20 
0500   01DF 73 74 61 72 
0500   01E3 74 69 6E 67 
0500   01E7 2E 2E 2E 0A 
0500   01EB 00 
0501   01EC 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0501   01F0 6D 61 74 74 
0501   01F4 69 6E 67 20 
0501   01F8 64 6F 6E 65 
0501   01FC 2E 0A 00 
0502   01FF 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0502   0203 20 73 74 61 
0502   0207 74 75 73 3A 
0502   020B 20 00 
0503   020D             
0504   020D             ; REBOOT SYSTEM
0505   020D             syscall_reboot:
0506   020D FD D7 FF FF   push word $FFFF 
0507   0211 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0508   0214 FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0509   0218 06            sysret
0510   0219             
0511   0219             ;------------------------------------------------------------------------------------------------------;;
0512   0219             ; switch to another process
0513   0219             ; inputs:
0514   0219             ; AL = new process number
0515   0219             ;------------------------------------------------------------------------------------------------------;;
0516   0219             syscall_resume_proc:
0517   0219 FD 78         mov g, a                            ; save the process number
0518   021B 4B            pusha                               ; save all registers into kernel stack
0519   021C 22 00         mov ah, 0
0520   021E 1D 0F 18      mov al, [active_proc_index]
0521   0221 FD 99         shl a              ; x2
0522   0223 B7 5E 10      mov a, [proc_table_convert + a]     ; get process state start index
0523   0226 4F            mov di, a
0524   0227 48            mov a, sp
0525   0228 77            inc a
0526   0229 4D            mov si, a
0527   022A 38 14 00      mov c, 20
0528   022D FD F5         rep movsb                           ; save process state!
0529   022F             ; restore kernel stack position to point before interrupt arrived
0530   022F 51 14 00      add sp, 20
0531   0232             ; now load the new process number!
0532   0232 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0533   0234 3D 0F 18      mov [active_proc_index], al         ; set new active proc
0534   0237             ; calculate LUT entry for next process
0535   0237 22 00         mov ah, 0
0536   0239 FD 99         shl a                               ; x2
0537   023B B7 5E 10      mov a, [proc_table_convert + a]     ; get process state start index  
0538   023E 4D            mov si, a                           ; source is proc state block
0539   023F 48            mov a, sp
0540   0240 5F 13 00      sub a, 19
0541   0243 4F            mov di, a                           ; destination is kernel stack
0542   0244             ; restore SP
0543   0244 7D            dec a
0544   0245 47            mov sp, a
0545   0246 38 14 00      mov c, 20
0546   0249 FD F5         rep movsb
0547   024B             ; set VM process
0548   024B 1D 0F 18      mov al, [active_proc_index]
0549   024E 01            setptb
0550   024F 4C            popa
0551   0250 06            sysret
0552   0251             
0553   0251             ;------------------------------------------------------------------------------------------------------;;
0554   0251             ; list processes
0555   0251             ;------------------------------------------------------------------------------------------------------;;
0556   0251             syscall_list_procs:
0557   0251 3B 46 18      mov d, s_ps_header
0558   0254 07 DE 12      call _puts
0559   0257 3B D6 1C      mov d, proc_availab_table + 1
0560   025A 38 01 00      mov c, 1
0561   025D             list_procs_L0:  
0562   025D BD 01         cmp byte[d], 1
0563   025F C7 83 02      jne list_procs_next
0564   0262 2D            mov b, d
0565   0263 61 D5 1C      sub b, proc_availab_table
0566   0266 FD 9F 05      shl b, 5
0567   0269 DA            push d
0568   026A D8            push b
0569   026B 28            mov b, c
0570   026C 07 7E 13      call print_u8x
0571   026F 22 20         mov ah, ' '
0572   0271 07 B2 11      call _putchar
0573   0274 07 B2 11      call _putchar
0574   0277 E5            pop b
0575   0278 74            mov d, b
0576   0279 58 E5 1C      add d, proc_names
0577   027C 07 DE 12      call _puts
0578   027F 07 8B 12      call printnl
0579   0282 E7            pop d
0580   0283             list_procs_next:
0581   0283 79            inc d
0582   0284 78            inc c
0583   0285 C2 09 00      cmp c, 9
0584   0288 C7 5D 02      jne list_procs_L0
0585   028B             list_procs_end:
0586   028B 06            sysret
0587   028C             
0588   028C             ; ------------------------------------------------------------------------------------------------------------------;
0589   028C             ; exceptions code block
0590   028C             ; ------------------------------------------------------------------------------------------------------------------;
0591   028C             ; privilege exception
0592   028C             ; ------------------------------------------------------------------------------------------------------------------;
0593   028C             trap_privilege:
0594   028C 0A 0D 02      jmp syscall_reboot
0595   028F DA            push d
0596   0290 3B 95 18      mov d, s_priviledge
0597   0293 07 DE 12      call _puts
0598   0296 E7            pop d
0599   0297 06            sysret
0600   0298             
0601   0298             ; ------------------------------------------------------------------------------------------------------------------;
0602   0298             ; breakpoint
0603   0298             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0604   0298             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0605   0298             ; ------------------------------------------------------------------------------------------------------------------;
0606   0298             syscall_break:
0607   0298 4B            pusha
0608   0299             syscall_break_prompt:
0609   0299 3B 53 03      mov d, s_break1
0610   029C 07 DE 12      call _puts
0611   029F 07 8B 12      call printnl
0612   02A2 07 E0 13      call scan_u16d
0613   02A5 AF 00 00      cmp a, 0
0614   02A8 C6 B3 02      je syscall_break_regs
0615   02AB AF 01 00      cmp a, 1
0616   02AE C6 D6 02      je syscall_break_mem
0617   02B1             syscall_break_end:  
0618   02B1 4C            popa
0619   02B2 06            sysret
0620   02B3             syscall_break_regs:
0621   02B3 48            mov a, sp
0622   02B4 53 0E 00      add a, 14               ; back-track 7 registers
0623   02B7 3C            mov d, a
0624   02B8 3A 07         mov cl, 7
0625   02BA             syscall_regs_L0:
0626   02BA 2A            mov b, [d]
0627   02BB FD AB         swp b
0628   02BD 07 3A 13      call print_u16x         ; print register value
0629   02C0 07 8B 12      call printnl
0630   02C3 63 02 00      sub d, 2
0631   02C6 71 01         sub cl, 1
0632   02C8 C3 00         cmp cl, 0
0633   02CA C7 BA 02      jne syscall_regs_L0
0634   02CD 0A 99 02      jmp syscall_break_prompt
0635   02D0 07 8B 12      call printnl
0636   02D3 0A 99 02      jmp syscall_break_prompt
0637   02D6             syscall_break_mem:
0638   02D6 07 8B 12      call printnl
0639   02D9 07 5C 13      call scan_u16x
0640   02DC 4D            mov si, a               ; data source from user space
0641   02DD FD 4F 65 25   mov di, scrap_sector    ; destination in kernel space
0642   02E1 38 00 02      mov c, 512
0643   02E4 04            load                    ; transfer data to kernel space!
0644   02E5 3B 65 25      mov d, scrap_sector     ; dump pointer in d
0645   02E8 38 00 00      mov c, 0
0646   02EB             dump_loop:
0647   02EB 84            mov al, cl
0648   02EC 87 0F         and al, $0F
0649   02EE C6 3C 03      jz print_base
0650   02F1             back:
0651   02F1 1E            mov al, [d]             ; read byte
0652   02F2 2F            mov bl, al
0653   02F3 07 7E 13      call print_u8x
0654   02F6 10 00 20      mov a, $2000
0655   02F9 05 03         syscall sys_io          ; space
0656   02FB 84            mov al, cl
0657   02FC 87 0F         and al, $0F
0658   02FE B9 0F         cmp al, $0F
0659   0300 C6 11 03      je print_ascii
0660   0303             back1:
0661   0303 79            inc d
0662   0304 78            inc c
0663   0305 C2 00 02      cmp c, 512
0664   0308 C7 EB 02      jne dump_loop
0665   030B 07 8B 12      call printnl
0666   030E 0A 99 02      jmp syscall_break_prompt  ; go to syscall_break return point
0667   0311             print_ascii:
0668   0311 10 00 20      mov a, $2000
0669   0314 05 03         syscall sys_io
0670   0316 63 10 00      sub d, 16
0671   0319 26 10 00      mov b, 16
0672   031C             print_ascii_L:
0673   031C 79            inc d
0674   031D 1E            mov al, [d]               ; read byte
0675   031E B9 20         cmp al, $20
0676   0320 C8 28 03      jlu dot
0677   0323 B9 7E         cmp al, $7E
0678   0325 D0 30 03      jleu ascii
0679   0328             dot:
0680   0328 10 00 2E      mov a, $2E00
0681   032B 05 03         syscall sys_io
0682   032D 0A 35 03      jmp ascii_continue
0683   0330             ascii:
0684   0330 23            mov ah, al
0685   0331 19 00         mov al, 0
0686   0333 05 03         syscall sys_io
0687   0335             ascii_continue:
0688   0335 FD A9 1C 03   loopb print_ascii_L
0689   0339 0A 03 03      jmp back1
0690   033C             print_base:
0691   033C 07 8B 12      call printnl
0692   033F 2D            mov b, d
0693   0340 61 65 25      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0694   0343 07 3A 13      call print_u16x          ; display row
0695   0346 10 00 3A      mov a, $3A00
0696   0349 05 03         syscall sys_io
0697   034B 10 00 20      mov a, $2000
0698   034E 05 03         syscall sys_io
0699   0350 0A F1 02      jmp back
0700   0353             
0701   0353             s_break1:  
0702   0353 0A 44 65 62   .db "\nDebugger entry point.\n"
0702   0357 75 67 67 65 
0702   035B 72 20 65 6E 
0702   035F 74 72 79 20 
0702   0363 70 6F 69 6E 
0702   0367 74 2E 0A 
0703   036A 30 2E 20 53   .db "0. Show Registers\n"
0703   036E 68 6F 77 20 
0703   0372 52 65 67 69 
0703   0376 73 74 65 72 
0703   037A 73 0A 
0704   037C 31 2E 20 53   .db "1. Show 512B RAM block\n"
0704   0380 68 6F 77 20 
0704   0384 35 31 32 42 
0704   0388 20 52 41 4D 
0704   038C 20 62 6C 6F 
0704   0390 63 6B 0A 
0705   0393 32 2E 20 43   .db "2. Continue Execution", 0
0705   0397 6F 6E 74 69 
0705   039B 6E 75 65 20 
0705   039F 45 78 65 63 
0705   03A3 75 74 69 6F 
0705   03A7 6E 00 
0706   03A9             
0707   03A9             ; ------------------------------------------------------------------------------------------------------------------;
0708   03A9             ; divide by zero exception
0709   03A9             ; ------------------------------------------------------------------------------------------------------------------;
0710   03A9             trap_div_zero:
0711   03A9 D7            push a
0712   03AA DA            push d
0713   03AB E1            pushf
0714   03AC 3B AC 18      mov d, s_divzero
0715   03AF 07 DE 12      call _puts
0716   03B2 EE            popf
0717   03B3 E7            pop d
0718   03B4 E4            pop a
0719   03B5 06            sysret ; enable interrupts
0720   03B6             
0721   03B6             ; ------------------------------------------------------------------------------------------------------------------;
0722   03B6             ; undefined opcode exception
0723   03B6             ; ------------------------------------------------------------------------------------------------------------------;
0724   03B6             trap_undef_opcode:
0725   03B6 06            sysret
0726   03B7             
0727   03B7             ; ------------------------------------------------------------------------------------------------------------------;
0728   03B7             ; real-time clock services syscall
0729   03B7             ; RTC I/O bank = FFA0 to FFAF
0730   03B7             ; FFA0 to FFA7 is scratch RAM
0731   03B7             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0732   03B7             ; al = 0..6 -> get
0733   03B7             ; al = 7..D -> set
0734   03B7             ; ------------------------------------------------------------------------------------------------------------------;
0735   03B7             syscall_rtc:
0736   03B7 DB            push al
0737   03B8 DA            push d
0738   03B9 B9 06         cmp al, 6
0739   03BB D1 D0 03      jgu syscall_rtc_set
0740   03BE             syscall_rtc_get:
0741   03BE 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0742   03C0 22 FF         mov ah, $FF    
0743   03C2 3C            mov d, a                ; get to FFA9 + offset
0744   03C3 F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0745   03C7 1E            mov al, [d]             ; get data
0746   03C8 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0747   03CC 23            mov ah, al
0748   03CD E7            pop d
0749   03CE E8            pop al
0750   03CF 06            sysret
0751   03D0             syscall_rtc_set:
0752   03D0 DD            push bl
0753   03D1 99            mov bl, ah              ; set data asIDE
0754   03D2 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0755   03D4 22 FF         mov ah, $FF    
0756   03D6 3C            mov d, a                ; get to FFA9 + offset
0757   03D7 1B            mov al, bl              ; get data back
0758   03D8 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0759   03DC 3E            mov [d], al             ; set data
0760   03DD F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0761   03E1 EA            pop bl
0762   03E2 E7            pop d
0763   03E3 E8            pop al
0764   03E4 06            sysret
0765   03E5             
0766   03E5             datetime_serv_tbl:
0767   03E5 ED 03         .dw print_date
0768   03E7 61 04         .dw set_date
0769   03E9             syscall_datetime:
0770   03E9 FD 0A E5 03   jmp [datetime_serv_tbl + al]      
0771   03ED             print_date:
0772   03ED 10 00 0D      mov a, $0D00           ; print carriage return char
0773   03F0 19 03         mov al, 3
0774   03F2 05 01         syscall sys_rtc        ; get week
0775   03F4 1A            mov al, ah
0776   03F5 22 00         mov ah, 0
0777   03F7 FD 9D 02      shl a, 2          
0778   03FA 3B 36 19      mov d, s_week
0779   03FD 59            add d, a
0780   03FE 07 DE 12      call _puts
0781   0401 10 00 20      mov a, $2000
0782   0404 05 03         syscall sys_io         ; display ' '
0783   0406 19 04         mov al, 4
0784   0408 05 01         syscall sys_rtc        ; get day
0785   040A 99            mov bl, ah
0786   040B 07 7E 13      call print_u8x
0787   040E 10 00 20      mov a, $2000
0788   0411 05 03         syscall sys_io         ; display ' '
0789   0413             ; there is a problem with the month displaying
0790   0413             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0791   0413             ; even though it is to be understood as BCD.
0792   0413             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0793   0413 19 05         mov al, 05
0794   0415 05 01         syscall sys_rtc        ; get month
0795   0417 1A            mov al, ah
0796   0418 22 00         mov ah, 0
0797   041A FD 9D 02      shl a, 2          
0798   041D 3B 02 19      mov d, s_months
0799   0420 59            add d, a
0800   0421 07 DE 12      call _puts
0801   0424 10 00 20      mov a, $2000
0802   0427 05 03         syscall sys_io         ; display ' '
0803   0429 2E 20         mov bl, $20
0804   042B 07 7E 13      call print_u8x         ; print 20 for year prefix
0805   042E 19 06         mov al, 06
0806   0430 05 01         syscall sys_rtc        ; get year
0807   0432 99            mov bl, ah
0808   0433 07 7E 13      call print_u8x
0809   0436 10 00 20      mov a, $2000  
0810   0439 05 03         syscall sys_io         ; display ' '
0811   043B 19 02         mov al, 2
0812   043D 05 01         syscall sys_rtc        ; get hours
0813   043F 99            mov bl, ah
0814   0440 07 7E 13      call print_u8x
0815   0443 10 00 3A      mov a, $3A00    
0816   0446 05 03         syscall sys_io         ; display ':'
0817   0448 19 01         mov al, 01
0818   044A 05 01         syscall sys_rtc        ; get minutes
0819   044C 99            mov bl, ah
0820   044D 07 7E 13      call print_u8x
0821   0450 10 00 3A      mov a, $3A00  
0822   0453 05 03         syscall sys_io         ; display ':'
0823   0455 19 00         mov al, 0
0824   0457 05 01         syscall sys_rtc        ; get seconds
0825   0459 99            mov bl, ah
0826   045A 07 7E 13      call print_u8x
0827   045D 07 8B 12      call printnl
0828   0460 06            sysret
0829   0461             set_date:
0830   0461 3B C7 18      mov d, s_set_year
0831   0464 07 DE 12      call _puts
0832   0467 07 C9 13      call scan_u8x          ; read integer into A
0833   046A FD 9D 08      shl a, 8               ; only AL used, move to AH
0834   046D 19 0D         mov al, 0Dh            ; set RTC year
0835   046F 05 01         syscall sys_rtc        ; set RTC
0836   0471 3B CE 18      mov d, s_set_month
0837   0474 07 DE 12      call _puts
0838   0477 07 C9 13      call scan_u8x          ; read integer into A
0839   047A FD 9D 08      shl a, 8               ; only AL used, move to AH
0840   047D 19 0C         mov al, 0Ch            ; set RTC month
0841   047F 05 01         syscall sys_rtc        ; set RTC
0842   0481 3B D6 18      mov d, s_set_day
0843   0484 07 DE 12      call _puts
0844   0487 07 C9 13      call scan_u8x          ; read integer into A
0845   048A FD 9D 08      shl a, 8               ; only AL used, move to AH
0846   048D 19 0B         mov al, 0Bh            ; set RTC month
0847   048F 05 01         syscall sys_rtc        ; set RTC
0848   0491 3B DC 18      mov d, s_set_week
0849   0494 07 DE 12      call _puts
0850   0497 07 C9 13      call scan_u8x          ; read integer into A
0851   049A FD 9D 08      shl a, 8               ; only AL used, move to AH
0852   049D 19 0A         mov al, 0Ah            ; set RTC month
0853   049F 05 01         syscall sys_rtc        ; set RTC
0854   04A1 3B E6 18      mov d, s_set_hours
0855   04A4 07 DE 12      call _puts
0856   04A7 07 C9 13      call scan_u8x          ; read integer into A
0857   04AA FD 9D 08      shl a, 8               ; only AL used, move to AH
0858   04AD 19 09         mov al, 09h            ; set RTC month
0859   04AF 05 01         syscall sys_rtc        ; set RTC
0860   04B1 3B EE 18      mov d, s_set_minutes
0861   04B4 07 DE 12      call _puts
0862   04B7 07 C9 13      call scan_u8x          ; read integer into A
0863   04BA FD 9D 08      shl a, 8               ; only AL used, move to AH
0864   04BD 19 08         mov al, 08h            ; set RTC month
0865   04BF 05 01         syscall sys_rtc        ; set RTC
0866   04C1 3B F8 18      mov d, s_set_seconds
0867   04C4 07 DE 12      call _puts
0868   04C7 07 C9 13      call scan_u8x          ; read integer into A
0869   04CA FD 9D 08      shl a, 8               ; only AL used, move to AH
0870   04CD 19 07         mov al, 07h            ; set RTC month
0871   04CF 05 01         syscall sys_rtc        ; set RTC
0872   04D1 06            sysret
0873   04D2             
0874   04D2             ; ------------------------------------------------------------------------------------------------------------------;
0875   04D2             ; IDE Services Syscall
0876   04D2             ; al = option
0877   04D2             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0878   04D2             ; IDE read/write sector
0879   04D2             ; 512 bytes
0880   04D2             ; User buffer pointer in D
0881   04D2             ; AH = number of sectors
0882   04D2             ; CB = LBA bytes 3..0
0883   04D2             ; ------------------------------------------------------------------------------------------------------------------;
0884   04D2 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0884   04D6 73 63 61 6C 
0884   04DA 6C 5F 69 64 
0884   04DE 65 20 63 61 
0884   04E2 6C 6C 65 64 
0884   04E6 3A 20 00 
0885   04E9             ide_serv_tbl:
0886   04E9 10 05         .dw ide_reset
0887   04EB 24 05         .dw ide_sleep
0888   04ED 33 05         .dw ide_read_sect_wrapper
0889   04EF 37 05         .dw ide_write_sect_wrapper
0890   04F1             syscall_ide:
0891   04F1 DD            push bl
0892   04F2 31 07 18      mov bl, [sys_debug_mode]
0893   04F5               ; debug block
0894   04F5 C1 00         cmp bl, 0
0895   04F7 EA            pop bl
0896   04F8 C6 0C 05      je syscall_ide_jmp
0897   04FB DA            push d
0898   04FC DD            push bl
0899   04FD 3B D2 04      mov d, s_syscall_ide_dbg0
0900   0500 07 DE 12      call _puts
0901   0503 2F            mov bl, al
0902   0504 07 7E 13      call print_u8x
0903   0507 07 8B 12      call printnl
0904   050A EA            pop bl
0905   050B E7            pop d
0906   050C             syscall_ide_jmp:
0907   050C FD 0A E9 04   jmp [ide_serv_tbl + al]    
0908   0510               
0909   0510             ide_reset:      
0910   0510 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0911   0514 07 BD 05      call ide_wait                   ; wait for IDE ready             
0912   0517 F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0913   051B F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0914   051F F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0915   0523 06            sysret
0916   0524             ide_sleep:
0917   0524 07 BD 05      call ide_wait                   ; wait for IDE ready             
0918   0527 F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0919   052B F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0920   052F 07 BD 05      call ide_wait                   ; wait for IDE ready
0921   0532 06            sysret
0922   0533             ide_read_sect_wrapper:
0923   0533 07 3B 05      call ide_read_sect
0924   0536 06            sysret
0925   0537             ide_write_sect_wrapper:
0926   0537 07 61 05      call ide_write_sect
0927   053A 06            sysret
0928   053B             ide_read_sect:
0929   053B 1A            mov al, ah
0930   053C 24            mov ah, bl
0931   053D 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0932   0540 1C            mov al, bh
0933   0541 3D D4 FF      mov [_ide_R4], al
0934   0544 12            mov a, c
0935   0545 3D D5 FF      mov [_ide_R5], al
0936   0548 1A            mov al, ah
0937   0549 87 0F         and al, %00001111
0938   054B 8B E0         or al, %11100000                ; mode lba, master
0939   054D 3D D6 FF      mov [_ide_R6], al
0940   0550             ide_read_sect_wait:
0941   0550 1D D7 FF      mov al, [_ide_R7]  
0942   0553 87 80         and al, $80                     ; BUSY FLAG
0943   0555 C7 50 05      jnz ide_read_sect_wait
0944   0558 19 20         mov al, $20
0945   055A 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0946   055D 07 87 05      call ide_read  
0947   0560 09            ret
0948   0561             ide_write_sect:
0949   0561 1A            mov al, ah
0950   0562 24            mov ah, bl
0951   0563 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0952   0566 1C            mov al, bh
0953   0567 3D D4 FF      mov [_ide_R4], al
0954   056A 12            mov a, c
0955   056B 3D D5 FF      mov [_ide_R5], al
0956   056E 1A            mov al, ah
0957   056F 87 0F         and al, %00001111
0958   0571 8B E0         or al, %11100000                ; mode lba, master
0959   0573 3D D6 FF      mov [_ide_R6], al
0960   0576             ide_write_sect_wait:
0961   0576 1D D7 FF      mov al, [_ide_R7]  
0962   0579 87 80         and al, $80                     ; BUSY FLAG
0963   057B C7 76 05      jnz ide_write_sect_wait
0964   057E 19 30         mov al, $30
0965   0580 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0966   0583 07 A2 05      call ide_write      
0967   0586 09            ret
0968   0587             
0969   0587             ;----------------------------------------------------------------------------------------------------;
0970   0587             ; READ IDE DATA
0971   0587             ; pointer in D
0972   0587             ;----------------------------------------------------------------------------------------------------;
0973   0587             ide_read:
0974   0587 DA            push d
0975   0588             ide_read_loop:
0976   0588 1D D7 FF      mov al, [_ide_R7]  
0977   058B 87 80         and al, 80h                     ; BUSY FLAG
0978   058D C7 88 05      jnz ide_read_loop               ; wait loop
0979   0590 1D D7 FF      mov al, [_ide_R7]
0980   0593 87 08         and al, %00001000               ; DRQ FLAG
0981   0595 C6 A0 05      jz ide_read_end
0982   0598 1D D0 FF      mov al, [_ide_R0]
0983   059B 3E            mov [d], al
0984   059C 79            inc d
0985   059D 0A 88 05      jmp ide_read_loop
0986   05A0             ide_read_end:
0987   05A0 E7            pop d
0988   05A1 09            ret
0989   05A2             
0990   05A2             ;----------------------------------------------------------------------------------------------------;
0991   05A2             ; WRITE IDE DATA
0992   05A2             ; data pointer in D
0993   05A2             ;----------------------------------------------------------------------------------------------------;
0994   05A2             ide_write:
0995   05A2 DA            push d
0996   05A3             ide_write_loop:
0997   05A3 1D D7 FF      mov al, [_ide_R7]  
0998   05A6 87 80         and al, 80h             ; BUSY FLAG
0999   05A8 C7 A3 05      jnz ide_write_loop      ; wait loop
1000   05AB 1D D7 FF      mov al, [_ide_R7]
1001   05AE 87 08         and al, %00001000       ; DRQ FLAG
1002   05B0 C6 BB 05      jz ide_write_end
1003   05B3 1E            mov al, [d]
1004   05B4 3D D0 FF      mov [_ide_R0], al
1005   05B7 79            inc d 
1006   05B8 0A A3 05      jmp ide_write_loop
1007   05BB             ide_write_end:
1008   05BB E7            pop d
1009   05BC 09            ret
1010   05BD             
1011   05BD             ;----------------------------------------------------------------------------------------------------;
1012   05BD             ; wait for IDE to be ready
1013   05BD             ;----------------------------------------------------------------------------------------------------;
1014   05BD             ide_wait:
1015   05BD 1D D7 FF      mov al, [_ide_R7]  
1016   05C0 87 80         and al, 80h        ; BUSY FLAG
1017   05C2 C7 BD 05      jnz ide_wait
1018   05C5 09            ret
1019   05C6             
1020   05C6             ;----------------------------------------------------------------------------------------------------;
1021   05C6             ; IO Syscall
1022   05C6             ;----------------------------------------------------------------------------------------------------;
1023   05C6             ; Baud  Divisor
1024   05C6             ; 50    2304
1025   05C6             ; 110   1047
1026   05C6             ; 300    384
1027   05C6             ; 600    192
1028   05C6             ; 1200    96
1029   05C6             ; 9600    12
1030   05C6             ; 19200    6
1031   05C6             ; 38400    3
1032   05C6             syscall_io_jmp:
1033   05C6 F9 05         .dw syscall_io_putchar
1034   05C8 06 06         .dw syscall_io_getch
1035   05CA D0 05         .dw syscall_io_uart_setup
1036   05CC             syscall_io:
1037   05CC FD 0A C6 05   jmp [syscall_io_jmp + al]
1038   05D0             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
1039   05D0             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
1040   05D0             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
1041   05D0             syscall_io_uart_setup:
1042   05D0 1D 09 18      mov al, [sys_uart0_lcr]
1043   05D3 8B 80         or al, $80                ; set DLAB access bit
1044   05D5 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
1045   05D8 1D 0C 18      mov al, [sys_uart0_div0]
1046   05DB 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
1047   05DE 1D 0D 18      mov al, [sys_uart0_div1]
1048   05E1 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
1049   05E4             
1050   05E4 1D 09 18      mov al, [sys_uart0_lcr]
1051   05E7 87 7F         and al, $7F               ; clear DLAB access bit 
1052   05E9 3D 83 FF      mov [_UART0_LCR], al
1053   05EC 1D 0A 18      mov al, [sys_uart0_inten]
1054   05EF 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1055   05F2 1D 0B 18      mov al, [sys_uart0_fifoen]
1056   05F5 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1057   05F8 06            sysret
1058   05F9             
1059   05F9             ; char in ah
1060   05F9             syscall_io_putchar:
1061   05F9             syscall_io_putchar_L0:
1062   05F9 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1063   05FC 87 20         and al, $20
1064   05FE C6 F9 05      jz syscall_io_putchar_L0    
1065   0601 1A            mov al, ah
1066   0602 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1067   0605 06            sysret
1068   0606             
1069   0606             ; char in ah
1070   0606             ; al = sucess code
1071   0606             syscall_io_getch:
1072   0606 D8            push b
1073   0607 DA            push d
1074   0608 FD 0C         sti
1075   060A             syscall_io_getch_L0:  
1076   060A 14 16 18      mov a, [fifo_out]
1077   060D 29 14 18      mov b, [fifo_in]
1078   0610 B0            cmp a, b
1079   0611 C6 0A 06      je syscall_io_getch_L0
1080   0614 3C            mov d, a
1081   0615 77            inc a
1082   0616 AF 65 25      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1083   0619 C7 1F 06      jne syscall_io_getch_cont
1084   061C 10 65 21      mov a, fifo  
1085   061F             syscall_io_getch_cont:  
1086   061F 42 16 18      mov [fifo_out], a             ; update fifo pointer
1087   0622 1E            mov al, [d]                   ; get char
1088   0623 23            mov ah, al
1089   0624 1D 08 18      mov al, [sys_echo_on]
1090   0627 B9 01         cmp al, 1
1091   0629 C7 38 06      jne syscall_io_getch_noecho 
1092   062C             ; here we just echo the char back to the console
1093   062C             syscall_io_getch_echo_L0:
1094   062C 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1095   062F 87 20         and al, $20                 ; isolate Transmitter Empty
1096   0631 C6 2C 06      jz syscall_io_getch_echo_L0
1097   0634 1A            mov al, ah
1098   0635 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1099   0638             syscall_io_getch_noecho:
1100   0638 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1101   063A E7            pop d
1102   063B E5            pop b
1103   063C 06            sysret
1104   063D             
1105   063D             ;------------------------------------------------------------------------------------------------------;
1106   063D             ; FILE SYSTEM DATA
1107   063D             ;------------------------------------------------------------------------------------------------------;
1108   063D             ; infor for : IDE SERVICES INTERRUPT
1109   063D             ; IDE read/write 512-byte sector
1110   063D             ; al = option
1111   063D             ; user buffer pointer in D
1112   063D             ; AH = number of sectors
1113   063D             ; CB = LBA bytes 3..0  
1114   063D             ;------------------------------------------------------------------------------------------------------;
1115   063D             ; FILE SYSTEM DATA STRUCTURE
1116   063D             ;------------------------------------------------------------------------------------------------------;
1117   063D             ; for a directory we have the header first, followed by metadata
1118   063D             ; header 1 sector (512 bytes)
1119   063D             ; metadata 1 sector (512 bytes)
1120   063D             ; HEADER ENTRIES:
1121   063D             ; filename (64)
1122   063D             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1123   063D             ;
1124   063D             ; metadata entries:
1125   063D             ; filename (24)
1126   063D             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1127   063D             ; LBA (2)
1128   063D             ; size (2)
1129   063D             ; day (1)
1130   063D             ; month (1)
1131   063D             ; year (1)
1132   063D             ; packet size = 32 bytes
1133   063D             ;
1134   063D             ; first directory on disk is the root directory '/'
1135   063D             file_system_jmptbl:
1136   063D A8 06         .dw fs_mkfs                   ; 0
1137   063F 00 00         .dw 0                         ; 1
1138   0641 0A 07         .dw fs_mkdir                  ; 2
1139   0643 83 0A         .dw fs_cd                     ; 3
1140   0645 8A 0A         .dw fs_ls                     ; 4
1141   0647 00 0C         .dw fs_mktxt                  ; 5
1142   0649 CB 0C         .dw fs_mkbin                  ; 6
1143   064B 92 0D         .dw fs_pwd                    ; 7
1144   064D AF 0D         .dw fs_cat                    ; 8
1145   064F 0B 0E         .dw fs_rmdir                  ; 9
1146   0651 67 0E         .dw fs_rm                     ; 10
1147   0653 5B 0B         .dw fs_starcom                ; 11
1148   0655 00 00         .dw 0                         ; 12
1149   0657 00 00         .dw 0                         ; 13
1150   0659 B0 06         .dw fs_chmod                  ; 14
1151   065B CF 0E         .dw fs_mv                     ; 15
1152   065D A9 06         .dw fs_cd_root                ; 16
1153   065F 7F 0A         .dw fs_get_curr_dirID         ; 17
1154   0661 5B 08         .dw fs_dir_id_to_path         ; 18
1155   0663 C1 08         .dw fs_path_to_dir_id_user    ; 19
1156   0665 DB 09         .dw fs_load_from_path_user    ; 20  
1157   0667 4B 09         .dw fs_filepath_exists_user   ; 21
1158   0669             
1159   0669 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1159   066D 79 73 63 61 
1159   0671 6C 6C 5F 66 
1159   0675 69 6C 65 5F 
1159   0679 73 79 73 74 
1159   067D 65 6D 20 63 
1159   0681 61 6C 6C 65 
1159   0685 64 3A 20 00 
1160   0689             syscall_file_system:
1161   0689 DD            push bl
1162   068A 31 07 18      mov bl, [sys_debug_mode]
1163   068D               ; debug block
1164   068D C1 00         cmp bl, 0
1165   068F EA            pop bl
1166   0690 C6 A4 06      je syscall_filesystem_jmp
1167   0693 DA            push d
1168   0694 DD            push bl
1169   0695 3B 69 06      mov d, s_syscall_fs_dbg0
1170   0698 07 DE 12      call _puts
1171   069B 2F            mov bl, al
1172   069C 07 7E 13      call print_u8x
1173   069F 07 8B 12      call printnl
1174   06A2 EA            pop bl
1175   06A3 E7            pop d
1176   06A4             syscall_filesystem_jmp:
1177   06A4 FD 0A 3D 06   jmp [file_system_jmptbl + al]
1178   06A8             
1179   06A8             fs_mkfs:  
1180   06A8 06            sysret  
1181   06A9               
1182   06A9             fs_cd_root:
1183   06A9 10 20 00      mov a, root_id
1184   06AC 42 18 18      mov [current_dir_id], a      ; set current directory LBA to ROOT
1185   06AF 06            sysret  
1186   06B0             
1187   06B0             ; filename in D (userspace data)
1188   06B0             ; permission in BL
1189   06B0             fs_chmod:
1190   06B0 DD            push bl
1191   06B1 FD 4E         mov si, d
1192   06B3 FD 4F 65 1F   mov di, user_data
1193   06B7 38 80 00      mov c, 128
1194   06BA 04            load                        ; load filename from user-space
1195   06BB 14 18 18      mov a, [current_dir_id]
1196   06BE 77            inc a                       ; metadata sector
1197   06BF 27            mov b, a
1198   06C0 38 00 00      mov c, 0                    ; upper LBA = 0
1199   06C3 22 01         mov ah, $01                  ; 1 sector
1200   06C5 3B 65 27      mov d, transient_area
1201   06C8 07 3B 05      call ide_read_sect          ; read directory
1202   06CB FD 10         cla
1203   06CD 42 10 18      mov [index], a              ; reset file counter
1204   06D0             fs_chmod_L1:
1205   06D0 FD 4E         mov si, d
1206   06D2 FD 4F 65 1F   mov di, user_data
1207   06D6 07 21 11      call _strcmp
1208   06D9 C6 F0 06      je fs_chmod_found_entry
1209   06DC 58 20 00      add d, 32
1210   06DF 14 10 18      mov a, [index]
1211   06E2 77            inc a
1212   06E3 42 10 18      mov [index], a
1213   06E6 AF 10 00      cmp a, FST_FILES_PER_DIR
1214   06E9 C7 D0 06      jne fs_chmod_L1
1215   06EC EA            pop bl
1216   06ED 0A 09 07      jmp fs_chmod_not_found
1217   06F0             fs_chmod_found_entry:  
1218   06F0 FD 79         mov g, b                    ; save LBA
1219   06F2 EA            pop bl                      ; retrieve saved permission value
1220   06F3 1F 18 00      mov al, [d + 24]            ; read file permissions
1221   06F6 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1222   06F8 8C            or al, bl                   ; set new permissions
1223   06F9 3F 18 00      mov [d + 24], al            ; write new permissions
1224   06FC 38 00 00      mov c, 0
1225   06FF 3B 65 27      mov d, transient_area
1226   0702 22 01         mov ah, $01                 ; disk write 1 sect
1227   0704 FD 27         mov b, g                    ; retrieve LBA
1228   0706 07 61 05      call ide_write_sect         ; write sector
1229   0709             fs_chmod_not_found:
1230   0709 06            sysret
1231   070A             
1232   070A             ;------------------------------------------------------------------------------------------------------;
1233   070A             ; CREATE NEW DIRECTORY
1234   070A             ;------------------------------------------------------------------------------------------------------;
1235   070A             ; search list for NULL name entry. add new directory to list
1236   070A             fs_mkdir:
1237   070A FD 4E         mov si, d
1238   070C FD 4F 65 1F   mov di, user_data
1239   0710 38 00 02      mov c, 512
1240   0713 04            load                        ; load data from user-space
1241   0714 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1242   0717                                           ; when checking for NULL name, since root has a NULL name)
1243   0717 38 00 00      mov c, 0                    ; upper LBA = 0
1244   071A             fs_mkdir_L1:  
1245   071A 22 01         mov ah, $01                  ; 1 sector
1246   071C 3B 65 27      mov d, transient_area
1247   071F 07 3B 05      call ide_read_sect          ; read sector
1248   0722 BD 00         cmp byte[d], 0              ; check for NULL
1249   0724 C6 2D 07      je fs_mkdir_found_null
1250   0727 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1251   072A 0A 1A 07      jmp fs_mkdir_L1
1252   072D             fs_mkdir_found_null:
1253   072D             ;create header file by grabbing dir name from parameter
1254   072D D8            push b                      ; save new directory's LBA
1255   072E 38 40 00      mov c, 64
1256   0731 FD 4D 65 1F   mov si, user_data
1257   0735 FD 4F 65 27   mov di, transient_area
1258   0739 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1259   073B 14 18 18      mov a, [current_dir_id]
1260   073E 42 A5 27      mov [transient_area + 64], a    ; store parent directory LBA
1261   0741 19 00         mov al, 0
1262   0743 FD 4F 65 29   mov di, transient_area + 512
1263   0747 38 00 02      mov c, 512
1264   074A FD F7         rep stosb                       ; clean buffer
1265   074C 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1266   074F             ; write directory entry sectors
1267   074F 3B 65 27      mov d, transient_area
1268   0752 22 02         mov ah, $02                     ; disk write, 2 sectors
1269   0754 07 61 05      call ide_write_sect             ; write sector
1270   0757             ; now we need to add the new directory to the list, insIDE the current directory
1271   0757 14 18 18      mov a, [current_dir_id]
1272   075A 53 01 00      add a, 1
1273   075D 27            mov b, a                        ; metadata sector
1274   075E 38 00 00      mov c, 0
1275   0761 FD 79         mov g, b                        ; save LBA
1276   0763 3B 65 27      mov d, transient_area
1277   0766 22 01         mov ah, $01                  ; 1 sector
1278   0768 07 3B 05      call ide_read_sect              ; read metadata sector
1279   076B             fs_mkdir_L2:
1280   076B BD 00         cmp byte[d], 0
1281   076D C6 76 07      je fs_mkdir_found_null2
1282   0770 58 20 00      add d, FST_ENTRY_SIZE
1283   0773 0A 6B 07      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1284   0776             fs_mkdir_found_null2:
1285   0776 FD 4D 65 1F   mov si, user_data
1286   077A FD 50         mov di, d
1287   077C 07 36 11      call _strcpy                    ; copy directory name
1288   077F 58 18 00      add d, 24                       ; goto ATTRIBUTES
1289   0782 19 0B         mov al, %00001011               ; directory, no execute, write, read
1290   0784 3E            mov [d], al      
1291   0785 79            inc d
1292   0786 E5            pop b
1293   0787 D8            push b                          ; push LBA back
1294   0788 FD 43         mov [d], b                      ; save LBA
1295   078A             ; set file creation date  
1296   078A 58 04 00      add d, 4
1297   078D 19 04         mov al, 4
1298   078F 05 01         syscall sys_rtc
1299   0791 1A            mov al, ah
1300   0792 3E            mov [d], al                     ; set day
1301   0793 79            inc d
1302   0794 19 05         mov al, 5
1303   0796 05 01         syscall sys_rtc
1304   0798 1A            mov al, ah
1305   0799 3E            mov [d], al                     ; set month
1306   079A 79            inc d
1307   079B 19 06         mov al, 6
1308   079D 05 01         syscall sys_rtc
1309   079F 1A            mov al, ah
1310   07A0 3E            mov [d], al                     ; set year
1311   07A1             ; write sector into disk for new directory entry
1312   07A1 FD 27         mov b, g
1313   07A3 38 00 00      mov c, 0
1314   07A6 3B 65 27      mov d, transient_area
1315   07A9 22 01         mov ah, $01                     ; disk write, 1 sector
1316   07AB 07 61 05      call ide_write_sect             ; write sector
1317   07AE             
1318   07AE             ; after adding the new directory's information to its parent directory's list
1319   07AE             ; we need to now enter the new directory, and to it add two new directories!
1320   07AE             ; which directories do we need to add ? '..' and '.' are the directories needed.
1321   07AE             ; importantly, note that these two new directories are only entries in the list
1322   07AE             ; and do not have actual physical entries in the disk as real directories.
1323   07AE             ; i.e. they only exist as list entries in the new directory created so that
1324   07AE             ; the new directory can reference its parent and itself.
1325   07AE             ; We need to add both '..' and '.'
1326   07AE             ; this first section is for '..' and on the section below we do the same for '.'
1327   07AE E4            pop a                         ; retrieve the new directory's LBA  
1328   07AF D7            push a                        ; and save again
1329   07B0 53 01 00      add a, 1
1330   07B3 27            mov b, a                      ; metadata sector
1331   07B4 38 00 00      mov c, 0
1332   07B7 FD 79         mov g, b                      ; save LBA
1333   07B9 3B 65 27      mov d, transient_area
1334   07BC 22 01         mov ah, $01                  ; 1 sector
1335   07BE 07 3B 05      call ide_read_sect            ; read metadata sector
1336   07C1             fs_mkdir_L3:
1337   07C1 BD 00         cmp byte[d], 0
1338   07C3 C6 CC 07      je fs_mkdir_found_null3
1339   07C6 58 20 00      add d, FST_ENTRY_SIZE
1340   07C9 0A C1 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1341   07CC             fs_mkdir_found_null3:
1342   07CC FD 4D 37 18   mov si, s_parent_dir
1343   07D0 FD 50         mov di, d
1344   07D2 07 36 11      call _strcpy                  ; copy directory name
1345   07D5 58 18 00      add d, 24                     ; goto ATTRIBUTES
1346   07D8 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1347   07DA 3E            mov [d], al      
1348   07DB 79            inc d
1349   07DC 29 18 18      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1350   07DF FD 43         mov [d], b                    ; save LBA
1351   07E1             ; set file creation date  
1352   07E1 58 04 00      add d, 4
1353   07E4 19 04         mov al, 4
1354   07E6 05 01         syscall sys_rtc
1355   07E8 1A            mov al, ah
1356   07E9 3E            mov [d], al                   ; set day
1357   07EA 79            inc d
1358   07EB 19 05         mov al, 5
1359   07ED 05 01         syscall sys_rtc
1360   07EF 1A            mov al, ah
1361   07F0 3E            mov [d], al                   ; set month
1362   07F1 79            inc d
1363   07F2 19 06         mov al, 6
1364   07F4 05 01         syscall sys_rtc
1365   07F6 1A            mov al, ah
1366   07F7 3E            mov [d], al                   ; set year
1367   07F8             ; write sector into disk for new directory entry
1368   07F8 FD 27         mov b, g
1369   07FA 38 00 00      mov c, 0
1370   07FD 3B 65 27      mov d, transient_area
1371   0800 22 01         mov ah, $01                   ; disk write, 1 sector
1372   0802 07 61 05      call ide_write_sect           ; write sector
1373   0805             ;;;;;;;;;;;;;
1374   0805             ; like we did above for '..', we need to now add the '.' directory to the list.
1375   0805             ;------------------------------------------------------------------------------------------------------;
1376   0805 E4            pop a                         ; retrieve the new directory's LBA  
1377   0806 D7            push a
1378   0807 53 01 00      add a, 1
1379   080A 27            mov b, a                      ; metadata sector
1380   080B 38 00 00      mov c, 0
1381   080E FD 79         mov g, b                      ; save LBA
1382   0810 3B 65 27      mov d, transient_area
1383   0813 22 01         mov ah, $01                  ; 1 sector
1384   0815 07 3B 05      call ide_read_sect            ; read metadata sector
1385   0818             fs_mkdir_L4:
1386   0818 BD 00         cmp byte[d], 0
1387   081A C6 23 08      je fs_mkdir_found_null4
1388   081D 58 20 00      add d, FST_ENTRY_SIZE
1389   0820 0A 18 08      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1390   0823             fs_mkdir_found_null4:
1391   0823 FD 4D 3A 18   mov si, s_current_dir
1392   0827 FD 50         mov di, d
1393   0829 07 36 11      call _strcpy                  ; copy directory name
1394   082C 58 18 00      add d, 24                     ; goto ATTRIBUTES
1395   082F 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1396   0831 3E            mov [d], al      
1397   0832 79            inc d
1398   0833 E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1399   0834 FD 43         mov [d], b                    ; save LBA
1400   0836             ; set file creation date  
1401   0836 58 04 00      add d, 4
1402   0839 19 04         mov al, 4
1403   083B 05 01         syscall sys_rtc
1404   083D 1A            mov al, ah
1405   083E 3E            mov [d], al                   ; set day
1406   083F 79            inc d
1407   0840 19 05         mov al, 5
1408   0842 05 01         syscall sys_rtc
1409   0844 1A            mov al, ah
1410   0845 3E            mov [d], al                   ; set month
1411   0846 79            inc d
1412   0847 19 06         mov al, 6
1413   0849 05 01         syscall sys_rtc
1414   084B 1A            mov al, ah
1415   084C 3E            mov [d], al                   ; set year
1416   084D             ; write sector into disk for new directory entry
1417   084D FD 27         mov b, g
1418   084F 38 00 00      mov c, 0
1419   0852 3B 65 27      mov d, transient_area
1420   0855 22 01         mov ah, $01                   ; disk write, 1 sector
1421   0857 07 61 05      call ide_write_sect           ; write sector
1422   085A             fs_mkdir_end:
1423   085A 06            sysret
1424   085B             
1425   085B             ;------------------------------------------------------------------------------------------------------;
1426   085B             ; get path from a given directory dirID
1427   085B             ; pseudo code:
1428   085B             ;  fs_dir_id_to_path(int dirID, char *D){
1429   085B             ;    if(dirID == 0){
1430   085B             ;      reverse path in D;
1431   085B             ;      return;
1432   085B             ;    }
1433   085B             ;    else{
1434   085B             ;      copy directory name to end of D;
1435   085B             ;      add '/' to end of D;
1436   085B             ;      parentID = get parent directory ID;
1437   085B             ;      fs_dir_id_to_path(parentID, D);
1438   085B             ;    }
1439   085B             ;  }
1440   085B             ; A = dirID
1441   085B             ; D = generated path string pointer
1442   085B             ;------------------------------------------------------------------------------------------------------;
1443   085B             ; sample path: /usr/bin
1444   085B             fs_dir_id_to_path:
1445   085B 3B E5 1E      mov d, filename
1446   085E 19 00         mov al, 0
1447   0860 3E            mov [d], al                     ; initialize path string 
1448   0861 14 18 18      mov a, [current_dir_id]
1449   0864 07 71 08      call fs_dir_id_to_path_E0
1450   0867 3B E5 1E      mov d, filename
1451   086A 07 CA 10      call _strrev
1452   086D 07 DE 12      call _puts
1453   0870 06            sysret
1454   0871             fs_dir_id_to_path_E0:
1455   0871 07 90 08      call get_dirname_from_dirID
1456   0874 FD 4D 3C 18   mov si, s_fslash
1457   0878 FD 50         mov di, d
1458   087A 07 44 11      call _strcat                    ; add '/' to end of path
1459   087D AF 20 00      cmp a, root_id               ; check if we are at the root directory
1460   0880 C6 8F 08      je fs_dir_id_to_path_root
1461   0883 07 AD 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1462   0886 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1463   0889 C6 8F 08      je fs_dir_id_to_path_root
1464   088C 07 71 08      call fs_dir_id_to_path_E0     ; recursively call itself
1465   088F             fs_dir_id_to_path_root:
1466   088F 09            ret
1467   0890             
1468   0890             ;------------------------------------------------------------------------------------------------------;
1469   0890             ; in_puts:
1470   0890             ; A = directory ID
1471   0890             ; out_puts:
1472   0890             ; D = pointer to directory name string
1473   0890             ;------------------------------------------------------------------------------------------------------;
1474   0890             get_dirname_from_dirID:
1475   0890 D7            push a
1476   0891 D8            push b
1477   0892 DA            push d
1478   0893 27            mov b, a
1479   0894 38 00 00      mov c, 0                      ; upper LBA = 0
1480   0897 22 01         mov ah, $01                  ; 1 sector
1481   0899 3B 65 25      mov d, transient_area - 512
1482   089C 07 3B 05      call ide_read_sect            ; read directory
1483   089F 07 CA 10      call _strrev                  ; reverse dir name before copying
1484   08A2 FD 4E         mov si, d
1485   08A4 E7            pop d                         ; destination address = D value pushed at beginning
1486   08A5 FD 50         mov di, d
1487   08A7 07 44 11      call _strcat                  ; copy filename to D
1488   08AA E5            pop b
1489   08AB E4            pop a
1490   08AC 09            ret
1491   08AD             
1492   08AD             ;------------------------------------------------------------------------------------------------------;
1493   08AD             ; in_puts:
1494   08AD             ; A = directory ID
1495   08AD             ; out_puts:
1496   08AD             ; A = parent directory ID
1497   08AD             ;------------------------------------------------------------------------------------------------------;
1498   08AD             get_parentID_from_dirID:
1499   08AD D8            push b
1500   08AE DA            push d
1501   08AF 27            mov b, a
1502   08B0 38 00 00      mov c, 0                      ; upper LBA = 0
1503   08B3 22 01         mov ah, $01                  ; 1 sector
1504   08B5 3B 65 25      mov d, transient_area - 512
1505   08B8 07 3B 05      call ide_read_sect            ; read directory
1506   08BB 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1507   08BE E7            pop d
1508   08BF E5            pop b
1509   08C0 09            ret
1510   08C1             
1511   08C1             ;------------------------------------------------------------------------------------------------------;
1512   08C1             ; get dirID from a given path string
1513   08C1             ; in_puts:
1514   08C1             ; D = path pointer 
1515   08C1             ; out_puts:
1516   08C1             ; A = dirID
1517   08C1             ; if dir non existent, A = FFFF (fail code)
1518   08C1             ; /usr/local/bin    - absolute
1519   08C1             ; local/bin/games    - relative
1520   08C1             ;------------------------------------------------------------------------------------------------------;
1521   08C1             fs_path_to_dir_id_user:
1522   08C1 FD 4E         mov si, d
1523   08C3 FD 4F 65 1F   mov di, user_data
1524   08C7 38 00 02      mov c, 512
1525   08CA 04            load
1526   08CB 07 CF 08      call get_dirID_from_path
1527   08CE 06            sysret
1528   08CF             get_dirID_from_path:
1529   08CF 26 65 1F      mov b, user_data
1530   08D2 FD 42 03 17   mov [prog], b                  ; token pointer set to path string
1531   08D6 07 64 15      call get_token
1532   08D9 31 06 17      mov bl, [tok]
1533   08DC C1 01         cmp bl, TOK_FSLASH
1534   08DE C6 EA 08      je get_dirID_from_path_abs 
1535   08E1 14 18 18      mov a, [current_dir_id]
1536   08E4 07 EA 16      call _putback
1537   08E7 0A ED 08      jmp get_dirID_from_path_E0
1538   08EA             get_dirID_from_path_abs:
1539   08EA 10 20 00      mov a, root_id
1540   08ED             get_dirID_from_path_E0:
1541   08ED 07 64 15      call get_token
1542   08F0 31 05 17      mov bl, [toktyp]
1543   08F3 C1 00         cmp bl, TOKTYP_IDENTIFIER
1544   08F5 C7 46 09      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1545   08F8             
1546   08F8 FD 4D 07 17   mov si, tokstr
1547   08FC FD 4F E5 1E   mov di, filename
1548   0900 07 36 11      call _strcpy        
1549   0903 77            inc a                         ; metadata sector
1550   0904 27            mov b, a
1551   0905 38 00 00      mov c, 0                      ; upper LBA = 0
1552   0908 22 01         mov ah, $01                  ; 1 sector
1553   090A 3B 65 27      mov d, transient_area
1554   090D 07 3B 05      call ide_read_sect            ; read directory
1555   0910 FD 10         cla
1556   0912 42 10 18      mov [index], a
1557   0915             get_dirID_from_path_L1:
1558   0915 FD 4E         mov si, d
1559   0917 FD 4F E5 1E   mov di, filename
1560   091B 07 21 11      call _strcmp
1561   091E C6 34 09      je get_dirID_from_path_name_equal  
1562   0921 58 20 00      add d, 32
1563   0924 14 10 18      mov a, [index]
1564   0927 77            inc a
1565   0928 42 10 18      mov [index], a
1566   092B AF 10 00      cmp a, FST_FILES_PER_DIR
1567   092E C6 47 09      je get_dirID_from_path_fail
1568   0931 0A 15 09      jmp get_dirID_from_path_L1
1569   0934             get_dirID_from_path_name_equal:
1570   0934 58 19 00      add d, 25           
1571   0937 15            mov a, [d]                    ; set result register A = dirID
1572   0938 07 64 15      call get_token
1573   093B 31 06 17      mov bl, [tok]
1574   093E C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1575   0940 C6 ED 08      je get_dirID_from_path_E0
1576   0943 07 EA 16      call _putback
1577   0946             get_dirID_from_path_end:
1578   0946 09            ret
1579   0947             get_dirID_from_path_fail:
1580   0947 10 FF FF      mov A, $FFFF
1581   094A 09            ret
1582   094B             
1583   094B             
1584   094B             ;------------------------------------------------------------------------------------------------------;
1585   094B             ; check if file exists by a given path string
1586   094B             ; in_puts:
1587   094B             ; D = path pointer 
1588   094B             ; OUTPUTS:
1589   094B             ; A = success code, if file exists gives LBA, else, give 0
1590   094B             ; /usr/local/bin/ed
1591   094B             ;------------------------------------------------------------------------------------------------------;
1592   094B             fs_filepath_exists_user:
1593   094B FD 4E         mov si, d
1594   094D FD 4F 65 1F   mov di, user_data
1595   0951 38 00 02      mov c, 512
1596   0954 04            load
1597   0955 07 59 09      call file_exists_by_path
1598   0958 06            sysret
1599   0959             file_exists_by_path:
1600   0959 26 65 1F      mov b, user_data
1601   095C FD 42 03 17   mov [prog], b                   ; token pointer set to path string
1602   0960 07 64 15      call get_token
1603   0963 31 06 17      mov bl, [tok]
1604   0966 C1 01         cmp bl, TOK_FSLASH
1605   0968 C6 74 09      je  file_exists_by_path_abs
1606   096B 14 18 18      mov a, [current_dir_id]
1607   096E 07 EA 16      call _putback
1608   0971 0A 77 09      jmp file_exists_by_path_E0
1609   0974             file_exists_by_path_abs:
1610   0974 10 20 00      mov a, root_id
1611   0977             file_exists_by_path_E0:
1612   0977 07 64 15      call get_token
1613   097A 31 05 17      mov bl, [toktyp]
1614   097D C1 00         cmp bl, TOKTYP_IDENTIFIER
1615   097F C7 D7 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1616   0982 FD 4D 07 17   mov si, tokstr
1617   0986 FD 4F E5 1E   mov di, filename
1618   098A 07 36 11      call _strcpy        
1619   098D 77            inc a                           ; metadata sector
1620   098E 27            mov b, a
1621   098F 38 00 00      mov c, 0                        ; upper LBA = 0
1622   0992 22 01         mov ah, $01                  ; 1 sector
1623   0994 3B 65 27      mov d, transient_area
1624   0997 07 3B 05      call ide_read_sect              ; read directory
1625   099A FD 10         cla
1626   099C 42 10 18      mov [index], a
1627   099F             file_exists_by_path_L1:
1628   099F FD 4E         mov si, d
1629   09A1 FD 4F E5 1E   mov di, filename
1630   09A5 07 21 11      call _strcmp
1631   09A8 C6 BE 09      je   file_exists_by_path_name_equal
1632   09AB 58 20 00      add d, 32
1633   09AE 14 10 18      mov a, [index]
1634   09B1 77            inc a
1635   09B2 42 10 18      mov [index], a
1636   09B5 AF 10 00      cmp a, FST_FILES_PER_DIR
1637   09B8 C6 D7 09      je file_exists_by_path_end
1638   09BB 0A 9F 09      jmp file_exists_by_path_L1
1639   09BE             file_exists_by_path_name_equal:
1640   09BE 33 18 00      mov bl, [d + 24]
1641   09C1 FD 87 38      and bl, %00111000               ; directory flag
1642   09C4 C1 08         cmp bl, %00001000               ; is dir?
1643   09C6 C6 CD 09      je file_exists_by_path_isdir;
1644   09C9             ; entry is a file
1645   09C9 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1646   09CC 09            ret
1647   09CD             file_exists_by_path_isdir:
1648   09CD 58 19 00      add d, 25           
1649   09D0 15            mov a, [d]                      ; set result register A = dirID
1650   09D1 07 64 15      call get_token
1651   09D4 0A 77 09      jmp file_exists_by_path_E0
1652   09D7             file_exists_by_path_end:
1653   09D7 10 00 00      mov a, 0                        ; return 0 because file was not found
1654   09DA 09            ret
1655   09DB             
1656   09DB             ;------------------------------------------------------------------------------------------------------;
1657   09DB             ; load file data from a given path string
1658   09DB             ; inputs:
1659   09DB             ; D = path pointer 
1660   09DB             ; DI = userspace program data destination
1661   09DB             ; /usr/local/bin/ed
1662   09DB             ; ./ed
1663   09DB             ;------------------------------------------------------------------------------------------------------;
1664   09DB             fs_load_from_path_user:
1665   09DB E3            push di
1666   09DC FD 4E         mov si, d
1667   09DE FD 4F 65 1F   mov di, user_data
1668   09E2 38 00 02      mov c, 512
1669   09E5 04            load
1670   09E6 07 F3 09      call loadfile_from_path
1671   09E9 F0            pop di
1672   09EA FD 4D 65 27   mov si, transient_area
1673   09EE 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1674   09F1 03            store
1675   09F2 06            sysret
1676   09F3             loadfile_from_path:
1677   09F3 26 65 1F      mov b, user_data
1678   09F6 FD 42 03 17   mov [prog], b                 ; token pointer set to path string
1679   09FA 07 64 15      call get_token
1680   09FD 31 06 17      mov bl, [tok]
1681   0A00 C1 01         cmp bl, TOK_FSLASH
1682   0A02 C6 0E 0A      je loadfile_from_path_abs 
1683   0A05 14 18 18      mov a, [current_dir_id]
1684   0A08 07 EA 16      call _putback
1685   0A0B 0A 11 0A      jmp loadfile_from_path_E0
1686   0A0E             loadfile_from_path_abs:
1687   0A0E 10 20 00      mov a, root_id
1688   0A11             loadfile_from_path_E0:
1689   0A11 07 64 15      call get_token
1690   0A14 31 05 17      mov bl, [toktyp]
1691   0A17 C1 00         cmp bl, TOKTYP_IDENTIFIER
1692   0A19 C7 7E 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1693   0A1C FD 4D 07 17   mov si, tokstr
1694   0A20 FD 4F E5 1E   mov di, filename
1695   0A24 07 36 11      call _strcpy        
1696   0A27 77            inc a                         ; metadata sector
1697   0A28 27            mov b, a
1698   0A29 38 00 00      mov c, 0                      ; upper LBA = 0
1699   0A2C 22 01         mov ah, $01                  ; 1 sector
1700   0A2E 3B 65 27      mov d, transient_area
1701   0A31 07 3B 05      call ide_read_sect            ; read directory
1702   0A34 FD 10         cla
1703   0A36 42 10 18      mov [index], a
1704   0A39             loadfile_from_path_L1:
1705   0A39 FD 4E         mov si, d
1706   0A3B FD 4F E5 1E   mov di, filename
1707   0A3F 07 21 11      call _strcmp
1708   0A42 C6 58 0A      je loadfile_from_path_name_equal  
1709   0A45 58 20 00      add d, 32
1710   0A48 14 10 18      mov a, [index]
1711   0A4B 77            inc a
1712   0A4C 42 10 18      mov [index], a
1713   0A4F AF 10 00      cmp a, FST_FILES_PER_DIR
1714   0A52 C6 7E 0A      je loadfile_from_path_end
1715   0A55 0A 39 0A      jmp loadfile_from_path_L1
1716   0A58             loadfile_from_path_name_equal:
1717   0A58 33 18 00      mov bl, [d + 24]
1718   0A5B FD 87 38      and bl, %00111000             ; directory flag
1719   0A5E C1 08         cmp bl, %00001000             ; is dir?
1720   0A60 C6 74 0A      je loadfile_isdirectory  
1721   0A63             ; entry is a file
1722   0A63 2B 19 00      mov b, [d + 25]               ; get LBA
1723   0A66 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1724   0A68 3B 65 27      mov d, transient_area
1725   0A6B 38 00 00      mov c, 0
1726   0A6E 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1727   0A70 07 3B 05      call ide_read_sect            ; read sector
1728   0A73 09            ret
1729   0A74             loadfile_isdirectory:
1730   0A74 58 19 00      add d, 25           
1731   0A77 15            mov a, [d]                    ; set result register A = dirID
1732   0A78 07 64 15      call get_token
1733   0A7B 0A 11 0A      jmp loadfile_from_path_E0
1734   0A7E             loadfile_from_path_end:
1735   0A7E 09            ret
1736   0A7F             
1737   0A7F             ;------------------------------------------------------------------------------------------------------;
1738   0A7F             ; return the ID of the current directory
1739   0A7F             ; ID returned in B
1740   0A7F             ;------------------------------------------------------------------------------------------------------;
1741   0A7F             fs_get_curr_dirID:
1742   0A7F 29 18 18      mov b, [current_dir_id]
1743   0A82 06            sysret
1744   0A83             
1745   0A83             ;------------------------------------------------------------------------------------------------------;
1746   0A83             ; CD
1747   0A83             ;------------------------------------------------------------------------------------------------------;
1748   0A83             ; new dirID in B
1749   0A83             fs_cd:
1750   0A83 FD 42 18 18   mov [current_dir_id], b
1751   0A87 06            sysret  
1752   0A88             
1753   0A88             ;------------------------------------------------------------------------------------------------------;
1754   0A88             ; LS
1755   0A88             ; dirID in B
1756   0A88             ;------------------------------------------------------------------------------------------------------;
1757   0A88 00 00       ls_count:       .dw 0
1758   0A8A             fs_ls:
1759   0A8A FD 77         inc b                        ; metadata sector
1760   0A8C 38 00 00      mov c, 0                     ; upper LBA = 0
1761   0A8F 22 01         mov ah, $01                  ; 1 sector
1762   0A91 3B 65 27      mov d, transient_area
1763   0A94 07 3B 05      call ide_read_sect           ; read directory
1764   0A97 FD 10         cla
1765   0A99 42 10 18      mov [index], a               ; reset entry index
1766   0A9C 3D 88 0A      mov [ls_count], al           ; reset item count
1767   0A9F             fs_ls_L1:
1768   0A9F BD 00         cmp byte [d], 0              ; check for NULL
1769   0AA1 C6 38 0B      je fs_ls_next
1770   0AA4             fs_ls_non_null:
1771   0AA4 1D 88 0A      mov al, [ls_count]
1772   0AA7 7A            inc al
1773   0AA8 3D 88 0A      mov [ls_count], al           ; increment item count
1774   0AAB 1F 18 00      mov al, [d + 24]
1775   0AAE 87 38         and al, %00111000
1776   0AB0 FD A2 03      shr al, 3
1777   0AB3 22 00         mov ah, 0                    ; file type
1778   0AB5 B7 43 18      mov a, [a + file_type]      
1779   0AB8 23            mov ah, al
1780   0AB9 07 B2 11      call _putchar
1781   0ABC 1F 18 00      mov al, [d + 24]
1782   0ABF 87 01         and al, %00000001
1783   0AC1 22 00         mov ah, 0
1784   0AC3 B7 3E 18      mov a, [a + file_attrib]     ; read
1785   0AC6 23            mov ah, al
1786   0AC7 07 B2 11      call _putchar
1787   0ACA 1F 18 00      mov al, [d + 24]
1788   0ACD 87 02         and al, %00000010
1789   0ACF 22 00         mov ah, 0
1790   0AD1 B7 3E 18      mov a, [a + file_attrib]     ; write
1791   0AD4 23            mov ah, al
1792   0AD5 07 B2 11      call _putchar
1793   0AD8 1F 18 00      mov al, [d + 24]
1794   0ADB 87 04         and al, %00000100
1795   0ADD 22 00         mov ah, 0
1796   0ADF B7 3E 18      mov a, [a + file_attrib]     ; execute
1797   0AE2 23            mov ah, al
1798   0AE3 07 B2 11      call _putchar
1799   0AE6 22 20         mov ah, $20
1800   0AE8 07 B2 11      call _putchar  
1801   0AEB 2B 1B 00      mov b, [d + 27]
1802   0AEE 07 3A 13      call print_u16x              ; filesize
1803   0AF1 22 20         mov ah, $20
1804   0AF3 07 B2 11      call _putchar  
1805   0AF6 2B 19 00      mov b, [d + 25]
1806   0AF9 07 3A 13      call print_u16x              ; dirID / LBA
1807   0AFC 22 20         mov ah, $20
1808   0AFE 07 B2 11      call _putchar
1809   0B01             ; print date
1810   0B01 33 1D 00      mov bl, [d + 29]             ; day
1811   0B04 07 7E 13      call print_u8x
1812   0B07 22 20         mov ah, $20
1813   0B09 07 B2 11      call _putchar  
1814   0B0C 1F 1E 00      mov al, [d + 30]             ; month
1815   0B0F FD 9E 02      shl al, 2
1816   0B12 DA            push d
1817   0B13 3B 02 19      mov d, s_months
1818   0B16 22 00         mov ah, 0
1819   0B18 59            add d, a
1820   0B19 07 DE 12      call _puts
1821   0B1C E7            pop d
1822   0B1D 22 20         mov ah, $20
1823   0B1F 07 B2 11      call _putchar
1824   0B22 2E 20         mov bl, $20
1825   0B24 07 7E 13      call print_u8x
1826   0B27 33 1F 00      mov bl, [d + 31]             ; year
1827   0B2A 07 7E 13      call print_u8x  
1828   0B2D 22 20         mov ah, $20
1829   0B2F 07 B2 11      call _putchar  
1830   0B32 07 DE 12      call _puts                   ; print filename  
1831   0B35 07 8B 12      call printnl
1832   0B38             fs_ls_next:
1833   0B38 14 10 18      mov a, [index]
1834   0B3B 77            inc a
1835   0B3C 42 10 18      mov [index], a
1836   0B3F AF 10 00      cmp a, FST_FILES_PER_DIR
1837   0B42 C6 4B 0B      je fs_ls_end
1838   0B45 58 20 00      add d, 32      
1839   0B48 0A 9F 0A      jmp fs_ls_L1  
1840   0B4B             fs_ls_end:
1841   0B4B 3B 53 18      mov d, s_ls_total
1842   0B4E 07 DE 12      call _puts
1843   0B51 1D 88 0A      mov al, [ls_count]
1844   0B54 07 90 13      call print_u8d
1845   0B57 07 8B 12      call printnl
1846   0B5A 06            sysret
1847   0B5B             
1848   0B5B             
1849   0B5B             ;------------------------------------------------------------------------------------------------------;
1850   0B5B             ; CREATE NEW TEXTFILE
1851   0B5B             ;------------------------------------------------------------------------------------------------------;
1852   0B5B             ; file structure:
1853   0B5B             ; 512 bytes header
1854   0B5B             ; header used to tell whether the block is free
1855   0B5B             ; d = content pointer in user space
1856   0B5B             ; c = file size
1857   0B5B             ; TODO: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1858   0B5B             fs_starcom:
1859   0B5B FD 4E       	mov si, d
1860   0B5D FD 4F 65 27 	mov di, transient_area
1861   0B61 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1862   0B64 04          	load					; load data from user-space
1863   0B65 07 E6 0B    	call fs_find_empty_block	; look for empty data blocks
1864   0B68 D8          	push b				; save empty block LBA
1865   0B69 FD 79         mov g, b
1866   0B6B             ;create header file by grabbing file name from parameter	
1867   0B6B 3B 65 29    	mov d, transient_area + 512			; pointer to file contents
1868   0B6E D9          	push c							; save length
1869   0B6F 19 01       	mov al, 1
1870   0B71 3D 65 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1871   0B74 3B 65 27    	mov d, transient_area
1872   0B77 12            mov a, c
1873   0B78 26 00 02      mov b, 512
1874   0B7B AE            div a, b
1875   0B7C FD 77         inc b         ; inc b as the division will most likely have a remainder
1876   0B7E 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1877   0B7F 38 00 00    	mov c, 0      ; lba 
1878   0B82 FD 27         mov b, g      ; lba 
1879   0B84 07 61 05    	call ide_write_sect			; write sectors
1880   0B87             ; now we add the file to the current directory!
1881   0B87             fs_starcom_add_to_dir:	
1882   0B87 14 18 18    	mov a, [current_dir_id]
1883   0B8A 77          	inc a
1884   0B8B 27          	mov b, a					; metadata sector
1885   0B8C 38 00 00    	mov c, 0
1886   0B8F FD 79       	mov g, b					; save LBA
1887   0B91 3B 65 25    	mov d, scrap_sector
1888   0B94 22 01       	mov ah, $01			  ; 1 sector
1889   0B96 07 3B 05    	call ide_read_sect		; read metadata sector
1890   0B99             fs_starcom_add_to_dir_L2:
1891   0B99 BD 00       	cmp byte[d], 0
1892   0B9B C6 A4 0B    	je fs_starcom_add_to_dir_null
1893   0B9E 58 20 00    	add d, FST_ENTRY_SIZE
1894   0BA1 0A 99 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1895   0BA4             fs_starcom_add_to_dir_null:
1896   0BA4 FD 4D 66 27 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1897   0BA8 FD 50       	mov di, d
1898   0BAA 07 36 11    	call _strcpy			; copy file name
1899   0BAD 58 18 00    	add d, 24			; skip name
1900   0BB0 19 07       	mov al, %00000111	; type=file, execute, write, read
1901   0BB2 3E          	mov [d], al			
1902   0BB3 58 03 00    	add d, 3
1903   0BB6 E4          	pop a
1904   0BB7 5F 00 02      sub a, 512
1905   0BBA 43          	mov [d], a ; file size
1906   0BBB 63 02 00    	sub d, 2
1907   0BBE E5          	pop b				; get file LBA
1908   0BBF FD 43       	mov [d], b			; save LBA	
1909   0BC1             ; set file creation date	
1910   0BC1 58 04 00    	add d, 4
1911   0BC4 19 04       	mov al, 4
1912   0BC6 05 01       	syscall sys_rtc
1913   0BC8 1A          	mov al, ah
1914   0BC9 3E          	mov [d], al			; set day
1915   0BCA 79          	inc d
1916   0BCB 19 05       	mov al, 5
1917   0BCD 05 01       	syscall sys_rtc
1918   0BCF 1A          	mov al, ah
1919   0BD0 3E          	mov [d], al			; set month
1920   0BD1 79          	inc d
1921   0BD2 19 06       	mov al, 6
1922   0BD4 05 01       	syscall sys_rtc
1923   0BD6 1A          	mov al, ah
1924   0BD7 3E          	mov [d], al			; set year
1925   0BD8             ; write sector into disk for new directory entry
1926   0BD8 FD 27       	mov b, g
1927   0BDA 38 00 00    	mov c, 0
1928   0BDD 3B 65 25    	mov d, scrap_sector
1929   0BE0 22 01       	mov ah, $01			; disk write, 1 sector
1930   0BE2 07 61 05    	call ide_write_sect		; write sector
1931   0BE5 06          	sysret
1932   0BE6             
1933   0BE6             ;------------------------------------------------------------------------------------------------------;
1934   0BE6             ; finds an empty data block
1935   0BE6             ; block LBA returned in B
1936   0BE6             ;------------------------------------------------------------------------------------------------------;
1937   0BE6             fs_find_empty_block:
1938   0BE6 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1939   0BE9 38 00 00      mov c, 0                ; upper LBA = 0
1940   0BEC             fs_find_empty_block_L1:  
1941   0BEC 22 01         mov ah, $01                  ; 1 sector
1942   0BEE 3B 65 25      mov d, transient_area - 512
1943   0BF1 07 3B 05      call ide_read_sect      ; read sector
1944   0BF4 BD 00         cmp byte [d], 0
1945   0BF6 C6 FF 0B      je fs_find_empty_block_found_null
1946   0BF9 55 20 00      add b, FS_SECTORS_PER_FILE
1947   0BFC 0A EC 0B      jmp fs_find_empty_block_L1
1948   0BFF             fs_find_empty_block_found_null:
1949   0BFF 09            ret
1950   0C00             
1951   0C00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1952   0C00             ;; CREATE NEW TEXTFILE
1953   0C00             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1954   0C00             ; search for first null block
1955   0C00             fs_mktxt:
1956   0C00 FD 4E       	mov si, d
1957   0C02 FD 4F 65 1F 	mov di, user_data
1958   0C06 38 00 01    	mov c, 256
1959   0C09 04          	load					; load data from user-space
1960   0C0A             	
1961   0C0A 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1962   0C0D 38 00 00    	mov c, 0						; reset LBA to 0
1963   0C10             fs_mktxt_L1:	
1964   0C10 10 02 01    	mov a, $0102			; disk read
1965   0C13 3B 65 27    	mov d, transient_area
1966   0C16 05 02       	syscall sys_ide ; read sector
1967   0C18 1E          	mov al, [d]
1968   0C19 B9 00       	cmp al, 0			; check for NULL
1969   0C1B C6 24 0C    	je fs_mktxt_found_null
1970   0C1E 55 20 00    	add b, FS_SECTORS_PER_FILE
1971   0C21 0A 10 0C    	jmp fs_mktxt_L1
1972   0C24             fs_mktxt_found_null:
1973   0C24 D8          	push b				; save LBA
1974   0C25             ;create header file by grabbing file name from parameter	
1975   0C25 3B 34 18    	mov d, s_dataentry
1976   0C28 07 DE 12    	call _puts
1977   0C2B 3B 65 29    	mov d, transient_area + 512			; pointer to file contents
1978   0C2E 07 44 12    	call _gettxt
1979   0C31 07 11 11    	call _strlen						; get length of file
1980   0C34 D9          	push c							; save length
1981   0C35 19 01       	mov al, 1
1982   0C37 3D 65 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1983   0C3A 10 00 00    	mov a, 0
1984   0C3D 42 10 18    	mov [index], a
1985   0C40 3B 65 27    	mov d, transient_area
1986   0C43 13          	mov a, d
1987   0C44 42 12 18    	mov [buffer_addr], a
1988   0C47             fs_mktxt_L2:
1989   0C47 38 00 00    	mov c, 0
1990   0C4A 10 03 01    	mov a, $0103			; disk write, 1 sector
1991   0C4D 05 02       	syscall sys_ide		; write sector
1992   0C4F 14 10 18    	mov a, [index]
1993   0C52 77          	inc a
1994   0C53 42 10 18    	mov [index], a
1995   0C56 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1996   0C59 C6 6B 0C    	je fs_mktxt_add_to_dir
1997   0C5C FD 77       	inc b
1998   0C5E 14 12 18    	mov a, [buffer_addr]
1999   0C61 53 00 02    	add a, 512
2000   0C64 42 12 18    	mov [buffer_addr], a
2001   0C67 3C          	mov d, a
2002   0C68 0A 47 0C    	jmp fs_mktxt_L2
2003   0C6B             ; now we add the file to the current directory!
2004   0C6B             fs_mktxt_add_to_dir:	
2005   0C6B 14 18 18    	mov a, [current_dir_id]
2006   0C6E 77          	inc a
2007   0C6F 27          	mov b, a					; metadata sector
2008   0C70 38 00 00    	mov c, 0
2009   0C73 FD 79       	mov g, b					; save LBA
2010   0C75 3B 65 27    	mov d, transient_area
2011   0C78 10 02 01    	mov a, $0102			; disk read
2012   0C7B 05 02       	syscall sys_ide		; read metadata sector
2013   0C7D             fs_mktxt_add_to_dir_L2:
2014   0C7D 1E          	mov al, [d]
2015   0C7E B9 00       	cmp al, 0
2016   0C80 C6 89 0C    	je fs_mktxt_add_to_dir_null
2017   0C83 58 20 00    	add d, FST_ENTRY_SIZE
2018   0C86 0A 7D 0C    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2019   0C89             fs_mktxt_add_to_dir_null:
2020   0C89 FD 4D 65 1F 	mov si, user_data
2021   0C8D FD 50       	mov di, d
2022   0C8F 07 36 11    	call _strcpy			; copy file name
2023   0C92 58 18 00    	add d, 24			; skip name
2024   0C95 19 06       	mov al, %00000110		; no execute, write, read, not directory
2025   0C97 3E          	mov [d], al			
2026   0C98 58 03 00    	add d, 3
2027   0C9B E4          	pop a
2028   0C9C 43          	mov [d], a
2029   0C9D 63 02 00    	sub d, 2
2030   0CA0 E5          	pop b				; get file LBA
2031   0CA1 FD 43       	mov [d], b			; save LBA	
2032   0CA3             	
2033   0CA3             	; set file creation date	
2034   0CA3 58 04 00    	add d, 4
2035   0CA6 19 04       	mov al, 4
2036   0CA8 05 01       	syscall sys_rtc
2037   0CAA 1A          	mov al, ah
2038   0CAB 3E          	mov [d], al			; set day
2039   0CAC             	
2040   0CAC 79          	inc d
2041   0CAD 19 05       	mov al, 5
2042   0CAF 05 01       	syscall sys_rtc
2043   0CB1 1A          	mov al, ah
2044   0CB2 3E          	mov [d], al			; set month
2045   0CB3             	
2046   0CB3 79          	inc d
2047   0CB4 19 06       	mov al, 6
2048   0CB6 05 01       	syscall sys_rtc
2049   0CB8 1A          	mov al, ah
2050   0CB9 3E          	mov [d], al			; set year
2051   0CBA             	
2052   0CBA             ; write sector into disk for new directory entry
2053   0CBA FD 27       	mov b, g
2054   0CBC 38 00 00    	mov c, 0
2055   0CBF 3B 65 27    	mov d, transient_area
2056   0CC2 10 03 01    	mov a, $0103			; disk write, 1 sector
2057   0CC5 05 02       	syscall sys_ide		; write sector
2058   0CC7 07 8B 12    	call printnl
2059   0CCA 06          	sysret
2060   0CCB             
2061   0CCB             
2062   0CCB             
2063   0CCB             ;------------------------------------------------------------------------------------------------------;
2064   0CCB             ; create new binary file
2065   0CCB             ;------------------------------------------------------------------------------------------------------;
2066   0CCB             ; search for first null block
2067   0CCB             fs_mkbin:
2068   0CCB 19 00         mov al, 0
2069   0CCD 3D 08 18      mov [sys_echo_on], al ; disable echo
2070   0CD0 FD 4E         mov si, d
2071   0CD2 FD 4F 65 1F   mov di, user_data
2072   0CD6 38 00 02      mov c, 512
2073   0CD9 04            load                          ; load data from user-space
2074   0CDA 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2075   0CDD 38 00 00      mov c, 0                      ; upper LBA = 0
2076   0CE0             fs_mkbin_L1:  
2077   0CE0 22 01         mov ah, $01                  ; 1 sector
2078   0CE2 3B 65 27      mov d, transient_area
2079   0CE5 07 3B 05      call ide_read_sect            ; read sector
2080   0CE8 BD 00         cmp byte[d], 0                ; check for NULL
2081   0CEA C6 F3 0C      je fs_mkbin_found_null
2082   0CED 55 20 00      add b, FS_SECTORS_PER_FILE
2083   0CF0 0A E0 0C      jmp fs_mkbin_L1
2084   0CF3             fs_mkbin_found_null:
2085   0CF3 D8            push b                        ; save LBA
2086   0CF4             ;create header file by grabbing file name from parameter
2087   0CF4 FD 4F 65 29   mov di, transient_area + 512  ; pointer to file contents
2088   0CF8 07 6E 10      call _load_hex                ; load binary hex
2089   0CFB D9            push c                        ; save size (nbr of bytes)
2090   0CFC 19 01         mov al, 1
2091   0CFE 3D 65 27      mov [transient_area], al      ; mark sectors as USED (not NULL)
2092   0D01 FD 10         cla
2093   0D03 42 10 18      mov [index], a
2094   0D06 3B 65 27      mov d, transient_area
2095   0D09 13            mov a, d
2096   0D0A 42 12 18      mov [buffer_addr], a
2097   0D0D             fs_mkbin_L2:
2098   0D0D 38 00 00      mov c, 0
2099   0D10 22 01         mov ah, $01                   ; disk write, 1 sector
2100   0D12 07 61 05      call ide_write_sect           ; write sector
2101   0D15 14 10 18      mov a, [index]
2102   0D18 77            inc a
2103   0D19 42 10 18      mov [index], a
2104   0D1C AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2105   0D1F C6 31 0D      je fs_mkbin_add_to_dir
2106   0D22 FD 77         inc b
2107   0D24 14 12 18      mov a, [buffer_addr]
2108   0D27 53 00 02      add a, 512
2109   0D2A 42 12 18      mov [buffer_addr], a
2110   0D2D 3C            mov d, a
2111   0D2E 0A 0D 0D      jmp fs_mkbin_L2
2112   0D31             ; now we add the file to the current directory!
2113   0D31             fs_mkbin_add_to_dir:  
2114   0D31 14 18 18      mov a, [current_dir_id]
2115   0D34 77            inc a
2116   0D35 27            mov b, a                      ; metadata sector
2117   0D36 38 00 00      mov c, 0
2118   0D39 FD 79         mov g, b                      ; save LBA
2119   0D3B 3B 65 27      mov d, transient_area
2120   0D3E 22 01         mov ah, $01                  ; 1 sector
2121   0D40 07 3B 05      call ide_read_sect            ; read metadata sector
2122   0D43             fs_mkbin_add_to_dir_L2:
2123   0D43 BD 00         cmp byte[d], 0
2124   0D45 C6 4E 0D      je fs_mkbin_add_to_dir_null
2125   0D48 58 20 00      add d, FST_ENTRY_SIZE
2126   0D4B 0A 43 0D      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2127   0D4E             fs_mkbin_add_to_dir_null:
2128   0D4E FD 4D 65 1F   mov si, user_data
2129   0D52 FD 50         mov di, d
2130   0D54 07 36 11      call _strcpy                  ; copy file name
2131   0D57 58 18 00      add d, 24                     ; skip name
2132   0D5A 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2133   0D5C 3E            mov [d], al
2134   0D5D 58 03 00      add d, 3
2135   0D60 E4            pop a
2136   0D61 43            mov [d], a
2137   0D62 63 02 00      sub d, 2
2138   0D65 E5            pop b                         ; get file LBA
2139   0D66 FD 43         mov [d], b                    ; save LBA
2140   0D68               ; set file creation date  
2141   0D68 58 04 00      add d, 4
2142   0D6B 19 04         mov al, 4
2143   0D6D 05 01         syscall sys_rtc
2144   0D6F 1A            mov al, ah
2145   0D70 3E            mov [d], al                   ; set day
2146   0D71 79            inc d
2147   0D72 19 05         mov al, 5
2148   0D74 05 01         syscall sys_rtc
2149   0D76 1A            mov al, ah
2150   0D77 3E            mov [d], al                   ; set month
2151   0D78 79            inc d
2152   0D79 19 06         mov al, 6
2153   0D7B 05 01         syscall sys_rtc
2154   0D7D 1A            mov al, ah
2155   0D7E 3E            mov [d], al                   ; set year
2156   0D7F             ; write sector into disk for new directory entry
2157   0D7F FD 27         mov b, g
2158   0D81 38 00 00      mov c, 0
2159   0D84 3B 65 27      mov d, transient_area
2160   0D87 22 01         mov ah, $01                   ; disk write, 1 sector
2161   0D89 07 61 05      call ide_write_sect           ; write sector
2162   0D8C 19 01         mov al, 1
2163   0D8E 3D 08 18      mov [sys_echo_on], al ; enable echo
2164   0D91 06            sysret
2165   0D92             
2166   0D92             ;------------------------------------------------------------------------------------------------------;
2167   0D92             ; pwd - print working directory
2168   0D92             ;------------------------------------------------------------------------------------------------------;    
2169   0D92             fs_pwd:
2170   0D92 3B E5 1E      mov d, filename
2171   0D95 19 00         mov al, 0
2172   0D97 3E            mov [d], al                   ; initialize path string 
2173   0D98 14 18 18      mov a, [current_dir_id]
2174   0D9B 07 71 08      call fs_dir_id_to_path_E0
2175   0D9E 3B E5 1E      mov d, filename
2176   0DA1 07 CA 10      call _strrev
2177   0DA4 07 DE 12      call _puts
2178   0DA7 07 8B 12      call printnl
2179   0DAA 06            sysret
2180   0DAB             
2181   0DAB             ;------------------------------------------------------------------------------------------------------;
2182   0DAB             ; get current directory LBA
2183   0DAB             ; A: returned LBA
2184   0DAB             ;------------------------------------------------------------------------------------------------------;
2185   0DAB             cmd_get_curr_dir_LBA:
2186   0DAB 14 18 18      mov a, [current_dir_id]
2187   0DAE 06            sysret
2188   0DAF             
2189   0DAF             ;------------------------------------------------------------------------------------------------------;
2190   0DAF             ; CAT
2191   0DAF             ; userspace destination data pointer in D
2192   0DAF             ; filename starts at D, but is overwritten after the read is made
2193   0DAF             ;------------------------------------------------------------------------------------------------------;:
2194   0DAF             fs_cat:
2195   0DAF DA            push d                              ; save userspace file data destination
2196   0DB0 FD 4E         mov si, d
2197   0DB2 FD 4F 65 1F   mov di, user_data
2198   0DB6 38 00 02      mov c, 512
2199   0DB9 04            load                                ; copy filename from user-space
2200   0DBA 29 18 18      mov b, [current_dir_id]
2201   0DBD FD 77         inc b                               ; metadata sector
2202   0DBF 38 00 00      mov c, 0                            ; upper LBA = 0
2203   0DC2 22 01         mov ah, $01                  ; 1 sector
2204   0DC4 3B 65 25      mov d, transient_area-512
2205   0DC7 07 3B 05      call ide_read_sect                  ; read directory
2206   0DCA FD 10         cla
2207   0DCC 42 10 18      mov [index], a                      ; reset file counter
2208   0DCF             fs_cat_L1:
2209   0DCF FD 4E         mov si, d
2210   0DD1 FD 4F 65 1F   mov di, user_data
2211   0DD5 07 21 11      call _strcmp
2212   0DD8 C6 EE 0D      je fs_cat_found_entry
2213   0DDB 58 20 00      add d, 32
2214   0DDE 14 10 18      mov a, [index]
2215   0DE1 77            inc a
2216   0DE2 42 10 18      mov [index], a
2217   0DE5 AF 10 00      cmp a, FST_FILES_PER_DIR
2218   0DE8 C6 09 0E      je fs_cat_not_found
2219   0DEB 0A CF 0D      jmp fs_cat_L1
2220   0DEE             fs_cat_found_entry:
2221   0DEE 58 19 00      add d, 25                           ; get to dirID of file in disk
2222   0DF1 2A            mov b, [d]                          ; get LBA
2223   0DF2 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2224   0DF4 3B 65 27      mov d, transient_area  
2225   0DF7 38 00 00      mov c, 0
2226   0DFA 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2227   0DFC 07 3B 05      call ide_read_sect                  ; read sectors
2228   0DFF F0            pop di                              ; write userspace file data destination to DI
2229   0E00 FD 4D 65 27   mov si, transient_area              ; data origin
2230   0E04 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2231   0E07 03            store
2232   0E08 06            sysret
2233   0E09             fs_cat_not_found:
2234   0E09 E7            pop d
2235   0E0A 06            sysret
2236   0E0B             
2237   0E0B             ;------------------------------------------------------------------------------------------------------;
2238   0E0B             ; RMDIR - remove DIR by dirID
2239   0E0B             ;------------------------------------------------------------------------------------------------------;
2240   0E0B             ; deletes a directory entry in the given directory's file list 
2241   0E0B             ; also deletes the actual directory entry in the FST
2242   0E0B             ; synopsis: rmdir /usr/local/testdir
2243   0E0B             ; B = dirID
2244   0E0B             fs_rmdir:
2245   0E0B FD 79         mov g, b
2246   0E0D 11            mov a, b
2247   0E0E 07 AD 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2248   0E11 D7            push a                        ; save dirID
2249   0E12             ; search for directory's entry in the parent's directory then and delete it
2250   0E12 77            inc a                         ; metadata sector
2251   0E13 27            mov b, a
2252   0E14 38 00 00      mov c, 0                      ; upper LBA = 0
2253   0E17 22 01         mov ah, $01          ;
2254   0E19 3B 65 27      mov d, transient_area
2255   0E1C 07 3B 05      call ide_read_sect            ; read directory
2256   0E1F FD 10         cla
2257   0E21 42 10 18      mov [index], a                ; reset file counter
2258   0E24 FD 27         mov b, g                      ; retrieve directory's dirID
2259   0E26             fs_rmdir_L1:
2260   0E26 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2261   0E29 B0            cmp a, b                      ; compare dirID's to find the directory
2262   0E2A C6 40 0E      je fs_rmdir_found_entry
2263   0E2D 58 20 00      add d, 32
2264   0E30 14 10 18      mov a, [index]
2265   0E33 77            inc a
2266   0E34 42 10 18      mov [index], a
2267   0E37 AF 10 00      cmp a, FST_FILES_PER_DIR
2268   0E3A C6 65 0E      je fs_rmdir_not_found
2269   0E3D 0A 26 0E      jmp fs_rmdir_L1
2270   0E40             fs_rmdir_found_entry:
2271   0E40 FD 10         cla
2272   0E42 3E            mov [d], al                   ; make filename NULL
2273   0E43 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2274   0E46 E5            pop b
2275   0E47 FD 77         inc b                         ; metadata sector
2276   0E49 38 00 00      mov c, 0                      ; upper LBA = 0
2277   0E4C 22 01         mov ah, $01          ; 
2278   0E4E 3B 65 27      mov d, transient_area
2279   0E51 07 61 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2280   0E54             
2281   0E54 FD 27         mov b, g
2282   0E56 3B 65 27      mov d, transient_area  
2283   0E59 FD 10         cla
2284   0E5B 3E            mov [d], al                   ; make directory's name header NULL for re-use
2285   0E5C 38 00 00      mov c, 0
2286   0E5F 22 01         mov ah, $01                   ; disk write 1 sect
2287   0E61 07 61 05      call ide_write_sect           ; delete directory given by dirID in B
2288   0E64 06            sysret
2289   0E65             fs_rmdir_not_found:
2290   0E65 E5            pop b
2291   0E66 06            sysret
2292   0E67             
2293   0E67             ;------------------------------------------------------------------------------------------------------;
2294   0E67             ; RM - remove file
2295   0E67             ;------------------------------------------------------------------------------------------------------;
2296   0E67             ; frees up the data sectors for the file further down the disk
2297   0E67             ; deletes file entry in the directory's file list 
2298   0E67             fs_rm:
2299   0E67 FD 4E         mov si, d
2300   0E69 FD 4F 65 1F   mov di, user_data
2301   0E6D 38 00 02      mov c, 512
2302   0E70 04            load                          ; load data from user-space
2303   0E71 14 18 18      mov a, [current_dir_id]
2304   0E74 77            inc a                         ; metadata sector
2305   0E75 27            mov b, a
2306   0E76 38 00 00      mov c, 0                      ; upper LBA = 0
2307   0E79 22 01         mov ah, $01                  ; 1 sector
2308   0E7B 3B 65 27      mov d, transient_area
2309   0E7E 07 3B 05      call ide_read_sect            ; read directory
2310   0E81 10 00 00      mov a, 0
2311   0E84 42 10 18      mov [index], a                ; reset file counter
2312   0E87             fs_rm_L1:
2313   0E87 FD 4E         mov si, d
2314   0E89 FD 4F 65 1F   mov di, user_data
2315   0E8D 07 21 11      call _strcmp
2316   0E90 C6 A6 0E      je fs_rm_found_entry
2317   0E93 58 20 00      add d, 32
2318   0E96 14 10 18      mov a, [index]
2319   0E99 77            inc a
2320   0E9A 42 10 18      mov [index], a
2321   0E9D AF 10 00      cmp a, FST_FILES_PER_DIR
2322   0EA0 C6 CE 0E      je fs_rm_not_found
2323   0EA3 0A 87 0E      jmp fs_rm_L1
2324   0EA6             fs_rm_found_entry:
2325   0EA6 2B 19 00      mov b, [d + 25]               ; get LBA
2326   0EA9 FD 79         mov g, b                      ; save LBA
2327   0EAB 19 00         mov al, 0
2328   0EAD 3E            mov [d], al                   ; make file entry NULL
2329   0EAE 14 18 18      mov a, [current_dir_id]
2330   0EB1 77            inc a                         ; metadata sector
2331   0EB2 27            mov b, a
2332   0EB3 38 00 00      mov c, 0                      ; upper LBA = 0
2333   0EB6 22 01         mov ah, $01                   ; disk write
2334   0EB8 3B 65 27      mov d, transient_area
2335   0EBB 07 61 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2336   0EBE 3B 65 27      mov d, transient_area  
2337   0EC1 19 00         mov al, 0
2338   0EC3 3E            mov [d], al                   ; make file's data header NULL for re-use
2339   0EC4 38 00 00      mov c, 0
2340   0EC7 FD 27         mov b, g                      ; get data header LBA
2341   0EC9 22 01         mov ah, $01                   ; disk write 1 sect
2342   0ECB 07 61 05      call ide_write_sect           ; write sector
2343   0ECE             fs_rm_not_found:  
2344   0ECE 06            sysret  
2345   0ECF             
2346   0ECF             ;------------------------------------------------------------------------------------------------------;
2347   0ECF             ; mv - move / change file name
2348   0ECF             ;------------------------------------------------------------------------------------------------------;
2349   0ECF             fs_mv:
2350   0ECF FD 4E         mov si, d
2351   0ED1 FD 4F 65 1F   mov di, user_data
2352   0ED5 38 00 02      mov c, 512
2353   0ED8 04            load                          ; load data from user-space
2354   0ED9 14 18 18      mov a, [current_dir_id]
2355   0EDC 77            inc a                         ; metadata sector
2356   0EDD 27            mov b, a  
2357   0EDE 38 00 00      mov c, 0                      ; upper LBA = 0
2358   0EE1 22 01         mov ah, $01                  ; 1 sector
2359   0EE3 3B 65 27      mov d, transient_area
2360   0EE6 07 3B 05      call ide_read_sect            ; read directory
2361   0EE9 FD 10         cla
2362   0EEB 42 10 18      mov [index], a                ; reset file counter
2363   0EEE             fs_mv_L1:
2364   0EEE FD 4E         mov si, d
2365   0EF0 FD 4F 65 1F   mov di, user_data
2366   0EF4 07 21 11      call _strcmp
2367   0EF7 C6 0D 0F      je fs_mv_found_entry
2368   0EFA 58 20 00      add d, 32
2369   0EFD 14 10 18      mov a, [index]
2370   0F00 77            inc a
2371   0F01 42 10 18      mov [index], a
2372   0F04 AF 10 00      cmp a, FST_FILES_PER_DIR
2373   0F07 C6 3F 0F      je fs_mv_not_found
2374   0F0A 0A EE 0E      jmp fs_mv_L1
2375   0F0D             fs_mv_found_entry:  
2376   0F0D DA            push d
2377   0F0E FD 4D E5 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2378   0F12 FD 50         mov di, d
2379   0F14 07 36 11      call _strcpy  
2380   0F17 38 00 00      mov c, 0
2381   0F1A 3B 65 27      mov d, transient_area
2382   0F1D 22 01         mov ah, $01                   ; disk write 1 sect
2383   0F1F 07 61 05      call ide_write_sect           ; write sector
2384   0F22 E7            pop d
2385   0F23             ;; need to check whether its a dir or a file here ;;;
2386   0F23 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2387   0F26 22 01         mov ah, $01
2388   0F28 3B 65 27      mov d, transient_area
2389   0F2B 38 00 00      mov c, 0
2390   0F2E 07 3B 05      call ide_read_sect            ; read directory entry
2391   0F31 FD 4D E5 1F   mov si, user_data + 128
2392   0F35 FD 50         mov di, d
2393   0F37 07 36 11      call _strcpy                  ; change directory's name
2394   0F3A 22 01         mov ah, $01
2395   0F3C 07 61 05      call ide_write_sect           ; rewrite directory back to disk
2396   0F3F             fs_mv_not_found:
2397   0F3F 06            sysret
2398   0F40             
2399   0F40             
2400   0F40             ;----------------------------------------------------------------------------------------------------;
2401   0F40             ; Process Index in A
2402   0F40             ;----------------------------------------------------------------------------------------------------;
2403   0F40             find_free_proc:
2404   0F40 FD 4D D6 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2405   0F44             find_free_proc_L0:
2406   0F44 F6            lodsb                               ; get process state
2407   0F45 B9 00         cmp al, 0
2408   0F47 C6 4D 0F      je find_free_proc_free              ; if free, jump
2409   0F4A 0A 44 0F      jmp find_free_proc_L0               ; else, goto next
2410   0F4D             find_free_proc_free:
2411   0F4D 4E            mov a, si
2412   0F4E 5F D6 1C      sub a, 1 + proc_availab_table       ; get process index
2413   0F51 09            ret
2414   0F52               
2415   0F52             
2416   0F52             ;----------------------------------------------------------------------------------------------------;
2417   0F52             ; Process Index in AL
2418   0F52             ;----------------------------------------------------------------------------------------------------;
2419   0F52             proc_memory_map:
2420   0F52 22 00         mov ah, 0
2421   0F54 27            mov b, a                      ; page in BL, 0 in BH
2422   0F55 FD 9D 05      shl a, 5                      ; multiply by 32
2423   0F58 39            mov c, a                      ; save in C
2424   0F59 57 20 00      add c, 32
2425   0F5C             proc_memory_map_L0:
2426   0F5C 02            pagemap
2427   0F5D 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2428   0F60 53 01 00      add a, 1                      ; increase both 
2429   0F63 B1            cmp a, c                      ; check to see if we reached the end of memory
2430   0F64 C7 5C 0F      jne proc_memory_map_L0
2431   0F67 09            ret
2432   0F68               
2433   0F68             
2434   0F68             ;----------------------------------------------------------------------------------------------------;
2435   0F68             ; terminate process
2436   0F68             ;----------------------------------------------------------------------------------------------------;
2437   0F68             syscall_terminate_proc:
2438   0F68 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2439   0F6B                                                    ; since they will not be used for anything here.
2440   0F6B 1D 0F 18      mov al, [active_proc_index]
2441   0F6E 22 00         mov ah, 0  
2442   0F70 FD 9D 05      shl a, 5                             ; x32
2443   0F73 53 E5 1C      add a, proc_names
2444   0F76 3C            mov d, a
2445   0F77 19 00         mov al, 0
2446   0F79 3E            mov [d], al                           ; nullify process name
2447   0F7A             
2448   0F7A 1D 0F 18      mov al, [active_proc_index]
2449   0F7D 22 00         mov ah, 0  
2450   0F7F 3C            mov d, a
2451   0F80 19 00         mov al, 0
2452   0F82 3F D5 1C      mov [d + proc_availab_table], al    ; make process empty again
2453   0F85               
2454   0F85 1D 0E 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2455   0F88 80            dec al
2456   0F89 3D 0E 18      mov [nbr_active_procs], al
2457   0F8C             
2458   0F8C             ; now load the shell process again
2459   0F8C 19 02         mov al, 2                           ; next process = process 2 = shell
2460   0F8E 3D 0F 18      mov [active_proc_index], al         ; set next active proc
2461   0F91             
2462   0F91             ; calculate LUT entry for next process
2463   0F91 22 00         mov ah, 0
2464   0F93 FD 99         shl a                               ; x2
2465   0F95 B7 5E 10      mov a, [proc_table_convert + a]     ; get process state start index  
2466   0F98               
2467   0F98 4D            mov si, a                           ; source is proc state block
2468   0F99 48            mov a, sp
2469   0F9A 5F 13 00      sub a, 19
2470   0F9D 4F            mov di, a                           ; destination is kernel stack
2471   0F9E             ; restore SP
2472   0F9E 7D            dec a
2473   0F9F 47            mov sp, a
2474   0FA0 38 14 00      mov c, 20
2475   0FA3 FD F5         rep movsb
2476   0FA5             ; set VM process
2477   0FA5 1D 0F 18      mov al, [active_proc_index]
2478   0FA8 01            setptb
2479   0FA9                 
2480   0FA9 4C            popa
2481   0FAA 06            sysret
2482   0FAB             
2483   0FAB             ;----------------------------------------------------------------------------------------------------;
2484   0FAB             ; pause process
2485   0FAB             ;----------------------------------------------------------------------------------------------------;
2486   0FAB             syscall_pause_proc:
2487   0FAB             ; save all registers into kernel stack
2488   0FAB 4B            pusha
2489   0FAC 22 00         mov ah, 0
2490   0FAE 1D 0F 18      mov al, [active_proc_index]
2491   0FB1 FD 99         shl a              ; x2
2492   0FB3 B7 5E 10      mov a, [proc_table_convert + a]   ; get process state start index
2493   0FB6                 
2494   0FB6 4F            mov di, a
2495   0FB7 48            mov a, sp
2496   0FB8 77            inc a
2497   0FB9 4D            mov si, a
2498   0FBA 38 14 00      mov c, 20
2499   0FBD FD F5         rep movsb                         ; save process state!
2500   0FBF             ; restore kernel stack position to point before interrupt arrived
2501   0FBF 51 14 00      add sp, 20
2502   0FC2             ; now load the shell process again
2503   0FC2 19 02         mov al, 2                         ; next process = process 2 = shell
2504   0FC4 3D 0F 18      mov [active_proc_index], al       ; set next active proc
2505   0FC7             
2506   0FC7             ; calculate LUT entry for next process
2507   0FC7 22 00         mov ah, 0
2508   0FC9 FD 99         shl a                             ; x2
2509   0FCB B7 5E 10      mov a, [proc_table_convert + a]   ; get process state start index  
2510   0FCE               
2511   0FCE 4D            mov si, a                         ; source is proc state block
2512   0FCF 48            mov a, sp
2513   0FD0 5F 13 00      sub a, 19
2514   0FD3 4F            mov di, a                         ; destination is kernel stack
2515   0FD4             ; restore SP
2516   0FD4 7D            dec a
2517   0FD5 47            mov sp, a
2518   0FD6 38 14 00      mov c, 20
2519   0FD9 FD F5         rep movsb
2520   0FDB             ; set VM process
2521   0FDB 1D 0F 18      mov al, [active_proc_index]
2522   0FDE 01            setptb
2523   0FDF                 
2524   0FDF 4C            popa
2525   0FE0 06            sysret
2526   0FE1             
2527   0FE1             ;----------------------------------------------------------------------------------------------------;
2528   0FE1             ; create a new process
2529   0FE1             ; D = path of the process file to be createed
2530   0FE1             ; B = arguments ptr
2531   0FE1             ;----------------------------------------------------------------------------------------------------;
2532   0FE1             syscall_create_proc:
2533   0FE1             ; we save the active process first  
2534   0FE1 4B            pusha
2535   0FE2 22 00         mov ah, 0
2536   0FE4 1D 0F 18      mov al, [active_proc_index]
2537   0FE7 FD 99         shl a              ; x2
2538   0FE9 B7 5E 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2539   0FEC               
2540   0FEC 4F            mov di, a
2541   0FED 48            mov a, sp
2542   0FEE 77            inc a
2543   0FEF 4D            mov si, a
2544   0FF0 38 14 00      mov c, 20
2545   0FF3 FD F5         rep movsb                          ; save process state!
2546   0FF5             ; restore kernel stack position to point before interrupt arrived
2547   0FF5 51 14 00      add sp, 20
2548   0FF8               
2549   0FF8 FD 4E         mov si, d                          ; copy the file path
2550   0FFA FD 4F 65 1F   mov di, user_data
2551   0FFE 38 00 02      mov c, 512
2552   1001 04            load
2553   1002 11            mov a, b
2554   1003 4D            mov si, a                          ; copy the arguments
2555   1004 FD 4F 65 25   mov di, scrap_sector
2556   1008 38 00 02      mov c, 512
2557   100B 04            load
2558   100C 07 F3 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2559   100F                                                  ; the file data is loaded into transient_area
2560   100F             ; now we allocate a new process  
2561   100F 07 40 0F      call find_free_proc                ; index in A
2562   1012 01            setptb 
2563   1013 07 52 0F      call proc_memory_map               ; map process memory pages
2564   1016             ; copy arguments into process's memory
2565   1016 FD 4D 65 25   mov si, scrap_sector
2566   101A FD 4F 00 00   mov di, 0
2567   101E 38 00 02      mov c, 512
2568   1021 03            store
2569   1022             ; now copy process binary data into process's memory
2570   1022 FD 4D 65 27   mov si, transient_area
2571   1026 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2572   102A 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2573   102D 03            store                              ; copy process data
2574   102E                 
2575   102E 07 40 0F      call find_free_proc                ; index in A
2576   1031 3D 0F 18      mov [active_proc_index], al        ; set new active process
2577   1034 FD 9D 05      shl a, 5                           ; x32
2578   1037 53 E5 1C      add a, proc_names
2579   103A 4F            mov di, a
2580   103B FD 4D 65 1F   mov si, user_data                  ; copy and store process filename
2581   103F 07 36 11      call _strcpy
2582   1042               
2583   1042 07 40 0F      call find_free_proc                ; index in A
2584   1045 3C            mov d, a
2585   1046 19 01         mov al, 1
2586   1048 3F D5 1C      mov [d + proc_availab_table], al   ; make process busy
2587   104B               
2588   104B 1D 0E 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2589   104E 7A            inc al
2590   104F 3D 0E 18      mov [nbr_active_procs], al
2591   1052             ; launch process
2592   1052 FD D7 FF FF   push word $FFFF 
2593   1056 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2594   1059 FD D7 00 04   push word text_org
2595   105D 06            sysret
2596   105E             
2597   105E             proc_table_convert:
2598   105E 95 1B         .dw proc_state_table + 0
2599   1060 A9 1B         .dw proc_state_table + 20
2600   1062 BD 1B         .dw proc_state_table + 40
2601   1064 D1 1B         .dw proc_state_table + 60
2602   1066 E5 1B         .dw proc_state_table + 80
2603   1068 F9 1B         .dw proc_state_table + 100
2604   106A 0D 1C         .dw proc_state_table + 120
2605   106C 21 1C         .dw proc_state_table + 140
2606   106E               
2607   106E             ;----------------------------------------------------------------------------------------------;
2608   106E             ; GET HEX FILE
2609   106E             ; di = destination address
2610   106E             ; return length in bytes in C
2611   106E             ;----------------------------------------------------------------------------------------------;
2612   106E             _load_hex:
2613   106E D7            push a
2614   106F D8            push b
2615   1070 DA            push d
2616   1071 E2            push si
2617   1072 E3            push di
2618   1073 38 00 00      mov c, 0
2619   1076 50            mov a, di
2620   1077 3C            mov d, a          ; start of string data block
2621   1078 07 B9 11      call _gets        ; get program string
2622   107B 4D            mov si, a
2623   107C             __load_hex_loop:
2624   107C F6            lodsb             ; load from [SI] to AL
2625   107D B9 00         cmp al, 0         ; check if ASCII 0
2626   107F C6 8D 10      jz __load_hex_ret
2627   1082 36            mov bh, al
2628   1083 F6            lodsb
2629   1084 2F            mov bl, al
2630   1085 07 6F 11      call _atoi        ; convert ASCII byte in B to int (to AL)
2631   1088 F7            stosb             ; store AL to [DI]
2632   1089 78            inc c
2633   108A 0A 7C 10      jmp __load_hex_loop
2634   108D             __load_hex_ret:
2635   108D F0            pop di
2636   108E EF            pop si
2637   108F E7            pop d
2638   1090 E5            pop b
2639   1091 E4            pop a
2640   1092 09            ret
2641   1093             
2642   1093             ; synopsis: look inside a certain directory for files/directories
2643   1093             ; before calling this function, cd into required directory
2644   1093             ; for each entry inside directory:
2645   1093             ;  if entry is a file:
2646   1093             ;    compare filename to searched filename
2647   1093             ;    if filenames are the same, print filename
2648   1093             ;  else if entry is a directory:
2649   1093             ;    cd to the given directory
2650   1093             ;    recursively call cmd_find
2651   1093             ;    cd outside previous directory
2652   1093             ;  if current entry == last entry, return
2653   1093             ; endfor
2654   1093             f_find:
2655   1093 09            ret
2656   1094             
2657   1094             
2658   1094             ; ---------------------------------------------------------------------
2659   1094             ; kernel reset vector
2660   1094             ; ---------------------------------------------------------------------
2661   1094             kernel_reset_vector:  
2662   1094 FD 49 FF F7   mov bp, STACK_BEGIN
2663   1098 FD 47 FF F7   mov sp, STACK_BEGIN
2664   109C               
2665   109C 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2666   109E FD 0F         stomsk                        
2667   10A0 FD 0C         sti  
2668   10A2             
2669   10A2 0C            lodstat
2670   10A3 87 DF         and al, %11011111             ; disable display register loading
2671   10A5 0D            stostat
2672   10A6               
2673   10A6             ; reset fifo pointers
2674   10A6 10 65 21      mov a, fifo
2675   10A9 3B 14 18      mov d, fifo_in
2676   10AC 43            mov [d], a
2677   10AD 3B 16 18      mov d, fifo_out
2678   10B0 43            mov [d], a  
2679   10B1 19 02         mov al, 2
2680   10B3 05 03         syscall sys_io                ; enable uart in interrupt mode
2681   10B5               
2682   10B5 3B 69 18      mov d, s_kernel_started
2683   10B8 07 DE 12      call _puts
2684   10BB             
2685   10BB 19 10         mov al, 16
2686   10BD 05 04         syscall sys_filesystem        ; set root dirID
2687   10BF             
2688   10BF 3B 86 18      mov d, s_prompt_init
2689   10C2 07 DE 12      call _puts
2690   10C5 3B 1A 18      mov d, s_init_path
2691   10C8 05 05         syscall sys_create_proc       ; launch init as a new process
2692   10CA             
2693   10CA             
2694   10CA             ; FILE INCLUDES
2695   10CA             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  10CA             BIOS_RESET_VECTOR .EQU  $01c0
0002+  10CA             IDE_buffer       .EQU  $8204
0003+  10CA             boot_origin      .EQU  $8004
0004+  10CA             bios_uart        .EQU  $0002
0005+  10CA             bios_ide         .EQU  $0003
2696   10CA             .include "lib/stdio.asm"
0001+  10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10CA             ; stdio.s
0003+  10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10CA             .include "lib/string.asm"
0001++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10CA             ; string.s
0003++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10CA             
0005++ 10CA             
0006++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10CA             ; _strrev
0008++ 10CA             ; reverse a string
0009++ 10CA             ; D = string address
0010++ 10CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10CA             ; 01234
0012++ 10CA             _strrev:
0013++ 10CA 4B          	pusha
0014++ 10CB 07 11 11    	call _strlen	; length in C
0015++ 10CE 12          	mov a, c
0016++ 10CF AF 01 00    	cmp a, 1
0017++ 10D2 D0 EC 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10D5 7D          	dec a
0019++ 10D6 FD 4E       	mov si, d	; beginning of string
0020++ 10D8 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10DA 59          	add d, a	; end of string
0022++ 10DB 12          	mov a, c
0023++ 10DC FD 9B       	shr a		; divide by 2
0024++ 10DE 39          	mov c, a	; C now counts the steps
0025++ 10DF             _strrev_L0:
0026++ 10DF 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10E0 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10E1 3E          	mov [d], al	; store left char into right side
0029++ 10E2 1B          	mov al, bl
0030++ 10E3 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10E4 7E          	dec c
0032++ 10E5 7F          	dec d
0033++ 10E6 C2 00 00    	cmp c, 0
0034++ 10E9 C7 DF 10    	jne _strrev_L0
0035++ 10EC             _strrev_end:
0036++ 10EC 4C          	popa
0037++ 10ED 09          	ret
0038++ 10EE             	
0039++ 10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10EE             ; _strchr
0041++ 10EE             ; search string in D for char in AL
0042++ 10EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10EE             _strchr:
0044++ 10EE             _strchr_L0:
0045++ 10EE 32          	mov bl, [d]
0046++ 10EF C1 00       	cmp bl, 0
0047++ 10F1 C6 FC 10    	je _strchr_end
0048++ 10F4 BA          	cmp al, bl
0049++ 10F5 C6 FC 10    	je _strchr_end
0050++ 10F8 79          	inc d
0051++ 10F9 0A EE 10    	jmp _strchr_L0
0052++ 10FC             _strchr_end:
0053++ 10FC 1B          	mov al, bl
0054++ 10FD 09          	ret
0055++ 10FE             
0056++ 10FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10FE             ; _strstr
0058++ 10FE             ; find sub-string
0059++ 10FE             ; str1 in SI
0060++ 10FE             ; str2 in DI
0061++ 10FE             ; SI points to end of source string
0062++ 10FE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10FE             _strstr:
0064++ 10FE DB          	push al
0065++ 10FF DA          	push d
0066++ 1100 E3          	push di
0067++ 1101             _strstr_loop:
0068++ 1101 F3          	cmpsb					; compare a byte of the strings
0069++ 1102 C7 0D 11    	jne _strstr_ret
0070++ 1105 FC 00 00    	lea d, [di + 0]
0071++ 1108 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 110A C7 01 11    	jne _strstr_loop				; equal chars but not at end
0073++ 110D             _strstr_ret:
0074++ 110D F0          	pop di
0075++ 110E E7          	pop d
0076++ 110F E8          	pop al
0077++ 1110 09          	ret
0078++ 1111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1111             ; length of null terminated string
0080++ 1111             ; result in C
0081++ 1111             ; pointer in D
0082++ 1111             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1111             _strlen:
0084++ 1111 DA          	push d
0085++ 1112 38 00 00    	mov c, 0
0086++ 1115             _strlen_L1:
0087++ 1115 BD 00       	cmp byte [d], 0
0088++ 1117 C6 1F 11    	je _strlen_ret
0089++ 111A 79          	inc d
0090++ 111B 78          	inc c
0091++ 111C 0A 15 11    	jmp _strlen_L1
0092++ 111F             _strlen_ret:
0093++ 111F E7          	pop d
0094++ 1120 09          	ret
0095++ 1121             
0096++ 1121             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1121             ; STRCMP
0098++ 1121             ; compare two strings
0099++ 1121             ; str1 in SI
0100++ 1121             ; str2 in DI
0101++ 1121             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1121             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1121             _strcmp:
0104++ 1121 DB          	push al
0105++ 1122 DA          	push d
0106++ 1123 E3          	push di
0107++ 1124 E2          	push si
0108++ 1125             _strcmp_loop:
0109++ 1125 F3          	cmpsb					; compare a byte of the strings
0110++ 1126 C7 31 11    	jne _strcmp_ret
0111++ 1129 FB FF FF    	lea d, [si +- 1]
0112++ 112C BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 112E C7 25 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1131             _strcmp_ret:
0115++ 1131 EF          	pop si
0116++ 1132 F0          	pop di
0117++ 1133 E7          	pop d
0118++ 1134 E8          	pop al
0119++ 1135 09          	ret
0120++ 1136             
0121++ 1136             
0122++ 1136             ; STRCPY
0123++ 1136             ; copy null terminated string from SI to DI
0124++ 1136             ; source in SI
0125++ 1136             ; destination in DI
0126++ 1136             _strcpy:
0127++ 1136 E2          	push si
0128++ 1137 E3          	push di
0129++ 1138 DB          	push al
0130++ 1139             _strcpy_L1:
0131++ 1139 F6          	lodsb
0132++ 113A F7          	stosb
0133++ 113B B9 00       	cmp al, 0
0134++ 113D C7 39 11    	jne _strcpy_L1
0135++ 1140             _strcpy_end:
0136++ 1140 E8          	pop al
0137++ 1141 F0          	pop di
0138++ 1142 EF          	pop si
0139++ 1143 09          	ret
0140++ 1144             
0141++ 1144             ; STRCAT
0142++ 1144             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 1144             ; source in SI
0144++ 1144             ; destination in DI
0145++ 1144             _strcat:
0146++ 1144 E2          	push si
0147++ 1145 E3          	push di
0148++ 1146 D7          	push a
0149++ 1147 DA          	push d
0150++ 1148 50          	mov a, di
0151++ 1149 3C          	mov d, a
0152++ 114A             _strcat_goto_end_L1:
0153++ 114A BD 00       	cmp byte[d], 0
0154++ 114C C6 53 11    	je _strcat_start
0155++ 114F 79          	inc d
0156++ 1150 0A 4A 11    	jmp _strcat_goto_end_L1
0157++ 1153             _strcat_start:
0158++ 1153 FD 50       	mov di, d
0159++ 1155             _strcat_L1:
0160++ 1155 F6          	lodsb
0161++ 1156 F7          	stosb
0162++ 1157 B9 00       	cmp al, 0
0163++ 1159 C7 55 11    	jne _strcat_L1
0164++ 115C             _strcat_end:
0165++ 115C E7          	pop d
0166++ 115D E4          	pop a
0167++ 115E F0          	pop di
0168++ 115F EF          	pop si
0169++ 1160 09          	ret
0170++ 1161             
0171++ 1161             
0005+  1161             
0006+  1161             
0007+  1161             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1161             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1161             ; ASCII in BL
0010+  1161             ; result in AL
0011+  1161             ; ascii for F = 0100 0110
0012+  1161             ; ascii for 9 = 0011 1001
0013+  1161             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1161             hex_ascii_encode:
0015+  1161 1B            mov al, bl
0016+  1162 93 40         test al, $40        ; test if letter or number
0017+  1164 C7 6A 11      jnz hex_letter
0018+  1167 87 0F         and al, $0F        ; get number
0019+  1169 09            ret
0020+  116A             hex_letter:
0021+  116A 87 0F         and al, $0F        ; get letter
0022+  116C 6A 09         add al, 9
0023+  116E 09            ret
0024+  116F             
0025+  116F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  116F             ; ATOI
0027+  116F             ; 2 letter hex string in B
0028+  116F             ; 8bit integer returned in AL
0029+  116F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  116F             _atoi:
0031+  116F D8            push b
0032+  1170 07 61 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1173 30            mov bl, bh
0034+  1174 DB            push al          ; save a
0035+  1175 07 61 11      call hex_ascii_encode
0036+  1178 EA            pop bl  
0037+  1179 FD 9E 04      shl al, 4
0038+  117C 8C            or al, bl
0039+  117D E5            pop b
0040+  117E 09            ret  
0041+  117F             
0042+  117F             
0043+  117F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  117F             ; scanf
0045+  117F             ; no need for explanations!
0046+  117F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  117F             scanf:
0048+  117F 09            ret
0049+  1180             
0050+  1180             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1180             ; ITOA
0052+  1180             ; 8bit value in BL
0053+  1180             ; 2 byte ASCII result in A
0054+  1180             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1180             _itoa:
0056+  1180 DA            push d
0057+  1181 D8            push b
0058+  1182 A7 00         mov bh, 0
0059+  1184 FD A4 04      shr bl, 4  
0060+  1187 74            mov d, b
0061+  1188 1F 1A 14      mov al, [d + s_hex_digits]
0062+  118B 23            mov ah, al
0063+  118C               
0064+  118C E5            pop b
0065+  118D D8            push b
0066+  118E A7 00         mov bh, 0
0067+  1190 FD 87 0F      and bl, $0F
0068+  1193 74            mov d, b
0069+  1194 1F 1A 14      mov al, [d + s_hex_digits]
0070+  1197 E5            pop b
0071+  1198 E7            pop d
0072+  1199 09            ret
0073+  119A             
0074+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  119A             ; HEX STRING TO BINARY
0076+  119A             ; di = destination address
0077+  119A             ; si = source
0078+  119A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  119A             _hex_to_int:
0080+  119A             _hex_to_int_L1:
0081+  119A F6            lodsb          ; load from [SI] to AL
0082+  119B B9 00         cmp al, 0        ; check if ASCII 0
0083+  119D C6 AA 11      jz _hex_to_int_ret
0084+  11A0 36            mov bh, al
0085+  11A1 F6            lodsb
0086+  11A2 2F            mov bl, al
0087+  11A3 07 6F 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  11A6 F7            stosb          ; store AL to [DI]
0089+  11A7 0A 9A 11      jmp _hex_to_int_L1
0090+  11AA             _hex_to_int_ret:
0091+  11AA 09            ret    
0092+  11AB             
0093+  11AB             
0094+  11AB             
0095+  11AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11AB             ; GETCHAR
0097+  11AB             ; char in ah
0098+  11AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11AB             getch:
0100+  11AB DB            push al
0101+  11AC             getch_retry:
0102+  11AC 19 01         mov al, 1
0103+  11AE 05 03         syscall sys_io      ; receive in AH
0104+  11B0 E8            pop al
0105+  11B1 09            ret
0106+  11B2             
0107+  11B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11B2             ; PUTCHAR
0109+  11B2             ; char in ah
0110+  11B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11B2             _putchar:
0112+  11B2 DB            push al
0113+  11B3 19 00         mov al, 0
0114+  11B5 05 03         syscall sys_io      ; char in AH
0115+  11B7 E8            pop al
0116+  11B8 09            ret
0117+  11B9             
0118+  11B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11B9             ;; INPUT A STRING
0120+  11B9             ;; terminates with null
0121+  11B9             ;; pointer in D
0122+  11B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11B9             _gets:
0124+  11B9 D7            push a
0125+  11BA DA            push d
0126+  11BB             _gets_loop:
0127+  11BB 19 01         mov al, 1
0128+  11BD 05 03         syscall sys_io      ; receive in AH
0129+  11BF 76 1B         cmp ah, 27
0130+  11C1 C6 E2 11      je _gets_ansi_esc
0131+  11C4 76 0A         cmp ah, $0A        ; LF
0132+  11C6 C6 3E 12      je _gets_end
0133+  11C9 76 0D         cmp ah, $0D        ; CR
0134+  11CB C6 3E 12      je _gets_end
0135+  11CE 76 5C         cmp ah, $5C        ; '\\'
0136+  11D0 C6 04 12      je _gets_escape
0137+  11D3 76 08         cmp ah, $08      ; check for backspace
0138+  11D5 C6 DE 11      je _gets_backspace
0139+  11D8 1A            mov al, ah
0140+  11D9 3E            mov [d], al
0141+  11DA 79            inc d
0142+  11DB 0A BB 11      jmp _gets_loop
0143+  11DE             _gets_backspace:
0144+  11DE 7F            dec d
0145+  11DF 0A BB 11      jmp _gets_loop
0146+  11E2             _gets_ansi_esc:
0147+  11E2 19 01         mov al, 1
0148+  11E4 05 03         syscall sys_io        ; receive in AH without echo
0149+  11E6 76 5B         cmp ah, '['
0150+  11E8 C7 BB 11      jne _gets_loop
0151+  11EB 19 01         mov al, 1
0152+  11ED 05 03         syscall sys_io          ; receive in AH without echo
0153+  11EF 76 44         cmp ah, 'D'
0154+  11F1 C6 FC 11      je _gets_left_arrow
0155+  11F4 76 43         cmp ah, 'C'
0156+  11F6 C6 00 12      je _gets_right_arrow
0157+  11F9 0A BB 11      jmp _gets_loop
0158+  11FC             _gets_left_arrow:
0159+  11FC 7F            dec d
0160+  11FD 0A BB 11      jmp _gets_loop
0161+  1200             _gets_right_arrow:
0162+  1200 79            inc d
0163+  1201 0A BB 11      jmp _gets_loop
0164+  1204             _gets_escape:
0165+  1204 19 01         mov al, 1
0166+  1206 05 03         syscall sys_io      ; receive in AH
0167+  1208 76 6E         cmp ah, 'n'
0168+  120A C6 29 12      je _gets_LF
0169+  120D 76 72         cmp ah, 'r'
0170+  120F C6 30 12      je _gets_CR
0171+  1212 76 30         cmp ah, '0'
0172+  1214 C6 37 12      je _gets_NULL
0173+  1217 76 5C         cmp ah, $5C  ; '\'
0174+  1219 C6 22 12      je _gets_slash
0175+  121C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  121D 3E            mov [d], al
0177+  121E 79            inc d
0178+  121F 0A BB 11      jmp _gets_loop
0179+  1222             _gets_slash:
0180+  1222 19 5C         mov al, $5C
0181+  1224 3E            mov [d], al
0182+  1225 79            inc d
0183+  1226 0A BB 11      jmp _gets_loop
0184+  1229             _gets_LF:
0185+  1229 19 0A         mov al, $0A
0186+  122B 3E            mov [d], al
0187+  122C 79            inc d
0188+  122D 0A BB 11      jmp _gets_loop
0189+  1230             _gets_CR:
0190+  1230 19 0D         mov al, $0D
0191+  1232 3E            mov [d], al
0192+  1233 79            inc d
0193+  1234 0A BB 11      jmp _gets_loop
0194+  1237             _gets_NULL:
0195+  1237 19 00         mov al, $00
0196+  1239 3E            mov [d], al
0197+  123A 79            inc d
0198+  123B 0A BB 11      jmp _gets_loop
0199+  123E             _gets_end:
0200+  123E 19 00         mov al, 0
0201+  1240 3E            mov [d], al        ; terminate string
0202+  1241 E7            pop d
0203+  1242 E4            pop a
0204+  1243 09            ret
0205+  1244             
0206+  1244             
0207+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1244             ;; INPUT TEXT
0209+  1244             ;; terminated with CTRL+D
0210+  1244             ;; pointer in D
0211+  1244             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1244             _gettxt:
0213+  1244 D7            push a
0214+  1245 DA            push d
0215+  1246             _gettxt_loop:
0216+  1246 19 01         mov al, 1
0217+  1248 05 03         syscall sys_io      ; receive in AH
0218+  124A 76 04         cmp ah, 4      ; EOT
0219+  124C C6 85 12      je _gettxt_end
0220+  124F 76 08         cmp ah, $08      ; check for backspace
0221+  1251 C6 81 12      je _gettxt_backspace
0222+  1254 76 5C         cmp ah, $5C        ; '\'
0223+  1256 C6 5F 12      je _gettxt_escape
0224+  1259 1A            mov al, ah
0225+  125A 3E            mov [d], al
0226+  125B 79            inc d
0227+  125C 0A 46 12      jmp _gettxt_loop
0228+  125F             _gettxt_escape:
0229+  125F 19 01         mov al, 1
0230+  1261 05 03         syscall sys_io      ; receive in AH
0231+  1263 76 6E         cmp ah, 'n'
0232+  1265 C6 73 12      je _gettxt_LF
0233+  1268 76 72         cmp ah, 'r'
0234+  126A C6 7A 12      je _gettxt_CR
0235+  126D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  126E 3E            mov [d], al
0237+  126F 79            inc d
0238+  1270 0A 46 12      jmp _gettxt_loop
0239+  1273             _gettxt_LF:
0240+  1273 19 0A         mov al, $0A
0241+  1275 3E            mov [d], al
0242+  1276 79            inc d
0243+  1277 0A 46 12      jmp _gettxt_loop
0244+  127A             _gettxt_CR:
0245+  127A 19 0D         mov al, $0D
0246+  127C 3E            mov [d], al
0247+  127D 79            inc d
0248+  127E 0A 46 12      jmp _gettxt_loop
0249+  1281             _gettxt_backspace:
0250+  1281 7F            dec d
0251+  1282 0A 46 12      jmp _gettxt_loop
0252+  1285             _gettxt_end:
0253+  1285 19 00         mov al, 0
0254+  1287 3E            mov [d], al        ; terminate string
0255+  1288 E7            pop d
0256+  1289 E4            pop a
0257+  128A 09            ret
0258+  128B             
0259+  128B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  128B             ; PRINT NEW LINE
0261+  128B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  128B             printnl:
0263+  128B D7            push a
0264+  128C 10 00 0A      mov a, $0A00
0265+  128F 05 03         syscall sys_io
0266+  1291 10 00 0D      mov a, $0D00
0267+  1294 05 03         syscall sys_io
0268+  1296 E4            pop a
0269+  1297 09            ret
0270+  1298             
0271+  1298             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  1298             ; _strtoint
0273+  1298             ; 4 digit hex string number in d
0274+  1298             ; integer returned in A
0275+  1298             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  1298             _strtointx:
0277+  1298 D8            push b
0278+  1299 32            mov bl, [d]
0279+  129A 37            mov bh, bl
0280+  129B 33 01 00      mov bl, [d + 1]
0281+  129E 07 6F 11      call _atoi        ; convert to int in AL
0282+  12A1 23            mov ah, al        ; move to AH
0283+  12A2 33 02 00      mov bl, [d + 2]
0284+  12A5 37            mov bh, bl
0285+  12A6 33 03 00      mov bl, [d + 3]
0286+  12A9 07 6F 11      call _atoi        ; convert to int in AL
0287+  12AC E5            pop b
0288+  12AD 09            ret
0289+  12AE             
0290+  12AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  12AE             ; _strtoint
0292+  12AE             ; 5 digit base10 string number in d
0293+  12AE             ; integer returned in A
0294+  12AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  12AE             _strtoint:
0296+  12AE E2            push si
0297+  12AF D8            push b
0298+  12B0 D9            push c
0299+  12B1 DA            push d
0300+  12B2 07 11 11      call _strlen      ; get string length in C
0301+  12B5 7E            dec c
0302+  12B6 FD 4E         mov si, d
0303+  12B8 12            mov a, c
0304+  12B9 FD 99         shl a
0305+  12BB 3B 32 14      mov d, table_power
0306+  12BE 59            add d, a
0307+  12BF 38 00 00      mov c, 0
0308+  12C2             _strtoint_L0:
0309+  12C2 F6            lodsb      ; load ASCII to al
0310+  12C3 B9 00         cmp al, 0
0311+  12C5 C6 D8 12      je _strtoint_end
0312+  12C8 6F 30         sub al, $30    ; make into integer
0313+  12CA 22 00         mov ah, 0
0314+  12CC 2A            mov b, [d]
0315+  12CD AC            mul a, b      ; result in B since it fits in 16bits
0316+  12CE 11            mov a, b
0317+  12CF 28            mov b, c
0318+  12D0 54            add a, b
0319+  12D1 39            mov c, a
0320+  12D2 63 02 00      sub d, 2
0321+  12D5 0A C2 12      jmp _strtoint_L0
0322+  12D8             _strtoint_end:
0323+  12D8 12            mov a, c
0324+  12D9 E7            pop d
0325+  12DA E6            pop c
0326+  12DB E5            pop b
0327+  12DC EF            pop si
0328+  12DD 09            ret
0329+  12DE             
0330+  12DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  12DE             ; PRINT NULL TERMINATED STRING
0332+  12DE             ; pointer in D
0333+  12DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  12DE             _puts:
0335+  12DE D7            push a
0336+  12DF DA            push d
0337+  12E0             _puts_L1:
0338+  12E0 1E            mov al, [d]
0339+  12E1 B9 00         cmp al, 0
0340+  12E3 C6 EF 12      jz _puts_END
0341+  12E6 23            mov ah, al
0342+  12E7 19 00         mov al, 0
0343+  12E9 05 03         syscall sys_io
0344+  12EB 79            inc d
0345+  12EC 0A E0 12      jmp _puts_L1
0346+  12EF             _puts_END:
0347+  12EF E7            pop d
0348+  12F0 E4            pop a
0349+  12F1 09            ret
0350+  12F2             
0351+  12F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12F2             ; PRINT N SIZE STRING
0353+  12F2             ; pointer in D
0354+  12F2             ; size in C
0355+  12F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12F2             _putsn:
0357+  12F2 DB            push al
0358+  12F3 DA            push d
0359+  12F4 D9            push c
0360+  12F5             _putsn_L0:
0361+  12F5 1E            mov al, [d]
0362+  12F6 23            mov ah, al
0363+  12F7 19 00         mov al, 0
0364+  12F9 05 03         syscall sys_io
0365+  12FB 79            inc d
0366+  12FC 7E            dec c  
0367+  12FD C2 00 00      cmp c, 0
0368+  1300 C7 F5 12      jne _putsn_L0
0369+  1303             _putsn_end:
0370+  1303 E6            pop c
0371+  1304 E7            pop d
0372+  1305 E8            pop al
0373+  1306 09            ret
0374+  1307             
0375+  1307             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1307             ; print 16bit decimal number
0377+  1307             ; input number in A
0378+  1307             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1307             print_u16d:
0380+  1307 D7            push a
0381+  1308 D8            push b
0382+  1309 FD D8         push g
0383+  130B 26 10 27      mov b, 10000
0384+  130E AE            div a, b      ; get 10000's coeff.
0385+  130F 07 33 13      call print_number
0386+  1312 11            mov a, b
0387+  1313 26 E8 03      mov b, 1000
0388+  1316 AE            div a, b      ; get 1000's coeff.
0389+  1317 07 33 13      call print_number
0390+  131A 11            mov a, b
0391+  131B 26 64 00      mov b, 100
0392+  131E AE            div a, b
0393+  131F 07 33 13      call print_number
0394+  1322 11            mov a, b
0395+  1323 26 0A 00      mov b, 10
0396+  1326 AE            div a, b
0397+  1327 07 33 13      call print_number
0398+  132A 1B            mov al, bl      ; 1's coeff in bl
0399+  132B 07 33 13      call print_number
0400+  132E FD F1         pop g
0401+  1330 E5            pop b
0402+  1331 E4            pop a
0403+  1332 09            ret
0404+  1333             
0405+  1333             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1333             ; print AL
0407+  1333             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1333             print_number:
0409+  1333 6A 30         add al, $30
0410+  1335 23            mov ah, al
0411+  1336 07 B2 11      call _putchar
0412+  1339 09            ret
0413+  133A             
0414+  133A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  133A             ; PRINT 16BIT HEX INTEGER
0416+  133A             ; integer value in reg B
0417+  133A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  133A             print_u16x:
0419+  133A D7            push a
0420+  133B D8            push b
0421+  133C DD            push bl
0422+  133D 30            mov bl, bh
0423+  133E 07 80 11      call _itoa        ; convert bh to char in A
0424+  1341 2F            mov bl, al        ; save al
0425+  1342 19 00         mov al, 0
0426+  1344 05 03         syscall sys_io        ; display AH
0427+  1346 24            mov ah, bl        ; retrieve al
0428+  1347 19 00         mov al, 0
0429+  1349 05 03         syscall sys_io        ; display AL
0430+  134B             
0431+  134B EA            pop bl
0432+  134C 07 80 11      call _itoa        ; convert bh to char in A
0433+  134F 2F            mov bl, al        ; save al
0434+  1350 19 00         mov al, 0
0435+  1352 05 03         syscall sys_io        ; display AH
0436+  1354 24            mov ah, bl        ; retrieve al
0437+  1355 19 00         mov al, 0
0438+  1357 05 03         syscall sys_io        ; display AL
0439+  1359             
0440+  1359 E5            pop b
0441+  135A E4            pop a
0442+  135B 09            ret
0443+  135C             
0444+  135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  135C             ; INPUT 16BIT HEX INTEGER
0446+  135C             ; read 16bit integer into A
0447+  135C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  135C             scan_u16x:
0449+  135C F8 10 00      enter 16
0450+  135F D8            push b
0451+  1360 DA            push d
0452+  1361             
0453+  1361 FA F1 FF      lea d, [bp + -15]
0454+  1364 07 B9 11      call _gets        ; get number
0455+  1367             
0456+  1367 32            mov bl, [d]
0457+  1368 37            mov bh, bl
0458+  1369 33 01 00      mov bl, [d + 1]
0459+  136C 07 6F 11      call _atoi        ; convert to int in AL
0460+  136F 23            mov ah, al        ; move to AH
0461+  1370             
0462+  1370 33 02 00      mov bl, [d + 2]
0463+  1373 37            mov bh, bl
0464+  1374 33 03 00      mov bl, [d + 3]
0465+  1377 07 6F 11      call _atoi        ; convert to int in AL
0466+  137A             
0467+  137A E7            pop d
0468+  137B E5            pop b
0469+  137C F9            leave
0470+  137D 09            ret
0471+  137E             
0472+  137E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  137E             ; PRINT 8bit HEX INTEGER
0474+  137E             ; integer value in reg bl
0475+  137E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  137E             print_u8x:
0477+  137E D7            push a
0478+  137F DD            push bl
0479+  1380             
0480+  1380 07 80 11      call _itoa        ; convert bl to char in A
0481+  1383 2F            mov bl, al        ; save al
0482+  1384 19 00         mov al, 0
0483+  1386 05 03         syscall sys_io        ; display AH
0484+  1388 24            mov ah, bl        ; retrieve al
0485+  1389 19 00         mov al, 0
0486+  138B 05 03         syscall sys_io        ; display AL
0487+  138D             
0488+  138D EA            pop bl
0489+  138E E4            pop a
0490+  138F 09            ret
0491+  1390             
0492+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1390             ; print 8bit decimal unsigned number
0494+  1390             ; input number in AL
0495+  1390             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1390             print_u8d:
0497+  1390 D7            push a
0498+  1391 D8            push b
0499+  1392 FD D8         push g
0500+  1394 22 00         mov ah, 0
0501+  1396 26 64 00      mov b, 100
0502+  1399 AE            div a, b
0503+  139A D8            push b      ; save remainder
0504+  139B B9 00         cmp al, 0
0505+  139D C6 A7 13      je skip100
0506+  13A0 6A 30         add al, $30
0507+  13A2 23            mov ah, al
0508+  13A3 19 00         mov al, 0
0509+  13A5 05 03         syscall sys_io  ; print coeff
0510+  13A7             skip100:
0511+  13A7 E4            pop a
0512+  13A8 22 00         mov ah, 0
0513+  13AA 26 0A 00      mov b, 10
0514+  13AD AE            div a, b
0515+  13AE D8            push b      ; save remainder
0516+  13AF B9 00         cmp al, 0
0517+  13B1 C6 BB 13      je skip10
0518+  13B4 6A 30         add al, $30
0519+  13B6 23            mov ah, al
0520+  13B7 19 00         mov al, 0
0521+  13B9 05 03         syscall sys_io  ; print coeff
0522+  13BB             skip10:
0523+  13BB E4            pop a
0524+  13BC 1B            mov al, bl
0525+  13BD 6A 30         add al, $30
0526+  13BF 23            mov ah, al
0527+  13C0 19 00         mov al, 0
0528+  13C2 05 03         syscall sys_io  ; print coeff
0529+  13C4 FD F1         pop g
0530+  13C6 E5            pop b
0531+  13C7 E4            pop a
0532+  13C8 09            ret
0533+  13C9             
0534+  13C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  13C9             ; INPUT 8BIT HEX INTEGER
0536+  13C9             ; read 8bit integer into AL
0537+  13C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  13C9             scan_u8x:
0539+  13C9 F8 04 00      enter 4
0540+  13CC D8            push b
0541+  13CD DA            push d
0542+  13CE             
0543+  13CE FA FD FF      lea d, [bp + -3]
0544+  13D1 07 B9 11      call _gets        ; get number
0545+  13D4             
0546+  13D4 32            mov bl, [d]
0547+  13D5 37            mov bh, bl
0548+  13D6 33 01 00      mov bl, [d + 1]
0549+  13D9 07 6F 11      call _atoi        ; convert to int in AL
0550+  13DC             
0551+  13DC E7            pop d
0552+  13DD E5            pop b
0553+  13DE F9            leave
0554+  13DF 09            ret
0555+  13E0             
0556+  13E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  13E0             ; input decimal number
0558+  13E0             ; result in A
0559+  13E0             ; 655'\0'
0560+  13E0             ; low--------high
0561+  13E0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  13E0             scan_u16d:
0563+  13E0 F8 08 00      enter 8
0564+  13E3 E2            push si
0565+  13E4 D8            push b
0566+  13E5 D9            push c
0567+  13E6 DA            push d
0568+  13E7 FA F9 FF      lea d, [bp +- 7]
0569+  13EA 07 B9 11      call _gets
0570+  13ED 07 11 11      call _strlen      ; get string length in C
0571+  13F0 7E            dec c
0572+  13F1 FD 4E         mov si, d
0573+  13F3 12            mov a, c
0574+  13F4 FD 99         shl a
0575+  13F6 3B 32 14      mov d, table_power
0576+  13F9 59            add d, a
0577+  13FA 38 00 00      mov c, 0
0578+  13FD             mul_loop:
0579+  13FD F6            lodsb      ; load ASCII to al
0580+  13FE B9 00         cmp al, 0
0581+  1400 C6 13 14      je mul_exit
0582+  1403 6F 30         sub al, $30    ; make into integer
0583+  1405 22 00         mov ah, 0
0584+  1407 2A            mov b, [d]
0585+  1408 AC            mul a, b      ; result in B since it fits in 16bits
0586+  1409 11            mov a, b
0587+  140A 28            mov b, c
0588+  140B 54            add a, b
0589+  140C 39            mov c, a
0590+  140D 63 02 00      sub d, 2
0591+  1410 0A FD 13      jmp mul_loop
0592+  1413             mul_exit:
0593+  1413 12            mov a, c
0594+  1414 E7            pop d
0595+  1415 E6            pop c
0596+  1416 E5            pop b
0597+  1417 EF            pop si
0598+  1418 F9            leave
0599+  1419 09            ret
0600+  141A             
0601+  141A             
0602+  141A 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  141E 34 35 36 37 
0602+  1422 38 39 41 42 
0602+  1426 43 44 45 46 
0603+  142A 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  142E 1B 5B 48 00 
0604+  1432             
0605+  1432             table_power:
0606+  1432 01 00         .dw 1
0607+  1434 0A 00         .dw 10
0608+  1436 64 00         .dw 100
0609+  1438 E8 03         .dw 1000
0610+  143A 10 27         .dw 100002697   143C             .include "lib/ctype.asm"
0001+  143C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  143C             ; ctype.s
0003+  143C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  143C             
0005+  143C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  143C             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  143C             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  143C             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  143C             ;; characters are supported.
0010+  143C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  143C             ;; _isalnum 
0012+  143C             ;; _isalpha 
0013+  143C             ;; islower 
0014+  143C             ;; isupper 
0015+  143C             ;; _isdigit 
0016+  143C             ;; isxdigit
0017+  143C             ;; iscntrl 
0018+  143C             ;; isgraph 
0019+  143C             ;; _isspace 
0020+  143C             ;; isblank 
0021+  143C             ;; isprint 
0022+  143C             ;; ispunct 
0023+  143C             ;; tolower 
0024+  143C             ;; toupper
0025+  143C             
0026+  143C             
0027+  143C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  143C             ;; IS ALPHANUMERIC
0029+  143C             ;; sets ZF according with result
0030+  143C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  143C             _isalnum:
0032+  143C 07 59 14    	call _isalpha
0033+  143F C6 45 14    	je _isalnum_exit
0034+  1442 07 46 14    	call _isdigit
0035+  1445             _isalnum_exit:
0036+  1445 09          	ret	
0037+  1446             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1446             ;; IS DIGIT
0039+  1446             ;; sets ZF according with result
0040+  1446             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1446             _isdigit:
0042+  1446 DB          	push al
0043+  1447 B9 30       	cmp al, '0'
0044+  1449 C8 55 14    	jlu _isdigit_false
0045+  144C B9 39       	cmp al, '9'
0046+  144E D1 55 14    	jgu _isdigit_false
0047+  1451 87 00       	and al, 0	; set ZF
0048+  1453 E8          	pop al
0049+  1454 09          	ret
0050+  1455             _isdigit_false:
0051+  1455 8B 01       	or al, 1	; clear ZF
0052+  1457 E8          	pop al
0053+  1458 09          	ret	
0054+  1459             	
0055+  1459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1459             ;; IS ALPHA
0057+  1459             ;; sets ZF according with result
0058+  1459             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1459             _isalpha:
0060+  1459 DB          	push al
0061+  145A B9 5F       	cmp al, '_'
0062+  145C C6 7C 14    	je _isalpha_true
0063+  145F B9 2E       	cmp al, '.'
0064+  1461 C6 7C 14    	je _isalpha_true
0065+  1464 B9 41       	cmp al, 'A'
0066+  1466 C8 78 14    	jlu _isalpha_false
0067+  1469 B9 7A       	cmp al, 'z'
0068+  146B D1 78 14    	jgu _isalpha_false
0069+  146E B9 5A       	cmp al, 'Z'
0070+  1470 D0 7C 14    	jleu _isalpha_true
0071+  1473 B9 61       	cmp al, 'a'
0072+  1475 C9 7C 14    	jgeu _isalpha_true
0073+  1478             _isalpha_false:
0074+  1478 8B 01       	or al, 1	; clear ZF
0075+  147A E8          	pop al
0076+  147B 09          	ret
0077+  147C             _isalpha_true:
0078+  147C 87 00       	and al, 0	; set ZF
0079+  147E E8          	pop al
0080+  147F 09          	ret
0081+  1480             
0082+  1480             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1480             ;; IS PATH-ALPHA
0084+  1480             ;; sets ZF according with result
0085+  1480             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1480             ispath:
0087+  1480 DB          	push al
0088+  1481 07 46 14    	call _isdigit
0089+  1484 C6 AE 14    	je ispath_true
0090+  1487 B9 5F       	cmp al, '_'
0091+  1489 C6 AE 14    	je ispath_true
0092+  148C B9 2F       	cmp al, '/'
0093+  148E C6 AE 14    	je ispath_true
0094+  1491 B9 2E       	cmp al, '.'
0095+  1493 C6 AE 14    	je ispath_true
0096+  1496 B9 41       	cmp al, 'A'
0097+  1498 C8 AA 14    	jlu ispath_false
0098+  149B B9 7A       	cmp al, 'z'
0099+  149D D1 AA 14    	jgu ispath_false
0100+  14A0 B9 5A       	cmp al, 'Z'
0101+  14A2 D0 AE 14    	jleu ispath_true
0102+  14A5 B9 61       	cmp al, 'a'
0103+  14A7 C9 AE 14    	jgeu ispath_true
0104+  14AA             ispath_false:
0105+  14AA 8B 01       	or al, 1	; clear ZF
0106+  14AC E8          	pop al
0107+  14AD 09          	ret
0108+  14AE             ispath_true:
0109+  14AE 87 00       	and al, 0	; set ZF
0110+  14B0 E8          	pop al
0111+  14B1 09          	ret
0112+  14B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14B2             ;; IS SPACE
0114+  14B2             ;; sets ZF according with result
0115+  14B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14B2             _isspace:
0117+  14B2 B9 20       	cmp al, $20		; ' '
0118+  14B4 C6 C8 14    	je _isspace_exit
0119+  14B7 B9 09       	cmp al, $09		; '\t'
0120+  14B9 C6 C8 14    	je _isspace_exit
0121+  14BC B9 0A       	cmp al, $0A		; '\n'
0122+  14BE C6 C8 14    	je _isspace_exit
0123+  14C1 B9 0D       	cmp al, $0D		; '\r'
0124+  14C3 C6 C8 14    	je _isspace_exit
0125+  14C6 B9 0B       	cmp al, $0B		; '\v'
0126+  14C8             _isspace_exit:
0127+  14C8 09          	ret	
0128+  14C9             
0129+  14C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  14C9             ; TO LOWER
0131+  14C9             ; input in AL
0132+  14C9             ; output in AL
0133+  14C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  14C9             _to_lower:
0135+  14C9 B9 5A       	cmp al, 'Z'
0136+  14CB D1 D0 14    	jgu _to_lower_ret
0137+  14CE 6A 20       	add al, $20				; convert to lower case
0138+  14D0             _to_lower_ret:
0139+  14D0 09          	ret
0140+  14D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  14D1             ; TO UPPER
0142+  14D1             ; input in AL
0143+  14D1             ; output in AL
0144+  14D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  14D1             _to_upper:
0146+  14D1 B9 61       	cmp al, 'a'
0147+  14D3 C8 D8 14    	jlu _to_upper_ret
0148+  14D6 6F 20       	sub al, $20			; convert to upper case
0149+  14D8             _to_upper_ret:
0150+  14D8 09          	ret
0151+  14D9             
2698   14D9             .include "lib/token.asm"
0001+  14D9             TOKTYP_IDENTIFIER  .equ 0
0002+  14D9             TOKTYP_KEYWORD     .equ 1
0003+  14D9             TOKTYP_DELIMITER   .equ 2
0004+  14D9             TOKTYP_STRING      .equ 3
0005+  14D9             TOKTYP_CHAR        .equ 4
0006+  14D9             TOKTYP_NUMERIC     .equ 5
0007+  14D9             TOKTYP_END         .equ 6
0008+  14D9             
0009+  14D9             TOK_NULL           .equ 0
0010+  14D9             TOK_FSLASH         .equ 1
0011+  14D9             TOK_TIMES          .equ 2
0012+  14D9             TOK_PLUS           .equ 3
0013+  14D9             TOK_MINUS          .equ 4
0014+  14D9             TOK_DOT            .equ 5
0015+  14D9             TOK_SEMI           .equ 6
0016+  14D9             TOK_ANGLE          .equ 7
0017+  14D9             TOK_TILDE          .equ 8
0018+  14D9             TOK_EQUAL          .equ 9
0019+  14D9             TOK_COLON          .equ 10
0020+  14D9             TOK_COMMA          .equ 11
0021+  14D9             
0022+  14D9             TOK_END            .equ 20
0023+  14D9             
0024+  14D9             
0025+  14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  14D9             ;; read a full command argment from shell input buffer
0027+  14D9             ;; argument is written into tokstr
0028+  14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  14D9             get_arg:
0030+  14D9 D7            push a
0031+  14DA E2            push si
0032+  14DB E3            push di
0033+  14DC 19 00         mov al, 0
0034+  14DE 3D 07 17      mov [tokstr], al      ; nullify tokstr string
0035+  14E1 14 03 17      mov a, [prog]
0036+  14E4 4D            mov si, a
0037+  14E5 FD 4F 07 17   mov di, tokstr
0038+  14E9             get_arg_skip_spaces:
0039+  14E9 F6            lodsb
0040+  14EA 07 B2 14      call _isspace
0041+  14ED C6 E9 14      je get_arg_skip_spaces
0042+  14F0             get_arg_L0:
0043+  14F0 B9 3B         cmp al, $3B        ; check if is ';'
0044+  14F2 C6 FF 14      je get_arg_end
0045+  14F5 B9 00         cmp al, 0
0046+  14F7 C6 FF 14      je get_arg_end      ; check if end of input
0047+  14FA F7            stosb
0048+  14FB F6            lodsb
0049+  14FC 0A F0 14      jmp get_arg_L0
0050+  14FF             get_arg_end:
0051+  14FF 19 00         mov al, 0
0052+  1501 F7            stosb
0053+  1502 D5 01 00      sub si, 1
0054+  1505 4E            mov a, si
0055+  1506 42 03 17      mov [prog], a    ; update pointer
0056+  1509 F0            pop di
0057+  150A EF            pop si
0058+  150B E4            pop a
0059+  150C 09            ret
0060+  150D             
0061+  150D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  150D             ;; read a path formation from shell input buffer
0063+  150D             ;; path is written into tokstr
0064+  150D             ;; /usr/bin
0065+  150D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  150D             get_path:
0067+  150D D7            push a
0068+  150E E2            push si
0069+  150F E3            push di
0070+  1510 19 00         mov al, 0
0071+  1512 3D 07 17      mov [tokstr], al      ; nullify tokstr string
0072+  1515 14 03 17      mov a, [prog]
0073+  1518 4D            mov si, a
0074+  1519 FD 4F 07 17   mov di, tokstr
0075+  151D             get_path_skip_spaces:
0076+  151D F6            lodsb
0077+  151E 07 B2 14      call _isspace
0078+  1521 C6 1D 15      je get_path_skip_spaces
0079+  1524             get_path_is_pathchar:
0080+  1524 F7            stosb
0081+  1525 F6            lodsb
0082+  1526 07 3C 14      call _isalnum      ;check if is alphanumeric
0083+  1529 C6 24 15      je get_path_is_pathchar
0084+  152C B9 2F         cmp al, '/'        ; check if is '/'
0085+  152E C6 24 15      je get_path_is_pathchar
0086+  1531 19 00         mov al, 0
0087+  1533 F7            stosb
0088+  1534 D5 01 00      sub si, 1
0089+  1537 4E            mov a, si
0090+  1538 42 03 17      mov [prog], a    ; update pointer
0091+  153B             get_path_end:
0092+  153B F0            pop di
0093+  153C EF            pop si
0094+  153D E4            pop a
0095+  153E 09            ret
0096+  153F             
0097+  153F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  153F             ;; read a line
0099+  153F             ;; line is written into tokstr
0100+  153F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  153F             get_line:
0102+  153F D7            push a
0103+  1540 E2            push si
0104+  1541 E3            push di
0105+  1542 19 00         mov al, 0
0106+  1544 3D 07 17      mov [tokstr], al      ; nullify tokstr string
0107+  1547 14 03 17      mov a, [prog]
0108+  154A 4D            mov si, a
0109+  154B FD 4F 07 17   mov di, tokstr
0110+  154F             get_line_L0:
0111+  154F F6            lodsb
0112+  1550 B9 0A         cmp al, $0A    ; check for new line
0113+  1552 C6 59 15      je get_line_exit
0114+  1555 F7            stosb
0115+  1556 0A 4F 15      jmp get_line_L0
0116+  1559             get_line_exit:
0117+  1559 19 00         mov al, 0
0118+  155B F7            stosb
0119+  155C 4E            mov a, si
0120+  155D 42 03 17      mov [prog], a    ; update pointer
0121+  1560 F0            pop di
0122+  1561 EF            pop si
0123+  1562 E4            pop a
0124+  1563 09            ret
0125+  1564             
0126+  1564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1564             ;; token parser
0128+  1564             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1564             get_token:
0130+  1564 D7            push a
0131+  1565 DA            push d
0132+  1566 E2            push si
0133+  1567 E3            push di
0134+  1568 19 00         mov al, 0
0135+  156A 3D 07 17      mov [tokstr], al      ; nullify tokstr string
0136+  156D 19 00         mov al, TOK_NULL
0137+  156F 3D 06 17      mov [tok], al        ; nullify token
0138+  1572 14 03 17      mov a, [prog]
0139+  1575 4D            mov si, a
0140+  1576 FD 4F 07 17   mov di, tokstr
0141+  157A             get_tok_skip_spaces:
0142+  157A F6            lodsb
0143+  157B 07 B2 14      call _isspace
0144+  157E C6 7A 15      je get_tok_skip_spaces
0145+  1581 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  1583 C6 68 16      je get_token_end
0147+  1586 B9 23         cmp al, '#'      ; comments!
0148+  1588 C6 96 16      je get_tok_comment
0149+  158B 07 3C 14      call _isalnum
0150+  158E C6 75 16      jz is_alphanumeric
0151+  1591             ; other token types
0152+  1591             get_token_slash:
0153+  1591 B9 2F         cmp al, '/'        ; check if '/'
0154+  1593 C7 AB 15      jne get_token_minus
0155+  1596 F7            stosb          ; store '/' into token string
0156+  1597 19 00         mov al, 0
0157+  1599 F7            stosb          ; terminate token string
0158+  159A 19 01         mov al, TOK_FSLASH
0159+  159C 3D 06 17      mov [tok], al      
0160+  159F 19 02         mov al, TOKTYP_DELIMITER
0161+  15A1 3D 05 17      mov [toktyp], al
0162+  15A4 4E            mov a, si
0163+  15A5 42 03 17      mov [prog], a    ; update pointer
0164+  15A8 0A 91 16      jmp get_token_return
0165+  15AB             get_token_minus:
0166+  15AB B9 2D         cmp al, '-'        ; check if '-'
0167+  15AD C7 C5 15      jne get_token_comma
0168+  15B0 F7            stosb          ; store '-' into token string
0169+  15B1 19 00         mov al, 0
0170+  15B3 F7            stosb          ; terminate token string
0171+  15B4 19 04         mov al, TOK_MINUS
0172+  15B6 3D 06 17      mov [tok], al      
0173+  15B9 19 02         mov al, TOKTYP_DELIMITER
0174+  15BB 3D 05 17      mov [toktyp], al
0175+  15BE 4E            mov a, si
0176+  15BF 42 03 17      mov [prog], a    ; update pointer
0177+  15C2 0A 91 16      jmp get_token_return
0178+  15C5             get_token_comma:
0179+  15C5 B9 2C         cmp al, ','        ; check if ','
0180+  15C7 C7 DF 15      jne get_token_semi
0181+  15CA F7            stosb          ; store ',' into token string
0182+  15CB 19 00         mov al, 0
0183+  15CD F7            stosb          ; terminate token string
0184+  15CE 19 0B         mov al, TOK_COMMA
0185+  15D0 3D 06 17      mov [tok], al      
0186+  15D3 19 02         mov al, TOKTYP_DELIMITER
0187+  15D5 3D 05 17      mov [toktyp], al
0188+  15D8 4E            mov a, si
0189+  15D9 42 03 17      mov [prog], a    ; update pointer
0190+  15DC 0A 91 16      jmp get_token_return
0191+  15DF             get_token_semi:
0192+  15DF B9 3B         cmp al, $3B        ; check if ';'
0193+  15E1 C7 F9 15      jne get_token_colon
0194+  15E4 F7            stosb          ; store ';' into token string
0195+  15E5 19 00         mov al, 0
0196+  15E7 F7            stosb          ; terminate token string
0197+  15E8 19 06         mov al, TOK_SEMI
0198+  15EA 3D 06 17      mov [tok], al      
0199+  15ED 19 02         mov al, TOKTYP_DELIMITER
0200+  15EF 3D 05 17      mov [toktyp], al
0201+  15F2 4E            mov a, si
0202+  15F3 42 03 17      mov [prog], a    ; update pointer
0203+  15F6 0A 91 16      jmp get_token_return
0204+  15F9             get_token_colon:
0205+  15F9 B9 3A         cmp al, $3A        ; check if ':'
0206+  15FB C7 13 16      jne get_token_angle
0207+  15FE F7            stosb          ; store ':' into token string
0208+  15FF 19 00         mov al, 0
0209+  1601 F7            stosb          ; terminate token string
0210+  1602 19 0A         mov al, TOK_COLON
0211+  1604 3D 06 17      mov [tok], al      
0212+  1607 19 02         mov al, TOKTYP_DELIMITER
0213+  1609 3D 05 17      mov [toktyp], al
0214+  160C 4E            mov a, si
0215+  160D 42 03 17      mov [prog], a    ; update pointer
0216+  1610 0A 91 16      jmp get_token_return
0217+  1613             get_token_angle:
0218+  1613 B9 3E         cmp al, $3E        ; check if '>'
0219+  1615 C7 2D 16      jne get_token_tilde
0220+  1618 F7            stosb          ; store '>' into token string
0221+  1619 19 00         mov al, 0
0222+  161B F7            stosb          ; terminate token string
0223+  161C 19 07         mov al, TOK_ANGLE
0224+  161E 3D 06 17      mov [tok], al      
0225+  1621 19 02         mov al, TOKTYP_DELIMITER
0226+  1623 3D 05 17      mov [toktyp], al
0227+  1626 4E            mov a, si
0228+  1627 42 03 17      mov [prog], a    ; update pointer
0229+  162A 0A 91 16      jmp get_token_return
0230+  162D             get_token_tilde:
0231+  162D B9 7E         cmp al, '~'        ; check if '~'
0232+  162F C7 47 16      jne get_token_equal
0233+  1632 F7            stosb          ; store '~' into token string
0234+  1633 19 00         mov al, 0
0235+  1635 F7            stosb          ; terminate token string
0236+  1636 19 08         mov al, TOK_TILDE
0237+  1638 3D 06 17      mov [tok], al      
0238+  163B 19 02         mov al, TOKTYP_DELIMITER
0239+  163D 3D 05 17      mov [toktyp], al
0240+  1640 4E            mov a, si
0241+  1641 42 03 17      mov [prog], a    ; update pointer
0242+  1644 0A 91 16      jmp get_token_return
0243+  1647             get_token_equal:
0244+  1647 B9 3D         cmp al, '='        ; check if '='
0245+  1649 C7 61 16      jne get_token_skip
0246+  164C F7            stosb          ; store '=' into token string
0247+  164D 19 00         mov al, 0
0248+  164F F7            stosb          ; terminate token string
0249+  1650 19 09         mov al, TOK_EQUAL
0250+  1652 3D 06 17      mov [tok], al      
0251+  1655 19 02         mov al, TOKTYP_DELIMITER
0252+  1657 3D 05 17      mov [toktyp], al
0253+  165A 4E            mov a, si
0254+  165B 42 03 17      mov [prog], a    ; update pointer
0255+  165E 0A 91 16      jmp get_token_return
0256+  1661             get_token_skip:
0257+  1661 4E            mov a, si
0258+  1662 42 03 17      mov [prog], a    ; update pointer
0259+  1665 0A 91 16      jmp get_token_return
0260+  1668             get_token_end:        ; end of file token
0261+  1668 19 14         mov al, TOK_END
0262+  166A 3D 06 17      mov [tok], al
0263+  166D 19 06         mov al, TOKTYP_END
0264+  166F 3D 05 17      mov [toktyp], al
0265+  1672 0A 91 16      jmp get_token_return
0266+  1675             is_alphanumeric:
0267+  1675 F7            stosb
0268+  1676 F6            lodsb
0269+  1677 07 3C 14      call _isalnum      ;check if is alphanumeric
0270+  167A C6 75 16      jz is_alphanumeric
0271+  167D B9 2E         cmp al, $2E        ; check if is '.'
0272+  167F C6 75 16      je is_alphanumeric
0273+  1682 19 00         mov al, 0
0274+  1684 F7            stosb
0275+  1685 19 00         mov al, TOKTYP_IDENTIFIER
0276+  1687 3D 05 17      mov [toktyp], al
0277+  168A D5 01 00      sub si, 1
0278+  168D 4E            mov a, si
0279+  168E 42 03 17      mov [prog], a    ; update pointer
0280+  1691             get_token_return:
0281+  1691 F0            pop di
0282+  1692 EF            pop si
0283+  1693 E7            pop d
0284+  1694 E4            pop a
0285+  1695 09            ret
0286+  1696             get_tok_comment:
0287+  1696 F6            lodsb
0288+  1697 B9 0A         cmp al, $0A      ; new line
0289+  1699 C7 96 16      jne get_tok_comment
0290+  169C 0A 7A 15      jmp get_tok_skip_spaces
0291+  169F             
0292+  169F             
0293+  169F             get_number:
0294+  169F D7            push a
0295+  16A0 DA            push d
0296+  16A1 E2            push si
0297+  16A2 E3            push di
0298+  16A3 19 00         mov al, 0
0299+  16A5 3D 07 17      mov [tokstr], al      ; nullify tokstr string
0300+  16A8 19 00         mov al, TOK_NULL
0301+  16AA 3D 06 17      mov [tok], al        ; nullify token
0302+  16AD 14 03 17      mov a, [prog]
0303+  16B0 4D            mov si, a
0304+  16B1 FD 4F 07 17   mov di, tokstr
0305+  16B5             get_number_skip_spaces:
0306+  16B5 F6            lodsb
0307+  16B6 07 B2 14      call _isspace
0308+  16B9 C6 B5 16      je get_number_skip_spaces
0309+  16BC B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  16BE C7 CE 16      jne get_number_L0
0311+  16C1 19 14         mov al, TOK_END
0312+  16C3 3D 06 17      mov [tok], al
0313+  16C6 19 06         mov al, TOKTYP_END
0314+  16C8 3D 05 17      mov [toktyp], al
0315+  16CB 0A E5 16      jmp get_number_return
0316+  16CE             get_number_L0:
0317+  16CE F7            stosb
0318+  16CF F6            lodsb
0319+  16D0 07 46 14      call _isdigit      ;check if is numeric
0320+  16D3 C6 CE 16      jz get_number_L0
0321+  16D6 19 00         mov al, 0
0322+  16D8 F7            stosb
0323+  16D9 19 05         mov al, TOKTYP_NUMERIC
0324+  16DB 3D 05 17      mov [toktyp], al
0325+  16DE D5 01 00      sub si, 1
0326+  16E1 4E            mov a, si
0327+  16E2 42 03 17      mov [prog], a    ; update pointer
0328+  16E5             get_number_return:
0329+  16E5 F0            pop di
0330+  16E6 EF            pop si
0331+  16E7 E7            pop d
0332+  16E8 E4            pop a
0333+  16E9 09            ret
0334+  16EA             
0335+  16EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  16EA             ;; PUT BACK TOKEN
0337+  16EA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  16EA             _putback:
0339+  16EA D7            push a
0340+  16EB E2            push si
0341+  16EC FD 4D 07 17   mov si, tokstr  
0342+  16F0             _putback_loop:
0343+  16F0 F6            lodsb
0344+  16F1 B9 00         cmp al, 0
0345+  16F3 C6 00 17      je _putback_end
0346+  16F6 14 03 17      mov a, [prog]
0347+  16F9 7D            dec a
0348+  16FA 42 03 17      mov [prog], a      ; update pointer
0349+  16FD 0A F0 16      jmp _putback_loop
0350+  1700             _putback_end:
0351+  1700 EF            pop si
0352+  1701 E4            pop a
0353+  1702 09            ret
0354+  1703             
0355+  1703             
0356+  1703             
0357+  1703             
0358+  1703 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1705             
0360+  1705 00          toktyp:    .db 0          ; token type symbol
0361+  1706 00          tok:       .db 0          ; current token symbol
0362+  1707 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  170B 00 00 00 00 
0362+  170F 00 00 00 00 
0362+  1713 00 00 00 00 
0362+  1717 00 00 00 00 
0362+  171B 00 00 00 00 
0362+  171F 00 00 00 00 
0362+  1723 00 00 00 00 
0362+  1727 00 00 00 00 
0362+  172B 00 00 00 00 
0362+  172F 00 00 00 00 
0362+  1733 00 00 00 00 
0362+  1737 00 00 00 00 
0362+  173B 00 00 00 00 
0362+  173F 00 00 00 00 
0362+  1743 00 00 00 00 
0362+  1747 00 00 00 00 
0362+  174B 00 00 00 00 
0362+  174F 00 00 00 00 
0362+  1753 00 00 00 00 
0362+  1757 00 00 00 00 
0362+  175B 00 00 00 00 
0362+  175F 00 00 00 00 
0362+  1763 00 00 00 00 
0362+  1767 00 00 00 00 
0362+  176B 00 00 00 00 
0362+  176F 00 00 00 00 
0362+  1773 00 00 00 00 
0362+  1777 00 00 00 00 
0362+  177B 00 00 00 00 
0362+  177F 00 00 00 00 
0362+  1783 00 00 00 00 
0362+  1787 00 00 00 00 
0362+  178B 00 00 00 00 
0362+  178F 00 00 00 00 
0362+  1793 00 00 00 00 
0362+  1797 00 00 00 00 
0362+  179B 00 00 00 00 
0362+  179F 00 00 00 00 
0362+  17A3 00 00 00 00 
0362+  17A7 00 00 00 00 
0362+  17AB 00 00 00 00 
0362+  17AF 00 00 00 00 
0362+  17B3 00 00 00 00 
0362+  17B7 00 00 00 00 
0362+  17BB 00 00 00 00 
0362+  17BF 00 00 00 00 
0362+  17C3 00 00 00 00 
0362+  17C7 00 00 00 00 
0362+  17CB 00 00 00 00 
0362+  17CF 00 00 00 00 
0362+  17D3 00 00 00 00 
0362+  17D7 00 00 00 00 
0362+  17DB 00 00 00 00 
0362+  17DF 00 00 00 00 
0362+  17E3 00 00 00 00 
0362+  17E7 00 00 00 00 
0362+  17EB 00 00 00 00 
0362+  17EF 00 00 00 00 
0362+  17F3 00 00 00 00 
0362+  17F7 00 00 00 00 
0362+  17FB 00 00 00 00 
0362+  17FF 00 00 00 00 
0362+  1803 00 00 00 00 
2699   1807             
2700   1807             ; kernel parameters
2701   1807             sys_debug_mode:
2702   1807 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2703   1808             sys_echo_on:
2704   1808 01            .db 1
2705   1809             sys_uart0_lcr:
2706   1809 07            .db $07 ; 8 data bits, 2 stop bit, no parity
2707   180A             sys_uart0_inten:
2708   180A 01            .db 1
2709   180B             sys_uart0_fifoen:
2710   180B 00            .db 0
2711   180C             sys_uart0_div0:
2712   180C 0C            .db 12  ;
2713   180D             sys_uart0_div1:
2714   180D 00            .db 0   ; default baud = 9600
2715   180E             ; Baud  Divisor
2716   180E             ; 50    2304
2717   180E             ; 110   1047
2718   180E             ; 300    384
2719   180E             ; 600    192
2720   180E             ; 1200    96
2721   180E             ; 9600    12
2722   180E             ; 19200    6
2723   180E             ; 38400    3
2724   180E             
2725   180E             nbr_active_procs:
2726   180E 00            .db 0
2727   180F             active_proc_index:
2728   180F 01            .db 1
2729   1810             
2730   1810             index:
2731   1810 00 00         .dw 0
2732   1812             buffer_addr:
2733   1812 00 00         .dw 0
2734   1814             
2735   1814             fifo_in:
2736   1814 65 21         .dw fifo
2737   1816             fifo_out:
2738   1816 65 21         .dw fifo
2739   1818             
2740   1818             ; file system variables
2741   1818             current_dir_id:
2742   1818 00 00         .dw 0     ; keep dirID of current directory
2743   181A             s_init_path:
2744   181A 2F 73 62 69   .db "/sbin/init", 0
2744   181E 6E 2F 69 6E 
2744   1822 69 74 00 
2745   1825             
2746   1825             s_uname:
2747   1825 73 6F 6C 61   .db "solarium v.1.0", 0
2747   1829 72 69 75 6D 
2747   182D 20 76 2E 31 
2747   1831 2E 30 00 
2748   1834             s_dataentry:
2749   1834 3E 20 00      .db "> ", 0
2750   1837             s_parent_dir:
2751   1837 2E 2E 00      .db "..", 0
2752   183A             s_current_dir:
2753   183A 2E 00         .db ".", 0
2754   183C             s_fslash:
2755   183C 2F 00         .db "/", 0
2756   183E             file_attrib:
2757   183E 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2757   1842 78 
2758   1843             file_type:
2759   1843 2D 64 63      .db "-dc"
2760   1846             s_ps_header:
2761   1846 70 69 64 20   .db "pid command\n", 0
2761   184A 63 6F 6D 6D 
2761   184E 61 6E 64 0A 
2761   1852 00 
2762   1853             s_ls_total:
2763   1853 74 6F 74 61   .db "total: ", 0
2763   1857 6C 3A 20 00 
2764   185B             
2765   185B             s_int_en:
2766   185B 49 52 51 73   .db "IRQs enabled\n", 0
2766   185F 20 65 6E 61 
2766   1863 62 6C 65 64 
2766   1867 0A 00 
2767   1869             s_kernel_started:
2768   1869 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2768   186D 65 6C 20 73 
2768   1871 74 61 72 74 
2768   1875 65 64 28 76 
2768   1879 65 72 73 69 
2768   187D 6F 6E 20 31 
2768   1881 2E 30 29 0A 
2768   1885 00 
2769   1886             s_prompt_init:
2770   1886 73 74 61 72   .db "starting init\n", 0
2770   188A 74 69 6E 67 
2770   188E 20 69 6E 69 
2770   1892 74 0A 00 
2771   1895             s_priviledge:
2772   1895 0A 65 78 63   .db "\nexception: privilege\n", 0
2772   1899 65 70 74 69 
2772   189D 6F 6E 3A 20 
2772   18A1 70 72 69 76 
2772   18A5 69 6C 65 67 
2772   18A9 65 0A 00 
2773   18AC             s_divzero:
2774   18AC 0A 65 78 63   .db "\nexception: zero division\n", 0
2774   18B0 65 70 74 69 
2774   18B4 6F 6E 3A 20 
2774   18B8 7A 65 72 6F 
2774   18BC 20 64 69 76 
2774   18C0 69 73 69 6F 
2774   18C4 6E 0A 00 
2775   18C7             
2776   18C7             s_set_year:
2777   18C7 79 65 61 72   .db "year: ", 0
2777   18CB 3A 20 00 
2778   18CE             s_set_month:
2779   18CE 6D 6F 6E 74   .db "month: ", 0
2779   18D2 68 3A 20 00 
2780   18D6             s_set_day:
2781   18D6 64 61 79 3A   .db "day: ", 0
2781   18DA 20 00 
2782   18DC             s_set_week:
2783   18DC 77 65 65 6B   .db "weekday: ", 0
2783   18E0 64 61 79 3A 
2783   18E4 20 00 
2784   18E6             s_set_hours:
2785   18E6 68 6F 75 72   .db "hours: ", 0
2785   18EA 73 3A 20 00 
2786   18EE             s_set_minutes:
2787   18EE 6D 69 6E 75   .db "minutes: ", 0
2787   18F2 74 65 73 3A 
2787   18F6 20 00 
2788   18F8             s_set_seconds:
2789   18F8 73 65 63 6F   .db "seconds: ", 0
2789   18FC 6E 64 73 3A 
2789   1900 20 00 
2790   1902             s_months:      
2791   1902 20 20 20 00   .db "   ", 0
2792   1906 4A 61 6E 00   .db "Jan", 0
2793   190A 46 65 62 00   .db "Feb", 0
2794   190E 4D 61 72 00   .db "Mar", 0
2795   1912 41 70 72 00   .db "Apr", 0
2796   1916 4D 61 79 00   .db "May", 0
2797   191A 4A 75 6E 00   .db "Jun", 0
2798   191E 4A 75 6C 00   .db "Jul", 0
2799   1922 41 75 67 00   .db "Aug", 0
2800   1926 53 65 70 00   .db "Sep", 0
2801   192A 4F 63 74 00   .db "Oct", 0
2802   192E 4E 6F 76 00   .db "Nov", 0
2803   1932 44 65 63 00   .db "Dec", 0
2804   1936             
2805   1936             s_week:        
2806   1936 53 75 6E 00   .db "Sun", 0 
2807   193A 4D 6F 6E 00   .db "Mon", 0 
2808   193E 54 75 65 00   .db "Tue", 0 
2809   1942 57 65 64 00   .db "Wed", 0 
2810   1946 54 68 75 00   .db "Thu", 0 
2811   194A 46 72 69 00   .db "Fri", 0 
2812   194E 53 61 74 00   .db "Sat", 0
2813   1952             
2814   1952             ; This is the format of a sector for the 128 byte per sector format.
2815   1952             ; Write the bracketed data 16 times per track.
2816   1952             ; The recommended single-density format with 128
2817   1952             ; bytes/sector is shown. In order to format a diskette,
2818   1952             ; the user issues the Write Track Command, and loads
2819   1952             ; the Data Register with the following values. For every
2820   1952             ; byte to be written, there is one Data Request.
2821   1952             fdc_128_format:                                                                       
2822   1952             fdc_40_FF:
2823   1952 FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
2823   1956 FF FF FF FF 
2823   195A FF FF FF FF 
2823   195E FF FF FF FF 
2823   1962 FF FF FF FF 
2823   1966 FF FF FF FF 
2823   196A FF FF FF FF 
2823   196E FF FF FF FF 
2823   1972 FF FF FF FF 
2823   1976 FF FF FF FF 
2824   197A             fdc_128_format_inner:
2825   197A 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
2825   197E 00 00 
2826   1980 FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
2827   1981             fdc_128_format_track:
2828   1981 00            .fill 1,   $00    ; Track Number   0 thru 76(4C)                                                  |                    
2829   1982 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
2830   1983             fdc_128_format_sect:
2831   1983 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
2832   1984 00            .fill 1,   $00    ; Sector Length                                                                 |                        
2833   1985 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
2834   1986 FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
2834   198A FF FF FF FF 
2834   198E FF FF FF 
2835   1991 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
2835   1995 00 00 
2836   1997 FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
2837   1998 E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
2837   199C E5 E5 E5 E5 
2837   19A0 E5 E5 E5 E5 
2837   19A4 E5 E5 E5 E5 
2837   19A8 E5 E5 E5 E5 
2837   19AC E5 E5 E5 E5 
2837   19B0 E5 E5 E5 E5 
2837   19B4 E5 E5 E5 E5 
2837   19B8 E5 E5 E5 E5 
2837   19BC E5 E5 E5 E5 
2837   19C0 E5 E5 E5 E5 
2837   19C4 E5 E5 E5 E5 
2837   19C8 E5 E5 E5 E5 
2837   19CC E5 E5 E5 E5 
2837   19D0 E5 E5 E5 E5 
2837   19D4 E5 E5 E5 E5 
2837   19D8 E5 E5 E5 E5 
2837   19DC E5 E5 E5 E5 
2837   19E0 E5 E5 E5 E5 
2837   19E4 E5 E5 E5 E5 
2837   19E8 E5 E5 E5 E5 
2837   19EC E5 E5 E5 E5 
2837   19F0 E5 E5 E5 E5 
2837   19F4 E5 E5 E5 E5 
2837   19F8 E5 E5 E5 E5 
2837   19FC E5 E5 E5 E5 
2837   1A00 E5 E5 E5 E5 
2837   1A04 E5 E5 E5 E5 
2837   1A08 E5 E5 E5 E5 
2837   1A0C E5 E5 E5 E5 
2837   1A10 E5 E5 E5 E5 
2837   1A14 E5 E5 E5 E5 
2838   1A18 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
2839   1A19 FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
2839   1A1D FF FF FF FF 
2839   1A21 FF FF 
2840   1A23             fdc_128_format_end:
2841   1A23 FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2841   1A27 FF FF FF FF 
2841   1A2B FF FF FF FF 
2841   1A2F FF FF FF FF 
2841   1A33 FF FF FF FF 
2841   1A37 FF FF FF FF 
2841   1A3B FF FF FF FF 
2841   1A3F FF FF FF FF 
2841   1A43 FF FF FF FF 
2841   1A47 FF FF FF FF 
2841   1A4B FF FF FF FF 
2841   1A4F FF FF FF FF 
2841   1A53 FF FF FF FF 
2841   1A57 FF FF FF FF 
2841   1A5B FF FF FF FF 
2841   1A5F FF FF FF FF 
2841   1A63 FF FF FF FF 
2841   1A67 FF FF FF FF 
2841   1A6B FF FF FF FF 
2841   1A6F FF FF FF FF 
2841   1A73 FF FF FF FF 
2841   1A77 FF FF FF FF 
2841   1A7B FF FF FF FF 
2841   1A7F FF FF FF FF 
2841   1A83 FF FF FF FF 
2841   1A87 FF FF FF FF 
2841   1A8B FF FF FF FF 
2841   1A8F FF FF FF FF 
2841   1A93 FF FF FF FF 
2841   1A97 FF FF FF FF 
2841   1A9B FF FF FF FF 
2841   1A9F FF FF FF FF 
2841   1AA3 FF FF FF FF 
2841   1AA7 FF FF FF FF 
2841   1AAB FF FF FF FF 
2841   1AAF FF FF FF FF 
2841   1AB3 FF FF FF FF 
2841   1AB7 FF FF FF FF 
2841   1ABB FF FF FF FF 
2841   1ABF FF FF FF FF 
2841   1AC3 FF FF FF FF 
2841   1AC7 FF FF FF FF 
2841   1ACB FF FF FF FF 
2841   1ACF FF FF FF FF 
2841   1AD3 FF FF FF FF 
2841   1AD7 FF FF FF FF 
2841   1ADB FF FF FF FF 
2841   1ADF FF FF FF FF 
2841   1AE3 FF FF FF FF 
2841   1AE7 FF FF FF FF 
2841   1AEB FF FF FF FF 
2841   1AEF FF FF FF FF 
2841   1AF3 FF FF FF FF 
2841   1AF7 FF FF FF FF 
2841   1AFB FF FF FF FF 
2841   1AFF FF FF FF FF 
2841   1B03 FF FF FF FF 
2841   1B07 FF FF FF FF 
2841   1B0B FF FF FF FF 
2841   1B0F FF FF FF FF 
2841   1B13 FF FF FF FF 
2841   1B17 FF FF FF FF 
2841   1B1B FF FF FF FF 
2841   1B1F FF FF FF FF 
2841   1B23 FF FF FF FF 
2841   1B27 FF FF FF FF 
2841   1B2B FF FF FF FF 
2841   1B2F FF FF FF FF 
2841   1B33 FF FF FF FF 
2841   1B37 FF FF FF FF 
2841   1B3B FF FF FF FF 
2841   1B3F FF FF FF FF 
2841   1B43 FF FF FF FF 
2841   1B47 FF FF FF FF 
2841   1B4B FF FF FF FF 
2841   1B4F FF FF FF FF 
2841   1B53 FF FF FF FF 
2841   1B57 FF FF FF FF 
2841   1B5B FF FF FF FF 
2841   1B5F FF FF FF FF 
2841   1B63 FF FF FF FF 
2841   1B67 FF FF FF FF 
2841   1B6B FF FF FF FF 
2841   1B6F FF FF FF FF 
2841   1B73 FF FF FF FF 
2841   1B77 FF FF FF FF 
2841   1B7B FF FF FF FF 
2841   1B7F FF FF FF FF 
2841   1B83 FF FF FF FF 
2841   1B87 FF FF FF FF 
2841   1B8B FF FF FF FF 
2841   1B8F FF FF FF FF 
2841   1B93 FF 
2842   1B94             fdc_irq_event:
2843   1B94 00            .fill 1,  $00       ; keeps status of fdc irq event
2844   1B95             
2845   1B95             proc_state_table:   
2846   1B95 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2846   1B99 00 00 00 00 
2846   1B9D 00 00 00 00 
2846   1BA1 00 00 00 00 
2846   1BA5 00 00 00 00 
2846   1BA9 00 00 00 00 
2846   1BAD 00 00 00 00 
2846   1BB1 00 00 00 00 
2846   1BB5 00 00 00 00 
2846   1BB9 00 00 00 00 
2846   1BBD 00 00 00 00 
2846   1BC1 00 00 00 00 
2846   1BC5 00 00 00 00 
2846   1BC9 00 00 00 00 
2846   1BCD 00 00 00 00 
2846   1BD1 00 00 00 00 
2846   1BD5 00 00 00 00 
2846   1BD9 00 00 00 00 
2846   1BDD 00 00 00 00 
2846   1BE1 00 00 00 00 
2846   1BE5 00 00 00 00 
2846   1BE9 00 00 00 00 
2846   1BED 00 00 00 00 
2846   1BF1 00 00 00 00 
2846   1BF5 00 00 00 00 
2846   1BF9 00 00 00 00 
2846   1BFD 00 00 00 00 
2846   1C01 00 00 00 00 
2846   1C05 00 00 00 00 
2846   1C09 00 00 00 00 
2846   1C0D 00 00 00 00 
2846   1C11 00 00 00 00 
2846   1C15 00 00 00 00 
2846   1C19 00 00 00 00 
2846   1C1D 00 00 00 00 
2846   1C21 00 00 00 00 
2846   1C25 00 00 00 00 
2846   1C29 00 00 00 00 
2846   1C2D 00 00 00 00 
2846   1C31 00 00 00 00 
2846   1C35 00 00 00 00 
2846   1C39 00 00 00 00 
2846   1C3D 00 00 00 00 
2846   1C41 00 00 00 00 
2846   1C45 00 00 00 00 
2846   1C49 00 00 00 00 
2846   1C4D 00 00 00 00 
2846   1C51 00 00 00 00 
2846   1C55 00 00 00 00 
2846   1C59 00 00 00 00 
2846   1C5D 00 00 00 00 
2846   1C61 00 00 00 00 
2846   1C65 00 00 00 00 
2846   1C69 00 00 00 00 
2846   1C6D 00 00 00 00 
2846   1C71 00 00 00 00 
2846   1C75 00 00 00 00 
2846   1C79 00 00 00 00 
2846   1C7D 00 00 00 00 
2846   1C81 00 00 00 00 
2846   1C85 00 00 00 00 
2846   1C89 00 00 00 00 
2846   1C8D 00 00 00 00 
2846   1C91 00 00 00 00 
2846   1C95 00 00 00 00 
2846   1C99 00 00 00 00 
2846   1C9D 00 00 00 00 
2846   1CA1 00 00 00 00 
2846   1CA5 00 00 00 00 
2846   1CA9 00 00 00 00 
2846   1CAD 00 00 00 00 
2846   1CB1 00 00 00 00 
2846   1CB5 00 00 00 00 
2846   1CB9 00 00 00 00 
2846   1CBD 00 00 00 00 
2846   1CC1 00 00 00 00 
2846   1CC5 00 00 00 00 
2846   1CC9 00 00 00 00 
2846   1CCD 00 00 00 00 
2846   1CD1 00 00 00 00 
2847   1CD5             proc_availab_table: 
2848   1CD5 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2848   1CD9 00 00 00 00 
2848   1CDD 00 00 00 00 
2848   1CE1 00 00 00 00 
2849   1CE5             proc_names:
2850   1CE5 00 00 00 00   .fill 16 * 32, 0  ; process names
2850   1CE9 00 00 00 00 
2850   1CED 00 00 00 00 
2850   1CF1 00 00 00 00 
2850   1CF5 00 00 00 00 
2850   1CF9 00 00 00 00 
2850   1CFD 00 00 00 00 
2850   1D01 00 00 00 00 
2850   1D05 00 00 00 00 
2850   1D09 00 00 00 00 
2850   1D0D 00 00 00 00 
2850   1D11 00 00 00 00 
2850   1D15 00 00 00 00 
2850   1D19 00 00 00 00 
2850   1D1D 00 00 00 00 
2850   1D21 00 00 00 00 
2850   1D25 00 00 00 00 
2850   1D29 00 00 00 00 
2850   1D2D 00 00 00 00 
2850   1D31 00 00 00 00 
2850   1D35 00 00 00 00 
2850   1D39 00 00 00 00 
2850   1D3D 00 00 00 00 
2850   1D41 00 00 00 00 
2850   1D45 00 00 00 00 
2850   1D49 00 00 00 00 
2850   1D4D 00 00 00 00 
2850   1D51 00 00 00 00 
2850   1D55 00 00 00 00 
2850   1D59 00 00 00 00 
2850   1D5D 00 00 00 00 
2850   1D61 00 00 00 00 
2850   1D65 00 00 00 00 
2850   1D69 00 00 00 00 
2850   1D6D 00 00 00 00 
2850   1D71 00 00 00 00 
2850   1D75 00 00 00 00 
2850   1D79 00 00 00 00 
2850   1D7D 00 00 00 00 
2850   1D81 00 00 00 00 
2850   1D85 00 00 00 00 
2850   1D89 00 00 00 00 
2850   1D8D 00 00 00 00 
2850   1D91 00 00 00 00 
2850   1D95 00 00 00 00 
2850   1D99 00 00 00 00 
2850   1D9D 00 00 00 00 
2850   1DA1 00 00 00 00 
2850   1DA5 00 00 00 00 
2850   1DA9 00 00 00 00 
2850   1DAD 00 00 00 00 
2850   1DB1 00 00 00 00 
2850   1DB5 00 00 00 00 
2850   1DB9 00 00 00 00 
2850   1DBD 00 00 00 00 
2850   1DC1 00 00 00 00 
2850   1DC5 00 00 00 00 
2850   1DC9 00 00 00 00 
2850   1DCD 00 00 00 00 
2850   1DD1 00 00 00 00 
2850   1DD5 00 00 00 00 
2850   1DD9 00 00 00 00 
2850   1DDD 00 00 00 00 
2850   1DE1 00 00 00 00 
2850   1DE5 00 00 00 00 
2850   1DE9 00 00 00 00 
2850   1DED 00 00 00 00 
2850   1DF1 00 00 00 00 
2850   1DF5 00 00 00 00 
2850   1DF9 00 00 00 00 
2850   1DFD 00 00 00 00 
2850   1E01 00 00 00 00 
2850   1E05 00 00 00 00 
2850   1E09 00 00 00 00 
2850   1E0D 00 00 00 00 
2850   1E11 00 00 00 00 
2850   1E15 00 00 00 00 
2850   1E19 00 00 00 00 
2850   1E1D 00 00 00 00 
2850   1E21 00 00 00 00 
2850   1E25 00 00 00 00 
2850   1E29 00 00 00 00 
2850   1E2D 00 00 00 00 
2850   1E31 00 00 00 00 
2850   1E35 00 00 00 00 
2850   1E39 00 00 00 00 
2850   1E3D 00 00 00 00 
2850   1E41 00 00 00 00 
2850   1E45 00 00 00 00 
2850   1E49 00 00 00 00 
2850   1E4D 00 00 00 00 
2850   1E51 00 00 00 00 
2850   1E55 00 00 00 00 
2850   1E59 00 00 00 00 
2850   1E5D 00 00 00 00 
2850   1E61 00 00 00 00 
2850   1E65 00 00 00 00 
2850   1E69 00 00 00 00 
2850   1E6D 00 00 00 00 
2850   1E71 00 00 00 00 
2850   1E75 00 00 00 00 
2850   1E79 00 00 00 00 
2850   1E7D 00 00 00 00 
2850   1E81 00 00 00 00 
2850   1E85 00 00 00 00 
2850   1E89 00 00 00 00 
2850   1E8D 00 00 00 00 
2850   1E91 00 00 00 00 
2850   1E95 00 00 00 00 
2850   1E99 00 00 00 00 
2850   1E9D 00 00 00 00 
2850   1EA1 00 00 00 00 
2850   1EA5 00 00 00 00 
2850   1EA9 00 00 00 00 
2850   1EAD 00 00 00 00 
2850   1EB1 00 00 00 00 
2850   1EB5 00 00 00 00 
2850   1EB9 00 00 00 00 
2850   1EBD 00 00 00 00 
2850   1EC1 00 00 00 00 
2850   1EC5 00 00 00 00 
2850   1EC9 00 00 00 00 
2850   1ECD 00 00 00 00 
2850   1ED1 00 00 00 00 
2850   1ED5 00 00 00 00 
2850   1ED9 00 00 00 00 
2850   1EDD 00 00 00 00 
2850   1EE1 00 00 00 00 
2851   1EE5             filename:
2852   1EE5 00 00 00 00   .fill 128, 0      ; holds a path for file search
2852   1EE9 00 00 00 00 
2852   1EED 00 00 00 00 
2852   1EF1 00 00 00 00 
2852   1EF5 00 00 00 00 
2852   1EF9 00 00 00 00 
2852   1EFD 00 00 00 00 
2852   1F01 00 00 00 00 
2852   1F05 00 00 00 00 
2852   1F09 00 00 00 00 
2852   1F0D 00 00 00 00 
2852   1F11 00 00 00 00 
2852   1F15 00 00 00 00 
2852   1F19 00 00 00 00 
2852   1F1D 00 00 00 00 
2852   1F21 00 00 00 00 
2852   1F25 00 00 00 00 
2852   1F29 00 00 00 00 
2852   1F2D 00 00 00 00 
2852   1F31 00 00 00 00 
2852   1F35 00 00 00 00 
2852   1F39 00 00 00 00 
2852   1F3D 00 00 00 00 
2852   1F41 00 00 00 00 
2852   1F45 00 00 00 00 
2852   1F49 00 00 00 00 
2852   1F4D 00 00 00 00 
2852   1F51 00 00 00 00 
2852   1F55 00 00 00 00 
2852   1F59 00 00 00 00 
2852   1F5D 00 00 00 00 
2852   1F61 00 00 00 00 
2853   1F65             user_data:
2854   1F65 00 00 00 00   .fill 512, 0      ;  user space data
2854   1F69 00 00 00 00 
2854   1F6D 00 00 00 00 
2854   1F71 00 00 00 00 
2854   1F75 00 00 00 00 
2854   1F79 00 00 00 00 
2854   1F7D 00 00 00 00 
2854   1F81 00 00 00 00 
2854   1F85 00 00 00 00 
2854   1F89 00 00 00 00 
2854   1F8D 00 00 00 00 
2854   1F91 00 00 00 00 
2854   1F95 00 00 00 00 
2854   1F99 00 00 00 00 
2854   1F9D 00 00 00 00 
2854   1FA1 00 00 00 00 
2854   1FA5 00 00 00 00 
2854   1FA9 00 00 00 00 
2854   1FAD 00 00 00 00 
2854   1FB1 00 00 00 00 
2854   1FB5 00 00 00 00 
2854   1FB9 00 00 00 00 
2854   1FBD 00 00 00 00 
2854   1FC1 00 00 00 00 
2854   1FC5 00 00 00 00 
2854   1FC9 00 00 00 00 
2854   1FCD 00 00 00 00 
2854   1FD1 00 00 00 00 
2854   1FD5 00 00 00 00 
2854   1FD9 00 00 00 00 
2854   1FDD 00 00 00 00 
2854   1FE1 00 00 00 00 
2854   1FE5 00 00 00 00 
2854   1FE9 00 00 00 00 
2854   1FED 00 00 00 00 
2854   1FF1 00 00 00 00 
2854   1FF5 00 00 00 00 
2854   1FF9 00 00 00 00 
2854   1FFD 00 00 00 00 
2854   2001 00 00 00 00 
2854   2005 00 00 00 00 
2854   2009 00 00 00 00 
2854   200D 00 00 00 00 
2854   2011 00 00 00 00 
2854   2015 00 00 00 00 
2854   2019 00 00 00 00 
2854   201D 00 00 00 00 
2854   2021 00 00 00 00 
2854   2025 00 00 00 00 
2854   2029 00 00 00 00 
2854   202D 00 00 00 00 
2854   2031 00 00 00 00 
2854   2035 00 00 00 00 
2854   2039 00 00 00 00 
2854   203D 00 00 00 00 
2854   2041 00 00 00 00 
2854   2045 00 00 00 00 
2854   2049 00 00 00 00 
2854   204D 00 00 00 00 
2854   2051 00 00 00 00 
2854   2055 00 00 00 00 
2854   2059 00 00 00 00 
2854   205D 00 00 00 00 
2854   2061 00 00 00 00 
2854   2065 00 00 00 00 
2854   2069 00 00 00 00 
2854   206D 00 00 00 00 
2854   2071 00 00 00 00 
2854   2075 00 00 00 00 
2854   2079 00 00 00 00 
2854   207D 00 00 00 00 
2854   2081 00 00 00 00 
2854   2085 00 00 00 00 
2854   2089 00 00 00 00 
2854   208D 00 00 00 00 
2854   2091 00 00 00 00 
2854   2095 00 00 00 00 
2854   2099 00 00 00 00 
2854   209D 00 00 00 00 
2854   20A1 00 00 00 00 
2854   20A5 00 00 00 00 
2854   20A9 00 00 00 00 
2854   20AD 00 00 00 00 
2854   20B1 00 00 00 00 
2854   20B5 00 00 00 00 
2854   20B9 00 00 00 00 
2854   20BD 00 00 00 00 
2854   20C1 00 00 00 00 
2854   20C5 00 00 00 00 
2854   20C9 00 00 00 00 
2854   20CD 00 00 00 00 
2854   20D1 00 00 00 00 
2854   20D5 00 00 00 00 
2854   20D9 00 00 00 00 
2854   20DD 00 00 00 00 
2854   20E1 00 00 00 00 
2854   20E5 00 00 00 00 
2854   20E9 00 00 00 00 
2854   20ED 00 00 00 00 
2854   20F1 00 00 00 00 
2854   20F5 00 00 00 00 
2854   20F9 00 00 00 00 
2854   20FD 00 00 00 00 
2854   2101 00 00 00 00 
2854   2105 00 00 00 00 
2854   2109 00 00 00 00 
2854   210D 00 00 00 00 
2854   2111 00 00 00 00 
2854   2115 00 00 00 00 
2854   2119 00 00 00 00 
2854   211D 00 00 00 00 
2854   2121 00 00 00 00 
2854   2125 00 00 00 00 
2854   2129 00 00 00 00 
2854   212D 00 00 00 00 
2854   2131 00 00 00 00 
2854   2135 00 00 00 00 
2854   2139 00 00 00 00 
2854   213D 00 00 00 00 
2854   2141 00 00 00 00 
2854   2145 00 00 00 00 
2854   2149 00 00 00 00 
2854   214D 00 00 00 00 
2854   2151 00 00 00 00 
2854   2155 00 00 00 00 
2854   2159 00 00 00 00 
2854   215D 00 00 00 00 
2854   2161 00 00 00 00 
2855   2165             fifo:
2856   2165 FF FF FF FF   .fill FIFO_SIZE
2856   2169 FF FF FF FF 
2856   216D FF FF FF FF 
2856   2171 FF FF FF FF 
2856   2175 FF FF FF FF 
2856   2179 FF FF FF FF 
2856   217D FF FF FF FF 
2856   2181 FF FF FF FF 
2856   2185 FF FF FF FF 
2856   2189 FF FF FF FF 
2856   218D FF FF FF FF 
2856   2191 FF FF FF FF 
2856   2195 FF FF FF FF 
2856   2199 FF FF FF FF 
2856   219D FF FF FF FF 
2856   21A1 FF FF FF FF 
2856   21A5 FF FF FF FF 
2856   21A9 FF FF FF FF 
2856   21AD FF FF FF FF 
2856   21B1 FF FF FF FF 
2856   21B5 FF FF FF FF 
2856   21B9 FF FF FF FF 
2856   21BD FF FF FF FF 
2856   21C1 FF FF FF FF 
2856   21C5 FF FF FF FF 
2856   21C9 FF FF FF FF 
2856   21CD FF FF FF FF 
2856   21D1 FF FF FF FF 
2856   21D5 FF FF FF FF 
2856   21D9 FF FF FF FF 
2856   21DD FF FF FF FF 
2856   21E1 FF FF FF FF 
2856   21E5 FF FF FF FF 
2856   21E9 FF FF FF FF 
2856   21ED FF FF FF FF 
2856   21F1 FF FF FF FF 
2856   21F5 FF FF FF FF 
2856   21F9 FF FF FF FF 
2856   21FD FF FF FF FF 
2856   2201 FF FF FF FF 
2856   2205 FF FF FF FF 
2856   2209 FF FF FF FF 
2856   220D FF FF FF FF 
2856   2211 FF FF FF FF 
2856   2215 FF FF FF FF 
2856   2219 FF FF FF FF 
2856   221D FF FF FF FF 
2856   2221 FF FF FF FF 
2856   2225 FF FF FF FF 
2856   2229 FF FF FF FF 
2856   222D FF FF FF FF 
2856   2231 FF FF FF FF 
2856   2235 FF FF FF FF 
2856   2239 FF FF FF FF 
2856   223D FF FF FF FF 
2856   2241 FF FF FF FF 
2856   2245 FF FF FF FF 
2856   2249 FF FF FF FF 
2856   224D FF FF FF FF 
2856   2251 FF FF FF FF 
2856   2255 FF FF FF FF 
2856   2259 FF FF FF FF 
2856   225D FF FF FF FF 
2856   2261 FF FF FF FF 
2856   2265 FF FF FF FF 
2856   2269 FF FF FF FF 
2856   226D FF FF FF FF 
2856   2271 FF FF FF FF 
2856   2275 FF FF FF FF 
2856   2279 FF FF FF FF 
2856   227D FF FF FF FF 
2856   2281 FF FF FF FF 
2856   2285 FF FF FF FF 
2856   2289 FF FF FF FF 
2856   228D FF FF FF FF 
2856   2291 FF FF FF FF 
2856   2295 FF FF FF FF 
2856   2299 FF FF FF FF 
2856   229D FF FF FF FF 
2856   22A1 FF FF FF FF 
2856   22A5 FF FF FF FF 
2856   22A9 FF FF FF FF 
2856   22AD FF FF FF FF 
2856   22B1 FF FF FF FF 
2856   22B5 FF FF FF FF 
2856   22B9 FF FF FF FF 
2856   22BD FF FF FF FF 
2856   22C1 FF FF FF FF 
2856   22C5 FF FF FF FF 
2856   22C9 FF FF FF FF 
2856   22CD FF FF FF FF 
2856   22D1 FF FF FF FF 
2856   22D5 FF FF FF FF 
2856   22D9 FF FF FF FF 
2856   22DD FF FF FF FF 
2856   22E1 FF FF FF FF 
2856   22E5 FF FF FF FF 
2856   22E9 FF FF FF FF 
2856   22ED FF FF FF FF 
2856   22F1 FF FF FF FF 
2856   22F5 FF FF FF FF 
2856   22F9 FF FF FF FF 
2856   22FD FF FF FF FF 
2856   2301 FF FF FF FF 
2856   2305 FF FF FF FF 
2856   2309 FF FF FF FF 
2856   230D FF FF FF FF 
2856   2311 FF FF FF FF 
2856   2315 FF FF FF FF 
2856   2319 FF FF FF FF 
2856   231D FF FF FF FF 
2856   2321 FF FF FF FF 
2856   2325 FF FF FF FF 
2856   2329 FF FF FF FF 
2856   232D FF FF FF FF 
2856   2331 FF FF FF FF 
2856   2335 FF FF FF FF 
2856   2339 FF FF FF FF 
2856   233D FF FF FF FF 
2856   2341 FF FF FF FF 
2856   2345 FF FF FF FF 
2856   2349 FF FF FF FF 
2856   234D FF FF FF FF 
2856   2351 FF FF FF FF 
2856   2355 FF FF FF FF 
2856   2359 FF FF FF FF 
2856   235D FF FF FF FF 
2856   2361 FF FF FF FF 
2856   2365 FF FF FF FF 
2856   2369 FF FF FF FF 
2856   236D FF FF FF FF 
2856   2371 FF FF FF FF 
2856   2375 FF FF FF FF 
2856   2379 FF FF FF FF 
2856   237D FF FF FF FF 
2856   2381 FF FF FF FF 
2856   2385 FF FF FF FF 
2856   2389 FF FF FF FF 
2856   238D FF FF FF FF 
2856   2391 FF FF FF FF 
2856   2395 FF FF FF FF 
2856   2399 FF FF FF FF 
2856   239D FF FF FF FF 
2856   23A1 FF FF FF FF 
2856   23A5 FF FF FF FF 
2856   23A9 FF FF FF FF 
2856   23AD FF FF FF FF 
2856   23B1 FF FF FF FF 
2856   23B5 FF FF FF FF 
2856   23B9 FF FF FF FF 
2856   23BD FF FF FF FF 
2856   23C1 FF FF FF FF 
2856   23C5 FF FF FF FF 
2856   23C9 FF FF FF FF 
2856   23CD FF FF FF FF 
2856   23D1 FF FF FF FF 
2856   23D5 FF FF FF FF 
2856   23D9 FF FF FF FF 
2856   23DD FF FF FF FF 
2856   23E1 FF FF FF FF 
2856   23E5 FF FF FF FF 
2856   23E9 FF FF FF FF 
2856   23ED FF FF FF FF 
2856   23F1 FF FF FF FF 
2856   23F5 FF FF FF FF 
2856   23F9 FF FF FF FF 
2856   23FD FF FF FF FF 
2856   2401 FF FF FF FF 
2856   2405 FF FF FF FF 
2856   2409 FF FF FF FF 
2856   240D FF FF FF FF 
2856   2411 FF FF FF FF 
2856   2415 FF FF FF FF 
2856   2419 FF FF FF FF 
2856   241D FF FF FF FF 
2856   2421 FF FF FF FF 
2856   2425 FF FF FF FF 
2856   2429 FF FF FF FF 
2856   242D FF FF FF FF 
2856   2431 FF FF FF FF 
2856   2435 FF FF FF FF 
2856   2439 FF FF FF FF 
2856   243D FF FF FF FF 
2856   2441 FF FF FF FF 
2856   2445 FF FF FF FF 
2856   2449 FF FF FF FF 
2856   244D FF FF FF FF 
2856   2451 FF FF FF FF 
2856   2455 FF FF FF FF 
2856   2459 FF FF FF FF 
2856   245D FF FF FF FF 
2856   2461 FF FF FF FF 
2856   2465 FF FF FF FF 
2856   2469 FF FF FF FF 
2856   246D FF FF FF FF 
2856   2471 FF FF FF FF 
2856   2475 FF FF FF FF 
2856   2479 FF FF FF FF 
2856   247D FF FF FF FF 
2856   2481 FF FF FF FF 
2856   2485 FF FF FF FF 
2856   2489 FF FF FF FF 
2856   248D FF FF FF FF 
2856   2491 FF FF FF FF 
2856   2495 FF FF FF FF 
2856   2499 FF FF FF FF 
2856   249D FF FF FF FF 
2856   24A1 FF FF FF FF 
2856   24A5 FF FF FF FF 
2856   24A9 FF FF FF FF 
2856   24AD FF FF FF FF 
2856   24B1 FF FF FF FF 
2856   24B5 FF FF FF FF 
2856   24B9 FF FF FF FF 
2856   24BD FF FF FF FF 
2856   24C1 FF FF FF FF 
2856   24C5 FF FF FF FF 
2856   24C9 FF FF FF FF 
2856   24CD FF FF FF FF 
2856   24D1 FF FF FF FF 
2856   24D5 FF FF FF FF 
2856   24D9 FF FF FF FF 
2856   24DD FF FF FF FF 
2856   24E1 FF FF FF FF 
2856   24E5 FF FF FF FF 
2856   24E9 FF FF FF FF 
2856   24ED FF FF FF FF 
2856   24F1 FF FF FF FF 
2856   24F5 FF FF FF FF 
2856   24F9 FF FF FF FF 
2856   24FD FF FF FF FF 
2856   2501 FF FF FF FF 
2856   2505 FF FF FF FF 
2856   2509 FF FF FF FF 
2856   250D FF FF FF FF 
2856   2511 FF FF FF FF 
2856   2515 FF FF FF FF 
2856   2519 FF FF FF FF 
2856   251D FF FF FF FF 
2856   2521 FF FF FF FF 
2856   2525 FF FF FF FF 
2856   2529 FF FF FF FF 
2856   252D FF FF FF FF 
2856   2531 FF FF FF FF 
2856   2535 FF FF FF FF 
2856   2539 FF FF FF FF 
2856   253D FF FF FF FF 
2856   2541 FF FF FF FF 
2856   2545 FF FF FF FF 
2856   2549 FF FF FF FF 
2856   254D FF FF FF FF 
2856   2551 FF FF FF FF 
2856   2555 FF FF FF FF 
2856   2559 FF FF FF FF 
2856   255D FF FF FF FF 
2856   2561 FF FF FF FF 
2857   2565             
2858   2565             scrap_sector:
2859   2565 FF FF FF FF   .fill 512         ; scrap sector
2859   2569 FF FF FF FF 
2859   256D FF FF FF FF 
2859   2571 FF FF FF FF 
2859   2575 FF FF FF FF 
2859   2579 FF FF FF FF 
2859   257D FF FF FF FF 
2859   2581 FF FF FF FF 
2859   2585 FF FF FF FF 
2859   2589 FF FF FF FF 
2859   258D FF FF FF FF 
2859   2591 FF FF FF FF 
2859   2595 FF FF FF FF 
2859   2599 FF FF FF FF 
2859   259D FF FF FF FF 
2859   25A1 FF FF FF FF 
2859   25A5 FF FF FF FF 
2859   25A9 FF FF FF FF 
2859   25AD FF FF FF FF 
2859   25B1 FF FF FF FF 
2859   25B5 FF FF FF FF 
2859   25B9 FF FF FF FF 
2859   25BD FF FF FF FF 
2859   25C1 FF FF FF FF 
2859   25C5 FF FF FF FF 
2859   25C9 FF FF FF FF 
2859   25CD FF FF FF FF 
2859   25D1 FF FF FF FF 
2859   25D5 FF FF FF FF 
2859   25D9 FF FF FF FF 
2859   25DD FF FF FF FF 
2859   25E1 FF FF FF FF 
2859   25E5 FF FF FF FF 
2859   25E9 FF FF FF FF 
2859   25ED FF FF FF FF 
2859   25F1 FF FF FF FF 
2859   25F5 FF FF FF FF 
2859   25F9 FF FF FF FF 
2859   25FD FF FF FF FF 
2859   2601 FF FF FF FF 
2859   2605 FF FF FF FF 
2859   2609 FF FF FF FF 
2859   260D FF FF FF FF 
2859   2611 FF FF FF FF 
2859   2615 FF FF FF FF 
2859   2619 FF FF FF FF 
2859   261D FF FF FF FF 
2859   2621 FF FF FF FF 
2859   2625 FF FF FF FF 
2859   2629 FF FF FF FF 
2859   262D FF FF FF FF 
2859   2631 FF FF FF FF 
2859   2635 FF FF FF FF 
2859   2639 FF FF FF FF 
2859   263D FF FF FF FF 
2859   2641 FF FF FF FF 
2859   2645 FF FF FF FF 
2859   2649 FF FF FF FF 
2859   264D FF FF FF FF 
2859   2651 FF FF FF FF 
2859   2655 FF FF FF FF 
2859   2659 FF FF FF FF 
2859   265D FF FF FF FF 
2859   2661 FF FF FF FF 
2859   2665 FF FF FF FF 
2859   2669 FF FF FF FF 
2859   266D FF FF FF FF 
2859   2671 FF FF FF FF 
2859   2675 FF FF FF FF 
2859   2679 FF FF FF FF 
2859   267D FF FF FF FF 
2859   2681 FF FF FF FF 
2859   2685 FF FF FF FF 
2859   2689 FF FF FF FF 
2859   268D FF FF FF FF 
2859   2691 FF FF FF FF 
2859   2695 FF FF FF FF 
2859   2699 FF FF FF FF 
2859   269D FF FF FF FF 
2859   26A1 FF FF FF FF 
2859   26A5 FF FF FF FF 
2859   26A9 FF FF FF FF 
2859   26AD FF FF FF FF 
2859   26B1 FF FF FF FF 
2859   26B5 FF FF FF FF 
2859   26B9 FF FF FF FF 
2859   26BD FF FF FF FF 
2859   26C1 FF FF FF FF 
2859   26C5 FF FF FF FF 
2859   26C9 FF FF FF FF 
2859   26CD FF FF FF FF 
2859   26D1 FF FF FF FF 
2859   26D5 FF FF FF FF 
2859   26D9 FF FF FF FF 
2859   26DD FF FF FF FF 
2859   26E1 FF FF FF FF 
2859   26E5 FF FF FF FF 
2859   26E9 FF FF FF FF 
2859   26ED FF FF FF FF 
2859   26F1 FF FF FF FF 
2859   26F5 FF FF FF FF 
2859   26F9 FF FF FF FF 
2859   26FD FF FF FF FF 
2859   2701 FF FF FF FF 
2859   2705 FF FF FF FF 
2859   2709 FF FF FF FF 
2859   270D FF FF FF FF 
2859   2711 FF FF FF FF 
2859   2715 FF FF FF FF 
2859   2719 FF FF FF FF 
2859   271D FF FF FF FF 
2859   2721 FF FF FF FF 
2859   2725 FF FF FF FF 
2859   2729 FF FF FF FF 
2859   272D FF FF FF FF 
2859   2731 FF FF FF FF 
2859   2735 FF FF FF FF 
2859   2739 FF FF FF FF 
2859   273D FF FF FF FF 
2859   2741 FF FF FF FF 
2859   2745 FF FF FF FF 
2859   2749 FF FF FF FF 
2859   274D FF FF FF FF 
2859   2751 FF FF FF FF 
2859   2755 FF FF FF FF 
2859   2759 FF FF FF FF 
2859   275D FF FF FF FF 
2859   2761 FF FF FF FF 
2860   2765             transient_area:
2861   2765 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2862   2766             
2863   2766             .end
tasm: Number of errors = 0
