0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; For the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; FILE ENTRY ATTRIBUTES
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0107   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0108   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0109   0000             FST_NBR_DIRECTORIES     .equ 64
0110   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0112   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0113   0000             FST_LBA_START           .equ 32
0114   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0115   0000             
0116   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0117   0000             FS_SECTORS_PER_FILE     .equ 32 ; the first sector is always a header with a NULL parameter (first byte)
0118   0000                                             ; so that we know which blocks are free or taken
0119   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0120   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0121   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0122   0000             FS_LBA_END              .equ (FS_LBA_START + FS_TOTAL_SECTORS - 1)
0123   0000             
0124   0000             root_id:                .equ FST_LBA_START
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; GLOBAL SYSTEM VARIABLES
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; IRQ table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 59 00       .dw int_6
0141   000E A5 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 9C 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 94 02       .dw trap_privilege
0153   0014 B1 03       .dw trap_div_zero
0154   0016 BE 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 A0 02       .dw syscall_break
0165   0022 BF 03       .dw syscall_rtc
0166   0024 F9 04       .dw syscall_ide
0167   0026 D4 05       .dw syscall_io
0168   0028 91 06       .dw syscall_file_system
0169   002A E9 0F       .dw syscall_create_proc
0170   002C 59 02       .dw syscall_list_procs
0171   002E F1 03       .dw syscall_datetime
0172   0030 15 02       .dw syscall_reboot
0173   0032 B3 0F       .dw syscall_pause_proc
0174   0034 21 02       .dw syscall_resume_proc
0175   0036 70 0F       .dw syscall_terminate_proc
0176   0038 E4 00       .dw syscall_system
0177   003A 20 01       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             .export fdc_irq_event
0216   003C             
0217   003C             ; ------------------------------------------------------------------------------------------------------------------;
0218   003C             ; IRQs' code block
0219   003C             ; ------------------------------------------------------------------------------------------------------------------;
0220   003C             ; 5.25" Floppy Drive Controller IRQ
0221   003C             int_0_fdc:
0222   003C 3B 48 00      mov d, s_fdc_irq
0223   003F 07 E6 12      call _puts
0224   0042 06            sysret
0225   0043             int_1:
0226   0043 06            sysret
0227   0044             int_2:
0228   0044 06            sysret
0229   0045             int_3:
0230   0045 06            sysret
0231   0046             int_4:
0232   0046 06            sysret
0233   0047             int_5:
0234   0047 06            sysret
0235   0048             
0236   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0236   004C 30 20 45 78 
0236   0050 65 63 75 74 
0236   0054 65 64 2E 0A 
0236   0058 00 
0237   0059             
0238   0059             ; ------------------------------------------------------------------------------------------------------------------;
0239   0059             ; process swapping
0240   0059             ; ------------------------------------------------------------------------------------------------------------------;
0241   0059             int_6:  
0242   0059 4B            pusha                             ; save all registers into kernel stack
0243   005A 22 00         mov ah, 0
0244   005C 1D 17 18      mov al, [active_proc_index]
0245   005F FD 99         shl a                             ; x2
0246   0061 B7 66 10      mov a, [proc_table_convert + a]   ; get process state start index
0247   0064 4F            mov di, a
0248   0065 48            mov a, sp
0249   0066 77            inc a
0250   0067 4D            mov si, a
0251   0068 38 14 00      mov c, 20
0252   006B FD F5         rep movsb                         ; save process state!
0253   006D             ; restore kernel stack position to point before interrupt arrived
0254   006D 51 14 00      add sp, 20
0255   0070             ; now load next process in queue
0256   0070 1D 17 18      mov al, [active_proc_index]
0257   0073 31 16 18      mov bl, [nbr_active_procs]
0258   0076 BA            cmp al, bl
0259   0077 C6 7E 00      je int6_cycle_back
0260   007A 7A            inc al                            ; next process is next in the series
0261   007B 0A 80 00      jmp int6_continue
0262   007E             int6_cycle_back:
0263   007E 19 01         mov al, 1                         ; next process = process 1
0264   0080             int6_continue:
0265   0080 3D 17 18      mov [active_proc_index], al       ; set next active proc
0266   0083             
0267   0083             ; calculate LUT entry for next process
0268   0083 22 00         mov ah, 0
0269   0085 FD 99         shl a                             ; x2
0270   0087 B7 66 10      mov a, [proc_table_convert + a]   ; get process state start index  
0271   008A               
0272   008A 4D            mov si, a                         ; source is proc state block
0273   008B 48            mov a, sp
0274   008C 5F 13 00      sub a, 19
0275   008F 4F            mov di, a                         ; destination is kernel stack
0276   0090             ; restore SP
0277   0090 7D            dec a
0278   0091 47            mov sp, a
0279   0092 38 14 00      mov c, 20
0280   0095 FD F5         rep movsb
0281   0097             ; set VM process
0282   0097 1D 17 18      mov al, [active_proc_index]
0283   009A 01            setptb
0284   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0           ; load counter 0 low byte
0285   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10         ; load counter 0 high byte
0286   00A3 4C            popa
0287   00A4 06            sysret
0288   00A5             
0289   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0290   00A5             ; UART0 Interrupt
0291   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0292   00A5             int_7_uart0:
0293   00A5 D7            push a
0294   00A6 DA            push d
0295   00A7 E1            pushf
0296   00A8 14 1C 18      mov a, [fifo_in]
0297   00AB 3C            mov d, a
0298   00AC 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0299   00AF B9 03         cmp al, $03                 ; CTRL-C
0300   00B1 C6 CE 00      je CTRLC
0301   00B4 B9 1A         cmp al, $1A                 ; CTRL-Z
0302   00B6 C6 D4 00      je CTRLZ
0303   00B9 3E            mov [d], al                 ; add to fifo
0304   00BA 14 1C 18      mov a, [fifo_in]
0305   00BD 77            inc a
0306   00BE AF 6D 25      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0307   00C1 C7 C7 00      jne int_7_continue
0308   00C4 10 6D 21      mov a, fifo  
0309   00C7             int_7_continue:  
0310   00C7 42 1C 18      mov [fifo_in], a            ; update fifo pointer
0311   00CA EE            popf
0312   00CB E7            pop d
0313   00CC E4            pop a  
0314   00CD 06            sysret
0315   00CE             CTRLC:
0316   00CE 51 05 00      add sp, 5
0317   00D1 0A 70 0F      jmp syscall_terminate_proc
0318   00D4             CTRLZ:
0319   00D4 EE            popf
0320   00D5 E7            pop d
0321   00D6 E4            pop a
0322   00D7 0A B3 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0323   00DA             
0324   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0325   00DA             ; system syscalls
0326   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0327   00DA             system_jmptbl:
0328   00DA 10 01         .dw system_uname
0329   00DC 17 01         .dw system_whoami
0330   00DE EA 00         .dw system_setparam
0331   00E0 ED 00         .dw system_bootloader_install
0332   00E2 E8 00         .dw system_getparam
0333   00E4             syscall_system:
0334   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0335   00E8             
0336   00E8             ; param register address in register d
0337   00E8             ; param value in register bl
0338   00E8             system_getparam:
0339   00E8 32            mov bl, [d]
0340   00E9 06            sysret
0341   00EA             
0342   00EA             ; param register address in register d
0343   00EA             ; param value in register bl
0344   00EA             system_setparam:
0345   00EA FD 3E         mov [d], bl
0346   00EC 06            sysret
0347   00ED             
0348   00ED             ; kernel LBA address in 'b'
0349   00ED             system_bootloader_install:
0350   00ED D8            push b
0351   00EE 26 00 00      mov b, 0
0352   00F1 38 00 00      mov c, 0
0353   00F4 22 01         mov ah, $01                 ; 1 sector
0354   00F6 3B 6D 27      mov d, transient_area
0355   00F9 07 43 05      call ide_read_sect          ; read sector
0356   00FC E5            pop b
0357   00FD FD 44 FE 01   mov [d + 510], b            ; update LBA address
0358   0101 26 00 00      mov b, 0
0359   0104 38 00 00      mov c, 0
0360   0107 22 01         mov ah, $01                 ; 1 sector
0361   0109 3B 6D 27      mov d, transient_area
0362   010C 07 69 05      call ide_write_sect         ; write sector
0363   010F 06            sysret
0364   0110             
0365   0110             system_uname:
0366   0110 3B 2D 18      mov d, s_uname
0367   0113 07 E6 12      call _puts
0368   0116 06            sysret
0369   0117             
0370   0117             system_whoami:
0371   0117 06            sysret
0372   0118             
0373   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0374   0118             ; floppy drive system calls
0375   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376   0118             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0377   0118             ; fdc_40_FF:
0378   0118             ;   .fill 40,  $FF    ; or 00                                                                                
0379   0118             ; fdc_128_format_inner:
0380   0118             ;   .fill 6,   $00    ;                                                                            <--|        
0381   0118             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0382   0118             ;   .fill 1,   $00    ; Track Number  0 thru 39                                                       |                    
0383   0118             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0384   0118             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0385   0118             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0386   0118             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0387   0118             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0388   0118             ;   .fill 6,   $00    ;                                                                               |                        
0389   0118             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0390   0118             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0391   0118             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0392   0118             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0393   0118             ; fdc_128_format_end:
0394   0118             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0395   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0396   0118             ; _FDC_CONFIG       .equ $FFC0 
0397   0118             ; _FDC_STATUS_1     .equ $FFC1
0398   0118             ; _FDC_WD_STAT_CMD  .equ $FFC8
0399   0118             ; _FDC_WD_TRACK     .equ $FFC9
0400   0118             ; _FDC_WD_SECTOR    .equ $FFCA
0401   0118             ; _FDC_WD_DATA      .equ $FFCB
0402   0118             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0403   0118             fdc_jmptbl:
0404   0118 3D 01         .dw syscall_fdc_format
0405   011A 24 01         .dw syscall_fdc_status1
0406   011C 2E 01         .dw syscall_fdc_status2
0407   011E 38 01         .dw syscall_fdc_cmd
0408   0120             syscall_fdc:
0409   0120 FD 0A 18 01   jmp [fdc_jmptbl + al]
0410   0124             ; bl: status
0411   0124             syscall_fdc_status1:
0412   0124 3B 07 02      mov d, s_fdc_status
0413   0127 07 E6 12      call _puts
0414   012A 31 C8 FF      mov bl, [_FDC_WD_STAT_CMD]
0415   012D 06            sysret
0416   012E             ; bl: status
0417   012E             syscall_fdc_status2:
0418   012E 3B 07 02      mov d, s_fdc_status
0419   0131 07 E6 12      call _puts
0420   0134 31 C1 FF      mov bl, [_FDC_STATUS_1]
0421   0137 06            sysret
0422   0138             ; issue a fdc command
0423   0138             ; bl: command
0424   0138             syscall_fdc_cmd:
0425   0138 FD 3D C8 FF   mov [_FDC_WD_STAT_CMD], bl
0426   013C 06            sysret
0427   013D             
0428   013D             ; bl: track number
0429   013D             syscall_fdc_format:
0430   013D FD 3D 8A 19   mov [fdc_128_format_track], bl  ; write track number to formatting data block
0431   0141 19 01         mov al, 1
0432   0143 3D 8C 19      mov [fdc_128_format_sect], al   ; reset sector variable to 1
0433   0146 19 80         mov al, %10000000               ; mask out fdc interrupt for now because we are trying to format without using irqs. an irq would consume too much time during formatting
0434   0148 FD 0F         stomsk                        
0435   014A 3B DB 01      mov d, s_format_begin
0436   014D 07 E6 12      call _puts
0437   0150             fdc_header_loop_start:
0438   0150 19 F2         mov al, %11110010               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0439   0152 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0440   0155             ; write the first data block for formatting which is 40 bytes of 0xFF:
0441   0155 07 B9 01      call fdc_wait_64us              ; after issuing write track command, need to wait 64us before reading the status register 
0442   0158 3A 28         mov cl, 40
0443   015A 2E FF         mov bl, $FF                     ; load format byte
0444   015C             fdc_drq_loop: ; for each byte, we need to wait for DRQ to be high
0445   015C 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]
0446   015F 87 02         and al, $02                ; check drq bit
0447   0161 C6 5C 01      jz fdc_drq_loop
0448   0164 FD 3D CB FF   mov [_FDC_WD_DATA], bl     ; send data byte to wd1770
0449   0168 81            dec cl
0450   0169 C7 5C 01      jnz fdc_drq_loop
0451   016C             ; start inner data block loop. this block is written 16 times
0452   016C             fdc_inner_loop:
0453   016C FD 4D 83 19   mov si, fdc_128_format_inner
0454   0170 3A A9         mov cl, 169                 ; the inner format data block has 169 bytes total
0455   0172             fdc_drq_loop1:
0456   0172 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]
0457   0175 87 02         and al, $02                ; check drq bit
0458   0177 C6 72 01      jz fdc_drq_loop1
0459   017A F6            lodsb                      ; load format byte
0460   017B 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0461   017E 81            dec cl
0462   017F C7 72 01      jnz fdc_drq_loop1          ; test whether entire data block was written
0463   0182 1D 8C 19      mov al, [fdc_128_format_sect] ; read the sector number variable in the format data block
0464   0185 7A            inc al
0465   0186 3D 8C 19      mov [fdc_128_format_sect], al ; update the sector number variable in the format data block
0466   0189 B9 11         cmp al, 17
0467   018B C7 6C 01      jne fdc_inner_loop         ; test whether data block was written 16 times
0468   018E             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0469   018E             fdc_format_footer:
0470   018E 2E FF         mov bl, $FF                ; load format byte
0471   0190             fdc_footer_drq_loop:
0472   0190 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]
0473   0193 87 02         and al, $02                ; check drq bit
0474   0195 C6 90 01      jz fdc_footer_drq_loop
0475   0198 FD 3D CB FF   mov [_FDC_WD_DATA], bl     ; send data byte to wd1770
0476   019C 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]
0477   019F 87 01         and al, $01                ; check busy bit
0478   01A1 C7 90 01      jnz fdc_footer_drq_loop    ; if busy == 1, command is not finished, so loop again
0479   01A4             fdc_format_done:
0480   01A4 3B F4 01      mov d, s_format_done
0481   01A7 07 E6 12      call _puts
0482   01AA 19 81         mov al, %10000001          ; re-enable uart and fdc irqs 
0483   01AC FD 0F         stomsk                        
0484   01AE 06            sysret
0485   01AF             
0486   01AF 0A 65 68 0A ss1: .db "\neh\n", 0
0486   01B3 00 
0487   01B4 0A 65 66 0A ss2: .db "\nef\n", 0
0487   01B8 00 
0488   01B9             ; fetch is 2 cycles long when 'display_reg_load' is false.
0489   01B9             ; mov cl, 14 is 5 cycles long (2 to fetch, and 3 execution)
0490   01B9             ; 64us amounts to 160 cycles of the 2.5MHz clock
0491   01B9             ; so we need to wait for 155 cycles after mov cl, 14
0492   01B9             ; and since dec cl, and jnz amount to 11 cycles, we need to loop there 14 times: 14*11 = 154
0493   01B9             ; and 154 + 5 = 159
0494   01B9             fdc_wait_64us:
0495   01B9 3A 0E         mov cl, 14                       ; 5 cycles
0496   01BB             fdc_wait_64_loop:
0497   01BB 81            dec cl                           ; 3 cycles
0498   01BC C7 BB 01      jnz fdc_wait_64_loop             ; 8 cycles
0499   01BF 09            ret
0500   01C0             
0501   01C0 0A 73 65 6E s_send_write_cmd: .db "\nsending write command...\n", 0
0501   01C4 64 69 6E 67 
0501   01C8 20 77 72 69 
0501   01CC 74 65 20 63 
0501   01D0 6F 6D 6D 61 
0501   01D4 6E 64 2E 2E 
0501   01D8 2E 0A 00 
0502   01DB 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0502   01DF 6D 61 74 74 
0502   01E3 69 6E 67 20 
0502   01E7 73 74 61 72 
0502   01EB 74 69 6E 67 
0502   01EF 2E 2E 2E 0A 
0502   01F3 00 
0503   01F4 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0503   01F8 6D 61 74 74 
0503   01FC 69 6E 67 20 
0503   0200 64 6F 6E 65 
0503   0204 2E 0A 00 
0504   0207 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0504   020B 20 73 74 61 
0504   020F 74 75 73 3A 
0504   0213 20 00 
0505   0215             
0506   0215             ; REBOOT SYSTEM
0507   0215             syscall_reboot:
0508   0215 FD D7 FF FF   push word $FFFF 
0509   0219 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0510   021C FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0511   0220 06            sysret
0512   0221             
0513   0221             ;------------------------------------------------------------------------------------------------------;;
0514   0221             ; switch to another process
0515   0221             ; inputs:
0516   0221             ; AL = new process number
0517   0221             ;------------------------------------------------------------------------------------------------------;;
0518   0221             syscall_resume_proc:
0519   0221 FD 78         mov g, a                            ; save the process number
0520   0223 4B            pusha                               ; save all registers into kernel stack
0521   0224 22 00         mov ah, 0
0522   0226 1D 17 18      mov al, [active_proc_index]
0523   0229 FD 99         shl a              ; x2
0524   022B B7 66 10      mov a, [proc_table_convert + a]     ; get process state start index
0525   022E 4F            mov di, a
0526   022F 48            mov a, sp
0527   0230 77            inc a
0528   0231 4D            mov si, a
0529   0232 38 14 00      mov c, 20
0530   0235 FD F5         rep movsb                           ; save process state!
0531   0237             ; restore kernel stack position to point before interrupt arrived
0532   0237 51 14 00      add sp, 20
0533   023A             ; now load the new process number!
0534   023A FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0535   023C 3D 17 18      mov [active_proc_index], al         ; set new active proc
0536   023F             ; calculate LUT entry for next process
0537   023F 22 00         mov ah, 0
0538   0241 FD 99         shl a                               ; x2
0539   0243 B7 66 10      mov a, [proc_table_convert + a]     ; get process state start index  
0540   0246 4D            mov si, a                           ; source is proc state block
0541   0247 48            mov a, sp
0542   0248 5F 13 00      sub a, 19
0543   024B 4F            mov di, a                           ; destination is kernel stack
0544   024C             ; restore SP
0545   024C 7D            dec a
0546   024D 47            mov sp, a
0547   024E 38 14 00      mov c, 20
0548   0251 FD F5         rep movsb
0549   0253             ; set VM process
0550   0253 1D 17 18      mov al, [active_proc_index]
0551   0256 01            setptb
0552   0257 4C            popa
0553   0258 06            sysret
0554   0259             
0555   0259             ;------------------------------------------------------------------------------------------------------;;
0556   0259             ; list processes
0557   0259             ;------------------------------------------------------------------------------------------------------;;
0558   0259             syscall_list_procs:
0559   0259 3B 4E 18      mov d, s_ps_header
0560   025C 07 E6 12      call _puts
0561   025F 3B DE 1C      mov d, proc_availab_table + 1
0562   0262 38 01 00      mov c, 1
0563   0265             list_procs_L0:  
0564   0265 BD 01         cmp byte[d], 1
0565   0267 C7 8B 02      jne list_procs_next
0566   026A 2D            mov b, d
0567   026B 61 DD 1C      sub b, proc_availab_table
0568   026E FD 9F 05      shl b, 5
0569   0271 DA            push d
0570   0272 D8            push b
0571   0273 28            mov b, c
0572   0274 07 86 13      call print_u8x
0573   0277 22 20         mov ah, ' '
0574   0279 07 BA 11      call _putchar
0575   027C 07 BA 11      call _putchar
0576   027F E5            pop b
0577   0280 74            mov d, b
0578   0281 58 ED 1C      add d, proc_names
0579   0284 07 E6 12      call _puts
0580   0287 07 93 12      call printnl
0581   028A E7            pop d
0582   028B             list_procs_next:
0583   028B 79            inc d
0584   028C 78            inc c
0585   028D C2 09 00      cmp c, 9
0586   0290 C7 65 02      jne list_procs_L0
0587   0293             list_procs_end:
0588   0293 06            sysret
0589   0294             
0590   0294             ; ------------------------------------------------------------------------------------------------------------------;
0591   0294             ; exceptions code block
0592   0294             ; ------------------------------------------------------------------------------------------------------------------;
0593   0294             ; privilege exception
0594   0294             ; ------------------------------------------------------------------------------------------------------------------;
0595   0294             trap_privilege:
0596   0294 0A 15 02      jmp syscall_reboot
0597   0297 DA            push d
0598   0298 3B 9D 18      mov d, s_priviledge
0599   029B 07 E6 12      call _puts
0600   029E E7            pop d
0601   029F 06            sysret
0602   02A0             
0603   02A0             ; ------------------------------------------------------------------------------------------------------------------;
0604   02A0             ; breakpoint
0605   02A0             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0606   02A0             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0607   02A0             ; ------------------------------------------------------------------------------------------------------------------;
0608   02A0             syscall_break:
0609   02A0 4B            pusha
0610   02A1             syscall_break_prompt:
0611   02A1 3B 5B 03      mov d, s_break1
0612   02A4 07 E6 12      call _puts
0613   02A7 07 93 12      call printnl
0614   02AA 07 E8 13      call scan_u16d
0615   02AD AF 00 00      cmp a, 0
0616   02B0 C6 BB 02      je syscall_break_regs
0617   02B3 AF 01 00      cmp a, 1
0618   02B6 C6 DE 02      je syscall_break_mem
0619   02B9             syscall_break_end:  
0620   02B9 4C            popa
0621   02BA 06            sysret
0622   02BB             syscall_break_regs:
0623   02BB 48            mov a, sp
0624   02BC 53 0E 00      add a, 14               ; back-track 7 registers
0625   02BF 3C            mov d, a
0626   02C0 3A 07         mov cl, 7
0627   02C2             syscall_regs_L0:
0628   02C2 2A            mov b, [d]
0629   02C3 FD AB         swp b
0630   02C5 07 42 13      call print_u16x         ; print register value
0631   02C8 07 93 12      call printnl
0632   02CB 63 02 00      sub d, 2
0633   02CE 71 01         sub cl, 1
0634   02D0 C3 00         cmp cl, 0
0635   02D2 C7 C2 02      jne syscall_regs_L0
0636   02D5 0A A1 02      jmp syscall_break_prompt
0637   02D8 07 93 12      call printnl
0638   02DB 0A A1 02      jmp syscall_break_prompt
0639   02DE             syscall_break_mem:
0640   02DE 07 93 12      call printnl
0641   02E1 07 64 13      call scan_u16x
0642   02E4 4D            mov si, a               ; data source from user space
0643   02E5 FD 4F 6D 25   mov di, scrap_sector    ; destination in kernel space
0644   02E9 38 00 02      mov c, 512
0645   02EC 04            load                    ; transfer data to kernel space!
0646   02ED 3B 6D 25      mov d, scrap_sector     ; dump pointer in d
0647   02F0 38 00 00      mov c, 0
0648   02F3             dump_loop:
0649   02F3 84            mov al, cl
0650   02F4 87 0F         and al, $0F
0651   02F6 C6 44 03      jz print_base
0652   02F9             back:
0653   02F9 1E            mov al, [d]             ; read byte
0654   02FA 2F            mov bl, al
0655   02FB 07 86 13      call print_u8x
0656   02FE 10 00 20      mov a, $2000
0657   0301 05 03         syscall sys_io          ; space
0658   0303 84            mov al, cl
0659   0304 87 0F         and al, $0F
0660   0306 B9 0F         cmp al, $0F
0661   0308 C6 19 03      je print_ascii
0662   030B             back1:
0663   030B 79            inc d
0664   030C 78            inc c
0665   030D C2 00 02      cmp c, 512
0666   0310 C7 F3 02      jne dump_loop
0667   0313 07 93 12      call printnl
0668   0316 0A A1 02      jmp syscall_break_prompt  ; go to syscall_break return point
0669   0319             print_ascii:
0670   0319 10 00 20      mov a, $2000
0671   031C 05 03         syscall sys_io
0672   031E 63 10 00      sub d, 16
0673   0321 26 10 00      mov b, 16
0674   0324             print_ascii_L:
0675   0324 79            inc d
0676   0325 1E            mov al, [d]               ; read byte
0677   0326 B9 20         cmp al, $20
0678   0328 C8 30 03      jlu dot
0679   032B B9 7E         cmp al, $7E
0680   032D D0 38 03      jleu ascii
0681   0330             dot:
0682   0330 10 00 2E      mov a, $2E00
0683   0333 05 03         syscall sys_io
0684   0335 0A 3D 03      jmp ascii_continue
0685   0338             ascii:
0686   0338 23            mov ah, al
0687   0339 19 00         mov al, 0
0688   033B 05 03         syscall sys_io
0689   033D             ascii_continue:
0690   033D FD A9 24 03   loopb print_ascii_L
0691   0341 0A 0B 03      jmp back1
0692   0344             print_base:
0693   0344 07 93 12      call printnl
0694   0347 2D            mov b, d
0695   0348 61 6D 25      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0696   034B 07 42 13      call print_u16x          ; display row
0697   034E 10 00 3A      mov a, $3A00
0698   0351 05 03         syscall sys_io
0699   0353 10 00 20      mov a, $2000
0700   0356 05 03         syscall sys_io
0701   0358 0A F9 02      jmp back
0702   035B             
0703   035B             s_break1:  
0704   035B 0A 44 65 62   .db "\nDebugger entry point.\n"
0704   035F 75 67 67 65 
0704   0363 72 20 65 6E 
0704   0367 74 72 79 20 
0704   036B 70 6F 69 6E 
0704   036F 74 2E 0A 
0705   0372 30 2E 20 53   .db "0. Show Registers\n"
0705   0376 68 6F 77 20 
0705   037A 52 65 67 69 
0705   037E 73 74 65 72 
0705   0382 73 0A 
0706   0384 31 2E 20 53   .db "1. Show 512B RAM block\n"
0706   0388 68 6F 77 20 
0706   038C 35 31 32 42 
0706   0390 20 52 41 4D 
0706   0394 20 62 6C 6F 
0706   0398 63 6B 0A 
0707   039B 32 2E 20 43   .db "2. Continue Execution", 0
0707   039F 6F 6E 74 69 
0707   03A3 6E 75 65 20 
0707   03A7 45 78 65 63 
0707   03AB 75 74 69 6F 
0707   03AF 6E 00 
0708   03B1             
0709   03B1             ; ------------------------------------------------------------------------------------------------------------------;
0710   03B1             ; divide by zero exception
0711   03B1             ; ------------------------------------------------------------------------------------------------------------------;
0712   03B1             trap_div_zero:
0713   03B1 D7            push a
0714   03B2 DA            push d
0715   03B3 E1            pushf
0716   03B4 3B B4 18      mov d, s_divzero
0717   03B7 07 E6 12      call _puts
0718   03BA EE            popf
0719   03BB E7            pop d
0720   03BC E4            pop a
0721   03BD 06            sysret ; enable interrupts
0722   03BE             
0723   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0724   03BE             ; undefined opcode exception
0725   03BE             ; ------------------------------------------------------------------------------------------------------------------;
0726   03BE             trap_undef_opcode:
0727   03BE 06            sysret
0728   03BF             
0729   03BF             ; ------------------------------------------------------------------------------------------------------------------;
0730   03BF             ; real-time clock services syscall
0731   03BF             ; RTC I/O bank = FFA0 to FFAF
0732   03BF             ; FFA0 to FFA7 is scratch RAM
0733   03BF             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0734   03BF             ; al = 0..6 -> get
0735   03BF             ; al = 7..D -> set
0736   03BF             ; ------------------------------------------------------------------------------------------------------------------;
0737   03BF             syscall_rtc:
0738   03BF DB            push al
0739   03C0 DA            push d
0740   03C1 B9 06         cmp al, 6
0741   03C3 D1 D8 03      jgu syscall_rtc_set
0742   03C6             syscall_rtc_get:
0743   03C6 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0744   03C8 22 FF         mov ah, $FF    
0745   03CA 3C            mov d, a                ; get to FFA9 + offset
0746   03CB F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0747   03CF 1E            mov al, [d]             ; get data
0748   03D0 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0749   03D4 23            mov ah, al
0750   03D5 E7            pop d
0751   03D6 E8            pop al
0752   03D7 06            sysret
0753   03D8             syscall_rtc_set:
0754   03D8 DD            push bl
0755   03D9 99            mov bl, ah              ; set data asIDE
0756   03DA 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0757   03DC 22 FF         mov ah, $FF    
0758   03DE 3C            mov d, a                ; get to FFA9 + offset
0759   03DF 1B            mov al, bl              ; get data back
0760   03E0 F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0761   03E4 3E            mov [d], al             ; set data
0762   03E5 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0763   03E9 EA            pop bl
0764   03EA E7            pop d
0765   03EB E8            pop al
0766   03EC 06            sysret
0767   03ED             
0768   03ED             datetime_serv_tbl:
0769   03ED F5 03         .dw print_date
0770   03EF 69 04         .dw set_date
0771   03F1             syscall_datetime:
0772   03F1 FD 0A ED 03   jmp [datetime_serv_tbl + al]      
0773   03F5             print_date:
0774   03F5 10 00 0D      mov a, $0D00           ; print carriage return char
0775   03F8 19 03         mov al, 3
0776   03FA 05 01         syscall sys_rtc        ; get week
0777   03FC 1A            mov al, ah
0778   03FD 22 00         mov ah, 0
0779   03FF FD 9D 02      shl a, 2          
0780   0402 3B 3E 19      mov d, s_week
0781   0405 59            add d, a
0782   0406 07 E6 12      call _puts
0783   0409 10 00 20      mov a, $2000
0784   040C 05 03         syscall sys_io         ; display ' '
0785   040E 19 04         mov al, 4
0786   0410 05 01         syscall sys_rtc        ; get day
0787   0412 99            mov bl, ah
0788   0413 07 86 13      call print_u8x
0789   0416 10 00 20      mov a, $2000
0790   0419 05 03         syscall sys_io         ; display ' '
0791   041B             ; there is a problem with the month displaying
0792   041B             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0793   041B             ; even though it is to be understood as BCD.
0794   041B             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0795   041B 19 05         mov al, 05
0796   041D 05 01         syscall sys_rtc        ; get month
0797   041F 1A            mov al, ah
0798   0420 22 00         mov ah, 0
0799   0422 FD 9D 02      shl a, 2          
0800   0425 3B 0A 19      mov d, s_months
0801   0428 59            add d, a
0802   0429 07 E6 12      call _puts
0803   042C 10 00 20      mov a, $2000
0804   042F 05 03         syscall sys_io         ; display ' '
0805   0431 2E 20         mov bl, $20
0806   0433 07 86 13      call print_u8x         ; print 20 for year prefix
0807   0436 19 06         mov al, 06
0808   0438 05 01         syscall sys_rtc        ; get year
0809   043A 99            mov bl, ah
0810   043B 07 86 13      call print_u8x
0811   043E 10 00 20      mov a, $2000  
0812   0441 05 03         syscall sys_io         ; display ' '
0813   0443 19 02         mov al, 2
0814   0445 05 01         syscall sys_rtc        ; get hours
0815   0447 99            mov bl, ah
0816   0448 07 86 13      call print_u8x
0817   044B 10 00 3A      mov a, $3A00    
0818   044E 05 03         syscall sys_io         ; display ':'
0819   0450 19 01         mov al, 01
0820   0452 05 01         syscall sys_rtc        ; get minutes
0821   0454 99            mov bl, ah
0822   0455 07 86 13      call print_u8x
0823   0458 10 00 3A      mov a, $3A00  
0824   045B 05 03         syscall sys_io         ; display ':'
0825   045D 19 00         mov al, 0
0826   045F 05 01         syscall sys_rtc        ; get seconds
0827   0461 99            mov bl, ah
0828   0462 07 86 13      call print_u8x
0829   0465 07 93 12      call printnl
0830   0468 06            sysret
0831   0469             set_date:
0832   0469 3B CF 18      mov d, s_set_year
0833   046C 07 E6 12      call _puts
0834   046F 07 D1 13      call scan_u8x          ; read integer into A
0835   0472 FD 9D 08      shl a, 8               ; only AL used, move to AH
0836   0475 19 0D         mov al, 0Dh            ; set RTC year
0837   0477 05 01         syscall sys_rtc        ; set RTC
0838   0479 3B D6 18      mov d, s_set_month
0839   047C 07 E6 12      call _puts
0840   047F 07 D1 13      call scan_u8x          ; read integer into A
0841   0482 FD 9D 08      shl a, 8               ; only AL used, move to AH
0842   0485 19 0C         mov al, 0Ch            ; set RTC month
0843   0487 05 01         syscall sys_rtc        ; set RTC
0844   0489 3B DE 18      mov d, s_set_day
0845   048C 07 E6 12      call _puts
0846   048F 07 D1 13      call scan_u8x          ; read integer into A
0847   0492 FD 9D 08      shl a, 8               ; only AL used, move to AH
0848   0495 19 0B         mov al, 0Bh            ; set RTC month
0849   0497 05 01         syscall sys_rtc        ; set RTC
0850   0499 3B E4 18      mov d, s_set_week
0851   049C 07 E6 12      call _puts
0852   049F 07 D1 13      call scan_u8x          ; read integer into A
0853   04A2 FD 9D 08      shl a, 8               ; only AL used, move to AH
0854   04A5 19 0A         mov al, 0Ah            ; set RTC month
0855   04A7 05 01         syscall sys_rtc        ; set RTC
0856   04A9 3B EE 18      mov d, s_set_hours
0857   04AC 07 E6 12      call _puts
0858   04AF 07 D1 13      call scan_u8x          ; read integer into A
0859   04B2 FD 9D 08      shl a, 8               ; only AL used, move to AH
0860   04B5 19 09         mov al, 09h            ; set RTC month
0861   04B7 05 01         syscall sys_rtc        ; set RTC
0862   04B9 3B F6 18      mov d, s_set_minutes
0863   04BC 07 E6 12      call _puts
0864   04BF 07 D1 13      call scan_u8x          ; read integer into A
0865   04C2 FD 9D 08      shl a, 8               ; only AL used, move to AH
0866   04C5 19 08         mov al, 08h            ; set RTC month
0867   04C7 05 01         syscall sys_rtc        ; set RTC
0868   04C9 3B 00 19      mov d, s_set_seconds
0869   04CC 07 E6 12      call _puts
0870   04CF 07 D1 13      call scan_u8x          ; read integer into A
0871   04D2 FD 9D 08      shl a, 8               ; only AL used, move to AH
0872   04D5 19 07         mov al, 07h            ; set RTC month
0873   04D7 05 01         syscall sys_rtc        ; set RTC
0874   04D9 06            sysret
0875   04DA             
0876   04DA             ; ------------------------------------------------------------------------------------------------------------------;
0877   04DA             ; IDE Services Syscall
0878   04DA             ; al = option
0879   04DA             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0880   04DA             ; IDE read/write sector
0881   04DA             ; 512 bytes
0882   04DA             ; User buffer pointer in D
0883   04DA             ; AH = number of sectors
0884   04DA             ; CB = LBA bytes 3..0
0885   04DA             ; ------------------------------------------------------------------------------------------------------------------;
0886   04DA 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0886   04DE 73 63 61 6C 
0886   04E2 6C 5F 69 64 
0886   04E6 65 20 63 61 
0886   04EA 6C 6C 65 64 
0886   04EE 3A 20 00 
0887   04F1             ide_serv_tbl:
0888   04F1 18 05         .dw ide_reset
0889   04F3 2C 05         .dw ide_sleep
0890   04F5 3B 05         .dw ide_read_sect_wrapper
0891   04F7 3F 05         .dw ide_write_sect_wrapper
0892   04F9             syscall_ide:
0893   04F9 DD            push bl
0894   04FA 31 0F 18      mov bl, [sys_debug_mode]
0895   04FD               ; debug block
0896   04FD C1 00         cmp bl, 0
0897   04FF EA            pop bl
0898   0500 C6 14 05      je syscall_ide_jmp
0899   0503 DA            push d
0900   0504 DD            push bl
0901   0505 3B DA 04      mov d, s_syscall_ide_dbg0
0902   0508 07 E6 12      call _puts
0903   050B 2F            mov bl, al
0904   050C 07 86 13      call print_u8x
0905   050F 07 93 12      call printnl
0906   0512 EA            pop bl
0907   0513 E7            pop d
0908   0514             syscall_ide_jmp:
0909   0514 FD 0A F1 04   jmp [ide_serv_tbl + al]    
0910   0518               
0911   0518             ide_reset:      
0912   0518 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0913   051C 07 C5 05      call ide_wait                   ; wait for IDE ready             
0914   051F F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0915   0523 F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0916   0527 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0917   052B 06            sysret
0918   052C             ide_sleep:
0919   052C 07 C5 05      call ide_wait                   ; wait for IDE ready             
0920   052F F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0921   0533 F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0922   0537 07 C5 05      call ide_wait                   ; wait for IDE ready
0923   053A 06            sysret
0924   053B             ide_read_sect_wrapper:
0925   053B 07 43 05      call ide_read_sect
0926   053E 06            sysret
0927   053F             ide_write_sect_wrapper:
0928   053F 07 69 05      call ide_write_sect
0929   0542 06            sysret
0930   0543             ide_read_sect:
0931   0543 1A            mov al, ah
0932   0544 24            mov ah, bl
0933   0545 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0934   0548 1C            mov al, bh
0935   0549 3D D4 FF      mov [_ide_R4], al
0936   054C 12            mov a, c
0937   054D 3D D5 FF      mov [_ide_R5], al
0938   0550 1A            mov al, ah
0939   0551 87 0F         and al, %00001111
0940   0553 8B E0         or al, %11100000                ; mode lba, master
0941   0555 3D D6 FF      mov [_ide_R6], al
0942   0558             ide_read_sect_wait:
0943   0558 1D D7 FF      mov al, [_ide_R7]  
0944   055B 87 80         and al, $80                     ; BUSY FLAG
0945   055D C7 58 05      jnz ide_read_sect_wait
0946   0560 19 20         mov al, $20
0947   0562 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0948   0565 07 8F 05      call ide_read  
0949   0568 09            ret
0950   0569             ide_write_sect:
0951   0569 1A            mov al, ah
0952   056A 24            mov ah, bl
0953   056B 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0954   056E 1C            mov al, bh
0955   056F 3D D4 FF      mov [_ide_R4], al
0956   0572 12            mov a, c
0957   0573 3D D5 FF      mov [_ide_R5], al
0958   0576 1A            mov al, ah
0959   0577 87 0F         and al, %00001111
0960   0579 8B E0         or al, %11100000                ; mode lba, master
0961   057B 3D D6 FF      mov [_ide_R6], al
0962   057E             ide_write_sect_wait:
0963   057E 1D D7 FF      mov al, [_ide_R7]  
0964   0581 87 80         and al, $80                     ; BUSY FLAG
0965   0583 C7 7E 05      jnz ide_write_sect_wait
0966   0586 19 30         mov al, $30
0967   0588 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0968   058B 07 AA 05      call ide_write      
0969   058E 09            ret
0970   058F             
0971   058F             ;----------------------------------------------------------------------------------------------------;
0972   058F             ; READ IDE DATA
0973   058F             ; pointer in D
0974   058F             ;----------------------------------------------------------------------------------------------------;
0975   058F             ide_read:
0976   058F DA            push d
0977   0590             ide_read_loop:
0978   0590 1D D7 FF      mov al, [_ide_R7]  
0979   0593 87 80         and al, 80h                     ; BUSY FLAG
0980   0595 C7 90 05      jnz ide_read_loop               ; wait loop
0981   0598 1D D7 FF      mov al, [_ide_R7]
0982   059B 87 08         and al, %00001000               ; DRQ FLAG
0983   059D C6 A8 05      jz ide_read_end
0984   05A0 1D D0 FF      mov al, [_ide_R0]
0985   05A3 3E            mov [d], al
0986   05A4 79            inc d
0987   05A5 0A 90 05      jmp ide_read_loop
0988   05A8             ide_read_end:
0989   05A8 E7            pop d
0990   05A9 09            ret
0991   05AA             
0992   05AA             ;----------------------------------------------------------------------------------------------------;
0993   05AA             ; WRITE IDE DATA
0994   05AA             ; data pointer in D
0995   05AA             ;----------------------------------------------------------------------------------------------------;
0996   05AA             ide_write:
0997   05AA DA            push d
0998   05AB             ide_write_loop:
0999   05AB 1D D7 FF      mov al, [_ide_R7]  
1000   05AE 87 80         and al, 80h             ; BUSY FLAG
1001   05B0 C7 AB 05      jnz ide_write_loop      ; wait loop
1002   05B3 1D D7 FF      mov al, [_ide_R7]
1003   05B6 87 08         and al, %00001000       ; DRQ FLAG
1004   05B8 C6 C3 05      jz ide_write_end
1005   05BB 1E            mov al, [d]
1006   05BC 3D D0 FF      mov [_ide_R0], al
1007   05BF 79            inc d 
1008   05C0 0A AB 05      jmp ide_write_loop
1009   05C3             ide_write_end:
1010   05C3 E7            pop d
1011   05C4 09            ret
1012   05C5             
1013   05C5             ;----------------------------------------------------------------------------------------------------;
1014   05C5             ; wait for IDE to be ready
1015   05C5             ;----------------------------------------------------------------------------------------------------;
1016   05C5             ide_wait:
1017   05C5 1D D7 FF      mov al, [_ide_R7]  
1018   05C8 87 80         and al, 80h        ; BUSY FLAG
1019   05CA C7 C5 05      jnz ide_wait
1020   05CD 09            ret
1021   05CE             
1022   05CE             ;----------------------------------------------------------------------------------------------------;
1023   05CE             ; IO Syscall
1024   05CE             ;----------------------------------------------------------------------------------------------------;
1025   05CE             ; Baud  Divisor
1026   05CE             ; 50    2304
1027   05CE             ; 110   1047
1028   05CE             ; 300    384
1029   05CE             ; 600    192
1030   05CE             ; 1200    96
1031   05CE             ; 9600    12
1032   05CE             ; 19200    6
1033   05CE             ; 38400    3
1034   05CE             syscall_io_jmp:
1035   05CE 01 06         .dw syscall_io_putchar
1036   05D0 0E 06         .dw syscall_io_getch
1037   05D2 D8 05         .dw syscall_io_uart_setup
1038   05D4             syscall_io:
1039   05D4 FD 0A CE 05   jmp [syscall_io_jmp + al]
1040   05D8             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
1041   05D8             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
1042   05D8             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
1043   05D8             syscall_io_uart_setup:
1044   05D8 1D 11 18      mov al, [sys_uart0_lcr]
1045   05DB 8B 80         or al, $80                ; set DLAB access bit
1046   05DD 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
1047   05E0 1D 14 18      mov al, [sys_uart0_div0]
1048   05E3 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
1049   05E6 1D 15 18      mov al, [sys_uart0_div1]
1050   05E9 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
1051   05EC             
1052   05EC 1D 11 18      mov al, [sys_uart0_lcr]
1053   05EF 87 7F         and al, $7F               ; clear DLAB access bit 
1054   05F1 3D 83 FF      mov [_UART0_LCR], al
1055   05F4 1D 12 18      mov al, [sys_uart0_inten]
1056   05F7 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1057   05FA 1D 13 18      mov al, [sys_uart0_fifoen]
1058   05FD 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1059   0600 06            sysret
1060   0601             
1061   0601             ; char in ah
1062   0601             syscall_io_putchar:
1063   0601             syscall_io_putchar_L0:
1064   0601 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1065   0604 87 20         and al, $20
1066   0606 C6 01 06      jz syscall_io_putchar_L0    
1067   0609 1A            mov al, ah
1068   060A 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1069   060D 06            sysret
1070   060E             
1071   060E             ; char in ah
1072   060E             ; al = sucess code
1073   060E             syscall_io_getch:
1074   060E D8            push b
1075   060F DA            push d
1076   0610 FD 0C         sti
1077   0612             syscall_io_getch_L0:  
1078   0612 14 1E 18      mov a, [fifo_out]
1079   0615 29 1C 18      mov b, [fifo_in]
1080   0618 B0            cmp a, b
1081   0619 C6 12 06      je syscall_io_getch_L0
1082   061C 3C            mov d, a
1083   061D 77            inc a
1084   061E AF 6D 25      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1085   0621 C7 27 06      jne syscall_io_getch_cont
1086   0624 10 6D 21      mov a, fifo  
1087   0627             syscall_io_getch_cont:  
1088   0627 42 1E 18      mov [fifo_out], a             ; update fifo pointer
1089   062A 1E            mov al, [d]                   ; get char
1090   062B 23            mov ah, al
1091   062C 1D 10 18      mov al, [sys_echo_on]
1092   062F B9 01         cmp al, 1
1093   0631 C7 40 06      jne syscall_io_getch_noecho 
1094   0634             ; here we just echo the char back to the console
1095   0634             syscall_io_getch_echo_L0:
1096   0634 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1097   0637 87 20         and al, $20                 ; isolate Transmitter Empty
1098   0639 C6 34 06      jz syscall_io_getch_echo_L0
1099   063C 1A            mov al, ah
1100   063D 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1101   0640             syscall_io_getch_noecho:
1102   0640 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1103   0642 E7            pop d
1104   0643 E5            pop b
1105   0644 06            sysret
1106   0645             
1107   0645             ;------------------------------------------------------------------------------------------------------;
1108   0645             ; FILE SYSTEM DATA
1109   0645             ;------------------------------------------------------------------------------------------------------;
1110   0645             ; infor for : IDE SERVICES INTERRUPT
1111   0645             ; IDE read/write 512-byte sector
1112   0645             ; al = option
1113   0645             ; user buffer pointer in D
1114   0645             ; AH = number of sectors
1115   0645             ; CB = LBA bytes 3..0  
1116   0645             ;------------------------------------------------------------------------------------------------------;
1117   0645             ; FILE SYSTEM DATA STRUCTURE
1118   0645             ;------------------------------------------------------------------------------------------------------;
1119   0645             ; for a directory we have the header first, followed by metadata
1120   0645             ; header 1 sector (512 bytes)
1121   0645             ; metadata 1 sector (512 bytes)
1122   0645             ; HEADER ENTRIES:
1123   0645             ; filename (64)
1124   0645             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1125   0645             ;
1126   0645             ; metadata entries:
1127   0645             ; filename (24)
1128   0645             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1129   0645             ; LBA (2)
1130   0645             ; size (2)
1131   0645             ; day (1)
1132   0645             ; month (1)
1133   0645             ; year (1)
1134   0645             ; packet size = 32 bytes
1135   0645             ;
1136   0645             ; first directory on disk is the root directory '/'
1137   0645             file_system_jmptbl:
1138   0645 B0 06         .dw fs_mkfs                   ; 0
1139   0647 00 00         .dw 0                         ; 1
1140   0649 12 07         .dw fs_mkdir                  ; 2
1141   064B 8B 0A         .dw fs_cd                     ; 3
1142   064D 92 0A         .dw fs_ls                     ; 4
1143   064F 08 0C         .dw fs_mktxt                  ; 5
1144   0651 D3 0C         .dw fs_mkbin                  ; 6
1145   0653 9A 0D         .dw fs_pwd                    ; 7
1146   0655 B7 0D         .dw fs_cat                    ; 8
1147   0657 13 0E         .dw fs_rmdir                  ; 9
1148   0659 6F 0E         .dw fs_rm                     ; 10
1149   065B 63 0B         .dw fs_starcom                ; 11
1150   065D 00 00         .dw 0                         ; 12
1151   065F 00 00         .dw 0                         ; 13
1152   0661 B8 06         .dw fs_chmod                  ; 14
1153   0663 D7 0E         .dw fs_mv                     ; 15
1154   0665 B1 06         .dw fs_cd_root                ; 16
1155   0667 87 0A         .dw fs_get_curr_dirID         ; 17
1156   0669 63 08         .dw fs_dir_id_to_path         ; 18
1157   066B C9 08         .dw fs_path_to_dir_id_user    ; 19
1158   066D E3 09         .dw fs_load_from_path_user    ; 20  
1159   066F 53 09         .dw fs_filepath_exists_user   ; 21
1160   0671             
1161   0671 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1161   0675 79 73 63 61 
1161   0679 6C 6C 5F 66 
1161   067D 69 6C 65 5F 
1161   0681 73 79 73 74 
1161   0685 65 6D 20 63 
1161   0689 61 6C 6C 65 
1161   068D 64 3A 20 00 
1162   0691             syscall_file_system:
1163   0691 DD            push bl
1164   0692 31 0F 18      mov bl, [sys_debug_mode]
1165   0695               ; debug block
1166   0695 C1 00         cmp bl, 0
1167   0697 EA            pop bl
1168   0698 C6 AC 06      je syscall_filesystem_jmp
1169   069B DA            push d
1170   069C DD            push bl
1171   069D 3B 71 06      mov d, s_syscall_fs_dbg0
1172   06A0 07 E6 12      call _puts
1173   06A3 2F            mov bl, al
1174   06A4 07 86 13      call print_u8x
1175   06A7 07 93 12      call printnl
1176   06AA EA            pop bl
1177   06AB E7            pop d
1178   06AC             syscall_filesystem_jmp:
1179   06AC FD 0A 45 06   jmp [file_system_jmptbl + al]
1180   06B0             
1181   06B0             fs_mkfs:  
1182   06B0 06            sysret  
1183   06B1               
1184   06B1             fs_cd_root:
1185   06B1 10 20 00      mov a, root_id
1186   06B4 42 20 18      mov [current_dir_id], a      ; set current directory LBA to ROOT
1187   06B7 06            sysret  
1188   06B8             
1189   06B8             ; filename in D (userspace data)
1190   06B8             ; permission in BL
1191   06B8             fs_chmod:
1192   06B8 DD            push bl
1193   06B9 FD 4E         mov si, d
1194   06BB FD 4F 6D 1F   mov di, user_data
1195   06BF 38 80 00      mov c, 128
1196   06C2 04            load                        ; load filename from user-space
1197   06C3 14 20 18      mov a, [current_dir_id]
1198   06C6 77            inc a                       ; metadata sector
1199   06C7 27            mov b, a
1200   06C8 38 00 00      mov c, 0                    ; upper LBA = 0
1201   06CB 22 01         mov ah, $01                  ; 1 sector
1202   06CD 3B 6D 27      mov d, transient_area
1203   06D0 07 43 05      call ide_read_sect          ; read directory
1204   06D3 FD 10         cla
1205   06D5 42 18 18      mov [index], a              ; reset file counter
1206   06D8             fs_chmod_L1:
1207   06D8 FD 4E         mov si, d
1208   06DA FD 4F 6D 1F   mov di, user_data
1209   06DE 07 29 11      call _strcmp
1210   06E1 C6 F8 06      je fs_chmod_found_entry
1211   06E4 58 20 00      add d, 32
1212   06E7 14 18 18      mov a, [index]
1213   06EA 77            inc a
1214   06EB 42 18 18      mov [index], a
1215   06EE AF 10 00      cmp a, FST_FILES_PER_DIR
1216   06F1 C7 D8 06      jne fs_chmod_L1
1217   06F4 EA            pop bl
1218   06F5 0A 11 07      jmp fs_chmod_not_found
1219   06F8             fs_chmod_found_entry:  
1220   06F8 FD 79         mov g, b                    ; save LBA
1221   06FA EA            pop bl                      ; retrieve saved permission value
1222   06FB 1F 18 00      mov al, [d + 24]            ; read file permissions
1223   06FE 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1224   0700 8C            or al, bl                   ; set new permissions
1225   0701 3F 18 00      mov [d + 24], al            ; write new permissions
1226   0704 38 00 00      mov c, 0
1227   0707 3B 6D 27      mov d, transient_area
1228   070A 22 01         mov ah, $01                 ; disk write 1 sect
1229   070C FD 27         mov b, g                    ; retrieve LBA
1230   070E 07 69 05      call ide_write_sect         ; write sector
1231   0711             fs_chmod_not_found:
1232   0711 06            sysret
1233   0712             
1234   0712             ;------------------------------------------------------------------------------------------------------;
1235   0712             ; CREATE NEW DIRECTORY
1236   0712             ;------------------------------------------------------------------------------------------------------;
1237   0712             ; search list for NULL name entry. add new directory to list
1238   0712             fs_mkdir:
1239   0712 FD 4E         mov si, d
1240   0714 FD 4F 6D 1F   mov di, user_data
1241   0718 38 00 02      mov c, 512
1242   071B 04            load                        ; load data from user-space
1243   071C 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1244   071F                                           ; when checking for NULL name, since root has a NULL name)
1245   071F 38 00 00      mov c, 0                    ; upper LBA = 0
1246   0722             fs_mkdir_L1:  
1247   0722 22 01         mov ah, $01                  ; 1 sector
1248   0724 3B 6D 27      mov d, transient_area
1249   0727 07 43 05      call ide_read_sect          ; read sector
1250   072A BD 00         cmp byte[d], 0              ; check for NULL
1251   072C C6 35 07      je fs_mkdir_found_null
1252   072F 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1253   0732 0A 22 07      jmp fs_mkdir_L1
1254   0735             fs_mkdir_found_null:
1255   0735             ;create header file by grabbing dir name from parameter
1256   0735 D8            push b                      ; save new directory's LBA
1257   0736 38 40 00      mov c, 64
1258   0739 FD 4D 6D 1F   mov si, user_data
1259   073D FD 4F 6D 27   mov di, transient_area
1260   0741 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1261   0743 14 20 18      mov a, [current_dir_id]
1262   0746 42 AD 27      mov [transient_area + 64], a    ; store parent directory LBA
1263   0749 19 00         mov al, 0
1264   074B FD 4F 6D 29   mov di, transient_area + 512
1265   074F 38 00 02      mov c, 512
1266   0752 FD F7         rep stosb                       ; clean buffer
1267   0754 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1268   0757             ; write directory entry sectors
1269   0757 3B 6D 27      mov d, transient_area
1270   075A 22 02         mov ah, $02                     ; disk write, 2 sectors
1271   075C 07 69 05      call ide_write_sect             ; write sector
1272   075F             ; now we need to add the new directory to the list, insIDE the current directory
1273   075F 14 20 18      mov a, [current_dir_id]
1274   0762 53 01 00      add a, 1
1275   0765 27            mov b, a                        ; metadata sector
1276   0766 38 00 00      mov c, 0
1277   0769 FD 79         mov g, b                        ; save LBA
1278   076B 3B 6D 27      mov d, transient_area
1279   076E 22 01         mov ah, $01                  ; 1 sector
1280   0770 07 43 05      call ide_read_sect              ; read metadata sector
1281   0773             fs_mkdir_L2:
1282   0773 BD 00         cmp byte[d], 0
1283   0775 C6 7E 07      je fs_mkdir_found_null2
1284   0778 58 20 00      add d, FST_ENTRY_SIZE
1285   077B 0A 73 07      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1286   077E             fs_mkdir_found_null2:
1287   077E FD 4D 6D 1F   mov si, user_data
1288   0782 FD 50         mov di, d
1289   0784 07 3E 11      call _strcpy                    ; copy directory name
1290   0787 58 18 00      add d, 24                       ; goto ATTRIBUTES
1291   078A 19 0B         mov al, %00001011               ; directory, no execute, write, read
1292   078C 3E            mov [d], al      
1293   078D 79            inc d
1294   078E E5            pop b
1295   078F D8            push b                          ; push LBA back
1296   0790 FD 43         mov [d], b                      ; save LBA
1297   0792             ; set file creation date  
1298   0792 58 04 00      add d, 4
1299   0795 19 04         mov al, 4
1300   0797 05 01         syscall sys_rtc
1301   0799 1A            mov al, ah
1302   079A 3E            mov [d], al                     ; set day
1303   079B 79            inc d
1304   079C 19 05         mov al, 5
1305   079E 05 01         syscall sys_rtc
1306   07A0 1A            mov al, ah
1307   07A1 3E            mov [d], al                     ; set month
1308   07A2 79            inc d
1309   07A3 19 06         mov al, 6
1310   07A5 05 01         syscall sys_rtc
1311   07A7 1A            mov al, ah
1312   07A8 3E            mov [d], al                     ; set year
1313   07A9             ; write sector into disk for new directory entry
1314   07A9 FD 27         mov b, g
1315   07AB 38 00 00      mov c, 0
1316   07AE 3B 6D 27      mov d, transient_area
1317   07B1 22 01         mov ah, $01                     ; disk write, 1 sector
1318   07B3 07 69 05      call ide_write_sect             ; write sector
1319   07B6             
1320   07B6             ; after adding the new directory's information to its parent directory's list
1321   07B6             ; we need to now enter the new directory, and to it add two new directories!
1322   07B6             ; which directories do we need to add ? '..' and '.' are the directories needed.
1323   07B6             ; importantly, note that these two new directories are only entries in the list
1324   07B6             ; and do not have actual physical entries in the disk as real directories.
1325   07B6             ; i.e. they only exist as list entries in the new directory created so that
1326   07B6             ; the new directory can reference its parent and itself.
1327   07B6             ; We need to add both '..' and '.'
1328   07B6             ; this first section is for '..' and on the section below we do the same for '.'
1329   07B6 E4            pop a                         ; retrieve the new directory's LBA  
1330   07B7 D7            push a                        ; and save again
1331   07B8 53 01 00      add a, 1
1332   07BB 27            mov b, a                      ; metadata sector
1333   07BC 38 00 00      mov c, 0
1334   07BF FD 79         mov g, b                      ; save LBA
1335   07C1 3B 6D 27      mov d, transient_area
1336   07C4 22 01         mov ah, $01                  ; 1 sector
1337   07C6 07 43 05      call ide_read_sect            ; read metadata sector
1338   07C9             fs_mkdir_L3:
1339   07C9 BD 00         cmp byte[d], 0
1340   07CB C6 D4 07      je fs_mkdir_found_null3
1341   07CE 58 20 00      add d, FST_ENTRY_SIZE
1342   07D1 0A C9 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1343   07D4             fs_mkdir_found_null3:
1344   07D4 FD 4D 3F 18   mov si, s_parent_dir
1345   07D8 FD 50         mov di, d
1346   07DA 07 3E 11      call _strcpy                  ; copy directory name
1347   07DD 58 18 00      add d, 24                     ; goto ATTRIBUTES
1348   07E0 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1349   07E2 3E            mov [d], al      
1350   07E3 79            inc d
1351   07E4 29 20 18      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1352   07E7 FD 43         mov [d], b                    ; save LBA
1353   07E9             ; set file creation date  
1354   07E9 58 04 00      add d, 4
1355   07EC 19 04         mov al, 4
1356   07EE 05 01         syscall sys_rtc
1357   07F0 1A            mov al, ah
1358   07F1 3E            mov [d], al                   ; set day
1359   07F2 79            inc d
1360   07F3 19 05         mov al, 5
1361   07F5 05 01         syscall sys_rtc
1362   07F7 1A            mov al, ah
1363   07F8 3E            mov [d], al                   ; set month
1364   07F9 79            inc d
1365   07FA 19 06         mov al, 6
1366   07FC 05 01         syscall sys_rtc
1367   07FE 1A            mov al, ah
1368   07FF 3E            mov [d], al                   ; set year
1369   0800             ; write sector into disk for new directory entry
1370   0800 FD 27         mov b, g
1371   0802 38 00 00      mov c, 0
1372   0805 3B 6D 27      mov d, transient_area
1373   0808 22 01         mov ah, $01                   ; disk write, 1 sector
1374   080A 07 69 05      call ide_write_sect           ; write sector
1375   080D             ;;;;;;;;;;;;;
1376   080D             ; like we did above for '..', we need to now add the '.' directory to the list.
1377   080D             ;------------------------------------------------------------------------------------------------------;
1378   080D E4            pop a                         ; retrieve the new directory's LBA  
1379   080E D7            push a
1380   080F 53 01 00      add a, 1
1381   0812 27            mov b, a                      ; metadata sector
1382   0813 38 00 00      mov c, 0
1383   0816 FD 79         mov g, b                      ; save LBA
1384   0818 3B 6D 27      mov d, transient_area
1385   081B 22 01         mov ah, $01                  ; 1 sector
1386   081D 07 43 05      call ide_read_sect            ; read metadata sector
1387   0820             fs_mkdir_L4:
1388   0820 BD 00         cmp byte[d], 0
1389   0822 C6 2B 08      je fs_mkdir_found_null4
1390   0825 58 20 00      add d, FST_ENTRY_SIZE
1391   0828 0A 20 08      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1392   082B             fs_mkdir_found_null4:
1393   082B FD 4D 42 18   mov si, s_current_dir
1394   082F FD 50         mov di, d
1395   0831 07 3E 11      call _strcpy                  ; copy directory name
1396   0834 58 18 00      add d, 24                     ; goto ATTRIBUTES
1397   0837 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1398   0839 3E            mov [d], al      
1399   083A 79            inc d
1400   083B E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1401   083C FD 43         mov [d], b                    ; save LBA
1402   083E             ; set file creation date  
1403   083E 58 04 00      add d, 4
1404   0841 19 04         mov al, 4
1405   0843 05 01         syscall sys_rtc
1406   0845 1A            mov al, ah
1407   0846 3E            mov [d], al                   ; set day
1408   0847 79            inc d
1409   0848 19 05         mov al, 5
1410   084A 05 01         syscall sys_rtc
1411   084C 1A            mov al, ah
1412   084D 3E            mov [d], al                   ; set month
1413   084E 79            inc d
1414   084F 19 06         mov al, 6
1415   0851 05 01         syscall sys_rtc
1416   0853 1A            mov al, ah
1417   0854 3E            mov [d], al                   ; set year
1418   0855             ; write sector into disk for new directory entry
1419   0855 FD 27         mov b, g
1420   0857 38 00 00      mov c, 0
1421   085A 3B 6D 27      mov d, transient_area
1422   085D 22 01         mov ah, $01                   ; disk write, 1 sector
1423   085F 07 69 05      call ide_write_sect           ; write sector
1424   0862             fs_mkdir_end:
1425   0862 06            sysret
1426   0863             
1427   0863             ;------------------------------------------------------------------------------------------------------;
1428   0863             ; get path from a given directory dirID
1429   0863             ; pseudo code:
1430   0863             ;  fs_dir_id_to_path(int dirID, char *D){
1431   0863             ;    if(dirID == 0){
1432   0863             ;      reverse path in D;
1433   0863             ;      return;
1434   0863             ;    }
1435   0863             ;    else{
1436   0863             ;      copy directory name to end of D;
1437   0863             ;      add '/' to end of D;
1438   0863             ;      parentID = get parent directory ID;
1439   0863             ;      fs_dir_id_to_path(parentID, D);
1440   0863             ;    }
1441   0863             ;  }
1442   0863             ; A = dirID
1443   0863             ; D = generated path string pointer
1444   0863             ;------------------------------------------------------------------------------------------------------;
1445   0863             ; sample path: /usr/bin
1446   0863             fs_dir_id_to_path:
1447   0863 3B ED 1E      mov d, filename
1448   0866 19 00         mov al, 0
1449   0868 3E            mov [d], al                     ; initialize path string 
1450   0869 14 20 18      mov a, [current_dir_id]
1451   086C 07 79 08      call fs_dir_id_to_path_E0
1452   086F 3B ED 1E      mov d, filename
1453   0872 07 D2 10      call _strrev
1454   0875 07 E6 12      call _puts
1455   0878 06            sysret
1456   0879             fs_dir_id_to_path_E0:
1457   0879 07 98 08      call get_dirname_from_dirID
1458   087C FD 4D 44 18   mov si, s_fslash
1459   0880 FD 50         mov di, d
1460   0882 07 4C 11      call _strcat                    ; add '/' to end of path
1461   0885 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1462   0888 C6 97 08      je fs_dir_id_to_path_root
1463   088B 07 B5 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1464   088E AF 20 00      cmp a, root_id               ; check if we are at the root directory
1465   0891 C6 97 08      je fs_dir_id_to_path_root
1466   0894 07 79 08      call fs_dir_id_to_path_E0     ; recursively call itself
1467   0897             fs_dir_id_to_path_root:
1468   0897 09            ret
1469   0898             
1470   0898             ;------------------------------------------------------------------------------------------------------;
1471   0898             ; in_puts:
1472   0898             ; A = directory ID
1473   0898             ; out_puts:
1474   0898             ; D = pointer to directory name string
1475   0898             ;------------------------------------------------------------------------------------------------------;
1476   0898             get_dirname_from_dirID:
1477   0898 D7            push a
1478   0899 D8            push b
1479   089A DA            push d
1480   089B 27            mov b, a
1481   089C 38 00 00      mov c, 0                      ; upper LBA = 0
1482   089F 22 01         mov ah, $01                  ; 1 sector
1483   08A1 3B 6D 25      mov d, transient_area - 512
1484   08A4 07 43 05      call ide_read_sect            ; read directory
1485   08A7 07 D2 10      call _strrev                  ; reverse dir name before copying
1486   08AA FD 4E         mov si, d
1487   08AC E7            pop d                         ; destination address = D value pushed at beginning
1488   08AD FD 50         mov di, d
1489   08AF 07 4C 11      call _strcat                  ; copy filename to D
1490   08B2 E5            pop b
1491   08B3 E4            pop a
1492   08B4 09            ret
1493   08B5             
1494   08B5             ;------------------------------------------------------------------------------------------------------;
1495   08B5             ; in_puts:
1496   08B5             ; A = directory ID
1497   08B5             ; out_puts:
1498   08B5             ; A = parent directory ID
1499   08B5             ;------------------------------------------------------------------------------------------------------;
1500   08B5             get_parentID_from_dirID:
1501   08B5 D8            push b
1502   08B6 DA            push d
1503   08B7 27            mov b, a
1504   08B8 38 00 00      mov c, 0                      ; upper LBA = 0
1505   08BB 22 01         mov ah, $01                  ; 1 sector
1506   08BD 3B 6D 25      mov d, transient_area - 512
1507   08C0 07 43 05      call ide_read_sect            ; read directory
1508   08C3 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1509   08C6 E7            pop d
1510   08C7 E5            pop b
1511   08C8 09            ret
1512   08C9             
1513   08C9             ;------------------------------------------------------------------------------------------------------;
1514   08C9             ; get dirID from a given path string
1515   08C9             ; in_puts:
1516   08C9             ; D = path pointer 
1517   08C9             ; out_puts:
1518   08C9             ; A = dirID
1519   08C9             ; if dir non existent, A = FFFF (fail code)
1520   08C9             ; /usr/local/bin    - absolute
1521   08C9             ; local/bin/games    - relative
1522   08C9             ;------------------------------------------------------------------------------------------------------;
1523   08C9             fs_path_to_dir_id_user:
1524   08C9 FD 4E         mov si, d
1525   08CB FD 4F 6D 1F   mov di, user_data
1526   08CF 38 00 02      mov c, 512
1527   08D2 04            load
1528   08D3 07 D7 08      call get_dirID_from_path
1529   08D6 06            sysret
1530   08D7             get_dirID_from_path:
1531   08D7 26 6D 1F      mov b, user_data
1532   08DA FD 42 0B 17   mov [prog], b                  ; token pointer set to path string
1533   08DE 07 6C 15      call get_token
1534   08E1 31 0E 17      mov bl, [tok]
1535   08E4 C1 01         cmp bl, TOK_FSLASH
1536   08E6 C6 F2 08      je get_dirID_from_path_abs 
1537   08E9 14 20 18      mov a, [current_dir_id]
1538   08EC 07 F2 16      call _putback
1539   08EF 0A F5 08      jmp get_dirID_from_path_E0
1540   08F2             get_dirID_from_path_abs:
1541   08F2 10 20 00      mov a, root_id
1542   08F5             get_dirID_from_path_E0:
1543   08F5 07 6C 15      call get_token
1544   08F8 31 0D 17      mov bl, [toktyp]
1545   08FB C1 00         cmp bl, TOKTYP_IDENTIFIER
1546   08FD C7 4E 09      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1547   0900             
1548   0900 FD 4D 0F 17   mov si, tokstr
1549   0904 FD 4F ED 1E   mov di, filename
1550   0908 07 3E 11      call _strcpy        
1551   090B 77            inc a                         ; metadata sector
1552   090C 27            mov b, a
1553   090D 38 00 00      mov c, 0                      ; upper LBA = 0
1554   0910 22 01         mov ah, $01                  ; 1 sector
1555   0912 3B 6D 27      mov d, transient_area
1556   0915 07 43 05      call ide_read_sect            ; read directory
1557   0918 FD 10         cla
1558   091A 42 18 18      mov [index], a
1559   091D             get_dirID_from_path_L1:
1560   091D FD 4E         mov si, d
1561   091F FD 4F ED 1E   mov di, filename
1562   0923 07 29 11      call _strcmp
1563   0926 C6 3C 09      je get_dirID_from_path_name_equal  
1564   0929 58 20 00      add d, 32
1565   092C 14 18 18      mov a, [index]
1566   092F 77            inc a
1567   0930 42 18 18      mov [index], a
1568   0933 AF 10 00      cmp a, FST_FILES_PER_DIR
1569   0936 C6 4F 09      je get_dirID_from_path_fail
1570   0939 0A 1D 09      jmp get_dirID_from_path_L1
1571   093C             get_dirID_from_path_name_equal:
1572   093C 58 19 00      add d, 25           
1573   093F 15            mov a, [d]                    ; set result register A = dirID
1574   0940 07 6C 15      call get_token
1575   0943 31 0E 17      mov bl, [tok]
1576   0946 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1577   0948 C6 F5 08      je get_dirID_from_path_E0
1578   094B 07 F2 16      call _putback
1579   094E             get_dirID_from_path_end:
1580   094E 09            ret
1581   094F             get_dirID_from_path_fail:
1582   094F 10 FF FF      mov A, $FFFF
1583   0952 09            ret
1584   0953             
1585   0953             
1586   0953             ;------------------------------------------------------------------------------------------------------;
1587   0953             ; check if file exists by a given path string
1588   0953             ; in_puts:
1589   0953             ; D = path pointer 
1590   0953             ; OUTPUTS:
1591   0953             ; A = success code, if file exists gives LBA, else, give 0
1592   0953             ; /usr/local/bin/ed
1593   0953             ;------------------------------------------------------------------------------------------------------;
1594   0953             fs_filepath_exists_user:
1595   0953 FD 4E         mov si, d
1596   0955 FD 4F 6D 1F   mov di, user_data
1597   0959 38 00 02      mov c, 512
1598   095C 04            load
1599   095D 07 61 09      call file_exists_by_path
1600   0960 06            sysret
1601   0961             file_exists_by_path:
1602   0961 26 6D 1F      mov b, user_data
1603   0964 FD 42 0B 17   mov [prog], b                   ; token pointer set to path string
1604   0968 07 6C 15      call get_token
1605   096B 31 0E 17      mov bl, [tok]
1606   096E C1 01         cmp bl, TOK_FSLASH
1607   0970 C6 7C 09      je  file_exists_by_path_abs
1608   0973 14 20 18      mov a, [current_dir_id]
1609   0976 07 F2 16      call _putback
1610   0979 0A 7F 09      jmp file_exists_by_path_E0
1611   097C             file_exists_by_path_abs:
1612   097C 10 20 00      mov a, root_id
1613   097F             file_exists_by_path_E0:
1614   097F 07 6C 15      call get_token
1615   0982 31 0D 17      mov bl, [toktyp]
1616   0985 C1 00         cmp bl, TOKTYP_IDENTIFIER
1617   0987 C7 DF 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1618   098A FD 4D 0F 17   mov si, tokstr
1619   098E FD 4F ED 1E   mov di, filename
1620   0992 07 3E 11      call _strcpy        
1621   0995 77            inc a                           ; metadata sector
1622   0996 27            mov b, a
1623   0997 38 00 00      mov c, 0                        ; upper LBA = 0
1624   099A 22 01         mov ah, $01                  ; 1 sector
1625   099C 3B 6D 27      mov d, transient_area
1626   099F 07 43 05      call ide_read_sect              ; read directory
1627   09A2 FD 10         cla
1628   09A4 42 18 18      mov [index], a
1629   09A7             file_exists_by_path_L1:
1630   09A7 FD 4E         mov si, d
1631   09A9 FD 4F ED 1E   mov di, filename
1632   09AD 07 29 11      call _strcmp
1633   09B0 C6 C6 09      je   file_exists_by_path_name_equal
1634   09B3 58 20 00      add d, 32
1635   09B6 14 18 18      mov a, [index]
1636   09B9 77            inc a
1637   09BA 42 18 18      mov [index], a
1638   09BD AF 10 00      cmp a, FST_FILES_PER_DIR
1639   09C0 C6 DF 09      je file_exists_by_path_end
1640   09C3 0A A7 09      jmp file_exists_by_path_L1
1641   09C6             file_exists_by_path_name_equal:
1642   09C6 33 18 00      mov bl, [d + 24]
1643   09C9 FD 87 38      and bl, %00111000               ; directory flag
1644   09CC C1 08         cmp bl, %00001000               ; is dir?
1645   09CE C6 D5 09      je file_exists_by_path_isdir;
1646   09D1             ; entry is a file
1647   09D1 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1648   09D4 09            ret
1649   09D5             file_exists_by_path_isdir:
1650   09D5 58 19 00      add d, 25           
1651   09D8 15            mov a, [d]                      ; set result register A = dirID
1652   09D9 07 6C 15      call get_token
1653   09DC 0A 7F 09      jmp file_exists_by_path_E0
1654   09DF             file_exists_by_path_end:
1655   09DF 10 00 00      mov a, 0                        ; return 0 because file was not found
1656   09E2 09            ret
1657   09E3             
1658   09E3             ;------------------------------------------------------------------------------------------------------;
1659   09E3             ; load file data from a given path string
1660   09E3             ; inputs:
1661   09E3             ; D = path pointer 
1662   09E3             ; DI = userspace program data destination
1663   09E3             ; /usr/local/bin/ed
1664   09E3             ; ./ed
1665   09E3             ;------------------------------------------------------------------------------------------------------;
1666   09E3             fs_load_from_path_user:
1667   09E3 E3            push di
1668   09E4 FD 4E         mov si, d
1669   09E6 FD 4F 6D 1F   mov di, user_data
1670   09EA 38 00 02      mov c, 512
1671   09ED 04            load
1672   09EE 07 FB 09      call loadfile_from_path
1673   09F1 F0            pop di
1674   09F2 FD 4D 6D 27   mov si, transient_area
1675   09F6 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1676   09F9 03            store
1677   09FA 06            sysret
1678   09FB             loadfile_from_path:
1679   09FB 26 6D 1F      mov b, user_data
1680   09FE FD 42 0B 17   mov [prog], b                 ; token pointer set to path string
1681   0A02 07 6C 15      call get_token
1682   0A05 31 0E 17      mov bl, [tok]
1683   0A08 C1 01         cmp bl, TOK_FSLASH
1684   0A0A C6 16 0A      je loadfile_from_path_abs 
1685   0A0D 14 20 18      mov a, [current_dir_id]
1686   0A10 07 F2 16      call _putback
1687   0A13 0A 19 0A      jmp loadfile_from_path_E0
1688   0A16             loadfile_from_path_abs:
1689   0A16 10 20 00      mov a, root_id
1690   0A19             loadfile_from_path_E0:
1691   0A19 07 6C 15      call get_token
1692   0A1C 31 0D 17      mov bl, [toktyp]
1693   0A1F C1 00         cmp bl, TOKTYP_IDENTIFIER
1694   0A21 C7 86 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1695   0A24 FD 4D 0F 17   mov si, tokstr
1696   0A28 FD 4F ED 1E   mov di, filename
1697   0A2C 07 3E 11      call _strcpy        
1698   0A2F 77            inc a                         ; metadata sector
1699   0A30 27            mov b, a
1700   0A31 38 00 00      mov c, 0                      ; upper LBA = 0
1701   0A34 22 01         mov ah, $01                  ; 1 sector
1702   0A36 3B 6D 27      mov d, transient_area
1703   0A39 07 43 05      call ide_read_sect            ; read directory
1704   0A3C FD 10         cla
1705   0A3E 42 18 18      mov [index], a
1706   0A41             loadfile_from_path_L1:
1707   0A41 FD 4E         mov si, d
1708   0A43 FD 4F ED 1E   mov di, filename
1709   0A47 07 29 11      call _strcmp
1710   0A4A C6 60 0A      je loadfile_from_path_name_equal  
1711   0A4D 58 20 00      add d, 32
1712   0A50 14 18 18      mov a, [index]
1713   0A53 77            inc a
1714   0A54 42 18 18      mov [index], a
1715   0A57 AF 10 00      cmp a, FST_FILES_PER_DIR
1716   0A5A C6 86 0A      je loadfile_from_path_end
1717   0A5D 0A 41 0A      jmp loadfile_from_path_L1
1718   0A60             loadfile_from_path_name_equal:
1719   0A60 33 18 00      mov bl, [d + 24]
1720   0A63 FD 87 38      and bl, %00111000             ; directory flag
1721   0A66 C1 08         cmp bl, %00001000             ; is dir?
1722   0A68 C6 7C 0A      je loadfile_isdirectory  
1723   0A6B             ; entry is a file
1724   0A6B 2B 19 00      mov b, [d + 25]               ; get LBA
1725   0A6E FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1726   0A70 3B 6D 27      mov d, transient_area
1727   0A73 38 00 00      mov c, 0
1728   0A76 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1729   0A78 07 43 05      call ide_read_sect            ; read sector
1730   0A7B 09            ret
1731   0A7C             loadfile_isdirectory:
1732   0A7C 58 19 00      add d, 25           
1733   0A7F 15            mov a, [d]                    ; set result register A = dirID
1734   0A80 07 6C 15      call get_token
1735   0A83 0A 19 0A      jmp loadfile_from_path_E0
1736   0A86             loadfile_from_path_end:
1737   0A86 09            ret
1738   0A87             
1739   0A87             ;------------------------------------------------------------------------------------------------------;
1740   0A87             ; return the ID of the current directory
1741   0A87             ; ID returned in B
1742   0A87             ;------------------------------------------------------------------------------------------------------;
1743   0A87             fs_get_curr_dirID:
1744   0A87 29 20 18      mov b, [current_dir_id]
1745   0A8A 06            sysret
1746   0A8B             
1747   0A8B             ;------------------------------------------------------------------------------------------------------;
1748   0A8B             ; CD
1749   0A8B             ;------------------------------------------------------------------------------------------------------;
1750   0A8B             ; new dirID in B
1751   0A8B             fs_cd:
1752   0A8B FD 42 20 18   mov [current_dir_id], b
1753   0A8F 06            sysret  
1754   0A90             
1755   0A90             ;------------------------------------------------------------------------------------------------------;
1756   0A90             ; LS
1757   0A90             ; dirID in B
1758   0A90             ;------------------------------------------------------------------------------------------------------;
1759   0A90 00 00       ls_count:       .dw 0
1760   0A92             fs_ls:
1761   0A92 FD 77         inc b                        ; metadata sector
1762   0A94 38 00 00      mov c, 0                     ; upper LBA = 0
1763   0A97 22 01         mov ah, $01                  ; 1 sector
1764   0A99 3B 6D 27      mov d, transient_area
1765   0A9C 07 43 05      call ide_read_sect           ; read directory
1766   0A9F FD 10         cla
1767   0AA1 42 18 18      mov [index], a               ; reset entry index
1768   0AA4 3D 90 0A      mov [ls_count], al           ; reset item count
1769   0AA7             fs_ls_L1:
1770   0AA7 BD 00         cmp byte [d], 0              ; check for NULL
1771   0AA9 C6 40 0B      je fs_ls_next
1772   0AAC             fs_ls_non_null:
1773   0AAC 1D 90 0A      mov al, [ls_count]
1774   0AAF 7A            inc al
1775   0AB0 3D 90 0A      mov [ls_count], al           ; increment item count
1776   0AB3 1F 18 00      mov al, [d + 24]
1777   0AB6 87 38         and al, %00111000
1778   0AB8 FD A2 03      shr al, 3
1779   0ABB 22 00         mov ah, 0                    ; file type
1780   0ABD B7 4B 18      mov a, [a + file_type]      
1781   0AC0 23            mov ah, al
1782   0AC1 07 BA 11      call _putchar
1783   0AC4 1F 18 00      mov al, [d + 24]
1784   0AC7 87 01         and al, %00000001
1785   0AC9 22 00         mov ah, 0
1786   0ACB B7 46 18      mov a, [a + file_attrib]     ; read
1787   0ACE 23            mov ah, al
1788   0ACF 07 BA 11      call _putchar
1789   0AD2 1F 18 00      mov al, [d + 24]
1790   0AD5 87 02         and al, %00000010
1791   0AD7 22 00         mov ah, 0
1792   0AD9 B7 46 18      mov a, [a + file_attrib]     ; write
1793   0ADC 23            mov ah, al
1794   0ADD 07 BA 11      call _putchar
1795   0AE0 1F 18 00      mov al, [d + 24]
1796   0AE3 87 04         and al, %00000100
1797   0AE5 22 00         mov ah, 0
1798   0AE7 B7 46 18      mov a, [a + file_attrib]     ; execute
1799   0AEA 23            mov ah, al
1800   0AEB 07 BA 11      call _putchar
1801   0AEE 22 20         mov ah, $20
1802   0AF0 07 BA 11      call _putchar  
1803   0AF3 2B 1B 00      mov b, [d + 27]
1804   0AF6 07 42 13      call print_u16x              ; filesize
1805   0AF9 22 20         mov ah, $20
1806   0AFB 07 BA 11      call _putchar  
1807   0AFE 2B 19 00      mov b, [d + 25]
1808   0B01 07 42 13      call print_u16x              ; dirID / LBA
1809   0B04 22 20         mov ah, $20
1810   0B06 07 BA 11      call _putchar
1811   0B09             ; print date
1812   0B09 33 1D 00      mov bl, [d + 29]             ; day
1813   0B0C 07 86 13      call print_u8x
1814   0B0F 22 20         mov ah, $20
1815   0B11 07 BA 11      call _putchar  
1816   0B14 1F 1E 00      mov al, [d + 30]             ; month
1817   0B17 FD 9E 02      shl al, 2
1818   0B1A DA            push d
1819   0B1B 3B 0A 19      mov d, s_months
1820   0B1E 22 00         mov ah, 0
1821   0B20 59            add d, a
1822   0B21 07 E6 12      call _puts
1823   0B24 E7            pop d
1824   0B25 22 20         mov ah, $20
1825   0B27 07 BA 11      call _putchar
1826   0B2A 2E 20         mov bl, $20
1827   0B2C 07 86 13      call print_u8x
1828   0B2F 33 1F 00      mov bl, [d + 31]             ; year
1829   0B32 07 86 13      call print_u8x  
1830   0B35 22 20         mov ah, $20
1831   0B37 07 BA 11      call _putchar  
1832   0B3A 07 E6 12      call _puts                   ; print filename  
1833   0B3D 07 93 12      call printnl
1834   0B40             fs_ls_next:
1835   0B40 14 18 18      mov a, [index]
1836   0B43 77            inc a
1837   0B44 42 18 18      mov [index], a
1838   0B47 AF 10 00      cmp a, FST_FILES_PER_DIR
1839   0B4A C6 53 0B      je fs_ls_end
1840   0B4D 58 20 00      add d, 32      
1841   0B50 0A A7 0A      jmp fs_ls_L1  
1842   0B53             fs_ls_end:
1843   0B53 3B 5B 18      mov d, s_ls_total
1844   0B56 07 E6 12      call _puts
1845   0B59 1D 90 0A      mov al, [ls_count]
1846   0B5C 07 98 13      call print_u8d
1847   0B5F 07 93 12      call printnl
1848   0B62 06            sysret
1849   0B63             
1850   0B63             
1851   0B63             ;------------------------------------------------------------------------------------------------------;
1852   0B63             ; CREATE NEW TEXTFILE
1853   0B63             ;------------------------------------------------------------------------------------------------------;
1854   0B63             ; file structure:
1855   0B63             ; 512 bytes header
1856   0B63             ; header used to tell whether the block is free
1857   0B63             ; d = content pointer in user space
1858   0B63             ; c = file size
1859   0B63             ; TODO: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1860   0B63             fs_starcom:
1861   0B63 FD 4E       	mov si, d
1862   0B65 FD 4F 6D 27 	mov di, transient_area
1863   0B69 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1864   0B6C 04          	load					; load data from user-space
1865   0B6D 07 EE 0B    	call fs_find_empty_block	; look for empty data blocks
1866   0B70 D8          	push b				; save empty block LBA
1867   0B71 FD 79         mov g, b
1868   0B73             ;create header file by grabbing file name from parameter	
1869   0B73 3B 6D 29    	mov d, transient_area + 512			; pointer to file contents
1870   0B76 D9          	push c							; save length
1871   0B77 19 01       	mov al, 1
1872   0B79 3D 6D 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1873   0B7C 3B 6D 27    	mov d, transient_area
1874   0B7F 12            mov a, c
1875   0B80 26 00 02      mov b, 512
1876   0B83 AE            div a, b
1877   0B84 FD 77         inc b         ; inc b as the division will most likely have a remainder
1878   0B86 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1879   0B87 38 00 00    	mov c, 0      ; lba 
1880   0B8A FD 27         mov b, g      ; lba 
1881   0B8C 07 69 05    	call ide_write_sect			; write sectors
1882   0B8F             ; now we add the file to the current directory!
1883   0B8F             fs_starcom_add_to_dir:	
1884   0B8F 14 20 18    	mov a, [current_dir_id]
1885   0B92 77          	inc a
1886   0B93 27          	mov b, a					; metadata sector
1887   0B94 38 00 00    	mov c, 0
1888   0B97 FD 79       	mov g, b					; save LBA
1889   0B99 3B 6D 25    	mov d, scrap_sector
1890   0B9C 22 01       	mov ah, $01			  ; 1 sector
1891   0B9E 07 43 05    	call ide_read_sect		; read metadata sector
1892   0BA1             fs_starcom_add_to_dir_L2:
1893   0BA1 BD 00       	cmp byte[d], 0
1894   0BA3 C6 AC 0B    	je fs_starcom_add_to_dir_null
1895   0BA6 58 20 00    	add d, FST_ENTRY_SIZE
1896   0BA9 0A A1 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1897   0BAC             fs_starcom_add_to_dir_null:
1898   0BAC FD 4D 6E 27 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1899   0BB0 FD 50       	mov di, d
1900   0BB2 07 3E 11    	call _strcpy			; copy file name
1901   0BB5 58 18 00    	add d, 24			; skip name
1902   0BB8 19 07       	mov al, %00000111	; type=file, execute, write, read
1903   0BBA 3E          	mov [d], al			
1904   0BBB 58 03 00    	add d, 3
1905   0BBE E4          	pop a
1906   0BBF 5F 00 02      sub a, 512
1907   0BC2 43          	mov [d], a ; file size
1908   0BC3 63 02 00    	sub d, 2
1909   0BC6 E5          	pop b				; get file LBA
1910   0BC7 FD 43       	mov [d], b			; save LBA	
1911   0BC9             ; set file creation date	
1912   0BC9 58 04 00    	add d, 4
1913   0BCC 19 04       	mov al, 4
1914   0BCE 05 01       	syscall sys_rtc
1915   0BD0 1A          	mov al, ah
1916   0BD1 3E          	mov [d], al			; set day
1917   0BD2 79          	inc d
1918   0BD3 19 05       	mov al, 5
1919   0BD5 05 01       	syscall sys_rtc
1920   0BD7 1A          	mov al, ah
1921   0BD8 3E          	mov [d], al			; set month
1922   0BD9 79          	inc d
1923   0BDA 19 06       	mov al, 6
1924   0BDC 05 01       	syscall sys_rtc
1925   0BDE 1A          	mov al, ah
1926   0BDF 3E          	mov [d], al			; set year
1927   0BE0             ; write sector into disk for new directory entry
1928   0BE0 FD 27       	mov b, g
1929   0BE2 38 00 00    	mov c, 0
1930   0BE5 3B 6D 25    	mov d, scrap_sector
1931   0BE8 22 01       	mov ah, $01			; disk write, 1 sector
1932   0BEA 07 69 05    	call ide_write_sect		; write sector
1933   0BED 06          	sysret
1934   0BEE             
1935   0BEE             ;------------------------------------------------------------------------------------------------------;
1936   0BEE             ; finds an empty data block
1937   0BEE             ; block LBA returned in B
1938   0BEE             ;------------------------------------------------------------------------------------------------------;
1939   0BEE             fs_find_empty_block:
1940   0BEE 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1941   0BF1 38 00 00      mov c, 0                ; upper LBA = 0
1942   0BF4             fs_find_empty_block_L1:  
1943   0BF4 22 01         mov ah, $01                  ; 1 sector
1944   0BF6 3B 6D 25      mov d, transient_area - 512
1945   0BF9 07 43 05      call ide_read_sect      ; read sector
1946   0BFC BD 00         cmp byte [d], 0
1947   0BFE C6 07 0C      je fs_find_empty_block_found_null
1948   0C01 55 20 00      add b, FS_SECTORS_PER_FILE
1949   0C04 0A F4 0B      jmp fs_find_empty_block_L1
1950   0C07             fs_find_empty_block_found_null:
1951   0C07 09            ret
1952   0C08             
1953   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1954   0C08             ;; CREATE NEW TEXTFILE
1955   0C08             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1956   0C08             ; search for first null block
1957   0C08             fs_mktxt:
1958   0C08 FD 4E       	mov si, d
1959   0C0A FD 4F 6D 1F 	mov di, user_data
1960   0C0E 38 00 01    	mov c, 256
1961   0C11 04          	load					; load data from user-space
1962   0C12             	
1963   0C12 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1964   0C15 38 00 00    	mov c, 0						; reset LBA to 0
1965   0C18             fs_mktxt_L1:	
1966   0C18 10 02 01    	mov a, $0102			; disk read
1967   0C1B 3B 6D 27    	mov d, transient_area
1968   0C1E 05 02       	syscall sys_ide ; read sector
1969   0C20 1E          	mov al, [d]
1970   0C21 B9 00       	cmp al, 0			; check for NULL
1971   0C23 C6 2C 0C    	je fs_mktxt_found_null
1972   0C26 55 20 00    	add b, FS_SECTORS_PER_FILE
1973   0C29 0A 18 0C    	jmp fs_mktxt_L1
1974   0C2C             fs_mktxt_found_null:
1975   0C2C D8          	push b				; save LBA
1976   0C2D             ;create header file by grabbing file name from parameter	
1977   0C2D 3B 3C 18    	mov d, s_dataentry
1978   0C30 07 E6 12    	call _puts
1979   0C33 3B 6D 29    	mov d, transient_area + 512			; pointer to file contents
1980   0C36 07 4C 12    	call _gettxt
1981   0C39 07 19 11    	call _strlen						; get length of file
1982   0C3C D9          	push c							; save length
1983   0C3D 19 01       	mov al, 1
1984   0C3F 3D 6D 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1985   0C42 10 00 00    	mov a, 0
1986   0C45 42 18 18    	mov [index], a
1987   0C48 3B 6D 27    	mov d, transient_area
1988   0C4B 13          	mov a, d
1989   0C4C 42 1A 18    	mov [buffer_addr], a
1990   0C4F             fs_mktxt_L2:
1991   0C4F 38 00 00    	mov c, 0
1992   0C52 10 03 01    	mov a, $0103			; disk write, 1 sector
1993   0C55 05 02       	syscall sys_ide		; write sector
1994   0C57 14 18 18    	mov a, [index]
1995   0C5A 77          	inc a
1996   0C5B 42 18 18    	mov [index], a
1997   0C5E AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1998   0C61 C6 73 0C    	je fs_mktxt_add_to_dir
1999   0C64 FD 77       	inc b
2000   0C66 14 1A 18    	mov a, [buffer_addr]
2001   0C69 53 00 02    	add a, 512
2002   0C6C 42 1A 18    	mov [buffer_addr], a
2003   0C6F 3C          	mov d, a
2004   0C70 0A 4F 0C    	jmp fs_mktxt_L2
2005   0C73             ; now we add the file to the current directory!
2006   0C73             fs_mktxt_add_to_dir:	
2007   0C73 14 20 18    	mov a, [current_dir_id]
2008   0C76 77          	inc a
2009   0C77 27          	mov b, a					; metadata sector
2010   0C78 38 00 00    	mov c, 0
2011   0C7B FD 79       	mov g, b					; save LBA
2012   0C7D 3B 6D 27    	mov d, transient_area
2013   0C80 10 02 01    	mov a, $0102			; disk read
2014   0C83 05 02       	syscall sys_ide		; read metadata sector
2015   0C85             fs_mktxt_add_to_dir_L2:
2016   0C85 1E          	mov al, [d]
2017   0C86 B9 00       	cmp al, 0
2018   0C88 C6 91 0C    	je fs_mktxt_add_to_dir_null
2019   0C8B 58 20 00    	add d, FST_ENTRY_SIZE
2020   0C8E 0A 85 0C    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2021   0C91             fs_mktxt_add_to_dir_null:
2022   0C91 FD 4D 6D 1F 	mov si, user_data
2023   0C95 FD 50       	mov di, d
2024   0C97 07 3E 11    	call _strcpy			; copy file name
2025   0C9A 58 18 00    	add d, 24			; skip name
2026   0C9D 19 06       	mov al, %00000110		; no execute, write, read, not directory
2027   0C9F 3E          	mov [d], al			
2028   0CA0 58 03 00    	add d, 3
2029   0CA3 E4          	pop a
2030   0CA4 43          	mov [d], a
2031   0CA5 63 02 00    	sub d, 2
2032   0CA8 E5          	pop b				; get file LBA
2033   0CA9 FD 43       	mov [d], b			; save LBA	
2034   0CAB             	
2035   0CAB             	; set file creation date	
2036   0CAB 58 04 00    	add d, 4
2037   0CAE 19 04       	mov al, 4
2038   0CB0 05 01       	syscall sys_rtc
2039   0CB2 1A          	mov al, ah
2040   0CB3 3E          	mov [d], al			; set day
2041   0CB4             	
2042   0CB4 79          	inc d
2043   0CB5 19 05       	mov al, 5
2044   0CB7 05 01       	syscall sys_rtc
2045   0CB9 1A          	mov al, ah
2046   0CBA 3E          	mov [d], al			; set month
2047   0CBB             	
2048   0CBB 79          	inc d
2049   0CBC 19 06       	mov al, 6
2050   0CBE 05 01       	syscall sys_rtc
2051   0CC0 1A          	mov al, ah
2052   0CC1 3E          	mov [d], al			; set year
2053   0CC2             	
2054   0CC2             ; write sector into disk for new directory entry
2055   0CC2 FD 27       	mov b, g
2056   0CC4 38 00 00    	mov c, 0
2057   0CC7 3B 6D 27    	mov d, transient_area
2058   0CCA 10 03 01    	mov a, $0103			; disk write, 1 sector
2059   0CCD 05 02       	syscall sys_ide		; write sector
2060   0CCF 07 93 12    	call printnl
2061   0CD2 06          	sysret
2062   0CD3             
2063   0CD3             
2064   0CD3             
2065   0CD3             ;------------------------------------------------------------------------------------------------------;
2066   0CD3             ; create new binary file
2067   0CD3             ;------------------------------------------------------------------------------------------------------;
2068   0CD3             ; search for first null block
2069   0CD3             fs_mkbin:
2070   0CD3 19 00         mov al, 0
2071   0CD5 3D 10 18      mov [sys_echo_on], al ; disable echo
2072   0CD8 FD 4E         mov si, d
2073   0CDA FD 4F 6D 1F   mov di, user_data
2074   0CDE 38 00 02      mov c, 512
2075   0CE1 04            load                          ; load data from user-space
2076   0CE2 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2077   0CE5 38 00 00      mov c, 0                      ; upper LBA = 0
2078   0CE8             fs_mkbin_L1:  
2079   0CE8 22 01         mov ah, $01                  ; 1 sector
2080   0CEA 3B 6D 27      mov d, transient_area
2081   0CED 07 43 05      call ide_read_sect            ; read sector
2082   0CF0 BD 00         cmp byte[d], 0                ; check for NULL
2083   0CF2 C6 FB 0C      je fs_mkbin_found_null
2084   0CF5 55 20 00      add b, FS_SECTORS_PER_FILE
2085   0CF8 0A E8 0C      jmp fs_mkbin_L1
2086   0CFB             fs_mkbin_found_null:
2087   0CFB D8            push b                        ; save LBA
2088   0CFC             ;create header file by grabbing file name from parameter
2089   0CFC FD 4F 6D 29   mov di, transient_area + 512  ; pointer to file contents
2090   0D00 07 76 10      call _load_hex                ; load binary hex
2091   0D03 D9            push c                        ; save size (nbr of bytes)
2092   0D04 19 01         mov al, 1
2093   0D06 3D 6D 27      mov [transient_area], al      ; mark sectors as USED (not NULL)
2094   0D09 FD 10         cla
2095   0D0B 42 18 18      mov [index], a
2096   0D0E 3B 6D 27      mov d, transient_area
2097   0D11 13            mov a, d
2098   0D12 42 1A 18      mov [buffer_addr], a
2099   0D15             fs_mkbin_L2:
2100   0D15 38 00 00      mov c, 0
2101   0D18 22 01         mov ah, $01                   ; disk write, 1 sector
2102   0D1A 07 69 05      call ide_write_sect           ; write sector
2103   0D1D 14 18 18      mov a, [index]
2104   0D20 77            inc a
2105   0D21 42 18 18      mov [index], a
2106   0D24 AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2107   0D27 C6 39 0D      je fs_mkbin_add_to_dir
2108   0D2A FD 77         inc b
2109   0D2C 14 1A 18      mov a, [buffer_addr]
2110   0D2F 53 00 02      add a, 512
2111   0D32 42 1A 18      mov [buffer_addr], a
2112   0D35 3C            mov d, a
2113   0D36 0A 15 0D      jmp fs_mkbin_L2
2114   0D39             ; now we add the file to the current directory!
2115   0D39             fs_mkbin_add_to_dir:  
2116   0D39 14 20 18      mov a, [current_dir_id]
2117   0D3C 77            inc a
2118   0D3D 27            mov b, a                      ; metadata sector
2119   0D3E 38 00 00      mov c, 0
2120   0D41 FD 79         mov g, b                      ; save LBA
2121   0D43 3B 6D 27      mov d, transient_area
2122   0D46 22 01         mov ah, $01                  ; 1 sector
2123   0D48 07 43 05      call ide_read_sect            ; read metadata sector
2124   0D4B             fs_mkbin_add_to_dir_L2:
2125   0D4B BD 00         cmp byte[d], 0
2126   0D4D C6 56 0D      je fs_mkbin_add_to_dir_null
2127   0D50 58 20 00      add d, FST_ENTRY_SIZE
2128   0D53 0A 4B 0D      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2129   0D56             fs_mkbin_add_to_dir_null:
2130   0D56 FD 4D 6D 1F   mov si, user_data
2131   0D5A FD 50         mov di, d
2132   0D5C 07 3E 11      call _strcpy                  ; copy file name
2133   0D5F 58 18 00      add d, 24                     ; skip name
2134   0D62 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2135   0D64 3E            mov [d], al
2136   0D65 58 03 00      add d, 3
2137   0D68 E4            pop a
2138   0D69 43            mov [d], a
2139   0D6A 63 02 00      sub d, 2
2140   0D6D E5            pop b                         ; get file LBA
2141   0D6E FD 43         mov [d], b                    ; save LBA
2142   0D70               ; set file creation date  
2143   0D70 58 04 00      add d, 4
2144   0D73 19 04         mov al, 4
2145   0D75 05 01         syscall sys_rtc
2146   0D77 1A            mov al, ah
2147   0D78 3E            mov [d], al                   ; set day
2148   0D79 79            inc d
2149   0D7A 19 05         mov al, 5
2150   0D7C 05 01         syscall sys_rtc
2151   0D7E 1A            mov al, ah
2152   0D7F 3E            mov [d], al                   ; set month
2153   0D80 79            inc d
2154   0D81 19 06         mov al, 6
2155   0D83 05 01         syscall sys_rtc
2156   0D85 1A            mov al, ah
2157   0D86 3E            mov [d], al                   ; set year
2158   0D87             ; write sector into disk for new directory entry
2159   0D87 FD 27         mov b, g
2160   0D89 38 00 00      mov c, 0
2161   0D8C 3B 6D 27      mov d, transient_area
2162   0D8F 22 01         mov ah, $01                   ; disk write, 1 sector
2163   0D91 07 69 05      call ide_write_sect           ; write sector
2164   0D94 19 01         mov al, 1
2165   0D96 3D 10 18      mov [sys_echo_on], al ; enable echo
2166   0D99 06            sysret
2167   0D9A             
2168   0D9A             ;------------------------------------------------------------------------------------------------------;
2169   0D9A             ; pwd - print working directory
2170   0D9A             ;------------------------------------------------------------------------------------------------------;    
2171   0D9A             fs_pwd:
2172   0D9A 3B ED 1E      mov d, filename
2173   0D9D 19 00         mov al, 0
2174   0D9F 3E            mov [d], al                   ; initialize path string 
2175   0DA0 14 20 18      mov a, [current_dir_id]
2176   0DA3 07 79 08      call fs_dir_id_to_path_E0
2177   0DA6 3B ED 1E      mov d, filename
2178   0DA9 07 D2 10      call _strrev
2179   0DAC 07 E6 12      call _puts
2180   0DAF 07 93 12      call printnl
2181   0DB2 06            sysret
2182   0DB3             
2183   0DB3             ;------------------------------------------------------------------------------------------------------;
2184   0DB3             ; get current directory LBA
2185   0DB3             ; A: returned LBA
2186   0DB3             ;------------------------------------------------------------------------------------------------------;
2187   0DB3             cmd_get_curr_dir_LBA:
2188   0DB3 14 20 18      mov a, [current_dir_id]
2189   0DB6 06            sysret
2190   0DB7             
2191   0DB7             ;------------------------------------------------------------------------------------------------------;
2192   0DB7             ; CAT
2193   0DB7             ; userspace destination data pointer in D
2194   0DB7             ; filename starts at D, but is overwritten after the read is made
2195   0DB7             ;------------------------------------------------------------------------------------------------------;:
2196   0DB7             fs_cat:
2197   0DB7 DA            push d                              ; save userspace file data destination
2198   0DB8 FD 4E         mov si, d
2199   0DBA FD 4F 6D 1F   mov di, user_data
2200   0DBE 38 00 02      mov c, 512
2201   0DC1 04            load                                ; copy filename from user-space
2202   0DC2 29 20 18      mov b, [current_dir_id]
2203   0DC5 FD 77         inc b                               ; metadata sector
2204   0DC7 38 00 00      mov c, 0                            ; upper LBA = 0
2205   0DCA 22 01         mov ah, $01                  ; 1 sector
2206   0DCC 3B 6D 25      mov d, transient_area-512
2207   0DCF 07 43 05      call ide_read_sect                  ; read directory
2208   0DD2 FD 10         cla
2209   0DD4 42 18 18      mov [index], a                      ; reset file counter
2210   0DD7             fs_cat_L1:
2211   0DD7 FD 4E         mov si, d
2212   0DD9 FD 4F 6D 1F   mov di, user_data
2213   0DDD 07 29 11      call _strcmp
2214   0DE0 C6 F6 0D      je fs_cat_found_entry
2215   0DE3 58 20 00      add d, 32
2216   0DE6 14 18 18      mov a, [index]
2217   0DE9 77            inc a
2218   0DEA 42 18 18      mov [index], a
2219   0DED AF 10 00      cmp a, FST_FILES_PER_DIR
2220   0DF0 C6 11 0E      je fs_cat_not_found
2221   0DF3 0A D7 0D      jmp fs_cat_L1
2222   0DF6             fs_cat_found_entry:
2223   0DF6 58 19 00      add d, 25                           ; get to dirID of file in disk
2224   0DF9 2A            mov b, [d]                          ; get LBA
2225   0DFA FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2226   0DFC 3B 6D 27      mov d, transient_area  
2227   0DFF 38 00 00      mov c, 0
2228   0E02 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2229   0E04 07 43 05      call ide_read_sect                  ; read sectors
2230   0E07 F0            pop di                              ; write userspace file data destination to DI
2231   0E08 FD 4D 6D 27   mov si, transient_area              ; data origin
2232   0E0C 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2233   0E0F 03            store
2234   0E10 06            sysret
2235   0E11             fs_cat_not_found:
2236   0E11 E7            pop d
2237   0E12 06            sysret
2238   0E13             
2239   0E13             ;------------------------------------------------------------------------------------------------------;
2240   0E13             ; RMDIR - remove DIR by dirID
2241   0E13             ;------------------------------------------------------------------------------------------------------;
2242   0E13             ; deletes a directory entry in the given directory's file list 
2243   0E13             ; also deletes the actual directory entry in the FST
2244   0E13             ; synopsis: rmdir /usr/local/testdir
2245   0E13             ; B = dirID
2246   0E13             fs_rmdir:
2247   0E13 FD 79         mov g, b
2248   0E15 11            mov a, b
2249   0E16 07 B5 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2250   0E19 D7            push a                        ; save dirID
2251   0E1A             ; search for directory's entry in the parent's directory then and delete it
2252   0E1A 77            inc a                         ; metadata sector
2253   0E1B 27            mov b, a
2254   0E1C 38 00 00      mov c, 0                      ; upper LBA = 0
2255   0E1F 22 01         mov ah, $01          ;
2256   0E21 3B 6D 27      mov d, transient_area
2257   0E24 07 43 05      call ide_read_sect            ; read directory
2258   0E27 FD 10         cla
2259   0E29 42 18 18      mov [index], a                ; reset file counter
2260   0E2C FD 27         mov b, g                      ; retrieve directory's dirID
2261   0E2E             fs_rmdir_L1:
2262   0E2E 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2263   0E31 B0            cmp a, b                      ; compare dirID's to find the directory
2264   0E32 C6 48 0E      je fs_rmdir_found_entry
2265   0E35 58 20 00      add d, 32
2266   0E38 14 18 18      mov a, [index]
2267   0E3B 77            inc a
2268   0E3C 42 18 18      mov [index], a
2269   0E3F AF 10 00      cmp a, FST_FILES_PER_DIR
2270   0E42 C6 6D 0E      je fs_rmdir_not_found
2271   0E45 0A 2E 0E      jmp fs_rmdir_L1
2272   0E48             fs_rmdir_found_entry:
2273   0E48 FD 10         cla
2274   0E4A 3E            mov [d], al                   ; make filename NULL
2275   0E4B 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2276   0E4E E5            pop b
2277   0E4F FD 77         inc b                         ; metadata sector
2278   0E51 38 00 00      mov c, 0                      ; upper LBA = 0
2279   0E54 22 01         mov ah, $01          ; 
2280   0E56 3B 6D 27      mov d, transient_area
2281   0E59 07 69 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2282   0E5C             
2283   0E5C FD 27         mov b, g
2284   0E5E 3B 6D 27      mov d, transient_area  
2285   0E61 FD 10         cla
2286   0E63 3E            mov [d], al                   ; make directory's name header NULL for re-use
2287   0E64 38 00 00      mov c, 0
2288   0E67 22 01         mov ah, $01                   ; disk write 1 sect
2289   0E69 07 69 05      call ide_write_sect           ; delete directory given by dirID in B
2290   0E6C 06            sysret
2291   0E6D             fs_rmdir_not_found:
2292   0E6D E5            pop b
2293   0E6E 06            sysret
2294   0E6F             
2295   0E6F             ;------------------------------------------------------------------------------------------------------;
2296   0E6F             ; RM - remove file
2297   0E6F             ;------------------------------------------------------------------------------------------------------;
2298   0E6F             ; frees up the data sectors for the file further down the disk
2299   0E6F             ; deletes file entry in the directory's file list 
2300   0E6F             fs_rm:
2301   0E6F FD 4E         mov si, d
2302   0E71 FD 4F 6D 1F   mov di, user_data
2303   0E75 38 00 02      mov c, 512
2304   0E78 04            load                          ; load data from user-space
2305   0E79 14 20 18      mov a, [current_dir_id]
2306   0E7C 77            inc a                         ; metadata sector
2307   0E7D 27            mov b, a
2308   0E7E 38 00 00      mov c, 0                      ; upper LBA = 0
2309   0E81 22 01         mov ah, $01                  ; 1 sector
2310   0E83 3B 6D 27      mov d, transient_area
2311   0E86 07 43 05      call ide_read_sect            ; read directory
2312   0E89 10 00 00      mov a, 0
2313   0E8C 42 18 18      mov [index], a                ; reset file counter
2314   0E8F             fs_rm_L1:
2315   0E8F FD 4E         mov si, d
2316   0E91 FD 4F 6D 1F   mov di, user_data
2317   0E95 07 29 11      call _strcmp
2318   0E98 C6 AE 0E      je fs_rm_found_entry
2319   0E9B 58 20 00      add d, 32
2320   0E9E 14 18 18      mov a, [index]
2321   0EA1 77            inc a
2322   0EA2 42 18 18      mov [index], a
2323   0EA5 AF 10 00      cmp a, FST_FILES_PER_DIR
2324   0EA8 C6 D6 0E      je fs_rm_not_found
2325   0EAB 0A 8F 0E      jmp fs_rm_L1
2326   0EAE             fs_rm_found_entry:
2327   0EAE 2B 19 00      mov b, [d + 25]               ; get LBA
2328   0EB1 FD 79         mov g, b                      ; save LBA
2329   0EB3 19 00         mov al, 0
2330   0EB5 3E            mov [d], al                   ; make file entry NULL
2331   0EB6 14 20 18      mov a, [current_dir_id]
2332   0EB9 77            inc a                         ; metadata sector
2333   0EBA 27            mov b, a
2334   0EBB 38 00 00      mov c, 0                      ; upper LBA = 0
2335   0EBE 22 01         mov ah, $01                   ; disk write
2336   0EC0 3B 6D 27      mov d, transient_area
2337   0EC3 07 69 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2338   0EC6 3B 6D 27      mov d, transient_area  
2339   0EC9 19 00         mov al, 0
2340   0ECB 3E            mov [d], al                   ; make file's data header NULL for re-use
2341   0ECC 38 00 00      mov c, 0
2342   0ECF FD 27         mov b, g                      ; get data header LBA
2343   0ED1 22 01         mov ah, $01                   ; disk write 1 sect
2344   0ED3 07 69 05      call ide_write_sect           ; write sector
2345   0ED6             fs_rm_not_found:  
2346   0ED6 06            sysret  
2347   0ED7             
2348   0ED7             ;------------------------------------------------------------------------------------------------------;
2349   0ED7             ; mv - move / change file name
2350   0ED7             ;------------------------------------------------------------------------------------------------------;
2351   0ED7             fs_mv:
2352   0ED7 FD 4E         mov si, d
2353   0ED9 FD 4F 6D 1F   mov di, user_data
2354   0EDD 38 00 02      mov c, 512
2355   0EE0 04            load                          ; load data from user-space
2356   0EE1 14 20 18      mov a, [current_dir_id]
2357   0EE4 77            inc a                         ; metadata sector
2358   0EE5 27            mov b, a  
2359   0EE6 38 00 00      mov c, 0                      ; upper LBA = 0
2360   0EE9 22 01         mov ah, $01                  ; 1 sector
2361   0EEB 3B 6D 27      mov d, transient_area
2362   0EEE 07 43 05      call ide_read_sect            ; read directory
2363   0EF1 FD 10         cla
2364   0EF3 42 18 18      mov [index], a                ; reset file counter
2365   0EF6             fs_mv_L1:
2366   0EF6 FD 4E         mov si, d
2367   0EF8 FD 4F 6D 1F   mov di, user_data
2368   0EFC 07 29 11      call _strcmp
2369   0EFF C6 15 0F      je fs_mv_found_entry
2370   0F02 58 20 00      add d, 32
2371   0F05 14 18 18      mov a, [index]
2372   0F08 77            inc a
2373   0F09 42 18 18      mov [index], a
2374   0F0C AF 10 00      cmp a, FST_FILES_PER_DIR
2375   0F0F C6 47 0F      je fs_mv_not_found
2376   0F12 0A F6 0E      jmp fs_mv_L1
2377   0F15             fs_mv_found_entry:  
2378   0F15 DA            push d
2379   0F16 FD 4D ED 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2380   0F1A FD 50         mov di, d
2381   0F1C 07 3E 11      call _strcpy  
2382   0F1F 38 00 00      mov c, 0
2383   0F22 3B 6D 27      mov d, transient_area
2384   0F25 22 01         mov ah, $01                   ; disk write 1 sect
2385   0F27 07 69 05      call ide_write_sect           ; write sector
2386   0F2A E7            pop d
2387   0F2B             ;; need to check whether its a dir or a file here ;;;
2388   0F2B 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2389   0F2E 22 01         mov ah, $01
2390   0F30 3B 6D 27      mov d, transient_area
2391   0F33 38 00 00      mov c, 0
2392   0F36 07 43 05      call ide_read_sect            ; read directory entry
2393   0F39 FD 4D ED 1F   mov si, user_data + 128
2394   0F3D FD 50         mov di, d
2395   0F3F 07 3E 11      call _strcpy                  ; change directory's name
2396   0F42 22 01         mov ah, $01
2397   0F44 07 69 05      call ide_write_sect           ; rewrite directory back to disk
2398   0F47             fs_mv_not_found:
2399   0F47 06            sysret
2400   0F48             
2401   0F48             
2402   0F48             ;----------------------------------------------------------------------------------------------------;
2403   0F48             ; Process Index in A
2404   0F48             ;----------------------------------------------------------------------------------------------------;
2405   0F48             find_free_proc:
2406   0F48 FD 4D DE 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2407   0F4C             find_free_proc_L0:
2408   0F4C F6            lodsb                               ; get process state
2409   0F4D B9 00         cmp al, 0
2410   0F4F C6 55 0F      je find_free_proc_free              ; if free, jump
2411   0F52 0A 4C 0F      jmp find_free_proc_L0               ; else, goto next
2412   0F55             find_free_proc_free:
2413   0F55 4E            mov a, si
2414   0F56 5F DE 1C      sub a, 1 + proc_availab_table       ; get process index
2415   0F59 09            ret
2416   0F5A               
2417   0F5A             
2418   0F5A             ;----------------------------------------------------------------------------------------------------;
2419   0F5A             ; Process Index in AL
2420   0F5A             ;----------------------------------------------------------------------------------------------------;
2421   0F5A             proc_memory_map:
2422   0F5A 22 00         mov ah, 0
2423   0F5C 27            mov b, a                      ; page in BL, 0 in BH
2424   0F5D FD 9D 05      shl a, 5                      ; multiply by 32
2425   0F60 39            mov c, a                      ; save in C
2426   0F61 57 20 00      add c, 32
2427   0F64             proc_memory_map_L0:
2428   0F64 02            pagemap
2429   0F65 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2430   0F68 53 01 00      add a, 1                      ; increase both 
2431   0F6B B1            cmp a, c                      ; check to see if we reached the end of memory
2432   0F6C C7 64 0F      jne proc_memory_map_L0
2433   0F6F 09            ret
2434   0F70               
2435   0F70             
2436   0F70             ;----------------------------------------------------------------------------------------------------;
2437   0F70             ; terminate process
2438   0F70             ;----------------------------------------------------------------------------------------------------;
2439   0F70             syscall_terminate_proc:
2440   0F70 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2441   0F73                                                    ; since they will not be used for anything here.
2442   0F73 1D 17 18      mov al, [active_proc_index]
2443   0F76 22 00         mov ah, 0  
2444   0F78 FD 9D 05      shl a, 5                             ; x32
2445   0F7B 53 ED 1C      add a, proc_names
2446   0F7E 3C            mov d, a
2447   0F7F 19 00         mov al, 0
2448   0F81 3E            mov [d], al                           ; nullify process name
2449   0F82             
2450   0F82 1D 17 18      mov al, [active_proc_index]
2451   0F85 22 00         mov ah, 0  
2452   0F87 3C            mov d, a
2453   0F88 19 00         mov al, 0
2454   0F8A 3F DD 1C      mov [d + proc_availab_table], al    ; make process empty again
2455   0F8D               
2456   0F8D 1D 16 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2457   0F90 80            dec al
2458   0F91 3D 16 18      mov [nbr_active_procs], al
2459   0F94             
2460   0F94             ; now load the shell process again
2461   0F94 19 02         mov al, 2                           ; next process = process 2 = shell
2462   0F96 3D 17 18      mov [active_proc_index], al         ; set next active proc
2463   0F99             
2464   0F99             ; calculate LUT entry for next process
2465   0F99 22 00         mov ah, 0
2466   0F9B FD 99         shl a                               ; x2
2467   0F9D B7 66 10      mov a, [proc_table_convert + a]     ; get process state start index  
2468   0FA0               
2469   0FA0 4D            mov si, a                           ; source is proc state block
2470   0FA1 48            mov a, sp
2471   0FA2 5F 13 00      sub a, 19
2472   0FA5 4F            mov di, a                           ; destination is kernel stack
2473   0FA6             ; restore SP
2474   0FA6 7D            dec a
2475   0FA7 47            mov sp, a
2476   0FA8 38 14 00      mov c, 20
2477   0FAB FD F5         rep movsb
2478   0FAD             ; set VM process
2479   0FAD 1D 17 18      mov al, [active_proc_index]
2480   0FB0 01            setptb
2481   0FB1                 
2482   0FB1 4C            popa
2483   0FB2 06            sysret
2484   0FB3             
2485   0FB3             ;----------------------------------------------------------------------------------------------------;
2486   0FB3             ; pause process
2487   0FB3             ;----------------------------------------------------------------------------------------------------;
2488   0FB3             syscall_pause_proc:
2489   0FB3             ; save all registers into kernel stack
2490   0FB3 4B            pusha
2491   0FB4 22 00         mov ah, 0
2492   0FB6 1D 17 18      mov al, [active_proc_index]
2493   0FB9 FD 99         shl a              ; x2
2494   0FBB B7 66 10      mov a, [proc_table_convert + a]   ; get process state start index
2495   0FBE                 
2496   0FBE 4F            mov di, a
2497   0FBF 48            mov a, sp
2498   0FC0 77            inc a
2499   0FC1 4D            mov si, a
2500   0FC2 38 14 00      mov c, 20
2501   0FC5 FD F5         rep movsb                         ; save process state!
2502   0FC7             ; restore kernel stack position to point before interrupt arrived
2503   0FC7 51 14 00      add sp, 20
2504   0FCA             ; now load the shell process again
2505   0FCA 19 02         mov al, 2                         ; next process = process 2 = shell
2506   0FCC 3D 17 18      mov [active_proc_index], al       ; set next active proc
2507   0FCF             
2508   0FCF             ; calculate LUT entry for next process
2509   0FCF 22 00         mov ah, 0
2510   0FD1 FD 99         shl a                             ; x2
2511   0FD3 B7 66 10      mov a, [proc_table_convert + a]   ; get process state start index  
2512   0FD6               
2513   0FD6 4D            mov si, a                         ; source is proc state block
2514   0FD7 48            mov a, sp
2515   0FD8 5F 13 00      sub a, 19
2516   0FDB 4F            mov di, a                         ; destination is kernel stack
2517   0FDC             ; restore SP
2518   0FDC 7D            dec a
2519   0FDD 47            mov sp, a
2520   0FDE 38 14 00      mov c, 20
2521   0FE1 FD F5         rep movsb
2522   0FE3             ; set VM process
2523   0FE3 1D 17 18      mov al, [active_proc_index]
2524   0FE6 01            setptb
2525   0FE7                 
2526   0FE7 4C            popa
2527   0FE8 06            sysret
2528   0FE9             
2529   0FE9             ;----------------------------------------------------------------------------------------------------;
2530   0FE9             ; create a new process
2531   0FE9             ; D = path of the process file to be createed
2532   0FE9             ; B = arguments ptr
2533   0FE9             ;----------------------------------------------------------------------------------------------------;
2534   0FE9             syscall_create_proc:
2535   0FE9             ; we save the active process first  
2536   0FE9 4B            pusha
2537   0FEA 22 00         mov ah, 0
2538   0FEC 1D 17 18      mov al, [active_proc_index]
2539   0FEF FD 99         shl a              ; x2
2540   0FF1 B7 66 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2541   0FF4               
2542   0FF4 4F            mov di, a
2543   0FF5 48            mov a, sp
2544   0FF6 77            inc a
2545   0FF7 4D            mov si, a
2546   0FF8 38 14 00      mov c, 20
2547   0FFB FD F5         rep movsb                          ; save process state!
2548   0FFD             ; restore kernel stack position to point before interrupt arrived
2549   0FFD 51 14 00      add sp, 20
2550   1000               
2551   1000 FD 4E         mov si, d                          ; copy the file path
2552   1002 FD 4F 6D 1F   mov di, user_data
2553   1006 38 00 02      mov c, 512
2554   1009 04            load
2555   100A 11            mov a, b
2556   100B 4D            mov si, a                          ; copy the arguments
2557   100C FD 4F 6D 25   mov di, scrap_sector
2558   1010 38 00 02      mov c, 512
2559   1013 04            load
2560   1014 07 FB 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2561   1017                                                  ; the file data is loaded into transient_area
2562   1017             ; now we allocate a new process  
2563   1017 07 48 0F      call find_free_proc                ; index in A
2564   101A 01            setptb 
2565   101B 07 5A 0F      call proc_memory_map               ; map process memory pages
2566   101E             ; copy arguments into process's memory
2567   101E FD 4D 6D 25   mov si, scrap_sector
2568   1022 FD 4F 00 00   mov di, 0
2569   1026 38 00 02      mov c, 512
2570   1029 03            store
2571   102A             ; now copy process binary data into process's memory
2572   102A FD 4D 6D 27   mov si, transient_area
2573   102E FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2574   1032 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2575   1035 03            store                              ; copy process data
2576   1036                 
2577   1036 07 48 0F      call find_free_proc                ; index in A
2578   1039 3D 17 18      mov [active_proc_index], al        ; set new active process
2579   103C FD 9D 05      shl a, 5                           ; x32
2580   103F 53 ED 1C      add a, proc_names
2581   1042 4F            mov di, a
2582   1043 FD 4D 6D 1F   mov si, user_data                  ; copy and store process filename
2583   1047 07 3E 11      call _strcpy
2584   104A               
2585   104A 07 48 0F      call find_free_proc                ; index in A
2586   104D 3C            mov d, a
2587   104E 19 01         mov al, 1
2588   1050 3F DD 1C      mov [d + proc_availab_table], al   ; make process busy
2589   1053               
2590   1053 1D 16 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2591   1056 7A            inc al
2592   1057 3D 16 18      mov [nbr_active_procs], al
2593   105A             ; launch process
2594   105A FD D7 FF FF   push word $FFFF 
2595   105E FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2596   1061 FD D7 00 04   push word text_org
2597   1065 06            sysret
2598   1066             
2599   1066             proc_table_convert:
2600   1066 9D 1B         .dw proc_state_table + 0
2601   1068 B1 1B         .dw proc_state_table + 20
2602   106A C5 1B         .dw proc_state_table + 40
2603   106C D9 1B         .dw proc_state_table + 60
2604   106E ED 1B         .dw proc_state_table + 80
2605   1070 01 1C         .dw proc_state_table + 100
2606   1072 15 1C         .dw proc_state_table + 120
2607   1074 29 1C         .dw proc_state_table + 140
2608   1076               
2609   1076             ;----------------------------------------------------------------------------------------------;
2610   1076             ; GET HEX FILE
2611   1076             ; di = destination address
2612   1076             ; return length in bytes in C
2613   1076             ;----------------------------------------------------------------------------------------------;
2614   1076             _load_hex:
2615   1076 D7            push a
2616   1077 D8            push b
2617   1078 DA            push d
2618   1079 E2            push si
2619   107A E3            push di
2620   107B 38 00 00      mov c, 0
2621   107E 50            mov a, di
2622   107F 3C            mov d, a          ; start of string data block
2623   1080 07 C1 11      call _gets        ; get program string
2624   1083 4D            mov si, a
2625   1084             __load_hex_loop:
2626   1084 F6            lodsb             ; load from [SI] to AL
2627   1085 B9 00         cmp al, 0         ; check if ASCII 0
2628   1087 C6 95 10      jz __load_hex_ret
2629   108A 36            mov bh, al
2630   108B F6            lodsb
2631   108C 2F            mov bl, al
2632   108D 07 77 11      call _atoi        ; convert ASCII byte in B to int (to AL)
2633   1090 F7            stosb             ; store AL to [DI]
2634   1091 78            inc c
2635   1092 0A 84 10      jmp __load_hex_loop
2636   1095             __load_hex_ret:
2637   1095 F0            pop di
2638   1096 EF            pop si
2639   1097 E7            pop d
2640   1098 E5            pop b
2641   1099 E4            pop a
2642   109A 09            ret
2643   109B             
2644   109B             ; synopsis: look inside a certain directory for files/directories
2645   109B             ; before calling this function, cd into required directory
2646   109B             ; for each entry inside directory:
2647   109B             ;  if entry is a file:
2648   109B             ;    compare filename to searched filename
2649   109B             ;    if filenames are the same, print filename
2650   109B             ;  else if entry is a directory:
2651   109B             ;    cd to the given directory
2652   109B             ;    recursively call cmd_find
2653   109B             ;    cd outside previous directory
2654   109B             ;  if current entry == last entry, return
2655   109B             ; endfor
2656   109B             f_find:
2657   109B 09            ret
2658   109C             
2659   109C             
2660   109C             ; ---------------------------------------------------------------------
2661   109C             ; kernel reset vector
2662   109C             ; ---------------------------------------------------------------------
2663   109C             kernel_reset_vector:  
2664   109C FD 49 FF F7   mov bp, STACK_BEGIN
2665   10A0 FD 47 FF F7   mov sp, STACK_BEGIN
2666   10A4               
2667   10A4 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2668   10A6 FD 0F         stomsk                        
2669   10A8 FD 0C         sti  
2670   10AA             
2671   10AA 0C            lodstat
2672   10AB 87 DF         and al, %11011111             ; disable display register loading
2673   10AD 0D            stostat
2674   10AE               
2675   10AE             ; reset fifo pointers
2676   10AE 10 6D 21      mov a, fifo
2677   10B1 3B 1C 18      mov d, fifo_in
2678   10B4 43            mov [d], a
2679   10B5 3B 1E 18      mov d, fifo_out
2680   10B8 43            mov [d], a  
2681   10B9 19 02         mov al, 2
2682   10BB 05 03         syscall sys_io                ; enable uart in interrupt mode
2683   10BD               
2684   10BD 3B 71 18      mov d, s_kernel_started
2685   10C0 07 E6 12      call _puts
2686   10C3             
2687   10C3 19 10         mov al, 16
2688   10C5 05 04         syscall sys_filesystem        ; set root dirID
2689   10C7             
2690   10C7 3B 8E 18      mov d, s_prompt_init
2691   10CA 07 E6 12      call _puts
2692   10CD 3B 22 18      mov d, s_init_path
2693   10D0 05 05         syscall sys_create_proc       ; launch init as a new process
2694   10D2             
2695   10D2             
2696   10D2             ; FILE INCLUDES
2697   10D2             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  10D2             BIOS_RESET_VECTOR .EQU  $01c0
0002+  10D2             IDE_buffer       .EQU  $8204
0003+  10D2             boot_origin      .EQU  $8004
0004+  10D2             bios_uart        .EQU  $0002
0005+  10D2             bios_ide         .EQU  $0003
2698   10D2             .include "lib/stdio.asm"
0001+  10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10D2             ; stdio.s
0003+  10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10D2             .include "lib/string.asm"
0001++ 10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10D2             ; string.s
0003++ 10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10D2             
0005++ 10D2             
0006++ 10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10D2             ; _strrev
0008++ 10D2             ; reverse a string
0009++ 10D2             ; D = string address
0010++ 10D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10D2             ; 01234
0012++ 10D2             _strrev:
0013++ 10D2 4B          	pusha
0014++ 10D3 07 19 11    	call _strlen	; length in C
0015++ 10D6 12          	mov a, c
0016++ 10D7 AF 01 00    	cmp a, 1
0017++ 10DA D0 F4 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 10DD 7D          	dec a
0019++ 10DE FD 4E       	mov si, d	; beginning of string
0020++ 10E0 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 10E2 59          	add d, a	; end of string
0022++ 10E3 12          	mov a, c
0023++ 10E4 FD 9B       	shr a		; divide by 2
0024++ 10E6 39          	mov c, a	; C now counts the steps
0025++ 10E7             _strrev_L0:
0026++ 10E7 32          	mov bl, [d]	; save load right-side char into BL
0027++ 10E8 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 10E9 3E          	mov [d], al	; store left char into right side
0029++ 10EA 1B          	mov al, bl
0030++ 10EB F7          	stosb		; store right-side char into left-side; increase DI
0031++ 10EC 7E          	dec c
0032++ 10ED 7F          	dec d
0033++ 10EE C2 00 00    	cmp c, 0
0034++ 10F1 C7 E7 10    	jne _strrev_L0
0035++ 10F4             _strrev_end:
0036++ 10F4 4C          	popa
0037++ 10F5 09          	ret
0038++ 10F6             	
0039++ 10F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10F6             ; _strchr
0041++ 10F6             ; search string in D for char in AL
0042++ 10F6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10F6             _strchr:
0044++ 10F6             _strchr_L0:
0045++ 10F6 32          	mov bl, [d]
0046++ 10F7 C1 00       	cmp bl, 0
0047++ 10F9 C6 04 11    	je _strchr_end
0048++ 10FC BA          	cmp al, bl
0049++ 10FD C6 04 11    	je _strchr_end
0050++ 1100 79          	inc d
0051++ 1101 0A F6 10    	jmp _strchr_L0
0052++ 1104             _strchr_end:
0053++ 1104 1B          	mov al, bl
0054++ 1105 09          	ret
0055++ 1106             
0056++ 1106             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 1106             ; _strstr
0058++ 1106             ; find sub-string
0059++ 1106             ; str1 in SI
0060++ 1106             ; str2 in DI
0061++ 1106             ; SI points to end of source string
0062++ 1106             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 1106             _strstr:
0064++ 1106 DB          	push al
0065++ 1107 DA          	push d
0066++ 1108 E3          	push di
0067++ 1109             _strstr_loop:
0068++ 1109 F3          	cmpsb					; compare a byte of the strings
0069++ 110A C7 15 11    	jne _strstr_ret
0070++ 110D FC 00 00    	lea d, [di + 0]
0071++ 1110 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1112 C7 09 11    	jne _strstr_loop				; equal chars but not at end
0073++ 1115             _strstr_ret:
0074++ 1115 F0          	pop di
0075++ 1116 E7          	pop d
0076++ 1117 E8          	pop al
0077++ 1118 09          	ret
0078++ 1119             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1119             ; length of null terminated string
0080++ 1119             ; result in C
0081++ 1119             ; pointer in D
0082++ 1119             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1119             _strlen:
0084++ 1119 DA          	push d
0085++ 111A 38 00 00    	mov c, 0
0086++ 111D             _strlen_L1:
0087++ 111D BD 00       	cmp byte [d], 0
0088++ 111F C6 27 11    	je _strlen_ret
0089++ 1122 79          	inc d
0090++ 1123 78          	inc c
0091++ 1124 0A 1D 11    	jmp _strlen_L1
0092++ 1127             _strlen_ret:
0093++ 1127 E7          	pop d
0094++ 1128 09          	ret
0095++ 1129             
0096++ 1129             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1129             ; STRCMP
0098++ 1129             ; compare two strings
0099++ 1129             ; str1 in SI
0100++ 1129             ; str2 in DI
0101++ 1129             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 1129             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1129             _strcmp:
0104++ 1129 DB          	push al
0105++ 112A DA          	push d
0106++ 112B E3          	push di
0107++ 112C E2          	push si
0108++ 112D             _strcmp_loop:
0109++ 112D F3          	cmpsb					; compare a byte of the strings
0110++ 112E C7 39 11    	jne _strcmp_ret
0111++ 1131 FB FF FF    	lea d, [si +- 1]
0112++ 1134 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 1136 C7 2D 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1139             _strcmp_ret:
0115++ 1139 EF          	pop si
0116++ 113A F0          	pop di
0117++ 113B E7          	pop d
0118++ 113C E8          	pop al
0119++ 113D 09          	ret
0120++ 113E             
0121++ 113E             
0122++ 113E             ; STRCPY
0123++ 113E             ; copy null terminated string from SI to DI
0124++ 113E             ; source in SI
0125++ 113E             ; destination in DI
0126++ 113E             _strcpy:
0127++ 113E E2          	push si
0128++ 113F E3          	push di
0129++ 1140 DB          	push al
0130++ 1141             _strcpy_L1:
0131++ 1141 F6          	lodsb
0132++ 1142 F7          	stosb
0133++ 1143 B9 00       	cmp al, 0
0134++ 1145 C7 41 11    	jne _strcpy_L1
0135++ 1148             _strcpy_end:
0136++ 1148 E8          	pop al
0137++ 1149 F0          	pop di
0138++ 114A EF          	pop si
0139++ 114B 09          	ret
0140++ 114C             
0141++ 114C             ; STRCAT
0142++ 114C             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 114C             ; source in SI
0144++ 114C             ; destination in DI
0145++ 114C             _strcat:
0146++ 114C E2          	push si
0147++ 114D E3          	push di
0148++ 114E D7          	push a
0149++ 114F DA          	push d
0150++ 1150 50          	mov a, di
0151++ 1151 3C          	mov d, a
0152++ 1152             _strcat_goto_end_L1:
0153++ 1152 BD 00       	cmp byte[d], 0
0154++ 1154 C6 5B 11    	je _strcat_start
0155++ 1157 79          	inc d
0156++ 1158 0A 52 11    	jmp _strcat_goto_end_L1
0157++ 115B             _strcat_start:
0158++ 115B FD 50       	mov di, d
0159++ 115D             _strcat_L1:
0160++ 115D F6          	lodsb
0161++ 115E F7          	stosb
0162++ 115F B9 00       	cmp al, 0
0163++ 1161 C7 5D 11    	jne _strcat_L1
0164++ 1164             _strcat_end:
0165++ 1164 E7          	pop d
0166++ 1165 E4          	pop a
0167++ 1166 F0          	pop di
0168++ 1167 EF          	pop si
0169++ 1168 09          	ret
0170++ 1169             
0171++ 1169             
0005+  1169             
0006+  1169             
0007+  1169             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1169             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1169             ; ASCII in BL
0010+  1169             ; result in AL
0011+  1169             ; ascii for F = 0100 0110
0012+  1169             ; ascii for 9 = 0011 1001
0013+  1169             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1169             hex_ascii_encode:
0015+  1169 1B            mov al, bl
0016+  116A 93 40         test al, $40        ; test if letter or number
0017+  116C C7 72 11      jnz hex_letter
0018+  116F 87 0F         and al, $0F        ; get number
0019+  1171 09            ret
0020+  1172             hex_letter:
0021+  1172 87 0F         and al, $0F        ; get letter
0022+  1174 6A 09         add al, 9
0023+  1176 09            ret
0024+  1177             
0025+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1177             ; ATOI
0027+  1177             ; 2 letter hex string in B
0028+  1177             ; 8bit integer returned in AL
0029+  1177             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1177             _atoi:
0031+  1177 D8            push b
0032+  1178 07 69 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  117B 30            mov bl, bh
0034+  117C DB            push al          ; save a
0035+  117D 07 69 11      call hex_ascii_encode
0036+  1180 EA            pop bl  
0037+  1181 FD 9E 04      shl al, 4
0038+  1184 8C            or al, bl
0039+  1185 E5            pop b
0040+  1186 09            ret  
0041+  1187             
0042+  1187             
0043+  1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1187             ; scanf
0045+  1187             ; no need for explanations!
0046+  1187             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1187             scanf:
0048+  1187 09            ret
0049+  1188             
0050+  1188             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1188             ; ITOA
0052+  1188             ; 8bit value in BL
0053+  1188             ; 2 byte ASCII result in A
0054+  1188             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1188             _itoa:
0056+  1188 DA            push d
0057+  1189 D8            push b
0058+  118A A7 00         mov bh, 0
0059+  118C FD A4 04      shr bl, 4  
0060+  118F 74            mov d, b
0061+  1190 1F 22 14      mov al, [d + s_hex_digits]
0062+  1193 23            mov ah, al
0063+  1194               
0064+  1194 E5            pop b
0065+  1195 D8            push b
0066+  1196 A7 00         mov bh, 0
0067+  1198 FD 87 0F      and bl, $0F
0068+  119B 74            mov d, b
0069+  119C 1F 22 14      mov al, [d + s_hex_digits]
0070+  119F E5            pop b
0071+  11A0 E7            pop d
0072+  11A1 09            ret
0073+  11A2             
0074+  11A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11A2             ; HEX STRING TO BINARY
0076+  11A2             ; di = destination address
0077+  11A2             ; si = source
0078+  11A2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11A2             _hex_to_int:
0080+  11A2             _hex_to_int_L1:
0081+  11A2 F6            lodsb          ; load from [SI] to AL
0082+  11A3 B9 00         cmp al, 0        ; check if ASCII 0
0083+  11A5 C6 B2 11      jz _hex_to_int_ret
0084+  11A8 36            mov bh, al
0085+  11A9 F6            lodsb
0086+  11AA 2F            mov bl, al
0087+  11AB 07 77 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  11AE F7            stosb          ; store AL to [DI]
0089+  11AF 0A A2 11      jmp _hex_to_int_L1
0090+  11B2             _hex_to_int_ret:
0091+  11B2 09            ret    
0092+  11B3             
0093+  11B3             
0094+  11B3             
0095+  11B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11B3             ; GETCHAR
0097+  11B3             ; char in ah
0098+  11B3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11B3             getch:
0100+  11B3 DB            push al
0101+  11B4             getch_retry:
0102+  11B4 19 01         mov al, 1
0103+  11B6 05 03         syscall sys_io      ; receive in AH
0104+  11B8 E8            pop al
0105+  11B9 09            ret
0106+  11BA             
0107+  11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11BA             ; PUTCHAR
0109+  11BA             ; char in ah
0110+  11BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11BA             _putchar:
0112+  11BA DB            push al
0113+  11BB 19 00         mov al, 0
0114+  11BD 05 03         syscall sys_io      ; char in AH
0115+  11BF E8            pop al
0116+  11C0 09            ret
0117+  11C1             
0118+  11C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11C1             ;; INPUT A STRING
0120+  11C1             ;; terminates with null
0121+  11C1             ;; pointer in D
0122+  11C1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11C1             _gets:
0124+  11C1 D7            push a
0125+  11C2 DA            push d
0126+  11C3             _gets_loop:
0127+  11C3 19 01         mov al, 1
0128+  11C5 05 03         syscall sys_io      ; receive in AH
0129+  11C7 76 1B         cmp ah, 27
0130+  11C9 C6 EA 11      je _gets_ansi_esc
0131+  11CC 76 0A         cmp ah, $0A        ; LF
0132+  11CE C6 46 12      je _gets_end
0133+  11D1 76 0D         cmp ah, $0D        ; CR
0134+  11D3 C6 46 12      je _gets_end
0135+  11D6 76 5C         cmp ah, $5C        ; '\\'
0136+  11D8 C6 0C 12      je _gets_escape
0137+  11DB 76 08         cmp ah, $08      ; check for backspace
0138+  11DD C6 E6 11      je _gets_backspace
0139+  11E0 1A            mov al, ah
0140+  11E1 3E            mov [d], al
0141+  11E2 79            inc d
0142+  11E3 0A C3 11      jmp _gets_loop
0143+  11E6             _gets_backspace:
0144+  11E6 7F            dec d
0145+  11E7 0A C3 11      jmp _gets_loop
0146+  11EA             _gets_ansi_esc:
0147+  11EA 19 01         mov al, 1
0148+  11EC 05 03         syscall sys_io        ; receive in AH without echo
0149+  11EE 76 5B         cmp ah, '['
0150+  11F0 C7 C3 11      jne _gets_loop
0151+  11F3 19 01         mov al, 1
0152+  11F5 05 03         syscall sys_io          ; receive in AH without echo
0153+  11F7 76 44         cmp ah, 'D'
0154+  11F9 C6 04 12      je _gets_left_arrow
0155+  11FC 76 43         cmp ah, 'C'
0156+  11FE C6 08 12      je _gets_right_arrow
0157+  1201 0A C3 11      jmp _gets_loop
0158+  1204             _gets_left_arrow:
0159+  1204 7F            dec d
0160+  1205 0A C3 11      jmp _gets_loop
0161+  1208             _gets_right_arrow:
0162+  1208 79            inc d
0163+  1209 0A C3 11      jmp _gets_loop
0164+  120C             _gets_escape:
0165+  120C 19 01         mov al, 1
0166+  120E 05 03         syscall sys_io      ; receive in AH
0167+  1210 76 6E         cmp ah, 'n'
0168+  1212 C6 31 12      je _gets_LF
0169+  1215 76 72         cmp ah, 'r'
0170+  1217 C6 38 12      je _gets_CR
0171+  121A 76 30         cmp ah, '0'
0172+  121C C6 3F 12      je _gets_NULL
0173+  121F 76 5C         cmp ah, $5C  ; '\'
0174+  1221 C6 2A 12      je _gets_slash
0175+  1224 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  1225 3E            mov [d], al
0177+  1226 79            inc d
0178+  1227 0A C3 11      jmp _gets_loop
0179+  122A             _gets_slash:
0180+  122A 19 5C         mov al, $5C
0181+  122C 3E            mov [d], al
0182+  122D 79            inc d
0183+  122E 0A C3 11      jmp _gets_loop
0184+  1231             _gets_LF:
0185+  1231 19 0A         mov al, $0A
0186+  1233 3E            mov [d], al
0187+  1234 79            inc d
0188+  1235 0A C3 11      jmp _gets_loop
0189+  1238             _gets_CR:
0190+  1238 19 0D         mov al, $0D
0191+  123A 3E            mov [d], al
0192+  123B 79            inc d
0193+  123C 0A C3 11      jmp _gets_loop
0194+  123F             _gets_NULL:
0195+  123F 19 00         mov al, $00
0196+  1241 3E            mov [d], al
0197+  1242 79            inc d
0198+  1243 0A C3 11      jmp _gets_loop
0199+  1246             _gets_end:
0200+  1246 19 00         mov al, 0
0201+  1248 3E            mov [d], al        ; terminate string
0202+  1249 E7            pop d
0203+  124A E4            pop a
0204+  124B 09            ret
0205+  124C             
0206+  124C             
0207+  124C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  124C             ;; INPUT TEXT
0209+  124C             ;; terminated with CTRL+D
0210+  124C             ;; pointer in D
0211+  124C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  124C             _gettxt:
0213+  124C D7            push a
0214+  124D DA            push d
0215+  124E             _gettxt_loop:
0216+  124E 19 01         mov al, 1
0217+  1250 05 03         syscall sys_io      ; receive in AH
0218+  1252 76 04         cmp ah, 4      ; EOT
0219+  1254 C6 8D 12      je _gettxt_end
0220+  1257 76 08         cmp ah, $08      ; check for backspace
0221+  1259 C6 89 12      je _gettxt_backspace
0222+  125C 76 5C         cmp ah, $5C        ; '\'
0223+  125E C6 67 12      je _gettxt_escape
0224+  1261 1A            mov al, ah
0225+  1262 3E            mov [d], al
0226+  1263 79            inc d
0227+  1264 0A 4E 12      jmp _gettxt_loop
0228+  1267             _gettxt_escape:
0229+  1267 19 01         mov al, 1
0230+  1269 05 03         syscall sys_io      ; receive in AH
0231+  126B 76 6E         cmp ah, 'n'
0232+  126D C6 7B 12      je _gettxt_LF
0233+  1270 76 72         cmp ah, 'r'
0234+  1272 C6 82 12      je _gettxt_CR
0235+  1275 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1276 3E            mov [d], al
0237+  1277 79            inc d
0238+  1278 0A 4E 12      jmp _gettxt_loop
0239+  127B             _gettxt_LF:
0240+  127B 19 0A         mov al, $0A
0241+  127D 3E            mov [d], al
0242+  127E 79            inc d
0243+  127F 0A 4E 12      jmp _gettxt_loop
0244+  1282             _gettxt_CR:
0245+  1282 19 0D         mov al, $0D
0246+  1284 3E            mov [d], al
0247+  1285 79            inc d
0248+  1286 0A 4E 12      jmp _gettxt_loop
0249+  1289             _gettxt_backspace:
0250+  1289 7F            dec d
0251+  128A 0A 4E 12      jmp _gettxt_loop
0252+  128D             _gettxt_end:
0253+  128D 19 00         mov al, 0
0254+  128F 3E            mov [d], al        ; terminate string
0255+  1290 E7            pop d
0256+  1291 E4            pop a
0257+  1292 09            ret
0258+  1293             
0259+  1293             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  1293             ; PRINT NEW LINE
0261+  1293             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  1293             printnl:
0263+  1293 D7            push a
0264+  1294 10 00 0A      mov a, $0A00
0265+  1297 05 03         syscall sys_io
0266+  1299 10 00 0D      mov a, $0D00
0267+  129C 05 03         syscall sys_io
0268+  129E E4            pop a
0269+  129F 09            ret
0270+  12A0             
0271+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  12A0             ; _strtoint
0273+  12A0             ; 4 digit hex string number in d
0274+  12A0             ; integer returned in A
0275+  12A0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12A0             _strtointx:
0277+  12A0 D8            push b
0278+  12A1 32            mov bl, [d]
0279+  12A2 37            mov bh, bl
0280+  12A3 33 01 00      mov bl, [d + 1]
0281+  12A6 07 77 11      call _atoi        ; convert to int in AL
0282+  12A9 23            mov ah, al        ; move to AH
0283+  12AA 33 02 00      mov bl, [d + 2]
0284+  12AD 37            mov bh, bl
0285+  12AE 33 03 00      mov bl, [d + 3]
0286+  12B1 07 77 11      call _atoi        ; convert to int in AL
0287+  12B4 E5            pop b
0288+  12B5 09            ret
0289+  12B6             
0290+  12B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  12B6             ; _strtoint
0292+  12B6             ; 5 digit base10 string number in d
0293+  12B6             ; integer returned in A
0294+  12B6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  12B6             _strtoint:
0296+  12B6 E2            push si
0297+  12B7 D8            push b
0298+  12B8 D9            push c
0299+  12B9 DA            push d
0300+  12BA 07 19 11      call _strlen      ; get string length in C
0301+  12BD 7E            dec c
0302+  12BE FD 4E         mov si, d
0303+  12C0 12            mov a, c
0304+  12C1 FD 99         shl a
0305+  12C3 3B 3A 14      mov d, table_power
0306+  12C6 59            add d, a
0307+  12C7 38 00 00      mov c, 0
0308+  12CA             _strtoint_L0:
0309+  12CA F6            lodsb      ; load ASCII to al
0310+  12CB B9 00         cmp al, 0
0311+  12CD C6 E0 12      je _strtoint_end
0312+  12D0 6F 30         sub al, $30    ; make into integer
0313+  12D2 22 00         mov ah, 0
0314+  12D4 2A            mov b, [d]
0315+  12D5 AC            mul a, b      ; result in B since it fits in 16bits
0316+  12D6 11            mov a, b
0317+  12D7 28            mov b, c
0318+  12D8 54            add a, b
0319+  12D9 39            mov c, a
0320+  12DA 63 02 00      sub d, 2
0321+  12DD 0A CA 12      jmp _strtoint_L0
0322+  12E0             _strtoint_end:
0323+  12E0 12            mov a, c
0324+  12E1 E7            pop d
0325+  12E2 E6            pop c
0326+  12E3 E5            pop b
0327+  12E4 EF            pop si
0328+  12E5 09            ret
0329+  12E6             
0330+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  12E6             ; PRINT NULL TERMINATED STRING
0332+  12E6             ; pointer in D
0333+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  12E6             _puts:
0335+  12E6 D7            push a
0336+  12E7 DA            push d
0337+  12E8             _puts_L1:
0338+  12E8 1E            mov al, [d]
0339+  12E9 B9 00         cmp al, 0
0340+  12EB C6 F7 12      jz _puts_END
0341+  12EE 23            mov ah, al
0342+  12EF 19 00         mov al, 0
0343+  12F1 05 03         syscall sys_io
0344+  12F3 79            inc d
0345+  12F4 0A E8 12      jmp _puts_L1
0346+  12F7             _puts_END:
0347+  12F7 E7            pop d
0348+  12F8 E4            pop a
0349+  12F9 09            ret
0350+  12FA             
0351+  12FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12FA             ; PRINT N SIZE STRING
0353+  12FA             ; pointer in D
0354+  12FA             ; size in C
0355+  12FA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12FA             _putsn:
0357+  12FA DB            push al
0358+  12FB DA            push d
0359+  12FC D9            push c
0360+  12FD             _putsn_L0:
0361+  12FD 1E            mov al, [d]
0362+  12FE 23            mov ah, al
0363+  12FF 19 00         mov al, 0
0364+  1301 05 03         syscall sys_io
0365+  1303 79            inc d
0366+  1304 7E            dec c  
0367+  1305 C2 00 00      cmp c, 0
0368+  1308 C7 FD 12      jne _putsn_L0
0369+  130B             _putsn_end:
0370+  130B E6            pop c
0371+  130C E7            pop d
0372+  130D E8            pop al
0373+  130E 09            ret
0374+  130F             
0375+  130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  130F             ; print 16bit decimal number
0377+  130F             ; input number in A
0378+  130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  130F             print_u16d:
0380+  130F D7            push a
0381+  1310 D8            push b
0382+  1311 FD D8         push g
0383+  1313 26 10 27      mov b, 10000
0384+  1316 AE            div a, b      ; get 10000's coeff.
0385+  1317 07 3B 13      call print_number
0386+  131A 11            mov a, b
0387+  131B 26 E8 03      mov b, 1000
0388+  131E AE            div a, b      ; get 1000's coeff.
0389+  131F 07 3B 13      call print_number
0390+  1322 11            mov a, b
0391+  1323 26 64 00      mov b, 100
0392+  1326 AE            div a, b
0393+  1327 07 3B 13      call print_number
0394+  132A 11            mov a, b
0395+  132B 26 0A 00      mov b, 10
0396+  132E AE            div a, b
0397+  132F 07 3B 13      call print_number
0398+  1332 1B            mov al, bl      ; 1's coeff in bl
0399+  1333 07 3B 13      call print_number
0400+  1336 FD F1         pop g
0401+  1338 E5            pop b
0402+  1339 E4            pop a
0403+  133A 09            ret
0404+  133B             
0405+  133B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  133B             ; print AL
0407+  133B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  133B             print_number:
0409+  133B 6A 30         add al, $30
0410+  133D 23            mov ah, al
0411+  133E 07 BA 11      call _putchar
0412+  1341 09            ret
0413+  1342             
0414+  1342             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1342             ; PRINT 16BIT HEX INTEGER
0416+  1342             ; integer value in reg B
0417+  1342             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1342             print_u16x:
0419+  1342 D7            push a
0420+  1343 D8            push b
0421+  1344 DD            push bl
0422+  1345 30            mov bl, bh
0423+  1346 07 88 11      call _itoa        ; convert bh to char in A
0424+  1349 2F            mov bl, al        ; save al
0425+  134A 19 00         mov al, 0
0426+  134C 05 03         syscall sys_io        ; display AH
0427+  134E 24            mov ah, bl        ; retrieve al
0428+  134F 19 00         mov al, 0
0429+  1351 05 03         syscall sys_io        ; display AL
0430+  1353             
0431+  1353 EA            pop bl
0432+  1354 07 88 11      call _itoa        ; convert bh to char in A
0433+  1357 2F            mov bl, al        ; save al
0434+  1358 19 00         mov al, 0
0435+  135A 05 03         syscall sys_io        ; display AH
0436+  135C 24            mov ah, bl        ; retrieve al
0437+  135D 19 00         mov al, 0
0438+  135F 05 03         syscall sys_io        ; display AL
0439+  1361             
0440+  1361 E5            pop b
0441+  1362 E4            pop a
0442+  1363 09            ret
0443+  1364             
0444+  1364             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  1364             ; INPUT 16BIT HEX INTEGER
0446+  1364             ; read 16bit integer into A
0447+  1364             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  1364             scan_u16x:
0449+  1364 F8 10 00      enter 16
0450+  1367 D8            push b
0451+  1368 DA            push d
0452+  1369             
0453+  1369 FA F1 FF      lea d, [bp + -15]
0454+  136C 07 C1 11      call _gets        ; get number
0455+  136F             
0456+  136F 32            mov bl, [d]
0457+  1370 37            mov bh, bl
0458+  1371 33 01 00      mov bl, [d + 1]
0459+  1374 07 77 11      call _atoi        ; convert to int in AL
0460+  1377 23            mov ah, al        ; move to AH
0461+  1378             
0462+  1378 33 02 00      mov bl, [d + 2]
0463+  137B 37            mov bh, bl
0464+  137C 33 03 00      mov bl, [d + 3]
0465+  137F 07 77 11      call _atoi        ; convert to int in AL
0466+  1382             
0467+  1382 E7            pop d
0468+  1383 E5            pop b
0469+  1384 F9            leave
0470+  1385 09            ret
0471+  1386             
0472+  1386             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1386             ; PRINT 8bit HEX INTEGER
0474+  1386             ; integer value in reg bl
0475+  1386             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1386             print_u8x:
0477+  1386 D7            push a
0478+  1387 DD            push bl
0479+  1388             
0480+  1388 07 88 11      call _itoa        ; convert bl to char in A
0481+  138B 2F            mov bl, al        ; save al
0482+  138C 19 00         mov al, 0
0483+  138E 05 03         syscall sys_io        ; display AH
0484+  1390 24            mov ah, bl        ; retrieve al
0485+  1391 19 00         mov al, 0
0486+  1393 05 03         syscall sys_io        ; display AL
0487+  1395             
0488+  1395 EA            pop bl
0489+  1396 E4            pop a
0490+  1397 09            ret
0491+  1398             
0492+  1398             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1398             ; print 8bit decimal unsigned number
0494+  1398             ; input number in AL
0495+  1398             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1398             print_u8d:
0497+  1398 D7            push a
0498+  1399 D8            push b
0499+  139A FD D8         push g
0500+  139C 22 00         mov ah, 0
0501+  139E 26 64 00      mov b, 100
0502+  13A1 AE            div a, b
0503+  13A2 D8            push b      ; save remainder
0504+  13A3 B9 00         cmp al, 0
0505+  13A5 C6 AF 13      je skip100
0506+  13A8 6A 30         add al, $30
0507+  13AA 23            mov ah, al
0508+  13AB 19 00         mov al, 0
0509+  13AD 05 03         syscall sys_io  ; print coeff
0510+  13AF             skip100:
0511+  13AF E4            pop a
0512+  13B0 22 00         mov ah, 0
0513+  13B2 26 0A 00      mov b, 10
0514+  13B5 AE            div a, b
0515+  13B6 D8            push b      ; save remainder
0516+  13B7 B9 00         cmp al, 0
0517+  13B9 C6 C3 13      je skip10
0518+  13BC 6A 30         add al, $30
0519+  13BE 23            mov ah, al
0520+  13BF 19 00         mov al, 0
0521+  13C1 05 03         syscall sys_io  ; print coeff
0522+  13C3             skip10:
0523+  13C3 E4            pop a
0524+  13C4 1B            mov al, bl
0525+  13C5 6A 30         add al, $30
0526+  13C7 23            mov ah, al
0527+  13C8 19 00         mov al, 0
0528+  13CA 05 03         syscall sys_io  ; print coeff
0529+  13CC FD F1         pop g
0530+  13CE E5            pop b
0531+  13CF E4            pop a
0532+  13D0 09            ret
0533+  13D1             
0534+  13D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  13D1             ; INPUT 8BIT HEX INTEGER
0536+  13D1             ; read 8bit integer into AL
0537+  13D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  13D1             scan_u8x:
0539+  13D1 F8 04 00      enter 4
0540+  13D4 D8            push b
0541+  13D5 DA            push d
0542+  13D6             
0543+  13D6 FA FD FF      lea d, [bp + -3]
0544+  13D9 07 C1 11      call _gets        ; get number
0545+  13DC             
0546+  13DC 32            mov bl, [d]
0547+  13DD 37            mov bh, bl
0548+  13DE 33 01 00      mov bl, [d + 1]
0549+  13E1 07 77 11      call _atoi        ; convert to int in AL
0550+  13E4             
0551+  13E4 E7            pop d
0552+  13E5 E5            pop b
0553+  13E6 F9            leave
0554+  13E7 09            ret
0555+  13E8             
0556+  13E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  13E8             ; input decimal number
0558+  13E8             ; result in A
0559+  13E8             ; 655'\0'
0560+  13E8             ; low--------high
0561+  13E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  13E8             scan_u16d:
0563+  13E8 F8 08 00      enter 8
0564+  13EB E2            push si
0565+  13EC D8            push b
0566+  13ED D9            push c
0567+  13EE DA            push d
0568+  13EF FA F9 FF      lea d, [bp +- 7]
0569+  13F2 07 C1 11      call _gets
0570+  13F5 07 19 11      call _strlen      ; get string length in C
0571+  13F8 7E            dec c
0572+  13F9 FD 4E         mov si, d
0573+  13FB 12            mov a, c
0574+  13FC FD 99         shl a
0575+  13FE 3B 3A 14      mov d, table_power
0576+  1401 59            add d, a
0577+  1402 38 00 00      mov c, 0
0578+  1405             mul_loop:
0579+  1405 F6            lodsb      ; load ASCII to al
0580+  1406 B9 00         cmp al, 0
0581+  1408 C6 1B 14      je mul_exit
0582+  140B 6F 30         sub al, $30    ; make into integer
0583+  140D 22 00         mov ah, 0
0584+  140F 2A            mov b, [d]
0585+  1410 AC            mul a, b      ; result in B since it fits in 16bits
0586+  1411 11            mov a, b
0587+  1412 28            mov b, c
0588+  1413 54            add a, b
0589+  1414 39            mov c, a
0590+  1415 63 02 00      sub d, 2
0591+  1418 0A 05 14      jmp mul_loop
0592+  141B             mul_exit:
0593+  141B 12            mov a, c
0594+  141C E7            pop d
0595+  141D E6            pop c
0596+  141E E5            pop b
0597+  141F EF            pop si
0598+  1420 F9            leave
0599+  1421 09            ret
0600+  1422             
0601+  1422             
0602+  1422 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  1426 34 35 36 37 
0602+  142A 38 39 41 42 
0602+  142E 43 44 45 46 
0603+  1432 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  1436 1B 5B 48 00 
0604+  143A             
0605+  143A             table_power:
0606+  143A 01 00         .dw 1
0607+  143C 0A 00         .dw 10
0608+  143E 64 00         .dw 100
0609+  1440 E8 03         .dw 1000
0610+  1442 10 27         .dw 100002699   1444             .include "lib/ctype.asm"
0001+  1444             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  1444             ; ctype.s
0003+  1444             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  1444             
0005+  1444             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  1444             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  1444             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  1444             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  1444             ;; characters are supported.
0010+  1444             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  1444             ;; _isalnum 
0012+  1444             ;; _isalpha 
0013+  1444             ;; islower 
0014+  1444             ;; isupper 
0015+  1444             ;; _isdigit 
0016+  1444             ;; isxdigit
0017+  1444             ;; iscntrl 
0018+  1444             ;; isgraph 
0019+  1444             ;; _isspace 
0020+  1444             ;; isblank 
0021+  1444             ;; isprint 
0022+  1444             ;; ispunct 
0023+  1444             ;; tolower 
0024+  1444             ;; toupper
0025+  1444             
0026+  1444             
0027+  1444             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  1444             ;; IS ALPHANUMERIC
0029+  1444             ;; sets ZF according with result
0030+  1444             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  1444             _isalnum:
0032+  1444 07 61 14    	call _isalpha
0033+  1447 C6 4D 14    	je _isalnum_exit
0034+  144A 07 4E 14    	call _isdigit
0035+  144D             _isalnum_exit:
0036+  144D 09          	ret	
0037+  144E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  144E             ;; IS DIGIT
0039+  144E             ;; sets ZF according with result
0040+  144E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  144E             _isdigit:
0042+  144E DB          	push al
0043+  144F B9 30       	cmp al, '0'
0044+  1451 C8 5D 14    	jlu _isdigit_false
0045+  1454 B9 39       	cmp al, '9'
0046+  1456 D1 5D 14    	jgu _isdigit_false
0047+  1459 87 00       	and al, 0	; set ZF
0048+  145B E8          	pop al
0049+  145C 09          	ret
0050+  145D             _isdigit_false:
0051+  145D 8B 01       	or al, 1	; clear ZF
0052+  145F E8          	pop al
0053+  1460 09          	ret	
0054+  1461             	
0055+  1461             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1461             ;; IS ALPHA
0057+  1461             ;; sets ZF according with result
0058+  1461             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1461             _isalpha:
0060+  1461 DB          	push al
0061+  1462 B9 5F       	cmp al, '_'
0062+  1464 C6 84 14    	je _isalpha_true
0063+  1467 B9 2E       	cmp al, '.'
0064+  1469 C6 84 14    	je _isalpha_true
0065+  146C B9 41       	cmp al, 'A'
0066+  146E C8 80 14    	jlu _isalpha_false
0067+  1471 B9 7A       	cmp al, 'z'
0068+  1473 D1 80 14    	jgu _isalpha_false
0069+  1476 B9 5A       	cmp al, 'Z'
0070+  1478 D0 84 14    	jleu _isalpha_true
0071+  147B B9 61       	cmp al, 'a'
0072+  147D C9 84 14    	jgeu _isalpha_true
0073+  1480             _isalpha_false:
0074+  1480 8B 01       	or al, 1	; clear ZF
0075+  1482 E8          	pop al
0076+  1483 09          	ret
0077+  1484             _isalpha_true:
0078+  1484 87 00       	and al, 0	; set ZF
0079+  1486 E8          	pop al
0080+  1487 09          	ret
0081+  1488             
0082+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1488             ;; IS PATH-ALPHA
0084+  1488             ;; sets ZF according with result
0085+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1488             ispath:
0087+  1488 DB          	push al
0088+  1489 07 4E 14    	call _isdigit
0089+  148C C6 B6 14    	je ispath_true
0090+  148F B9 5F       	cmp al, '_'
0091+  1491 C6 B6 14    	je ispath_true
0092+  1494 B9 2F       	cmp al, '/'
0093+  1496 C6 B6 14    	je ispath_true
0094+  1499 B9 2E       	cmp al, '.'
0095+  149B C6 B6 14    	je ispath_true
0096+  149E B9 41       	cmp al, 'A'
0097+  14A0 C8 B2 14    	jlu ispath_false
0098+  14A3 B9 7A       	cmp al, 'z'
0099+  14A5 D1 B2 14    	jgu ispath_false
0100+  14A8 B9 5A       	cmp al, 'Z'
0101+  14AA D0 B6 14    	jleu ispath_true
0102+  14AD B9 61       	cmp al, 'a'
0103+  14AF C9 B6 14    	jgeu ispath_true
0104+  14B2             ispath_false:
0105+  14B2 8B 01       	or al, 1	; clear ZF
0106+  14B4 E8          	pop al
0107+  14B5 09          	ret
0108+  14B6             ispath_true:
0109+  14B6 87 00       	and al, 0	; set ZF
0110+  14B8 E8          	pop al
0111+  14B9 09          	ret
0112+  14BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14BA             ;; IS SPACE
0114+  14BA             ;; sets ZF according with result
0115+  14BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14BA             _isspace:
0117+  14BA B9 20       	cmp al, $20		; ' '
0118+  14BC C6 D0 14    	je _isspace_exit
0119+  14BF B9 09       	cmp al, $09		; '\t'
0120+  14C1 C6 D0 14    	je _isspace_exit
0121+  14C4 B9 0A       	cmp al, $0A		; '\n'
0122+  14C6 C6 D0 14    	je _isspace_exit
0123+  14C9 B9 0D       	cmp al, $0D		; '\r'
0124+  14CB C6 D0 14    	je _isspace_exit
0125+  14CE B9 0B       	cmp al, $0B		; '\v'
0126+  14D0             _isspace_exit:
0127+  14D0 09          	ret	
0128+  14D1             
0129+  14D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  14D1             ; TO LOWER
0131+  14D1             ; input in AL
0132+  14D1             ; output in AL
0133+  14D1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  14D1             _to_lower:
0135+  14D1 B9 5A       	cmp al, 'Z'
0136+  14D3 D1 D8 14    	jgu _to_lower_ret
0137+  14D6 6A 20       	add al, $20				; convert to lower case
0138+  14D8             _to_lower_ret:
0139+  14D8 09          	ret
0140+  14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  14D9             ; TO UPPER
0142+  14D9             ; input in AL
0143+  14D9             ; output in AL
0144+  14D9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  14D9             _to_upper:
0146+  14D9 B9 61       	cmp al, 'a'
0147+  14DB C8 E0 14    	jlu _to_upper_ret
0148+  14DE 6F 20       	sub al, $20			; convert to upper case
0149+  14E0             _to_upper_ret:
0150+  14E0 09          	ret
0151+  14E1             
2700   14E1             .include "lib/token.asm"
0001+  14E1             TOKTYP_IDENTIFIER  .equ 0
0002+  14E1             TOKTYP_KEYWORD     .equ 1
0003+  14E1             TOKTYP_DELIMITER   .equ 2
0004+  14E1             TOKTYP_STRING      .equ 3
0005+  14E1             TOKTYP_CHAR        .equ 4
0006+  14E1             TOKTYP_NUMERIC     .equ 5
0007+  14E1             TOKTYP_END         .equ 6
0008+  14E1             
0009+  14E1             TOK_NULL           .equ 0
0010+  14E1             TOK_FSLASH         .equ 1
0011+  14E1             TOK_TIMES          .equ 2
0012+  14E1             TOK_PLUS           .equ 3
0013+  14E1             TOK_MINUS          .equ 4
0014+  14E1             TOK_DOT            .equ 5
0015+  14E1             TOK_SEMI           .equ 6
0016+  14E1             TOK_ANGLE          .equ 7
0017+  14E1             TOK_TILDE          .equ 8
0018+  14E1             TOK_EQUAL          .equ 9
0019+  14E1             TOK_COLON          .equ 10
0020+  14E1             TOK_COMMA          .equ 11
0021+  14E1             
0022+  14E1             TOK_END            .equ 20
0023+  14E1             
0024+  14E1             
0025+  14E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  14E1             ;; read a full command argment from shell input buffer
0027+  14E1             ;; argument is written into tokstr
0028+  14E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  14E1             get_arg:
0030+  14E1 D7            push a
0031+  14E2 E2            push si
0032+  14E3 E3            push di
0033+  14E4 19 00         mov al, 0
0034+  14E6 3D 0F 17      mov [tokstr], al      ; nullify tokstr string
0035+  14E9 14 0B 17      mov a, [prog]
0036+  14EC 4D            mov si, a
0037+  14ED FD 4F 0F 17   mov di, tokstr
0038+  14F1             get_arg_skip_spaces:
0039+  14F1 F6            lodsb
0040+  14F2 07 BA 14      call _isspace
0041+  14F5 C6 F1 14      je get_arg_skip_spaces
0042+  14F8             get_arg_L0:
0043+  14F8 B9 3B         cmp al, $3B        ; check if is ';'
0044+  14FA C6 07 15      je get_arg_end
0045+  14FD B9 00         cmp al, 0
0046+  14FF C6 07 15      je get_arg_end      ; check if end of input
0047+  1502 F7            stosb
0048+  1503 F6            lodsb
0049+  1504 0A F8 14      jmp get_arg_L0
0050+  1507             get_arg_end:
0051+  1507 19 00         mov al, 0
0052+  1509 F7            stosb
0053+  150A D5 01 00      sub si, 1
0054+  150D 4E            mov a, si
0055+  150E 42 0B 17      mov [prog], a    ; update pointer
0056+  1511 F0            pop di
0057+  1512 EF            pop si
0058+  1513 E4            pop a
0059+  1514 09            ret
0060+  1515             
0061+  1515             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  1515             ;; read a path formation from shell input buffer
0063+  1515             ;; path is written into tokstr
0064+  1515             ;; /usr/bin
0065+  1515             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  1515             get_path:
0067+  1515 D7            push a
0068+  1516 E2            push si
0069+  1517 E3            push di
0070+  1518 19 00         mov al, 0
0071+  151A 3D 0F 17      mov [tokstr], al      ; nullify tokstr string
0072+  151D 14 0B 17      mov a, [prog]
0073+  1520 4D            mov si, a
0074+  1521 FD 4F 0F 17   mov di, tokstr
0075+  1525             get_path_skip_spaces:
0076+  1525 F6            lodsb
0077+  1526 07 BA 14      call _isspace
0078+  1529 C6 25 15      je get_path_skip_spaces
0079+  152C             get_path_is_pathchar:
0080+  152C F7            stosb
0081+  152D F6            lodsb
0082+  152E 07 44 14      call _isalnum      ;check if is alphanumeric
0083+  1531 C6 2C 15      je get_path_is_pathchar
0084+  1534 B9 2F         cmp al, '/'        ; check if is '/'
0085+  1536 C6 2C 15      je get_path_is_pathchar
0086+  1539 19 00         mov al, 0
0087+  153B F7            stosb
0088+  153C D5 01 00      sub si, 1
0089+  153F 4E            mov a, si
0090+  1540 42 0B 17      mov [prog], a    ; update pointer
0091+  1543             get_path_end:
0092+  1543 F0            pop di
0093+  1544 EF            pop si
0094+  1545 E4            pop a
0095+  1546 09            ret
0096+  1547             
0097+  1547             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  1547             ;; read a line
0099+  1547             ;; line is written into tokstr
0100+  1547             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  1547             get_line:
0102+  1547 D7            push a
0103+  1548 E2            push si
0104+  1549 E3            push di
0105+  154A 19 00         mov al, 0
0106+  154C 3D 0F 17      mov [tokstr], al      ; nullify tokstr string
0107+  154F 14 0B 17      mov a, [prog]
0108+  1552 4D            mov si, a
0109+  1553 FD 4F 0F 17   mov di, tokstr
0110+  1557             get_line_L0:
0111+  1557 F6            lodsb
0112+  1558 B9 0A         cmp al, $0A    ; check for new line
0113+  155A C6 61 15      je get_line_exit
0114+  155D F7            stosb
0115+  155E 0A 57 15      jmp get_line_L0
0116+  1561             get_line_exit:
0117+  1561 19 00         mov al, 0
0118+  1563 F7            stosb
0119+  1564 4E            mov a, si
0120+  1565 42 0B 17      mov [prog], a    ; update pointer
0121+  1568 F0            pop di
0122+  1569 EF            pop si
0123+  156A E4            pop a
0124+  156B 09            ret
0125+  156C             
0126+  156C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  156C             ;; token parser
0128+  156C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  156C             get_token:
0130+  156C D7            push a
0131+  156D DA            push d
0132+  156E E2            push si
0133+  156F E3            push di
0134+  1570 19 00         mov al, 0
0135+  1572 3D 0F 17      mov [tokstr], al      ; nullify tokstr string
0136+  1575 19 00         mov al, TOK_NULL
0137+  1577 3D 0E 17      mov [tok], al        ; nullify token
0138+  157A 14 0B 17      mov a, [prog]
0139+  157D 4D            mov si, a
0140+  157E FD 4F 0F 17   mov di, tokstr
0141+  1582             get_tok_skip_spaces:
0142+  1582 F6            lodsb
0143+  1583 07 BA 14      call _isspace
0144+  1586 C6 82 15      je get_tok_skip_spaces
0145+  1589 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  158B C6 70 16      je get_token_end
0147+  158E B9 23         cmp al, '#'      ; comments!
0148+  1590 C6 9E 16      je get_tok_comment
0149+  1593 07 44 14      call _isalnum
0150+  1596 C6 7D 16      jz is_alphanumeric
0151+  1599             ; other token types
0152+  1599             get_token_slash:
0153+  1599 B9 2F         cmp al, '/'        ; check if '/'
0154+  159B C7 B3 15      jne get_token_minus
0155+  159E F7            stosb          ; store '/' into token string
0156+  159F 19 00         mov al, 0
0157+  15A1 F7            stosb          ; terminate token string
0158+  15A2 19 01         mov al, TOK_FSLASH
0159+  15A4 3D 0E 17      mov [tok], al      
0160+  15A7 19 02         mov al, TOKTYP_DELIMITER
0161+  15A9 3D 0D 17      mov [toktyp], al
0162+  15AC 4E            mov a, si
0163+  15AD 42 0B 17      mov [prog], a    ; update pointer
0164+  15B0 0A 99 16      jmp get_token_return
0165+  15B3             get_token_minus:
0166+  15B3 B9 2D         cmp al, '-'        ; check if '-'
0167+  15B5 C7 CD 15      jne get_token_comma
0168+  15B8 F7            stosb          ; store '-' into token string
0169+  15B9 19 00         mov al, 0
0170+  15BB F7            stosb          ; terminate token string
0171+  15BC 19 04         mov al, TOK_MINUS
0172+  15BE 3D 0E 17      mov [tok], al      
0173+  15C1 19 02         mov al, TOKTYP_DELIMITER
0174+  15C3 3D 0D 17      mov [toktyp], al
0175+  15C6 4E            mov a, si
0176+  15C7 42 0B 17      mov [prog], a    ; update pointer
0177+  15CA 0A 99 16      jmp get_token_return
0178+  15CD             get_token_comma:
0179+  15CD B9 2C         cmp al, ','        ; check if ','
0180+  15CF C7 E7 15      jne get_token_semi
0181+  15D2 F7            stosb          ; store ',' into token string
0182+  15D3 19 00         mov al, 0
0183+  15D5 F7            stosb          ; terminate token string
0184+  15D6 19 0B         mov al, TOK_COMMA
0185+  15D8 3D 0E 17      mov [tok], al      
0186+  15DB 19 02         mov al, TOKTYP_DELIMITER
0187+  15DD 3D 0D 17      mov [toktyp], al
0188+  15E0 4E            mov a, si
0189+  15E1 42 0B 17      mov [prog], a    ; update pointer
0190+  15E4 0A 99 16      jmp get_token_return
0191+  15E7             get_token_semi:
0192+  15E7 B9 3B         cmp al, $3B        ; check if ';'
0193+  15E9 C7 01 16      jne get_token_colon
0194+  15EC F7            stosb          ; store ';' into token string
0195+  15ED 19 00         mov al, 0
0196+  15EF F7            stosb          ; terminate token string
0197+  15F0 19 06         mov al, TOK_SEMI
0198+  15F2 3D 0E 17      mov [tok], al      
0199+  15F5 19 02         mov al, TOKTYP_DELIMITER
0200+  15F7 3D 0D 17      mov [toktyp], al
0201+  15FA 4E            mov a, si
0202+  15FB 42 0B 17      mov [prog], a    ; update pointer
0203+  15FE 0A 99 16      jmp get_token_return
0204+  1601             get_token_colon:
0205+  1601 B9 3A         cmp al, $3A        ; check if ':'
0206+  1603 C7 1B 16      jne get_token_angle
0207+  1606 F7            stosb          ; store ':' into token string
0208+  1607 19 00         mov al, 0
0209+  1609 F7            stosb          ; terminate token string
0210+  160A 19 0A         mov al, TOK_COLON
0211+  160C 3D 0E 17      mov [tok], al      
0212+  160F 19 02         mov al, TOKTYP_DELIMITER
0213+  1611 3D 0D 17      mov [toktyp], al
0214+  1614 4E            mov a, si
0215+  1615 42 0B 17      mov [prog], a    ; update pointer
0216+  1618 0A 99 16      jmp get_token_return
0217+  161B             get_token_angle:
0218+  161B B9 3E         cmp al, $3E        ; check if '>'
0219+  161D C7 35 16      jne get_token_tilde
0220+  1620 F7            stosb          ; store '>' into token string
0221+  1621 19 00         mov al, 0
0222+  1623 F7            stosb          ; terminate token string
0223+  1624 19 07         mov al, TOK_ANGLE
0224+  1626 3D 0E 17      mov [tok], al      
0225+  1629 19 02         mov al, TOKTYP_DELIMITER
0226+  162B 3D 0D 17      mov [toktyp], al
0227+  162E 4E            mov a, si
0228+  162F 42 0B 17      mov [prog], a    ; update pointer
0229+  1632 0A 99 16      jmp get_token_return
0230+  1635             get_token_tilde:
0231+  1635 B9 7E         cmp al, '~'        ; check if '~'
0232+  1637 C7 4F 16      jne get_token_equal
0233+  163A F7            stosb          ; store '~' into token string
0234+  163B 19 00         mov al, 0
0235+  163D F7            stosb          ; terminate token string
0236+  163E 19 08         mov al, TOK_TILDE
0237+  1640 3D 0E 17      mov [tok], al      
0238+  1643 19 02         mov al, TOKTYP_DELIMITER
0239+  1645 3D 0D 17      mov [toktyp], al
0240+  1648 4E            mov a, si
0241+  1649 42 0B 17      mov [prog], a    ; update pointer
0242+  164C 0A 99 16      jmp get_token_return
0243+  164F             get_token_equal:
0244+  164F B9 3D         cmp al, '='        ; check if '='
0245+  1651 C7 69 16      jne get_token_skip
0246+  1654 F7            stosb          ; store '=' into token string
0247+  1655 19 00         mov al, 0
0248+  1657 F7            stosb          ; terminate token string
0249+  1658 19 09         mov al, TOK_EQUAL
0250+  165A 3D 0E 17      mov [tok], al      
0251+  165D 19 02         mov al, TOKTYP_DELIMITER
0252+  165F 3D 0D 17      mov [toktyp], al
0253+  1662 4E            mov a, si
0254+  1663 42 0B 17      mov [prog], a    ; update pointer
0255+  1666 0A 99 16      jmp get_token_return
0256+  1669             get_token_skip:
0257+  1669 4E            mov a, si
0258+  166A 42 0B 17      mov [prog], a    ; update pointer
0259+  166D 0A 99 16      jmp get_token_return
0260+  1670             get_token_end:        ; end of file token
0261+  1670 19 14         mov al, TOK_END
0262+  1672 3D 0E 17      mov [tok], al
0263+  1675 19 06         mov al, TOKTYP_END
0264+  1677 3D 0D 17      mov [toktyp], al
0265+  167A 0A 99 16      jmp get_token_return
0266+  167D             is_alphanumeric:
0267+  167D F7            stosb
0268+  167E F6            lodsb
0269+  167F 07 44 14      call _isalnum      ;check if is alphanumeric
0270+  1682 C6 7D 16      jz is_alphanumeric
0271+  1685 B9 2E         cmp al, $2E        ; check if is '.'
0272+  1687 C6 7D 16      je is_alphanumeric
0273+  168A 19 00         mov al, 0
0274+  168C F7            stosb
0275+  168D 19 00         mov al, TOKTYP_IDENTIFIER
0276+  168F 3D 0D 17      mov [toktyp], al
0277+  1692 D5 01 00      sub si, 1
0278+  1695 4E            mov a, si
0279+  1696 42 0B 17      mov [prog], a    ; update pointer
0280+  1699             get_token_return:
0281+  1699 F0            pop di
0282+  169A EF            pop si
0283+  169B E7            pop d
0284+  169C E4            pop a
0285+  169D 09            ret
0286+  169E             get_tok_comment:
0287+  169E F6            lodsb
0288+  169F B9 0A         cmp al, $0A      ; new line
0289+  16A1 C7 9E 16      jne get_tok_comment
0290+  16A4 0A 82 15      jmp get_tok_skip_spaces
0291+  16A7             
0292+  16A7             
0293+  16A7             get_number:
0294+  16A7 D7            push a
0295+  16A8 DA            push d
0296+  16A9 E2            push si
0297+  16AA E3            push di
0298+  16AB 19 00         mov al, 0
0299+  16AD 3D 0F 17      mov [tokstr], al      ; nullify tokstr string
0300+  16B0 19 00         mov al, TOK_NULL
0301+  16B2 3D 0E 17      mov [tok], al        ; nullify token
0302+  16B5 14 0B 17      mov a, [prog]
0303+  16B8 4D            mov si, a
0304+  16B9 FD 4F 0F 17   mov di, tokstr
0305+  16BD             get_number_skip_spaces:
0306+  16BD F6            lodsb
0307+  16BE 07 BA 14      call _isspace
0308+  16C1 C6 BD 16      je get_number_skip_spaces
0309+  16C4 B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  16C6 C7 D6 16      jne get_number_L0
0311+  16C9 19 14         mov al, TOK_END
0312+  16CB 3D 0E 17      mov [tok], al
0313+  16CE 19 06         mov al, TOKTYP_END
0314+  16D0 3D 0D 17      mov [toktyp], al
0315+  16D3 0A ED 16      jmp get_number_return
0316+  16D6             get_number_L0:
0317+  16D6 F7            stosb
0318+  16D7 F6            lodsb
0319+  16D8 07 4E 14      call _isdigit      ;check if is numeric
0320+  16DB C6 D6 16      jz get_number_L0
0321+  16DE 19 00         mov al, 0
0322+  16E0 F7            stosb
0323+  16E1 19 05         mov al, TOKTYP_NUMERIC
0324+  16E3 3D 0D 17      mov [toktyp], al
0325+  16E6 D5 01 00      sub si, 1
0326+  16E9 4E            mov a, si
0327+  16EA 42 0B 17      mov [prog], a    ; update pointer
0328+  16ED             get_number_return:
0329+  16ED F0            pop di
0330+  16EE EF            pop si
0331+  16EF E7            pop d
0332+  16F0 E4            pop a
0333+  16F1 09            ret
0334+  16F2             
0335+  16F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  16F2             ;; PUT BACK TOKEN
0337+  16F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  16F2             _putback:
0339+  16F2 D7            push a
0340+  16F3 E2            push si
0341+  16F4 FD 4D 0F 17   mov si, tokstr  
0342+  16F8             _putback_loop:
0343+  16F8 F6            lodsb
0344+  16F9 B9 00         cmp al, 0
0345+  16FB C6 08 17      je _putback_end
0346+  16FE 14 0B 17      mov a, [prog]
0347+  1701 7D            dec a
0348+  1702 42 0B 17      mov [prog], a      ; update pointer
0349+  1705 0A F8 16      jmp _putback_loop
0350+  1708             _putback_end:
0351+  1708 EF            pop si
0352+  1709 E4            pop a
0353+  170A 09            ret
0354+  170B             
0355+  170B             
0356+  170B             
0357+  170B             
0358+  170B 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  170D             
0360+  170D 00          toktyp:    .db 0          ; token type symbol
0361+  170E 00          tok:       .db 0          ; current token symbol
0362+  170F 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  1713 00 00 00 00 
0362+  1717 00 00 00 00 
0362+  171B 00 00 00 00 
0362+  171F 00 00 00 00 
0362+  1723 00 00 00 00 
0362+  1727 00 00 00 00 
0362+  172B 00 00 00 00 
0362+  172F 00 00 00 00 
0362+  1733 00 00 00 00 
0362+  1737 00 00 00 00 
0362+  173B 00 00 00 00 
0362+  173F 00 00 00 00 
0362+  1743 00 00 00 00 
0362+  1747 00 00 00 00 
0362+  174B 00 00 00 00 
0362+  174F 00 00 00 00 
0362+  1753 00 00 00 00 
0362+  1757 00 00 00 00 
0362+  175B 00 00 00 00 
0362+  175F 00 00 00 00 
0362+  1763 00 00 00 00 
0362+  1767 00 00 00 00 
0362+  176B 00 00 00 00 
0362+  176F 00 00 00 00 
0362+  1773 00 00 00 00 
0362+  1777 00 00 00 00 
0362+  177B 00 00 00 00 
0362+  177F 00 00 00 00 
0362+  1783 00 00 00 00 
0362+  1787 00 00 00 00 
0362+  178B 00 00 00 00 
0362+  178F 00 00 00 00 
0362+  1793 00 00 00 00 
0362+  1797 00 00 00 00 
0362+  179B 00 00 00 00 
0362+  179F 00 00 00 00 
0362+  17A3 00 00 00 00 
0362+  17A7 00 00 00 00 
0362+  17AB 00 00 00 00 
0362+  17AF 00 00 00 00 
0362+  17B3 00 00 00 00 
0362+  17B7 00 00 00 00 
0362+  17BB 00 00 00 00 
0362+  17BF 00 00 00 00 
0362+  17C3 00 00 00 00 
0362+  17C7 00 00 00 00 
0362+  17CB 00 00 00 00 
0362+  17CF 00 00 00 00 
0362+  17D3 00 00 00 00 
0362+  17D7 00 00 00 00 
0362+  17DB 00 00 00 00 
0362+  17DF 00 00 00 00 
0362+  17E3 00 00 00 00 
0362+  17E7 00 00 00 00 
0362+  17EB 00 00 00 00 
0362+  17EF 00 00 00 00 
0362+  17F3 00 00 00 00 
0362+  17F7 00 00 00 00 
0362+  17FB 00 00 00 00 
0362+  17FF 00 00 00 00 
0362+  1803 00 00 00 00 
0362+  1807 00 00 00 00 
0362+  180B 00 00 00 00 
2701   180F             
2702   180F             ; kernel parameters
2703   180F             sys_debug_mode:
2704   180F 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2705   1810             sys_echo_on:
2706   1810 01            .db 1
2707   1811             sys_uart0_lcr:
2708   1811 07            .db $07 ; 8 data bits, 2 stop bit, no parity
2709   1812             sys_uart0_inten:
2710   1812 01            .db 1
2711   1813             sys_uart0_fifoen:
2712   1813 00            .db 0
2713   1814             sys_uart0_div0:
2714   1814 0C            .db 12  ;
2715   1815             sys_uart0_div1:
2716   1815 00            .db 0   ; default baud = 9600
2717   1816             ; Baud  Divisor
2718   1816             ; 50    2304
2719   1816             ; 110   1047
2720   1816             ; 300    384
2721   1816             ; 600    192
2722   1816             ; 1200    96
2723   1816             ; 9600    12
2724   1816             ; 19200    6
2725   1816             ; 38400    3
2726   1816             
2727   1816             nbr_active_procs:
2728   1816 00            .db 0
2729   1817             active_proc_index:
2730   1817 01            .db 1
2731   1818             
2732   1818             index:
2733   1818 00 00         .dw 0
2734   181A             buffer_addr:
2735   181A 00 00         .dw 0
2736   181C             
2737   181C             fifo_in:
2738   181C 6D 21         .dw fifo
2739   181E             fifo_out:
2740   181E 6D 21         .dw fifo
2741   1820             
2742   1820             ; file system variables
2743   1820             current_dir_id:
2744   1820 00 00         .dw 0     ; keep dirID of current directory
2745   1822             s_init_path:
2746   1822 2F 73 62 69   .db "/sbin/init", 0
2746   1826 6E 2F 69 6E 
2746   182A 69 74 00 
2747   182D             
2748   182D             s_uname:
2749   182D 73 6F 6C 61   .db "solarium v.1.0", 0
2749   1831 72 69 75 6D 
2749   1835 20 76 2E 31 
2749   1839 2E 30 00 
2750   183C             s_dataentry:
2751   183C 3E 20 00      .db "> ", 0
2752   183F             s_parent_dir:
2753   183F 2E 2E 00      .db "..", 0
2754   1842             s_current_dir:
2755   1842 2E 00         .db ".", 0
2756   1844             s_fslash:
2757   1844 2F 00         .db "/", 0
2758   1846             file_attrib:
2759   1846 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2759   184A 78 
2760   184B             file_type:
2761   184B 2D 64 63      .db "-dc"
2762   184E             s_ps_header:
2763   184E 70 69 64 20   .db "pid command\n", 0
2763   1852 63 6F 6D 6D 
2763   1856 61 6E 64 0A 
2763   185A 00 
2764   185B             s_ls_total:
2765   185B 74 6F 74 61   .db "total: ", 0
2765   185F 6C 3A 20 00 
2766   1863             
2767   1863             s_int_en:
2768   1863 49 52 51 73   .db "IRQs enabled\n", 0
2768   1867 20 65 6E 61 
2768   186B 62 6C 65 64 
2768   186F 0A 00 
2769   1871             s_kernel_started:
2770   1871 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2770   1875 65 6C 20 73 
2770   1879 74 61 72 74 
2770   187D 65 64 28 76 
2770   1881 65 72 73 69 
2770   1885 6F 6E 20 31 
2770   1889 2E 30 29 0A 
2770   188D 00 
2771   188E             s_prompt_init:
2772   188E 73 74 61 72   .db "starting init\n", 0
2772   1892 74 69 6E 67 
2772   1896 20 69 6E 69 
2772   189A 74 0A 00 
2773   189D             s_priviledge:
2774   189D 0A 65 78 63   .db "\nexception: privilege\n", 0
2774   18A1 65 70 74 69 
2774   18A5 6F 6E 3A 20 
2774   18A9 70 72 69 76 
2774   18AD 69 6C 65 67 
2774   18B1 65 0A 00 
2775   18B4             s_divzero:
2776   18B4 0A 65 78 63   .db "\nexception: zero division\n", 0
2776   18B8 65 70 74 69 
2776   18BC 6F 6E 3A 20 
2776   18C0 7A 65 72 6F 
2776   18C4 20 64 69 76 
2776   18C8 69 73 69 6F 
2776   18CC 6E 0A 00 
2777   18CF             
2778   18CF             s_set_year:
2779   18CF 79 65 61 72   .db "year: ", 0
2779   18D3 3A 20 00 
2780   18D6             s_set_month:
2781   18D6 6D 6F 6E 74   .db "month: ", 0
2781   18DA 68 3A 20 00 
2782   18DE             s_set_day:
2783   18DE 64 61 79 3A   .db "day: ", 0
2783   18E2 20 00 
2784   18E4             s_set_week:
2785   18E4 77 65 65 6B   .db "weekday: ", 0
2785   18E8 64 61 79 3A 
2785   18EC 20 00 
2786   18EE             s_set_hours:
2787   18EE 68 6F 75 72   .db "hours: ", 0
2787   18F2 73 3A 20 00 
2788   18F6             s_set_minutes:
2789   18F6 6D 69 6E 75   .db "minutes: ", 0
2789   18FA 74 65 73 3A 
2789   18FE 20 00 
2790   1900             s_set_seconds:
2791   1900 73 65 63 6F   .db "seconds: ", 0
2791   1904 6E 64 73 3A 
2791   1908 20 00 
2792   190A             s_months:      
2793   190A 20 20 20 00   .db "   ", 0
2794   190E 4A 61 6E 00   .db "Jan", 0
2795   1912 46 65 62 00   .db "Feb", 0
2796   1916 4D 61 72 00   .db "Mar", 0
2797   191A 41 70 72 00   .db "Apr", 0
2798   191E 4D 61 79 00   .db "May", 0
2799   1922 4A 75 6E 00   .db "Jun", 0
2800   1926 4A 75 6C 00   .db "Jul", 0
2801   192A 41 75 67 00   .db "Aug", 0
2802   192E 53 65 70 00   .db "Sep", 0
2803   1932 4F 63 74 00   .db "Oct", 0
2804   1936 4E 6F 76 00   .db "Nov", 0
2805   193A 44 65 63 00   .db "Dec", 0
2806   193E             
2807   193E             s_week:        
2808   193E 53 75 6E 00   .db "Sun", 0 
2809   1942 4D 6F 6E 00   .db "Mon", 0 
2810   1946 54 75 65 00   .db "Tue", 0 
2811   194A 57 65 64 00   .db "Wed", 0 
2812   194E 54 68 75 00   .db "Thu", 0 
2813   1952 46 72 69 00   .db "Fri", 0 
2814   1956 53 61 74 00   .db "Sat", 0
2815   195A             
2816   195A             ; This is the format of a sector for the 128 byte per sector format.
2817   195A             ; Write the bracketed data 16 times per track.
2818   195A             ; The recommended single-density format with 128
2819   195A             ; bytes/sector is shown. In order to format a diskette,
2820   195A             ; the user issues the Write Track Command, and loads
2821   195A             ; the Data Register with the following values. For every
2822   195A             ; byte to be written, there is one Data Request.
2823   195A             fdc_irq_event:
2824   195A 00            .fill 1,  $00       ; keeps status of fdc irq event
2825   195B             fdc_128_format:                                                                       
2826   195B             fdc_40_FF:
2827   195B FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
2827   195F FF FF FF FF 
2827   1963 FF FF FF FF 
2827   1967 FF FF FF FF 
2827   196B FF FF FF FF 
2827   196F FF FF FF FF 
2827   1973 FF FF FF FF 
2827   1977 FF FF FF FF 
2827   197B FF FF FF FF 
2827   197F FF FF FF FF 
2828   1983             fdc_128_format_inner:
2829   1983 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
2829   1987 00 00 
2830   1989 FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
2831   198A             fdc_128_format_track:
2832   198A 00            .fill 1,   $00    ; Track Number   0 thru 39                                                      |                    
2833   198B 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
2834   198C             fdc_128_format_sect:
2835   198C 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
2836   198D 00            .fill 1,   $00    ; Sector Length                                                                 |                        
2837   198E F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
2838   198F FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
2838   1993 FF FF FF FF 
2838   1997 FF FF FF 
2839   199A 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
2839   199E 00 00 
2840   19A0 FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
2841   19A1 E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
2841   19A5 E5 E5 E5 E5 
2841   19A9 E5 E5 E5 E5 
2841   19AD E5 E5 E5 E5 
2841   19B1 E5 E5 E5 E5 
2841   19B5 E5 E5 E5 E5 
2841   19B9 E5 E5 E5 E5 
2841   19BD E5 E5 E5 E5 
2841   19C1 E5 E5 E5 E5 
2841   19C5 E5 E5 E5 E5 
2841   19C9 E5 E5 E5 E5 
2841   19CD E5 E5 E5 E5 
2841   19D1 E5 E5 E5 E5 
2841   19D5 E5 E5 E5 E5 
2841   19D9 E5 E5 E5 E5 
2841   19DD E5 E5 E5 E5 
2841   19E1 E5 E5 E5 E5 
2841   19E5 E5 E5 E5 E5 
2841   19E9 E5 E5 E5 E5 
2841   19ED E5 E5 E5 E5 
2841   19F1 E5 E5 E5 E5 
2841   19F5 E5 E5 E5 E5 
2841   19F9 E5 E5 E5 E5 
2841   19FD E5 E5 E5 E5 
2841   1A01 E5 E5 E5 E5 
2841   1A05 E5 E5 E5 E5 
2841   1A09 E5 E5 E5 E5 
2841   1A0D E5 E5 E5 E5 
2841   1A11 E5 E5 E5 E5 
2841   1A15 E5 E5 E5 E5 
2841   1A19 E5 E5 E5 E5 
2841   1A1D E5 E5 E5 E5 
2842   1A21 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
2843   1A22 FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
2843   1A26 FF FF FF FF 
2843   1A2A FF FF 
2844   1A2C             fdc_128_format_end:
2845   1A2C FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2845   1A30 FF FF FF FF 
2845   1A34 FF FF FF FF 
2845   1A38 FF FF FF FF 
2845   1A3C FF FF FF FF 
2845   1A40 FF FF FF FF 
2845   1A44 FF FF FF FF 
2845   1A48 FF FF FF FF 
2845   1A4C FF FF FF FF 
2845   1A50 FF FF FF FF 
2845   1A54 FF FF FF FF 
2845   1A58 FF FF FF FF 
2845   1A5C FF FF FF FF 
2845   1A60 FF FF FF FF 
2845   1A64 FF FF FF FF 
2845   1A68 FF FF FF FF 
2845   1A6C FF FF FF FF 
2845   1A70 FF FF FF FF 
2845   1A74 FF FF FF FF 
2845   1A78 FF FF FF FF 
2845   1A7C FF FF FF FF 
2845   1A80 FF FF FF FF 
2845   1A84 FF FF FF FF 
2845   1A88 FF FF FF FF 
2845   1A8C FF FF FF FF 
2845   1A90 FF FF FF FF 
2845   1A94 FF FF FF FF 
2845   1A98 FF FF FF FF 
2845   1A9C FF FF FF FF 
2845   1AA0 FF FF FF FF 
2845   1AA4 FF FF FF FF 
2845   1AA8 FF FF FF FF 
2845   1AAC FF FF FF FF 
2845   1AB0 FF FF FF FF 
2845   1AB4 FF FF FF FF 
2845   1AB8 FF FF FF FF 
2845   1ABC FF FF FF FF 
2845   1AC0 FF FF FF FF 
2845   1AC4 FF FF FF FF 
2845   1AC8 FF FF FF FF 
2845   1ACC FF FF FF FF 
2845   1AD0 FF FF FF FF 
2845   1AD4 FF FF FF FF 
2845   1AD8 FF FF FF FF 
2845   1ADC FF FF FF FF 
2845   1AE0 FF FF FF FF 
2845   1AE4 FF FF FF FF 
2845   1AE8 FF FF FF FF 
2845   1AEC FF FF FF FF 
2845   1AF0 FF FF FF FF 
2845   1AF4 FF FF FF FF 
2845   1AF8 FF FF FF FF 
2845   1AFC FF FF FF FF 
2845   1B00 FF FF FF FF 
2845   1B04 FF FF FF FF 
2845   1B08 FF FF FF FF 
2845   1B0C FF FF FF FF 
2845   1B10 FF FF FF FF 
2845   1B14 FF FF FF FF 
2845   1B18 FF FF FF FF 
2845   1B1C FF FF FF FF 
2845   1B20 FF FF FF FF 
2845   1B24 FF FF FF FF 
2845   1B28 FF FF FF FF 
2845   1B2C FF FF FF FF 
2845   1B30 FF FF FF FF 
2845   1B34 FF FF FF FF 
2845   1B38 FF FF FF FF 
2845   1B3C FF FF FF FF 
2845   1B40 FF FF FF FF 
2845   1B44 FF FF FF FF 
2845   1B48 FF FF FF FF 
2845   1B4C FF FF FF FF 
2845   1B50 FF FF FF FF 
2845   1B54 FF FF FF FF 
2845   1B58 FF FF FF FF 
2845   1B5C FF FF FF FF 
2845   1B60 FF FF FF FF 
2845   1B64 FF FF FF FF 
2845   1B68 FF FF FF FF 
2845   1B6C FF FF FF FF 
2845   1B70 FF FF FF FF 
2845   1B74 FF FF FF FF 
2845   1B78 FF FF FF FF 
2845   1B7C FF FF FF FF 
2845   1B80 FF FF FF FF 
2845   1B84 FF FF FF FF 
2845   1B88 FF FF FF FF 
2845   1B8C FF FF FF FF 
2845   1B90 FF FF FF FF 
2845   1B94 FF FF FF FF 
2845   1B98 FF FF FF FF 
2845   1B9C FF 
2846   1B9D             
2847   1B9D             proc_state_table:   
2848   1B9D 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
2848   1BA1 00 00 00 00 
2848   1BA5 00 00 00 00 
2848   1BA9 00 00 00 00 
2848   1BAD 00 00 00 00 
2848   1BB1 00 00 00 00 
2848   1BB5 00 00 00 00 
2848   1BB9 00 00 00 00 
2848   1BBD 00 00 00 00 
2848   1BC1 00 00 00 00 
2848   1BC5 00 00 00 00 
2848   1BC9 00 00 00 00 
2848   1BCD 00 00 00 00 
2848   1BD1 00 00 00 00 
2848   1BD5 00 00 00 00 
2848   1BD9 00 00 00 00 
2848   1BDD 00 00 00 00 
2848   1BE1 00 00 00 00 
2848   1BE5 00 00 00 00 
2848   1BE9 00 00 00 00 
2848   1BED 00 00 00 00 
2848   1BF1 00 00 00 00 
2848   1BF5 00 00 00 00 
2848   1BF9 00 00 00 00 
2848   1BFD 00 00 00 00 
2848   1C01 00 00 00 00 
2848   1C05 00 00 00 00 
2848   1C09 00 00 00 00 
2848   1C0D 00 00 00 00 
2848   1C11 00 00 00 00 
2848   1C15 00 00 00 00 
2848   1C19 00 00 00 00 
2848   1C1D 00 00 00 00 
2848   1C21 00 00 00 00 
2848   1C25 00 00 00 00 
2848   1C29 00 00 00 00 
2848   1C2D 00 00 00 00 
2848   1C31 00 00 00 00 
2848   1C35 00 00 00 00 
2848   1C39 00 00 00 00 
2848   1C3D 00 00 00 00 
2848   1C41 00 00 00 00 
2848   1C45 00 00 00 00 
2848   1C49 00 00 00 00 
2848   1C4D 00 00 00 00 
2848   1C51 00 00 00 00 
2848   1C55 00 00 00 00 
2848   1C59 00 00 00 00 
2848   1C5D 00 00 00 00 
2848   1C61 00 00 00 00 
2848   1C65 00 00 00 00 
2848   1C69 00 00 00 00 
2848   1C6D 00 00 00 00 
2848   1C71 00 00 00 00 
2848   1C75 00 00 00 00 
2848   1C79 00 00 00 00 
2848   1C7D 00 00 00 00 
2848   1C81 00 00 00 00 
2848   1C85 00 00 00 00 
2848   1C89 00 00 00 00 
2848   1C8D 00 00 00 00 
2848   1C91 00 00 00 00 
2848   1C95 00 00 00 00 
2848   1C99 00 00 00 00 
2848   1C9D 00 00 00 00 
2848   1CA1 00 00 00 00 
2848   1CA5 00 00 00 00 
2848   1CA9 00 00 00 00 
2848   1CAD 00 00 00 00 
2848   1CB1 00 00 00 00 
2848   1CB5 00 00 00 00 
2848   1CB9 00 00 00 00 
2848   1CBD 00 00 00 00 
2848   1CC1 00 00 00 00 
2848   1CC5 00 00 00 00 
2848   1CC9 00 00 00 00 
2848   1CCD 00 00 00 00 
2848   1CD1 00 00 00 00 
2848   1CD5 00 00 00 00 
2848   1CD9 00 00 00 00 
2849   1CDD             proc_availab_table: 
2850   1CDD 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2850   1CE1 00 00 00 00 
2850   1CE5 00 00 00 00 
2850   1CE9 00 00 00 00 
2851   1CED             proc_names:
2852   1CED 00 00 00 00   .fill 16 * 32, 0  ; process names
2852   1CF1 00 00 00 00 
2852   1CF5 00 00 00 00 
2852   1CF9 00 00 00 00 
2852   1CFD 00 00 00 00 
2852   1D01 00 00 00 00 
2852   1D05 00 00 00 00 
2852   1D09 00 00 00 00 
2852   1D0D 00 00 00 00 
2852   1D11 00 00 00 00 
2852   1D15 00 00 00 00 
2852   1D19 00 00 00 00 
2852   1D1D 00 00 00 00 
2852   1D21 00 00 00 00 
2852   1D25 00 00 00 00 
2852   1D29 00 00 00 00 
2852   1D2D 00 00 00 00 
2852   1D31 00 00 00 00 
2852   1D35 00 00 00 00 
2852   1D39 00 00 00 00 
2852   1D3D 00 00 00 00 
2852   1D41 00 00 00 00 
2852   1D45 00 00 00 00 
2852   1D49 00 00 00 00 
2852   1D4D 00 00 00 00 
2852   1D51 00 00 00 00 
2852   1D55 00 00 00 00 
2852   1D59 00 00 00 00 
2852   1D5D 00 00 00 00 
2852   1D61 00 00 00 00 
2852   1D65 00 00 00 00 
2852   1D69 00 00 00 00 
2852   1D6D 00 00 00 00 
2852   1D71 00 00 00 00 
2852   1D75 00 00 00 00 
2852   1D79 00 00 00 00 
2852   1D7D 00 00 00 00 
2852   1D81 00 00 00 00 
2852   1D85 00 00 00 00 
2852   1D89 00 00 00 00 
2852   1D8D 00 00 00 00 
2852   1D91 00 00 00 00 
2852   1D95 00 00 00 00 
2852   1D99 00 00 00 00 
2852   1D9D 00 00 00 00 
2852   1DA1 00 00 00 00 
2852   1DA5 00 00 00 00 
2852   1DA9 00 00 00 00 
2852   1DAD 00 00 00 00 
2852   1DB1 00 00 00 00 
2852   1DB5 00 00 00 00 
2852   1DB9 00 00 00 00 
2852   1DBD 00 00 00 00 
2852   1DC1 00 00 00 00 
2852   1DC5 00 00 00 00 
2852   1DC9 00 00 00 00 
2852   1DCD 00 00 00 00 
2852   1DD1 00 00 00 00 
2852   1DD5 00 00 00 00 
2852   1DD9 00 00 00 00 
2852   1DDD 00 00 00 00 
2852   1DE1 00 00 00 00 
2852   1DE5 00 00 00 00 
2852   1DE9 00 00 00 00 
2852   1DED 00 00 00 00 
2852   1DF1 00 00 00 00 
2852   1DF5 00 00 00 00 
2852   1DF9 00 00 00 00 
2852   1DFD 00 00 00 00 
2852   1E01 00 00 00 00 
2852   1E05 00 00 00 00 
2852   1E09 00 00 00 00 
2852   1E0D 00 00 00 00 
2852   1E11 00 00 00 00 
2852   1E15 00 00 00 00 
2852   1E19 00 00 00 00 
2852   1E1D 00 00 00 00 
2852   1E21 00 00 00 00 
2852   1E25 00 00 00 00 
2852   1E29 00 00 00 00 
2852   1E2D 00 00 00 00 
2852   1E31 00 00 00 00 
2852   1E35 00 00 00 00 
2852   1E39 00 00 00 00 
2852   1E3D 00 00 00 00 
2852   1E41 00 00 00 00 
2852   1E45 00 00 00 00 
2852   1E49 00 00 00 00 
2852   1E4D 00 00 00 00 
2852   1E51 00 00 00 00 
2852   1E55 00 00 00 00 
2852   1E59 00 00 00 00 
2852   1E5D 00 00 00 00 
2852   1E61 00 00 00 00 
2852   1E65 00 00 00 00 
2852   1E69 00 00 00 00 
2852   1E6D 00 00 00 00 
2852   1E71 00 00 00 00 
2852   1E75 00 00 00 00 
2852   1E79 00 00 00 00 
2852   1E7D 00 00 00 00 
2852   1E81 00 00 00 00 
2852   1E85 00 00 00 00 
2852   1E89 00 00 00 00 
2852   1E8D 00 00 00 00 
2852   1E91 00 00 00 00 
2852   1E95 00 00 00 00 
2852   1E99 00 00 00 00 
2852   1E9D 00 00 00 00 
2852   1EA1 00 00 00 00 
2852   1EA5 00 00 00 00 
2852   1EA9 00 00 00 00 
2852   1EAD 00 00 00 00 
2852   1EB1 00 00 00 00 
2852   1EB5 00 00 00 00 
2852   1EB9 00 00 00 00 
2852   1EBD 00 00 00 00 
2852   1EC1 00 00 00 00 
2852   1EC5 00 00 00 00 
2852   1EC9 00 00 00 00 
2852   1ECD 00 00 00 00 
2852   1ED1 00 00 00 00 
2852   1ED5 00 00 00 00 
2852   1ED9 00 00 00 00 
2852   1EDD 00 00 00 00 
2852   1EE1 00 00 00 00 
2852   1EE5 00 00 00 00 
2852   1EE9 00 00 00 00 
2853   1EED             filename:
2854   1EED 00 00 00 00   .fill 128, 0      ; holds a path for file search
2854   1EF1 00 00 00 00 
2854   1EF5 00 00 00 00 
2854   1EF9 00 00 00 00 
2854   1EFD 00 00 00 00 
2854   1F01 00 00 00 00 
2854   1F05 00 00 00 00 
2854   1F09 00 00 00 00 
2854   1F0D 00 00 00 00 
2854   1F11 00 00 00 00 
2854   1F15 00 00 00 00 
2854   1F19 00 00 00 00 
2854   1F1D 00 00 00 00 
2854   1F21 00 00 00 00 
2854   1F25 00 00 00 00 
2854   1F29 00 00 00 00 
2854   1F2D 00 00 00 00 
2854   1F31 00 00 00 00 
2854   1F35 00 00 00 00 
2854   1F39 00 00 00 00 
2854   1F3D 00 00 00 00 
2854   1F41 00 00 00 00 
2854   1F45 00 00 00 00 
2854   1F49 00 00 00 00 
2854   1F4D 00 00 00 00 
2854   1F51 00 00 00 00 
2854   1F55 00 00 00 00 
2854   1F59 00 00 00 00 
2854   1F5D 00 00 00 00 
2854   1F61 00 00 00 00 
2854   1F65 00 00 00 00 
2854   1F69 00 00 00 00 
2855   1F6D             user_data:
2856   1F6D 00 00 00 00   .fill 512, 0      ;  user space data
2856   1F71 00 00 00 00 
2856   1F75 00 00 00 00 
2856   1F79 00 00 00 00 
2856   1F7D 00 00 00 00 
2856   1F81 00 00 00 00 
2856   1F85 00 00 00 00 
2856   1F89 00 00 00 00 
2856   1F8D 00 00 00 00 
2856   1F91 00 00 00 00 
2856   1F95 00 00 00 00 
2856   1F99 00 00 00 00 
2856   1F9D 00 00 00 00 
2856   1FA1 00 00 00 00 
2856   1FA5 00 00 00 00 
2856   1FA9 00 00 00 00 
2856   1FAD 00 00 00 00 
2856   1FB1 00 00 00 00 
2856   1FB5 00 00 00 00 
2856   1FB9 00 00 00 00 
2856   1FBD 00 00 00 00 
2856   1FC1 00 00 00 00 
2856   1FC5 00 00 00 00 
2856   1FC9 00 00 00 00 
2856   1FCD 00 00 00 00 
2856   1FD1 00 00 00 00 
2856   1FD5 00 00 00 00 
2856   1FD9 00 00 00 00 
2856   1FDD 00 00 00 00 
2856   1FE1 00 00 00 00 
2856   1FE5 00 00 00 00 
2856   1FE9 00 00 00 00 
2856   1FED 00 00 00 00 
2856   1FF1 00 00 00 00 
2856   1FF5 00 00 00 00 
2856   1FF9 00 00 00 00 
2856   1FFD 00 00 00 00 
2856   2001 00 00 00 00 
2856   2005 00 00 00 00 
2856   2009 00 00 00 00 
2856   200D 00 00 00 00 
2856   2011 00 00 00 00 
2856   2015 00 00 00 00 
2856   2019 00 00 00 00 
2856   201D 00 00 00 00 
2856   2021 00 00 00 00 
2856   2025 00 00 00 00 
2856   2029 00 00 00 00 
2856   202D 00 00 00 00 
2856   2031 00 00 00 00 
2856   2035 00 00 00 00 
2856   2039 00 00 00 00 
2856   203D 00 00 00 00 
2856   2041 00 00 00 00 
2856   2045 00 00 00 00 
2856   2049 00 00 00 00 
2856   204D 00 00 00 00 
2856   2051 00 00 00 00 
2856   2055 00 00 00 00 
2856   2059 00 00 00 00 
2856   205D 00 00 00 00 
2856   2061 00 00 00 00 
2856   2065 00 00 00 00 
2856   2069 00 00 00 00 
2856   206D 00 00 00 00 
2856   2071 00 00 00 00 
2856   2075 00 00 00 00 
2856   2079 00 00 00 00 
2856   207D 00 00 00 00 
2856   2081 00 00 00 00 
2856   2085 00 00 00 00 
2856   2089 00 00 00 00 
2856   208D 00 00 00 00 
2856   2091 00 00 00 00 
2856   2095 00 00 00 00 
2856   2099 00 00 00 00 
2856   209D 00 00 00 00 
2856   20A1 00 00 00 00 
2856   20A5 00 00 00 00 
2856   20A9 00 00 00 00 
2856   20AD 00 00 00 00 
2856   20B1 00 00 00 00 
2856   20B5 00 00 00 00 
2856   20B9 00 00 00 00 
2856   20BD 00 00 00 00 
2856   20C1 00 00 00 00 
2856   20C5 00 00 00 00 
2856   20C9 00 00 00 00 
2856   20CD 00 00 00 00 
2856   20D1 00 00 00 00 
2856   20D5 00 00 00 00 
2856   20D9 00 00 00 00 
2856   20DD 00 00 00 00 
2856   20E1 00 00 00 00 
2856   20E5 00 00 00 00 
2856   20E9 00 00 00 00 
2856   20ED 00 00 00 00 
2856   20F1 00 00 00 00 
2856   20F5 00 00 00 00 
2856   20F9 00 00 00 00 
2856   20FD 00 00 00 00 
2856   2101 00 00 00 00 
2856   2105 00 00 00 00 
2856   2109 00 00 00 00 
2856   210D 00 00 00 00 
2856   2111 00 00 00 00 
2856   2115 00 00 00 00 
2856   2119 00 00 00 00 
2856   211D 00 00 00 00 
2856   2121 00 00 00 00 
2856   2125 00 00 00 00 
2856   2129 00 00 00 00 
2856   212D 00 00 00 00 
2856   2131 00 00 00 00 
2856   2135 00 00 00 00 
2856   2139 00 00 00 00 
2856   213D 00 00 00 00 
2856   2141 00 00 00 00 
2856   2145 00 00 00 00 
2856   2149 00 00 00 00 
2856   214D 00 00 00 00 
2856   2151 00 00 00 00 
2856   2155 00 00 00 00 
2856   2159 00 00 00 00 
2856   215D 00 00 00 00 
2856   2161 00 00 00 00 
2856   2165 00 00 00 00 
2856   2169 00 00 00 00 
2857   216D             fifo:
2858   216D FF FF FF FF   .fill FIFO_SIZE
2858   2171 FF FF FF FF 
2858   2175 FF FF FF FF 
2858   2179 FF FF FF FF 
2858   217D FF FF FF FF 
2858   2181 FF FF FF FF 
2858   2185 FF FF FF FF 
2858   2189 FF FF FF FF 
2858   218D FF FF FF FF 
2858   2191 FF FF FF FF 
2858   2195 FF FF FF FF 
2858   2199 FF FF FF FF 
2858   219D FF FF FF FF 
2858   21A1 FF FF FF FF 
2858   21A5 FF FF FF FF 
2858   21A9 FF FF FF FF 
2858   21AD FF FF FF FF 
2858   21B1 FF FF FF FF 
2858   21B5 FF FF FF FF 
2858   21B9 FF FF FF FF 
2858   21BD FF FF FF FF 
2858   21C1 FF FF FF FF 
2858   21C5 FF FF FF FF 
2858   21C9 FF FF FF FF 
2858   21CD FF FF FF FF 
2858   21D1 FF FF FF FF 
2858   21D5 FF FF FF FF 
2858   21D9 FF FF FF FF 
2858   21DD FF FF FF FF 
2858   21E1 FF FF FF FF 
2858   21E5 FF FF FF FF 
2858   21E9 FF FF FF FF 
2858   21ED FF FF FF FF 
2858   21F1 FF FF FF FF 
2858   21F5 FF FF FF FF 
2858   21F9 FF FF FF FF 
2858   21FD FF FF FF FF 
2858   2201 FF FF FF FF 
2858   2205 FF FF FF FF 
2858   2209 FF FF FF FF 
2858   220D FF FF FF FF 
2858   2211 FF FF FF FF 
2858   2215 FF FF FF FF 
2858   2219 FF FF FF FF 
2858   221D FF FF FF FF 
2858   2221 FF FF FF FF 
2858   2225 FF FF FF FF 
2858   2229 FF FF FF FF 
2858   222D FF FF FF FF 
2858   2231 FF FF FF FF 
2858   2235 FF FF FF FF 
2858   2239 FF FF FF FF 
2858   223D FF FF FF FF 
2858   2241 FF FF FF FF 
2858   2245 FF FF FF FF 
2858   2249 FF FF FF FF 
2858   224D FF FF FF FF 
2858   2251 FF FF FF FF 
2858   2255 FF FF FF FF 
2858   2259 FF FF FF FF 
2858   225D FF FF FF FF 
2858   2261 FF FF FF FF 
2858   2265 FF FF FF FF 
2858   2269 FF FF FF FF 
2858   226D FF FF FF FF 
2858   2271 FF FF FF FF 
2858   2275 FF FF FF FF 
2858   2279 FF FF FF FF 
2858   227D FF FF FF FF 
2858   2281 FF FF FF FF 
2858   2285 FF FF FF FF 
2858   2289 FF FF FF FF 
2858   228D FF FF FF FF 
2858   2291 FF FF FF FF 
2858   2295 FF FF FF FF 
2858   2299 FF FF FF FF 
2858   229D FF FF FF FF 
2858   22A1 FF FF FF FF 
2858   22A5 FF FF FF FF 
2858   22A9 FF FF FF FF 
2858   22AD FF FF FF FF 
2858   22B1 FF FF FF FF 
2858   22B5 FF FF FF FF 
2858   22B9 FF FF FF FF 
2858   22BD FF FF FF FF 
2858   22C1 FF FF FF FF 
2858   22C5 FF FF FF FF 
2858   22C9 FF FF FF FF 
2858   22CD FF FF FF FF 
2858   22D1 FF FF FF FF 
2858   22D5 FF FF FF FF 
2858   22D9 FF FF FF FF 
2858   22DD FF FF FF FF 
2858   22E1 FF FF FF FF 
2858   22E5 FF FF FF FF 
2858   22E9 FF FF FF FF 
2858   22ED FF FF FF FF 
2858   22F1 FF FF FF FF 
2858   22F5 FF FF FF FF 
2858   22F9 FF FF FF FF 
2858   22FD FF FF FF FF 
2858   2301 FF FF FF FF 
2858   2305 FF FF FF FF 
2858   2309 FF FF FF FF 
2858   230D FF FF FF FF 
2858   2311 FF FF FF FF 
2858   2315 FF FF FF FF 
2858   2319 FF FF FF FF 
2858   231D FF FF FF FF 
2858   2321 FF FF FF FF 
2858   2325 FF FF FF FF 
2858   2329 FF FF FF FF 
2858   232D FF FF FF FF 
2858   2331 FF FF FF FF 
2858   2335 FF FF FF FF 
2858   2339 FF FF FF FF 
2858   233D FF FF FF FF 
2858   2341 FF FF FF FF 
2858   2345 FF FF FF FF 
2858   2349 FF FF FF FF 
2858   234D FF FF FF FF 
2858   2351 FF FF FF FF 
2858   2355 FF FF FF FF 
2858   2359 FF FF FF FF 
2858   235D FF FF FF FF 
2858   2361 FF FF FF FF 
2858   2365 FF FF FF FF 
2858   2369 FF FF FF FF 
2858   236D FF FF FF FF 
2858   2371 FF FF FF FF 
2858   2375 FF FF FF FF 
2858   2379 FF FF FF FF 
2858   237D FF FF FF FF 
2858   2381 FF FF FF FF 
2858   2385 FF FF FF FF 
2858   2389 FF FF FF FF 
2858   238D FF FF FF FF 
2858   2391 FF FF FF FF 
2858   2395 FF FF FF FF 
2858   2399 FF FF FF FF 
2858   239D FF FF FF FF 
2858   23A1 FF FF FF FF 
2858   23A5 FF FF FF FF 
2858   23A9 FF FF FF FF 
2858   23AD FF FF FF FF 
2858   23B1 FF FF FF FF 
2858   23B5 FF FF FF FF 
2858   23B9 FF FF FF FF 
2858   23BD FF FF FF FF 
2858   23C1 FF FF FF FF 
2858   23C5 FF FF FF FF 
2858   23C9 FF FF FF FF 
2858   23CD FF FF FF FF 
2858   23D1 FF FF FF FF 
2858   23D5 FF FF FF FF 
2858   23D9 FF FF FF FF 
2858   23DD FF FF FF FF 
2858   23E1 FF FF FF FF 
2858   23E5 FF FF FF FF 
2858   23E9 FF FF FF FF 
2858   23ED FF FF FF FF 
2858   23F1 FF FF FF FF 
2858   23F5 FF FF FF FF 
2858   23F9 FF FF FF FF 
2858   23FD FF FF FF FF 
2858   2401 FF FF FF FF 
2858   2405 FF FF FF FF 
2858   2409 FF FF FF FF 
2858   240D FF FF FF FF 
2858   2411 FF FF FF FF 
2858   2415 FF FF FF FF 
2858   2419 FF FF FF FF 
2858   241D FF FF FF FF 
2858   2421 FF FF FF FF 
2858   2425 FF FF FF FF 
2858   2429 FF FF FF FF 
2858   242D FF FF FF FF 
2858   2431 FF FF FF FF 
2858   2435 FF FF FF FF 
2858   2439 FF FF FF FF 
2858   243D FF FF FF FF 
2858   2441 FF FF FF FF 
2858   2445 FF FF FF FF 
2858   2449 FF FF FF FF 
2858   244D FF FF FF FF 
2858   2451 FF FF FF FF 
2858   2455 FF FF FF FF 
2858   2459 FF FF FF FF 
2858   245D FF FF FF FF 
2858   2461 FF FF FF FF 
2858   2465 FF FF FF FF 
2858   2469 FF FF FF FF 
2858   246D FF FF FF FF 
2858   2471 FF FF FF FF 
2858   2475 FF FF FF FF 
2858   2479 FF FF FF FF 
2858   247D FF FF FF FF 
2858   2481 FF FF FF FF 
2858   2485 FF FF FF FF 
2858   2489 FF FF FF FF 
2858   248D FF FF FF FF 
2858   2491 FF FF FF FF 
2858   2495 FF FF FF FF 
2858   2499 FF FF FF FF 
2858   249D FF FF FF FF 
2858   24A1 FF FF FF FF 
2858   24A5 FF FF FF FF 
2858   24A9 FF FF FF FF 
2858   24AD FF FF FF FF 
2858   24B1 FF FF FF FF 
2858   24B5 FF FF FF FF 
2858   24B9 FF FF FF FF 
2858   24BD FF FF FF FF 
2858   24C1 FF FF FF FF 
2858   24C5 FF FF FF FF 
2858   24C9 FF FF FF FF 
2858   24CD FF FF FF FF 
2858   24D1 FF FF FF FF 
2858   24D5 FF FF FF FF 
2858   24D9 FF FF FF FF 
2858   24DD FF FF FF FF 
2858   24E1 FF FF FF FF 
2858   24E5 FF FF FF FF 
2858   24E9 FF FF FF FF 
2858   24ED FF FF FF FF 
2858   24F1 FF FF FF FF 
2858   24F5 FF FF FF FF 
2858   24F9 FF FF FF FF 
2858   24FD FF FF FF FF 
2858   2501 FF FF FF FF 
2858   2505 FF FF FF FF 
2858   2509 FF FF FF FF 
2858   250D FF FF FF FF 
2858   2511 FF FF FF FF 
2858   2515 FF FF FF FF 
2858   2519 FF FF FF FF 
2858   251D FF FF FF FF 
2858   2521 FF FF FF FF 
2858   2525 FF FF FF FF 
2858   2529 FF FF FF FF 
2858   252D FF FF FF FF 
2858   2531 FF FF FF FF 
2858   2535 FF FF FF FF 
2858   2539 FF FF FF FF 
2858   253D FF FF FF FF 
2858   2541 FF FF FF FF 
2858   2545 FF FF FF FF 
2858   2549 FF FF FF FF 
2858   254D FF FF FF FF 
2858   2551 FF FF FF FF 
2858   2555 FF FF FF FF 
2858   2559 FF FF FF FF 
2858   255D FF FF FF FF 
2858   2561 FF FF FF FF 
2858   2565 FF FF FF FF 
2858   2569 FF FF FF FF 
2859   256D             
2860   256D             scrap_sector:
2861   256D FF FF FF FF   .fill 512         ; scrap sector
2861   2571 FF FF FF FF 
2861   2575 FF FF FF FF 
2861   2579 FF FF FF FF 
2861   257D FF FF FF FF 
2861   2581 FF FF FF FF 
2861   2585 FF FF FF FF 
2861   2589 FF FF FF FF 
2861   258D FF FF FF FF 
2861   2591 FF FF FF FF 
2861   2595 FF FF FF FF 
2861   2599 FF FF FF FF 
2861   259D FF FF FF FF 
2861   25A1 FF FF FF FF 
2861   25A5 FF FF FF FF 
2861   25A9 FF FF FF FF 
2861   25AD FF FF FF FF 
2861   25B1 FF FF FF FF 
2861   25B5 FF FF FF FF 
2861   25B9 FF FF FF FF 
2861   25BD FF FF FF FF 
2861   25C1 FF FF FF FF 
2861   25C5 FF FF FF FF 
2861   25C9 FF FF FF FF 
2861   25CD FF FF FF FF 
2861   25D1 FF FF FF FF 
2861   25D5 FF FF FF FF 
2861   25D9 FF FF FF FF 
2861   25DD FF FF FF FF 
2861   25E1 FF FF FF FF 
2861   25E5 FF FF FF FF 
2861   25E9 FF FF FF FF 
2861   25ED FF FF FF FF 
2861   25F1 FF FF FF FF 
2861   25F5 FF FF FF FF 
2861   25F9 FF FF FF FF 
2861   25FD FF FF FF FF 
2861   2601 FF FF FF FF 
2861   2605 FF FF FF FF 
2861   2609 FF FF FF FF 
2861   260D FF FF FF FF 
2861   2611 FF FF FF FF 
2861   2615 FF FF FF FF 
2861   2619 FF FF FF FF 
2861   261D FF FF FF FF 
2861   2621 FF FF FF FF 
2861   2625 FF FF FF FF 
2861   2629 FF FF FF FF 
2861   262D FF FF FF FF 
2861   2631 FF FF FF FF 
2861   2635 FF FF FF FF 
2861   2639 FF FF FF FF 
2861   263D FF FF FF FF 
2861   2641 FF FF FF FF 
2861   2645 FF FF FF FF 
2861   2649 FF FF FF FF 
2861   264D FF FF FF FF 
2861   2651 FF FF FF FF 
2861   2655 FF FF FF FF 
2861   2659 FF FF FF FF 
2861   265D FF FF FF FF 
2861   2661 FF FF FF FF 
2861   2665 FF FF FF FF 
2861   2669 FF FF FF FF 
2861   266D FF FF FF FF 
2861   2671 FF FF FF FF 
2861   2675 FF FF FF FF 
2861   2679 FF FF FF FF 
2861   267D FF FF FF FF 
2861   2681 FF FF FF FF 
2861   2685 FF FF FF FF 
2861   2689 FF FF FF FF 
2861   268D FF FF FF FF 
2861   2691 FF FF FF FF 
2861   2695 FF FF FF FF 
2861   2699 FF FF FF FF 
2861   269D FF FF FF FF 
2861   26A1 FF FF FF FF 
2861   26A5 FF FF FF FF 
2861   26A9 FF FF FF FF 
2861   26AD FF FF FF FF 
2861   26B1 FF FF FF FF 
2861   26B5 FF FF FF FF 
2861   26B9 FF FF FF FF 
2861   26BD FF FF FF FF 
2861   26C1 FF FF FF FF 
2861   26C5 FF FF FF FF 
2861   26C9 FF FF FF FF 
2861   26CD FF FF FF FF 
2861   26D1 FF FF FF FF 
2861   26D5 FF FF FF FF 
2861   26D9 FF FF FF FF 
2861   26DD FF FF FF FF 
2861   26E1 FF FF FF FF 
2861   26E5 FF FF FF FF 
2861   26E9 FF FF FF FF 
2861   26ED FF FF FF FF 
2861   26F1 FF FF FF FF 
2861   26F5 FF FF FF FF 
2861   26F9 FF FF FF FF 
2861   26FD FF FF FF FF 
2861   2701 FF FF FF FF 
2861   2705 FF FF FF FF 
2861   2709 FF FF FF FF 
2861   270D FF FF FF FF 
2861   2711 FF FF FF FF 
2861   2715 FF FF FF FF 
2861   2719 FF FF FF FF 
2861   271D FF FF FF FF 
2861   2721 FF FF FF FF 
2861   2725 FF FF FF FF 
2861   2729 FF FF FF FF 
2861   272D FF FF FF FF 
2861   2731 FF FF FF FF 
2861   2735 FF FF FF FF 
2861   2739 FF FF FF FF 
2861   273D FF FF FF FF 
2861   2741 FF FF FF FF 
2861   2745 FF FF FF FF 
2861   2749 FF FF FF FF 
2861   274D FF FF FF FF 
2861   2751 FF FF FF FF 
2861   2755 FF FF FF FF 
2861   2759 FF FF FF FF 
2861   275D FF FF FF FF 
2861   2761 FF FF FF FF 
2861   2765 FF FF FF FF 
2861   2769 FF FF FF FF 
2862   276D             transient_area:
2863   276D 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2864   276E             
2865   276E             .end
tasm: Number of errors = 0
