0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; For the next iteration:
0086   0000             ; boot-sector(1) | kernel-sectors(32) | inode-bitmap | rawdata-bitmap | inode-table | raw-disk-data
0087   0000             ; inode-table format:
0088   0000             ;  file-type(f, d)
0089   0000             ;  permissons
0090   0000             ;  link-count
0091   0000             ;  filesize
0092   0000             ;  time-stamps
0093   0000             ;  15 data block pointers
0094   0000             ;  single-indirect pointer
0095   0000             
0096   0000             ; FILE ENTRY ATTRIBUTES
0097   0000             ; filename (24)
0098   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0099   0000             ; LBA (2)              : location of raw data for file entry, or dirID for directory entry
0100   0000             ; size (2)             : filesize
0101   0000             ; day (1)           
0102   0000             ; month (1)
0103   0000             ; year (1)
0104   0000             ; packet size = 32 bytes  : total packet size in bytes
0105   0000             
0106   0000             FST_ENTRY_SIZE          .equ 32  ; bytes
0107   0000             FST_FILES_PER_SECT      .equ (512 / FST_ENTRY_SIZE)
0108   0000             FST_FILES_PER_DIR       .equ (512 / FST_ENTRY_SIZE)
0109   0000             FST_NBR_DIRECTORIES     .equ 64
0110   0000                                     ; 1 sector for header, the rest is for the list of files/dirs
0111   0000             FST_SECTORS_PER_DIR     .equ (1 + (FST_ENTRY_SIZE * FST_FILES_PER_DIR / 512))    
0112   0000             FST_TOTAL_SECTORS       .equ (FST_SECTORS_PER_DIR * FST_NBR_DIRECTORIES)
0113   0000             FST_LBA_START           .equ 32
0114   0000             FST_LBA_END             .equ (FST_LBA_START + FST_TOTAL_SECTORS - 1)
0115   0000             
0116   0000             FS_NBR_FILES            .equ (FST_NBR_DIRECTORIES * FST_FILES_PER_DIR)
0117   0000             FS_SECTORS_PER_FILE     .equ 32 ; the first sector is always a header with a NULL parameter (first byte)
0118   0000                                             ; so that we know which blocks are free or taken
0119   0000             FS_FILE_SIZE            .equ (FS_SECTORS_PER_FILE * 512)                  
0120   0000             FS_TOTAL_SECTORS        .equ (FS_NBR_FILES * FS_SECTORS_PER_FILE)
0121   0000             FS_LBA_START            .equ (FST_LBA_END + 1)
0122   0000             FS_LBA_END              .equ (FS_LBA_START + FS_NBR_FILES - 1)
0123   0000             
0124   0000             root_id:                .equ FST_LBA_START
0125   0000             
0126   0000             ; ------------------------------------------------------------------------------------------------------------------;
0127   0000             ; GLOBAL SYSTEM VARIABLES
0128   0000             ; ------------------------------------------------------------------------------------------------------------------;
0129   0000             
0130   0000             ; ------------------------------------------------------------------------------------------------------------------;
0131   0000             ; IRQ table
0132   0000             ; highest priority at lowest address
0133   0000             ; ------------------------------------------------------------------------------------------------------------------;
0134   0000 3C 00       .dw int_0_fdc
0135   0002 43 00       .dw int_1
0136   0004 44 00       .dw int_2
0137   0006 45 00       .dw int_3
0138   0008 46 00       .dw int_4
0139   000A 47 00       .dw int_5
0140   000C 59 00       .dw int_6
0141   000E A5 00       .dw int_7_uart0
0142   0010             
0143   0010             ; ------------------------------------------------------------------------------------------------------------------;
0144   0010             ; kernel reset vector
0145   0010             ; ------------------------------------------------------------------------------------------------------------------;
0146   0010 47 10       .dw kernel_reset_vector
0147   0012             
0148   0012             ; ------------------------------------------------------------------------------------------------------------------;
0149   0012             ; exception vector table
0150   0012             ; total of 7 entries, starting at address $0012
0151   0012             ; ------------------------------------------------------------------------------------------------------------------;
0152   0012 3F 02       .dw trap_privilege
0153   0014 5C 03       .dw trap_div_zero
0154   0016 69 03       .dw trap_undef_opcode
0155   0018 00 00       .dw 0
0156   001A 00 00       .dw 0
0157   001C 00 00       .dw 0
0158   001E 00 00       .dw 0
0159   0020             
0160   0020             ; ------------------------------------------------------------------------------------------------------------------;
0161   0020             ; system call vector table
0162   0020             ; starts at address $0020
0163   0020             ; ------------------------------------------------------------------------------------------------------------------;
0164   0020 4B 02       .dw syscall_break
0165   0022 6A 03       .dw syscall_rtc
0166   0024 A4 04       .dw syscall_ide
0167   0026 7F 05       .dw syscall_io
0168   0028 3C 06       .dw syscall_file_system
0169   002A 94 0F       .dw syscall_create_proc
0170   002C 04 02       .dw syscall_list_procs
0171   002E 9C 03       .dw syscall_datetime
0172   0030 C0 01       .dw syscall_reboot
0173   0032 5E 0F       .dw syscall_pause_proc
0174   0034 CC 01       .dw syscall_resume_proc
0175   0036 1B 0F       .dw syscall_terminate_proc
0176   0038 E4 00       .dw syscall_system
0177   003A 14 01       .dw syscall_fdc
0178   003C             
0179   003C             ; ------------------------------------------------------------------------------------------------------------------;
0180   003C             ; system call aliases
0181   003C             ; ------------------------------------------------------------------------------------------------------------------;
0182   003C             sys_break            .equ 0
0183   003C             sys_rtc              .equ 1
0184   003C             sys_ide              .equ 2
0185   003C             sys_io               .equ 3
0186   003C             sys_filesystem       .equ 4
0187   003C             sys_create_proc      .equ 5
0188   003C             sys_list_proc        .equ 6
0189   003C             sys_datetime         .equ 7
0190   003C             sys_reboot           .equ 8
0191   003C             sys_pause_proc       .equ 9
0192   003C             sys_resume_proc      .equ 10
0193   003C             sys_terminate_proc   .equ 11
0194   003C             sys_system           .equ 12
0195   003C             sys_fdc              .equ 13
0196   003C             
0197   003C             ; ------------------------------------------------------------------------------------------------------------------;
0198   003C             ; alias exports
0199   003C             ; ------------------------------------------------------------------------------------------------------------------;
0200   003C             .export text_org
0201   003C             .export sys_break
0202   003C             .export sys_rtc
0203   003C             .export sys_ide
0204   003C             .export sys_io
0205   003C             .export sys_filesystem
0206   003C             .export sys_create_proc
0207   003C             .export sys_list_proc
0208   003C             .export sys_datetime
0209   003C             .export sys_reboot
0210   003C             .export sys_pause_proc
0211   003C             .export sys_resume_proc
0212   003C             .export sys_terminate_proc
0213   003C             .export sys_system
0214   003C             .export sys_fdc
0215   003C             
0216   003C             ; ------------------------------------------------------------------------------------------------------------------;
0217   003C             ; IRQs' code block
0218   003C             ; ------------------------------------------------------------------------------------------------------------------;
0219   003C             ; 5.25" Floppy Drive Controller IRQ
0220   003C             int_0_fdc:
0221   003C 3B 48 00      mov d, s_fdc_irq
0222   003F 07 91 12      call _puts
0223   0042 06            sysret
0224   0043             int_1:
0225   0043 06            sysret
0226   0044             int_2:
0227   0044 06            sysret
0228   0045             int_3:
0229   0045 06            sysret
0230   0046             int_4:
0231   0046 06            sysret
0232   0047             int_5:
0233   0047 06            sysret
0234   0048             
0235   0048 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
0235   004C 30 20 45 78 
0235   0050 65 63 75 74 
0235   0054 65 64 2E 0A 
0235   0058 00 
0236   0059             
0237   0059             ; ------------------------------------------------------------------------------------------------------------------;
0238   0059             ; process swapping
0239   0059             ; ------------------------------------------------------------------------------------------------------------------;
0240   0059             int_6:  
0241   0059 4B            pusha                             ; save all registers into kernel stack
0242   005A 22 00         mov ah, 0
0243   005C 1D C2 17      mov al, [active_proc_index]
0244   005F FD 99         shl a                             ; x2
0245   0061 B7 11 10      mov a, [proc_table_convert + a]   ; get process state start index
0246   0064 4F            mov di, a
0247   0065 48            mov a, sp
0248   0066 77            inc a
0249   0067 4D            mov si, a
0250   0068 38 14 00      mov c, 20
0251   006B FD F5         rep movsb                         ; save process state!
0252   006D             ; restore kernel stack position to point before interrupt arrived
0253   006D 51 14 00      add sp, 20
0254   0070             ; now load next process in queue
0255   0070 1D C2 17      mov al, [active_proc_index]
0256   0073 31 C1 17      mov bl, [nbr_active_procs]
0257   0076 BA            cmp al, bl
0258   0077 C6 7E 00      je int6_cycle_back
0259   007A 7A            inc al                            ; next process is next in the series
0260   007B 0A 80 00      jmp int6_continue
0261   007E             int6_cycle_back:
0262   007E 19 01         mov al, 1                         ; next process = process 1
0263   0080             int6_continue:
0264   0080 3D C2 17      mov [active_proc_index], al       ; set next active proc
0265   0083             
0266   0083             ; calculate LUT entry for next process
0267   0083 22 00         mov ah, 0
0268   0085 FD 99         shl a                             ; x2
0269   0087 B7 11 10      mov a, [proc_table_convert + a]   ; get process state start index  
0270   008A               
0271   008A 4D            mov si, a                         ; source is proc state block
0272   008B 48            mov a, sp
0273   008C 5F 13 00      sub a, 19
0274   008F 4F            mov di, a                         ; destination is kernel stack
0275   0090             ; restore SP
0276   0090 7D            dec a
0277   0091 47            mov sp, a
0278   0092 38 14 00      mov c, 20
0279   0095 FD F5         rep movsb
0280   0097             ; set VM process
0281   0097 1D C2 17      mov al, [active_proc_index]
0282   009A 01            setptb
0283   009B F2 E0 FF 00   mov byte[_TIMER_C_0], 0           ; load counter 0 low byte
0284   009F F2 E0 FF 10   mov byte[_TIMER_C_0], $10         ; load counter 0 high byte
0285   00A3 4C            popa
0286   00A4 06            sysret
0287   00A5             
0288   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0289   00A5             ; UART0 Interrupt
0290   00A5             ; ------------------------------------------------------------------------------------------------------------------;
0291   00A5             int_7_uart0:
0292   00A5 D7            push a
0293   00A6 DA            push d
0294   00A7 E1            pushf
0295   00A8 14 C7 17      mov a, [fifo_in]
0296   00AB 3C            mov d, a
0297   00AC 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0298   00AF B9 03         cmp al, $03                 ; CTRL-C
0299   00B1 C6 CE 00      je CTRLC
0300   00B4 B9 1A         cmp al, $1A                 ; CTRL-Z
0301   00B6 C6 D4 00      je CTRLZ
0302   00B9 3E            mov [d], al                 ; add to fifo
0303   00BA 14 C7 17      mov a, [fifo_in]
0304   00BD 77            inc a
0305   00BE AF 08 25      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0306   00C1 C7 C7 00      jne int_7_continue
0307   00C4 10 08 21      mov a, fifo  
0308   00C7             int_7_continue:  
0309   00C7 42 C7 17      mov [fifo_in], a            ; update fifo pointer
0310   00CA EE            popf
0311   00CB E7            pop d
0312   00CC E4            pop a  
0313   00CD 06            sysret
0314   00CE             CTRLC:
0315   00CE 51 05 00      add sp, 5
0316   00D1 0A 1B 0F      jmp syscall_terminate_proc
0317   00D4             CTRLZ:
0318   00D4 EE            popf
0319   00D5 E7            pop d
0320   00D6 E4            pop a
0321   00D7 0A 5E 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0322   00DA             
0323   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0324   00DA             ; system syscalls
0325   00DA             ; ------------------------------------------------------------------------------------------------------------------;
0326   00DA             system_jmptbl:
0327   00DA 10 01         .dw system_uname
0328   00DC 11 01         .dw system_whoami
0329   00DE 0D 01         .dw system_setparam
0330   00E0 EA 00         .dw system_bootloader_install
0331   00E2 E8 00         .dw system_getparam
0332   00E4             syscall_system:
0333   00E4 FD 0A DA 00   jmp [system_jmptbl + al]
0334   00E8             
0335   00E8             ; param register address in register d
0336   00E8             ; param value in register bl
0337   00E8             system_getparam:
0338   00E8 32            mov bl, [d]
0339   00E9 06            sysret
0340   00EA             
0341   00EA             ; kernel LBA address in 'b'
0342   00EA             system_bootloader_install:
0343   00EA D8            push b
0344   00EB 26 00 00      mov b, 0
0345   00EE 38 00 00      mov c, 0
0346   00F1 22 01         mov ah, $01                 ; 1 sector
0347   00F3 3B 08 27      mov d, transient_area
0348   00F6 07 EE 04      call ide_read_sect          ; read sector
0349   00F9 E5            pop b
0350   00FA FD 44 FE 01   mov [d + 510], b            ; update LBA address
0351   00FE 26 00 00      mov b, 0
0352   0101 38 00 00      mov c, 0
0353   0104 22 01         mov ah, $01                 ; 1 sector
0354   0106 3B 08 27      mov d, transient_area
0355   0109 07 14 05      call ide_write_sect         ; write sector
0356   010C 06            sysret
0357   010D             
0358   010D             ; param register address in register d
0359   010D             ; param value in register bl
0360   010D             system_setparam:
0361   010D FD 3E         mov [d], bl
0362   010F 06            sysret
0363   0110             
0364   0110             system_uname:
0365   0110 06            sysret
0366   0111             
0367   0111             system_whoami:
0368   0111 06            sysret
0369   0112             
0370   0112             
0371   0112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0372   0112             ; floppy drive system calls
0373   0112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0374   0112             ; the floppy control below is not yet tested. it needs to be tested.
0375   0112             ; fdc_40_FF:     .fill 40,  $FF  ; or 00                                                                                
0376   0112             ; fdc_6_00_0:    .fill 6,   $00  ;                                                                            <--|        
0377   0112             ; fdc_id_fe:     .fill 1,   $FE  ; ID Address Mark                                                               |        
0378   0112             ; fdc_track:     .fill 1,   $00  ; Track Number                                                                  |                    
0379   0112             ; fdc_side:      .fill 1,   $00  ; Side Number 00 or 01                                                          |                
0380   0112             ; fdc_sector:    .fill 1,   $01  ; Sector Number  1 through 10                                                   |                              
0381   0112             ; fdc_length:    .fill 1,   $00  ; Sector Length                                                                 |                        
0382   0112             ; fdc_2_crc_0:   .fill 1,   $F7  ; 2 CRC's Written                                                               | Write 16 times                 
0383   0112             ; fdc_11_ff:     .fill 11,  $FF  ; or 00                                                                         |                      
0384   0112             ; fdc_6_00_1:    .fill 6,   $00  ;                                                                               |                        
0385   0112             ; fdc_data_addr: .fill 1,   $FB  ; Data Address Mark                                                             |                                  
0386   0112             ; fdc_data:      .fill 128, $E5  ; Data (IBM uses E5)                                                            |                                      
0387   0112             ; fdc_2_crc_1:   .fill 1,   $F7  ; 2 CRC's Written                                                               |                                                        
0388   0112             ; fdc_10_ff:     .fill 10,  $FF  ; or 00                                                                      <--|                                                  
0389   0112             ; fdc_369_ff:    .fill 369, $FF  ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0390   0112             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0391   0112             ; _FDC_CONFIG       .equ $FFC0 
0392   0112             ; _FDC_STATUS_1     .equ $FFC1
0393   0112             ; _FDC_WD_STAT_CMD  .equ $FFC8
0394   0112             ; _FDC_WD_TRACK     .equ $FFC9
0395   0112             ; _FDC_WD_SECTOR    .equ $FFCA
0396   0112             ; _FDC_WD_DATA      .equ $FFCB
0397   0112             fdc_jmptbl:
0398   0112 18 01         .dw syscall_fdc_format
0399   0114             syscall_fdc:
0400   0114 FD 0A 12 01   jmp [fdc_jmptbl + al]
0401   0118             
0402   0118             syscall_fdc_format:
0403   0118 3B 94 01      mov d, s_format_begin
0404   011B 07 91 12      call _puts
0405   011E FD 22 FF 00   mov g, $FF
0406   0122             fdc_wait_busy:
0407   0122 1D C8 FF      mov al, [_FDC_WD_STAT_CMD] ; read wd1770 status register
0408   0125 87 01         and al, $01                ; busy bit
0409   0127 C7 22 01      jnz fdc_wait_busy
0410   012A             
0411   012A FD 4D F6 18   mov si, fdc_40_FF
0412   012E 38 D1 00      mov c, 209
0413   0131 3B 79 01      mov d, s_send_write_cmd
0414   0134 07 91 12      call _puts
0415   0137 3B C8 FF      mov d, _FDC_WD_STAT_CMD
0416   013A 19 F2         mov al, %11110010          ; Write Track Command: {1111, 0: Enable Spin-up Seq, 0: No Settling Delay, 1: No Write Precompensation, 0}
0417   013C 3E            mov [d], al
0418   013D             fdc_sector_loop:
0419   013D             fdc_drq_loop:
0420   013D 3B C1 FF      mov d, _FDC_STATUS_1
0421   0140 1E            mov al, [d]
0422   0141 87 01         and al, $01                ; check drq bit
0423   0143 C6 3D 01      jz fdc_drq_loop
0424   0146 F6            lodsb                      ; load format byte
0425   0147 3B CB FF      mov d, _FDC_WD_DATA        ; data register
0426   014A 3E            mov [d], al                ; send data byte to wd1770
0427   014B 7E            dec c
0428   014C C7 3D 01      jnz fdc_sector_loop
0429   014F 3B 27 19      mov d, fdc_sector
0430   0152 32            mov bl, [d]
0431   0153 FD 77         inc b
0432   0155 FD 3E         mov [d], bl
0433   0157 C1 0B         cmp bl, 11
0434   0159 C7 3D 01      jne fdc_sector_loop        ; continue formatting
0435   015C             
0436   015C             ; here all the sectors have been written. now fill in remaining of the track until wd1770 interrupts out
0437   015C             fdc_drq_loop_fill:
0438   015C 3B C1 FF      mov d, _FDC_STATUS_1
0439   015F 1E            mov al, [d]
0440   0160 87 01         and al, $01                ; check drq bit
0441   0162 C6 5C 01      jz fdc_drq_loop_fill
0442   0165 3B CB FF      mov d, _FDC_WD_DATA        ; data register
0443   0168 FD 1A         mov al, gl
0444   016A 3E            mov [d], al                ; send data byte to wd1770
0445   016B 0C            lodstat
0446   016C 1A            mov al, ah
0447   016D 87 01         and al, $01
0448   016F C6 5C 01      jz fdc_drq_loop_fill
0449   0172             
0450   0172 3B AD 01      mov d, s_format_done
0451   0175 07 91 12      call _puts
0452   0178             
0453   0178 06            sysret
0454   0179             
0455   0179 0A 53 65 6E s_send_write_cmd: .db "\nSending Write Command...\n", 0
0455   017D 64 69 6E 67 
0455   0181 20 57 72 69 
0455   0185 74 65 20 43 
0455   0189 6F 6D 6D 61 
0455   018D 6E 64 2E 2E 
0455   0191 2E 0A 00 
0456   0194 0A 46 6F 72 s_format_begin:   .db "\nFormatting starting...\n", 0
0456   0198 6D 61 74 74 
0456   019C 69 6E 67 20 
0456   01A0 73 74 61 72 
0456   01A4 74 69 6E 67 
0456   01A8 2E 2E 2E 0A 
0456   01AC 00 
0457   01AD 0A 46 6F 72 s_format_done:    .db "\nFormatting done.\n", 0
0457   01B1 6D 61 74 74 
0457   01B5 69 6E 67 20 
0457   01B9 64 6F 6E 65 
0457   01BD 2E 0A 00 
0458   01C0             
0459   01C0             ; REBOOT SYSTEM
0460   01C0             syscall_reboot:
0461   01C0 FD D7 FF FF   push word $FFFF 
0462   01C4 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0463   01C7 FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0464   01CB 06            sysret
0465   01CC             
0466   01CC             ;------------------------------------------------------------------------------------------------------;;
0467   01CC             ; switch to another process
0468   01CC             ; inputs:
0469   01CC             ; AL = new process number
0470   01CC             ;------------------------------------------------------------------------------------------------------;;
0471   01CC             syscall_resume_proc:
0472   01CC FD 78         mov g, a                            ; save the process number
0473   01CE 4B            pusha                               ; save all registers into kernel stack
0474   01CF 22 00         mov ah, 0
0475   01D1 1D C2 17      mov al, [active_proc_index]
0476   01D4 FD 99         shl a              ; x2
0477   01D6 B7 11 10      mov a, [proc_table_convert + a]     ; get process state start index
0478   01D9 4F            mov di, a
0479   01DA 48            mov a, sp
0480   01DB 77            inc a
0481   01DC 4D            mov si, a
0482   01DD 38 14 00      mov c, 20
0483   01E0 FD F5         rep movsb                           ; save process state!
0484   01E2             ; restore kernel stack position to point before interrupt arrived
0485   01E2 51 14 00      add sp, 20
0486   01E5             ; now load the new process number!
0487   01E5 FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0488   01E7 3D C2 17      mov [active_proc_index], al         ; set new active proc
0489   01EA             ; calculate LUT entry for next process
0490   01EA 22 00         mov ah, 0
0491   01EC FD 99         shl a                               ; x2
0492   01EE B7 11 10      mov a, [proc_table_convert + a]     ; get process state start index  
0493   01F1 4D            mov si, a                           ; source is proc state block
0494   01F2 48            mov a, sp
0495   01F3 5F 13 00      sub a, 19
0496   01F6 4F            mov di, a                           ; destination is kernel stack
0497   01F7             ; restore SP
0498   01F7 7D            dec a
0499   01F8 47            mov sp, a
0500   01F9 38 14 00      mov c, 20
0501   01FC FD F5         rep movsb
0502   01FE             ; set VM process
0503   01FE 1D C2 17      mov al, [active_proc_index]
0504   0201 01            setptb
0505   0202 4C            popa
0506   0203 06            sysret
0507   0204             
0508   0204             ;------------------------------------------------------------------------------------------------------;;
0509   0204             ; list processes
0510   0204             ;------------------------------------------------------------------------------------------------------;;
0511   0204             syscall_list_procs:
0512   0204 3B EA 17      mov d, s_ps_header
0513   0207 07 91 12      call _puts
0514   020A 3B 79 1C      mov d, proc_availab_table + 1
0515   020D 38 01 00      mov c, 1
0516   0210             list_procs_L0:  
0517   0210 BD 01         cmp byte[d], 1
0518   0212 C7 36 02      jne list_procs_next
0519   0215 2D            mov b, d
0520   0216 61 78 1C      sub b, proc_availab_table
0521   0219 FD 9F 05      shl b, 5
0522   021C DA            push d
0523   021D D8            push b
0524   021E 28            mov b, c
0525   021F 07 31 13      call print_u8x
0526   0222 22 20         mov ah, ' '
0527   0224 07 65 11      call _putchar
0528   0227 07 65 11      call _putchar
0529   022A E5            pop b
0530   022B 74            mov d, b
0531   022C 58 88 1C      add d, proc_names
0532   022F 07 91 12      call _puts
0533   0232 07 3E 12      call printnl
0534   0235 E7            pop d
0535   0236             list_procs_next:
0536   0236 79            inc d
0537   0237 78            inc c
0538   0238 C2 09 00      cmp c, 9
0539   023B C7 10 02      jne list_procs_L0
0540   023E             list_procs_end:
0541   023E 06            sysret
0542   023F             
0543   023F             ; ------------------------------------------------------------------------------------------------------------------;
0544   023F             ; exceptions code block
0545   023F             ; ------------------------------------------------------------------------------------------------------------------;
0546   023F             ; privilege exception
0547   023F             ; ------------------------------------------------------------------------------------------------------------------;
0548   023F             trap_privilege:
0549   023F 0A C0 01      jmp syscall_reboot
0550   0242 DA            push d
0551   0243 3B 39 18      mov d, s_priviledge
0552   0246 07 91 12      call _puts
0553   0249 E7            pop d
0554   024A 06            sysret
0555   024B             
0556   024B             ; ------------------------------------------------------------------------------------------------------------------;
0557   024B             ; breakpoint
0558   024B             ; IMPORTANT: values in the stack are being pushed in big endian. i.e.: MSB at low address
0559   024B             ; and LSB at high address. *** NEED TO CORRECT THIS IN THE MICROCODE and make it little endian again ***
0560   024B             ; ------------------------------------------------------------------------------------------------------------------;
0561   024B             syscall_break:
0562   024B 4B            pusha
0563   024C             syscall_break_prompt:
0564   024C 3B 06 03      mov d, s_break1
0565   024F 07 91 12      call _puts
0566   0252 07 3E 12      call printnl
0567   0255 07 93 13      call scan_u16d
0568   0258 AF 00 00      cmp a, 0
0569   025B C6 66 02      je syscall_break_regs
0570   025E AF 01 00      cmp a, 1
0571   0261 C6 89 02      je syscall_break_mem
0572   0264             syscall_break_end:  
0573   0264 4C            popa
0574   0265 06            sysret
0575   0266             syscall_break_regs:
0576   0266 48            mov a, sp
0577   0267 53 0E 00      add a, 14               ; back-track 7 registers
0578   026A 3C            mov d, a
0579   026B 3A 07         mov cl, 7
0580   026D             syscall_regs_L0:
0581   026D 2A            mov b, [d]
0582   026E FD AB         swp b
0583   0270 07 ED 12      call print_u16x         ; print register value
0584   0273 07 3E 12      call printnl
0585   0276 63 02 00      sub d, 2
0586   0279 71 01         sub cl, 1
0587   027B C3 00         cmp cl, 0
0588   027D C7 6D 02      jne syscall_regs_L0
0589   0280 0A 4C 02      jmp syscall_break_prompt
0590   0283 07 3E 12      call printnl
0591   0286 0A 4C 02      jmp syscall_break_prompt
0592   0289             syscall_break_mem:
0593   0289 07 3E 12      call printnl
0594   028C 07 0F 13      call scan_u16x
0595   028F 4D            mov si, a               ; data source from user space
0596   0290 FD 4F 08 25   mov di, scrap_sector    ; destination in kernel space
0597   0294 38 00 02      mov c, 512
0598   0297 04            load                    ; transfer data to kernel space!
0599   0298 3B 08 25      mov d, scrap_sector     ; dump pointer in d
0600   029B 38 00 00      mov c, 0
0601   029E             dump_loop:
0602   029E 84            mov al, cl
0603   029F 87 0F         and al, $0F
0604   02A1 C6 EF 02      jz print_base
0605   02A4             back:
0606   02A4 1E            mov al, [d]             ; read byte
0607   02A5 2F            mov bl, al
0608   02A6 07 31 13      call print_u8x
0609   02A9 10 00 20      mov a, $2000
0610   02AC 05 03         syscall sys_io          ; space
0611   02AE 84            mov al, cl
0612   02AF 87 0F         and al, $0F
0613   02B1 B9 0F         cmp al, $0F
0614   02B3 C6 C4 02      je print_ascii
0615   02B6             back1:
0616   02B6 79            inc d
0617   02B7 78            inc c
0618   02B8 C2 00 02      cmp c, 512
0619   02BB C7 9E 02      jne dump_loop
0620   02BE 07 3E 12      call printnl
0621   02C1 0A 4C 02      jmp syscall_break_prompt  ; go to syscall_break return point
0622   02C4             print_ascii:
0623   02C4 10 00 20      mov a, $2000
0624   02C7 05 03         syscall sys_io
0625   02C9 63 10 00      sub d, 16
0626   02CC 26 10 00      mov b, 16
0627   02CF             print_ascii_L:
0628   02CF 79            inc d
0629   02D0 1E            mov al, [d]               ; read byte
0630   02D1 B9 20         cmp al, $20
0631   02D3 C8 DB 02      jlu dot
0632   02D6 B9 7E         cmp al, $7E
0633   02D8 D0 E3 02      jleu ascii
0634   02DB             dot:
0635   02DB 10 00 2E      mov a, $2E00
0636   02DE 05 03         syscall sys_io
0637   02E0 0A E8 02      jmp ascii_continue
0638   02E3             ascii:
0639   02E3 23            mov ah, al
0640   02E4 19 00         mov al, 0
0641   02E6 05 03         syscall sys_io
0642   02E8             ascii_continue:
0643   02E8 FD A9 CF 02   loopb print_ascii_L
0644   02EC 0A B6 02      jmp back1
0645   02EF             print_base:
0646   02EF 07 3E 12      call printnl
0647   02F2 2D            mov b, d
0648   02F3 61 08 25      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
0649   02F6 07 ED 12      call print_u16x          ; display row
0650   02F9 10 00 3A      mov a, $3A00
0651   02FC 05 03         syscall sys_io
0652   02FE 10 00 20      mov a, $2000
0653   0301 05 03         syscall sys_io
0654   0303 0A A4 02      jmp back
0655   0306             
0656   0306             s_break1:  
0657   0306 0A 44 65 62   .db "\nDebugger entry point.\n"
0657   030A 75 67 67 65 
0657   030E 72 20 65 6E 
0657   0312 74 72 79 20 
0657   0316 70 6F 69 6E 
0657   031A 74 2E 0A 
0658   031D 30 2E 20 53   .db "0. Show Registers\n"
0658   0321 68 6F 77 20 
0658   0325 52 65 67 69 
0658   0329 73 74 65 72 
0658   032D 73 0A 
0659   032F 31 2E 20 53   .db "1. Show 512B RAM block\n"
0659   0333 68 6F 77 20 
0659   0337 35 31 32 42 
0659   033B 20 52 41 4D 
0659   033F 20 62 6C 6F 
0659   0343 63 6B 0A 
0660   0346 32 2E 20 43   .db "2. Continue Execution", 0
0660   034A 6F 6E 74 69 
0660   034E 6E 75 65 20 
0660   0352 45 78 65 63 
0660   0356 75 74 69 6F 
0660   035A 6E 00 
0661   035C             
0662   035C             ; ------------------------------------------------------------------------------------------------------------------;
0663   035C             ; divide by zero exception
0664   035C             ; ------------------------------------------------------------------------------------------------------------------;
0665   035C             trap_div_zero:
0666   035C D7            push a
0667   035D DA            push d
0668   035E E1            pushf
0669   035F 3B 50 18      mov d, s_divzero
0670   0362 07 91 12      call _puts
0671   0365 EE            popf
0672   0366 E7            pop d
0673   0367 E4            pop a
0674   0368 06            sysret ; enable interrupts
0675   0369             
0676   0369             ; ------------------------------------------------------------------------------------------------------------------;
0677   0369             ; undefined opcode exception
0678   0369             ; ------------------------------------------------------------------------------------------------------------------;
0679   0369             trap_undef_opcode:
0680   0369 06            sysret
0681   036A             
0682   036A             ; ------------------------------------------------------------------------------------------------------------------;
0683   036A             ; real-time clock services syscall
0684   036A             ; RTC I/O bank = FFA0 to FFAF
0685   036A             ; FFA0 to FFA7 is scratch RAM
0686   036A             ; Control register at $FFA8 [ W | R | S | Cal4..Cal0 ]
0687   036A             ; al = 0..6 -> get
0688   036A             ; al = 7..D -> set
0689   036A             ; ------------------------------------------------------------------------------------------------------------------;
0690   036A             syscall_rtc:
0691   036A DB            push al
0692   036B DA            push d
0693   036C B9 06         cmp al, 6
0694   036E D1 83 03      jgu syscall_rtc_set
0695   0371             syscall_rtc_get:
0696   0371 6A A9         add al, $A9             ; generate RTC address to get to address A9 of clock
0697   0373 22 FF         mov ah, $FF    
0698   0375 3C            mov d, a                ; get to FFA9 + offset
0699   0376 F2 A8 FF 40   mov byte[$FFA8], $40    ; set R bit to 1
0700   037A 1E            mov al, [d]             ; get data
0701   037B F2 A8 FF 00   mov byte[$FFA8], 0      ; reset R bit
0702   037F 23            mov ah, al
0703   0380 E7            pop d
0704   0381 E8            pop al
0705   0382 06            sysret
0706   0383             syscall_rtc_set:
0707   0383 DD            push bl
0708   0384 99            mov bl, ah              ; set data asIDE
0709   0385 6A A2         add al, $A2             ; generate RTC address to get to address A9 of clock
0710   0387 22 FF         mov ah, $FF    
0711   0389 3C            mov d, a                ; get to FFA9 + offset
0712   038A 1B            mov al, bl              ; get data back
0713   038B F2 A8 FF 80   mov byte[$FFA8], $80    ; set W bit to 1
0714   038F 3E            mov [d], al             ; set data
0715   0390 F2 A8 FF 00   mov byte[$FFA8], 0      ; reset write bit
0716   0394 EA            pop bl
0717   0395 E7            pop d
0718   0396 E8            pop al
0719   0397 06            sysret
0720   0398             
0721   0398             datetime_serv_tbl:
0722   0398 A0 03         .dw print_date
0723   039A 14 04         .dw set_date
0724   039C             syscall_datetime:
0725   039C FD 0A 98 03   jmp [datetime_serv_tbl + al]      
0726   03A0             print_date:
0727   03A0 10 00 0D      mov a, $0D00           ; print carriage return char
0728   03A3 19 03         mov al, 3
0729   03A5 05 01         syscall sys_rtc        ; get week
0730   03A7 1A            mov al, ah
0731   03A8 22 00         mov ah, 0
0732   03AA FD 9D 02      shl a, 2          
0733   03AD 3B DA 18      mov d, s_week
0734   03B0 59            add d, a
0735   03B1 07 91 12      call _puts
0736   03B4 10 00 20      mov a, $2000
0737   03B7 05 03         syscall sys_io         ; display ' '
0738   03B9 19 04         mov al, 4
0739   03BB 05 01         syscall sys_rtc        ; get day
0740   03BD 99            mov bl, ah
0741   03BE 07 31 13      call print_u8x
0742   03C1 10 00 20      mov a, $2000
0743   03C4 05 03         syscall sys_io         ; display ' '
0744   03C6             ; there is a problem with the month displaying
0745   03C6             ; the month is stored as BCD. so when retrieving the month, the value will be in binary
0746   03C6             ; even though it is to be understood as BCD.
0747   03C6             ; when retrieving the value and adding the string table address offset the value will go overboard!  
0748   03C6 19 05         mov al, 05
0749   03C8 05 01         syscall sys_rtc        ; get month
0750   03CA 1A            mov al, ah
0751   03CB 22 00         mov ah, 0
0752   03CD FD 9D 02      shl a, 2          
0753   03D0 3B A6 18      mov d, s_months
0754   03D3 59            add d, a
0755   03D4 07 91 12      call _puts
0756   03D7 10 00 20      mov a, $2000
0757   03DA 05 03         syscall sys_io         ; display ' '
0758   03DC 2E 20         mov bl, $20
0759   03DE 07 31 13      call print_u8x         ; print 20 for year prefix
0760   03E1 19 06         mov al, 06
0761   03E3 05 01         syscall sys_rtc        ; get year
0762   03E5 99            mov bl, ah
0763   03E6 07 31 13      call print_u8x
0764   03E9 10 00 20      mov a, $2000  
0765   03EC 05 03         syscall sys_io         ; display ' '
0766   03EE 19 02         mov al, 2
0767   03F0 05 01         syscall sys_rtc        ; get hours
0768   03F2 99            mov bl, ah
0769   03F3 07 31 13      call print_u8x
0770   03F6 10 00 3A      mov a, $3A00    
0771   03F9 05 03         syscall sys_io         ; display ':'
0772   03FB 19 01         mov al, 01
0773   03FD 05 01         syscall sys_rtc        ; get minutes
0774   03FF 99            mov bl, ah
0775   0400 07 31 13      call print_u8x
0776   0403 10 00 3A      mov a, $3A00  
0777   0406 05 03         syscall sys_io         ; display ':'
0778   0408 19 00         mov al, 0
0779   040A 05 01         syscall sys_rtc        ; get seconds
0780   040C 99            mov bl, ah
0781   040D 07 31 13      call print_u8x
0782   0410 07 3E 12      call printnl
0783   0413 06            sysret
0784   0414             set_date:
0785   0414 3B 6B 18      mov d, s_set_year
0786   0417 07 91 12      call _puts
0787   041A 07 7C 13      call scan_u8x          ; read integer into A
0788   041D FD 9D 08      shl a, 8               ; only AL used, move to AH
0789   0420 19 0D         mov al, 0Dh            ; set RTC year
0790   0422 05 01         syscall sys_rtc        ; set RTC
0791   0424 3B 72 18      mov d, s_set_month
0792   0427 07 91 12      call _puts
0793   042A 07 7C 13      call scan_u8x          ; read integer into A
0794   042D FD 9D 08      shl a, 8               ; only AL used, move to AH
0795   0430 19 0C         mov al, 0Ch            ; set RTC month
0796   0432 05 01         syscall sys_rtc        ; set RTC
0797   0434 3B 7A 18      mov d, s_set_day
0798   0437 07 91 12      call _puts
0799   043A 07 7C 13      call scan_u8x          ; read integer into A
0800   043D FD 9D 08      shl a, 8               ; only AL used, move to AH
0801   0440 19 0B         mov al, 0Bh            ; set RTC month
0802   0442 05 01         syscall sys_rtc        ; set RTC
0803   0444 3B 80 18      mov d, s_set_week
0804   0447 07 91 12      call _puts
0805   044A 07 7C 13      call scan_u8x          ; read integer into A
0806   044D FD 9D 08      shl a, 8               ; only AL used, move to AH
0807   0450 19 0A         mov al, 0Ah            ; set RTC month
0808   0452 05 01         syscall sys_rtc        ; set RTC
0809   0454 3B 8A 18      mov d, s_set_hours
0810   0457 07 91 12      call _puts
0811   045A 07 7C 13      call scan_u8x          ; read integer into A
0812   045D FD 9D 08      shl a, 8               ; only AL used, move to AH
0813   0460 19 09         mov al, 09h            ; set RTC month
0814   0462 05 01         syscall sys_rtc        ; set RTC
0815   0464 3B 92 18      mov d, s_set_minutes
0816   0467 07 91 12      call _puts
0817   046A 07 7C 13      call scan_u8x          ; read integer into A
0818   046D FD 9D 08      shl a, 8               ; only AL used, move to AH
0819   0470 19 08         mov al, 08h            ; set RTC month
0820   0472 05 01         syscall sys_rtc        ; set RTC
0821   0474 3B 9C 18      mov d, s_set_seconds
0822   0477 07 91 12      call _puts
0823   047A 07 7C 13      call scan_u8x          ; read integer into A
0824   047D FD 9D 08      shl a, 8               ; only AL used, move to AH
0825   0480 19 07         mov al, 07h            ; set RTC month
0826   0482 05 01         syscall sys_rtc        ; set RTC
0827   0484 06            sysret
0828   0485             
0829   0485             ; ------------------------------------------------------------------------------------------------------------------;
0830   0485             ; IDE Services Syscall
0831   0485             ; al = option
0832   0485             ; 0 = IDE reset, 1 = IDE sleep, 2 = read sector, 3 = write sector
0833   0485             ; IDE read/write sector
0834   0485             ; 512 bytes
0835   0485             ; User buffer pointer in D
0836   0485             ; AH = number of sectors
0837   0485             ; CB = LBA bytes 3..0
0838   0485             ; ------------------------------------------------------------------------------------------------------------------;
0839   0485 3E 20 73 79 s_syscall_ide_dbg0: .db "> syscall_ide called: ", 0
0839   0489 73 63 61 6C 
0839   048D 6C 5F 69 64 
0839   0491 65 20 63 61 
0839   0495 6C 6C 65 64 
0839   0499 3A 20 00 
0840   049C             ide_serv_tbl:
0841   049C C3 04         .dw ide_reset
0842   049E D7 04         .dw ide_sleep
0843   04A0 E6 04         .dw ide_read_sect_wrapper
0844   04A2 EA 04         .dw ide_write_sect_wrapper
0845   04A4             syscall_ide:
0846   04A4 DD            push bl
0847   04A5 31 BA 17      mov bl, [sys_debug_mode]
0848   04A8               ; debug block
0849   04A8 C1 00         cmp bl, 0
0850   04AA EA            pop bl
0851   04AB C6 BF 04      je syscall_ide_jmp
0852   04AE DA            push d
0853   04AF DD            push bl
0854   04B0 3B 85 04      mov d, s_syscall_ide_dbg0
0855   04B3 07 91 12      call _puts
0856   04B6 2F            mov bl, al
0857   04B7 07 31 13      call print_u8x
0858   04BA 07 3E 12      call printnl
0859   04BD EA            pop bl
0860   04BE E7            pop d
0861   04BF             syscall_ide_jmp:
0862   04BF FD 0A 9C 04   jmp [ide_serv_tbl + al]    
0863   04C3               
0864   04C3             ide_reset:      
0865   04C3 F2 D7 FF 04   mov byte[_ide_R7], 4            ; RESET IDE
0866   04C7 07 70 05      call ide_wait                   ; wait for IDE ready             
0867   04CA F2 D6 FF E0   mov byte[_ide_R6], $E0          ; LBA3= 0, MASTER, MODE= LBA        
0868   04CE F2 D1 FF 01   mov byte[_ide_R1], 1            ; 8-BIT TRANSFERS      
0869   04D2 F2 D7 FF EF   mov byte[_ide_R7], $EF          ; SET FEATURE COMMAND
0870   04D6 06            sysret
0871   04D7             ide_sleep:
0872   04D7 07 70 05      call ide_wait                   ; wait for IDE ready             
0873   04DA F2 D6 FF 40   mov byte [_ide_R6], %01000000   ; lba[3:0](reserved), bit 6=1
0874   04DE F2 D7 FF E6   mov byte [_ide_R7], $E6         ; sleep command
0875   04E2 07 70 05      call ide_wait                   ; wait for IDE ready
0876   04E5 06            sysret
0877   04E6             ide_read_sect_wrapper:
0878   04E6 07 EE 04      call ide_read_sect
0879   04E9 06            sysret
0880   04EA             ide_write_sect_wrapper:
0881   04EA 07 14 05      call ide_write_sect
0882   04ED 06            sysret
0883   04EE             ide_read_sect:
0884   04EE 1A            mov al, ah
0885   04EF 24            mov ah, bl
0886   04F0 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0887   04F3 1C            mov al, bh
0888   04F4 3D D4 FF      mov [_ide_R4], al
0889   04F7 12            mov a, c
0890   04F8 3D D5 FF      mov [_ide_R5], al
0891   04FB 1A            mov al, ah
0892   04FC 87 0F         and al, %00001111
0893   04FE 8B E0         or al, %11100000                ; mode lba, master
0894   0500 3D D6 FF      mov [_ide_R6], al
0895   0503             ide_read_sect_wait:
0896   0503 1D D7 FF      mov al, [_ide_R7]  
0897   0506 87 80         and al, $80                     ; BUSY FLAG
0898   0508 C7 03 05      jnz ide_read_sect_wait
0899   050B 19 20         mov al, $20
0900   050D 3D D7 FF      mov [_ide_R7], al               ; read sector cmd
0901   0510 07 3A 05      call ide_read  
0902   0513 09            ret
0903   0514             ide_write_sect:
0904   0514 1A            mov al, ah
0905   0515 24            mov ah, bl
0906   0516 42 D2 FF      mov [_ide_R2], a                ; number of sectors (0..255)
0907   0519 1C            mov al, bh
0908   051A 3D D4 FF      mov [_ide_R4], al
0909   051D 12            mov a, c
0910   051E 3D D5 FF      mov [_ide_R5], al
0911   0521 1A            mov al, ah
0912   0522 87 0F         and al, %00001111
0913   0524 8B E0         or al, %11100000                ; mode lba, master
0914   0526 3D D6 FF      mov [_ide_R6], al
0915   0529             ide_write_sect_wait:
0916   0529 1D D7 FF      mov al, [_ide_R7]  
0917   052C 87 80         and al, $80                     ; BUSY FLAG
0918   052E C7 29 05      jnz ide_write_sect_wait
0919   0531 19 30         mov al, $30
0920   0533 3D D7 FF      mov [_ide_R7], al               ; write sector cmd
0921   0536 07 55 05      call ide_write      
0922   0539 09            ret
0923   053A             
0924   053A             ;----------------------------------------------------------------------------------------------------;
0925   053A             ; READ IDE DATA
0926   053A             ; pointer in D
0927   053A             ;----------------------------------------------------------------------------------------------------;
0928   053A             ide_read:
0929   053A DA            push d
0930   053B             ide_read_loop:
0931   053B 1D D7 FF      mov al, [_ide_R7]  
0932   053E 87 80         and al, 80h                     ; BUSY FLAG
0933   0540 C7 3B 05      jnz ide_read_loop               ; wait loop
0934   0543 1D D7 FF      mov al, [_ide_R7]
0935   0546 87 08         and al, %00001000               ; DRQ FLAG
0936   0548 C6 53 05      jz ide_read_end
0937   054B 1D D0 FF      mov al, [_ide_R0]
0938   054E 3E            mov [d], al
0939   054F 79            inc d
0940   0550 0A 3B 05      jmp ide_read_loop
0941   0553             ide_read_end:
0942   0553 E7            pop d
0943   0554 09            ret
0944   0555             
0945   0555             ;----------------------------------------------------------------------------------------------------;
0946   0555             ; WRITE IDE DATA
0947   0555             ; data pointer in D
0948   0555             ;----------------------------------------------------------------------------------------------------;
0949   0555             ide_write:
0950   0555 DA            push d
0951   0556             ide_write_loop:
0952   0556 1D D7 FF      mov al, [_ide_R7]  
0953   0559 87 80         and al, 80h             ; BUSY FLAG
0954   055B C7 56 05      jnz ide_write_loop      ; wait loop
0955   055E 1D D7 FF      mov al, [_ide_R7]
0956   0561 87 08         and al, %00001000       ; DRQ FLAG
0957   0563 C6 6E 05      jz ide_write_end
0958   0566 1E            mov al, [d]
0959   0567 3D D0 FF      mov [_ide_R0], al
0960   056A 79            inc d 
0961   056B 0A 56 05      jmp ide_write_loop
0962   056E             ide_write_end:
0963   056E E7            pop d
0964   056F 09            ret
0965   0570             
0966   0570             ;----------------------------------------------------------------------------------------------------;
0967   0570             ; wait for IDE to be ready
0968   0570             ;----------------------------------------------------------------------------------------------------;
0969   0570             ide_wait:
0970   0570 1D D7 FF      mov al, [_ide_R7]  
0971   0573 87 80         and al, 80h        ; BUSY FLAG
0972   0575 C7 70 05      jnz ide_wait
0973   0578 09            ret
0974   0579             
0975   0579             ;----------------------------------------------------------------------------------------------------;
0976   0579             ; IO Syscall
0977   0579             ;----------------------------------------------------------------------------------------------------;
0978   0579             ; Baud  Divisor
0979   0579             ; 50    2304
0980   0579             ; 110   1047
0981   0579             ; 300    384
0982   0579             ; 600    192
0983   0579             ; 1200    96
0984   0579             ; 9600    12
0985   0579             ; 19200    6
0986   0579             ; 38400    3
0987   0579             syscall_io_jmp:
0988   0579 AC 05         .dw syscall_io_putchar
0989   057B B9 05         .dw syscall_io_getch
0990   057D 83 05         .dw syscall_io_uart_setup
0991   057F             syscall_io:
0992   057F FD 0A 79 05   jmp [syscall_io_jmp + al]
0993   0583             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0994   0583             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0995   0583             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0996   0583             syscall_io_uart_setup:
0997   0583 1D BC 17      mov al, [sys_uart0_lcr]
0998   0586 8B 80         or al, $80                ; set DLAB access bit
0999   0588 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
1000   058B 1D BF 17      mov al, [sys_uart0_div0]
1001   058E 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
1002   0591 1D C0 17      mov al, [sys_uart0_div1]
1003   0594 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
1004   0597             
1005   0597 1D BC 17      mov al, [sys_uart0_lcr]
1006   059A 87 7F         and al, $7F               ; clear DLAB access bit 
1007   059C 3D 83 FF      mov [_UART0_LCR], al
1008   059F 1D BD 17      mov al, [sys_uart0_inten]
1009   05A2 3D 81 FF      mov [_UART0_IER], al      ; interrupts
1010   05A5 1D BE 17      mov al, [sys_uart0_fifoen]
1011   05A8 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
1012   05AB 06            sysret
1013   05AC             
1014   05AC             ; char in ah
1015   05AC             syscall_io_putchar:
1016   05AC             syscall_io_putchar_L0:
1017   05AC 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1018   05AF 87 20         and al, $20
1019   05B1 C6 AC 05      jz syscall_io_putchar_L0    
1020   05B4 1A            mov al, ah
1021   05B5 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1022   05B8 06            sysret
1023   05B9             
1024   05B9             ; char in ah
1025   05B9             ; al = sucess code
1026   05B9             syscall_io_getch:
1027   05B9 D8            push b
1028   05BA DA            push d
1029   05BB FD 0C         sti
1030   05BD             syscall_io_getch_L0:  
1031   05BD 14 C9 17      mov a, [fifo_out]
1032   05C0 29 C7 17      mov b, [fifo_in]
1033   05C3 B0            cmp a, b
1034   05C4 C6 BD 05      je syscall_io_getch_L0
1035   05C7 3C            mov d, a
1036   05C8 77            inc a
1037   05C9 AF 08 25      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
1038   05CC C7 D2 05      jne syscall_io_getch_cont
1039   05CF 10 08 21      mov a, fifo  
1040   05D2             syscall_io_getch_cont:  
1041   05D2 42 C9 17      mov [fifo_out], a             ; update fifo pointer
1042   05D5 1E            mov al, [d]                   ; get char
1043   05D6 23            mov ah, al
1044   05D7 1D BB 17      mov al, [sys_echo_on]
1045   05DA B9 01         cmp al, 1
1046   05DC C7 EB 05      jne syscall_io_getch_noecho 
1047   05DF             ; here we just echo the char back to the console
1048   05DF             syscall_io_getch_echo_L0:
1049   05DF 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
1050   05E2 87 20         and al, $20                 ; isolate Transmitter Empty
1051   05E4 C6 DF 05      jz syscall_io_getch_echo_L0
1052   05E7 1A            mov al, ah
1053   05E8 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
1054   05EB             syscall_io_getch_noecho:
1055   05EB 19 01         mov al, 1                    ; AL = 1 means a char successfully received
1056   05ED E7            pop d
1057   05EE E5            pop b
1058   05EF 06            sysret
1059   05F0             
1060   05F0             ;------------------------------------------------------------------------------------------------------;
1061   05F0             ; FILE SYSTEM DATA
1062   05F0             ;------------------------------------------------------------------------------------------------------;
1063   05F0             ; infor for : IDE SERVICES INTERRUPT
1064   05F0             ; IDE read/write 512-byte sector
1065   05F0             ; al = option
1066   05F0             ; user buffer pointer in D
1067   05F0             ; AH = number of sectors
1068   05F0             ; CB = LBA bytes 3..0  
1069   05F0             ;------------------------------------------------------------------------------------------------------;
1070   05F0             ; FILE SYSTEM DATA STRUCTURE
1071   05F0             ;------------------------------------------------------------------------------------------------------;
1072   05F0             ; for a directory we have the header first, followed by metadata
1073   05F0             ; header 1 sector (512 bytes)
1074   05F0             ; metadata 1 sector (512 bytes)
1075   05F0             ; HEADER ENTRIES:
1076   05F0             ; filename (64)
1077   05F0             ; parent dir LBA (2) -  to be used for faster backwards navigation...
1078   05F0             ;
1079   05F0             ; metadata entries:
1080   05F0             ; filename (24)
1081   05F0             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1082   05F0             ; LBA (2)
1083   05F0             ; size (2)
1084   05F0             ; day (1)
1085   05F0             ; month (1)
1086   05F0             ; year (1)
1087   05F0             ; packet size = 32 bytes
1088   05F0             ;
1089   05F0             ; first directory on disk is the root directory '/'
1090   05F0             file_system_jmptbl:
1091   05F0 5B 06         .dw fs_mkfs                   ; 0
1092   05F2 00 00         .dw 0                         ; 1
1093   05F4 BD 06         .dw fs_mkdir                  ; 2
1094   05F6 36 0A         .dw fs_cd                     ; 3
1095   05F8 3D 0A         .dw fs_ls                     ; 4
1096   05FA B3 0B         .dw fs_mktxt                  ; 5
1097   05FC 7E 0C         .dw fs_mkbin                  ; 6
1098   05FE 45 0D         .dw fs_pwd                    ; 7
1099   0600 62 0D         .dw fs_cat                    ; 8
1100   0602 BE 0D         .dw fs_rmdir                  ; 9
1101   0604 1A 0E         .dw fs_rm                     ; 10
1102   0606 0E 0B         .dw fs_starcom                ; 11
1103   0608 00 00         .dw 0                         ; 12
1104   060A 00 00         .dw 0                         ; 13
1105   060C 63 06         .dw fs_chmod                  ; 14
1106   060E 82 0E         .dw fs_mv                     ; 15
1107   0610 5C 06         .dw fs_cd_root                ; 16
1108   0612 32 0A         .dw fs_get_curr_dirID         ; 17
1109   0614 0E 08         .dw fs_dir_id_to_path         ; 18
1110   0616 74 08         .dw fs_path_to_dir_id_user    ; 19
1111   0618 8E 09         .dw fs_load_from_path_user    ; 20  
1112   061A FE 08         .dw fs_filepath_exists_user   ; 21
1113   061C             
1114   061C 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1114   0620 79 73 63 61 
1114   0624 6C 6C 5F 66 
1114   0628 69 6C 65 5F 
1114   062C 73 79 73 74 
1114   0630 65 6D 20 63 
1114   0634 61 6C 6C 65 
1114   0638 64 3A 20 00 
1115   063C             syscall_file_system:
1116   063C DD            push bl
1117   063D 31 BA 17      mov bl, [sys_debug_mode]
1118   0640               ; debug block
1119   0640 C1 00         cmp bl, 0
1120   0642 EA            pop bl
1121   0643 C6 57 06      je syscall_filesystem_jmp
1122   0646 DA            push d
1123   0647 DD            push bl
1124   0648 3B 1C 06      mov d, s_syscall_fs_dbg0
1125   064B 07 91 12      call _puts
1126   064E 2F            mov bl, al
1127   064F 07 31 13      call print_u8x
1128   0652 07 3E 12      call printnl
1129   0655 EA            pop bl
1130   0656 E7            pop d
1131   0657             syscall_filesystem_jmp:
1132   0657 FD 0A F0 05   jmp [file_system_jmptbl + al]
1133   065B             
1134   065B             fs_mkfs:  
1135   065B 06            sysret  
1136   065C               
1137   065C             fs_cd_root:
1138   065C 10 20 00      mov a, root_id
1139   065F 42 CB 17      mov [current_dir_id], a      ; set current directory LBA to ROOT
1140   0662 06            sysret  
1141   0663             
1142   0663             ; filename in D (userspace data)
1143   0663             ; permission in BL
1144   0663             fs_chmod:
1145   0663 DD            push bl
1146   0664 FD 4E         mov si, d
1147   0666 FD 4F 08 1F   mov di, user_data
1148   066A 38 80 00      mov c, 128
1149   066D 04            load                        ; load filename from user-space
1150   066E 14 CB 17      mov a, [current_dir_id]
1151   0671 77            inc a                       ; metadata sector
1152   0672 27            mov b, a
1153   0673 38 00 00      mov c, 0                    ; upper LBA = 0
1154   0676 22 01         mov ah, $01                  ; 1 sector
1155   0678 3B 08 27      mov d, transient_area
1156   067B 07 EE 04      call ide_read_sect          ; read directory
1157   067E FD 10         cla
1158   0680 42 C3 17      mov [index], a              ; reset file counter
1159   0683             fs_chmod_L1:
1160   0683 FD 4E         mov si, d
1161   0685 FD 4F 08 1F   mov di, user_data
1162   0689 07 D4 10      call _strcmp
1163   068C C6 A3 06      je fs_chmod_found_entry
1164   068F 58 20 00      add d, 32
1165   0692 14 C3 17      mov a, [index]
1166   0695 77            inc a
1167   0696 42 C3 17      mov [index], a
1168   0699 AF 10 00      cmp a, FST_FILES_PER_DIR
1169   069C C7 83 06      jne fs_chmod_L1
1170   069F EA            pop bl
1171   06A0 0A BC 06      jmp fs_chmod_not_found
1172   06A3             fs_chmod_found_entry:  
1173   06A3 FD 79         mov g, b                    ; save LBA
1174   06A5 EA            pop bl                      ; retrieve saved permission value
1175   06A6 1F 18 00      mov al, [d + 24]            ; read file permissions
1176   06A9 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1177   06AB 8C            or al, bl                   ; set new permissions
1178   06AC 3F 18 00      mov [d + 24], al            ; write new permissions
1179   06AF 38 00 00      mov c, 0
1180   06B2 3B 08 27      mov d, transient_area
1181   06B5 22 01         mov ah, $01                 ; disk write 1 sect
1182   06B7 FD 27         mov b, g                    ; retrieve LBA
1183   06B9 07 14 05      call ide_write_sect         ; write sector
1184   06BC             fs_chmod_not_found:
1185   06BC 06            sysret
1186   06BD             
1187   06BD             ;------------------------------------------------------------------------------------------------------;
1188   06BD             ; CREATE NEW DIRECTORY
1189   06BD             ;------------------------------------------------------------------------------------------------------;
1190   06BD             ; search list for NULL name entry. add new directory to list
1191   06BD             fs_mkdir:
1192   06BD FD 4E         mov si, d
1193   06BF FD 4F 08 1F   mov di, user_data
1194   06C3 38 00 02      mov c, 512
1195   06C6 04            load                        ; load data from user-space
1196   06C7 26 22 00      mov b, FST_LBA_START + 2    ; start at 2 because LBA  0 is ROOT (this would also cause issues                 
1197   06CA                                           ; when checking for NULL name, since root has a NULL name)
1198   06CA 38 00 00      mov c, 0                    ; upper LBA = 0
1199   06CD             fs_mkdir_L1:  
1200   06CD 22 01         mov ah, $01                  ; 1 sector
1201   06CF 3B 08 27      mov d, transient_area
1202   06D2 07 EE 04      call ide_read_sect          ; read sector
1203   06D5 BD 00         cmp byte[d], 0              ; check for NULL
1204   06D7 C6 E0 06      je fs_mkdir_found_null
1205   06DA 55 02 00      add b, FST_SECTORS_PER_DIR  ; skip directory
1206   06DD 0A CD 06      jmp fs_mkdir_L1
1207   06E0             fs_mkdir_found_null:
1208   06E0             ;create header file by grabbing dir name from parameter
1209   06E0 D8            push b                      ; save new directory's LBA
1210   06E1 38 40 00      mov c, 64
1211   06E4 FD 4D 08 1F   mov si, user_data
1212   06E8 FD 4F 08 27   mov di, transient_area
1213   06EC FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1214   06EE 14 CB 17      mov a, [current_dir_id]
1215   06F1 42 48 27      mov [transient_area + 64], a    ; store parent directory LBA
1216   06F4 19 00         mov al, 0
1217   06F6 FD 4F 08 29   mov di, transient_area + 512
1218   06FA 38 00 02      mov c, 512
1219   06FD FD F7         rep stosb                       ; clean buffer
1220   06FF 38 00 00      mov c, 0                        ; reset LBA(c) to 0
1221   0702             ; write directory entry sectors
1222   0702 3B 08 27      mov d, transient_area
1223   0705 22 02         mov ah, $02                     ; disk write, 2 sectors
1224   0707 07 14 05      call ide_write_sect             ; write sector
1225   070A             ; now we need to add the new directory to the list, insIDE the current directory
1226   070A 14 CB 17      mov a, [current_dir_id]
1227   070D 53 01 00      add a, 1
1228   0710 27            mov b, a                        ; metadata sector
1229   0711 38 00 00      mov c, 0
1230   0714 FD 79         mov g, b                        ; save LBA
1231   0716 3B 08 27      mov d, transient_area
1232   0719 22 01         mov ah, $01                  ; 1 sector
1233   071B 07 EE 04      call ide_read_sect              ; read metadata sector
1234   071E             fs_mkdir_L2:
1235   071E BD 00         cmp byte[d], 0
1236   0720 C6 29 07      je fs_mkdir_found_null2
1237   0723 58 20 00      add d, FST_ENTRY_SIZE
1238   0726 0A 1E 07      jmp fs_mkdir_L2                ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1239   0729             fs_mkdir_found_null2:
1240   0729 FD 4D 08 1F   mov si, user_data
1241   072D FD 50         mov di, d
1242   072F 07 E9 10      call _strcpy                    ; copy directory name
1243   0732 58 18 00      add d, 24                       ; goto ATTRIBUTES
1244   0735 19 0B         mov al, %00001011               ; directory, no execute, write, read
1245   0737 3E            mov [d], al      
1246   0738 79            inc d
1247   0739 E5            pop b
1248   073A D8            push b                          ; push LBA back
1249   073B FD 43         mov [d], b                      ; save LBA
1250   073D             ; set file creation date  
1251   073D 58 04 00      add d, 4
1252   0740 19 04         mov al, 4
1253   0742 05 01         syscall sys_rtc
1254   0744 1A            mov al, ah
1255   0745 3E            mov [d], al                     ; set day
1256   0746 79            inc d
1257   0747 19 05         mov al, 5
1258   0749 05 01         syscall sys_rtc
1259   074B 1A            mov al, ah
1260   074C 3E            mov [d], al                     ; set month
1261   074D 79            inc d
1262   074E 19 06         mov al, 6
1263   0750 05 01         syscall sys_rtc
1264   0752 1A            mov al, ah
1265   0753 3E            mov [d], al                     ; set year
1266   0754             ; write sector into disk for new directory entry
1267   0754 FD 27         mov b, g
1268   0756 38 00 00      mov c, 0
1269   0759 3B 08 27      mov d, transient_area
1270   075C 22 01         mov ah, $01                     ; disk write, 1 sector
1271   075E 07 14 05      call ide_write_sect             ; write sector
1272   0761             
1273   0761             ; after adding the new directory's information to its parent directory's list
1274   0761             ; we need to now enter the new directory, and to it add two new directories!
1275   0761             ; which directories do we need to add ? '..' and '.' are the directories needed.
1276   0761             ; importantly, note that these two new directories are only entries in the list
1277   0761             ; and do not have actual physical entries in the disk as real directories.
1278   0761             ; i.e. they only exist as list entries in the new directory created so that
1279   0761             ; the new directory can reference its parent and itself.
1280   0761             ; We need to add both '..' and '.'
1281   0761             ; this first section is for '..' and on the section below we do the same for '.'
1282   0761 E4            pop a                         ; retrieve the new directory's LBA  
1283   0762 D7            push a                        ; and save again
1284   0763 53 01 00      add a, 1
1285   0766 27            mov b, a                      ; metadata sector
1286   0767 38 00 00      mov c, 0
1287   076A FD 79         mov g, b                      ; save LBA
1288   076C 3B 08 27      mov d, transient_area
1289   076F 22 01         mov ah, $01                  ; 1 sector
1290   0771 07 EE 04      call ide_read_sect            ; read metadata sector
1291   0774             fs_mkdir_L3:
1292   0774 BD 00         cmp byte[d], 0
1293   0776 C6 7F 07      je fs_mkdir_found_null3
1294   0779 58 20 00      add d, FST_ENTRY_SIZE
1295   077C 0A 74 07      jmp fs_mkdir_L3              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1296   077F             fs_mkdir_found_null3:
1297   077F FD 4D DB 17   mov si, s_parent_dir
1298   0783 FD 50         mov di, d
1299   0785 07 E9 10      call _strcpy                  ; copy directory name
1300   0788 58 18 00      add d, 24                     ; goto ATTRIBUTES
1301   078B 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1302   078D 3E            mov [d], al      
1303   078E 79            inc d
1304   078F 29 CB 17      mov b, [current_dir_id]        ; retrieve the parent directorys LBA
1305   0792 FD 43         mov [d], b                    ; save LBA
1306   0794             ; set file creation date  
1307   0794 58 04 00      add d, 4
1308   0797 19 04         mov al, 4
1309   0799 05 01         syscall sys_rtc
1310   079B 1A            mov al, ah
1311   079C 3E            mov [d], al                   ; set day
1312   079D 79            inc d
1313   079E 19 05         mov al, 5
1314   07A0 05 01         syscall sys_rtc
1315   07A2 1A            mov al, ah
1316   07A3 3E            mov [d], al                   ; set month
1317   07A4 79            inc d
1318   07A5 19 06         mov al, 6
1319   07A7 05 01         syscall sys_rtc
1320   07A9 1A            mov al, ah
1321   07AA 3E            mov [d], al                   ; set year
1322   07AB             ; write sector into disk for new directory entry
1323   07AB FD 27         mov b, g
1324   07AD 38 00 00      mov c, 0
1325   07B0 3B 08 27      mov d, transient_area
1326   07B3 22 01         mov ah, $01                   ; disk write, 1 sector
1327   07B5 07 14 05      call ide_write_sect           ; write sector
1328   07B8             ;;;;;;;;;;;;;
1329   07B8             ; like we did above for '..', we need to now add the '.' directory to the list.
1330   07B8             ;------------------------------------------------------------------------------------------------------;
1331   07B8 E4            pop a                         ; retrieve the new directory's LBA  
1332   07B9 D7            push a
1333   07BA 53 01 00      add a, 1
1334   07BD 27            mov b, a                      ; metadata sector
1335   07BE 38 00 00      mov c, 0
1336   07C1 FD 79         mov g, b                      ; save LBA
1337   07C3 3B 08 27      mov d, transient_area
1338   07C6 22 01         mov ah, $01                  ; 1 sector
1339   07C8 07 EE 04      call ide_read_sect            ; read metadata sector
1340   07CB             fs_mkdir_L4:
1341   07CB BD 00         cmp byte[d], 0
1342   07CD C6 D6 07      je fs_mkdir_found_null4
1343   07D0 58 20 00      add d, FST_ENTRY_SIZE
1344   07D3 0A CB 07      jmp fs_mkdir_L4              ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1345   07D6             fs_mkdir_found_null4:
1346   07D6 FD 4D DE 17   mov si, s_current_dir
1347   07DA FD 50         mov di, d
1348   07DC 07 E9 10      call _strcpy                  ; copy directory name
1349   07DF 58 18 00      add d, 24                     ; goto ATTRIBUTES
1350   07E2 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1351   07E4 3E            mov [d], al      
1352   07E5 79            inc d
1353   07E6 E5            pop b                         ; new directory's LBA itself. for self-referential directory entry '.'
1354   07E7 FD 43         mov [d], b                    ; save LBA
1355   07E9             ; set file creation date  
1356   07E9 58 04 00      add d, 4
1357   07EC 19 04         mov al, 4
1358   07EE 05 01         syscall sys_rtc
1359   07F0 1A            mov al, ah
1360   07F1 3E            mov [d], al                   ; set day
1361   07F2 79            inc d
1362   07F3 19 05         mov al, 5
1363   07F5 05 01         syscall sys_rtc
1364   07F7 1A            mov al, ah
1365   07F8 3E            mov [d], al                   ; set month
1366   07F9 79            inc d
1367   07FA 19 06         mov al, 6
1368   07FC 05 01         syscall sys_rtc
1369   07FE 1A            mov al, ah
1370   07FF 3E            mov [d], al                   ; set year
1371   0800             ; write sector into disk for new directory entry
1372   0800 FD 27         mov b, g
1373   0802 38 00 00      mov c, 0
1374   0805 3B 08 27      mov d, transient_area
1375   0808 22 01         mov ah, $01                   ; disk write, 1 sector
1376   080A 07 14 05      call ide_write_sect           ; write sector
1377   080D             fs_mkdir_end:
1378   080D 06            sysret
1379   080E             
1380   080E             ;------------------------------------------------------------------------------------------------------;
1381   080E             ; get path from a given directory dirID
1382   080E             ; pseudo code:
1383   080E             ;  fs_dir_id_to_path(int dirID, char *D){
1384   080E             ;    if(dirID == 0){
1385   080E             ;      reverse path in D;
1386   080E             ;      return;
1387   080E             ;    }
1388   080E             ;    else{
1389   080E             ;      copy directory name to end of D;
1390   080E             ;      add '/' to end of D;
1391   080E             ;      parentID = get parent directory ID;
1392   080E             ;      fs_dir_id_to_path(parentID, D);
1393   080E             ;    }
1394   080E             ;  }
1395   080E             ; A = dirID
1396   080E             ; D = generated path string pointer
1397   080E             ;------------------------------------------------------------------------------------------------------;
1398   080E             ; sample path: /usr/bin
1399   080E             fs_dir_id_to_path:
1400   080E 3B 88 1E      mov d, filename
1401   0811 19 00         mov al, 0
1402   0813 3E            mov [d], al                     ; initialize path string 
1403   0814 14 CB 17      mov a, [current_dir_id]
1404   0817 07 24 08      call fs_dir_id_to_path_E0
1405   081A 3B 88 1E      mov d, filename
1406   081D 07 7D 10      call _strrev
1407   0820 07 91 12      call _puts
1408   0823 06            sysret
1409   0824             fs_dir_id_to_path_E0:
1410   0824 07 43 08      call get_dirname_from_dirID
1411   0827 FD 4D E0 17   mov si, s_fslash
1412   082B FD 50         mov di, d
1413   082D 07 F7 10      call _strcat                    ; add '/' to end of path
1414   0830 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1415   0833 C6 42 08      je fs_dir_id_to_path_root
1416   0836 07 60 08      call get_parentID_from_dirID    ; use current ID (A) to find parentID (into A)
1417   0839 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1418   083C C6 42 08      je fs_dir_id_to_path_root
1419   083F 07 24 08      call fs_dir_id_to_path_E0     ; recursively call itself
1420   0842             fs_dir_id_to_path_root:
1421   0842 09            ret
1422   0843             
1423   0843             ;------------------------------------------------------------------------------------------------------;
1424   0843             ; in_puts:
1425   0843             ; A = directory ID
1426   0843             ; out_puts:
1427   0843             ; D = pointer to directory name string
1428   0843             ;------------------------------------------------------------------------------------------------------;
1429   0843             get_dirname_from_dirID:
1430   0843 D7            push a
1431   0844 D8            push b
1432   0845 DA            push d
1433   0846 27            mov b, a
1434   0847 38 00 00      mov c, 0                      ; upper LBA = 0
1435   084A 22 01         mov ah, $01                  ; 1 sector
1436   084C 3B 08 25      mov d, transient_area - 512
1437   084F 07 EE 04      call ide_read_sect            ; read directory
1438   0852 07 7D 10      call _strrev                  ; reverse dir name before copying
1439   0855 FD 4E         mov si, d
1440   0857 E7            pop d                         ; destination address = D value pushed at beginning
1441   0858 FD 50         mov di, d
1442   085A 07 F7 10      call _strcat                  ; copy filename to D
1443   085D E5            pop b
1444   085E E4            pop a
1445   085F 09            ret
1446   0860             
1447   0860             ;------------------------------------------------------------------------------------------------------;
1448   0860             ; in_puts:
1449   0860             ; A = directory ID
1450   0860             ; out_puts:
1451   0860             ; A = parent directory ID
1452   0860             ;------------------------------------------------------------------------------------------------------;
1453   0860             get_parentID_from_dirID:
1454   0860 D8            push b
1455   0861 DA            push d
1456   0862 27            mov b, a
1457   0863 38 00 00      mov c, 0                      ; upper LBA = 0
1458   0866 22 01         mov ah, $01                  ; 1 sector
1459   0868 3B 08 25      mov d, transient_area - 512
1460   086B 07 EE 04      call ide_read_sect            ; read directory
1461   086E 16 40 00      mov a, [d + 64]               ; copy parent ID value to A
1462   0871 E7            pop d
1463   0872 E5            pop b
1464   0873 09            ret
1465   0874             
1466   0874             ;------------------------------------------------------------------------------------------------------;
1467   0874             ; get dirID from a given path string
1468   0874             ; in_puts:
1469   0874             ; D = path pointer 
1470   0874             ; out_puts:
1471   0874             ; A = dirID
1472   0874             ; if dir non existent, A = FFFF (fail code)
1473   0874             ; /usr/local/bin    - absolute
1474   0874             ; local/bin/games    - relative
1475   0874             ;------------------------------------------------------------------------------------------------------;
1476   0874             fs_path_to_dir_id_user:
1477   0874 FD 4E         mov si, d
1478   0876 FD 4F 08 1F   mov di, user_data
1479   087A 38 00 02      mov c, 512
1480   087D 04            load
1481   087E 07 82 08      call get_dirID_from_path
1482   0881 06            sysret
1483   0882             get_dirID_from_path:
1484   0882 26 08 1F      mov b, user_data
1485   0885 FD 42 B6 16   mov [prog], b                  ; token pointer set to path string
1486   0889 07 17 15      call get_token
1487   088C 31 B9 16      mov bl, [tok]
1488   088F C1 01         cmp bl, TOK_FSLASH
1489   0891 C6 9D 08      je get_dirID_from_path_abs 
1490   0894 14 CB 17      mov a, [current_dir_id]
1491   0897 07 9D 16      call _putback
1492   089A 0A A0 08      jmp get_dirID_from_path_E0
1493   089D             get_dirID_from_path_abs:
1494   089D 10 20 00      mov a, root_id
1495   08A0             get_dirID_from_path_E0:
1496   08A0 07 17 15      call get_token
1497   08A3 31 B8 16      mov bl, [toktyp]
1498   08A6 C1 00         cmp bl, TOKTYP_IDENTIFIER
1499   08A8 C7 F9 08      jne get_dirID_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1500   08AB             
1501   08AB FD 4D BA 16   mov si, tokstr
1502   08AF FD 4F 88 1E   mov di, filename
1503   08B3 07 E9 10      call _strcpy        
1504   08B6 77            inc a                         ; metadata sector
1505   08B7 27            mov b, a
1506   08B8 38 00 00      mov c, 0                      ; upper LBA = 0
1507   08BB 22 01         mov ah, $01                  ; 1 sector
1508   08BD 3B 08 27      mov d, transient_area
1509   08C0 07 EE 04      call ide_read_sect            ; read directory
1510   08C3 FD 10         cla
1511   08C5 42 C3 17      mov [index], a
1512   08C8             get_dirID_from_path_L1:
1513   08C8 FD 4E         mov si, d
1514   08CA FD 4F 88 1E   mov di, filename
1515   08CE 07 D4 10      call _strcmp
1516   08D1 C6 E7 08      je get_dirID_from_path_name_equal  
1517   08D4 58 20 00      add d, 32
1518   08D7 14 C3 17      mov a, [index]
1519   08DA 77            inc a
1520   08DB 42 C3 17      mov [index], a
1521   08DE AF 10 00      cmp a, FST_FILES_PER_DIR
1522   08E1 C6 FA 08      je get_dirID_from_path_fail
1523   08E4 0A C8 08      jmp get_dirID_from_path_L1
1524   08E7             get_dirID_from_path_name_equal:
1525   08E7 58 19 00      add d, 25           
1526   08EA 15            mov a, [d]                    ; set result register A = dirID
1527   08EB 07 17 15      call get_token
1528   08EE 31 B9 16      mov bl, [tok]
1529   08F1 C1 01         cmp bl, TOK_FSLASH            ; check if there are more elements in the path
1530   08F3 C6 A0 08      je get_dirID_from_path_E0
1531   08F6 07 9D 16      call _putback
1532   08F9             get_dirID_from_path_end:
1533   08F9 09            ret
1534   08FA             get_dirID_from_path_fail:
1535   08FA 10 FF FF      mov A, $FFFF
1536   08FD 09            ret
1537   08FE             
1538   08FE             
1539   08FE             ;------------------------------------------------------------------------------------------------------;
1540   08FE             ; check if file exists by a given path string
1541   08FE             ; in_puts:
1542   08FE             ; D = path pointer 
1543   08FE             ; OUTPUTS:
1544   08FE             ; A = success code, if file exists gives LBA, else, give 0
1545   08FE             ; /usr/local/bin/ed
1546   08FE             ;------------------------------------------------------------------------------------------------------;
1547   08FE             fs_filepath_exists_user:
1548   08FE FD 4E         mov si, d
1549   0900 FD 4F 08 1F   mov di, user_data
1550   0904 38 00 02      mov c, 512
1551   0907 04            load
1552   0908 07 0C 09      call file_exists_by_path
1553   090B 06            sysret
1554   090C             file_exists_by_path:
1555   090C 26 08 1F      mov b, user_data
1556   090F FD 42 B6 16   mov [prog], b                   ; token pointer set to path string
1557   0913 07 17 15      call get_token
1558   0916 31 B9 16      mov bl, [tok]
1559   0919 C1 01         cmp bl, TOK_FSLASH
1560   091B C6 27 09      je  file_exists_by_path_abs
1561   091E 14 CB 17      mov a, [current_dir_id]
1562   0921 07 9D 16      call _putback
1563   0924 0A 2A 09      jmp file_exists_by_path_E0
1564   0927             file_exists_by_path_abs:
1565   0927 10 20 00      mov a, root_id
1566   092A             file_exists_by_path_E0:
1567   092A 07 17 15      call get_token
1568   092D 31 B8 16      mov bl, [toktyp]
1569   0930 C1 00         cmp bl, TOKTYP_IDENTIFIER
1570   0932 C7 8A 09      jne file_exists_by_path_end     ; check if there are tokens after '/'
1571   0935 FD 4D BA 16   mov si, tokstr
1572   0939 FD 4F 88 1E   mov di, filename
1573   093D 07 E9 10      call _strcpy        
1574   0940 77            inc a                           ; metadata sector
1575   0941 27            mov b, a
1576   0942 38 00 00      mov c, 0                        ; upper LBA = 0
1577   0945 22 01         mov ah, $01                  ; 1 sector
1578   0947 3B 08 27      mov d, transient_area
1579   094A 07 EE 04      call ide_read_sect              ; read directory
1580   094D FD 10         cla
1581   094F 42 C3 17      mov [index], a
1582   0952             file_exists_by_path_L1:
1583   0952 FD 4E         mov si, d
1584   0954 FD 4F 88 1E   mov di, filename
1585   0958 07 D4 10      call _strcmp
1586   095B C6 71 09      je   file_exists_by_path_name_equal
1587   095E 58 20 00      add d, 32
1588   0961 14 C3 17      mov a, [index]
1589   0964 77            inc a
1590   0965 42 C3 17      mov [index], a
1591   0968 AF 10 00      cmp a, FST_FILES_PER_DIR
1592   096B C6 8A 09      je file_exists_by_path_end
1593   096E 0A 52 09      jmp file_exists_by_path_L1
1594   0971             file_exists_by_path_name_equal:
1595   0971 33 18 00      mov bl, [d + 24]
1596   0974 FD 87 38      and bl, %00111000               ; directory flag
1597   0977 C1 08         cmp bl, %00001000               ; is dir?
1598   0979 C6 80 09      je file_exists_by_path_isdir;
1599   097C             ; entry is a file
1600   097C 16 19 00      mov a, [d + 25]                 ; get and return LBA of file
1601   097F 09            ret
1602   0980             file_exists_by_path_isdir:
1603   0980 58 19 00      add d, 25           
1604   0983 15            mov a, [d]                      ; set result register A = dirID
1605   0984 07 17 15      call get_token
1606   0987 0A 2A 09      jmp file_exists_by_path_E0
1607   098A             file_exists_by_path_end:
1608   098A 10 00 00      mov a, 0                        ; return 0 because file was not found
1609   098D 09            ret
1610   098E             
1611   098E             ;------------------------------------------------------------------------------------------------------;
1612   098E             ; load file data from a given path string
1613   098E             ; inputs:
1614   098E             ; D = path pointer 
1615   098E             ; DI = userspace program data destination
1616   098E             ; /usr/local/bin/ed
1617   098E             ; ./ed
1618   098E             ;------------------------------------------------------------------------------------------------------;
1619   098E             fs_load_from_path_user:
1620   098E E3            push di
1621   098F FD 4E         mov si, d
1622   0991 FD 4F 08 1F   mov di, user_data
1623   0995 38 00 02      mov c, 512
1624   0998 04            load
1625   0999 07 A6 09      call loadfile_from_path
1626   099C F0            pop di
1627   099D FD 4D 08 27   mov si, transient_area
1628   09A1 38 00 3E      mov c, 512 * (FS_SECTORS_PER_FILE-1)
1629   09A4 03            store
1630   09A5 06            sysret
1631   09A6             loadfile_from_path:
1632   09A6 26 08 1F      mov b, user_data
1633   09A9 FD 42 B6 16   mov [prog], b                 ; token pointer set to path string
1634   09AD 07 17 15      call get_token
1635   09B0 31 B9 16      mov bl, [tok]
1636   09B3 C1 01         cmp bl, TOK_FSLASH
1637   09B5 C6 C1 09      je loadfile_from_path_abs 
1638   09B8 14 CB 17      mov a, [current_dir_id]
1639   09BB 07 9D 16      call _putback
1640   09BE 0A C4 09      jmp loadfile_from_path_E0
1641   09C1             loadfile_from_path_abs:
1642   09C1 10 20 00      mov a, root_id
1643   09C4             loadfile_from_path_E0:
1644   09C4 07 17 15      call get_token
1645   09C7 31 B8 16      mov bl, [toktyp]
1646   09CA C1 00         cmp bl, TOKTYP_IDENTIFIER
1647   09CC C7 31 0A      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1648   09CF FD 4D BA 16   mov si, tokstr
1649   09D3 FD 4F 88 1E   mov di, filename
1650   09D7 07 E9 10      call _strcpy        
1651   09DA 77            inc a                         ; metadata sector
1652   09DB 27            mov b, a
1653   09DC 38 00 00      mov c, 0                      ; upper LBA = 0
1654   09DF 22 01         mov ah, $01                  ; 1 sector
1655   09E1 3B 08 27      mov d, transient_area
1656   09E4 07 EE 04      call ide_read_sect            ; read directory
1657   09E7 FD 10         cla
1658   09E9 42 C3 17      mov [index], a
1659   09EC             loadfile_from_path_L1:
1660   09EC FD 4E         mov si, d
1661   09EE FD 4F 88 1E   mov di, filename
1662   09F2 07 D4 10      call _strcmp
1663   09F5 C6 0B 0A      je loadfile_from_path_name_equal  
1664   09F8 58 20 00      add d, 32
1665   09FB 14 C3 17      mov a, [index]
1666   09FE 77            inc a
1667   09FF 42 C3 17      mov [index], a
1668   0A02 AF 10 00      cmp a, FST_FILES_PER_DIR
1669   0A05 C6 31 0A      je loadfile_from_path_end
1670   0A08 0A EC 09      jmp loadfile_from_path_L1
1671   0A0B             loadfile_from_path_name_equal:
1672   0A0B 33 18 00      mov bl, [d + 24]
1673   0A0E FD 87 38      and bl, %00111000             ; directory flag
1674   0A11 C1 08         cmp bl, %00001000             ; is dir?
1675   0A13 C6 27 0A      je loadfile_isdirectory  
1676   0A16             ; entry is a file
1677   0A16 2B 19 00      mov b, [d + 25]               ; get LBA
1678   0A19 FD 77         inc b                         ; add 1 to B because the LBA for data comes after the header sector
1679   0A1B 3B 08 27      mov d, transient_area
1680   0A1E 38 00 00      mov c, 0
1681   0A21 22 1F         mov ah, FS_SECTORS_PER_FILE-1 ; number of sectors
1682   0A23 07 EE 04      call ide_read_sect            ; read sector
1683   0A26 09            ret
1684   0A27             loadfile_isdirectory:
1685   0A27 58 19 00      add d, 25           
1686   0A2A 15            mov a, [d]                    ; set result register A = dirID
1687   0A2B 07 17 15      call get_token
1688   0A2E 0A C4 09      jmp loadfile_from_path_E0
1689   0A31             loadfile_from_path_end:
1690   0A31 09            ret
1691   0A32             
1692   0A32             ;------------------------------------------------------------------------------------------------------;
1693   0A32             ; return the ID of the current directory
1694   0A32             ; ID returned in B
1695   0A32             ;------------------------------------------------------------------------------------------------------;
1696   0A32             fs_get_curr_dirID:
1697   0A32 29 CB 17      mov b, [current_dir_id]
1698   0A35 06            sysret
1699   0A36             
1700   0A36             ;------------------------------------------------------------------------------------------------------;
1701   0A36             ; CD
1702   0A36             ;------------------------------------------------------------------------------------------------------;
1703   0A36             ; new dirID in B
1704   0A36             fs_cd:
1705   0A36 FD 42 CB 17   mov [current_dir_id], b
1706   0A3A 06            sysret  
1707   0A3B             
1708   0A3B             ;------------------------------------------------------------------------------------------------------;
1709   0A3B             ; LS
1710   0A3B             ; dirID in B
1711   0A3B             ;------------------------------------------------------------------------------------------------------;
1712   0A3B 00 00       ls_count:       .dw 0
1713   0A3D             fs_ls:
1714   0A3D FD 77         inc b                        ; metadata sector
1715   0A3F 38 00 00      mov c, 0                     ; upper LBA = 0
1716   0A42 22 01         mov ah, $01                  ; 1 sector
1717   0A44 3B 08 27      mov d, transient_area
1718   0A47 07 EE 04      call ide_read_sect           ; read directory
1719   0A4A FD 10         cla
1720   0A4C 42 C3 17      mov [index], a               ; reset entry index
1721   0A4F 3D 3B 0A      mov [ls_count], al           ; reset item count
1722   0A52             fs_ls_L1:
1723   0A52 BD 00         cmp byte [d], 0              ; check for NULL
1724   0A54 C6 EB 0A      je fs_ls_next
1725   0A57             fs_ls_non_null:
1726   0A57 1D 3B 0A      mov al, [ls_count]
1727   0A5A 7A            inc al
1728   0A5B 3D 3B 0A      mov [ls_count], al           ; increment item count
1729   0A5E 1F 18 00      mov al, [d + 24]
1730   0A61 87 38         and al, %00111000
1731   0A63 FD A2 03      shr al, 3
1732   0A66 22 00         mov ah, 0                    ; file type
1733   0A68 B7 E7 17      mov a, [a + file_type]      
1734   0A6B 23            mov ah, al
1735   0A6C 07 65 11      call _putchar
1736   0A6F 1F 18 00      mov al, [d + 24]
1737   0A72 87 01         and al, %00000001
1738   0A74 22 00         mov ah, 0
1739   0A76 B7 E2 17      mov a, [a + file_attrib]     ; read
1740   0A79 23            mov ah, al
1741   0A7A 07 65 11      call _putchar
1742   0A7D 1F 18 00      mov al, [d + 24]
1743   0A80 87 02         and al, %00000010
1744   0A82 22 00         mov ah, 0
1745   0A84 B7 E2 17      mov a, [a + file_attrib]     ; write
1746   0A87 23            mov ah, al
1747   0A88 07 65 11      call _putchar
1748   0A8B 1F 18 00      mov al, [d + 24]
1749   0A8E 87 04         and al, %00000100
1750   0A90 22 00         mov ah, 0
1751   0A92 B7 E2 17      mov a, [a + file_attrib]     ; execute
1752   0A95 23            mov ah, al
1753   0A96 07 65 11      call _putchar
1754   0A99 22 20         mov ah, $20
1755   0A9B 07 65 11      call _putchar  
1756   0A9E 2B 1B 00      mov b, [d + 27]
1757   0AA1 07 ED 12      call print_u16x              ; filesize
1758   0AA4 22 20         mov ah, $20
1759   0AA6 07 65 11      call _putchar  
1760   0AA9 2B 19 00      mov b, [d + 25]
1761   0AAC 07 ED 12      call print_u16x              ; dirID / LBA
1762   0AAF 22 20         mov ah, $20
1763   0AB1 07 65 11      call _putchar
1764   0AB4             ; print date
1765   0AB4 33 1D 00      mov bl, [d + 29]             ; day
1766   0AB7 07 31 13      call print_u8x
1767   0ABA 22 20         mov ah, $20
1768   0ABC 07 65 11      call _putchar  
1769   0ABF 1F 1E 00      mov al, [d + 30]             ; month
1770   0AC2 FD 9E 02      shl al, 2
1771   0AC5 DA            push d
1772   0AC6 3B A6 18      mov d, s_months
1773   0AC9 22 00         mov ah, 0
1774   0ACB 59            add d, a
1775   0ACC 07 91 12      call _puts
1776   0ACF E7            pop d
1777   0AD0 22 20         mov ah, $20
1778   0AD2 07 65 11      call _putchar
1779   0AD5 2E 20         mov bl, $20
1780   0AD7 07 31 13      call print_u8x
1781   0ADA 33 1F 00      mov bl, [d + 31]             ; year
1782   0ADD 07 31 13      call print_u8x  
1783   0AE0 22 20         mov ah, $20
1784   0AE2 07 65 11      call _putchar  
1785   0AE5 07 91 12      call _puts                   ; print filename  
1786   0AE8 07 3E 12      call printnl
1787   0AEB             fs_ls_next:
1788   0AEB 14 C3 17      mov a, [index]
1789   0AEE 77            inc a
1790   0AEF 42 C3 17      mov [index], a
1791   0AF2 AF 10 00      cmp a, FST_FILES_PER_DIR
1792   0AF5 C6 FE 0A      je fs_ls_end
1793   0AF8 58 20 00      add d, 32      
1794   0AFB 0A 52 0A      jmp fs_ls_L1  
1795   0AFE             fs_ls_end:
1796   0AFE 3B F7 17      mov d, s_ls_total
1797   0B01 07 91 12      call _puts
1798   0B04 1D 3B 0A      mov al, [ls_count]
1799   0B07 07 43 13      call print_u8d
1800   0B0A 07 3E 12      call printnl
1801   0B0D 06            sysret
1802   0B0E             
1803   0B0E             
1804   0B0E             ;------------------------------------------------------------------------------------------------------;
1805   0B0E             ; CREATE NEW TEXTFILE
1806   0B0E             ;------------------------------------------------------------------------------------------------------;
1807   0B0E             ; file structure:
1808   0B0E             ; 512 bytes header
1809   0B0E             ; header used to tell whether the block is free
1810   0B0E             ; d = content pointer in user space
1811   0B0E             ; c = file size
1812   0B0E             ; TODO: i cant remember what starcom is about. i dont think it works anyhow and needs revising/deleting
1813   0B0E             fs_starcom:
1814   0B0E FD 4E       	mov si, d
1815   0B10 FD 4F 08 27 	mov di, transient_area
1816   0B14 57 00 02      add c, 512   ; add 512 to c to include file header which contains the filename
1817   0B17 04          	load					; load data from user-space
1818   0B18 07 99 0B    	call fs_find_empty_block	; look for empty data blocks
1819   0B1B D8          	push b				; save empty block LBA
1820   0B1C FD 79         mov g, b
1821   0B1E             ;create header file by grabbing file name from parameter	
1822   0B1E 3B 08 29    	mov d, transient_area + 512			; pointer to file contents
1823   0B21 D9          	push c							; save length
1824   0B22 19 01       	mov al, 1
1825   0B24 3D 08 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1826   0B27 3B 08 27    	mov d, transient_area
1827   0B2A 12            mov a, c
1828   0B2B 26 00 02      mov b, 512
1829   0B2E AE            div a, b
1830   0B2F FD 77         inc b         ; inc b as the division will most likely have a remainder
1831   0B31 24          	mov ah, bl		; number of sectors to write, which is the result of the division of file size / 512 (small enough to fit in bl)
1832   0B32 38 00 00    	mov c, 0      ; lba 
1833   0B35 FD 27         mov b, g      ; lba 
1834   0B37 07 14 05    	call ide_write_sect			; write sectors
1835   0B3A             ; now we add the file to the current directory!
1836   0B3A             fs_starcom_add_to_dir:	
1837   0B3A 14 CB 17    	mov a, [current_dir_id]
1838   0B3D 77          	inc a
1839   0B3E 27          	mov b, a					; metadata sector
1840   0B3F 38 00 00    	mov c, 0
1841   0B42 FD 79       	mov g, b					; save LBA
1842   0B44 3B 08 25    	mov d, scrap_sector
1843   0B47 22 01       	mov ah, $01			  ; 1 sector
1844   0B49 07 EE 04    	call ide_read_sect		; read metadata sector
1845   0B4C             fs_starcom_add_to_dir_L2:
1846   0B4C BD 00       	cmp byte[d], 0
1847   0B4E C6 57 0B    	je fs_starcom_add_to_dir_null
1848   0B51 58 20 00    	add d, FST_ENTRY_SIZE
1849   0B54 0A 4C 0B    	jmp fs_starcom_add_to_dir_L2		; we look for a NULL entry here but dont check for limits. 
1850   0B57             fs_starcom_add_to_dir_null:
1851   0B57 FD 4D 09 27 	mov si, transient_area + 1		; filename located after the data block 'USED' marker byte
1852   0B5B FD 50       	mov di, d
1853   0B5D 07 E9 10    	call _strcpy			; copy file name
1854   0B60 58 18 00    	add d, 24			; skip name
1855   0B63 19 07       	mov al, %00000111	; type=file, execute, write, read
1856   0B65 3E          	mov [d], al			
1857   0B66 58 03 00    	add d, 3
1858   0B69 E4          	pop a
1859   0B6A 5F 00 02      sub a, 512
1860   0B6D 43          	mov [d], a ; file size
1861   0B6E 63 02 00    	sub d, 2
1862   0B71 E5          	pop b				; get file LBA
1863   0B72 FD 43       	mov [d], b			; save LBA	
1864   0B74             ; set file creation date	
1865   0B74 58 04 00    	add d, 4
1866   0B77 19 04       	mov al, 4
1867   0B79 05 01       	syscall sys_rtc
1868   0B7B 1A          	mov al, ah
1869   0B7C 3E          	mov [d], al			; set day
1870   0B7D 79          	inc d
1871   0B7E 19 05       	mov al, 5
1872   0B80 05 01       	syscall sys_rtc
1873   0B82 1A          	mov al, ah
1874   0B83 3E          	mov [d], al			; set month
1875   0B84 79          	inc d
1876   0B85 19 06       	mov al, 6
1877   0B87 05 01       	syscall sys_rtc
1878   0B89 1A          	mov al, ah
1879   0B8A 3E          	mov [d], al			; set year
1880   0B8B             ; write sector into disk for new directory entry
1881   0B8B FD 27       	mov b, g
1882   0B8D 38 00 00    	mov c, 0
1883   0B90 3B 08 25    	mov d, scrap_sector
1884   0B93 22 01       	mov ah, $01			; disk write, 1 sector
1885   0B95 07 14 05    	call ide_write_sect		; write sector
1886   0B98 06          	sysret
1887   0B99             
1888   0B99             ;------------------------------------------------------------------------------------------------------;
1889   0B99             ; finds an empty data block
1890   0B99             ; block LBA returned in B
1891   0B99             ;------------------------------------------------------------------------------------------------------;
1892   0B99             fs_find_empty_block:
1893   0B99 26 A0 00      mov b, FS_LBA_START     ; raw files starting block
1894   0B9C 38 00 00      mov c, 0                ; upper LBA = 0
1895   0B9F             fs_find_empty_block_L1:  
1896   0B9F 22 01         mov ah, $01                  ; 1 sector
1897   0BA1 3B 08 25      mov d, transient_area - 512
1898   0BA4 07 EE 04      call ide_read_sect      ; read sector
1899   0BA7 BD 00         cmp byte [d], 0
1900   0BA9 C6 B2 0B      je fs_find_empty_block_found_null
1901   0BAC 55 20 00      add b, FS_SECTORS_PER_FILE
1902   0BAF 0A 9F 0B      jmp fs_find_empty_block_L1
1903   0BB2             fs_find_empty_block_found_null:
1904   0BB2 09            ret
1905   0BB3             
1906   0BB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1907   0BB3             ;; CREATE NEW TEXTFILE
1908   0BB3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1909   0BB3             ; search for first null block
1910   0BB3             fs_mktxt:
1911   0BB3 FD 4E       	mov si, d
1912   0BB5 FD 4F 08 1F 	mov di, user_data
1913   0BB9 38 00 01    	mov c, 256
1914   0BBC 04          	load					; load data from user-space
1915   0BBD             	
1916   0BBD 26 A0 00    	mov b, FS_LBA_START		; raw files starting block
1917   0BC0 38 00 00    	mov c, 0						; reset LBA to 0
1918   0BC3             fs_mktxt_L1:	
1919   0BC3 10 02 01    	mov a, $0102			; disk read
1920   0BC6 3B 08 27    	mov d, transient_area
1921   0BC9 05 02       	syscall sys_ide ; read sector
1922   0BCB 1E          	mov al, [d]
1923   0BCC B9 00       	cmp al, 0			; check for NULL
1924   0BCE C6 D7 0B    	je fs_mktxt_found_null
1925   0BD1 55 20 00    	add b, FS_SECTORS_PER_FILE
1926   0BD4 0A C3 0B    	jmp fs_mktxt_L1
1927   0BD7             fs_mktxt_found_null:
1928   0BD7 D8          	push b				; save LBA
1929   0BD8             ;create header file by grabbing file name from parameter	
1930   0BD8 3B D8 17    	mov d, s_dataentry
1931   0BDB 07 91 12    	call _puts
1932   0BDE 3B 08 29    	mov d, transient_area + 512			; pointer to file contents
1933   0BE1 07 F7 11    	call _gettxt
1934   0BE4 07 C4 10    	call _strlen						; get length of file
1935   0BE7 D9          	push c							; save length
1936   0BE8 19 01       	mov al, 1
1937   0BEA 3D 08 27    	mov [transient_area], al					; mark sectors as USED (not NULL)
1938   0BED 10 00 00    	mov a, 0
1939   0BF0 42 C3 17    	mov [index], a
1940   0BF3 3B 08 27    	mov d, transient_area
1941   0BF6 13          	mov a, d
1942   0BF7 42 C5 17    	mov [buffer_addr], a
1943   0BFA             fs_mktxt_L2:
1944   0BFA 38 00 00    	mov c, 0
1945   0BFD 10 03 01    	mov a, $0103			; disk write, 1 sector
1946   0C00 05 02       	syscall sys_ide		; write sector
1947   0C02 14 C3 17    	mov a, [index]
1948   0C05 77          	inc a
1949   0C06 42 C3 17    	mov [index], a
1950   0C09 AF 20 00    	cmp a, FS_SECTORS_PER_FILE
1951   0C0C C6 1E 0C    	je fs_mktxt_add_to_dir
1952   0C0F FD 77       	inc b
1953   0C11 14 C5 17    	mov a, [buffer_addr]
1954   0C14 53 00 02    	add a, 512
1955   0C17 42 C5 17    	mov [buffer_addr], a
1956   0C1A 3C          	mov d, a
1957   0C1B 0A FA 0B    	jmp fs_mktxt_L2
1958   0C1E             ; now we add the file to the current directory!
1959   0C1E             fs_mktxt_add_to_dir:	
1960   0C1E 14 CB 17    	mov a, [current_dir_id]
1961   0C21 77          	inc a
1962   0C22 27          	mov b, a					; metadata sector
1963   0C23 38 00 00    	mov c, 0
1964   0C26 FD 79       	mov g, b					; save LBA
1965   0C28 3B 08 27    	mov d, transient_area
1966   0C2B 10 02 01    	mov a, $0102			; disk read
1967   0C2E 05 02       	syscall sys_ide		; read metadata sector
1968   0C30             fs_mktxt_add_to_dir_L2:
1969   0C30 1E          	mov al, [d]
1970   0C31 B9 00       	cmp al, 0
1971   0C33 C6 3C 0C    	je fs_mktxt_add_to_dir_null
1972   0C36 58 20 00    	add d, FST_ENTRY_SIZE
1973   0C39 0A 30 0C    	jmp fs_mktxt_add_to_dir_L2					; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
1974   0C3C             fs_mktxt_add_to_dir_null:
1975   0C3C FD 4D 08 1F 	mov si, user_data
1976   0C40 FD 50       	mov di, d
1977   0C42 07 E9 10    	call _strcpy			; copy file name
1978   0C45 58 18 00    	add d, 24			; skip name
1979   0C48 19 06       	mov al, %00000110		; no execute, write, read, not directory
1980   0C4A 3E          	mov [d], al			
1981   0C4B 58 03 00    	add d, 3
1982   0C4E E4          	pop a
1983   0C4F 43          	mov [d], a
1984   0C50 63 02 00    	sub d, 2
1985   0C53 E5          	pop b				; get file LBA
1986   0C54 FD 43       	mov [d], b			; save LBA	
1987   0C56             	
1988   0C56             	; set file creation date	
1989   0C56 58 04 00    	add d, 4
1990   0C59 19 04       	mov al, 4
1991   0C5B 05 01       	syscall sys_rtc
1992   0C5D 1A          	mov al, ah
1993   0C5E 3E          	mov [d], al			; set day
1994   0C5F             	
1995   0C5F 79          	inc d
1996   0C60 19 05       	mov al, 5
1997   0C62 05 01       	syscall sys_rtc
1998   0C64 1A          	mov al, ah
1999   0C65 3E          	mov [d], al			; set month
2000   0C66             	
2001   0C66 79          	inc d
2002   0C67 19 06       	mov al, 6
2003   0C69 05 01       	syscall sys_rtc
2004   0C6B 1A          	mov al, ah
2005   0C6C 3E          	mov [d], al			; set year
2006   0C6D             	
2007   0C6D             ; write sector into disk for new directory entry
2008   0C6D FD 27       	mov b, g
2009   0C6F 38 00 00    	mov c, 0
2010   0C72 3B 08 27    	mov d, transient_area
2011   0C75 10 03 01    	mov a, $0103			; disk write, 1 sector
2012   0C78 05 02       	syscall sys_ide		; write sector
2013   0C7A 07 3E 12    	call printnl
2014   0C7D 06          	sysret
2015   0C7E             
2016   0C7E             
2017   0C7E             
2018   0C7E             ;------------------------------------------------------------------------------------------------------;
2019   0C7E             ; create new binary file
2020   0C7E             ;------------------------------------------------------------------------------------------------------;
2021   0C7E             ; search for first null block
2022   0C7E             fs_mkbin:
2023   0C7E 19 00         mov al, 0
2024   0C80 3D BB 17      mov [sys_echo_on], al ; disable echo
2025   0C83 FD 4E         mov si, d
2026   0C85 FD 4F 08 1F   mov di, user_data
2027   0C89 38 00 02      mov c, 512
2028   0C8C 04            load                          ; load data from user-space
2029   0C8D 26 A0 00      mov b, FS_LBA_START           ; files start when directories end
2030   0C90 38 00 00      mov c, 0                      ; upper LBA = 0
2031   0C93             fs_mkbin_L1:  
2032   0C93 22 01         mov ah, $01                  ; 1 sector
2033   0C95 3B 08 27      mov d, transient_area
2034   0C98 07 EE 04      call ide_read_sect            ; read sector
2035   0C9B BD 00         cmp byte[d], 0                ; check for NULL
2036   0C9D C6 A6 0C      je fs_mkbin_found_null
2037   0CA0 55 20 00      add b, FS_SECTORS_PER_FILE
2038   0CA3 0A 93 0C      jmp fs_mkbin_L1
2039   0CA6             fs_mkbin_found_null:
2040   0CA6 D8            push b                        ; save LBA
2041   0CA7             ;create header file by grabbing file name from parameter
2042   0CA7 FD 4F 08 29   mov di, transient_area + 512  ; pointer to file contents
2043   0CAB 07 21 10      call _load_hex                ; load binary hex
2044   0CAE D9            push c                        ; save size (nbr of bytes)
2045   0CAF 19 01         mov al, 1
2046   0CB1 3D 08 27      mov [transient_area], al      ; mark sectors as USED (not NULL)
2047   0CB4 FD 10         cla
2048   0CB6 42 C3 17      mov [index], a
2049   0CB9 3B 08 27      mov d, transient_area
2050   0CBC 13            mov a, d
2051   0CBD 42 C5 17      mov [buffer_addr], a
2052   0CC0             fs_mkbin_L2:
2053   0CC0 38 00 00      mov c, 0
2054   0CC3 22 01         mov ah, $01                   ; disk write, 1 sector
2055   0CC5 07 14 05      call ide_write_sect           ; write sector
2056   0CC8 14 C3 17      mov a, [index]
2057   0CCB 77            inc a
2058   0CCC 42 C3 17      mov [index], a
2059   0CCF AF 20 00      cmp a, FS_SECTORS_PER_FILE    ; remove 1 from this because we dont count the header sector
2060   0CD2 C6 E4 0C      je fs_mkbin_add_to_dir
2061   0CD5 FD 77         inc b
2062   0CD7 14 C5 17      mov a, [buffer_addr]
2063   0CDA 53 00 02      add a, 512
2064   0CDD 42 C5 17      mov [buffer_addr], a
2065   0CE0 3C            mov d, a
2066   0CE1 0A C0 0C      jmp fs_mkbin_L2
2067   0CE4             ; now we add the file to the current directory!
2068   0CE4             fs_mkbin_add_to_dir:  
2069   0CE4 14 CB 17      mov a, [current_dir_id]
2070   0CE7 77            inc a
2071   0CE8 27            mov b, a                      ; metadata sector
2072   0CE9 38 00 00      mov c, 0
2073   0CEC FD 79         mov g, b                      ; save LBA
2074   0CEE 3B 08 27      mov d, transient_area
2075   0CF1 22 01         mov ah, $01                  ; 1 sector
2076   0CF3 07 EE 04      call ide_read_sect            ; read metadata sector
2077   0CF6             fs_mkbin_add_to_dir_L2:
2078   0CF6 BD 00         cmp byte[d], 0
2079   0CF8 C6 01 0D      je fs_mkbin_add_to_dir_null
2080   0CFB 58 20 00      add d, FST_ENTRY_SIZE
2081   0CFE 0A F6 0C      jmp fs_mkbin_add_to_dir_L2   ; we look for a NULL entry here but dont check for limits. CARE NEEDED WHEN ADDING TOO MANY FILES TO A DIRECTORY
2082   0D01             fs_mkbin_add_to_dir_null:
2083   0D01 FD 4D 08 1F   mov si, user_data
2084   0D05 FD 50         mov di, d
2085   0D07 07 E9 10      call _strcpy                  ; copy file name
2086   0D0A 58 18 00      add d, 24                     ; skip name
2087   0D0D 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2088   0D0F 3E            mov [d], al
2089   0D10 58 03 00      add d, 3
2090   0D13 E4            pop a
2091   0D14 43            mov [d], a
2092   0D15 63 02 00      sub d, 2
2093   0D18 E5            pop b                         ; get file LBA
2094   0D19 FD 43         mov [d], b                    ; save LBA
2095   0D1B               ; set file creation date  
2096   0D1B 58 04 00      add d, 4
2097   0D1E 19 04         mov al, 4
2098   0D20 05 01         syscall sys_rtc
2099   0D22 1A            mov al, ah
2100   0D23 3E            mov [d], al                   ; set day
2101   0D24 79            inc d
2102   0D25 19 05         mov al, 5
2103   0D27 05 01         syscall sys_rtc
2104   0D29 1A            mov al, ah
2105   0D2A 3E            mov [d], al                   ; set month
2106   0D2B 79            inc d
2107   0D2C 19 06         mov al, 6
2108   0D2E 05 01         syscall sys_rtc
2109   0D30 1A            mov al, ah
2110   0D31 3E            mov [d], al                   ; set year
2111   0D32             ; write sector into disk for new directory entry
2112   0D32 FD 27         mov b, g
2113   0D34 38 00 00      mov c, 0
2114   0D37 3B 08 27      mov d, transient_area
2115   0D3A 22 01         mov ah, $01                   ; disk write, 1 sector
2116   0D3C 07 14 05      call ide_write_sect           ; write sector
2117   0D3F 19 01         mov al, 1
2118   0D41 3D BB 17      mov [sys_echo_on], al ; enable echo
2119   0D44 06            sysret
2120   0D45             
2121   0D45             ;------------------------------------------------------------------------------------------------------;
2122   0D45             ; pwd - print working directory
2123   0D45             ;------------------------------------------------------------------------------------------------------;    
2124   0D45             fs_pwd:
2125   0D45 3B 88 1E      mov d, filename
2126   0D48 19 00         mov al, 0
2127   0D4A 3E            mov [d], al                   ; initialize path string 
2128   0D4B 14 CB 17      mov a, [current_dir_id]
2129   0D4E 07 24 08      call fs_dir_id_to_path_E0
2130   0D51 3B 88 1E      mov d, filename
2131   0D54 07 7D 10      call _strrev
2132   0D57 07 91 12      call _puts
2133   0D5A 07 3E 12      call printnl
2134   0D5D 06            sysret
2135   0D5E             
2136   0D5E             ;------------------------------------------------------------------------------------------------------;
2137   0D5E             ; get current directory LBA
2138   0D5E             ; A: returned LBA
2139   0D5E             ;------------------------------------------------------------------------------------------------------;
2140   0D5E             cmd_get_curr_dir_LBA:
2141   0D5E 14 CB 17      mov a, [current_dir_id]
2142   0D61 06            sysret
2143   0D62             
2144   0D62             ;------------------------------------------------------------------------------------------------------;
2145   0D62             ; CAT
2146   0D62             ; userspace destination data pointer in D
2147   0D62             ; filename starts at D, but is overwritten after the read is made
2148   0D62             ;------------------------------------------------------------------------------------------------------;:
2149   0D62             fs_cat:
2150   0D62 DA            push d                              ; save userspace file data destination
2151   0D63 FD 4E         mov si, d
2152   0D65 FD 4F 08 1F   mov di, user_data
2153   0D69 38 00 02      mov c, 512
2154   0D6C 04            load                                ; copy filename from user-space
2155   0D6D 29 CB 17      mov b, [current_dir_id]
2156   0D70 FD 77         inc b                               ; metadata sector
2157   0D72 38 00 00      mov c, 0                            ; upper LBA = 0
2158   0D75 22 01         mov ah, $01                  ; 1 sector
2159   0D77 3B 08 25      mov d, transient_area-512
2160   0D7A 07 EE 04      call ide_read_sect                  ; read directory
2161   0D7D FD 10         cla
2162   0D7F 42 C3 17      mov [index], a                      ; reset file counter
2163   0D82             fs_cat_L1:
2164   0D82 FD 4E         mov si, d
2165   0D84 FD 4F 08 1F   mov di, user_data
2166   0D88 07 D4 10      call _strcmp
2167   0D8B C6 A1 0D      je fs_cat_found_entry
2168   0D8E 58 20 00      add d, 32
2169   0D91 14 C3 17      mov a, [index]
2170   0D94 77            inc a
2171   0D95 42 C3 17      mov [index], a
2172   0D98 AF 10 00      cmp a, FST_FILES_PER_DIR
2173   0D9B C6 BC 0D      je fs_cat_not_found
2174   0D9E 0A 82 0D      jmp fs_cat_L1
2175   0DA1             fs_cat_found_entry:
2176   0DA1 58 19 00      add d, 25                           ; get to dirID of file in disk
2177   0DA4 2A            mov b, [d]                          ; get LBA
2178   0DA5 FD 77         inc b                               ; add 1 to B because the LBA for data comes after the header sector 
2179   0DA7 3B 08 27      mov d, transient_area  
2180   0DAA 38 00 00      mov c, 0
2181   0DAD 22 1F         mov ah, FS_SECTORS_PER_FILE-1       ; nbr sectors
2182   0DAF 07 EE 04      call ide_read_sect                  ; read sectors
2183   0DB2 F0            pop di                              ; write userspace file data destination to DI
2184   0DB3 FD 4D 08 27   mov si, transient_area              ; data origin
2185   0DB7 38 00 3E      mov c, 512*(FS_SECTORS_PER_FILE-1)
2186   0DBA 03            store
2187   0DBB 06            sysret
2188   0DBC             fs_cat_not_found:
2189   0DBC E7            pop d
2190   0DBD 06            sysret
2191   0DBE             
2192   0DBE             ;------------------------------------------------------------------------------------------------------;
2193   0DBE             ; RMDIR - remove DIR by dirID
2194   0DBE             ;------------------------------------------------------------------------------------------------------;
2195   0DBE             ; deletes a directory entry in the given directory's file list 
2196   0DBE             ; also deletes the actual directory entry in the FST
2197   0DBE             ; synopsis: rmdir /usr/local/testdir
2198   0DBE             ; B = dirID
2199   0DBE             fs_rmdir:
2200   0DBE FD 79         mov g, b
2201   0DC0 11            mov a, b
2202   0DC1 07 60 08      call get_parentID_from_dirID  ; now get the directory's parent, in A
2203   0DC4 D7            push a                        ; save dirID
2204   0DC5             ; search for directory's entry in the parent's directory then and delete it
2205   0DC5 77            inc a                         ; metadata sector
2206   0DC6 27            mov b, a
2207   0DC7 38 00 00      mov c, 0                      ; upper LBA = 0
2208   0DCA 22 01         mov ah, $01          ;
2209   0DCC 3B 08 27      mov d, transient_area
2210   0DCF 07 EE 04      call ide_read_sect            ; read directory
2211   0DD2 FD 10         cla
2212   0DD4 42 C3 17      mov [index], a                ; reset file counter
2213   0DD7 FD 27         mov b, g                      ; retrieve directory's dirID
2214   0DD9             fs_rmdir_L1:
2215   0DD9 16 19 00      mov a, [d + 25]               ; get entry's dirID/LBA value
2216   0DDC B0            cmp a, b                      ; compare dirID's to find the directory
2217   0DDD C6 F3 0D      je fs_rmdir_found_entry
2218   0DE0 58 20 00      add d, 32
2219   0DE3 14 C3 17      mov a, [index]
2220   0DE6 77            inc a
2221   0DE7 42 C3 17      mov [index], a
2222   0DEA AF 10 00      cmp a, FST_FILES_PER_DIR
2223   0DED C6 18 0E      je fs_rmdir_not_found
2224   0DF0 0A D9 0D      jmp fs_rmdir_L1
2225   0DF3             fs_rmdir_found_entry:
2226   0DF3 FD 10         cla
2227   0DF5 3E            mov [d], al                   ; make filename NULL
2228   0DF6 44 19 00      mov [d + 25], a               ; clear dirID/LBA as well not to generate problems with previously deleted directories
2229   0DF9 E5            pop b
2230   0DFA FD 77         inc b                         ; metadata sector
2231   0DFC 38 00 00      mov c, 0                      ; upper LBA = 0
2232   0DFF 22 01         mov ah, $01          ; 
2233   0E01 3B 08 27      mov d, transient_area
2234   0E04 07 14 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2235   0E07             
2236   0E07 FD 27         mov b, g
2237   0E09 3B 08 27      mov d, transient_area  
2238   0E0C FD 10         cla
2239   0E0E 3E            mov [d], al                   ; make directory's name header NULL for re-use
2240   0E0F 38 00 00      mov c, 0
2241   0E12 22 01         mov ah, $01                   ; disk write 1 sect
2242   0E14 07 14 05      call ide_write_sect           ; delete directory given by dirID in B
2243   0E17 06            sysret
2244   0E18             fs_rmdir_not_found:
2245   0E18 E5            pop b
2246   0E19 06            sysret
2247   0E1A             
2248   0E1A             ;------------------------------------------------------------------------------------------------------;
2249   0E1A             ; RM - remove file
2250   0E1A             ;------------------------------------------------------------------------------------------------------;
2251   0E1A             ; frees up the data sectors for the file further down the disk
2252   0E1A             ; deletes file entry in the directory's file list 
2253   0E1A             fs_rm:
2254   0E1A FD 4E         mov si, d
2255   0E1C FD 4F 08 1F   mov di, user_data
2256   0E20 38 00 02      mov c, 512
2257   0E23 04            load                          ; load data from user-space
2258   0E24 14 CB 17      mov a, [current_dir_id]
2259   0E27 77            inc a                         ; metadata sector
2260   0E28 27            mov b, a
2261   0E29 38 00 00      mov c, 0                      ; upper LBA = 0
2262   0E2C 22 01         mov ah, $01                  ; 1 sector
2263   0E2E 3B 08 27      mov d, transient_area
2264   0E31 07 EE 04      call ide_read_sect            ; read directory
2265   0E34 10 00 00      mov a, 0
2266   0E37 42 C3 17      mov [index], a                ; reset file counter
2267   0E3A             fs_rm_L1:
2268   0E3A FD 4E         mov si, d
2269   0E3C FD 4F 08 1F   mov di, user_data
2270   0E40 07 D4 10      call _strcmp
2271   0E43 C6 59 0E      je fs_rm_found_entry
2272   0E46 58 20 00      add d, 32
2273   0E49 14 C3 17      mov a, [index]
2274   0E4C 77            inc a
2275   0E4D 42 C3 17      mov [index], a
2276   0E50 AF 10 00      cmp a, FST_FILES_PER_DIR
2277   0E53 C6 81 0E      je fs_rm_not_found
2278   0E56 0A 3A 0E      jmp fs_rm_L1
2279   0E59             fs_rm_found_entry:
2280   0E59 2B 19 00      mov b, [d + 25]               ; get LBA
2281   0E5C FD 79         mov g, b                      ; save LBA
2282   0E5E 19 00         mov al, 0
2283   0E60 3E            mov [d], al                   ; make file entry NULL
2284   0E61 14 CB 17      mov a, [current_dir_id]
2285   0E64 77            inc a                         ; metadata sector
2286   0E65 27            mov b, a
2287   0E66 38 00 00      mov c, 0                      ; upper LBA = 0
2288   0E69 22 01         mov ah, $01                   ; disk write
2289   0E6B 3B 08 27      mov d, transient_area
2290   0E6E 07 14 05      call ide_write_sect           ; write sector and erase file's entry in the current DIR
2291   0E71 3B 08 27      mov d, transient_area  
2292   0E74 19 00         mov al, 0
2293   0E76 3E            mov [d], al                   ; make file's data header NULL for re-use
2294   0E77 38 00 00      mov c, 0
2295   0E7A FD 27         mov b, g                      ; get data header LBA
2296   0E7C 22 01         mov ah, $01                   ; disk write 1 sect
2297   0E7E 07 14 05      call ide_write_sect           ; write sector
2298   0E81             fs_rm_not_found:  
2299   0E81 06            sysret  
2300   0E82             
2301   0E82             ;------------------------------------------------------------------------------------------------------;
2302   0E82             ; mv - move / change file name
2303   0E82             ;------------------------------------------------------------------------------------------------------;
2304   0E82             fs_mv:
2305   0E82 FD 4E         mov si, d
2306   0E84 FD 4F 08 1F   mov di, user_data
2307   0E88 38 00 02      mov c, 512
2308   0E8B 04            load                          ; load data from user-space
2309   0E8C 14 CB 17      mov a, [current_dir_id]
2310   0E8F 77            inc a                         ; metadata sector
2311   0E90 27            mov b, a  
2312   0E91 38 00 00      mov c, 0                      ; upper LBA = 0
2313   0E94 22 01         mov ah, $01                  ; 1 sector
2314   0E96 3B 08 27      mov d, transient_area
2315   0E99 07 EE 04      call ide_read_sect            ; read directory
2316   0E9C FD 10         cla
2317   0E9E 42 C3 17      mov [index], a                ; reset file counter
2318   0EA1             fs_mv_L1:
2319   0EA1 FD 4E         mov si, d
2320   0EA3 FD 4F 08 1F   mov di, user_data
2321   0EA7 07 D4 10      call _strcmp
2322   0EAA C6 C0 0E      je fs_mv_found_entry
2323   0EAD 58 20 00      add d, 32
2324   0EB0 14 C3 17      mov a, [index]
2325   0EB3 77            inc a
2326   0EB4 42 C3 17      mov [index], a
2327   0EB7 AF 10 00      cmp a, FST_FILES_PER_DIR
2328   0EBA C6 F2 0E      je fs_mv_not_found
2329   0EBD 0A A1 0E      jmp fs_mv_L1
2330   0EC0             fs_mv_found_entry:  
2331   0EC0 DA            push d
2332   0EC1 FD 4D 88 1F   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2333   0EC5 FD 50         mov di, d
2334   0EC7 07 E9 10      call _strcpy  
2335   0ECA 38 00 00      mov c, 0
2336   0ECD 3B 08 27      mov d, transient_area
2337   0ED0 22 01         mov ah, $01                   ; disk write 1 sect
2338   0ED2 07 14 05      call ide_write_sect           ; write sector
2339   0ED5 E7            pop d
2340   0ED6             ;; need to check whether its a dir or a file here ;;;
2341   0ED6 2B 19 00      mov b, [d + 25]               ; get the dirID of the directory so we can locate its own entry in the list
2342   0ED9 22 01         mov ah, $01
2343   0EDB 3B 08 27      mov d, transient_area
2344   0EDE 38 00 00      mov c, 0
2345   0EE1 07 EE 04      call ide_read_sect            ; read directory entry
2346   0EE4 FD 4D 88 1F   mov si, user_data + 128
2347   0EE8 FD 50         mov di, d
2348   0EEA 07 E9 10      call _strcpy                  ; change directory's name
2349   0EED 22 01         mov ah, $01
2350   0EEF 07 14 05      call ide_write_sect           ; rewrite directory back to disk
2351   0EF2             fs_mv_not_found:
2352   0EF2 06            sysret
2353   0EF3             
2354   0EF3             
2355   0EF3             ;----------------------------------------------------------------------------------------------------;
2356   0EF3             ; Process Index in A
2357   0EF3             ;----------------------------------------------------------------------------------------------------;
2358   0EF3             find_free_proc:
2359   0EF3 FD 4D 79 1C   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2360   0EF7             find_free_proc_L0:
2361   0EF7 F6            lodsb                               ; get process state
2362   0EF8 B9 00         cmp al, 0
2363   0EFA C6 00 0F      je find_free_proc_free              ; if free, jump
2364   0EFD 0A F7 0E      jmp find_free_proc_L0               ; else, goto next
2365   0F00             find_free_proc_free:
2366   0F00 4E            mov a, si
2367   0F01 5F 79 1C      sub a, 1 + proc_availab_table       ; get process index
2368   0F04 09            ret
2369   0F05               
2370   0F05             
2371   0F05             ;----------------------------------------------------------------------------------------------------;
2372   0F05             ; Process Index in AL
2373   0F05             ;----------------------------------------------------------------------------------------------------;
2374   0F05             proc_memory_map:
2375   0F05 22 00         mov ah, 0
2376   0F07 27            mov b, a                      ; page in BL, 0 in BH
2377   0F08 FD 9D 05      shl a, 5                      ; multiply by 32
2378   0F0B 39            mov c, a                      ; save in C
2379   0F0C 57 20 00      add c, 32
2380   0F0F             proc_memory_map_L0:
2381   0F0F 02            pagemap
2382   0F10 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of BH only)
2383   0F13 53 01 00      add a, 1                      ; increase both 
2384   0F16 B1            cmp a, c                      ; check to see if we reached the end of memory
2385   0F17 C7 0F 0F      jne proc_memory_map_L0
2386   0F1A 09            ret
2387   0F1B               
2388   0F1B             
2389   0F1B             ;----------------------------------------------------------------------------------------------------;
2390   0F1B             ; terminate process
2391   0F1B             ;----------------------------------------------------------------------------------------------------;
2392   0F1B             syscall_terminate_proc:
2393   0F1B 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (SP, Status, PC)
2394   0F1E                                                    ; since they will not be used for anything here.
2395   0F1E 1D C2 17      mov al, [active_proc_index]
2396   0F21 22 00         mov ah, 0  
2397   0F23 FD 9D 05      shl a, 5                             ; x32
2398   0F26 53 88 1C      add a, proc_names
2399   0F29 3C            mov d, a
2400   0F2A 19 00         mov al, 0
2401   0F2C 3E            mov [d], al                           ; nullify process name
2402   0F2D             
2403   0F2D 1D C2 17      mov al, [active_proc_index]
2404   0F30 22 00         mov ah, 0  
2405   0F32 3C            mov d, a
2406   0F33 19 00         mov al, 0
2407   0F35 3F 78 1C      mov [d + proc_availab_table], al    ; make process empty again
2408   0F38               
2409   0F38 1D C1 17      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2410   0F3B 80            dec al
2411   0F3C 3D C1 17      mov [nbr_active_procs], al
2412   0F3F             
2413   0F3F             ; now load the shell process again
2414   0F3F 19 02         mov al, 2                           ; next process = process 2 = shell
2415   0F41 3D C2 17      mov [active_proc_index], al         ; set next active proc
2416   0F44             
2417   0F44             ; calculate LUT entry for next process
2418   0F44 22 00         mov ah, 0
2419   0F46 FD 99         shl a                               ; x2
2420   0F48 B7 11 10      mov a, [proc_table_convert + a]     ; get process state start index  
2421   0F4B               
2422   0F4B 4D            mov si, a                           ; source is proc state block
2423   0F4C 48            mov a, sp
2424   0F4D 5F 13 00      sub a, 19
2425   0F50 4F            mov di, a                           ; destination is kernel stack
2426   0F51             ; restore SP
2427   0F51 7D            dec a
2428   0F52 47            mov sp, a
2429   0F53 38 14 00      mov c, 20
2430   0F56 FD F5         rep movsb
2431   0F58             ; set VM process
2432   0F58 1D C2 17      mov al, [active_proc_index]
2433   0F5B 01            setptb
2434   0F5C                 
2435   0F5C 4C            popa
2436   0F5D 06            sysret
2437   0F5E             
2438   0F5E             ;----------------------------------------------------------------------------------------------------;
2439   0F5E             ; pause process
2440   0F5E             ;----------------------------------------------------------------------------------------------------;
2441   0F5E             syscall_pause_proc:
2442   0F5E             ; save all registers into kernel stack
2443   0F5E 4B            pusha
2444   0F5F 22 00         mov ah, 0
2445   0F61 1D C2 17      mov al, [active_proc_index]
2446   0F64 FD 99         shl a              ; x2
2447   0F66 B7 11 10      mov a, [proc_table_convert + a]   ; get process state start index
2448   0F69                 
2449   0F69 4F            mov di, a
2450   0F6A 48            mov a, sp
2451   0F6B 77            inc a
2452   0F6C 4D            mov si, a
2453   0F6D 38 14 00      mov c, 20
2454   0F70 FD F5         rep movsb                         ; save process state!
2455   0F72             ; restore kernel stack position to point before interrupt arrived
2456   0F72 51 14 00      add sp, 20
2457   0F75             ; now load the shell process again
2458   0F75 19 02         mov al, 2                         ; next process = process 2 = shell
2459   0F77 3D C2 17      mov [active_proc_index], al       ; set next active proc
2460   0F7A             
2461   0F7A             ; calculate LUT entry for next process
2462   0F7A 22 00         mov ah, 0
2463   0F7C FD 99         shl a                             ; x2
2464   0F7E B7 11 10      mov a, [proc_table_convert + a]   ; get process state start index  
2465   0F81               
2466   0F81 4D            mov si, a                         ; source is proc state block
2467   0F82 48            mov a, sp
2468   0F83 5F 13 00      sub a, 19
2469   0F86 4F            mov di, a                         ; destination is kernel stack
2470   0F87             ; restore SP
2471   0F87 7D            dec a
2472   0F88 47            mov sp, a
2473   0F89 38 14 00      mov c, 20
2474   0F8C FD F5         rep movsb
2475   0F8E             ; set VM process
2476   0F8E 1D C2 17      mov al, [active_proc_index]
2477   0F91 01            setptb
2478   0F92                 
2479   0F92 4C            popa
2480   0F93 06            sysret
2481   0F94             
2482   0F94             ;----------------------------------------------------------------------------------------------------;
2483   0F94             ; create a new process
2484   0F94             ; D = path of the process file to be createed
2485   0F94             ; B = arguments ptr
2486   0F94             ;----------------------------------------------------------------------------------------------------;
2487   0F94             syscall_create_proc:
2488   0F94             ; we save the active process first  
2489   0F94 4B            pusha
2490   0F95 22 00         mov ah, 0
2491   0F97 1D C2 17      mov al, [active_proc_index]
2492   0F9A FD 99         shl a              ; x2
2493   0F9C B7 11 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2494   0F9F               
2495   0F9F 4F            mov di, a
2496   0FA0 48            mov a, sp
2497   0FA1 77            inc a
2498   0FA2 4D            mov si, a
2499   0FA3 38 14 00      mov c, 20
2500   0FA6 FD F5         rep movsb                          ; save process state!
2501   0FA8             ; restore kernel stack position to point before interrupt arrived
2502   0FA8 51 14 00      add sp, 20
2503   0FAB               
2504   0FAB FD 4E         mov si, d                          ; copy the file path
2505   0FAD FD 4F 08 1F   mov di, user_data
2506   0FB1 38 00 02      mov c, 512
2507   0FB4 04            load
2508   0FB5 11            mov a, b
2509   0FB6 4D            mov si, a                          ; copy the arguments
2510   0FB7 FD 4F 08 25   mov di, scrap_sector
2511   0FBB 38 00 02      mov c, 512
2512   0FBE 04            load
2513   0FBF 07 A6 09      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2514   0FC2                                                  ; the file data is loaded into transient_area
2515   0FC2             ; now we allocate a new process  
2516   0FC2 07 F3 0E      call find_free_proc                ; index in A
2517   0FC5 01            setptb 
2518   0FC6 07 05 0F      call proc_memory_map               ; map process memory pages
2519   0FC9             ; copy arguments into process's memory
2520   0FC9 FD 4D 08 25   mov si, scrap_sector
2521   0FCD FD 4F 00 00   mov di, 0
2522   0FD1 38 00 02      mov c, 512
2523   0FD4 03            store
2524   0FD5             ; now copy process binary data into process's memory
2525   0FD5 FD 4D 08 27   mov si, transient_area
2526   0FD9 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2527   0FDD 38 00 40      mov c, FS_FILE_SIZE                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2528   0FE0 03            store                              ; copy process data
2529   0FE1                 
2530   0FE1 07 F3 0E      call find_free_proc                ; index in A
2531   0FE4 3D C2 17      mov [active_proc_index], al        ; set new active process
2532   0FE7 FD 9D 05      shl a, 5                           ; x32
2533   0FEA 53 88 1C      add a, proc_names
2534   0FED 4F            mov di, a
2535   0FEE FD 4D 08 1F   mov si, user_data                  ; copy and store process filename
2536   0FF2 07 E9 10      call _strcpy
2537   0FF5               
2538   0FF5 07 F3 0E      call find_free_proc                ; index in A
2539   0FF8 3C            mov d, a
2540   0FF9 19 01         mov al, 1
2541   0FFB 3F 78 1C      mov [d + proc_availab_table], al   ; make process busy
2542   0FFE               
2543   0FFE 1D C1 17      mov al, [nbr_active_procs]         ; increase nbr of active processes
2544   1001 7A            inc al
2545   1002 3D C1 17      mov [nbr_active_procs], al
2546   1005             ; launch process
2547   1005 FD D7 FF FF   push word $FFFF 
2548   1009 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2549   100C FD D7 00 04   push word text_org
2550   1010 06            sysret
2551   1011             
2552   1011             proc_table_convert:
2553   1011 38 1B         .dw proc_state_table + 0
2554   1013 4C 1B         .dw proc_state_table + 20
2555   1015 60 1B         .dw proc_state_table + 40
2556   1017 74 1B         .dw proc_state_table + 60
2557   1019 88 1B         .dw proc_state_table + 80
2558   101B 9C 1B         .dw proc_state_table + 100
2559   101D B0 1B         .dw proc_state_table + 120
2560   101F C4 1B         .dw proc_state_table + 140
2561   1021               
2562   1021             ;----------------------------------------------------------------------------------------------;
2563   1021             ; GET HEX FILE
2564   1021             ; di = destination address
2565   1021             ; return length in bytes in C
2566   1021             ;----------------------------------------------------------------------------------------------;
2567   1021             _load_hex:
2568   1021 D7            push a
2569   1022 D8            push b
2570   1023 DA            push d
2571   1024 E2            push si
2572   1025 E3            push di
2573   1026 38 00 00      mov c, 0
2574   1029 50            mov a, di
2575   102A 3C            mov d, a          ; start of string data block
2576   102B 07 6C 11      call _gets        ; get program string
2577   102E 4D            mov si, a
2578   102F             __load_hex_loop:
2579   102F F6            lodsb             ; load from [SI] to AL
2580   1030 B9 00         cmp al, 0         ; check if ASCII 0
2581   1032 C6 40 10      jz __load_hex_ret
2582   1035 36            mov bh, al
2583   1036 F6            lodsb
2584   1037 2F            mov bl, al
2585   1038 07 22 11      call _atoi        ; convert ASCII byte in B to int (to AL)
2586   103B F7            stosb             ; store AL to [DI]
2587   103C 78            inc c
2588   103D 0A 2F 10      jmp __load_hex_loop
2589   1040             __load_hex_ret:
2590   1040 F0            pop di
2591   1041 EF            pop si
2592   1042 E7            pop d
2593   1043 E5            pop b
2594   1044 E4            pop a
2595   1045 09            ret
2596   1046             
2597   1046             ; synopsis: look inside a certain directory for files/directories
2598   1046             ; before calling this function, cd into required directory
2599   1046             ; for each entry inside directory:
2600   1046             ;  if entry is a file:
2601   1046             ;    compare filename to searched filename
2602   1046             ;    if filenames are the same, print filename
2603   1046             ;  else if entry is a directory:
2604   1046             ;    cd to the given directory
2605   1046             ;    recursively call cmd_find
2606   1046             ;    cd outside previous directory
2607   1046             ;  if current entry == last entry, return
2608   1046             ; endfor
2609   1046             f_find:
2610   1046 09            ret
2611   1047             
2612   1047             
2613   1047             ; ---------------------------------------------------------------------
2614   1047             ; kernel reset vector
2615   1047             ; ---------------------------------------------------------------------
2616   1047             kernel_reset_vector:  
2617   1047 FD 49 FF F7   mov bp, STACK_BEGIN
2618   104B FD 47 FF F7   mov sp, STACK_BEGIN
2619   104F               
2620   104F 19 81         mov al, %10000001
2621   1051 FD 0F         stomsk                        ; mask out timer interrupt for now (only allow UART to interrupt)
2622   1053 FD 0C         sti  
2623   1055             
2624   1055 0C            lodstat
2625   1056 87 DF         and al, %11011111             ; disable display register loading
2626   1058 0D            stostat
2627   1059               
2628   1059             ; reset fifo pointers
2629   1059 10 08 21      mov a, fifo
2630   105C 3B C7 17      mov d, fifo_in
2631   105F 43            mov [d], a
2632   1060 3B C9 17      mov d, fifo_out
2633   1063 43            mov [d], a  
2634   1064 19 02         mov al, 2
2635   1066 05 03         syscall sys_io                ; enable uart in interrupt mode
2636   1068               
2637   1068 3B 0D 18      mov d, s_kernel_started
2638   106B 07 91 12      call _puts
2639   106E             
2640   106E 19 10         mov al, 16
2641   1070 05 04         syscall sys_filesystem        ; set root dirID
2642   1072             
2643   1072 3B 2A 18      mov d, s_prompt_init
2644   1075 07 91 12      call _puts
2645   1078 3B CD 17      mov d, s_init_path
2646   107B 05 05         syscall sys_create_proc              ; launch init as a new process
2647   107D             
2648   107D             
2649   107D             ; FILE INCLUDES
2650   107D             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  107D             BIOS_RESET_VECTOR .EQU  $01c0
0002+  107D             IDE_buffer       .EQU  $8204
0003+  107D             boot_origin      .EQU  $8004
0004+  107D             bios_uart        .EQU  $0002
0005+  107D             bios_ide         .EQU  $0003
2651   107D             .include "lib/stdio.asm"
0001+  107D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  107D             ; stdio.s
0003+  107D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  107D             .include "lib/string.asm"
0001++ 107D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 107D             ; string.s
0003++ 107D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 107D             
0005++ 107D             
0006++ 107D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 107D             ; _strrev
0008++ 107D             ; reverse a string
0009++ 107D             ; D = string address
0010++ 107D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 107D             ; 01234
0012++ 107D             _strrev:
0013++ 107D 4B          	pusha
0014++ 107E 07 C4 10    	call _strlen	; length in C
0015++ 1081 12          	mov a, c
0016++ 1082 AF 01 00    	cmp a, 1
0017++ 1085 D0 9F 10    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1088 7D          	dec a
0019++ 1089 FD 4E       	mov si, d	; beginning of string
0020++ 108B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 108D 59          	add d, a	; end of string
0022++ 108E 12          	mov a, c
0023++ 108F FD 9B       	shr a		; divide by 2
0024++ 1091 39          	mov c, a	; C now counts the steps
0025++ 1092             _strrev_L0:
0026++ 1092 32          	mov bl, [d]	; save load right-side char into BL
0027++ 1093 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 1094 3E          	mov [d], al	; store left char into right side
0029++ 1095 1B          	mov al, bl
0030++ 1096 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 1097 7E          	dec c
0032++ 1098 7F          	dec d
0033++ 1099 C2 00 00    	cmp c, 0
0034++ 109C C7 92 10    	jne _strrev_L0
0035++ 109F             _strrev_end:
0036++ 109F 4C          	popa
0037++ 10A0 09          	ret
0038++ 10A1             	
0039++ 10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 10A1             ; _strchr
0041++ 10A1             ; search string in D for char in AL
0042++ 10A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 10A1             _strchr:
0044++ 10A1             _strchr_L0:
0045++ 10A1 32          	mov bl, [d]
0046++ 10A2 C1 00       	cmp bl, 0
0047++ 10A4 C6 AF 10    	je _strchr_end
0048++ 10A7 BA          	cmp al, bl
0049++ 10A8 C6 AF 10    	je _strchr_end
0050++ 10AB 79          	inc d
0051++ 10AC 0A A1 10    	jmp _strchr_L0
0052++ 10AF             _strchr_end:
0053++ 10AF 1B          	mov al, bl
0054++ 10B0 09          	ret
0055++ 10B1             
0056++ 10B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 10B1             ; _strstr
0058++ 10B1             ; find sub-string
0059++ 10B1             ; str1 in SI
0060++ 10B1             ; str2 in DI
0061++ 10B1             ; SI points to end of source string
0062++ 10B1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 10B1             _strstr:
0064++ 10B1 DB          	push al
0065++ 10B2 DA          	push d
0066++ 10B3 E3          	push di
0067++ 10B4             _strstr_loop:
0068++ 10B4 F3          	cmpsb					; compare a byte of the strings
0069++ 10B5 C7 C0 10    	jne _strstr_ret
0070++ 10B8 FC 00 00    	lea d, [di + 0]
0071++ 10BB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 10BD C7 B4 10    	jne _strstr_loop				; equal chars but not at end
0073++ 10C0             _strstr_ret:
0074++ 10C0 F0          	pop di
0075++ 10C1 E7          	pop d
0076++ 10C2 E8          	pop al
0077++ 10C3 09          	ret
0078++ 10C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 10C4             ; length of null terminated string
0080++ 10C4             ; result in C
0081++ 10C4             ; pointer in D
0082++ 10C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 10C4             _strlen:
0084++ 10C4 DA          	push d
0085++ 10C5 38 00 00    	mov c, 0
0086++ 10C8             _strlen_L1:
0087++ 10C8 BD 00       	cmp byte [d], 0
0088++ 10CA C6 D2 10    	je _strlen_ret
0089++ 10CD 79          	inc d
0090++ 10CE 78          	inc c
0091++ 10CF 0A C8 10    	jmp _strlen_L1
0092++ 10D2             _strlen_ret:
0093++ 10D2 E7          	pop d
0094++ 10D3 09          	ret
0095++ 10D4             
0096++ 10D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 10D4             ; STRCMP
0098++ 10D4             ; compare two strings
0099++ 10D4             ; str1 in SI
0100++ 10D4             ; str2 in DI
0101++ 10D4             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 10D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 10D4             _strcmp:
0104++ 10D4 DB          	push al
0105++ 10D5 DA          	push d
0106++ 10D6 E3          	push di
0107++ 10D7 E2          	push si
0108++ 10D8             _strcmp_loop:
0109++ 10D8 F3          	cmpsb					; compare a byte of the strings
0110++ 10D9 C7 E4 10    	jne _strcmp_ret
0111++ 10DC FB FF FF    	lea d, [si +- 1]
0112++ 10DF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 10E1 C7 D8 10    	jne _strcmp_loop				; equal chars but not at end
0114++ 10E4             _strcmp_ret:
0115++ 10E4 EF          	pop si
0116++ 10E5 F0          	pop di
0117++ 10E6 E7          	pop d
0118++ 10E7 E8          	pop al
0119++ 10E8 09          	ret
0120++ 10E9             
0121++ 10E9             
0122++ 10E9             ; STRCPY
0123++ 10E9             ; copy null terminated string from SI to DI
0124++ 10E9             ; source in SI
0125++ 10E9             ; destination in DI
0126++ 10E9             _strcpy:
0127++ 10E9 E2          	push si
0128++ 10EA E3          	push di
0129++ 10EB DB          	push al
0130++ 10EC             _strcpy_L1:
0131++ 10EC F6          	lodsb
0132++ 10ED F7          	stosb
0133++ 10EE B9 00       	cmp al, 0
0134++ 10F0 C7 EC 10    	jne _strcpy_L1
0135++ 10F3             _strcpy_end:
0136++ 10F3 E8          	pop al
0137++ 10F4 F0          	pop di
0138++ 10F5 EF          	pop si
0139++ 10F6 09          	ret
0140++ 10F7             
0141++ 10F7             ; STRCAT
0142++ 10F7             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 10F7             ; source in SI
0144++ 10F7             ; destination in DI
0145++ 10F7             _strcat:
0146++ 10F7 E2          	push si
0147++ 10F8 E3          	push di
0148++ 10F9 D7          	push a
0149++ 10FA DA          	push d
0150++ 10FB 50          	mov a, di
0151++ 10FC 3C          	mov d, a
0152++ 10FD             _strcat_goto_end_L1:
0153++ 10FD BD 00       	cmp byte[d], 0
0154++ 10FF C6 06 11    	je _strcat_start
0155++ 1102 79          	inc d
0156++ 1103 0A FD 10    	jmp _strcat_goto_end_L1
0157++ 1106             _strcat_start:
0158++ 1106 FD 50       	mov di, d
0159++ 1108             _strcat_L1:
0160++ 1108 F6          	lodsb
0161++ 1109 F7          	stosb
0162++ 110A B9 00       	cmp al, 0
0163++ 110C C7 08 11    	jne _strcat_L1
0164++ 110F             _strcat_end:
0165++ 110F E7          	pop d
0166++ 1110 E4          	pop a
0167++ 1111 F0          	pop di
0168++ 1112 EF          	pop si
0169++ 1113 09          	ret
0170++ 1114             
0171++ 1114             
0005+  1114             
0006+  1114             
0007+  1114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1114             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  1114             ; ASCII in BL
0010+  1114             ; result in AL
0011+  1114             ; ascii for F = 0100 0110
0012+  1114             ; ascii for 9 = 0011 1001
0013+  1114             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1114             hex_ascii_encode:
0015+  1114 1B            mov al, bl
0016+  1115 93 40         test al, $40        ; test if letter or number
0017+  1117 C7 1D 11      jnz hex_letter
0018+  111A 87 0F         and al, $0F        ; get number
0019+  111C 09            ret
0020+  111D             hex_letter:
0021+  111D 87 0F         and al, $0F        ; get letter
0022+  111F 6A 09         add al, 9
0023+  1121 09            ret
0024+  1122             
0025+  1122             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1122             ; ATOI
0027+  1122             ; 2 letter hex string in B
0028+  1122             ; 8bit integer returned in AL
0029+  1122             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  1122             _atoi:
0031+  1122 D8            push b
0032+  1123 07 14 11      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  1126 30            mov bl, bh
0034+  1127 DB            push al          ; save a
0035+  1128 07 14 11      call hex_ascii_encode
0036+  112B EA            pop bl  
0037+  112C FD 9E 04      shl al, 4
0038+  112F 8C            or al, bl
0039+  1130 E5            pop b
0040+  1131 09            ret  
0041+  1132             
0042+  1132             
0043+  1132             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  1132             ; scanf
0045+  1132             ; no need for explanations!
0046+  1132             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  1132             scanf:
0048+  1132 09            ret
0049+  1133             
0050+  1133             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  1133             ; ITOA
0052+  1133             ; 8bit value in BL
0053+  1133             ; 2 byte ASCII result in A
0054+  1133             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  1133             _itoa:
0056+  1133 DA            push d
0057+  1134 D8            push b
0058+  1135 A7 00         mov bh, 0
0059+  1137 FD A4 04      shr bl, 4  
0060+  113A 74            mov d, b
0061+  113B 1F CD 13      mov al, [d + s_hex_digits]
0062+  113E 23            mov ah, al
0063+  113F               
0064+  113F E5            pop b
0065+  1140 D8            push b
0066+  1141 A7 00         mov bh, 0
0067+  1143 FD 87 0F      and bl, $0F
0068+  1146 74            mov d, b
0069+  1147 1F CD 13      mov al, [d + s_hex_digits]
0070+  114A E5            pop b
0071+  114B E7            pop d
0072+  114C 09            ret
0073+  114D             
0074+  114D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  114D             ; HEX STRING TO BINARY
0076+  114D             ; di = destination address
0077+  114D             ; si = source
0078+  114D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  114D             _hex_to_int:
0080+  114D             _hex_to_int_L1:
0081+  114D F6            lodsb          ; load from [SI] to AL
0082+  114E B9 00         cmp al, 0        ; check if ASCII 0
0083+  1150 C6 5D 11      jz _hex_to_int_ret
0084+  1153 36            mov bh, al
0085+  1154 F6            lodsb
0086+  1155 2F            mov bl, al
0087+  1156 07 22 11      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  1159 F7            stosb          ; store AL to [DI]
0089+  115A 0A 4D 11      jmp _hex_to_int_L1
0090+  115D             _hex_to_int_ret:
0091+  115D 09            ret    
0092+  115E             
0093+  115E             
0094+  115E             
0095+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  115E             ; GETCHAR
0097+  115E             ; char in ah
0098+  115E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  115E             getch:
0100+  115E DB            push al
0101+  115F             getch_retry:
0102+  115F 19 01         mov al, 1
0103+  1161 05 03         syscall sys_io      ; receive in AH
0104+  1163 E8            pop al
0105+  1164 09            ret
0106+  1165             
0107+  1165             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  1165             ; PUTCHAR
0109+  1165             ; char in ah
0110+  1165             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  1165             _putchar:
0112+  1165 DB            push al
0113+  1166 19 00         mov al, 0
0114+  1168 05 03         syscall sys_io      ; char in AH
0115+  116A E8            pop al
0116+  116B 09            ret
0117+  116C             
0118+  116C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  116C             ;; INPUT A STRING
0120+  116C             ;; terminates with null
0121+  116C             ;; pointer in D
0122+  116C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  116C             _gets:
0124+  116C D7            push a
0125+  116D DA            push d
0126+  116E             _gets_loop:
0127+  116E 19 01         mov al, 1
0128+  1170 05 03         syscall sys_io      ; receive in AH
0129+  1172 76 1B         cmp ah, 27
0130+  1174 C6 95 11      je _gets_ansi_esc
0131+  1177 76 0A         cmp ah, $0A        ; LF
0132+  1179 C6 F1 11      je _gets_end
0133+  117C 76 0D         cmp ah, $0D        ; CR
0134+  117E C6 F1 11      je _gets_end
0135+  1181 76 5C         cmp ah, $5C        ; '\\'
0136+  1183 C6 B7 11      je _gets_escape
0137+  1186 76 08         cmp ah, $08      ; check for backspace
0138+  1188 C6 91 11      je _gets_backspace
0139+  118B 1A            mov al, ah
0140+  118C 3E            mov [d], al
0141+  118D 79            inc d
0142+  118E 0A 6E 11      jmp _gets_loop
0143+  1191             _gets_backspace:
0144+  1191 7F            dec d
0145+  1192 0A 6E 11      jmp _gets_loop
0146+  1195             _gets_ansi_esc:
0147+  1195 19 01         mov al, 1
0148+  1197 05 03         syscall sys_io        ; receive in AH without echo
0149+  1199 76 5B         cmp ah, '['
0150+  119B C7 6E 11      jne _gets_loop
0151+  119E 19 01         mov al, 1
0152+  11A0 05 03         syscall sys_io          ; receive in AH without echo
0153+  11A2 76 44         cmp ah, 'D'
0154+  11A4 C6 AF 11      je _gets_left_arrow
0155+  11A7 76 43         cmp ah, 'C'
0156+  11A9 C6 B3 11      je _gets_right_arrow
0157+  11AC 0A 6E 11      jmp _gets_loop
0158+  11AF             _gets_left_arrow:
0159+  11AF 7F            dec d
0160+  11B0 0A 6E 11      jmp _gets_loop
0161+  11B3             _gets_right_arrow:
0162+  11B3 79            inc d
0163+  11B4 0A 6E 11      jmp _gets_loop
0164+  11B7             _gets_escape:
0165+  11B7 19 01         mov al, 1
0166+  11B9 05 03         syscall sys_io      ; receive in AH
0167+  11BB 76 6E         cmp ah, 'n'
0168+  11BD C6 DC 11      je _gets_LF
0169+  11C0 76 72         cmp ah, 'r'
0170+  11C2 C6 E3 11      je _gets_CR
0171+  11C5 76 30         cmp ah, '0'
0172+  11C7 C6 EA 11      je _gets_NULL
0173+  11CA 76 5C         cmp ah, $5C  ; '\'
0174+  11CC C6 D5 11      je _gets_slash
0175+  11CF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  11D0 3E            mov [d], al
0177+  11D1 79            inc d
0178+  11D2 0A 6E 11      jmp _gets_loop
0179+  11D5             _gets_slash:
0180+  11D5 19 5C         mov al, $5C
0181+  11D7 3E            mov [d], al
0182+  11D8 79            inc d
0183+  11D9 0A 6E 11      jmp _gets_loop
0184+  11DC             _gets_LF:
0185+  11DC 19 0A         mov al, $0A
0186+  11DE 3E            mov [d], al
0187+  11DF 79            inc d
0188+  11E0 0A 6E 11      jmp _gets_loop
0189+  11E3             _gets_CR:
0190+  11E3 19 0D         mov al, $0D
0191+  11E5 3E            mov [d], al
0192+  11E6 79            inc d
0193+  11E7 0A 6E 11      jmp _gets_loop
0194+  11EA             _gets_NULL:
0195+  11EA 19 00         mov al, $00
0196+  11EC 3E            mov [d], al
0197+  11ED 79            inc d
0198+  11EE 0A 6E 11      jmp _gets_loop
0199+  11F1             _gets_end:
0200+  11F1 19 00         mov al, 0
0201+  11F3 3E            mov [d], al        ; terminate string
0202+  11F4 E7            pop d
0203+  11F5 E4            pop a
0204+  11F6 09            ret
0205+  11F7             
0206+  11F7             
0207+  11F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  11F7             ;; INPUT TEXT
0209+  11F7             ;; terminated with CTRL+D
0210+  11F7             ;; pointer in D
0211+  11F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  11F7             _gettxt:
0213+  11F7 D7            push a
0214+  11F8 DA            push d
0215+  11F9             _gettxt_loop:
0216+  11F9 19 01         mov al, 1
0217+  11FB 05 03         syscall sys_io      ; receive in AH
0218+  11FD 76 04         cmp ah, 4      ; EOT
0219+  11FF C6 38 12      je _gettxt_end
0220+  1202 76 08         cmp ah, $08      ; check for backspace
0221+  1204 C6 34 12      je _gettxt_backspace
0222+  1207 76 5C         cmp ah, $5C        ; '\'
0223+  1209 C6 12 12      je _gettxt_escape
0224+  120C 1A            mov al, ah
0225+  120D 3E            mov [d], al
0226+  120E 79            inc d
0227+  120F 0A F9 11      jmp _gettxt_loop
0228+  1212             _gettxt_escape:
0229+  1212 19 01         mov al, 1
0230+  1214 05 03         syscall sys_io      ; receive in AH
0231+  1216 76 6E         cmp ah, 'n'
0232+  1218 C6 26 12      je _gettxt_LF
0233+  121B 76 72         cmp ah, 'r'
0234+  121D C6 2D 12      je _gettxt_CR
0235+  1220 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  1221 3E            mov [d], al
0237+  1222 79            inc d
0238+  1223 0A F9 11      jmp _gettxt_loop
0239+  1226             _gettxt_LF:
0240+  1226 19 0A         mov al, $0A
0241+  1228 3E            mov [d], al
0242+  1229 79            inc d
0243+  122A 0A F9 11      jmp _gettxt_loop
0244+  122D             _gettxt_CR:
0245+  122D 19 0D         mov al, $0D
0246+  122F 3E            mov [d], al
0247+  1230 79            inc d
0248+  1231 0A F9 11      jmp _gettxt_loop
0249+  1234             _gettxt_backspace:
0250+  1234 7F            dec d
0251+  1235 0A F9 11      jmp _gettxt_loop
0252+  1238             _gettxt_end:
0253+  1238 19 00         mov al, 0
0254+  123A 3E            mov [d], al        ; terminate string
0255+  123B E7            pop d
0256+  123C E4            pop a
0257+  123D 09            ret
0258+  123E             
0259+  123E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  123E             ; PRINT NEW LINE
0261+  123E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  123E             printnl:
0263+  123E D7            push a
0264+  123F 10 00 0A      mov a, $0A00
0265+  1242 05 03         syscall sys_io
0266+  1244 10 00 0D      mov a, $0D00
0267+  1247 05 03         syscall sys_io
0268+  1249 E4            pop a
0269+  124A 09            ret
0270+  124B             
0271+  124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  124B             ; _strtoint
0273+  124B             ; 4 digit hex string number in d
0274+  124B             ; integer returned in A
0275+  124B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  124B             _strtointx:
0277+  124B D8            push b
0278+  124C 32            mov bl, [d]
0279+  124D 37            mov bh, bl
0280+  124E 33 01 00      mov bl, [d + 1]
0281+  1251 07 22 11      call _atoi        ; convert to int in AL
0282+  1254 23            mov ah, al        ; move to AH
0283+  1255 33 02 00      mov bl, [d + 2]
0284+  1258 37            mov bh, bl
0285+  1259 33 03 00      mov bl, [d + 3]
0286+  125C 07 22 11      call _atoi        ; convert to int in AL
0287+  125F E5            pop b
0288+  1260 09            ret
0289+  1261             
0290+  1261             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  1261             ; _strtoint
0292+  1261             ; 5 digit base10 string number in d
0293+  1261             ; integer returned in A
0294+  1261             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  1261             _strtoint:
0296+  1261 E2            push si
0297+  1262 D8            push b
0298+  1263 D9            push c
0299+  1264 DA            push d
0300+  1265 07 C4 10      call _strlen      ; get string length in C
0301+  1268 7E            dec c
0302+  1269 FD 4E         mov si, d
0303+  126B 12            mov a, c
0304+  126C FD 99         shl a
0305+  126E 3B E5 13      mov d, table_power
0306+  1271 59            add d, a
0307+  1272 38 00 00      mov c, 0
0308+  1275             _strtoint_L0:
0309+  1275 F6            lodsb      ; load ASCII to al
0310+  1276 B9 00         cmp al, 0
0311+  1278 C6 8B 12      je _strtoint_end
0312+  127B 6F 30         sub al, $30    ; make into integer
0313+  127D 22 00         mov ah, 0
0314+  127F 2A            mov b, [d]
0315+  1280 AC            mul a, b      ; result in B since it fits in 16bits
0316+  1281 11            mov a, b
0317+  1282 28            mov b, c
0318+  1283 54            add a, b
0319+  1284 39            mov c, a
0320+  1285 63 02 00      sub d, 2
0321+  1288 0A 75 12      jmp _strtoint_L0
0322+  128B             _strtoint_end:
0323+  128B 12            mov a, c
0324+  128C E7            pop d
0325+  128D E6            pop c
0326+  128E E5            pop b
0327+  128F EF            pop si
0328+  1290 09            ret
0329+  1291             
0330+  1291             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  1291             ; PRINT NULL TERMINATED STRING
0332+  1291             ; pointer in D
0333+  1291             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  1291             _puts:
0335+  1291 D7            push a
0336+  1292 DA            push d
0337+  1293             _puts_L1:
0338+  1293 1E            mov al, [d]
0339+  1294 B9 00         cmp al, 0
0340+  1296 C6 A2 12      jz _puts_END
0341+  1299 23            mov ah, al
0342+  129A 19 00         mov al, 0
0343+  129C 05 03         syscall sys_io
0344+  129E 79            inc d
0345+  129F 0A 93 12      jmp _puts_L1
0346+  12A2             _puts_END:
0347+  12A2 E7            pop d
0348+  12A3 E4            pop a
0349+  12A4 09            ret
0350+  12A5             
0351+  12A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  12A5             ; PRINT N SIZE STRING
0353+  12A5             ; pointer in D
0354+  12A5             ; size in C
0355+  12A5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  12A5             _putsn:
0357+  12A5 DB            push al
0358+  12A6 DA            push d
0359+  12A7 D9            push c
0360+  12A8             _putsn_L0:
0361+  12A8 1E            mov al, [d]
0362+  12A9 23            mov ah, al
0363+  12AA 19 00         mov al, 0
0364+  12AC 05 03         syscall sys_io
0365+  12AE 79            inc d
0366+  12AF 7E            dec c  
0367+  12B0 C2 00 00      cmp c, 0
0368+  12B3 C7 A8 12      jne _putsn_L0
0369+  12B6             _putsn_end:
0370+  12B6 E6            pop c
0371+  12B7 E7            pop d
0372+  12B8 E8            pop al
0373+  12B9 09            ret
0374+  12BA             
0375+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  12BA             ; print 16bit decimal number
0377+  12BA             ; input number in A
0378+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  12BA             print_u16d:
0380+  12BA D7            push a
0381+  12BB D8            push b
0382+  12BC FD D8         push g
0383+  12BE 26 10 27      mov b, 10000
0384+  12C1 AE            div a, b      ; get 10000's coeff.
0385+  12C2 07 E6 12      call print_number
0386+  12C5 11            mov a, b
0387+  12C6 26 E8 03      mov b, 1000
0388+  12C9 AE            div a, b      ; get 1000's coeff.
0389+  12CA 07 E6 12      call print_number
0390+  12CD 11            mov a, b
0391+  12CE 26 64 00      mov b, 100
0392+  12D1 AE            div a, b
0393+  12D2 07 E6 12      call print_number
0394+  12D5 11            mov a, b
0395+  12D6 26 0A 00      mov b, 10
0396+  12D9 AE            div a, b
0397+  12DA 07 E6 12      call print_number
0398+  12DD 1B            mov al, bl      ; 1's coeff in bl
0399+  12DE 07 E6 12      call print_number
0400+  12E1 FD F1         pop g
0401+  12E3 E5            pop b
0402+  12E4 E4            pop a
0403+  12E5 09            ret
0404+  12E6             
0405+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  12E6             ; print AL
0407+  12E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  12E6             print_number:
0409+  12E6 6A 30         add al, $30
0410+  12E8 23            mov ah, al
0411+  12E9 07 65 11      call _putchar
0412+  12EC 09            ret
0413+  12ED             
0414+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  12ED             ; PRINT 16BIT HEX INTEGER
0416+  12ED             ; integer value in reg B
0417+  12ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  12ED             print_u16x:
0419+  12ED D7            push a
0420+  12EE D8            push b
0421+  12EF DD            push bl
0422+  12F0 30            mov bl, bh
0423+  12F1 07 33 11      call _itoa        ; convert bh to char in A
0424+  12F4 2F            mov bl, al        ; save al
0425+  12F5 19 00         mov al, 0
0426+  12F7 05 03         syscall sys_io        ; display AH
0427+  12F9 24            mov ah, bl        ; retrieve al
0428+  12FA 19 00         mov al, 0
0429+  12FC 05 03         syscall sys_io        ; display AL
0430+  12FE             
0431+  12FE EA            pop bl
0432+  12FF 07 33 11      call _itoa        ; convert bh to char in A
0433+  1302 2F            mov bl, al        ; save al
0434+  1303 19 00         mov al, 0
0435+  1305 05 03         syscall sys_io        ; display AH
0436+  1307 24            mov ah, bl        ; retrieve al
0437+  1308 19 00         mov al, 0
0438+  130A 05 03         syscall sys_io        ; display AL
0439+  130C             
0440+  130C E5            pop b
0441+  130D E4            pop a
0442+  130E 09            ret
0443+  130F             
0444+  130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  130F             ; INPUT 16BIT HEX INTEGER
0446+  130F             ; read 16bit integer into A
0447+  130F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  130F             scan_u16x:
0449+  130F F8 10 00      enter 16
0450+  1312 D8            push b
0451+  1313 DA            push d
0452+  1314             
0453+  1314 FA F1 FF      lea d, [bp + -15]
0454+  1317 07 6C 11      call _gets        ; get number
0455+  131A             
0456+  131A 32            mov bl, [d]
0457+  131B 37            mov bh, bl
0458+  131C 33 01 00      mov bl, [d + 1]
0459+  131F 07 22 11      call _atoi        ; convert to int in AL
0460+  1322 23            mov ah, al        ; move to AH
0461+  1323             
0462+  1323 33 02 00      mov bl, [d + 2]
0463+  1326 37            mov bh, bl
0464+  1327 33 03 00      mov bl, [d + 3]
0465+  132A 07 22 11      call _atoi        ; convert to int in AL
0466+  132D             
0467+  132D E7            pop d
0468+  132E E5            pop b
0469+  132F F9            leave
0470+  1330 09            ret
0471+  1331             
0472+  1331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  1331             ; PRINT 8bit HEX INTEGER
0474+  1331             ; integer value in reg bl
0475+  1331             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  1331             print_u8x:
0477+  1331 D7            push a
0478+  1332 DD            push bl
0479+  1333             
0480+  1333 07 33 11      call _itoa        ; convert bl to char in A
0481+  1336 2F            mov bl, al        ; save al
0482+  1337 19 00         mov al, 0
0483+  1339 05 03         syscall sys_io        ; display AH
0484+  133B 24            mov ah, bl        ; retrieve al
0485+  133C 19 00         mov al, 0
0486+  133E 05 03         syscall sys_io        ; display AL
0487+  1340             
0488+  1340 EA            pop bl
0489+  1341 E4            pop a
0490+  1342 09            ret
0491+  1343             
0492+  1343             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  1343             ; print 8bit decimal unsigned number
0494+  1343             ; input number in AL
0495+  1343             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  1343             print_u8d:
0497+  1343 D7            push a
0498+  1344 D8            push b
0499+  1345 FD D8         push g
0500+  1347 22 00         mov ah, 0
0501+  1349 26 64 00      mov b, 100
0502+  134C AE            div a, b
0503+  134D D8            push b      ; save remainder
0504+  134E B9 00         cmp al, 0
0505+  1350 C6 5A 13      je skip100
0506+  1353 6A 30         add al, $30
0507+  1355 23            mov ah, al
0508+  1356 19 00         mov al, 0
0509+  1358 05 03         syscall sys_io  ; print coeff
0510+  135A             skip100:
0511+  135A E4            pop a
0512+  135B 22 00         mov ah, 0
0513+  135D 26 0A 00      mov b, 10
0514+  1360 AE            div a, b
0515+  1361 D8            push b      ; save remainder
0516+  1362 B9 00         cmp al, 0
0517+  1364 C6 6E 13      je skip10
0518+  1367 6A 30         add al, $30
0519+  1369 23            mov ah, al
0520+  136A 19 00         mov al, 0
0521+  136C 05 03         syscall sys_io  ; print coeff
0522+  136E             skip10:
0523+  136E E4            pop a
0524+  136F 1B            mov al, bl
0525+  1370 6A 30         add al, $30
0526+  1372 23            mov ah, al
0527+  1373 19 00         mov al, 0
0528+  1375 05 03         syscall sys_io  ; print coeff
0529+  1377 FD F1         pop g
0530+  1379 E5            pop b
0531+  137A E4            pop a
0532+  137B 09            ret
0533+  137C             
0534+  137C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  137C             ; INPUT 8BIT HEX INTEGER
0536+  137C             ; read 8bit integer into AL
0537+  137C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  137C             scan_u8x:
0539+  137C F8 04 00      enter 4
0540+  137F D8            push b
0541+  1380 DA            push d
0542+  1381             
0543+  1381 FA FD FF      lea d, [bp + -3]
0544+  1384 07 6C 11      call _gets        ; get number
0545+  1387             
0546+  1387 32            mov bl, [d]
0547+  1388 37            mov bh, bl
0548+  1389 33 01 00      mov bl, [d + 1]
0549+  138C 07 22 11      call _atoi        ; convert to int in AL
0550+  138F             
0551+  138F E7            pop d
0552+  1390 E5            pop b
0553+  1391 F9            leave
0554+  1392 09            ret
0555+  1393             
0556+  1393             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  1393             ; input decimal number
0558+  1393             ; result in A
0559+  1393             ; 655'\0'
0560+  1393             ; low--------high
0561+  1393             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  1393             scan_u16d:
0563+  1393 F8 08 00      enter 8
0564+  1396 E2            push si
0565+  1397 D8            push b
0566+  1398 D9            push c
0567+  1399 DA            push d
0568+  139A FA F9 FF      lea d, [bp +- 7]
0569+  139D 07 6C 11      call _gets
0570+  13A0 07 C4 10      call _strlen      ; get string length in C
0571+  13A3 7E            dec c
0572+  13A4 FD 4E         mov si, d
0573+  13A6 12            mov a, c
0574+  13A7 FD 99         shl a
0575+  13A9 3B E5 13      mov d, table_power
0576+  13AC 59            add d, a
0577+  13AD 38 00 00      mov c, 0
0578+  13B0             mul_loop:
0579+  13B0 F6            lodsb      ; load ASCII to al
0580+  13B1 B9 00         cmp al, 0
0581+  13B3 C6 C6 13      je mul_exit
0582+  13B6 6F 30         sub al, $30    ; make into integer
0583+  13B8 22 00         mov ah, 0
0584+  13BA 2A            mov b, [d]
0585+  13BB AC            mul a, b      ; result in B since it fits in 16bits
0586+  13BC 11            mov a, b
0587+  13BD 28            mov b, c
0588+  13BE 54            add a, b
0589+  13BF 39            mov c, a
0590+  13C0 63 02 00      sub d, 2
0591+  13C3 0A B0 13      jmp mul_loop
0592+  13C6             mul_exit:
0593+  13C6 12            mov a, c
0594+  13C7 E7            pop d
0595+  13C8 E6            pop c
0596+  13C9 E5            pop b
0597+  13CA EF            pop si
0598+  13CB F9            leave
0599+  13CC 09            ret
0600+  13CD             
0601+  13CD             
0602+  13CD 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  13D1 34 35 36 37 
0602+  13D5 38 39 41 42 
0602+  13D9 43 44 45 46 
0603+  13DD 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  13E1 1B 5B 48 00 
0604+  13E5             
0605+  13E5             table_power:
0606+  13E5 01 00         .dw 1
0607+  13E7 0A 00         .dw 10
0608+  13E9 64 00         .dw 100
0609+  13EB E8 03         .dw 1000
0610+  13ED 10 27         .dw 100002652   13EF             .include "lib/ctype.asm"
0001+  13EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  13EF             ; ctype.s
0003+  13EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  13EF             
0005+  13EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  13EF             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  13EF             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  13EF             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  13EF             ;; characters are supported.
0010+  13EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  13EF             ;; _isalnum 
0012+  13EF             ;; _isalpha 
0013+  13EF             ;; islower 
0014+  13EF             ;; isupper 
0015+  13EF             ;; _isdigit 
0016+  13EF             ;; isxdigit
0017+  13EF             ;; iscntrl 
0018+  13EF             ;; isgraph 
0019+  13EF             ;; _isspace 
0020+  13EF             ;; isblank 
0021+  13EF             ;; isprint 
0022+  13EF             ;; ispunct 
0023+  13EF             ;; tolower 
0024+  13EF             ;; toupper
0025+  13EF             
0026+  13EF             
0027+  13EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  13EF             ;; IS ALPHANUMERIC
0029+  13EF             ;; sets ZF according with result
0030+  13EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  13EF             _isalnum:
0032+  13EF 07 0C 14    	call _isalpha
0033+  13F2 C6 F8 13    	je _isalnum_exit
0034+  13F5 07 F9 13    	call _isdigit
0035+  13F8             _isalnum_exit:
0036+  13F8 09          	ret	
0037+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  13F9             ;; IS DIGIT
0039+  13F9             ;; sets ZF according with result
0040+  13F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  13F9             _isdigit:
0042+  13F9 DB          	push al
0043+  13FA B9 30       	cmp al, '0'
0044+  13FC C8 08 14    	jlu _isdigit_false
0045+  13FF B9 39       	cmp al, '9'
0046+  1401 D1 08 14    	jgu _isdigit_false
0047+  1404 87 00       	and al, 0	; set ZF
0048+  1406 E8          	pop al
0049+  1407 09          	ret
0050+  1408             _isdigit_false:
0051+  1408 8B 01       	or al, 1	; clear ZF
0052+  140A E8          	pop al
0053+  140B 09          	ret	
0054+  140C             	
0055+  140C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  140C             ;; IS ALPHA
0057+  140C             ;; sets ZF according with result
0058+  140C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  140C             _isalpha:
0060+  140C DB          	push al
0061+  140D B9 5F       	cmp al, '_'
0062+  140F C6 2F 14    	je _isalpha_true
0063+  1412 B9 2E       	cmp al, '.'
0064+  1414 C6 2F 14    	je _isalpha_true
0065+  1417 B9 41       	cmp al, 'A'
0066+  1419 C8 2B 14    	jlu _isalpha_false
0067+  141C B9 7A       	cmp al, 'z'
0068+  141E D1 2B 14    	jgu _isalpha_false
0069+  1421 B9 5A       	cmp al, 'Z'
0070+  1423 D0 2F 14    	jleu _isalpha_true
0071+  1426 B9 61       	cmp al, 'a'
0072+  1428 C9 2F 14    	jgeu _isalpha_true
0073+  142B             _isalpha_false:
0074+  142B 8B 01       	or al, 1	; clear ZF
0075+  142D E8          	pop al
0076+  142E 09          	ret
0077+  142F             _isalpha_true:
0078+  142F 87 00       	and al, 0	; set ZF
0079+  1431 E8          	pop al
0080+  1432 09          	ret
0081+  1433             
0082+  1433             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  1433             ;; IS PATH-ALPHA
0084+  1433             ;; sets ZF according with result
0085+  1433             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  1433             ispath:
0087+  1433 DB          	push al
0088+  1434 07 F9 13    	call _isdigit
0089+  1437 C6 61 14    	je ispath_true
0090+  143A B9 5F       	cmp al, '_'
0091+  143C C6 61 14    	je ispath_true
0092+  143F B9 2F       	cmp al, '/'
0093+  1441 C6 61 14    	je ispath_true
0094+  1444 B9 2E       	cmp al, '.'
0095+  1446 C6 61 14    	je ispath_true
0096+  1449 B9 41       	cmp al, 'A'
0097+  144B C8 5D 14    	jlu ispath_false
0098+  144E B9 7A       	cmp al, 'z'
0099+  1450 D1 5D 14    	jgu ispath_false
0100+  1453 B9 5A       	cmp al, 'Z'
0101+  1455 D0 61 14    	jleu ispath_true
0102+  1458 B9 61       	cmp al, 'a'
0103+  145A C9 61 14    	jgeu ispath_true
0104+  145D             ispath_false:
0105+  145D 8B 01       	or al, 1	; clear ZF
0106+  145F E8          	pop al
0107+  1460 09          	ret
0108+  1461             ispath_true:
0109+  1461 87 00       	and al, 0	; set ZF
0110+  1463 E8          	pop al
0111+  1464 09          	ret
0112+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  1465             ;; IS SPACE
0114+  1465             ;; sets ZF according with result
0115+  1465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  1465             _isspace:
0117+  1465 B9 20       	cmp al, $20		; ' '
0118+  1467 C6 7B 14    	je _isspace_exit
0119+  146A B9 09       	cmp al, $09		; '\t'
0120+  146C C6 7B 14    	je _isspace_exit
0121+  146F B9 0A       	cmp al, $0A		; '\n'
0122+  1471 C6 7B 14    	je _isspace_exit
0123+  1474 B9 0D       	cmp al, $0D		; '\r'
0124+  1476 C6 7B 14    	je _isspace_exit
0125+  1479 B9 0B       	cmp al, $0B		; '\v'
0126+  147B             _isspace_exit:
0127+  147B 09          	ret	
0128+  147C             
0129+  147C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  147C             ; TO LOWER
0131+  147C             ; input in AL
0132+  147C             ; output in AL
0133+  147C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  147C             _to_lower:
0135+  147C B9 5A       	cmp al, 'Z'
0136+  147E D1 83 14    	jgu _to_lower_ret
0137+  1481 6A 20       	add al, $20				; convert to lower case
0138+  1483             _to_lower_ret:
0139+  1483 09          	ret
0140+  1484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1484             ; TO UPPER
0142+  1484             ; input in AL
0143+  1484             ; output in AL
0144+  1484             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1484             _to_upper:
0146+  1484 B9 61       	cmp al, 'a'
0147+  1486 C8 8B 14    	jlu _to_upper_ret
0148+  1489 6F 20       	sub al, $20			; convert to upper case
0149+  148B             _to_upper_ret:
0150+  148B 09          	ret
0151+  148C             
2653   148C             .include "lib/token.asm"
0001+  148C             TOKTYP_IDENTIFIER  .equ 0
0002+  148C             TOKTYP_KEYWORD     .equ 1
0003+  148C             TOKTYP_DELIMITER   .equ 2
0004+  148C             TOKTYP_STRING      .equ 3
0005+  148C             TOKTYP_CHAR        .equ 4
0006+  148C             TOKTYP_NUMERIC     .equ 5
0007+  148C             TOKTYP_END         .equ 6
0008+  148C             
0009+  148C             TOK_NULL           .equ 0
0010+  148C             TOK_FSLASH         .equ 1
0011+  148C             TOK_TIMES          .equ 2
0012+  148C             TOK_PLUS           .equ 3
0013+  148C             TOK_MINUS          .equ 4
0014+  148C             TOK_DOT            .equ 5
0015+  148C             TOK_SEMI           .equ 6
0016+  148C             TOK_ANGLE          .equ 7
0017+  148C             TOK_TILDE          .equ 8
0018+  148C             TOK_EQUAL          .equ 9
0019+  148C             TOK_COLON          .equ 10
0020+  148C             TOK_COMMA          .equ 11
0021+  148C             
0022+  148C             TOK_END            .equ 20
0023+  148C             
0024+  148C             
0025+  148C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  148C             ;; read a full command argment from shell input buffer
0027+  148C             ;; argument is written into tokstr
0028+  148C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  148C             get_arg:
0030+  148C D7            push a
0031+  148D E2            push si
0032+  148E E3            push di
0033+  148F 19 00         mov al, 0
0034+  1491 3D BA 16      mov [tokstr], al      ; nullify tokstr string
0035+  1494 14 B6 16      mov a, [prog]
0036+  1497 4D            mov si, a
0037+  1498 FD 4F BA 16   mov di, tokstr
0038+  149C             get_arg_skip_spaces:
0039+  149C F6            lodsb
0040+  149D 07 65 14      call _isspace
0041+  14A0 C6 9C 14      je get_arg_skip_spaces
0042+  14A3             get_arg_L0:
0043+  14A3 B9 3B         cmp al, $3B        ; check if is ';'
0044+  14A5 C6 B2 14      je get_arg_end
0045+  14A8 B9 00         cmp al, 0
0046+  14AA C6 B2 14      je get_arg_end      ; check if end of input
0047+  14AD F7            stosb
0048+  14AE F6            lodsb
0049+  14AF 0A A3 14      jmp get_arg_L0
0050+  14B2             get_arg_end:
0051+  14B2 19 00         mov al, 0
0052+  14B4 F7            stosb
0053+  14B5 D5 01 00      sub si, 1
0054+  14B8 4E            mov a, si
0055+  14B9 42 B6 16      mov [prog], a    ; update pointer
0056+  14BC F0            pop di
0057+  14BD EF            pop si
0058+  14BE E4            pop a
0059+  14BF 09            ret
0060+  14C0             
0061+  14C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  14C0             ;; read a path formation from shell input buffer
0063+  14C0             ;; path is written into tokstr
0064+  14C0             ;; /usr/bin
0065+  14C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  14C0             get_path:
0067+  14C0 D7            push a
0068+  14C1 E2            push si
0069+  14C2 E3            push di
0070+  14C3 19 00         mov al, 0
0071+  14C5 3D BA 16      mov [tokstr], al      ; nullify tokstr string
0072+  14C8 14 B6 16      mov a, [prog]
0073+  14CB 4D            mov si, a
0074+  14CC FD 4F BA 16   mov di, tokstr
0075+  14D0             get_path_skip_spaces:
0076+  14D0 F6            lodsb
0077+  14D1 07 65 14      call _isspace
0078+  14D4 C6 D0 14      je get_path_skip_spaces
0079+  14D7             get_path_is_pathchar:
0080+  14D7 F7            stosb
0081+  14D8 F6            lodsb
0082+  14D9 07 EF 13      call _isalnum      ;check if is alphanumeric
0083+  14DC C6 D7 14      je get_path_is_pathchar
0084+  14DF B9 2F         cmp al, '/'        ; check if is '/'
0085+  14E1 C6 D7 14      je get_path_is_pathchar
0086+  14E4 19 00         mov al, 0
0087+  14E6 F7            stosb
0088+  14E7 D5 01 00      sub si, 1
0089+  14EA 4E            mov a, si
0090+  14EB 42 B6 16      mov [prog], a    ; update pointer
0091+  14EE             get_path_end:
0092+  14EE F0            pop di
0093+  14EF EF            pop si
0094+  14F0 E4            pop a
0095+  14F1 09            ret
0096+  14F2             
0097+  14F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  14F2             ;; read a line
0099+  14F2             ;; line is written into tokstr
0100+  14F2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  14F2             get_line:
0102+  14F2 D7            push a
0103+  14F3 E2            push si
0104+  14F4 E3            push di
0105+  14F5 19 00         mov al, 0
0106+  14F7 3D BA 16      mov [tokstr], al      ; nullify tokstr string
0107+  14FA 14 B6 16      mov a, [prog]
0108+  14FD 4D            mov si, a
0109+  14FE FD 4F BA 16   mov di, tokstr
0110+  1502             get_line_L0:
0111+  1502 F6            lodsb
0112+  1503 B9 0A         cmp al, $0A    ; check for new line
0113+  1505 C6 0C 15      je get_line_exit
0114+  1508 F7            stosb
0115+  1509 0A 02 15      jmp get_line_L0
0116+  150C             get_line_exit:
0117+  150C 19 00         mov al, 0
0118+  150E F7            stosb
0119+  150F 4E            mov a, si
0120+  1510 42 B6 16      mov [prog], a    ; update pointer
0121+  1513 F0            pop di
0122+  1514 EF            pop si
0123+  1515 E4            pop a
0124+  1516 09            ret
0125+  1517             
0126+  1517             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1517             ;; token parser
0128+  1517             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1517             get_token:
0130+  1517 D7            push a
0131+  1518 DA            push d
0132+  1519 E2            push si
0133+  151A E3            push di
0134+  151B 19 00         mov al, 0
0135+  151D 3D BA 16      mov [tokstr], al      ; nullify tokstr string
0136+  1520 19 00         mov al, TOK_NULL
0137+  1522 3D B9 16      mov [tok], al        ; nullify token
0138+  1525 14 B6 16      mov a, [prog]
0139+  1528 4D            mov si, a
0140+  1529 FD 4F BA 16   mov di, tokstr
0141+  152D             get_tok_skip_spaces:
0142+  152D F6            lodsb
0143+  152E 07 65 14      call _isspace
0144+  1531 C6 2D 15      je get_tok_skip_spaces
0145+  1534 B9 00         cmp al, 0      ; check for end of input (NULL)
0146+  1536 C6 1B 16      je get_token_end
0147+  1539 B9 23         cmp al, '#'      ; comments!
0148+  153B C6 49 16      je get_tok_comment
0149+  153E 07 EF 13      call _isalnum
0150+  1541 C6 28 16      jz is_alphanumeric
0151+  1544             ; other token types
0152+  1544             get_token_slash:
0153+  1544 B9 2F         cmp al, '/'        ; check if '/'
0154+  1546 C7 5E 15      jne get_token_minus
0155+  1549 F7            stosb          ; store '/' into token string
0156+  154A 19 00         mov al, 0
0157+  154C F7            stosb          ; terminate token string
0158+  154D 19 01         mov al, TOK_FSLASH
0159+  154F 3D B9 16      mov [tok], al      
0160+  1552 19 02         mov al, TOKTYP_DELIMITER
0161+  1554 3D B8 16      mov [toktyp], al
0162+  1557 4E            mov a, si
0163+  1558 42 B6 16      mov [prog], a    ; update pointer
0164+  155B 0A 44 16      jmp get_token_return
0165+  155E             get_token_minus:
0166+  155E B9 2D         cmp al, '-'        ; check if '-'
0167+  1560 C7 78 15      jne get_token_comma
0168+  1563 F7            stosb          ; store '-' into token string
0169+  1564 19 00         mov al, 0
0170+  1566 F7            stosb          ; terminate token string
0171+  1567 19 04         mov al, TOK_MINUS
0172+  1569 3D B9 16      mov [tok], al      
0173+  156C 19 02         mov al, TOKTYP_DELIMITER
0174+  156E 3D B8 16      mov [toktyp], al
0175+  1571 4E            mov a, si
0176+  1572 42 B6 16      mov [prog], a    ; update pointer
0177+  1575 0A 44 16      jmp get_token_return
0178+  1578             get_token_comma:
0179+  1578 B9 2C         cmp al, ','        ; check if ','
0180+  157A C7 92 15      jne get_token_semi
0181+  157D F7            stosb          ; store ',' into token string
0182+  157E 19 00         mov al, 0
0183+  1580 F7            stosb          ; terminate token string
0184+  1581 19 0B         mov al, TOK_COMMA
0185+  1583 3D B9 16      mov [tok], al      
0186+  1586 19 02         mov al, TOKTYP_DELIMITER
0187+  1588 3D B8 16      mov [toktyp], al
0188+  158B 4E            mov a, si
0189+  158C 42 B6 16      mov [prog], a    ; update pointer
0190+  158F 0A 44 16      jmp get_token_return
0191+  1592             get_token_semi:
0192+  1592 B9 3B         cmp al, $3B        ; check if ';'
0193+  1594 C7 AC 15      jne get_token_colon
0194+  1597 F7            stosb          ; store ';' into token string
0195+  1598 19 00         mov al, 0
0196+  159A F7            stosb          ; terminate token string
0197+  159B 19 06         mov al, TOK_SEMI
0198+  159D 3D B9 16      mov [tok], al      
0199+  15A0 19 02         mov al, TOKTYP_DELIMITER
0200+  15A2 3D B8 16      mov [toktyp], al
0201+  15A5 4E            mov a, si
0202+  15A6 42 B6 16      mov [prog], a    ; update pointer
0203+  15A9 0A 44 16      jmp get_token_return
0204+  15AC             get_token_colon:
0205+  15AC B9 3A         cmp al, $3A        ; check if ':'
0206+  15AE C7 C6 15      jne get_token_angle
0207+  15B1 F7            stosb          ; store ':' into token string
0208+  15B2 19 00         mov al, 0
0209+  15B4 F7            stosb          ; terminate token string
0210+  15B5 19 0A         mov al, TOK_COLON
0211+  15B7 3D B9 16      mov [tok], al      
0212+  15BA 19 02         mov al, TOKTYP_DELIMITER
0213+  15BC 3D B8 16      mov [toktyp], al
0214+  15BF 4E            mov a, si
0215+  15C0 42 B6 16      mov [prog], a    ; update pointer
0216+  15C3 0A 44 16      jmp get_token_return
0217+  15C6             get_token_angle:
0218+  15C6 B9 3E         cmp al, $3E        ; check if '>'
0219+  15C8 C7 E0 15      jne get_token_tilde
0220+  15CB F7            stosb          ; store '>' into token string
0221+  15CC 19 00         mov al, 0
0222+  15CE F7            stosb          ; terminate token string
0223+  15CF 19 07         mov al, TOK_ANGLE
0224+  15D1 3D B9 16      mov [tok], al      
0225+  15D4 19 02         mov al, TOKTYP_DELIMITER
0226+  15D6 3D B8 16      mov [toktyp], al
0227+  15D9 4E            mov a, si
0228+  15DA 42 B6 16      mov [prog], a    ; update pointer
0229+  15DD 0A 44 16      jmp get_token_return
0230+  15E0             get_token_tilde:
0231+  15E0 B9 7E         cmp al, '~'        ; check if '~'
0232+  15E2 C7 FA 15      jne get_token_equal
0233+  15E5 F7            stosb          ; store '~' into token string
0234+  15E6 19 00         mov al, 0
0235+  15E8 F7            stosb          ; terminate token string
0236+  15E9 19 08         mov al, TOK_TILDE
0237+  15EB 3D B9 16      mov [tok], al      
0238+  15EE 19 02         mov al, TOKTYP_DELIMITER
0239+  15F0 3D B8 16      mov [toktyp], al
0240+  15F3 4E            mov a, si
0241+  15F4 42 B6 16      mov [prog], a    ; update pointer
0242+  15F7 0A 44 16      jmp get_token_return
0243+  15FA             get_token_equal:
0244+  15FA B9 3D         cmp al, '='        ; check if '='
0245+  15FC C7 14 16      jne get_token_skip
0246+  15FF F7            stosb          ; store '=' into token string
0247+  1600 19 00         mov al, 0
0248+  1602 F7            stosb          ; terminate token string
0249+  1603 19 09         mov al, TOK_EQUAL
0250+  1605 3D B9 16      mov [tok], al      
0251+  1608 19 02         mov al, TOKTYP_DELIMITER
0252+  160A 3D B8 16      mov [toktyp], al
0253+  160D 4E            mov a, si
0254+  160E 42 B6 16      mov [prog], a    ; update pointer
0255+  1611 0A 44 16      jmp get_token_return
0256+  1614             get_token_skip:
0257+  1614 4E            mov a, si
0258+  1615 42 B6 16      mov [prog], a    ; update pointer
0259+  1618 0A 44 16      jmp get_token_return
0260+  161B             get_token_end:        ; end of file token
0261+  161B 19 14         mov al, TOK_END
0262+  161D 3D B9 16      mov [tok], al
0263+  1620 19 06         mov al, TOKTYP_END
0264+  1622 3D B8 16      mov [toktyp], al
0265+  1625 0A 44 16      jmp get_token_return
0266+  1628             is_alphanumeric:
0267+  1628 F7            stosb
0268+  1629 F6            lodsb
0269+  162A 07 EF 13      call _isalnum      ;check if is alphanumeric
0270+  162D C6 28 16      jz is_alphanumeric
0271+  1630 B9 2E         cmp al, $2E        ; check if is '.'
0272+  1632 C6 28 16      je is_alphanumeric
0273+  1635 19 00         mov al, 0
0274+  1637 F7            stosb
0275+  1638 19 00         mov al, TOKTYP_IDENTIFIER
0276+  163A 3D B8 16      mov [toktyp], al
0277+  163D D5 01 00      sub si, 1
0278+  1640 4E            mov a, si
0279+  1641 42 B6 16      mov [prog], a    ; update pointer
0280+  1644             get_token_return:
0281+  1644 F0            pop di
0282+  1645 EF            pop si
0283+  1646 E7            pop d
0284+  1647 E4            pop a
0285+  1648 09            ret
0286+  1649             get_tok_comment:
0287+  1649 F6            lodsb
0288+  164A B9 0A         cmp al, $0A      ; new line
0289+  164C C7 49 16      jne get_tok_comment
0290+  164F 0A 2D 15      jmp get_tok_skip_spaces
0291+  1652             
0292+  1652             
0293+  1652             get_number:
0294+  1652 D7            push a
0295+  1653 DA            push d
0296+  1654 E2            push si
0297+  1655 E3            push di
0298+  1656 19 00         mov al, 0
0299+  1658 3D BA 16      mov [tokstr], al      ; nullify tokstr string
0300+  165B 19 00         mov al, TOK_NULL
0301+  165D 3D B9 16      mov [tok], al        ; nullify token
0302+  1660 14 B6 16      mov a, [prog]
0303+  1663 4D            mov si, a
0304+  1664 FD 4F BA 16   mov di, tokstr
0305+  1668             get_number_skip_spaces:
0306+  1668 F6            lodsb
0307+  1669 07 65 14      call _isspace
0308+  166C C6 68 16      je get_number_skip_spaces
0309+  166F B9 00         cmp al, 0      ; check for end of input (NULL)
0310+  1671 C7 81 16      jne get_number_L0
0311+  1674 19 14         mov al, TOK_END
0312+  1676 3D B9 16      mov [tok], al
0313+  1679 19 06         mov al, TOKTYP_END
0314+  167B 3D B8 16      mov [toktyp], al
0315+  167E 0A 98 16      jmp get_number_return
0316+  1681             get_number_L0:
0317+  1681 F7            stosb
0318+  1682 F6            lodsb
0319+  1683 07 F9 13      call _isdigit      ;check if is numeric
0320+  1686 C6 81 16      jz get_number_L0
0321+  1689 19 00         mov al, 0
0322+  168B F7            stosb
0323+  168C 19 05         mov al, TOKTYP_NUMERIC
0324+  168E 3D B8 16      mov [toktyp], al
0325+  1691 D5 01 00      sub si, 1
0326+  1694 4E            mov a, si
0327+  1695 42 B6 16      mov [prog], a    ; update pointer
0328+  1698             get_number_return:
0329+  1698 F0            pop di
0330+  1699 EF            pop si
0331+  169A E7            pop d
0332+  169B E4            pop a
0333+  169C 09            ret
0334+  169D             
0335+  169D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  169D             ;; PUT BACK TOKEN
0337+  169D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  169D             _putback:
0339+  169D D7            push a
0340+  169E E2            push si
0341+  169F FD 4D BA 16   mov si, tokstr  
0342+  16A3             _putback_loop:
0343+  16A3 F6            lodsb
0344+  16A4 B9 00         cmp al, 0
0345+  16A6 C6 B3 16      je _putback_end
0346+  16A9 14 B6 16      mov a, [prog]
0347+  16AC 7D            dec a
0348+  16AD 42 B6 16      mov [prog], a      ; update pointer
0349+  16B0 0A A3 16      jmp _putback_loop
0350+  16B3             _putback_end:
0351+  16B3 EF            pop si
0352+  16B4 E4            pop a
0353+  16B5 09            ret
0354+  16B6             
0355+  16B6             
0356+  16B6             
0357+  16B6             
0358+  16B6 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  16B8             
0360+  16B8 00          toktyp:    .db 0          ; token type symbol
0361+  16B9 00          tok:       .db 0          ; current token symbol
0362+  16BA 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  16BE 00 00 00 00 
0362+  16C2 00 00 00 00 
0362+  16C6 00 00 00 00 
0362+  16CA 00 00 00 00 
0362+  16CE 00 00 00 00 
0362+  16D2 00 00 00 00 
0362+  16D6 00 00 00 00 
0362+  16DA 00 00 00 00 
0362+  16DE 00 00 00 00 
0362+  16E2 00 00 00 00 
0362+  16E6 00 00 00 00 
0362+  16EA 00 00 00 00 
0362+  16EE 00 00 00 00 
0362+  16F2 00 00 00 00 
0362+  16F6 00 00 00 00 
0362+  16FA 00 00 00 00 
0362+  16FE 00 00 00 00 
0362+  1702 00 00 00 00 
0362+  1706 00 00 00 00 
0362+  170A 00 00 00 00 
0362+  170E 00 00 00 00 
0362+  1712 00 00 00 00 
0362+  1716 00 00 00 00 
0362+  171A 00 00 00 00 
0362+  171E 00 00 00 00 
0362+  1722 00 00 00 00 
0362+  1726 00 00 00 00 
0362+  172A 00 00 00 00 
0362+  172E 00 00 00 00 
0362+  1732 00 00 00 00 
0362+  1736 00 00 00 00 
0362+  173A 00 00 00 00 
0362+  173E 00 00 00 00 
0362+  1742 00 00 00 00 
0362+  1746 00 00 00 00 
0362+  174A 00 00 00 00 
0362+  174E 00 00 00 00 
0362+  1752 00 00 00 00 
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
0362+  176E 00 00 00 00 
0362+  1772 00 00 00 00 
0362+  1776 00 00 00 00 
0362+  177A 00 00 00 00 
0362+  177E 00 00 00 00 
0362+  1782 00 00 00 00 
0362+  1786 00 00 00 00 
0362+  178A 00 00 00 00 
0362+  178E 00 00 00 00 
0362+  1792 00 00 00 00 
0362+  1796 00 00 00 00 
0362+  179A 00 00 00 00 
0362+  179E 00 00 00 00 
0362+  17A2 00 00 00 00 
0362+  17A6 00 00 00 00 
0362+  17AA 00 00 00 00 
0362+  17AE 00 00 00 00 
0362+  17B2 00 00 00 00 
0362+  17B6 00 00 00 00 
2654   17BA             
2655   17BA             ; kernel parameters
2656   17BA 00          sys_debug_mode:     .db 0   ; debug modes: 0=normal mode, 1=debug mode
2657   17BB 01          sys_echo_on:        .db 1
2658   17BC 07          sys_uart0_lcr:      .db $07 ; 8 data bits, 2 stop bit, no parity
2659   17BD 01          sys_uart0_inten:    .db 1
2660   17BE 00          sys_uart0_fifoen:   .db 0
2661   17BF 0C          sys_uart0_div0:     .db 12  ;
2662   17C0 00          sys_uart0_div1:     .db 0   ; default baud = 9600
2663   17C1             ; Baud  Divisor
2664   17C1             ; 50    2304
2665   17C1             ; 110   1047
2666   17C1             ; 300    384
2667   17C1             ; 600    192
2668   17C1             ; 1200    96
2669   17C1             ; 9600    12
2670   17C1             ; 19200    6
2671   17C1             ; 38400    3
2672   17C1             
2673   17C1 00          nbr_active_procs:   .db 0
2674   17C2 01          active_proc_index:  .db 1
2675   17C3             
2676   17C3 00 00       index:              .dw 0
2677   17C5 00 00       buffer_addr:        .dw 0
2678   17C7             
2679   17C7 08 21       fifo_in:            .dw fifo
2680   17C9 08 21       fifo_out:           .dw fifo
2681   17CB             
2682   17CB             ; file system variables
2683   17CB 00 00       current_dir_id:     .dw 0     ; keep dirID of current directory
2684   17CD 2F 73 62 69 s_init_path:        .db "/sbin/init", 0
2684   17D1 6E 2F 69 6E 
2684   17D5 69 74 00 
2685   17D8             
2686   17D8 3E 20 00    s_dataentry:        .db "> ", 0
2687   17DB 2E 2E 00    s_parent_dir:       .db "..", 0
2688   17DE 2E 00       s_current_dir:      .db ".", 0
2689   17E0 2F 00       s_fslash:           .db "/", 0
2690   17E2 2D 72 77 20 file_attrib:        .db "-rw x"      ; chars at powers of 2
2690   17E6 78 
2691   17E7 2D 64 63    file_type:          .db "-dc"
2692   17EA 50 49 44 20 s_ps_header:        .db "PID COMMAND\n", 0
2692   17EE 43 4F 4D 4D 
2692   17F2 41 4E 44 0A 
2692   17F6 00 
2693   17F7 54 6F 74 61 s_ls_total:         .db "Total: ", 0
2693   17FB 6C 3A 20 00 
2694   17FF             
2695   17FF 49 52 51 73 s_int_en:           .db "IRQs enabled\n", 0
2695   1803 20 65 6E 61 
2695   1807 62 6C 65 64 
2695   180B 0A 00 
2696   180D 6B 65 72 6E s_kernel_started:   .db "kernel started(version 1.0)\n", 0
2696   1811 65 6C 20 73 
2696   1815 74 61 72 74 
2696   1819 65 64 28 76 
2696   181D 65 72 73 69 
2696   1821 6F 6E 20 31 
2696   1825 2E 30 29 0A 
2696   1829 00 
2697   182A 73 74 61 72 s_prompt_init:      .db "starting init\n", 0
2697   182E 74 69 6E 67 
2697   1832 20 69 6E 69 
2697   1836 74 0A 00 
2698   1839 0A 65 78 63 s_priviledge:       .db "\nexception: privilege\n", 0
2698   183D 65 70 74 69 
2698   1841 6F 6E 3A 20 
2698   1845 70 72 69 76 
2698   1849 69 6C 65 67 
2698   184D 65 0A 00 
2699   1850 0A 65 78 63 s_divzero:          .db "\nexception: zero division\n", 0
2699   1854 65 70 74 69 
2699   1858 6F 6E 3A 20 
2699   185C 7A 65 72 6F 
2699   1860 20 64 69 76 
2699   1864 69 73 69 6F 
2699   1868 6E 0A 00 
2700   186B             
2701   186B 59 65 61 72 s_set_year:         .db "Year: ", 0
2701   186F 3A 20 00 
2702   1872 4D 6F 6E 74 s_set_month:        .db "Month: ", 0
2702   1876 68 3A 20 00 
2703   187A 44 61 79 3A s_set_day:          .db "Day: ", 0
2703   187E 20 00 
2704   1880 57 65 65 6B s_set_week:         .db "Weekday: ", 0
2704   1884 64 61 79 3A 
2704   1888 20 00 
2705   188A 48 6F 75 72 s_set_hours:        .db "Hours: ", 0
2705   188E 73 3A 20 00 
2706   1892 4D 69 6E 75 s_set_minutes:      .db "Minutes: ", 0
2706   1896 74 65 73 3A 
2706   189A 20 00 
2707   189C 53 65 63 6F s_set_seconds:      .db "Seconds: ", 0
2707   18A0 6E 64 73 3A 
2707   18A4 20 00 
2708   18A6             s_months:      
2709   18A6 20 20 20 00   .db "   ", 0
2710   18AA 4A 61 6E 00   .db "Jan", 0
2711   18AE 46 65 62 00   .db "Feb", 0
2712   18B2 4D 61 72 00   .db "Mar", 0
2713   18B6 41 70 72 00   .db "Apr", 0
2714   18BA 4D 61 79 00   .db "May", 0
2715   18BE 4A 75 6E 00   .db "Jun", 0
2716   18C2 4A 75 6C 00   .db "Jul", 0
2717   18C6 41 75 67 00   .db "Aug", 0
2718   18CA 53 65 70 00   .db "Sep", 0
2719   18CE 4F 63 74 00   .db "Oct", 0
2720   18D2 4E 6F 76 00   .db "Nov", 0
2721   18D6 44 65 63 00   .db "Dec", 0
2722   18DA             
2723   18DA             s_week:        
2724   18DA 53 75 6E 00   .db "Sun", 0 
2725   18DE 4D 6F 6E 00   .db "Mon", 0 
2726   18E2 54 75 65 00   .db "Tue", 0 
2727   18E6 57 65 64 00   .db "Wed", 0 
2728   18EA 54 68 75 00   .db "Thu", 0 
2729   18EE 46 72 69 00   .db "Fri", 0 
2730   18F2 53 61 74 00   .db "Sat", 0
2731   18F6             
2732   18F6             ; This is the format of a sector for the 128 byte per sector format.
2733   18F6             ; Write the bracketed data 16 times per track.
2734   18F6             ; The recommended single-density format with 128
2735   18F6             ; bytes/sector is shown. In order to format a diskette,
2736   18F6             ; the user issues the Write Track Command, and loads
2737   18F6             ; the Data Register with the following values. For every
2738   18F6             ; byte to be written, there is one Data Request.
2739   18F6             fdc_128_bytes_per_sect:                                                                       
2740   18F6 FF FF FF FF fdc_40_FF:          .fill 40,  $FF    ; or 00                                                                                
2740   18FA FF FF FF FF 
2740   18FE FF FF FF FF 
2740   1902 FF FF FF FF 
2740   1906 FF FF FF FF 
2740   190A FF FF FF FF 
2740   190E FF FF FF FF 
2740   1912 FF FF FF FF 
2740   1916 FF FF FF FF 
2740   191A FF FF FF FF 
2741   191E 00 00 00 00 fdc_6_00_0:         .fill 6,   $00    ;                                                                            <--|        
2741   1922 00 00 
2742   1924 FE          fdc_id_fe:          .fill 1,   $FE    ; ID Address Mark                                                               |        
2743   1925 00          fdc_track:          .fill 1,   $00    ; Track Number                                                                  |                    
2744   1926 00          fdc_side:           .fill 1,   $00    ; Side Number 00 or 01                                                          |                
2745   1927 01          fdc_sector:         .fill 1,   $01    ; Sector Number  1 through 10                                                   |                              
2746   1928 00          fdc_length:         .fill 1,   $00    ; Sector Length                                                                 |                        
2747   1929 F7          fdc_2_crc_0:        .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
2748   192A FF FF FF FF fdc_11_ff:          .fill 11,  $FF    ; or 00                                                                         |                      
2748   192E FF FF FF FF 
2748   1932 FF FF FF 
2749   1935 00 00 00 00 fdc_6_00_1:         .fill 6,   $00    ;                                                                               |                        
2749   1939 00 00 
2750   193B FB          fdc_data_addr:      .fill 1,   $FB    ; Data Address Mark                                                             |                                  
2751   193C E5 E5 E5 E5 fdc_data:           .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
2751   1940 E5 E5 E5 E5 
2751   1944 E5 E5 E5 E5 
2751   1948 E5 E5 E5 E5 
2751   194C E5 E5 E5 E5 
2751   1950 E5 E5 E5 E5 
2751   1954 E5 E5 E5 E5 
2751   1958 E5 E5 E5 E5 
2751   195C E5 E5 E5 E5 
2751   1960 E5 E5 E5 E5 
2751   1964 E5 E5 E5 E5 
2751   1968 E5 E5 E5 E5 
2751   196C E5 E5 E5 E5 
2751   1970 E5 E5 E5 E5 
2751   1974 E5 E5 E5 E5 
2751   1978 E5 E5 E5 E5 
2751   197C E5 E5 E5 E5 
2751   1980 E5 E5 E5 E5 
2751   1984 E5 E5 E5 E5 
2751   1988 E5 E5 E5 E5 
2751   198C E5 E5 E5 E5 
2751   1990 E5 E5 E5 E5 
2751   1994 E5 E5 E5 E5 
2751   1998 E5 E5 E5 E5 
2751   199C E5 E5 E5 E5 
2751   19A0 E5 E5 E5 E5 
2751   19A4 E5 E5 E5 E5 
2751   19A8 E5 E5 E5 E5 
2751   19AC E5 E5 E5 E5 
2751   19B0 E5 E5 E5 E5 
2751   19B4 E5 E5 E5 E5 
2751   19B8 E5 E5 E5 E5 
2752   19BC F7          fdc_2_crc_1:        .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
2753   19BD FF FF FF FF fdc_10_ff:          .fill 10,  $FF    ; or 00                                                                      <--|                                                  
2753   19C1 FF FF FF FF 
2753   19C5 FF FF 
2754   19C7 FF FF FF FF fdc_369_ff:         .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
2754   19CB FF FF FF FF 
2754   19CF FF FF FF FF 
2754   19D3 FF FF FF FF 
2754   19D7 FF FF FF FF 
2754   19DB FF FF FF FF 
2754   19DF FF FF FF FF 
2754   19E3 FF FF FF FF 
2754   19E7 FF FF FF FF 
2754   19EB FF FF FF FF 
2754   19EF FF FF FF FF 
2754   19F3 FF FF FF FF 
2754   19F7 FF FF FF FF 
2754   19FB FF FF FF FF 
2754   19FF FF FF FF FF 
2754   1A03 FF FF FF FF 
2754   1A07 FF FF FF FF 
2754   1A0B FF FF FF FF 
2754   1A0F FF FF FF FF 
2754   1A13 FF FF FF FF 
2754   1A17 FF FF FF FF 
2754   1A1B FF FF FF FF 
2754   1A1F FF FF FF FF 
2754   1A23 FF FF FF FF 
2754   1A27 FF FF FF FF 
2754   1A2B FF FF FF FF 
2754   1A2F FF FF FF FF 
2754   1A33 FF FF FF FF 
2754   1A37 FF FF FF FF 
2754   1A3B FF FF FF FF 
2754   1A3F FF FF FF FF 
2754   1A43 FF FF FF FF 
2754   1A47 FF FF FF FF 
2754   1A4B FF FF FF FF 
2754   1A4F FF FF FF FF 
2754   1A53 FF FF FF FF 
2754   1A57 FF FF FF FF 
2754   1A5B FF FF FF FF 
2754   1A5F FF FF FF FF 
2754   1A63 FF FF FF FF 
2754   1A67 FF FF FF FF 
2754   1A6B FF FF FF FF 
2754   1A6F FF FF FF FF 
2754   1A73 FF FF FF FF 
2754   1A77 FF FF FF FF 
2754   1A7B FF FF FF FF 
2754   1A7F FF FF FF FF 
2754   1A83 FF FF FF FF 
2754   1A87 FF FF FF FF 
2754   1A8B FF FF FF FF 
2754   1A8F FF FF FF FF 
2754   1A93 FF FF FF FF 
2754   1A97 FF FF FF FF 
2754   1A9B FF FF FF FF 
2754   1A9F FF FF FF FF 
2754   1AA3 FF FF FF FF 
2754   1AA7 FF FF FF FF 
2754   1AAB FF FF FF FF 
2754   1AAF FF FF FF FF 
2754   1AB3 FF FF FF FF 
2754   1AB7 FF FF FF FF 
2754   1ABB FF FF FF FF 
2754   1ABF FF FF FF FF 
2754   1AC3 FF FF FF FF 
2754   1AC7 FF FF FF FF 
2754   1ACB FF FF FF FF 
2754   1ACF FF FF FF FF 
2754   1AD3 FF FF FF FF 
2754   1AD7 FF FF FF FF 
2754   1ADB FF FF FF FF 
2754   1ADF FF FF FF FF 
2754   1AE3 FF FF FF FF 
2754   1AE7 FF FF FF FF 
2754   1AEB FF FF FF FF 
2754   1AEF FF FF FF FF 
2754   1AF3 FF FF FF FF 
2754   1AF7 FF FF FF FF 
2754   1AFB FF FF FF FF 
2754   1AFF FF FF FF FF 
2754   1B03 FF FF FF FF 
2754   1B07 FF FF FF FF 
2754   1B0B FF FF FF FF 
2754   1B0F FF FF FF FF 
2754   1B13 FF FF FF FF 
2754   1B17 FF FF FF FF 
2754   1B1B FF FF FF FF 
2754   1B1F FF FF FF FF 
2754   1B23 FF FF FF FF 
2754   1B27 FF FF FF FF 
2754   1B2B FF FF FF FF 
2754   1B2F FF FF FF FF 
2754   1B33 FF FF FF FF 
2754   1B37 FF 
2755   1B38             
2756   1B38 00 00 00 00 proc_state_table:   .fill 16 * 20, 0  ; for 15 processes max
2756   1B3C 00 00 00 00 
2756   1B40 00 00 00 00 
2756   1B44 00 00 00 00 
2756   1B48 00 00 00 00 
2756   1B4C 00 00 00 00 
2756   1B50 00 00 00 00 
2756   1B54 00 00 00 00 
2756   1B58 00 00 00 00 
2756   1B5C 00 00 00 00 
2756   1B60 00 00 00 00 
2756   1B64 00 00 00 00 
2756   1B68 00 00 00 00 
2756   1B6C 00 00 00 00 
2756   1B70 00 00 00 00 
2756   1B74 00 00 00 00 
2756   1B78 00 00 00 00 
2756   1B7C 00 00 00 00 
2756   1B80 00 00 00 00 
2756   1B84 00 00 00 00 
2756   1B88 00 00 00 00 
2756   1B8C 00 00 00 00 
2756   1B90 00 00 00 00 
2756   1B94 00 00 00 00 
2756   1B98 00 00 00 00 
2756   1B9C 00 00 00 00 
2756   1BA0 00 00 00 00 
2756   1BA4 00 00 00 00 
2756   1BA8 00 00 00 00 
2756   1BAC 00 00 00 00 
2756   1BB0 00 00 00 00 
2756   1BB4 00 00 00 00 
2756   1BB8 00 00 00 00 
2756   1BBC 00 00 00 00 
2756   1BC0 00 00 00 00 
2756   1BC4 00 00 00 00 
2756   1BC8 00 00 00 00 
2756   1BCC 00 00 00 00 
2756   1BD0 00 00 00 00 
2756   1BD4 00 00 00 00 
2756   1BD8 00 00 00 00 
2756   1BDC 00 00 00 00 
2756   1BE0 00 00 00 00 
2756   1BE4 00 00 00 00 
2756   1BE8 00 00 00 00 
2756   1BEC 00 00 00 00 
2756   1BF0 00 00 00 00 
2756   1BF4 00 00 00 00 
2756   1BF8 00 00 00 00 
2756   1BFC 00 00 00 00 
2756   1C00 00 00 00 00 
2756   1C04 00 00 00 00 
2756   1C08 00 00 00 00 
2756   1C0C 00 00 00 00 
2756   1C10 00 00 00 00 
2756   1C14 00 00 00 00 
2756   1C18 00 00 00 00 
2756   1C1C 00 00 00 00 
2756   1C20 00 00 00 00 
2756   1C24 00 00 00 00 
2756   1C28 00 00 00 00 
2756   1C2C 00 00 00 00 
2756   1C30 00 00 00 00 
2756   1C34 00 00 00 00 
2756   1C38 00 00 00 00 
2756   1C3C 00 00 00 00 
2756   1C40 00 00 00 00 
2756   1C44 00 00 00 00 
2756   1C48 00 00 00 00 
2756   1C4C 00 00 00 00 
2756   1C50 00 00 00 00 
2756   1C54 00 00 00 00 
2756   1C58 00 00 00 00 
2756   1C5C 00 00 00 00 
2756   1C60 00 00 00 00 
2756   1C64 00 00 00 00 
2756   1C68 00 00 00 00 
2756   1C6C 00 00 00 00 
2756   1C70 00 00 00 00 
2756   1C74 00 00 00 00 
2757   1C78 00 00 00 00 proc_availab_table: .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
2757   1C7C 00 00 00 00 
2757   1C80 00 00 00 00 
2757   1C84 00 00 00 00 
2758   1C88 00 00 00 00 proc_names:         .fill 16 * 32, 0  ; process names
2758   1C8C 00 00 00 00 
2758   1C90 00 00 00 00 
2758   1C94 00 00 00 00 
2758   1C98 00 00 00 00 
2758   1C9C 00 00 00 00 
2758   1CA0 00 00 00 00 
2758   1CA4 00 00 00 00 
2758   1CA8 00 00 00 00 
2758   1CAC 00 00 00 00 
2758   1CB0 00 00 00 00 
2758   1CB4 00 00 00 00 
2758   1CB8 00 00 00 00 
2758   1CBC 00 00 00 00 
2758   1CC0 00 00 00 00 
2758   1CC4 00 00 00 00 
2758   1CC8 00 00 00 00 
2758   1CCC 00 00 00 00 
2758   1CD0 00 00 00 00 
2758   1CD4 00 00 00 00 
2758   1CD8 00 00 00 00 
2758   1CDC 00 00 00 00 
2758   1CE0 00 00 00 00 
2758   1CE4 00 00 00 00 
2758   1CE8 00 00 00 00 
2758   1CEC 00 00 00 00 
2758   1CF0 00 00 00 00 
2758   1CF4 00 00 00 00 
2758   1CF8 00 00 00 00 
2758   1CFC 00 00 00 00 
2758   1D00 00 00 00 00 
2758   1D04 00 00 00 00 
2758   1D08 00 00 00 00 
2758   1D0C 00 00 00 00 
2758   1D10 00 00 00 00 
2758   1D14 00 00 00 00 
2758   1D18 00 00 00 00 
2758   1D1C 00 00 00 00 
2758   1D20 00 00 00 00 
2758   1D24 00 00 00 00 
2758   1D28 00 00 00 00 
2758   1D2C 00 00 00 00 
2758   1D30 00 00 00 00 
2758   1D34 00 00 00 00 
2758   1D38 00 00 00 00 
2758   1D3C 00 00 00 00 
2758   1D40 00 00 00 00 
2758   1D44 00 00 00 00 
2758   1D48 00 00 00 00 
2758   1D4C 00 00 00 00 
2758   1D50 00 00 00 00 
2758   1D54 00 00 00 00 
2758   1D58 00 00 00 00 
2758   1D5C 00 00 00 00 
2758   1D60 00 00 00 00 
2758   1D64 00 00 00 00 
2758   1D68 00 00 00 00 
2758   1D6C 00 00 00 00 
2758   1D70 00 00 00 00 
2758   1D74 00 00 00 00 
2758   1D78 00 00 00 00 
2758   1D7C 00 00 00 00 
2758   1D80 00 00 00 00 
2758   1D84 00 00 00 00 
2758   1D88 00 00 00 00 
2758   1D8C 00 00 00 00 
2758   1D90 00 00 00 00 
2758   1D94 00 00 00 00 
2758   1D98 00 00 00 00 
2758   1D9C 00 00 00 00 
2758   1DA0 00 00 00 00 
2758   1DA4 00 00 00 00 
2758   1DA8 00 00 00 00 
2758   1DAC 00 00 00 00 
2758   1DB0 00 00 00 00 
2758   1DB4 00 00 00 00 
2758   1DB8 00 00 00 00 
2758   1DBC 00 00 00 00 
2758   1DC0 00 00 00 00 
2758   1DC4 00 00 00 00 
2758   1DC8 00 00 00 00 
2758   1DCC 00 00 00 00 
2758   1DD0 00 00 00 00 
2758   1DD4 00 00 00 00 
2758   1DD8 00 00 00 00 
2758   1DDC 00 00 00 00 
2758   1DE0 00 00 00 00 
2758   1DE4 00 00 00 00 
2758   1DE8 00 00 00 00 
2758   1DEC 00 00 00 00 
2758   1DF0 00 00 00 00 
2758   1DF4 00 00 00 00 
2758   1DF8 00 00 00 00 
2758   1DFC 00 00 00 00 
2758   1E00 00 00 00 00 
2758   1E04 00 00 00 00 
2758   1E08 00 00 00 00 
2758   1E0C 00 00 00 00 
2758   1E10 00 00 00 00 
2758   1E14 00 00 00 00 
2758   1E18 00 00 00 00 
2758   1E1C 00 00 00 00 
2758   1E20 00 00 00 00 
2758   1E24 00 00 00 00 
2758   1E28 00 00 00 00 
2758   1E2C 00 00 00 00 
2758   1E30 00 00 00 00 
2758   1E34 00 00 00 00 
2758   1E38 00 00 00 00 
2758   1E3C 00 00 00 00 
2758   1E40 00 00 00 00 
2758   1E44 00 00 00 00 
2758   1E48 00 00 00 00 
2758   1E4C 00 00 00 00 
2758   1E50 00 00 00 00 
2758   1E54 00 00 00 00 
2758   1E58 00 00 00 00 
2758   1E5C 00 00 00 00 
2758   1E60 00 00 00 00 
2758   1E64 00 00 00 00 
2758   1E68 00 00 00 00 
2758   1E6C 00 00 00 00 
2758   1E70 00 00 00 00 
2758   1E74 00 00 00 00 
2758   1E78 00 00 00 00 
2758   1E7C 00 00 00 00 
2758   1E80 00 00 00 00 
2758   1E84 00 00 00 00 
2759   1E88 00 00 00 00 filename:           .fill 128, 0      ; holds a path for file search
2759   1E8C 00 00 00 00 
2759   1E90 00 00 00 00 
2759   1E94 00 00 00 00 
2759   1E98 00 00 00 00 
2759   1E9C 00 00 00 00 
2759   1EA0 00 00 00 00 
2759   1EA4 00 00 00 00 
2759   1EA8 00 00 00 00 
2759   1EAC 00 00 00 00 
2759   1EB0 00 00 00 00 
2759   1EB4 00 00 00 00 
2759   1EB8 00 00 00 00 
2759   1EBC 00 00 00 00 
2759   1EC0 00 00 00 00 
2759   1EC4 00 00 00 00 
2759   1EC8 00 00 00 00 
2759   1ECC 00 00 00 00 
2759   1ED0 00 00 00 00 
2759   1ED4 00 00 00 00 
2759   1ED8 00 00 00 00 
2759   1EDC 00 00 00 00 
2759   1EE0 00 00 00 00 
2759   1EE4 00 00 00 00 
2759   1EE8 00 00 00 00 
2759   1EEC 00 00 00 00 
2759   1EF0 00 00 00 00 
2759   1EF4 00 00 00 00 
2759   1EF8 00 00 00 00 
2759   1EFC 00 00 00 00 
2759   1F00 00 00 00 00 
2759   1F04 00 00 00 00 
2760   1F08 00 00 00 00 user_data:          .fill 512, 0      ;  user space data
2760   1F0C 00 00 00 00 
2760   1F10 00 00 00 00 
2760   1F14 00 00 00 00 
2760   1F18 00 00 00 00 
2760   1F1C 00 00 00 00 
2760   1F20 00 00 00 00 
2760   1F24 00 00 00 00 
2760   1F28 00 00 00 00 
2760   1F2C 00 00 00 00 
2760   1F30 00 00 00 00 
2760   1F34 00 00 00 00 
2760   1F38 00 00 00 00 
2760   1F3C 00 00 00 00 
2760   1F40 00 00 00 00 
2760   1F44 00 00 00 00 
2760   1F48 00 00 00 00 
2760   1F4C 00 00 00 00 
2760   1F50 00 00 00 00 
2760   1F54 00 00 00 00 
2760   1F58 00 00 00 00 
2760   1F5C 00 00 00 00 
2760   1F60 00 00 00 00 
2760   1F64 00 00 00 00 
2760   1F68 00 00 00 00 
2760   1F6C 00 00 00 00 
2760   1F70 00 00 00 00 
2760   1F74 00 00 00 00 
2760   1F78 00 00 00 00 
2760   1F7C 00 00 00 00 
2760   1F80 00 00 00 00 
2760   1F84 00 00 00 00 
2760   1F88 00 00 00 00 
2760   1F8C 00 00 00 00 
2760   1F90 00 00 00 00 
2760   1F94 00 00 00 00 
2760   1F98 00 00 00 00 
2760   1F9C 00 00 00 00 
2760   1FA0 00 00 00 00 
2760   1FA4 00 00 00 00 
2760   1FA8 00 00 00 00 
2760   1FAC 00 00 00 00 
2760   1FB0 00 00 00 00 
2760   1FB4 00 00 00 00 
2760   1FB8 00 00 00 00 
2760   1FBC 00 00 00 00 
2760   1FC0 00 00 00 00 
2760   1FC4 00 00 00 00 
2760   1FC8 00 00 00 00 
2760   1FCC 00 00 00 00 
2760   1FD0 00 00 00 00 
2760   1FD4 00 00 00 00 
2760   1FD8 00 00 00 00 
2760   1FDC 00 00 00 00 
2760   1FE0 00 00 00 00 
2760   1FE4 00 00 00 00 
2760   1FE8 00 00 00 00 
2760   1FEC 00 00 00 00 
2760   1FF0 00 00 00 00 
2760   1FF4 00 00 00 00 
2760   1FF8 00 00 00 00 
2760   1FFC 00 00 00 00 
2760   2000 00 00 00 00 
2760   2004 00 00 00 00 
2760   2008 00 00 00 00 
2760   200C 00 00 00 00 
2760   2010 00 00 00 00 
2760   2014 00 00 00 00 
2760   2018 00 00 00 00 
2760   201C 00 00 00 00 
2760   2020 00 00 00 00 
2760   2024 00 00 00 00 
2760   2028 00 00 00 00 
2760   202C 00 00 00 00 
2760   2030 00 00 00 00 
2760   2034 00 00 00 00 
2760   2038 00 00 00 00 
2760   203C 00 00 00 00 
2760   2040 00 00 00 00 
2760   2044 00 00 00 00 
2760   2048 00 00 00 00 
2760   204C 00 00 00 00 
2760   2050 00 00 00 00 
2760   2054 00 00 00 00 
2760   2058 00 00 00 00 
2760   205C 00 00 00 00 
2760   2060 00 00 00 00 
2760   2064 00 00 00 00 
2760   2068 00 00 00 00 
2760   206C 00 00 00 00 
2760   2070 00 00 00 00 
2760   2074 00 00 00 00 
2760   2078 00 00 00 00 
2760   207C 00 00 00 00 
2760   2080 00 00 00 00 
2760   2084 00 00 00 00 
2760   2088 00 00 00 00 
2760   208C 00 00 00 00 
2760   2090 00 00 00 00 
2760   2094 00 00 00 00 
2760   2098 00 00 00 00 
2760   209C 00 00 00 00 
2760   20A0 00 00 00 00 
2760   20A4 00 00 00 00 
2760   20A8 00 00 00 00 
2760   20AC 00 00 00 00 
2760   20B0 00 00 00 00 
2760   20B4 00 00 00 00 
2760   20B8 00 00 00 00 
2760   20BC 00 00 00 00 
2760   20C0 00 00 00 00 
2760   20C4 00 00 00 00 
2760   20C8 00 00 00 00 
2760   20CC 00 00 00 00 
2760   20D0 00 00 00 00 
2760   20D4 00 00 00 00 
2760   20D8 00 00 00 00 
2760   20DC 00 00 00 00 
2760   20E0 00 00 00 00 
2760   20E4 00 00 00 00 
2760   20E8 00 00 00 00 
2760   20EC 00 00 00 00 
2760   20F0 00 00 00 00 
2760   20F4 00 00 00 00 
2760   20F8 00 00 00 00 
2760   20FC 00 00 00 00 
2760   2100 00 00 00 00 
2760   2104 00 00 00 00 
2761   2108 FF FF FF FF fifo:               .fill FIFO_SIZE
2761   210C FF FF FF FF 
2761   2110 FF FF FF FF 
2761   2114 FF FF FF FF 
2761   2118 FF FF FF FF 
2761   211C FF FF FF FF 
2761   2120 FF FF FF FF 
2761   2124 FF FF FF FF 
2761   2128 FF FF FF FF 
2761   212C FF FF FF FF 
2761   2130 FF FF FF FF 
2761   2134 FF FF FF FF 
2761   2138 FF FF FF FF 
2761   213C FF FF FF FF 
2761   2140 FF FF FF FF 
2761   2144 FF FF FF FF 
2761   2148 FF FF FF FF 
2761   214C FF FF FF FF 
2761   2150 FF FF FF FF 
2761   2154 FF FF FF FF 
2761   2158 FF FF FF FF 
2761   215C FF FF FF FF 
2761   2160 FF FF FF FF 
2761   2164 FF FF FF FF 
2761   2168 FF FF FF FF 
2761   216C FF FF FF FF 
2761   2170 FF FF FF FF 
2761   2174 FF FF FF FF 
2761   2178 FF FF FF FF 
2761   217C FF FF FF FF 
2761   2180 FF FF FF FF 
2761   2184 FF FF FF FF 
2761   2188 FF FF FF FF 
2761   218C FF FF FF FF 
2761   2190 FF FF FF FF 
2761   2194 FF FF FF FF 
2761   2198 FF FF FF FF 
2761   219C FF FF FF FF 
2761   21A0 FF FF FF FF 
2761   21A4 FF FF FF FF 
2761   21A8 FF FF FF FF 
2761   21AC FF FF FF FF 
2761   21B0 FF FF FF FF 
2761   21B4 FF FF FF FF 
2761   21B8 FF FF FF FF 
2761   21BC FF FF FF FF 
2761   21C0 FF FF FF FF 
2761   21C4 FF FF FF FF 
2761   21C8 FF FF FF FF 
2761   21CC FF FF FF FF 
2761   21D0 FF FF FF FF 
2761   21D4 FF FF FF FF 
2761   21D8 FF FF FF FF 
2761   21DC FF FF FF FF 
2761   21E0 FF FF FF FF 
2761   21E4 FF FF FF FF 
2761   21E8 FF FF FF FF 
2761   21EC FF FF FF FF 
2761   21F0 FF FF FF FF 
2761   21F4 FF FF FF FF 
2761   21F8 FF FF FF FF 
2761   21FC FF FF FF FF 
2761   2200 FF FF FF FF 
2761   2204 FF FF FF FF 
2761   2208 FF FF FF FF 
2761   220C FF FF FF FF 
2761   2210 FF FF FF FF 
2761   2214 FF FF FF FF 
2761   2218 FF FF FF FF 
2761   221C FF FF FF FF 
2761   2220 FF FF FF FF 
2761   2224 FF FF FF FF 
2761   2228 FF FF FF FF 
2761   222C FF FF FF FF 
2761   2230 FF FF FF FF 
2761   2234 FF FF FF FF 
2761   2238 FF FF FF FF 
2761   223C FF FF FF FF 
2761   2240 FF FF FF FF 
2761   2244 FF FF FF FF 
2761   2248 FF FF FF FF 
2761   224C FF FF FF FF 
2761   2250 FF FF FF FF 
2761   2254 FF FF FF FF 
2761   2258 FF FF FF FF 
2761   225C FF FF FF FF 
2761   2260 FF FF FF FF 
2761   2264 FF FF FF FF 
2761   2268 FF FF FF FF 
2761   226C FF FF FF FF 
2761   2270 FF FF FF FF 
2761   2274 FF FF FF FF 
2761   2278 FF FF FF FF 
2761   227C FF FF FF FF 
2761   2280 FF FF FF FF 
2761   2284 FF FF FF FF 
2761   2288 FF FF FF FF 
2761   228C FF FF FF FF 
2761   2290 FF FF FF FF 
2761   2294 FF FF FF FF 
2761   2298 FF FF FF FF 
2761   229C FF FF FF FF 
2761   22A0 FF FF FF FF 
2761   22A4 FF FF FF FF 
2761   22A8 FF FF FF FF 
2761   22AC FF FF FF FF 
2761   22B0 FF FF FF FF 
2761   22B4 FF FF FF FF 
2761   22B8 FF FF FF FF 
2761   22BC FF FF FF FF 
2761   22C0 FF FF FF FF 
2761   22C4 FF FF FF FF 
2761   22C8 FF FF FF FF 
2761   22CC FF FF FF FF 
2761   22D0 FF FF FF FF 
2761   22D4 FF FF FF FF 
2761   22D8 FF FF FF FF 
2761   22DC FF FF FF FF 
2761   22E0 FF FF FF FF 
2761   22E4 FF FF FF FF 
2761   22E8 FF FF FF FF 
2761   22EC FF FF FF FF 
2761   22F0 FF FF FF FF 
2761   22F4 FF FF FF FF 
2761   22F8 FF FF FF FF 
2761   22FC FF FF FF FF 
2761   2300 FF FF FF FF 
2761   2304 FF FF FF FF 
2761   2308 FF FF FF FF 
2761   230C FF FF FF FF 
2761   2310 FF FF FF FF 
2761   2314 FF FF FF FF 
2761   2318 FF FF FF FF 
2761   231C FF FF FF FF 
2761   2320 FF FF FF FF 
2761   2324 FF FF FF FF 
2761   2328 FF FF FF FF 
2761   232C FF FF FF FF 
2761   2330 FF FF FF FF 
2761   2334 FF FF FF FF 
2761   2338 FF FF FF FF 
2761   233C FF FF FF FF 
2761   2340 FF FF FF FF 
2761   2344 FF FF FF FF 
2761   2348 FF FF FF FF 
2761   234C FF FF FF FF 
2761   2350 FF FF FF FF 
2761   2354 FF FF FF FF 
2761   2358 FF FF FF FF 
2761   235C FF FF FF FF 
2761   2360 FF FF FF FF 
2761   2364 FF FF FF FF 
2761   2368 FF FF FF FF 
2761   236C FF FF FF FF 
2761   2370 FF FF FF FF 
2761   2374 FF FF FF FF 
2761   2378 FF FF FF FF 
2761   237C FF FF FF FF 
2761   2380 FF FF FF FF 
2761   2384 FF FF FF FF 
2761   2388 FF FF FF FF 
2761   238C FF FF FF FF 
2761   2390 FF FF FF FF 
2761   2394 FF FF FF FF 
2761   2398 FF FF FF FF 
2761   239C FF FF FF FF 
2761   23A0 FF FF FF FF 
2761   23A4 FF FF FF FF 
2761   23A8 FF FF FF FF 
2761   23AC FF FF FF FF 
2761   23B0 FF FF FF FF 
2761   23B4 FF FF FF FF 
2761   23B8 FF FF FF FF 
2761   23BC FF FF FF FF 
2761   23C0 FF FF FF FF 
2761   23C4 FF FF FF FF 
2761   23C8 FF FF FF FF 
2761   23CC FF FF FF FF 
2761   23D0 FF FF FF FF 
2761   23D4 FF FF FF FF 
2761   23D8 FF FF FF FF 
2761   23DC FF FF FF FF 
2761   23E0 FF FF FF FF 
2761   23E4 FF FF FF FF 
2761   23E8 FF FF FF FF 
2761   23EC FF FF FF FF 
2761   23F0 FF FF FF FF 
2761   23F4 FF FF FF FF 
2761   23F8 FF FF FF FF 
2761   23FC FF FF FF FF 
2761   2400 FF FF FF FF 
2761   2404 FF FF FF FF 
2761   2408 FF FF FF FF 
2761   240C FF FF FF FF 
2761   2410 FF FF FF FF 
2761   2414 FF FF FF FF 
2761   2418 FF FF FF FF 
2761   241C FF FF FF FF 
2761   2420 FF FF FF FF 
2761   2424 FF FF FF FF 
2761   2428 FF FF FF FF 
2761   242C FF FF FF FF 
2761   2430 FF FF FF FF 
2761   2434 FF FF FF FF 
2761   2438 FF FF FF FF 
2761   243C FF FF FF FF 
2761   2440 FF FF FF FF 
2761   2444 FF FF FF FF 
2761   2448 FF FF FF FF 
2761   244C FF FF FF FF 
2761   2450 FF FF FF FF 
2761   2454 FF FF FF FF 
2761   2458 FF FF FF FF 
2761   245C FF FF FF FF 
2761   2460 FF FF FF FF 
2761   2464 FF FF FF FF 
2761   2468 FF FF FF FF 
2761   246C FF FF FF FF 
2761   2470 FF FF FF FF 
2761   2474 FF FF FF FF 
2761   2478 FF FF FF FF 
2761   247C FF FF FF FF 
2761   2480 FF FF FF FF 
2761   2484 FF FF FF FF 
2761   2488 FF FF FF FF 
2761   248C FF FF FF FF 
2761   2490 FF FF FF FF 
2761   2494 FF FF FF FF 
2761   2498 FF FF FF FF 
2761   249C FF FF FF FF 
2761   24A0 FF FF FF FF 
2761   24A4 FF FF FF FF 
2761   24A8 FF FF FF FF 
2761   24AC FF FF FF FF 
2761   24B0 FF FF FF FF 
2761   24B4 FF FF FF FF 
2761   24B8 FF FF FF FF 
2761   24BC FF FF FF FF 
2761   24C0 FF FF FF FF 
2761   24C4 FF FF FF FF 
2761   24C8 FF FF FF FF 
2761   24CC FF FF FF FF 
2761   24D0 FF FF FF FF 
2761   24D4 FF FF FF FF 
2761   24D8 FF FF FF FF 
2761   24DC FF FF FF FF 
2761   24E0 FF FF FF FF 
2761   24E4 FF FF FF FF 
2761   24E8 FF FF FF FF 
2761   24EC FF FF FF FF 
2761   24F0 FF FF FF FF 
2761   24F4 FF FF FF FF 
2761   24F8 FF FF FF FF 
2761   24FC FF FF FF FF 
2761   2500 FF FF FF FF 
2761   2504 FF FF FF FF 
2762   2508             
2763   2508 FF FF FF FF scrap_sector:       .fill 512         ; scrap sector
2763   250C FF FF FF FF 
2763   2510 FF FF FF FF 
2763   2514 FF FF FF FF 
2763   2518 FF FF FF FF 
2763   251C FF FF FF FF 
2763   2520 FF FF FF FF 
2763   2524 FF FF FF FF 
2763   2528 FF FF FF FF 
2763   252C FF FF FF FF 
2763   2530 FF FF FF FF 
2763   2534 FF FF FF FF 
2763   2538 FF FF FF FF 
2763   253C FF FF FF FF 
2763   2540 FF FF FF FF 
2763   2544 FF FF FF FF 
2763   2548 FF FF FF FF 
2763   254C FF FF FF FF 
2763   2550 FF FF FF FF 
2763   2554 FF FF FF FF 
2763   2558 FF FF FF FF 
2763   255C FF FF FF FF 
2763   2560 FF FF FF FF 
2763   2564 FF FF FF FF 
2763   2568 FF FF FF FF 
2763   256C FF FF FF FF 
2763   2570 FF FF FF FF 
2763   2574 FF FF FF FF 
2763   2578 FF FF FF FF 
2763   257C FF FF FF FF 
2763   2580 FF FF FF FF 
2763   2584 FF FF FF FF 
2763   2588 FF FF FF FF 
2763   258C FF FF FF FF 
2763   2590 FF FF FF FF 
2763   2594 FF FF FF FF 
2763   2598 FF FF FF FF 
2763   259C FF FF FF FF 
2763   25A0 FF FF FF FF 
2763   25A4 FF FF FF FF 
2763   25A8 FF FF FF FF 
2763   25AC FF FF FF FF 
2763   25B0 FF FF FF FF 
2763   25B4 FF FF FF FF 
2763   25B8 FF FF FF FF 
2763   25BC FF FF FF FF 
2763   25C0 FF FF FF FF 
2763   25C4 FF FF FF FF 
2763   25C8 FF FF FF FF 
2763   25CC FF FF FF FF 
2763   25D0 FF FF FF FF 
2763   25D4 FF FF FF FF 
2763   25D8 FF FF FF FF 
2763   25DC FF FF FF FF 
2763   25E0 FF FF FF FF 
2763   25E4 FF FF FF FF 
2763   25E8 FF FF FF FF 
2763   25EC FF FF FF FF 
2763   25F0 FF FF FF FF 
2763   25F4 FF FF FF FF 
2763   25F8 FF FF FF FF 
2763   25FC FF FF FF FF 
2763   2600 FF FF FF FF 
2763   2604 FF FF FF FF 
2763   2608 FF FF FF FF 
2763   260C FF FF FF FF 
2763   2610 FF FF FF FF 
2763   2614 FF FF FF FF 
2763   2618 FF FF FF FF 
2763   261C FF FF FF FF 
2763   2620 FF FF FF FF 
2763   2624 FF FF FF FF 
2763   2628 FF FF FF FF 
2763   262C FF FF FF FF 
2763   2630 FF FF FF FF 
2763   2634 FF FF FF FF 
2763   2638 FF FF FF FF 
2763   263C FF FF FF FF 
2763   2640 FF FF FF FF 
2763   2644 FF FF FF FF 
2763   2648 FF FF FF FF 
2763   264C FF FF FF FF 
2763   2650 FF FF FF FF 
2763   2654 FF FF FF FF 
2763   2658 FF FF FF FF 
2763   265C FF FF FF FF 
2763   2660 FF FF FF FF 
2763   2664 FF FF FF FF 
2763   2668 FF FF FF FF 
2763   266C FF FF FF FF 
2763   2670 FF FF FF FF 
2763   2674 FF FF FF FF 
2763   2678 FF FF FF FF 
2763   267C FF FF FF FF 
2763   2680 FF FF FF FF 
2763   2684 FF FF FF FF 
2763   2688 FF FF FF FF 
2763   268C FF FF FF FF 
2763   2690 FF FF FF FF 
2763   2694 FF FF FF FF 
2763   2698 FF FF FF FF 
2763   269C FF FF FF FF 
2763   26A0 FF FF FF FF 
2763   26A4 FF FF FF FF 
2763   26A8 FF FF FF FF 
2763   26AC FF FF FF FF 
2763   26B0 FF FF FF FF 
2763   26B4 FF FF FF FF 
2763   26B8 FF FF FF FF 
2763   26BC FF FF FF FF 
2763   26C0 FF FF FF FF 
2763   26C4 FF FF FF FF 
2763   26C8 FF FF FF FF 
2763   26CC FF FF FF FF 
2763   26D0 FF FF FF FF 
2763   26D4 FF FF FF FF 
2763   26D8 FF FF FF FF 
2763   26DC FF FF FF FF 
2763   26E0 FF FF FF FF 
2763   26E4 FF FF FF FF 
2763   26E8 FF FF FF FF 
2763   26EC FF FF FF FF 
2763   26F0 FF FF FF FF 
2763   26F4 FF FF FF FF 
2763   26F8 FF FF FF FF 
2763   26FC FF FF FF FF 
2763   2700 FF FF FF FF 
2763   2704 FF FF FF FF 
2764   2708 00          transient_area:     .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
2765   2709             
2766   2709             
2767   2709             .end
tasm: Number of errors = 0
