0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80         ; data
0034   0000             _uart0_dlab_0     .equ $ff80         ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81         ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81         ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82         ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83         ; line control register
0039   0000             _uart0_lsr        .equ $ff85         ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90         ; data
0042   0000             _uart1_dlab_0     .equ $ff90         ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91         ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91         ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92         ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93         ; line control register
0047   0000             _uart1_lsr        .equ $ff95         ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0         ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0 ; data port
0051   0000             _ide_r1           .equ _ide_base + 1 ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2 ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3 ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4 ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5 ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6 ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7 ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0         ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3         ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3         ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0         ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_0     .equ $ffc1         ; 0 = drq, 1 = ready
0068   0000             _fdc_stat_cmd     .equ $ffc8         ; status / command register
0069   0000             _fdc_track        .equ $ffc9         ; track register
0070   0000             _fdc_sector       .equ $ffca         ; sector register
0071   0000             _fdc_data         .equ $ffcb         ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0         ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1         ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2         ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3         ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff         ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400          ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; DISK LAYOUT:
0086   0000             ; | Metadata               | Size (bytes)    | Blocks (2048 bytes)              |
0087   0000             ; | ---------------------- | --------------- | -------------------------------- |
0088   0000             ; | Bootloader             | 512 bytes       | 0.25 (1 sector)                  |
0089   0000             ; | Superblock             | 1024 bytes      | 1 block (2048 bytes, must align) |
0090   0000             ; | Block Group Descriptor | \~32 bytes      | 1 block (2048 bytes)             |
0091   0000             ; | Block Bitmap           | 16,384 bytes    | 8 blocks                         |
0092   0000             ; | Inode Bitmap           | 2,048 bytes     | 1 block                          |
0093   0000             ; | Inode Table            | 2,097,152 bytes | 1024 blocks                      |
0094   0000             ; 
0095   0000             ; first 512 bytes: bootloader from 0 to 445, MBR partition table from 446 to 511 (64 bytes)
0096   0000             ; up to 4 partitions, each 16 bytes long
0097   0000             ; MBR:
0098   0000             ; Byte | Description
0099   0000             ; -----|----------------------------
0100   0000             ; 0    | Boot flag (0x80 active, 0x00 inactive)
0101   0000             ; 1-3  | Start CHS (head, sector, cylinder)
0102   0000             ; 4    | Partition type (filesystem ID)
0103   0000             ;   0x83 = Linux native (ext2/3/4)
0104   0000             ;   0x07 = NTFS/exFAT
0105   0000             ;   0x0B = FAT32 CHS
0106   0000             ;   0x0C = FAT32 LBA
0107   0000             ;   0x05 = Extended partition
0108   0000             ; 5-7  | End CHS
0109   0000             ; 8-11 | Start LBA (little endian)
0110   0000             ; 12-15| Size in sectors (little endian)
0111   0000             ; 
0112   0000             ; 
0113   0000             ; SUPERBLOCK:
0114   0000             ; | Field                 | Description                                  |
0115   0000             ; | --------------------- | -------------------------------------------- |
0116   0000             ; | `s_inodes_count`      | Total number of inodes in the filesystem     |
0117   0000             ; | `s_blocks_count`      | Total number of data blocks                  |
0118   0000             ; | `s_free_inodes_count` | Number of free inodes                        |
0119   0000             ; | `s_free_blocks_count` | Number of free blocks                        |
0120   0000             ; | `s_first_data_block`  | Block number of the first data block         |
0121   0000             ; | `s_log_block_size`    | Block size = 1024 << `s_log_block_size`      |
0122   0000             ; | `s_inode_size`        | Size of each inode (in bytes)                |
0123   0000             ; | `s_magic`             | Filesystem signature (`0xEF53` for ext2/3/4) |
0124   0000             ; | `s_mtime`             | Last mount time                              |
0125   0000             ; | `s_wtime`             | Last write time                              |
0126   0000             ; | `s_uuid`              | Unique ID of the filesystem                  |
0127   0000             ; | `s_volume_name`       | Label of the filesystem                      |
0128   0000             ; | `s_feature_flags`     | Compatibility flags                          |
0129   0000             ; 
0130   0000             ; 
0131   0000             ; 
0132   0000             ; inode for root dir is #2, #0 and #1 not used
0133   0000             ; bock size: 2048
0134   0000             
0135   0000             ; inode-table format:
0136   0000             ; | Field         | Size (bytes) | Description                                                                                  |
0137   0000             ; | ------------- | ------------ | -------------------------------------------------------------------------------------------- |
0138   0000             ; | `mode`        | 2            | File type and permissions                                                                    |
0139   0000             ; | `uid`         | 2            | Owner user ID                                                                                |
0140   0000             ; | `size`        | 4            | Size of the file in bytes                                                                    |
0141   0000             ; | `atime`       | 4            | Last access time (timestamp)                                                                 |
0142   0000             ; | `ctime`       | 4            | Creation time (timestamp)                                                                    |
0143   0000             ; | `mtime`       | 4            | Last modification time (timestamp)                                                           |
0144   0000             ; | `dtime`       | 4            | Deletion time (timestamp)                                                                    |
0145   0000             ; | `gid`         | 2            | Group ID                                                                                     |
0146   0000             ; | `links_count` | 2            | Number of hard links                                                                         |
0147   0000             ; | `blocks`      | 4            | Number of 512-byte blocks allocated                                                          |
0148   0000             ; | `flags`       | 4            | File flags                                                                                   |
0149   0000             ; | `block`       | 15 x 4 = 60  | Pointers to data blocks (12 direct, 1 single indirect, 1 double indirect, 1 triple indirect) |
0150   0000             
0151   0000             
0152   0000             ; file entry attributes
0153   0000             ; filename (24)
0154   0000             ; attributes (1)       :|0|0|file_type(3bits)|x|w|r|
0155   0000             ; lba (2)              : location of raw data for file entry, or dirid for directory entry
0156   0000             ; size (2)             : filesize
0157   0000             ; day (1)           
0158   0000             ; month (1)
0159   0000             ; year (1)
0160   0000             ; packet size = 32 bytes  : total packet size in bytes
0161   0000             
0162   0000             fst_entry_size      .equ 32  ; bytes
0163   0000             fst_files_per_sect  .equ (512 / fst_entry_size)
0164   0000             fst_files_per_dir   .equ (512 / fst_entry_size)
0165   0000             fst_nbr_directories .equ 64
0166   0000                                 ; 1 sector for header, the rest is for the list of files/dirs
0167   0000             fst_sectors_per_dir .equ (1 + (fst_entry_size * fst_files_per_dir / 512))    
0168   0000             fst_total_sectors   .equ (fst_sectors_per_dir * fst_nbr_directories)
0169   0000             fst_lba_start       .equ 32
0170   0000             fst_lba_end         .equ (fst_lba_start + fst_total_sectors - 1)
0171   0000             
0172   0000             fs_nbr_files        .equ (fst_nbr_directories * fst_files_per_dir)
0173   0000             fs_sectors_per_file .equ 32 ; the first sector is always a header with a null parameter (first byte)
0174   0000                                         ; so that we know which blocks are free or taken
0175   0000             fs_file_size        .equ (fs_sectors_per_file * 512)                  
0176   0000             fs_total_sectors    .equ (fs_nbr_files * fs_sectors_per_file)
0177   0000             fs_lba_start        .equ (fst_lba_end + 1)
0178   0000             fs_lba_end          .equ (fs_lba_start + fs_total_sectors - 1)
0179   0000             
0180   0000             root_id:            .equ fst_lba_start
0181   0000             
0182   0000             ; ------------------------------------------------------------------------------------------------------------------;
0183   0000             ; global system variables
0184   0000             ; ------------------------------------------------------------------------------------------------------------------;
0185   0000             
0186   0000             ; ------------------------------------------------------------------------------------------------------------------;
0187   0000             ; irq table
0188   0000             ; highest priority at lowest address
0189   0000             ; ------------------------------------------------------------------------------------------------------------------;
0190   0000 3C 00       .dw int_0_fdc
0191   0002 3D 00       .dw int_1
0192   0004 3E 00       .dw int_2
0193   0006 3F 00       .dw int_3
0194   0008 40 00       .dw int_4
0195   000A 41 00       .dw int_5
0196   000C 42 00       .dw int_6
0197   000E 43 00       .dw int_7_uart0
0198   0010             
0199   0010             ; ------------------------------------------------------------------------------------------------------------------;
0200   0010             ; kernel reset vector
0201   0010             ; ------------------------------------------------------------------------------------------------------------------;
0202   0010 B1 10       .dw kernel_reset_vector
0203   0012             
0204   0012             ; ------------------------------------------------------------------------------------------------------------------;
0205   0012             ; exception vector table
0206   0012             ; total of 7 entries, starting at address $0012
0207   0012             ; ------------------------------------------------------------------------------------------------------------------;
0208   0012 66 03       .dw trap_privilege
0209   0014 83 04       .dw trap_div_zero
0210   0016 90 04       .dw trap_undef_opcode
0211   0018 00 00       .dw 0
0212   001A 00 00       .dw 0
0213   001C 00 00       .dw 0
0214   001E 00 00       .dw 0
0215   0020             
0216   0020             ; ------------------------------------------------------------------------------------------------------------------;
0217   0020             ; system call vector table
0218   0020             ; starts at address $0020
0219   0020             ; ------------------------------------------------------------------------------------------------------------------;
0220   0020 72 03       .dw syscall_break
0221   0022 91 04       .dw syscall_rtc
0222   0024 B4 05       .dw syscall_ide
0223   0026 74 06       .dw syscall_io
0224   0028 31 07       .dw syscall_file_system
0225   002A FE 0F       .dw syscall_create_proc
0226   002C 2B 03       .dw syscall_list_procs
0227   002E C3 04       .dw syscall_datetime
0228   0030 E7 02       .dw syscall_reboot
0229   0032 C8 0F       .dw syscall_pause_proc
0230   0034 F3 02       .dw syscall_resume_proc
0231   0036 85 0F       .dw syscall_terminate_proc
0232   0038 B3 02       .dw syscall_system
0233   003A 94 00       .dw syscall_fdc
0234   003C             
0235   003C             ; ------------------------------------------------------------------------------------------------------------------;
0236   003C             ; system call aliases
0237   003C             ; ------------------------------------------------------------------------------------------------------------------;
0238   003C             sys_break            .equ 0
0239   003C             sys_rtc              .equ 1
0240   003C             sys_ide              .equ 2
0241   003C             sys_io               .equ 3
0242   003C             sys_filesystem       .equ 4
0243   003C             sys_create_proc      .equ 5
0244   003C             sys_list_proc        .equ 6
0245   003C             sys_datetime         .equ 7
0246   003C             sys_reboot           .equ 8
0247   003C             sys_pause_proc       .equ 9
0248   003C             sys_resume_proc      .equ 10
0249   003C             sys_terminate_proc   .equ 11
0250   003C             sys_system           .equ 12
0251   003C             sys_fdc              .equ 13
0252   003C             
0253   003C             ; aliases for individual 'al' options for FDC system calls
0254   003C             fdc_al_restore      .equ 0
0255   003C             fdc_al_step         .equ 1
0256   003C             fdc_al_step_in      .equ 2
0257   003C             fdc_al_step_out     .equ 3
0258   003C             fdc_al_seek         .equ 4
0259   003C             fdc_al_format_128   .equ 5
0260   003C             fdc_al_format_512   .equ 6
0261   003C             fdc_al_read_addr    .equ 7
0262   003C             fdc_al_read_track   .equ 8
0263   003C             fdc_al_read_sect    .equ 9
0264   003C             fdc_al_write_sect   .equ 10
0265   003C             fdc_al_force_int    .equ 11
0266   003C             fdc_al_status0      .equ 12
0267   003C             fdc_al_status1      .equ 13
0268   003C             
0269   003C             ; ------------------------------------------------------------------------------------------------------------------;
0270   003C             ; alias exports
0271   003C             ; ------------------------------------------------------------------------------------------------------------------;
0272   003C             .export text_org
0273   003C             .export sys_break
0274   003C             .export sys_rtc
0275   003C             .export sys_ide
0276   003C             .export sys_io
0277   003C             .export sys_filesystem
0278   003C             .export sys_create_proc
0279   003C             .export sys_list_proc
0280   003C             .export sys_datetime
0281   003C             .export sys_reboot
0282   003C             .export sys_pause_proc
0283   003C             .export sys_resume_proc
0284   003C             .export sys_terminate_proc
0285   003C             .export sys_system
0286   003C             .export sys_fdc
0287   003C             
0288   003C             .export _fdc_config        
0289   003C             .export _fdc_status_0      
0290   003C             .export _fdc_stat_cmd     
0291   003C             
0292   003C             ; exports of aliases for individual 'al' options for FDC system calls
0293   003C             .export fdc_al_restore
0294   003C             .export fdc_al_step
0295   003C             .export fdc_al_step_in
0296   003C             .export fdc_al_step_out
0297   003C             .export fdc_al_seek
0298   003C             .export fdc_al_format_128
0299   003C             .export fdc_al_format_512
0300   003C             .export fdc_al_read_addr
0301   003C             .export fdc_al_read_track
0302   003C             .export fdc_al_read_sect
0303   003C             .export fdc_al_write_sect
0304   003C             .export fdc_al_force_int
0305   003C             .export fdc_al_status0
0306   003C             .export fdc_al_status1
0307   003C             
0308   003C             ; ------------------------------------------------------------------------------------------------------------------;
0309   003C             ; irqs' code block
0310   003C             ; ------------------------------------------------------------------------------------------------------------------;
0311   003C             ; 5.25" floppy drive controller irq
0312   003C             int_0_fdc:
0313   003C 06            sysret
0314   003D             int_1:
0315   003D 06            sysret
0316   003E             int_2:
0317   003E 06            sysret
0318   003F             int_3:
0319   003F 06            sysret
0320   0040             int_4:
0321   0040 06            sysret
0322   0041             int_5:
0323   0041 06            sysret
0324   0042             
0325   0042             ; timer irq
0326   0042             int_6:  
0327   0042 06            sysret
0328   0043             
0329   0043             ; ------------------------------------------------------------------------------------------------------------------;
0330   0043             ; uart0 interrupt
0331   0043             ; ------------------------------------------------------------------------------------------------------------------;
0332   0043             int_7_uart0:
0333   0043 D7            push a
0334   0044 DA            push d
0335   0045 E1            pushf
0336   0046 14 43 18      mov a, [fifo_in]
0337   0049 3C            mov d, a
0338   004A 1D 80 FF      mov al, [_uart0_data]       ; get character
0339   004D B9 03         cmp al, $03                 ; ctrl-c
0340   004F C6 6C 00      je ctrlc
0341   0052 B9 1A         cmp al, $1a                 ; ctrl-z
0342   0054 C6 72 00      je ctrlz
0343   0057 3E            mov [d], al                 ; add to fifo
0344   0058 14 43 18      mov a, [fifo_in]
0345   005B 77            inc a
0346   005C AF A4 23      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0347   005F C7 65 00      jne int_7_continue
0348   0062 10 A4 1F      mov a, fifo  
0349   0065             int_7_continue:  
0350   0065 42 43 18      mov [fifo_in], a            ; update fifo pointer
0351   0068 EE            popf
0352   0069 E7            pop d
0353   006A E4            pop a  
0354   006B 06            sysret
0355   006C             ctrlc:
0356   006C 51 05 00      add sp, 5
0357   006F 0A 85 0F      jmp syscall_terminate_proc
0358   0072             ctrlz:
0359   0072 EE            popf
0360   0073 E7            pop d
0361   0074 E4            pop a
0362   0075 0A C8 0F      jmp syscall_pause_proc      ; pause current process and go back to the shell
0363   0078             
0364   0078             ; ------------------------------------------------------------------------------------------------------------------;
0365   0078             ; floppy drive syscalls
0366   0078             ; ------------------------------------------------------------------------------------------------------------------;
0367   0078             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0368   0078             ; fdc_40_ff:
0369   0078             ;   .fill 40,  $ff    ; or 00                                                                                
0370   0078             ; fdc_128_format_inner:
0371   0078             ;   .fill 6,   $00    ;                                                                            <--|        
0372   0078             ;   .fill 1,   $fe    ; id address mark                                                               |        
0373   0078             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0374   0078             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0375   0078             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0376   0078             ;   .fill 1,   $00    ; sector length                                                                 |                        
0377   0078             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0378   0078             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0379   0078             ;   .fill 6,   $00    ;                                                                               |                        
0380   0078             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0381   0078             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0382   0078             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0383   0078             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0384   0078             ; fdc_128_format_end:
0385   0078             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0386   0078             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0387   0078             fdc_jmptbl:
0388   0078 A0 00         .dw syscall_fdc_restore
0389   007A AC 00         .dw syscall_fdc_step
0390   007C B4 00         .dw syscall_fdc_step_in
0391   007E BC 00         .dw syscall_fdc_step_out
0392   0080 C4 00         .dw syscall_fdc_seek
0393   0082 D2 00         .dw syscall_fdc_format_128
0394   0084 FC 00         .dw syscall_fdc_format_512
0395   0086 D0 00         .dw syscall_fdc_read_addr
0396   0088 26 01         .dw syscall_fdc_read_track
0397   008A 55 01         .dw syscall_fdc_read_sect
0398   008C 8D 01         .dw syscall_fdc_write_sect
0399   008E D1 00         .dw syscall_fdc_force_int
0400   0090 98 00         .dw syscall_fdc_status0
0401   0092 9C 00         .dw syscall_fdc_status1
0402   0094             syscall_fdc:
0403   0094 FD 0A 78 00   jmp [fdc_jmptbl + al]
0404   0098             
0405   0098             syscall_fdc_status0:
0406   0098 1D C1 FF      mov al, [_fdc_status_0]
0407   009B 06            sysret
0408   009C             
0409   009C             syscall_fdc_status1:
0410   009C 1D C8 FF      mov al, [_fdc_stat_cmd]
0411   009F 06            sysret
0412   00A0             
0413   00A0             syscall_fdc_restore:
0414   00A0 07 BF 01      call fdc_wait_not_busy
0415   00A3 F2 C8 FF 0A   mov byte [_fdc_stat_cmd], %00001010
0416   00A7 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
0417   00AB 06            sysret
0418   00AC             
0419   00AC             syscall_fdc_step:
0420   00AC 07 BF 01      call fdc_wait_not_busy
0421   00AF F2 C8 FF 38   mov byte [_fdc_stat_cmd], %00111000
0422   00B3 06            sysret
0423   00B4             
0424   00B4             syscall_fdc_step_in:
0425   00B4 07 BF 01      call fdc_wait_not_busy
0426   00B7 F2 C8 FF 50   mov byte [_fdc_stat_cmd], %01010000
0427   00BB 06            sysret
0428   00BC             
0429   00BC             syscall_fdc_step_out:
0430   00BC 07 BF 01      call fdc_wait_not_busy
0431   00BF F2 C8 FF 78   mov byte [_fdc_stat_cmd], %01111000
0432   00C3 06            sysret
0433   00C4             
0434   00C4             ; bl: desired track
0435   00C4             syscall_fdc_seek:
0436   00C4 07 BF 01      call fdc_wait_not_busy
0437   00C7 FD 3D CB FF   mov [_fdc_data], bl ; set desired track to bl
0438   00CB F2 C8 FF 18   mov byte [_fdc_stat_cmd], %00011000 ; seek command
0439   00CF 06            sysret
0440   00D0             
0441   00D0             syscall_fdc_read_addr:
0442   00D0 06            sysret
0443   00D1             
0444   00D1             syscall_fdc_force_int:
0445   00D1 06            sysret
0446   00D2             
0447   00D2             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0448   00D2             ; in the ram formatting block because they are all set as 00 right now
0449   00D2             ; bl: track number
0450   00D2             syscall_fdc_format_128:
0451   00D2 07 CA 01      call fdc_format_mem_128
0452   00D5 07 BF 01      call fdc_wait_not_busy
0453   00D8 FD 3D C9 FF   mov [_fdc_track], bl
0454   00DC FD 4D A4 25   mov si, transient_area
0455   00E0 F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0456   00E4 07 A2 02      call fdc_wait_64us
0457   00E7             fdc_format_drq_128:
0458   00E7 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0459   00EA 93 01         test al, $01                ; 4
0460   00EC C6 FB 00      jz fdc_format_end_128           ; 8
0461   00EF 93 02         test al, $02                ; 4
0462   00F1 C6 E7 00      jz fdc_format_drq_128           ; 8
0463   00F4 F6            lodsb                       ; 7
0464   00F5 3D CB FF      mov [_fdc_data], al         ; 10   
0465   00F8 0A E7 00      jmp fdc_format_drq_128
0466   00FB             fdc_format_end_128:
0467   00FB 06            sysret
0468   00FC             
0469   00FC             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0470   00FC             ; in the ram formatting block because they are all set as 00 right now
0471   00FC             ; bl: track number
0472   00FC             syscall_fdc_format_512:
0473   00FC 07 36 02      call fdc_format_mem_512
0474   00FF 07 BF 01      call fdc_wait_not_busy
0475   0102 FD 3D C9 FF   mov [_fdc_track], bl
0476   0106 FD 4D A4 25   mov si, transient_area
0477   010A F2 C8 FF FA   mov byte [_fdc_stat_cmd], %11111010 ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0478   010E 07 A2 02      call fdc_wait_64us
0479   0111             fdc_format_drq_512:
0480   0111 1D C8 FF      mov al, [_fdc_stat_cmd]     ; 10
0481   0114 93 01         test al, $01                ; 4
0482   0116 C6 25 01      jz fdc_format_end_512           ; 8
0483   0119 93 02         test al, $02                ; 4
0484   011B C6 11 01      jz fdc_format_drq_512           ; 8
0485   011E F6            lodsb                       ; 7
0486   011F 3D CB FF      mov [_fdc_data], al         ; 10   
0487   0122 0A 11 01      jmp fdc_format_drq_512
0488   0125             fdc_format_end_512:
0489   0125 06            sysret
0490   0126             
0491   0126             ; di : destination in user space
0492   0126             ; a  : returns number of read bytes
0493   0126             syscall_fdc_read_track:
0494   0126 07 BF 01      call fdc_wait_not_busy
0495   0129 E3            push di
0496   012A FD 4F A4 25   mov di, transient_area
0497   012E F2 C8 FF E8   mov byte [_fdc_stat_cmd], %11101000
0498   0132 07 A2 02      call fdc_wait_64us
0499   0135             fdc_read_track_l0: ; for each byte, we need to wait for drq to be high
0500   0135 1D C8 FF      mov al, [_fdc_stat_cmd]      ; 
0501   0138 93 01         test al, $01                ; check busy bit
0502   013A C6 49 01      jz fdc_read_track_end
0503   013D 93 02         test al, $02                ; check drq bit
0504   013F C6 35 01      jz fdc_read_track_l0
0505   0142 1D CB FF      mov al, [_fdc_data]     ; 
0506   0145 F7            stosb
0507   0146 0A 35 01      jmp fdc_read_track_l0
0508   0149             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0509   0149             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0510   0149             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0511   0149             fdc_read_track_end:
0512   0149 50            mov a, di
0513   014A 5F A4 25      sub a, transient_area
0514   014D F0            pop di
0515   014E FD 4D A4 25   mov si, transient_area
0516   0152 39            mov c, a  ; copy track over to user space
0517   0153 03            store
0518   0154 06            sysret
0519   0155             
0520   0155             ; sector in bl
0521   0155             ; track in bh
0522   0155             ; di = user space destination
0523   0155             syscall_fdc_read_sect:
0524   0155 07 BF 01      call fdc_wait_not_busy
0525   0158 E3            push di
0526   0159 FD 3D CA FF   mov [_fdc_sector], bl
0527   015D 30            mov bl, bh
0528   015E FD 3D C9 FF   mov [_fdc_track], bl
0529   0162 F2 C8 FF 88   mov byte [_fdc_stat_cmd], %10001000
0530   0166 07 A2 02      call fdc_wait_64us
0531   0169 FD 4F A4 25   mov di, transient_area
0532   016D             fdc_read_sect_l0: ; for each byte, we need to wait for drq to be high
0533   016D 1D C8 FF      mov al, [_fdc_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0534   0170 93 01         test al, $01                ; check drq bit
0535   0172 C6 81 01      jz fdc_read_sect_end
0536   0175 93 02         test al, $02                ; check drq bit
0537   0177 C6 6D 01      jz fdc_read_sect_l0
0538   017A 1D CB FF      mov al, [_fdc_data]     ; 
0539   017D F7            stosb
0540   017E 0A 6D 01      jmp fdc_read_sect_l0
0541   0181             fdc_read_sect_end:
0542   0181 50            mov a, di
0543   0182 5F A4 25      sub a, transient_area
0544   0185 F0            pop di
0545   0186 FD 4D A4 25   mov si, transient_area
0546   018A 39            mov c, a  ; copy sector over to user space
0547   018B 03            store
0548   018C 06            sysret
0549   018D             
0550   018D             ; sector size in c
0551   018D             ; sector in bl
0552   018D             ; track in bh
0553   018D             ; data pointer in si
0554   018D             syscall_fdc_write_sect:
0555   018D 07 BF 01      call fdc_wait_not_busy
0556   0190 D9            push c
0557   0191 FD 3D CA FF   mov [_fdc_sector], bl
0558   0195 30            mov bl, bh
0559   0196 FD 3D C9 FF   mov [_fdc_track], bl
0560   019A FD 4F A4 25   mov di, transient_area    ; si = data source, di = destination 
0561   019E 04            load                    ; transfer data to kernel space!
0562   019F FD 4D A4 25   mov si, transient_area
0563   01A3 F2 C8 FF AA   mov byte [_fdc_stat_cmd], %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0564   01A7 07 A2 02      call fdc_wait_64us
0565   01AA             fdc_write_sect_l0: ; for each byte, we need to wait for drq to be high
0566   01AA 1D C8 FF      mov al, [_fdc_stat_cmd]         ; 10
0567   01AD 93 01         test al, $01                    ; 4
0568   01AF C6 BE 01      jz fdc_write_sect_end           ; 8
0569   01B2 93 02         test al, $02                    ; 4
0570   01B4 C6 AA 01      jz fdc_write_sect_l0            ; 8
0571   01B7 F6            lodsb                           ; 7
0572   01B8 3D CB FF      mov [_fdc_data], al             ; 10   
0573   01BB 0A AA 01      jmp fdc_write_sect_l0
0574   01BE             fdc_write_sect_end:
0575   01BE 06            sysret
0576   01BF             
0577   01BF             fdc_wait_not_busy:
0578   01BF DB            push al
0579   01C0 1D C8 FF      mov al, [_fdc_stat_cmd]   
0580   01C3 93 01         test al, $01               
0581   01C5 C7 BF 01      jnz fdc_wait_not_busy          
0582   01C8 E8            pop al
0583   01C9 09            ret
0584   01CA             
0585   01CA             fdc_format_mem_128:
0586   01CA 3B 01 00      mov d, 1
0587   01CD FD 4F A4 25   mov di, transient_area
0588   01D1             ; 40 * FF
0589   01D1 38 28 00      mov c, 40
0590   01D4 19 FF         mov al, $ff
0591   01D6             fdc_l0: 
0592   01D6 F7            stosb
0593   01D7 7E            dec c
0594   01D8 C7 D6 01      jnz fdc_l0
0595   01DB             ; 6 * 00
0596   01DB             fdc_inner_loop:
0597   01DB 38 06 00      mov c, 6
0598   01DE 19 00         mov al, $00
0599   01E0             fdc_l1:
0600   01E0 F7            stosb
0601   01E1 7E            dec c
0602   01E2 C7 E0 01      jnz fdc_l1
0603   01E5             ; FE address mark
0604   01E5             fdc_l2:
0605   01E5 19 FE         mov al, $fe
0606   01E7 F7            stosb
0607   01E8             ; track number
0608   01E8             fdc_l3:
0609   01E8 19 00         mov al, $00
0610   01EA F7            stosb
0611   01EB             ; side number
0612   01EB             fdc_l4:
0613   01EB 19 00         mov al, $00
0614   01ED F7            stosb
0615   01EE             ; sector number
0616   01EE             fdc_l5:
0617   01EE 13            mov a, d
0618   01EF F7            stosb
0619   01F0             ; sector length 128 bytes
0620   01F0             fdc_l6:
0621   01F0 19 00         mov al, $00
0622   01F2 F7            stosb
0623   01F3             ; 2 crc's
0624   01F3             fdc_l7:
0625   01F3 19 F7         mov al, $f7
0626   01F5 F7            stosb
0627   01F6             ; 11 times $ff
0628   01F6 38 0B 00      mov c, 11
0629   01F9 19 FF         mov al, $ff
0630   01FB             fdc_l8:
0631   01FB F7            stosb
0632   01FC 7E            dec c
0633   01FD C7 FB 01      jnz fdc_l8
0634   0200             ; 6 times 00
0635   0200 38 06 00      mov c, 6
0636   0203 19 00         mov al, $00
0637   0205             fdc_l9:
0638   0205 F7            stosb
0639   0206 7E            dec c
0640   0207 C7 05 02      jnz fdc_l9
0641   020A             ; FB data address mark
0642   020A 19 FB         mov al, $fb
0643   020C             fdc_l10:
0644   020C F7            stosb
0645   020D             ; 128 bytes sector data
0646   020D 38 80 00      mov c, 128
0647   0210 19 E5         mov al, $E5
0648   0212             fdc_l11:
0649   0212 F7            stosb
0650   0213 7E            dec c
0651   0214 C7 12 02      jnz fdc_l11
0652   0217             ; 2 crc's
0653   0217             fdc_l12:
0654   0217 19 F7         mov al, $f7
0655   0219 F7            stosb
0656   021A             ; 10 * $FF
0657   021A 38 0A 00      mov c, 10
0658   021D 19 FF         mov al, $ff
0659   021F             fdc_l13:
0660   021F F7            stosb
0661   0220 7E            dec c
0662   0221 C7 1F 02      jnz fdc_l13
0663   0224             ; check whether we did this 16 times
0664   0224 79            inc d
0665   0225 C5 11 00      cmp d, 17
0666   0228 C7 DB 01      jne fdc_inner_loop
0667   022B             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0668   022B 38 F4 01      mov c, 500
0669   022E 19 FF         mov al, $ff
0670   0230             fdc_format_footer:
0671   0230             fdc_footer_drq_loop:
0672   0230 F7            stosb
0673   0231 7E            dec c
0674   0232 C7 30 02      jnz fdc_footer_drq_loop
0675   0235 09            ret
0676   0236             
0677   0236             fdc_format_mem_512:
0678   0236 3B 01 00      mov d, 1
0679   0239 FD 4F A4 25   mov di, transient_area
0680   023D             ; 40 * FF
0681   023D 38 28 00      mov c, 40
0682   0240 19 FF         mov al, $ff
0683   0242             fdc_512_l0: 
0684   0242 F7            stosb
0685   0243 7E            dec c
0686   0244 C7 42 02      jnz fdc_512_l0
0687   0247             ; 6 * 00
0688   0247             fdc_512_inner_loop:
0689   0247 38 06 00      mov c, 6
0690   024A 19 00         mov al, $00
0691   024C             fdc_512_l1:
0692   024C F7            stosb
0693   024D 7E            dec c
0694   024E C7 4C 02      jnz fdc_512_l1
0695   0251             ; FE address mark
0696   0251             fdc_512_l2:
0697   0251 19 FE         mov al, $fe
0698   0253 F7            stosb
0699   0254             ; track number
0700   0254             fdc_512_l3:
0701   0254 19 00         mov al, $00
0702   0256 F7            stosb
0703   0257             ; side number
0704   0257             fdc_512_l4:
0705   0257 19 00         mov al, $00
0706   0259 F7            stosb
0707   025A             ; sector number
0708   025A             fdc_512_l5:
0709   025A 13            mov a, d
0710   025B F7            stosb
0711   025C             ; sector length 512 bytes
0712   025C             fdc_512_l6:
0713   025C 19 02         mov al, $02
0714   025E F7            stosb
0715   025F             ; 2 crc's
0716   025F             fdc_512_l7:
0717   025F 19 F7         mov al, $f7
0718   0261 F7            stosb
0719   0262             ; 11 times $ff
0720   0262 38 0B 00      mov c, 11
0721   0265 19 FF         mov al, $ff
0722   0267             fdc_512_l8:
0723   0267 F7            stosb
0724   0268 7E            dec c
0725   0269 C7 67 02      jnz fdc_512_l8
0726   026C             ; 6 times 00
0727   026C 38 06 00      mov c, 6
0728   026F 19 00         mov al, $00
0729   0271             fdc_512_l9:
0730   0271 F7            stosb
0731   0272 7E            dec c
0732   0273 C7 71 02      jnz fdc_512_l9
0733   0276             ; FB data address mark
0734   0276 19 FB         mov al, $fb
0735   0278             fdc_512_l10:
0736   0278 F7            stosb
0737   0279             ; 128 bytes sector data
0738   0279 38 00 02      mov c, 512
0739   027C 19 E5         mov al, $E5
0740   027E             fdc_512_l11:
0741   027E F7            stosb
0742   027F 7E            dec c
0743   0280 C7 7E 02      jnz fdc_512_l11
0744   0283             ; 2 crc's
0745   0283             fdc_512_l12:
0746   0283 19 F7         mov al, $f7
0747   0285 F7            stosb
0748   0286             ; 10 * $FF
0749   0286 38 0A 00      mov c, 10
0750   0289 19 FF         mov al, $ff
0751   028B             fdc_512_l13:
0752   028B F7            stosb
0753   028C 7E            dec c
0754   028D C7 8B 02      jnz fdc_512_l13
0755   0290             ; check whether we did this 16 times
0756   0290 79            inc d
0757   0291 C5 06 00      cmp d, 6
0758   0294 C7 47 02      jne fdc_512_inner_loop
0759   0297             ; 500 bytes of FF for end filler. wd1770 writes these until it finishes, so the number varies. usually it writes ~450 bytes
0760   0297 38 F4 01      mov c, 500
0761   029A 19 FF         mov al, $ff
0762   029C             fdc_512_format_footer:
0763   029C             fdc_512_footer_drq_loop:
0764   029C F7            stosb
0765   029D 7E            dec c
0766   029E C7 9C 02      jnz fdc_512_footer_drq_loop
0767   02A1 09            ret
0768   02A2             
0769   02A2             ; fetch is 2 cycles long when 'display_reg_load' is false.
0770   02A2             ; 64us amounts to 160 cycles of the 2.5mhz clock
0771   02A2             ; call u16 is 14 cycles long
0772   02A2             ; 160 - 5 - 14 = 
0773   02A2             fdc_wait_64us:
0774   02A2 3A 0D         mov cl, 13                       ; 5 cycles
0775   02A4             fdc_wait_64_loop:
0776   02A4 81            dec cl                           ; 3 cycles
0777   02A5 C7 A4 02      jnz fdc_wait_64_loop             ; 8 cycles
0778   02A8 09            ret
0779   02A9             
0780   02A9             ; ------------------------------------------------------------------------------------------------------------------;
0781   02A9             ; system syscalls
0782   02A9             ; ------------------------------------------------------------------------------------------------------------------;
0783   02A9             system_jmptbl:
0784   02A9 DF 02         .dw system_uname
0785   02AB E6 02         .dw system_whoami
0786   02AD B9 02         .dw system_setparam
0787   02AF BC 02         .dw system_bootloader_install
0788   02B1 B7 02         .dw system_getparam
0789   02B3             syscall_system:
0790   02B3 FD 0A A9 02   jmp [system_jmptbl + al]
0791   02B7             
0792   02B7             ; param register address in register d
0793   02B7             ; param value in register bl
0794   02B7             system_getparam:
0795   02B7 32            mov bl, [d]
0796   02B8 06            sysret
0797   02B9             
0798   02B9             ; param register address in register d
0799   02B9             ; param value in register bl
0800   02B9             system_setparam:
0801   02B9 FD 3E         mov [d], bl
0802   02BB 06            sysret
0803   02BC             
0804   02BC             ; kernel LBA address in 'b'
0805   02BC             system_bootloader_install:
0806   02BC D8            push b
0807   02BD 26 00 00      mov b, 0
0808   02C0 38 00 00      mov c, 0
0809   02C3 22 01         mov ah, $01                 ; 1 sector
0810   02C5 3B A4 25      mov d, transient_area
0811   02C8 07 E3 05      call ide_read_sect          ; read sector
0812   02CB E5            pop b
0813   02CC FD 44 FE 01   mov [d + 510], b            ; update LBA address
0814   02D0 26 00 00      mov b, 0
0815   02D3 38 00 00      mov c, 0
0816   02D6 22 01         mov ah, $01                 ; 1 sector
0817   02D8 3B A4 25      mov d, transient_area
0818   02DB 07 09 06      call ide_write_sect         ; write sector
0819   02DE 06            sysret
0820   02DF             
0821   02DF             system_uname:
0822   02DF 3B 54 18      mov d, s_uname
0823   02E2 07 0D 13      call _puts
0824   02E5 06            sysret
0825   02E6             
0826   02E6             system_whoami:
0827   02E6 06            sysret
0828   02E7             
0829   02E7             ; reboot system
0830   02E7             syscall_reboot:
0831   02E7 FD D7 FF FF   push word $ffff 
0832   02EB FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0833   02EE FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0834   02F2 06            sysret
0835   02F3             
0836   02F3             ;------------------------------------------------------------------------------------------------------;;
0837   02F3             ; switch to another process
0838   02F3             ; inputs:
0839   02F3             ; al = new process number
0840   02F3             ;------------------------------------------------------------------------------------------------------;;
0841   02F3             syscall_resume_proc:
0842   02F3 FD 78         mov g, a                            ; save the process number
0843   02F5 4B            pusha                               ; save all registers into kernel stack
0844   02F6 22 00         mov ah, 0
0845   02F8 1D 3E 18      mov al, [active_proc_index]
0846   02FB FD 99         shl a              ; x2
0847   02FD B7 7B 10      mov a, [proc_table_convert + a]     ; get process state start index
0848   0300 4F            mov di, a
0849   0301 48            mov a, sp
0850   0302 77            inc a
0851   0303 4D            mov si, a
0852   0304 38 14 00      mov c, 20
0853   0307 FD F5         rep movsb                           ; save process state!
0854   0309             ; restore kernel stack position to point before interrupt arrived
0855   0309 51 14 00      add sp, 20
0856   030C             ; now load the new process number!
0857   030C FD 12         mov a, g                            ; retrieve the process number argument that was saved in the beginning
0858   030E 3D 3E 18      mov [active_proc_index], al         ; set new active proc
0859   0311             ; calculate lut entry for next process
0860   0311 22 00         mov ah, 0
0861   0313 FD 99         shl a                               ; x2
0862   0315 B7 7B 10      mov a, [proc_table_convert + a]     ; get process state start index  
0863   0318 4D            mov si, a                           ; source is proc state block
0864   0319 48            mov a, sp
0865   031A 5F 13 00      sub a, 19
0866   031D 4F            mov di, a                           ; destination is kernel stack
0867   031E             ; restore sp
0868   031E 7D            dec a
0869   031F 47            mov sp, a
0870   0320 38 14 00      mov c, 20
0871   0323 FD F5         rep movsb
0872   0325             ; set vm process
0873   0325 1D 3E 18      mov al, [active_proc_index]
0874   0328 01            setptb
0875   0329 4C            popa
0876   032A 06            sysret
0877   032B             
0878   032B             ;------------------------------------------------------------------------------------------------------;;
0879   032B             ; list processes
0880   032B             ;------------------------------------------------------------------------------------------------------;;
0881   032B             syscall_list_procs:
0882   032B 3B 75 18      mov d, s_ps_header
0883   032E 07 0D 13      call _puts
0884   0331 3B 15 1B      mov d, proc_availab_table + 1
0885   0334 38 01 00      mov c, 1
0886   0337             list_procs_l0:  
0887   0337 BD 01         cmp byte[d], 1
0888   0339 C7 5D 03      jne list_procs_next
0889   033C 2D            mov b, d
0890   033D 61 14 1B      sub b, proc_availab_table
0891   0340 FD 9F 05      shl b, 5
0892   0343 DA            push d
0893   0344 D8            push b
0894   0345 28            mov b, c
0895   0346 07 AD 13      call print_u8x
0896   0349 22 20         mov ah, ' '
0897   034B 07 E1 11      call _putchar
0898   034E 07 E1 11      call _putchar
0899   0351 E5            pop b
0900   0352 74            mov d, b
0901   0353 58 24 1B      add d, proc_names
0902   0356 07 0D 13      call _puts
0903   0359 07 BA 12      call printnl
0904   035C E7            pop d
0905   035D             list_procs_next:
0906   035D 79            inc d
0907   035E 78            inc c
0908   035F C2 09 00      cmp c, 9
0909   0362 C7 37 03      jne list_procs_l0
0910   0365             list_procs_end:
0911   0365 06            sysret
0912   0366             
0913   0366             ; ------------------------------------------------------------------------------------------------------------------;
0914   0366             ; exceptions code block
0915   0366             ; ------------------------------------------------------------------------------------------------------------------;
0916   0366             ; privilege exception
0917   0366             ; ------------------------------------------------------------------------------------------------------------------;
0918   0366             trap_privilege:
0919   0366 0A E7 02      jmp syscall_reboot
0920   0369 DA            push d
0921   036A 3B C4 18      mov d, s_priviledge
0922   036D 07 0D 13      call _puts
0923   0370 E7            pop d
0924   0371 06            sysret
0925   0372             
0926   0372             ; ------------------------------------------------------------------------------------------------------------------;
0927   0372             ; breakpoint
0928   0372             ; important: values in the stack are being pushed in big endian. i.e.: msb at low address
0929   0372             ; and lsb at high address. *** need to correct this in the microcode and make it little endian again ***
0930   0372             ; ------------------------------------------------------------------------------------------------------------------;
0931   0372             syscall_break:
0932   0372 4B            pusha
0933   0373             syscall_break_prompt:
0934   0373 3B 2D 04      mov d, s_break1
0935   0376 07 0D 13      call _puts
0936   0379 07 BA 12      call printnl
0937   037C 07 0F 14      call scan_u16d
0938   037F AF 00 00      cmp a, 0
0939   0382 C6 8D 03      je syscall_break_regs
0940   0385 AF 01 00      cmp a, 1
0941   0388 C6 B0 03      je syscall_break_mem
0942   038B             syscall_break_end:  
0943   038B 4C            popa
0944   038C 06            sysret
0945   038D             syscall_break_regs:
0946   038D 48            mov a, sp
0947   038E 53 0E 00      add a, 14               ; back-track 7 registers
0948   0391 3C            mov d, a
0949   0392 3A 07         mov cl, 7
0950   0394             syscall_regs_l0:
0951   0394 2A            mov b, [d]
0952   0395 FD AB         swp b
0953   0397 07 69 13      call print_u16x         ; print register value
0954   039A 07 BA 12      call printnl
0955   039D 63 02 00      sub d, 2
0956   03A0 71 01         sub cl, 1
0957   03A2 C3 00         cmp cl, 0
0958   03A4 C7 94 03      jne syscall_regs_l0
0959   03A7 0A 73 03      jmp syscall_break_prompt
0960   03AA 07 BA 12      call printnl
0961   03AD 0A 73 03      jmp syscall_break_prompt
0962   03B0             syscall_break_mem:
0963   03B0 07 BA 12      call printnl
0964   03B3 07 8B 13      call scan_u16x
0965   03B6 4D            mov si, a               ; data source from user space
0966   03B7 FD 4F A4 23   mov di, scrap_sector    ; destination in kernel space
0967   03BB 38 00 02      mov c, 512
0968   03BE 04            load                    ; transfer data to kernel space!
0969   03BF 3B A4 23      mov d, scrap_sector     ; dump pointer in d
0970   03C2 38 00 00      mov c, 0
0971   03C5             dump_loop:
0972   03C5 84            mov al, cl
0973   03C6 87 0F         and al, $0f
0974   03C8 C6 16 04      jz print_base
0975   03CB             back:
0976   03CB 1E            mov al, [d]             ; read byte
0977   03CC 2F            mov bl, al
0978   03CD 07 AD 13      call print_u8x
0979   03D0 10 00 20      mov a, $2000
0980   03D3 05 03         syscall sys_io          ; space
0981   03D5 84            mov al, cl
0982   03D6 87 0F         and al, $0f
0983   03D8 B9 0F         cmp al, $0f
0984   03DA C6 EB 03      je print_ascii
0985   03DD             back1:
0986   03DD 79            inc d
0987   03DE 78            inc c
0988   03DF C2 00 02      cmp c, 512
0989   03E2 C7 C5 03      jne dump_loop
0990   03E5 07 BA 12      call printnl
0991   03E8 0A 73 03      jmp syscall_break_prompt  ; go to syscall_break return point
0992   03EB             print_ascii:
0993   03EB 10 00 20      mov a, $2000
0994   03EE 05 03         syscall sys_io
0995   03F0 63 10 00      sub d, 16
0996   03F3 26 10 00      mov b, 16
0997   03F6             print_ascii_l:
0998   03F6 79            inc d
0999   03F7 1E            mov al, [d]               ; read byte
1000   03F8 B9 20         cmp al, $20
1001   03FA C8 02 04      jlu dot
1002   03FD B9 7E         cmp al, $7e
1003   03FF D0 0A 04      jleu ascii
1004   0402             dot:
1005   0402 10 00 2E      mov a, $2e00
1006   0405 05 03         syscall sys_io
1007   0407 0A 0F 04      jmp ascii_continue
1008   040A             ascii:
1009   040A 23            mov ah, al
1010   040B 19 00         mov al, 0
1011   040D 05 03         syscall sys_io
1012   040F             ascii_continue:
1013   040F FD A9 F6 03   loopb print_ascii_l
1014   0413 0A DD 03      jmp back1
1015   0416             print_base:
1016   0416 07 BA 12      call printnl
1017   0419 2D            mov b, d
1018   041A 61 A4 23      sub b, scrap_sector      ; remove this later and fix address bases which display incorrectly
1019   041D 07 69 13      call print_u16x          ; display row
1020   0420 10 00 3A      mov a, $3a00
1021   0423 05 03         syscall sys_io
1022   0425 10 00 20      mov a, $2000
1023   0428 05 03         syscall sys_io
1024   042A 0A CB 03      jmp back
1025   042D             
1026   042D             s_break1:  
1027   042D 0A 64 65 62   .db "\ndebugger entry point.\n"
1027   0431 75 67 67 65 
1027   0435 72 20 65 6E 
1027   0439 74 72 79 20 
1027   043D 70 6F 69 6E 
1027   0441 74 2E 0A 
1028   0444 30 2E 20 73   .db "0. show registers\n"
1028   0448 68 6F 77 20 
1028   044C 72 65 67 69 
1028   0450 73 74 65 72 
1028   0454 73 0A 
1029   0456 31 2E 20 73   .db "1. show 512b ram block\n"
1029   045A 68 6F 77 20 
1029   045E 35 31 32 62 
1029   0462 20 72 61 6D 
1029   0466 20 62 6C 6F 
1029   046A 63 6B 0A 
1030   046D 32 2E 20 63   .db "2. continue execution", 0
1030   0471 6F 6E 74 69 
1030   0475 6E 75 65 20 
1030   0479 65 78 65 63 
1030   047D 75 74 69 6F 
1030   0481 6E 00 
1031   0483             
1032   0483             ; ------------------------------------------------------------------------------------------------------------------;
1033   0483             ; divide by zero exception
1034   0483             ; ------------------------------------------------------------------------------------------------------------------;
1035   0483             trap_div_zero:
1036   0483 D7            push a
1037   0484 DA            push d
1038   0485 E1            pushf
1039   0486 3B DB 18      mov d, s_divzero
1040   0489 07 0D 13      call _puts
1041   048C EE            popf
1042   048D E7            pop d
1043   048E E4            pop a
1044   048F 06            sysret ; enable interrupts
1045   0490             
1046   0490             ; ------------------------------------------------------------------------------------------------------------------;
1047   0490             ; undefined opcode exception
1048   0490             ; ------------------------------------------------------------------------------------------------------------------;
1049   0490             trap_undef_opcode:
1050   0490 06            sysret
1051   0491             
1052   0491             ; ------------------------------------------------------------------------------------------------------------------;
1053   0491             ; real-time clock services syscall
1054   0491             ; rtc i/o bank = ffa0 to ffaf
1055   0491             ; ffa0 to ffa7 is scratch ram
1056   0491             ; control register at $ffa8 [ w | r | s | cal4..cal0 ]
1057   0491             ; al = 0..6 -> get
1058   0491             ; al = 7..d -> set
1059   0491             ; ------------------------------------------------------------------------------------------------------------------;
1060   0491             syscall_rtc:
1061   0491 DB            push al
1062   0492 DA            push d
1063   0493 B9 06         cmp al, 6
1064   0495 D1 AA 04      jgu syscall_rtc_set
1065   0498             syscall_rtc_get:
1066   0498 6A A9         add al, $a9             ; generate rtc address to get to address a9 of clock
1067   049A 22 FF         mov ah, $ff    
1068   049C 3C            mov d, a                ; get to ffa9 + offset
1069   049D F2 A8 FF 40   mov byte[$ffa8], $40    ; set r bit to 1
1070   04A1 1E            mov al, [d]             ; get data
1071   04A2 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset r bit
1072   04A6 23            mov ah, al
1073   04A7 E7            pop d
1074   04A8 E8            pop al
1075   04A9 06            sysret
1076   04AA             syscall_rtc_set:
1077   04AA DD            push bl
1078   04AB 99            mov bl, ah              ; set data aside
1079   04AC 6A A2         add al, $a2             ; generate rtc address to get to address a9 of clock
1080   04AE 22 FF         mov ah, $ff    
1081   04B0 3C            mov d, a                ; get to ffa9 + offset
1082   04B1 1B            mov al, bl              ; get data back
1083   04B2 F2 A8 FF 80   mov byte[$ffa8], $80    ; set w bit to 1
1084   04B6 3E            mov [d], al             ; set data
1085   04B7 F2 A8 FF 00   mov byte[$ffa8], 0      ; reset write bit
1086   04BB EA            pop bl
1087   04BC E7            pop d
1088   04BD E8            pop al
1089   04BE 06            sysret
1090   04BF             
1091   04BF             datetime_serv_tbl:
1092   04BF C7 04         .dw print_date
1093   04C1 3B 05         .dw set_date
1094   04C3             syscall_datetime:
1095   04C3 FD 0A BF 04   jmp [datetime_serv_tbl + al]      
1096   04C7             print_date:
1097   04C7 10 00 0D      mov a, $0d00           ; print carriage return char
1098   04CA 19 03         mov al, 3
1099   04CC 05 01         syscall sys_rtc        ; get week
1100   04CE 1A            mov al, ah
1101   04CF 22 00         mov ah, 0
1102   04D1 FD 9D 02      shl a, 2          
1103   04D4 3B 65 19      mov d, s_week
1104   04D7 59            add d, a
1105   04D8 07 0D 13      call _puts
1106   04DB 10 00 20      mov a, $2000
1107   04DE 05 03         syscall sys_io         ; display ' '
1108   04E0 19 04         mov al, 4
1109   04E2 05 01         syscall sys_rtc        ; get day
1110   04E4 99            mov bl, ah
1111   04E5 07 AD 13      call print_u8x
1112   04E8 10 00 20      mov a, $2000
1113   04EB 05 03         syscall sys_io         ; display ' '
1114   04ED             ; there is a problem with the month displaying
1115   04ED             ; the month is stored as bcd. so when retrieving the month, the value will be in binary
1116   04ED             ; even though it is to be understood as bcd.
1117   04ED             ; when retrieving the value and adding the string table address offset the value will go overboard!  
1118   04ED 19 05         mov al, 05
1119   04EF 05 01         syscall sys_rtc        ; get month
1120   04F1 1A            mov al, ah
1121   04F2 22 00         mov ah, 0
1122   04F4 FD 9D 02      shl a, 2          
1123   04F7 3B 31 19      mov d, s_months
1124   04FA 59            add d, a
1125   04FB 07 0D 13      call _puts
1126   04FE 10 00 20      mov a, $2000
1127   0501 05 03         syscall sys_io         ; display ' '
1128   0503 2E 20         mov bl, $20
1129   0505 07 AD 13      call print_u8x         ; print 20 for year prefix
1130   0508 19 06         mov al, 06
1131   050A 05 01         syscall sys_rtc        ; get year
1132   050C 99            mov bl, ah
1133   050D 07 AD 13      call print_u8x
1134   0510 10 00 20      mov a, $2000  
1135   0513 05 03         syscall sys_io         ; display ' '
1136   0515 19 02         mov al, 2
1137   0517 05 01         syscall sys_rtc        ; get hours
1138   0519 99            mov bl, ah
1139   051A 07 AD 13      call print_u8x
1140   051D 10 00 3A      mov a, $3a00    
1141   0520 05 03         syscall sys_io         ; display ':'
1142   0522 19 01         mov al, 01
1143   0524 05 01         syscall sys_rtc        ; get minutes
1144   0526 99            mov bl, ah
1145   0527 07 AD 13      call print_u8x
1146   052A 10 00 3A      mov a, $3a00  
1147   052D 05 03         syscall sys_io         ; display ':'
1148   052F 19 00         mov al, 0
1149   0531 05 01         syscall sys_rtc        ; get seconds
1150   0533 99            mov bl, ah
1151   0534 07 AD 13      call print_u8x
1152   0537 07 BA 12      call printnl
1153   053A 06            sysret
1154   053B             set_date:
1155   053B 3B F6 18      mov d, s_set_year
1156   053E 07 0D 13      call _puts
1157   0541 07 F8 13      call scan_u8x          ; read integer into a
1158   0544 FD 9D 08      shl a, 8               ; only al used, move to ah
1159   0547 19 0D         mov al, 0dh            ; set rtc year
1160   0549 05 01         syscall sys_rtc        ; set rtc
1161   054B 3B FD 18      mov d, s_set_month
1162   054E 07 0D 13      call _puts
1163   0551 07 F8 13      call scan_u8x          ; read integer into a
1164   0554 FD 9D 08      shl a, 8               ; only al used, move to ah
1165   0557 19 0C         mov al, 0ch            ; set rtc month
1166   0559 05 01         syscall sys_rtc        ; set rtc
1167   055B 3B 05 19      mov d, s_set_day
1168   055E 07 0D 13      call _puts
1169   0561 07 F8 13      call scan_u8x          ; read integer into a
1170   0564 FD 9D 08      shl a, 8               ; only al used, move to ah
1171   0567 19 0B         mov al, 0bh            ; set rtc month
1172   0569 05 01         syscall sys_rtc        ; set rtc
1173   056B 3B 0B 19      mov d, s_set_week
1174   056E 07 0D 13      call _puts
1175   0571 07 F8 13      call scan_u8x          ; read integer into a
1176   0574 FD 9D 08      shl a, 8               ; only al used, move to ah
1177   0577 19 0A         mov al, 0ah            ; set rtc month
1178   0579 05 01         syscall sys_rtc        ; set rtc
1179   057B 3B 15 19      mov d, s_set_hours
1180   057E 07 0D 13      call _puts
1181   0581 07 F8 13      call scan_u8x          ; read integer into a
1182   0584 FD 9D 08      shl a, 8               ; only al used, move to ah
1183   0587 19 09         mov al, 09h            ; set rtc month
1184   0589 05 01         syscall sys_rtc        ; set rtc
1185   058B 3B 1D 19      mov d, s_set_minutes
1186   058E 07 0D 13      call _puts
1187   0591 07 F8 13      call scan_u8x          ; read integer into a
1188   0594 FD 9D 08      shl a, 8               ; only al used, move to ah
1189   0597 19 08         mov al, 08h            ; set rtc month
1190   0599 05 01         syscall sys_rtc        ; set rtc
1191   059B 3B 27 19      mov d, s_set_seconds
1192   059E 07 0D 13      call _puts
1193   05A1 07 F8 13      call scan_u8x          ; read integer into a
1194   05A4 FD 9D 08      shl a, 8               ; only al used, move to ah
1195   05A7 19 07         mov al, 07h            ; set rtc month
1196   05A9 05 01         syscall sys_rtc        ; set rtc
1197   05AB 06            sysret
1198   05AC             
1199   05AC             ; ------------------------------------------------------------------------------------------------------------------;
1200   05AC             ; ide services syscall
1201   05AC             ; al = option
1202   05AC             ; 0 = ide reset, 1 = ide sleep, 2 = read sector, 3 = write sector
1203   05AC             ; ide read/write sector
1204   05AC             ; 512 bytes
1205   05AC             ; user buffer pointer in d
1206   05AC             ; ah = number of sectors
1207   05AC             ; cb = lba bytes 3..0
1208   05AC             ; ------------------------------------------------------------------------------------------------------------------;
1209   05AC             ide_serv_tbl:
1210   05AC B8 05         .dw ide_reset
1211   05AE CC 05         .dw ide_sleep
1212   05B0 DB 05         .dw ide_read_sect_wrapper
1213   05B2 DF 05         .dw ide_write_sect_wrapper
1214   05B4             syscall_ide:
1215   05B4 FD 0A AC 05   jmp [ide_serv_tbl + al]    
1216   05B8             
1217   05B8             ide_reset:      
1218   05B8 F2 D7 FF 04   mov byte[_ide_r7], 4            ; reset ide
1219   05BC 07 65 06      call ide_wait                   ; wait for ide ready             
1220   05BF F2 D6 FF E0   mov byte[_ide_r6], $e0          ; lba3= 0, master, mode= lba        
1221   05C3 F2 D1 FF 01   mov byte[_ide_r1], 1            ; 8-bit transfers      
1222   05C7 F2 D7 FF EF   mov byte[_ide_r7], $ef          ; set feature command
1223   05CB 06            sysret
1224   05CC             ide_sleep:
1225   05CC 07 65 06      call ide_wait                   ; wait for ide ready             
1226   05CF F2 D6 FF 40   mov byte [_ide_r6], %01000000   ; lba[3:0](reserved), bit 6=1
1227   05D3 F2 D7 FF E6   mov byte [_ide_r7], $e6         ; sleep command
1228   05D7 07 65 06      call ide_wait                   ; wait for ide ready
1229   05DA 06            sysret
1230   05DB             ide_read_sect_wrapper:
1231   05DB 07 E3 05      call ide_read_sect
1232   05DE 06            sysret
1233   05DF             ide_write_sect_wrapper:
1234   05DF 07 09 06      call ide_write_sect
1235   05E2 06            sysret
1236   05E3             ide_read_sect:
1237   05E3 1A            mov al, ah
1238   05E4 24            mov ah, bl
1239   05E5 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1240   05E8 1C            mov al, bh
1241   05E9 3D D4 FF      mov [_ide_r4], al
1242   05EC 12            mov a, c
1243   05ED 3D D5 FF      mov [_ide_r5], al
1244   05F0 1A            mov al, ah
1245   05F1 87 0F         and al, %00001111
1246   05F3 8B E0         or al, %11100000                ; mode lba, master
1247   05F5 3D D6 FF      mov [_ide_r6], al
1248   05F8             ide_read_sect_wait:
1249   05F8 1D D7 FF      mov al, [_ide_r7]  
1250   05FB 87 80         and al, $80                     ; busy flag
1251   05FD C7 F8 05      jnz ide_read_sect_wait
1252   0600 19 20         mov al, $20
1253   0602 3D D7 FF      mov [_ide_r7], al               ; read sector cmd
1254   0605 07 2F 06      call ide_read  
1255   0608 09            ret
1256   0609             ide_write_sect:
1257   0609 1A            mov al, ah
1258   060A 24            mov ah, bl
1259   060B 42 D2 FF      mov [_ide_r2], a                ; number of sectors (0..255)
1260   060E 1C            mov al, bh
1261   060F 3D D4 FF      mov [_ide_r4], al
1262   0612 12            mov a, c
1263   0613 3D D5 FF      mov [_ide_r5], al
1264   0616 1A            mov al, ah
1265   0617 87 0F         and al, %00001111
1266   0619 8B E0         or al, %11100000                ; mode lba, master
1267   061B 3D D6 FF      mov [_ide_r6], al
1268   061E             ide_write_sect_wait:
1269   061E 1D D7 FF      mov al, [_ide_r7]  
1270   0621 87 80         and al, $80                     ; busy flag
1271   0623 C7 1E 06      jnz ide_write_sect_wait
1272   0626 19 30         mov al, $30
1273   0628 3D D7 FF      mov [_ide_r7], al               ; write sector cmd
1274   062B 07 4A 06      call ide_write      
1275   062E 09            ret
1276   062F             
1277   062F             ;----------------------------------------------------------------------------------------------------;
1278   062F             ; read ide data
1279   062F             ; pointer in d
1280   062F             ;----------------------------------------------------------------------------------------------------;
1281   062F             ide_read:
1282   062F DA            push d
1283   0630             ide_read_loop:
1284   0630 1D D7 FF      mov al, [_ide_r7]  
1285   0633 87 80         and al, 80h                     ; busy flag
1286   0635 C7 30 06      jnz ide_read_loop               ; wait loop
1287   0638 1D D7 FF      mov al, [_ide_r7]
1288   063B 87 08         and al, %00001000               ; drq flag
1289   063D C6 48 06      jz ide_read_end
1290   0640 1D D0 FF      mov al, [_ide_r0]
1291   0643 3E            mov [d], al
1292   0644 79            inc d
1293   0645 0A 30 06      jmp ide_read_loop
1294   0648             ide_read_end:
1295   0648 E7            pop d
1296   0649 09            ret
1297   064A             
1298   064A             ;----------------------------------------------------------------------------------------------------;
1299   064A             ; write ide data
1300   064A             ; data pointer in d
1301   064A             ;----------------------------------------------------------------------------------------------------;
1302   064A             ide_write:
1303   064A DA            push d
1304   064B             ide_write_loop:
1305   064B 1D D7 FF      mov al, [_ide_r7]  
1306   064E 87 80         and al, 80h             ; busy flag
1307   0650 C7 4B 06      jnz ide_write_loop      ; wait loop
1308   0653 1D D7 FF      mov al, [_ide_r7]
1309   0656 87 08         and al, %00001000       ; drq flag
1310   0658 C6 63 06      jz ide_write_end
1311   065B 1E            mov al, [d]
1312   065C 3D D0 FF      mov [_ide_r0], al
1313   065F 79            inc d 
1314   0660 0A 4B 06      jmp ide_write_loop
1315   0663             ide_write_end:
1316   0663 E7            pop d
1317   0664 09            ret
1318   0665             
1319   0665             ;----------------------------------------------------------------------------------------------------;
1320   0665             ; wait for ide to be ready
1321   0665             ;----------------------------------------------------------------------------------------------------;
1322   0665             ide_wait:
1323   0665 1D D7 FF      mov al, [_ide_r7]  
1324   0668 87 80         and al, 80h        ; busy flag
1325   066A C7 65 06      jnz ide_wait
1326   066D 09            ret
1327   066E             
1328   066E             ;----------------------------------------------------------------------------------------------------;
1329   066E             ; io syscall
1330   066E             ;----------------------------------------------------------------------------------------------------;
1331   066E             ; baud  divisor
1332   066E             ; 50    2304
1333   066E             ; 110   1047
1334   066E             ; 300    384
1335   066E             ; 600    192
1336   066E             ; 1200    96
1337   066E             ; 9600    12
1338   066E             ; 19200    6
1339   066E             ; 38400    3
1340   066E             syscall_io_jmp:
1341   066E A1 06         .dw syscall_io_putchar
1342   0670 AE 06         .dw syscall_io_getch
1343   0672 78 06         .dw syscall_io_uart_setup
1344   0674             syscall_io:
1345   0674 FD 0A 6E 06   jmp [syscall_io_jmp + al]
1346   0678             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
1347   0678             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
1348   0678             ; buffer, the transmitter holding register, or the interrupt enable register.
1349   0678             syscall_io_uart_setup:
1350   0678 1D 38 18      mov al, [sys_uart0_lcr]
1351   067B 8B 80         or al, $80                ; set dlab access bit
1352   067D 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
1353   0680 1D 3B 18      mov al, [sys_uart0_div0]
1354   0683 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
1355   0686 1D 3C 18      mov al, [sys_uart0_div1]
1356   0689 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
1357   068C             
1358   068C 1D 38 18      mov al, [sys_uart0_lcr]
1359   068F 87 7F         and al, $7f               ; clear dlab access bit 
1360   0691 3D 83 FF      mov [_uart0_lcr], al
1361   0694 1D 39 18      mov al, [sys_uart0_inten]
1362   0697 3D 81 FF      mov [_uart0_ier], al      ; interrupts
1363   069A 1D 3A 18      mov al, [sys_uart0_fifoen]
1364   069D 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
1365   06A0 06            sysret
1366   06A1             
1367   06A1             ; char in ah
1368   06A1             syscall_io_putchar:
1369   06A1             syscall_io_putchar_l0:
1370   06A1 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1371   06A4 87 20         and al, $20
1372   06A6 C6 A1 06      jz syscall_io_putchar_l0    
1373   06A9 1A            mov al, ah
1374   06AA 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1375   06AD 06            sysret
1376   06AE             
1377   06AE             ; char in ah
1378   06AE             ; al = sucess code
1379   06AE             syscall_io_getch:
1380   06AE D8            push b
1381   06AF DA            push d
1382   06B0 FD 0C         sti
1383   06B2             syscall_io_getch_l0:  
1384   06B2 14 45 18      mov a, [fifo_out]
1385   06B5 29 43 18      mov b, [fifo_in]
1386   06B8 B0            cmp a, b
1387   06B9 C6 B2 06      je syscall_io_getch_l0
1388   06BC 3C            mov d, a
1389   06BD 77            inc a
1390   06BE AF A4 23      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
1391   06C1 C7 C7 06      jne syscall_io_getch_cont
1392   06C4 10 A4 1F      mov a, fifo  
1393   06C7             syscall_io_getch_cont:  
1394   06C7 42 45 18      mov [fifo_out], a             ; update fifo pointer
1395   06CA 1E            mov al, [d]                   ; get char
1396   06CB 23            mov ah, al
1397   06CC 1D 37 18      mov al, [sys_echo_on]
1398   06CF B9 01         cmp al, 1
1399   06D1 C7 E0 06      jne syscall_io_getch_noecho 
1400   06D4             ; here we just echo the char back to the console
1401   06D4             syscall_io_getch_echo_l0:
1402   06D4 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
1403   06D7 87 20         and al, $20                 ; isolate transmitter empty
1404   06D9 C6 D4 06      jz syscall_io_getch_echo_l0
1405   06DC 1A            mov al, ah
1406   06DD 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
1407   06E0             syscall_io_getch_noecho:
1408   06E0 19 01         mov al, 1                    ; al = 1 means a char successfully received
1409   06E2 E7            pop d
1410   06E3 E5            pop b
1411   06E4 06            sysret
1412   06E5             
1413   06E5             ;------------------------------------------------------------------------------------------------------;
1414   06E5             ; file system data
1415   06E5             ;------------------------------------------------------------------------------------------------------;
1416   06E5             ; infor for : ide services interrupt
1417   06E5             ; ide read/write 512-byte sector
1418   06E5             ; al = option
1419   06E5             ; user buffer pointer in d
1420   06E5             ; ah = number of sectors
1421   06E5             ; cb = lba bytes 3..0  
1422   06E5             ;------------------------------------------------------------------------------------------------------;
1423   06E5             ; file system data structure
1424   06E5             ;------------------------------------------------------------------------------------------------------;
1425   06E5             ; for a directory we have the header first, followed by metadata
1426   06E5             ; header 1 sector (512 bytes)
1427   06E5             ; metadata 1 sector (512 bytes)
1428   06E5             ; header entries:
1429   06E5             ; filename (64)
1430   06E5             ; parent dir lba (2) -  to be used for faster backwards navigation...
1431   06E5             ;
1432   06E5             ; metadata entries:
1433   06E5             ; filename (24)
1434   06E5             ; attributes (1)  |_|_|file_type(3bits)|x|w|r| types: file, directory, character device
1435   06E5             ; lba (2)
1436   06E5             ; size (2)
1437   06E5             ; day (1)
1438   06E5             ; month (1)
1439   06E5             ; year (1)
1440   06E5             ; packet size = 32 bytes
1441   06E5             ;
1442   06E5             ; first directory on disk is the root directory '/'
1443   06E5             file_system_jmptbl:
1444   06E5 50 07         .dw fs_mkfs                   ; 0
1445   06E7 00 00         .dw 0                         ; 1
1446   06E9 B2 07         .dw fs_mkdir                  ; 2
1447   06EB 2B 0B         .dw fs_cd                     ; 3
1448   06ED 32 0B         .dw fs_ls                     ; 4
1449   06EF 1D 0C         .dw fs_mktxt                  ; 5
1450   06F1 E8 0C         .dw fs_mkbin                  ; 6
1451   06F3 AF 0D         .dw fs_pwd                    ; 7
1452   06F5 CC 0D         .dw fs_cat                    ; 8
1453   06F7 28 0E         .dw fs_rmdir                  ; 9
1454   06F9 84 0E         .dw fs_rm                     ; 10
1455   06FB 00 00         .dw 0                         ; 11
1456   06FD 00 00         .dw 0                         ; 12
1457   06FF 00 00         .dw 0                         ; 13
1458   0701 58 07         .dw fs_chmod                  ; 14
1459   0703 EC 0E         .dw fs_mv                     ; 15
1460   0705 51 07         .dw fs_cd_root                ; 16
1461   0707 27 0B         .dw fs_get_curr_dirid         ; 17
1462   0709 03 09         .dw fs_dir_id_to_path         ; 18
1463   070B 69 09         .dw fs_path_to_dir_id_user    ; 19
1464   070D 83 0A         .dw fs_load_from_path_user    ; 20  
1465   070F F3 09         .dw fs_filepath_exists_user   ; 21
1466   0711             
1467   0711 0A 3E 20 73 s_syscall_fs_dbg0: .db "\n> syscall_file_system called: ", 0
1467   0715 79 73 63 61 
1467   0719 6C 6C 5F 66 
1467   071D 69 6C 65 5F 
1467   0721 73 79 73 74 
1467   0725 65 6D 20 63 
1467   0729 61 6C 6C 65 
1467   072D 64 3A 20 00 
1468   0731             syscall_file_system:
1469   0731 DD            push bl
1470   0732 31 36 18      mov bl, [sys_debug_mode]
1471   0735               ; debug block
1472   0735 C1 00         cmp bl, 0
1473   0737 EA            pop bl
1474   0738 C6 4C 07      je syscall_filesystem_jmp
1475   073B DA            push d
1476   073C DD            push bl
1477   073D 3B 11 07      mov d, s_syscall_fs_dbg0
1478   0740 07 0D 13      call _puts
1479   0743 2F            mov bl, al
1480   0744 07 AD 13      call print_u8x
1481   0747 07 BA 12      call printnl
1482   074A EA            pop bl
1483   074B E7            pop d
1484   074C             syscall_filesystem_jmp:
1485   074C FD 0A E5 06   jmp [file_system_jmptbl + al]
1486   0750             
1487   0750             fs_mkfs:  
1488   0750 06            sysret  
1489   0751               
1490   0751             fs_cd_root:
1491   0751 10 20 00      mov a, root_id
1492   0754 42 47 18      mov [current_dir_id], a      ; set current directory lba to root
1493   0757 06            sysret  
1494   0758             
1495   0758             ; filename in d (userspace data)
1496   0758             ; permission in bl
1497   0758             fs_chmod:
1498   0758 DD            push bl
1499   0759 FD 4E         mov si, d
1500   075B FD 4F A4 1D   mov di, user_data
1501   075F 38 80 00      mov c, 128
1502   0762 04            load                        ; load filename from user-space
1503   0763 14 47 18      mov a, [current_dir_id]
1504   0766 77            inc a                       ; metadata sector
1505   0767 27            mov b, a
1506   0768 38 00 00      mov c, 0                    ; upper lba = 0
1507   076B 22 01         mov ah, $01                  ; 1 sector
1508   076D 3B A4 25      mov d, transient_area
1509   0770 07 E3 05      call ide_read_sect          ; read directory
1510   0773 FD 10         cla
1511   0775 42 3F 18      mov [index], a              ; reset file counter
1512   0778             fs_chmod_l1:
1513   0778 FD 4E         mov si, d
1514   077A FD 4F A4 1D   mov di, user_data
1515   077E 07 50 11      call _strcmp
1516   0781 C6 98 07      je fs_chmod_found_entry
1517   0784 58 20 00      add d, 32
1518   0787 14 3F 18      mov a, [index]
1519   078A 77            inc a
1520   078B 42 3F 18      mov [index], a
1521   078E AF 10 00      cmp a, fst_files_per_dir
1522   0791 C7 78 07      jne fs_chmod_l1
1523   0794 EA            pop bl
1524   0795 0A B1 07      jmp fs_chmod_not_found
1525   0798             fs_chmod_found_entry:  
1526   0798 FD 79         mov g, b                    ; save lba
1527   079A EA            pop bl                      ; retrieve saved permission value
1528   079B 1F 18 00      mov al, [d + 24]            ; read file permissions
1529   079E 87 F8         and al, %11111000           ; remove all permissions, keep other flags
1530   07A0 8C            or al, bl                   ; set new permissions
1531   07A1 3F 18 00      mov [d + 24], al            ; write new permissions
1532   07A4 38 00 00      mov c, 0
1533   07A7 3B A4 25      mov d, transient_area
1534   07AA 22 01         mov ah, $01                 ; disk write 1 sect
1535   07AC FD 27         mov b, g                    ; retrieve lba
1536   07AE 07 09 06      call ide_write_sect         ; write sector
1537   07B1             fs_chmod_not_found:
1538   07B1 06            sysret
1539   07B2             
1540   07B2             ;------------------------------------------------------------------------------------------------------;
1541   07B2             ; create new directory
1542   07B2             ;------------------------------------------------------------------------------------------------------;
1543   07B2             ; search list for null name entry. add new directory to list
1544   07B2             fs_mkdir:
1545   07B2 FD 4E         mov si, d
1546   07B4 FD 4F A4 1D   mov di, user_data
1547   07B8 38 00 02      mov c, 512
1548   07BB 04            load                        ; load data from user-space
1549   07BC 26 22 00      mov b, fst_lba_start + 2    ; start at 2 because lba  0 is root (this would also cause issues                 
1550   07BF                                           ; when checking for null name, since root has a null name)
1551   07BF 38 00 00      mov c, 0                    ; upper lba = 0
1552   07C2             fs_mkdir_l1:  
1553   07C2 22 01         mov ah, $01                  ; 1 sector
1554   07C4 3B A4 25      mov d, transient_area
1555   07C7 07 E3 05      call ide_read_sect          ; read sector
1556   07CA BD 00         cmp byte[d], 0              ; check for null
1557   07CC C6 D5 07      je fs_mkdir_found_null
1558   07CF 55 02 00      add b, fst_sectors_per_dir  ; skip directory
1559   07D2 0A C2 07      jmp fs_mkdir_l1
1560   07D5             fs_mkdir_found_null:
1561   07D5             ;create header file by grabbing dir name from parameter
1562   07D5 D8            push b                      ; save new directory's lba
1563   07D6 38 40 00      mov c, 64
1564   07D9 FD 4D A4 1D   mov si, user_data
1565   07DD FD 4F A4 25   mov di, transient_area
1566   07E1 FD F5         rep movsb                   ; copy dirname from user_data to transient_area
1567   07E3 14 47 18      mov a, [current_dir_id]
1568   07E6 42 E4 25      mov [transient_area + 64], a    ; store parent directory lba
1569   07E9 19 00         mov al, 0
1570   07EB FD 4F A4 27   mov di, transient_area + 512
1571   07EF 38 00 02      mov c, 512
1572   07F2 FD F7         rep stosb                       ; clean buffer
1573   07F4 38 00 00      mov c, 0                        ; reset lba(c) to 0
1574   07F7             ; write directory entry sectors
1575   07F7 3B A4 25      mov d, transient_area
1576   07FA 22 02         mov ah, $02                     ; disk write, 2 sectors
1577   07FC 07 09 06      call ide_write_sect             ; write sector
1578   07FF             ; now we need to add the new directory to the list, inside the current directory
1579   07FF 14 47 18      mov a, [current_dir_id]
1580   0802 53 01 00      add a, 1
1581   0805 27            mov b, a                        ; metadata sector
1582   0806 38 00 00      mov c, 0
1583   0809 FD 79         mov g, b                        ; save lba
1584   080B 3B A4 25      mov d, transient_area
1585   080E 22 01         mov ah, $01                  ; 1 sector
1586   0810 07 E3 05      call ide_read_sect              ; read metadata sector
1587   0813             fs_mkdir_l2:
1588   0813 BD 00         cmp byte[d], 0
1589   0815 C6 1E 08      je fs_mkdir_found_null2
1590   0818 58 20 00      add d, fst_entry_size
1591   081B 0A 13 08      jmp fs_mkdir_l2                ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1592   081E             fs_mkdir_found_null2:
1593   081E FD 4D A4 1D   mov si, user_data
1594   0822 FD 50         mov di, d
1595   0824 07 65 11      call _strcpy                    ; copy directory name
1596   0827 58 18 00      add d, 24                       ; goto attributes
1597   082A 19 0B         mov al, %00001011               ; directory, no execute, write, read
1598   082C 3E            mov [d], al      
1599   082D 79            inc d
1600   082E E5            pop b
1601   082F D8            push b                          ; push lba back
1602   0830 FD 43         mov [d], b                      ; save lba
1603   0832             ; set file creation date  
1604   0832 58 04 00      add d, 4
1605   0835 19 04         mov al, 4
1606   0837 05 01         syscall sys_rtc
1607   0839 1A            mov al, ah
1608   083A 3E            mov [d], al                     ; set day
1609   083B 79            inc d
1610   083C 19 05         mov al, 5
1611   083E 05 01         syscall sys_rtc
1612   0840 1A            mov al, ah
1613   0841 3E            mov [d], al                     ; set month
1614   0842 79            inc d
1615   0843 19 06         mov al, 6
1616   0845 05 01         syscall sys_rtc
1617   0847 1A            mov al, ah
1618   0848 3E            mov [d], al                     ; set year
1619   0849             ; write sector into disk for new directory entry
1620   0849 FD 27         mov b, g
1621   084B 38 00 00      mov c, 0
1622   084E 3B A4 25      mov d, transient_area
1623   0851 22 01         mov ah, $01                     ; disk write, 1 sector
1624   0853 07 09 06      call ide_write_sect             ; write sector
1625   0856             
1626   0856             ; after adding the new directory's information to its parent directory's list
1627   0856             ; we need to now enter the new directory, and to it add two new directories!
1628   0856             ; which directories do we need to add ? '..' and '.' are the directories needed.
1629   0856             ; importantly, note that these two new directories are only entries in the list
1630   0856             ; and do not have actual physical entries in the disk as real directories.
1631   0856             ; i.e. they only exist as list entries in the new directory created so that
1632   0856             ; the new directory can reference its parent and itself.
1633   0856             ; we need to add both '..' and '.'
1634   0856             ; this first section is for '..' and on the section below we do the same for '.'
1635   0856 E4            pop a                         ; retrieve the new directory's lba  
1636   0857 D7            push a                        ; and save again
1637   0858 53 01 00      add a, 1
1638   085B 27            mov b, a                      ; metadata sector
1639   085C 38 00 00      mov c, 0
1640   085F FD 79         mov g, b                      ; save lba
1641   0861 3B A4 25      mov d, transient_area
1642   0864 22 01         mov ah, $01                  ; 1 sector
1643   0866 07 E3 05      call ide_read_sect            ; read metadata sector
1644   0869             fs_mkdir_l3:
1645   0869 BD 00         cmp byte[d], 0
1646   086B C6 74 08      je fs_mkdir_found_null3
1647   086E 58 20 00      add d, fst_entry_size
1648   0871 0A 69 08      jmp fs_mkdir_l3              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1649   0874             fs_mkdir_found_null3:
1650   0874 FD 4D 66 18   mov si, s_parent_dir
1651   0878 FD 50         mov di, d
1652   087A 07 65 11      call _strcpy                  ; copy directory name
1653   087D 58 18 00      add d, 24                     ; goto attributes
1654   0880 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1655   0882 3E            mov [d], al      
1656   0883 79            inc d
1657   0884 29 47 18      mov b, [current_dir_id]        ; retrieve the parent directorys lba
1658   0887 FD 43         mov [d], b                    ; save lba
1659   0889             ; set file creation date  
1660   0889 58 04 00      add d, 4
1661   088C 19 04         mov al, 4
1662   088E 05 01         syscall sys_rtc
1663   0890 1A            mov al, ah
1664   0891 3E            mov [d], al                   ; set day
1665   0892 79            inc d
1666   0893 19 05         mov al, 5
1667   0895 05 01         syscall sys_rtc
1668   0897 1A            mov al, ah
1669   0898 3E            mov [d], al                   ; set month
1670   0899 79            inc d
1671   089A 19 06         mov al, 6
1672   089C 05 01         syscall sys_rtc
1673   089E 1A            mov al, ah
1674   089F 3E            mov [d], al                   ; set year
1675   08A0             ; write sector into disk for new directory entry
1676   08A0 FD 27         mov b, g
1677   08A2 38 00 00      mov c, 0
1678   08A5 3B A4 25      mov d, transient_area
1679   08A8 22 01         mov ah, $01                   ; disk write, 1 sector
1680   08AA 07 09 06      call ide_write_sect           ; write sector
1681   08AD             ;;;;;;;;;;;;;
1682   08AD             ; like we did above for '..', we need to now add the '.' directory to the list.
1683   08AD             ;------------------------------------------------------------------------------------------------------;
1684   08AD E4            pop a                         ; retrieve the new directory's lba  
1685   08AE D7            push a
1686   08AF 53 01 00      add a, 1
1687   08B2 27            mov b, a                      ; metadata sector
1688   08B3 38 00 00      mov c, 0
1689   08B6 FD 79         mov g, b                      ; save lba
1690   08B8 3B A4 25      mov d, transient_area
1691   08BB 22 01         mov ah, $01                  ; 1 sector
1692   08BD 07 E3 05      call ide_read_sect            ; read metadata sector
1693   08C0             fs_mkdir_l4:
1694   08C0 BD 00         cmp byte[d], 0
1695   08C2 C6 CB 08      je fs_mkdir_found_null4
1696   08C5 58 20 00      add d, fst_entry_size
1697   08C8 0A C0 08      jmp fs_mkdir_l4              ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
1698   08CB             fs_mkdir_found_null4:
1699   08CB FD 4D 69 18   mov si, s_current_dir
1700   08CF FD 50         mov di, d
1701   08D1 07 65 11      call _strcpy                  ; copy directory name
1702   08D4 58 18 00      add d, 24                     ; goto attributes
1703   08D7 19 0B         mov al, %00001011             ; directory, no execute, write, read, 
1704   08D9 3E            mov [d], al      
1705   08DA 79            inc d
1706   08DB E5            pop b                         ; new directory's lba itself. for self-referential directory entry '.'
1707   08DC FD 43         mov [d], b                    ; save lba
1708   08DE             ; set file creation date  
1709   08DE 58 04 00      add d, 4
1710   08E1 19 04         mov al, 4
1711   08E3 05 01         syscall sys_rtc
1712   08E5 1A            mov al, ah
1713   08E6 3E            mov [d], al                   ; set day
1714   08E7 79            inc d
1715   08E8 19 05         mov al, 5
1716   08EA 05 01         syscall sys_rtc
1717   08EC 1A            mov al, ah
1718   08ED 3E            mov [d], al                   ; set month
1719   08EE 79            inc d
1720   08EF 19 06         mov al, 6
1721   08F1 05 01         syscall sys_rtc
1722   08F3 1A            mov al, ah
1723   08F4 3E            mov [d], al                   ; set year
1724   08F5             ; write sector into disk for new directory entry
1725   08F5 FD 27         mov b, g
1726   08F7 38 00 00      mov c, 0
1727   08FA 3B A4 25      mov d, transient_area
1728   08FD 22 01         mov ah, $01                   ; disk write, 1 sector
1729   08FF 07 09 06      call ide_write_sect           ; write sector
1730   0902             fs_mkdir_end:
1731   0902 06            sysret
1732   0903             
1733   0903             ;------------------------------------------------------------------------------------------------------;
1734   0903             ; get path from a given directory dirid
1735   0903             ; pseudo code:
1736   0903             ;  fs_dir_id_to_path(int dirid, char *d){
1737   0903             ;    if(dirid == 0){
1738   0903             ;      reverse path in d;
1739   0903             ;      return;
1740   0903             ;    }
1741   0903             ;    else{
1742   0903             ;      copy directory name to end of d;
1743   0903             ;      add '/' to end of d;
1744   0903             ;      parentid = get parent directory id;
1745   0903             ;      fs_dir_id_to_path(parentid, d);
1746   0903             ;    }
1747   0903             ;  }
1748   0903             ; a = dirid
1749   0903             ; d = generated path string pointer
1750   0903             ;------------------------------------------------------------------------------------------------------;
1751   0903             ; sample path: /usr/bin
1752   0903             fs_dir_id_to_path:
1753   0903 3B 24 1D      mov d, filename
1754   0906 19 00         mov al, 0
1755   0908 3E            mov [d], al                     ; initialize path string 
1756   0909 14 47 18      mov a, [current_dir_id]
1757   090C 07 19 09      call fs_dir_id_to_path_e0
1758   090F 3B 24 1D      mov d, filename
1759   0912 07 F9 10      call _strrev
1760   0915 07 0D 13      call _puts
1761   0918 06            sysret
1762   0919             fs_dir_id_to_path_e0:
1763   0919 07 38 09      call get_dirname_from_dirid
1764   091C FD 4D 6B 18   mov si, s_fslash
1765   0920 FD 50         mov di, d
1766   0922 07 73 11      call _strcat                    ; add '/' to end of path
1767   0925 AF 20 00      cmp a, root_id               ; check if we are at the root directory
1768   0928 C6 37 09      je fs_dir_id_to_path_root
1769   092B 07 55 09      call get_parentid_from_dirid    ; use current id (a) to find parentid (into a)
1770   092E AF 20 00      cmp a, root_id               ; check if we are at the root directory
1771   0931 C6 37 09      je fs_dir_id_to_path_root
1772   0934 07 19 09      call fs_dir_id_to_path_e0     ; recursively call itself
1773   0937             fs_dir_id_to_path_root:
1774   0937 09            ret
1775   0938             
1776   0938             ;------------------------------------------------------------------------------------------------------;
1777   0938             ; in_puts:
1778   0938             ; a = directory id
1779   0938             ; out_puts:
1780   0938             ; d = pointer to directory name string
1781   0938             ;------------------------------------------------------------------------------------------------------;
1782   0938             get_dirname_from_dirid:
1783   0938 D7            push a
1784   0939 D8            push b
1785   093A DA            push d
1786   093B 27            mov b, a
1787   093C 38 00 00      mov c, 0                      ; upper lba = 0
1788   093F 22 01         mov ah, $01                  ; 1 sector
1789   0941 3B A4 23      mov d, transient_area - 512
1790   0944 07 E3 05      call ide_read_sect            ; read directory
1791   0947 07 F9 10      call _strrev                  ; reverse dir name before copying
1792   094A FD 4E         mov si, d
1793   094C E7            pop d                         ; destination address = d value pushed at beginning
1794   094D FD 50         mov di, d
1795   094F 07 73 11      call _strcat                  ; copy filename to d
1796   0952 E5            pop b
1797   0953 E4            pop a
1798   0954 09            ret
1799   0955             
1800   0955             ;------------------------------------------------------------------------------------------------------;
1801   0955             ; in_puts:
1802   0955             ; a = directory id
1803   0955             ; out_puts:
1804   0955             ; a = parent directory id
1805   0955             ;------------------------------------------------------------------------------------------------------;
1806   0955             get_parentid_from_dirid:
1807   0955 D8            push b
1808   0956 DA            push d
1809   0957 27            mov b, a
1810   0958 38 00 00      mov c, 0                      ; upper lba = 0
1811   095B 22 01         mov ah, $01                  ; 1 sector
1812   095D 3B A4 23      mov d, transient_area - 512
1813   0960 07 E3 05      call ide_read_sect            ; read directory
1814   0963 16 40 00      mov a, [d + 64]               ; copy parent id value to a
1815   0966 E7            pop d
1816   0967 E5            pop b
1817   0968 09            ret
1818   0969             
1819   0969             ;------------------------------------------------------------------------------------------------------;
1820   0969             ; get dirid from a given path string
1821   0969             ; in_puts:
1822   0969             ; d = path pointer 
1823   0969             ; out_puts:
1824   0969             ; a = dirid
1825   0969             ; if dir non existent, a = ffff (fail code)
1826   0969             ; /usr/local/bin    - absolute
1827   0969             ; local/bin/games    - relative
1828   0969             ;------------------------------------------------------------------------------------------------------;
1829   0969             fs_path_to_dir_id_user:
1830   0969 FD 4E         mov si, d
1831   096B FD 4F A4 1D   mov di, user_data
1832   096F 38 00 02      mov c, 512
1833   0972 04            load
1834   0973 07 77 09      call get_dirid_from_path
1835   0976 06            sysret
1836   0977             get_dirid_from_path:
1837   0977 26 A4 1D      mov b, user_data
1838   097A FD 42 32 17   mov [prog], b                  ; token pointer set to path string
1839   097E 07 93 15      call get_token
1840   0981 31 35 17      mov bl, [tok]
1841   0984 C1 01         cmp bl, tok_fslash
1842   0986 C6 92 09      je get_dirid_from_path_abs 
1843   0989 14 47 18      mov a, [current_dir_id]
1844   098C 07 19 17      call _putback
1845   098F 0A 95 09      jmp get_dirid_from_path_e0
1846   0992             get_dirid_from_path_abs:
1847   0992 10 20 00      mov a, root_id
1848   0995             get_dirid_from_path_e0:
1849   0995 07 93 15      call get_token
1850   0998 31 34 17      mov bl, [toktyp]
1851   099B C1 00         cmp bl, toktyp_identifier
1852   099D C7 EE 09      jne get_dirid_from_path_end   ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
1853   09A0             
1854   09A0 FD 4D 36 17   mov si, tokstr
1855   09A4 FD 4F 24 1D   mov di, filename
1856   09A8 07 65 11      call _strcpy        
1857   09AB 77            inc a                         ; metadata sector
1858   09AC 27            mov b, a
1859   09AD 38 00 00      mov c, 0                      ; upper lba = 0
1860   09B0 22 01         mov ah, $01                  ; 1 sector
1861   09B2 3B A4 25      mov d, transient_area
1862   09B5 07 E3 05      call ide_read_sect            ; read directory
1863   09B8 FD 10         cla
1864   09BA 42 3F 18      mov [index], a
1865   09BD             get_dirid_from_path_l1:
1866   09BD FD 4E         mov si, d
1867   09BF FD 4F 24 1D   mov di, filename
1868   09C3 07 50 11      call _strcmp
1869   09C6 C6 DC 09      je get_dirid_from_path_name_equal  
1870   09C9 58 20 00      add d, 32
1871   09CC 14 3F 18      mov a, [index]
1872   09CF 77            inc a
1873   09D0 42 3F 18      mov [index], a
1874   09D3 AF 10 00      cmp a, fst_files_per_dir
1875   09D6 C6 EF 09      je get_dirid_from_path_fail
1876   09D9 0A BD 09      jmp get_dirid_from_path_l1
1877   09DC             get_dirid_from_path_name_equal:
1878   09DC 58 19 00      add d, 25           
1879   09DF 15            mov a, [d]                    ; set result register a = dirid
1880   09E0 07 93 15      call get_token
1881   09E3 31 35 17      mov bl, [tok]
1882   09E6 C1 01         cmp bl, tok_fslash            ; check if there are more elements in the path
1883   09E8 C6 95 09      je get_dirid_from_path_e0
1884   09EB 07 19 17      call _putback
1885   09EE             get_dirid_from_path_end:
1886   09EE 09            ret
1887   09EF             get_dirid_from_path_fail:
1888   09EF 10 FF FF      mov a, $ffff
1889   09F2 09            ret
1890   09F3             
1891   09F3             
1892   09F3             ;------------------------------------------------------------------------------------------------------;
1893   09F3             ; check if file exists by a given path string
1894   09F3             ; in_puts:
1895   09F3             ; d = path pointer 
1896   09F3             ; outputs:
1897   09F3             ; a = success code, if file exists gives lba, else, give 0
1898   09F3             ; /usr/local/bin/ed
1899   09F3             ;------------------------------------------------------------------------------------------------------;
1900   09F3             fs_filepath_exists_user:
1901   09F3 FD 4E         mov si, d
1902   09F5 FD 4F A4 1D   mov di, user_data
1903   09F9 38 00 02      mov c, 512
1904   09FC 04            load
1905   09FD 07 01 0A      call file_exists_by_path
1906   0A00 06            sysret
1907   0A01             file_exists_by_path:
1908   0A01 26 A4 1D      mov b, user_data
1909   0A04 FD 42 32 17   mov [prog], b                   ; token pointer set to path string
1910   0A08 07 93 15      call get_token
1911   0A0B 31 35 17      mov bl, [tok]
1912   0A0E C1 01         cmp bl, tok_fslash
1913   0A10 C6 1C 0A      je  file_exists_by_path_abs
1914   0A13 14 47 18      mov a, [current_dir_id]
1915   0A16 07 19 17      call _putback
1916   0A19 0A 1F 0A      jmp file_exists_by_path_e0
1917   0A1C             file_exists_by_path_abs:
1918   0A1C 10 20 00      mov a, root_id
1919   0A1F             file_exists_by_path_e0:
1920   0A1F 07 93 15      call get_token
1921   0A22 31 34 17      mov bl, [toktyp]
1922   0A25 C1 00         cmp bl, toktyp_identifier
1923   0A27 C7 7F 0A      jne file_exists_by_path_end     ; check if there are tokens after '/'
1924   0A2A FD 4D 36 17   mov si, tokstr
1925   0A2E FD 4F 24 1D   mov di, filename
1926   0A32 07 65 11      call _strcpy        
1927   0A35 77            inc a                           ; metadata sector
1928   0A36 27            mov b, a
1929   0A37 38 00 00      mov c, 0                        ; upper lba = 0
1930   0A3A 22 01         mov ah, $01                  ; 1 sector
1931   0A3C 3B A4 25      mov d, transient_area
1932   0A3F 07 E3 05      call ide_read_sect              ; read directory
1933   0A42 FD 10         cla
1934   0A44 42 3F 18      mov [index], a
1935   0A47             file_exists_by_path_l1:
1936   0A47 FD 4E         mov si, d
1937   0A49 FD 4F 24 1D   mov di, filename
1938   0A4D 07 50 11      call _strcmp
1939   0A50 C6 66 0A      je   file_exists_by_path_name_equal
1940   0A53 58 20 00      add d, 32
1941   0A56 14 3F 18      mov a, [index]
1942   0A59 77            inc a
1943   0A5A 42 3F 18      mov [index], a
1944   0A5D AF 10 00      cmp a, fst_files_per_dir
1945   0A60 C6 7F 0A      je file_exists_by_path_end
1946   0A63 0A 47 0A      jmp file_exists_by_path_l1
1947   0A66             file_exists_by_path_name_equal:
1948   0A66 33 18 00      mov bl, [d + 24]
1949   0A69 FD 87 38      and bl, %00111000               ; directory flag
1950   0A6C C1 08         cmp bl, %00001000               ; is dir?
1951   0A6E C6 75 0A      je file_exists_by_path_isdir;
1952   0A71             ; entry is a file
1953   0A71 16 19 00      mov a, [d + 25]                 ; get and return lba of file
1954   0A74 09            ret
1955   0A75             file_exists_by_path_isdir:
1956   0A75 58 19 00      add d, 25           
1957   0A78 15            mov a, [d]                      ; set result register a = dirid
1958   0A79 07 93 15      call get_token
1959   0A7C 0A 1F 0A      jmp file_exists_by_path_e0
1960   0A7F             file_exists_by_path_end:
1961   0A7F 10 00 00      mov a, 0                        ; return 0 because file was not found
1962   0A82 09            ret
1963   0A83             
1964   0A83             ;------------------------------------------------------------------------------------------------------;
1965   0A83             ; load file data from a given path string
1966   0A83             ; inputs:
1967   0A83             ; d = path pointer 
1968   0A83             ; di = userspace program data destination
1969   0A83             ; /usr/local/bin/ed
1970   0A83             ; ./ed
1971   0A83             ;------------------------------------------------------------------------------------------------------;
1972   0A83             fs_load_from_path_user:
1973   0A83 E3            push di
1974   0A84 FD 4E         mov si, d
1975   0A86 FD 4F A4 1D   mov di, user_data
1976   0A8A 38 00 02      mov c, 512
1977   0A8D 04            load
1978   0A8E 07 9B 0A      call loadfile_from_path
1979   0A91 F0            pop di
1980   0A92 FD 4D A4 25   mov si, transient_area
1981   0A96 38 00 3E      mov c, 512 * (fs_sectors_per_file-1)
1982   0A99 03            store
1983   0A9A 06            sysret
1984   0A9B             loadfile_from_path:
1985   0A9B 26 A4 1D      mov b, user_data
1986   0A9E FD 42 32 17   mov [prog], b                 ; token pointer set to path string
1987   0AA2 07 93 15      call get_token
1988   0AA5 31 35 17      mov bl, [tok]
1989   0AA8 C1 01         cmp bl, tok_fslash
1990   0AAA C6 B6 0A      je loadfile_from_path_abs 
1991   0AAD 14 47 18      mov a, [current_dir_id]
1992   0AB0 07 19 17      call _putback
1993   0AB3 0A B9 0A      jmp loadfile_from_path_e0
1994   0AB6             loadfile_from_path_abs:
1995   0AB6 10 20 00      mov a, root_id
1996   0AB9             loadfile_from_path_e0:
1997   0AB9 07 93 15      call get_token
1998   0ABC 31 34 17      mov bl, [toktyp]
1999   0ABF C1 00         cmp bl, toktyp_identifier
2000   0AC1 C7 26 0B      jne loadfile_from_path_end    ; check if there are tokens after '/'. i.e. is this a 'cd /' command?
2001   0AC4 FD 4D 36 17   mov si, tokstr
2002   0AC8 FD 4F 24 1D   mov di, filename
2003   0ACC 07 65 11      call _strcpy        
2004   0ACF 77            inc a                         ; metadata sector
2005   0AD0 27            mov b, a
2006   0AD1 38 00 00      mov c, 0                      ; upper lba = 0
2007   0AD4 22 01         mov ah, $01                  ; 1 sector
2008   0AD6 3B A4 25      mov d, transient_area
2009   0AD9 07 E3 05      call ide_read_sect            ; read directory
2010   0ADC FD 10         cla
2011   0ADE 42 3F 18      mov [index], a
2012   0AE1             loadfile_from_path_l1:
2013   0AE1 FD 4E         mov si, d
2014   0AE3 FD 4F 24 1D   mov di, filename
2015   0AE7 07 50 11      call _strcmp
2016   0AEA C6 00 0B      je loadfile_from_path_name_equal  
2017   0AED 58 20 00      add d, 32
2018   0AF0 14 3F 18      mov a, [index]
2019   0AF3 77            inc a
2020   0AF4 42 3F 18      mov [index], a
2021   0AF7 AF 10 00      cmp a, fst_files_per_dir
2022   0AFA C6 26 0B      je loadfile_from_path_end
2023   0AFD 0A E1 0A      jmp loadfile_from_path_l1
2024   0B00             loadfile_from_path_name_equal:
2025   0B00 33 18 00      mov bl, [d + 24]
2026   0B03 FD 87 38      and bl, %00111000             ; directory flag
2027   0B06 C1 08         cmp bl, %00001000             ; is dir?
2028   0B08 C6 1C 0B      je loadfile_isdirectory  
2029   0B0B             ; entry is a file
2030   0B0B 2B 19 00      mov b, [d + 25]               ; get lba
2031   0B0E FD 77         inc b                         ; add 1 to b because the lba for data comes after the header sector
2032   0B10 3B A4 25      mov d, transient_area
2033   0B13 38 00 00      mov c, 0
2034   0B16 22 1F         mov ah, fs_sectors_per_file-1 ; number of sectors
2035   0B18 07 E3 05      call ide_read_sect            ; read sector
2036   0B1B 09            ret
2037   0B1C             loadfile_isdirectory:
2038   0B1C 58 19 00      add d, 25           
2039   0B1F 15            mov a, [d]                    ; set result register a = dirid
2040   0B20 07 93 15      call get_token
2041   0B23 0A B9 0A      jmp loadfile_from_path_e0
2042   0B26             loadfile_from_path_end:
2043   0B26 09            ret
2044   0B27             
2045   0B27             ;------------------------------------------------------------------------------------------------------;
2046   0B27             ; return the id of the current directory
2047   0B27             ; id returned in b
2048   0B27             ;------------------------------------------------------------------------------------------------------;
2049   0B27             fs_get_curr_dirid:
2050   0B27 29 47 18      mov b, [current_dir_id]
2051   0B2A 06            sysret
2052   0B2B             
2053   0B2B             ;------------------------------------------------------------------------------------------------------;
2054   0B2B             ; cd
2055   0B2B             ;------------------------------------------------------------------------------------------------------;
2056   0B2B             ; new dirid in b
2057   0B2B             fs_cd:
2058   0B2B FD 42 47 18   mov [current_dir_id], b
2059   0B2F 06            sysret  
2060   0B30             
2061   0B30             ;------------------------------------------------------------------------------------------------------;
2062   0B30             ; ls
2063   0B30             ; dirid in b
2064   0B30             ;------------------------------------------------------------------------------------------------------;
2065   0B30 00 00       ls_count:       .dw 0
2066   0B32             fs_ls:
2067   0B32 FD 77         inc b                        ; metadata sector
2068   0B34 38 00 00      mov c, 0                     ; upper lba = 0
2069   0B37 22 01         mov ah, $01                  ; 1 sector
2070   0B39 3B A4 25      mov d, transient_area
2071   0B3C 07 E3 05      call ide_read_sect           ; read directory
2072   0B3F FD 10         cla
2073   0B41 42 3F 18      mov [index], a               ; reset entry index
2074   0B44 3D 30 0B      mov [ls_count], al           ; reset item count
2075   0B47             fs_ls_l1:
2076   0B47 BD 00         cmp byte [d], 0              ; check for null
2077   0B49 C6 E0 0B      je fs_ls_next
2078   0B4C             fs_ls_non_null:
2079   0B4C 1D 30 0B      mov al, [ls_count]
2080   0B4F 7A            inc al
2081   0B50 3D 30 0B      mov [ls_count], al           ; increment item count
2082   0B53 1F 18 00      mov al, [d + 24]
2083   0B56 87 38         and al, %00111000
2084   0B58 FD A2 03      shr al, 3
2085   0B5B 22 00         mov ah, 0                    ; file type
2086   0B5D B7 72 18      mov a, [a + file_type]      
2087   0B60 23            mov ah, al
2088   0B61 07 E1 11      call _putchar
2089   0B64 1F 18 00      mov al, [d + 24]
2090   0B67 87 01         and al, %00000001
2091   0B69 22 00         mov ah, 0
2092   0B6B B7 6D 18      mov a, [a + file_attrib]     ; read
2093   0B6E 23            mov ah, al
2094   0B6F 07 E1 11      call _putchar
2095   0B72 1F 18 00      mov al, [d + 24]
2096   0B75 87 02         and al, %00000010
2097   0B77 22 00         mov ah, 0
2098   0B79 B7 6D 18      mov a, [a + file_attrib]     ; write
2099   0B7C 23            mov ah, al
2100   0B7D 07 E1 11      call _putchar
2101   0B80 1F 18 00      mov al, [d + 24]
2102   0B83 87 04         and al, %00000100
2103   0B85 22 00         mov ah, 0
2104   0B87 B7 6D 18      mov a, [a + file_attrib]     ; execute
2105   0B8A 23            mov ah, al
2106   0B8B 07 E1 11      call _putchar
2107   0B8E 22 20         mov ah, $20
2108   0B90 07 E1 11      call _putchar  
2109   0B93 2B 1B 00      mov b, [d + 27]
2110   0B96 07 69 13      call print_u16x              ; filesize
2111   0B99 22 20         mov ah, $20
2112   0B9B 07 E1 11      call _putchar  
2113   0B9E 2B 19 00      mov b, [d + 25]
2114   0BA1 07 69 13      call print_u16x              ; dirid / lba
2115   0BA4 22 20         mov ah, $20
2116   0BA6 07 E1 11      call _putchar
2117   0BA9             ; print date
2118   0BA9 33 1D 00      mov bl, [d + 29]             ; day
2119   0BAC 07 AD 13      call print_u8x
2120   0BAF 22 20         mov ah, $20
2121   0BB1 07 E1 11      call _putchar  
2122   0BB4 1F 1E 00      mov al, [d + 30]             ; month
2123   0BB7 FD 9E 02      shl al, 2
2124   0BBA DA            push d
2125   0BBB 3B 31 19      mov d, s_months
2126   0BBE 22 00         mov ah, 0
2127   0BC0 59            add d, a
2128   0BC1 07 0D 13      call _puts
2129   0BC4 E7            pop d
2130   0BC5 22 20         mov ah, $20
2131   0BC7 07 E1 11      call _putchar
2132   0BCA 2E 20         mov bl, $20
2133   0BCC 07 AD 13      call print_u8x
2134   0BCF 33 1F 00      mov bl, [d + 31]             ; year
2135   0BD2 07 AD 13      call print_u8x  
2136   0BD5 22 20         mov ah, $20
2137   0BD7 07 E1 11      call _putchar  
2138   0BDA 07 0D 13      call _puts                   ; print filename  
2139   0BDD 07 BA 12      call printnl
2140   0BE0             fs_ls_next:
2141   0BE0 14 3F 18      mov a, [index]
2142   0BE3 77            inc a
2143   0BE4 42 3F 18      mov [index], a
2144   0BE7 AF 10 00      cmp a, fst_files_per_dir
2145   0BEA C6 F3 0B      je fs_ls_end
2146   0BED 58 20 00      add d, 32      
2147   0BF0 0A 47 0B      jmp fs_ls_l1  
2148   0BF3             fs_ls_end:
2149   0BF3 3B 82 18      mov d, s_ls_total
2150   0BF6 07 0D 13      call _puts
2151   0BF9 1D 30 0B      mov al, [ls_count]
2152   0BFC 07 BF 13      call print_u8d
2153   0BFF 07 BA 12      call printnl
2154   0C02 06            sysret
2155   0C03             
2156   0C03             ;------------------------------------------------------------------------------------------------------;
2157   0C03             ; finds an empty data block
2158   0C03             ; block lba returned in b
2159   0C03             ;------------------------------------------------------------------------------------------------------;
2160   0C03             fs_find_empty_block:
2161   0C03 26 A0 00      mov b, fs_lba_start     ; raw files starting block
2162   0C06 38 00 00      mov c, 0                ; upper lba = 0
2163   0C09             fs_find_empty_block_l1:  
2164   0C09 22 01         mov ah, $01                  ; 1 sector
2165   0C0B 3B A4 23      mov d, transient_area - 512
2166   0C0E 07 E3 05      call ide_read_sect      ; read sector
2167   0C11 BD 00         cmp byte [d], 0
2168   0C13 C6 1C 0C      je fs_find_empty_block_found_null
2169   0C16 55 20 00      add b, fs_sectors_per_file
2170   0C19 0A 09 0C      jmp fs_find_empty_block_l1
2171   0C1C             fs_find_empty_block_found_null:
2172   0C1C 09            ret
2173   0C1D             
2174   0C1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2175   0C1D             ;; create new textfile
2176   0C1D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
2177   0C1D             ; search for first null block
2178   0C1D             fs_mktxt:
2179   0C1D FD 4E       	mov si, d
2180   0C1F FD 4F A4 1D 	mov di, user_data
2181   0C23 38 00 01    	mov c, 256
2182   0C26 04          	load					; load data from user-space
2183   0C27             	
2184   0C27 26 A0 00    	mov b, fs_lba_start		; raw files starting block
2185   0C2A 38 00 00    	mov c, 0						; reset lba to 0
2186   0C2D             fs_mktxt_l1:	
2187   0C2D 10 02 01    	mov a, $0102			; disk read
2188   0C30 3B A4 25    	mov d, transient_area
2189   0C33 05 02       	syscall sys_ide ; read sector
2190   0C35 1E          	mov al, [d]
2191   0C36 B9 00       	cmp al, 0			; check for null
2192   0C38 C6 41 0C    	je fs_mktxt_found_null
2193   0C3B 55 20 00    	add b, fs_sectors_per_file
2194   0C3E 0A 2D 0C    	jmp fs_mktxt_l1
2195   0C41             fs_mktxt_found_null:
2196   0C41 D8          	push b				; save lba
2197   0C42             ;create header file by grabbing file name from parameter	
2198   0C42 3B 63 18    	mov d, s_dataentry
2199   0C45 07 0D 13    	call _puts
2200   0C48 3B A4 27    	mov d, transient_area + 512			; pointer to file contents
2201   0C4B 07 73 12    	call _gettxt
2202   0C4E 07 40 11    	call _strlen						; get length of file
2203   0C51 D9          	push c							; save length
2204   0C52 19 01       	mov al, 1
2205   0C54 3D A4 25    	mov [transient_area], al					; mark sectors as used (not null)
2206   0C57 10 00 00    	mov a, 0
2207   0C5A 42 3F 18    	mov [index], a
2208   0C5D 3B A4 25    	mov d, transient_area
2209   0C60 13          	mov a, d
2210   0C61 42 41 18    	mov [buffer_addr], a
2211   0C64             fs_mktxt_l2:
2212   0C64 38 00 00    	mov c, 0
2213   0C67 10 03 01    	mov a, $0103			; disk write, 1 sector
2214   0C6A 05 02       	syscall sys_ide		; write sector
2215   0C6C 14 3F 18    	mov a, [index]
2216   0C6F 77          	inc a
2217   0C70 42 3F 18    	mov [index], a
2218   0C73 AF 20 00    	cmp a, fs_sectors_per_file
2219   0C76 C6 88 0C    	je fs_mktxt_add_to_dir
2220   0C79 FD 77       	inc b
2221   0C7B 14 41 18    	mov a, [buffer_addr]
2222   0C7E 53 00 02    	add a, 512
2223   0C81 42 41 18    	mov [buffer_addr], a
2224   0C84 3C          	mov d, a
2225   0C85 0A 64 0C    	jmp fs_mktxt_l2
2226   0C88             ; now we add the file to the current directory!
2227   0C88             fs_mktxt_add_to_dir:	
2228   0C88 14 47 18    	mov a, [current_dir_id]
2229   0C8B 77          	inc a
2230   0C8C 27          	mov b, a					; metadata sector
2231   0C8D 38 00 00    	mov c, 0
2232   0C90 FD 79       	mov g, b					; save lba
2233   0C92 3B A4 25    	mov d, transient_area
2234   0C95 10 02 01    	mov a, $0102			; disk read
2235   0C98 05 02       	syscall sys_ide		; read metadata sector
2236   0C9A             fs_mktxt_add_to_dir_l2:
2237   0C9A 1E          	mov al, [d]
2238   0C9B B9 00       	cmp al, 0
2239   0C9D C6 A6 0C    	je fs_mktxt_add_to_dir_null
2240   0CA0 58 20 00    	add d, fst_entry_size
2241   0CA3 0A 9A 0C    	jmp fs_mktxt_add_to_dir_l2					; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2242   0CA6             fs_mktxt_add_to_dir_null:
2243   0CA6 FD 4D A4 1D 	mov si, user_data
2244   0CAA FD 50       	mov di, d
2245   0CAC 07 65 11    	call _strcpy			; copy file name
2246   0CAF 58 18 00    	add d, 24			; skip name
2247   0CB2 19 06       	mov al, %00000110		; no execute, write, read, not directory
2248   0CB4 3E          	mov [d], al			
2249   0CB5 58 03 00    	add d, 3
2250   0CB8 E4          	pop a
2251   0CB9 43          	mov [d], a
2252   0CBA 63 02 00    	sub d, 2
2253   0CBD E5          	pop b				; get file lba
2254   0CBE FD 43       	mov [d], b			; save lba	
2255   0CC0             	
2256   0CC0             	; set file creation date	
2257   0CC0 58 04 00    	add d, 4
2258   0CC3 19 04       	mov al, 4
2259   0CC5 05 01       	syscall sys_rtc
2260   0CC7 1A          	mov al, ah
2261   0CC8 3E          	mov [d], al			; set day
2262   0CC9             	
2263   0CC9 79          	inc d
2264   0CCA 19 05       	mov al, 5
2265   0CCC 05 01       	syscall sys_rtc
2266   0CCE 1A          	mov al, ah
2267   0CCF 3E          	mov [d], al			; set month
2268   0CD0             	
2269   0CD0 79          	inc d
2270   0CD1 19 06       	mov al, 6
2271   0CD3 05 01       	syscall sys_rtc
2272   0CD5 1A          	mov al, ah
2273   0CD6 3E          	mov [d], al			; set year
2274   0CD7             	
2275   0CD7             ; write sector into disk for new directory entry
2276   0CD7 FD 27       	mov b, g
2277   0CD9 38 00 00    	mov c, 0
2278   0CDC 3B A4 25    	mov d, transient_area
2279   0CDF 10 03 01    	mov a, $0103			; disk write, 1 sector
2280   0CE2 05 02       	syscall sys_ide		; write sector
2281   0CE4 07 BA 12    	call printnl
2282   0CE7 06          	sysret
2283   0CE8             
2284   0CE8             
2285   0CE8             
2286   0CE8             ;------------------------------------------------------------------------------------------------------;
2287   0CE8             ; create new binary file
2288   0CE8             ;------------------------------------------------------------------------------------------------------;
2289   0CE8             ; search for first null block
2290   0CE8             fs_mkbin:
2291   0CE8 19 00         mov al, 0
2292   0CEA 3D 37 18      mov [sys_echo_on], al ; disable echo
2293   0CED FD 4E         mov si, d
2294   0CEF FD 4F A4 1D   mov di, user_data
2295   0CF3 38 00 02      mov c, 512
2296   0CF6 04            load                          ; load data from user-space
2297   0CF7 26 A0 00      mov b, fs_lba_start           ; files start when directories end
2298   0CFA 38 00 00      mov c, 0                      ; upper lba = 0
2299   0CFD             fs_mkbin_l1:  
2300   0CFD 22 01         mov ah, $01                  ; 1 sector
2301   0CFF 3B A4 25      mov d, transient_area
2302   0D02 07 E3 05      call ide_read_sect            ; read sector
2303   0D05 BD 00         cmp byte[d], 0                ; check for null
2304   0D07 C6 10 0D      je fs_mkbin_found_null
2305   0D0A 55 20 00      add b, fs_sectors_per_file
2306   0D0D 0A FD 0C      jmp fs_mkbin_l1
2307   0D10             fs_mkbin_found_null:
2308   0D10 D8            push b                        ; save lba
2309   0D11             ;create header file by grabbing file name from parameter
2310   0D11 FD 4F A4 27   mov di, transient_area + 512  ; pointer to file contents
2311   0D15 07 8B 10      call _load_hex                ; load binary hex
2312   0D18 D9            push c                        ; save size (nbr of bytes)
2313   0D19 19 01         mov al, 1
2314   0D1B 3D A4 25      mov [transient_area], al      ; mark sectors as used (not null)
2315   0D1E FD 10         cla
2316   0D20 42 3F 18      mov [index], a
2317   0D23 3B A4 25      mov d, transient_area
2318   0D26 13            mov a, d
2319   0D27 42 41 18      mov [buffer_addr], a
2320   0D2A             fs_mkbin_l2:
2321   0D2A 38 00 00      mov c, 0
2322   0D2D 22 01         mov ah, $01                   ; disk write, 1 sector
2323   0D2F 07 09 06      call ide_write_sect           ; write sector
2324   0D32 14 3F 18      mov a, [index]
2325   0D35 77            inc a
2326   0D36 42 3F 18      mov [index], a
2327   0D39 AF 20 00      cmp a, fs_sectors_per_file    ; remove 1 from this because we dont count the header sector
2328   0D3C C6 4E 0D      je fs_mkbin_add_to_dir
2329   0D3F FD 77         inc b
2330   0D41 14 41 18      mov a, [buffer_addr]
2331   0D44 53 00 02      add a, 512
2332   0D47 42 41 18      mov [buffer_addr], a
2333   0D4A 3C            mov d, a
2334   0D4B 0A 2A 0D      jmp fs_mkbin_l2
2335   0D4E             ; now we add the file to the current directory!
2336   0D4E             fs_mkbin_add_to_dir:  
2337   0D4E 14 47 18      mov a, [current_dir_id]
2338   0D51 77            inc a
2339   0D52 27            mov b, a                      ; metadata sector
2340   0D53 38 00 00      mov c, 0
2341   0D56 FD 79         mov g, b                      ; save lba
2342   0D58 3B A4 25      mov d, transient_area
2343   0D5B 22 01         mov ah, $01                  ; 1 sector
2344   0D5D 07 E3 05      call ide_read_sect            ; read metadata sector
2345   0D60             fs_mkbin_add_to_dir_l2:
2346   0D60 BD 00         cmp byte[d], 0
2347   0D62 C6 6B 0D      je fs_mkbin_add_to_dir_null
2348   0D65 58 20 00      add d, fst_entry_size
2349   0D68 0A 60 0D      jmp fs_mkbin_add_to_dir_l2   ; we look for a null entry here but dont check for limits. care needed when adding too many files to a directory
2350   0D6B             fs_mkbin_add_to_dir_null:
2351   0D6B FD 4D A4 1D   mov si, user_data
2352   0D6F FD 50         mov di, d
2353   0D71 07 65 11      call _strcpy                  ; copy file name
2354   0D74 58 18 00      add d, 24                     ; skip name
2355   0D77 19 03         mov al, %00000011             ; type=file, no execute, write, read, 
2356   0D79 3E            mov [d], al
2357   0D7A 58 03 00      add d, 3
2358   0D7D E4            pop a
2359   0D7E 43            mov [d], a
2360   0D7F 63 02 00      sub d, 2
2361   0D82 E5            pop b                         ; get file lba
2362   0D83 FD 43         mov [d], b                    ; save lba
2363   0D85               ; set file creation date  
2364   0D85 58 04 00      add d, 4
2365   0D88 19 04         mov al, 4
2366   0D8A 05 01         syscall sys_rtc
2367   0D8C 1A            mov al, ah
2368   0D8D 3E            mov [d], al                   ; set day
2369   0D8E 79            inc d
2370   0D8F 19 05         mov al, 5
2371   0D91 05 01         syscall sys_rtc
2372   0D93 1A            mov al, ah
2373   0D94 3E            mov [d], al                   ; set month
2374   0D95 79            inc d
2375   0D96 19 06         mov al, 6
2376   0D98 05 01         syscall sys_rtc
2377   0D9A 1A            mov al, ah
2378   0D9B 3E            mov [d], al                   ; set year
2379   0D9C             ; write sector into disk for new directory entry
2380   0D9C FD 27         mov b, g
2381   0D9E 38 00 00      mov c, 0
2382   0DA1 3B A4 25      mov d, transient_area
2383   0DA4 22 01         mov ah, $01                   ; disk write, 1 sector
2384   0DA6 07 09 06      call ide_write_sect           ; write sector
2385   0DA9 19 01         mov al, 1
2386   0DAB 3D 37 18      mov [sys_echo_on], al ; enable echo
2387   0DAE 06            sysret
2388   0DAF             
2389   0DAF             ;------------------------------------------------------------------------------------------------------;
2390   0DAF             ; pwd - print working directory
2391   0DAF             ;------------------------------------------------------------------------------------------------------;    
2392   0DAF             fs_pwd:
2393   0DAF 3B 24 1D      mov d, filename
2394   0DB2 19 00         mov al, 0
2395   0DB4 3E            mov [d], al                   ; initialize path string 
2396   0DB5 14 47 18      mov a, [current_dir_id]
2397   0DB8 07 19 09      call fs_dir_id_to_path_e0
2398   0DBB 3B 24 1D      mov d, filename
2399   0DBE 07 F9 10      call _strrev
2400   0DC1 07 0D 13      call _puts
2401   0DC4 07 BA 12      call printnl
2402   0DC7 06            sysret
2403   0DC8             
2404   0DC8             ;------------------------------------------------------------------------------------------------------;
2405   0DC8             ; get current directory lba
2406   0DC8             ; a: returned lba
2407   0DC8             ;------------------------------------------------------------------------------------------------------;
2408   0DC8             cmd_get_curr_dir_lba:
2409   0DC8 14 47 18      mov a, [current_dir_id]
2410   0DCB 06            sysret
2411   0DCC             
2412   0DCC             ;------------------------------------------------------------------------------------------------------;
2413   0DCC             ; cat
2414   0DCC             ; userspace destination data pointer in d
2415   0DCC             ; filename starts at d, but is overwritten after the read is made
2416   0DCC             ;------------------------------------------------------------------------------------------------------;:
2417   0DCC             fs_cat:
2418   0DCC DA            push d                              ; save userspace file data destination
2419   0DCD FD 4E         mov si, d
2420   0DCF FD 4F A4 1D   mov di, user_data
2421   0DD3 38 00 02      mov c, 512
2422   0DD6 04            load                                ; copy filename from user-space
2423   0DD7 29 47 18      mov b, [current_dir_id]
2424   0DDA FD 77         inc b                               ; metadata sector
2425   0DDC 38 00 00      mov c, 0                            ; upper lba = 0
2426   0DDF 22 01         mov ah, $01                  ; 1 sector
2427   0DE1 3B A4 23      mov d, transient_area-512
2428   0DE4 07 E3 05      call ide_read_sect                  ; read directory
2429   0DE7 FD 10         cla
2430   0DE9 42 3F 18      mov [index], a                      ; reset file counter
2431   0DEC             fs_cat_l1:
2432   0DEC FD 4E         mov si, d
2433   0DEE FD 4F A4 1D   mov di, user_data
2434   0DF2 07 50 11      call _strcmp
2435   0DF5 C6 0B 0E      je fs_cat_found_entry
2436   0DF8 58 20 00      add d, 32
2437   0DFB 14 3F 18      mov a, [index]
2438   0DFE 77            inc a
2439   0DFF 42 3F 18      mov [index], a
2440   0E02 AF 10 00      cmp a, fst_files_per_dir
2441   0E05 C6 26 0E      je fs_cat_not_found
2442   0E08 0A EC 0D      jmp fs_cat_l1
2443   0E0B             fs_cat_found_entry:
2444   0E0B 58 19 00      add d, 25                           ; get to dirid of file in disk
2445   0E0E 2A            mov b, [d]                          ; get lba
2446   0E0F FD 77         inc b                               ; add 1 to b because the lba for data comes after the header sector 
2447   0E11 3B A4 25      mov d, transient_area  
2448   0E14 38 00 00      mov c, 0
2449   0E17 22 1F         mov ah, fs_sectors_per_file-1       ; nbr sectors
2450   0E19 07 E3 05      call ide_read_sect                  ; read sectors
2451   0E1C F0            pop di                              ; write userspace file data destination to di
2452   0E1D FD 4D A4 25   mov si, transient_area              ; data origin
2453   0E21 38 00 3E      mov c, 512*(fs_sectors_per_file-1)
2454   0E24 03            store
2455   0E25 06            sysret
2456   0E26             fs_cat_not_found:
2457   0E26 E7            pop d
2458   0E27 06            sysret
2459   0E28             
2460   0E28             ;------------------------------------------------------------------------------------------------------;
2461   0E28             ; rmdir - remove dir by dirid
2462   0E28             ;------------------------------------------------------------------------------------------------------;
2463   0E28             ; deletes a directory entry in the given directory's file list 
2464   0E28             ; also deletes the actual directory entry in the fst
2465   0E28             ; synopsis: rmdir /usr/local/testdir
2466   0E28             ; b = dirid
2467   0E28             fs_rmdir:
2468   0E28 FD 79         mov g, b
2469   0E2A 11            mov a, b
2470   0E2B 07 55 09      call get_parentid_from_dirid  ; now get the directory's parent, in a
2471   0E2E D7            push a                        ; save dirid
2472   0E2F             ; search for directory's entry in the parent's directory then and delete it
2473   0E2F 77            inc a                         ; metadata sector
2474   0E30 27            mov b, a
2475   0E31 38 00 00      mov c, 0                      ; upper lba = 0
2476   0E34 22 01         mov ah, $01          ;
2477   0E36 3B A4 25      mov d, transient_area
2478   0E39 07 E3 05      call ide_read_sect            ; read directory
2479   0E3C FD 10         cla
2480   0E3E 42 3F 18      mov [index], a                ; reset file counter
2481   0E41 FD 27         mov b, g                      ; retrieve directory's dirid
2482   0E43             fs_rmdir_l1:
2483   0E43 16 19 00      mov a, [d + 25]               ; get entry's dirid/lba value
2484   0E46 B0            cmp a, b                      ; compare dirid's to find the directory
2485   0E47 C6 5D 0E      je fs_rmdir_found_entry
2486   0E4A 58 20 00      add d, 32
2487   0E4D 14 3F 18      mov a, [index]
2488   0E50 77            inc a
2489   0E51 42 3F 18      mov [index], a
2490   0E54 AF 10 00      cmp a, fst_files_per_dir
2491   0E57 C6 82 0E      je fs_rmdir_not_found
2492   0E5A 0A 43 0E      jmp fs_rmdir_l1
2493   0E5D             fs_rmdir_found_entry:
2494   0E5D FD 10         cla
2495   0E5F 3E            mov [d], al                   ; make filename null
2496   0E60 44 19 00      mov [d + 25], a               ; clear dirid/lba as well not to generate problems with previously deleted directories
2497   0E63 E5            pop b
2498   0E64 FD 77         inc b                         ; metadata sector
2499   0E66 38 00 00      mov c, 0                      ; upper lba = 0
2500   0E69 22 01         mov ah, $01          ; 
2501   0E6B 3B A4 25      mov d, transient_area
2502   0E6E 07 09 06      call ide_write_sect           ; write sector and erase file's entry in the current dir
2503   0E71             
2504   0E71 FD 27         mov b, g
2505   0E73 3B A4 25      mov d, transient_area  
2506   0E76 FD 10         cla
2507   0E78 3E            mov [d], al                   ; make directory's name header null for re-use
2508   0E79 38 00 00      mov c, 0
2509   0E7C 22 01         mov ah, $01                   ; disk write 1 sect
2510   0E7E 07 09 06      call ide_write_sect           ; delete directory given by dirid in b
2511   0E81 06            sysret
2512   0E82             fs_rmdir_not_found:
2513   0E82 E5            pop b
2514   0E83 06            sysret
2515   0E84             
2516   0E84             ;------------------------------------------------------------------------------------------------------;
2517   0E84             ; rm - remove file
2518   0E84             ;------------------------------------------------------------------------------------------------------;
2519   0E84             ; frees up the data sectors for the file further down the disk
2520   0E84             ; deletes file entry in the directory's file list 
2521   0E84             fs_rm:
2522   0E84 FD 4E         mov si, d
2523   0E86 FD 4F A4 1D   mov di, user_data
2524   0E8A 38 00 02      mov c, 512
2525   0E8D 04            load                          ; load data from user-space
2526   0E8E 14 47 18      mov a, [current_dir_id]
2527   0E91 77            inc a                         ; metadata sector
2528   0E92 27            mov b, a
2529   0E93 38 00 00      mov c, 0                      ; upper lba = 0
2530   0E96 22 01         mov ah, $01                  ; 1 sector
2531   0E98 3B A4 25      mov d, transient_area
2532   0E9B 07 E3 05      call ide_read_sect            ; read directory
2533   0E9E 10 00 00      mov a, 0
2534   0EA1 42 3F 18      mov [index], a                ; reset file counter
2535   0EA4             fs_rm_l1:
2536   0EA4 FD 4E         mov si, d
2537   0EA6 FD 4F A4 1D   mov di, user_data
2538   0EAA 07 50 11      call _strcmp
2539   0EAD C6 C3 0E      je fs_rm_found_entry
2540   0EB0 58 20 00      add d, 32
2541   0EB3 14 3F 18      mov a, [index]
2542   0EB6 77            inc a
2543   0EB7 42 3F 18      mov [index], a
2544   0EBA AF 10 00      cmp a, fst_files_per_dir
2545   0EBD C6 EB 0E      je fs_rm_not_found
2546   0EC0 0A A4 0E      jmp fs_rm_l1
2547   0EC3             fs_rm_found_entry:
2548   0EC3 2B 19 00      mov b, [d + 25]               ; get lba
2549   0EC6 FD 79         mov g, b                      ; save lba
2550   0EC8 19 00         mov al, 0
2551   0ECA 3E            mov [d], al                   ; make file entry null
2552   0ECB 14 47 18      mov a, [current_dir_id]
2553   0ECE 77            inc a                         ; metadata sector
2554   0ECF 27            mov b, a
2555   0ED0 38 00 00      mov c, 0                      ; upper lba = 0
2556   0ED3 22 01         mov ah, $01                   ; disk write
2557   0ED5 3B A4 25      mov d, transient_area
2558   0ED8 07 09 06      call ide_write_sect           ; write sector and erase file's entry in the current dir
2559   0EDB 3B A4 25      mov d, transient_area  
2560   0EDE 19 00         mov al, 0
2561   0EE0 3E            mov [d], al                   ; make file's data header null for re-use
2562   0EE1 38 00 00      mov c, 0
2563   0EE4 FD 27         mov b, g                      ; get data header lba
2564   0EE6 22 01         mov ah, $01                   ; disk write 1 sect
2565   0EE8 07 09 06      call ide_write_sect           ; write sector
2566   0EEB             fs_rm_not_found:  
2567   0EEB 06            sysret  
2568   0EEC             
2569   0EEC             ;------------------------------------------------------------------------------------------------------;
2570   0EEC             ; mv - move / change file name
2571   0EEC             ;------------------------------------------------------------------------------------------------------;
2572   0EEC             fs_mv:
2573   0EEC FD 4E         mov si, d
2574   0EEE FD 4F A4 1D   mov di, user_data
2575   0EF2 38 00 02      mov c, 512
2576   0EF5 04            load                          ; load data from user-space
2577   0EF6 14 47 18      mov a, [current_dir_id]
2578   0EF9 77            inc a                         ; metadata sector
2579   0EFA 27            mov b, a  
2580   0EFB 38 00 00      mov c, 0                      ; upper lba = 0
2581   0EFE 22 01         mov ah, $01                  ; 1 sector
2582   0F00 3B A4 25      mov d, transient_area
2583   0F03 07 E3 05      call ide_read_sect            ; read directory
2584   0F06 FD 10         cla
2585   0F08 42 3F 18      mov [index], a                ; reset file counter
2586   0F0B             fs_mv_l1:
2587   0F0B FD 4E         mov si, d
2588   0F0D FD 4F A4 1D   mov di, user_data
2589   0F11 07 50 11      call _strcmp
2590   0F14 C6 2A 0F      je fs_mv_found_entry
2591   0F17 58 20 00      add d, 32
2592   0F1A 14 3F 18      mov a, [index]
2593   0F1D 77            inc a
2594   0F1E 42 3F 18      mov [index], a
2595   0F21 AF 10 00      cmp a, fst_files_per_dir
2596   0F24 C6 5C 0F      je fs_mv_not_found
2597   0F27 0A 0B 0F      jmp fs_mv_l1
2598   0F2A             fs_mv_found_entry:  
2599   0F2A DA            push d
2600   0F2B FD 4D 24 1E   mov si, user_data + 128       ; (0...127) = original filename , (128...255) = new name
2601   0F2F FD 50         mov di, d
2602   0F31 07 65 11      call _strcpy  
2603   0F34 38 00 00      mov c, 0
2604   0F37 3B A4 25      mov d, transient_area
2605   0F3A 22 01         mov ah, $01                   ; disk write 1 sect
2606   0F3C 07 09 06      call ide_write_sect           ; write sector
2607   0F3F E7            pop d
2608   0F40             ;; need to check whether its a dir or a file here ;;;
2609   0F40 2B 19 00      mov b, [d + 25]               ; get the dirid of the directory so we can locate its own entry in the list
2610   0F43 22 01         mov ah, $01
2611   0F45 3B A4 25      mov d, transient_area
2612   0F48 38 00 00      mov c, 0
2613   0F4B 07 E3 05      call ide_read_sect            ; read directory entry
2614   0F4E FD 4D 24 1E   mov si, user_data + 128
2615   0F52 FD 50         mov di, d
2616   0F54 07 65 11      call _strcpy                  ; change directory's name
2617   0F57 22 01         mov ah, $01
2618   0F59 07 09 06      call ide_write_sect           ; rewrite directory back to disk
2619   0F5C             fs_mv_not_found:
2620   0F5C 06            sysret
2621   0F5D             
2622   0F5D             
2623   0F5D             ;----------------------------------------------------------------------------------------------------;
2624   0F5D             ; process index in a
2625   0F5D             ;----------------------------------------------------------------------------------------------------;
2626   0F5D             find_free_proc:
2627   0F5D FD 4D 15 1B   mov si, proc_availab_table + 1      ; skip process 0 (kernel)
2628   0F61             find_free_proc_l0:
2629   0F61 F6            lodsb                               ; get process state
2630   0F62 B9 00         cmp al, 0
2631   0F64 C6 6A 0F      je find_free_proc_free              ; if free, jump
2632   0F67 0A 61 0F      jmp find_free_proc_l0               ; else, goto next
2633   0F6A             find_free_proc_free:
2634   0F6A 4E            mov a, si
2635   0F6B 5F 15 1B      sub a, 1 + proc_availab_table       ; get process index
2636   0F6E 09            ret
2637   0F6F               
2638   0F6F             
2639   0F6F             ;----------------------------------------------------------------------------------------------------;
2640   0F6F             ; process index in al
2641   0F6F             ;----------------------------------------------------------------------------------------------------;
2642   0F6F             proc_memory_map:
2643   0F6F 22 00         mov ah, 0
2644   0F71 27            mov b, a                      ; page in bl, 0 in bh
2645   0F72 FD 9D 05      shl a, 5                      ; multiply by 32
2646   0F75 39            mov c, a                      ; save in c
2647   0F76 57 20 00      add c, 32
2648   0F79             proc_memory_map_l0:
2649   0F79 02            pagemap
2650   0F7A 55 00 08      add b, $0800                  ; increase page number (msb 5 bits of bh only)
2651   0F7D 53 01 00      add a, 1                      ; increase both 
2652   0F80 B1            cmp a, c                      ; check to see if we reached the end of memory
2653   0F81 C7 79 0F      jne proc_memory_map_l0
2654   0F84 09            ret
2655   0F85               
2656   0F85             
2657   0F85             ;----------------------------------------------------------------------------------------------------;
2658   0F85             ; terminate process
2659   0F85             ;----------------------------------------------------------------------------------------------------;
2660   0F85             syscall_terminate_proc:
2661   0F85 51 05 00      add sp, 5                            ; clear stack of the values that were pushed by the interrupt (sp, status, pc)
2662   0F88                                                    ; since they will not be used for anything here.
2663   0F88 1D 3E 18      mov al, [active_proc_index]
2664   0F8B 22 00         mov ah, 0  
2665   0F8D FD 9D 05      shl a, 5                             ; x32
2666   0F90 53 24 1B      add a, proc_names
2667   0F93 3C            mov d, a
2668   0F94 19 00         mov al, 0
2669   0F96 3E            mov [d], al                           ; nullify process name
2670   0F97             
2671   0F97 1D 3E 18      mov al, [active_proc_index]
2672   0F9A 22 00         mov ah, 0  
2673   0F9C 3C            mov d, a
2674   0F9D 19 00         mov al, 0
2675   0F9F 3F 14 1B      mov [d + proc_availab_table], al    ; make process empty again
2676   0FA2               
2677   0FA2 1D 3D 18      mov al, [nbr_active_procs]          ; decrease nbr of active processes
2678   0FA5 80            dec al
2679   0FA6 3D 3D 18      mov [nbr_active_procs], al
2680   0FA9             
2681   0FA9             ; now load the shell process again
2682   0FA9 19 02         mov al, 2                           ; next process = process 2 = shell
2683   0FAB 3D 3E 18      mov [active_proc_index], al         ; set next active proc
2684   0FAE             
2685   0FAE             ; calculate lut entry for next process
2686   0FAE 22 00         mov ah, 0
2687   0FB0 FD 99         shl a                               ; x2
2688   0FB2 B7 7B 10      mov a, [proc_table_convert + a]     ; get process state start index  
2689   0FB5               
2690   0FB5 4D            mov si, a                           ; source is proc state block
2691   0FB6 48            mov a, sp
2692   0FB7 5F 13 00      sub a, 19
2693   0FBA 4F            mov di, a                           ; destination is kernel stack
2694   0FBB             ; restore sp
2695   0FBB 7D            dec a
2696   0FBC 47            mov sp, a
2697   0FBD 38 14 00      mov c, 20
2698   0FC0 FD F5         rep movsb
2699   0FC2             ; set vm process
2700   0FC2 1D 3E 18      mov al, [active_proc_index]
2701   0FC5 01            setptb
2702   0FC6                 
2703   0FC6 4C            popa
2704   0FC7 06            sysret
2705   0FC8             
2706   0FC8             ;----------------------------------------------------------------------------------------------------;
2707   0FC8             ; pause process
2708   0FC8             ;----------------------------------------------------------------------------------------------------;
2709   0FC8             syscall_pause_proc:
2710   0FC8             ; save all registers into kernel stack
2711   0FC8 4B            pusha
2712   0FC9 22 00         mov ah, 0
2713   0FCB 1D 3E 18      mov al, [active_proc_index]
2714   0FCE FD 99         shl a              ; x2
2715   0FD0 B7 7B 10      mov a, [proc_table_convert + a]   ; get process state start index
2716   0FD3                 
2717   0FD3 4F            mov di, a
2718   0FD4 48            mov a, sp
2719   0FD5 77            inc a
2720   0FD6 4D            mov si, a
2721   0FD7 38 14 00      mov c, 20
2722   0FDA FD F5         rep movsb                         ; save process state!
2723   0FDC             ; restore kernel stack position to point before interrupt arrived
2724   0FDC 51 14 00      add sp, 20
2725   0FDF             ; now load the shell process again
2726   0FDF 19 02         mov al, 2                         ; next process = process 2 = shell
2727   0FE1 3D 3E 18      mov [active_proc_index], al       ; set next active proc
2728   0FE4             
2729   0FE4             ; calculate lut entry for next process
2730   0FE4 22 00         mov ah, 0
2731   0FE6 FD 99         shl a                             ; x2
2732   0FE8 B7 7B 10      mov a, [proc_table_convert + a]   ; get process state start index  
2733   0FEB               
2734   0FEB 4D            mov si, a                         ; source is proc state block
2735   0FEC 48            mov a, sp
2736   0FED 5F 13 00      sub a, 19
2737   0FF0 4F            mov di, a                         ; destination is kernel stack
2738   0FF1             ; restore sp
2739   0FF1 7D            dec a
2740   0FF2 47            mov sp, a
2741   0FF3 38 14 00      mov c, 20
2742   0FF6 FD F5         rep movsb
2743   0FF8             ; set vm process
2744   0FF8 1D 3E 18      mov al, [active_proc_index]
2745   0FFB 01            setptb
2746   0FFC                 
2747   0FFC 4C            popa
2748   0FFD 06            sysret
2749   0FFE             
2750   0FFE             ;----------------------------------------------------------------------------------------------------;
2751   0FFE             ; create a new process
2752   0FFE             ; d = path of the process file to be createed
2753   0FFE             ; b = arguments ptr
2754   0FFE             ;----------------------------------------------------------------------------------------------------;
2755   0FFE             syscall_create_proc:
2756   0FFE             ; we save the active process first  
2757   0FFE 4B            pusha
2758   0FFF 22 00         mov ah, 0
2759   1001 1D 3E 18      mov al, [active_proc_index]
2760   1004 FD 99         shl a              ; x2
2761   1006 B7 7B 10      mov a, [proc_table_convert + a]    ; get process state table's start index
2762   1009               
2763   1009 4F            mov di, a
2764   100A 48            mov a, sp
2765   100B 77            inc a
2766   100C 4D            mov si, a
2767   100D 38 14 00      mov c, 20
2768   1010 FD F5         rep movsb                          ; save process state!
2769   1012             ; restore kernel stack position to point before interrupt arrived
2770   1012 51 14 00      add sp, 20
2771   1015               
2772   1015 FD 4E         mov si, d                          ; copy the file path
2773   1017 FD 4F A4 1D   mov di, user_data
2774   101B 38 00 02      mov c, 512
2775   101E 04            load
2776   101F 11            mov a, b
2777   1020 4D            mov si, a                          ; copy the arguments
2778   1021 FD 4F A4 23   mov di, scrap_sector
2779   1025 38 00 02      mov c, 512
2780   1028 04            load
2781   1029 07 9B 0A      call loadfile_from_path            ; load the process file from disk by path (path is in user_data)
2782   102C                                                  ; the file data is loaded into transient_area
2783   102C             ; now we allocate a new process  
2784   102C 07 5D 0F      call find_free_proc                ; index in a
2785   102F 01            setptb 
2786   1030 07 6F 0F      call proc_memory_map               ; map process memory pages
2787   1033             ; copy arguments into process's memory
2788   1033 FD 4D A4 23   mov si, scrap_sector
2789   1037 FD 4F 00 00   mov di, 0
2790   103B 38 00 02      mov c, 512
2791   103E 03            store
2792   103F             ; now copy process binary data into process's memory
2793   103F FD 4D A4 25   mov si, transient_area
2794   1043 FD 4F 00 04   mov di, text_org                   ; code origin address for all user processes
2795   1047 38 00 40      mov c, fs_file_size                ; size of memory space to copy, which is equal to the max file size in disk (for now)
2796   104A 03            store                              ; copy process data
2797   104B                 
2798   104B 07 5D 0F      call find_free_proc                ; index in a
2799   104E 3D 3E 18      mov [active_proc_index], al        ; set new active process
2800   1051 FD 9D 05      shl a, 5                           ; x32
2801   1054 53 24 1B      add a, proc_names
2802   1057 4F            mov di, a
2803   1058 FD 4D A4 1D   mov si, user_data                  ; copy and store process filename
2804   105C 07 65 11      call _strcpy
2805   105F               
2806   105F 07 5D 0F      call find_free_proc                ; index in a
2807   1062 3C            mov d, a
2808   1063 19 01         mov al, 1
2809   1065 3F 14 1B      mov [d + proc_availab_table], al   ; make process busy
2810   1068               
2811   1068 1D 3D 18      mov al, [nbr_active_procs]         ; increase nbr of active processes
2812   106B 7A            inc al
2813   106C 3D 3D 18      mov [nbr_active_procs], al
2814   106F             ; launch process
2815   106F FD D7 FF FF   push word $ffff 
2816   1073 FD DB 0E      push byte %00001110                ; dma_ack = 0, interrupts enabled = 1, mode = user, paging = on, halt=0, display_reg_load=0, dir=0
2817   1076 FD D7 00 04   push word text_org
2818   107A 06            sysret
2819   107B             
2820   107B             proc_table_convert:
2821   107B D4 19         .dw proc_state_table + 0
2822   107D E8 19         .dw proc_state_table + 20
2823   107F FC 19         .dw proc_state_table + 40
2824   1081 10 1A         .dw proc_state_table + 60
2825   1083 24 1A         .dw proc_state_table + 80
2826   1085 38 1A         .dw proc_state_table + 100
2827   1087 4C 1A         .dw proc_state_table + 120
2828   1089 60 1A         .dw proc_state_table + 140
2829   108B               
2830   108B             ;----------------------------------------------------------------------------------------------;
2831   108B             ; get hex file
2832   108B             ; di = destination address
2833   108B             ; return length in bytes in c
2834   108B             ;----------------------------------------------------------------------------------------------;
2835   108B             _load_hex:
2836   108B D7            push a
2837   108C D8            push b
2838   108D DA            push d
2839   108E E2            push si
2840   108F E3            push di
2841   1090 38 00 00      mov c, 0
2842   1093 50            mov a, di
2843   1094 3C            mov d, a          ; start of string data block
2844   1095 07 E8 11      call _gets        ; get program string
2845   1098 4D            mov si, a
2846   1099             __load_hex_loop:
2847   1099 F6            lodsb             ; load from [si] to al
2848   109A B9 00         cmp al, 0         ; check if ascii 0
2849   109C C6 AA 10      jz __load_hex_ret
2850   109F 36            mov bh, al
2851   10A0 F6            lodsb
2852   10A1 2F            mov bl, al
2853   10A2 07 9E 11      call _atoi        ; convert ascii byte in b to int (to al)
2854   10A5 F7            stosb             ; store al to [di]
2855   10A6 78            inc c
2856   10A7 0A 99 10      jmp __load_hex_loop
2857   10AA             __load_hex_ret:
2858   10AA F0            pop di
2859   10AB EF            pop si
2860   10AC E7            pop d
2861   10AD E5            pop b
2862   10AE E4            pop a
2863   10AF 09            ret
2864   10B0             
2865   10B0             ; synopsis: look inside a certain directory for files/directories
2866   10B0             ; before calling this function, cd into required directory
2867   10B0             ; for each entry inside directory:
2868   10B0             ;  if entry is a file:
2869   10B0             ;    compare filename to searched filename
2870   10B0             ;    if filenames are the same, print filename
2871   10B0             ;  else if entry is a directory:
2872   10B0             ;    cd to the given directory
2873   10B0             ;    recursively call cmd_find
2874   10B0             ;    cd outside previous directory
2875   10B0             ;  if current entry == last entry, return
2876   10B0             ; endfor
2877   10B0             f_find:
2878   10B0 09            ret
2879   10B1             
2880   10B1             
2881   10B1             ; ---------------------------------------------------------------------
2882   10B1             ; kernel reset vector
2883   10B1             ; ---------------------------------------------------------------------
2884   10B1             kernel_reset_vector:  
2885   10B1 FD 49 FF F7   mov bp, stack_begin
2886   10B5 FD 47 FF F7   mov sp, stack_begin
2887   10B9               
2888   10B9 19 81         mov al, %10000001             ; mask out timer interrupt for now - enable uart and fdc irqs 
2889   10BB FD 0F         stomsk                        
2890   10BD FD 0C         sti  
2891   10BF             
2892   10BF 0C            lodstat
2893   10C0 87 DF         and al, %11011111             ; disable display register loading
2894   10C2 0D            stostat
2895   10C3               
2896   10C3             ; reset fifo pointers
2897   10C3 10 A4 1F      mov a, fifo
2898   10C6 3B 43 18      mov d, fifo_in
2899   10C9 43            mov [d], a
2900   10CA 3B 45 18      mov d, fifo_out
2901   10CD 43            mov [d], a  
2902   10CE 19 02         mov al, 2
2903   10D0 05 03         syscall sys_io                ; enable uart in interrupt mode
2904   10D2             
2905   10D2 3B 98 18      mov d, s_kernel_started
2906   10D5 07 0D 13      call _puts
2907   10D8             
2908   10D8 3B 92 19      mov d, s_fdc_config
2909   10DB 07 0D 13      call _puts
2910   10DE F2 C0 FF 0E   mov byte [_fdc_config], %00001110  ; %00001001 : turn led on / head load, disable double density, select side 0, select drive 0, do not select drive 1
2911   10E2 F2 C8 FF 08   mov byte [_fdc_stat_cmd], %00001000     ; leave this restore command in order to clear BUSY flag
2912   10E6 F2 C9 FF 00   mov byte [_fdc_track], $00 ; reset track
2913   10EA             
2914   10EA 19 10         mov al, 16
2915   10EC 05 04         syscall sys_filesystem        ; set root dirid
2916   10EE             
2917   10EE 3B B5 18      mov d, s_prompt_init
2918   10F1 07 0D 13      call _puts
2919   10F4 3B 49 18      mov d, s_init_path
2920   10F7 05 05         syscall sys_create_proc       ; launch init as a new process
2921   10F9             
2922   10F9             
2923   10F9             ; file includes
2924   10F9             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  10F9             boot_origin      .EQU  $8004
0002+  10F9             bios_uart        .EQU  $0002
0003+  10F9             bios_ide         .EQU  $0003
0004+  10F9             bios_reset_vector .EQU  $01c0
0005+  10F9             ide_buffer       .EQU  $8204
2925   10F9             .include "lib/stdio.asm"
0001+  10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  10F9             ; stdio.s
0003+  10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  10F9             .include "lib/string.asm"
0001++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 10F9             ; string.s
0003++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 10F9             
0005++ 10F9             
0006++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 10F9             ; _strrev
0008++ 10F9             ; reverse a string
0009++ 10F9             ; d = string address
0010++ 10F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 10F9             ; 01234
0012++ 10F9             _strrev:
0013++ 10F9 4B          	pusha
0014++ 10FA 07 40 11    	call _strlen	; length in c
0015++ 10FD 12          	mov a, c
0016++ 10FE AF 01 00    	cmp a, 1
0017++ 1101 D0 1B 11    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 1104 7D          	dec a
0019++ 1105 FD 4E       	mov si, d	; beginning of string
0020++ 1107 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 1109 59          	add d, a	; end of string
0022++ 110A 12          	mov a, c
0023++ 110B FD 9B       	shr a		; divide by 2
0024++ 110D 39          	mov c, a	; c now counts the steps
0025++ 110E             _strrev_l0:
0026++ 110E 32          	mov bl, [d]	; save load right-side char into bl
0027++ 110F F6          	lodsb		; load left-side char into al; increase si
0028++ 1110 3E          	mov [d], al	; store left char into right side
0029++ 1111 1B          	mov al, bl
0030++ 1112 F7          	stosb		; store right-side char into left-side; increase di
0031++ 1113 7E          	dec c
0032++ 1114 7F          	dec d
0033++ 1115 C2 00 00    	cmp c, 0
0034++ 1118 C7 0E 11    	jne _strrev_l0
0035++ 111B             _strrev_end:
0036++ 111B 4C          	popa
0037++ 111C 09          	ret
0038++ 111D             	
0039++ 111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 111D             ; _strchr
0041++ 111D             ; search string in d for char in al
0042++ 111D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 111D             _strchr:
0044++ 111D             _strchr_l0:
0045++ 111D 32          	mov bl, [d]
0046++ 111E C1 00       	cmp bl, 0
0047++ 1120 C6 2B 11    	je _strchr_end
0048++ 1123 BA          	cmp al, bl
0049++ 1124 C6 2B 11    	je _strchr_end
0050++ 1127 79          	inc d
0051++ 1128 0A 1D 11    	jmp _strchr_l0
0052++ 112B             _strchr_end:
0053++ 112B 1B          	mov al, bl
0054++ 112C 09          	ret
0055++ 112D             
0056++ 112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 112D             ; _strstr
0058++ 112D             ; find sub-string
0059++ 112D             ; str1 in si
0060++ 112D             ; str2 in di
0061++ 112D             ; si points to end of source string
0062++ 112D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 112D             _strstr:
0064++ 112D DB          	push al
0065++ 112E DA          	push d
0066++ 112F E3          	push di
0067++ 1130             _strstr_loop:
0068++ 1130 F3          	cmpsb					; compare a byte of the strings
0069++ 1131 C7 3C 11    	jne _strstr_ret
0070++ 1134 FC 00 00    	lea d, [di + 0]
0071++ 1137 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 1139 C7 30 11    	jne _strstr_loop				; equal chars but not at end
0073++ 113C             _strstr_ret:
0074++ 113C F0          	pop di
0075++ 113D E7          	pop d
0076++ 113E E8          	pop al
0077++ 113F 09          	ret
0078++ 1140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 1140             ; length of null terminated string
0080++ 1140             ; result in c
0081++ 1140             ; pointer in d
0082++ 1140             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 1140             _strlen:
0084++ 1140 DA          	push d
0085++ 1141 38 00 00    	mov c, 0
0086++ 1144             _strlen_l1:
0087++ 1144 BD 00       	cmp byte [d], 0
0088++ 1146 C6 4E 11    	je _strlen_ret
0089++ 1149 79          	inc d
0090++ 114A 78          	inc c
0091++ 114B 0A 44 11    	jmp _strlen_l1
0092++ 114E             _strlen_ret:
0093++ 114E E7          	pop d
0094++ 114F 09          	ret
0095++ 1150             
0096++ 1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 1150             ; strcmp
0098++ 1150             ; compare two strings
0099++ 1150             ; str1 in si
0100++ 1150             ; str2 in di
0101++ 1150             ; create a string compairon instrucion ?????
0102++ 1150             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 1150             _strcmp:
0104++ 1150 DB          	push al
0105++ 1151 DA          	push d
0106++ 1152 E3          	push di
0107++ 1153 E2          	push si
0108++ 1154             _strcmp_loop:
0109++ 1154 F3          	cmpsb					; compare a byte of the strings
0110++ 1155 C7 60 11    	jne _strcmp_ret
0111++ 1158 FB FF FF    	lea d, [si +- 1]
0112++ 115B BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 115D C7 54 11    	jne _strcmp_loop				; equal chars but not at end
0114++ 1160             _strcmp_ret:
0115++ 1160 EF          	pop si
0116++ 1161 F0          	pop di
0117++ 1162 E7          	pop d
0118++ 1163 E8          	pop al
0119++ 1164 09          	ret
0120++ 1165             
0121++ 1165             
0122++ 1165             ; strcpy
0123++ 1165             ; copy null terminated string from si to di
0124++ 1165             ; source in si
0125++ 1165             ; destination in di
0126++ 1165             _strcpy:
0127++ 1165 E2          	push si
0128++ 1166 E3          	push di
0129++ 1167 DB          	push al
0130++ 1168             _strcpy_l1:
0131++ 1168 F6          	lodsb
0132++ 1169 F7          	stosb
0133++ 116A B9 00       	cmp al, 0
0134++ 116C C7 68 11    	jne _strcpy_l1
0135++ 116F             _strcpy_end:
0136++ 116F E8          	pop al
0137++ 1170 F0          	pop di
0138++ 1171 EF          	pop si
0139++ 1172 09          	ret
0140++ 1173             
0141++ 1173             ; strcat
0142++ 1173             ; concatenate a null terminated string into string at di, from string at si
0143++ 1173             ; source in si
0144++ 1173             ; destination in di
0145++ 1173             _strcat:
0146++ 1173 E2          	push si
0147++ 1174 E3          	push di
0148++ 1175 D7          	push a
0149++ 1176 DA          	push d
0150++ 1177 50          	mov a, di
0151++ 1178 3C          	mov d, a
0152++ 1179             _strcat_goto_end_l1:
0153++ 1179 BD 00       	cmp byte[d], 0
0154++ 117B C6 82 11    	je _strcat_start
0155++ 117E 79          	inc d
0156++ 117F 0A 79 11    	jmp _strcat_goto_end_l1
0157++ 1182             _strcat_start:
0158++ 1182 FD 50       	mov di, d
0159++ 1184             _strcat_l1:
0160++ 1184 F6          	lodsb
0161++ 1185 F7          	stosb
0162++ 1186 B9 00       	cmp al, 0
0163++ 1188 C7 84 11    	jne _strcat_l1
0164++ 118B             _strcat_end:
0165++ 118B E7          	pop d
0166++ 118C E4          	pop a
0167++ 118D F0          	pop di
0168++ 118E EF          	pop si
0169++ 118F 09          	ret
0170++ 1190             
0171++ 1190             
0005+  1190             
0006+  1190             
0007+  1190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  1190             ; convert ascii 'o'..'f' to integer 0..15
0009+  1190             ; ascii in bl
0010+  1190             ; result in al
0011+  1190             ; ascii for f = 0100 0110
0012+  1190             ; ascii for 9 = 0011 1001
0013+  1190             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  1190             hex_ascii_encode:
0015+  1190 1B            mov al, bl
0016+  1191 93 40         test al, $40        ; test if letter or number
0017+  1193 C7 99 11      jnz hex_letter
0018+  1196 87 0F         and al, $0f        ; get number
0019+  1198 09            ret
0020+  1199             hex_letter:
0021+  1199 87 0F         and al, $0f        ; get letter
0022+  119B 6A 09         add al, 9
0023+  119D 09            ret
0024+  119E             
0025+  119E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  119E             ; atoi
0027+  119E             ; 2 letter hex string in b
0028+  119E             ; 8bit integer returned in al
0029+  119E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  119E             _atoi:
0031+  119E D8            push b
0032+  119F 07 90 11      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  11A2 30            mov bl, bh
0034+  11A3 DB            push al          ; save a
0035+  11A4 07 90 11      call hex_ascii_encode
0036+  11A7 EA            pop bl  
0037+  11A8 FD 9E 04      shl al, 4
0038+  11AB 8C            or al, bl
0039+  11AC E5            pop b
0040+  11AD 09            ret  
0041+  11AE             
0042+  11AE             
0043+  11AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  11AE             ; scanf
0045+  11AE             ; no need for explanations!
0046+  11AE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  11AE             scanf:
0048+  11AE 09            ret
0049+  11AF             
0050+  11AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  11AF             ; itoa
0052+  11AF             ; 8bit value in bl
0053+  11AF             ; 2 byte ascii result in a
0054+  11AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  11AF             _itoa:
0056+  11AF DA            push d
0057+  11B0 D8            push b
0058+  11B1 A7 00         mov bh, 0
0059+  11B3 FD A4 04      shr bl, 4  
0060+  11B6 74            mov d, b
0061+  11B7 1F 49 14      mov al, [d + s_hex_digits]
0062+  11BA 23            mov ah, al
0063+  11BB               
0064+  11BB E5            pop b
0065+  11BC D8            push b
0066+  11BD A7 00         mov bh, 0
0067+  11BF FD 87 0F      and bl, $0f
0068+  11C2 74            mov d, b
0069+  11C3 1F 49 14      mov al, [d + s_hex_digits]
0070+  11C6 E5            pop b
0071+  11C7 E7            pop d
0072+  11C8 09            ret
0073+  11C9             
0074+  11C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  11C9             ; hex string to binary
0076+  11C9             ; di = destination address
0077+  11C9             ; si = source
0078+  11C9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  11C9             _hex_to_int:
0080+  11C9             _hex_to_int_l1:
0081+  11C9 F6            lodsb          ; load from [si] to al
0082+  11CA B9 00         cmp al, 0        ; check if ascii 0
0083+  11CC C6 D9 11      jz _hex_to_int_ret
0084+  11CF 36            mov bh, al
0085+  11D0 F6            lodsb
0086+  11D1 2F            mov bl, al
0087+  11D2 07 9E 11      call _atoi        ; convert ascii byte in b to int (to al)
0088+  11D5 F7            stosb          ; store al to [di]
0089+  11D6 0A C9 11      jmp _hex_to_int_l1
0090+  11D9             _hex_to_int_ret:
0091+  11D9 09            ret    
0092+  11DA             
0093+  11DA             
0094+  11DA             
0095+  11DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  11DA             ; getchar
0097+  11DA             ; char in ah
0098+  11DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  11DA             getch:
0100+  11DA DB            push al
0101+  11DB             getch_retry:
0102+  11DB 19 01         mov al, 1
0103+  11DD 05 03         syscall sys_io      ; receive in ah
0104+  11DF E8            pop al
0105+  11E0 09            ret
0106+  11E1             
0107+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  11E1             ; putchar
0109+  11E1             ; char in ah
0110+  11E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  11E1             _putchar:
0112+  11E1 DB            push al
0113+  11E2 19 00         mov al, 0
0114+  11E4 05 03         syscall sys_io      ; char in ah
0115+  11E6 E8            pop al
0116+  11E7 09            ret
0117+  11E8             
0118+  11E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  11E8             ;; input a string
0120+  11E8             ;; terminates with null
0121+  11E8             ;; pointer in d
0122+  11E8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  11E8             _gets:
0124+  11E8 D7            push a
0125+  11E9 DA            push d
0126+  11EA             _gets_loop:
0127+  11EA 19 01         mov al, 1
0128+  11EC 05 03         syscall sys_io      ; receive in ah
0129+  11EE 76 1B         cmp ah, 27
0130+  11F0 C6 11 12      je _gets_ansi_esc
0131+  11F3 76 0A         cmp ah, $0a        ; lf
0132+  11F5 C6 6D 12      je _gets_end
0133+  11F8 76 0D         cmp ah, $0d        ; cr
0134+  11FA C6 6D 12      je _gets_end
0135+  11FD 76 5C         cmp ah, $5c        ; '\\'
0136+  11FF C6 33 12      je _gets_escape
0137+  1202 76 08         cmp ah, $08      ; check for backspace
0138+  1204 C6 0D 12      je _gets_backspace
0139+  1207 1A            mov al, ah
0140+  1208 3E            mov [d], al
0141+  1209 79            inc d
0142+  120A 0A EA 11      jmp _gets_loop
0143+  120D             _gets_backspace:
0144+  120D 7F            dec d
0145+  120E 0A EA 11      jmp _gets_loop
0146+  1211             _gets_ansi_esc:
0147+  1211 19 01         mov al, 1
0148+  1213 05 03         syscall sys_io        ; receive in ah without echo
0149+  1215 76 5B         cmp ah, '['
0150+  1217 C7 EA 11      jne _gets_loop
0151+  121A 19 01         mov al, 1
0152+  121C 05 03         syscall sys_io          ; receive in ah without echo
0153+  121E 76 64         cmp ah, 'd'
0154+  1220 C6 2B 12      je _gets_left_arrow
0155+  1223 76 63         cmp ah, 'c'
0156+  1225 C6 2F 12      je _gets_right_arrow
0157+  1228 0A EA 11      jmp _gets_loop
0158+  122B             _gets_left_arrow:
0159+  122B 7F            dec d
0160+  122C 0A EA 11      jmp _gets_loop
0161+  122F             _gets_right_arrow:
0162+  122F 79            inc d
0163+  1230 0A EA 11      jmp _gets_loop
0164+  1233             _gets_escape:
0165+  1233 19 01         mov al, 1
0166+  1235 05 03         syscall sys_io      ; receive in ah
0167+  1237 76 6E         cmp ah, 'n'
0168+  1239 C6 58 12      je _gets_lf
0169+  123C 76 72         cmp ah, 'r'
0170+  123E C6 5F 12      je _gets_cr
0171+  1241 76 30         cmp ah, '0'
0172+  1243 C6 66 12      je _gets_null
0173+  1246 76 5C         cmp ah, $5c  ; '\'
0174+  1248 C6 51 12      je _gets_slash
0175+  124B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  124C 3E            mov [d], al
0177+  124D 79            inc d
0178+  124E 0A EA 11      jmp _gets_loop
0179+  1251             _gets_slash:
0180+  1251 19 5C         mov al, $5c
0181+  1253 3E            mov [d], al
0182+  1254 79            inc d
0183+  1255 0A EA 11      jmp _gets_loop
0184+  1258             _gets_lf:
0185+  1258 19 0A         mov al, $0a
0186+  125A 3E            mov [d], al
0187+  125B 79            inc d
0188+  125C 0A EA 11      jmp _gets_loop
0189+  125F             _gets_cr:
0190+  125F 19 0D         mov al, $0d
0191+  1261 3E            mov [d], al
0192+  1262 79            inc d
0193+  1263 0A EA 11      jmp _gets_loop
0194+  1266             _gets_null:
0195+  1266 19 00         mov al, $00
0196+  1268 3E            mov [d], al
0197+  1269 79            inc d
0198+  126A 0A EA 11      jmp _gets_loop
0199+  126D             _gets_end:
0200+  126D 19 00         mov al, 0
0201+  126F 3E            mov [d], al        ; terminate string
0202+  1270 E7            pop d
0203+  1271 E4            pop a
0204+  1272 09            ret
0205+  1273             
0206+  1273             
0207+  1273             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  1273             ;; input text
0209+  1273             ;; terminated with ctrl+d
0210+  1273             ;; pointer in d
0211+  1273             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  1273             _gettxt:
0213+  1273 D7            push a
0214+  1274 DA            push d
0215+  1275             _gettxt_loop:
0216+  1275 19 01         mov al, 1
0217+  1277 05 03         syscall sys_io      ; receive in ah
0218+  1279 76 04         cmp ah, 4      ; eot
0219+  127B C6 B4 12      je _gettxt_end
0220+  127E 76 08         cmp ah, $08      ; check for backspace
0221+  1280 C6 B0 12      je _gettxt_backspace
0222+  1283 76 5C         cmp ah, $5c        ; '\'
0223+  1285 C6 8E 12      je _gettxt_escape
0224+  1288 1A            mov al, ah
0225+  1289 3E            mov [d], al
0226+  128A 79            inc d
0227+  128B 0A 75 12      jmp _gettxt_loop
0228+  128E             _gettxt_escape:
0229+  128E 19 01         mov al, 1
0230+  1290 05 03         syscall sys_io      ; receive in ah
0231+  1292 76 6E         cmp ah, 'n'
0232+  1294 C6 A2 12      je _gettxt_lf
0233+  1297 76 72         cmp ah, 'r'
0234+  1299 C6 A9 12      je _gettxt_cr
0235+  129C 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  129D 3E            mov [d], al
0237+  129E 79            inc d
0238+  129F 0A 75 12      jmp _gettxt_loop
0239+  12A2             _gettxt_lf:
0240+  12A2 19 0A         mov al, $0a
0241+  12A4 3E            mov [d], al
0242+  12A5 79            inc d
0243+  12A6 0A 75 12      jmp _gettxt_loop
0244+  12A9             _gettxt_cr:
0245+  12A9 19 0D         mov al, $0d
0246+  12AB 3E            mov [d], al
0247+  12AC 79            inc d
0248+  12AD 0A 75 12      jmp _gettxt_loop
0249+  12B0             _gettxt_backspace:
0250+  12B0 7F            dec d
0251+  12B1 0A 75 12      jmp _gettxt_loop
0252+  12B4             _gettxt_end:
0253+  12B4 19 00         mov al, 0
0254+  12B6 3E            mov [d], al        ; terminate string
0255+  12B7 E7            pop d
0256+  12B8 E4            pop a
0257+  12B9 09            ret
0258+  12BA             
0259+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  12BA             ; print new line
0261+  12BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  12BA             printnl:
0263+  12BA D7            push a
0264+  12BB 10 00 0A      mov a, $0a00
0265+  12BE 05 03         syscall sys_io
0266+  12C0 10 00 0D      mov a, $0d00
0267+  12C3 05 03         syscall sys_io
0268+  12C5 E4            pop a
0269+  12C6 09            ret
0270+  12C7             
0271+  12C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  12C7             ; _strtoint
0273+  12C7             ; 4 digit hex string number in d
0274+  12C7             ; integer returned in a
0275+  12C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  12C7             _strtointx:
0277+  12C7 D8            push b
0278+  12C8 32            mov bl, [d]
0279+  12C9 37            mov bh, bl
0280+  12CA 33 01 00      mov bl, [d + 1]
0281+  12CD 07 9E 11      call _atoi        ; convert to int in al
0282+  12D0 23            mov ah, al        ; move to ah
0283+  12D1 33 02 00      mov bl, [d + 2]
0284+  12D4 37            mov bh, bl
0285+  12D5 33 03 00      mov bl, [d + 3]
0286+  12D8 07 9E 11      call _atoi        ; convert to int in al
0287+  12DB E5            pop b
0288+  12DC 09            ret
0289+  12DD             
0290+  12DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  12DD             ; _strtoint
0292+  12DD             ; 5 digit base10 string number in d
0293+  12DD             ; integer returned in a
0294+  12DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  12DD             _strtoint:
0296+  12DD E2            push si
0297+  12DE D8            push b
0298+  12DF D9            push c
0299+  12E0 DA            push d
0300+  12E1 07 40 11      call _strlen      ; get string length in c
0301+  12E4 7E            dec c
0302+  12E5 FD 4E         mov si, d
0303+  12E7 12            mov a, c
0304+  12E8 FD 99         shl a
0305+  12EA 3B 61 14      mov d, table_power
0306+  12ED 59            add d, a
0307+  12EE 38 00 00      mov c, 0
0308+  12F1             _strtoint_l0:
0309+  12F1 F6            lodsb      ; load ascii to al
0310+  12F2 B9 00         cmp al, 0
0311+  12F4 C6 07 13      je _strtoint_end
0312+  12F7 6F 30         sub al, $30    ; make into integer
0313+  12F9 22 00         mov ah, 0
0314+  12FB 2A            mov b, [d]
0315+  12FC AC            mul a, b      ; result in b since it fits in 16bits
0316+  12FD 11            mov a, b
0317+  12FE 28            mov b, c
0318+  12FF 54            add a, b
0319+  1300 39            mov c, a
0320+  1301 63 02 00      sub d, 2
0321+  1304 0A F1 12      jmp _strtoint_l0
0322+  1307             _strtoint_end:
0323+  1307 12            mov a, c
0324+  1308 E7            pop d
0325+  1309 E6            pop c
0326+  130A E5            pop b
0327+  130B EF            pop si
0328+  130C 09            ret
0329+  130D             
0330+  130D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  130D             ; print null terminated string
0332+  130D             ; pointer in d
0333+  130D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  130D             _puts:
0335+  130D D7            push a
0336+  130E DA            push d
0337+  130F             _puts_l1:
0338+  130F 1E            mov al, [d]
0339+  1310 B9 00         cmp al, 0
0340+  1312 C6 1E 13      jz _puts_end
0341+  1315 23            mov ah, al
0342+  1316 19 00         mov al, 0
0343+  1318 05 03         syscall sys_io
0344+  131A 79            inc d
0345+  131B 0A 0F 13      jmp _puts_l1
0346+  131E             _puts_end:
0347+  131E E7            pop d
0348+  131F E4            pop a
0349+  1320 09            ret
0350+  1321             
0351+  1321             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  1321             ; print n size string
0353+  1321             ; pointer in d
0354+  1321             ; size in c
0355+  1321             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  1321             _putsn:
0357+  1321 DB            push al
0358+  1322 DA            push d
0359+  1323 D9            push c
0360+  1324             _putsn_l0:
0361+  1324 1E            mov al, [d]
0362+  1325 23            mov ah, al
0363+  1326 19 00         mov al, 0
0364+  1328 05 03         syscall sys_io
0365+  132A 79            inc d
0366+  132B 7E            dec c  
0367+  132C C2 00 00      cmp c, 0
0368+  132F C7 24 13      jne _putsn_l0
0369+  1332             _putsn_end:
0370+  1332 E6            pop c
0371+  1333 E7            pop d
0372+  1334 E8            pop al
0373+  1335 09            ret
0374+  1336             
0375+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  1336             ; print 16bit decimal number
0377+  1336             ; input number in a
0378+  1336             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  1336             print_u16d:
0380+  1336 D7            push a
0381+  1337 D8            push b
0382+  1338 FD D8         push g
0383+  133A 26 10 27      mov b, 10000
0384+  133D AE            div a, b      ; get 10000's coeff.
0385+  133E 07 62 13      call print_number
0386+  1341 11            mov a, b
0387+  1342 26 E8 03      mov b, 1000
0388+  1345 AE            div a, b      ; get 1000's coeff.
0389+  1346 07 62 13      call print_number
0390+  1349 11            mov a, b
0391+  134A 26 64 00      mov b, 100
0392+  134D AE            div a, b
0393+  134E 07 62 13      call print_number
0394+  1351 11            mov a, b
0395+  1352 26 0A 00      mov b, 10
0396+  1355 AE            div a, b
0397+  1356 07 62 13      call print_number
0398+  1359 1B            mov al, bl      ; 1's coeff in bl
0399+  135A 07 62 13      call print_number
0400+  135D FD F1         pop g
0401+  135F E5            pop b
0402+  1360 E4            pop a
0403+  1361 09            ret
0404+  1362             
0405+  1362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  1362             ; print al
0407+  1362             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  1362             print_number:
0409+  1362 6A 30         add al, $30
0410+  1364 23            mov ah, al
0411+  1365 07 E1 11      call _putchar
0412+  1368 09            ret
0413+  1369             
0414+  1369             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  1369             ; print 16bit hex integer
0416+  1369             ; integer value in reg b
0417+  1369             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  1369             print_u16x:
0419+  1369 D7            push a
0420+  136A D8            push b
0421+  136B DD            push bl
0422+  136C 30            mov bl, bh
0423+  136D 07 AF 11      call _itoa        ; convert bh to char in a
0424+  1370 2F            mov bl, al        ; save al
0425+  1371 19 00         mov al, 0
0426+  1373 05 03         syscall sys_io        ; display ah
0427+  1375 24            mov ah, bl        ; retrieve al
0428+  1376 19 00         mov al, 0
0429+  1378 05 03         syscall sys_io        ; display al
0430+  137A             
0431+  137A EA            pop bl
0432+  137B 07 AF 11      call _itoa        ; convert bh to char in a
0433+  137E 2F            mov bl, al        ; save al
0434+  137F 19 00         mov al, 0
0435+  1381 05 03         syscall sys_io        ; display ah
0436+  1383 24            mov ah, bl        ; retrieve al
0437+  1384 19 00         mov al, 0
0438+  1386 05 03         syscall sys_io        ; display al
0439+  1388             
0440+  1388 E5            pop b
0441+  1389 E4            pop a
0442+  138A 09            ret
0443+  138B             
0444+  138B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  138B             ; input 16bit hex integer
0446+  138B             ; read 16bit integer into a
0447+  138B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  138B             scan_u16x:
0449+  138B F8 10 00      enter 16
0450+  138E D8            push b
0451+  138F DA            push d
0452+  1390             
0453+  1390 FA F1 FF      lea d, [bp + -15]
0454+  1393 07 E8 11      call _gets        ; get number
0455+  1396             
0456+  1396 32            mov bl, [d]
0457+  1397 37            mov bh, bl
0458+  1398 33 01 00      mov bl, [d + 1]
0459+  139B 07 9E 11      call _atoi        ; convert to int in al
0460+  139E 23            mov ah, al        ; move to ah
0461+  139F             
0462+  139F 33 02 00      mov bl, [d + 2]
0463+  13A2 37            mov bh, bl
0464+  13A3 33 03 00      mov bl, [d + 3]
0465+  13A6 07 9E 11      call _atoi        ; convert to int in al
0466+  13A9             
0467+  13A9 E7            pop d
0468+  13AA E5            pop b
0469+  13AB F9            leave
0470+  13AC 09            ret
0471+  13AD             
0472+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  13AD             ; print 8bit hex integer
0474+  13AD             ; integer value in reg bl
0475+  13AD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  13AD             print_u8x:
0477+  13AD D7            push a
0478+  13AE DD            push bl
0479+  13AF             
0480+  13AF 07 AF 11      call _itoa        ; convert bl to char in a
0481+  13B2 2F            mov bl, al        ; save al
0482+  13B3 19 00         mov al, 0
0483+  13B5 05 03         syscall sys_io        ; display ah
0484+  13B7 24            mov ah, bl        ; retrieve al
0485+  13B8 19 00         mov al, 0
0486+  13BA 05 03         syscall sys_io        ; display al
0487+  13BC             
0488+  13BC EA            pop bl
0489+  13BD E4            pop a
0490+  13BE 09            ret
0491+  13BF             
0492+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  13BF             ; print 8bit decimal unsigned number
0494+  13BF             ; input number in al
0495+  13BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  13BF             print_u8d:
0497+  13BF D7            push a
0498+  13C0 D8            push b
0499+  13C1 FD D8         push g
0500+  13C3 22 00         mov ah, 0
0501+  13C5 26 64 00      mov b, 100
0502+  13C8 AE            div a, b
0503+  13C9 D8            push b      ; save remainder
0504+  13CA B9 00         cmp al, 0
0505+  13CC C6 D6 13      je skip100
0506+  13CF 6A 30         add al, $30
0507+  13D1 23            mov ah, al
0508+  13D2 19 00         mov al, 0
0509+  13D4 05 03         syscall sys_io  ; print coeff
0510+  13D6             skip100:
0511+  13D6 E4            pop a
0512+  13D7 22 00         mov ah, 0
0513+  13D9 26 0A 00      mov b, 10
0514+  13DC AE            div a, b
0515+  13DD D8            push b      ; save remainder
0516+  13DE B9 00         cmp al, 0
0517+  13E0 C6 EA 13      je skip10
0518+  13E3 6A 30         add al, $30
0519+  13E5 23            mov ah, al
0520+  13E6 19 00         mov al, 0
0521+  13E8 05 03         syscall sys_io  ; print coeff
0522+  13EA             skip10:
0523+  13EA E4            pop a
0524+  13EB 1B            mov al, bl
0525+  13EC 6A 30         add al, $30
0526+  13EE 23            mov ah, al
0527+  13EF 19 00         mov al, 0
0528+  13F1 05 03         syscall sys_io  ; print coeff
0529+  13F3 FD F1         pop g
0530+  13F5 E5            pop b
0531+  13F6 E4            pop a
0532+  13F7 09            ret
0533+  13F8             
0534+  13F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  13F8             ; input 8bit hex integer
0536+  13F8             ; read 8bit integer into al
0537+  13F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  13F8             scan_u8x:
0539+  13F8 F8 04 00      enter 4
0540+  13FB D8            push b
0541+  13FC DA            push d
0542+  13FD             
0543+  13FD FA FD FF      lea d, [bp + -3]
0544+  1400 07 E8 11      call _gets        ; get number
0545+  1403             
0546+  1403 32            mov bl, [d]
0547+  1404 37            mov bh, bl
0548+  1405 33 01 00      mov bl, [d + 1]
0549+  1408 07 9E 11      call _atoi        ; convert to int in al
0550+  140B             
0551+  140B E7            pop d
0552+  140C E5            pop b
0553+  140D F9            leave
0554+  140E 09            ret
0555+  140F             
0556+  140F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  140F             ; input decimal number
0558+  140F             ; result in a
0559+  140F             ; 655'\0'
0560+  140F             ; low--------high
0561+  140F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  140F             scan_u16d:
0563+  140F F8 08 00      enter 8
0564+  1412 E2            push si
0565+  1413 D8            push b
0566+  1414 D9            push c
0567+  1415 DA            push d
0568+  1416 FA F9 FF      lea d, [bp +- 7]
0569+  1419 07 E8 11      call _gets
0570+  141C 07 40 11      call _strlen      ; get string length in c
0571+  141F 7E            dec c
0572+  1420 FD 4E         mov si, d
0573+  1422 12            mov a, c
0574+  1423 FD 99         shl a
0575+  1425 3B 61 14      mov d, table_power
0576+  1428 59            add d, a
0577+  1429 38 00 00      mov c, 0
0578+  142C             mul_loop:
0579+  142C F6            lodsb      ; load ascii to al
0580+  142D B9 00         cmp al, 0
0581+  142F C6 42 14      je mul_exit
0582+  1432 6F 30         sub al, $30    ; make into integer
0583+  1434 22 00         mov ah, 0
0584+  1436 2A            mov b, [d]
0585+  1437 AC            mul a, b      ; result in b since it fits in 16bits
0586+  1438 11            mov a, b
0587+  1439 28            mov b, c
0588+  143A 54            add a, b
0589+  143B 39            mov c, a
0590+  143C 63 02 00      sub d, 2
0591+  143F 0A 2C 14      jmp mul_loop
0592+  1442             mul_exit:
0593+  1442 12            mov a, c
0594+  1443 E7            pop d
0595+  1444 E6            pop c
0596+  1445 E5            pop b
0597+  1446 EF            pop si
0598+  1447 F9            leave
0599+  1448 09            ret
0600+  1449             
0601+  1449             
0602+  1449 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  144D 34 35 36 37 
0602+  1451 38 39 61 62 
0602+  1455 63 64 65 66 
0603+  1459 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  145D 1B 5B 68 00 
0604+  1461             
0605+  1461             table_power:
0606+  1461 01 00         .dw 1
0607+  1463 0A 00         .dw 10
0608+  1465 64 00         .dw 100
0609+  1467 E8 03         .dw 1000
0610+  1469 10 27         .dw 100002926   146B             .include "lib/ctype.asm"
0001+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  146B             ; ctype.s
0003+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  146B             
0005+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  146B             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  146B             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  146B             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  146B             ;; characters are supported.
0010+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  146B             ;; _isalnum 
0012+  146B             ;; _isalpha 
0013+  146B             ;; islower 
0014+  146B             ;; isupper 
0015+  146B             ;; _isdigit 
0016+  146B             ;; isxdigit
0017+  146B             ;; iscntrl 
0018+  146B             ;; isgraph 
0019+  146B             ;; _isspace 
0020+  146B             ;; isblank 
0021+  146B             ;; isprint 
0022+  146B             ;; ispunct 
0023+  146B             ;; tolower 
0024+  146B             ;; toupper
0025+  146B             
0026+  146B             
0027+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  146B             ;; is alphanumeric
0029+  146B             ;; sets zf according with result
0030+  146B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  146B             _isalnum:
0032+  146B 07 88 14    	call _isalpha
0033+  146E C6 74 14    	je _isalnum_exit
0034+  1471 07 75 14    	call _isdigit
0035+  1474             _isalnum_exit:
0036+  1474 09          	ret	
0037+  1475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  1475             ;; is digit
0039+  1475             ;; sets zf according with result
0040+  1475             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  1475             _isdigit:
0042+  1475 DB          	push al
0043+  1476 B9 30       	cmp al, '0'
0044+  1478 C8 84 14    	jlu _isdigit_false
0045+  147B B9 39       	cmp al, '9'
0046+  147D D1 84 14    	jgu _isdigit_false
0047+  1480 87 00       	and al, 0	; set zf
0048+  1482 E8          	pop al
0049+  1483 09          	ret
0050+  1484             _isdigit_false:
0051+  1484 8B 01       	or al, 1	; clear zf
0052+  1486 E8          	pop al
0053+  1487 09          	ret	
0054+  1488             	
0055+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  1488             ;; is alpha
0057+  1488             ;; sets zf according with result
0058+  1488             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  1488             _isalpha:
0060+  1488 DB          	push al
0061+  1489 B9 5F       	cmp al, '_'
0062+  148B C6 AB 14    	je _isalpha_true
0063+  148E B9 2E       	cmp al, '.'
0064+  1490 C6 AB 14    	je _isalpha_true
0065+  1493 B9 61       	cmp al, 'a'
0066+  1495 C8 A7 14    	jlu _isalpha_false
0067+  1498 B9 7A       	cmp al, 'z'
0068+  149A D1 A7 14    	jgu _isalpha_false
0069+  149D B9 7A       	cmp al, 'z'
0070+  149F D0 AB 14    	jleu _isalpha_true
0071+  14A2 B9 61       	cmp al, 'a'
0072+  14A4 C9 AB 14    	jgeu _isalpha_true
0073+  14A7             _isalpha_false:
0074+  14A7 8B 01       	or al, 1	; clear zf
0075+  14A9 E8          	pop al
0076+  14AA 09          	ret
0077+  14AB             _isalpha_true:
0078+  14AB 87 00       	and al, 0	; set zf
0079+  14AD E8          	pop al
0080+  14AE 09          	ret
0081+  14AF             
0082+  14AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  14AF             ;; is path-alpha
0084+  14AF             ;; sets zf according with result
0085+  14AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  14AF             ispath:
0087+  14AF DB          	push al
0088+  14B0 07 75 14    	call _isdigit
0089+  14B3 C6 DD 14    	je ispath_true
0090+  14B6 B9 5F       	cmp al, '_'
0091+  14B8 C6 DD 14    	je ispath_true
0092+  14BB B9 2F       	cmp al, '/'
0093+  14BD C6 DD 14    	je ispath_true
0094+  14C0 B9 2E       	cmp al, '.'
0095+  14C2 C6 DD 14    	je ispath_true
0096+  14C5 B9 61       	cmp al, 'a'
0097+  14C7 C8 D9 14    	jlu ispath_false
0098+  14CA B9 7A       	cmp al, 'z'
0099+  14CC D1 D9 14    	jgu ispath_false
0100+  14CF B9 7A       	cmp al, 'z'
0101+  14D1 D0 DD 14    	jleu ispath_true
0102+  14D4 B9 61       	cmp al, 'a'
0103+  14D6 C9 DD 14    	jgeu ispath_true
0104+  14D9             ispath_false:
0105+  14D9 8B 01       	or al, 1	; clear zf
0106+  14DB E8          	pop al
0107+  14DC 09          	ret
0108+  14DD             ispath_true:
0109+  14DD 87 00       	and al, 0	; set zf
0110+  14DF E8          	pop al
0111+  14E0 09          	ret
0112+  14E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  14E1             ;; is space
0114+  14E1             ;; sets zf according with result
0115+  14E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  14E1             _isspace:
0117+  14E1 B9 20       	cmp al, $20		; ' '
0118+  14E3 C6 F7 14    	je _isspace_exit
0119+  14E6 B9 09       	cmp al, $09		; '\t'
0120+  14E8 C6 F7 14    	je _isspace_exit
0121+  14EB B9 0A       	cmp al, $0a		; '\n'
0122+  14ED C6 F7 14    	je _isspace_exit
0123+  14F0 B9 0D       	cmp al, $0d		; '\r'
0124+  14F2 C6 F7 14    	je _isspace_exit
0125+  14F5 B9 0B       	cmp al, $0b		; '\v'
0126+  14F7             _isspace_exit:
0127+  14F7 09          	ret	
0128+  14F8             
0129+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  14F8             ; to lower
0131+  14F8             ; input in al
0132+  14F8             ; output in al
0133+  14F8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  14F8             _to_lower:
0135+  14F8 B9 7A       	cmp al, 'z'
0136+  14FA D1 FF 14    	jgu _to_lower_ret
0137+  14FD 6A 20       	add al, $20				; convert to lower case
0138+  14FF             _to_lower_ret:
0139+  14FF 09          	ret
0140+  1500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  1500             ; to upper
0142+  1500             ; input in al
0143+  1500             ; output in al
0144+  1500             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  1500             _to_upper:
0146+  1500 B9 61       	cmp al, 'a'
0147+  1502 C8 07 15    	jlu _to_upper_ret
0148+  1505 6F 20       	sub al, $20			; convert to upper case
0149+  1507             _to_upper_ret:
0150+  1507 09          	ret
0151+  1508             
2927   1508             .include "lib/token.asm"
0001+  1508             toktyp_identifier  .equ 0
0002+  1508             toktyp_keyword     .equ 1
0003+  1508             toktyp_delimiter   .equ 2
0004+  1508             toktyp_string      .equ 3
0005+  1508             toktyp_char        .equ 4
0006+  1508             toktyp_numeric     .equ 5
0007+  1508             toktyp_end         .equ 6
0008+  1508             
0009+  1508             tok_null           .equ 0
0010+  1508             tok_fslash         .equ 1
0011+  1508             tok_times          .equ 2
0012+  1508             tok_plus           .equ 3
0013+  1508             tok_minus          .equ 4
0014+  1508             tok_dot            .equ 5
0015+  1508             tok_semi           .equ 6
0016+  1508             tok_angle          .equ 7
0017+  1508             tok_tilde          .equ 8
0018+  1508             tok_equal          .equ 9
0019+  1508             tok_colon          .equ 10
0020+  1508             tok_comma          .equ 11
0021+  1508             
0022+  1508             tok_end            .equ 20
0023+  1508             
0024+  1508             
0025+  1508             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  1508             ;; read a full command argment from shell input buffer
0027+  1508             ;; argument is written into tokstr
0028+  1508             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  1508             get_arg:
0030+  1508 D7            push a
0031+  1509 E2            push si
0032+  150A E3            push di
0033+  150B 19 00         mov al, 0
0034+  150D 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0035+  1510 14 32 17      mov a, [prog]
0036+  1513 4D            mov si, a
0037+  1514 FD 4F 36 17   mov di, tokstr
0038+  1518             get_arg_skip_spaces:
0039+  1518 F6            lodsb
0040+  1519 07 E1 14      call _isspace
0041+  151C C6 18 15      je get_arg_skip_spaces
0042+  151F             get_arg_l0:
0043+  151F B9 3B         cmp al, $3b        ; check if is ';'
0044+  1521 C6 2E 15      je get_arg_end
0045+  1524 B9 00         cmp al, 0
0046+  1526 C6 2E 15      je get_arg_end      ; check if end of input
0047+  1529 F7            stosb
0048+  152A F6            lodsb
0049+  152B 0A 1F 15      jmp get_arg_l0
0050+  152E             get_arg_end:
0051+  152E 19 00         mov al, 0
0052+  1530 F7            stosb
0053+  1531 D5 01 00      sub si, 1
0054+  1534 4E            mov a, si
0055+  1535 42 32 17      mov [prog], a    ; update pointer
0056+  1538 F0            pop di
0057+  1539 EF            pop si
0058+  153A E4            pop a
0059+  153B 09            ret
0060+  153C             
0061+  153C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  153C             ;; read a path formation from shell input buffer
0063+  153C             ;; path is written into tokstr
0064+  153C             ;; /usr/bin
0065+  153C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  153C             get_path:
0067+  153C D7            push a
0068+  153D E2            push si
0069+  153E E3            push di
0070+  153F 19 00         mov al, 0
0071+  1541 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0072+  1544 14 32 17      mov a, [prog]
0073+  1547 4D            mov si, a
0074+  1548 FD 4F 36 17   mov di, tokstr
0075+  154C             get_path_skip_spaces:
0076+  154C F6            lodsb
0077+  154D 07 E1 14      call _isspace
0078+  1550 C6 4C 15      je get_path_skip_spaces
0079+  1553             get_path_is_pathchar:
0080+  1553 F7            stosb
0081+  1554 F6            lodsb
0082+  1555 07 6B 14      call _isalnum      ;check if is alphanumeric
0083+  1558 C6 53 15      je get_path_is_pathchar
0084+  155B B9 2F         cmp al, '/'        ; check if is '/'
0085+  155D C6 53 15      je get_path_is_pathchar
0086+  1560 19 00         mov al, 0
0087+  1562 F7            stosb
0088+  1563 D5 01 00      sub si, 1
0089+  1566 4E            mov a, si
0090+  1567 42 32 17      mov [prog], a    ; update pointer
0091+  156A             get_path_end:
0092+  156A F0            pop di
0093+  156B EF            pop si
0094+  156C E4            pop a
0095+  156D 09            ret
0096+  156E             
0097+  156E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  156E             ;; read a line
0099+  156E             ;; line is written into tokstr
0100+  156E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  156E             get_line:
0102+  156E D7            push a
0103+  156F E2            push si
0104+  1570 E3            push di
0105+  1571 19 00         mov al, 0
0106+  1573 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0107+  1576 14 32 17      mov a, [prog]
0108+  1579 4D            mov si, a
0109+  157A FD 4F 36 17   mov di, tokstr
0110+  157E             get_line_l0:
0111+  157E F6            lodsb
0112+  157F B9 0A         cmp al, $0a    ; check for new line
0113+  1581 C6 88 15      je get_line_exit
0114+  1584 F7            stosb
0115+  1585 0A 7E 15      jmp get_line_l0
0116+  1588             get_line_exit:
0117+  1588 19 00         mov al, 0
0118+  158A F7            stosb
0119+  158B 4E            mov a, si
0120+  158C 42 32 17      mov [prog], a    ; update pointer
0121+  158F F0            pop di
0122+  1590 EF            pop si
0123+  1591 E4            pop a
0124+  1592 09            ret
0125+  1593             
0126+  1593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  1593             ;; token parser
0128+  1593             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  1593             get_token:
0130+  1593 D7            push a
0131+  1594 DA            push d
0132+  1595 E2            push si
0133+  1596 E3            push di
0134+  1597 19 00         mov al, 0
0135+  1599 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0136+  159C 19 00         mov al, tok_null
0137+  159E 3D 35 17      mov [tok], al        ; nullify token
0138+  15A1 14 32 17      mov a, [prog]
0139+  15A4 4D            mov si, a
0140+  15A5 FD 4F 36 17   mov di, tokstr
0141+  15A9             get_tok_skip_spaces:
0142+  15A9 F6            lodsb
0143+  15AA 07 E1 14      call _isspace
0144+  15AD C6 A9 15      je get_tok_skip_spaces
0145+  15B0 B9 00         cmp al, 0      ; check for end of input (null)
0146+  15B2 C6 97 16      je get_token_end
0147+  15B5 B9 23         cmp al, '#'      ; comments!
0148+  15B7 C6 C5 16      je get_tok_comment
0149+  15BA 07 6B 14      call _isalnum
0150+  15BD C6 A4 16      jz is_alphanumeric
0151+  15C0             ; other token types
0152+  15C0             get_token_slash:
0153+  15C0 B9 2F         cmp al, '/'        ; check if '/'
0154+  15C2 C7 DA 15      jne get_token_minus
0155+  15C5 F7            stosb          ; store '/' into token string
0156+  15C6 19 00         mov al, 0
0157+  15C8 F7            stosb          ; terminate token string
0158+  15C9 19 01         mov al, tok_fslash
0159+  15CB 3D 35 17      mov [tok], al      
0160+  15CE 19 02         mov al, toktyp_delimiter
0161+  15D0 3D 34 17      mov [toktyp], al
0162+  15D3 4E            mov a, si
0163+  15D4 42 32 17      mov [prog], a    ; update pointer
0164+  15D7 0A C0 16      jmp get_token_return
0165+  15DA             get_token_minus:
0166+  15DA B9 2D         cmp al, '-'        ; check if '-'
0167+  15DC C7 F4 15      jne get_token_comma
0168+  15DF F7            stosb          ; store '-' into token string
0169+  15E0 19 00         mov al, 0
0170+  15E2 F7            stosb          ; terminate token string
0171+  15E3 19 04         mov al, tok_minus
0172+  15E5 3D 35 17      mov [tok], al      
0173+  15E8 19 02         mov al, toktyp_delimiter
0174+  15EA 3D 34 17      mov [toktyp], al
0175+  15ED 4E            mov a, si
0176+  15EE 42 32 17      mov [prog], a    ; update pointer
0177+  15F1 0A C0 16      jmp get_token_return
0178+  15F4             get_token_comma:
0179+  15F4 B9 2C         cmp al, ','        ; check if ','
0180+  15F6 C7 0E 16      jne get_token_semi
0181+  15F9 F7            stosb          ; store ',' into token string
0182+  15FA 19 00         mov al, 0
0183+  15FC F7            stosb          ; terminate token string
0184+  15FD 19 0B         mov al, tok_comma
0185+  15FF 3D 35 17      mov [tok], al      
0186+  1602 19 02         mov al, toktyp_delimiter
0187+  1604 3D 34 17      mov [toktyp], al
0188+  1607 4E            mov a, si
0189+  1608 42 32 17      mov [prog], a    ; update pointer
0190+  160B 0A C0 16      jmp get_token_return
0191+  160E             get_token_semi:
0192+  160E B9 3B         cmp al, $3b        ; check if ';'
0193+  1610 C7 28 16      jne get_token_colon
0194+  1613 F7            stosb          ; store ';' into token string
0195+  1614 19 00         mov al, 0
0196+  1616 F7            stosb          ; terminate token string
0197+  1617 19 06         mov al, tok_semi
0198+  1619 3D 35 17      mov [tok], al      
0199+  161C 19 02         mov al, toktyp_delimiter
0200+  161E 3D 34 17      mov [toktyp], al
0201+  1621 4E            mov a, si
0202+  1622 42 32 17      mov [prog], a    ; update pointer
0203+  1625 0A C0 16      jmp get_token_return
0204+  1628             get_token_colon:
0205+  1628 B9 3A         cmp al, $3a        ; check if ':'
0206+  162A C7 42 16      jne get_token_angle
0207+  162D F7            stosb          ; store ':' into token string
0208+  162E 19 00         mov al, 0
0209+  1630 F7            stosb          ; terminate token string
0210+  1631 19 0A         mov al, tok_colon
0211+  1633 3D 35 17      mov [tok], al      
0212+  1636 19 02         mov al, toktyp_delimiter
0213+  1638 3D 34 17      mov [toktyp], al
0214+  163B 4E            mov a, si
0215+  163C 42 32 17      mov [prog], a    ; update pointer
0216+  163F 0A C0 16      jmp get_token_return
0217+  1642             get_token_angle:
0218+  1642 B9 3E         cmp al, $3e        ; check if '>'
0219+  1644 C7 5C 16      jne get_token_tilde
0220+  1647 F7            stosb          ; store '>' into token string
0221+  1648 19 00         mov al, 0
0222+  164A F7            stosb          ; terminate token string
0223+  164B 19 07         mov al, tok_angle
0224+  164D 3D 35 17      mov [tok], al      
0225+  1650 19 02         mov al, toktyp_delimiter
0226+  1652 3D 34 17      mov [toktyp], al
0227+  1655 4E            mov a, si
0228+  1656 42 32 17      mov [prog], a    ; update pointer
0229+  1659 0A C0 16      jmp get_token_return
0230+  165C             get_token_tilde:
0231+  165C B9 7E         cmp al, '~'        ; check if '~'
0232+  165E C7 76 16      jne get_token_equal
0233+  1661 F7            stosb          ; store '~' into token string
0234+  1662 19 00         mov al, 0
0235+  1664 F7            stosb          ; terminate token string
0236+  1665 19 08         mov al, tok_tilde
0237+  1667 3D 35 17      mov [tok], al      
0238+  166A 19 02         mov al, toktyp_delimiter
0239+  166C 3D 34 17      mov [toktyp], al
0240+  166F 4E            mov a, si
0241+  1670 42 32 17      mov [prog], a    ; update pointer
0242+  1673 0A C0 16      jmp get_token_return
0243+  1676             get_token_equal:
0244+  1676 B9 3D         cmp al, '='        ; check if '='
0245+  1678 C7 90 16      jne get_token_skip
0246+  167B F7            stosb          ; store '=' into token string
0247+  167C 19 00         mov al, 0
0248+  167E F7            stosb          ; terminate token string
0249+  167F 19 09         mov al, tok_equal
0250+  1681 3D 35 17      mov [tok], al      
0251+  1684 19 02         mov al, toktyp_delimiter
0252+  1686 3D 34 17      mov [toktyp], al
0253+  1689 4E            mov a, si
0254+  168A 42 32 17      mov [prog], a    ; update pointer
0255+  168D 0A C0 16      jmp get_token_return
0256+  1690             get_token_skip:
0257+  1690 4E            mov a, si
0258+  1691 42 32 17      mov [prog], a    ; update pointer
0259+  1694 0A C0 16      jmp get_token_return
0260+  1697             get_token_end:        ; end of file token
0261+  1697 19 14         mov al, tok_end
0262+  1699 3D 35 17      mov [tok], al
0263+  169C 19 06         mov al, toktyp_end
0264+  169E 3D 34 17      mov [toktyp], al
0265+  16A1 0A C0 16      jmp get_token_return
0266+  16A4             is_alphanumeric:
0267+  16A4 F7            stosb
0268+  16A5 F6            lodsb
0269+  16A6 07 6B 14      call _isalnum      ;check if is alphanumeric
0270+  16A9 C6 A4 16      jz is_alphanumeric
0271+  16AC B9 2E         cmp al, $2e        ; check if is '.'
0272+  16AE C6 A4 16      je is_alphanumeric
0273+  16B1 19 00         mov al, 0
0274+  16B3 F7            stosb
0275+  16B4 19 00         mov al, toktyp_identifier
0276+  16B6 3D 34 17      mov [toktyp], al
0277+  16B9 D5 01 00      sub si, 1
0278+  16BC 4E            mov a, si
0279+  16BD 42 32 17      mov [prog], a    ; update pointer
0280+  16C0             get_token_return:
0281+  16C0 F0            pop di
0282+  16C1 EF            pop si
0283+  16C2 E7            pop d
0284+  16C3 E4            pop a
0285+  16C4 09            ret
0286+  16C5             get_tok_comment:
0287+  16C5 F6            lodsb
0288+  16C6 B9 0A         cmp al, $0a      ; new line
0289+  16C8 C7 C5 16      jne get_tok_comment
0290+  16CB 0A A9 15      jmp get_tok_skip_spaces
0291+  16CE             
0292+  16CE             
0293+  16CE             get_number:
0294+  16CE D7            push a
0295+  16CF DA            push d
0296+  16D0 E2            push si
0297+  16D1 E3            push di
0298+  16D2 19 00         mov al, 0
0299+  16D4 3D 36 17      mov [tokstr], al      ; nullify tokstr string
0300+  16D7 19 00         mov al, tok_null
0301+  16D9 3D 35 17      mov [tok], al        ; nullify token
0302+  16DC 14 32 17      mov a, [prog]
0303+  16DF 4D            mov si, a
0304+  16E0 FD 4F 36 17   mov di, tokstr
0305+  16E4             get_number_skip_spaces:
0306+  16E4 F6            lodsb
0307+  16E5 07 E1 14      call _isspace
0308+  16E8 C6 E4 16      je get_number_skip_spaces
0309+  16EB B9 00         cmp al, 0      ; check for end of input (null)
0310+  16ED C7 FD 16      jne get_number_l0
0311+  16F0 19 14         mov al, tok_end
0312+  16F2 3D 35 17      mov [tok], al
0313+  16F5 19 06         mov al, toktyp_end
0314+  16F7 3D 34 17      mov [toktyp], al
0315+  16FA 0A 14 17      jmp get_number_return
0316+  16FD             get_number_l0:
0317+  16FD F7            stosb
0318+  16FE F6            lodsb
0319+  16FF 07 75 14      call _isdigit      ;check if is numeric
0320+  1702 C6 FD 16      jz get_number_l0
0321+  1705 19 00         mov al, 0
0322+  1707 F7            stosb
0323+  1708 19 05         mov al, toktyp_numeric
0324+  170A 3D 34 17      mov [toktyp], al
0325+  170D D5 01 00      sub si, 1
0326+  1710 4E            mov a, si
0327+  1711 42 32 17      mov [prog], a    ; update pointer
0328+  1714             get_number_return:
0329+  1714 F0            pop di
0330+  1715 EF            pop si
0331+  1716 E7            pop d
0332+  1717 E4            pop a
0333+  1718 09            ret
0334+  1719             
0335+  1719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  1719             ;; put back token
0337+  1719             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  1719             _putback:
0339+  1719 D7            push a
0340+  171A E2            push si
0341+  171B FD 4D 36 17   mov si, tokstr  
0342+  171F             _putback_loop:
0343+  171F F6            lodsb
0344+  1720 B9 00         cmp al, 0
0345+  1722 C6 2F 17      je _putback_end
0346+  1725 14 32 17      mov a, [prog]
0347+  1728 7D            dec a
0348+  1729 42 32 17      mov [prog], a      ; update pointer
0349+  172C 0A 1F 17      jmp _putback_loop
0350+  172F             _putback_end:
0351+  172F EF            pop si
0352+  1730 E4            pop a
0353+  1731 09            ret
0354+  1732             
0355+  1732             
0356+  1732             
0357+  1732             
0358+  1732 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  1734             
0360+  1734 00          toktyp:    .db 0          ; token type symbol
0361+  1735 00          tok:       .db 0          ; current token symbol
0362+  1736 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  173A 00 00 00 00 
0362+  173E 00 00 00 00 
0362+  1742 00 00 00 00 
0362+  1746 00 00 00 00 
0362+  174A 00 00 00 00 
0362+  174E 00 00 00 00 
0362+  1752 00 00 00 00 
0362+  1756 00 00 00 00 
0362+  175A 00 00 00 00 
0362+  175E 00 00 00 00 
0362+  1762 00 00 00 00 
0362+  1766 00 00 00 00 
0362+  176A 00 00 00 00 
0362+  176E 00 00 00 00 
0362+  1772 00 00 00 00 
0362+  1776 00 00 00 00 
0362+  177A 00 00 00 00 
0362+  177E 00 00 00 00 
0362+  1782 00 00 00 00 
0362+  1786 00 00 00 00 
0362+  178A 00 00 00 00 
0362+  178E 00 00 00 00 
0362+  1792 00 00 00 00 
0362+  1796 00 00 00 00 
0362+  179A 00 00 00 00 
0362+  179E 00 00 00 00 
0362+  17A2 00 00 00 00 
0362+  17A6 00 00 00 00 
0362+  17AA 00 00 00 00 
0362+  17AE 00 00 00 00 
0362+  17B2 00 00 00 00 
0362+  17B6 00 00 00 00 
0362+  17BA 00 00 00 00 
0362+  17BE 00 00 00 00 
0362+  17C2 00 00 00 00 
0362+  17C6 00 00 00 00 
0362+  17CA 00 00 00 00 
0362+  17CE 00 00 00 00 
0362+  17D2 00 00 00 00 
0362+  17D6 00 00 00 00 
0362+  17DA 00 00 00 00 
0362+  17DE 00 00 00 00 
0362+  17E2 00 00 00 00 
0362+  17E6 00 00 00 00 
0362+  17EA 00 00 00 00 
0362+  17EE 00 00 00 00 
0362+  17F2 00 00 00 00 
0362+  17F6 00 00 00 00 
0362+  17FA 00 00 00 00 
0362+  17FE 00 00 00 00 
0362+  1802 00 00 00 00 
0362+  1806 00 00 00 00 
0362+  180A 00 00 00 00 
0362+  180E 00 00 00 00 
0362+  1812 00 00 00 00 
0362+  1816 00 00 00 00 
0362+  181A 00 00 00 00 
0362+  181E 00 00 00 00 
0362+  1822 00 00 00 00 
0362+  1826 00 00 00 00 
0362+  182A 00 00 00 00 
0362+  182E 00 00 00 00 
0362+  1832 00 00 00 00 
2928   1836             
2929   1836             ; kernel parameters
2930   1836             sys_debug_mode:
2931   1836 00            .db 0   ; debug modes: 0=normal mode, 1=debug mode
2932   1837             sys_echo_on:
2933   1837 01            .db 1
2934   1838             sys_uart0_lcr:
2935   1838 0F            .db %00001111 ; 8 data bits, 2 stop bits, enable parity, odd parity
2936   1839             sys_uart0_inten:
2937   1839 01            .db 1
2938   183A             sys_uart0_fifoen:
2939   183A 00            .db 0
2940   183B             sys_uart0_div0:
2941   183B 03            .db 3
2942   183C             sys_uart0_div1:
2943   183C 00            .db 0   ; default baud = 38400
2944   183D             ; baud  divisor
2945   183D             ; 50    2304
2946   183D             ; 110   1047
2947   183D             ; 300    384
2948   183D             ; 600    192
2949   183D             ; 1200    96
2950   183D             ; 9600    12
2951   183D             ; 19200    6
2952   183D             ; 38400    3
2953   183D             
2954   183D             nbr_active_procs:
2955   183D 00            .db 0
2956   183E             active_proc_index:
2957   183E 01            .db 1
2958   183F             
2959   183F             index:
2960   183F 00 00         .dw 0
2961   1841             buffer_addr:
2962   1841 00 00         .dw 0
2963   1843             
2964   1843             fifo_in:
2965   1843 A4 1F         .dw fifo
2966   1845             fifo_out:
2967   1845 A4 1F         .dw fifo
2968   1847             
2969   1847             ; file system variables
2970   1847             current_dir_id:
2971   1847 00 00         .dw 0     ; keep dirid of current directory
2972   1849             s_init_path:
2973   1849 2F 73 62 69   .db "/sbin/init", 0
2973   184D 6E 2F 69 6E 
2973   1851 69 74 00 
2974   1854             
2975   1854             s_uname:
2976   1854 73 6F 6C 61   .db "solarium v.1.0", 0
2976   1858 72 69 75 6D 
2976   185C 20 76 2E 31 
2976   1860 2E 30 00 
2977   1863             s_dataentry:
2978   1863 3E 20 00      .db "> ", 0
2979   1866             s_parent_dir:
2980   1866 2E 2E 00      .db "..", 0
2981   1869             s_current_dir:
2982   1869 2E 00         .db ".", 0
2983   186B             s_fslash:
2984   186B 2F 00         .db "/", 0
2985   186D             file_attrib:
2986   186D 2D 72 77 20   .db "-rw x"      ; chars at powers of 2
2986   1871 78 
2987   1872             file_type:
2988   1872 2D 64 63      .db "-dc"
2989   1875             s_ps_header:
2990   1875 70 69 64 20   .db "pid command\n", 0
2990   1879 63 6F 6D 6D 
2990   187D 61 6E 64 0A 
2990   1881 00 
2991   1882             s_ls_total:
2992   1882 74 6F 74 61   .db "total: ", 0
2992   1886 6C 3A 20 00 
2993   188A             
2994   188A             s_int_en:
2995   188A 69 72 71 73   .db "irqs enabled\n", 0
2995   188E 20 65 6E 61 
2995   1892 62 6C 65 64 
2995   1896 0A 00 
2996   1898             s_kernel_started:
2997   1898 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
2997   189C 65 6C 20 73 
2997   18A0 74 61 72 74 
2997   18A4 65 64 28 76 
2997   18A8 65 72 73 69 
2997   18AC 6F 6E 20 31 
2997   18B0 2E 30 29 0A 
2997   18B4 00 
2998   18B5             s_prompt_init:
2999   18B5 73 74 61 72   .db "starting init\n", 0
2999   18B9 74 69 6E 67 
2999   18BD 20 69 6E 69 
2999   18C1 74 0A 00 
3000   18C4             s_priviledge:
3001   18C4 0A 65 78 63   .db "\nexception: privilege\n", 0
3001   18C8 65 70 74 69 
3001   18CC 6F 6E 3A 20 
3001   18D0 70 72 69 76 
3001   18D4 69 6C 65 67 
3001   18D8 65 0A 00 
3002   18DB             s_divzero:
3003   18DB 0A 65 78 63   .db "\nexception: zero division\n", 0
3003   18DF 65 70 74 69 
3003   18E3 6F 6E 3A 20 
3003   18E7 7A 65 72 6F 
3003   18EB 20 64 69 76 
3003   18EF 69 73 69 6F 
3003   18F3 6E 0A 00 
3004   18F6             
3005   18F6             s_set_year:
3006   18F6 79 65 61 72   .db "year: ", 0
3006   18FA 3A 20 00 
3007   18FD             s_set_month:
3008   18FD 6D 6F 6E 74   .db "month: ", 0
3008   1901 68 3A 20 00 
3009   1905             s_set_day:
3010   1905 64 61 79 3A   .db "day: ", 0
3010   1909 20 00 
3011   190B             s_set_week:
3012   190B 77 65 65 6B   .db "weekday: ", 0
3012   190F 64 61 79 3A 
3012   1913 20 00 
3013   1915             s_set_hours:
3014   1915 68 6F 75 72   .db "hours: ", 0
3014   1919 73 3A 20 00 
3015   191D             s_set_minutes:
3016   191D 6D 69 6E 75   .db "minutes: ", 0
3016   1921 74 65 73 3A 
3016   1925 20 00 
3017   1927             s_set_seconds:
3018   1927 73 65 63 6F   .db "seconds: ", 0
3018   192B 6E 64 73 3A 
3018   192F 20 00 
3019   1931             s_months:      
3020   1931 20 20 20 00   .db "   ", 0
3021   1935 6A 61 6E 00   .db "jan", 0
3022   1939 66 65 62 00   .db "feb", 0
3023   193D 6D 61 72 00   .db "mar", 0
3024   1941 61 70 72 00   .db "apr", 0
3025   1945 6D 61 79 00   .db "may", 0
3026   1949 6A 75 6E 00   .db "jun", 0
3027   194D 6A 75 6C 00   .db "jul", 0
3028   1951 61 75 67 00   .db "aug", 0
3029   1955 73 65 70 00   .db "sep", 0
3030   1959 6F 63 74 00   .db "oct", 0
3031   195D 6E 6F 76 00   .db "nov", 0
3032   1961 64 65 63 00   .db "dec", 0
3033   1965             
3034   1965             s_week:        
3035   1965 73 75 6E 00   .db "sun", 0 
3036   1969 6D 6F 6E 00   .db "mon", 0 
3037   196D 74 75 65 00   .db "tue", 0 
3038   1971 77 65 64 00   .db "wed", 0 
3039   1975 74 68 75 00   .db "thu", 0 
3040   1979 66 72 69 00   .db "fri", 0 
3041   197D 73 61 74 00   .db "sat", 0
3042   1981             
3043   1981 0A 49 52 51 s_fdc_irq: .db "\nIRQ0 Executed.\n", 0
3043   1985 30 20 45 78 
3043   1989 65 63 75 74 
3043   198D 65 64 2E 0A 
3043   1991 00 
3044   1992             s_fdc_config:
3045   1992 0A 73 65 6C   .db "\nselecting diskette drive 0, side 0, single density, head loaded\n", 0
3045   1996 65 63 74 69 
3045   199A 6E 67 20 64 
3045   199E 69 73 6B 65 
3045   19A2 74 74 65 20 
3045   19A6 64 72 69 76 
3045   19AA 65 20 30 2C 
3045   19AE 20 73 69 64 
3045   19B2 65 20 30 2C 
3045   19B6 20 73 69 6E 
3045   19BA 67 6C 65 20 
3045   19BE 64 65 6E 73 
3045   19C2 69 74 79 2C 
3045   19C6 20 68 65 61 
3045   19CA 64 20 6C 6F 
3045   19CE 61 64 65 64 
3045   19D2 0A 00 
3046   19D4             
3047   19D4             proc_state_table:   
3048   19D4 00 00 00 00   .fill 16 * 20, 0  ; for 15 processes max
3048   19D8 00 00 00 00 
3048   19DC 00 00 00 00 
3048   19E0 00 00 00 00 
3048   19E4 00 00 00 00 
3048   19E8 00 00 00 00 
3048   19EC 00 00 00 00 
3048   19F0 00 00 00 00 
3048   19F4 00 00 00 00 
3048   19F8 00 00 00 00 
3048   19FC 00 00 00 00 
3048   1A00 00 00 00 00 
3048   1A04 00 00 00 00 
3048   1A08 00 00 00 00 
3048   1A0C 00 00 00 00 
3048   1A10 00 00 00 00 
3048   1A14 00 00 00 00 
3048   1A18 00 00 00 00 
3048   1A1C 00 00 00 00 
3048   1A20 00 00 00 00 
3048   1A24 00 00 00 00 
3048   1A28 00 00 00 00 
3048   1A2C 00 00 00 00 
3048   1A30 00 00 00 00 
3048   1A34 00 00 00 00 
3048   1A38 00 00 00 00 
3048   1A3C 00 00 00 00 
3048   1A40 00 00 00 00 
3048   1A44 00 00 00 00 
3048   1A48 00 00 00 00 
3048   1A4C 00 00 00 00 
3048   1A50 00 00 00 00 
3048   1A54 00 00 00 00 
3048   1A58 00 00 00 00 
3048   1A5C 00 00 00 00 
3048   1A60 00 00 00 00 
3048   1A64 00 00 00 00 
3048   1A68 00 00 00 00 
3048   1A6C 00 00 00 00 
3048   1A70 00 00 00 00 
3048   1A74 00 00 00 00 
3048   1A78 00 00 00 00 
3048   1A7C 00 00 00 00 
3048   1A80 00 00 00 00 
3048   1A84 00 00 00 00 
3048   1A88 00 00 00 00 
3048   1A8C 00 00 00 00 
3048   1A90 00 00 00 00 
3048   1A94 00 00 00 00 
3048   1A98 00 00 00 00 
3048   1A9C 00 00 00 00 
3048   1AA0 00 00 00 00 
3048   1AA4 00 00 00 00 
3048   1AA8 00 00 00 00 
3048   1AAC 00 00 00 00 
3048   1AB0 00 00 00 00 
3048   1AB4 00 00 00 00 
3048   1AB8 00 00 00 00 
3048   1ABC 00 00 00 00 
3048   1AC0 00 00 00 00 
3048   1AC4 00 00 00 00 
3048   1AC8 00 00 00 00 
3048   1ACC 00 00 00 00 
3048   1AD0 00 00 00 00 
3048   1AD4 00 00 00 00 
3048   1AD8 00 00 00 00 
3048   1ADC 00 00 00 00 
3048   1AE0 00 00 00 00 
3048   1AE4 00 00 00 00 
3048   1AE8 00 00 00 00 
3048   1AEC 00 00 00 00 
3048   1AF0 00 00 00 00 
3048   1AF4 00 00 00 00 
3048   1AF8 00 00 00 00 
3048   1AFC 00 00 00 00 
3048   1B00 00 00 00 00 
3048   1B04 00 00 00 00 
3048   1B08 00 00 00 00 
3048   1B0C 00 00 00 00 
3048   1B10 00 00 00 00 
3049   1B14             proc_availab_table: 
3050   1B14 00 00 00 00   .fill 16, 0       ; space for 15 processes. 0 = process empty, 1 = process taken
3050   1B18 00 00 00 00 
3050   1B1C 00 00 00 00 
3050   1B20 00 00 00 00 
3051   1B24             proc_names:
3052   1B24 00 00 00 00   .fill 16 * 32, 0  ; process names
3052   1B28 00 00 00 00 
3052   1B2C 00 00 00 00 
3052   1B30 00 00 00 00 
3052   1B34 00 00 00 00 
3052   1B38 00 00 00 00 
3052   1B3C 00 00 00 00 
3052   1B40 00 00 00 00 
3052   1B44 00 00 00 00 
3052   1B48 00 00 00 00 
3052   1B4C 00 00 00 00 
3052   1B50 00 00 00 00 
3052   1B54 00 00 00 00 
3052   1B58 00 00 00 00 
3052   1B5C 00 00 00 00 
3052   1B60 00 00 00 00 
3052   1B64 00 00 00 00 
3052   1B68 00 00 00 00 
3052   1B6C 00 00 00 00 
3052   1B70 00 00 00 00 
3052   1B74 00 00 00 00 
3052   1B78 00 00 00 00 
3052   1B7C 00 00 00 00 
3052   1B80 00 00 00 00 
3052   1B84 00 00 00 00 
3052   1B88 00 00 00 00 
3052   1B8C 00 00 00 00 
3052   1B90 00 00 00 00 
3052   1B94 00 00 00 00 
3052   1B98 00 00 00 00 
3052   1B9C 00 00 00 00 
3052   1BA0 00 00 00 00 
3052   1BA4 00 00 00 00 
3052   1BA8 00 00 00 00 
3052   1BAC 00 00 00 00 
3052   1BB0 00 00 00 00 
3052   1BB4 00 00 00 00 
3052   1BB8 00 00 00 00 
3052   1BBC 00 00 00 00 
3052   1BC0 00 00 00 00 
3052   1BC4 00 00 00 00 
3052   1BC8 00 00 00 00 
3052   1BCC 00 00 00 00 
3052   1BD0 00 00 00 00 
3052   1BD4 00 00 00 00 
3052   1BD8 00 00 00 00 
3052   1BDC 00 00 00 00 
3052   1BE0 00 00 00 00 
3052   1BE4 00 00 00 00 
3052   1BE8 00 00 00 00 
3052   1BEC 00 00 00 00 
3052   1BF0 00 00 00 00 
3052   1BF4 00 00 00 00 
3052   1BF8 00 00 00 00 
3052   1BFC 00 00 00 00 
3052   1C00 00 00 00 00 
3052   1C04 00 00 00 00 
3052   1C08 00 00 00 00 
3052   1C0C 00 00 00 00 
3052   1C10 00 00 00 00 
3052   1C14 00 00 00 00 
3052   1C18 00 00 00 00 
3052   1C1C 00 00 00 00 
3052   1C20 00 00 00 00 
3052   1C24 00 00 00 00 
3052   1C28 00 00 00 00 
3052   1C2C 00 00 00 00 
3052   1C30 00 00 00 00 
3052   1C34 00 00 00 00 
3052   1C38 00 00 00 00 
3052   1C3C 00 00 00 00 
3052   1C40 00 00 00 00 
3052   1C44 00 00 00 00 
3052   1C48 00 00 00 00 
3052   1C4C 00 00 00 00 
3052   1C50 00 00 00 00 
3052   1C54 00 00 00 00 
3052   1C58 00 00 00 00 
3052   1C5C 00 00 00 00 
3052   1C60 00 00 00 00 
3052   1C64 00 00 00 00 
3052   1C68 00 00 00 00 
3052   1C6C 00 00 00 00 
3052   1C70 00 00 00 00 
3052   1C74 00 00 00 00 
3052   1C78 00 00 00 00 
3052   1C7C 00 00 00 00 
3052   1C80 00 00 00 00 
3052   1C84 00 00 00 00 
3052   1C88 00 00 00 00 
3052   1C8C 00 00 00 00 
3052   1C90 00 00 00 00 
3052   1C94 00 00 00 00 
3052   1C98 00 00 00 00 
3052   1C9C 00 00 00 00 
3052   1CA0 00 00 00 00 
3052   1CA4 00 00 00 00 
3052   1CA8 00 00 00 00 
3052   1CAC 00 00 00 00 
3052   1CB0 00 00 00 00 
3052   1CB4 00 00 00 00 
3052   1CB8 00 00 00 00 
3052   1CBC 00 00 00 00 
3052   1CC0 00 00 00 00 
3052   1CC4 00 00 00 00 
3052   1CC8 00 00 00 00 
3052   1CCC 00 00 00 00 
3052   1CD0 00 00 00 00 
3052   1CD4 00 00 00 00 
3052   1CD8 00 00 00 00 
3052   1CDC 00 00 00 00 
3052   1CE0 00 00 00 00 
3052   1CE4 00 00 00 00 
3052   1CE8 00 00 00 00 
3052   1CEC 00 00 00 00 
3052   1CF0 00 00 00 00 
3052   1CF4 00 00 00 00 
3052   1CF8 00 00 00 00 
3052   1CFC 00 00 00 00 
3052   1D00 00 00 00 00 
3052   1D04 00 00 00 00 
3052   1D08 00 00 00 00 
3052   1D0C 00 00 00 00 
3052   1D10 00 00 00 00 
3052   1D14 00 00 00 00 
3052   1D18 00 00 00 00 
3052   1D1C 00 00 00 00 
3052   1D20 00 00 00 00 
3053   1D24             filename:
3054   1D24 00 00 00 00   .fill 128, 0      ; holds a path for file search
3054   1D28 00 00 00 00 
3054   1D2C 00 00 00 00 
3054   1D30 00 00 00 00 
3054   1D34 00 00 00 00 
3054   1D38 00 00 00 00 
3054   1D3C 00 00 00 00 
3054   1D40 00 00 00 00 
3054   1D44 00 00 00 00 
3054   1D48 00 00 00 00 
3054   1D4C 00 00 00 00 
3054   1D50 00 00 00 00 
3054   1D54 00 00 00 00 
3054   1D58 00 00 00 00 
3054   1D5C 00 00 00 00 
3054   1D60 00 00 00 00 
3054   1D64 00 00 00 00 
3054   1D68 00 00 00 00 
3054   1D6C 00 00 00 00 
3054   1D70 00 00 00 00 
3054   1D74 00 00 00 00 
3054   1D78 00 00 00 00 
3054   1D7C 00 00 00 00 
3054   1D80 00 00 00 00 
3054   1D84 00 00 00 00 
3054   1D88 00 00 00 00 
3054   1D8C 00 00 00 00 
3054   1D90 00 00 00 00 
3054   1D94 00 00 00 00 
3054   1D98 00 00 00 00 
3054   1D9C 00 00 00 00 
3054   1DA0 00 00 00 00 
3055   1DA4             user_data:
3056   1DA4 00 00 00 00   .fill 512, 0      ;  user space data
3056   1DA8 00 00 00 00 
3056   1DAC 00 00 00 00 
3056   1DB0 00 00 00 00 
3056   1DB4 00 00 00 00 
3056   1DB8 00 00 00 00 
3056   1DBC 00 00 00 00 
3056   1DC0 00 00 00 00 
3056   1DC4 00 00 00 00 
3056   1DC8 00 00 00 00 
3056   1DCC 00 00 00 00 
3056   1DD0 00 00 00 00 
3056   1DD4 00 00 00 00 
3056   1DD8 00 00 00 00 
3056   1DDC 00 00 00 00 
3056   1DE0 00 00 00 00 
3056   1DE4 00 00 00 00 
3056   1DE8 00 00 00 00 
3056   1DEC 00 00 00 00 
3056   1DF0 00 00 00 00 
3056   1DF4 00 00 00 00 
3056   1DF8 00 00 00 00 
3056   1DFC 00 00 00 00 
3056   1E00 00 00 00 00 
3056   1E04 00 00 00 00 
3056   1E08 00 00 00 00 
3056   1E0C 00 00 00 00 
3056   1E10 00 00 00 00 
3056   1E14 00 00 00 00 
3056   1E18 00 00 00 00 
3056   1E1C 00 00 00 00 
3056   1E20 00 00 00 00 
3056   1E24 00 00 00 00 
3056   1E28 00 00 00 00 
3056   1E2C 00 00 00 00 
3056   1E30 00 00 00 00 
3056   1E34 00 00 00 00 
3056   1E38 00 00 00 00 
3056   1E3C 00 00 00 00 
3056   1E40 00 00 00 00 
3056   1E44 00 00 00 00 
3056   1E48 00 00 00 00 
3056   1E4C 00 00 00 00 
3056   1E50 00 00 00 00 
3056   1E54 00 00 00 00 
3056   1E58 00 00 00 00 
3056   1E5C 00 00 00 00 
3056   1E60 00 00 00 00 
3056   1E64 00 00 00 00 
3056   1E68 00 00 00 00 
3056   1E6C 00 00 00 00 
3056   1E70 00 00 00 00 
3056   1E74 00 00 00 00 
3056   1E78 00 00 00 00 
3056   1E7C 00 00 00 00 
3056   1E80 00 00 00 00 
3056   1E84 00 00 00 00 
3056   1E88 00 00 00 00 
3056   1E8C 00 00 00 00 
3056   1E90 00 00 00 00 
3056   1E94 00 00 00 00 
3056   1E98 00 00 00 00 
3056   1E9C 00 00 00 00 
3056   1EA0 00 00 00 00 
3056   1EA4 00 00 00 00 
3056   1EA8 00 00 00 00 
3056   1EAC 00 00 00 00 
3056   1EB0 00 00 00 00 
3056   1EB4 00 00 00 00 
3056   1EB8 00 00 00 00 
3056   1EBC 00 00 00 00 
3056   1EC0 00 00 00 00 
3056   1EC4 00 00 00 00 
3056   1EC8 00 00 00 00 
3056   1ECC 00 00 00 00 
3056   1ED0 00 00 00 00 
3056   1ED4 00 00 00 00 
3056   1ED8 00 00 00 00 
3056   1EDC 00 00 00 00 
3056   1EE0 00 00 00 00 
3056   1EE4 00 00 00 00 
3056   1EE8 00 00 00 00 
3056   1EEC 00 00 00 00 
3056   1EF0 00 00 00 00 
3056   1EF4 00 00 00 00 
3056   1EF8 00 00 00 00 
3056   1EFC 00 00 00 00 
3056   1F00 00 00 00 00 
3056   1F04 00 00 00 00 
3056   1F08 00 00 00 00 
3056   1F0C 00 00 00 00 
3056   1F10 00 00 00 00 
3056   1F14 00 00 00 00 
3056   1F18 00 00 00 00 
3056   1F1C 00 00 00 00 
3056   1F20 00 00 00 00 
3056   1F24 00 00 00 00 
3056   1F28 00 00 00 00 
3056   1F2C 00 00 00 00 
3056   1F30 00 00 00 00 
3056   1F34 00 00 00 00 
3056   1F38 00 00 00 00 
3056   1F3C 00 00 00 00 
3056   1F40 00 00 00 00 
3056   1F44 00 00 00 00 
3056   1F48 00 00 00 00 
3056   1F4C 00 00 00 00 
3056   1F50 00 00 00 00 
3056   1F54 00 00 00 00 
3056   1F58 00 00 00 00 
3056   1F5C 00 00 00 00 
3056   1F60 00 00 00 00 
3056   1F64 00 00 00 00 
3056   1F68 00 00 00 00 
3056   1F6C 00 00 00 00 
3056   1F70 00 00 00 00 
3056   1F74 00 00 00 00 
3056   1F78 00 00 00 00 
3056   1F7C 00 00 00 00 
3056   1F80 00 00 00 00 
3056   1F84 00 00 00 00 
3056   1F88 00 00 00 00 
3056   1F8C 00 00 00 00 
3056   1F90 00 00 00 00 
3056   1F94 00 00 00 00 
3056   1F98 00 00 00 00 
3056   1F9C 00 00 00 00 
3056   1FA0 00 00 00 00 
3057   1FA4             fifo:
3058   1FA4 FF FF FF FF   .fill fifo_size
3058   1FA8 FF FF FF FF 
3058   1FAC FF FF FF FF 
3058   1FB0 FF FF FF FF 
3058   1FB4 FF FF FF FF 
3058   1FB8 FF FF FF FF 
3058   1FBC FF FF FF FF 
3058   1FC0 FF FF FF FF 
3058   1FC4 FF FF FF FF 
3058   1FC8 FF FF FF FF 
3058   1FCC FF FF FF FF 
3058   1FD0 FF FF FF FF 
3058   1FD4 FF FF FF FF 
3058   1FD8 FF FF FF FF 
3058   1FDC FF FF FF FF 
3058   1FE0 FF FF FF FF 
3058   1FE4 FF FF FF FF 
3058   1FE8 FF FF FF FF 
3058   1FEC FF FF FF FF 
3058   1FF0 FF FF FF FF 
3058   1FF4 FF FF FF FF 
3058   1FF8 FF FF FF FF 
3058   1FFC FF FF FF FF 
3058   2000 FF FF FF FF 
3058   2004 FF FF FF FF 
3058   2008 FF FF FF FF 
3058   200C FF FF FF FF 
3058   2010 FF FF FF FF 
3058   2014 FF FF FF FF 
3058   2018 FF FF FF FF 
3058   201C FF FF FF FF 
3058   2020 FF FF FF FF 
3058   2024 FF FF FF FF 
3058   2028 FF FF FF FF 
3058   202C FF FF FF FF 
3058   2030 FF FF FF FF 
3058   2034 FF FF FF FF 
3058   2038 FF FF FF FF 
3058   203C FF FF FF FF 
3058   2040 FF FF FF FF 
3058   2044 FF FF FF FF 
3058   2048 FF FF FF FF 
3058   204C FF FF FF FF 
3058   2050 FF FF FF FF 
3058   2054 FF FF FF FF 
3058   2058 FF FF FF FF 
3058   205C FF FF FF FF 
3058   2060 FF FF FF FF 
3058   2064 FF FF FF FF 
3058   2068 FF FF FF FF 
3058   206C FF FF FF FF 
3058   2070 FF FF FF FF 
3058   2074 FF FF FF FF 
3058   2078 FF FF FF FF 
3058   207C FF FF FF FF 
3058   2080 FF FF FF FF 
3058   2084 FF FF FF FF 
3058   2088 FF FF FF FF 
3058   208C FF FF FF FF 
3058   2090 FF FF FF FF 
3058   2094 FF FF FF FF 
3058   2098 FF FF FF FF 
3058   209C FF FF FF FF 
3058   20A0 FF FF FF FF 
3058   20A4 FF FF FF FF 
3058   20A8 FF FF FF FF 
3058   20AC FF FF FF FF 
3058   20B0 FF FF FF FF 
3058   20B4 FF FF FF FF 
3058   20B8 FF FF FF FF 
3058   20BC FF FF FF FF 
3058   20C0 FF FF FF FF 
3058   20C4 FF FF FF FF 
3058   20C8 FF FF FF FF 
3058   20CC FF FF FF FF 
3058   20D0 FF FF FF FF 
3058   20D4 FF FF FF FF 
3058   20D8 FF FF FF FF 
3058   20DC FF FF FF FF 
3058   20E0 FF FF FF FF 
3058   20E4 FF FF FF FF 
3058   20E8 FF FF FF FF 
3058   20EC FF FF FF FF 
3058   20F0 FF FF FF FF 
3058   20F4 FF FF FF FF 
3058   20F8 FF FF FF FF 
3058   20FC FF FF FF FF 
3058   2100 FF FF FF FF 
3058   2104 FF FF FF FF 
3058   2108 FF FF FF FF 
3058   210C FF FF FF FF 
3058   2110 FF FF FF FF 
3058   2114 FF FF FF FF 
3058   2118 FF FF FF FF 
3058   211C FF FF FF FF 
3058   2120 FF FF FF FF 
3058   2124 FF FF FF FF 
3058   2128 FF FF FF FF 
3058   212C FF FF FF FF 
3058   2130 FF FF FF FF 
3058   2134 FF FF FF FF 
3058   2138 FF FF FF FF 
3058   213C FF FF FF FF 
3058   2140 FF FF FF FF 
3058   2144 FF FF FF FF 
3058   2148 FF FF FF FF 
3058   214C FF FF FF FF 
3058   2150 FF FF FF FF 
3058   2154 FF FF FF FF 
3058   2158 FF FF FF FF 
3058   215C FF FF FF FF 
3058   2160 FF FF FF FF 
3058   2164 FF FF FF FF 
3058   2168 FF FF FF FF 
3058   216C FF FF FF FF 
3058   2170 FF FF FF FF 
3058   2174 FF FF FF FF 
3058   2178 FF FF FF FF 
3058   217C FF FF FF FF 
3058   2180 FF FF FF FF 
3058   2184 FF FF FF FF 
3058   2188 FF FF FF FF 
3058   218C FF FF FF FF 
3058   2190 FF FF FF FF 
3058   2194 FF FF FF FF 
3058   2198 FF FF FF FF 
3058   219C FF FF FF FF 
3058   21A0 FF FF FF FF 
3058   21A4 FF FF FF FF 
3058   21A8 FF FF FF FF 
3058   21AC FF FF FF FF 
3058   21B0 FF FF FF FF 
3058   21B4 FF FF FF FF 
3058   21B8 FF FF FF FF 
3058   21BC FF FF FF FF 
3058   21C0 FF FF FF FF 
3058   21C4 FF FF FF FF 
3058   21C8 FF FF FF FF 
3058   21CC FF FF FF FF 
3058   21D0 FF FF FF FF 
3058   21D4 FF FF FF FF 
3058   21D8 FF FF FF FF 
3058   21DC FF FF FF FF 
3058   21E0 FF FF FF FF 
3058   21E4 FF FF FF FF 
3058   21E8 FF FF FF FF 
3058   21EC FF FF FF FF 
3058   21F0 FF FF FF FF 
3058   21F4 FF FF FF FF 
3058   21F8 FF FF FF FF 
3058   21FC FF FF FF FF 
3058   2200 FF FF FF FF 
3058   2204 FF FF FF FF 
3058   2208 FF FF FF FF 
3058   220C FF FF FF FF 
3058   2210 FF FF FF FF 
3058   2214 FF FF FF FF 
3058   2218 FF FF FF FF 
3058   221C FF FF FF FF 
3058   2220 FF FF FF FF 
3058   2224 FF FF FF FF 
3058   2228 FF FF FF FF 
3058   222C FF FF FF FF 
3058   2230 FF FF FF FF 
3058   2234 FF FF FF FF 
3058   2238 FF FF FF FF 
3058   223C FF FF FF FF 
3058   2240 FF FF FF FF 
3058   2244 FF FF FF FF 
3058   2248 FF FF FF FF 
3058   224C FF FF FF FF 
3058   2250 FF FF FF FF 
3058   2254 FF FF FF FF 
3058   2258 FF FF FF FF 
3058   225C FF FF FF FF 
3058   2260 FF FF FF FF 
3058   2264 FF FF FF FF 
3058   2268 FF FF FF FF 
3058   226C FF FF FF FF 
3058   2270 FF FF FF FF 
3058   2274 FF FF FF FF 
3058   2278 FF FF FF FF 
3058   227C FF FF FF FF 
3058   2280 FF FF FF FF 
3058   2284 FF FF FF FF 
3058   2288 FF FF FF FF 
3058   228C FF FF FF FF 
3058   2290 FF FF FF FF 
3058   2294 FF FF FF FF 
3058   2298 FF FF FF FF 
3058   229C FF FF FF FF 
3058   22A0 FF FF FF FF 
3058   22A4 FF FF FF FF 
3058   22A8 FF FF FF FF 
3058   22AC FF FF FF FF 
3058   22B0 FF FF FF FF 
3058   22B4 FF FF FF FF 
3058   22B8 FF FF FF FF 
3058   22BC FF FF FF FF 
3058   22C0 FF FF FF FF 
3058   22C4 FF FF FF FF 
3058   22C8 FF FF FF FF 
3058   22CC FF FF FF FF 
3058   22D0 FF FF FF FF 
3058   22D4 FF FF FF FF 
3058   22D8 FF FF FF FF 
3058   22DC FF FF FF FF 
3058   22E0 FF FF FF FF 
3058   22E4 FF FF FF FF 
3058   22E8 FF FF FF FF 
3058   22EC FF FF FF FF 
3058   22F0 FF FF FF FF 
3058   22F4 FF FF FF FF 
3058   22F8 FF FF FF FF 
3058   22FC FF FF FF FF 
3058   2300 FF FF FF FF 
3058   2304 FF FF FF FF 
3058   2308 FF FF FF FF 
3058   230C FF FF FF FF 
3058   2310 FF FF FF FF 
3058   2314 FF FF FF FF 
3058   2318 FF FF FF FF 
3058   231C FF FF FF FF 
3058   2320 FF FF FF FF 
3058   2324 FF FF FF FF 
3058   2328 FF FF FF FF 
3058   232C FF FF FF FF 
3058   2330 FF FF FF FF 
3058   2334 FF FF FF FF 
3058   2338 FF FF FF FF 
3058   233C FF FF FF FF 
3058   2340 FF FF FF FF 
3058   2344 FF FF FF FF 
3058   2348 FF FF FF FF 
3058   234C FF FF FF FF 
3058   2350 FF FF FF FF 
3058   2354 FF FF FF FF 
3058   2358 FF FF FF FF 
3058   235C FF FF FF FF 
3058   2360 FF FF FF FF 
3058   2364 FF FF FF FF 
3058   2368 FF FF FF FF 
3058   236C FF FF FF FF 
3058   2370 FF FF FF FF 
3058   2374 FF FF FF FF 
3058   2378 FF FF FF FF 
3058   237C FF FF FF FF 
3058   2380 FF FF FF FF 
3058   2384 FF FF FF FF 
3058   2388 FF FF FF FF 
3058   238C FF FF FF FF 
3058   2390 FF FF FF FF 
3058   2394 FF FF FF FF 
3058   2398 FF FF FF FF 
3058   239C FF FF FF FF 
3058   23A0 FF FF FF FF 
3059   23A4             
3060   23A4             scrap_sector:
3061   23A4 FF FF FF FF   .fill 512         ; scrap sector
3061   23A8 FF FF FF FF 
3061   23AC FF FF FF FF 
3061   23B0 FF FF FF FF 
3061   23B4 FF FF FF FF 
3061   23B8 FF FF FF FF 
3061   23BC FF FF FF FF 
3061   23C0 FF FF FF FF 
3061   23C4 FF FF FF FF 
3061   23C8 FF FF FF FF 
3061   23CC FF FF FF FF 
3061   23D0 FF FF FF FF 
3061   23D4 FF FF FF FF 
3061   23D8 FF FF FF FF 
3061   23DC FF FF FF FF 
3061   23E0 FF FF FF FF 
3061   23E4 FF FF FF FF 
3061   23E8 FF FF FF FF 
3061   23EC FF FF FF FF 
3061   23F0 FF FF FF FF 
3061   23F4 FF FF FF FF 
3061   23F8 FF FF FF FF 
3061   23FC FF FF FF FF 
3061   2400 FF FF FF FF 
3061   2404 FF FF FF FF 
3061   2408 FF FF FF FF 
3061   240C FF FF FF FF 
3061   2410 FF FF FF FF 
3061   2414 FF FF FF FF 
3061   2418 FF FF FF FF 
3061   241C FF FF FF FF 
3061   2420 FF FF FF FF 
3061   2424 FF FF FF FF 
3061   2428 FF FF FF FF 
3061   242C FF FF FF FF 
3061   2430 FF FF FF FF 
3061   2434 FF FF FF FF 
3061   2438 FF FF FF FF 
3061   243C FF FF FF FF 
3061   2440 FF FF FF FF 
3061   2444 FF FF FF FF 
3061   2448 FF FF FF FF 
3061   244C FF FF FF FF 
3061   2450 FF FF FF FF 
3061   2454 FF FF FF FF 
3061   2458 FF FF FF FF 
3061   245C FF FF FF FF 
3061   2460 FF FF FF FF 
3061   2464 FF FF FF FF 
3061   2468 FF FF FF FF 
3061   246C FF FF FF FF 
3061   2470 FF FF FF FF 
3061   2474 FF FF FF FF 
3061   2478 FF FF FF FF 
3061   247C FF FF FF FF 
3061   2480 FF FF FF FF 
3061   2484 FF FF FF FF 
3061   2488 FF FF FF FF 
3061   248C FF FF FF FF 
3061   2490 FF FF FF FF 
3061   2494 FF FF FF FF 
3061   2498 FF FF FF FF 
3061   249C FF FF FF FF 
3061   24A0 FF FF FF FF 
3061   24A4 FF FF FF FF 
3061   24A8 FF FF FF FF 
3061   24AC FF FF FF FF 
3061   24B0 FF FF FF FF 
3061   24B4 FF FF FF FF 
3061   24B8 FF FF FF FF 
3061   24BC FF FF FF FF 
3061   24C0 FF FF FF FF 
3061   24C4 FF FF FF FF 
3061   24C8 FF FF FF FF 
3061   24CC FF FF FF FF 
3061   24D0 FF FF FF FF 
3061   24D4 FF FF FF FF 
3061   24D8 FF FF FF FF 
3061   24DC FF FF FF FF 
3061   24E0 FF FF FF FF 
3061   24E4 FF FF FF FF 
3061   24E8 FF FF FF FF 
3061   24EC FF FF FF FF 
3061   24F0 FF FF FF FF 
3061   24F4 FF FF FF FF 
3061   24F8 FF FF FF FF 
3061   24FC FF FF FF FF 
3061   2500 FF FF FF FF 
3061   2504 FF FF FF FF 
3061   2508 FF FF FF FF 
3061   250C FF FF FF FF 
3061   2510 FF FF FF FF 
3061   2514 FF FF FF FF 
3061   2518 FF FF FF FF 
3061   251C FF FF FF FF 
3061   2520 FF FF FF FF 
3061   2524 FF FF FF FF 
3061   2528 FF FF FF FF 
3061   252C FF FF FF FF 
3061   2530 FF FF FF FF 
3061   2534 FF FF FF FF 
3061   2538 FF FF FF FF 
3061   253C FF FF FF FF 
3061   2540 FF FF FF FF 
3061   2544 FF FF FF FF 
3061   2548 FF FF FF FF 
3061   254C FF FF FF FF 
3061   2550 FF FF FF FF 
3061   2554 FF FF FF FF 
3061   2558 FF FF FF FF 
3061   255C FF FF FF FF 
3061   2560 FF FF FF FF 
3061   2564 FF FF FF FF 
3061   2568 FF FF FF FF 
3061   256C FF FF FF FF 
3061   2570 FF FF FF FF 
3061   2574 FF FF FF FF 
3061   2578 FF FF FF FF 
3061   257C FF FF FF FF 
3061   2580 FF FF FF FF 
3061   2584 FF FF FF FF 
3061   2588 FF FF FF FF 
3061   258C FF FF FF FF 
3061   2590 FF FF FF FF 
3061   2594 FF FF FF FF 
3061   2598 FF FF FF FF 
3061   259C FF FF FF FF 
3061   25A0 FF FF FF FF 
3062   25A4             transient_area:
3063   25A4 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
3064   25A5             
3065   25A5             .end
tasm: Number of errors = 0
