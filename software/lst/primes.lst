0001   0000             .include "lib/kernel.exp"
0001+  0000             fdc_al_restore   .EQU  $0000
0002+  0000             fdc_al_step      .EQU  $0001
0003+  0000             fdc_al_step_in   .EQU  $0002
0004+  0000             fdc_al_step_out  .EQU  $0003
0005+  0000             fdc_al_seek      .EQU  $0004
0006+  0000             fdc_al_format_128 .EQU  $0005
0007+  0000             fdc_al_formatdisk_128 .EQU  $0006
0008+  0000             fdc_al_format_512 .EQU  $0007
0009+  0000             fdc_al_formatdisk_512 .EQU  $0008
0010+  0000             fdc_al_read_addr .EQU  $0009
0011+  0000             fdc_al_read_track .EQU  $000a
0012+  0000             fdc_al_read_sect .EQU  $000b
0013+  0000             fdc_al_write_sect .EQU  $000c
0014+  0000             fdc_al_force_int .EQU  $000d
0015+  0000             fdc_al_status0   .EQU  $000e
0016+  0000             fdc_al_status1   .EQU  $000f
0017+  0000             noname._til311_display .EQU  $ffb0
0018+  0000             noname._fdc_config .EQU  $ffc0
0019+  0000             noname._fdc_status_0 .EQU  $ffc1
0020+  0000             noname._fdc_stat_cmd .EQU  $ffc8
0021+  0000             sys_break        .EQU  $0000
0022+  0000             sys_rtc          .EQU  $0001
0023+  0000             sys_ide          .EQU  $0002
0024+  0000             sys_io           .EQU  $0003
0025+  0000             sys_filesystem   .EQU  $0004
0026+  0000             sys_create_proc  .EQU  $0005
0027+  0000             sys_list_proc    .EQU  $0006
0028+  0000             sys_datetime     .EQU  $0007
0029+  0000             sys_reboot       .EQU  $0008
0030+  0000             sys_pause_proc   .EQU  $0009
0031+  0000             sys_resume_proc  .EQU  $000a
0032+  0000             sys_terminate_proc .EQU  $000b
0033+  0000             sys_system       .EQU  $000c
0034+  0000             sys_fdc          .EQU  $000d
0035+  0000             text_org         .EQU  $0400
0002   0000             
0003   0400             .org text_org
0004   0400             
0005   0400             primes:
0006   0400 FD 47 FF FF 	mov sp, $FFFF
0007   0404 FD 49 FF FF 	mov bp, $FFFF
0008   0408             
0009   0408 10 00 00    	mov a, 0
0010   040B 42 09 0A    	mov [prog], a
0011   040E 07 6A 08    	call get_token
0012   0411 1D 0C 0A    	mov al, [tok]
0013   0414 B9 14       	cmp al, tok_end
0014   0416 C6 64 04    	je bad_args
0015   0419 3B 0D 0A    	mov d, tokstr
0016   041C 07 51 06    	call _strtoint
0017   041F 42 C1 0B    	mov [max], a
0018   0422             	
0019   0422 10 02 00    	mov a, 2
0020   0425             primes_l1:
0021   0425 38 02 00    	mov c, 2	
0022   0428             primes_l2:
0023   0428 D7          	push a
0024   0429 28          	mov b, c
0025   042A AE          	div a, b
0026   042B C0 00 00    	cmp b, 0
0027   042E C6 36 04    	jz divisible
0028   0431 78          	inc c
0029   0432 E4          	pop a
0030   0433 0A 28 04    	jmp primes_l2		
0031   0436             divisible:
0032   0436 E4          	pop a
0033   0437 B1          	cmp a, c
0034   0438 C7 5E 04    	jnz notprime			
0035   043B             isprime:
0036   043B 07 AA 06    	call print_u16d
0037   043E             	
0038   043E D7          	push a
0039   043F 14 BF 0B    	mov a, [total]
0040   0442 77          	inc a
0041   0443 42 BF 0B    	mov [total], a
0042   0446 3B D2 0B    	mov d, s_total
0043   0449 07 81 06    	call _puts
0044   044C 07 AA 06    	call print_u16d
0045   044F             	
0046   044F E4          	pop a
0047   0450             
0048   0450 07 2E 06    	call printnl
0049   0453 77          	inc a
0050   0454 29 C1 0B    	mov b, [max]
0051   0457 B0          	cmp a, b
0052   0458 C9 62 04    	jgeu primes_ret
0053   045B 0A 25 04    	jmp primes_l1
0054   045E             notprime:
0055   045E 77          	inc a
0056   045F 0A 25 04    	jmp primes_l1		
0057   0462             primes_ret:
0058   0462 05 0B       	syscall sys_terminate_proc
0059   0464             
0060   0464             bad_args:
0061   0464 3B AA 0B    	mov d, s_usage
0062   0467 07 81 06    	call _puts
0063   046A 0A 62 04    	jmp primes_ret
0064   046D             
0065   046D             .include "lib/stdio.asm"
0001+  046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  046D             ; stdio.s
0003+  046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  046D             .include "lib/string.asm"
0001++ 046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 046D             ; string.s
0003++ 046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 046D             
0005++ 046D             
0006++ 046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 046D             ; _strrev
0008++ 046D             ; reverse a string
0009++ 046D             ; d = string address
0010++ 046D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 046D             ; 01234
0012++ 046D             _strrev:
0013++ 046D 4B          	pusha
0014++ 046E 07 B4 04    	call _strlen	; length in c
0015++ 0471 12          	mov a, c
0016++ 0472 AF 01 00    	cmp a, 1
0017++ 0475 D0 8F 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 0478 7D          	dec a
0019++ 0479 FD 4E       	mov si, d	; beginning of string
0020++ 047B FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 047D 59          	add d, a	; end of string
0022++ 047E 12          	mov a, c
0023++ 047F FD 9B       	shr a		; divide by 2
0024++ 0481 39          	mov c, a	; c now counts the steps
0025++ 0482             _strrev_l0:
0026++ 0482 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0483 F6          	lodsb		; load left-side char into al; increase si
0028++ 0484 3E          	mov [d], al	; store left char into right side
0029++ 0485 1B          	mov al, bl
0030++ 0486 F7          	stosb		; store right-side char into left-side; increase di
0031++ 0487 7E          	dec c
0032++ 0488 7F          	dec d
0033++ 0489 C2 00 00    	cmp c, 0
0034++ 048C C7 82 04    	jne _strrev_l0
0035++ 048F             _strrev_end:
0036++ 048F 4C          	popa
0037++ 0490 09          	ret
0038++ 0491             	
0039++ 0491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0491             ; _strchr
0041++ 0491             ; search string in d for char in al
0042++ 0491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0491             _strchr:
0044++ 0491             _strchr_l0:
0045++ 0491 32          	mov bl, [d]
0046++ 0492 C1 00       	cmp bl, 0
0047++ 0494 C6 9F 04    	je _strchr_end
0048++ 0497 BA          	cmp al, bl
0049++ 0498 C6 9F 04    	je _strchr_end
0050++ 049B 79          	inc d
0051++ 049C 0A 91 04    	jmp _strchr_l0
0052++ 049F             _strchr_end:
0053++ 049F 1B          	mov al, bl
0054++ 04A0 09          	ret
0055++ 04A1             
0056++ 04A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04A1             ; _strstr
0058++ 04A1             ; find sub-string
0059++ 04A1             ; str1 in si
0060++ 04A1             ; str2 in di
0061++ 04A1             ; si points to end of source string
0062++ 04A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04A1             _strstr:
0064++ 04A1 DB          	push al
0065++ 04A2 DA          	push d
0066++ 04A3 E3          	push di
0067++ 04A4             _strstr_loop:
0068++ 04A4 F3          	cmpsb					; compare a byte of the strings
0069++ 04A5 C7 B0 04    	jne _strstr_ret
0070++ 04A8 FC 00 00    	lea d, [di + 0]
0071++ 04AB BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04AD C7 A4 04    	jne _strstr_loop				; equal chars but not at end
0073++ 04B0             _strstr_ret:
0074++ 04B0 F0          	pop di
0075++ 04B1 E7          	pop d
0076++ 04B2 E8          	pop al
0077++ 04B3 09          	ret
0078++ 04B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04B4             ; length of null terminated string
0080++ 04B4             ; result in c
0081++ 04B4             ; pointer in d
0082++ 04B4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04B4             _strlen:
0084++ 04B4 DA          	push d
0085++ 04B5 38 00 00    	mov c, 0
0086++ 04B8             _strlen_l1:
0087++ 04B8 BD 00       	cmp byte [d], 0
0088++ 04BA C6 C2 04    	je _strlen_ret
0089++ 04BD 79          	inc d
0090++ 04BE 78          	inc c
0091++ 04BF 0A B8 04    	jmp _strlen_l1
0092++ 04C2             _strlen_ret:
0093++ 04C2 E7          	pop d
0094++ 04C3 09          	ret
0095++ 04C4             
0096++ 04C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04C4             ; strcmp
0098++ 04C4             ; compare two strings
0099++ 04C4             ; str1 in si
0100++ 04C4             ; str2 in di
0101++ 04C4             ; create a string compairon instrucion ?????
0102++ 04C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04C4             _strcmp:
0104++ 04C4 DB          	push al
0105++ 04C5 DA          	push d
0106++ 04C6 E3          	push di
0107++ 04C7 E2          	push si
0108++ 04C8             _strcmp_loop:
0109++ 04C8 F3          	cmpsb					; compare a byte of the strings
0110++ 04C9 C7 D4 04    	jne _strcmp_ret
0111++ 04CC FB FF FF    	lea d, [si +- 1]
0112++ 04CF BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04D1 C7 C8 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 04D4             _strcmp_ret:
0115++ 04D4 EF          	pop si
0116++ 04D5 F0          	pop di
0117++ 04D6 E7          	pop d
0118++ 04D7 E8          	pop al
0119++ 04D8 09          	ret
0120++ 04D9             
0121++ 04D9             
0122++ 04D9             ; strcpy
0123++ 04D9             ; copy null terminated string from si to di
0124++ 04D9             ; source in si
0125++ 04D9             ; destination in di
0126++ 04D9             _strcpy:
0127++ 04D9 E2          	push si
0128++ 04DA E3          	push di
0129++ 04DB DB          	push al
0130++ 04DC             _strcpy_l1:
0131++ 04DC F6          	lodsb
0132++ 04DD F7          	stosb
0133++ 04DE B9 00       	cmp al, 0
0134++ 04E0 C7 DC 04    	jne _strcpy_l1
0135++ 04E3             _strcpy_end:
0136++ 04E3 E8          	pop al
0137++ 04E4 F0          	pop di
0138++ 04E5 EF          	pop si
0139++ 04E6 09          	ret
0140++ 04E7             
0141++ 04E7             ; strcat
0142++ 04E7             ; concatenate a null terminated string into string at di, from string at si
0143++ 04E7             ; source in si
0144++ 04E7             ; destination in di
0145++ 04E7             _strcat:
0146++ 04E7 E2          	push si
0147++ 04E8 E3          	push di
0148++ 04E9 D7          	push a
0149++ 04EA DA          	push d
0150++ 04EB 50          	mov a, di
0151++ 04EC 3C          	mov d, a
0152++ 04ED             _strcat_goto_end_l1:
0153++ 04ED BD 00       	cmp byte[d], 0
0154++ 04EF C6 F6 04    	je _strcat_start
0155++ 04F2 79          	inc d
0156++ 04F3 0A ED 04    	jmp _strcat_goto_end_l1
0157++ 04F6             _strcat_start:
0158++ 04F6 FD 50       	mov di, d
0159++ 04F8             _strcat_l1:
0160++ 04F8 F6          	lodsb
0161++ 04F9 F7          	stosb
0162++ 04FA B9 00       	cmp al, 0
0163++ 04FC C7 F8 04    	jne _strcat_l1
0164++ 04FF             _strcat_end:
0165++ 04FF E7          	pop d
0166++ 0500 E4          	pop a
0167++ 0501 F0          	pop di
0168++ 0502 EF          	pop si
0169++ 0503 09          	ret
0170++ 0504             
0171++ 0504             
0005+  0504             
0006+  0504             
0007+  0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0504             ; convert ascii 'o'..'f' to integer 0..15
0009+  0504             ; ascii in bl
0010+  0504             ; result in al
0011+  0504             ; ascii for f = 0100 0110
0012+  0504             ; ascii for 9 = 0011 1001
0013+  0504             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0504             hex_ascii_encode:
0015+  0504 1B            mov al, bl
0016+  0505 93 40         test al, $40        ; test if letter or number
0017+  0507 C7 0D 05      jnz hex_letter
0018+  050A 87 0F         and al, $0f        ; get number
0019+  050C 09            ret
0020+  050D             hex_letter:
0021+  050D 87 0F         and al, $0f        ; get letter
0022+  050F 6A 09         add al, 9
0023+  0511 09            ret
0024+  0512             
0025+  0512             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0512             ; atoi
0027+  0512             ; 2 letter hex string in b
0028+  0512             ; 8bit integer returned in al
0029+  0512             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0512             _atoi:
0031+  0512 D8            push b
0032+  0513 07 04 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  0516 30            mov bl, bh
0034+  0517 DB            push al          ; save a
0035+  0518 07 04 05      call hex_ascii_encode
0036+  051B EA            pop bl  
0037+  051C FD 9E 04      shl al, 4
0038+  051F 8C            or al, bl
0039+  0520 E5            pop b
0040+  0521 09            ret  
0041+  0522             
0042+  0522             
0043+  0522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0522             ; scanf
0045+  0522             ; no need for explanations!
0046+  0522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0522             scanf:
0048+  0522 09            ret
0049+  0523             
0050+  0523             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0523             ; itoa
0052+  0523             ; 8bit value in bl
0053+  0523             ; 2 byte ascii result in a
0054+  0523             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0523             _itoa:
0056+  0523 DA            push d
0057+  0524 D8            push b
0058+  0525 A7 00         mov bh, 0
0059+  0527 FD A4 04      shr bl, 4  
0060+  052A 74            mov d, b
0061+  052B 1F BD 07      mov al, [d + s_hex_digits]
0062+  052E 23            mov ah, al
0063+  052F               
0064+  052F E5            pop b
0065+  0530 D8            push b
0066+  0531 A7 00         mov bh, 0
0067+  0533 FD 87 0F      and bl, $0f
0068+  0536 74            mov d, b
0069+  0537 1F BD 07      mov al, [d + s_hex_digits]
0070+  053A E5            pop b
0071+  053B E7            pop d
0072+  053C 09            ret
0073+  053D             
0074+  053D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  053D             ; hex string to binary
0076+  053D             ; di = destination address
0077+  053D             ; si = source
0078+  053D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  053D             _hex_to_int:
0080+  053D             _hex_to_int_l1:
0081+  053D F6            lodsb          ; load from [si] to al
0082+  053E B9 00         cmp al, 0        ; check if ascii 0
0083+  0540 C6 4D 05      jz _hex_to_int_ret
0084+  0543 36            mov bh, al
0085+  0544 F6            lodsb
0086+  0545 2F            mov bl, al
0087+  0546 07 12 05      call _atoi        ; convert ascii byte in b to int (to al)
0088+  0549 F7            stosb          ; store al to [di]
0089+  054A 0A 3D 05      jmp _hex_to_int_l1
0090+  054D             _hex_to_int_ret:
0091+  054D 09            ret    
0092+  054E             
0093+  054E             
0094+  054E             
0095+  054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  054E             ; getchar
0097+  054E             ; char in ah
0098+  054E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  054E             getch:
0100+  054E DB            push al
0101+  054F             getch_retry:
0102+  054F 19 01         mov al, 1
0103+  0551 05 03         syscall sys_io      ; receive in ah
0104+  0553 E8            pop al
0105+  0554 09            ret
0106+  0555             
0107+  0555             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0555             ; putchar
0109+  0555             ; char in ah
0110+  0555             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0555             _putchar:
0112+  0555 DB            push al
0113+  0556 19 00         mov al, 0
0114+  0558 05 03         syscall sys_io      ; char in ah
0115+  055A E8            pop al
0116+  055B 09            ret
0117+  055C             
0118+  055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  055C             ;; input a string
0120+  055C             ;; terminates with null
0121+  055C             ;; pointer in d
0122+  055C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  055C             _gets:
0124+  055C D7            push a
0125+  055D DA            push d
0126+  055E             _gets_loop:
0127+  055E 19 01         mov al, 1
0128+  0560 05 03         syscall sys_io      ; receive in ah
0129+  0562 76 1B         cmp ah, 27
0130+  0564 C6 85 05      je _gets_ansi_esc
0131+  0567 76 0A         cmp ah, $0a        ; lf
0132+  0569 C6 E1 05      je _gets_end
0133+  056C 76 0D         cmp ah, $0d        ; cr
0134+  056E C6 E1 05      je _gets_end
0135+  0571 76 5C         cmp ah, $5c        ; '\\'
0136+  0573 C6 A7 05      je _gets_escape
0137+  0576 76 08         cmp ah, $08      ; check for backspace
0138+  0578 C6 81 05      je _gets_backspace
0139+  057B 1A            mov al, ah
0140+  057C 3E            mov [d], al
0141+  057D 79            inc d
0142+  057E 0A 5E 05      jmp _gets_loop
0143+  0581             _gets_backspace:
0144+  0581 7F            dec d
0145+  0582 0A 5E 05      jmp _gets_loop
0146+  0585             _gets_ansi_esc:
0147+  0585 19 01         mov al, 1
0148+  0587 05 03         syscall sys_io        ; receive in ah without echo
0149+  0589 76 5B         cmp ah, '['
0150+  058B C7 5E 05      jne _gets_loop
0151+  058E 19 01         mov al, 1
0152+  0590 05 03         syscall sys_io          ; receive in ah without echo
0153+  0592 76 64         cmp ah, 'd'
0154+  0594 C6 9F 05      je _gets_left_arrow
0155+  0597 76 63         cmp ah, 'c'
0156+  0599 C6 A3 05      je _gets_right_arrow
0157+  059C 0A 5E 05      jmp _gets_loop
0158+  059F             _gets_left_arrow:
0159+  059F 7F            dec d
0160+  05A0 0A 5E 05      jmp _gets_loop
0161+  05A3             _gets_right_arrow:
0162+  05A3 79            inc d
0163+  05A4 0A 5E 05      jmp _gets_loop
0164+  05A7             _gets_escape:
0165+  05A7 19 01         mov al, 1
0166+  05A9 05 03         syscall sys_io      ; receive in ah
0167+  05AB 76 6E         cmp ah, 'n'
0168+  05AD C6 CC 05      je _gets_lf
0169+  05B0 76 72         cmp ah, 'r'
0170+  05B2 C6 D3 05      je _gets_cr
0171+  05B5 76 30         cmp ah, '0'
0172+  05B7 C6 DA 05      je _gets_null
0173+  05BA 76 5C         cmp ah, $5c  ; '\'
0174+  05BC C6 C5 05      je _gets_slash
0175+  05BF 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  05C0 3E            mov [d], al
0177+  05C1 79            inc d
0178+  05C2 0A 5E 05      jmp _gets_loop
0179+  05C5             _gets_slash:
0180+  05C5 19 5C         mov al, $5c
0181+  05C7 3E            mov [d], al
0182+  05C8 79            inc d
0183+  05C9 0A 5E 05      jmp _gets_loop
0184+  05CC             _gets_lf:
0185+  05CC 19 0A         mov al, $0a
0186+  05CE 3E            mov [d], al
0187+  05CF 79            inc d
0188+  05D0 0A 5E 05      jmp _gets_loop
0189+  05D3             _gets_cr:
0190+  05D3 19 0D         mov al, $0d
0191+  05D5 3E            mov [d], al
0192+  05D6 79            inc d
0193+  05D7 0A 5E 05      jmp _gets_loop
0194+  05DA             _gets_null:
0195+  05DA 19 00         mov al, $00
0196+  05DC 3E            mov [d], al
0197+  05DD 79            inc d
0198+  05DE 0A 5E 05      jmp _gets_loop
0199+  05E1             _gets_end:
0200+  05E1 19 00         mov al, 0
0201+  05E3 3E            mov [d], al        ; terminate string
0202+  05E4 E7            pop d
0203+  05E5 E4            pop a
0204+  05E6 09            ret
0205+  05E7             
0206+  05E7             
0207+  05E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  05E7             ;; input text
0209+  05E7             ;; terminated with ctrl+d
0210+  05E7             ;; pointer in d
0211+  05E7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  05E7             _gettxt:
0213+  05E7 D7            push a
0214+  05E8 DA            push d
0215+  05E9             _gettxt_loop:
0216+  05E9 19 01         mov al, 1
0217+  05EB 05 03         syscall sys_io      ; receive in ah
0218+  05ED 76 04         cmp ah, 4      ; eot
0219+  05EF C6 28 06      je _gettxt_end
0220+  05F2 76 08         cmp ah, $08      ; check for backspace
0221+  05F4 C6 24 06      je _gettxt_backspace
0222+  05F7 76 5C         cmp ah, $5c        ; '\'
0223+  05F9 C6 02 06      je _gettxt_escape
0224+  05FC 1A            mov al, ah
0225+  05FD 3E            mov [d], al
0226+  05FE 79            inc d
0227+  05FF 0A E9 05      jmp _gettxt_loop
0228+  0602             _gettxt_escape:
0229+  0602 19 01         mov al, 1
0230+  0604 05 03         syscall sys_io      ; receive in ah
0231+  0606 76 6E         cmp ah, 'n'
0232+  0608 C6 16 06      je _gettxt_lf
0233+  060B 76 72         cmp ah, 'r'
0234+  060D C6 1D 06      je _gettxt_cr
0235+  0610 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0611 3E            mov [d], al
0237+  0612 79            inc d
0238+  0613 0A E9 05      jmp _gettxt_loop
0239+  0616             _gettxt_lf:
0240+  0616 19 0A         mov al, $0a
0241+  0618 3E            mov [d], al
0242+  0619 79            inc d
0243+  061A 0A E9 05      jmp _gettxt_loop
0244+  061D             _gettxt_cr:
0245+  061D 19 0D         mov al, $0d
0246+  061F 3E            mov [d], al
0247+  0620 79            inc d
0248+  0621 0A E9 05      jmp _gettxt_loop
0249+  0624             _gettxt_backspace:
0250+  0624 7F            dec d
0251+  0625 0A E9 05      jmp _gettxt_loop
0252+  0628             _gettxt_end:
0253+  0628 19 00         mov al, 0
0254+  062A 3E            mov [d], al        ; terminate string
0255+  062B E7            pop d
0256+  062C E4            pop a
0257+  062D 09            ret
0258+  062E             
0259+  062E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  062E             ; print new line
0261+  062E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  062E             printnl:
0263+  062E D7            push a
0264+  062F 10 00 0A      mov a, $0a00
0265+  0632 05 03         syscall sys_io
0266+  0634 10 00 0D      mov a, $0d00
0267+  0637 05 03         syscall sys_io
0268+  0639 E4            pop a
0269+  063A 09            ret
0270+  063B             
0271+  063B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  063B             ; _strtoint
0273+  063B             ; 4 digit hex string number in d
0274+  063B             ; integer returned in a
0275+  063B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  063B             _strtointx:
0277+  063B D8            push b
0278+  063C 32            mov bl, [d]
0279+  063D 37            mov bh, bl
0280+  063E 33 01 00      mov bl, [d + 1]
0281+  0641 07 12 05      call _atoi        ; convert to int in al
0282+  0644 23            mov ah, al        ; move to ah
0283+  0645 33 02 00      mov bl, [d + 2]
0284+  0648 37            mov bh, bl
0285+  0649 33 03 00      mov bl, [d + 3]
0286+  064C 07 12 05      call _atoi        ; convert to int in al
0287+  064F E5            pop b
0288+  0650 09            ret
0289+  0651             
0290+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0651             ; _strtoint
0292+  0651             ; 5 digit base10 string number in d
0293+  0651             ; integer returned in a
0294+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0651             _strtoint:
0296+  0651 E2            push si
0297+  0652 D8            push b
0298+  0653 D9            push c
0299+  0654 DA            push d
0300+  0655 07 B4 04      call _strlen      ; get string length in c
0301+  0658 7E            dec c
0302+  0659 FD 4E         mov si, d
0303+  065B 12            mov a, c
0304+  065C FD 99         shl a
0305+  065E 3B D5 07      mov d, table_power
0306+  0661 59            add d, a
0307+  0662 38 00 00      mov c, 0
0308+  0665             _strtoint_l0:
0309+  0665 F6            lodsb      ; load ascii to al
0310+  0666 B9 00         cmp al, 0
0311+  0668 C6 7B 06      je _strtoint_end
0312+  066B 6F 30         sub al, $30    ; make into integer
0313+  066D 22 00         mov ah, 0
0314+  066F 2A            mov b, [d]
0315+  0670 AC            mul a, b      ; result in b since it fits in 16bits
0316+  0671 11            mov a, b
0317+  0672 28            mov b, c
0318+  0673 54            add a, b
0319+  0674 39            mov c, a
0320+  0675 63 02 00      sub d, 2
0321+  0678 0A 65 06      jmp _strtoint_l0
0322+  067B             _strtoint_end:
0323+  067B 12            mov a, c
0324+  067C E7            pop d
0325+  067D E6            pop c
0326+  067E E5            pop b
0327+  067F EF            pop si
0328+  0680 09            ret
0329+  0681             
0330+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0681             ; print null terminated string
0332+  0681             ; pointer in d
0333+  0681             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0681             _puts:
0335+  0681 D7            push a
0336+  0682 DA            push d
0337+  0683             _puts_l1:
0338+  0683 1E            mov al, [d]
0339+  0684 B9 00         cmp al, 0
0340+  0686 C6 92 06      jz _puts_end
0341+  0689 23            mov ah, al
0342+  068A 19 00         mov al, 0
0343+  068C 05 03         syscall sys_io
0344+  068E 79            inc d
0345+  068F 0A 83 06      jmp _puts_l1
0346+  0692             _puts_end:
0347+  0692 E7            pop d
0348+  0693 E4            pop a
0349+  0694 09            ret
0350+  0695             
0351+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0695             ; print n size string
0353+  0695             ; pointer in d
0354+  0695             ; size in c
0355+  0695             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0695             _putsn:
0357+  0695 DB            push al
0358+  0696 DA            push d
0359+  0697 D9            push c
0360+  0698             _putsn_l0:
0361+  0698 1E            mov al, [d]
0362+  0699 23            mov ah, al
0363+  069A 19 00         mov al, 0
0364+  069C 05 03         syscall sys_io
0365+  069E 79            inc d
0366+  069F 7E            dec c  
0367+  06A0 C2 00 00      cmp c, 0
0368+  06A3 C7 98 06      jne _putsn_l0
0369+  06A6             _putsn_end:
0370+  06A6 E6            pop c
0371+  06A7 E7            pop d
0372+  06A8 E8            pop al
0373+  06A9 09            ret
0374+  06AA             
0375+  06AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  06AA             ; print 16bit decimal number
0377+  06AA             ; input number in a
0378+  06AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06AA             print_u16d:
0380+  06AA D7            push a
0381+  06AB D8            push b
0382+  06AC FD D8         push g
0383+  06AE 26 10 27      mov b, 10000
0384+  06B1 AE            div a, b      ; get 10000's coeff.
0385+  06B2 07 D6 06      call print_number
0386+  06B5 11            mov a, b
0387+  06B6 26 E8 03      mov b, 1000
0388+  06B9 AE            div a, b      ; get 1000's coeff.
0389+  06BA 07 D6 06      call print_number
0390+  06BD 11            mov a, b
0391+  06BE 26 64 00      mov b, 100
0392+  06C1 AE            div a, b
0393+  06C2 07 D6 06      call print_number
0394+  06C5 11            mov a, b
0395+  06C6 26 0A 00      mov b, 10
0396+  06C9 AE            div a, b
0397+  06CA 07 D6 06      call print_number
0398+  06CD 1B            mov al, bl      ; 1's coeff in bl
0399+  06CE 07 D6 06      call print_number
0400+  06D1 FD F1         pop g
0401+  06D3 E5            pop b
0402+  06D4 E4            pop a
0403+  06D5 09            ret
0404+  06D6             
0405+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06D6             ; print al
0407+  06D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  06D6             print_number:
0409+  06D6 6A 30         add al, $30
0410+  06D8 23            mov ah, al
0411+  06D9 07 55 05      call _putchar
0412+  06DC 09            ret
0413+  06DD             
0414+  06DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  06DD             ; print 16bit hex integer
0416+  06DD             ; integer value in reg b
0417+  06DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  06DD             print_u16x:
0419+  06DD D7            push a
0420+  06DE D8            push b
0421+  06DF DD            push bl
0422+  06E0 30            mov bl, bh
0423+  06E1 07 23 05      call _itoa        ; convert bh to char in a
0424+  06E4 2F            mov bl, al        ; save al
0425+  06E5 19 00         mov al, 0
0426+  06E7 05 03         syscall sys_io        ; display ah
0427+  06E9 24            mov ah, bl        ; retrieve al
0428+  06EA 19 00         mov al, 0
0429+  06EC 05 03         syscall sys_io        ; display al
0430+  06EE             
0431+  06EE EA            pop bl
0432+  06EF 07 23 05      call _itoa        ; convert bh to char in a
0433+  06F2 2F            mov bl, al        ; save al
0434+  06F3 19 00         mov al, 0
0435+  06F5 05 03         syscall sys_io        ; display ah
0436+  06F7 24            mov ah, bl        ; retrieve al
0437+  06F8 19 00         mov al, 0
0438+  06FA 05 03         syscall sys_io        ; display al
0439+  06FC             
0440+  06FC E5            pop b
0441+  06FD E4            pop a
0442+  06FE 09            ret
0443+  06FF             
0444+  06FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  06FF             ; input 16bit hex integer
0446+  06FF             ; read 16bit integer into a
0447+  06FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  06FF             scan_u16x:
0449+  06FF F8 10 00      enter 16
0450+  0702 D8            push b
0451+  0703 DA            push d
0452+  0704             
0453+  0704 FA F1 FF      lea d, [bp + -15]
0454+  0707 07 5C 05      call _gets        ; get number
0455+  070A             
0456+  070A 32            mov bl, [d]
0457+  070B 37            mov bh, bl
0458+  070C 33 01 00      mov bl, [d + 1]
0459+  070F 07 12 05      call _atoi        ; convert to int in al
0460+  0712 23            mov ah, al        ; move to ah
0461+  0713             
0462+  0713 33 02 00      mov bl, [d + 2]
0463+  0716 37            mov bh, bl
0464+  0717 33 03 00      mov bl, [d + 3]
0465+  071A 07 12 05      call _atoi        ; convert to int in al
0466+  071D             
0467+  071D E7            pop d
0468+  071E E5            pop b
0469+  071F F9            leave
0470+  0720 09            ret
0471+  0721             
0472+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0721             ; print 8bit hex integer
0474+  0721             ; integer value in reg bl
0475+  0721             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0721             print_u8x:
0477+  0721 D7            push a
0478+  0722 DD            push bl
0479+  0723             
0480+  0723 07 23 05      call _itoa        ; convert bl to char in a
0481+  0726 2F            mov bl, al        ; save al
0482+  0727 19 00         mov al, 0
0483+  0729 05 03         syscall sys_io        ; display ah
0484+  072B 24            mov ah, bl        ; retrieve al
0485+  072C 19 00         mov al, 0
0486+  072E 05 03         syscall sys_io        ; display al
0487+  0730             
0488+  0730 EA            pop bl
0489+  0731 E4            pop a
0490+  0732 09            ret
0491+  0733             
0492+  0733             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0733             ; print 8bit decimal unsigned number
0494+  0733             ; input number in al
0495+  0733             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0733             print_u8d:
0497+  0733 D7            push a
0498+  0734 D8            push b
0499+  0735 FD D8         push g
0500+  0737 22 00         mov ah, 0
0501+  0739 26 64 00      mov b, 100
0502+  073C AE            div a, b
0503+  073D D8            push b      ; save remainder
0504+  073E B9 00         cmp al, 0
0505+  0740 C6 4A 07      je skip100
0506+  0743 6A 30         add al, $30
0507+  0745 23            mov ah, al
0508+  0746 19 00         mov al, 0
0509+  0748 05 03         syscall sys_io  ; print coeff
0510+  074A             skip100:
0511+  074A E4            pop a
0512+  074B 22 00         mov ah, 0
0513+  074D 26 0A 00      mov b, 10
0514+  0750 AE            div a, b
0515+  0751 D8            push b      ; save remainder
0516+  0752 B9 00         cmp al, 0
0517+  0754 C6 5E 07      je skip10
0518+  0757 6A 30         add al, $30
0519+  0759 23            mov ah, al
0520+  075A 19 00         mov al, 0
0521+  075C 05 03         syscall sys_io  ; print coeff
0522+  075E             skip10:
0523+  075E E4            pop a
0524+  075F 1B            mov al, bl
0525+  0760 6A 30         add al, $30
0526+  0762 23            mov ah, al
0527+  0763 19 00         mov al, 0
0528+  0765 05 03         syscall sys_io  ; print coeff
0529+  0767 FD F1         pop g
0530+  0769 E5            pop b
0531+  076A E4            pop a
0532+  076B 09            ret
0533+  076C             
0534+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  076C             ; input 8bit hex integer
0536+  076C             ; read 8bit integer into al
0537+  076C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  076C             scan_u8x:
0539+  076C F8 04 00      enter 4
0540+  076F D8            push b
0541+  0770 DA            push d
0542+  0771             
0543+  0771 FA FD FF      lea d, [bp + -3]
0544+  0774 07 5C 05      call _gets        ; get number
0545+  0777             
0546+  0777 32            mov bl, [d]
0547+  0778 37            mov bh, bl
0548+  0779 33 01 00      mov bl, [d + 1]
0549+  077C 07 12 05      call _atoi        ; convert to int in al
0550+  077F             
0551+  077F E7            pop d
0552+  0780 E5            pop b
0553+  0781 F9            leave
0554+  0782 09            ret
0555+  0783             
0556+  0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0783             ; input decimal number
0558+  0783             ; result in a
0559+  0783             ; 655'\0'
0560+  0783             ; low--------high
0561+  0783             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0783             scan_u16d:
0563+  0783 F8 08 00      enter 8
0564+  0786 E2            push si
0565+  0787 D8            push b
0566+  0788 D9            push c
0567+  0789 DA            push d
0568+  078A FA F9 FF      lea d, [bp +- 7]
0569+  078D 07 5C 05      call _gets
0570+  0790 07 B4 04      call _strlen      ; get string length in c
0571+  0793 7E            dec c
0572+  0794 FD 4E         mov si, d
0573+  0796 12            mov a, c
0574+  0797 FD 99         shl a
0575+  0799 3B D5 07      mov d, table_power
0576+  079C 59            add d, a
0577+  079D 38 00 00      mov c, 0
0578+  07A0             mul_loop:
0579+  07A0 F6            lodsb      ; load ascii to al
0580+  07A1 B9 00         cmp al, 0
0581+  07A3 C6 B6 07      je mul_exit
0582+  07A6 6F 30         sub al, $30    ; make into integer
0583+  07A8 22 00         mov ah, 0
0584+  07AA 2A            mov b, [d]
0585+  07AB AC            mul a, b      ; result in b since it fits in 16bits
0586+  07AC 11            mov a, b
0587+  07AD 28            mov b, c
0588+  07AE 54            add a, b
0589+  07AF 39            mov c, a
0590+  07B0 63 02 00      sub d, 2
0591+  07B3 0A A0 07      jmp mul_loop
0592+  07B6             mul_exit:
0593+  07B6 12            mov a, c
0594+  07B7 E7            pop d
0595+  07B8 E6            pop c
0596+  07B9 E5            pop b
0597+  07BA EF            pop si
0598+  07BB F9            leave
0599+  07BC 09            ret
0600+  07BD             
0601+  07BD             
0602+  07BD 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  07C1 34 35 36 37 
0602+  07C5 38 39 61 62 
0602+  07C9 63 64 65 66 
0603+  07CD 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  07D1 1B 5B 68 00 
0604+  07D5             
0605+  07D5             table_power:
0606+  07D5 01 00         .dw 1
0607+  07D7 0A 00         .dw 10
0608+  07D9 64 00         .dw 100
0609+  07DB E8 03         .dw 1000
0610+  07DD 10 27         .dw 100000066   07DF             .include "lib/token.asm"
0001+  07DF             toktyp_identifier  .equ 0
0002+  07DF             toktyp_keyword     .equ 1
0003+  07DF             toktyp_delimiter   .equ 2
0004+  07DF             toktyp_string      .equ 3
0005+  07DF             toktyp_char        .equ 4
0006+  07DF             toktyp_numeric     .equ 5
0007+  07DF             toktyp_end         .equ 6
0008+  07DF             
0009+  07DF             tok_null           .equ 0
0010+  07DF             tok_fslash         .equ 1
0011+  07DF             tok_times          .equ 2
0012+  07DF             tok_plus           .equ 3
0013+  07DF             tok_minus          .equ 4
0014+  07DF             tok_dot            .equ 5
0015+  07DF             tok_semi           .equ 6
0016+  07DF             tok_angle          .equ 7
0017+  07DF             tok_tilde          .equ 8
0018+  07DF             tok_equal          .equ 9
0019+  07DF             tok_colon          .equ 10
0020+  07DF             tok_comma          .equ 11
0021+  07DF             
0022+  07DF             tok_end            .equ 20
0023+  07DF             
0024+  07DF             
0025+  07DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  07DF             ;; read a full command argment from shell input buffer
0027+  07DF             ;; argument is written into tokstr
0028+  07DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0029+  07DF             get_arg:
0030+  07DF D7            push a
0031+  07E0 E2            push si
0032+  07E1 E3            push di
0033+  07E2 19 00         mov al, 0
0034+  07E4 3D 0D 0A      mov [tokstr], al      ; nullify tokstr string
0035+  07E7 14 09 0A      mov a, [prog]
0036+  07EA 4D            mov si, a
0037+  07EB FD 4F 0D 0A   mov di, tokstr
0038+  07EF             get_arg_skip_spaces:
0039+  07EF F6            lodsb
0040+  07F0 07 83 0B      call _isspace
0041+  07F3 C6 EF 07      je get_arg_skip_spaces
0042+  07F6             get_arg_l0:
0043+  07F6 B9 3B         cmp al, $3b        ; check if is ';'
0044+  07F8 C6 05 08      je get_arg_end
0045+  07FB B9 00         cmp al, 0
0046+  07FD C6 05 08      je get_arg_end      ; check if end of input
0047+  0800 F7            stosb
0048+  0801 F6            lodsb
0049+  0802 0A F6 07      jmp get_arg_l0
0050+  0805             get_arg_end:
0051+  0805 19 00         mov al, 0
0052+  0807 F7            stosb
0053+  0808 D5 01 00      sub si, 1
0054+  080B 4E            mov a, si
0055+  080C 42 09 0A      mov [prog], a    ; update pointer
0056+  080F F0            pop di
0057+  0810 EF            pop si
0058+  0811 E4            pop a
0059+  0812 09            ret
0060+  0813             
0061+  0813             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0062+  0813             ;; read a path formation from shell input buffer
0063+  0813             ;; path is written into tokstr
0064+  0813             ;; /usr/bin
0065+  0813             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0066+  0813             get_path:
0067+  0813 D7            push a
0068+  0814 E2            push si
0069+  0815 E3            push di
0070+  0816 19 00         mov al, 0
0071+  0818 3D 0D 0A      mov [tokstr], al      ; nullify tokstr string
0072+  081B 14 09 0A      mov a, [prog]
0073+  081E 4D            mov si, a
0074+  081F FD 4F 0D 0A   mov di, tokstr
0075+  0823             get_path_skip_spaces:
0076+  0823 F6            lodsb
0077+  0824 07 83 0B      call _isspace
0078+  0827 C6 23 08      je get_path_skip_spaces
0079+  082A             get_path_is_pathchar:
0080+  082A F7            stosb
0081+  082B F6            lodsb
0082+  082C 07 0D 0B      call _isalnum      ;check if is alphanumeric
0083+  082F C6 2A 08      je get_path_is_pathchar
0084+  0832 B9 2F         cmp al, '/'        ; check if is '/'
0085+  0834 C6 2A 08      je get_path_is_pathchar
0086+  0837 19 00         mov al, 0
0087+  0839 F7            stosb
0088+  083A D5 01 00      sub si, 1
0089+  083D 4E            mov a, si
0090+  083E 42 09 0A      mov [prog], a    ; update pointer
0091+  0841             get_path_end:
0092+  0841 F0            pop di
0093+  0842 EF            pop si
0094+  0843 E4            pop a
0095+  0844 09            ret
0096+  0845             
0097+  0845             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0098+  0845             ;; read a line
0099+  0845             ;; line is written into tokstr
0100+  0845             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0101+  0845             get_line:
0102+  0845 D7            push a
0103+  0846 E2            push si
0104+  0847 E3            push di
0105+  0848 19 00         mov al, 0
0106+  084A 3D 0D 0A      mov [tokstr], al      ; nullify tokstr string
0107+  084D 14 09 0A      mov a, [prog]
0108+  0850 4D            mov si, a
0109+  0851 FD 4F 0D 0A   mov di, tokstr
0110+  0855             get_line_l0:
0111+  0855 F6            lodsb
0112+  0856 B9 0A         cmp al, $0a    ; check for new line
0113+  0858 C6 5F 08      je get_line_exit
0114+  085B F7            stosb
0115+  085C 0A 55 08      jmp get_line_l0
0116+  085F             get_line_exit:
0117+  085F 19 00         mov al, 0
0118+  0861 F7            stosb
0119+  0862 4E            mov a, si
0120+  0863 42 09 0A      mov [prog], a    ; update pointer
0121+  0866 F0            pop di
0122+  0867 EF            pop si
0123+  0868 E4            pop a
0124+  0869 09            ret
0125+  086A             
0126+  086A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0127+  086A             ;; token parser
0128+  086A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0129+  086A             get_token:
0130+  086A D7            push a
0131+  086B DA            push d
0132+  086C E2            push si
0133+  086D E3            push di
0134+  086E 19 00         mov al, 0
0135+  0870 3D 0D 0A      mov [tokstr], al      ; nullify tokstr string
0136+  0873 19 00         mov al, tok_null
0137+  0875 3D 0C 0A      mov [tok], al        ; nullify token
0138+  0878 14 09 0A      mov a, [prog]
0139+  087B 4D            mov si, a
0140+  087C FD 4F 0D 0A   mov di, tokstr
0141+  0880             get_tok_skip_spaces:
0142+  0880 F6            lodsb
0143+  0881 07 83 0B      call _isspace
0144+  0884 C6 80 08      je get_tok_skip_spaces
0145+  0887 B9 00         cmp al, 0      ; check for end of input (null)
0146+  0889 C6 6E 09      je get_token_end
0147+  088C B9 23         cmp al, '#'      ; comments!
0148+  088E C6 9C 09      je get_tok_comment
0149+  0891 07 0D 0B      call _isalnum
0150+  0894 C6 7B 09      jz is_alphanumeric
0151+  0897             ; other token types
0152+  0897             get_token_slash:
0153+  0897 B9 2F         cmp al, '/'        ; check if '/'
0154+  0899 C7 B1 08      jne get_token_minus
0155+  089C F7            stosb          ; store '/' into token string
0156+  089D 19 00         mov al, 0
0157+  089F F7            stosb          ; terminate token string
0158+  08A0 19 01         mov al, tok_fslash
0159+  08A2 3D 0C 0A      mov [tok], al      
0160+  08A5 19 02         mov al, toktyp_delimiter
0161+  08A7 3D 0B 0A      mov [toktyp], al
0162+  08AA 4E            mov a, si
0163+  08AB 42 09 0A      mov [prog], a    ; update pointer
0164+  08AE 0A 97 09      jmp get_token_return
0165+  08B1             get_token_minus:
0166+  08B1 B9 2D         cmp al, '-'        ; check if '-'
0167+  08B3 C7 CB 08      jne get_token_comma
0168+  08B6 F7            stosb          ; store '-' into token string
0169+  08B7 19 00         mov al, 0
0170+  08B9 F7            stosb          ; terminate token string
0171+  08BA 19 04         mov al, tok_minus
0172+  08BC 3D 0C 0A      mov [tok], al      
0173+  08BF 19 02         mov al, toktyp_delimiter
0174+  08C1 3D 0B 0A      mov [toktyp], al
0175+  08C4 4E            mov a, si
0176+  08C5 42 09 0A      mov [prog], a    ; update pointer
0177+  08C8 0A 97 09      jmp get_token_return
0178+  08CB             get_token_comma:
0179+  08CB B9 2C         cmp al, ','        ; check if ','
0180+  08CD C7 E5 08      jne get_token_semi
0181+  08D0 F7            stosb          ; store ',' into token string
0182+  08D1 19 00         mov al, 0
0183+  08D3 F7            stosb          ; terminate token string
0184+  08D4 19 0B         mov al, tok_comma
0185+  08D6 3D 0C 0A      mov [tok], al      
0186+  08D9 19 02         mov al, toktyp_delimiter
0187+  08DB 3D 0B 0A      mov [toktyp], al
0188+  08DE 4E            mov a, si
0189+  08DF 42 09 0A      mov [prog], a    ; update pointer
0190+  08E2 0A 97 09      jmp get_token_return
0191+  08E5             get_token_semi:
0192+  08E5 B9 3B         cmp al, $3b        ; check if ';'
0193+  08E7 C7 FF 08      jne get_token_colon
0194+  08EA F7            stosb          ; store ';' into token string
0195+  08EB 19 00         mov al, 0
0196+  08ED F7            stosb          ; terminate token string
0197+  08EE 19 06         mov al, tok_semi
0198+  08F0 3D 0C 0A      mov [tok], al      
0199+  08F3 19 02         mov al, toktyp_delimiter
0200+  08F5 3D 0B 0A      mov [toktyp], al
0201+  08F8 4E            mov a, si
0202+  08F9 42 09 0A      mov [prog], a    ; update pointer
0203+  08FC 0A 97 09      jmp get_token_return
0204+  08FF             get_token_colon:
0205+  08FF B9 3A         cmp al, $3a        ; check if ':'
0206+  0901 C7 19 09      jne get_token_angle
0207+  0904 F7            stosb          ; store ':' into token string
0208+  0905 19 00         mov al, 0
0209+  0907 F7            stosb          ; terminate token string
0210+  0908 19 0A         mov al, tok_colon
0211+  090A 3D 0C 0A      mov [tok], al      
0212+  090D 19 02         mov al, toktyp_delimiter
0213+  090F 3D 0B 0A      mov [toktyp], al
0214+  0912 4E            mov a, si
0215+  0913 42 09 0A      mov [prog], a    ; update pointer
0216+  0916 0A 97 09      jmp get_token_return
0217+  0919             get_token_angle:
0218+  0919 B9 3E         cmp al, $3e        ; check if '>'
0219+  091B C7 33 09      jne get_token_tilde
0220+  091E F7            stosb          ; store '>' into token string
0221+  091F 19 00         mov al, 0
0222+  0921 F7            stosb          ; terminate token string
0223+  0922 19 07         mov al, tok_angle
0224+  0924 3D 0C 0A      mov [tok], al      
0225+  0927 19 02         mov al, toktyp_delimiter
0226+  0929 3D 0B 0A      mov [toktyp], al
0227+  092C 4E            mov a, si
0228+  092D 42 09 0A      mov [prog], a    ; update pointer
0229+  0930 0A 97 09      jmp get_token_return
0230+  0933             get_token_tilde:
0231+  0933 B9 7E         cmp al, '~'        ; check if '~'
0232+  0935 C7 4D 09      jne get_token_equal
0233+  0938 F7            stosb          ; store '~' into token string
0234+  0939 19 00         mov al, 0
0235+  093B F7            stosb          ; terminate token string
0236+  093C 19 08         mov al, tok_tilde
0237+  093E 3D 0C 0A      mov [tok], al      
0238+  0941 19 02         mov al, toktyp_delimiter
0239+  0943 3D 0B 0A      mov [toktyp], al
0240+  0946 4E            mov a, si
0241+  0947 42 09 0A      mov [prog], a    ; update pointer
0242+  094A 0A 97 09      jmp get_token_return
0243+  094D             get_token_equal:
0244+  094D B9 3D         cmp al, '='        ; check if '='
0245+  094F C7 67 09      jne get_token_skip
0246+  0952 F7            stosb          ; store '=' into token string
0247+  0953 19 00         mov al, 0
0248+  0955 F7            stosb          ; terminate token string
0249+  0956 19 09         mov al, tok_equal
0250+  0958 3D 0C 0A      mov [tok], al      
0251+  095B 19 02         mov al, toktyp_delimiter
0252+  095D 3D 0B 0A      mov [toktyp], al
0253+  0960 4E            mov a, si
0254+  0961 42 09 0A      mov [prog], a    ; update pointer
0255+  0964 0A 97 09      jmp get_token_return
0256+  0967             get_token_skip:
0257+  0967 4E            mov a, si
0258+  0968 42 09 0A      mov [prog], a    ; update pointer
0259+  096B 0A 97 09      jmp get_token_return
0260+  096E             get_token_end:        ; end of file token
0261+  096E 19 14         mov al, tok_end
0262+  0970 3D 0C 0A      mov [tok], al
0263+  0973 19 06         mov al, toktyp_end
0264+  0975 3D 0B 0A      mov [toktyp], al
0265+  0978 0A 97 09      jmp get_token_return
0266+  097B             is_alphanumeric:
0267+  097B F7            stosb
0268+  097C F6            lodsb
0269+  097D 07 0D 0B      call _isalnum      ;check if is alphanumeric
0270+  0980 C6 7B 09      jz is_alphanumeric
0271+  0983 B9 2E         cmp al, $2e        ; check if is '.'
0272+  0985 C6 7B 09      je is_alphanumeric
0273+  0988 19 00         mov al, 0
0274+  098A F7            stosb
0275+  098B 19 00         mov al, toktyp_identifier
0276+  098D 3D 0B 0A      mov [toktyp], al
0277+  0990 D5 01 00      sub si, 1
0278+  0993 4E            mov a, si
0279+  0994 42 09 0A      mov [prog], a    ; update pointer
0280+  0997             get_token_return:
0281+  0997 F0            pop di
0282+  0998 EF            pop si
0283+  0999 E7            pop d
0284+  099A E4            pop a
0285+  099B 09            ret
0286+  099C             get_tok_comment:
0287+  099C F6            lodsb
0288+  099D B9 0A         cmp al, $0a      ; new line
0289+  099F C7 9C 09      jne get_tok_comment
0290+  09A2 0A 80 08      jmp get_tok_skip_spaces
0291+  09A5             
0292+  09A5             
0293+  09A5             get_number:
0294+  09A5 D7            push a
0295+  09A6 DA            push d
0296+  09A7 E2            push si
0297+  09A8 E3            push di
0298+  09A9 19 00         mov al, 0
0299+  09AB 3D 0D 0A      mov [tokstr], al      ; nullify tokstr string
0300+  09AE 19 00         mov al, tok_null
0301+  09B0 3D 0C 0A      mov [tok], al        ; nullify token
0302+  09B3 14 09 0A      mov a, [prog]
0303+  09B6 4D            mov si, a
0304+  09B7 FD 4F 0D 0A   mov di, tokstr
0305+  09BB             get_number_skip_spaces:
0306+  09BB F6            lodsb
0307+  09BC 07 83 0B      call _isspace
0308+  09BF C6 BB 09      je get_number_skip_spaces
0309+  09C2 B9 00         cmp al, 0      ; check for end of input (null)
0310+  09C4 C7 D4 09      jne get_number_l0
0311+  09C7 19 14         mov al, tok_end
0312+  09C9 3D 0C 0A      mov [tok], al
0313+  09CC 19 06         mov al, toktyp_end
0314+  09CE 3D 0B 0A      mov [toktyp], al
0315+  09D1 0A EB 09      jmp get_number_return
0316+  09D4             get_number_l0:
0317+  09D4 F7            stosb
0318+  09D5 F6            lodsb
0319+  09D6 07 17 0B      call _isdigit      ;check if is numeric
0320+  09D9 C6 D4 09      jz get_number_l0
0321+  09DC 19 00         mov al, 0
0322+  09DE F7            stosb
0323+  09DF 19 05         mov al, toktyp_numeric
0324+  09E1 3D 0B 0A      mov [toktyp], al
0325+  09E4 D5 01 00      sub si, 1
0326+  09E7 4E            mov a, si
0327+  09E8 42 09 0A      mov [prog], a    ; update pointer
0328+  09EB             get_number_return:
0329+  09EB F0            pop di
0330+  09EC EF            pop si
0331+  09ED E7            pop d
0332+  09EE E4            pop a
0333+  09EF 09            ret
0334+  09F0             
0335+  09F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0336+  09F0             ;; put back token
0337+  09F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;  
0338+  09F0             _putback:
0339+  09F0 D7            push a
0340+  09F1 E2            push si
0341+  09F2 FD 4D 0D 0A   mov si, tokstr  
0342+  09F6             _putback_loop:
0343+  09F6 F6            lodsb
0344+  09F7 B9 00         cmp al, 0
0345+  09F9 C6 06 0A      je _putback_end
0346+  09FC 14 09 0A      mov a, [prog]
0347+  09FF 7D            dec a
0348+  0A00 42 09 0A      mov [prog], a      ; update pointer
0349+  0A03 0A F6 09      jmp _putback_loop
0350+  0A06             _putback_end:
0351+  0A06 EF            pop si
0352+  0A07 E4            pop a
0353+  0A08 09            ret
0354+  0A09             
0355+  0A09             
0356+  0A09             
0357+  0A09             
0358+  0A09 00 00       prog:      .dw 0          ; pointer to current position in buffer
0359+  0A0B             
0360+  0A0B 00          toktyp:    .db 0          ; token type symbol
0361+  0A0C 00          tok:       .db 0          ; current token symbol
0362+  0A0D 00 00 00 00 tokstr:    .fill 256, 0   ; token as a string
0362+  0A11 00 00 00 00 
0362+  0A15 00 00 00 00 
0362+  0A19 00 00 00 00 
0362+  0A1D 00 00 00 00 
0362+  0A21 00 00 00 00 
0362+  0A25 00 00 00 00 
0362+  0A29 00 00 00 00 
0362+  0A2D 00 00 00 00 
0362+  0A31 00 00 00 00 
0362+  0A35 00 00 00 00 
0362+  0A39 00 00 00 00 
0362+  0A3D 00 00 00 00 
0362+  0A41 00 00 00 00 
0362+  0A45 00 00 00 00 
0362+  0A49 00 00 00 00 
0362+  0A4D 00 00 00 00 
0362+  0A51 00 00 00 00 
0362+  0A55 00 00 00 00 
0362+  0A59 00 00 00 00 
0362+  0A5D 00 00 00 00 
0362+  0A61 00 00 00 00 
0362+  0A65 00 00 00 00 
0362+  0A69 00 00 00 00 
0362+  0A6D 00 00 00 00 
0362+  0A71 00 00 00 00 
0362+  0A75 00 00 00 00 
0362+  0A79 00 00 00 00 
0362+  0A7D 00 00 00 00 
0362+  0A81 00 00 00 00 
0362+  0A85 00 00 00 00 
0362+  0A89 00 00 00 00 
0362+  0A8D 00 00 00 00 
0362+  0A91 00 00 00 00 
0362+  0A95 00 00 00 00 
0362+  0A99 00 00 00 00 
0362+  0A9D 00 00 00 00 
0362+  0AA1 00 00 00 00 
0362+  0AA5 00 00 00 00 
0362+  0AA9 00 00 00 00 
0362+  0AAD 00 00 00 00 
0362+  0AB1 00 00 00 00 
0362+  0AB5 00 00 00 00 
0362+  0AB9 00 00 00 00 
0362+  0ABD 00 00 00 00 
0362+  0AC1 00 00 00 00 
0362+  0AC5 00 00 00 00 
0362+  0AC9 00 00 00 00 
0362+  0ACD 00 00 00 00 
0362+  0AD1 00 00 00 00 
0362+  0AD5 00 00 00 00 
0362+  0AD9 00 00 00 00 
0362+  0ADD 00 00 00 00 
0362+  0AE1 00 00 00 00 
0362+  0AE5 00 00 00 00 
0362+  0AE9 00 00 00 00 
0362+  0AED 00 00 00 00 
0362+  0AF1 00 00 00 00 
0362+  0AF5 00 00 00 00 
0362+  0AF9 00 00 00 00 
0362+  0AFD 00 00 00 00 
0362+  0B01 00 00 00 00 
0362+  0B05 00 00 00 00 
0362+  0B09 00 00 00 00 
0067   0B0D             .include "lib/ctype.asm"
0001+  0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0B0D             ; ctype.s
0003+  0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0B0D             
0005+  0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0B0D             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  0B0D             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  0B0D             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  0B0D             ;; characters are supported.
0010+  0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0B0D             ;; _isalnum 
0012+  0B0D             ;; _isalpha 
0013+  0B0D             ;; islower 
0014+  0B0D             ;; isupper 
0015+  0B0D             ;; _isdigit 
0016+  0B0D             ;; isxdigit
0017+  0B0D             ;; iscntrl 
0018+  0B0D             ;; isgraph 
0019+  0B0D             ;; _isspace 
0020+  0B0D             ;; isblank 
0021+  0B0D             ;; isprint 
0022+  0B0D             ;; ispunct 
0023+  0B0D             ;; tolower 
0024+  0B0D             ;; toupper
0025+  0B0D             
0026+  0B0D             
0027+  0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0B0D             ;; is alphanumeric
0029+  0B0D             ;; sets zf according with result
0030+  0B0D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0B0D             _isalnum:
0032+  0B0D 07 2A 0B    	call _isalpha
0033+  0B10 C6 16 0B    	je _isalnum_exit
0034+  0B13 07 17 0B    	call _isdigit
0035+  0B16             _isalnum_exit:
0036+  0B16 09          	ret	
0037+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0B17             ;; is digit
0039+  0B17             ;; sets zf according with result
0040+  0B17             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0B17             _isdigit:
0042+  0B17 DB          	push al
0043+  0B18 B9 30       	cmp al, '0'
0044+  0B1A C8 26 0B    	jlu _isdigit_false
0045+  0B1D B9 39       	cmp al, '9'
0046+  0B1F D1 26 0B    	jgu _isdigit_false
0047+  0B22 87 00       	and al, 0	; set zf
0048+  0B24 E8          	pop al
0049+  0B25 09          	ret
0050+  0B26             _isdigit_false:
0051+  0B26 8B 01       	or al, 1	; clear zf
0052+  0B28 E8          	pop al
0053+  0B29 09          	ret	
0054+  0B2A             	
0055+  0B2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0B2A             ;; is alpha
0057+  0B2A             ;; sets zf according with result
0058+  0B2A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0B2A             _isalpha:
0060+  0B2A DB          	push al
0061+  0B2B B9 5F       	cmp al, '_'
0062+  0B2D C6 4D 0B    	je _isalpha_true
0063+  0B30 B9 2E       	cmp al, '.'
0064+  0B32 C6 4D 0B    	je _isalpha_true
0065+  0B35 B9 61       	cmp al, 'a'
0066+  0B37 C8 49 0B    	jlu _isalpha_false
0067+  0B3A B9 7A       	cmp al, 'z'
0068+  0B3C D1 49 0B    	jgu _isalpha_false
0069+  0B3F B9 7A       	cmp al, 'z'
0070+  0B41 D0 4D 0B    	jleu _isalpha_true
0071+  0B44 B9 61       	cmp al, 'a'
0072+  0B46 C9 4D 0B    	jgeu _isalpha_true
0073+  0B49             _isalpha_false:
0074+  0B49 8B 01       	or al, 1	; clear zf
0075+  0B4B E8          	pop al
0076+  0B4C 09          	ret
0077+  0B4D             _isalpha_true:
0078+  0B4D 87 00       	and al, 0	; set zf
0079+  0B4F E8          	pop al
0080+  0B50 09          	ret
0081+  0B51             
0082+  0B51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0B51             ;; is path-alpha
0084+  0B51             ;; sets zf according with result
0085+  0B51             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0B51             ispath:
0087+  0B51 DB          	push al
0088+  0B52 07 17 0B    	call _isdigit
0089+  0B55 C6 7F 0B    	je ispath_true
0090+  0B58 B9 5F       	cmp al, '_'
0091+  0B5A C6 7F 0B    	je ispath_true
0092+  0B5D B9 2F       	cmp al, '/'
0093+  0B5F C6 7F 0B    	je ispath_true
0094+  0B62 B9 2E       	cmp al, '.'
0095+  0B64 C6 7F 0B    	je ispath_true
0096+  0B67 B9 61       	cmp al, 'a'
0097+  0B69 C8 7B 0B    	jlu ispath_false
0098+  0B6C B9 7A       	cmp al, 'z'
0099+  0B6E D1 7B 0B    	jgu ispath_false
0100+  0B71 B9 7A       	cmp al, 'z'
0101+  0B73 D0 7F 0B    	jleu ispath_true
0102+  0B76 B9 61       	cmp al, 'a'
0103+  0B78 C9 7F 0B    	jgeu ispath_true
0104+  0B7B             ispath_false:
0105+  0B7B 8B 01       	or al, 1	; clear zf
0106+  0B7D E8          	pop al
0107+  0B7E 09          	ret
0108+  0B7F             ispath_true:
0109+  0B7F 87 00       	and al, 0	; set zf
0110+  0B81 E8          	pop al
0111+  0B82 09          	ret
0112+  0B83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0B83             ;; is space
0114+  0B83             ;; sets zf according with result
0115+  0B83             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0B83             _isspace:
0117+  0B83 B9 20       	cmp al, $20		; ' '
0118+  0B85 C6 99 0B    	je _isspace_exit
0119+  0B88 B9 09       	cmp al, $09		; '\t'
0120+  0B8A C6 99 0B    	je _isspace_exit
0121+  0B8D B9 0A       	cmp al, $0a		; '\n'
0122+  0B8F C6 99 0B    	je _isspace_exit
0123+  0B92 B9 0D       	cmp al, $0d		; '\r'
0124+  0B94 C6 99 0B    	je _isspace_exit
0125+  0B97 B9 0B       	cmp al, $0b		; '\v'
0126+  0B99             _isspace_exit:
0127+  0B99 09          	ret	
0128+  0B9A             
0129+  0B9A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0B9A             ; to lower
0131+  0B9A             ; input in al
0132+  0B9A             ; output in al
0133+  0B9A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0B9A             _to_lower:
0135+  0B9A B9 7A       	cmp al, 'z'
0136+  0B9C D1 A1 0B    	jgu _to_lower_ret
0137+  0B9F 6A 20       	add al, $20				; convert to lower case
0138+  0BA1             _to_lower_ret:
0139+  0BA1 09          	ret
0140+  0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0BA2             ; to upper
0142+  0BA2             ; input in al
0143+  0BA2             ; output in al
0144+  0BA2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0BA2             _to_upper:
0146+  0BA2 B9 61       	cmp al, 'a'
0147+  0BA4 C8 A9 0B    	jlu _to_upper_ret
0148+  0BA7 6F 20       	sub al, $20			; convert to upper case
0149+  0BA9             _to_upper_ret:
0150+  0BA9 09          	ret
0151+  0BAA             
0068   0BAA             
0069   0BAA 55 73 61 67 s_usage:	.db "Usage: primes <max>\n", 0
0069   0BAE 65 3A 20 70 
0069   0BB2 72 69 6D 65 
0069   0BB6 73 20 3C 6D 
0069   0BBA 61 78 3E 0A 
0069   0BBE 00 
0070   0BBF 00 00       total:		.dw 0
0071   0BC1 E8 03       max:		.dw 1000
0072   0BC3             
0073   0BC3 0D 55 70 70 s_max:		.db "\rUpper bound: ", 0
0073   0BC7 65 72 20 62 
0073   0BCB 6F 75 6E 64 
0073   0BCF 3A 20 00 
0074   0BD2 2C 20 54 6F s_total:	.db ", Total primes: ", 0
0074   0BD6 74 61 6C 20 
0074   0BDA 70 72 69 6D 
0074   0BDE 65 73 3A 20 
0074   0BE2 00 
0075   0BE3             			
0076   0BE3             .end
tasm: Number of errors = 0
