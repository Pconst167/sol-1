0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; GLOBAL SYSTEM VARIABLES
0086   0000             ; ------------------------------------------------------------------------------------------------------------------;
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; IRQ table
0090   0000             ; highest priority at lowest address
0091   0000             ; ------------------------------------------------------------------------------------------------------------------;
0092   0000 2A 00       .dw int_0_fdc
0093   0002 2B 00       .dw int_1
0094   0004 2C 00       .dw int_2
0095   0006 2D 00       .dw int_3
0096   0008 2E 00       .dw int_4
0097   000A 2F 00       .dw int_5
0098   000C 30 00       .dw int_6
0099   000E 31 00       .dw int_7_uart0
0100   0010             
0101   0010             ; ------------------------------------------------------------------------------------------------------------------;
0102   0010             ; kernel reset vector
0103   0010             ; ------------------------------------------------------------------------------------------------------------------;
0104   0010 6A 02       .dw kernel_reset_vector
0105   0012             
0106   0012             ; ------------------------------------------------------------------------------------------------------------------;
0107   0012             ; exception vector table
0108   0012             ; total of 7 entries, starting at address $0012
0109   0012             ; ------------------------------------------------------------------------------------------------------------------;
0110   0012 D9 01       .dw trap_privilege
0111   0014 E5 01       .dw trap_div_zero
0112   0016 F2 01       .dw trap_undef_opcode
0113   0018 00 00       .dw 0
0114   001A 00 00       .dw 0
0115   001C 00 00       .dw 0
0116   001E 00 00       .dw 0
0117   0020             
0118   0020             ; ------------------------------------------------------------------------------------------------------------------;
0119   0020             ; system call vector table
0120   0020             ; starts at address $0020
0121   0020             ; ------------------------------------------------------------------------------------------------------------------;
0122   0020 F9 01       .dw syscall_io
0123   0022 CD 01       .dw syscall_reboot
0124   0024 D8 00       .dw syscall_fdc_format
0125   0026 50 00       .dw syscall_fdc_read
0126   0028 9A 00       .dw syscall_fdc_read_sec
0127   002A             
0128   002A             ; ------------------------------------------------------------------------------------------------------------------;
0129   002A             ; system call aliases
0130   002A             ; ------------------------------------------------------------------------------------------------------------------;
0131   002A             sys_io               .equ 0
0132   002A             sys_reboot           .equ 1
0133   002A             sys_fdc_format       .equ 2
0134   002A             sys_fdc_read         .equ 3
0135   002A             sys_fdc_read_sec     .equ 4
0136   002A             
0137   002A             ; ------------------------------------------------------------------------------------------------------------------;
0138   002A             ; IRQs' code block
0139   002A             ; ------------------------------------------------------------------------------------------------------------------;
0140   002A             ; 5.25" Floppy Drive Controller IRQ
0141   002A             int_0_fdc:
0142   002A 06            sysret
0143   002B             int_1:
0144   002B 06            sysret
0145   002C             int_2:
0146   002C 06            sysret
0147   002D             int_3:
0148   002D 06            sysret
0149   002E             int_4:
0150   002E 06            sysret
0151   002F             int_5:
0152   002F 06            sysret
0153   0030             
0154   0030             ; ------------------------------------------------------------------------------------------------------------------;
0155   0030             ; process swapping
0156   0030             ; ------------------------------------------------------------------------------------------------------------------;
0157   0030             int_6:  
0158   0030 06            sysret
0159   0031             
0160   0031             ; ------------------------------------------------------------------------------------------------------------------;
0161   0031             ; UART0 Interrupt
0162   0031             ; ------------------------------------------------------------------------------------------------------------------;
0163   0031             int_7_uart0:
0164   0031 D7            push a
0165   0032 DA            push d
0166   0033 E1            pushf
0167   0034 14 ED 08      mov a, [fifo_in]
0168   0037 3C            mov d, a
0169   0038 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0170   003B 3E            mov [d], al                 ; add to fifo
0171   003C 14 ED 08      mov a, [fifo_in]
0172   003F 77            inc a
0173   0040 AF 83 0F      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0174   0043 C7 49 00      jne int_7_continue
0175   0046 10 83 0B      mov a, fifo  
0176   0049             int_7_continue:  
0177   0049 42 ED 08      mov [fifo_in], a            ; update fifo pointer
0178   004C EE            popf
0179   004D E7            pop d
0180   004E E4            pop a  
0181   004F 06            sysret
0182   0050             
0183   0050             
0184   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0185   0050             ; floppy drive system calls
0186   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0187   0050             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0188   0050             ; fdc_40_FF:
0189   0050             ;   .fill 40,  $FF    ; or 00                                                                                
0190   0050             ; fdc_128_format_inner:
0191   0050             ;   .fill 6,   $00    ;                                                                            <--|        
0192   0050             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0193   0050             ;   .fill 1,   $00    ; Track Number  0 thru 39                                                       |                    
0194   0050             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0195   0050             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0196   0050             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0197   0050             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0198   0050             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0199   0050             ;   .fill 6,   $00    ;                                                                               |                        
0200   0050             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0201   0050             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0202   0050             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0203   0050             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0204   0050             ; fdc_128_format_end:
0205   0050             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0206   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   0050             ; _FDC_CONFIG       .equ $FFC0 
0208   0050             ; _FDC_STATUS_1     .equ $FFC1
0209   0050             ; _FDC_WD_STAT_CMD  .equ $FFC8
0210   0050             ; _FDC_WD_TRACK     .equ $FFC9
0211   0050             ; _FDC_WD_SECTOR    .equ $FFCA
0212   0050             ; _FDC_WD_DATA      .equ $FFCB
0213   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0214   0050             
0215   0050             syscall_fdc_read:
0216   0050 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0217   0053 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0218   0056 19 E8         mov al, %11101000         
0219   0058 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0220   005B 07 8B 01      call fdc_wait_64us
0221   005E             
0222   005E             ;fdc_wait_busy_high1:
0223   005E             ;  mov al, [_FDC_WD_STAT_CMD]      ; 
0224   005E             ;  test al, $01                ; 
0225   005E             ;  jz fdc_wait_busy_high1
0226   005E             
0227   005E FD 4F 83 11   mov di, transient_area
0228   0062             fdc_read_loop: ; for each byte, we need to wait for DRQ to be high
0229   0062 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0230   0065 93 01         test al, $01                ; check busy bit
0231   0067 C6 76 00      jz fdc_read_end
0232   006A 93 02         test al, $02                ; check drq bit
0233   006C C6 62 00      jz fdc_read_loop
0234   006F 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0235   0072 F7            stosb
0236   0073 0A 62 00      jmp fdc_read_loop
0237   0076             
0238   0076             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0239   0076             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0240   0076             ;because for every write, if it also reads, then that clears DRQ, so we need to wait for next DRQ.
0241   0076             fdc_read_end:
0242   0076 50            mov a, di
0243   0077 5F 83 11      sub a, transient_area
0244   007A 3B 8D 00      mov d, sss
0245   007D 07 EC 06      call _puts
0246   0080 07 15 07      call print_u16d
0247   0083 07 99 06      call printnl
0248   0086 26 E4 0C      mov b, 3300
0249   0089 07 9A 03      call cmd_hexd
0250   008C 06            sysret
0251   008D 0A 74 72 61 sss:.db "\ntrack read\n", 0
0251   0091 63 6B 20 72 
0251   0095 65 61 64 0A 
0251   0099 00 
0252   009A             
0253   009A             
0254   009A             ; sector in al
0255   009A             ; track in ah
0256   009A             syscall_fdc_read_sec:
0257   009A 3D CA FF      mov [_FDC_WD_SECTOR], al
0258   009D 1A            mov al, ah
0259   009E 3D C9 FF      mov [_FDC_WD_TRACK], al
0260   00A1 19 88         mov al, %10001000         
0261   00A3 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0262   00A6 07 8B 01      call fdc_wait_64us
0263   00A9             
0264   00A9             ;fdc_wait_busy_high2:
0265   00A9             ;  mov al, [_FDC_WD_STAT_CMD]      ; 
0266   00A9             ;  test al, $01                ; 
0267   00A9             ;  jz fdc_wait_busy_high2
0268   00A9             
0269   00A9 FD 4F 83 11   mov di, transient_area
0270   00AD             fdc_read_loop2: ; for each byte, we need to wait for DRQ to be high
0271   00AD 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag 10+3+5+8+5+8
0272   00B0 93 01         test al, $01                ; check drq bit
0273   00B2 C6 C1 00      jz fdc_read_end2
0274   00B5 93 02         test al, $02                ; check drq bit
0275   00B7 C6 AD 00      jz fdc_read_loop2
0276   00BA 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0277   00BD F7            stosb
0278   00BE 0A AD 00      jmp fdc_read_loop2
0279   00C1             fdc_read_end2:
0280   00C1 50            mov a, di
0281   00C2 5F 83 11      sub a, transient_area
0282   00C5 3B 8D 00      mov d, sss
0283   00C8 07 EC 06      call _puts
0284   00CB 07 15 07      call print_u16d
0285   00CE 07 99 06      call printnl
0286   00D1 26 80 00      mov b, 128
0287   00D4 07 9A 03      call cmd_hexd
0288   00D7 06            sysret
0289   00D8             
0290   00D8             ; bl: track number
0291   00D8             syscall_fdc_format:
0292   00D8 FD 3D C9 FF   mov [_FDC_WD_TRACK], bl
0293   00DC 3B 93 01      mov d, s_format_begin
0294   00DF 07 EC 06      call _puts
0295   00E2 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0296   00E5 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0297   00E8             fdc_header_loop_start:
0298   00E8 19 FA         mov al, %11111010               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0299   00EA 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0300   00ED             ; write the first data block for formatting which is 40 bytes of 0xFF:
0301   00ED 07 8B 01      call fdc_wait_64us
0302   00F0             
0303   00F0             
0304   00F0             ;fdc_wait_busy_high:
0305   00F0             ;  mov al, [_FDC_WD_STAT_CMD]      ; 
0306   00F0             ;  test al, $01                ; 
0307   00F0             ;  jz fdc_wait_busy_high
0308   00F0             
0309   00F0 FD 4D 83 11   mov si, transient_area
0310   00F4             fdc_format_drq:
0311   00F4 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]  ; 10
0312   00F7 93 01         test al, $01                ; 4
0313   00F9 C6 08 01      jz fdc_format_end           ; 8
0314   00FC 93 02         test al, $02                ; 4
0315   00FE C6 F4 00      jz fdc_format_drq           ; 8
0316   0101 F6            lodsb                       ; 7
0317   0102 3D CB FF      mov [_FDC_WD_DATA], al      ; 10   
0318   0105 0A F4 00      jmp fdc_format_drq
0319   0108             fdc_format_end:
0320   0108 3B 0F 01      mov d, sss1
0321   010B 07 EC 06      call _puts
0322   010E 06            sysret
0323   010F             
0324   010F 0A 66 6F 72 sss1:.db "\nformat done\n", 0
0324   0113 6D 61 74 20 
0324   0117 64 6F 6E 65 
0324   011B 0A 00 
0325   011D             
0326   011D             
0327   011D             
0328   011D             
0329   011D             
0330   011D             
0331   011D             fdc_format_mem:
0332   011D 3B 01 00      mov d, 1
0333   0120 FD 4F 83 11   mov di, transient_area
0334   0124 38 28 00      mov c, 40
0335   0127 19 FF         mov al, $FF
0336   0129             fdc_l0: 
0337   0129 F7            stosb
0338   012A 7E            dec c
0339   012B C7 29 01      jnz fdc_l0
0340   012E             
0341   012E             fdc_inner_loop:
0342   012E 38 06 00      mov c, 6
0343   0131 19 00         mov al, $00
0344   0133             fdc_l1:
0345   0133 F7            stosb
0346   0134 7E            dec c
0347   0135 C7 33 01      jnz fdc_l1
0348   0138             
0349   0138             ; address mark
0350   0138             fdc_l2:
0351   0138 19 FE         mov al, $FE
0352   013A F7            stosb
0353   013B             
0354   013B             ; track number
0355   013B             fdc_l3:
0356   013B 19 00         mov al, $00
0357   013D F7            stosb
0358   013E             
0359   013E             ; side number
0360   013E             fdc_l4:
0361   013E 19 00         mov al, $00
0362   0140 F7            stosb
0363   0141             
0364   0141             ; sector number
0365   0141             fdc_l5:
0366   0141 13            mov a, d
0367   0142 F7            stosb
0368   0143             
0369   0143             ; sector length 128 bytes
0370   0143             fdc_l6:
0371   0143 19 00         mov al, $00
0372   0145 F7            stosb
0373   0146             
0374   0146             ; 2 crc's
0375   0146             fdc_l7:
0376   0146 19 F7         mov al, $F7
0377   0148 F7            stosb
0378   0149             
0379   0149             ; 11 times $FF
0380   0149 38 0B 00      mov c, 11
0381   014C 19 FF         mov al, $FF
0382   014E             fdc_l8:
0383   014E F7            stosb
0384   014F 7E            dec c
0385   0150 C7 4E 01      jnz fdc_l8
0386   0153             
0387   0153             ; 6 times 00
0388   0153 38 06 00      mov c, 6
0389   0156 19 00         mov al, $00
0390   0158             fdc_l9:
0391   0158 F7            stosb
0392   0159 7E            dec c
0393   015A C7 58 01      jnz fdc_l9
0394   015D             
0395   015D             ; data address mark
0396   015D 19 FB         mov al, $FB
0397   015F             fdc_l10:
0398   015F F7            stosb
0399   0160             
0400   0160             ; sector data
0401   0160 38 00 00      mov c, 0
0402   0163             fdc_l11:
0403   0163 84            mov al, cl
0404   0164 F7            stosb
0405   0165 78            inc c
0406   0166 C2 80 00      cmp c, 128
0407   0169 C7 63 01      jne fdc_l11
0408   016C             
0409   016C             ; 2 crc's
0410   016C             fdc_l12:
0411   016C 19 F7         mov al, $F7
0412   016E F7            stosb
0413   016F             
0414   016F             ; 10 times $FF
0415   016F 38 0A 00      mov c, 10
0416   0172 19 FF         mov al, $FF
0417   0174             fdc_l13:
0418   0174 F7            stosb
0419   0175 7E            dec c
0420   0176 C7 74 01      jnz fdc_l13
0421   0179             
0422   0179             ; check whether we did this 16 times
0423   0179 79            inc d
0424   017A C5 11 00      cmp d, 17
0425   017D C7 2E 01      jne fdc_inner_loop
0426   0180             
0427   0180             ; loop ~369 times
0428   0180 38 90 01      mov c, 400
0429   0183 19 FF         mov al, $FF
0430   0185             fdc_format_footer:
0431   0185             fdc_footer_drq_loop:
0432   0185 F7            stosb
0433   0186 7E            dec c
0434   0187 C7 85 01      jnz fdc_footer_drq_loop
0435   018A             
0436   018A 09            ret
0437   018B             
0438   018B             ; fetch is 2 cycles long when 'display_reg_load' is false.
0439   018B             ; 64us amounts to 160 cycles of the 2.5MHz clock
0440   018B             ; call u16 is 14 cycles long
0441   018B             ; 160 - 5 - 14 = 
0442   018B             fdc_wait_64us:
0443   018B 3A 0B         mov cl, 11                       ; 5 cycles
0444   018D             fdc_wait_64_loop:
0445   018D 81            dec cl                           ; 3 cycles
0446   018E C7 8D 01      jnz fdc_wait_64_loop             ; 8 cycles
0447   0191 09            ret
0448   0192             
0449   0192 00          fdc_irq: .db 0
0450   0193 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0450   0197 6D 61 74 74 
0450   019B 69 6E 67 20 
0450   019F 73 74 61 72 
0450   01A3 74 69 6E 67 
0450   01A7 2E 2E 2E 0A 
0450   01AB 00 
0451   01AC 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0451   01B0 6D 61 74 74 
0451   01B4 69 6E 67 20 
0451   01B8 64 6F 6E 65 
0451   01BC 2E 0A 00 
0452   01BF 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0452   01C3 20 73 74 61 
0452   01C7 74 75 73 3A 
0452   01CB 20 00 
0453   01CD             
0454   01CD             ; REBOOT SYSTEM
0455   01CD             syscall_reboot:
0456   01CD FD D7 FF FF   push word $FFFF 
0457   01D1 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0458   01D4 FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0459   01D8 06            sysret
0460   01D9             
0461   01D9             ; ------------------------------------------------------------------------------------------------------------------;
0462   01D9             ; exceptions code block
0463   01D9             ; ------------------------------------------------------------------------------------------------------------------;
0464   01D9             ; privilege exception
0465   01D9             ; ------------------------------------------------------------------------------------------------------------------;
0466   01D9             trap_privilege:
0467   01D9 0A CD 01      jmp syscall_reboot
0468   01DC DA            push d
0469   01DD 3B 0E 09      mov d, s_priviledge
0470   01E0 07 EC 06      call _puts
0471   01E3 E7            pop d
0472   01E4 06            sysret
0473   01E5             
0474   01E5             ; ------------------------------------------------------------------------------------------------------------------;
0475   01E5             ; divide by zero exception
0476   01E5             ; ------------------------------------------------------------------------------------------------------------------;
0477   01E5             trap_div_zero:
0478   01E5 D7            push a
0479   01E6 DA            push d
0480   01E7 E1            pushf
0481   01E8 3B 25 09      mov d, s_divzero
0482   01EB 07 EC 06      call _puts
0483   01EE EE            popf
0484   01EF E7            pop d
0485   01F0 E4            pop a
0486   01F1 06            sysret ; enable interrupts
0487   01F2             
0488   01F2             ; ------------------------------------------------------------------------------------------------------------------;
0489   01F2             ; undefined opcode exception
0490   01F2             ; ------------------------------------------------------------------------------------------------------------------;
0491   01F2             trap_undef_opcode:
0492   01F2 06            sysret
0493   01F3             
0494   01F3             
0495   01F3             
0496   01F3             ;----------------------------------------------------------------------------------------------------;
0497   01F3             ; IO Syscall
0498   01F3             ;----------------------------------------------------------------------------------------------------;
0499   01F3             ; Baud  Divisor
0500   01F3             ; 50    2304
0501   01F3             ; 110   1047
0502   01F3             ; 300    384
0503   01F3             ; 600    192
0504   01F3             ; 1200    96
0505   01F3             ; 9600    12
0506   01F3             ; 19200    6
0507   01F3             ; 38400    3
0508   01F3             syscall_io_jmp:
0509   01F3 26 02         .dw syscall_io_putchar
0510   01F5 33 02         .dw syscall_io_getch
0511   01F7 FD 01         .dw syscall_io_uart_setup
0512   01F9             syscall_io:
0513   01F9 FD 0A F3 01   jmp [syscall_io_jmp + al]
0514   01FD             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0515   01FD             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0516   01FD             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0517   01FD             syscall_io_uart_setup:
0518   01FD 1D E8 08      mov al, [sys_uart0_lcr]
0519   0200 8B 80         or al, $80                ; set DLAB access bit
0520   0202 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0521   0205 1D EB 08      mov al, [sys_uart0_div0]
0522   0208 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0523   020B 1D EC 08      mov al, [sys_uart0_div1]
0524   020E 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0525   0211             
0526   0211 1D E8 08      mov al, [sys_uart0_lcr]
0527   0214 87 7F         and al, $7F               ; clear DLAB access bit 
0528   0216 3D 83 FF      mov [_UART0_LCR], al
0529   0219 1D E9 08      mov al, [sys_uart0_inten]
0530   021C 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0531   021F 1D EA 08      mov al, [sys_uart0_fifoen]
0532   0222 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0533   0225 06            sysret
0534   0226             
0535   0226             ; char in ah
0536   0226             syscall_io_putchar:
0537   0226             syscall_io_putchar_L0:
0538   0226 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0539   0229 87 20         and al, $20
0540   022B C6 26 02      jz syscall_io_putchar_L0    
0541   022E 1A            mov al, ah
0542   022F 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0543   0232 06            sysret
0544   0233             
0545   0233             ; char in ah
0546   0233             ; al = sucess code
0547   0233             syscall_io_getch:
0548   0233 D8            push b
0549   0234 DA            push d
0550   0235 FD 0C         sti
0551   0237             syscall_io_getch_L0:  
0552   0237 14 EF 08      mov a, [fifo_out]
0553   023A 29 ED 08      mov b, [fifo_in]
0554   023D B0            cmp a, b
0555   023E C6 37 02      je syscall_io_getch_L0
0556   0241 3C            mov d, a
0557   0242 77            inc a
0558   0243 AF 83 0F      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0559   0246 C7 4C 02      jne syscall_io_getch_cont
0560   0249 10 83 0B      mov a, fifo  
0561   024C             syscall_io_getch_cont:  
0562   024C 42 EF 08      mov [fifo_out], a             ; update fifo pointer
0563   024F 1E            mov al, [d]                   ; get char
0564   0250 23            mov ah, al
0565   0251 1D E7 08      mov al, [sys_echo_on]
0566   0254 B9 01         cmp al, 1
0567   0256 C7 65 02      jne syscall_io_getch_noecho 
0568   0259             ; here we just echo the char back to the console
0569   0259             syscall_io_getch_echo_L0:
0570   0259 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0571   025C 87 20         and al, $20                 ; isolate Transmitter Empty
0572   025E C6 59 02      jz syscall_io_getch_echo_L0
0573   0261 1A            mov al, ah
0574   0262 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0575   0265             syscall_io_getch_noecho:
0576   0265 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0577   0267 E7            pop d
0578   0268 E5            pop b
0579   0269 06            sysret
0580   026A             
0581   026A             
0582   026A             
0583   026A             
0584   026A             
0585   026A             
0586   026A             ; ---------------------------------------------------------------------
0587   026A             ; kernel reset vector
0588   026A             ; ---------------------------------------------------------------------
0589   026A             kernel_reset_vector:  
0590   026A FD 49 FF F7   mov bp, STACK_BEGIN
0591   026E FD 47 FF F7   mov sp, STACK_BEGIN
0592   0272               
0593   0272 19 80         mov al, %10000000             ; mask out timer interrupt
0594   0274 FD 0F         stomsk                        
0595   0276 FD 0C         sti  
0596   0278             
0597   0278 0C            lodstat
0598   0279 87 DF         and al, %11011111             ; disable display register loading
0599   027B 0D            stostat
0600   027C               
0601   027C             ; reset fifo pointers
0602   027C 10 83 0B      mov a, fifo
0603   027F 3B ED 08      mov d, fifo_in
0604   0282 43            mov [d], a
0605   0283 3B EF 08      mov d, fifo_out
0606   0286 43            mov [d], a  
0607   0287 19 02         mov al, 2
0608   0289 05 00         syscall sys_io                ; enable uart in interrupt mode
0609   028B               
0610   028B 3B F1 08      mov d, s_kernel_started
0611   028E 07 EC 06      call _puts
0612   0291             
0613   0291 3B B4 04      mov d, str0
0614   0294 07 EC 06      call _puts
0615   0297               ; First, select drive 1 and de-select drive 0
0616   0297 3B C0 FF      mov d, $FFC0
0617   029A 2E 0D         mov bl, %00001101     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0618   029C FD 3E         mov [d], bl
0619   029E             
0620   029E             
0621   029E             menu:
0622   029E 3B 27 04      mov d, s_menu
0623   02A1 07 EC 06      call _puts
0624   02A4 07 B9 05      call getch
0625   02A7 76 30         cmp ah, '0'
0626   02A9 C6 D7 02      je step_in
0627   02AC 76 31         cmp ah, '1'
0628   02AE C6 EF 02      je step_out
0629   02B1 76 32         cmp ah, '2'
0630   02B3 C6 E3 02      je restore
0631   02B6 76 33         cmp ah, '3'
0632   02B8 C6 FB 02      je status1
0633   02BB 76 34         cmp ah, '4'
0634   02BD C6 0D 03      je status2
0635   02C0 76 35         cmp ah, '5'
0636   02C2 C6 1F 03      je format
0637   02C5 76 36         cmp ah, '6'
0638   02C7 C6 39 03      je read
0639   02CA 76 37         cmp ah, '7'
0640   02CC C6 4C 03      je read_sec
0641   02CF 76 38         cmp ah, '8'
0642   02D1 C6 8E 03      je fdc_options
0643   02D4 0A 9E 02      jmp menu
0644   02D7             step_in:
0645   02D7 3B C8 FF      mov d, $FFC8    ; wd1770
0646   02DA 19 02         mov al, 2       ; setparam call
0647   02DC 2E 53         mov bl, %01010011     ; step in
0648   02DE FD 3E         mov [d], bl
0649   02E0 0A 9E 02      jmp menu
0650   02E3             restore:
0651   02E3             ; send restore command
0652   02E3 3B C8 FF      mov d, $FFC8    ; wd1770
0653   02E6 19 02         mov al, 2       ; setparam call
0654   02E8 2E 03         mov bl, $03     ; restore command, 30ms rate
0655   02EA FD 3E         mov [d], bl
0656   02EC 0A 9E 02      jmp menu
0657   02EF             step_out:
0658   02EF 3B C8 FF      mov d, $FFC8    ; wd1770
0659   02F2 19 02         mov al, 2       ; setparam call
0660   02F4 2E 73         mov bl, %01110011     ; step out
0661   02F6 FD 3E         mov [d], bl
0662   02F8 0A 9E 02      jmp menu
0663   02FB             status1:
0664   02FB 07 99 06      call printnl
0665   02FE 3B C1 FF      mov d, $FFC1    ; wd1770 status 1
0666   0301 19 04         mov al, 4       ; getparam call
0667   0303 32            mov bl, [d]
0668   0304 07 8C 07      call print_u8x   ; print bl
0669   0307 07 99 06      call printnl
0670   030A 0A 9E 02      jmp menu
0671   030D             status2:
0672   030D 07 99 06      call printnl
0673   0310 3B C8 FF      mov d, $FFC8    ; wd1770 status 
0674   0313 19 04         mov al, 4       ; getparam call
0675   0315 32            mov bl, [d]
0676   0316 07 8C 07      call print_u8x   ; print bl
0677   0319 07 99 06      call printnl
0678   031C 0A 9E 02      jmp menu
0679   031F             format:
0680   031F 07 1D 01      call fdc_format_mem ; fill ram with format
0681   0322 3B 1E 04      mov d, s_track
0682   0325 07 EC 06      call _puts
0683   0328 07 D7 07      call scan_u8x   ; in al
0684   032B 2F            mov bl, al      ; track needs to be in bl
0685   032C 19 00         mov al, 0       ; 0 = format
0686   032E 05 02         syscall sys_fdc_format
0687   0330 3B AC 01      mov d, s_format_done
0688   0333 07 EC 06      call _puts
0689   0336 0A 9E 02      jmp menu
0690   0339             read:
0691   0339 FD 4F 83 11   mov di, transient_area
0692   033D 38 A0 0F      mov c, 4000
0693   0340 19 33         mov al, $33
0694   0342             read_l0:
0695   0342 F7            stosb
0696   0343 7E            dec c
0697   0344 C7 42 03      jnz read_l0
0698   0347 05 03         syscall sys_fdc_read
0699   0349 0A 9E 02      jmp menu
0700   034C             read_sec:
0701   034C FD 4F 83 11   mov di, transient_area
0702   0350 38 80 00      mov c, 128
0703   0353 19 55         mov al, $55
0704   0355             read_l1:
0705   0355 F7            stosb
0706   0356 7E            dec c
0707   0357 C7 55 03      jnz read_l1
0708   035A 3B 72 03      mov d, s1
0709   035D 07 EC 06      call _puts
0710   0360 07 D7 07      call scan_u8x
0711   0363 23            mov ah, al
0712   0364 3B 7B 03      mov d, s2
0713   0367 07 EC 06      call _puts
0714   036A 07 D7 07      call scan_u8x ; in al
0715   036D               
0716   036D 05 04         syscall sys_fdc_read_sec
0717   036F 0A 9E 02      jmp menu
0718   0372 0A 74 72 61 s1:.db "\ntrack: ", 0
0718   0376 63 6B 3A 20 
0718   037A 00 
0719   037B 0A 73 65 63 s2:.db "\nsector: ", 0
0719   037F 74 6F 72 3A 
0719   0383 20 00 
0720   0385 0A 76 61 6C ss3:.db "\nvalue: ", 0
0720   0389 75 65 3A 20 
0720   038D 00 
0721   038E             
0722   038E             fdc_options:
0723   038E               mod d, ss3
kernel_simple.asm line 0723: unrecognized instruction.          (MOD)
0724   038E 07 EC 06      call _puts
0725   0391 07 D7 07      call scan_u8x
0726   0394 3D C0 FF      mov [_FDC_CONFIG], al
0727   0397 0A 9E 02      jmp menu
0728   039A             
0729   039A             ; b : len
0730   039A             cmd_hexd:
0731   039A 10 83 11      mov a, transient_area
0732   039D 42 1A 04      mov [start], a
0733   03A0 11            mov a, b
0734   03A1 42 1C 04      mov [length], a
0735   03A4             
0736   03A4 14 1A 04    	mov a, [start]
0737   03A7 3C            mov d, a        ; dump pointer in d
0738   03A8 38 00 00      mov c, 0
0739   03AB             dump_loop:
0740   03AB 84            mov al, cl
0741   03AC 87 0F         and al, $0F
0742   03AE C6 FD 03      jz print_base
0743   03B1             back:
0744   03B1 1E            mov al, [d]        ; read byte
0745   03B2 2F            mov bl, al
0746   03B3 07 8C 07      call print_u8x
0747   03B6 10 00 20      mov a, $2000
0748   03B9 05 00         syscall sys_io      ; space
0749   03BB 84            mov al, cl
0750   03BC 87 0F         and al, $0F
0751   03BE B9 0F         cmp al, $0F
0752   03C0 C6 D7 03      je print_ascii
0753   03C3             back1:
0754   03C3 79            inc d
0755   03C4 78            inc c
0756   03C5 14 1C 04      mov a, [length]
0757   03C8 B1            cmp a, c
0758   03C9 C7 AB 03      jne dump_loop
0759   03CC               
0760   03CC 10 00 0A      mov a, $0A00
0761   03CF 05 00         syscall sys_io
0762   03D1 10 00 0D      mov a, $0D00
0763   03D4 05 00         syscall sys_io
0764   03D6               ;call printnl
0765   03D6             
0766   03D6 09            ret
0767   03D7             print_ascii:
0768   03D7 63 10 00      sub d, 16
0769   03DA 26 10 00      mov b, 16
0770   03DD             print_ascii_L:
0771   03DD 79            inc d
0772   03DE 1E            mov al, [d]        ; read byte
0773   03DF B9 20         cmp al, $20
0774   03E1 C8 E9 03      jlu dot
0775   03E4 B9 7E         cmp al, $7E
0776   03E6 D0 F1 03      jleu ascii
0777   03E9             dot:
0778   03E9 10 00 2E      mov a, $2E00
0779   03EC 05 00         syscall sys_io
0780   03EE 0A F6 03      jmp ascii_continue
0781   03F1             ascii:
0782   03F1 23            mov ah, al
0783   03F2 19 00         mov al, 0
0784   03F4 05 00         syscall sys_io
0785   03F6             ascii_continue:
0786   03F6 FD A9 DD 03   loopb print_ascii_L
0787   03FA 0A C3 03      jmp back1
0788   03FD             print_base:
0789   03FD 10 00 0A      mov a, $0A00
0790   0400 05 00         syscall sys_io
0791   0402 10 00 0D      mov a, $0D00
0792   0405 05 00         syscall sys_io
0793   0407 2D            mov b, d
0794   0408 61 83 11      sub b, transient_area
0795   040B 07 48 07      call print_u16x        ; display row
0796   040E 55 83 11      add b, transient_area
0797   0411 10 00 20      mov a, $2000
0798   0414 05 00         syscall sys_io
0799   0416 0A B1 03      jmp back
0800   0419             
0801   0419 09            ret
0802   041A             
0803   041A 00 00       start:  .dw 0
0804   041C 00 04       length: .dw 1024
0805   041E             
0806   041E             
0807   041E 0A 74 72 61 s_track: .db "\ntrack: ", 0
0807   0422 63 6B 3A 20 
0807   0426 00 
0808   0427             
0809   0427 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0809   042B 73 74 65 70 
0809   042F 20 69 6E 0A 
0810   0433 31 2E 20 73         .db "1. step out\n", 
0810   0437 74 65 70 20 
0810   043B 6F 75 74 0A 
0811   043F 32 2E 20 72         .db "2. restore\n", 
0811   0443 65 73 74 6F 
0811   0447 72 65 0A 
0812   044A 33 2E 20 72         .db "3. read status 1\n", 
0812   044E 65 61 64 20 
0812   0452 73 74 61 74 
0812   0456 75 73 20 31 
0812   045A 0A 
0813   045B 34 2E 20 72         .db "4. read status 2\n", 
0813   045F 65 61 64 20 
0813   0463 73 74 61 74 
0813   0467 75 73 20 32 
0813   046B 0A 
0814   046C 35 2E 20 66         .db "5. format track\n", 
0814   0470 6F 72 6D 61 
0814   0474 74 20 74 72 
0814   0478 61 63 6B 0A 
0815   047C 36 2E 20 72         .db "6. read track\n", 
0815   0480 65 61 64 20 
0815   0484 74 72 61 63 
0815   0488 6B 0A 
0816   048A 37 2E 20 72         .db "7. read sector\n", 
0816   048E 65 61 64 20 
0816   0492 73 65 63 74 
0816   0496 6F 72 0A 
0817   0499 38 2E 20 63         .db "8. config\n", 
0817   049D 6F 6E 66 69 
0817   04A1 67 0A 
0818   04A3 0A 73 65 6C         .db "\nselect option: ", 0
0818   04A7 65 63 74 20 
0818   04AB 6F 70 74 69 
0818   04AF 6F 6E 3A 20 
0818   04B3 00 
0819   04B4             
0820   04B4 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0820   04B8 65 63 74 69 
0820   04BC 6E 67 20 64 
0820   04C0 72 69 76 65 
0820   04C4 20 31 2E 2E 
0820   04C8 2E 0A 00 
0821   04CB 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0821   04CF 74 69 6E 67 
0821   04D3 2E 2E 2E 0A 
0821   04D7 00 
0822   04D8             
0823   04D8             
0824   04D8             
0825   04D8             ; FILE INCLUDES
0826   04D8             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  04D8             BIOS_RESET_VECTOR .EQU  $01c0
0002+  04D8             IDE_buffer       .EQU  $8204
0003+  04D8             boot_origin      .EQU  $8004
0004+  04D8             bios_uart        .EQU  $0002
0005+  04D8             bios_ide         .EQU  $0003
0827   04D8             .include "lib/stdio.asm"
0001+  04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04D8             ; stdio.s
0003+  04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04D8             .include "lib/string.asm"
0001++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04D8             ; string.s
0003++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04D8             
0005++ 04D8             
0006++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04D8             ; _strrev
0008++ 04D8             ; reverse a string
0009++ 04D8             ; D = string address
0010++ 04D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04D8             ; 01234
0012++ 04D8             _strrev:
0013++ 04D8 4B          	pusha
0014++ 04D9 07 1F 05    	call _strlen	; length in C
0015++ 04DC 12          	mov a, c
0016++ 04DD AF 01 00    	cmp a, 1
0017++ 04E0 D0 FA 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04E3 7D          	dec a
0019++ 04E4 FD 4E       	mov si, d	; beginning of string
0020++ 04E6 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04E8 59          	add d, a	; end of string
0022++ 04E9 12          	mov a, c
0023++ 04EA FD 9B       	shr a		; divide by 2
0024++ 04EC 39          	mov c, a	; C now counts the steps
0025++ 04ED             _strrev_L0:
0026++ 04ED 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04EE F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04EF 3E          	mov [d], al	; store left char into right side
0029++ 04F0 1B          	mov al, bl
0030++ 04F1 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04F2 7E          	dec c
0032++ 04F3 7F          	dec d
0033++ 04F4 C2 00 00    	cmp c, 0
0034++ 04F7 C7 ED 04    	jne _strrev_L0
0035++ 04FA             _strrev_end:
0036++ 04FA 4C          	popa
0037++ 04FB 09          	ret
0038++ 04FC             	
0039++ 04FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04FC             ; _strchr
0041++ 04FC             ; search string in D for char in AL
0042++ 04FC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04FC             _strchr:
0044++ 04FC             _strchr_L0:
0045++ 04FC 32          	mov bl, [d]
0046++ 04FD C1 00       	cmp bl, 0
0047++ 04FF C6 0A 05    	je _strchr_end
0048++ 0502 BA          	cmp al, bl
0049++ 0503 C6 0A 05    	je _strchr_end
0050++ 0506 79          	inc d
0051++ 0507 0A FC 04    	jmp _strchr_L0
0052++ 050A             _strchr_end:
0053++ 050A 1B          	mov al, bl
0054++ 050B 09          	ret
0055++ 050C             
0056++ 050C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 050C             ; _strstr
0058++ 050C             ; find sub-string
0059++ 050C             ; str1 in SI
0060++ 050C             ; str2 in DI
0061++ 050C             ; SI points to end of source string
0062++ 050C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 050C             _strstr:
0064++ 050C DB          	push al
0065++ 050D DA          	push d
0066++ 050E E3          	push di
0067++ 050F             _strstr_loop:
0068++ 050F F3          	cmpsb					; compare a byte of the strings
0069++ 0510 C7 1B 05    	jne _strstr_ret
0070++ 0513 FC 00 00    	lea d, [di + 0]
0071++ 0516 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0518 C7 0F 05    	jne _strstr_loop				; equal chars but not at end
0073++ 051B             _strstr_ret:
0074++ 051B F0          	pop di
0075++ 051C E7          	pop d
0076++ 051D E8          	pop al
0077++ 051E 09          	ret
0078++ 051F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 051F             ; length of null terminated string
0080++ 051F             ; result in C
0081++ 051F             ; pointer in D
0082++ 051F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 051F             _strlen:
0084++ 051F DA          	push d
0085++ 0520 38 00 00    	mov c, 0
0086++ 0523             _strlen_L1:
0087++ 0523 BD 00       	cmp byte [d], 0
0088++ 0525 C6 2D 05    	je _strlen_ret
0089++ 0528 79          	inc d
0090++ 0529 78          	inc c
0091++ 052A 0A 23 05    	jmp _strlen_L1
0092++ 052D             _strlen_ret:
0093++ 052D E7          	pop d
0094++ 052E 09          	ret
0095++ 052F             
0096++ 052F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 052F             ; STRCMP
0098++ 052F             ; compare two strings
0099++ 052F             ; str1 in SI
0100++ 052F             ; str2 in DI
0101++ 052F             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 052F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 052F             _strcmp:
0104++ 052F DB          	push al
0105++ 0530 DA          	push d
0106++ 0531 E3          	push di
0107++ 0532 E2          	push si
0108++ 0533             _strcmp_loop:
0109++ 0533 F3          	cmpsb					; compare a byte of the strings
0110++ 0534 C7 3F 05    	jne _strcmp_ret
0111++ 0537 FB FF FF    	lea d, [si +- 1]
0112++ 053A BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 053C C7 33 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 053F             _strcmp_ret:
0115++ 053F EF          	pop si
0116++ 0540 F0          	pop di
0117++ 0541 E7          	pop d
0118++ 0542 E8          	pop al
0119++ 0543 09          	ret
0120++ 0544             
0121++ 0544             
0122++ 0544             ; STRCPY
0123++ 0544             ; copy null terminated string from SI to DI
0124++ 0544             ; source in SI
0125++ 0544             ; destination in DI
0126++ 0544             _strcpy:
0127++ 0544 E2          	push si
0128++ 0545 E3          	push di
0129++ 0546 DB          	push al
0130++ 0547             _strcpy_L1:
0131++ 0547 F6          	lodsb
0132++ 0548 F7          	stosb
0133++ 0549 B9 00       	cmp al, 0
0134++ 054B C7 47 05    	jne _strcpy_L1
0135++ 054E             _strcpy_end:
0136++ 054E E8          	pop al
0137++ 054F F0          	pop di
0138++ 0550 EF          	pop si
0139++ 0551 09          	ret
0140++ 0552             
0141++ 0552             ; STRCAT
0142++ 0552             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0552             ; source in SI
0144++ 0552             ; destination in DI
0145++ 0552             _strcat:
0146++ 0552 E2          	push si
0147++ 0553 E3          	push di
0148++ 0554 D7          	push a
0149++ 0555 DA          	push d
0150++ 0556 50          	mov a, di
0151++ 0557 3C          	mov d, a
0152++ 0558             _strcat_goto_end_L1:
0153++ 0558 BD 00       	cmp byte[d], 0
0154++ 055A C6 61 05    	je _strcat_start
0155++ 055D 79          	inc d
0156++ 055E 0A 58 05    	jmp _strcat_goto_end_L1
0157++ 0561             _strcat_start:
0158++ 0561 FD 50       	mov di, d
0159++ 0563             _strcat_L1:
0160++ 0563 F6          	lodsb
0161++ 0564 F7          	stosb
0162++ 0565 B9 00       	cmp al, 0
0163++ 0567 C7 63 05    	jne _strcat_L1
0164++ 056A             _strcat_end:
0165++ 056A E7          	pop d
0166++ 056B E4          	pop a
0167++ 056C F0          	pop di
0168++ 056D EF          	pop si
0169++ 056E 09          	ret
0170++ 056F             
0171++ 056F             
0005+  056F             
0006+  056F             
0007+  056F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  056F             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  056F             ; ASCII in BL
0010+  056F             ; result in AL
0011+  056F             ; ascii for F = 0100 0110
0012+  056F             ; ascii for 9 = 0011 1001
0013+  056F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  056F             hex_ascii_encode:
0015+  056F 1B            mov al, bl
0016+  0570 93 40         test al, $40        ; test if letter or number
0017+  0572 C7 78 05      jnz hex_letter
0018+  0575 87 0F         and al, $0F        ; get number
0019+  0577 09            ret
0020+  0578             hex_letter:
0021+  0578 87 0F         and al, $0F        ; get letter
0022+  057A 6A 09         add al, 9
0023+  057C 09            ret
0024+  057D             
0025+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  057D             ; ATOI
0027+  057D             ; 2 letter hex string in B
0028+  057D             ; 8bit integer returned in AL
0029+  057D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  057D             _atoi:
0031+  057D D8            push b
0032+  057E 07 6F 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0581 30            mov bl, bh
0034+  0582 DB            push al          ; save a
0035+  0583 07 6F 05      call hex_ascii_encode
0036+  0586 EA            pop bl  
0037+  0587 FD 9E 04      shl al, 4
0038+  058A 8C            or al, bl
0039+  058B E5            pop b
0040+  058C 09            ret  
0041+  058D             
0042+  058D             
0043+  058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  058D             ; scanf
0045+  058D             ; no need for explanations!
0046+  058D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  058D             scanf:
0048+  058D 09            ret
0049+  058E             
0050+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  058E             ; ITOA
0052+  058E             ; 8bit value in BL
0053+  058E             ; 2 byte ASCII result in A
0054+  058E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  058E             _itoa:
0056+  058E DA            push d
0057+  058F D8            push b
0058+  0590 A7 00         mov bh, 0
0059+  0592 FD A4 04      shr bl, 4  
0060+  0595 74            mov d, b
0061+  0596 1F 28 08      mov al, [d + s_hex_digits]
0062+  0599 23            mov ah, al
0063+  059A               
0064+  059A E5            pop b
0065+  059B D8            push b
0066+  059C A7 00         mov bh, 0
0067+  059E FD 87 0F      and bl, $0F
0068+  05A1 74            mov d, b
0069+  05A2 1F 28 08      mov al, [d + s_hex_digits]
0070+  05A5 E5            pop b
0071+  05A6 E7            pop d
0072+  05A7 09            ret
0073+  05A8             
0074+  05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  05A8             ; HEX STRING TO BINARY
0076+  05A8             ; di = destination address
0077+  05A8             ; si = source
0078+  05A8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  05A8             _hex_to_int:
0080+  05A8             _hex_to_int_L1:
0081+  05A8 F6            lodsb          ; load from [SI] to AL
0082+  05A9 B9 00         cmp al, 0        ; check if ASCII 0
0083+  05AB C6 B8 05      jz _hex_to_int_ret
0084+  05AE 36            mov bh, al
0085+  05AF F6            lodsb
0086+  05B0 2F            mov bl, al
0087+  05B1 07 7D 05      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  05B4 F7            stosb          ; store AL to [DI]
0089+  05B5 0A A8 05      jmp _hex_to_int_L1
0090+  05B8             _hex_to_int_ret:
0091+  05B8 09            ret    
0092+  05B9             
0093+  05B9             
0094+  05B9             
0095+  05B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  05B9             ; GETCHAR
0097+  05B9             ; char in ah
0098+  05B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  05B9             getch:
0100+  05B9 DB            push al
0101+  05BA             getch_retry:
0102+  05BA 19 01         mov al, 1
0103+  05BC 05 00         syscall sys_io      ; receive in AH
0104+  05BE E8            pop al
0105+  05BF 09            ret
0106+  05C0             
0107+  05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  05C0             ; PUTCHAR
0109+  05C0             ; char in ah
0110+  05C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05C0             _putchar:
0112+  05C0 DB            push al
0113+  05C1 19 00         mov al, 0
0114+  05C3 05 00         syscall sys_io      ; char in AH
0115+  05C5 E8            pop al
0116+  05C6 09            ret
0117+  05C7             
0118+  05C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  05C7             ;; INPUT A STRING
0120+  05C7             ;; terminates with null
0121+  05C7             ;; pointer in D
0122+  05C7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  05C7             _gets:
0124+  05C7 D7            push a
0125+  05C8 DA            push d
0126+  05C9             _gets_loop:
0127+  05C9 19 01         mov al, 1
0128+  05CB 05 00         syscall sys_io      ; receive in AH
0129+  05CD 76 1B         cmp ah, 27
0130+  05CF C6 F0 05      je _gets_ansi_esc
0131+  05D2 76 0A         cmp ah, $0A        ; LF
0132+  05D4 C6 4C 06      je _gets_end
0133+  05D7 76 0D         cmp ah, $0D        ; CR
0134+  05D9 C6 4C 06      je _gets_end
0135+  05DC 76 5C         cmp ah, $5C        ; '\\'
0136+  05DE C6 12 06      je _gets_escape
0137+  05E1 76 08         cmp ah, $08      ; check for backspace
0138+  05E3 C6 EC 05      je _gets_backspace
0139+  05E6 1A            mov al, ah
0140+  05E7 3E            mov [d], al
0141+  05E8 79            inc d
0142+  05E9 0A C9 05      jmp _gets_loop
0143+  05EC             _gets_backspace:
0144+  05EC 7F            dec d
0145+  05ED 0A C9 05      jmp _gets_loop
0146+  05F0             _gets_ansi_esc:
0147+  05F0 19 01         mov al, 1
0148+  05F2 05 00         syscall sys_io        ; receive in AH without echo
0149+  05F4 76 5B         cmp ah, '['
0150+  05F6 C7 C9 05      jne _gets_loop
0151+  05F9 19 01         mov al, 1
0152+  05FB 05 00         syscall sys_io          ; receive in AH without echo
0153+  05FD 76 44         cmp ah, 'D'
0154+  05FF C6 0A 06      je _gets_left_arrow
0155+  0602 76 43         cmp ah, 'C'
0156+  0604 C6 0E 06      je _gets_right_arrow
0157+  0607 0A C9 05      jmp _gets_loop
0158+  060A             _gets_left_arrow:
0159+  060A 7F            dec d
0160+  060B 0A C9 05      jmp _gets_loop
0161+  060E             _gets_right_arrow:
0162+  060E 79            inc d
0163+  060F 0A C9 05      jmp _gets_loop
0164+  0612             _gets_escape:
0165+  0612 19 01         mov al, 1
0166+  0614 05 00         syscall sys_io      ; receive in AH
0167+  0616 76 6E         cmp ah, 'n'
0168+  0618 C6 37 06      je _gets_LF
0169+  061B 76 72         cmp ah, 'r'
0170+  061D C6 3E 06      je _gets_CR
0171+  0620 76 30         cmp ah, '0'
0172+  0622 C6 45 06      je _gets_NULL
0173+  0625 76 5C         cmp ah, $5C  ; '\'
0174+  0627 C6 30 06      je _gets_slash
0175+  062A 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  062B 3E            mov [d], al
0177+  062C 79            inc d
0178+  062D 0A C9 05      jmp _gets_loop
0179+  0630             _gets_slash:
0180+  0630 19 5C         mov al, $5C
0181+  0632 3E            mov [d], al
0182+  0633 79            inc d
0183+  0634 0A C9 05      jmp _gets_loop
0184+  0637             _gets_LF:
0185+  0637 19 0A         mov al, $0A
0186+  0639 3E            mov [d], al
0187+  063A 79            inc d
0188+  063B 0A C9 05      jmp _gets_loop
0189+  063E             _gets_CR:
0190+  063E 19 0D         mov al, $0D
0191+  0640 3E            mov [d], al
0192+  0641 79            inc d
0193+  0642 0A C9 05      jmp _gets_loop
0194+  0645             _gets_NULL:
0195+  0645 19 00         mov al, $00
0196+  0647 3E            mov [d], al
0197+  0648 79            inc d
0198+  0649 0A C9 05      jmp _gets_loop
0199+  064C             _gets_end:
0200+  064C 19 00         mov al, 0
0201+  064E 3E            mov [d], al        ; terminate string
0202+  064F E7            pop d
0203+  0650 E4            pop a
0204+  0651 09            ret
0205+  0652             
0206+  0652             
0207+  0652             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0652             ;; INPUT TEXT
0209+  0652             ;; terminated with CTRL+D
0210+  0652             ;; pointer in D
0211+  0652             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0652             _gettxt:
0213+  0652 D7            push a
0214+  0653 DA            push d
0215+  0654             _gettxt_loop:
0216+  0654 19 01         mov al, 1
0217+  0656 05 00         syscall sys_io      ; receive in AH
0218+  0658 76 04         cmp ah, 4      ; EOT
0219+  065A C6 93 06      je _gettxt_end
0220+  065D 76 08         cmp ah, $08      ; check for backspace
0221+  065F C6 8F 06      je _gettxt_backspace
0222+  0662 76 5C         cmp ah, $5C        ; '\'
0223+  0664 C6 6D 06      je _gettxt_escape
0224+  0667 1A            mov al, ah
0225+  0668 3E            mov [d], al
0226+  0669 79            inc d
0227+  066A 0A 54 06      jmp _gettxt_loop
0228+  066D             _gettxt_escape:
0229+  066D 19 01         mov al, 1
0230+  066F 05 00         syscall sys_io      ; receive in AH
0231+  0671 76 6E         cmp ah, 'n'
0232+  0673 C6 81 06      je _gettxt_LF
0233+  0676 76 72         cmp ah, 'r'
0234+  0678 C6 88 06      je _gettxt_CR
0235+  067B 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  067C 3E            mov [d], al
0237+  067D 79            inc d
0238+  067E 0A 54 06      jmp _gettxt_loop
0239+  0681             _gettxt_LF:
0240+  0681 19 0A         mov al, $0A
0241+  0683 3E            mov [d], al
0242+  0684 79            inc d
0243+  0685 0A 54 06      jmp _gettxt_loop
0244+  0688             _gettxt_CR:
0245+  0688 19 0D         mov al, $0D
0246+  068A 3E            mov [d], al
0247+  068B 79            inc d
0248+  068C 0A 54 06      jmp _gettxt_loop
0249+  068F             _gettxt_backspace:
0250+  068F 7F            dec d
0251+  0690 0A 54 06      jmp _gettxt_loop
0252+  0693             _gettxt_end:
0253+  0693 19 00         mov al, 0
0254+  0695 3E            mov [d], al        ; terminate string
0255+  0696 E7            pop d
0256+  0697 E4            pop a
0257+  0698 09            ret
0258+  0699             
0259+  0699             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0699             ; PRINT NEW LINE
0261+  0699             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0699             printnl:
0263+  0699 D7            push a
0264+  069A 10 00 0A      mov a, $0A00
0265+  069D 05 00         syscall sys_io
0266+  069F 10 00 0D      mov a, $0D00
0267+  06A2 05 00         syscall sys_io
0268+  06A4 E4            pop a
0269+  06A5 09            ret
0270+  06A6             
0271+  06A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  06A6             ; _strtoint
0273+  06A6             ; 4 digit hex string number in d
0274+  06A6             ; integer returned in A
0275+  06A6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  06A6             _strtointx:
0277+  06A6 D8            push b
0278+  06A7 32            mov bl, [d]
0279+  06A8 37            mov bh, bl
0280+  06A9 33 01 00      mov bl, [d + 1]
0281+  06AC 07 7D 05      call _atoi        ; convert to int in AL
0282+  06AF 23            mov ah, al        ; move to AH
0283+  06B0 33 02 00      mov bl, [d + 2]
0284+  06B3 37            mov bh, bl
0285+  06B4 33 03 00      mov bl, [d + 3]
0286+  06B7 07 7D 05      call _atoi        ; convert to int in AL
0287+  06BA E5            pop b
0288+  06BB 09            ret
0289+  06BC             
0290+  06BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  06BC             ; _strtoint
0292+  06BC             ; 5 digit base10 string number in d
0293+  06BC             ; integer returned in A
0294+  06BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  06BC             _strtoint:
0296+  06BC E2            push si
0297+  06BD D8            push b
0298+  06BE D9            push c
0299+  06BF DA            push d
0300+  06C0 07 1F 05      call _strlen      ; get string length in C
0301+  06C3 7E            dec c
0302+  06C4 FD 4E         mov si, d
0303+  06C6 12            mov a, c
0304+  06C7 FD 99         shl a
0305+  06C9 3B 40 08      mov d, table_power
0306+  06CC 59            add d, a
0307+  06CD 38 00 00      mov c, 0
0308+  06D0             _strtoint_L0:
0309+  06D0 F6            lodsb      ; load ASCII to al
0310+  06D1 B9 00         cmp al, 0
0311+  06D3 C6 E6 06      je _strtoint_end
0312+  06D6 6F 30         sub al, $30    ; make into integer
0313+  06D8 22 00         mov ah, 0
0314+  06DA 2A            mov b, [d]
0315+  06DB AC            mul a, b      ; result in B since it fits in 16bits
0316+  06DC 11            mov a, b
0317+  06DD 28            mov b, c
0318+  06DE 54            add a, b
0319+  06DF 39            mov c, a
0320+  06E0 63 02 00      sub d, 2
0321+  06E3 0A D0 06      jmp _strtoint_L0
0322+  06E6             _strtoint_end:
0323+  06E6 12            mov a, c
0324+  06E7 E7            pop d
0325+  06E8 E6            pop c
0326+  06E9 E5            pop b
0327+  06EA EF            pop si
0328+  06EB 09            ret
0329+  06EC             
0330+  06EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  06EC             ; PRINT NULL TERMINATED STRING
0332+  06EC             ; pointer in D
0333+  06EC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  06EC             _puts:
0335+  06EC D7            push a
0336+  06ED DA            push d
0337+  06EE             _puts_L1:
0338+  06EE 1E            mov al, [d]
0339+  06EF B9 00         cmp al, 0
0340+  06F1 C6 FD 06      jz _puts_END
0341+  06F4 23            mov ah, al
0342+  06F5 19 00         mov al, 0
0343+  06F7 05 00         syscall sys_io
0344+  06F9 79            inc d
0345+  06FA 0A EE 06      jmp _puts_L1
0346+  06FD             _puts_END:
0347+  06FD E7            pop d
0348+  06FE E4            pop a
0349+  06FF 09            ret
0350+  0700             
0351+  0700             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0700             ; PRINT N SIZE STRING
0353+  0700             ; pointer in D
0354+  0700             ; size in C
0355+  0700             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0700             _putsn:
0357+  0700 DB            push al
0358+  0701 DA            push d
0359+  0702 D9            push c
0360+  0703             _putsn_L0:
0361+  0703 1E            mov al, [d]
0362+  0704 23            mov ah, al
0363+  0705 19 00         mov al, 0
0364+  0707 05 00         syscall sys_io
0365+  0709 79            inc d
0366+  070A 7E            dec c  
0367+  070B C2 00 00      cmp c, 0
0368+  070E C7 03 07      jne _putsn_L0
0369+  0711             _putsn_end:
0370+  0711 E6            pop c
0371+  0712 E7            pop d
0372+  0713 E8            pop al
0373+  0714 09            ret
0374+  0715             
0375+  0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0715             ; print 16bit decimal number
0377+  0715             ; input number in A
0378+  0715             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0715             print_u16d:
0380+  0715 D7            push a
0381+  0716 D8            push b
0382+  0717 FD D8         push g
0383+  0719 26 10 27      mov b, 10000
0384+  071C AE            div a, b      ; get 10000's coeff.
0385+  071D 07 41 07      call print_number
0386+  0720 11            mov a, b
0387+  0721 26 E8 03      mov b, 1000
0388+  0724 AE            div a, b      ; get 1000's coeff.
0389+  0725 07 41 07      call print_number
0390+  0728 11            mov a, b
0391+  0729 26 64 00      mov b, 100
0392+  072C AE            div a, b
0393+  072D 07 41 07      call print_number
0394+  0730 11            mov a, b
0395+  0731 26 0A 00      mov b, 10
0396+  0734 AE            div a, b
0397+  0735 07 41 07      call print_number
0398+  0738 1B            mov al, bl      ; 1's coeff in bl
0399+  0739 07 41 07      call print_number
0400+  073C FD F1         pop g
0401+  073E E5            pop b
0402+  073F E4            pop a
0403+  0740 09            ret
0404+  0741             
0405+  0741             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0741             ; print AL
0407+  0741             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0741             print_number:
0409+  0741 6A 30         add al, $30
0410+  0743 23            mov ah, al
0411+  0744 07 C0 05      call _putchar
0412+  0747 09            ret
0413+  0748             
0414+  0748             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0748             ; PRINT 16BIT HEX INTEGER
0416+  0748             ; integer value in reg B
0417+  0748             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0748             print_u16x:
0419+  0748 D7            push a
0420+  0749 D8            push b
0421+  074A DD            push bl
0422+  074B 30            mov bl, bh
0423+  074C 07 8E 05      call _itoa        ; convert bh to char in A
0424+  074F 2F            mov bl, al        ; save al
0425+  0750 19 00         mov al, 0
0426+  0752 05 00         syscall sys_io        ; display AH
0427+  0754 24            mov ah, bl        ; retrieve al
0428+  0755 19 00         mov al, 0
0429+  0757 05 00         syscall sys_io        ; display AL
0430+  0759             
0431+  0759 EA            pop bl
0432+  075A 07 8E 05      call _itoa        ; convert bh to char in A
0433+  075D 2F            mov bl, al        ; save al
0434+  075E 19 00         mov al, 0
0435+  0760 05 00         syscall sys_io        ; display AH
0436+  0762 24            mov ah, bl        ; retrieve al
0437+  0763 19 00         mov al, 0
0438+  0765 05 00         syscall sys_io        ; display AL
0439+  0767             
0440+  0767 E5            pop b
0441+  0768 E4            pop a
0442+  0769 09            ret
0443+  076A             
0444+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  076A             ; INPUT 16BIT HEX INTEGER
0446+  076A             ; read 16bit integer into A
0447+  076A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  076A             scan_u16x:
0449+  076A F8 10 00      enter 16
0450+  076D D8            push b
0451+  076E DA            push d
0452+  076F             
0453+  076F FA F1 FF      lea d, [bp + -15]
0454+  0772 07 C7 05      call _gets        ; get number
0455+  0775             
0456+  0775 32            mov bl, [d]
0457+  0776 37            mov bh, bl
0458+  0777 33 01 00      mov bl, [d + 1]
0459+  077A 07 7D 05      call _atoi        ; convert to int in AL
0460+  077D 23            mov ah, al        ; move to AH
0461+  077E             
0462+  077E 33 02 00      mov bl, [d + 2]
0463+  0781 37            mov bh, bl
0464+  0782 33 03 00      mov bl, [d + 3]
0465+  0785 07 7D 05      call _atoi        ; convert to int in AL
0466+  0788             
0467+  0788 E7            pop d
0468+  0789 E5            pop b
0469+  078A F9            leave
0470+  078B 09            ret
0471+  078C             
0472+  078C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  078C             ; PRINT 8bit HEX INTEGER
0474+  078C             ; integer value in reg bl
0475+  078C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  078C             print_u8x:
0477+  078C D7            push a
0478+  078D DD            push bl
0479+  078E             
0480+  078E 07 8E 05      call _itoa        ; convert bl to char in A
0481+  0791 2F            mov bl, al        ; save al
0482+  0792 19 00         mov al, 0
0483+  0794 05 00         syscall sys_io        ; display AH
0484+  0796 24            mov ah, bl        ; retrieve al
0485+  0797 19 00         mov al, 0
0486+  0799 05 00         syscall sys_io        ; display AL
0487+  079B             
0488+  079B EA            pop bl
0489+  079C E4            pop a
0490+  079D 09            ret
0491+  079E             
0492+  079E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  079E             ; print 8bit decimal unsigned number
0494+  079E             ; input number in AL
0495+  079E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  079E             print_u8d:
0497+  079E D7            push a
0498+  079F D8            push b
0499+  07A0 FD D8         push g
0500+  07A2 22 00         mov ah, 0
0501+  07A4 26 64 00      mov b, 100
0502+  07A7 AE            div a, b
0503+  07A8 D8            push b      ; save remainder
0504+  07A9 B9 00         cmp al, 0
0505+  07AB C6 B5 07      je skip100
0506+  07AE 6A 30         add al, $30
0507+  07B0 23            mov ah, al
0508+  07B1 19 00         mov al, 0
0509+  07B3 05 00         syscall sys_io  ; print coeff
0510+  07B5             skip100:
0511+  07B5 E4            pop a
0512+  07B6 22 00         mov ah, 0
0513+  07B8 26 0A 00      mov b, 10
0514+  07BB AE            div a, b
0515+  07BC D8            push b      ; save remainder
0516+  07BD B9 00         cmp al, 0
0517+  07BF C6 C9 07      je skip10
0518+  07C2 6A 30         add al, $30
0519+  07C4 23            mov ah, al
0520+  07C5 19 00         mov al, 0
0521+  07C7 05 00         syscall sys_io  ; print coeff
0522+  07C9             skip10:
0523+  07C9 E4            pop a
0524+  07CA 1B            mov al, bl
0525+  07CB 6A 30         add al, $30
0526+  07CD 23            mov ah, al
0527+  07CE 19 00         mov al, 0
0528+  07D0 05 00         syscall sys_io  ; print coeff
0529+  07D2 FD F1         pop g
0530+  07D4 E5            pop b
0531+  07D5 E4            pop a
0532+  07D6 09            ret
0533+  07D7             
0534+  07D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  07D7             ; INPUT 8BIT HEX INTEGER
0536+  07D7             ; read 8bit integer into AL
0537+  07D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  07D7             scan_u8x:
0539+  07D7 F8 04 00      enter 4
0540+  07DA D8            push b
0541+  07DB DA            push d
0542+  07DC             
0543+  07DC FA FD FF      lea d, [bp + -3]
0544+  07DF 07 C7 05      call _gets        ; get number
0545+  07E2             
0546+  07E2 32            mov bl, [d]
0547+  07E3 37            mov bh, bl
0548+  07E4 33 01 00      mov bl, [d + 1]
0549+  07E7 07 7D 05      call _atoi        ; convert to int in AL
0550+  07EA             
0551+  07EA E7            pop d
0552+  07EB E5            pop b
0553+  07EC F9            leave
0554+  07ED 09            ret
0555+  07EE             
0556+  07EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  07EE             ; input decimal number
0558+  07EE             ; result in A
0559+  07EE             ; 655'\0'
0560+  07EE             ; low--------high
0561+  07EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  07EE             scan_u16d:
0563+  07EE F8 08 00      enter 8
0564+  07F1 E2            push si
0565+  07F2 D8            push b
0566+  07F3 D9            push c
0567+  07F4 DA            push d
0568+  07F5 FA F9 FF      lea d, [bp +- 7]
0569+  07F8 07 C7 05      call _gets
0570+  07FB 07 1F 05      call _strlen      ; get string length in C
0571+  07FE 7E            dec c
0572+  07FF FD 4E         mov si, d
0573+  0801 12            mov a, c
0574+  0802 FD 99         shl a
0575+  0804 3B 40 08      mov d, table_power
0576+  0807 59            add d, a
0577+  0808 38 00 00      mov c, 0
0578+  080B             mul_loop:
0579+  080B F6            lodsb      ; load ASCII to al
0580+  080C B9 00         cmp al, 0
0581+  080E C6 21 08      je mul_exit
0582+  0811 6F 30         sub al, $30    ; make into integer
0583+  0813 22 00         mov ah, 0
0584+  0815 2A            mov b, [d]
0585+  0816 AC            mul a, b      ; result in B since it fits in 16bits
0586+  0817 11            mov a, b
0587+  0818 28            mov b, c
0588+  0819 54            add a, b
0589+  081A 39            mov c, a
0590+  081B 63 02 00      sub d, 2
0591+  081E 0A 0B 08      jmp mul_loop
0592+  0821             mul_exit:
0593+  0821 12            mov a, c
0594+  0822 E7            pop d
0595+  0823 E6            pop c
0596+  0824 E5            pop b
0597+  0825 EF            pop si
0598+  0826 F9            leave
0599+  0827 09            ret
0600+  0828             
0601+  0828             
0602+  0828 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  082C 34 35 36 37 
0602+  0830 38 39 41 42 
0602+  0834 43 44 45 46 
0603+  0838 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  083C 1B 5B 48 00 
0604+  0840             
0605+  0840             table_power:
0606+  0840 01 00         .dw 1
0607+  0842 0A 00         .dw 10
0608+  0844 64 00         .dw 100
0609+  0846 E8 03         .dw 1000
0610+  0848 10 27         .dw 100000828   084A             .include "lib/ctype.asm"
0001+  084A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  084A             ; ctype.s
0003+  084A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  084A             
0005+  084A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  084A             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  084A             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  084A             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  084A             ;; characters are supported.
0010+  084A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  084A             ;; _isalnum 
0012+  084A             ;; _isalpha 
0013+  084A             ;; islower 
0014+  084A             ;; isupper 
0015+  084A             ;; _isdigit 
0016+  084A             ;; isxdigit
0017+  084A             ;; iscntrl 
0018+  084A             ;; isgraph 
0019+  084A             ;; _isspace 
0020+  084A             ;; isblank 
0021+  084A             ;; isprint 
0022+  084A             ;; ispunct 
0023+  084A             ;; tolower 
0024+  084A             ;; toupper
0025+  084A             
0026+  084A             
0027+  084A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  084A             ;; IS ALPHANUMERIC
0029+  084A             ;; sets ZF according with result
0030+  084A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  084A             _isalnum:
0032+  084A 07 67 08    	call _isalpha
0033+  084D C6 53 08    	je _isalnum_exit
0034+  0850 07 54 08    	call _isdigit
0035+  0853             _isalnum_exit:
0036+  0853 09          	ret	
0037+  0854             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0854             ;; IS DIGIT
0039+  0854             ;; sets ZF according with result
0040+  0854             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0854             _isdigit:
0042+  0854 DB          	push al
0043+  0855 B9 30       	cmp al, '0'
0044+  0857 C8 63 08    	jlu _isdigit_false
0045+  085A B9 39       	cmp al, '9'
0046+  085C D1 63 08    	jgu _isdigit_false
0047+  085F 87 00       	and al, 0	; set ZF
0048+  0861 E8          	pop al
0049+  0862 09          	ret
0050+  0863             _isdigit_false:
0051+  0863 8B 01       	or al, 1	; clear ZF
0052+  0865 E8          	pop al
0053+  0866 09          	ret	
0054+  0867             	
0055+  0867             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0867             ;; IS ALPHA
0057+  0867             ;; sets ZF according with result
0058+  0867             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0867             _isalpha:
0060+  0867 DB          	push al
0061+  0868 B9 5F       	cmp al, '_'
0062+  086A C6 8A 08    	je _isalpha_true
0063+  086D B9 2E       	cmp al, '.'
0064+  086F C6 8A 08    	je _isalpha_true
0065+  0872 B9 41       	cmp al, 'A'
0066+  0874 C8 86 08    	jlu _isalpha_false
0067+  0877 B9 7A       	cmp al, 'z'
0068+  0879 D1 86 08    	jgu _isalpha_false
0069+  087C B9 5A       	cmp al, 'Z'
0070+  087E D0 8A 08    	jleu _isalpha_true
0071+  0881 B9 61       	cmp al, 'a'
0072+  0883 C9 8A 08    	jgeu _isalpha_true
0073+  0886             _isalpha_false:
0074+  0886 8B 01       	or al, 1	; clear ZF
0075+  0888 E8          	pop al
0076+  0889 09          	ret
0077+  088A             _isalpha_true:
0078+  088A 87 00       	and al, 0	; set ZF
0079+  088C E8          	pop al
0080+  088D 09          	ret
0081+  088E             
0082+  088E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  088E             ;; IS PATH-ALPHA
0084+  088E             ;; sets ZF according with result
0085+  088E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  088E             ispath:
0087+  088E DB          	push al
0088+  088F 07 54 08    	call _isdigit
0089+  0892 C6 BC 08    	je ispath_true
0090+  0895 B9 5F       	cmp al, '_'
0091+  0897 C6 BC 08    	je ispath_true
0092+  089A B9 2F       	cmp al, '/'
0093+  089C C6 BC 08    	je ispath_true
0094+  089F B9 2E       	cmp al, '.'
0095+  08A1 C6 BC 08    	je ispath_true
0096+  08A4 B9 41       	cmp al, 'A'
0097+  08A6 C8 B8 08    	jlu ispath_false
0098+  08A9 B9 7A       	cmp al, 'z'
0099+  08AB D1 B8 08    	jgu ispath_false
0100+  08AE B9 5A       	cmp al, 'Z'
0101+  08B0 D0 BC 08    	jleu ispath_true
0102+  08B3 B9 61       	cmp al, 'a'
0103+  08B5 C9 BC 08    	jgeu ispath_true
0104+  08B8             ispath_false:
0105+  08B8 8B 01       	or al, 1	; clear ZF
0106+  08BA E8          	pop al
0107+  08BB 09          	ret
0108+  08BC             ispath_true:
0109+  08BC 87 00       	and al, 0	; set ZF
0110+  08BE E8          	pop al
0111+  08BF 09          	ret
0112+  08C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  08C0             ;; IS SPACE
0114+  08C0             ;; sets ZF according with result
0115+  08C0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  08C0             _isspace:
0117+  08C0 B9 20       	cmp al, $20		; ' '
0118+  08C2 C6 D6 08    	je _isspace_exit
0119+  08C5 B9 09       	cmp al, $09		; '\t'
0120+  08C7 C6 D6 08    	je _isspace_exit
0121+  08CA B9 0A       	cmp al, $0A		; '\n'
0122+  08CC C6 D6 08    	je _isspace_exit
0123+  08CF B9 0D       	cmp al, $0D		; '\r'
0124+  08D1 C6 D6 08    	je _isspace_exit
0125+  08D4 B9 0B       	cmp al, $0B		; '\v'
0126+  08D6             _isspace_exit:
0127+  08D6 09          	ret	
0128+  08D7             
0129+  08D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08D7             ; TO LOWER
0131+  08D7             ; input in AL
0132+  08D7             ; output in AL
0133+  08D7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  08D7             _to_lower:
0135+  08D7 B9 5A       	cmp al, 'Z'
0136+  08D9 D1 DE 08    	jgu _to_lower_ret
0137+  08DC 6A 20       	add al, $20				; convert to lower case
0138+  08DE             _to_lower_ret:
0139+  08DE 09          	ret
0140+  08DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  08DF             ; TO UPPER
0142+  08DF             ; input in AL
0143+  08DF             ; output in AL
0144+  08DF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  08DF             _to_upper:
0146+  08DF B9 61       	cmp al, 'a'
0147+  08E1 C8 E6 08    	jlu _to_upper_ret
0148+  08E4 6F 20       	sub al, $20			; convert to upper case
0149+  08E6             _to_upper_ret:
0150+  08E6 09          	ret
0151+  08E7             
0829   08E7             
0830   08E7             ; kernel parameters
0831   08E7             sys_echo_on:
0832   08E7 01            .db 1
0833   08E8             sys_uart0_lcr:
0834   08E8 07            .db $07 ; 8 data bits, 2 stop bit, no parity
0835   08E9             sys_uart0_inten:
0836   08E9 01            .db 1
0837   08EA             sys_uart0_fifoen:
0838   08EA 00            .db 0
0839   08EB             sys_uart0_div0:
0840   08EB 0C            .db 12  ;
0841   08EC             sys_uart0_div1:
0842   08EC 00            .db 0   ; default baud = 9600
0843   08ED             ; Baud  Divisor
0844   08ED             ; 50    2304
0845   08ED             ; 110   1047
0846   08ED             ; 300    384
0847   08ED             ; 600    192
0848   08ED             ; 1200    96
0849   08ED             ; 9600    12
0850   08ED             ; 19200    6
0851   08ED             ; 38400    3
0852   08ED             
0853   08ED             
0854   08ED             fifo_in:
0855   08ED 83 0B         .dw fifo
0856   08EF             fifo_out:
0857   08EF 83 0B         .dw fifo
0858   08F1             
0859   08F1             
0860   08F1             s_kernel_started:
0861   08F1 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
0861   08F5 65 6C 20 73 
0861   08F9 74 61 72 74 
0861   08FD 65 64 28 76 
0861   0901 65 72 73 69 
0861   0905 6F 6E 20 31 
0861   0909 2E 30 29 0A 
0861   090D 00 
0862   090E             s_priviledge:
0863   090E 0A 65 78 63   .db "\nexception: privilege\n", 0
0863   0912 65 70 74 69 
0863   0916 6F 6E 3A 20 
0863   091A 70 72 69 76 
0863   091E 69 6C 65 67 
0863   0922 65 0A 00 
0864   0925             s_divzero:
0865   0925 0A 65 78 63   .db "\nexception: zero division\n", 0
0865   0929 65 70 74 69 
0865   092D 6F 6E 3A 20 
0865   0931 7A 65 72 6F 
0865   0935 20 64 69 76 
0865   0939 69 73 69 6F 
0865   093D 6E 0A 00 
0866   0940             
0867   0940             ; This is the format of a sector for the 128 byte per sector format.
0868   0940             ; Write the bracketed data 16 times per track.
0869   0940             ; The recommended single-density format with 128
0870   0940             ; bytes/sector is shown. In order to format a diskette,
0871   0940             ; the user issues the Write Track Command, and loads
0872   0940             ; the Data Register with the following values. For every
0873   0940             ; byte to be written, there is one Data Request.
0874   0940             fdc_irq_event:
0875   0940 00            .fill 1,  $00       ; keeps status of fdc irq event
0876   0941             fdc_128_format:                                                                       
0877   0941             fdc_40_FF:
0878   0941 FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
0878   0945 FF FF FF FF 
0878   0949 FF FF FF FF 
0878   094D FF FF FF FF 
0878   0951 FF FF FF FF 
0878   0955 FF FF FF FF 
0878   0959 FF FF FF FF 
0878   095D FF FF FF FF 
0878   0961 FF FF FF FF 
0878   0965 FF FF FF FF 
0879   0969             fdc_128_format_inner:
0880   0969 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
0880   096D 00 00 
0881   096F FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
0882   0970             fdc_128_format_track:
0883   0970 00            .fill 1,   $00    ; Track Number   0 thru 39                                                      |                    
0884   0971 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0885   0972             fdc_128_format_sect:
0886   0972 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0887   0973 00            .fill 1,   $00    ; Sector Length                                                                 |                        
0888   0974 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0889   0975 FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
0889   0979 FF FF FF FF 
0889   097D FF FF FF 
0890   0980 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
0890   0984 00 00 
0891   0986 FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0892   0987 E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0892   098B E5 E5 E5 E5 
0892   098F E5 E5 E5 E5 
0892   0993 E5 E5 E5 E5 
0892   0997 E5 E5 E5 E5 
0892   099B E5 E5 E5 E5 
0892   099F E5 E5 E5 E5 
0892   09A3 E5 E5 E5 E5 
0892   09A7 E5 E5 E5 E5 
0892   09AB E5 E5 E5 E5 
0892   09AF E5 E5 E5 E5 
0892   09B3 E5 E5 E5 E5 
0892   09B7 E5 E5 E5 E5 
0892   09BB E5 E5 E5 E5 
0892   09BF E5 E5 E5 E5 
0892   09C3 E5 E5 E5 E5 
0892   09C7 E5 E5 E5 E5 
0892   09CB E5 E5 E5 E5 
0892   09CF E5 E5 E5 E5 
0892   09D3 E5 E5 E5 E5 
0892   09D7 E5 E5 E5 E5 
0892   09DB E5 E5 E5 E5 
0892   09DF E5 E5 E5 E5 
0892   09E3 E5 E5 E5 E5 
0892   09E7 E5 E5 E5 E5 
0892   09EB E5 E5 E5 E5 
0892   09EF E5 E5 E5 E5 
0892   09F3 E5 E5 E5 E5 
0892   09F7 E5 E5 E5 E5 
0892   09FB E5 E5 E5 E5 
0892   09FF E5 E5 E5 E5 
0892   0A03 E5 E5 E5 E5 
0893   0A07 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0894   0A08 FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0894   0A0C FF FF FF FF 
0894   0A10 FF FF 
0895   0A12             fdc_128_format_end:
0896   0A12 FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0896   0A16 FF FF FF FF 
0896   0A1A FF FF FF FF 
0896   0A1E FF FF FF FF 
0896   0A22 FF FF FF FF 
0896   0A26 FF FF FF FF 
0896   0A2A FF FF FF FF 
0896   0A2E FF FF FF FF 
0896   0A32 FF FF FF FF 
0896   0A36 FF FF FF FF 
0896   0A3A FF FF FF FF 
0896   0A3E FF FF FF FF 
0896   0A42 FF FF FF FF 
0896   0A46 FF FF FF FF 
0896   0A4A FF FF FF FF 
0896   0A4E FF FF FF FF 
0896   0A52 FF FF FF FF 
0896   0A56 FF FF FF FF 
0896   0A5A FF FF FF FF 
0896   0A5E FF FF FF FF 
0896   0A62 FF FF FF FF 
0896   0A66 FF FF FF FF 
0896   0A6A FF FF FF FF 
0896   0A6E FF FF FF FF 
0896   0A72 FF FF FF FF 
0896   0A76 FF FF FF FF 
0896   0A7A FF FF FF FF 
0896   0A7E FF FF FF FF 
0896   0A82 FF FF FF FF 
0896   0A86 FF FF FF FF 
0896   0A8A FF FF FF FF 
0896   0A8E FF FF FF FF 
0896   0A92 FF FF FF FF 
0896   0A96 FF FF FF FF 
0896   0A9A FF FF FF FF 
0896   0A9E FF FF FF FF 
0896   0AA2 FF FF FF FF 
0896   0AA6 FF FF FF FF 
0896   0AAA FF FF FF FF 
0896   0AAE FF FF FF FF 
0896   0AB2 FF FF FF FF 
0896   0AB6 FF FF FF FF 
0896   0ABA FF FF FF FF 
0896   0ABE FF FF FF FF 
0896   0AC2 FF FF FF FF 
0896   0AC6 FF FF FF FF 
0896   0ACA FF FF FF FF 
0896   0ACE FF FF FF FF 
0896   0AD2 FF FF FF FF 
0896   0AD6 FF FF FF FF 
0896   0ADA FF FF FF FF 
0896   0ADE FF FF FF FF 
0896   0AE2 FF FF FF FF 
0896   0AE6 FF FF FF FF 
0896   0AEA FF FF FF FF 
0896   0AEE FF FF FF FF 
0896   0AF2 FF FF FF FF 
0896   0AF6 FF FF FF FF 
0896   0AFA FF FF FF FF 
0896   0AFE FF FF FF FF 
0896   0B02 FF FF FF FF 
0896   0B06 FF FF FF FF 
0896   0B0A FF FF FF FF 
0896   0B0E FF FF FF FF 
0896   0B12 FF FF FF FF 
0896   0B16 FF FF FF FF 
0896   0B1A FF FF FF FF 
0896   0B1E FF FF FF FF 
0896   0B22 FF FF FF FF 
0896   0B26 FF FF FF FF 
0896   0B2A FF FF FF FF 
0896   0B2E FF FF FF FF 
0896   0B32 FF FF FF FF 
0896   0B36 FF FF FF FF 
0896   0B3A FF FF FF FF 
0896   0B3E FF FF FF FF 
0896   0B42 FF FF FF FF 
0896   0B46 FF FF FF FF 
0896   0B4A FF FF FF FF 
0896   0B4E FF FF FF FF 
0896   0B52 FF FF FF FF 
0896   0B56 FF FF FF FF 
0896   0B5A FF FF FF FF 
0896   0B5E FF FF FF FF 
0896   0B62 FF FF FF FF 
0896   0B66 FF FF FF FF 
0896   0B6A FF FF FF FF 
0896   0B6E FF FF FF FF 
0896   0B72 FF FF FF FF 
0896   0B76 FF FF FF FF 
0896   0B7A FF FF FF FF 
0896   0B7E FF FF FF FF 
0896   0B82 FF 
0897   0B83             
0898   0B83             fifo:
0899   0B83 FF FF FF FF   .fill FIFO_SIZE
0899   0B87 FF FF FF FF 
0899   0B8B FF FF FF FF 
0899   0B8F FF FF FF FF 
0899   0B93 FF FF FF FF 
0899   0B97 FF FF FF FF 
0899   0B9B FF FF FF FF 
0899   0B9F FF FF FF FF 
0899   0BA3 FF FF FF FF 
0899   0BA7 FF FF FF FF 
0899   0BAB FF FF FF FF 
0899   0BAF FF FF FF FF 
0899   0BB3 FF FF FF FF 
0899   0BB7 FF FF FF FF 
0899   0BBB FF FF FF FF 
0899   0BBF FF FF FF FF 
0899   0BC3 FF FF FF FF 
0899   0BC7 FF FF FF FF 
0899   0BCB FF FF FF FF 
0899   0BCF FF FF FF FF 
0899   0BD3 FF FF FF FF 
0899   0BD7 FF FF FF FF 
0899   0BDB FF FF FF FF 
0899   0BDF FF FF FF FF 
0899   0BE3 FF FF FF FF 
0899   0BE7 FF FF FF FF 
0899   0BEB FF FF FF FF 
0899   0BEF FF FF FF FF 
0899   0BF3 FF FF FF FF 
0899   0BF7 FF FF FF FF 
0899   0BFB FF FF FF FF 
0899   0BFF FF FF FF FF 
0899   0C03 FF FF FF FF 
0899   0C07 FF FF FF FF 
0899   0C0B FF FF FF FF 
0899   0C0F FF FF FF FF 
0899   0C13 FF FF FF FF 
0899   0C17 FF FF FF FF 
0899   0C1B FF FF FF FF 
0899   0C1F FF FF FF FF 
0899   0C23 FF FF FF FF 
0899   0C27 FF FF FF FF 
0899   0C2B FF FF FF FF 
0899   0C2F FF FF FF FF 
0899   0C33 FF FF FF FF 
0899   0C37 FF FF FF FF 
0899   0C3B FF FF FF FF 
0899   0C3F FF FF FF FF 
0899   0C43 FF FF FF FF 
0899   0C47 FF FF FF FF 
0899   0C4B FF FF FF FF 
0899   0C4F FF FF FF FF 
0899   0C53 FF FF FF FF 
0899   0C57 FF FF FF FF 
0899   0C5B FF FF FF FF 
0899   0C5F FF FF FF FF 
0899   0C63 FF FF FF FF 
0899   0C67 FF FF FF FF 
0899   0C6B FF FF FF FF 
0899   0C6F FF FF FF FF 
0899   0C73 FF FF FF FF 
0899   0C77 FF FF FF FF 
0899   0C7B FF FF FF FF 
0899   0C7F FF FF FF FF 
0899   0C83 FF FF FF FF 
0899   0C87 FF FF FF FF 
0899   0C8B FF FF FF FF 
0899   0C8F FF FF FF FF 
0899   0C93 FF FF FF FF 
0899   0C97 FF FF FF FF 
0899   0C9B FF FF FF FF 
0899   0C9F FF FF FF FF 
0899   0CA3 FF FF FF FF 
0899   0CA7 FF FF FF FF 
0899   0CAB FF FF FF FF 
0899   0CAF FF FF FF FF 
0899   0CB3 FF FF FF FF 
0899   0CB7 FF FF FF FF 
0899   0CBB FF FF FF FF 
0899   0CBF FF FF FF FF 
0899   0CC3 FF FF FF FF 
0899   0CC7 FF FF FF FF 
0899   0CCB FF FF FF FF 
0899   0CCF FF FF FF FF 
0899   0CD3 FF FF FF FF 
0899   0CD7 FF FF FF FF 
0899   0CDB FF FF FF FF 
0899   0CDF FF FF FF FF 
0899   0CE3 FF FF FF FF 
0899   0CE7 FF FF FF FF 
0899   0CEB FF FF FF FF 
0899   0CEF FF FF FF FF 
0899   0CF3 FF FF FF FF 
0899   0CF7 FF FF FF FF 
0899   0CFB FF FF FF FF 
0899   0CFF FF FF FF FF 
0899   0D03 FF FF FF FF 
0899   0D07 FF FF FF FF 
0899   0D0B FF FF FF FF 
0899   0D0F FF FF FF FF 
0899   0D13 FF FF FF FF 
0899   0D17 FF FF FF FF 
0899   0D1B FF FF FF FF 
0899   0D1F FF FF FF FF 
0899   0D23 FF FF FF FF 
0899   0D27 FF FF FF FF 
0899   0D2B FF FF FF FF 
0899   0D2F FF FF FF FF 
0899   0D33 FF FF FF FF 
0899   0D37 FF FF FF FF 
0899   0D3B FF FF FF FF 
0899   0D3F FF FF FF FF 
0899   0D43 FF FF FF FF 
0899   0D47 FF FF FF FF 
0899   0D4B FF FF FF FF 
0899   0D4F FF FF FF FF 
0899   0D53 FF FF FF FF 
0899   0D57 FF FF FF FF 
0899   0D5B FF FF FF FF 
0899   0D5F FF FF FF FF 
0899   0D63 FF FF FF FF 
0899   0D67 FF FF FF FF 
0899   0D6B FF FF FF FF 
0899   0D6F FF FF FF FF 
0899   0D73 FF FF FF FF 
0899   0D77 FF FF FF FF 
0899   0D7B FF FF FF FF 
0899   0D7F FF FF FF FF 
0899   0D83 FF FF FF FF 
0899   0D87 FF FF FF FF 
0899   0D8B FF FF FF FF 
0899   0D8F FF FF FF FF 
0899   0D93 FF FF FF FF 
0899   0D97 FF FF FF FF 
0899   0D9B FF FF FF FF 
0899   0D9F FF FF FF FF 
0899   0DA3 FF FF FF FF 
0899   0DA7 FF FF FF FF 
0899   0DAB FF FF FF FF 
0899   0DAF FF FF FF FF 
0899   0DB3 FF FF FF FF 
0899   0DB7 FF FF FF FF 
0899   0DBB FF FF FF FF 
0899   0DBF FF FF FF FF 
0899   0DC3 FF FF FF FF 
0899   0DC7 FF FF FF FF 
0899   0DCB FF FF FF FF 
0899   0DCF FF FF FF FF 
0899   0DD3 FF FF FF FF 
0899   0DD7 FF FF FF FF 
0899   0DDB FF FF FF FF 
0899   0DDF FF FF FF FF 
0899   0DE3 FF FF FF FF 
0899   0DE7 FF FF FF FF 
0899   0DEB FF FF FF FF 
0899   0DEF FF FF FF FF 
0899   0DF3 FF FF FF FF 
0899   0DF7 FF FF FF FF 
0899   0DFB FF FF FF FF 
0899   0DFF FF FF FF FF 
0899   0E03 FF FF FF FF 
0899   0E07 FF FF FF FF 
0899   0E0B FF FF FF FF 
0899   0E0F FF FF FF FF 
0899   0E13 FF FF FF FF 
0899   0E17 FF FF FF FF 
0899   0E1B FF FF FF FF 
0899   0E1F FF FF FF FF 
0899   0E23 FF FF FF FF 
0899   0E27 FF FF FF FF 
0899   0E2B FF FF FF FF 
0899   0E2F FF FF FF FF 
0899   0E33 FF FF FF FF 
0899   0E37 FF FF FF FF 
0899   0E3B FF FF FF FF 
0899   0E3F FF FF FF FF 
0899   0E43 FF FF FF FF 
0899   0E47 FF FF FF FF 
0899   0E4B FF FF FF FF 
0899   0E4F FF FF FF FF 
0899   0E53 FF FF FF FF 
0899   0E57 FF FF FF FF 
0899   0E5B FF FF FF FF 
0899   0E5F FF FF FF FF 
0899   0E63 FF FF FF FF 
0899   0E67 FF FF FF FF 
0899   0E6B FF FF FF FF 
0899   0E6F FF FF FF FF 
0899   0E73 FF FF FF FF 
0899   0E77 FF FF FF FF 
0899   0E7B FF FF FF FF 
0899   0E7F FF FF FF FF 
0899   0E83 FF FF FF FF 
0899   0E87 FF FF FF FF 
0899   0E8B FF FF FF FF 
0899   0E8F FF FF FF FF 
0899   0E93 FF FF FF FF 
0899   0E97 FF FF FF FF 
0899   0E9B FF FF FF FF 
0899   0E9F FF FF FF FF 
0899   0EA3 FF FF FF FF 
0899   0EA7 FF FF FF FF 
0899   0EAB FF FF FF FF 
0899   0EAF FF FF FF FF 
0899   0EB3 FF FF FF FF 
0899   0EB7 FF FF FF FF 
0899   0EBB FF FF FF FF 
0899   0EBF FF FF FF FF 
0899   0EC3 FF FF FF FF 
0899   0EC7 FF FF FF FF 
0899   0ECB FF FF FF FF 
0899   0ECF FF FF FF FF 
0899   0ED3 FF FF FF FF 
0899   0ED7 FF FF FF FF 
0899   0EDB FF FF FF FF 
0899   0EDF FF FF FF FF 
0899   0EE3 FF FF FF FF 
0899   0EE7 FF FF FF FF 
0899   0EEB FF FF FF FF 
0899   0EEF FF FF FF FF 
0899   0EF3 FF FF FF FF 
0899   0EF7 FF FF FF FF 
0899   0EFB FF FF FF FF 
0899   0EFF FF FF FF FF 
0899   0F03 FF FF FF FF 
0899   0F07 FF FF FF FF 
0899   0F0B FF FF FF FF 
0899   0F0F FF FF FF FF 
0899   0F13 FF FF FF FF 
0899   0F17 FF FF FF FF 
0899   0F1B FF FF FF FF 
0899   0F1F FF FF FF FF 
0899   0F23 FF FF FF FF 
0899   0F27 FF FF FF FF 
0899   0F2B FF FF FF FF 
0899   0F2F FF FF FF FF 
0899   0F33 FF FF FF FF 
0899   0F37 FF FF FF FF 
0899   0F3B FF FF FF FF 
0899   0F3F FF FF FF FF 
0899   0F43 FF FF FF FF 
0899   0F47 FF FF FF FF 
0899   0F4B FF FF FF FF 
0899   0F4F FF FF FF FF 
0899   0F53 FF FF FF FF 
0899   0F57 FF FF FF FF 
0899   0F5B FF FF FF FF 
0899   0F5F FF FF FF FF 
0899   0F63 FF FF FF FF 
0899   0F67 FF FF FF FF 
0899   0F6B FF FF FF FF 
0899   0F6F FF FF FF FF 
0899   0F73 FF FF FF FF 
0899   0F77 FF FF FF FF 
0899   0F7B FF FF FF FF 
0899   0F7F FF FF FF FF 
0900   0F83             
0901   0F83             scrap_sector:
0902   0F83 FF FF FF FF   .fill 512         ; scrap sector
0902   0F87 FF FF FF FF 
0902   0F8B FF FF FF FF 
0902   0F8F FF FF FF FF 
0902   0F93 FF FF FF FF 
0902   0F97 FF FF FF FF 
0902   0F9B FF FF FF FF 
0902   0F9F FF FF FF FF 
0902   0FA3 FF FF FF FF 
0902   0FA7 FF FF FF FF 
0902   0FAB FF FF FF FF 
0902   0FAF FF FF FF FF 
0902   0FB3 FF FF FF FF 
0902   0FB7 FF FF FF FF 
0902   0FBB FF FF FF FF 
0902   0FBF FF FF FF FF 
0902   0FC3 FF FF FF FF 
0902   0FC7 FF FF FF FF 
0902   0FCB FF FF FF FF 
0902   0FCF FF FF FF FF 
0902   0FD3 FF FF FF FF 
0902   0FD7 FF FF FF FF 
0902   0FDB FF FF FF FF 
0902   0FDF FF FF FF FF 
0902   0FE3 FF FF FF FF 
0902   0FE7 FF FF FF FF 
0902   0FEB FF FF FF FF 
0902   0FEF FF FF FF FF 
0902   0FF3 FF FF FF FF 
0902   0FF7 FF FF FF FF 
0902   0FFB FF FF FF FF 
0902   0FFF FF FF FF FF 
0902   1003 FF FF FF FF 
0902   1007 FF FF FF FF 
0902   100B FF FF FF FF 
0902   100F FF FF FF FF 
0902   1013 FF FF FF FF 
0902   1017 FF FF FF FF 
0902   101B FF FF FF FF 
0902   101F FF FF FF FF 
0902   1023 FF FF FF FF 
0902   1027 FF FF FF FF 
0902   102B FF FF FF FF 
0902   102F FF FF FF FF 
0902   1033 FF FF FF FF 
0902   1037 FF FF FF FF 
0902   103B FF FF FF FF 
0902   103F FF FF FF FF 
0902   1043 FF FF FF FF 
0902   1047 FF FF FF FF 
0902   104B FF FF FF FF 
0902   104F FF FF FF FF 
0902   1053 FF FF FF FF 
0902   1057 FF FF FF FF 
0902   105B FF FF FF FF 
0902   105F FF FF FF FF 
0902   1063 FF FF FF FF 
0902   1067 FF FF FF FF 
0902   106B FF FF FF FF 
0902   106F FF FF FF FF 
0902   1073 FF FF FF FF 
0902   1077 FF FF FF FF 
0902   107B FF FF FF FF 
0902   107F FF FF FF FF 
0902   1083 FF FF FF FF 
0902   1087 FF FF FF FF 
0902   108B FF FF FF FF 
0902   108F FF FF FF FF 
0902   1093 FF FF FF FF 
0902   1097 FF FF FF FF 
0902   109B FF FF FF FF 
0902   109F FF FF FF FF 
0902   10A3 FF FF FF FF 
0902   10A7 FF FF FF FF 
0902   10AB FF FF FF FF 
0902   10AF FF FF FF FF 
0902   10B3 FF FF FF FF 
0902   10B7 FF FF FF FF 
0902   10BB FF FF FF FF 
0902   10BF FF FF FF FF 
0902   10C3 FF FF FF FF 
0902   10C7 FF FF FF FF 
0902   10CB FF FF FF FF 
0902   10CF FF FF FF FF 
0902   10D3 FF FF FF FF 
0902   10D7 FF FF FF FF 
0902   10DB FF FF FF FF 
0902   10DF FF FF FF FF 
0902   10E3 FF FF FF FF 
0902   10E7 FF FF FF FF 
0902   10EB FF FF FF FF 
0902   10EF FF FF FF FF 
0902   10F3 FF FF FF FF 
0902   10F7 FF FF FF FF 
0902   10FB FF FF FF FF 
0902   10FF FF FF FF FF 
0902   1103 FF FF FF FF 
0902   1107 FF FF FF FF 
0902   110B FF FF FF FF 
0902   110F FF FF FF FF 
0902   1113 FF FF FF FF 
0902   1117 FF FF FF FF 
0902   111B FF FF FF FF 
0902   111F FF FF FF FF 
0902   1123 FF FF FF FF 
0902   1127 FF FF FF FF 
0902   112B FF FF FF FF 
0902   112F FF FF FF FF 
0902   1133 FF FF FF FF 
0902   1137 FF FF FF FF 
0902   113B FF FF FF FF 
0902   113F FF FF FF FF 
0902   1143 FF FF FF FF 
0902   1147 FF FF FF FF 
0902   114B FF FF FF FF 
0902   114F FF FF FF FF 
0902   1153 FF FF FF FF 
0902   1157 FF FF FF FF 
0902   115B FF FF FF FF 
0902   115F FF FF FF FF 
0902   1163 FF FF FF FF 
0902   1167 FF FF FF FF 
0902   116B FF FF FF FF 
0902   116F FF FF FF FF 
0902   1173 FF FF FF FF 
0902   1177 FF FF FF FF 
0902   117B FF FF FF FF 
0902   117F FF FF FF FF 
0903   1183             transient_area:
0904   1183 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
0905   1184             
0906   1184             .end
tasm: Number of errors = 1
