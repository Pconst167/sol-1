0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; GLOBAL SYSTEM VARIABLES
0086   0000             ; ------------------------------------------------------------------------------------------------------------------;
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; IRQ table
0090   0000             ; highest priority at lowest address
0091   0000             ; ------------------------------------------------------------------------------------------------------------------;
0092   0000 28 00       .dw int_0_fdc
0093   0002 29 00       .dw int_1
0094   0004 2A 00       .dw int_2
0095   0006 2B 00       .dw int_3
0096   0008 2C 00       .dw int_4
0097   000A 2D 00       .dw int_5
0098   000C 2E 00       .dw int_6
0099   000E 2F 00       .dw int_7_uart0
0100   0010             
0101   0010             ; ------------------------------------------------------------------------------------------------------------------;
0102   0010             ; kernel reset vector
0103   0010             ; ------------------------------------------------------------------------------------------------------------------;
0104   0010 A8 02       .dw kernel_reset_vector
0105   0012             
0106   0012             ; ------------------------------------------------------------------------------------------------------------------;
0107   0012             ; exception vector table
0108   0012             ; total of 7 entries, starting at address $0012
0109   0012             ; ------------------------------------------------------------------------------------------------------------------;
0110   0012 17 02       .dw trap_privilege
0111   0014 23 02       .dw trap_div_zero
0112   0016 30 02       .dw trap_undef_opcode
0113   0018 00 00       .dw 0
0114   001A 00 00       .dw 0
0115   001C 00 00       .dw 0
0116   001E 00 00       .dw 0
0117   0020             
0118   0020             ; ------------------------------------------------------------------------------------------------------------------;
0119   0020             ; system call vector table
0120   0020             ; starts at address $0020
0121   0020             ; ------------------------------------------------------------------------------------------------------------------;
0122   0020 37 02       .dw syscall_io
0123   0022 0B 02       .dw syscall_reboot
0124   0024 9F 00       .dw syscall_fdc
0125   0026 4E 00       .dw syscall_fdc_read
0126   0028             
0127   0028             ; ------------------------------------------------------------------------------------------------------------------;
0128   0028             ; system call aliases
0129   0028             ; ------------------------------------------------------------------------------------------------------------------;
0130   0028             sys_io               .equ 0
0131   0028             sys_reboot           .equ 1
0132   0028             sys_fdc              .equ 2
0133   0028             sys_fdc_read         .equ 3
0134   0028             
0135   0028             ; ------------------------------------------------------------------------------------------------------------------;
0136   0028             ; IRQs' code block
0137   0028             ; ------------------------------------------------------------------------------------------------------------------;
0138   0028             ; 5.25" Floppy Drive Controller IRQ
0139   0028             int_0_fdc:
0140   0028 06            sysret
0141   0029             int_1:
0142   0029 06            sysret
0143   002A             int_2:
0144   002A 06            sysret
0145   002B             int_3:
0146   002B 06            sysret
0147   002C             int_4:
0148   002C 06            sysret
0149   002D             int_5:
0150   002D 06            sysret
0151   002E             
0152   002E             ; ------------------------------------------------------------------------------------------------------------------;
0153   002E             ; process swapping
0154   002E             ; ------------------------------------------------------------------------------------------------------------------;
0155   002E             int_6:  
0156   002E 06            sysret
0157   002F             
0158   002F             ; ------------------------------------------------------------------------------------------------------------------;
0159   002F             ; UART0 Interrupt
0160   002F             ; ------------------------------------------------------------------------------------------------------------------;
0161   002F             int_7_uart0:
0162   002F D7            push a
0163   0030 DA            push d
0164   0031 E1            pushf
0165   0032 14 AB 08      mov a, [fifo_in]
0166   0035 3C            mov d, a
0167   0036 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0168   0039 3E            mov [d], al                 ; add to fifo
0169   003A 14 AB 08      mov a, [fifo_in]
0170   003D 77            inc a
0171   003E AF 41 0F      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0172   0041 C7 47 00      jne int_7_continue
0173   0044 10 41 0B      mov a, fifo  
0174   0047             int_7_continue:  
0175   0047 42 AB 08      mov [fifo_in], a            ; update fifo pointer
0176   004A EE            popf
0177   004B E7            pop d
0178   004C E4            pop a  
0179   004D 06            sysret
0180   004E             
0181   004E             
0182   004E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0183   004E             ; floppy drive system calls
0184   004E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0185   004E             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0186   004E             ; fdc_40_FF:
0187   004E             ;   .fill 40,  $FF    ; or 00                                                                                
0188   004E             ; fdc_128_format_inner:
0189   004E             ;   .fill 6,   $00    ;                                                                            <--|        
0190   004E             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0191   004E             ;   .fill 1,   $00    ; Track Number  0 thru 39                                                       |                    
0192   004E             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0193   004E             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0194   004E             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0195   004E             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0196   004E             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0197   004E             ;   .fill 6,   $00    ;                                                                               |                        
0198   004E             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0199   004E             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0200   004E             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0201   004E             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0202   004E             ; fdc_128_format_end:
0203   004E             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0204   004E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0205   004E             ; _FDC_CONFIG       .equ $FFC0 
0206   004E             ; _FDC_STATUS_1     .equ $FFC1
0207   004E             ; _FDC_WD_STAT_CMD  .equ $FFC8
0208   004E             ; _FDC_WD_TRACK     .equ $FFC9
0209   004E             ; _FDC_WD_SECTOR    .equ $FFCA
0210   004E             ; _FDC_WD_DATA      .equ $FFCB
0211   004E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212   004E             syscall_fdc_read:
0213   004E 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0214   0051 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0215   0054 19 E0         mov al, %11100000         
0216   0056 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0217   0059 07 C7 01      call fdc_wait_64us
0218   005C             
0219   005C             fdc_wait_busy_high1:
0220   005C 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0221   005F 87 01         and al, $01                ; 
0222   0061 C6 5C 00      jz fdc_wait_busy_high1
0223   0064             
0224   0064 FD 4F 41 11   mov di, transient_area
0225   0068             fdc_read_loop: ; for each byte, we need to wait for DRQ to be high
0226   0068 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag 10+3+5+8+5+8
0227   006B 2F            mov bl, al                                                
0228   006C FD 87 01      and bl, $01                ; check drq bit
0229   006F C6 82 00      jz fdc_read_end
0230   0072 87 02         and al, $02                ; check drq bit
0231   0074 C6 68 00      jz fdc_read_loop
0232   0077 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0233   007A F7            stosb
0234   007B 0A 68 00      jmp fdc_read_loop
0235   007E             
0236   007E 50            mov a, di
0237   007F 5F 41 11      sub a, transient_area
0238   0082             
0239   0082             
0240   0082             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0241   0082             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0242   0082             ;because for every write, if it also reads, then that clears DRQ, so we need to wait for next DRQ.
0243   0082             
0244   0082             
0245   0082             fdc_read_end:
0246   0082 3B 92 00      mov d, sss
0247   0085 07 AA 06      call _puts
0248   0088 07 D3 06      call print_u16d
0249   008B 07 57 06      call printnl
0250   008E 07 6F 03      call cmd_hexd
0251   0091 06            sysret
0252   0092 0A 74 72 61 sss:.db "\ntrack read\n", 0
0252   0096 63 6B 20 72 
0252   009A 65 61 64 0A 
0252   009E 00 
0253   009F             
0254   009F             syscall_fdc:
0255   009F             ; bl: track number
0256   009F             syscall_fdc_format:
0257   009F 1B            mov al, bl
0258   00A0 3D 2E 09      mov [fdc_128_format_track], al  ; write track number to formatting data block
0259   00A3 19 01         mov al, 1
0260   00A5 3D 30 09      mov [fdc_128_format_sect], al   ; reset sector variable to 1
0261   00A8 19 00         mov al, 0
0262   00AA 3D C9 FF      mov [_FDC_WD_TRACK], al   
0263   00AD 3B D1 01      mov d, s_format_begin
0264   00B0 07 AA 06      call _puts
0265   00B3 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0266   00B6 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0267   00B9 2F            mov bl, al
0268   00BA 07 4A 07      call print_u8x
0269   00BD 07 57 06      call printnl
0270   00C0 10 00 00      mov a, 0
0271   00C3 42 CE 01      mov [fdc_count], a
0272   00C6             fdc_header_loop_start:
0273   00C6 19 F6         mov al, %11110110               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0274   00C8 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0275   00CB             ; write the first data block for formatting which is 40 bytes of 0xFF:
0276   00CB 07 C7 01      call fdc_wait_64us
0277   00CE 3B 01 00      mov d, 1
0278   00D1             
0279   00D1             fdc_wait_busy_high:
0280   00D1 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0281   00D4 87 01         and al, $01                ; 
0282   00D6 C6 D1 00      jz fdc_wait_busy_high
0283   00D9             
0284   00D9             
0285   00D9 3A 28         mov cl, 40
0286   00DB             fdc_drq_loop: ; for each byte, we need to wait for DRQ to be high
0287   00DB 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0288   00DE 87 02         and al, $02                ; check drq bit
0289   00E0 C6 DB 00      jz fdc_drq_loop
0290   00E3 F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0291   00E7 81            dec cl
0292   00E8 C7 DB 00      jnz fdc_drq_loop
0293   00EB             ; start inner data block loop. this block is written 16 times
0294   00EB             
0295   00EB             fdc_inner_loop:
0296   00EB 3A 06         mov cl, 6
0297   00ED             fdc_l1:
0298   00ED 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0299   00F0 87 02         and al, $02                ; check drq bit
0300   00F2 C6 ED 00      jz fdc_l1
0301   00F5 F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0302   00F9 81            dec cl
0303   00FA C7 ED 00      jnz fdc_l1
0304   00FD             
0305   00FD             ; address mark
0306   00FD             fdc_l2:
0307   00FD 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0308   0100 87 02         and al, $02                ; check drq bit
0309   0102 C6 FD 00      jz fdc_l2
0310   0105 F2 CB FF FE   mov byte [_FDC_WD_DATA], $FE     ; send data byte to wd1770
0311   0109             
0312   0109             ; track number
0313   0109             fdc_l3:
0314   0109 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0315   010C 87 02         and al, $02                ; check drq bit
0316   010E C6 09 01      jz fdc_l3
0317   0111 F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0318   0115             
0319   0115             ; side number
0320   0115             fdc_l4:
0321   0115 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0322   0118 87 02         and al, $02                ; check drq bit
0323   011A C6 15 01      jz fdc_l4
0324   011D F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0325   0121             
0326   0121             ; sector number
0327   0121             fdc_l5:
0328   0121 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0329   0124 87 02         and al, $02                ; check drq bit
0330   0126 C6 21 01      jz fdc_l5
0331   0129 FD 1A         mov al, gl
0332   012B 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0333   012E             
0334   012E             ; sector length
0335   012E             fdc_l6:
0336   012E 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0337   0131 87 02         and al, $02                ; check drq bit
0338   0133 C6 2E 01      jz fdc_l6
0339   0136 F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0340   013A             
0341   013A             ; 2 crc's
0342   013A             fdc_l7:
0343   013A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0344   013D 87 02         and al, $02                ; check drq bit
0345   013F C6 3A 01      jz fdc_l7
0346   0142 F2 CB FF F7   mov byte [_FDC_WD_DATA], $F7     ; send data byte to wd1770
0347   0146             
0348   0146             ; 11 times $FF
0349   0146 3A 0B         mov cl, 11
0350   0148             fdc_l8:
0351   0148 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0352   014B 87 02         and al, $02                ; check drq bit
0353   014D C6 48 01      jz fdc_l8
0354   0150 F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0355   0154 81            dec cl
0356   0155 C7 48 01      jnz fdc_l8
0357   0158             
0358   0158             ; 6 times 00
0359   0158 3A 06         mov cl, 6
0360   015A             fdc_l9:
0361   015A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0362   015D 87 02         and al, $02                ; check drq bit
0363   015F C6 5A 01      jz fdc_l9
0364   0162 F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0365   0166 81            dec cl
0366   0167 C7 5A 01      jnz fdc_l9
0367   016A             
0368   016A             ; data address mark
0369   016A             fdc_l10:
0370   016A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0371   016D 87 02         and al, $02                ; check drq bit
0372   016F C6 6A 01      jz fdc_l10
0373   0172 F2 CB FF FB   mov byte [_FDC_WD_DATA], $FB     ; send data byte to wd1770
0374   0176             
0375   0176             ; sector data
0376   0176 3A 80         mov cl, 128
0377   0178 2E E5         mov bl, $E5
0378   017A             fdc_l11:
0379   017A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0380   017D 87 02         and al, $02                ; check drq bit
0381   017F C6 7A 01      jz fdc_l11
0382   0182 FD 3D CB FF   mov [_FDC_WD_DATA], bl     ; send data byte to wd1770
0383   0186 81            dec cl
0384   0187 C7 7A 01      jnz fdc_l11
0385   018A             
0386   018A             ; 2 crc's
0387   018A             fdc_l12:
0388   018A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0389   018D 87 02         and al, $02                ; check drq bit
0390   018F C6 8A 01      jz fdc_l12
0391   0192 F2 CB FF F7   mov byte [_FDC_WD_DATA], $F7     ; send data byte to wd1770
0392   0196             
0393   0196             ; 10 times $FF
0394   0196 3A 0A         mov cl, 10
0395   0198             fdc_l13:
0396   0198 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0397   019B 87 02         and al, $02                ; check drq bit
0398   019D C6 98 01      jz fdc_l13
0399   01A0 F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0400   01A4 81            dec cl
0401   01A5 C7 98 01      jnz fdc_l13
0402   01A8             
0403   01A8             ; check whether we did this 16 times
0404   01A8 79            inc d
0405   01A9 C5 11 00      cmp d, 17
0406   01AC C7 EB 00      jne fdc_inner_loop
0407   01AF             
0408   01AF 06            sysret
0409   01B0             
0410   01B0             ; loop ~369 times
0411   01B0             fdc_format_footer:
0412   01B0             fdc_footer_drq_loop:
0413   01B0 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0414   01B3 2F            mov bl, al
0415   01B4 FD 87 01      and bl, $01                ; check busy bit
0416   01B7 C6 C6 01      jz fdc_format_done
0417   01BA 87 02         and al, $02                ; check drq bit
0418   01BC C6 B0 01      jz fdc_footer_drq_loop
0419   01BF F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0420   01C3 0A B0 01      jmp fdc_footer_drq_loop
0421   01C6             
0422   01C6             fdc_format_done:
0423   01C6 06            sysret
0424   01C7             
0425   01C7             ; fetch is 2 cycles long when 'display_reg_load' is false.
0426   01C7             ; mov cl, 14 is 5 cycles long (2 to fetch, and 3 execution)
0427   01C7             ; 64us amounts to 160 cycles of the 2.5MHz clock
0428   01C7             ; so we need to wait for 155 cycles after mov cl, 14
0429   01C7             ; and since dec cl, and jnz amount to 11 cycles, we need to loop there 14 times: 14*11 = 154
0430   01C7             ; and 154 + 5 = 159
0431   01C7             fdc_wait_64us:
0432   01C7 3A 0E         mov cl, 14                       ; 5 cycles
0433   01C9             fdc_wait_64_loop:
0434   01C9 81            dec cl                           ; 3 cycles
0435   01CA C7 C9 01      jnz fdc_wait_64_loop             ; 8 cycles
0436   01CD 09            ret
0437   01CE             
0438   01CE 00 00       fdc_count: .dw 0
0439   01D0 00          fdc_irq: .db 0
0440   01D1 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0440   01D5 6D 61 74 74 
0440   01D9 69 6E 67 20 
0440   01DD 73 74 61 72 
0440   01E1 74 69 6E 67 
0440   01E5 2E 2E 2E 0A 
0440   01E9 00 
0441   01EA 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0441   01EE 6D 61 74 74 
0441   01F2 69 6E 67 20 
0441   01F6 64 6F 6E 65 
0441   01FA 2E 0A 00 
0442   01FD 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0442   0201 20 73 74 61 
0442   0205 74 75 73 3A 
0442   0209 20 00 
0443   020B             
0444   020B             ; REBOOT SYSTEM
0445   020B             syscall_reboot:
0446   020B FD D7 FF FF   push word $FFFF 
0447   020F FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0448   0212 FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0449   0216 06            sysret
0450   0217             
0451   0217             ; ------------------------------------------------------------------------------------------------------------------;
0452   0217             ; exceptions code block
0453   0217             ; ------------------------------------------------------------------------------------------------------------------;
0454   0217             ; privilege exception
0455   0217             ; ------------------------------------------------------------------------------------------------------------------;
0456   0217             trap_privilege:
0457   0217 0A 0B 02      jmp syscall_reboot
0458   021A DA            push d
0459   021B 3B CC 08      mov d, s_priviledge
0460   021E 07 AA 06      call _puts
0461   0221 E7            pop d
0462   0222 06            sysret
0463   0223             
0464   0223             ; ------------------------------------------------------------------------------------------------------------------;
0465   0223             ; divide by zero exception
0466   0223             ; ------------------------------------------------------------------------------------------------------------------;
0467   0223             trap_div_zero:
0468   0223 D7            push a
0469   0224 DA            push d
0470   0225 E1            pushf
0471   0226 3B E3 08      mov d, s_divzero
0472   0229 07 AA 06      call _puts
0473   022C EE            popf
0474   022D E7            pop d
0475   022E E4            pop a
0476   022F 06            sysret ; enable interrupts
0477   0230             
0478   0230             ; ------------------------------------------------------------------------------------------------------------------;
0479   0230             ; undefined opcode exception
0480   0230             ; ------------------------------------------------------------------------------------------------------------------;
0481   0230             trap_undef_opcode:
0482   0230 06            sysret
0483   0231             
0484   0231             
0485   0231             
0486   0231             ;----------------------------------------------------------------------------------------------------;
0487   0231             ; IO Syscall
0488   0231             ;----------------------------------------------------------------------------------------------------;
0489   0231             ; Baud  Divisor
0490   0231             ; 50    2304
0491   0231             ; 110   1047
0492   0231             ; 300    384
0493   0231             ; 600    192
0494   0231             ; 1200    96
0495   0231             ; 9600    12
0496   0231             ; 19200    6
0497   0231             ; 38400    3
0498   0231             syscall_io_jmp:
0499   0231 64 02         .dw syscall_io_putchar
0500   0233 71 02         .dw syscall_io_getch
0501   0235 3B 02         .dw syscall_io_uart_setup
0502   0237             syscall_io:
0503   0237 FD 0A 31 02   jmp [syscall_io_jmp + al]
0504   023B             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0505   023B             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0506   023B             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0507   023B             syscall_io_uart_setup:
0508   023B 1D A6 08      mov al, [sys_uart0_lcr]
0509   023E 8B 80         or al, $80                ; set DLAB access bit
0510   0240 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0511   0243 1D A9 08      mov al, [sys_uart0_div0]
0512   0246 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0513   0249 1D AA 08      mov al, [sys_uart0_div1]
0514   024C 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0515   024F             
0516   024F 1D A6 08      mov al, [sys_uart0_lcr]
0517   0252 87 7F         and al, $7F               ; clear DLAB access bit 
0518   0254 3D 83 FF      mov [_UART0_LCR], al
0519   0257 1D A7 08      mov al, [sys_uart0_inten]
0520   025A 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0521   025D 1D A8 08      mov al, [sys_uart0_fifoen]
0522   0260 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0523   0263 06            sysret
0524   0264             
0525   0264             ; char in ah
0526   0264             syscall_io_putchar:
0527   0264             syscall_io_putchar_L0:
0528   0264 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0529   0267 87 20         and al, $20
0530   0269 C6 64 02      jz syscall_io_putchar_L0    
0531   026C 1A            mov al, ah
0532   026D 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0533   0270 06            sysret
0534   0271             
0535   0271             ; char in ah
0536   0271             ; al = sucess code
0537   0271             syscall_io_getch:
0538   0271 D8            push b
0539   0272 DA            push d
0540   0273 FD 0C         sti
0541   0275             syscall_io_getch_L0:  
0542   0275 14 AD 08      mov a, [fifo_out]
0543   0278 29 AB 08      mov b, [fifo_in]
0544   027B B0            cmp a, b
0545   027C C6 75 02      je syscall_io_getch_L0
0546   027F 3C            mov d, a
0547   0280 77            inc a
0548   0281 AF 41 0F      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0549   0284 C7 8A 02      jne syscall_io_getch_cont
0550   0287 10 41 0B      mov a, fifo  
0551   028A             syscall_io_getch_cont:  
0552   028A 42 AD 08      mov [fifo_out], a             ; update fifo pointer
0553   028D 1E            mov al, [d]                   ; get char
0554   028E 23            mov ah, al
0555   028F 1D A5 08      mov al, [sys_echo_on]
0556   0292 B9 01         cmp al, 1
0557   0294 C7 A3 02      jne syscall_io_getch_noecho 
0558   0297             ; here we just echo the char back to the console
0559   0297             syscall_io_getch_echo_L0:
0560   0297 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0561   029A 87 20         and al, $20                 ; isolate Transmitter Empty
0562   029C C6 97 02      jz syscall_io_getch_echo_L0
0563   029F 1A            mov al, ah
0564   02A0 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0565   02A3             syscall_io_getch_noecho:
0566   02A3 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0567   02A5 E7            pop d
0568   02A6 E5            pop b
0569   02A7 06            sysret
0570   02A8             
0571   02A8             
0572   02A8             
0573   02A8             
0574   02A8             
0575   02A8             
0576   02A8             ; ---------------------------------------------------------------------
0577   02A8             ; kernel reset vector
0578   02A8             ; ---------------------------------------------------------------------
0579   02A8             kernel_reset_vector:  
0580   02A8 FD 49 FF F7   mov bp, STACK_BEGIN
0581   02AC FD 47 FF F7   mov sp, STACK_BEGIN
0582   02B0               
0583   02B0 19 80         mov al, %10000000             ; mask out timer interrupt
0584   02B2 FD 0F         stomsk                        
0585   02B4 FD 0C         sti  
0586   02B6             
0587   02B6 0C            lodstat
0588   02B7 87 DF         and al, %11011111             ; disable display register loading
0589   02B9 0D            stostat
0590   02BA               
0591   02BA             ; reset fifo pointers
0592   02BA 10 41 0B      mov a, fifo
0593   02BD 3B AB 08      mov d, fifo_in
0594   02C0 43            mov [d], a
0595   02C1 3B AD 08      mov d, fifo_out
0596   02C4 43            mov [d], a  
0597   02C5 19 02         mov al, 2
0598   02C7 05 00         syscall sys_io                ; enable uart in interrupt mode
0599   02C9               
0600   02C9 3B AF 08      mov d, s_kernel_started
0601   02CC 07 AA 06      call _puts
0602   02CF             
0603   02CF 3B 72 04      mov d, str0
0604   02D2 07 AA 06      call _puts
0605   02D5               ; First, select drive 1 and de-select drive 0
0606   02D5 3B C0 FF      mov d, $FFC0
0607   02D8 2E 0D         mov bl, %00001101     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0608   02DA FD 3E         mov [d], bl
0609   02DC             
0610   02DC             menu:
0611   02DC 3B FE 03      mov d, s_menu
0612   02DF 07 AA 06      call _puts
0613   02E2 07 77 05      call getch
0614   02E5 76 30         cmp ah, '0'
0615   02E7 C6 0B 03      je step_in
0616   02EA 76 31         cmp ah, '1'
0617   02EC C6 23 03      je step_out
0618   02EF 76 32         cmp ah, '2'
0619   02F1 C6 17 03      je restore
0620   02F4 76 33         cmp ah, '3'
0621   02F6 C6 2F 03      je status1
0622   02F9 76 34         cmp ah, '4'
0623   02FB C6 41 03      je status2
0624   02FE 76 35         cmp ah, '5'
0625   0300 C6 53 03      je format
0626   0303 76 36         cmp ah, '6'
0627   0305 C6 6A 03      je read
0628   0308 0A DC 02      jmp menu
0629   030B             step_in:
0630   030B 3B C8 FF      mov d, $FFC8    ; wd1770
0631   030E 19 02         mov al, 2       ; setparam call
0632   0310 2E 53         mov bl, %01010011     ; step in
0633   0312 FD 3E         mov [d], bl
0634   0314 0A DC 02      jmp menu
0635   0317             restore:
0636   0317             ; send restore command
0637   0317 3B C8 FF      mov d, $FFC8    ; wd1770
0638   031A 19 02         mov al, 2       ; setparam call
0639   031C 2E 03         mov bl, $03     ; restore command, 30ms rate
0640   031E FD 3E         mov [d], bl
0641   0320 0A DC 02      jmp menu
0642   0323             step_out:
0643   0323 3B C8 FF      mov d, $FFC8    ; wd1770
0644   0326 19 02         mov al, 2       ; setparam call
0645   0328 2E 73         mov bl, %01110011     ; step out
0646   032A FD 3E         mov [d], bl
0647   032C 0A DC 02      jmp menu
0648   032F             status1:
0649   032F 07 57 06      call printnl
0650   0332 3B C1 FF      mov d, $FFC1    ; wd1770 status 1
0651   0335 19 04         mov al, 4       ; getparam call
0652   0337 32            mov bl, [d]
0653   0338 07 4A 07      call print_u8x   ; print bl
0654   033B 07 57 06      call printnl
0655   033E 0A DC 02      jmp menu
0656   0341             status2:
0657   0341 07 57 06      call printnl
0658   0344 3B C8 FF      mov d, $FFC8    ; wd1770 status 
0659   0347 19 04         mov al, 4       ; getparam call
0660   0349 32            mov bl, [d]
0661   034A 07 4A 07      call print_u8x   ; print bl
0662   034D 07 57 06      call printnl
0663   0350 0A DC 02      jmp menu
0664   0353             format:
0665   0353 3B F5 03      mov d, s_track
0666   0356 07 AA 06      call _puts
0667   0359 07 95 07      call scan_u8x   ; in al
0668   035C 2F            mov bl, al      ; track needs to be in bl
0669   035D 19 00         mov al, 0       ; 0 = format
0670   035F 05 02         syscall sys_fdc 
0671   0361 3B EA 01      mov d, s_format_done
0672   0364 07 AA 06      call _puts
0673   0367 0A DC 02      jmp menu
0674   036A             read:
0675   036A 05 03         syscall sys_fdc_read
0676   036C 0A DC 02      jmp menu
0677   036F             
0678   036F             
0679   036F             cmd_hexd:
0680   036F 10 41 11      mov a, transient_area
0681   0372 42 F1 03      mov [start], a
0682   0375 10 01 0C      mov a, 3073
0683   0378 42 F3 03      mov [length], a
0684   037B             
0685   037B 14 F1 03    	mov a, [start]
0686   037E 3C            mov d, a        ; dump pointer in d
0687   037F 38 00 00      mov c, 0
0688   0382             dump_loop:
0689   0382 84            mov al, cl
0690   0383 87 0F         and al, $0F
0691   0385 C6 D4 03      jz print_base
0692   0388             back:
0693   0388 1E            mov al, [d]        ; read byte
0694   0389 2F            mov bl, al
0695   038A 07 4A 07      call print_u8x
0696   038D 10 00 20      mov a, $2000
0697   0390 05 00         syscall sys_io      ; space
0698   0392 84            mov al, cl
0699   0393 87 0F         and al, $0F
0700   0395 B9 0F         cmp al, $0F
0701   0397 C6 AE 03      je print_ascii
0702   039A             back1:
0703   039A 79            inc d
0704   039B 78            inc c
0705   039C 14 F3 03      mov a, [length]
0706   039F B1            cmp a, c
0707   03A0 C7 82 03      jne dump_loop
0708   03A3               
0709   03A3 10 00 0A      mov a, $0A00
0710   03A6 05 00         syscall sys_io
0711   03A8 10 00 0D      mov a, $0D00
0712   03AB 05 00         syscall sys_io
0713   03AD               ;call printnl
0714   03AD             
0715   03AD 09            ret
0716   03AE             print_ascii:
0717   03AE 63 10 00      sub d, 16
0718   03B1 26 10 00      mov b, 16
0719   03B4             print_ascii_L:
0720   03B4 79            inc d
0721   03B5 1E            mov al, [d]        ; read byte
0722   03B6 B9 20         cmp al, $20
0723   03B8 C8 C0 03      jlu dot
0724   03BB B9 7E         cmp al, $7E
0725   03BD D0 C8 03      jleu ascii
0726   03C0             dot:
0727   03C0 10 00 2E      mov a, $2E00
0728   03C3 05 00         syscall sys_io
0729   03C5 0A CD 03      jmp ascii_continue
0730   03C8             ascii:
0731   03C8 23            mov ah, al
0732   03C9 19 00         mov al, 0
0733   03CB 05 00         syscall sys_io
0734   03CD             ascii_continue:
0735   03CD FD A9 B4 03   loopb print_ascii_L
0736   03D1 0A 9A 03      jmp back1
0737   03D4             print_base:
0738   03D4 10 00 0A      mov a, $0A00
0739   03D7 05 00         syscall sys_io
0740   03D9 10 00 0D      mov a, $0D00
0741   03DC 05 00         syscall sys_io
0742   03DE 2D            mov b, d
0743   03DF 61 41 11      sub b, transient_area
0744   03E2 07 06 07      call print_u16x        ; display row
0745   03E5 55 41 11      add b, transient_area
0746   03E8 10 00 20      mov a, $2000
0747   03EB 05 00         syscall sys_io
0748   03ED 0A 88 03      jmp back
0749   03F0             
0750   03F0 09            ret
0751   03F1             
0752   03F1 00 00       start:  .dw 0
0753   03F3 00 04       length: .dw 1024
0754   03F5             
0755   03F5             
0756   03F5 0A 74 72 61 s_track: .db "\ntrack: ", 0
0756   03F9 63 6B 3A 20 
0756   03FD 00 
0757   03FE             
0758   03FE 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0758   0402 73 74 65 70 
0758   0406 20 69 6E 0A 
0759   040A 31 2E 20 73         .db "1. step out\n", 
0759   040E 74 65 70 20 
0759   0412 6F 75 74 0A 
0760   0416 32 2E 20 72         .db "2. restore\n", 
0760   041A 65 73 74 6F 
0760   041E 72 65 0A 
0761   0421 33 2E 20 72         .db "3. read status 1\n", 
0761   0425 65 61 64 20 
0761   0429 73 74 61 74 
0761   042D 75 73 20 31 
0761   0431 0A 
0762   0432 34 2E 20 72         .db "4. read status 2\n", 
0762   0436 65 61 64 20 
0762   043A 73 74 61 74 
0762   043E 75 73 20 32 
0762   0442 0A 
0763   0443 35 2E 20 66         .db "5. format track\n", 
0763   0447 6F 72 6D 61 
0763   044B 74 20 74 72 
0763   044F 61 63 6B 0A 
0764   0453 36 2E 20 72         .db "6. read track\n", 
0764   0457 65 61 64 20 
0764   045B 74 72 61 63 
0764   045F 6B 0A 
0765   0461 0A 73 65 6C         .db "\nselect option: ", 0
0765   0465 65 63 74 20 
0765   0469 6F 70 74 69 
0765   046D 6F 6E 3A 20 
0765   0471 00 
0766   0472             
0767   0472 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0767   0476 65 63 74 69 
0767   047A 6E 67 20 64 
0767   047E 72 69 76 65 
0767   0482 20 31 2E 2E 
0767   0486 2E 0A 00 
0768   0489 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0768   048D 74 69 6E 67 
0768   0491 2E 2E 2E 0A 
0768   0495 00 
0769   0496             
0770   0496             
0771   0496             
0772   0496             ; FILE INCLUDES
0773   0496             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0496             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0496             IDE_buffer       .EQU  $8204
0003+  0496             boot_origin      .EQU  $8004
0004+  0496             bios_uart        .EQU  $0002
0005+  0496             bios_ide         .EQU  $0003
0774   0496             .include "lib/stdio.asm"
0001+  0496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0496             ; stdio.s
0003+  0496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0496             .include "lib/string.asm"
0001++ 0496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0496             ; string.s
0003++ 0496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0496             
0005++ 0496             
0006++ 0496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0496             ; _strrev
0008++ 0496             ; reverse a string
0009++ 0496             ; D = string address
0010++ 0496             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0496             ; 01234
0012++ 0496             _strrev:
0013++ 0496 4B          	pusha
0014++ 0497 07 DD 04    	call _strlen	; length in C
0015++ 049A 12          	mov a, c
0016++ 049B AF 01 00    	cmp a, 1
0017++ 049E D0 B8 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04A1 7D          	dec a
0019++ 04A2 FD 4E       	mov si, d	; beginning of string
0020++ 04A4 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04A6 59          	add d, a	; end of string
0022++ 04A7 12          	mov a, c
0023++ 04A8 FD 9B       	shr a		; divide by 2
0024++ 04AA 39          	mov c, a	; C now counts the steps
0025++ 04AB             _strrev_L0:
0026++ 04AB 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04AC F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04AD 3E          	mov [d], al	; store left char into right side
0029++ 04AE 1B          	mov al, bl
0030++ 04AF F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04B0 7E          	dec c
0032++ 04B1 7F          	dec d
0033++ 04B2 C2 00 00    	cmp c, 0
0034++ 04B5 C7 AB 04    	jne _strrev_L0
0035++ 04B8             _strrev_end:
0036++ 04B8 4C          	popa
0037++ 04B9 09          	ret
0038++ 04BA             	
0039++ 04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04BA             ; _strchr
0041++ 04BA             ; search string in D for char in AL
0042++ 04BA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04BA             _strchr:
0044++ 04BA             _strchr_L0:
0045++ 04BA 32          	mov bl, [d]
0046++ 04BB C1 00       	cmp bl, 0
0047++ 04BD C6 C8 04    	je _strchr_end
0048++ 04C0 BA          	cmp al, bl
0049++ 04C1 C6 C8 04    	je _strchr_end
0050++ 04C4 79          	inc d
0051++ 04C5 0A BA 04    	jmp _strchr_L0
0052++ 04C8             _strchr_end:
0053++ 04C8 1B          	mov al, bl
0054++ 04C9 09          	ret
0055++ 04CA             
0056++ 04CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 04CA             ; _strstr
0058++ 04CA             ; find sub-string
0059++ 04CA             ; str1 in SI
0060++ 04CA             ; str2 in DI
0061++ 04CA             ; SI points to end of source string
0062++ 04CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 04CA             _strstr:
0064++ 04CA DB          	push al
0065++ 04CB DA          	push d
0066++ 04CC E3          	push di
0067++ 04CD             _strstr_loop:
0068++ 04CD F3          	cmpsb					; compare a byte of the strings
0069++ 04CE C7 D9 04    	jne _strstr_ret
0070++ 04D1 FC 00 00    	lea d, [di + 0]
0071++ 04D4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 04D6 C7 CD 04    	jne _strstr_loop				; equal chars but not at end
0073++ 04D9             _strstr_ret:
0074++ 04D9 F0          	pop di
0075++ 04DA E7          	pop d
0076++ 04DB E8          	pop al
0077++ 04DC 09          	ret
0078++ 04DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 04DD             ; length of null terminated string
0080++ 04DD             ; result in C
0081++ 04DD             ; pointer in D
0082++ 04DD             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 04DD             _strlen:
0084++ 04DD DA          	push d
0085++ 04DE 38 00 00    	mov c, 0
0086++ 04E1             _strlen_L1:
0087++ 04E1 BD 00       	cmp byte [d], 0
0088++ 04E3 C6 EB 04    	je _strlen_ret
0089++ 04E6 79          	inc d
0090++ 04E7 78          	inc c
0091++ 04E8 0A E1 04    	jmp _strlen_L1
0092++ 04EB             _strlen_ret:
0093++ 04EB E7          	pop d
0094++ 04EC 09          	ret
0095++ 04ED             
0096++ 04ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 04ED             ; STRCMP
0098++ 04ED             ; compare two strings
0099++ 04ED             ; str1 in SI
0100++ 04ED             ; str2 in DI
0101++ 04ED             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 04ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 04ED             _strcmp:
0104++ 04ED DB          	push al
0105++ 04EE DA          	push d
0106++ 04EF E3          	push di
0107++ 04F0 E2          	push si
0108++ 04F1             _strcmp_loop:
0109++ 04F1 F3          	cmpsb					; compare a byte of the strings
0110++ 04F2 C7 FD 04    	jne _strcmp_ret
0111++ 04F5 FB FF FF    	lea d, [si +- 1]
0112++ 04F8 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 04FA C7 F1 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 04FD             _strcmp_ret:
0115++ 04FD EF          	pop si
0116++ 04FE F0          	pop di
0117++ 04FF E7          	pop d
0118++ 0500 E8          	pop al
0119++ 0501 09          	ret
0120++ 0502             
0121++ 0502             
0122++ 0502             ; STRCPY
0123++ 0502             ; copy null terminated string from SI to DI
0124++ 0502             ; source in SI
0125++ 0502             ; destination in DI
0126++ 0502             _strcpy:
0127++ 0502 E2          	push si
0128++ 0503 E3          	push di
0129++ 0504 DB          	push al
0130++ 0505             _strcpy_L1:
0131++ 0505 F6          	lodsb
0132++ 0506 F7          	stosb
0133++ 0507 B9 00       	cmp al, 0
0134++ 0509 C7 05 05    	jne _strcpy_L1
0135++ 050C             _strcpy_end:
0136++ 050C E8          	pop al
0137++ 050D F0          	pop di
0138++ 050E EF          	pop si
0139++ 050F 09          	ret
0140++ 0510             
0141++ 0510             ; STRCAT
0142++ 0510             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0510             ; source in SI
0144++ 0510             ; destination in DI
0145++ 0510             _strcat:
0146++ 0510 E2          	push si
0147++ 0511 E3          	push di
0148++ 0512 D7          	push a
0149++ 0513 DA          	push d
0150++ 0514 50          	mov a, di
0151++ 0515 3C          	mov d, a
0152++ 0516             _strcat_goto_end_L1:
0153++ 0516 BD 00       	cmp byte[d], 0
0154++ 0518 C6 1F 05    	je _strcat_start
0155++ 051B 79          	inc d
0156++ 051C 0A 16 05    	jmp _strcat_goto_end_L1
0157++ 051F             _strcat_start:
0158++ 051F FD 50       	mov di, d
0159++ 0521             _strcat_L1:
0160++ 0521 F6          	lodsb
0161++ 0522 F7          	stosb
0162++ 0523 B9 00       	cmp al, 0
0163++ 0525 C7 21 05    	jne _strcat_L1
0164++ 0528             _strcat_end:
0165++ 0528 E7          	pop d
0166++ 0529 E4          	pop a
0167++ 052A F0          	pop di
0168++ 052B EF          	pop si
0169++ 052C 09          	ret
0170++ 052D             
0171++ 052D             
0005+  052D             
0006+  052D             
0007+  052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  052D             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  052D             ; ASCII in BL
0010+  052D             ; result in AL
0011+  052D             ; ascii for F = 0100 0110
0012+  052D             ; ascii for 9 = 0011 1001
0013+  052D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  052D             hex_ascii_encode:
0015+  052D 1B            mov al, bl
0016+  052E 93 40         test al, $40        ; test if letter or number
0017+  0530 C7 36 05      jnz hex_letter
0018+  0533 87 0F         and al, $0F        ; get number
0019+  0535 09            ret
0020+  0536             hex_letter:
0021+  0536 87 0F         and al, $0F        ; get letter
0022+  0538 6A 09         add al, 9
0023+  053A 09            ret
0024+  053B             
0025+  053B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  053B             ; ATOI
0027+  053B             ; 2 letter hex string in B
0028+  053B             ; 8bit integer returned in AL
0029+  053B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  053B             _atoi:
0031+  053B D8            push b
0032+  053C 07 2D 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  053F 30            mov bl, bh
0034+  0540 DB            push al          ; save a
0035+  0541 07 2D 05      call hex_ascii_encode
0036+  0544 EA            pop bl  
0037+  0545 FD 9E 04      shl al, 4
0038+  0548 8C            or al, bl
0039+  0549 E5            pop b
0040+  054A 09            ret  
0041+  054B             
0042+  054B             
0043+  054B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  054B             ; scanf
0045+  054B             ; no need for explanations!
0046+  054B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  054B             scanf:
0048+  054B 09            ret
0049+  054C             
0050+  054C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  054C             ; ITOA
0052+  054C             ; 8bit value in BL
0053+  054C             ; 2 byte ASCII result in A
0054+  054C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  054C             _itoa:
0056+  054C DA            push d
0057+  054D D8            push b
0058+  054E A7 00         mov bh, 0
0059+  0550 FD A4 04      shr bl, 4  
0060+  0553 74            mov d, b
0061+  0554 1F E6 07      mov al, [d + s_hex_digits]
0062+  0557 23            mov ah, al
0063+  0558               
0064+  0558 E5            pop b
0065+  0559 D8            push b
0066+  055A A7 00         mov bh, 0
0067+  055C FD 87 0F      and bl, $0F
0068+  055F 74            mov d, b
0069+  0560 1F E6 07      mov al, [d + s_hex_digits]
0070+  0563 E5            pop b
0071+  0564 E7            pop d
0072+  0565 09            ret
0073+  0566             
0074+  0566             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0566             ; HEX STRING TO BINARY
0076+  0566             ; di = destination address
0077+  0566             ; si = source
0078+  0566             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0566             _hex_to_int:
0080+  0566             _hex_to_int_L1:
0081+  0566 F6            lodsb          ; load from [SI] to AL
0082+  0567 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0569 C6 76 05      jz _hex_to_int_ret
0084+  056C 36            mov bh, al
0085+  056D F6            lodsb
0086+  056E 2F            mov bl, al
0087+  056F 07 3B 05      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  0572 F7            stosb          ; store AL to [DI]
0089+  0573 0A 66 05      jmp _hex_to_int_L1
0090+  0576             _hex_to_int_ret:
0091+  0576 09            ret    
0092+  0577             
0093+  0577             
0094+  0577             
0095+  0577             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0577             ; GETCHAR
0097+  0577             ; char in ah
0098+  0577             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0577             getch:
0100+  0577 DB            push al
0101+  0578             getch_retry:
0102+  0578 19 01         mov al, 1
0103+  057A 05 00         syscall sys_io      ; receive in AH
0104+  057C E8            pop al
0105+  057D 09            ret
0106+  057E             
0107+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  057E             ; PUTCHAR
0109+  057E             ; char in ah
0110+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  057E             _putchar:
0112+  057E DB            push al
0113+  057F 19 00         mov al, 0
0114+  0581 05 00         syscall sys_io      ; char in AH
0115+  0583 E8            pop al
0116+  0584 09            ret
0117+  0585             
0118+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0585             ;; INPUT A STRING
0120+  0585             ;; terminates with null
0121+  0585             ;; pointer in D
0122+  0585             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0585             _gets:
0124+  0585 D7            push a
0125+  0586 DA            push d
0126+  0587             _gets_loop:
0127+  0587 19 01         mov al, 1
0128+  0589 05 00         syscall sys_io      ; receive in AH
0129+  058B 76 1B         cmp ah, 27
0130+  058D C6 AE 05      je _gets_ansi_esc
0131+  0590 76 0A         cmp ah, $0A        ; LF
0132+  0592 C6 0A 06      je _gets_end
0133+  0595 76 0D         cmp ah, $0D        ; CR
0134+  0597 C6 0A 06      je _gets_end
0135+  059A 76 5C         cmp ah, $5C        ; '\\'
0136+  059C C6 D0 05      je _gets_escape
0137+  059F 76 08         cmp ah, $08      ; check for backspace
0138+  05A1 C6 AA 05      je _gets_backspace
0139+  05A4 1A            mov al, ah
0140+  05A5 3E            mov [d], al
0141+  05A6 79            inc d
0142+  05A7 0A 87 05      jmp _gets_loop
0143+  05AA             _gets_backspace:
0144+  05AA 7F            dec d
0145+  05AB 0A 87 05      jmp _gets_loop
0146+  05AE             _gets_ansi_esc:
0147+  05AE 19 01         mov al, 1
0148+  05B0 05 00         syscall sys_io        ; receive in AH without echo
0149+  05B2 76 5B         cmp ah, '['
0150+  05B4 C7 87 05      jne _gets_loop
0151+  05B7 19 01         mov al, 1
0152+  05B9 05 00         syscall sys_io          ; receive in AH without echo
0153+  05BB 76 44         cmp ah, 'D'
0154+  05BD C6 C8 05      je _gets_left_arrow
0155+  05C0 76 43         cmp ah, 'C'
0156+  05C2 C6 CC 05      je _gets_right_arrow
0157+  05C5 0A 87 05      jmp _gets_loop
0158+  05C8             _gets_left_arrow:
0159+  05C8 7F            dec d
0160+  05C9 0A 87 05      jmp _gets_loop
0161+  05CC             _gets_right_arrow:
0162+  05CC 79            inc d
0163+  05CD 0A 87 05      jmp _gets_loop
0164+  05D0             _gets_escape:
0165+  05D0 19 01         mov al, 1
0166+  05D2 05 00         syscall sys_io      ; receive in AH
0167+  05D4 76 6E         cmp ah, 'n'
0168+  05D6 C6 F5 05      je _gets_LF
0169+  05D9 76 72         cmp ah, 'r'
0170+  05DB C6 FC 05      je _gets_CR
0171+  05DE 76 30         cmp ah, '0'
0172+  05E0 C6 03 06      je _gets_NULL
0173+  05E3 76 5C         cmp ah, $5C  ; '\'
0174+  05E5 C6 EE 05      je _gets_slash
0175+  05E8 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  05E9 3E            mov [d], al
0177+  05EA 79            inc d
0178+  05EB 0A 87 05      jmp _gets_loop
0179+  05EE             _gets_slash:
0180+  05EE 19 5C         mov al, $5C
0181+  05F0 3E            mov [d], al
0182+  05F1 79            inc d
0183+  05F2 0A 87 05      jmp _gets_loop
0184+  05F5             _gets_LF:
0185+  05F5 19 0A         mov al, $0A
0186+  05F7 3E            mov [d], al
0187+  05F8 79            inc d
0188+  05F9 0A 87 05      jmp _gets_loop
0189+  05FC             _gets_CR:
0190+  05FC 19 0D         mov al, $0D
0191+  05FE 3E            mov [d], al
0192+  05FF 79            inc d
0193+  0600 0A 87 05      jmp _gets_loop
0194+  0603             _gets_NULL:
0195+  0603 19 00         mov al, $00
0196+  0605 3E            mov [d], al
0197+  0606 79            inc d
0198+  0607 0A 87 05      jmp _gets_loop
0199+  060A             _gets_end:
0200+  060A 19 00         mov al, 0
0201+  060C 3E            mov [d], al        ; terminate string
0202+  060D E7            pop d
0203+  060E E4            pop a
0204+  060F 09            ret
0205+  0610             
0206+  0610             
0207+  0610             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0610             ;; INPUT TEXT
0209+  0610             ;; terminated with CTRL+D
0210+  0610             ;; pointer in D
0211+  0610             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0610             _gettxt:
0213+  0610 D7            push a
0214+  0611 DA            push d
0215+  0612             _gettxt_loop:
0216+  0612 19 01         mov al, 1
0217+  0614 05 00         syscall sys_io      ; receive in AH
0218+  0616 76 04         cmp ah, 4      ; EOT
0219+  0618 C6 51 06      je _gettxt_end
0220+  061B 76 08         cmp ah, $08      ; check for backspace
0221+  061D C6 4D 06      je _gettxt_backspace
0222+  0620 76 5C         cmp ah, $5C        ; '\'
0223+  0622 C6 2B 06      je _gettxt_escape
0224+  0625 1A            mov al, ah
0225+  0626 3E            mov [d], al
0226+  0627 79            inc d
0227+  0628 0A 12 06      jmp _gettxt_loop
0228+  062B             _gettxt_escape:
0229+  062B 19 01         mov al, 1
0230+  062D 05 00         syscall sys_io      ; receive in AH
0231+  062F 76 6E         cmp ah, 'n'
0232+  0631 C6 3F 06      je _gettxt_LF
0233+  0634 76 72         cmp ah, 'r'
0234+  0636 C6 46 06      je _gettxt_CR
0235+  0639 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  063A 3E            mov [d], al
0237+  063B 79            inc d
0238+  063C 0A 12 06      jmp _gettxt_loop
0239+  063F             _gettxt_LF:
0240+  063F 19 0A         mov al, $0A
0241+  0641 3E            mov [d], al
0242+  0642 79            inc d
0243+  0643 0A 12 06      jmp _gettxt_loop
0244+  0646             _gettxt_CR:
0245+  0646 19 0D         mov al, $0D
0246+  0648 3E            mov [d], al
0247+  0649 79            inc d
0248+  064A 0A 12 06      jmp _gettxt_loop
0249+  064D             _gettxt_backspace:
0250+  064D 7F            dec d
0251+  064E 0A 12 06      jmp _gettxt_loop
0252+  0651             _gettxt_end:
0253+  0651 19 00         mov al, 0
0254+  0653 3E            mov [d], al        ; terminate string
0255+  0654 E7            pop d
0256+  0655 E4            pop a
0257+  0656 09            ret
0258+  0657             
0259+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0657             ; PRINT NEW LINE
0261+  0657             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0657             printnl:
0263+  0657 D7            push a
0264+  0658 10 00 0A      mov a, $0A00
0265+  065B 05 00         syscall sys_io
0266+  065D 10 00 0D      mov a, $0D00
0267+  0660 05 00         syscall sys_io
0268+  0662 E4            pop a
0269+  0663 09            ret
0270+  0664             
0271+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0664             ; _strtoint
0273+  0664             ; 4 digit hex string number in d
0274+  0664             ; integer returned in A
0275+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0664             _strtointx:
0277+  0664 D8            push b
0278+  0665 32            mov bl, [d]
0279+  0666 37            mov bh, bl
0280+  0667 33 01 00      mov bl, [d + 1]
0281+  066A 07 3B 05      call _atoi        ; convert to int in AL
0282+  066D 23            mov ah, al        ; move to AH
0283+  066E 33 02 00      mov bl, [d + 2]
0284+  0671 37            mov bh, bl
0285+  0672 33 03 00      mov bl, [d + 3]
0286+  0675 07 3B 05      call _atoi        ; convert to int in AL
0287+  0678 E5            pop b
0288+  0679 09            ret
0289+  067A             
0290+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  067A             ; _strtoint
0292+  067A             ; 5 digit base10 string number in d
0293+  067A             ; integer returned in A
0294+  067A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  067A             _strtoint:
0296+  067A E2            push si
0297+  067B D8            push b
0298+  067C D9            push c
0299+  067D DA            push d
0300+  067E 07 DD 04      call _strlen      ; get string length in C
0301+  0681 7E            dec c
0302+  0682 FD 4E         mov si, d
0303+  0684 12            mov a, c
0304+  0685 FD 99         shl a
0305+  0687 3B FE 07      mov d, table_power
0306+  068A 59            add d, a
0307+  068B 38 00 00      mov c, 0
0308+  068E             _strtoint_L0:
0309+  068E F6            lodsb      ; load ASCII to al
0310+  068F B9 00         cmp al, 0
0311+  0691 C6 A4 06      je _strtoint_end
0312+  0694 6F 30         sub al, $30    ; make into integer
0313+  0696 22 00         mov ah, 0
0314+  0698 2A            mov b, [d]
0315+  0699 AC            mul a, b      ; result in B since it fits in 16bits
0316+  069A 11            mov a, b
0317+  069B 28            mov b, c
0318+  069C 54            add a, b
0319+  069D 39            mov c, a
0320+  069E 63 02 00      sub d, 2
0321+  06A1 0A 8E 06      jmp _strtoint_L0
0322+  06A4             _strtoint_end:
0323+  06A4 12            mov a, c
0324+  06A5 E7            pop d
0325+  06A6 E6            pop c
0326+  06A7 E5            pop b
0327+  06A8 EF            pop si
0328+  06A9 09            ret
0329+  06AA             
0330+  06AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  06AA             ; PRINT NULL TERMINATED STRING
0332+  06AA             ; pointer in D
0333+  06AA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  06AA             _puts:
0335+  06AA D7            push a
0336+  06AB DA            push d
0337+  06AC             _puts_L1:
0338+  06AC 1E            mov al, [d]
0339+  06AD B9 00         cmp al, 0
0340+  06AF C6 BB 06      jz _puts_END
0341+  06B2 23            mov ah, al
0342+  06B3 19 00         mov al, 0
0343+  06B5 05 00         syscall sys_io
0344+  06B7 79            inc d
0345+  06B8 0A AC 06      jmp _puts_L1
0346+  06BB             _puts_END:
0347+  06BB E7            pop d
0348+  06BC E4            pop a
0349+  06BD 09            ret
0350+  06BE             
0351+  06BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  06BE             ; PRINT N SIZE STRING
0353+  06BE             ; pointer in D
0354+  06BE             ; size in C
0355+  06BE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  06BE             _putsn:
0357+  06BE DB            push al
0358+  06BF DA            push d
0359+  06C0 D9            push c
0360+  06C1             _putsn_L0:
0361+  06C1 1E            mov al, [d]
0362+  06C2 23            mov ah, al
0363+  06C3 19 00         mov al, 0
0364+  06C5 05 00         syscall sys_io
0365+  06C7 79            inc d
0366+  06C8 7E            dec c  
0367+  06C9 C2 00 00      cmp c, 0
0368+  06CC C7 C1 06      jne _putsn_L0
0369+  06CF             _putsn_end:
0370+  06CF E6            pop c
0371+  06D0 E7            pop d
0372+  06D1 E8            pop al
0373+  06D2 09            ret
0374+  06D3             
0375+  06D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  06D3             ; print 16bit decimal number
0377+  06D3             ; input number in A
0378+  06D3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  06D3             print_u16d:
0380+  06D3 D7            push a
0381+  06D4 D8            push b
0382+  06D5 FD D8         push g
0383+  06D7 26 10 27      mov b, 10000
0384+  06DA AE            div a, b      ; get 10000's coeff.
0385+  06DB 07 FF 06      call print_number
0386+  06DE 11            mov a, b
0387+  06DF 26 E8 03      mov b, 1000
0388+  06E2 AE            div a, b      ; get 1000's coeff.
0389+  06E3 07 FF 06      call print_number
0390+  06E6 11            mov a, b
0391+  06E7 26 64 00      mov b, 100
0392+  06EA AE            div a, b
0393+  06EB 07 FF 06      call print_number
0394+  06EE 11            mov a, b
0395+  06EF 26 0A 00      mov b, 10
0396+  06F2 AE            div a, b
0397+  06F3 07 FF 06      call print_number
0398+  06F6 1B            mov al, bl      ; 1's coeff in bl
0399+  06F7 07 FF 06      call print_number
0400+  06FA FD F1         pop g
0401+  06FC E5            pop b
0402+  06FD E4            pop a
0403+  06FE 09            ret
0404+  06FF             
0405+  06FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  06FF             ; print AL
0407+  06FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  06FF             print_number:
0409+  06FF 6A 30         add al, $30
0410+  0701 23            mov ah, al
0411+  0702 07 7E 05      call _putchar
0412+  0705 09            ret
0413+  0706             
0414+  0706             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0706             ; PRINT 16BIT HEX INTEGER
0416+  0706             ; integer value in reg B
0417+  0706             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0706             print_u16x:
0419+  0706 D7            push a
0420+  0707 D8            push b
0421+  0708 DD            push bl
0422+  0709 30            mov bl, bh
0423+  070A 07 4C 05      call _itoa        ; convert bh to char in A
0424+  070D 2F            mov bl, al        ; save al
0425+  070E 19 00         mov al, 0
0426+  0710 05 00         syscall sys_io        ; display AH
0427+  0712 24            mov ah, bl        ; retrieve al
0428+  0713 19 00         mov al, 0
0429+  0715 05 00         syscall sys_io        ; display AL
0430+  0717             
0431+  0717 EA            pop bl
0432+  0718 07 4C 05      call _itoa        ; convert bh to char in A
0433+  071B 2F            mov bl, al        ; save al
0434+  071C 19 00         mov al, 0
0435+  071E 05 00         syscall sys_io        ; display AH
0436+  0720 24            mov ah, bl        ; retrieve al
0437+  0721 19 00         mov al, 0
0438+  0723 05 00         syscall sys_io        ; display AL
0439+  0725             
0440+  0725 E5            pop b
0441+  0726 E4            pop a
0442+  0727 09            ret
0443+  0728             
0444+  0728             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0728             ; INPUT 16BIT HEX INTEGER
0446+  0728             ; read 16bit integer into A
0447+  0728             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0728             scan_u16x:
0449+  0728 F8 10 00      enter 16
0450+  072B D8            push b
0451+  072C DA            push d
0452+  072D             
0453+  072D FA F1 FF      lea d, [bp + -15]
0454+  0730 07 85 05      call _gets        ; get number
0455+  0733             
0456+  0733 32            mov bl, [d]
0457+  0734 37            mov bh, bl
0458+  0735 33 01 00      mov bl, [d + 1]
0459+  0738 07 3B 05      call _atoi        ; convert to int in AL
0460+  073B 23            mov ah, al        ; move to AH
0461+  073C             
0462+  073C 33 02 00      mov bl, [d + 2]
0463+  073F 37            mov bh, bl
0464+  0740 33 03 00      mov bl, [d + 3]
0465+  0743 07 3B 05      call _atoi        ; convert to int in AL
0466+  0746             
0467+  0746 E7            pop d
0468+  0747 E5            pop b
0469+  0748 F9            leave
0470+  0749 09            ret
0471+  074A             
0472+  074A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  074A             ; PRINT 8bit HEX INTEGER
0474+  074A             ; integer value in reg bl
0475+  074A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  074A             print_u8x:
0477+  074A D7            push a
0478+  074B DD            push bl
0479+  074C             
0480+  074C 07 4C 05      call _itoa        ; convert bl to char in A
0481+  074F 2F            mov bl, al        ; save al
0482+  0750 19 00         mov al, 0
0483+  0752 05 00         syscall sys_io        ; display AH
0484+  0754 24            mov ah, bl        ; retrieve al
0485+  0755 19 00         mov al, 0
0486+  0757 05 00         syscall sys_io        ; display AL
0487+  0759             
0488+  0759 EA            pop bl
0489+  075A E4            pop a
0490+  075B 09            ret
0491+  075C             
0492+  075C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  075C             ; print 8bit decimal unsigned number
0494+  075C             ; input number in AL
0495+  075C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  075C             print_u8d:
0497+  075C D7            push a
0498+  075D D8            push b
0499+  075E FD D8         push g
0500+  0760 22 00         mov ah, 0
0501+  0762 26 64 00      mov b, 100
0502+  0765 AE            div a, b
0503+  0766 D8            push b      ; save remainder
0504+  0767 B9 00         cmp al, 0
0505+  0769 C6 73 07      je skip100
0506+  076C 6A 30         add al, $30
0507+  076E 23            mov ah, al
0508+  076F 19 00         mov al, 0
0509+  0771 05 00         syscall sys_io  ; print coeff
0510+  0773             skip100:
0511+  0773 E4            pop a
0512+  0774 22 00         mov ah, 0
0513+  0776 26 0A 00      mov b, 10
0514+  0779 AE            div a, b
0515+  077A D8            push b      ; save remainder
0516+  077B B9 00         cmp al, 0
0517+  077D C6 87 07      je skip10
0518+  0780 6A 30         add al, $30
0519+  0782 23            mov ah, al
0520+  0783 19 00         mov al, 0
0521+  0785 05 00         syscall sys_io  ; print coeff
0522+  0787             skip10:
0523+  0787 E4            pop a
0524+  0788 1B            mov al, bl
0525+  0789 6A 30         add al, $30
0526+  078B 23            mov ah, al
0527+  078C 19 00         mov al, 0
0528+  078E 05 00         syscall sys_io  ; print coeff
0529+  0790 FD F1         pop g
0530+  0792 E5            pop b
0531+  0793 E4            pop a
0532+  0794 09            ret
0533+  0795             
0534+  0795             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0795             ; INPUT 8BIT HEX INTEGER
0536+  0795             ; read 8bit integer into AL
0537+  0795             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0795             scan_u8x:
0539+  0795 F8 04 00      enter 4
0540+  0798 D8            push b
0541+  0799 DA            push d
0542+  079A             
0543+  079A FA FD FF      lea d, [bp + -3]
0544+  079D 07 85 05      call _gets        ; get number
0545+  07A0             
0546+  07A0 32            mov bl, [d]
0547+  07A1 37            mov bh, bl
0548+  07A2 33 01 00      mov bl, [d + 1]
0549+  07A5 07 3B 05      call _atoi        ; convert to int in AL
0550+  07A8             
0551+  07A8 E7            pop d
0552+  07A9 E5            pop b
0553+  07AA F9            leave
0554+  07AB 09            ret
0555+  07AC             
0556+  07AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  07AC             ; input decimal number
0558+  07AC             ; result in A
0559+  07AC             ; 655'\0'
0560+  07AC             ; low--------high
0561+  07AC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  07AC             scan_u16d:
0563+  07AC F8 08 00      enter 8
0564+  07AF E2            push si
0565+  07B0 D8            push b
0566+  07B1 D9            push c
0567+  07B2 DA            push d
0568+  07B3 FA F9 FF      lea d, [bp +- 7]
0569+  07B6 07 85 05      call _gets
0570+  07B9 07 DD 04      call _strlen      ; get string length in C
0571+  07BC 7E            dec c
0572+  07BD FD 4E         mov si, d
0573+  07BF 12            mov a, c
0574+  07C0 FD 99         shl a
0575+  07C2 3B FE 07      mov d, table_power
0576+  07C5 59            add d, a
0577+  07C6 38 00 00      mov c, 0
0578+  07C9             mul_loop:
0579+  07C9 F6            lodsb      ; load ASCII to al
0580+  07CA B9 00         cmp al, 0
0581+  07CC C6 DF 07      je mul_exit
0582+  07CF 6F 30         sub al, $30    ; make into integer
0583+  07D1 22 00         mov ah, 0
0584+  07D3 2A            mov b, [d]
0585+  07D4 AC            mul a, b      ; result in B since it fits in 16bits
0586+  07D5 11            mov a, b
0587+  07D6 28            mov b, c
0588+  07D7 54            add a, b
0589+  07D8 39            mov c, a
0590+  07D9 63 02 00      sub d, 2
0591+  07DC 0A C9 07      jmp mul_loop
0592+  07DF             mul_exit:
0593+  07DF 12            mov a, c
0594+  07E0 E7            pop d
0595+  07E1 E6            pop c
0596+  07E2 E5            pop b
0597+  07E3 EF            pop si
0598+  07E4 F9            leave
0599+  07E5 09            ret
0600+  07E6             
0601+  07E6             
0602+  07E6 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  07EA 34 35 36 37 
0602+  07EE 38 39 41 42 
0602+  07F2 43 44 45 46 
0603+  07F6 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  07FA 1B 5B 48 00 
0604+  07FE             
0605+  07FE             table_power:
0606+  07FE 01 00         .dw 1
0607+  0800 0A 00         .dw 10
0608+  0802 64 00         .dw 100
0609+  0804 E8 03         .dw 1000
0610+  0806 10 27         .dw 100000775   0808             .include "lib/ctype.asm"
0001+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0808             ; ctype.s
0003+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0808             
0005+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0808             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0808             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0808             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0808             ;; characters are supported.
0010+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0808             ;; _isalnum 
0012+  0808             ;; _isalpha 
0013+  0808             ;; islower 
0014+  0808             ;; isupper 
0015+  0808             ;; _isdigit 
0016+  0808             ;; isxdigit
0017+  0808             ;; iscntrl 
0018+  0808             ;; isgraph 
0019+  0808             ;; _isspace 
0020+  0808             ;; isblank 
0021+  0808             ;; isprint 
0022+  0808             ;; ispunct 
0023+  0808             ;; tolower 
0024+  0808             ;; toupper
0025+  0808             
0026+  0808             
0027+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0808             ;; IS ALPHANUMERIC
0029+  0808             ;; sets ZF according with result
0030+  0808             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0808             _isalnum:
0032+  0808 07 25 08    	call _isalpha
0033+  080B C6 11 08    	je _isalnum_exit
0034+  080E 07 12 08    	call _isdigit
0035+  0811             _isalnum_exit:
0036+  0811 09          	ret	
0037+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0812             ;; IS DIGIT
0039+  0812             ;; sets ZF according with result
0040+  0812             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0812             _isdigit:
0042+  0812 DB          	push al
0043+  0813 B9 30       	cmp al, '0'
0044+  0815 C8 21 08    	jlu _isdigit_false
0045+  0818 B9 39       	cmp al, '9'
0046+  081A D1 21 08    	jgu _isdigit_false
0047+  081D 87 00       	and al, 0	; set ZF
0048+  081F E8          	pop al
0049+  0820 09          	ret
0050+  0821             _isdigit_false:
0051+  0821 8B 01       	or al, 1	; clear ZF
0052+  0823 E8          	pop al
0053+  0824 09          	ret	
0054+  0825             	
0055+  0825             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  0825             ;; IS ALPHA
0057+  0825             ;; sets ZF according with result
0058+  0825             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  0825             _isalpha:
0060+  0825 DB          	push al
0061+  0826 B9 5F       	cmp al, '_'
0062+  0828 C6 48 08    	je _isalpha_true
0063+  082B B9 2E       	cmp al, '.'
0064+  082D C6 48 08    	je _isalpha_true
0065+  0830 B9 41       	cmp al, 'A'
0066+  0832 C8 44 08    	jlu _isalpha_false
0067+  0835 B9 7A       	cmp al, 'z'
0068+  0837 D1 44 08    	jgu _isalpha_false
0069+  083A B9 5A       	cmp al, 'Z'
0070+  083C D0 48 08    	jleu _isalpha_true
0071+  083F B9 61       	cmp al, 'a'
0072+  0841 C9 48 08    	jgeu _isalpha_true
0073+  0844             _isalpha_false:
0074+  0844 8B 01       	or al, 1	; clear ZF
0075+  0846 E8          	pop al
0076+  0847 09          	ret
0077+  0848             _isalpha_true:
0078+  0848 87 00       	and al, 0	; set ZF
0079+  084A E8          	pop al
0080+  084B 09          	ret
0081+  084C             
0082+  084C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  084C             ;; IS PATH-ALPHA
0084+  084C             ;; sets ZF according with result
0085+  084C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  084C             ispath:
0087+  084C DB          	push al
0088+  084D 07 12 08    	call _isdigit
0089+  0850 C6 7A 08    	je ispath_true
0090+  0853 B9 5F       	cmp al, '_'
0091+  0855 C6 7A 08    	je ispath_true
0092+  0858 B9 2F       	cmp al, '/'
0093+  085A C6 7A 08    	je ispath_true
0094+  085D B9 2E       	cmp al, '.'
0095+  085F C6 7A 08    	je ispath_true
0096+  0862 B9 41       	cmp al, 'A'
0097+  0864 C8 76 08    	jlu ispath_false
0098+  0867 B9 7A       	cmp al, 'z'
0099+  0869 D1 76 08    	jgu ispath_false
0100+  086C B9 5A       	cmp al, 'Z'
0101+  086E D0 7A 08    	jleu ispath_true
0102+  0871 B9 61       	cmp al, 'a'
0103+  0873 C9 7A 08    	jgeu ispath_true
0104+  0876             ispath_false:
0105+  0876 8B 01       	or al, 1	; clear ZF
0106+  0878 E8          	pop al
0107+  0879 09          	ret
0108+  087A             ispath_true:
0109+  087A 87 00       	and al, 0	; set ZF
0110+  087C E8          	pop al
0111+  087D 09          	ret
0112+  087E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  087E             ;; IS SPACE
0114+  087E             ;; sets ZF according with result
0115+  087E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  087E             _isspace:
0117+  087E B9 20       	cmp al, $20		; ' '
0118+  0880 C6 94 08    	je _isspace_exit
0119+  0883 B9 09       	cmp al, $09		; '\t'
0120+  0885 C6 94 08    	je _isspace_exit
0121+  0888 B9 0A       	cmp al, $0A		; '\n'
0122+  088A C6 94 08    	je _isspace_exit
0123+  088D B9 0D       	cmp al, $0D		; '\r'
0124+  088F C6 94 08    	je _isspace_exit
0125+  0892 B9 0B       	cmp al, $0B		; '\v'
0126+  0894             _isspace_exit:
0127+  0894 09          	ret	
0128+  0895             
0129+  0895             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0895             ; TO LOWER
0131+  0895             ; input in AL
0132+  0895             ; output in AL
0133+  0895             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0895             _to_lower:
0135+  0895 B9 5A       	cmp al, 'Z'
0136+  0897 D1 9C 08    	jgu _to_lower_ret
0137+  089A 6A 20       	add al, $20				; convert to lower case
0138+  089C             _to_lower_ret:
0139+  089C 09          	ret
0140+  089D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  089D             ; TO UPPER
0142+  089D             ; input in AL
0143+  089D             ; output in AL
0144+  089D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  089D             _to_upper:
0146+  089D B9 61       	cmp al, 'a'
0147+  089F C8 A4 08    	jlu _to_upper_ret
0148+  08A2 6F 20       	sub al, $20			; convert to upper case
0149+  08A4             _to_upper_ret:
0150+  08A4 09          	ret
0151+  08A5             
0776   08A5             
0777   08A5             ; kernel parameters
0778   08A5             sys_echo_on:
0779   08A5 01            .db 1
0780   08A6             sys_uart0_lcr:
0781   08A6 07            .db $07 ; 8 data bits, 2 stop bit, no parity
0782   08A7             sys_uart0_inten:
0783   08A7 01            .db 1
0784   08A8             sys_uart0_fifoen:
0785   08A8 00            .db 0
0786   08A9             sys_uart0_div0:
0787   08A9 0C            .db 12  ;
0788   08AA             sys_uart0_div1:
0789   08AA 00            .db 0   ; default baud = 9600
0790   08AB             ; Baud  Divisor
0791   08AB             ; 50    2304
0792   08AB             ; 110   1047
0793   08AB             ; 300    384
0794   08AB             ; 600    192
0795   08AB             ; 1200    96
0796   08AB             ; 9600    12
0797   08AB             ; 19200    6
0798   08AB             ; 38400    3
0799   08AB             
0800   08AB             
0801   08AB             fifo_in:
0802   08AB 41 0B         .dw fifo
0803   08AD             fifo_out:
0804   08AD 41 0B         .dw fifo
0805   08AF             
0806   08AF             
0807   08AF             s_kernel_started:
0808   08AF 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
0808   08B3 65 6C 20 73 
0808   08B7 74 61 72 74 
0808   08BB 65 64 28 76 
0808   08BF 65 72 73 69 
0808   08C3 6F 6E 20 31 
0808   08C7 2E 30 29 0A 
0808   08CB 00 
0809   08CC             s_priviledge:
0810   08CC 0A 65 78 63   .db "\nexception: privilege\n", 0
0810   08D0 65 70 74 69 
0810   08D4 6F 6E 3A 20 
0810   08D8 70 72 69 76 
0810   08DC 69 6C 65 67 
0810   08E0 65 0A 00 
0811   08E3             s_divzero:
0812   08E3 0A 65 78 63   .db "\nexception: zero division\n", 0
0812   08E7 65 70 74 69 
0812   08EB 6F 6E 3A 20 
0812   08EF 7A 65 72 6F 
0812   08F3 20 64 69 76 
0812   08F7 69 73 69 6F 
0812   08FB 6E 0A 00 
0813   08FE             
0814   08FE             ; This is the format of a sector for the 128 byte per sector format.
0815   08FE             ; Write the bracketed data 16 times per track.
0816   08FE             ; The recommended single-density format with 128
0817   08FE             ; bytes/sector is shown. In order to format a diskette,
0818   08FE             ; the user issues the Write Track Command, and loads
0819   08FE             ; the Data Register with the following values. For every
0820   08FE             ; byte to be written, there is one Data Request.
0821   08FE             fdc_irq_event:
0822   08FE 00            .fill 1,  $00       ; keeps status of fdc irq event
0823   08FF             fdc_128_format:                                                                       
0824   08FF             fdc_40_FF:
0825   08FF FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
0825   0903 FF FF FF FF 
0825   0907 FF FF FF FF 
0825   090B FF FF FF FF 
0825   090F FF FF FF FF 
0825   0913 FF FF FF FF 
0825   0917 FF FF FF FF 
0825   091B FF FF FF FF 
0825   091F FF FF FF FF 
0825   0923 FF FF FF FF 
0826   0927             fdc_128_format_inner:
0827   0927 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
0827   092B 00 00 
0828   092D FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
0829   092E             fdc_128_format_track:
0830   092E 00            .fill 1,   $00    ; Track Number   0 thru 39                                                      |                    
0831   092F 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0832   0930             fdc_128_format_sect:
0833   0930 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0834   0931 00            .fill 1,   $00    ; Sector Length                                                                 |                        
0835   0932 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0836   0933 FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
0836   0937 FF FF FF FF 
0836   093B FF FF FF 
0837   093E 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
0837   0942 00 00 
0838   0944 FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0839   0945 E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0839   0949 E5 E5 E5 E5 
0839   094D E5 E5 E5 E5 
0839   0951 E5 E5 E5 E5 
0839   0955 E5 E5 E5 E5 
0839   0959 E5 E5 E5 E5 
0839   095D E5 E5 E5 E5 
0839   0961 E5 E5 E5 E5 
0839   0965 E5 E5 E5 E5 
0839   0969 E5 E5 E5 E5 
0839   096D E5 E5 E5 E5 
0839   0971 E5 E5 E5 E5 
0839   0975 E5 E5 E5 E5 
0839   0979 E5 E5 E5 E5 
0839   097D E5 E5 E5 E5 
0839   0981 E5 E5 E5 E5 
0839   0985 E5 E5 E5 E5 
0839   0989 E5 E5 E5 E5 
0839   098D E5 E5 E5 E5 
0839   0991 E5 E5 E5 E5 
0839   0995 E5 E5 E5 E5 
0839   0999 E5 E5 E5 E5 
0839   099D E5 E5 E5 E5 
0839   09A1 E5 E5 E5 E5 
0839   09A5 E5 E5 E5 E5 
0839   09A9 E5 E5 E5 E5 
0839   09AD E5 E5 E5 E5 
0839   09B1 E5 E5 E5 E5 
0839   09B5 E5 E5 E5 E5 
0839   09B9 E5 E5 E5 E5 
0839   09BD E5 E5 E5 E5 
0839   09C1 E5 E5 E5 E5 
0840   09C5 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0841   09C6 FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0841   09CA FF FF FF FF 
0841   09CE FF FF 
0842   09D0             fdc_128_format_end:
0843   09D0 FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0843   09D4 FF FF FF FF 
0843   09D8 FF FF FF FF 
0843   09DC FF FF FF FF 
0843   09E0 FF FF FF FF 
0843   09E4 FF FF FF FF 
0843   09E8 FF FF FF FF 
0843   09EC FF FF FF FF 
0843   09F0 FF FF FF FF 
0843   09F4 FF FF FF FF 
0843   09F8 FF FF FF FF 
0843   09FC FF FF FF FF 
0843   0A00 FF FF FF FF 
0843   0A04 FF FF FF FF 
0843   0A08 FF FF FF FF 
0843   0A0C FF FF FF FF 
0843   0A10 FF FF FF FF 
0843   0A14 FF FF FF FF 
0843   0A18 FF FF FF FF 
0843   0A1C FF FF FF FF 
0843   0A20 FF FF FF FF 
0843   0A24 FF FF FF FF 
0843   0A28 FF FF FF FF 
0843   0A2C FF FF FF FF 
0843   0A30 FF FF FF FF 
0843   0A34 FF FF FF FF 
0843   0A38 FF FF FF FF 
0843   0A3C FF FF FF FF 
0843   0A40 FF FF FF FF 
0843   0A44 FF FF FF FF 
0843   0A48 FF FF FF FF 
0843   0A4C FF FF FF FF 
0843   0A50 FF FF FF FF 
0843   0A54 FF FF FF FF 
0843   0A58 FF FF FF FF 
0843   0A5C FF FF FF FF 
0843   0A60 FF FF FF FF 
0843   0A64 FF FF FF FF 
0843   0A68 FF FF FF FF 
0843   0A6C FF FF FF FF 
0843   0A70 FF FF FF FF 
0843   0A74 FF FF FF FF 
0843   0A78 FF FF FF FF 
0843   0A7C FF FF FF FF 
0843   0A80 FF FF FF FF 
0843   0A84 FF FF FF FF 
0843   0A88 FF FF FF FF 
0843   0A8C FF FF FF FF 
0843   0A90 FF FF FF FF 
0843   0A94 FF FF FF FF 
0843   0A98 FF FF FF FF 
0843   0A9C FF FF FF FF 
0843   0AA0 FF FF FF FF 
0843   0AA4 FF FF FF FF 
0843   0AA8 FF FF FF FF 
0843   0AAC FF FF FF FF 
0843   0AB0 FF FF FF FF 
0843   0AB4 FF FF FF FF 
0843   0AB8 FF FF FF FF 
0843   0ABC FF FF FF FF 
0843   0AC0 FF FF FF FF 
0843   0AC4 FF FF FF FF 
0843   0AC8 FF FF FF FF 
0843   0ACC FF FF FF FF 
0843   0AD0 FF FF FF FF 
0843   0AD4 FF FF FF FF 
0843   0AD8 FF FF FF FF 
0843   0ADC FF FF FF FF 
0843   0AE0 FF FF FF FF 
0843   0AE4 FF FF FF FF 
0843   0AE8 FF FF FF FF 
0843   0AEC FF FF FF FF 
0843   0AF0 FF FF FF FF 
0843   0AF4 FF FF FF FF 
0843   0AF8 FF FF FF FF 
0843   0AFC FF FF FF FF 
0843   0B00 FF FF FF FF 
0843   0B04 FF FF FF FF 
0843   0B08 FF FF FF FF 
0843   0B0C FF FF FF FF 
0843   0B10 FF FF FF FF 
0843   0B14 FF FF FF FF 
0843   0B18 FF FF FF FF 
0843   0B1C FF FF FF FF 
0843   0B20 FF FF FF FF 
0843   0B24 FF FF FF FF 
0843   0B28 FF FF FF FF 
0843   0B2C FF FF FF FF 
0843   0B30 FF FF FF FF 
0843   0B34 FF FF FF FF 
0843   0B38 FF FF FF FF 
0843   0B3C FF FF FF FF 
0843   0B40 FF 
0844   0B41             
0845   0B41             fifo:
0846   0B41 FF FF FF FF   .fill FIFO_SIZE
0846   0B45 FF FF FF FF 
0846   0B49 FF FF FF FF 
0846   0B4D FF FF FF FF 
0846   0B51 FF FF FF FF 
0846   0B55 FF FF FF FF 
0846   0B59 FF FF FF FF 
0846   0B5D FF FF FF FF 
0846   0B61 FF FF FF FF 
0846   0B65 FF FF FF FF 
0846   0B69 FF FF FF FF 
0846   0B6D FF FF FF FF 
0846   0B71 FF FF FF FF 
0846   0B75 FF FF FF FF 
0846   0B79 FF FF FF FF 
0846   0B7D FF FF FF FF 
0846   0B81 FF FF FF FF 
0846   0B85 FF FF FF FF 
0846   0B89 FF FF FF FF 
0846   0B8D FF FF FF FF 
0846   0B91 FF FF FF FF 
0846   0B95 FF FF FF FF 
0846   0B99 FF FF FF FF 
0846   0B9D FF FF FF FF 
0846   0BA1 FF FF FF FF 
0846   0BA5 FF FF FF FF 
0846   0BA9 FF FF FF FF 
0846   0BAD FF FF FF FF 
0846   0BB1 FF FF FF FF 
0846   0BB5 FF FF FF FF 
0846   0BB9 FF FF FF FF 
0846   0BBD FF FF FF FF 
0846   0BC1 FF FF FF FF 
0846   0BC5 FF FF FF FF 
0846   0BC9 FF FF FF FF 
0846   0BCD FF FF FF FF 
0846   0BD1 FF FF FF FF 
0846   0BD5 FF FF FF FF 
0846   0BD9 FF FF FF FF 
0846   0BDD FF FF FF FF 
0846   0BE1 FF FF FF FF 
0846   0BE5 FF FF FF FF 
0846   0BE9 FF FF FF FF 
0846   0BED FF FF FF FF 
0846   0BF1 FF FF FF FF 
0846   0BF5 FF FF FF FF 
0846   0BF9 FF FF FF FF 
0846   0BFD FF FF FF FF 
0846   0C01 FF FF FF FF 
0846   0C05 FF FF FF FF 
0846   0C09 FF FF FF FF 
0846   0C0D FF FF FF FF 
0846   0C11 FF FF FF FF 
0846   0C15 FF FF FF FF 
0846   0C19 FF FF FF FF 
0846   0C1D FF FF FF FF 
0846   0C21 FF FF FF FF 
0846   0C25 FF FF FF FF 
0846   0C29 FF FF FF FF 
0846   0C2D FF FF FF FF 
0846   0C31 FF FF FF FF 
0846   0C35 FF FF FF FF 
0846   0C39 FF FF FF FF 
0846   0C3D FF FF FF FF 
0846   0C41 FF FF FF FF 
0846   0C45 FF FF FF FF 
0846   0C49 FF FF FF FF 
0846   0C4D FF FF FF FF 
0846   0C51 FF FF FF FF 
0846   0C55 FF FF FF FF 
0846   0C59 FF FF FF FF 
0846   0C5D FF FF FF FF 
0846   0C61 FF FF FF FF 
0846   0C65 FF FF FF FF 
0846   0C69 FF FF FF FF 
0846   0C6D FF FF FF FF 
0846   0C71 FF FF FF FF 
0846   0C75 FF FF FF FF 
0846   0C79 FF FF FF FF 
0846   0C7D FF FF FF FF 
0846   0C81 FF FF FF FF 
0846   0C85 FF FF FF FF 
0846   0C89 FF FF FF FF 
0846   0C8D FF FF FF FF 
0846   0C91 FF FF FF FF 
0846   0C95 FF FF FF FF 
0846   0C99 FF FF FF FF 
0846   0C9D FF FF FF FF 
0846   0CA1 FF FF FF FF 
0846   0CA5 FF FF FF FF 
0846   0CA9 FF FF FF FF 
0846   0CAD FF FF FF FF 
0846   0CB1 FF FF FF FF 
0846   0CB5 FF FF FF FF 
0846   0CB9 FF FF FF FF 
0846   0CBD FF FF FF FF 
0846   0CC1 FF FF FF FF 
0846   0CC5 FF FF FF FF 
0846   0CC9 FF FF FF FF 
0846   0CCD FF FF FF FF 
0846   0CD1 FF FF FF FF 
0846   0CD5 FF FF FF FF 
0846   0CD9 FF FF FF FF 
0846   0CDD FF FF FF FF 
0846   0CE1 FF FF FF FF 
0846   0CE5 FF FF FF FF 
0846   0CE9 FF FF FF FF 
0846   0CED FF FF FF FF 
0846   0CF1 FF FF FF FF 
0846   0CF5 FF FF FF FF 
0846   0CF9 FF FF FF FF 
0846   0CFD FF FF FF FF 
0846   0D01 FF FF FF FF 
0846   0D05 FF FF FF FF 
0846   0D09 FF FF FF FF 
0846   0D0D FF FF FF FF 
0846   0D11 FF FF FF FF 
0846   0D15 FF FF FF FF 
0846   0D19 FF FF FF FF 
0846   0D1D FF FF FF FF 
0846   0D21 FF FF FF FF 
0846   0D25 FF FF FF FF 
0846   0D29 FF FF FF FF 
0846   0D2D FF FF FF FF 
0846   0D31 FF FF FF FF 
0846   0D35 FF FF FF FF 
0846   0D39 FF FF FF FF 
0846   0D3D FF FF FF FF 
0846   0D41 FF FF FF FF 
0846   0D45 FF FF FF FF 
0846   0D49 FF FF FF FF 
0846   0D4D FF FF FF FF 
0846   0D51 FF FF FF FF 
0846   0D55 FF FF FF FF 
0846   0D59 FF FF FF FF 
0846   0D5D FF FF FF FF 
0846   0D61 FF FF FF FF 
0846   0D65 FF FF FF FF 
0846   0D69 FF FF FF FF 
0846   0D6D FF FF FF FF 
0846   0D71 FF FF FF FF 
0846   0D75 FF FF FF FF 
0846   0D79 FF FF FF FF 
0846   0D7D FF FF FF FF 
0846   0D81 FF FF FF FF 
0846   0D85 FF FF FF FF 
0846   0D89 FF FF FF FF 
0846   0D8D FF FF FF FF 
0846   0D91 FF FF FF FF 
0846   0D95 FF FF FF FF 
0846   0D99 FF FF FF FF 
0846   0D9D FF FF FF FF 
0846   0DA1 FF FF FF FF 
0846   0DA5 FF FF FF FF 
0846   0DA9 FF FF FF FF 
0846   0DAD FF FF FF FF 
0846   0DB1 FF FF FF FF 
0846   0DB5 FF FF FF FF 
0846   0DB9 FF FF FF FF 
0846   0DBD FF FF FF FF 
0846   0DC1 FF FF FF FF 
0846   0DC5 FF FF FF FF 
0846   0DC9 FF FF FF FF 
0846   0DCD FF FF FF FF 
0846   0DD1 FF FF FF FF 
0846   0DD5 FF FF FF FF 
0846   0DD9 FF FF FF FF 
0846   0DDD FF FF FF FF 
0846   0DE1 FF FF FF FF 
0846   0DE5 FF FF FF FF 
0846   0DE9 FF FF FF FF 
0846   0DED FF FF FF FF 
0846   0DF1 FF FF FF FF 
0846   0DF5 FF FF FF FF 
0846   0DF9 FF FF FF FF 
0846   0DFD FF FF FF FF 
0846   0E01 FF FF FF FF 
0846   0E05 FF FF FF FF 
0846   0E09 FF FF FF FF 
0846   0E0D FF FF FF FF 
0846   0E11 FF FF FF FF 
0846   0E15 FF FF FF FF 
0846   0E19 FF FF FF FF 
0846   0E1D FF FF FF FF 
0846   0E21 FF FF FF FF 
0846   0E25 FF FF FF FF 
0846   0E29 FF FF FF FF 
0846   0E2D FF FF FF FF 
0846   0E31 FF FF FF FF 
0846   0E35 FF FF FF FF 
0846   0E39 FF FF FF FF 
0846   0E3D FF FF FF FF 
0846   0E41 FF FF FF FF 
0846   0E45 FF FF FF FF 
0846   0E49 FF FF FF FF 
0846   0E4D FF FF FF FF 
0846   0E51 FF FF FF FF 
0846   0E55 FF FF FF FF 
0846   0E59 FF FF FF FF 
0846   0E5D FF FF FF FF 
0846   0E61 FF FF FF FF 
0846   0E65 FF FF FF FF 
0846   0E69 FF FF FF FF 
0846   0E6D FF FF FF FF 
0846   0E71 FF FF FF FF 
0846   0E75 FF FF FF FF 
0846   0E79 FF FF FF FF 
0846   0E7D FF FF FF FF 
0846   0E81 FF FF FF FF 
0846   0E85 FF FF FF FF 
0846   0E89 FF FF FF FF 
0846   0E8D FF FF FF FF 
0846   0E91 FF FF FF FF 
0846   0E95 FF FF FF FF 
0846   0E99 FF FF FF FF 
0846   0E9D FF FF FF FF 
0846   0EA1 FF FF FF FF 
0846   0EA5 FF FF FF FF 
0846   0EA9 FF FF FF FF 
0846   0EAD FF FF FF FF 
0846   0EB1 FF FF FF FF 
0846   0EB5 FF FF FF FF 
0846   0EB9 FF FF FF FF 
0846   0EBD FF FF FF FF 
0846   0EC1 FF FF FF FF 
0846   0EC5 FF FF FF FF 
0846   0EC9 FF FF FF FF 
0846   0ECD FF FF FF FF 
0846   0ED1 FF FF FF FF 
0846   0ED5 FF FF FF FF 
0846   0ED9 FF FF FF FF 
0846   0EDD FF FF FF FF 
0846   0EE1 FF FF FF FF 
0846   0EE5 FF FF FF FF 
0846   0EE9 FF FF FF FF 
0846   0EED FF FF FF FF 
0846   0EF1 FF FF FF FF 
0846   0EF5 FF FF FF FF 
0846   0EF9 FF FF FF FF 
0846   0EFD FF FF FF FF 
0846   0F01 FF FF FF FF 
0846   0F05 FF FF FF FF 
0846   0F09 FF FF FF FF 
0846   0F0D FF FF FF FF 
0846   0F11 FF FF FF FF 
0846   0F15 FF FF FF FF 
0846   0F19 FF FF FF FF 
0846   0F1D FF FF FF FF 
0846   0F21 FF FF FF FF 
0846   0F25 FF FF FF FF 
0846   0F29 FF FF FF FF 
0846   0F2D FF FF FF FF 
0846   0F31 FF FF FF FF 
0846   0F35 FF FF FF FF 
0846   0F39 FF FF FF FF 
0846   0F3D FF FF FF FF 
0847   0F41             
0848   0F41             scrap_sector:
0849   0F41 FF FF FF FF   .fill 512         ; scrap sector
0849   0F45 FF FF FF FF 
0849   0F49 FF FF FF FF 
0849   0F4D FF FF FF FF 
0849   0F51 FF FF FF FF 
0849   0F55 FF FF FF FF 
0849   0F59 FF FF FF FF 
0849   0F5D FF FF FF FF 
0849   0F61 FF FF FF FF 
0849   0F65 FF FF FF FF 
0849   0F69 FF FF FF FF 
0849   0F6D FF FF FF FF 
0849   0F71 FF FF FF FF 
0849   0F75 FF FF FF FF 
0849   0F79 FF FF FF FF 
0849   0F7D FF FF FF FF 
0849   0F81 FF FF FF FF 
0849   0F85 FF FF FF FF 
0849   0F89 FF FF FF FF 
0849   0F8D FF FF FF FF 
0849   0F91 FF FF FF FF 
0849   0F95 FF FF FF FF 
0849   0F99 FF FF FF FF 
0849   0F9D FF FF FF FF 
0849   0FA1 FF FF FF FF 
0849   0FA5 FF FF FF FF 
0849   0FA9 FF FF FF FF 
0849   0FAD FF FF FF FF 
0849   0FB1 FF FF FF FF 
0849   0FB5 FF FF FF FF 
0849   0FB9 FF FF FF FF 
0849   0FBD FF FF FF FF 
0849   0FC1 FF FF FF FF 
0849   0FC5 FF FF FF FF 
0849   0FC9 FF FF FF FF 
0849   0FCD FF FF FF FF 
0849   0FD1 FF FF FF FF 
0849   0FD5 FF FF FF FF 
0849   0FD9 FF FF FF FF 
0849   0FDD FF FF FF FF 
0849   0FE1 FF FF FF FF 
0849   0FE5 FF FF FF FF 
0849   0FE9 FF FF FF FF 
0849   0FED FF FF FF FF 
0849   0FF1 FF FF FF FF 
0849   0FF5 FF FF FF FF 
0849   0FF9 FF FF FF FF 
0849   0FFD FF FF FF FF 
0849   1001 FF FF FF FF 
0849   1005 FF FF FF FF 
0849   1009 FF FF FF FF 
0849   100D FF FF FF FF 
0849   1011 FF FF FF FF 
0849   1015 FF FF FF FF 
0849   1019 FF FF FF FF 
0849   101D FF FF FF FF 
0849   1021 FF FF FF FF 
0849   1025 FF FF FF FF 
0849   1029 FF FF FF FF 
0849   102D FF FF FF FF 
0849   1031 FF FF FF FF 
0849   1035 FF FF FF FF 
0849   1039 FF FF FF FF 
0849   103D FF FF FF FF 
0849   1041 FF FF FF FF 
0849   1045 FF FF FF FF 
0849   1049 FF FF FF FF 
0849   104D FF FF FF FF 
0849   1051 FF FF FF FF 
0849   1055 FF FF FF FF 
0849   1059 FF FF FF FF 
0849   105D FF FF FF FF 
0849   1061 FF FF FF FF 
0849   1065 FF FF FF FF 
0849   1069 FF FF FF FF 
0849   106D FF FF FF FF 
0849   1071 FF FF FF FF 
0849   1075 FF FF FF FF 
0849   1079 FF FF FF FF 
0849   107D FF FF FF FF 
0849   1081 FF FF FF FF 
0849   1085 FF FF FF FF 
0849   1089 FF FF FF FF 
0849   108D FF FF FF FF 
0849   1091 FF FF FF FF 
0849   1095 FF FF FF FF 
0849   1099 FF FF FF FF 
0849   109D FF FF FF FF 
0849   10A1 FF FF FF FF 
0849   10A5 FF FF FF FF 
0849   10A9 FF FF FF FF 
0849   10AD FF FF FF FF 
0849   10B1 FF FF FF FF 
0849   10B5 FF FF FF FF 
0849   10B9 FF FF FF FF 
0849   10BD FF FF FF FF 
0849   10C1 FF FF FF FF 
0849   10C5 FF FF FF FF 
0849   10C9 FF FF FF FF 
0849   10CD FF FF FF FF 
0849   10D1 FF FF FF FF 
0849   10D5 FF FF FF FF 
0849   10D9 FF FF FF FF 
0849   10DD FF FF FF FF 
0849   10E1 FF FF FF FF 
0849   10E5 FF FF FF FF 
0849   10E9 FF FF FF FF 
0849   10ED FF FF FF FF 
0849   10F1 FF FF FF FF 
0849   10F5 FF FF FF FF 
0849   10F9 FF FF FF FF 
0849   10FD FF FF FF FF 
0849   1101 FF FF FF FF 
0849   1105 FF FF FF FF 
0849   1109 FF FF FF FF 
0849   110D FF FF FF FF 
0849   1111 FF FF FF FF 
0849   1115 FF FF FF FF 
0849   1119 FF FF FF FF 
0849   111D FF FF FF FF 
0849   1121 FF FF FF FF 
0849   1125 FF FF FF FF 
0849   1129 FF FF FF FF 
0849   112D FF FF FF FF 
0849   1131 FF FF FF FF 
0849   1135 FF FF FF FF 
0849   1139 FF FF FF FF 
0849   113D FF FF FF FF 
0850   1141             transient_area:
0851   1141 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
0852   1142             
0853   1142             .end
tasm: Number of errors = 0
