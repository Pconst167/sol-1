0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; GLOBAL SYSTEM VARIABLES
0086   0000             ; ------------------------------------------------------------------------------------------------------------------;
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; IRQ table
0090   0000             ; highest priority at lowest address
0091   0000             ; ------------------------------------------------------------------------------------------------------------------;
0092   0000 2A 00       .dw int_0_fdc
0093   0002 2B 00       .dw int_1
0094   0004 2C 00       .dw int_2
0095   0006 2D 00       .dw int_3
0096   0008 2E 00       .dw int_4
0097   000A 2F 00       .dw int_5
0098   000C 30 00       .dw int_6
0099   000E 31 00       .dw int_7_uart0
0100   0010             
0101   0010             ; ------------------------------------------------------------------------------------------------------------------;
0102   0010             ; kernel reset vector
0103   0010             ; ------------------------------------------------------------------------------------------------------------------;
0104   0010 F5 02       .dw kernel_reset_vector
0105   0012             
0106   0012             ; ------------------------------------------------------------------------------------------------------------------;
0107   0012             ; exception vector table
0108   0012             ; total of 7 entries, starting at address $0012
0109   0012             ; ------------------------------------------------------------------------------------------------------------------;
0110   0012 64 02       .dw trap_privilege
0111   0014 70 02       .dw trap_div_zero
0112   0016 7D 02       .dw trap_undef_opcode
0113   0018 00 00       .dw 0
0114   001A 00 00       .dw 0
0115   001C 00 00       .dw 0
0116   001E 00 00       .dw 0
0117   0020             
0118   0020             ; ------------------------------------------------------------------------------------------------------------------;
0119   0020             ; system call vector table
0120   0020             ; starts at address $0020
0121   0020             ; ------------------------------------------------------------------------------------------------------------------;
0122   0020 84 02       .dw syscall_io
0123   0022 58 02       .dw syscall_reboot
0124   0024 EC 00       .dw syscall_fdc
0125   0026 50 00       .dw syscall_fdc_read
0126   0028 A4 00       .dw syscall_fdc_read_sec
0127   002A             
0128   002A             ; ------------------------------------------------------------------------------------------------------------------;
0129   002A             ; system call aliases
0130   002A             ; ------------------------------------------------------------------------------------------------------------------;
0131   002A             sys_io               .equ 0
0132   002A             sys_reboot           .equ 1
0133   002A             sys_fdc              .equ 2
0134   002A             sys_fdc_read         .equ 3
0135   002A             sys_fdc_read_sec     .equ 4
0136   002A             
0137   002A             ; ------------------------------------------------------------------------------------------------------------------;
0138   002A             ; IRQs' code block
0139   002A             ; ------------------------------------------------------------------------------------------------------------------;
0140   002A             ; 5.25" Floppy Drive Controller IRQ
0141   002A             int_0_fdc:
0142   002A 06            sysret
0143   002B             int_1:
0144   002B 06            sysret
0145   002C             int_2:
0146   002C 06            sysret
0147   002D             int_3:
0148   002D 06            sysret
0149   002E             int_4:
0150   002E 06            sysret
0151   002F             int_5:
0152   002F 06            sysret
0153   0030             
0154   0030             ; ------------------------------------------------------------------------------------------------------------------;
0155   0030             ; process swapping
0156   0030             ; ------------------------------------------------------------------------------------------------------------------;
0157   0030             int_6:  
0158   0030 06            sysret
0159   0031             
0160   0031             ; ------------------------------------------------------------------------------------------------------------------;
0161   0031             ; UART0 Interrupt
0162   0031             ; ------------------------------------------------------------------------------------------------------------------;
0163   0031             int_7_uart0:
0164   0031 D7            push a
0165   0032 DA            push d
0166   0033 E1            pushf
0167   0034 14 35 09      mov a, [fifo_in]
0168   0037 3C            mov d, a
0169   0038 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0170   003B 3E            mov [d], al                 ; add to fifo
0171   003C 14 35 09      mov a, [fifo_in]
0172   003F 77            inc a
0173   0040 AF CB 0F      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0174   0043 C7 49 00      jne int_7_continue
0175   0046 10 CB 0B      mov a, fifo  
0176   0049             int_7_continue:  
0177   0049 42 35 09      mov [fifo_in], a            ; update fifo pointer
0178   004C EE            popf
0179   004D E7            pop d
0180   004E E4            pop a  
0181   004F 06            sysret
0182   0050             
0183   0050             
0184   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0185   0050             ; floppy drive system calls
0186   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0187   0050             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0188   0050             ; fdc_40_FF:
0189   0050             ;   .fill 40,  $FF    ; or 00                                                                                
0190   0050             ; fdc_128_format_inner:
0191   0050             ;   .fill 6,   $00    ;                                                                            <--|        
0192   0050             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0193   0050             ;   .fill 1,   $00    ; Track Number  0 thru 39                                                       |                    
0194   0050             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0195   0050             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0196   0050             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0197   0050             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0198   0050             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0199   0050             ;   .fill 6,   $00    ;                                                                               |                        
0200   0050             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0201   0050             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0202   0050             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0203   0050             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0204   0050             ; fdc_128_format_end:
0205   0050             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0206   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   0050             ; _FDC_CONFIG       .equ $FFC0 
0208   0050             ; _FDC_STATUS_1     .equ $FFC1
0209   0050             ; _FDC_WD_STAT_CMD  .equ $FFC8
0210   0050             ; _FDC_WD_TRACK     .equ $FFC9
0211   0050             ; _FDC_WD_SECTOR    .equ $FFCA
0212   0050             ; _FDC_WD_DATA      .equ $FFCB
0213   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0214   0050             syscall_fdc_read:
0215   0050 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0216   0053 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0217   0056 19 E4         mov al, %11100100         
0218   0058 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0219   005B 07 14 02      call fdc_wait_64us
0220   005E             
0221   005E             fdc_wait_busy_high1:
0222   005E 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0223   0061 87 01         and al, $01                ; 
0224   0063 C6 5E 00      jz fdc_wait_busy_high1
0225   0066             
0226   0066 FD 4F CB 11   mov di, transient_area
0227   006A             fdc_read_loop: ; for each byte, we need to wait for DRQ to be high
0228   006A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag 10+3+5+8+5+8
0229   006D 2F            mov bl, al                                                
0230   006E FD 87 01      and bl, $01                ; check drq bit
0231   0071 C6 80 00      jz fdc_read_end
0232   0074 87 02         and al, $02                ; check drq bit
0233   0076 C6 6A 00      jz fdc_read_loop
0234   0079 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0235   007C F7            stosb
0236   007D 0A 6A 00      jmp fdc_read_loop
0237   0080             
0238   0080             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0239   0080             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0240   0080             ;because for every write, if it also reads, then that clears DRQ, so we need to wait for next DRQ.
0241   0080             fdc_read_end:
0242   0080 50            mov a, di
0243   0081 5F CB 11      sub a, transient_area
0244   0084 3B 97 00      mov d, sss
0245   0087 07 34 07      call _puts
0246   008A 07 5D 07      call print_u16d
0247   008D 07 E1 06      call printnl
0248   0090 26 08 0C      mov b, 3080
0249   0093 07 EC 03      call cmd_hexd
0250   0096 06            sysret
0251   0097 0A 74 72 61 sss:.db "\ntrack read\n", 0
0251   009B 63 6B 20 72 
0251   009F 65 61 64 0A 
0251   00A3 00 
0252   00A4             
0253   00A4             
0254   00A4             ; sector in al
0255   00A4             ; track in ah
0256   00A4             syscall_fdc_read_sec:
0257   00A4 3D CA FF      mov [_FDC_WD_SECTOR], al
0258   00A7 1A            mov al, ah
0259   00A8 3D C9 FF      mov [_FDC_WD_TRACK], al
0260   00AB 19 84         mov al, %10000100         
0261   00AD 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0262   00B0 07 14 02      call fdc_wait_64us
0263   00B3             
0264   00B3             fdc_wait_busy_high2:
0265   00B3 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0266   00B6 87 01         and al, $01                ; 
0267   00B8 C6 B3 00      jz fdc_wait_busy_high2
0268   00BB             
0269   00BB FD 4F CB 11   mov di, transient_area
0270   00BF             fdc_read_loop2: ; for each byte, we need to wait for DRQ to be high
0271   00BF 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag 10+3+5+8+5+8
0272   00C2 2F            mov bl, al                                                
0273   00C3 FD 87 01      and bl, $01                ; check drq bit
0274   00C6 C6 D5 00      jz fdc_read_end2
0275   00C9 87 02         and al, $02                ; check drq bit
0276   00CB C6 BF 00      jz fdc_read_loop2
0277   00CE 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0278   00D1 F7            stosb
0279   00D2 0A BF 00      jmp fdc_read_loop2
0280   00D5             fdc_read_end2:
0281   00D5 50            mov a, di
0282   00D6 5F CB 11      sub a, transient_area
0283   00D9 3B 97 00      mov d, sss
0284   00DC 07 34 07      call _puts
0285   00DF 07 5D 07      call print_u16d
0286   00E2 07 E1 06      call printnl
0287   00E5 26 80 00      mov b, 128
0288   00E8 07 EC 03      call cmd_hexd
0289   00EB 06            sysret
0290   00EC             
0291   00EC             syscall_fdc:
0292   00EC             ; bl: track number
0293   00EC             syscall_fdc_format:
0294   00EC 1B            mov al, bl
0295   00ED 3D B8 09      mov [fdc_128_format_track], al  ; write track number to formatting data block
0296   00F0 19 01         mov al, 1
0297   00F2 3D BA 09      mov [fdc_128_format_sect], al   ; reset sector variable to 1
0298   00F5 19 00         mov al, 0
0299   00F7 3D C9 FF      mov [_FDC_WD_TRACK], al   
0300   00FA 3B 1E 02      mov d, s_format_begin
0301   00FD 07 34 07      call _puts
0302   0100 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0303   0103 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0304   0106 2F            mov bl, al
0305   0107 07 D4 07      call print_u8x
0306   010A 07 E1 06      call printnl
0307   010D 10 00 00      mov a, 0
0308   0110 42 1B 02      mov [fdc_count], a
0309   0113             fdc_header_loop_start:
0310   0113 19 F6         mov al, %11110110               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0311   0115 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0312   0118             ; write the first data block for formatting which is 40 bytes of 0xFF:
0313   0118 07 14 02      call fdc_wait_64us
0314   011B 3B 01 00      mov d, 1
0315   011E             
0316   011E             fdc_wait_busy_high:
0317   011E 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0318   0121 87 01         and al, $01                ; 
0319   0123 C6 1E 01      jz fdc_wait_busy_high
0320   0126             
0321   0126             
0322   0126 3A 28         mov cl, 40
0323   0128             fdc_drq_loop: ; for each byte, we need to wait for DRQ to be high
0324   0128 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0325   012B 87 02         and al, $02                ; check drq bit
0326   012D C6 28 01      jz fdc_drq_loop
0327   0130 F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0328   0134 81            dec cl
0329   0135 C7 28 01      jnz fdc_drq_loop
0330   0138             ; start inner data block loop. this block is written 16 times
0331   0138             
0332   0138             fdc_inner_loop:
0333   0138 3A 06         mov cl, 6
0334   013A             fdc_l1:
0335   013A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0336   013D 87 02         and al, $02                ; check drq bit
0337   013F C6 3A 01      jz fdc_l1
0338   0142 F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0339   0146 81            dec cl
0340   0147 C7 3A 01      jnz fdc_l1
0341   014A             
0342   014A             ; address mark
0343   014A             fdc_l2:
0344   014A 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0345   014D 87 02         and al, $02                ; check drq bit
0346   014F C6 4A 01      jz fdc_l2
0347   0152 F2 CB FF FE   mov byte [_FDC_WD_DATA], $FE     ; send data byte to wd1770
0348   0156             
0349   0156             ; track number
0350   0156             fdc_l3:
0351   0156 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0352   0159 87 02         and al, $02                ; check drq bit
0353   015B C6 56 01      jz fdc_l3
0354   015E F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0355   0162             
0356   0162             ; side number
0357   0162             fdc_l4:
0358   0162 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0359   0165 87 02         and al, $02                ; check drq bit
0360   0167 C6 62 01      jz fdc_l4
0361   016A F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0362   016E             
0363   016E             ; sector number
0364   016E             fdc_l5:
0365   016E 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0366   0171 87 02         and al, $02                ; check drq bit
0367   0173 C6 6E 01      jz fdc_l5
0368   0176 FD 1A         mov al, gl
0369   0178 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0370   017B             
0371   017B             ; sector length
0372   017B             fdc_l6:
0373   017B 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0374   017E 87 02         and al, $02                ; check drq bit
0375   0180 C6 7B 01      jz fdc_l6
0376   0183 F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0377   0187             
0378   0187             ; 2 crc's
0379   0187             fdc_l7:
0380   0187 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0381   018A 87 02         and al, $02                ; check drq bit
0382   018C C6 87 01      jz fdc_l7
0383   018F F2 CB FF F7   mov byte [_FDC_WD_DATA], $F7     ; send data byte to wd1770
0384   0193             
0385   0193             ; 11 times $FF
0386   0193 3A 0B         mov cl, 11
0387   0195             fdc_l8:
0388   0195 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0389   0198 87 02         and al, $02                ; check drq bit
0390   019A C6 95 01      jz fdc_l8
0391   019D F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0392   01A1 81            dec cl
0393   01A2 C7 95 01      jnz fdc_l8
0394   01A5             
0395   01A5             ; 6 times 00
0396   01A5 3A 06         mov cl, 6
0397   01A7             fdc_l9:
0398   01A7 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0399   01AA 87 02         and al, $02                ; check drq bit
0400   01AC C6 A7 01      jz fdc_l9
0401   01AF F2 CB FF 00   mov byte [_FDC_WD_DATA], $00     ; send data byte to wd1770
0402   01B3 81            dec cl
0403   01B4 C7 A7 01      jnz fdc_l9
0404   01B7             
0405   01B7             ; data address mark
0406   01B7             fdc_l10:
0407   01B7 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0408   01BA 87 02         and al, $02                ; check drq bit
0409   01BC C6 B7 01      jz fdc_l10
0410   01BF F2 CB FF FB   mov byte [_FDC_WD_DATA], $FB     ; send data byte to wd1770
0411   01C3             
0412   01C3             ; sector data
0413   01C3 3A 80         mov cl, 128
0414   01C5 2E E5         mov bl, $E5
0415   01C7             fdc_l11:
0416   01C7 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0417   01CA 87 02         and al, $02                ; check drq bit
0418   01CC C6 C7 01      jz fdc_l11
0419   01CF FD 3D CB FF   mov [_FDC_WD_DATA], bl     ; send data byte to wd1770
0420   01D3 81            dec cl
0421   01D4 C7 C7 01      jnz fdc_l11
0422   01D7             
0423   01D7             ; 2 crc's
0424   01D7             fdc_l12:
0425   01D7 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0426   01DA 87 02         and al, $02                ; check drq bit
0427   01DC C6 D7 01      jz fdc_l12
0428   01DF F2 CB FF F7   mov byte [_FDC_WD_DATA], $F7     ; send data byte to wd1770
0429   01E3             
0430   01E3             ; 10 times $FF
0431   01E3 3A 0A         mov cl, 10
0432   01E5             fdc_l13:
0433   01E5 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0434   01E8 87 02         and al, $02                ; check drq bit
0435   01EA C6 E5 01      jz fdc_l13
0436   01ED F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0437   01F1 81            dec cl
0438   01F2 C7 E5 01      jnz fdc_l13
0439   01F5             
0440   01F5             ; check whether we did this 16 times
0441   01F5 79            inc d
0442   01F6 C5 11 00      cmp d, 17
0443   01F9 C7 38 01      jne fdc_inner_loop
0444   01FC             
0445   01FC 06            sysret
0446   01FD             
0447   01FD             ; loop ~369 times
0448   01FD             fdc_format_footer:
0449   01FD             fdc_footer_drq_loop:
0450   01FD 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0451   0200 2F            mov bl, al
0452   0201 FD 87 01      and bl, $01                ; check busy bit
0453   0204 C6 13 02      jz fdc_format_done
0454   0207 87 02         and al, $02                ; check drq bit
0455   0209 C6 FD 01      jz fdc_footer_drq_loop
0456   020C F2 CB FF FF   mov byte [_FDC_WD_DATA], $FF     ; send data byte to wd1770
0457   0210 0A FD 01      jmp fdc_footer_drq_loop
0458   0213             
0459   0213             fdc_format_done:
0460   0213 06            sysret
0461   0214             
0462   0214             ; fetch is 2 cycles long when 'display_reg_load' is false.
0463   0214             ; 64us amounts to 160 cycles of the 2.5MHz clock
0464   0214             ; call u16 is 14 cycles long
0465   0214             ; 160 - 5 - 14 = 
0466   0214             fdc_wait_64us:
0467   0214 3A 0C         mov cl, 12                       ; 5 cycles
0468   0216             fdc_wait_64_loop:
0469   0216 81            dec cl                           ; 3 cycles
0470   0217 C7 16 02      jnz fdc_wait_64_loop             ; 8 cycles
0471   021A 09            ret
0472   021B             
0473   021B 00 00       fdc_count: .dw 0
0474   021D 00          fdc_irq: .db 0
0475   021E 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0475   0222 6D 61 74 74 
0475   0226 69 6E 67 20 
0475   022A 73 74 61 72 
0475   022E 74 69 6E 67 
0475   0232 2E 2E 2E 0A 
0475   0236 00 
0476   0237 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0476   023B 6D 61 74 74 
0476   023F 69 6E 67 20 
0476   0243 64 6F 6E 65 
0476   0247 2E 0A 00 
0477   024A 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0477   024E 20 73 74 61 
0477   0252 74 75 73 3A 
0477   0256 20 00 
0478   0258             
0479   0258             ; REBOOT SYSTEM
0480   0258             syscall_reboot:
0481   0258 FD D7 FF FF   push word $FFFF 
0482   025C FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0483   025F FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0484   0263 06            sysret
0485   0264             
0486   0264             ; ------------------------------------------------------------------------------------------------------------------;
0487   0264             ; exceptions code block
0488   0264             ; ------------------------------------------------------------------------------------------------------------------;
0489   0264             ; privilege exception
0490   0264             ; ------------------------------------------------------------------------------------------------------------------;
0491   0264             trap_privilege:
0492   0264 0A 58 02      jmp syscall_reboot
0493   0267 DA            push d
0494   0268 3B 56 09      mov d, s_priviledge
0495   026B 07 34 07      call _puts
0496   026E E7            pop d
0497   026F 06            sysret
0498   0270             
0499   0270             ; ------------------------------------------------------------------------------------------------------------------;
0500   0270             ; divide by zero exception
0501   0270             ; ------------------------------------------------------------------------------------------------------------------;
0502   0270             trap_div_zero:
0503   0270 D7            push a
0504   0271 DA            push d
0505   0272 E1            pushf
0506   0273 3B 6D 09      mov d, s_divzero
0507   0276 07 34 07      call _puts
0508   0279 EE            popf
0509   027A E7            pop d
0510   027B E4            pop a
0511   027C 06            sysret ; enable interrupts
0512   027D             
0513   027D             ; ------------------------------------------------------------------------------------------------------------------;
0514   027D             ; undefined opcode exception
0515   027D             ; ------------------------------------------------------------------------------------------------------------------;
0516   027D             trap_undef_opcode:
0517   027D 06            sysret
0518   027E             
0519   027E             
0520   027E             
0521   027E             ;----------------------------------------------------------------------------------------------------;
0522   027E             ; IO Syscall
0523   027E             ;----------------------------------------------------------------------------------------------------;
0524   027E             ; Baud  Divisor
0525   027E             ; 50    2304
0526   027E             ; 110   1047
0527   027E             ; 300    384
0528   027E             ; 600    192
0529   027E             ; 1200    96
0530   027E             ; 9600    12
0531   027E             ; 19200    6
0532   027E             ; 38400    3
0533   027E             syscall_io_jmp:
0534   027E B1 02         .dw syscall_io_putchar
0535   0280 BE 02         .dw syscall_io_getch
0536   0282 88 02         .dw syscall_io_uart_setup
0537   0284             syscall_io:
0538   0284 FD 0A 7E 02   jmp [syscall_io_jmp + al]
0539   0288             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0540   0288             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0541   0288             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0542   0288             syscall_io_uart_setup:
0543   0288 1D 30 09      mov al, [sys_uart0_lcr]
0544   028B 8B 80         or al, $80                ; set DLAB access bit
0545   028D 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0546   0290 1D 33 09      mov al, [sys_uart0_div0]
0547   0293 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0548   0296 1D 34 09      mov al, [sys_uart0_div1]
0549   0299 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0550   029C             
0551   029C 1D 30 09      mov al, [sys_uart0_lcr]
0552   029F 87 7F         and al, $7F               ; clear DLAB access bit 
0553   02A1 3D 83 FF      mov [_UART0_LCR], al
0554   02A4 1D 31 09      mov al, [sys_uart0_inten]
0555   02A7 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0556   02AA 1D 32 09      mov al, [sys_uart0_fifoen]
0557   02AD 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0558   02B0 06            sysret
0559   02B1             
0560   02B1             ; char in ah
0561   02B1             syscall_io_putchar:
0562   02B1             syscall_io_putchar_L0:
0563   02B1 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0564   02B4 87 20         and al, $20
0565   02B6 C6 B1 02      jz syscall_io_putchar_L0    
0566   02B9 1A            mov al, ah
0567   02BA 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0568   02BD 06            sysret
0569   02BE             
0570   02BE             ; char in ah
0571   02BE             ; al = sucess code
0572   02BE             syscall_io_getch:
0573   02BE D8            push b
0574   02BF DA            push d
0575   02C0 FD 0C         sti
0576   02C2             syscall_io_getch_L0:  
0577   02C2 14 37 09      mov a, [fifo_out]
0578   02C5 29 35 09      mov b, [fifo_in]
0579   02C8 B0            cmp a, b
0580   02C9 C6 C2 02      je syscall_io_getch_L0
0581   02CC 3C            mov d, a
0582   02CD 77            inc a
0583   02CE AF CB 0F      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0584   02D1 C7 D7 02      jne syscall_io_getch_cont
0585   02D4 10 CB 0B      mov a, fifo  
0586   02D7             syscall_io_getch_cont:  
0587   02D7 42 37 09      mov [fifo_out], a             ; update fifo pointer
0588   02DA 1E            mov al, [d]                   ; get char
0589   02DB 23            mov ah, al
0590   02DC 1D 2F 09      mov al, [sys_echo_on]
0591   02DF B9 01         cmp al, 1
0592   02E1 C7 F0 02      jne syscall_io_getch_noecho 
0593   02E4             ; here we just echo the char back to the console
0594   02E4             syscall_io_getch_echo_L0:
0595   02E4 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0596   02E7 87 20         and al, $20                 ; isolate Transmitter Empty
0597   02E9 C6 E4 02      jz syscall_io_getch_echo_L0
0598   02EC 1A            mov al, ah
0599   02ED 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0600   02F0             syscall_io_getch_noecho:
0601   02F0 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0602   02F2 E7            pop d
0603   02F3 E5            pop b
0604   02F4 06            sysret
0605   02F5             
0606   02F5             
0607   02F5             
0608   02F5             
0609   02F5             
0610   02F5             
0611   02F5             ; ---------------------------------------------------------------------
0612   02F5             ; kernel reset vector
0613   02F5             ; ---------------------------------------------------------------------
0614   02F5             kernel_reset_vector:  
0615   02F5 FD 49 FF F7   mov bp, STACK_BEGIN
0616   02F9 FD 47 FF F7   mov sp, STACK_BEGIN
0617   02FD               
0618   02FD 19 80         mov al, %10000000             ; mask out timer interrupt
0619   02FF FD 0F         stomsk                        
0620   0301 FD 0C         sti  
0621   0303             
0622   0303 0C            lodstat
0623   0304 87 DF         and al, %11011111             ; disable display register loading
0624   0306 0D            stostat
0625   0307               
0626   0307             ; reset fifo pointers
0627   0307 10 CB 0B      mov a, fifo
0628   030A 3B 35 09      mov d, fifo_in
0629   030D 43            mov [d], a
0630   030E 3B 37 09      mov d, fifo_out
0631   0311 43            mov [d], a  
0632   0312 19 02         mov al, 2
0633   0314 05 00         syscall sys_io                ; enable uart in interrupt mode
0634   0316               
0635   0316 3B 39 09      mov d, s_kernel_started
0636   0319 07 34 07      call _puts
0637   031C             
0638   031C 3B FC 04      mov d, str0
0639   031F 07 34 07      call _puts
0640   0322               ; First, select drive 1 and de-select drive 0
0641   0322 3B C0 FF      mov d, $FFC0
0642   0325 2E 09         mov bl, %00001001     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0643   0327 FD 3E         mov [d], bl
0644   0329             
0645   0329             menu:
0646   0329 3B 79 04      mov d, s_menu
0647   032C 07 34 07      call _puts
0648   032F 07 01 06      call getch
0649   0332 76 30         cmp ah, '0'
0650   0334 C6 5D 03      je step_in
0651   0337 76 31         cmp ah, '1'
0652   0339 C6 75 03      je step_out
0653   033C 76 32         cmp ah, '2'
0654   033E C6 69 03      je restore
0655   0341 76 33         cmp ah, '3'
0656   0343 C6 81 03      je status1
0657   0346 76 34         cmp ah, '4'
0658   0348 C6 93 03      je status2
0659   034B 76 35         cmp ah, '5'
0660   034D C6 A5 03      je format
0661   0350 76 36         cmp ah, '6'
0662   0352 C6 C1 03      je read_sec
0663   0355 76 37         cmp ah, '7'
0664   0357 C6 BC 03      je read
0665   035A 0A 29 03      jmp menu
0666   035D             step_in:
0667   035D 3B C8 FF      mov d, $FFC8    ; wd1770
0668   0360 19 02         mov al, 2       ; setparam call
0669   0362 2E 53         mov bl, %01010011     ; step in
0670   0364 FD 3E         mov [d], bl
0671   0366 0A 29 03      jmp menu
0672   0369             restore:
0673   0369             ; send restore command
0674   0369 3B C8 FF      mov d, $FFC8    ; wd1770
0675   036C 19 02         mov al, 2       ; setparam call
0676   036E 2E 03         mov bl, $03     ; restore command, 30ms rate
0677   0370 FD 3E         mov [d], bl
0678   0372 0A 29 03      jmp menu
0679   0375             step_out:
0680   0375 3B C8 FF      mov d, $FFC8    ; wd1770
0681   0378 19 02         mov al, 2       ; setparam call
0682   037A 2E 73         mov bl, %01110011     ; step out
0683   037C FD 3E         mov [d], bl
0684   037E 0A 29 03      jmp menu
0685   0381             status1:
0686   0381 07 E1 06      call printnl
0687   0384 3B C1 FF      mov d, $FFC1    ; wd1770 status 1
0688   0387 19 04         mov al, 4       ; getparam call
0689   0389 32            mov bl, [d]
0690   038A 07 D4 07      call print_u8x   ; print bl
0691   038D 07 E1 06      call printnl
0692   0390 0A 29 03      jmp menu
0693   0393             status2:
0694   0393 07 E1 06      call printnl
0695   0396 3B C8 FF      mov d, $FFC8    ; wd1770 status 
0696   0399 19 04         mov al, 4       ; getparam call
0697   039B 32            mov bl, [d]
0698   039C 07 D4 07      call print_u8x   ; print bl
0699   039F 07 E1 06      call printnl
0700   03A2 0A 29 03      jmp menu
0701   03A5             format:
0702   03A5 3B 70 04      mov d, s_track
0703   03A8 07 34 07      call _puts
0704   03AB 07 1F 08      call scan_u8x   ; in al
0705   03AE 2F            mov bl, al      ; track needs to be in bl
0706   03AF 19 00         mov al, 0       ; 0 = format
0707   03B1 05 02         syscall sys_fdc 
0708   03B3 3B 37 02      mov d, s_format_done
0709   03B6 07 34 07      call _puts
0710   03B9 0A 29 03      jmp menu
0711   03BC             read:
0712   03BC 05 03         syscall sys_fdc_read
0713   03BE 0A 29 03      jmp menu
0714   03C1             read_sec:
0715   03C1 3B D9 03      mov d, s1
0716   03C4 07 34 07      call _puts
0717   03C7 07 1F 08      call scan_u8x
0718   03CA 23            mov ah, al
0719   03CB 3B E2 03      mov d, s2
0720   03CE 07 34 07      call _puts
0721   03D1 07 1F 08      call scan_u8x ; in al
0722   03D4               
0723   03D4 05 04         syscall sys_fdc_read_sec
0724   03D6 0A 29 03      jmp menu
0725   03D9 0A 74 72 61 s1:.db "\ntrack: ", 0
0725   03DD 63 6B 3A 20 
0725   03E1 00 
0726   03E2 0A 73 65 63 s2:.db "\nsector: ", 0
0726   03E6 74 6F 72 3A 
0726   03EA 20 00 
0727   03EC             
0728   03EC             ; b : len
0729   03EC             cmd_hexd:
0730   03EC 10 CB 11      mov a, transient_area
0731   03EF 42 6C 04      mov [start], a
0732   03F2 11            mov a, b
0733   03F3 42 6E 04      mov [length], a
0734   03F6             
0735   03F6 14 6C 04    	mov a, [start]
0736   03F9 3C            mov d, a        ; dump pointer in d
0737   03FA 38 00 00      mov c, 0
0738   03FD             dump_loop:
0739   03FD 84            mov al, cl
0740   03FE 87 0F         and al, $0F
0741   0400 C6 4F 04      jz print_base
0742   0403             back:
0743   0403 1E            mov al, [d]        ; read byte
0744   0404 2F            mov bl, al
0745   0405 07 D4 07      call print_u8x
0746   0408 10 00 20      mov a, $2000
0747   040B 05 00         syscall sys_io      ; space
0748   040D 84            mov al, cl
0749   040E 87 0F         and al, $0F
0750   0410 B9 0F         cmp al, $0F
0751   0412 C6 29 04      je print_ascii
0752   0415             back1:
0753   0415 79            inc d
0754   0416 78            inc c
0755   0417 14 6E 04      mov a, [length]
0756   041A B1            cmp a, c
0757   041B C7 FD 03      jne dump_loop
0758   041E               
0759   041E 10 00 0A      mov a, $0A00
0760   0421 05 00         syscall sys_io
0761   0423 10 00 0D      mov a, $0D00
0762   0426 05 00         syscall sys_io
0763   0428               ;call printnl
0764   0428             
0765   0428 09            ret
0766   0429             print_ascii:
0767   0429 63 10 00      sub d, 16
0768   042C 26 10 00      mov b, 16
0769   042F             print_ascii_L:
0770   042F 79            inc d
0771   0430 1E            mov al, [d]        ; read byte
0772   0431 B9 20         cmp al, $20
0773   0433 C8 3B 04      jlu dot
0774   0436 B9 7E         cmp al, $7E
0775   0438 D0 43 04      jleu ascii
0776   043B             dot:
0777   043B 10 00 2E      mov a, $2E00
0778   043E 05 00         syscall sys_io
0779   0440 0A 48 04      jmp ascii_continue
0780   0443             ascii:
0781   0443 23            mov ah, al
0782   0444 19 00         mov al, 0
0783   0446 05 00         syscall sys_io
0784   0448             ascii_continue:
0785   0448 FD A9 2F 04   loopb print_ascii_L
0786   044C 0A 15 04      jmp back1
0787   044F             print_base:
0788   044F 10 00 0A      mov a, $0A00
0789   0452 05 00         syscall sys_io
0790   0454 10 00 0D      mov a, $0D00
0791   0457 05 00         syscall sys_io
0792   0459 2D            mov b, d
0793   045A 61 CB 11      sub b, transient_area
0794   045D 07 90 07      call print_u16x        ; display row
0795   0460 55 CB 11      add b, transient_area
0796   0463 10 00 20      mov a, $2000
0797   0466 05 00         syscall sys_io
0798   0468 0A 03 04      jmp back
0799   046B             
0800   046B 09            ret
0801   046C             
0802   046C 00 00       start:  .dw 0
0803   046E 00 04       length: .dw 1024
0804   0470             
0805   0470             
0806   0470 0A 74 72 61 s_track: .db "\ntrack: ", 0
0806   0474 63 6B 3A 20 
0806   0478 00 
0807   0479             
0808   0479 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0808   047D 73 74 65 70 
0808   0481 20 69 6E 0A 
0809   0485 31 2E 20 73         .db "1. step out\n", 
0809   0489 74 65 70 20 
0809   048D 6F 75 74 0A 
0810   0491 32 2E 20 72         .db "2. restore\n", 
0810   0495 65 73 74 6F 
0810   0499 72 65 0A 
0811   049C 33 2E 20 72         .db "3. read status 1\n", 
0811   04A0 65 61 64 20 
0811   04A4 73 74 61 74 
0811   04A8 75 73 20 31 
0811   04AC 0A 
0812   04AD 34 2E 20 72         .db "4. read status 2\n", 
0812   04B1 65 61 64 20 
0812   04B5 73 74 61 74 
0812   04B9 75 73 20 32 
0812   04BD 0A 
0813   04BE 35 2E 20 66         .db "5. format track\n", 
0813   04C2 6F 72 6D 61 
0813   04C6 74 20 74 72 
0813   04CA 61 63 6B 0A 
0814   04CE 36 2E 20 72         .db "6. read track\n", 
0814   04D2 65 61 64 20 
0814   04D6 74 72 61 63 
0814   04DA 6B 0A 
0815   04DC 37 2E 20 72         .db "7. read sector\n", 
0815   04E0 65 61 64 20 
0815   04E4 73 65 63 74 
0815   04E8 6F 72 0A 
0816   04EB 0A 73 65 6C         .db "\nselect option: ", 0
0816   04EF 65 63 74 20 
0816   04F3 6F 70 74 69 
0816   04F7 6F 6E 3A 20 
0816   04FB 00 
0817   04FC             
0818   04FC 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0818   0500 65 63 74 69 
0818   0504 6E 67 20 64 
0818   0508 72 69 76 65 
0818   050C 20 31 2E 2E 
0818   0510 2E 0A 00 
0819   0513 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0819   0517 74 69 6E 67 
0819   051B 2E 2E 2E 0A 
0819   051F 00 
0820   0520             
0821   0520             
0822   0520             
0823   0520             ; FILE INCLUDES
0824   0520             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  0520             BIOS_RESET_VECTOR .EQU  $01c0
0002+  0520             IDE_buffer       .EQU  $8204
0003+  0520             boot_origin      .EQU  $8004
0004+  0520             bios_uart        .EQU  $0002
0005+  0520             bios_ide         .EQU  $0003
0825   0520             .include "lib/stdio.asm"
0001+  0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0520             ; stdio.s
0003+  0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0520             .include "lib/string.asm"
0001++ 0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0520             ; string.s
0003++ 0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0520             
0005++ 0520             
0006++ 0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0520             ; _strrev
0008++ 0520             ; reverse a string
0009++ 0520             ; D = string address
0010++ 0520             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0520             ; 01234
0012++ 0520             _strrev:
0013++ 0520 4B          	pusha
0014++ 0521 07 67 05    	call _strlen	; length in C
0015++ 0524 12          	mov a, c
0016++ 0525 AF 01 00    	cmp a, 1
0017++ 0528 D0 42 05    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 052B 7D          	dec a
0019++ 052C FD 4E       	mov si, d	; beginning of string
0020++ 052E FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0530 59          	add d, a	; end of string
0022++ 0531 12          	mov a, c
0023++ 0532 FD 9B       	shr a		; divide by 2
0024++ 0534 39          	mov c, a	; C now counts the steps
0025++ 0535             _strrev_L0:
0026++ 0535 32          	mov bl, [d]	; save load right-side char into BL
0027++ 0536 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 0537 3E          	mov [d], al	; store left char into right side
0029++ 0538 1B          	mov al, bl
0030++ 0539 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 053A 7E          	dec c
0032++ 053B 7F          	dec d
0033++ 053C C2 00 00    	cmp c, 0
0034++ 053F C7 35 05    	jne _strrev_L0
0035++ 0542             _strrev_end:
0036++ 0542 4C          	popa
0037++ 0543 09          	ret
0038++ 0544             	
0039++ 0544             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0544             ; _strchr
0041++ 0544             ; search string in D for char in AL
0042++ 0544             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0544             _strchr:
0044++ 0544             _strchr_L0:
0045++ 0544 32          	mov bl, [d]
0046++ 0545 C1 00       	cmp bl, 0
0047++ 0547 C6 52 05    	je _strchr_end
0048++ 054A BA          	cmp al, bl
0049++ 054B C6 52 05    	je _strchr_end
0050++ 054E 79          	inc d
0051++ 054F 0A 44 05    	jmp _strchr_L0
0052++ 0552             _strchr_end:
0053++ 0552 1B          	mov al, bl
0054++ 0553 09          	ret
0055++ 0554             
0056++ 0554             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0554             ; _strstr
0058++ 0554             ; find sub-string
0059++ 0554             ; str1 in SI
0060++ 0554             ; str2 in DI
0061++ 0554             ; SI points to end of source string
0062++ 0554             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0554             _strstr:
0064++ 0554 DB          	push al
0065++ 0555 DA          	push d
0066++ 0556 E3          	push di
0067++ 0557             _strstr_loop:
0068++ 0557 F3          	cmpsb					; compare a byte of the strings
0069++ 0558 C7 63 05    	jne _strstr_ret
0070++ 055B FC 00 00    	lea d, [di + 0]
0071++ 055E BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 0560 C7 57 05    	jne _strstr_loop				; equal chars but not at end
0073++ 0563             _strstr_ret:
0074++ 0563 F0          	pop di
0075++ 0564 E7          	pop d
0076++ 0565 E8          	pop al
0077++ 0566 09          	ret
0078++ 0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0567             ; length of null terminated string
0080++ 0567             ; result in C
0081++ 0567             ; pointer in D
0082++ 0567             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0567             _strlen:
0084++ 0567 DA          	push d
0085++ 0568 38 00 00    	mov c, 0
0086++ 056B             _strlen_L1:
0087++ 056B BD 00       	cmp byte [d], 0
0088++ 056D C6 75 05    	je _strlen_ret
0089++ 0570 79          	inc d
0090++ 0571 78          	inc c
0091++ 0572 0A 6B 05    	jmp _strlen_L1
0092++ 0575             _strlen_ret:
0093++ 0575 E7          	pop d
0094++ 0576 09          	ret
0095++ 0577             
0096++ 0577             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0577             ; STRCMP
0098++ 0577             ; compare two strings
0099++ 0577             ; str1 in SI
0100++ 0577             ; str2 in DI
0101++ 0577             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0577             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0577             _strcmp:
0104++ 0577 DB          	push al
0105++ 0578 DA          	push d
0106++ 0579 E3          	push di
0107++ 057A E2          	push si
0108++ 057B             _strcmp_loop:
0109++ 057B F3          	cmpsb					; compare a byte of the strings
0110++ 057C C7 87 05    	jne _strcmp_ret
0111++ 057F FB FF FF    	lea d, [si +- 1]
0112++ 0582 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0584 C7 7B 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 0587             _strcmp_ret:
0115++ 0587 EF          	pop si
0116++ 0588 F0          	pop di
0117++ 0589 E7          	pop d
0118++ 058A E8          	pop al
0119++ 058B 09          	ret
0120++ 058C             
0121++ 058C             
0122++ 058C             ; STRCPY
0123++ 058C             ; copy null terminated string from SI to DI
0124++ 058C             ; source in SI
0125++ 058C             ; destination in DI
0126++ 058C             _strcpy:
0127++ 058C E2          	push si
0128++ 058D E3          	push di
0129++ 058E DB          	push al
0130++ 058F             _strcpy_L1:
0131++ 058F F6          	lodsb
0132++ 0590 F7          	stosb
0133++ 0591 B9 00       	cmp al, 0
0134++ 0593 C7 8F 05    	jne _strcpy_L1
0135++ 0596             _strcpy_end:
0136++ 0596 E8          	pop al
0137++ 0597 F0          	pop di
0138++ 0598 EF          	pop si
0139++ 0599 09          	ret
0140++ 059A             
0141++ 059A             ; STRCAT
0142++ 059A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 059A             ; source in SI
0144++ 059A             ; destination in DI
0145++ 059A             _strcat:
0146++ 059A E2          	push si
0147++ 059B E3          	push di
0148++ 059C D7          	push a
0149++ 059D DA          	push d
0150++ 059E 50          	mov a, di
0151++ 059F 3C          	mov d, a
0152++ 05A0             _strcat_goto_end_L1:
0153++ 05A0 BD 00       	cmp byte[d], 0
0154++ 05A2 C6 A9 05    	je _strcat_start
0155++ 05A5 79          	inc d
0156++ 05A6 0A A0 05    	jmp _strcat_goto_end_L1
0157++ 05A9             _strcat_start:
0158++ 05A9 FD 50       	mov di, d
0159++ 05AB             _strcat_L1:
0160++ 05AB F6          	lodsb
0161++ 05AC F7          	stosb
0162++ 05AD B9 00       	cmp al, 0
0163++ 05AF C7 AB 05    	jne _strcat_L1
0164++ 05B2             _strcat_end:
0165++ 05B2 E7          	pop d
0166++ 05B3 E4          	pop a
0167++ 05B4 F0          	pop di
0168++ 05B5 EF          	pop si
0169++ 05B6 09          	ret
0170++ 05B7             
0171++ 05B7             
0005+  05B7             
0006+  05B7             
0007+  05B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  05B7             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  05B7             ; ASCII in BL
0010+  05B7             ; result in AL
0011+  05B7             ; ascii for F = 0100 0110
0012+  05B7             ; ascii for 9 = 0011 1001
0013+  05B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  05B7             hex_ascii_encode:
0015+  05B7 1B            mov al, bl
0016+  05B8 93 40         test al, $40        ; test if letter or number
0017+  05BA C7 C0 05      jnz hex_letter
0018+  05BD 87 0F         and al, $0F        ; get number
0019+  05BF 09            ret
0020+  05C0             hex_letter:
0021+  05C0 87 0F         and al, $0F        ; get letter
0022+  05C2 6A 09         add al, 9
0023+  05C4 09            ret
0024+  05C5             
0025+  05C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  05C5             ; ATOI
0027+  05C5             ; 2 letter hex string in B
0028+  05C5             ; 8bit integer returned in AL
0029+  05C5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  05C5             _atoi:
0031+  05C5 D8            push b
0032+  05C6 07 B7 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  05C9 30            mov bl, bh
0034+  05CA DB            push al          ; save a
0035+  05CB 07 B7 05      call hex_ascii_encode
0036+  05CE EA            pop bl  
0037+  05CF FD 9E 04      shl al, 4
0038+  05D2 8C            or al, bl
0039+  05D3 E5            pop b
0040+  05D4 09            ret  
0041+  05D5             
0042+  05D5             
0043+  05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  05D5             ; scanf
0045+  05D5             ; no need for explanations!
0046+  05D5             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  05D5             scanf:
0048+  05D5 09            ret
0049+  05D6             
0050+  05D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  05D6             ; ITOA
0052+  05D6             ; 8bit value in BL
0053+  05D6             ; 2 byte ASCII result in A
0054+  05D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  05D6             _itoa:
0056+  05D6 DA            push d
0057+  05D7 D8            push b
0058+  05D8 A7 00         mov bh, 0
0059+  05DA FD A4 04      shr bl, 4  
0060+  05DD 74            mov d, b
0061+  05DE 1F 70 08      mov al, [d + s_hex_digits]
0062+  05E1 23            mov ah, al
0063+  05E2               
0064+  05E2 E5            pop b
0065+  05E3 D8            push b
0066+  05E4 A7 00         mov bh, 0
0067+  05E6 FD 87 0F      and bl, $0F
0068+  05E9 74            mov d, b
0069+  05EA 1F 70 08      mov al, [d + s_hex_digits]
0070+  05ED E5            pop b
0071+  05EE E7            pop d
0072+  05EF 09            ret
0073+  05F0             
0074+  05F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  05F0             ; HEX STRING TO BINARY
0076+  05F0             ; di = destination address
0077+  05F0             ; si = source
0078+  05F0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  05F0             _hex_to_int:
0080+  05F0             _hex_to_int_L1:
0081+  05F0 F6            lodsb          ; load from [SI] to AL
0082+  05F1 B9 00         cmp al, 0        ; check if ASCII 0
0083+  05F3 C6 00 06      jz _hex_to_int_ret
0084+  05F6 36            mov bh, al
0085+  05F7 F6            lodsb
0086+  05F8 2F            mov bl, al
0087+  05F9 07 C5 05      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  05FC F7            stosb          ; store AL to [DI]
0089+  05FD 0A F0 05      jmp _hex_to_int_L1
0090+  0600             _hex_to_int_ret:
0091+  0600 09            ret    
0092+  0601             
0093+  0601             
0094+  0601             
0095+  0601             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0601             ; GETCHAR
0097+  0601             ; char in ah
0098+  0601             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0601             getch:
0100+  0601 DB            push al
0101+  0602             getch_retry:
0102+  0602 19 01         mov al, 1
0103+  0604 05 00         syscall sys_io      ; receive in AH
0104+  0606 E8            pop al
0105+  0607 09            ret
0106+  0608             
0107+  0608             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0608             ; PUTCHAR
0109+  0608             ; char in ah
0110+  0608             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0608             _putchar:
0112+  0608 DB            push al
0113+  0609 19 00         mov al, 0
0114+  060B 05 00         syscall sys_io      ; char in AH
0115+  060D E8            pop al
0116+  060E 09            ret
0117+  060F             
0118+  060F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  060F             ;; INPUT A STRING
0120+  060F             ;; terminates with null
0121+  060F             ;; pointer in D
0122+  060F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  060F             _gets:
0124+  060F D7            push a
0125+  0610 DA            push d
0126+  0611             _gets_loop:
0127+  0611 19 01         mov al, 1
0128+  0613 05 00         syscall sys_io      ; receive in AH
0129+  0615 76 1B         cmp ah, 27
0130+  0617 C6 38 06      je _gets_ansi_esc
0131+  061A 76 0A         cmp ah, $0A        ; LF
0132+  061C C6 94 06      je _gets_end
0133+  061F 76 0D         cmp ah, $0D        ; CR
0134+  0621 C6 94 06      je _gets_end
0135+  0624 76 5C         cmp ah, $5C        ; '\\'
0136+  0626 C6 5A 06      je _gets_escape
0137+  0629 76 08         cmp ah, $08      ; check for backspace
0138+  062B C6 34 06      je _gets_backspace
0139+  062E 1A            mov al, ah
0140+  062F 3E            mov [d], al
0141+  0630 79            inc d
0142+  0631 0A 11 06      jmp _gets_loop
0143+  0634             _gets_backspace:
0144+  0634 7F            dec d
0145+  0635 0A 11 06      jmp _gets_loop
0146+  0638             _gets_ansi_esc:
0147+  0638 19 01         mov al, 1
0148+  063A 05 00         syscall sys_io        ; receive in AH without echo
0149+  063C 76 5B         cmp ah, '['
0150+  063E C7 11 06      jne _gets_loop
0151+  0641 19 01         mov al, 1
0152+  0643 05 00         syscall sys_io          ; receive in AH without echo
0153+  0645 76 44         cmp ah, 'D'
0154+  0647 C6 52 06      je _gets_left_arrow
0155+  064A 76 43         cmp ah, 'C'
0156+  064C C6 56 06      je _gets_right_arrow
0157+  064F 0A 11 06      jmp _gets_loop
0158+  0652             _gets_left_arrow:
0159+  0652 7F            dec d
0160+  0653 0A 11 06      jmp _gets_loop
0161+  0656             _gets_right_arrow:
0162+  0656 79            inc d
0163+  0657 0A 11 06      jmp _gets_loop
0164+  065A             _gets_escape:
0165+  065A 19 01         mov al, 1
0166+  065C 05 00         syscall sys_io      ; receive in AH
0167+  065E 76 6E         cmp ah, 'n'
0168+  0660 C6 7F 06      je _gets_LF
0169+  0663 76 72         cmp ah, 'r'
0170+  0665 C6 86 06      je _gets_CR
0171+  0668 76 30         cmp ah, '0'
0172+  066A C6 8D 06      je _gets_NULL
0173+  066D 76 5C         cmp ah, $5C  ; '\'
0174+  066F C6 78 06      je _gets_slash
0175+  0672 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0673 3E            mov [d], al
0177+  0674 79            inc d
0178+  0675 0A 11 06      jmp _gets_loop
0179+  0678             _gets_slash:
0180+  0678 19 5C         mov al, $5C
0181+  067A 3E            mov [d], al
0182+  067B 79            inc d
0183+  067C 0A 11 06      jmp _gets_loop
0184+  067F             _gets_LF:
0185+  067F 19 0A         mov al, $0A
0186+  0681 3E            mov [d], al
0187+  0682 79            inc d
0188+  0683 0A 11 06      jmp _gets_loop
0189+  0686             _gets_CR:
0190+  0686 19 0D         mov al, $0D
0191+  0688 3E            mov [d], al
0192+  0689 79            inc d
0193+  068A 0A 11 06      jmp _gets_loop
0194+  068D             _gets_NULL:
0195+  068D 19 00         mov al, $00
0196+  068F 3E            mov [d], al
0197+  0690 79            inc d
0198+  0691 0A 11 06      jmp _gets_loop
0199+  0694             _gets_end:
0200+  0694 19 00         mov al, 0
0201+  0696 3E            mov [d], al        ; terminate string
0202+  0697 E7            pop d
0203+  0698 E4            pop a
0204+  0699 09            ret
0205+  069A             
0206+  069A             
0207+  069A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  069A             ;; INPUT TEXT
0209+  069A             ;; terminated with CTRL+D
0210+  069A             ;; pointer in D
0211+  069A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  069A             _gettxt:
0213+  069A D7            push a
0214+  069B DA            push d
0215+  069C             _gettxt_loop:
0216+  069C 19 01         mov al, 1
0217+  069E 05 00         syscall sys_io      ; receive in AH
0218+  06A0 76 04         cmp ah, 4      ; EOT
0219+  06A2 C6 DB 06      je _gettxt_end
0220+  06A5 76 08         cmp ah, $08      ; check for backspace
0221+  06A7 C6 D7 06      je _gettxt_backspace
0222+  06AA 76 5C         cmp ah, $5C        ; '\'
0223+  06AC C6 B5 06      je _gettxt_escape
0224+  06AF 1A            mov al, ah
0225+  06B0 3E            mov [d], al
0226+  06B1 79            inc d
0227+  06B2 0A 9C 06      jmp _gettxt_loop
0228+  06B5             _gettxt_escape:
0229+  06B5 19 01         mov al, 1
0230+  06B7 05 00         syscall sys_io      ; receive in AH
0231+  06B9 76 6E         cmp ah, 'n'
0232+  06BB C6 C9 06      je _gettxt_LF
0233+  06BE 76 72         cmp ah, 'r'
0234+  06C0 C6 D0 06      je _gettxt_CR
0235+  06C3 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  06C4 3E            mov [d], al
0237+  06C5 79            inc d
0238+  06C6 0A 9C 06      jmp _gettxt_loop
0239+  06C9             _gettxt_LF:
0240+  06C9 19 0A         mov al, $0A
0241+  06CB 3E            mov [d], al
0242+  06CC 79            inc d
0243+  06CD 0A 9C 06      jmp _gettxt_loop
0244+  06D0             _gettxt_CR:
0245+  06D0 19 0D         mov al, $0D
0246+  06D2 3E            mov [d], al
0247+  06D3 79            inc d
0248+  06D4 0A 9C 06      jmp _gettxt_loop
0249+  06D7             _gettxt_backspace:
0250+  06D7 7F            dec d
0251+  06D8 0A 9C 06      jmp _gettxt_loop
0252+  06DB             _gettxt_end:
0253+  06DB 19 00         mov al, 0
0254+  06DD 3E            mov [d], al        ; terminate string
0255+  06DE E7            pop d
0256+  06DF E4            pop a
0257+  06E0 09            ret
0258+  06E1             
0259+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  06E1             ; PRINT NEW LINE
0261+  06E1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  06E1             printnl:
0263+  06E1 D7            push a
0264+  06E2 10 00 0A      mov a, $0A00
0265+  06E5 05 00         syscall sys_io
0266+  06E7 10 00 0D      mov a, $0D00
0267+  06EA 05 00         syscall sys_io
0268+  06EC E4            pop a
0269+  06ED 09            ret
0270+  06EE             
0271+  06EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  06EE             ; _strtoint
0273+  06EE             ; 4 digit hex string number in d
0274+  06EE             ; integer returned in A
0275+  06EE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  06EE             _strtointx:
0277+  06EE D8            push b
0278+  06EF 32            mov bl, [d]
0279+  06F0 37            mov bh, bl
0280+  06F1 33 01 00      mov bl, [d + 1]
0281+  06F4 07 C5 05      call _atoi        ; convert to int in AL
0282+  06F7 23            mov ah, al        ; move to AH
0283+  06F8 33 02 00      mov bl, [d + 2]
0284+  06FB 37            mov bh, bl
0285+  06FC 33 03 00      mov bl, [d + 3]
0286+  06FF 07 C5 05      call _atoi        ; convert to int in AL
0287+  0702 E5            pop b
0288+  0703 09            ret
0289+  0704             
0290+  0704             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0704             ; _strtoint
0292+  0704             ; 5 digit base10 string number in d
0293+  0704             ; integer returned in A
0294+  0704             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0704             _strtoint:
0296+  0704 E2            push si
0297+  0705 D8            push b
0298+  0706 D9            push c
0299+  0707 DA            push d
0300+  0708 07 67 05      call _strlen      ; get string length in C
0301+  070B 7E            dec c
0302+  070C FD 4E         mov si, d
0303+  070E 12            mov a, c
0304+  070F FD 99         shl a
0305+  0711 3B 88 08      mov d, table_power
0306+  0714 59            add d, a
0307+  0715 38 00 00      mov c, 0
0308+  0718             _strtoint_L0:
0309+  0718 F6            lodsb      ; load ASCII to al
0310+  0719 B9 00         cmp al, 0
0311+  071B C6 2E 07      je _strtoint_end
0312+  071E 6F 30         sub al, $30    ; make into integer
0313+  0720 22 00         mov ah, 0
0314+  0722 2A            mov b, [d]
0315+  0723 AC            mul a, b      ; result in B since it fits in 16bits
0316+  0724 11            mov a, b
0317+  0725 28            mov b, c
0318+  0726 54            add a, b
0319+  0727 39            mov c, a
0320+  0728 63 02 00      sub d, 2
0321+  072B 0A 18 07      jmp _strtoint_L0
0322+  072E             _strtoint_end:
0323+  072E 12            mov a, c
0324+  072F E7            pop d
0325+  0730 E6            pop c
0326+  0731 E5            pop b
0327+  0732 EF            pop si
0328+  0733 09            ret
0329+  0734             
0330+  0734             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0734             ; PRINT NULL TERMINATED STRING
0332+  0734             ; pointer in D
0333+  0734             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0734             _puts:
0335+  0734 D7            push a
0336+  0735 DA            push d
0337+  0736             _puts_L1:
0338+  0736 1E            mov al, [d]
0339+  0737 B9 00         cmp al, 0
0340+  0739 C6 45 07      jz _puts_END
0341+  073C 23            mov ah, al
0342+  073D 19 00         mov al, 0
0343+  073F 05 00         syscall sys_io
0344+  0741 79            inc d
0345+  0742 0A 36 07      jmp _puts_L1
0346+  0745             _puts_END:
0347+  0745 E7            pop d
0348+  0746 E4            pop a
0349+  0747 09            ret
0350+  0748             
0351+  0748             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0748             ; PRINT N SIZE STRING
0353+  0748             ; pointer in D
0354+  0748             ; size in C
0355+  0748             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0748             _putsn:
0357+  0748 DB            push al
0358+  0749 DA            push d
0359+  074A D9            push c
0360+  074B             _putsn_L0:
0361+  074B 1E            mov al, [d]
0362+  074C 23            mov ah, al
0363+  074D 19 00         mov al, 0
0364+  074F 05 00         syscall sys_io
0365+  0751 79            inc d
0366+  0752 7E            dec c  
0367+  0753 C2 00 00      cmp c, 0
0368+  0756 C7 4B 07      jne _putsn_L0
0369+  0759             _putsn_end:
0370+  0759 E6            pop c
0371+  075A E7            pop d
0372+  075B E8            pop al
0373+  075C 09            ret
0374+  075D             
0375+  075D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  075D             ; print 16bit decimal number
0377+  075D             ; input number in A
0378+  075D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  075D             print_u16d:
0380+  075D D7            push a
0381+  075E D8            push b
0382+  075F FD D8         push g
0383+  0761 26 10 27      mov b, 10000
0384+  0764 AE            div a, b      ; get 10000's coeff.
0385+  0765 07 89 07      call print_number
0386+  0768 11            mov a, b
0387+  0769 26 E8 03      mov b, 1000
0388+  076C AE            div a, b      ; get 1000's coeff.
0389+  076D 07 89 07      call print_number
0390+  0770 11            mov a, b
0391+  0771 26 64 00      mov b, 100
0392+  0774 AE            div a, b
0393+  0775 07 89 07      call print_number
0394+  0778 11            mov a, b
0395+  0779 26 0A 00      mov b, 10
0396+  077C AE            div a, b
0397+  077D 07 89 07      call print_number
0398+  0780 1B            mov al, bl      ; 1's coeff in bl
0399+  0781 07 89 07      call print_number
0400+  0784 FD F1         pop g
0401+  0786 E5            pop b
0402+  0787 E4            pop a
0403+  0788 09            ret
0404+  0789             
0405+  0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0789             ; print AL
0407+  0789             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0789             print_number:
0409+  0789 6A 30         add al, $30
0410+  078B 23            mov ah, al
0411+  078C 07 08 06      call _putchar
0412+  078F 09            ret
0413+  0790             
0414+  0790             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0790             ; PRINT 16BIT HEX INTEGER
0416+  0790             ; integer value in reg B
0417+  0790             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0790             print_u16x:
0419+  0790 D7            push a
0420+  0791 D8            push b
0421+  0792 DD            push bl
0422+  0793 30            mov bl, bh
0423+  0794 07 D6 05      call _itoa        ; convert bh to char in A
0424+  0797 2F            mov bl, al        ; save al
0425+  0798 19 00         mov al, 0
0426+  079A 05 00         syscall sys_io        ; display AH
0427+  079C 24            mov ah, bl        ; retrieve al
0428+  079D 19 00         mov al, 0
0429+  079F 05 00         syscall sys_io        ; display AL
0430+  07A1             
0431+  07A1 EA            pop bl
0432+  07A2 07 D6 05      call _itoa        ; convert bh to char in A
0433+  07A5 2F            mov bl, al        ; save al
0434+  07A6 19 00         mov al, 0
0435+  07A8 05 00         syscall sys_io        ; display AH
0436+  07AA 24            mov ah, bl        ; retrieve al
0437+  07AB 19 00         mov al, 0
0438+  07AD 05 00         syscall sys_io        ; display AL
0439+  07AF             
0440+  07AF E5            pop b
0441+  07B0 E4            pop a
0442+  07B1 09            ret
0443+  07B2             
0444+  07B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  07B2             ; INPUT 16BIT HEX INTEGER
0446+  07B2             ; read 16bit integer into A
0447+  07B2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  07B2             scan_u16x:
0449+  07B2 F8 10 00      enter 16
0450+  07B5 D8            push b
0451+  07B6 DA            push d
0452+  07B7             
0453+  07B7 FA F1 FF      lea d, [bp + -15]
0454+  07BA 07 0F 06      call _gets        ; get number
0455+  07BD             
0456+  07BD 32            mov bl, [d]
0457+  07BE 37            mov bh, bl
0458+  07BF 33 01 00      mov bl, [d + 1]
0459+  07C2 07 C5 05      call _atoi        ; convert to int in AL
0460+  07C5 23            mov ah, al        ; move to AH
0461+  07C6             
0462+  07C6 33 02 00      mov bl, [d + 2]
0463+  07C9 37            mov bh, bl
0464+  07CA 33 03 00      mov bl, [d + 3]
0465+  07CD 07 C5 05      call _atoi        ; convert to int in AL
0466+  07D0             
0467+  07D0 E7            pop d
0468+  07D1 E5            pop b
0469+  07D2 F9            leave
0470+  07D3 09            ret
0471+  07D4             
0472+  07D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  07D4             ; PRINT 8bit HEX INTEGER
0474+  07D4             ; integer value in reg bl
0475+  07D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  07D4             print_u8x:
0477+  07D4 D7            push a
0478+  07D5 DD            push bl
0479+  07D6             
0480+  07D6 07 D6 05      call _itoa        ; convert bl to char in A
0481+  07D9 2F            mov bl, al        ; save al
0482+  07DA 19 00         mov al, 0
0483+  07DC 05 00         syscall sys_io        ; display AH
0484+  07DE 24            mov ah, bl        ; retrieve al
0485+  07DF 19 00         mov al, 0
0486+  07E1 05 00         syscall sys_io        ; display AL
0487+  07E3             
0488+  07E3 EA            pop bl
0489+  07E4 E4            pop a
0490+  07E5 09            ret
0491+  07E6             
0492+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  07E6             ; print 8bit decimal unsigned number
0494+  07E6             ; input number in AL
0495+  07E6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  07E6             print_u8d:
0497+  07E6 D7            push a
0498+  07E7 D8            push b
0499+  07E8 FD D8         push g
0500+  07EA 22 00         mov ah, 0
0501+  07EC 26 64 00      mov b, 100
0502+  07EF AE            div a, b
0503+  07F0 D8            push b      ; save remainder
0504+  07F1 B9 00         cmp al, 0
0505+  07F3 C6 FD 07      je skip100
0506+  07F6 6A 30         add al, $30
0507+  07F8 23            mov ah, al
0508+  07F9 19 00         mov al, 0
0509+  07FB 05 00         syscall sys_io  ; print coeff
0510+  07FD             skip100:
0511+  07FD E4            pop a
0512+  07FE 22 00         mov ah, 0
0513+  0800 26 0A 00      mov b, 10
0514+  0803 AE            div a, b
0515+  0804 D8            push b      ; save remainder
0516+  0805 B9 00         cmp al, 0
0517+  0807 C6 11 08      je skip10
0518+  080A 6A 30         add al, $30
0519+  080C 23            mov ah, al
0520+  080D 19 00         mov al, 0
0521+  080F 05 00         syscall sys_io  ; print coeff
0522+  0811             skip10:
0523+  0811 E4            pop a
0524+  0812 1B            mov al, bl
0525+  0813 6A 30         add al, $30
0526+  0815 23            mov ah, al
0527+  0816 19 00         mov al, 0
0528+  0818 05 00         syscall sys_io  ; print coeff
0529+  081A FD F1         pop g
0530+  081C E5            pop b
0531+  081D E4            pop a
0532+  081E 09            ret
0533+  081F             
0534+  081F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  081F             ; INPUT 8BIT HEX INTEGER
0536+  081F             ; read 8bit integer into AL
0537+  081F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  081F             scan_u8x:
0539+  081F F8 04 00      enter 4
0540+  0822 D8            push b
0541+  0823 DA            push d
0542+  0824             
0543+  0824 FA FD FF      lea d, [bp + -3]
0544+  0827 07 0F 06      call _gets        ; get number
0545+  082A             
0546+  082A 32            mov bl, [d]
0547+  082B 37            mov bh, bl
0548+  082C 33 01 00      mov bl, [d + 1]
0549+  082F 07 C5 05      call _atoi        ; convert to int in AL
0550+  0832             
0551+  0832 E7            pop d
0552+  0833 E5            pop b
0553+  0834 F9            leave
0554+  0835 09            ret
0555+  0836             
0556+  0836             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0836             ; input decimal number
0558+  0836             ; result in A
0559+  0836             ; 655'\0'
0560+  0836             ; low--------high
0561+  0836             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0836             scan_u16d:
0563+  0836 F8 08 00      enter 8
0564+  0839 E2            push si
0565+  083A D8            push b
0566+  083B D9            push c
0567+  083C DA            push d
0568+  083D FA F9 FF      lea d, [bp +- 7]
0569+  0840 07 0F 06      call _gets
0570+  0843 07 67 05      call _strlen      ; get string length in C
0571+  0846 7E            dec c
0572+  0847 FD 4E         mov si, d
0573+  0849 12            mov a, c
0574+  084A FD 99         shl a
0575+  084C 3B 88 08      mov d, table_power
0576+  084F 59            add d, a
0577+  0850 38 00 00      mov c, 0
0578+  0853             mul_loop:
0579+  0853 F6            lodsb      ; load ASCII to al
0580+  0854 B9 00         cmp al, 0
0581+  0856 C6 69 08      je mul_exit
0582+  0859 6F 30         sub al, $30    ; make into integer
0583+  085B 22 00         mov ah, 0
0584+  085D 2A            mov b, [d]
0585+  085E AC            mul a, b      ; result in B since it fits in 16bits
0586+  085F 11            mov a, b
0587+  0860 28            mov b, c
0588+  0861 54            add a, b
0589+  0862 39            mov c, a
0590+  0863 63 02 00      sub d, 2
0591+  0866 0A 53 08      jmp mul_loop
0592+  0869             mul_exit:
0593+  0869 12            mov a, c
0594+  086A E7            pop d
0595+  086B E6            pop c
0596+  086C E5            pop b
0597+  086D EF            pop si
0598+  086E F9            leave
0599+  086F 09            ret
0600+  0870             
0601+  0870             
0602+  0870 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  0874 34 35 36 37 
0602+  0878 38 39 41 42 
0602+  087C 43 44 45 46 
0603+  0880 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  0884 1B 5B 48 00 
0604+  0888             
0605+  0888             table_power:
0606+  0888 01 00         .dw 1
0607+  088A 0A 00         .dw 10
0608+  088C 64 00         .dw 100
0609+  088E E8 03         .dw 1000
0610+  0890 10 27         .dw 100000826   0892             .include "lib/ctype.asm"
0001+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0892             ; ctype.s
0003+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0892             
0005+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0892             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0892             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0892             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0892             ;; characters are supported.
0010+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0892             ;; _isalnum 
0012+  0892             ;; _isalpha 
0013+  0892             ;; islower 
0014+  0892             ;; isupper 
0015+  0892             ;; _isdigit 
0016+  0892             ;; isxdigit
0017+  0892             ;; iscntrl 
0018+  0892             ;; isgraph 
0019+  0892             ;; _isspace 
0020+  0892             ;; isblank 
0021+  0892             ;; isprint 
0022+  0892             ;; ispunct 
0023+  0892             ;; tolower 
0024+  0892             ;; toupper
0025+  0892             
0026+  0892             
0027+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0892             ;; IS ALPHANUMERIC
0029+  0892             ;; sets ZF according with result
0030+  0892             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0892             _isalnum:
0032+  0892 07 AF 08    	call _isalpha
0033+  0895 C6 9B 08    	je _isalnum_exit
0034+  0898 07 9C 08    	call _isdigit
0035+  089B             _isalnum_exit:
0036+  089B 09          	ret	
0037+  089C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  089C             ;; IS DIGIT
0039+  089C             ;; sets ZF according with result
0040+  089C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  089C             _isdigit:
0042+  089C DB          	push al
0043+  089D B9 30       	cmp al, '0'
0044+  089F C8 AB 08    	jlu _isdigit_false
0045+  08A2 B9 39       	cmp al, '9'
0046+  08A4 D1 AB 08    	jgu _isdigit_false
0047+  08A7 87 00       	and al, 0	; set ZF
0048+  08A9 E8          	pop al
0049+  08AA 09          	ret
0050+  08AB             _isdigit_false:
0051+  08AB 8B 01       	or al, 1	; clear ZF
0052+  08AD E8          	pop al
0053+  08AE 09          	ret	
0054+  08AF             	
0055+  08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  08AF             ;; IS ALPHA
0057+  08AF             ;; sets ZF according with result
0058+  08AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08AF             _isalpha:
0060+  08AF DB          	push al
0061+  08B0 B9 5F       	cmp al, '_'
0062+  08B2 C6 D2 08    	je _isalpha_true
0063+  08B5 B9 2E       	cmp al, '.'
0064+  08B7 C6 D2 08    	je _isalpha_true
0065+  08BA B9 41       	cmp al, 'A'
0066+  08BC C8 CE 08    	jlu _isalpha_false
0067+  08BF B9 7A       	cmp al, 'z'
0068+  08C1 D1 CE 08    	jgu _isalpha_false
0069+  08C4 B9 5A       	cmp al, 'Z'
0070+  08C6 D0 D2 08    	jleu _isalpha_true
0071+  08C9 B9 61       	cmp al, 'a'
0072+  08CB C9 D2 08    	jgeu _isalpha_true
0073+  08CE             _isalpha_false:
0074+  08CE 8B 01       	or al, 1	; clear ZF
0075+  08D0 E8          	pop al
0076+  08D1 09          	ret
0077+  08D2             _isalpha_true:
0078+  08D2 87 00       	and al, 0	; set ZF
0079+  08D4 E8          	pop al
0080+  08D5 09          	ret
0081+  08D6             
0082+  08D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  08D6             ;; IS PATH-ALPHA
0084+  08D6             ;; sets ZF according with result
0085+  08D6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  08D6             ispath:
0087+  08D6 DB          	push al
0088+  08D7 07 9C 08    	call _isdigit
0089+  08DA C6 04 09    	je ispath_true
0090+  08DD B9 5F       	cmp al, '_'
0091+  08DF C6 04 09    	je ispath_true
0092+  08E2 B9 2F       	cmp al, '/'
0093+  08E4 C6 04 09    	je ispath_true
0094+  08E7 B9 2E       	cmp al, '.'
0095+  08E9 C6 04 09    	je ispath_true
0096+  08EC B9 41       	cmp al, 'A'
0097+  08EE C8 00 09    	jlu ispath_false
0098+  08F1 B9 7A       	cmp al, 'z'
0099+  08F3 D1 00 09    	jgu ispath_false
0100+  08F6 B9 5A       	cmp al, 'Z'
0101+  08F8 D0 04 09    	jleu ispath_true
0102+  08FB B9 61       	cmp al, 'a'
0103+  08FD C9 04 09    	jgeu ispath_true
0104+  0900             ispath_false:
0105+  0900 8B 01       	or al, 1	; clear ZF
0106+  0902 E8          	pop al
0107+  0903 09          	ret
0108+  0904             ispath_true:
0109+  0904 87 00       	and al, 0	; set ZF
0110+  0906 E8          	pop al
0111+  0907 09          	ret
0112+  0908             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0908             ;; IS SPACE
0114+  0908             ;; sets ZF according with result
0115+  0908             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0908             _isspace:
0117+  0908 B9 20       	cmp al, $20		; ' '
0118+  090A C6 1E 09    	je _isspace_exit
0119+  090D B9 09       	cmp al, $09		; '\t'
0120+  090F C6 1E 09    	je _isspace_exit
0121+  0912 B9 0A       	cmp al, $0A		; '\n'
0122+  0914 C6 1E 09    	je _isspace_exit
0123+  0917 B9 0D       	cmp al, $0D		; '\r'
0124+  0919 C6 1E 09    	je _isspace_exit
0125+  091C B9 0B       	cmp al, $0B		; '\v'
0126+  091E             _isspace_exit:
0127+  091E 09          	ret	
0128+  091F             
0129+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  091F             ; TO LOWER
0131+  091F             ; input in AL
0132+  091F             ; output in AL
0133+  091F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  091F             _to_lower:
0135+  091F B9 5A       	cmp al, 'Z'
0136+  0921 D1 26 09    	jgu _to_lower_ret
0137+  0924 6A 20       	add al, $20				; convert to lower case
0138+  0926             _to_lower_ret:
0139+  0926 09          	ret
0140+  0927             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0927             ; TO UPPER
0142+  0927             ; input in AL
0143+  0927             ; output in AL
0144+  0927             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0927             _to_upper:
0146+  0927 B9 61       	cmp al, 'a'
0147+  0929 C8 2E 09    	jlu _to_upper_ret
0148+  092C 6F 20       	sub al, $20			; convert to upper case
0149+  092E             _to_upper_ret:
0150+  092E 09          	ret
0151+  092F             
0827   092F             
0828   092F             ; kernel parameters
0829   092F             sys_echo_on:
0830   092F 01            .db 1
0831   0930             sys_uart0_lcr:
0832   0930 07            .db $07 ; 8 data bits, 2 stop bit, no parity
0833   0931             sys_uart0_inten:
0834   0931 01            .db 1
0835   0932             sys_uart0_fifoen:
0836   0932 00            .db 0
0837   0933             sys_uart0_div0:
0838   0933 0C            .db 12  ;
0839   0934             sys_uart0_div1:
0840   0934 00            .db 0   ; default baud = 9600
0841   0935             ; Baud  Divisor
0842   0935             ; 50    2304
0843   0935             ; 110   1047
0844   0935             ; 300    384
0845   0935             ; 600    192
0846   0935             ; 1200    96
0847   0935             ; 9600    12
0848   0935             ; 19200    6
0849   0935             ; 38400    3
0850   0935             
0851   0935             
0852   0935             fifo_in:
0853   0935 CB 0B         .dw fifo
0854   0937             fifo_out:
0855   0937 CB 0B         .dw fifo
0856   0939             
0857   0939             
0858   0939             s_kernel_started:
0859   0939 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
0859   093D 65 6C 20 73 
0859   0941 74 61 72 74 
0859   0945 65 64 28 76 
0859   0949 65 72 73 69 
0859   094D 6F 6E 20 31 
0859   0951 2E 30 29 0A 
0859   0955 00 
0860   0956             s_priviledge:
0861   0956 0A 65 78 63   .db "\nexception: privilege\n", 0
0861   095A 65 70 74 69 
0861   095E 6F 6E 3A 20 
0861   0962 70 72 69 76 
0861   0966 69 6C 65 67 
0861   096A 65 0A 00 
0862   096D             s_divzero:
0863   096D 0A 65 78 63   .db "\nexception: zero division\n", 0
0863   0971 65 70 74 69 
0863   0975 6F 6E 3A 20 
0863   0979 7A 65 72 6F 
0863   097D 20 64 69 76 
0863   0981 69 73 69 6F 
0863   0985 6E 0A 00 
0864   0988             
0865   0988             ; This is the format of a sector for the 128 byte per sector format.
0866   0988             ; Write the bracketed data 16 times per track.
0867   0988             ; The recommended single-density format with 128
0868   0988             ; bytes/sector is shown. In order to format a diskette,
0869   0988             ; the user issues the Write Track Command, and loads
0870   0988             ; the Data Register with the following values. For every
0871   0988             ; byte to be written, there is one Data Request.
0872   0988             fdc_irq_event:
0873   0988 00            .fill 1,  $00       ; keeps status of fdc irq event
0874   0989             fdc_128_format:                                                                       
0875   0989             fdc_40_FF:
0876   0989 FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
0876   098D FF FF FF FF 
0876   0991 FF FF FF FF 
0876   0995 FF FF FF FF 
0876   0999 FF FF FF FF 
0876   099D FF FF FF FF 
0876   09A1 FF FF FF FF 
0876   09A5 FF FF FF FF 
0876   09A9 FF FF FF FF 
0876   09AD FF FF FF FF 
0877   09B1             fdc_128_format_inner:
0878   09B1 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
0878   09B5 00 00 
0879   09B7 FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
0880   09B8             fdc_128_format_track:
0881   09B8 00            .fill 1,   $00    ; Track Number   0 thru 39                                                      |                    
0882   09B9 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0883   09BA             fdc_128_format_sect:
0884   09BA 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0885   09BB 00            .fill 1,   $00    ; Sector Length                                                                 |                        
0886   09BC F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0887   09BD FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
0887   09C1 FF FF FF FF 
0887   09C5 FF FF FF 
0888   09C8 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
0888   09CC 00 00 
0889   09CE FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0890   09CF E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0890   09D3 E5 E5 E5 E5 
0890   09D7 E5 E5 E5 E5 
0890   09DB E5 E5 E5 E5 
0890   09DF E5 E5 E5 E5 
0890   09E3 E5 E5 E5 E5 
0890   09E7 E5 E5 E5 E5 
0890   09EB E5 E5 E5 E5 
0890   09EF E5 E5 E5 E5 
0890   09F3 E5 E5 E5 E5 
0890   09F7 E5 E5 E5 E5 
0890   09FB E5 E5 E5 E5 
0890   09FF E5 E5 E5 E5 
0890   0A03 E5 E5 E5 E5 
0890   0A07 E5 E5 E5 E5 
0890   0A0B E5 E5 E5 E5 
0890   0A0F E5 E5 E5 E5 
0890   0A13 E5 E5 E5 E5 
0890   0A17 E5 E5 E5 E5 
0890   0A1B E5 E5 E5 E5 
0890   0A1F E5 E5 E5 E5 
0890   0A23 E5 E5 E5 E5 
0890   0A27 E5 E5 E5 E5 
0890   0A2B E5 E5 E5 E5 
0890   0A2F E5 E5 E5 E5 
0890   0A33 E5 E5 E5 E5 
0890   0A37 E5 E5 E5 E5 
0890   0A3B E5 E5 E5 E5 
0890   0A3F E5 E5 E5 E5 
0890   0A43 E5 E5 E5 E5 
0890   0A47 E5 E5 E5 E5 
0890   0A4B E5 E5 E5 E5 
0891   0A4F F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0892   0A50 FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0892   0A54 FF FF FF FF 
0892   0A58 FF FF 
0893   0A5A             fdc_128_format_end:
0894   0A5A FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0894   0A5E FF FF FF FF 
0894   0A62 FF FF FF FF 
0894   0A66 FF FF FF FF 
0894   0A6A FF FF FF FF 
0894   0A6E FF FF FF FF 
0894   0A72 FF FF FF FF 
0894   0A76 FF FF FF FF 
0894   0A7A FF FF FF FF 
0894   0A7E FF FF FF FF 
0894   0A82 FF FF FF FF 
0894   0A86 FF FF FF FF 
0894   0A8A FF FF FF FF 
0894   0A8E FF FF FF FF 
0894   0A92 FF FF FF FF 
0894   0A96 FF FF FF FF 
0894   0A9A FF FF FF FF 
0894   0A9E FF FF FF FF 
0894   0AA2 FF FF FF FF 
0894   0AA6 FF FF FF FF 
0894   0AAA FF FF FF FF 
0894   0AAE FF FF FF FF 
0894   0AB2 FF FF FF FF 
0894   0AB6 FF FF FF FF 
0894   0ABA FF FF FF FF 
0894   0ABE FF FF FF FF 
0894   0AC2 FF FF FF FF 
0894   0AC6 FF FF FF FF 
0894   0ACA FF FF FF FF 
0894   0ACE FF FF FF FF 
0894   0AD2 FF FF FF FF 
0894   0AD6 FF FF FF FF 
0894   0ADA FF FF FF FF 
0894   0ADE FF FF FF FF 
0894   0AE2 FF FF FF FF 
0894   0AE6 FF FF FF FF 
0894   0AEA FF FF FF FF 
0894   0AEE FF FF FF FF 
0894   0AF2 FF FF FF FF 
0894   0AF6 FF FF FF FF 
0894   0AFA FF FF FF FF 
0894   0AFE FF FF FF FF 
0894   0B02 FF FF FF FF 
0894   0B06 FF FF FF FF 
0894   0B0A FF FF FF FF 
0894   0B0E FF FF FF FF 
0894   0B12 FF FF FF FF 
0894   0B16 FF FF FF FF 
0894   0B1A FF FF FF FF 
0894   0B1E FF FF FF FF 
0894   0B22 FF FF FF FF 
0894   0B26 FF FF FF FF 
0894   0B2A FF FF FF FF 
0894   0B2E FF FF FF FF 
0894   0B32 FF FF FF FF 
0894   0B36 FF FF FF FF 
0894   0B3A FF FF FF FF 
0894   0B3E FF FF FF FF 
0894   0B42 FF FF FF FF 
0894   0B46 FF FF FF FF 
0894   0B4A FF FF FF FF 
0894   0B4E FF FF FF FF 
0894   0B52 FF FF FF FF 
0894   0B56 FF FF FF FF 
0894   0B5A FF FF FF FF 
0894   0B5E FF FF FF FF 
0894   0B62 FF FF FF FF 
0894   0B66 FF FF FF FF 
0894   0B6A FF FF FF FF 
0894   0B6E FF FF FF FF 
0894   0B72 FF FF FF FF 
0894   0B76 FF FF FF FF 
0894   0B7A FF FF FF FF 
0894   0B7E FF FF FF FF 
0894   0B82 FF FF FF FF 
0894   0B86 FF FF FF FF 
0894   0B8A FF FF FF FF 
0894   0B8E FF FF FF FF 
0894   0B92 FF FF FF FF 
0894   0B96 FF FF FF FF 
0894   0B9A FF FF FF FF 
0894   0B9E FF FF FF FF 
0894   0BA2 FF FF FF FF 
0894   0BA6 FF FF FF FF 
0894   0BAA FF FF FF FF 
0894   0BAE FF FF FF FF 
0894   0BB2 FF FF FF FF 
0894   0BB6 FF FF FF FF 
0894   0BBA FF FF FF FF 
0894   0BBE FF FF FF FF 
0894   0BC2 FF FF FF FF 
0894   0BC6 FF FF FF FF 
0894   0BCA FF 
0895   0BCB             
0896   0BCB             fifo:
0897   0BCB FF FF FF FF   .fill FIFO_SIZE
0897   0BCF FF FF FF FF 
0897   0BD3 FF FF FF FF 
0897   0BD7 FF FF FF FF 
0897   0BDB FF FF FF FF 
0897   0BDF FF FF FF FF 
0897   0BE3 FF FF FF FF 
0897   0BE7 FF FF FF FF 
0897   0BEB FF FF FF FF 
0897   0BEF FF FF FF FF 
0897   0BF3 FF FF FF FF 
0897   0BF7 FF FF FF FF 
0897   0BFB FF FF FF FF 
0897   0BFF FF FF FF FF 
0897   0C03 FF FF FF FF 
0897   0C07 FF FF FF FF 
0897   0C0B FF FF FF FF 
0897   0C0F FF FF FF FF 
0897   0C13 FF FF FF FF 
0897   0C17 FF FF FF FF 
0897   0C1B FF FF FF FF 
0897   0C1F FF FF FF FF 
0897   0C23 FF FF FF FF 
0897   0C27 FF FF FF FF 
0897   0C2B FF FF FF FF 
0897   0C2F FF FF FF FF 
0897   0C33 FF FF FF FF 
0897   0C37 FF FF FF FF 
0897   0C3B FF FF FF FF 
0897   0C3F FF FF FF FF 
0897   0C43 FF FF FF FF 
0897   0C47 FF FF FF FF 
0897   0C4B FF FF FF FF 
0897   0C4F FF FF FF FF 
0897   0C53 FF FF FF FF 
0897   0C57 FF FF FF FF 
0897   0C5B FF FF FF FF 
0897   0C5F FF FF FF FF 
0897   0C63 FF FF FF FF 
0897   0C67 FF FF FF FF 
0897   0C6B FF FF FF FF 
0897   0C6F FF FF FF FF 
0897   0C73 FF FF FF FF 
0897   0C77 FF FF FF FF 
0897   0C7B FF FF FF FF 
0897   0C7F FF FF FF FF 
0897   0C83 FF FF FF FF 
0897   0C87 FF FF FF FF 
0897   0C8B FF FF FF FF 
0897   0C8F FF FF FF FF 
0897   0C93 FF FF FF FF 
0897   0C97 FF FF FF FF 
0897   0C9B FF FF FF FF 
0897   0C9F FF FF FF FF 
0897   0CA3 FF FF FF FF 
0897   0CA7 FF FF FF FF 
0897   0CAB FF FF FF FF 
0897   0CAF FF FF FF FF 
0897   0CB3 FF FF FF FF 
0897   0CB7 FF FF FF FF 
0897   0CBB FF FF FF FF 
0897   0CBF FF FF FF FF 
0897   0CC3 FF FF FF FF 
0897   0CC7 FF FF FF FF 
0897   0CCB FF FF FF FF 
0897   0CCF FF FF FF FF 
0897   0CD3 FF FF FF FF 
0897   0CD7 FF FF FF FF 
0897   0CDB FF FF FF FF 
0897   0CDF FF FF FF FF 
0897   0CE3 FF FF FF FF 
0897   0CE7 FF FF FF FF 
0897   0CEB FF FF FF FF 
0897   0CEF FF FF FF FF 
0897   0CF3 FF FF FF FF 
0897   0CF7 FF FF FF FF 
0897   0CFB FF FF FF FF 
0897   0CFF FF FF FF FF 
0897   0D03 FF FF FF FF 
0897   0D07 FF FF FF FF 
0897   0D0B FF FF FF FF 
0897   0D0F FF FF FF FF 
0897   0D13 FF FF FF FF 
0897   0D17 FF FF FF FF 
0897   0D1B FF FF FF FF 
0897   0D1F FF FF FF FF 
0897   0D23 FF FF FF FF 
0897   0D27 FF FF FF FF 
0897   0D2B FF FF FF FF 
0897   0D2F FF FF FF FF 
0897   0D33 FF FF FF FF 
0897   0D37 FF FF FF FF 
0897   0D3B FF FF FF FF 
0897   0D3F FF FF FF FF 
0897   0D43 FF FF FF FF 
0897   0D47 FF FF FF FF 
0897   0D4B FF FF FF FF 
0897   0D4F FF FF FF FF 
0897   0D53 FF FF FF FF 
0897   0D57 FF FF FF FF 
0897   0D5B FF FF FF FF 
0897   0D5F FF FF FF FF 
0897   0D63 FF FF FF FF 
0897   0D67 FF FF FF FF 
0897   0D6B FF FF FF FF 
0897   0D6F FF FF FF FF 
0897   0D73 FF FF FF FF 
0897   0D77 FF FF FF FF 
0897   0D7B FF FF FF FF 
0897   0D7F FF FF FF FF 
0897   0D83 FF FF FF FF 
0897   0D87 FF FF FF FF 
0897   0D8B FF FF FF FF 
0897   0D8F FF FF FF FF 
0897   0D93 FF FF FF FF 
0897   0D97 FF FF FF FF 
0897   0D9B FF FF FF FF 
0897   0D9F FF FF FF FF 
0897   0DA3 FF FF FF FF 
0897   0DA7 FF FF FF FF 
0897   0DAB FF FF FF FF 
0897   0DAF FF FF FF FF 
0897   0DB3 FF FF FF FF 
0897   0DB7 FF FF FF FF 
0897   0DBB FF FF FF FF 
0897   0DBF FF FF FF FF 
0897   0DC3 FF FF FF FF 
0897   0DC7 FF FF FF FF 
0897   0DCB FF FF FF FF 
0897   0DCF FF FF FF FF 
0897   0DD3 FF FF FF FF 
0897   0DD7 FF FF FF FF 
0897   0DDB FF FF FF FF 
0897   0DDF FF FF FF FF 
0897   0DE3 FF FF FF FF 
0897   0DE7 FF FF FF FF 
0897   0DEB FF FF FF FF 
0897   0DEF FF FF FF FF 
0897   0DF3 FF FF FF FF 
0897   0DF7 FF FF FF FF 
0897   0DFB FF FF FF FF 
0897   0DFF FF FF FF FF 
0897   0E03 FF FF FF FF 
0897   0E07 FF FF FF FF 
0897   0E0B FF FF FF FF 
0897   0E0F FF FF FF FF 
0897   0E13 FF FF FF FF 
0897   0E17 FF FF FF FF 
0897   0E1B FF FF FF FF 
0897   0E1F FF FF FF FF 
0897   0E23 FF FF FF FF 
0897   0E27 FF FF FF FF 
0897   0E2B FF FF FF FF 
0897   0E2F FF FF FF FF 
0897   0E33 FF FF FF FF 
0897   0E37 FF FF FF FF 
0897   0E3B FF FF FF FF 
0897   0E3F FF FF FF FF 
0897   0E43 FF FF FF FF 
0897   0E47 FF FF FF FF 
0897   0E4B FF FF FF FF 
0897   0E4F FF FF FF FF 
0897   0E53 FF FF FF FF 
0897   0E57 FF FF FF FF 
0897   0E5B FF FF FF FF 
0897   0E5F FF FF FF FF 
0897   0E63 FF FF FF FF 
0897   0E67 FF FF FF FF 
0897   0E6B FF FF FF FF 
0897   0E6F FF FF FF FF 
0897   0E73 FF FF FF FF 
0897   0E77 FF FF FF FF 
0897   0E7B FF FF FF FF 
0897   0E7F FF FF FF FF 
0897   0E83 FF FF FF FF 
0897   0E87 FF FF FF FF 
0897   0E8B FF FF FF FF 
0897   0E8F FF FF FF FF 
0897   0E93 FF FF FF FF 
0897   0E97 FF FF FF FF 
0897   0E9B FF FF FF FF 
0897   0E9F FF FF FF FF 
0897   0EA3 FF FF FF FF 
0897   0EA7 FF FF FF FF 
0897   0EAB FF FF FF FF 
0897   0EAF FF FF FF FF 
0897   0EB3 FF FF FF FF 
0897   0EB7 FF FF FF FF 
0897   0EBB FF FF FF FF 
0897   0EBF FF FF FF FF 
0897   0EC3 FF FF FF FF 
0897   0EC7 FF FF FF FF 
0897   0ECB FF FF FF FF 
0897   0ECF FF FF FF FF 
0897   0ED3 FF FF FF FF 
0897   0ED7 FF FF FF FF 
0897   0EDB FF FF FF FF 
0897   0EDF FF FF FF FF 
0897   0EE3 FF FF FF FF 
0897   0EE7 FF FF FF FF 
0897   0EEB FF FF FF FF 
0897   0EEF FF FF FF FF 
0897   0EF3 FF FF FF FF 
0897   0EF7 FF FF FF FF 
0897   0EFB FF FF FF FF 
0897   0EFF FF FF FF FF 
0897   0F03 FF FF FF FF 
0897   0F07 FF FF FF FF 
0897   0F0B FF FF FF FF 
0897   0F0F FF FF FF FF 
0897   0F13 FF FF FF FF 
0897   0F17 FF FF FF FF 
0897   0F1B FF FF FF FF 
0897   0F1F FF FF FF FF 
0897   0F23 FF FF FF FF 
0897   0F27 FF FF FF FF 
0897   0F2B FF FF FF FF 
0897   0F2F FF FF FF FF 
0897   0F33 FF FF FF FF 
0897   0F37 FF FF FF FF 
0897   0F3B FF FF FF FF 
0897   0F3F FF FF FF FF 
0897   0F43 FF FF FF FF 
0897   0F47 FF FF FF FF 
0897   0F4B FF FF FF FF 
0897   0F4F FF FF FF FF 
0897   0F53 FF FF FF FF 
0897   0F57 FF FF FF FF 
0897   0F5B FF FF FF FF 
0897   0F5F FF FF FF FF 
0897   0F63 FF FF FF FF 
0897   0F67 FF FF FF FF 
0897   0F6B FF FF FF FF 
0897   0F6F FF FF FF FF 
0897   0F73 FF FF FF FF 
0897   0F77 FF FF FF FF 
0897   0F7B FF FF FF FF 
0897   0F7F FF FF FF FF 
0897   0F83 FF FF FF FF 
0897   0F87 FF FF FF FF 
0897   0F8B FF FF FF FF 
0897   0F8F FF FF FF FF 
0897   0F93 FF FF FF FF 
0897   0F97 FF FF FF FF 
0897   0F9B FF FF FF FF 
0897   0F9F FF FF FF FF 
0897   0FA3 FF FF FF FF 
0897   0FA7 FF FF FF FF 
0897   0FAB FF FF FF FF 
0897   0FAF FF FF FF FF 
0897   0FB3 FF FF FF FF 
0897   0FB7 FF FF FF FF 
0897   0FBB FF FF FF FF 
0897   0FBF FF FF FF FF 
0897   0FC3 FF FF FF FF 
0897   0FC7 FF FF FF FF 
0898   0FCB             
0899   0FCB             scrap_sector:
0900   0FCB FF FF FF FF   .fill 512         ; scrap sector
0900   0FCF FF FF FF FF 
0900   0FD3 FF FF FF FF 
0900   0FD7 FF FF FF FF 
0900   0FDB FF FF FF FF 
0900   0FDF FF FF FF FF 
0900   0FE3 FF FF FF FF 
0900   0FE7 FF FF FF FF 
0900   0FEB FF FF FF FF 
0900   0FEF FF FF FF FF 
0900   0FF3 FF FF FF FF 
0900   0FF7 FF FF FF FF 
0900   0FFB FF FF FF FF 
0900   0FFF FF FF FF FF 
0900   1003 FF FF FF FF 
0900   1007 FF FF FF FF 
0900   100B FF FF FF FF 
0900   100F FF FF FF FF 
0900   1013 FF FF FF FF 
0900   1017 FF FF FF FF 
0900   101B FF FF FF FF 
0900   101F FF FF FF FF 
0900   1023 FF FF FF FF 
0900   1027 FF FF FF FF 
0900   102B FF FF FF FF 
0900   102F FF FF FF FF 
0900   1033 FF FF FF FF 
0900   1037 FF FF FF FF 
0900   103B FF FF FF FF 
0900   103F FF FF FF FF 
0900   1043 FF FF FF FF 
0900   1047 FF FF FF FF 
0900   104B FF FF FF FF 
0900   104F FF FF FF FF 
0900   1053 FF FF FF FF 
0900   1057 FF FF FF FF 
0900   105B FF FF FF FF 
0900   105F FF FF FF FF 
0900   1063 FF FF FF FF 
0900   1067 FF FF FF FF 
0900   106B FF FF FF FF 
0900   106F FF FF FF FF 
0900   1073 FF FF FF FF 
0900   1077 FF FF FF FF 
0900   107B FF FF FF FF 
0900   107F FF FF FF FF 
0900   1083 FF FF FF FF 
0900   1087 FF FF FF FF 
0900   108B FF FF FF FF 
0900   108F FF FF FF FF 
0900   1093 FF FF FF FF 
0900   1097 FF FF FF FF 
0900   109B FF FF FF FF 
0900   109F FF FF FF FF 
0900   10A3 FF FF FF FF 
0900   10A7 FF FF FF FF 
0900   10AB FF FF FF FF 
0900   10AF FF FF FF FF 
0900   10B3 FF FF FF FF 
0900   10B7 FF FF FF FF 
0900   10BB FF FF FF FF 
0900   10BF FF FF FF FF 
0900   10C3 FF FF FF FF 
0900   10C7 FF FF FF FF 
0900   10CB FF FF FF FF 
0900   10CF FF FF FF FF 
0900   10D3 FF FF FF FF 
0900   10D7 FF FF FF FF 
0900   10DB FF FF FF FF 
0900   10DF FF FF FF FF 
0900   10E3 FF FF FF FF 
0900   10E7 FF FF FF FF 
0900   10EB FF FF FF FF 
0900   10EF FF FF FF FF 
0900   10F3 FF FF FF FF 
0900   10F7 FF FF FF FF 
0900   10FB FF FF FF FF 
0900   10FF FF FF FF FF 
0900   1103 FF FF FF FF 
0900   1107 FF FF FF FF 
0900   110B FF FF FF FF 
0900   110F FF FF FF FF 
0900   1113 FF FF FF FF 
0900   1117 FF FF FF FF 
0900   111B FF FF FF FF 
0900   111F FF FF FF FF 
0900   1123 FF FF FF FF 
0900   1127 FF FF FF FF 
0900   112B FF FF FF FF 
0900   112F FF FF FF FF 
0900   1133 FF FF FF FF 
0900   1137 FF FF FF FF 
0900   113B FF FF FF FF 
0900   113F FF FF FF FF 
0900   1143 FF FF FF FF 
0900   1147 FF FF FF FF 
0900   114B FF FF FF FF 
0900   114F FF FF FF FF 
0900   1153 FF FF FF FF 
0900   1157 FF FF FF FF 
0900   115B FF FF FF FF 
0900   115F FF FF FF FF 
0900   1163 FF FF FF FF 
0900   1167 FF FF FF FF 
0900   116B FF FF FF FF 
0900   116F FF FF FF FF 
0900   1173 FF FF FF FF 
0900   1177 FF FF FF FF 
0900   117B FF FF FF FF 
0900   117F FF FF FF FF 
0900   1183 FF FF FF FF 
0900   1187 FF FF FF FF 
0900   118B FF FF FF FF 
0900   118F FF FF FF FF 
0900   1193 FF FF FF FF 
0900   1197 FF FF FF FF 
0900   119B FF FF FF FF 
0900   119F FF FF FF FF 
0900   11A3 FF FF FF FF 
0900   11A7 FF FF FF FF 
0900   11AB FF FF FF FF 
0900   11AF FF FF FF FF 
0900   11B3 FF FF FF FF 
0900   11B7 FF FF FF FF 
0900   11BB FF FF FF FF 
0900   11BF FF FF FF FF 
0900   11C3 FF FF FF FF 
0900   11C7 FF FF FF FF 
0901   11CB             transient_area:
0902   11CB 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
0903   11CC             
0904   11CC             .end
tasm: Number of errors = 0
