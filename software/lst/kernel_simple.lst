0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; GLOBAL SYSTEM VARIABLES
0086   0000             ; ------------------------------------------------------------------------------------------------------------------;
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; IRQ table
0090   0000             ; highest priority at lowest address
0091   0000             ; ------------------------------------------------------------------------------------------------------------------;
0092   0000 26 00       .dw int_0_fdc
0093   0002 27 00       .dw int_1
0094   0004 28 00       .dw int_2
0095   0006 29 00       .dw int_3
0096   0008 2A 00       .dw int_4
0097   000A 2B 00       .dw int_5
0098   000C 2C 00       .dw int_6
0099   000E 2D 00       .dw int_7_uart0
0100   0010             
0101   0010             ; ------------------------------------------------------------------------------------------------------------------;
0102   0010             ; kernel reset vector
0103   0010             ; ------------------------------------------------------------------------------------------------------------------;
0104   0010 58 02       .dw kernel_reset_vector
0105   0012             
0106   0012             ; ------------------------------------------------------------------------------------------------------------------;
0107   0012             ; exception vector table
0108   0012             ; total of 7 entries, starting at address $0012
0109   0012             ; ------------------------------------------------------------------------------------------------------------------;
0110   0012 C7 01       .dw trap_privilege
0111   0014 D3 01       .dw trap_div_zero
0112   0016 E0 01       .dw trap_undef_opcode
0113   0018 00 00       .dw 0
0114   001A 00 00       .dw 0
0115   001C 00 00       .dw 0
0116   001E 00 00       .dw 0
0117   0020             
0118   0020             ; ------------------------------------------------------------------------------------------------------------------;
0119   0020             ; system call vector table
0120   0020             ; starts at address $0020
0121   0020             ; ------------------------------------------------------------------------------------------------------------------;
0122   0020 E7 01       .dw syscall_io
0123   0022 BB 01       .dw syscall_reboot
0124   0024 4C 00       .dw syscall_fdc
0125   0026             
0126   0026             ; ------------------------------------------------------------------------------------------------------------------;
0127   0026             ; system call aliases
0128   0026             ; ------------------------------------------------------------------------------------------------------------------;
0129   0026             sys_io               .equ 0
0130   0026             sys_reboot           .equ 1
0131   0026             sys_fdc              .equ 2
0132   0026             
0133   0026             ; ------------------------------------------------------------------------------------------------------------------;
0134   0026             ; IRQs' code block
0135   0026             ; ------------------------------------------------------------------------------------------------------------------;
0136   0026             ; 5.25" Floppy Drive Controller IRQ
0137   0026             int_0_fdc:
0138   0026 06            sysret
0139   0027             int_1:
0140   0027 06            sysret
0141   0028             int_2:
0142   0028 06            sysret
0143   0029             int_3:
0144   0029 06            sysret
0145   002A             int_4:
0146   002A 06            sysret
0147   002B             int_5:
0148   002B 06            sysret
0149   002C             
0150   002C             ; ------------------------------------------------------------------------------------------------------------------;
0151   002C             ; process swapping
0152   002C             ; ------------------------------------------------------------------------------------------------------------------;
0153   002C             int_6:  
0154   002C 06            sysret
0155   002D             
0156   002D             ; ------------------------------------------------------------------------------------------------------------------;
0157   002D             ; UART0 Interrupt
0158   002D             ; ------------------------------------------------------------------------------------------------------------------;
0159   002D             int_7_uart0:
0160   002D D7            push a
0161   002E DA            push d
0162   002F E1            pushf
0163   0030 14 C5 07      mov a, [fifo_in]
0164   0033 3C            mov d, a
0165   0034 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0166   0037 3E            mov [d], al                 ; add to fifo
0167   0038 14 C5 07      mov a, [fifo_in]
0168   003B 77            inc a
0169   003C AF 5B 0E      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0170   003F C7 45 00      jne int_7_continue
0171   0042 10 5B 0A      mov a, fifo  
0172   0045             int_7_continue:  
0173   0045 42 C5 07      mov [fifo_in], a            ; update fifo pointer
0174   0048 EE            popf
0175   0049 E7            pop d
0176   004A E4            pop a  
0177   004B 06            sysret
0178   004C             
0179   004C             
0180   004C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0181   004C             ; floppy drive system calls
0182   004C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0183   004C             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0184   004C             ; fdc_40_FF:
0185   004C             ;   .fill 40,  $FF    ; or 00                                                                                
0186   004C             ; fdc_128_format_inner:
0187   004C             ;   .fill 6,   $00    ;                                                                            <--|        
0188   004C             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0189   004C             ;   .fill 1,   $00    ; Track Number  0 thru 39                                                       |                    
0190   004C             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0191   004C             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0192   004C             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0193   004C             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0194   004C             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0195   004C             ;   .fill 6,   $00    ;                                                                               |                        
0196   004C             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0197   004C             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0198   004C             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0199   004C             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0200   004C             ; fdc_128_format_end:
0201   004C             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0202   004C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0203   004C             ; _FDC_CONFIG       .equ $FFC0 
0204   004C             ; _FDC_STATUS_1     .equ $FFC1
0205   004C             ; _FDC_WD_STAT_CMD  .equ $FFC8
0206   004C             ; _FDC_WD_TRACK     .equ $FFC9
0207   004C             ; _FDC_WD_SECTOR    .equ $FFCA
0208   004C             ; _FDC_WD_DATA      .equ $FFCB
0209   004C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0210   004C             syscall_fdc:
0211   004C             ; bl: track number
0212   004C             syscall_fdc_format:
0213   004C 1B            mov al, bl
0214   004D 3D 48 08      mov [fdc_128_format_track], al  ; write track number to formatting data block
0215   0050 19 01         mov al, 1
0216   0052 3D 4A 08      mov [fdc_128_format_sect], al   ; reset sector variable to 1
0217   0055 19 00         mov al, 0
0218   0057 3D C9 FF      mov [_FDC_WD_TRACK], al   
0219   005A 3B 81 01      mov d, s_format_begin
0220   005D 07 C4 05      call _puts
0221   0060 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0222   0063 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0223   0066 2F            mov bl, al
0224   0067 07 64 06      call print_u8x
0225   006A 07 71 05      call printnl
0226   006D             fdc_header_loop_start:
0227   006D 19 F2         mov al, %11110010               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0228   006F 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0229   0072             ; write the first data block for formatting which is 40 bytes of 0xFF:
0230   0072 07 79 01      call fdc_wait_64us
0231   0075             
0232   0075 3A 28         mov cl, 40
0233   0077             fdc_drq_loop: ; for each byte, we need to wait for DRQ to be high
0234   0077 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0235   007A 87 02         and al, $02                ; check drq bit
0236   007C C6 77 00      jz fdc_drq_loop
0237   007F 19 FF         mov al, $FF                     ; load format byte
0238   0081 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0239   0084 81            dec cl
0240   0085 C7 77 00      jnz fdc_drq_loop
0241   0088             ; start inner data block loop. this block is written 16 times
0242   0088             
0243   0088 FD 22 01 00   mov g, 1
0244   008C             fdc_inner_loop:
0245   008C 3A 06         mov cl, 6
0246   008E             fdc_l1:
0247   008E 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0248   0091 87 02         and al, $02                ; check drq bit
0249   0093 C6 8E 00      jz fdc_l1
0250   0096 19 00         mov al, $00                     ; load format byte
0251   0098 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0252   009B 81            dec cl
0253   009C C7 8E 00      jnz fdc_l1
0254   009F             
0255   009F             ; address mark
0256   009F             fdc_l2:
0257   009F 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0258   00A2 87 02         and al, $02                ; check drq bit
0259   00A4 C6 9F 00      jz fdc_l2
0260   00A7 19 FE         mov al, $FE                     ; load format byte
0261   00A9 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0262   00AC             
0263   00AC             ; track number
0264   00AC             fdc_l3:
0265   00AC 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0266   00AF 87 02         and al, $02                ; check drq bit
0267   00B1 C6 AC 00      jz fdc_l3
0268   00B4 19 00         mov al, $00                     ; load format byte
0269   00B6 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0270   00B9             
0271   00B9             ; side number
0272   00B9             fdc_l4:
0273   00B9 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0274   00BC 87 02         and al, $02                ; check drq bit
0275   00BE C6 B9 00      jz fdc_l4
0276   00C1 19 00         mov al, $00                     ; load format byte
0277   00C3 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0278   00C6             
0279   00C6             ; sector number
0280   00C6             fdc_l5:
0281   00C6 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0282   00C9 87 02         and al, $02                ; check drq bit
0283   00CB C6 C6 00      jz fdc_l5
0284   00CE FD 1A         mov al, gl
0285   00D0 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0286   00D3             
0287   00D3             ; sector length
0288   00D3             fdc_l6:
0289   00D3 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0290   00D6 87 02         and al, $02                ; check drq bit
0291   00D8 C6 D3 00      jz fdc_l6
0292   00DB 19 00         mov al, $00                     ; load format byte
0293   00DD 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0294   00E0             
0295   00E0             ; 2 crc's
0296   00E0             fdc_l7:
0297   00E0 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0298   00E3 87 02         and al, $02                ; check drq bit
0299   00E5 C6 E0 00      jz fdc_l7
0300   00E8 19 F7         mov al, $F7                     ; load format byte
0301   00EA 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0302   00ED             
0303   00ED             ; 11 times $FF
0304   00ED 3A 0B         mov cl, 11
0305   00EF             fdc_l8:
0306   00EF 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0307   00F2 87 02         and al, $02                ; check drq bit
0308   00F4 C6 EF 00      jz fdc_l8
0309   00F7 19 FF         mov al, $FF
0310   00F9 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0311   00FC 81            dec cl
0312   00FD C7 EF 00      jnz fdc_l8
0313   0100             
0314   0100             ; 6 times 00
0315   0100 3A 06         mov cl, 6
0316   0102             fdc_l9:
0317   0102 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0318   0105 87 02         and al, $02                ; check drq bit
0319   0107 C6 02 01      jz fdc_l9
0320   010A 19 00         mov al, $00
0321   010C 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0322   010F 81            dec cl
0323   0110 C7 02 01      jnz fdc_l9
0324   0113             
0325   0113             ; data address mark
0326   0113             fdc_l10:
0327   0113 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0328   0116 87 02         and al, $02                ; check drq bit
0329   0118 C6 13 01      jz fdc_l10
0330   011B 19 FB         mov al, $FB                     ; load format byte
0331   011D 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0332   0120             
0333   0120             ; sector data
0334   0120 3A 80         mov cl, 128
0335   0122             fdc_l11:
0336   0122 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0337   0125 87 02         and al, $02                ; check drq bit
0338   0127 C6 22 01      jz fdc_l11
0339   012A 19 FF         mov al, $FF
0340   012C 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0341   012F 81            dec cl
0342   0130 C7 22 01      jnz fdc_l11
0343   0133             
0344   0133             ; 2 crc's
0345   0133             fdc_l12:
0346   0133 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0347   0136 87 02         and al, $02                ; check drq bit
0348   0138 C6 33 01      jz fdc_l12
0349   013B 19 F7         mov al, $F7                     ; load format byte
0350   013D 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0351   0140             
0352   0140             ; 10 times $FF
0353   0140 3A 0A         mov cl, 10
0354   0142             fdc_l13:
0355   0142 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0356   0145 87 02         and al, $02                ; check drq bit
0357   0147 C6 42 01      jz fdc_l13
0358   014A 19 FF         mov al, $FF
0359   014C 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0360   014F 81            dec cl
0361   0150 C7 42 01      jnz fdc_l13
0362   0153             
0363   0153             ; check whether we did this 16 times
0364   0153 FD 1A         mov al, gl
0365   0155 7A            inc al
0366   0156 FD 78         mov g, a
0367   0158 B9 11         cmp al, 17
0368   015A 3D B0 FF      mov [_7SEG_DISPLAY], al
0369   015D C7 8C 00      jne fdc_inner_loop
0370   0160             
0371   0160             ; loop ~369 times
0372   0160             fdc_format_footer:
0373   0160 3A FF         mov cl, $FF
0374   0162             fdc_footer_drq_loop:
0375   0162 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag
0376   0165 2F            mov bl, al
0377   0166 FD 87 01      and bl, $01                ; check busy bit
0378   0169 C6 78 01      jz fdc_format_done
0379   016C 87 02         and al, $02                ; check drq bit
0380   016E C6 62 01      jz fdc_footer_drq_loop
0381   0171 84            mov al, cl
0382   0172 3D CB FF      mov [_FDC_WD_DATA], al     ; send data byte to wd1770
0383   0175 0A 62 01      jmp fdc_footer_drq_loop
0384   0178             
0385   0178             fdc_format_done:
0386   0178             
0387   0178 06            sysret
0388   0179             
0389   0179             ; fetch is 2 cycles long when 'display_reg_load' is false.
0390   0179             ; mov cl, 14 is 5 cycles long (2 to fetch, and 3 execution)
0391   0179             ; 64us amounts to 160 cycles of the 2.5MHz clock
0392   0179             ; so we need to wait for 155 cycles after mov cl, 14
0393   0179             ; and since dec cl, and jnz amount to 11 cycles, we need to loop there 14 times: 14*11 = 154
0394   0179             ; and 154 + 5 = 159
0395   0179             fdc_wait_64us:
0396   0179 3A 10         mov cl, 16                       ; 5 cycles
0397   017B             fdc_wait_64_loop:
0398   017B 81            dec cl                           ; 3 cycles
0399   017C C7 7B 01      jnz fdc_wait_64_loop             ; 8 cycles
0400   017F 09            ret
0401   0180             
0402   0180 00          fdc_irq: .db 0
0403   0181 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0403   0185 6D 61 74 74 
0403   0189 69 6E 67 20 
0403   018D 73 74 61 72 
0403   0191 74 69 6E 67 
0403   0195 2E 2E 2E 0A 
0403   0199 00 
0404   019A 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0404   019E 6D 61 74 74 
0404   01A2 69 6E 67 20 
0404   01A6 64 6F 6E 65 
0404   01AA 2E 0A 00 
0405   01AD 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0405   01B1 20 73 74 61 
0405   01B5 74 75 73 3A 
0405   01B9 20 00 
0406   01BB             
0407   01BB             ; REBOOT SYSTEM
0408   01BB             syscall_reboot:
0409   01BB FD D7 FF FF   push word $FFFF 
0410   01BF FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0411   01C2 FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0412   01C6 06            sysret
0413   01C7             
0414   01C7             ; ------------------------------------------------------------------------------------------------------------------;
0415   01C7             ; exceptions code block
0416   01C7             ; ------------------------------------------------------------------------------------------------------------------;
0417   01C7             ; privilege exception
0418   01C7             ; ------------------------------------------------------------------------------------------------------------------;
0419   01C7             trap_privilege:
0420   01C7 0A BB 01      jmp syscall_reboot
0421   01CA DA            push d
0422   01CB 3B E6 07      mov d, s_priviledge
0423   01CE 07 C4 05      call _puts
0424   01D1 E7            pop d
0425   01D2 06            sysret
0426   01D3             
0427   01D3             ; ------------------------------------------------------------------------------------------------------------------;
0428   01D3             ; divide by zero exception
0429   01D3             ; ------------------------------------------------------------------------------------------------------------------;
0430   01D3             trap_div_zero:
0431   01D3 D7            push a
0432   01D4 DA            push d
0433   01D5 E1            pushf
0434   01D6 3B FD 07      mov d, s_divzero
0435   01D9 07 C4 05      call _puts
0436   01DC EE            popf
0437   01DD E7            pop d
0438   01DE E4            pop a
0439   01DF 06            sysret ; enable interrupts
0440   01E0             
0441   01E0             ; ------------------------------------------------------------------------------------------------------------------;
0442   01E0             ; undefined opcode exception
0443   01E0             ; ------------------------------------------------------------------------------------------------------------------;
0444   01E0             trap_undef_opcode:
0445   01E0 06            sysret
0446   01E1             
0447   01E1             
0448   01E1             
0449   01E1             ;----------------------------------------------------------------------------------------------------;
0450   01E1             ; IO Syscall
0451   01E1             ;----------------------------------------------------------------------------------------------------;
0452   01E1             ; Baud  Divisor
0453   01E1             ; 50    2304
0454   01E1             ; 110   1047
0455   01E1             ; 300    384
0456   01E1             ; 600    192
0457   01E1             ; 1200    96
0458   01E1             ; 9600    12
0459   01E1             ; 19200    6
0460   01E1             ; 38400    3
0461   01E1             syscall_io_jmp:
0462   01E1 14 02         .dw syscall_io_putchar
0463   01E3 21 02         .dw syscall_io_getch
0464   01E5 EB 01         .dw syscall_io_uart_setup
0465   01E7             syscall_io:
0466   01E7 FD 0A E1 01   jmp [syscall_io_jmp + al]
0467   01EB             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0468   01EB             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0469   01EB             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0470   01EB             syscall_io_uart_setup:
0471   01EB 1D C0 07      mov al, [sys_uart0_lcr]
0472   01EE 8B 80         or al, $80                ; set DLAB access bit
0473   01F0 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0474   01F3 1D C3 07      mov al, [sys_uart0_div0]
0475   01F6 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0476   01F9 1D C4 07      mov al, [sys_uart0_div1]
0477   01FC 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0478   01FF             
0479   01FF 1D C0 07      mov al, [sys_uart0_lcr]
0480   0202 87 7F         and al, $7F               ; clear DLAB access bit 
0481   0204 3D 83 FF      mov [_UART0_LCR], al
0482   0207 1D C1 07      mov al, [sys_uart0_inten]
0483   020A 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0484   020D 1D C2 07      mov al, [sys_uart0_fifoen]
0485   0210 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0486   0213 06            sysret
0487   0214             
0488   0214             ; char in ah
0489   0214             syscall_io_putchar:
0490   0214             syscall_io_putchar_L0:
0491   0214 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0492   0217 87 20         and al, $20
0493   0219 C6 14 02      jz syscall_io_putchar_L0    
0494   021C 1A            mov al, ah
0495   021D 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0496   0220 06            sysret
0497   0221             
0498   0221             ; char in ah
0499   0221             ; al = sucess code
0500   0221             syscall_io_getch:
0501   0221 D8            push b
0502   0222 DA            push d
0503   0223 FD 0C         sti
0504   0225             syscall_io_getch_L0:  
0505   0225 14 C7 07      mov a, [fifo_out]
0506   0228 29 C5 07      mov b, [fifo_in]
0507   022B B0            cmp a, b
0508   022C C6 25 02      je syscall_io_getch_L0
0509   022F 3C            mov d, a
0510   0230 77            inc a
0511   0231 AF 5B 0E      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0512   0234 C7 3A 02      jne syscall_io_getch_cont
0513   0237 10 5B 0A      mov a, fifo  
0514   023A             syscall_io_getch_cont:  
0515   023A 42 C7 07      mov [fifo_out], a             ; update fifo pointer
0516   023D 1E            mov al, [d]                   ; get char
0517   023E 23            mov ah, al
0518   023F 1D BF 07      mov al, [sys_echo_on]
0519   0242 B9 01         cmp al, 1
0520   0244 C7 53 02      jne syscall_io_getch_noecho 
0521   0247             ; here we just echo the char back to the console
0522   0247             syscall_io_getch_echo_L0:
0523   0247 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0524   024A 87 20         and al, $20                 ; isolate Transmitter Empty
0525   024C C6 47 02      jz syscall_io_getch_echo_L0
0526   024F 1A            mov al, ah
0527   0250 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0528   0253             syscall_io_getch_noecho:
0529   0253 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0530   0255 E7            pop d
0531   0256 E5            pop b
0532   0257 06            sysret
0533   0258             
0534   0258             
0535   0258             
0536   0258             
0537   0258             
0538   0258             
0539   0258             ; ---------------------------------------------------------------------
0540   0258             ; kernel reset vector
0541   0258             ; ---------------------------------------------------------------------
0542   0258             kernel_reset_vector:  
0543   0258 FD 49 FF F7   mov bp, STACK_BEGIN
0544   025C FD 47 FF F7   mov sp, STACK_BEGIN
0545   0260               
0546   0260 19 80         mov al, %10000000             ; mask out timer interrupt
0547   0262 FD 0F         stomsk                        
0548   0264 FD 0C         sti  
0549   0266             
0550   0266 0C            lodstat
0551   0267 87 DF         and al, %11011111             ; disable display register loading
0552   0269 0D            stostat
0553   026A               
0554   026A             ; reset fifo pointers
0555   026A 10 5B 0A      mov a, fifo
0556   026D 3B C5 07      mov d, fifo_in
0557   0270 43            mov [d], a
0558   0271 3B C7 07      mov d, fifo_out
0559   0274 43            mov [d], a  
0560   0275 19 02         mov al, 2
0561   0277 05 00         syscall sys_io                ; enable uart in interrupt mode
0562   0279               
0563   0279 3B C9 07      mov d, s_kernel_started
0564   027C 07 C4 05      call _puts
0565   027F             
0566   027F 3B 8C 03      mov d, str0
0567   0282 07 C4 05      call _puts
0568   0285               ; First, select drive 1 and de-select drive 0
0569   0285 3B C0 FF      mov d, $FFC0
0570   0288 2E 09         mov bl, %00001001     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0571   028A FD 3E         mov [d], bl
0572   028C             
0573   028C             menu:
0574   028C 3B 1E 03      mov d, s_menu
0575   028F 07 C4 05      call _puts
0576   0292 07 91 04      call getch
0577   0295 76 30         cmp ah, '0'
0578   0297 C6 B6 02      je step_in
0579   029A 76 31         cmp ah, '1'
0580   029C C6 CE 02      je step_out
0581   029F 76 32         cmp ah, '2'
0582   02A1 C6 C2 02      je restore
0583   02A4 76 33         cmp ah, '3'
0584   02A6 C6 DA 02      je status1
0585   02A9 76 34         cmp ah, '4'
0586   02AB C6 EC 02      je status2
0587   02AE 76 35         cmp ah, '5'
0588   02B0 C6 FE 02      je format
0589   02B3 0A 8C 02      jmp menu
0590   02B6             step_in:
0591   02B6 3B C8 FF      mov d, $FFC8    ; wd1770
0592   02B9 19 02         mov al, 2       ; setparam call
0593   02BB 2E 53         mov bl, %01010011     ; step in
0594   02BD FD 3E         mov [d], bl
0595   02BF 0A 8C 02      jmp menu
0596   02C2             restore:
0597   02C2             ; send restore command
0598   02C2 3B C8 FF      mov d, $FFC8    ; wd1770
0599   02C5 19 02         mov al, 2       ; setparam call
0600   02C7 2E 03         mov bl, $03     ; restore command, 30ms rate
0601   02C9 FD 3E         mov [d], bl
0602   02CB 0A 8C 02      jmp menu
0603   02CE             step_out:
0604   02CE 3B C8 FF      mov d, $FFC8    ; wd1770
0605   02D1 19 02         mov al, 2       ; setparam call
0606   02D3 2E 73         mov bl, %01110011     ; step out
0607   02D5 FD 3E         mov [d], bl
0608   02D7 0A 8C 02      jmp menu
0609   02DA             status1:
0610   02DA 07 71 05      call printnl
0611   02DD 3B C1 FF      mov d, $FFC1    ; wd1770 status 1
0612   02E0 19 04         mov al, 4       ; getparam call
0613   02E2 32            mov bl, [d]
0614   02E3 07 64 06      call print_u8x   ; print bl
0615   02E6 07 71 05      call printnl
0616   02E9 0A 8C 02      jmp menu
0617   02EC             status2:
0618   02EC 07 71 05      call printnl
0619   02EF 3B C8 FF      mov d, $FFC8    ; wd1770 status 
0620   02F2 19 04         mov al, 4       ; getparam call
0621   02F4 32            mov bl, [d]
0622   02F5 07 64 06      call print_u8x   ; print bl
0623   02F8 07 71 05      call printnl
0624   02FB 0A 8C 02      jmp menu
0625   02FE             format:
0626   02FE 3B 15 03      mov d, s_track
0627   0301 07 C4 05      call _puts
0628   0304 07 AF 06      call scan_u8x   ; in al
0629   0307 2F            mov bl, al      ; track needs to be in bl
0630   0308 19 00         mov al, 0       ; 0 = format
0631   030A 05 02         syscall sys_fdc 
0632   030C 3B 9A 01      mov d, s_format_done
0633   030F 07 C4 05      call _puts
0634   0312 0A 8C 02      jmp menu
0635   0315             
0636   0315 0A 74 72 61 s_track: .db "\ntrack: ", 0
0636   0319 63 6B 3A 20 
0636   031D 00 
0637   031E             
0638   031E 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0638   0322 73 74 65 70 
0638   0326 20 69 6E 0A 
0639   032A 31 2E 20 73         .db "1. step out\n", 
0639   032E 74 65 70 20 
0639   0332 6F 75 74 0A 
0640   0336 32 2E 20 72         .db "2. restore\n", 
0640   033A 65 73 74 6F 
0640   033E 72 65 0A 
0641   0341 33 2E 20 72         .db "3. read status 1\n", 
0641   0345 65 61 64 20 
0641   0349 73 74 61 74 
0641   034D 75 73 20 31 
0641   0351 0A 
0642   0352 34 2E 20 72         .db "4. read status 2\n", 
0642   0356 65 61 64 20 
0642   035A 73 74 61 74 
0642   035E 75 73 20 32 
0642   0362 0A 
0643   0363 35 2E 20 66         .db "5. format track\n", 
0643   0367 6F 72 6D 61 
0643   036B 74 20 74 72 
0643   036F 61 63 6B 0A 
0644   0373 36 2E 20 65         .db "6. exit\n", 
0644   0377 78 69 74 0A 
0645   037B 0A 73 65 6C         .db "\nselect option: ", 0
0645   037F 65 63 74 20 
0645   0383 6F 70 74 69 
0645   0387 6F 6E 3A 20 
0645   038B 00 
0646   038C             
0647   038C 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0647   0390 65 63 74 69 
0647   0394 6E 67 20 64 
0647   0398 72 69 76 65 
0647   039C 20 31 2E 2E 
0647   03A0 2E 0A 00 
0648   03A3 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0648   03A7 74 69 6E 67 
0648   03AB 2E 2E 2E 0A 
0648   03AF 00 
0649   03B0             
0650   03B0             
0651   03B0             
0652   03B0             ; FILE INCLUDES
0653   03B0             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  03B0             BIOS_RESET_VECTOR .EQU  $01c0
0002+  03B0             IDE_buffer       .EQU  $8204
0003+  03B0             boot_origin      .EQU  $8004
0004+  03B0             bios_uart        .EQU  $0002
0005+  03B0             bios_ide         .EQU  $0003
0654   03B0             .include "lib/stdio.asm"
0001+  03B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  03B0             ; stdio.s
0003+  03B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  03B0             .include "lib/string.asm"
0001++ 03B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 03B0             ; string.s
0003++ 03B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 03B0             
0005++ 03B0             
0006++ 03B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 03B0             ; _strrev
0008++ 03B0             ; reverse a string
0009++ 03B0             ; D = string address
0010++ 03B0             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 03B0             ; 01234
0012++ 03B0             _strrev:
0013++ 03B0 4B          	pusha
0014++ 03B1 07 F7 03    	call _strlen	; length in C
0015++ 03B4 12          	mov a, c
0016++ 03B5 AF 01 00    	cmp a, 1
0017++ 03B8 D0 D2 03    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 03BB 7D          	dec a
0019++ 03BC FD 4E       	mov si, d	; beginning of string
0020++ 03BE FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 03C0 59          	add d, a	; end of string
0022++ 03C1 12          	mov a, c
0023++ 03C2 FD 9B       	shr a		; divide by 2
0024++ 03C4 39          	mov c, a	; C now counts the steps
0025++ 03C5             _strrev_L0:
0026++ 03C5 32          	mov bl, [d]	; save load right-side char into BL
0027++ 03C6 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 03C7 3E          	mov [d], al	; store left char into right side
0029++ 03C8 1B          	mov al, bl
0030++ 03C9 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 03CA 7E          	dec c
0032++ 03CB 7F          	dec d
0033++ 03CC C2 00 00    	cmp c, 0
0034++ 03CF C7 C5 03    	jne _strrev_L0
0035++ 03D2             _strrev_end:
0036++ 03D2 4C          	popa
0037++ 03D3 09          	ret
0038++ 03D4             	
0039++ 03D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 03D4             ; _strchr
0041++ 03D4             ; search string in D for char in AL
0042++ 03D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 03D4             _strchr:
0044++ 03D4             _strchr_L0:
0045++ 03D4 32          	mov bl, [d]
0046++ 03D5 C1 00       	cmp bl, 0
0047++ 03D7 C6 E2 03    	je _strchr_end
0048++ 03DA BA          	cmp al, bl
0049++ 03DB C6 E2 03    	je _strchr_end
0050++ 03DE 79          	inc d
0051++ 03DF 0A D4 03    	jmp _strchr_L0
0052++ 03E2             _strchr_end:
0053++ 03E2 1B          	mov al, bl
0054++ 03E3 09          	ret
0055++ 03E4             
0056++ 03E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 03E4             ; _strstr
0058++ 03E4             ; find sub-string
0059++ 03E4             ; str1 in SI
0060++ 03E4             ; str2 in DI
0061++ 03E4             ; SI points to end of source string
0062++ 03E4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 03E4             _strstr:
0064++ 03E4 DB          	push al
0065++ 03E5 DA          	push d
0066++ 03E6 E3          	push di
0067++ 03E7             _strstr_loop:
0068++ 03E7 F3          	cmpsb					; compare a byte of the strings
0069++ 03E8 C7 F3 03    	jne _strstr_ret
0070++ 03EB FC 00 00    	lea d, [di + 0]
0071++ 03EE BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 03F0 C7 E7 03    	jne _strstr_loop				; equal chars but not at end
0073++ 03F3             _strstr_ret:
0074++ 03F3 F0          	pop di
0075++ 03F4 E7          	pop d
0076++ 03F5 E8          	pop al
0077++ 03F6 09          	ret
0078++ 03F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 03F7             ; length of null terminated string
0080++ 03F7             ; result in C
0081++ 03F7             ; pointer in D
0082++ 03F7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 03F7             _strlen:
0084++ 03F7 DA          	push d
0085++ 03F8 38 00 00    	mov c, 0
0086++ 03FB             _strlen_L1:
0087++ 03FB BD 00       	cmp byte [d], 0
0088++ 03FD C6 05 04    	je _strlen_ret
0089++ 0400 79          	inc d
0090++ 0401 78          	inc c
0091++ 0402 0A FB 03    	jmp _strlen_L1
0092++ 0405             _strlen_ret:
0093++ 0405 E7          	pop d
0094++ 0406 09          	ret
0095++ 0407             
0096++ 0407             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0407             ; STRCMP
0098++ 0407             ; compare two strings
0099++ 0407             ; str1 in SI
0100++ 0407             ; str2 in DI
0101++ 0407             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0407             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0407             _strcmp:
0104++ 0407 DB          	push al
0105++ 0408 DA          	push d
0106++ 0409 E3          	push di
0107++ 040A E2          	push si
0108++ 040B             _strcmp_loop:
0109++ 040B F3          	cmpsb					; compare a byte of the strings
0110++ 040C C7 17 04    	jne _strcmp_ret
0111++ 040F FB FF FF    	lea d, [si +- 1]
0112++ 0412 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 0414 C7 0B 04    	jne _strcmp_loop				; equal chars but not at end
0114++ 0417             _strcmp_ret:
0115++ 0417 EF          	pop si
0116++ 0418 F0          	pop di
0117++ 0419 E7          	pop d
0118++ 041A E8          	pop al
0119++ 041B 09          	ret
0120++ 041C             
0121++ 041C             
0122++ 041C             ; STRCPY
0123++ 041C             ; copy null terminated string from SI to DI
0124++ 041C             ; source in SI
0125++ 041C             ; destination in DI
0126++ 041C             _strcpy:
0127++ 041C E2          	push si
0128++ 041D E3          	push di
0129++ 041E DB          	push al
0130++ 041F             _strcpy_L1:
0131++ 041F F6          	lodsb
0132++ 0420 F7          	stosb
0133++ 0421 B9 00       	cmp al, 0
0134++ 0423 C7 1F 04    	jne _strcpy_L1
0135++ 0426             _strcpy_end:
0136++ 0426 E8          	pop al
0137++ 0427 F0          	pop di
0138++ 0428 EF          	pop si
0139++ 0429 09          	ret
0140++ 042A             
0141++ 042A             ; STRCAT
0142++ 042A             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 042A             ; source in SI
0144++ 042A             ; destination in DI
0145++ 042A             _strcat:
0146++ 042A E2          	push si
0147++ 042B E3          	push di
0148++ 042C D7          	push a
0149++ 042D DA          	push d
0150++ 042E 50          	mov a, di
0151++ 042F 3C          	mov d, a
0152++ 0430             _strcat_goto_end_L1:
0153++ 0430 BD 00       	cmp byte[d], 0
0154++ 0432 C6 39 04    	je _strcat_start
0155++ 0435 79          	inc d
0156++ 0436 0A 30 04    	jmp _strcat_goto_end_L1
0157++ 0439             _strcat_start:
0158++ 0439 FD 50       	mov di, d
0159++ 043B             _strcat_L1:
0160++ 043B F6          	lodsb
0161++ 043C F7          	stosb
0162++ 043D B9 00       	cmp al, 0
0163++ 043F C7 3B 04    	jne _strcat_L1
0164++ 0442             _strcat_end:
0165++ 0442 E7          	pop d
0166++ 0443 E4          	pop a
0167++ 0444 F0          	pop di
0168++ 0445 EF          	pop si
0169++ 0446 09          	ret
0170++ 0447             
0171++ 0447             
0005+  0447             
0006+  0447             
0007+  0447             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0447             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0447             ; ASCII in BL
0010+  0447             ; result in AL
0011+  0447             ; ascii for F = 0100 0110
0012+  0447             ; ascii for 9 = 0011 1001
0013+  0447             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0447             hex_ascii_encode:
0015+  0447 1B            mov al, bl
0016+  0448 93 40         test al, $40        ; test if letter or number
0017+  044A C7 50 04      jnz hex_letter
0018+  044D 87 0F         and al, $0F        ; get number
0019+  044F 09            ret
0020+  0450             hex_letter:
0021+  0450 87 0F         and al, $0F        ; get letter
0022+  0452 6A 09         add al, 9
0023+  0454 09            ret
0024+  0455             
0025+  0455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0455             ; ATOI
0027+  0455             ; 2 letter hex string in B
0028+  0455             ; 8bit integer returned in AL
0029+  0455             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0455             _atoi:
0031+  0455 D8            push b
0032+  0456 07 47 04      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0459 30            mov bl, bh
0034+  045A DB            push al          ; save a
0035+  045B 07 47 04      call hex_ascii_encode
0036+  045E EA            pop bl  
0037+  045F FD 9E 04      shl al, 4
0038+  0462 8C            or al, bl
0039+  0463 E5            pop b
0040+  0464 09            ret  
0041+  0465             
0042+  0465             
0043+  0465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0465             ; scanf
0045+  0465             ; no need for explanations!
0046+  0465             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0465             scanf:
0048+  0465 09            ret
0049+  0466             
0050+  0466             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0466             ; ITOA
0052+  0466             ; 8bit value in BL
0053+  0466             ; 2 byte ASCII result in A
0054+  0466             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0466             _itoa:
0056+  0466 DA            push d
0057+  0467 D8            push b
0058+  0468 A7 00         mov bh, 0
0059+  046A FD A4 04      shr bl, 4  
0060+  046D 74            mov d, b
0061+  046E 1F 00 07      mov al, [d + s_hex_digits]
0062+  0471 23            mov ah, al
0063+  0472               
0064+  0472 E5            pop b
0065+  0473 D8            push b
0066+  0474 A7 00         mov bh, 0
0067+  0476 FD 87 0F      and bl, $0F
0068+  0479 74            mov d, b
0069+  047A 1F 00 07      mov al, [d + s_hex_digits]
0070+  047D E5            pop b
0071+  047E E7            pop d
0072+  047F 09            ret
0073+  0480             
0074+  0480             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0480             ; HEX STRING TO BINARY
0076+  0480             ; di = destination address
0077+  0480             ; si = source
0078+  0480             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0480             _hex_to_int:
0080+  0480             _hex_to_int_L1:
0081+  0480 F6            lodsb          ; load from [SI] to AL
0082+  0481 B9 00         cmp al, 0        ; check if ASCII 0
0083+  0483 C6 90 04      jz _hex_to_int_ret
0084+  0486 36            mov bh, al
0085+  0487 F6            lodsb
0086+  0488 2F            mov bl, al
0087+  0489 07 55 04      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  048C F7            stosb          ; store AL to [DI]
0089+  048D 0A 80 04      jmp _hex_to_int_L1
0090+  0490             _hex_to_int_ret:
0091+  0490 09            ret    
0092+  0491             
0093+  0491             
0094+  0491             
0095+  0491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0491             ; GETCHAR
0097+  0491             ; char in ah
0098+  0491             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0491             getch:
0100+  0491 DB            push al
0101+  0492             getch_retry:
0102+  0492 19 01         mov al, 1
0103+  0494 05 00         syscall sys_io      ; receive in AH
0104+  0496 E8            pop al
0105+  0497 09            ret
0106+  0498             
0107+  0498             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  0498             ; PUTCHAR
0109+  0498             ; char in ah
0110+  0498             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  0498             _putchar:
0112+  0498 DB            push al
0113+  0499 19 00         mov al, 0
0114+  049B 05 00         syscall sys_io      ; char in AH
0115+  049D E8            pop al
0116+  049E 09            ret
0117+  049F             
0118+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  049F             ;; INPUT A STRING
0120+  049F             ;; terminates with null
0121+  049F             ;; pointer in D
0122+  049F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  049F             _gets:
0124+  049F D7            push a
0125+  04A0 DA            push d
0126+  04A1             _gets_loop:
0127+  04A1 19 01         mov al, 1
0128+  04A3 05 00         syscall sys_io      ; receive in AH
0129+  04A5 76 1B         cmp ah, 27
0130+  04A7 C6 C8 04      je _gets_ansi_esc
0131+  04AA 76 0A         cmp ah, $0A        ; LF
0132+  04AC C6 24 05      je _gets_end
0133+  04AF 76 0D         cmp ah, $0D        ; CR
0134+  04B1 C6 24 05      je _gets_end
0135+  04B4 76 5C         cmp ah, $5C        ; '\\'
0136+  04B6 C6 EA 04      je _gets_escape
0137+  04B9 76 08         cmp ah, $08      ; check for backspace
0138+  04BB C6 C4 04      je _gets_backspace
0139+  04BE 1A            mov al, ah
0140+  04BF 3E            mov [d], al
0141+  04C0 79            inc d
0142+  04C1 0A A1 04      jmp _gets_loop
0143+  04C4             _gets_backspace:
0144+  04C4 7F            dec d
0145+  04C5 0A A1 04      jmp _gets_loop
0146+  04C8             _gets_ansi_esc:
0147+  04C8 19 01         mov al, 1
0148+  04CA 05 00         syscall sys_io        ; receive in AH without echo
0149+  04CC 76 5B         cmp ah, '['
0150+  04CE C7 A1 04      jne _gets_loop
0151+  04D1 19 01         mov al, 1
0152+  04D3 05 00         syscall sys_io          ; receive in AH without echo
0153+  04D5 76 44         cmp ah, 'D'
0154+  04D7 C6 E2 04      je _gets_left_arrow
0155+  04DA 76 43         cmp ah, 'C'
0156+  04DC C6 E6 04      je _gets_right_arrow
0157+  04DF 0A A1 04      jmp _gets_loop
0158+  04E2             _gets_left_arrow:
0159+  04E2 7F            dec d
0160+  04E3 0A A1 04      jmp _gets_loop
0161+  04E6             _gets_right_arrow:
0162+  04E6 79            inc d
0163+  04E7 0A A1 04      jmp _gets_loop
0164+  04EA             _gets_escape:
0165+  04EA 19 01         mov al, 1
0166+  04EC 05 00         syscall sys_io      ; receive in AH
0167+  04EE 76 6E         cmp ah, 'n'
0168+  04F0 C6 0F 05      je _gets_LF
0169+  04F3 76 72         cmp ah, 'r'
0170+  04F5 C6 16 05      je _gets_CR
0171+  04F8 76 30         cmp ah, '0'
0172+  04FA C6 1D 05      je _gets_NULL
0173+  04FD 76 5C         cmp ah, $5C  ; '\'
0174+  04FF C6 08 05      je _gets_slash
0175+  0502 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  0503 3E            mov [d], al
0177+  0504 79            inc d
0178+  0505 0A A1 04      jmp _gets_loop
0179+  0508             _gets_slash:
0180+  0508 19 5C         mov al, $5C
0181+  050A 3E            mov [d], al
0182+  050B 79            inc d
0183+  050C 0A A1 04      jmp _gets_loop
0184+  050F             _gets_LF:
0185+  050F 19 0A         mov al, $0A
0186+  0511 3E            mov [d], al
0187+  0512 79            inc d
0188+  0513 0A A1 04      jmp _gets_loop
0189+  0516             _gets_CR:
0190+  0516 19 0D         mov al, $0D
0191+  0518 3E            mov [d], al
0192+  0519 79            inc d
0193+  051A 0A A1 04      jmp _gets_loop
0194+  051D             _gets_NULL:
0195+  051D 19 00         mov al, $00
0196+  051F 3E            mov [d], al
0197+  0520 79            inc d
0198+  0521 0A A1 04      jmp _gets_loop
0199+  0524             _gets_end:
0200+  0524 19 00         mov al, 0
0201+  0526 3E            mov [d], al        ; terminate string
0202+  0527 E7            pop d
0203+  0528 E4            pop a
0204+  0529 09            ret
0205+  052A             
0206+  052A             
0207+  052A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  052A             ;; INPUT TEXT
0209+  052A             ;; terminated with CTRL+D
0210+  052A             ;; pointer in D
0211+  052A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  052A             _gettxt:
0213+  052A D7            push a
0214+  052B DA            push d
0215+  052C             _gettxt_loop:
0216+  052C 19 01         mov al, 1
0217+  052E 05 00         syscall sys_io      ; receive in AH
0218+  0530 76 04         cmp ah, 4      ; EOT
0219+  0532 C6 6B 05      je _gettxt_end
0220+  0535 76 08         cmp ah, $08      ; check for backspace
0221+  0537 C6 67 05      je _gettxt_backspace
0222+  053A 76 5C         cmp ah, $5C        ; '\'
0223+  053C C6 45 05      je _gettxt_escape
0224+  053F 1A            mov al, ah
0225+  0540 3E            mov [d], al
0226+  0541 79            inc d
0227+  0542 0A 2C 05      jmp _gettxt_loop
0228+  0545             _gettxt_escape:
0229+  0545 19 01         mov al, 1
0230+  0547 05 00         syscall sys_io      ; receive in AH
0231+  0549 76 6E         cmp ah, 'n'
0232+  054B C6 59 05      je _gettxt_LF
0233+  054E 76 72         cmp ah, 'r'
0234+  0550 C6 60 05      je _gettxt_CR
0235+  0553 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0554 3E            mov [d], al
0237+  0555 79            inc d
0238+  0556 0A 2C 05      jmp _gettxt_loop
0239+  0559             _gettxt_LF:
0240+  0559 19 0A         mov al, $0A
0241+  055B 3E            mov [d], al
0242+  055C 79            inc d
0243+  055D 0A 2C 05      jmp _gettxt_loop
0244+  0560             _gettxt_CR:
0245+  0560 19 0D         mov al, $0D
0246+  0562 3E            mov [d], al
0247+  0563 79            inc d
0248+  0564 0A 2C 05      jmp _gettxt_loop
0249+  0567             _gettxt_backspace:
0250+  0567 7F            dec d
0251+  0568 0A 2C 05      jmp _gettxt_loop
0252+  056B             _gettxt_end:
0253+  056B 19 00         mov al, 0
0254+  056D 3E            mov [d], al        ; terminate string
0255+  056E E7            pop d
0256+  056F E4            pop a
0257+  0570 09            ret
0258+  0571             
0259+  0571             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0571             ; PRINT NEW LINE
0261+  0571             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0571             printnl:
0263+  0571 D7            push a
0264+  0572 10 00 0A      mov a, $0A00
0265+  0575 05 00         syscall sys_io
0266+  0577 10 00 0D      mov a, $0D00
0267+  057A 05 00         syscall sys_io
0268+  057C E4            pop a
0269+  057D 09            ret
0270+  057E             
0271+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  057E             ; _strtoint
0273+  057E             ; 4 digit hex string number in d
0274+  057E             ; integer returned in A
0275+  057E             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  057E             _strtointx:
0277+  057E D8            push b
0278+  057F 32            mov bl, [d]
0279+  0580 37            mov bh, bl
0280+  0581 33 01 00      mov bl, [d + 1]
0281+  0584 07 55 04      call _atoi        ; convert to int in AL
0282+  0587 23            mov ah, al        ; move to AH
0283+  0588 33 02 00      mov bl, [d + 2]
0284+  058B 37            mov bh, bl
0285+  058C 33 03 00      mov bl, [d + 3]
0286+  058F 07 55 04      call _atoi        ; convert to int in AL
0287+  0592 E5            pop b
0288+  0593 09            ret
0289+  0594             
0290+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0594             ; _strtoint
0292+  0594             ; 5 digit base10 string number in d
0293+  0594             ; integer returned in A
0294+  0594             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0594             _strtoint:
0296+  0594 E2            push si
0297+  0595 D8            push b
0298+  0596 D9            push c
0299+  0597 DA            push d
0300+  0598 07 F7 03      call _strlen      ; get string length in C
0301+  059B 7E            dec c
0302+  059C FD 4E         mov si, d
0303+  059E 12            mov a, c
0304+  059F FD 99         shl a
0305+  05A1 3B 18 07      mov d, table_power
0306+  05A4 59            add d, a
0307+  05A5 38 00 00      mov c, 0
0308+  05A8             _strtoint_L0:
0309+  05A8 F6            lodsb      ; load ASCII to al
0310+  05A9 B9 00         cmp al, 0
0311+  05AB C6 BE 05      je _strtoint_end
0312+  05AE 6F 30         sub al, $30    ; make into integer
0313+  05B0 22 00         mov ah, 0
0314+  05B2 2A            mov b, [d]
0315+  05B3 AC            mul a, b      ; result in B since it fits in 16bits
0316+  05B4 11            mov a, b
0317+  05B5 28            mov b, c
0318+  05B6 54            add a, b
0319+  05B7 39            mov c, a
0320+  05B8 63 02 00      sub d, 2
0321+  05BB 0A A8 05      jmp _strtoint_L0
0322+  05BE             _strtoint_end:
0323+  05BE 12            mov a, c
0324+  05BF E7            pop d
0325+  05C0 E6            pop c
0326+  05C1 E5            pop b
0327+  05C2 EF            pop si
0328+  05C3 09            ret
0329+  05C4             
0330+  05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  05C4             ; PRINT NULL TERMINATED STRING
0332+  05C4             ; pointer in D
0333+  05C4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  05C4             _puts:
0335+  05C4 D7            push a
0336+  05C5 DA            push d
0337+  05C6             _puts_L1:
0338+  05C6 1E            mov al, [d]
0339+  05C7 B9 00         cmp al, 0
0340+  05C9 C6 D5 05      jz _puts_END
0341+  05CC 23            mov ah, al
0342+  05CD 19 00         mov al, 0
0343+  05CF 05 00         syscall sys_io
0344+  05D1 79            inc d
0345+  05D2 0A C6 05      jmp _puts_L1
0346+  05D5             _puts_END:
0347+  05D5 E7            pop d
0348+  05D6 E4            pop a
0349+  05D7 09            ret
0350+  05D8             
0351+  05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  05D8             ; PRINT N SIZE STRING
0353+  05D8             ; pointer in D
0354+  05D8             ; size in C
0355+  05D8             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  05D8             _putsn:
0357+  05D8 DB            push al
0358+  05D9 DA            push d
0359+  05DA D9            push c
0360+  05DB             _putsn_L0:
0361+  05DB 1E            mov al, [d]
0362+  05DC 23            mov ah, al
0363+  05DD 19 00         mov al, 0
0364+  05DF 05 00         syscall sys_io
0365+  05E1 79            inc d
0366+  05E2 7E            dec c  
0367+  05E3 C2 00 00      cmp c, 0
0368+  05E6 C7 DB 05      jne _putsn_L0
0369+  05E9             _putsn_end:
0370+  05E9 E6            pop c
0371+  05EA E7            pop d
0372+  05EB E8            pop al
0373+  05EC 09            ret
0374+  05ED             
0375+  05ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  05ED             ; print 16bit decimal number
0377+  05ED             ; input number in A
0378+  05ED             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  05ED             print_u16d:
0380+  05ED D7            push a
0381+  05EE D8            push b
0382+  05EF FD D8         push g
0383+  05F1 26 10 27      mov b, 10000
0384+  05F4 AE            div a, b      ; get 10000's coeff.
0385+  05F5 07 19 06      call print_number
0386+  05F8 11            mov a, b
0387+  05F9 26 E8 03      mov b, 1000
0388+  05FC AE            div a, b      ; get 1000's coeff.
0389+  05FD 07 19 06      call print_number
0390+  0600 11            mov a, b
0391+  0601 26 64 00      mov b, 100
0392+  0604 AE            div a, b
0393+  0605 07 19 06      call print_number
0394+  0608 11            mov a, b
0395+  0609 26 0A 00      mov b, 10
0396+  060C AE            div a, b
0397+  060D 07 19 06      call print_number
0398+  0610 1B            mov al, bl      ; 1's coeff in bl
0399+  0611 07 19 06      call print_number
0400+  0614 FD F1         pop g
0401+  0616 E5            pop b
0402+  0617 E4            pop a
0403+  0618 09            ret
0404+  0619             
0405+  0619             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0619             ; print AL
0407+  0619             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0619             print_number:
0409+  0619 6A 30         add al, $30
0410+  061B 23            mov ah, al
0411+  061C 07 98 04      call _putchar
0412+  061F 09            ret
0413+  0620             
0414+  0620             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  0620             ; PRINT 16BIT HEX INTEGER
0416+  0620             ; integer value in reg B
0417+  0620             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  0620             print_u16x:
0419+  0620 D7            push a
0420+  0621 D8            push b
0421+  0622 DD            push bl
0422+  0623 30            mov bl, bh
0423+  0624 07 66 04      call _itoa        ; convert bh to char in A
0424+  0627 2F            mov bl, al        ; save al
0425+  0628 19 00         mov al, 0
0426+  062A 05 00         syscall sys_io        ; display AH
0427+  062C 24            mov ah, bl        ; retrieve al
0428+  062D 19 00         mov al, 0
0429+  062F 05 00         syscall sys_io        ; display AL
0430+  0631             
0431+  0631 EA            pop bl
0432+  0632 07 66 04      call _itoa        ; convert bh to char in A
0433+  0635 2F            mov bl, al        ; save al
0434+  0636 19 00         mov al, 0
0435+  0638 05 00         syscall sys_io        ; display AH
0436+  063A 24            mov ah, bl        ; retrieve al
0437+  063B 19 00         mov al, 0
0438+  063D 05 00         syscall sys_io        ; display AL
0439+  063F             
0440+  063F E5            pop b
0441+  0640 E4            pop a
0442+  0641 09            ret
0443+  0642             
0444+  0642             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  0642             ; INPUT 16BIT HEX INTEGER
0446+  0642             ; read 16bit integer into A
0447+  0642             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  0642             scan_u16x:
0449+  0642 F8 10 00      enter 16
0450+  0645 D8            push b
0451+  0646 DA            push d
0452+  0647             
0453+  0647 FA F1 FF      lea d, [bp + -15]
0454+  064A 07 9F 04      call _gets        ; get number
0455+  064D             
0456+  064D 32            mov bl, [d]
0457+  064E 37            mov bh, bl
0458+  064F 33 01 00      mov bl, [d + 1]
0459+  0652 07 55 04      call _atoi        ; convert to int in AL
0460+  0655 23            mov ah, al        ; move to AH
0461+  0656             
0462+  0656 33 02 00      mov bl, [d + 2]
0463+  0659 37            mov bh, bl
0464+  065A 33 03 00      mov bl, [d + 3]
0465+  065D 07 55 04      call _atoi        ; convert to int in AL
0466+  0660             
0467+  0660 E7            pop d
0468+  0661 E5            pop b
0469+  0662 F9            leave
0470+  0663 09            ret
0471+  0664             
0472+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0664             ; PRINT 8bit HEX INTEGER
0474+  0664             ; integer value in reg bl
0475+  0664             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0664             print_u8x:
0477+  0664 D7            push a
0478+  0665 DD            push bl
0479+  0666             
0480+  0666 07 66 04      call _itoa        ; convert bl to char in A
0481+  0669 2F            mov bl, al        ; save al
0482+  066A 19 00         mov al, 0
0483+  066C 05 00         syscall sys_io        ; display AH
0484+  066E 24            mov ah, bl        ; retrieve al
0485+  066F 19 00         mov al, 0
0486+  0671 05 00         syscall sys_io        ; display AL
0487+  0673             
0488+  0673 EA            pop bl
0489+  0674 E4            pop a
0490+  0675 09            ret
0491+  0676             
0492+  0676             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0676             ; print 8bit decimal unsigned number
0494+  0676             ; input number in AL
0495+  0676             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0676             print_u8d:
0497+  0676 D7            push a
0498+  0677 D8            push b
0499+  0678 FD D8         push g
0500+  067A 22 00         mov ah, 0
0501+  067C 26 64 00      mov b, 100
0502+  067F AE            div a, b
0503+  0680 D8            push b      ; save remainder
0504+  0681 B9 00         cmp al, 0
0505+  0683 C6 8D 06      je skip100
0506+  0686 6A 30         add al, $30
0507+  0688 23            mov ah, al
0508+  0689 19 00         mov al, 0
0509+  068B 05 00         syscall sys_io  ; print coeff
0510+  068D             skip100:
0511+  068D E4            pop a
0512+  068E 22 00         mov ah, 0
0513+  0690 26 0A 00      mov b, 10
0514+  0693 AE            div a, b
0515+  0694 D8            push b      ; save remainder
0516+  0695 B9 00         cmp al, 0
0517+  0697 C6 A1 06      je skip10
0518+  069A 6A 30         add al, $30
0519+  069C 23            mov ah, al
0520+  069D 19 00         mov al, 0
0521+  069F 05 00         syscall sys_io  ; print coeff
0522+  06A1             skip10:
0523+  06A1 E4            pop a
0524+  06A2 1B            mov al, bl
0525+  06A3 6A 30         add al, $30
0526+  06A5 23            mov ah, al
0527+  06A6 19 00         mov al, 0
0528+  06A8 05 00         syscall sys_io  ; print coeff
0529+  06AA FD F1         pop g
0530+  06AC E5            pop b
0531+  06AD E4            pop a
0532+  06AE 09            ret
0533+  06AF             
0534+  06AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  06AF             ; INPUT 8BIT HEX INTEGER
0536+  06AF             ; read 8bit integer into AL
0537+  06AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  06AF             scan_u8x:
0539+  06AF F8 04 00      enter 4
0540+  06B2 D8            push b
0541+  06B3 DA            push d
0542+  06B4             
0543+  06B4 FA FD FF      lea d, [bp + -3]
0544+  06B7 07 9F 04      call _gets        ; get number
0545+  06BA             
0546+  06BA 32            mov bl, [d]
0547+  06BB 37            mov bh, bl
0548+  06BC 33 01 00      mov bl, [d + 1]
0549+  06BF 07 55 04      call _atoi        ; convert to int in AL
0550+  06C2             
0551+  06C2 E7            pop d
0552+  06C3 E5            pop b
0553+  06C4 F9            leave
0554+  06C5 09            ret
0555+  06C6             
0556+  06C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  06C6             ; input decimal number
0558+  06C6             ; result in A
0559+  06C6             ; 655'\0'
0560+  06C6             ; low--------high
0561+  06C6             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  06C6             scan_u16d:
0563+  06C6 F8 08 00      enter 8
0564+  06C9 E2            push si
0565+  06CA D8            push b
0566+  06CB D9            push c
0567+  06CC DA            push d
0568+  06CD FA F9 FF      lea d, [bp +- 7]
0569+  06D0 07 9F 04      call _gets
0570+  06D3 07 F7 03      call _strlen      ; get string length in C
0571+  06D6 7E            dec c
0572+  06D7 FD 4E         mov si, d
0573+  06D9 12            mov a, c
0574+  06DA FD 99         shl a
0575+  06DC 3B 18 07      mov d, table_power
0576+  06DF 59            add d, a
0577+  06E0 38 00 00      mov c, 0
0578+  06E3             mul_loop:
0579+  06E3 F6            lodsb      ; load ASCII to al
0580+  06E4 B9 00         cmp al, 0
0581+  06E6 C6 F9 06      je mul_exit
0582+  06E9 6F 30         sub al, $30    ; make into integer
0583+  06EB 22 00         mov ah, 0
0584+  06ED 2A            mov b, [d]
0585+  06EE AC            mul a, b      ; result in B since it fits in 16bits
0586+  06EF 11            mov a, b
0587+  06F0 28            mov b, c
0588+  06F1 54            add a, b
0589+  06F2 39            mov c, a
0590+  06F3 63 02 00      sub d, 2
0591+  06F6 0A E3 06      jmp mul_loop
0592+  06F9             mul_exit:
0593+  06F9 12            mov a, c
0594+  06FA E7            pop d
0595+  06FB E6            pop c
0596+  06FC E5            pop b
0597+  06FD EF            pop si
0598+  06FE F9            leave
0599+  06FF 09            ret
0600+  0700             
0601+  0700             
0602+  0700 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  0704 34 35 36 37 
0602+  0708 38 39 41 42 
0602+  070C 43 44 45 46 
0603+  0710 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  0714 1B 5B 48 00 
0604+  0718             
0605+  0718             table_power:
0606+  0718 01 00         .dw 1
0607+  071A 0A 00         .dw 10
0608+  071C 64 00         .dw 100
0609+  071E E8 03         .dw 1000
0610+  0720 10 27         .dw 100000655   0722             .include "lib/ctype.asm"
0001+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0722             ; ctype.s
0003+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0722             
0005+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  0722             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  0722             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  0722             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  0722             ;; characters are supported.
0010+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  0722             ;; _isalnum 
0012+  0722             ;; _isalpha 
0013+  0722             ;; islower 
0014+  0722             ;; isupper 
0015+  0722             ;; _isdigit 
0016+  0722             ;; isxdigit
0017+  0722             ;; iscntrl 
0018+  0722             ;; isgraph 
0019+  0722             ;; _isspace 
0020+  0722             ;; isblank 
0021+  0722             ;; isprint 
0022+  0722             ;; ispunct 
0023+  0722             ;; tolower 
0024+  0722             ;; toupper
0025+  0722             
0026+  0722             
0027+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  0722             ;; IS ALPHANUMERIC
0029+  0722             ;; sets ZF according with result
0030+  0722             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  0722             _isalnum:
0032+  0722 07 3F 07    	call _isalpha
0033+  0725 C6 2B 07    	je _isalnum_exit
0034+  0728 07 2C 07    	call _isdigit
0035+  072B             _isalnum_exit:
0036+  072B 09          	ret	
0037+  072C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  072C             ;; IS DIGIT
0039+  072C             ;; sets ZF according with result
0040+  072C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  072C             _isdigit:
0042+  072C DB          	push al
0043+  072D B9 30       	cmp al, '0'
0044+  072F C8 3B 07    	jlu _isdigit_false
0045+  0732 B9 39       	cmp al, '9'
0046+  0734 D1 3B 07    	jgu _isdigit_false
0047+  0737 87 00       	and al, 0	; set ZF
0048+  0739 E8          	pop al
0049+  073A 09          	ret
0050+  073B             _isdigit_false:
0051+  073B 8B 01       	or al, 1	; clear ZF
0052+  073D E8          	pop al
0053+  073E 09          	ret	
0054+  073F             	
0055+  073F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  073F             ;; IS ALPHA
0057+  073F             ;; sets ZF according with result
0058+  073F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  073F             _isalpha:
0060+  073F DB          	push al
0061+  0740 B9 5F       	cmp al, '_'
0062+  0742 C6 62 07    	je _isalpha_true
0063+  0745 B9 2E       	cmp al, '.'
0064+  0747 C6 62 07    	je _isalpha_true
0065+  074A B9 41       	cmp al, 'A'
0066+  074C C8 5E 07    	jlu _isalpha_false
0067+  074F B9 7A       	cmp al, 'z'
0068+  0751 D1 5E 07    	jgu _isalpha_false
0069+  0754 B9 5A       	cmp al, 'Z'
0070+  0756 D0 62 07    	jleu _isalpha_true
0071+  0759 B9 61       	cmp al, 'a'
0072+  075B C9 62 07    	jgeu _isalpha_true
0073+  075E             _isalpha_false:
0074+  075E 8B 01       	or al, 1	; clear ZF
0075+  0760 E8          	pop al
0076+  0761 09          	ret
0077+  0762             _isalpha_true:
0078+  0762 87 00       	and al, 0	; set ZF
0079+  0764 E8          	pop al
0080+  0765 09          	ret
0081+  0766             
0082+  0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0766             ;; IS PATH-ALPHA
0084+  0766             ;; sets ZF according with result
0085+  0766             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0766             ispath:
0087+  0766 DB          	push al
0088+  0767 07 2C 07    	call _isdigit
0089+  076A C6 94 07    	je ispath_true
0090+  076D B9 5F       	cmp al, '_'
0091+  076F C6 94 07    	je ispath_true
0092+  0772 B9 2F       	cmp al, '/'
0093+  0774 C6 94 07    	je ispath_true
0094+  0777 B9 2E       	cmp al, '.'
0095+  0779 C6 94 07    	je ispath_true
0096+  077C B9 41       	cmp al, 'A'
0097+  077E C8 90 07    	jlu ispath_false
0098+  0781 B9 7A       	cmp al, 'z'
0099+  0783 D1 90 07    	jgu ispath_false
0100+  0786 B9 5A       	cmp al, 'Z'
0101+  0788 D0 94 07    	jleu ispath_true
0102+  078B B9 61       	cmp al, 'a'
0103+  078D C9 94 07    	jgeu ispath_true
0104+  0790             ispath_false:
0105+  0790 8B 01       	or al, 1	; clear ZF
0106+  0792 E8          	pop al
0107+  0793 09          	ret
0108+  0794             ispath_true:
0109+  0794 87 00       	and al, 0	; set ZF
0110+  0796 E8          	pop al
0111+  0797 09          	ret
0112+  0798             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  0798             ;; IS SPACE
0114+  0798             ;; sets ZF according with result
0115+  0798             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  0798             _isspace:
0117+  0798 B9 20       	cmp al, $20		; ' '
0118+  079A C6 AE 07    	je _isspace_exit
0119+  079D B9 09       	cmp al, $09		; '\t'
0120+  079F C6 AE 07    	je _isspace_exit
0121+  07A2 B9 0A       	cmp al, $0A		; '\n'
0122+  07A4 C6 AE 07    	je _isspace_exit
0123+  07A7 B9 0D       	cmp al, $0D		; '\r'
0124+  07A9 C6 AE 07    	je _isspace_exit
0125+  07AC B9 0B       	cmp al, $0B		; '\v'
0126+  07AE             _isspace_exit:
0127+  07AE 09          	ret	
0128+  07AF             
0129+  07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  07AF             ; TO LOWER
0131+  07AF             ; input in AL
0132+  07AF             ; output in AL
0133+  07AF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  07AF             _to_lower:
0135+  07AF B9 5A       	cmp al, 'Z'
0136+  07B1 D1 B6 07    	jgu _to_lower_ret
0137+  07B4 6A 20       	add al, $20				; convert to lower case
0138+  07B6             _to_lower_ret:
0139+  07B6 09          	ret
0140+  07B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  07B7             ; TO UPPER
0142+  07B7             ; input in AL
0143+  07B7             ; output in AL
0144+  07B7             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  07B7             _to_upper:
0146+  07B7 B9 61       	cmp al, 'a'
0147+  07B9 C8 BE 07    	jlu _to_upper_ret
0148+  07BC 6F 20       	sub al, $20			; convert to upper case
0149+  07BE             _to_upper_ret:
0150+  07BE 09          	ret
0151+  07BF             
0656   07BF             
0657   07BF             ; kernel parameters
0658   07BF             sys_echo_on:
0659   07BF 01            .db 1
0660   07C0             sys_uart0_lcr:
0661   07C0 07            .db $07 ; 8 data bits, 2 stop bit, no parity
0662   07C1             sys_uart0_inten:
0663   07C1 01            .db 1
0664   07C2             sys_uart0_fifoen:
0665   07C2 00            .db 0
0666   07C3             sys_uart0_div0:
0667   07C3 0C            .db 12  ;
0668   07C4             sys_uart0_div1:
0669   07C4 00            .db 0   ; default baud = 9600
0670   07C5             ; Baud  Divisor
0671   07C5             ; 50    2304
0672   07C5             ; 110   1047
0673   07C5             ; 300    384
0674   07C5             ; 600    192
0675   07C5             ; 1200    96
0676   07C5             ; 9600    12
0677   07C5             ; 19200    6
0678   07C5             ; 38400    3
0679   07C5             
0680   07C5             
0681   07C5             fifo_in:
0682   07C5 5B 0A         .dw fifo
0683   07C7             fifo_out:
0684   07C7 5B 0A         .dw fifo
0685   07C9             
0686   07C9             
0687   07C9             s_kernel_started:
0688   07C9 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
0688   07CD 65 6C 20 73 
0688   07D1 74 61 72 74 
0688   07D5 65 64 28 76 
0688   07D9 65 72 73 69 
0688   07DD 6F 6E 20 31 
0688   07E1 2E 30 29 0A 
0688   07E5 00 
0689   07E6             s_priviledge:
0690   07E6 0A 65 78 63   .db "\nexception: privilege\n", 0
0690   07EA 65 70 74 69 
0690   07EE 6F 6E 3A 20 
0690   07F2 70 72 69 76 
0690   07F6 69 6C 65 67 
0690   07FA 65 0A 00 
0691   07FD             s_divzero:
0692   07FD 0A 65 78 63   .db "\nexception: zero division\n", 0
0692   0801 65 70 74 69 
0692   0805 6F 6E 3A 20 
0692   0809 7A 65 72 6F 
0692   080D 20 64 69 76 
0692   0811 69 73 69 6F 
0692   0815 6E 0A 00 
0693   0818             
0694   0818             ; This is the format of a sector for the 128 byte per sector format.
0695   0818             ; Write the bracketed data 16 times per track.
0696   0818             ; The recommended single-density format with 128
0697   0818             ; bytes/sector is shown. In order to format a diskette,
0698   0818             ; the user issues the Write Track Command, and loads
0699   0818             ; the Data Register with the following values. For every
0700   0818             ; byte to be written, there is one Data Request.
0701   0818             fdc_irq_event:
0702   0818 00            .fill 1,  $00       ; keeps status of fdc irq event
0703   0819             fdc_128_format:                                                                       
0704   0819             fdc_40_FF:
0705   0819 FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
0705   081D FF FF FF FF 
0705   0821 FF FF FF FF 
0705   0825 FF FF FF FF 
0705   0829 FF FF FF FF 
0705   082D FF FF FF FF 
0705   0831 FF FF FF FF 
0705   0835 FF FF FF FF 
0705   0839 FF FF FF FF 
0705   083D FF FF FF FF 
0706   0841             fdc_128_format_inner:
0707   0841 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
0707   0845 00 00 
0708   0847 FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
0709   0848             fdc_128_format_track:
0710   0848 00            .fill 1,   $00    ; Track Number   0 thru 39                                                      |                    
0711   0849 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0712   084A             fdc_128_format_sect:
0713   084A 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0714   084B 00            .fill 1,   $00    ; Sector Length                                                                 |                        
0715   084C F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0716   084D FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
0716   0851 FF FF FF FF 
0716   0855 FF FF FF 
0717   0858 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
0717   085C 00 00 
0718   085E FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0719   085F E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0719   0863 E5 E5 E5 E5 
0719   0867 E5 E5 E5 E5 
0719   086B E5 E5 E5 E5 
0719   086F E5 E5 E5 E5 
0719   0873 E5 E5 E5 E5 
0719   0877 E5 E5 E5 E5 
0719   087B E5 E5 E5 E5 
0719   087F E5 E5 E5 E5 
0719   0883 E5 E5 E5 E5 
0719   0887 E5 E5 E5 E5 
0719   088B E5 E5 E5 E5 
0719   088F E5 E5 E5 E5 
0719   0893 E5 E5 E5 E5 
0719   0897 E5 E5 E5 E5 
0719   089B E5 E5 E5 E5 
0719   089F E5 E5 E5 E5 
0719   08A3 E5 E5 E5 E5 
0719   08A7 E5 E5 E5 E5 
0719   08AB E5 E5 E5 E5 
0719   08AF E5 E5 E5 E5 
0719   08B3 E5 E5 E5 E5 
0719   08B7 E5 E5 E5 E5 
0719   08BB E5 E5 E5 E5 
0719   08BF E5 E5 E5 E5 
0719   08C3 E5 E5 E5 E5 
0719   08C7 E5 E5 E5 E5 
0719   08CB E5 E5 E5 E5 
0719   08CF E5 E5 E5 E5 
0719   08D3 E5 E5 E5 E5 
0719   08D7 E5 E5 E5 E5 
0719   08DB E5 E5 E5 E5 
0720   08DF F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0721   08E0 FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0721   08E4 FF FF FF FF 
0721   08E8 FF FF 
0722   08EA             fdc_128_format_end:
0723   08EA FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0723   08EE FF FF FF FF 
0723   08F2 FF FF FF FF 
0723   08F6 FF FF FF FF 
0723   08FA FF FF FF FF 
0723   08FE FF FF FF FF 
0723   0902 FF FF FF FF 
0723   0906 FF FF FF FF 
0723   090A FF FF FF FF 
0723   090E FF FF FF FF 
0723   0912 FF FF FF FF 
0723   0916 FF FF FF FF 
0723   091A FF FF FF FF 
0723   091E FF FF FF FF 
0723   0922 FF FF FF FF 
0723   0926 FF FF FF FF 
0723   092A FF FF FF FF 
0723   092E FF FF FF FF 
0723   0932 FF FF FF FF 
0723   0936 FF FF FF FF 
0723   093A FF FF FF FF 
0723   093E FF FF FF FF 
0723   0942 FF FF FF FF 
0723   0946 FF FF FF FF 
0723   094A FF FF FF FF 
0723   094E FF FF FF FF 
0723   0952 FF FF FF FF 
0723   0956 FF FF FF FF 
0723   095A FF FF FF FF 
0723   095E FF FF FF FF 
0723   0962 FF FF FF FF 
0723   0966 FF FF FF FF 
0723   096A FF FF FF FF 
0723   096E FF FF FF FF 
0723   0972 FF FF FF FF 
0723   0976 FF FF FF FF 
0723   097A FF FF FF FF 
0723   097E FF FF FF FF 
0723   0982 FF FF FF FF 
0723   0986 FF FF FF FF 
0723   098A FF FF FF FF 
0723   098E FF FF FF FF 
0723   0992 FF FF FF FF 
0723   0996 FF FF FF FF 
0723   099A FF FF FF FF 
0723   099E FF FF FF FF 
0723   09A2 FF FF FF FF 
0723   09A6 FF FF FF FF 
0723   09AA FF FF FF FF 
0723   09AE FF FF FF FF 
0723   09B2 FF FF FF FF 
0723   09B6 FF FF FF FF 
0723   09BA FF FF FF FF 
0723   09BE FF FF FF FF 
0723   09C2 FF FF FF FF 
0723   09C6 FF FF FF FF 
0723   09CA FF FF FF FF 
0723   09CE FF FF FF FF 
0723   09D2 FF FF FF FF 
0723   09D6 FF FF FF FF 
0723   09DA FF FF FF FF 
0723   09DE FF FF FF FF 
0723   09E2 FF FF FF FF 
0723   09E6 FF FF FF FF 
0723   09EA FF FF FF FF 
0723   09EE FF FF FF FF 
0723   09F2 FF FF FF FF 
0723   09F6 FF FF FF FF 
0723   09FA FF FF FF FF 
0723   09FE FF FF FF FF 
0723   0A02 FF FF FF FF 
0723   0A06 FF FF FF FF 
0723   0A0A FF FF FF FF 
0723   0A0E FF FF FF FF 
0723   0A12 FF FF FF FF 
0723   0A16 FF FF FF FF 
0723   0A1A FF FF FF FF 
0723   0A1E FF FF FF FF 
0723   0A22 FF FF FF FF 
0723   0A26 FF FF FF FF 
0723   0A2A FF FF FF FF 
0723   0A2E FF FF FF FF 
0723   0A32 FF FF FF FF 
0723   0A36 FF FF FF FF 
0723   0A3A FF FF FF FF 
0723   0A3E FF FF FF FF 
0723   0A42 FF FF FF FF 
0723   0A46 FF FF FF FF 
0723   0A4A FF FF FF FF 
0723   0A4E FF FF FF FF 
0723   0A52 FF FF FF FF 
0723   0A56 FF FF FF FF 
0723   0A5A FF 
0724   0A5B             
0725   0A5B             fifo:
0726   0A5B FF FF FF FF   .fill FIFO_SIZE
0726   0A5F FF FF FF FF 
0726   0A63 FF FF FF FF 
0726   0A67 FF FF FF FF 
0726   0A6B FF FF FF FF 
0726   0A6F FF FF FF FF 
0726   0A73 FF FF FF FF 
0726   0A77 FF FF FF FF 
0726   0A7B FF FF FF FF 
0726   0A7F FF FF FF FF 
0726   0A83 FF FF FF FF 
0726   0A87 FF FF FF FF 
0726   0A8B FF FF FF FF 
0726   0A8F FF FF FF FF 
0726   0A93 FF FF FF FF 
0726   0A97 FF FF FF FF 
0726   0A9B FF FF FF FF 
0726   0A9F FF FF FF FF 
0726   0AA3 FF FF FF FF 
0726   0AA7 FF FF FF FF 
0726   0AAB FF FF FF FF 
0726   0AAF FF FF FF FF 
0726   0AB3 FF FF FF FF 
0726   0AB7 FF FF FF FF 
0726   0ABB FF FF FF FF 
0726   0ABF FF FF FF FF 
0726   0AC3 FF FF FF FF 
0726   0AC7 FF FF FF FF 
0726   0ACB FF FF FF FF 
0726   0ACF FF FF FF FF 
0726   0AD3 FF FF FF FF 
0726   0AD7 FF FF FF FF 
0726   0ADB FF FF FF FF 
0726   0ADF FF FF FF FF 
0726   0AE3 FF FF FF FF 
0726   0AE7 FF FF FF FF 
0726   0AEB FF FF FF FF 
0726   0AEF FF FF FF FF 
0726   0AF3 FF FF FF FF 
0726   0AF7 FF FF FF FF 
0726   0AFB FF FF FF FF 
0726   0AFF FF FF FF FF 
0726   0B03 FF FF FF FF 
0726   0B07 FF FF FF FF 
0726   0B0B FF FF FF FF 
0726   0B0F FF FF FF FF 
0726   0B13 FF FF FF FF 
0726   0B17 FF FF FF FF 
0726   0B1B FF FF FF FF 
0726   0B1F FF FF FF FF 
0726   0B23 FF FF FF FF 
0726   0B27 FF FF FF FF 
0726   0B2B FF FF FF FF 
0726   0B2F FF FF FF FF 
0726   0B33 FF FF FF FF 
0726   0B37 FF FF FF FF 
0726   0B3B FF FF FF FF 
0726   0B3F FF FF FF FF 
0726   0B43 FF FF FF FF 
0726   0B47 FF FF FF FF 
0726   0B4B FF FF FF FF 
0726   0B4F FF FF FF FF 
0726   0B53 FF FF FF FF 
0726   0B57 FF FF FF FF 
0726   0B5B FF FF FF FF 
0726   0B5F FF FF FF FF 
0726   0B63 FF FF FF FF 
0726   0B67 FF FF FF FF 
0726   0B6B FF FF FF FF 
0726   0B6F FF FF FF FF 
0726   0B73 FF FF FF FF 
0726   0B77 FF FF FF FF 
0726   0B7B FF FF FF FF 
0726   0B7F FF FF FF FF 
0726   0B83 FF FF FF FF 
0726   0B87 FF FF FF FF 
0726   0B8B FF FF FF FF 
0726   0B8F FF FF FF FF 
0726   0B93 FF FF FF FF 
0726   0B97 FF FF FF FF 
0726   0B9B FF FF FF FF 
0726   0B9F FF FF FF FF 
0726   0BA3 FF FF FF FF 
0726   0BA7 FF FF FF FF 
0726   0BAB FF FF FF FF 
0726   0BAF FF FF FF FF 
0726   0BB3 FF FF FF FF 
0726   0BB7 FF FF FF FF 
0726   0BBB FF FF FF FF 
0726   0BBF FF FF FF FF 
0726   0BC3 FF FF FF FF 
0726   0BC7 FF FF FF FF 
0726   0BCB FF FF FF FF 
0726   0BCF FF FF FF FF 
0726   0BD3 FF FF FF FF 
0726   0BD7 FF FF FF FF 
0726   0BDB FF FF FF FF 
0726   0BDF FF FF FF FF 
0726   0BE3 FF FF FF FF 
0726   0BE7 FF FF FF FF 
0726   0BEB FF FF FF FF 
0726   0BEF FF FF FF FF 
0726   0BF3 FF FF FF FF 
0726   0BF7 FF FF FF FF 
0726   0BFB FF FF FF FF 
0726   0BFF FF FF FF FF 
0726   0C03 FF FF FF FF 
0726   0C07 FF FF FF FF 
0726   0C0B FF FF FF FF 
0726   0C0F FF FF FF FF 
0726   0C13 FF FF FF FF 
0726   0C17 FF FF FF FF 
0726   0C1B FF FF FF FF 
0726   0C1F FF FF FF FF 
0726   0C23 FF FF FF FF 
0726   0C27 FF FF FF FF 
0726   0C2B FF FF FF FF 
0726   0C2F FF FF FF FF 
0726   0C33 FF FF FF FF 
0726   0C37 FF FF FF FF 
0726   0C3B FF FF FF FF 
0726   0C3F FF FF FF FF 
0726   0C43 FF FF FF FF 
0726   0C47 FF FF FF FF 
0726   0C4B FF FF FF FF 
0726   0C4F FF FF FF FF 
0726   0C53 FF FF FF FF 
0726   0C57 FF FF FF FF 
0726   0C5B FF FF FF FF 
0726   0C5F FF FF FF FF 
0726   0C63 FF FF FF FF 
0726   0C67 FF FF FF FF 
0726   0C6B FF FF FF FF 
0726   0C6F FF FF FF FF 
0726   0C73 FF FF FF FF 
0726   0C77 FF FF FF FF 
0726   0C7B FF FF FF FF 
0726   0C7F FF FF FF FF 
0726   0C83 FF FF FF FF 
0726   0C87 FF FF FF FF 
0726   0C8B FF FF FF FF 
0726   0C8F FF FF FF FF 
0726   0C93 FF FF FF FF 
0726   0C97 FF FF FF FF 
0726   0C9B FF FF FF FF 
0726   0C9F FF FF FF FF 
0726   0CA3 FF FF FF FF 
0726   0CA7 FF FF FF FF 
0726   0CAB FF FF FF FF 
0726   0CAF FF FF FF FF 
0726   0CB3 FF FF FF FF 
0726   0CB7 FF FF FF FF 
0726   0CBB FF FF FF FF 
0726   0CBF FF FF FF FF 
0726   0CC3 FF FF FF FF 
0726   0CC7 FF FF FF FF 
0726   0CCB FF FF FF FF 
0726   0CCF FF FF FF FF 
0726   0CD3 FF FF FF FF 
0726   0CD7 FF FF FF FF 
0726   0CDB FF FF FF FF 
0726   0CDF FF FF FF FF 
0726   0CE3 FF FF FF FF 
0726   0CE7 FF FF FF FF 
0726   0CEB FF FF FF FF 
0726   0CEF FF FF FF FF 
0726   0CF3 FF FF FF FF 
0726   0CF7 FF FF FF FF 
0726   0CFB FF FF FF FF 
0726   0CFF FF FF FF FF 
0726   0D03 FF FF FF FF 
0726   0D07 FF FF FF FF 
0726   0D0B FF FF FF FF 
0726   0D0F FF FF FF FF 
0726   0D13 FF FF FF FF 
0726   0D17 FF FF FF FF 
0726   0D1B FF FF FF FF 
0726   0D1F FF FF FF FF 
0726   0D23 FF FF FF FF 
0726   0D27 FF FF FF FF 
0726   0D2B FF FF FF FF 
0726   0D2F FF FF FF FF 
0726   0D33 FF FF FF FF 
0726   0D37 FF FF FF FF 
0726   0D3B FF FF FF FF 
0726   0D3F FF FF FF FF 
0726   0D43 FF FF FF FF 
0726   0D47 FF FF FF FF 
0726   0D4B FF FF FF FF 
0726   0D4F FF FF FF FF 
0726   0D53 FF FF FF FF 
0726   0D57 FF FF FF FF 
0726   0D5B FF FF FF FF 
0726   0D5F FF FF FF FF 
0726   0D63 FF FF FF FF 
0726   0D67 FF FF FF FF 
0726   0D6B FF FF FF FF 
0726   0D6F FF FF FF FF 
0726   0D73 FF FF FF FF 
0726   0D77 FF FF FF FF 
0726   0D7B FF FF FF FF 
0726   0D7F FF FF FF FF 
0726   0D83 FF FF FF FF 
0726   0D87 FF FF FF FF 
0726   0D8B FF FF FF FF 
0726   0D8F FF FF FF FF 
0726   0D93 FF FF FF FF 
0726   0D97 FF FF FF FF 
0726   0D9B FF FF FF FF 
0726   0D9F FF FF FF FF 
0726   0DA3 FF FF FF FF 
0726   0DA7 FF FF FF FF 
0726   0DAB FF FF FF FF 
0726   0DAF FF FF FF FF 
0726   0DB3 FF FF FF FF 
0726   0DB7 FF FF FF FF 
0726   0DBB FF FF FF FF 
0726   0DBF FF FF FF FF 
0726   0DC3 FF FF FF FF 
0726   0DC7 FF FF FF FF 
0726   0DCB FF FF FF FF 
0726   0DCF FF FF FF FF 
0726   0DD3 FF FF FF FF 
0726   0DD7 FF FF FF FF 
0726   0DDB FF FF FF FF 
0726   0DDF FF FF FF FF 
0726   0DE3 FF FF FF FF 
0726   0DE7 FF FF FF FF 
0726   0DEB FF FF FF FF 
0726   0DEF FF FF FF FF 
0726   0DF3 FF FF FF FF 
0726   0DF7 FF FF FF FF 
0726   0DFB FF FF FF FF 
0726   0DFF FF FF FF FF 
0726   0E03 FF FF FF FF 
0726   0E07 FF FF FF FF 
0726   0E0B FF FF FF FF 
0726   0E0F FF FF FF FF 
0726   0E13 FF FF FF FF 
0726   0E17 FF FF FF FF 
0726   0E1B FF FF FF FF 
0726   0E1F FF FF FF FF 
0726   0E23 FF FF FF FF 
0726   0E27 FF FF FF FF 
0726   0E2B FF FF FF FF 
0726   0E2F FF FF FF FF 
0726   0E33 FF FF FF FF 
0726   0E37 FF FF FF FF 
0726   0E3B FF FF FF FF 
0726   0E3F FF FF FF FF 
0726   0E43 FF FF FF FF 
0726   0E47 FF FF FF FF 
0726   0E4B FF FF FF FF 
0726   0E4F FF FF FF FF 
0726   0E53 FF FF FF FF 
0726   0E57 FF FF FF FF 
0727   0E5B             
0728   0E5B             scrap_sector:
0729   0E5B FF FF FF FF   .fill 512         ; scrap sector
0729   0E5F FF FF FF FF 
0729   0E63 FF FF FF FF 
0729   0E67 FF FF FF FF 
0729   0E6B FF FF FF FF 
0729   0E6F FF FF FF FF 
0729   0E73 FF FF FF FF 
0729   0E77 FF FF FF FF 
0729   0E7B FF FF FF FF 
0729   0E7F FF FF FF FF 
0729   0E83 FF FF FF FF 
0729   0E87 FF FF FF FF 
0729   0E8B FF FF FF FF 
0729   0E8F FF FF FF FF 
0729   0E93 FF FF FF FF 
0729   0E97 FF FF FF FF 
0729   0E9B FF FF FF FF 
0729   0E9F FF FF FF FF 
0729   0EA3 FF FF FF FF 
0729   0EA7 FF FF FF FF 
0729   0EAB FF FF FF FF 
0729   0EAF FF FF FF FF 
0729   0EB3 FF FF FF FF 
0729   0EB7 FF FF FF FF 
0729   0EBB FF FF FF FF 
0729   0EBF FF FF FF FF 
0729   0EC3 FF FF FF FF 
0729   0EC7 FF FF FF FF 
0729   0ECB FF FF FF FF 
0729   0ECF FF FF FF FF 
0729   0ED3 FF FF FF FF 
0729   0ED7 FF FF FF FF 
0729   0EDB FF FF FF FF 
0729   0EDF FF FF FF FF 
0729   0EE3 FF FF FF FF 
0729   0EE7 FF FF FF FF 
0729   0EEB FF FF FF FF 
0729   0EEF FF FF FF FF 
0729   0EF3 FF FF FF FF 
0729   0EF7 FF FF FF FF 
0729   0EFB FF FF FF FF 
0729   0EFF FF FF FF FF 
0729   0F03 FF FF FF FF 
0729   0F07 FF FF FF FF 
0729   0F0B FF FF FF FF 
0729   0F0F FF FF FF FF 
0729   0F13 FF FF FF FF 
0729   0F17 FF FF FF FF 
0729   0F1B FF FF FF FF 
0729   0F1F FF FF FF FF 
0729   0F23 FF FF FF FF 
0729   0F27 FF FF FF FF 
0729   0F2B FF FF FF FF 
0729   0F2F FF FF FF FF 
0729   0F33 FF FF FF FF 
0729   0F37 FF FF FF FF 
0729   0F3B FF FF FF FF 
0729   0F3F FF FF FF FF 
0729   0F43 FF FF FF FF 
0729   0F47 FF FF FF FF 
0729   0F4B FF FF FF FF 
0729   0F4F FF FF FF FF 
0729   0F53 FF FF FF FF 
0729   0F57 FF FF FF FF 
0729   0F5B FF FF FF FF 
0729   0F5F FF FF FF FF 
0729   0F63 FF FF FF FF 
0729   0F67 FF FF FF FF 
0729   0F6B FF FF FF FF 
0729   0F6F FF FF FF FF 
0729   0F73 FF FF FF FF 
0729   0F77 FF FF FF FF 
0729   0F7B FF FF FF FF 
0729   0F7F FF FF FF FF 
0729   0F83 FF FF FF FF 
0729   0F87 FF FF FF FF 
0729   0F8B FF FF FF FF 
0729   0F8F FF FF FF FF 
0729   0F93 FF FF FF FF 
0729   0F97 FF FF FF FF 
0729   0F9B FF FF FF FF 
0729   0F9F FF FF FF FF 
0729   0FA3 FF FF FF FF 
0729   0FA7 FF FF FF FF 
0729   0FAB FF FF FF FF 
0729   0FAF FF FF FF FF 
0729   0FB3 FF FF FF FF 
0729   0FB7 FF FF FF FF 
0729   0FBB FF FF FF FF 
0729   0FBF FF FF FF FF 
0729   0FC3 FF FF FF FF 
0729   0FC7 FF FF FF FF 
0729   0FCB FF FF FF FF 
0729   0FCF FF FF FF FF 
0729   0FD3 FF FF FF FF 
0729   0FD7 FF FF FF FF 
0729   0FDB FF FF FF FF 
0729   0FDF FF FF FF FF 
0729   0FE3 FF FF FF FF 
0729   0FE7 FF FF FF FF 
0729   0FEB FF FF FF FF 
0729   0FEF FF FF FF FF 
0729   0FF3 FF FF FF FF 
0729   0FF7 FF FF FF FF 
0729   0FFB FF FF FF FF 
0729   0FFF FF FF FF FF 
0729   1003 FF FF FF FF 
0729   1007 FF FF FF FF 
0729   100B FF FF FF FF 
0729   100F FF FF FF FF 
0729   1013 FF FF FF FF 
0729   1017 FF FF FF FF 
0729   101B FF FF FF FF 
0729   101F FF FF FF FF 
0729   1023 FF FF FF FF 
0729   1027 FF FF FF FF 
0729   102B FF FF FF FF 
0729   102F FF FF FF FF 
0729   1033 FF FF FF FF 
0729   1037 FF FF FF FF 
0729   103B FF FF FF FF 
0729   103F FF FF FF FF 
0729   1043 FF FF FF FF 
0729   1047 FF FF FF FF 
0729   104B FF FF FF FF 
0729   104F FF FF FF FF 
0729   1053 FF FF FF FF 
0729   1057 FF FF FF FF 
0730   105B             transient_area:
0731   105B 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
0732   105C             
0733   105C             .end
tasm: Number of errors = 0
