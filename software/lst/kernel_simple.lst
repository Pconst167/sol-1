0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; Solarium - Sol-1 Homebrew Minicomputer Operating System Kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; Memory Map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7FFF - ROM SPACE
0008   0000             ; 8000 ... F7FF - RAM SPACE
0009   0000             ; F7FF          - Stack root
0010   0000             
0011   0000             ; I/O MAP
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; FF80 - UART 0 (16550)
0014   0000             ; FF90 - UART 1 (16550)
0015   0000             ; FFA0 - RTC    (M48T02)
0016   0000             ; FFB0 - PIO 0  (8255)
0017   0000             ; FFC0 - FDD    (5.25" Floppy Drive Block)
0018   0000             ;   - FFC0      Output Port (377 Flip-Flop)                  
0019   0000             ;   - FFC1      Input Port  (244 Buffer)                     
0020   0000             ;   - FFC8      WD1770 Status/Command    
0021   0000             ;   - FFC9      WD1770 Track Register
0022   0000             ;   - FFCA      WD1770 Sector Register
0023   0000             ;   - FFCB      WD1770 Data Register
0024   0000             ;      
0025   0000             ; FFD0 - IDE    (Compact Flash / PATA)
0026   0000             ; FFE0 - Timer  (8253)
0027   0000             ; FFF0 - BIOS CONFIGURATION NV-RAM STORE AREA
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; System Constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _UART0_DATA       .equ $FF80            ; data
0034   0000             _UART0_DLAB_0     .equ $FF80            ; divisor latch low byte
0035   0000             _UART0_DLAB_1     .equ $FF81            ; divisor latch high byte
0036   0000             _UART0_IER        .equ $FF81            ; Interrupt enable register
0037   0000             _UART0_FCR        .equ $FF82            ; FIFO control register
0038   0000             _UART0_LCR        .equ $FF83            ; line control register
0039   0000             _UART0_LSR        .equ $FF85            ; line status register
0040   0000             
0041   0000             _UART1_DATA       .equ $FF90            ; data
0042   0000             _UART1_DLAB_0     .equ $FF90            ; divisor latch low byte
0043   0000             _UART1_DLAB_1     .equ $FF91            ; divisor latch high byte
0044   0000             _UART1_IER        .equ $FF91            ; Interrupt enable register
0045   0000             _UART1_FCR        .equ $FF92            ; FIFO control register
0046   0000             _UART1_LCR        .equ $FF93            ; line control register
0047   0000             _UART1_LSR        .equ $FF95            ; line status register
0048   0000             
0049   0000             _ide_BASE         .equ $FFD0            ; ide base
0050   0000             _ide_R0           .equ _ide_BASE + 0    ; data port
0051   0000             _ide_R1           .equ _ide_BASE + 1    ; read: error code, write: feature
0052   0000             _ide_R2           .equ _ide_BASE + 2    ; number of sectors to transfer
0053   0000             _ide_R3           .equ _ide_BASE + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_R4           .equ _ide_BASE + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_R5           .equ _ide_BASE + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_R6           .equ _ide_BASE + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_R7           .equ _ide_BASE + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7SEG_DISPLAY     .equ $FFB0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _BIOS_POST_CTRL   .equ $FFB3            ; bios post display control register, 80h = as output
0061   0000             _PIO_A            .equ $FFB0    
0062   0000             _PIO_B            .equ $FFB1
0063   0000             _PIO_C            .equ $FFB2
0064   0000             _PIO_CONTROL      .equ $FFB3            ; pio control port
0065   0000             
0066   0000             _FDC_CONFIG       .equ $FFC0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _FDC_STATUS_1     .equ $FFC1            ; 0 = drq, 1 = ready
0068   0000             _FDC_WD_STAT_CMD  .equ $FFC8            ; status / command register
0069   0000             _FDC_WD_TRACK     .equ $FFC9            ; track register
0070   0000             _FDC_WD_SECTOR    .equ $FFCA            ; sector register
0071   0000             _FDC_WD_DATA      .equ $FFCB            ; data register
0072   0000             
0073   0000             _TIMER_C_0        .equ $FFE0            ; timer counter 0
0074   0000             _TIMER_C_1        .equ $FFE1            ; timer counter 1
0075   0000             _TIMER_C_2        .equ $FFE2            ; timer counter 2
0076   0000             _TIMER_CTRL       .equ $FFE3            ; timer control register
0077   0000             
0078   0000             STACK_BEGIN       .equ $F7FF            ; beginning of stack
0079   0000             FIFO_SIZE         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; GLOBAL SYSTEM VARIABLES
0086   0000             ; ------------------------------------------------------------------------------------------------------------------;
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; IRQ table
0090   0000             ; highest priority at lowest address
0091   0000             ; ------------------------------------------------------------------------------------------------------------------;
0092   0000 2A 00       .dw int_0_fdc
0093   0002 2B 00       .dw int_1
0094   0004 2C 00       .dw int_2
0095   0006 2D 00       .dw int_3
0096   0008 2E 00       .dw int_4
0097   000A 2F 00       .dw int_5
0098   000C 30 00       .dw int_6
0099   000E 31 00       .dw int_7_uart0
0100   0010             
0101   0010             ; ------------------------------------------------------------------------------------------------------------------;
0102   0010             ; kernel reset vector
0103   0010             ; ------------------------------------------------------------------------------------------------------------------;
0104   0010 6A 02       .dw kernel_reset_vector
0105   0012             
0106   0012             ; ------------------------------------------------------------------------------------------------------------------;
0107   0012             ; exception vector table
0108   0012             ; total of 7 entries, starting at address $0012
0109   0012             ; ------------------------------------------------------------------------------------------------------------------;
0110   0012 D9 01       .dw trap_privilege
0111   0014 E5 01       .dw trap_div_zero
0112   0016 F2 01       .dw trap_undef_opcode
0113   0018 00 00       .dw 0
0114   001A 00 00       .dw 0
0115   001C 00 00       .dw 0
0116   001E 00 00       .dw 0
0117   0020             
0118   0020             ; ------------------------------------------------------------------------------------------------------------------;
0119   0020             ; system call vector table
0120   0020             ; starts at address $0020
0121   0020             ; ------------------------------------------------------------------------------------------------------------------;
0122   0020 F9 01       .dw syscall_io
0123   0022 CD 01       .dw syscall_reboot
0124   0024 D8 00       .dw syscall_fdc_format
0125   0026 50 00       .dw syscall_fdc_read
0126   0028 9A 00       .dw syscall_fdc_read_sec
0127   002A             
0128   002A             ; ------------------------------------------------------------------------------------------------------------------;
0129   002A             ; system call aliases
0130   002A             ; ------------------------------------------------------------------------------------------------------------------;
0131   002A             sys_io               .equ 0
0132   002A             sys_reboot           .equ 1
0133   002A             sys_fdc_format       .equ 2
0134   002A             sys_fdc_read         .equ 3
0135   002A             sys_fdc_read_sec     .equ 4
0136   002A             
0137   002A             ; ------------------------------------------------------------------------------------------------------------------;
0138   002A             ; IRQs' code block
0139   002A             ; ------------------------------------------------------------------------------------------------------------------;
0140   002A             ; 5.25" Floppy Drive Controller IRQ
0141   002A             int_0_fdc:
0142   002A 06            sysret
0143   002B             int_1:
0144   002B 06            sysret
0145   002C             int_2:
0146   002C 06            sysret
0147   002D             int_3:
0148   002D 06            sysret
0149   002E             int_4:
0150   002E 06            sysret
0151   002F             int_5:
0152   002F 06            sysret
0153   0030             
0154   0030             ; ------------------------------------------------------------------------------------------------------------------;
0155   0030             ; process swapping
0156   0030             ; ------------------------------------------------------------------------------------------------------------------;
0157   0030             int_6:  
0158   0030 06            sysret
0159   0031             
0160   0031             ; ------------------------------------------------------------------------------------------------------------------;
0161   0031             ; UART0 Interrupt
0162   0031             ; ------------------------------------------------------------------------------------------------------------------;
0163   0031             int_7_uart0:
0164   0031 D7            push a
0165   0032 DA            push d
0166   0033 E1            pushf
0167   0034 14 F0 08      mov a, [fifo_in]
0168   0037 3C            mov d, a
0169   0038 1D 80 FF      mov al, [_UART0_DATA]       ; get character
0170   003B 3E            mov [d], al                 ; add to fifo
0171   003C 14 F0 08      mov a, [fifo_in]
0172   003F 77            inc a
0173   0040 AF 86 0F      cmp a, fifo + FIFO_SIZE     ; check if pointer reached the end of the fifo
0174   0043 C7 49 00      jne int_7_continue
0175   0046 10 86 0B      mov a, fifo  
0176   0049             int_7_continue:  
0177   0049 42 F0 08      mov [fifo_in], a            ; update fifo pointer
0178   004C EE            popf
0179   004D E7            pop d
0180   004E E4            pop a  
0181   004F 06            sysret
0182   0050             
0183   0050             
0184   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0185   0050             ; floppy drive system calls
0186   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0187   0050             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0188   0050             ; fdc_40_FF:
0189   0050             ;   .fill 40,  $FF    ; or 00                                                                                
0190   0050             ; fdc_128_format_inner:
0191   0050             ;   .fill 6,   $00    ;                                                                            <--|        
0192   0050             ;   .fill 1,   $FE    ; ID Address Mark                                                               |        
0193   0050             ;   .fill 1,   $00    ; Track Number  0 thru 39                                                       |                    
0194   0050             ;   .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0195   0050             ;   .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0196   0050             ;   .fill 1,   $00    ; Sector Length                                                                 |                        
0197   0050             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0198   0050             ;   .fill 11,  $FF    ; or 00                                                                         |                      
0199   0050             ;   .fill 6,   $00    ;                                                                               |                        
0200   0050             ;   .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0201   0050             ;   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0202   0050             ;   .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0203   0050             ;   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0204   0050             ; fdc_128_format_end:
0205   0050             ;   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0206   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0207   0050             ; _FDC_CONFIG       .equ $FFC0 
0208   0050             ; _FDC_STATUS_1     .equ $FFC1
0209   0050             ; _FDC_WD_STAT_CMD  .equ $FFC8
0210   0050             ; _FDC_WD_TRACK     .equ $FFC9
0211   0050             ; _FDC_WD_SECTOR    .equ $FFCA
0212   0050             ; _FDC_WD_DATA      .equ $FFCB
0213   0050             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0214   0050             
0215   0050             syscall_fdc_read:
0216   0050 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0217   0053 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0218   0056 19 E8         mov al, %11101000         
0219   0058 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0220   005B 07 8B 01      call fdc_wait_64us
0221   005E             
0222   005E             ;fdc_wait_busy_high1:
0223   005E             ;  mov al, [_FDC_WD_STAT_CMD]      ; 
0224   005E             ;  test al, $01                ; 
0225   005E             ;  jz fdc_wait_busy_high1
0226   005E             
0227   005E FD 4F 86 11   mov di, transient_area
0228   0062             fdc_read_loop: ; for each byte, we need to wait for DRQ to be high
0229   0062 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; 
0230   0065 93 01         test al, $01                ; check busy bit
0231   0067 C6 76 00      jz fdc_read_end
0232   006A 93 02         test al, $02                ; check drq bit
0233   006C C6 62 00      jz fdc_read_loop
0234   006F 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0235   0072 F7            stosb
0236   0073 0A 62 00      jmp fdc_read_loop
0237   0076             
0238   0076             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0239   0076             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0240   0076             ;because for every write, if it also reads, then that clears DRQ, so we need to wait for next DRQ.
0241   0076             fdc_read_end:
0242   0076 50            mov a, di
0243   0077 5F 86 11      sub a, transient_area
0244   007A 3B 8D 00      mov d, sss
0245   007D 07 EF 06      call _puts
0246   0080 07 18 07      call print_u16d
0247   0083 07 9C 06      call printnl
0248   0086 26 12 0C      mov b, 3090
0249   0089 07 9D 03      call cmd_hexd
0250   008C 06            sysret
0251   008D 0A 74 72 61 sss:.db "\ntrack read\n", 0
0251   0091 63 6B 20 72 
0251   0095 65 61 64 0A 
0251   0099 00 
0252   009A             
0253   009A             
0254   009A             ; sector in al
0255   009A             ; track in ah
0256   009A             syscall_fdc_read_sec:
0257   009A 3D CA FF      mov [_FDC_WD_SECTOR], al
0258   009D 1A            mov al, ah
0259   009E 3D C9 FF      mov [_FDC_WD_TRACK], al
0260   00A1 19 88         mov al, %10001000         
0261   00A3 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0262   00A6 07 8B 01      call fdc_wait_64us
0263   00A9             
0264   00A9             ;fdc_wait_busy_high2:
0265   00A9             ;  mov al, [_FDC_WD_STAT_CMD]      ; 
0266   00A9             ;  test al, $01                ; 
0267   00A9             ;  jz fdc_wait_busy_high2
0268   00A9             
0269   00A9 FD 4F 86 11   mov di, transient_area
0270   00AD             fdc_read_loop2: ; for each byte, we need to wait for DRQ to be high
0271   00AD 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read lost data flag 10+3+5+8+5+8
0272   00B0 93 01         test al, $01                ; check drq bit
0273   00B2 C6 C1 00      jz fdc_read_end2
0274   00B5 93 02         test al, $02                ; check drq bit
0275   00B7 C6 AD 00      jz fdc_read_loop2
0276   00BA 1D CB FF      mov al, [_FDC_WD_DATA]     ; 
0277   00BD F7            stosb
0278   00BE 0A AD 00      jmp fdc_read_loop2
0279   00C1             fdc_read_end2:
0280   00C1 50            mov a, di
0281   00C2 5F 86 11      sub a, transient_area
0282   00C5 3B 8D 00      mov d, sss
0283   00C8 07 EF 06      call _puts
0284   00CB 07 18 07      call print_u16d
0285   00CE 07 9C 06      call printnl
0286   00D1 26 80 00      mov b, 128
0287   00D4 07 9D 03      call cmd_hexd
0288   00D7 06            sysret
0289   00D8             
0290   00D8             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0291   00D8             ; in the RAM formatting block because they are all set as 00 right now
0292   00D8             ; bl: track number
0293   00D8             syscall_fdc_format:
0294   00D8 FD 3D C9 FF   mov [_FDC_WD_TRACK], bl
0295   00DC 3B 93 01      mov d, s_format_begin
0296   00DF 07 EF 06      call _puts
0297   00E2 1D CB FF      mov al, [_FDC_WD_DATA]      ; read data register to clear any errors
0298   00E5 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]      ; read status register to clear any errors
0299   00E8             fdc_header_loop_start:
0300   00E8 19 FA         mov al, %11111010               ; Write Track Command: {1111, 0: Enable Spin-up Seq, 1: Settling Delay, 1: No Write Precompensation, 0}
0301   00EA 3D C8 FF      mov [_FDC_WD_STAT_CMD], al
0302   00ED             ; write the first data block for formatting which is 40 bytes of 0xFF:
0303   00ED 07 8B 01      call fdc_wait_64us
0304   00F0             
0305   00F0             
0306   00F0             ;fdc_wait_busy_high:
0307   00F0             ;  mov al, [_FDC_WD_STAT_CMD]      ; 
0308   00F0             ;  test al, $01                ; 
0309   00F0             ;  jz fdc_wait_busy_high
0310   00F0             
0311   00F0 FD 4D 86 11   mov si, transient_area
0312   00F4             fdc_format_drq:
0313   00F4 1D C8 FF      mov al, [_FDC_WD_STAT_CMD]  ; 10
0314   00F7 93 01         test al, $01                ; 4
0315   00F9 C6 08 01      jz fdc_format_end           ; 8
0316   00FC 93 02         test al, $02                ; 4
0317   00FE C6 F4 00      jz fdc_format_drq           ; 8
0318   0101 F6            lodsb                       ; 7
0319   0102 3D CB FF      mov [_FDC_WD_DATA], al      ; 10   
0320   0105 0A F4 00      jmp fdc_format_drq
0321   0108             fdc_format_end:
0322   0108 3B 0F 01      mov d, sss1
0323   010B 07 EF 06      call _puts
0324   010E 06            sysret
0325   010F             
0326   010F 0A 66 6F 72 sss1:.db "\nformat done\n", 0
0326   0113 6D 61 74 20 
0326   0117 64 6F 6E 65 
0326   011B 0A 00 
0327   011D             
0328   011D             
0329   011D             
0330   011D             
0331   011D             
0332   011D             
0333   011D             fdc_format_mem:
0334   011D 3B 01 00      mov d, 1
0335   0120 FD 4F 86 11   mov di, transient_area
0336   0124 38 28 00      mov c, 40
0337   0127 19 FF         mov al, $FF
0338   0129             fdc_l0: 
0339   0129 F7            stosb
0340   012A 7E            dec c
0341   012B C7 29 01      jnz fdc_l0
0342   012E             
0343   012E             fdc_inner_loop:
0344   012E 38 06 00      mov c, 6
0345   0131 19 00         mov al, $00
0346   0133             fdc_l1:
0347   0133 F7            stosb
0348   0134 7E            dec c
0349   0135 C7 33 01      jnz fdc_l1
0350   0138             
0351   0138             ; address mark
0352   0138             fdc_l2:
0353   0138 19 FE         mov al, $FE
0354   013A F7            stosb
0355   013B             
0356   013B             ; track number
0357   013B             fdc_l3:
0358   013B 19 00         mov al, $00
0359   013D F7            stosb
0360   013E             
0361   013E             ; side number
0362   013E             fdc_l4:
0363   013E 19 00         mov al, $00
0364   0140 F7            stosb
0365   0141             
0366   0141             ; sector number
0367   0141             fdc_l5:
0368   0141 13            mov a, d
0369   0142 F7            stosb
0370   0143             
0371   0143             ; sector length 128 bytes
0372   0143             fdc_l6:
0373   0143 19 00         mov al, $00
0374   0145 F7            stosb
0375   0146             
0376   0146             ; 2 crc's
0377   0146             fdc_l7:
0378   0146 19 F7         mov al, $F7
0379   0148 F7            stosb
0380   0149             
0381   0149             ; 11 times $FF
0382   0149 38 0B 00      mov c, 11
0383   014C 19 FF         mov al, $FF
0384   014E             fdc_l8:
0385   014E F7            stosb
0386   014F 7E            dec c
0387   0150 C7 4E 01      jnz fdc_l8
0388   0153             
0389   0153             ; 6 times 00
0390   0153 38 06 00      mov c, 6
0391   0156 19 00         mov al, $00
0392   0158             fdc_l9:
0393   0158 F7            stosb
0394   0159 7E            dec c
0395   015A C7 58 01      jnz fdc_l9
0396   015D             
0397   015D             ; data address mark
0398   015D 19 FB         mov al, $FB
0399   015F             fdc_l10:
0400   015F F7            stosb
0401   0160             
0402   0160             ; sector data
0403   0160 38 00 00      mov c, 0
0404   0163             fdc_l11:
0405   0163 84            mov al, cl
0406   0164 F7            stosb
0407   0165 78            inc c
0408   0166 C2 80 00      cmp c, 128
0409   0169 C7 63 01      jne fdc_l11
0410   016C             
0411   016C             ; 2 crc's
0412   016C             fdc_l12:
0413   016C 19 F7         mov al, $F7
0414   016E F7            stosb
0415   016F             
0416   016F             ; 10 times $FF
0417   016F 38 0A 00      mov c, 10
0418   0172 19 FF         mov al, $FF
0419   0174             fdc_l13:
0420   0174 F7            stosb
0421   0175 7E            dec c
0422   0176 C7 74 01      jnz fdc_l13
0423   0179             
0424   0179             ; check whether we did this 16 times
0425   0179 79            inc d
0426   017A C5 11 00      cmp d, 17
0427   017D C7 2E 01      jne fdc_inner_loop
0428   0180             
0429   0180             ; loop ~369 times
0430   0180 38 90 01      mov c, 400
0431   0183 19 FF         mov al, $FF
0432   0185             fdc_format_footer:
0433   0185             fdc_footer_drq_loop:
0434   0185 F7            stosb
0435   0186 7E            dec c
0436   0187 C7 85 01      jnz fdc_footer_drq_loop
0437   018A             
0438   018A 09            ret
0439   018B             
0440   018B             ; fetch is 2 cycles long when 'display_reg_load' is false.
0441   018B             ; 64us amounts to 160 cycles of the 2.5MHz clock
0442   018B             ; call u16 is 14 cycles long
0443   018B             ; 160 - 5 - 14 = 
0444   018B             fdc_wait_64us:
0445   018B 3A 01         mov cl, 1                       ; 5 cycles
0446   018D             fdc_wait_64_loop:
0447   018D 81            dec cl                           ; 3 cycles
0448   018E C7 8D 01      jnz fdc_wait_64_loop             ; 8 cycles
0449   0191 09            ret
0450   0192             
0451   0192 00          fdc_irq: .db 0
0452   0193 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0452   0197 6D 61 74 74 
0452   019B 69 6E 67 20 
0452   019F 73 74 61 72 
0452   01A3 74 69 6E 67 
0452   01A7 2E 2E 2E 0A 
0452   01AB 00 
0453   01AC 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0453   01B0 6D 61 74 74 
0453   01B4 69 6E 67 20 
0453   01B8 64 6F 6E 65 
0453   01BC 2E 0A 00 
0454   01BF 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0454   01C3 20 73 74 61 
0454   01C7 74 75 73 3A 
0454   01CB 20 00 
0455   01CD             
0456   01CD             ; REBOOT SYSTEM
0457   01CD             syscall_reboot:
0458   01CD FD D7 FF FF   push word $FFFF 
0459   01D1 FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0460   01D4 FD D7 C0 01   push word BIOS_RESET_VECTOR     ; and then push RESET VECTOR of the shell to the stack
0461   01D8 06            sysret
0462   01D9             
0463   01D9             ; ------------------------------------------------------------------------------------------------------------------;
0464   01D9             ; exceptions code block
0465   01D9             ; ------------------------------------------------------------------------------------------------------------------;
0466   01D9             ; privilege exception
0467   01D9             ; ------------------------------------------------------------------------------------------------------------------;
0468   01D9             trap_privilege:
0469   01D9 0A CD 01      jmp syscall_reboot
0470   01DC DA            push d
0471   01DD 3B 11 09      mov d, s_priviledge
0472   01E0 07 EF 06      call _puts
0473   01E3 E7            pop d
0474   01E4 06            sysret
0475   01E5             
0476   01E5             ; ------------------------------------------------------------------------------------------------------------------;
0477   01E5             ; divide by zero exception
0478   01E5             ; ------------------------------------------------------------------------------------------------------------------;
0479   01E5             trap_div_zero:
0480   01E5 D7            push a
0481   01E6 DA            push d
0482   01E7 E1            pushf
0483   01E8 3B 28 09      mov d, s_divzero
0484   01EB 07 EF 06      call _puts
0485   01EE EE            popf
0486   01EF E7            pop d
0487   01F0 E4            pop a
0488   01F1 06            sysret ; enable interrupts
0489   01F2             
0490   01F2             ; ------------------------------------------------------------------------------------------------------------------;
0491   01F2             ; undefined opcode exception
0492   01F2             ; ------------------------------------------------------------------------------------------------------------------;
0493   01F2             trap_undef_opcode:
0494   01F2 06            sysret
0495   01F3             
0496   01F3             
0497   01F3             
0498   01F3             ;----------------------------------------------------------------------------------------------------;
0499   01F3             ; IO Syscall
0500   01F3             ;----------------------------------------------------------------------------------------------------;
0501   01F3             ; Baud  Divisor
0502   01F3             ; 50    2304
0503   01F3             ; 110   1047
0504   01F3             ; 300    384
0505   01F3             ; 600    192
0506   01F3             ; 1200    96
0507   01F3             ; 9600    12
0508   01F3             ; 19200    6
0509   01F3             ; 38400    3
0510   01F3             syscall_io_jmp:
0511   01F3 26 02         .dw syscall_io_putchar
0512   01F5 33 02         .dw syscall_io_getch
0513   01F7 FD 01         .dw syscall_io_uart_setup
0514   01F9             syscall_io:
0515   01F9 FD 0A F3 01   jmp [syscall_io_jmp + al]
0516   01FD             ; bit7 is the Divisor Latch Access Bit (DLAB). It must be set high (logic 1) to access the Divisor Latches
0517   01FD             ; of the Baud Generator during a Read or Write operation. It must be set low (logic 0) to access the Receiver
0518   01FD             ; Buffer, the Transmitter Holding Register, or the Interrupt Enable Register.
0519   01FD             syscall_io_uart_setup:
0520   01FD 1D EB 08      mov al, [sys_uart0_lcr]
0521   0200 8B 80         or al, $80                ; set DLAB access bit
0522   0202 3D 83 FF      mov [_UART0_LCR], al      ; 8 data, 2 stop, no parity by default
0523   0205 1D EE 08      mov al, [sys_uart0_div0]
0524   0208 3D 80 FF      mov [_UART0_DLAB_0], al   ; divisor latch byte 0
0525   020B 1D EF 08      mov al, [sys_uart0_div1]
0526   020E 3D 81 FF      mov [_UART0_DLAB_1], al   ; divisor latch byte 1      
0527   0211             
0528   0211 1D EB 08      mov al, [sys_uart0_lcr]
0529   0214 87 7F         and al, $7F               ; clear DLAB access bit 
0530   0216 3D 83 FF      mov [_UART0_LCR], al
0531   0219 1D EC 08      mov al, [sys_uart0_inten]
0532   021C 3D 81 FF      mov [_UART0_IER], al      ; interrupts
0533   021F 1D ED 08      mov al, [sys_uart0_fifoen]
0534   0222 3D 82 FF      mov [_UART0_FCR], al      ; FIFO control
0535   0225 06            sysret
0536   0226             
0537   0226             ; char in ah
0538   0226             syscall_io_putchar:
0539   0226             syscall_io_putchar_L0:
0540   0226 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0541   0229 87 20         and al, $20
0542   022B C6 26 02      jz syscall_io_putchar_L0    
0543   022E 1A            mov al, ah
0544   022F 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0545   0232 06            sysret
0546   0233             
0547   0233             ; char in ah
0548   0233             ; al = sucess code
0549   0233             syscall_io_getch:
0550   0233 D8            push b
0551   0234 DA            push d
0552   0235 FD 0C         sti
0553   0237             syscall_io_getch_L0:  
0554   0237 14 F2 08      mov a, [fifo_out]
0555   023A 29 F0 08      mov b, [fifo_in]
0556   023D B0            cmp a, b
0557   023E C6 37 02      je syscall_io_getch_L0
0558   0241 3C            mov d, a
0559   0242 77            inc a
0560   0243 AF 86 0F      cmp a, fifo + FIFO_SIZE      ; check if pointer reached the end of the fifo
0561   0246 C7 4C 02      jne syscall_io_getch_cont
0562   0249 10 86 0B      mov a, fifo  
0563   024C             syscall_io_getch_cont:  
0564   024C 42 F2 08      mov [fifo_out], a             ; update fifo pointer
0565   024F 1E            mov al, [d]                   ; get char
0566   0250 23            mov ah, al
0567   0251 1D EA 08      mov al, [sys_echo_on]
0568   0254 B9 01         cmp al, 1
0569   0256 C7 65 02      jne syscall_io_getch_noecho 
0570   0259             ; here we just echo the char back to the console
0571   0259             syscall_io_getch_echo_L0:
0572   0259 1D 85 FF      mov al, [_UART0_LSR]         ; read Line Status Register
0573   025C 87 20         and al, $20                 ; isolate Transmitter Empty
0574   025E C6 59 02      jz syscall_io_getch_echo_L0
0575   0261 1A            mov al, ah
0576   0262 3D 80 FF      mov [_UART0_DATA], al        ; write char to Transmitter Holding Register
0577   0265             syscall_io_getch_noecho:
0578   0265 19 01         mov al, 1                    ; AL = 1 means a char successfully received
0579   0267 E7            pop d
0580   0268 E5            pop b
0581   0269 06            sysret
0582   026A             
0583   026A             
0584   026A             
0585   026A             
0586   026A             
0587   026A             
0588   026A             ; ---------------------------------------------------------------------
0589   026A             ; kernel reset vector
0590   026A             ; ---------------------------------------------------------------------
0591   026A             kernel_reset_vector:  
0592   026A FD 49 FF F7   mov bp, STACK_BEGIN
0593   026E FD 47 FF F7   mov sp, STACK_BEGIN
0594   0272               
0595   0272 19 80         mov al, %10000000             ; mask out timer interrupt
0596   0274 FD 0F         stomsk                        
0597   0276 FD 0C         sti  
0598   0278             
0599   0278 0C            lodstat
0600   0279 87 DF         and al, %11011111             ; disable display register loading
0601   027B 0D            stostat
0602   027C               
0603   027C             ; reset fifo pointers
0604   027C 10 86 0B      mov a, fifo
0605   027F 3B F0 08      mov d, fifo_in
0606   0282 43            mov [d], a
0607   0283 3B F2 08      mov d, fifo_out
0608   0286 43            mov [d], a  
0609   0287 19 02         mov al, 2
0610   0289 05 00         syscall sys_io                ; enable uart in interrupt mode
0611   028B               
0612   028B 3B F4 08      mov d, s_kernel_started
0613   028E 07 EF 06      call _puts
0614   0291             
0615   0291 3B B7 04      mov d, str0
0616   0294 07 EF 06      call _puts
0617   0297               ; First, select drive 1 and de-select drive 0
0618   0297 3B C0 FF      mov d, $FFC0
0619   029A 2E 0D         mov bl, %00001101     ; %00001001 : turn LED on, disable double density, select side 0, select drive 0, do not select drive 1
0620   029C FD 3E         mov [d], bl
0621   029E             
0622   029E             
0623   029E             menu:
0624   029E 3B 2A 04      mov d, s_menu
0625   02A1 07 EF 06      call _puts
0626   02A4 07 BC 05      call getch
0627   02A7 76 30         cmp ah, '0'
0628   02A9 C6 D7 02      je step_in
0629   02AC 76 31         cmp ah, '1'
0630   02AE C6 EF 02      je step_out
0631   02B1 76 32         cmp ah, '2'
0632   02B3 C6 E3 02      je restore
0633   02B6 76 33         cmp ah, '3'
0634   02B8 C6 FB 02      je status1
0635   02BB 76 34         cmp ah, '4'
0636   02BD C6 0D 03      je status2
0637   02C0 76 35         cmp ah, '5'
0638   02C2 C6 1F 03      je format
0639   02C5 76 36         cmp ah, '6'
0640   02C7 C6 39 03      je read
0641   02CA 76 37         cmp ah, '7'
0642   02CC C6 4C 03      je read_sec
0643   02CF 76 38         cmp ah, '8'
0644   02D1 C6 8E 03      je fdc_options
0645   02D4 0A 9E 02      jmp menu
0646   02D7             step_in:
0647   02D7 3B C8 FF      mov d, $FFC8    ; wd1770
0648   02DA 19 02         mov al, 2       ; setparam call
0649   02DC 2E 53         mov bl, %01010011     ; step in
0650   02DE FD 3E         mov [d], bl
0651   02E0 0A 9E 02      jmp menu
0652   02E3             restore:
0653   02E3             ; send restore command
0654   02E3 3B C8 FF      mov d, $FFC8    ; wd1770
0655   02E6 19 02         mov al, 2       ; setparam call
0656   02E8 2E 03         mov bl, $03     ; restore command, 30ms rate
0657   02EA FD 3E         mov [d], bl
0658   02EC 0A 9E 02      jmp menu
0659   02EF             step_out:
0660   02EF 3B C8 FF      mov d, $FFC8    ; wd1770
0661   02F2 19 02         mov al, 2       ; setparam call
0662   02F4 2E 73         mov bl, %01110011     ; step out
0663   02F6 FD 3E         mov [d], bl
0664   02F8 0A 9E 02      jmp menu
0665   02FB             status1:
0666   02FB 07 9C 06      call printnl
0667   02FE 3B C1 FF      mov d, $FFC1    ; wd1770 status 1
0668   0301 19 04         mov al, 4       ; getparam call
0669   0303 32            mov bl, [d]
0670   0304 07 8F 07      call print_u8x   ; print bl
0671   0307 07 9C 06      call printnl
0672   030A 0A 9E 02      jmp menu
0673   030D             status2:
0674   030D 07 9C 06      call printnl
0675   0310 3B C8 FF      mov d, $FFC8    ; wd1770 status 
0676   0313 19 04         mov al, 4       ; getparam call
0677   0315 32            mov bl, [d]
0678   0316 07 8F 07      call print_u8x   ; print bl
0679   0319 07 9C 06      call printnl
0680   031C 0A 9E 02      jmp menu
0681   031F             format:
0682   031F 07 1D 01      call fdc_format_mem ; fill ram with format
0683   0322 3B 21 04      mov d, s_track
0684   0325 07 EF 06      call _puts
0685   0328 07 DA 07      call scan_u8x   ; in al
0686   032B 2F            mov bl, al      ; track needs to be in bl
0687   032C 19 00         mov al, 0       ; 0 = format
0688   032E 05 02         syscall sys_fdc_format
0689   0330 3B AC 01      mov d, s_format_done
0690   0333 07 EF 06      call _puts
0691   0336 0A 9E 02      jmp menu
0692   0339             read:
0693   0339 FD 4F 86 11   mov di, transient_area
0694   033D 38 A0 0F      mov c, 4000
0695   0340 19 33         mov al, $33
0696   0342             read_l0:
0697   0342 F7            stosb
0698   0343 7E            dec c
0699   0344 C7 42 03      jnz read_l0
0700   0347 05 03         syscall sys_fdc_read
0701   0349 0A 9E 02      jmp menu
0702   034C             read_sec:
0703   034C FD 4F 86 11   mov di, transient_area
0704   0350 38 80 00      mov c, 128
0705   0353 19 55         mov al, $55
0706   0355             read_l1:
0707   0355 F7            stosb
0708   0356 7E            dec c
0709   0357 C7 55 03      jnz read_l1
0710   035A 3B 72 03      mov d, s1
0711   035D 07 EF 06      call _puts
0712   0360 07 DA 07      call scan_u8x
0713   0363 23            mov ah, al
0714   0364 3B 7B 03      mov d, s2
0715   0367 07 EF 06      call _puts
0716   036A 07 DA 07      call scan_u8x ; in al
0717   036D               
0718   036D 05 04         syscall sys_fdc_read_sec
0719   036F 0A 9E 02      jmp menu
0720   0372 0A 74 72 61 s1:.db "\ntrack: ", 0
0720   0376 63 6B 3A 20 
0720   037A 00 
0721   037B 0A 73 65 63 s2:.db "\nsector: ", 0
0721   037F 74 6F 72 3A 
0721   0383 20 00 
0722   0385 0A 76 61 6C ss3:.db "\nvalue: ", 0
0722   0389 75 65 3A 20 
0722   038D 00 
0723   038E             
0724   038E             fdc_options:
0725   038E 3B 85 03      mov d, ss3
0726   0391 07 EF 06      call _puts
0727   0394 07 DA 07      call scan_u8x
0728   0397 3D C0 FF      mov [_FDC_CONFIG], al
0729   039A 0A 9E 02      jmp menu
0730   039D             
0731   039D             ; b : len
0732   039D             cmd_hexd:
0733   039D 10 86 11      mov a, transient_area
0734   03A0 42 1D 04      mov [start], a
0735   03A3 11            mov a, b
0736   03A4 42 1F 04      mov [length], a
0737   03A7             
0738   03A7 14 1D 04    	mov a, [start]
0739   03AA 3C            mov d, a        ; dump pointer in d
0740   03AB 38 00 00      mov c, 0
0741   03AE             dump_loop:
0742   03AE 84            mov al, cl
0743   03AF 87 0F         and al, $0F
0744   03B1 C6 00 04      jz print_base
0745   03B4             back:
0746   03B4 1E            mov al, [d]        ; read byte
0747   03B5 2F            mov bl, al
0748   03B6 07 8F 07      call print_u8x
0749   03B9 10 00 20      mov a, $2000
0750   03BC 05 00         syscall sys_io      ; space
0751   03BE 84            mov al, cl
0752   03BF 87 0F         and al, $0F
0753   03C1 B9 0F         cmp al, $0F
0754   03C3 C6 DA 03      je print_ascii
0755   03C6             back1:
0756   03C6 79            inc d
0757   03C7 78            inc c
0758   03C8 14 1F 04      mov a, [length]
0759   03CB B1            cmp a, c
0760   03CC C7 AE 03      jne dump_loop
0761   03CF               
0762   03CF 10 00 0A      mov a, $0A00
0763   03D2 05 00         syscall sys_io
0764   03D4 10 00 0D      mov a, $0D00
0765   03D7 05 00         syscall sys_io
0766   03D9               ;call printnl
0767   03D9             
0768   03D9 09            ret
0769   03DA             print_ascii:
0770   03DA 63 10 00      sub d, 16
0771   03DD 26 10 00      mov b, 16
0772   03E0             print_ascii_L:
0773   03E0 79            inc d
0774   03E1 1E            mov al, [d]        ; read byte
0775   03E2 B9 20         cmp al, $20
0776   03E4 C8 EC 03      jlu dot
0777   03E7 B9 7E         cmp al, $7E
0778   03E9 D0 F4 03      jleu ascii
0779   03EC             dot:
0780   03EC 10 00 2E      mov a, $2E00
0781   03EF 05 00         syscall sys_io
0782   03F1 0A F9 03      jmp ascii_continue
0783   03F4             ascii:
0784   03F4 23            mov ah, al
0785   03F5 19 00         mov al, 0
0786   03F7 05 00         syscall sys_io
0787   03F9             ascii_continue:
0788   03F9 FD A9 E0 03   loopb print_ascii_L
0789   03FD 0A C6 03      jmp back1
0790   0400             print_base:
0791   0400 10 00 0A      mov a, $0A00
0792   0403 05 00         syscall sys_io
0793   0405 10 00 0D      mov a, $0D00
0794   0408 05 00         syscall sys_io
0795   040A 2D            mov b, d
0796   040B 61 86 11      sub b, transient_area
0797   040E 07 4B 07      call print_u16x        ; display row
0798   0411 55 86 11      add b, transient_area
0799   0414 10 00 20      mov a, $2000
0800   0417 05 00         syscall sys_io
0801   0419 0A B4 03      jmp back
0802   041C             
0803   041C 09            ret
0804   041D             
0805   041D 00 00       start:  .dw 0
0806   041F 00 04       length: .dw 1024
0807   0421             
0808   0421             
0809   0421 0A 74 72 61 s_track: .db "\ntrack: ", 0
0809   0425 63 6B 3A 20 
0809   0429 00 
0810   042A             
0811   042A 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0811   042E 73 74 65 70 
0811   0432 20 69 6E 0A 
0812   0436 31 2E 20 73         .db "1. step out\n", 
0812   043A 74 65 70 20 
0812   043E 6F 75 74 0A 
0813   0442 32 2E 20 72         .db "2. restore\n", 
0813   0446 65 73 74 6F 
0813   044A 72 65 0A 
0814   044D 33 2E 20 72         .db "3. read status 1\n", 
0814   0451 65 61 64 20 
0814   0455 73 74 61 74 
0814   0459 75 73 20 31 
0814   045D 0A 
0815   045E 34 2E 20 72         .db "4. read status 2\n", 
0815   0462 65 61 64 20 
0815   0466 73 74 61 74 
0815   046A 75 73 20 32 
0815   046E 0A 
0816   046F 35 2E 20 66         .db "5. format track\n", 
0816   0473 6F 72 6D 61 
0816   0477 74 20 74 72 
0816   047B 61 63 6B 0A 
0817   047F 36 2E 20 72         .db "6. read track\n", 
0817   0483 65 61 64 20 
0817   0487 74 72 61 63 
0817   048B 6B 0A 
0818   048D 37 2E 20 72         .db "7. read sector\n", 
0818   0491 65 61 64 20 
0818   0495 73 65 63 74 
0818   0499 6F 72 0A 
0819   049C 38 2E 20 63         .db "8. config\n", 
0819   04A0 6F 6E 66 69 
0819   04A4 67 0A 
0820   04A6 0A 73 65 6C         .db "\nselect option: ", 0
0820   04AA 65 63 74 20 
0820   04AE 6F 70 74 69 
0820   04B2 6F 6E 3A 20 
0820   04B6 00 
0821   04B7             
0822   04B7 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0822   04BB 65 63 74 69 
0822   04BF 6E 67 20 64 
0822   04C3 72 69 76 65 
0822   04C7 20 31 2E 2E 
0822   04CB 2E 0A 00 
0823   04CE 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0823   04D2 74 69 6E 67 
0823   04D6 2E 2E 2E 0A 
0823   04DA 00 
0824   04DB             
0825   04DB             
0826   04DB             
0827   04DB             ; FILE INCLUDES
0828   04DB             .include "bios.exp"         ; to obtain the BIOS_RESET_VECTOR location (for reboots)
0001+  04DB             BIOS_RESET_VECTOR .EQU  $01c0
0002+  04DB             IDE_buffer       .EQU  $8204
0003+  04DB             boot_origin      .EQU  $8004
0004+  04DB             bios_uart        .EQU  $0002
0005+  04DB             bios_ide         .EQU  $0003
0829   04DB             .include "lib/stdio.asm"
0001+  04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  04DB             ; stdio.s
0003+  04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  04DB             .include "lib/string.asm"
0001++ 04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 04DB             ; string.s
0003++ 04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 04DB             
0005++ 04DB             
0006++ 04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 04DB             ; _strrev
0008++ 04DB             ; reverse a string
0009++ 04DB             ; D = string address
0010++ 04DB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 04DB             ; 01234
0012++ 04DB             _strrev:
0013++ 04DB 4B          	pusha
0014++ 04DC 07 22 05    	call _strlen	; length in C
0015++ 04DF 12          	mov a, c
0016++ 04E0 AF 01 00    	cmp a, 1
0017++ 04E3 D0 FD 04    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 04E6 7D          	dec a
0019++ 04E7 FD 4E       	mov si, d	; beginning of string
0020++ 04E9 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 04EB 59          	add d, a	; end of string
0022++ 04EC 12          	mov a, c
0023++ 04ED FD 9B       	shr a		; divide by 2
0024++ 04EF 39          	mov c, a	; C now counts the steps
0025++ 04F0             _strrev_L0:
0026++ 04F0 32          	mov bl, [d]	; save load right-side char into BL
0027++ 04F1 F6          	lodsb		; load left-side char into AL; increase SI
0028++ 04F2 3E          	mov [d], al	; store left char into right side
0029++ 04F3 1B          	mov al, bl
0030++ 04F4 F7          	stosb		; store right-side char into left-side; increase DI
0031++ 04F5 7E          	dec c
0032++ 04F6 7F          	dec d
0033++ 04F7 C2 00 00    	cmp c, 0
0034++ 04FA C7 F0 04    	jne _strrev_L0
0035++ 04FD             _strrev_end:
0036++ 04FD 4C          	popa
0037++ 04FE 09          	ret
0038++ 04FF             	
0039++ 04FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 04FF             ; _strchr
0041++ 04FF             ; search string in D for char in AL
0042++ 04FF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 04FF             _strchr:
0044++ 04FF             _strchr_L0:
0045++ 04FF 32          	mov bl, [d]
0046++ 0500 C1 00       	cmp bl, 0
0047++ 0502 C6 0D 05    	je _strchr_end
0048++ 0505 BA          	cmp al, bl
0049++ 0506 C6 0D 05    	je _strchr_end
0050++ 0509 79          	inc d
0051++ 050A 0A FF 04    	jmp _strchr_L0
0052++ 050D             _strchr_end:
0053++ 050D 1B          	mov al, bl
0054++ 050E 09          	ret
0055++ 050F             
0056++ 050F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 050F             ; _strstr
0058++ 050F             ; find sub-string
0059++ 050F             ; str1 in SI
0060++ 050F             ; str2 in DI
0061++ 050F             ; SI points to end of source string
0062++ 050F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 050F             _strstr:
0064++ 050F DB          	push al
0065++ 0510 DA          	push d
0066++ 0511 E3          	push di
0067++ 0512             _strstr_loop:
0068++ 0512 F3          	cmpsb					; compare a byte of the strings
0069++ 0513 C7 1E 05    	jne _strstr_ret
0070++ 0516 FC 00 00    	lea d, [di + 0]
0071++ 0519 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 051B C7 12 05    	jne _strstr_loop				; equal chars but not at end
0073++ 051E             _strstr_ret:
0074++ 051E F0          	pop di
0075++ 051F E7          	pop d
0076++ 0520 E8          	pop al
0077++ 0521 09          	ret
0078++ 0522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 0522             ; length of null terminated string
0080++ 0522             ; result in C
0081++ 0522             ; pointer in D
0082++ 0522             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 0522             _strlen:
0084++ 0522 DA          	push d
0085++ 0523 38 00 00    	mov c, 0
0086++ 0526             _strlen_L1:
0087++ 0526 BD 00       	cmp byte [d], 0
0088++ 0528 C6 30 05    	je _strlen_ret
0089++ 052B 79          	inc d
0090++ 052C 78          	inc c
0091++ 052D 0A 26 05    	jmp _strlen_L1
0092++ 0530             _strlen_ret:
0093++ 0530 E7          	pop d
0094++ 0531 09          	ret
0095++ 0532             
0096++ 0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 0532             ; STRCMP
0098++ 0532             ; compare two strings
0099++ 0532             ; str1 in SI
0100++ 0532             ; str2 in DI
0101++ 0532             ; CREATE A STRING COMPAIRON INSTRUCION ?????
0102++ 0532             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 0532             _strcmp:
0104++ 0532 DB          	push al
0105++ 0533 DA          	push d
0106++ 0534 E3          	push di
0107++ 0535 E2          	push si
0108++ 0536             _strcmp_loop:
0109++ 0536 F3          	cmpsb					; compare a byte of the strings
0110++ 0537 C7 42 05    	jne _strcmp_ret
0111++ 053A FB FF FF    	lea d, [si +- 1]
0112++ 053D BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 053F C7 36 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 0542             _strcmp_ret:
0115++ 0542 EF          	pop si
0116++ 0543 F0          	pop di
0117++ 0544 E7          	pop d
0118++ 0545 E8          	pop al
0119++ 0546 09          	ret
0120++ 0547             
0121++ 0547             
0122++ 0547             ; STRCPY
0123++ 0547             ; copy null terminated string from SI to DI
0124++ 0547             ; source in SI
0125++ 0547             ; destination in DI
0126++ 0547             _strcpy:
0127++ 0547 E2          	push si
0128++ 0548 E3          	push di
0129++ 0549 DB          	push al
0130++ 054A             _strcpy_L1:
0131++ 054A F6          	lodsb
0132++ 054B F7          	stosb
0133++ 054C B9 00       	cmp al, 0
0134++ 054E C7 4A 05    	jne _strcpy_L1
0135++ 0551             _strcpy_end:
0136++ 0551 E8          	pop al
0137++ 0552 F0          	pop di
0138++ 0553 EF          	pop si
0139++ 0554 09          	ret
0140++ 0555             
0141++ 0555             ; STRCAT
0142++ 0555             ; concatenate a NULL terminated string into string at DI, from string at SI
0143++ 0555             ; source in SI
0144++ 0555             ; destination in DI
0145++ 0555             _strcat:
0146++ 0555 E2          	push si
0147++ 0556 E3          	push di
0148++ 0557 D7          	push a
0149++ 0558 DA          	push d
0150++ 0559 50          	mov a, di
0151++ 055A 3C          	mov d, a
0152++ 055B             _strcat_goto_end_L1:
0153++ 055B BD 00       	cmp byte[d], 0
0154++ 055D C6 64 05    	je _strcat_start
0155++ 0560 79          	inc d
0156++ 0561 0A 5B 05    	jmp _strcat_goto_end_L1
0157++ 0564             _strcat_start:
0158++ 0564 FD 50       	mov di, d
0159++ 0566             _strcat_L1:
0160++ 0566 F6          	lodsb
0161++ 0567 F7          	stosb
0162++ 0568 B9 00       	cmp al, 0
0163++ 056A C7 66 05    	jne _strcat_L1
0164++ 056D             _strcat_end:
0165++ 056D E7          	pop d
0166++ 056E E4          	pop a
0167++ 056F F0          	pop di
0168++ 0570 EF          	pop si
0169++ 0571 09          	ret
0170++ 0572             
0171++ 0572             
0005+  0572             
0006+  0572             
0007+  0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  0572             ; CONVERT ASCII 'O'..'F' TO INTEGER 0..15
0009+  0572             ; ASCII in BL
0010+  0572             ; result in AL
0011+  0572             ; ascii for F = 0100 0110
0012+  0572             ; ascii for 9 = 0011 1001
0013+  0572             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  0572             hex_ascii_encode:
0015+  0572 1B            mov al, bl
0016+  0573 93 40         test al, $40        ; test if letter or number
0017+  0575 C7 7B 05      jnz hex_letter
0018+  0578 87 0F         and al, $0F        ; get number
0019+  057A 09            ret
0020+  057B             hex_letter:
0021+  057B 87 0F         and al, $0F        ; get letter
0022+  057D 6A 09         add al, 9
0023+  057F 09            ret
0024+  0580             
0025+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0580             ; ATOI
0027+  0580             ; 2 letter hex string in B
0028+  0580             ; 8bit integer returned in AL
0029+  0580             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0580             _atoi:
0031+  0580 D8            push b
0032+  0581 07 72 05      call hex_ascii_encode      ; convert BL to 4bit code in AL
0033+  0584 30            mov bl, bh
0034+  0585 DB            push al          ; save a
0035+  0586 07 72 05      call hex_ascii_encode
0036+  0589 EA            pop bl  
0037+  058A FD 9E 04      shl al, 4
0038+  058D 8C            or al, bl
0039+  058E E5            pop b
0040+  058F 09            ret  
0041+  0590             
0042+  0590             
0043+  0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0590             ; scanf
0045+  0590             ; no need for explanations!
0046+  0590             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0590             scanf:
0048+  0590 09            ret
0049+  0591             
0050+  0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0591             ; ITOA
0052+  0591             ; 8bit value in BL
0053+  0591             ; 2 byte ASCII result in A
0054+  0591             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0591             _itoa:
0056+  0591 DA            push d
0057+  0592 D8            push b
0058+  0593 A7 00         mov bh, 0
0059+  0595 FD A4 04      shr bl, 4  
0060+  0598 74            mov d, b
0061+  0599 1F 2B 08      mov al, [d + s_hex_digits]
0062+  059C 23            mov ah, al
0063+  059D               
0064+  059D E5            pop b
0065+  059E D8            push b
0066+  059F A7 00         mov bh, 0
0067+  05A1 FD 87 0F      and bl, $0F
0068+  05A4 74            mov d, b
0069+  05A5 1F 2B 08      mov al, [d + s_hex_digits]
0070+  05A8 E5            pop b
0071+  05A9 E7            pop d
0072+  05AA 09            ret
0073+  05AB             
0074+  05AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  05AB             ; HEX STRING TO BINARY
0076+  05AB             ; di = destination address
0077+  05AB             ; si = source
0078+  05AB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  05AB             _hex_to_int:
0080+  05AB             _hex_to_int_L1:
0081+  05AB F6            lodsb          ; load from [SI] to AL
0082+  05AC B9 00         cmp al, 0        ; check if ASCII 0
0083+  05AE C6 BB 05      jz _hex_to_int_ret
0084+  05B1 36            mov bh, al
0085+  05B2 F6            lodsb
0086+  05B3 2F            mov bl, al
0087+  05B4 07 80 05      call _atoi        ; convert ASCII byte in B to int (to AL)
0088+  05B7 F7            stosb          ; store AL to [DI]
0089+  05B8 0A AB 05      jmp _hex_to_int_L1
0090+  05BB             _hex_to_int_ret:
0091+  05BB 09            ret    
0092+  05BC             
0093+  05BC             
0094+  05BC             
0095+  05BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  05BC             ; GETCHAR
0097+  05BC             ; char in ah
0098+  05BC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  05BC             getch:
0100+  05BC DB            push al
0101+  05BD             getch_retry:
0102+  05BD 19 01         mov al, 1
0103+  05BF 05 00         syscall sys_io      ; receive in AH
0104+  05C1 E8            pop al
0105+  05C2 09            ret
0106+  05C3             
0107+  05C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  05C3             ; PUTCHAR
0109+  05C3             ; char in ah
0110+  05C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  05C3             _putchar:
0112+  05C3 DB            push al
0113+  05C4 19 00         mov al, 0
0114+  05C6 05 00         syscall sys_io      ; char in AH
0115+  05C8 E8            pop al
0116+  05C9 09            ret
0117+  05CA             
0118+  05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  05CA             ;; INPUT A STRING
0120+  05CA             ;; terminates with null
0121+  05CA             ;; pointer in D
0122+  05CA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  05CA             _gets:
0124+  05CA D7            push a
0125+  05CB DA            push d
0126+  05CC             _gets_loop:
0127+  05CC 19 01         mov al, 1
0128+  05CE 05 00         syscall sys_io      ; receive in AH
0129+  05D0 76 1B         cmp ah, 27
0130+  05D2 C6 F3 05      je _gets_ansi_esc
0131+  05D5 76 0A         cmp ah, $0A        ; LF
0132+  05D7 C6 4F 06      je _gets_end
0133+  05DA 76 0D         cmp ah, $0D        ; CR
0134+  05DC C6 4F 06      je _gets_end
0135+  05DF 76 5C         cmp ah, $5C        ; '\\'
0136+  05E1 C6 15 06      je _gets_escape
0137+  05E4 76 08         cmp ah, $08      ; check for backspace
0138+  05E6 C6 EF 05      je _gets_backspace
0139+  05E9 1A            mov al, ah
0140+  05EA 3E            mov [d], al
0141+  05EB 79            inc d
0142+  05EC 0A CC 05      jmp _gets_loop
0143+  05EF             _gets_backspace:
0144+  05EF 7F            dec d
0145+  05F0 0A CC 05      jmp _gets_loop
0146+  05F3             _gets_ansi_esc:
0147+  05F3 19 01         mov al, 1
0148+  05F5 05 00         syscall sys_io        ; receive in AH without echo
0149+  05F7 76 5B         cmp ah, '['
0150+  05F9 C7 CC 05      jne _gets_loop
0151+  05FC 19 01         mov al, 1
0152+  05FE 05 00         syscall sys_io          ; receive in AH without echo
0153+  0600 76 44         cmp ah, 'D'
0154+  0602 C6 0D 06      je _gets_left_arrow
0155+  0605 76 43         cmp ah, 'C'
0156+  0607 C6 11 06      je _gets_right_arrow
0157+  060A 0A CC 05      jmp _gets_loop
0158+  060D             _gets_left_arrow:
0159+  060D 7F            dec d
0160+  060E 0A CC 05      jmp _gets_loop
0161+  0611             _gets_right_arrow:
0162+  0611 79            inc d
0163+  0612 0A CC 05      jmp _gets_loop
0164+  0615             _gets_escape:
0165+  0615 19 01         mov al, 1
0166+  0617 05 00         syscall sys_io      ; receive in AH
0167+  0619 76 6E         cmp ah, 'n'
0168+  061B C6 3A 06      je _gets_LF
0169+  061E 76 72         cmp ah, 'r'
0170+  0620 C6 41 06      je _gets_CR
0171+  0623 76 30         cmp ah, '0'
0172+  0625 C6 48 06      je _gets_NULL
0173+  0628 76 5C         cmp ah, $5C  ; '\'
0174+  062A C6 33 06      je _gets_slash
0175+  062D 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  062E 3E            mov [d], al
0177+  062F 79            inc d
0178+  0630 0A CC 05      jmp _gets_loop
0179+  0633             _gets_slash:
0180+  0633 19 5C         mov al, $5C
0181+  0635 3E            mov [d], al
0182+  0636 79            inc d
0183+  0637 0A CC 05      jmp _gets_loop
0184+  063A             _gets_LF:
0185+  063A 19 0A         mov al, $0A
0186+  063C 3E            mov [d], al
0187+  063D 79            inc d
0188+  063E 0A CC 05      jmp _gets_loop
0189+  0641             _gets_CR:
0190+  0641 19 0D         mov al, $0D
0191+  0643 3E            mov [d], al
0192+  0644 79            inc d
0193+  0645 0A CC 05      jmp _gets_loop
0194+  0648             _gets_NULL:
0195+  0648 19 00         mov al, $00
0196+  064A 3E            mov [d], al
0197+  064B 79            inc d
0198+  064C 0A CC 05      jmp _gets_loop
0199+  064F             _gets_end:
0200+  064F 19 00         mov al, 0
0201+  0651 3E            mov [d], al        ; terminate string
0202+  0652 E7            pop d
0203+  0653 E4            pop a
0204+  0654 09            ret
0205+  0655             
0206+  0655             
0207+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  0655             ;; INPUT TEXT
0209+  0655             ;; terminated with CTRL+D
0210+  0655             ;; pointer in D
0211+  0655             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  0655             _gettxt:
0213+  0655 D7            push a
0214+  0656 DA            push d
0215+  0657             _gettxt_loop:
0216+  0657 19 01         mov al, 1
0217+  0659 05 00         syscall sys_io      ; receive in AH
0218+  065B 76 04         cmp ah, 4      ; EOT
0219+  065D C6 96 06      je _gettxt_end
0220+  0660 76 08         cmp ah, $08      ; check for backspace
0221+  0662 C6 92 06      je _gettxt_backspace
0222+  0665 76 5C         cmp ah, $5C        ; '\'
0223+  0667 C6 70 06      je _gettxt_escape
0224+  066A 1A            mov al, ah
0225+  066B 3E            mov [d], al
0226+  066C 79            inc d
0227+  066D 0A 57 06      jmp _gettxt_loop
0228+  0670             _gettxt_escape:
0229+  0670 19 01         mov al, 1
0230+  0672 05 00         syscall sys_io      ; receive in AH
0231+  0674 76 6E         cmp ah, 'n'
0232+  0676 C6 84 06      je _gettxt_LF
0233+  0679 76 72         cmp ah, 'r'
0234+  067B C6 8B 06      je _gettxt_CR
0235+  067E 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  067F 3E            mov [d], al
0237+  0680 79            inc d
0238+  0681 0A 57 06      jmp _gettxt_loop
0239+  0684             _gettxt_LF:
0240+  0684 19 0A         mov al, $0A
0241+  0686 3E            mov [d], al
0242+  0687 79            inc d
0243+  0688 0A 57 06      jmp _gettxt_loop
0244+  068B             _gettxt_CR:
0245+  068B 19 0D         mov al, $0D
0246+  068D 3E            mov [d], al
0247+  068E 79            inc d
0248+  068F 0A 57 06      jmp _gettxt_loop
0249+  0692             _gettxt_backspace:
0250+  0692 7F            dec d
0251+  0693 0A 57 06      jmp _gettxt_loop
0252+  0696             _gettxt_end:
0253+  0696 19 00         mov al, 0
0254+  0698 3E            mov [d], al        ; terminate string
0255+  0699 E7            pop d
0256+  069A E4            pop a
0257+  069B 09            ret
0258+  069C             
0259+  069C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  069C             ; PRINT NEW LINE
0261+  069C             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  069C             printnl:
0263+  069C D7            push a
0264+  069D 10 00 0A      mov a, $0A00
0265+  06A0 05 00         syscall sys_io
0266+  06A2 10 00 0D      mov a, $0D00
0267+  06A5 05 00         syscall sys_io
0268+  06A7 E4            pop a
0269+  06A8 09            ret
0270+  06A9             
0271+  06A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  06A9             ; _strtoint
0273+  06A9             ; 4 digit hex string number in d
0274+  06A9             ; integer returned in A
0275+  06A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  06A9             _strtointx:
0277+  06A9 D8            push b
0278+  06AA 32            mov bl, [d]
0279+  06AB 37            mov bh, bl
0280+  06AC 33 01 00      mov bl, [d + 1]
0281+  06AF 07 80 05      call _atoi        ; convert to int in AL
0282+  06B2 23            mov ah, al        ; move to AH
0283+  06B3 33 02 00      mov bl, [d + 2]
0284+  06B6 37            mov bh, bl
0285+  06B7 33 03 00      mov bl, [d + 3]
0286+  06BA 07 80 05      call _atoi        ; convert to int in AL
0287+  06BD E5            pop b
0288+  06BE 09            ret
0289+  06BF             
0290+  06BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  06BF             ; _strtoint
0292+  06BF             ; 5 digit base10 string number in d
0293+  06BF             ; integer returned in A
0294+  06BF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  06BF             _strtoint:
0296+  06BF E2            push si
0297+  06C0 D8            push b
0298+  06C1 D9            push c
0299+  06C2 DA            push d
0300+  06C3 07 22 05      call _strlen      ; get string length in C
0301+  06C6 7E            dec c
0302+  06C7 FD 4E         mov si, d
0303+  06C9 12            mov a, c
0304+  06CA FD 99         shl a
0305+  06CC 3B 43 08      mov d, table_power
0306+  06CF 59            add d, a
0307+  06D0 38 00 00      mov c, 0
0308+  06D3             _strtoint_L0:
0309+  06D3 F6            lodsb      ; load ASCII to al
0310+  06D4 B9 00         cmp al, 0
0311+  06D6 C6 E9 06      je _strtoint_end
0312+  06D9 6F 30         sub al, $30    ; make into integer
0313+  06DB 22 00         mov ah, 0
0314+  06DD 2A            mov b, [d]
0315+  06DE AC            mul a, b      ; result in B since it fits in 16bits
0316+  06DF 11            mov a, b
0317+  06E0 28            mov b, c
0318+  06E1 54            add a, b
0319+  06E2 39            mov c, a
0320+  06E3 63 02 00      sub d, 2
0321+  06E6 0A D3 06      jmp _strtoint_L0
0322+  06E9             _strtoint_end:
0323+  06E9 12            mov a, c
0324+  06EA E7            pop d
0325+  06EB E6            pop c
0326+  06EC E5            pop b
0327+  06ED EF            pop si
0328+  06EE 09            ret
0329+  06EF             
0330+  06EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  06EF             ; PRINT NULL TERMINATED STRING
0332+  06EF             ; pointer in D
0333+  06EF             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  06EF             _puts:
0335+  06EF D7            push a
0336+  06F0 DA            push d
0337+  06F1             _puts_L1:
0338+  06F1 1E            mov al, [d]
0339+  06F2 B9 00         cmp al, 0
0340+  06F4 C6 00 07      jz _puts_END
0341+  06F7 23            mov ah, al
0342+  06F8 19 00         mov al, 0
0343+  06FA 05 00         syscall sys_io
0344+  06FC 79            inc d
0345+  06FD 0A F1 06      jmp _puts_L1
0346+  0700             _puts_END:
0347+  0700 E7            pop d
0348+  0701 E4            pop a
0349+  0702 09            ret
0350+  0703             
0351+  0703             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  0703             ; PRINT N SIZE STRING
0353+  0703             ; pointer in D
0354+  0703             ; size in C
0355+  0703             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  0703             _putsn:
0357+  0703 DB            push al
0358+  0704 DA            push d
0359+  0705 D9            push c
0360+  0706             _putsn_L0:
0361+  0706 1E            mov al, [d]
0362+  0707 23            mov ah, al
0363+  0708 19 00         mov al, 0
0364+  070A 05 00         syscall sys_io
0365+  070C 79            inc d
0366+  070D 7E            dec c  
0367+  070E C2 00 00      cmp c, 0
0368+  0711 C7 06 07      jne _putsn_L0
0369+  0714             _putsn_end:
0370+  0714 E6            pop c
0371+  0715 E7            pop d
0372+  0716 E8            pop al
0373+  0717 09            ret
0374+  0718             
0375+  0718             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  0718             ; print 16bit decimal number
0377+  0718             ; input number in A
0378+  0718             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  0718             print_u16d:
0380+  0718 D7            push a
0381+  0719 D8            push b
0382+  071A FD D8         push g
0383+  071C 26 10 27      mov b, 10000
0384+  071F AE            div a, b      ; get 10000's coeff.
0385+  0720 07 44 07      call print_number
0386+  0723 11            mov a, b
0387+  0724 26 E8 03      mov b, 1000
0388+  0727 AE            div a, b      ; get 1000's coeff.
0389+  0728 07 44 07      call print_number
0390+  072B 11            mov a, b
0391+  072C 26 64 00      mov b, 100
0392+  072F AE            div a, b
0393+  0730 07 44 07      call print_number
0394+  0733 11            mov a, b
0395+  0734 26 0A 00      mov b, 10
0396+  0737 AE            div a, b
0397+  0738 07 44 07      call print_number
0398+  073B 1B            mov al, bl      ; 1's coeff in bl
0399+  073C 07 44 07      call print_number
0400+  073F FD F1         pop g
0401+  0741 E5            pop b
0402+  0742 E4            pop a
0403+  0743 09            ret
0404+  0744             
0405+  0744             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  0744             ; print AL
0407+  0744             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  0744             print_number:
0409+  0744 6A 30         add al, $30
0410+  0746 23            mov ah, al
0411+  0747 07 C3 05      call _putchar
0412+  074A 09            ret
0413+  074B             
0414+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  074B             ; PRINT 16BIT HEX INTEGER
0416+  074B             ; integer value in reg B
0417+  074B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  074B             print_u16x:
0419+  074B D7            push a
0420+  074C D8            push b
0421+  074D DD            push bl
0422+  074E 30            mov bl, bh
0423+  074F 07 91 05      call _itoa        ; convert bh to char in A
0424+  0752 2F            mov bl, al        ; save al
0425+  0753 19 00         mov al, 0
0426+  0755 05 00         syscall sys_io        ; display AH
0427+  0757 24            mov ah, bl        ; retrieve al
0428+  0758 19 00         mov al, 0
0429+  075A 05 00         syscall sys_io        ; display AL
0430+  075C             
0431+  075C EA            pop bl
0432+  075D 07 91 05      call _itoa        ; convert bh to char in A
0433+  0760 2F            mov bl, al        ; save al
0434+  0761 19 00         mov al, 0
0435+  0763 05 00         syscall sys_io        ; display AH
0436+  0765 24            mov ah, bl        ; retrieve al
0437+  0766 19 00         mov al, 0
0438+  0768 05 00         syscall sys_io        ; display AL
0439+  076A             
0440+  076A E5            pop b
0441+  076B E4            pop a
0442+  076C 09            ret
0443+  076D             
0444+  076D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  076D             ; INPUT 16BIT HEX INTEGER
0446+  076D             ; read 16bit integer into A
0447+  076D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  076D             scan_u16x:
0449+  076D F8 10 00      enter 16
0450+  0770 D8            push b
0451+  0771 DA            push d
0452+  0772             
0453+  0772 FA F1 FF      lea d, [bp + -15]
0454+  0775 07 CA 05      call _gets        ; get number
0455+  0778             
0456+  0778 32            mov bl, [d]
0457+  0779 37            mov bh, bl
0458+  077A 33 01 00      mov bl, [d + 1]
0459+  077D 07 80 05      call _atoi        ; convert to int in AL
0460+  0780 23            mov ah, al        ; move to AH
0461+  0781             
0462+  0781 33 02 00      mov bl, [d + 2]
0463+  0784 37            mov bh, bl
0464+  0785 33 03 00      mov bl, [d + 3]
0465+  0788 07 80 05      call _atoi        ; convert to int in AL
0466+  078B             
0467+  078B E7            pop d
0468+  078C E5            pop b
0469+  078D F9            leave
0470+  078E 09            ret
0471+  078F             
0472+  078F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  078F             ; PRINT 8bit HEX INTEGER
0474+  078F             ; integer value in reg bl
0475+  078F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  078F             print_u8x:
0477+  078F D7            push a
0478+  0790 DD            push bl
0479+  0791             
0480+  0791 07 91 05      call _itoa        ; convert bl to char in A
0481+  0794 2F            mov bl, al        ; save al
0482+  0795 19 00         mov al, 0
0483+  0797 05 00         syscall sys_io        ; display AH
0484+  0799 24            mov ah, bl        ; retrieve al
0485+  079A 19 00         mov al, 0
0486+  079C 05 00         syscall sys_io        ; display AL
0487+  079E             
0488+  079E EA            pop bl
0489+  079F E4            pop a
0490+  07A0 09            ret
0491+  07A1             
0492+  07A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  07A1             ; print 8bit decimal unsigned number
0494+  07A1             ; input number in AL
0495+  07A1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  07A1             print_u8d:
0497+  07A1 D7            push a
0498+  07A2 D8            push b
0499+  07A3 FD D8         push g
0500+  07A5 22 00         mov ah, 0
0501+  07A7 26 64 00      mov b, 100
0502+  07AA AE            div a, b
0503+  07AB D8            push b      ; save remainder
0504+  07AC B9 00         cmp al, 0
0505+  07AE C6 B8 07      je skip100
0506+  07B1 6A 30         add al, $30
0507+  07B3 23            mov ah, al
0508+  07B4 19 00         mov al, 0
0509+  07B6 05 00         syscall sys_io  ; print coeff
0510+  07B8             skip100:
0511+  07B8 E4            pop a
0512+  07B9 22 00         mov ah, 0
0513+  07BB 26 0A 00      mov b, 10
0514+  07BE AE            div a, b
0515+  07BF D8            push b      ; save remainder
0516+  07C0 B9 00         cmp al, 0
0517+  07C2 C6 CC 07      je skip10
0518+  07C5 6A 30         add al, $30
0519+  07C7 23            mov ah, al
0520+  07C8 19 00         mov al, 0
0521+  07CA 05 00         syscall sys_io  ; print coeff
0522+  07CC             skip10:
0523+  07CC E4            pop a
0524+  07CD 1B            mov al, bl
0525+  07CE 6A 30         add al, $30
0526+  07D0 23            mov ah, al
0527+  07D1 19 00         mov al, 0
0528+  07D3 05 00         syscall sys_io  ; print coeff
0529+  07D5 FD F1         pop g
0530+  07D7 E5            pop b
0531+  07D8 E4            pop a
0532+  07D9 09            ret
0533+  07DA             
0534+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  07DA             ; INPUT 8BIT HEX INTEGER
0536+  07DA             ; read 8bit integer into AL
0537+  07DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  07DA             scan_u8x:
0539+  07DA F8 04 00      enter 4
0540+  07DD D8            push b
0541+  07DE DA            push d
0542+  07DF             
0543+  07DF FA FD FF      lea d, [bp + -3]
0544+  07E2 07 CA 05      call _gets        ; get number
0545+  07E5             
0546+  07E5 32            mov bl, [d]
0547+  07E6 37            mov bh, bl
0548+  07E7 33 01 00      mov bl, [d + 1]
0549+  07EA 07 80 05      call _atoi        ; convert to int in AL
0550+  07ED             
0551+  07ED E7            pop d
0552+  07EE E5            pop b
0553+  07EF F9            leave
0554+  07F0 09            ret
0555+  07F1             
0556+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  07F1             ; input decimal number
0558+  07F1             ; result in A
0559+  07F1             ; 655'\0'
0560+  07F1             ; low--------high
0561+  07F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  07F1             scan_u16d:
0563+  07F1 F8 08 00      enter 8
0564+  07F4 E2            push si
0565+  07F5 D8            push b
0566+  07F6 D9            push c
0567+  07F7 DA            push d
0568+  07F8 FA F9 FF      lea d, [bp +- 7]
0569+  07FB 07 CA 05      call _gets
0570+  07FE 07 22 05      call _strlen      ; get string length in C
0571+  0801 7E            dec c
0572+  0802 FD 4E         mov si, d
0573+  0804 12            mov a, c
0574+  0805 FD 99         shl a
0575+  0807 3B 43 08      mov d, table_power
0576+  080A 59            add d, a
0577+  080B 38 00 00      mov c, 0
0578+  080E             mul_loop:
0579+  080E F6            lodsb      ; load ASCII to al
0580+  080F B9 00         cmp al, 0
0581+  0811 C6 24 08      je mul_exit
0582+  0814 6F 30         sub al, $30    ; make into integer
0583+  0816 22 00         mov ah, 0
0584+  0818 2A            mov b, [d]
0585+  0819 AC            mul a, b      ; result in B since it fits in 16bits
0586+  081A 11            mov a, b
0587+  081B 28            mov b, c
0588+  081C 54            add a, b
0589+  081D 39            mov c, a
0590+  081E 63 02 00      sub d, 2
0591+  0821 0A 0E 08      jmp mul_loop
0592+  0824             mul_exit:
0593+  0824 12            mov a, c
0594+  0825 E7            pop d
0595+  0826 E6            pop c
0596+  0827 E5            pop b
0597+  0828 EF            pop si
0598+  0829 F9            leave
0599+  082A 09            ret
0600+  082B             
0601+  082B             
0602+  082B 30 31 32 33 s_hex_digits:    .db "0123456789ABCDEF"  
0602+  082F 34 35 36 37 
0602+  0833 38 39 41 42 
0602+  0837 43 44 45 46 
0603+  083B 1B 5B 32 4A s_telnet_clear:  .db "\033[2J\033[H", 0
0603+  083F 1B 5B 48 00 
0604+  0843             
0605+  0843             table_power:
0606+  0843 01 00         .dw 1
0607+  0845 0A 00         .dw 10
0608+  0847 64 00         .dw 100
0609+  0849 E8 03         .dw 1000
0610+  084B 10 27         .dw 100000830   084D             .include "lib/ctype.asm"
0001+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  084D             ; ctype.s
0003+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  084D             
0005+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  084D             ;; C character classification is an operation provided by a group of functions in the ANSI C Standard Library
0007+  084D             ;; for the C programming language. These functions are used to test characters for membership in a particular
0008+  084D             ;; class of characters, such as alphabetic characters, control characters, etc. Both single-byte, and wide
0009+  084D             ;; characters are supported.
0010+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  084D             ;; _isalnum 
0012+  084D             ;; _isalpha 
0013+  084D             ;; islower 
0014+  084D             ;; isupper 
0015+  084D             ;; _isdigit 
0016+  084D             ;; isxdigit
0017+  084D             ;; iscntrl 
0018+  084D             ;; isgraph 
0019+  084D             ;; _isspace 
0020+  084D             ;; isblank 
0021+  084D             ;; isprint 
0022+  084D             ;; ispunct 
0023+  084D             ;; tolower 
0024+  084D             ;; toupper
0025+  084D             
0026+  084D             
0027+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  084D             ;; IS ALPHANUMERIC
0029+  084D             ;; sets ZF according with result
0030+  084D             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  084D             _isalnum:
0032+  084D 07 6A 08    	call _isalpha
0033+  0850 C6 56 08    	je _isalnum_exit
0034+  0853 07 57 08    	call _isdigit
0035+  0856             _isalnum_exit:
0036+  0856 09          	ret	
0037+  0857             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  0857             ;; IS DIGIT
0039+  0857             ;; sets ZF according with result
0040+  0857             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  0857             _isdigit:
0042+  0857 DB          	push al
0043+  0858 B9 30       	cmp al, '0'
0044+  085A C8 66 08    	jlu _isdigit_false
0045+  085D B9 39       	cmp al, '9'
0046+  085F D1 66 08    	jgu _isdigit_false
0047+  0862 87 00       	and al, 0	; set ZF
0048+  0864 E8          	pop al
0049+  0865 09          	ret
0050+  0866             _isdigit_false:
0051+  0866 8B 01       	or al, 1	; clear ZF
0052+  0868 E8          	pop al
0053+  0869 09          	ret	
0054+  086A             	
0055+  086A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  086A             ;; IS ALPHA
0057+  086A             ;; sets ZF according with result
0058+  086A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  086A             _isalpha:
0060+  086A DB          	push al
0061+  086B B9 5F       	cmp al, '_'
0062+  086D C6 8D 08    	je _isalpha_true
0063+  0870 B9 2E       	cmp al, '.'
0064+  0872 C6 8D 08    	je _isalpha_true
0065+  0875 B9 41       	cmp al, 'A'
0066+  0877 C8 89 08    	jlu _isalpha_false
0067+  087A B9 7A       	cmp al, 'z'
0068+  087C D1 89 08    	jgu _isalpha_false
0069+  087F B9 5A       	cmp al, 'Z'
0070+  0881 D0 8D 08    	jleu _isalpha_true
0071+  0884 B9 61       	cmp al, 'a'
0072+  0886 C9 8D 08    	jgeu _isalpha_true
0073+  0889             _isalpha_false:
0074+  0889 8B 01       	or al, 1	; clear ZF
0075+  088B E8          	pop al
0076+  088C 09          	ret
0077+  088D             _isalpha_true:
0078+  088D 87 00       	and al, 0	; set ZF
0079+  088F E8          	pop al
0080+  0890 09          	ret
0081+  0891             
0082+  0891             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0891             ;; IS PATH-ALPHA
0084+  0891             ;; sets ZF according with result
0085+  0891             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0891             ispath:
0087+  0891 DB          	push al
0088+  0892 07 57 08    	call _isdigit
0089+  0895 C6 BF 08    	je ispath_true
0090+  0898 B9 5F       	cmp al, '_'
0091+  089A C6 BF 08    	je ispath_true
0092+  089D B9 2F       	cmp al, '/'
0093+  089F C6 BF 08    	je ispath_true
0094+  08A2 B9 2E       	cmp al, '.'
0095+  08A4 C6 BF 08    	je ispath_true
0096+  08A7 B9 41       	cmp al, 'A'
0097+  08A9 C8 BB 08    	jlu ispath_false
0098+  08AC B9 7A       	cmp al, 'z'
0099+  08AE D1 BB 08    	jgu ispath_false
0100+  08B1 B9 5A       	cmp al, 'Z'
0101+  08B3 D0 BF 08    	jleu ispath_true
0102+  08B6 B9 61       	cmp al, 'a'
0103+  08B8 C9 BF 08    	jgeu ispath_true
0104+  08BB             ispath_false:
0105+  08BB 8B 01       	or al, 1	; clear ZF
0106+  08BD E8          	pop al
0107+  08BE 09          	ret
0108+  08BF             ispath_true:
0109+  08BF 87 00       	and al, 0	; set ZF
0110+  08C1 E8          	pop al
0111+  08C2 09          	ret
0112+  08C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  08C3             ;; IS SPACE
0114+  08C3             ;; sets ZF according with result
0115+  08C3             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  08C3             _isspace:
0117+  08C3 B9 20       	cmp al, $20		; ' '
0118+  08C5 C6 D9 08    	je _isspace_exit
0119+  08C8 B9 09       	cmp al, $09		; '\t'
0120+  08CA C6 D9 08    	je _isspace_exit
0121+  08CD B9 0A       	cmp al, $0A		; '\n'
0122+  08CF C6 D9 08    	je _isspace_exit
0123+  08D2 B9 0D       	cmp al, $0D		; '\r'
0124+  08D4 C6 D9 08    	je _isspace_exit
0125+  08D7 B9 0B       	cmp al, $0B		; '\v'
0126+  08D9             _isspace_exit:
0127+  08D9 09          	ret	
0128+  08DA             
0129+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  08DA             ; TO LOWER
0131+  08DA             ; input in AL
0132+  08DA             ; output in AL
0133+  08DA             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  08DA             _to_lower:
0135+  08DA B9 5A       	cmp al, 'Z'
0136+  08DC D1 E1 08    	jgu _to_lower_ret
0137+  08DF 6A 20       	add al, $20				; convert to lower case
0138+  08E1             _to_lower_ret:
0139+  08E1 09          	ret
0140+  08E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  08E2             ; TO UPPER
0142+  08E2             ; input in AL
0143+  08E2             ; output in AL
0144+  08E2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  08E2             _to_upper:
0146+  08E2 B9 61       	cmp al, 'a'
0147+  08E4 C8 E9 08    	jlu _to_upper_ret
0148+  08E7 6F 20       	sub al, $20			; convert to upper case
0149+  08E9             _to_upper_ret:
0150+  08E9 09          	ret
0151+  08EA             
0831   08EA             
0832   08EA             ; kernel parameters
0833   08EA             sys_echo_on:
0834   08EA 01            .db 1
0835   08EB             sys_uart0_lcr:
0836   08EB 07            .db $07 ; 8 data bits, 2 stop bit, no parity
0837   08EC             sys_uart0_inten:
0838   08EC 01            .db 1
0839   08ED             sys_uart0_fifoen:
0840   08ED 00            .db 0
0841   08EE             sys_uart0_div0:
0842   08EE 0C            .db 12  ;
0843   08EF             sys_uart0_div1:
0844   08EF 00            .db 0   ; default baud = 9600
0845   08F0             ; Baud  Divisor
0846   08F0             ; 50    2304
0847   08F0             ; 110   1047
0848   08F0             ; 300    384
0849   08F0             ; 600    192
0850   08F0             ; 1200    96
0851   08F0             ; 9600    12
0852   08F0             ; 19200    6
0853   08F0             ; 38400    3
0854   08F0             
0855   08F0             
0856   08F0             fifo_in:
0857   08F0 86 0B         .dw fifo
0858   08F2             fifo_out:
0859   08F2 86 0B         .dw fifo
0860   08F4             
0861   08F4             
0862   08F4             s_kernel_started:
0863   08F4 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
0863   08F8 65 6C 20 73 
0863   08FC 74 61 72 74 
0863   0900 65 64 28 76 
0863   0904 65 72 73 69 
0863   0908 6F 6E 20 31 
0863   090C 2E 30 29 0A 
0863   0910 00 
0864   0911             s_priviledge:
0865   0911 0A 65 78 63   .db "\nexception: privilege\n", 0
0865   0915 65 70 74 69 
0865   0919 6F 6E 3A 20 
0865   091D 70 72 69 76 
0865   0921 69 6C 65 67 
0865   0925 65 0A 00 
0866   0928             s_divzero:
0867   0928 0A 65 78 63   .db "\nexception: zero division\n", 0
0867   092C 65 70 74 69 
0867   0930 6F 6E 3A 20 
0867   0934 7A 65 72 6F 
0867   0938 20 64 69 76 
0867   093C 69 73 69 6F 
0867   0940 6E 0A 00 
0868   0943             
0869   0943             ; This is the format of a sector for the 128 byte per sector format.
0870   0943             ; Write the bracketed data 16 times per track.
0871   0943             ; The recommended single-density format with 128
0872   0943             ; bytes/sector is shown. In order to format a diskette,
0873   0943             ; the user issues the Write Track Command, and loads
0874   0943             ; the Data Register with the following values. For every
0875   0943             ; byte to be written, there is one Data Request.
0876   0943             fdc_irq_event:
0877   0943 00            .fill 1,  $00       ; keeps status of fdc irq event
0878   0944             fdc_128_format:                                                                       
0879   0944             fdc_40_FF:
0880   0944 FF FF FF FF   .fill 40,  $FF    ; or 00                                                                                
0880   0948 FF FF FF FF 
0880   094C FF FF FF FF 
0880   0950 FF FF FF FF 
0880   0954 FF FF FF FF 
0880   0958 FF FF FF FF 
0880   095C FF FF FF FF 
0880   0960 FF FF FF FF 
0880   0964 FF FF FF FF 
0880   0968 FF FF FF FF 
0881   096C             fdc_128_format_inner:
0882   096C 00 00 00 00   .fill 6,   $00    ;                                                                            <--|        
0882   0970 00 00 
0883   0972 FE            .fill 1,   $FE    ; ID Address Mark                                                               |        
0884   0973             fdc_128_format_track:
0885   0973 00            .fill 1,   $00    ; Track Number   0 thru 39                                                      |                    
0886   0974 00            .fill 1,   $00    ; Side Number 00 or 01                                                          |                
0887   0975             fdc_128_format_sect:
0888   0975 01            .fill 1,   $01    ; Sector Number  0x01 through 0x10                                              |                              
0889   0976 00            .fill 1,   $00    ; Sector Length                                                                 |                        
0890   0977 F7            .fill 1,   $F7    ; 2 CRC's Written                                                               | Write 16 times                 
0891   0978 FF FF FF FF   .fill 11,  $FF    ; or 00                                                                         |                      
0891   097C FF FF FF FF 
0891   0980 FF FF FF 
0892   0983 00 00 00 00   .fill 6,   $00    ;                                                                               |                        
0892   0987 00 00 
0893   0989 FB            .fill 1,   $FB    ; Data Address Mark                                                             |                                  
0894   098A E5 E5 E5 E5   .fill 128, $E5    ; Data (IBM uses E5)                                                            |                                      
0894   098E E5 E5 E5 E5 
0894   0992 E5 E5 E5 E5 
0894   0996 E5 E5 E5 E5 
0894   099A E5 E5 E5 E5 
0894   099E E5 E5 E5 E5 
0894   09A2 E5 E5 E5 E5 
0894   09A6 E5 E5 E5 E5 
0894   09AA E5 E5 E5 E5 
0894   09AE E5 E5 E5 E5 
0894   09B2 E5 E5 E5 E5 
0894   09B6 E5 E5 E5 E5 
0894   09BA E5 E5 E5 E5 
0894   09BE E5 E5 E5 E5 
0894   09C2 E5 E5 E5 E5 
0894   09C6 E5 E5 E5 E5 
0894   09CA E5 E5 E5 E5 
0894   09CE E5 E5 E5 E5 
0894   09D2 E5 E5 E5 E5 
0894   09D6 E5 E5 E5 E5 
0894   09DA E5 E5 E5 E5 
0894   09DE E5 E5 E5 E5 
0894   09E2 E5 E5 E5 E5 
0894   09E6 E5 E5 E5 E5 
0894   09EA E5 E5 E5 E5 
0894   09EE E5 E5 E5 E5 
0894   09F2 E5 E5 E5 E5 
0894   09F6 E5 E5 E5 E5 
0894   09FA E5 E5 E5 E5 
0894   09FE E5 E5 E5 E5 
0894   0A02 E5 E5 E5 E5 
0894   0A06 E5 E5 E5 E5 
0895   0A0A F7            .fill 1,   $F7    ; 2 CRC's Written                                                               |                                                        
0896   0A0B FF FF FF FF   .fill 10,  $FF    ; or 00                                                                      <--|                                                  
0896   0A0F FF FF FF FF 
0896   0A13 FF FF 
0897   0A15             fdc_128_format_end:
0898   0A15 FF FF FF FF   .fill 369, $FF    ; or 00. Continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0898   0A19 FF FF FF FF 
0898   0A1D FF FF FF FF 
0898   0A21 FF FF FF FF 
0898   0A25 FF FF FF FF 
0898   0A29 FF FF FF FF 
0898   0A2D FF FF FF FF 
0898   0A31 FF FF FF FF 
0898   0A35 FF FF FF FF 
0898   0A39 FF FF FF FF 
0898   0A3D FF FF FF FF 
0898   0A41 FF FF FF FF 
0898   0A45 FF FF FF FF 
0898   0A49 FF FF FF FF 
0898   0A4D FF FF FF FF 
0898   0A51 FF FF FF FF 
0898   0A55 FF FF FF FF 
0898   0A59 FF FF FF FF 
0898   0A5D FF FF FF FF 
0898   0A61 FF FF FF FF 
0898   0A65 FF FF FF FF 
0898   0A69 FF FF FF FF 
0898   0A6D FF FF FF FF 
0898   0A71 FF FF FF FF 
0898   0A75 FF FF FF FF 
0898   0A79 FF FF FF FF 
0898   0A7D FF FF FF FF 
0898   0A81 FF FF FF FF 
0898   0A85 FF FF FF FF 
0898   0A89 FF FF FF FF 
0898   0A8D FF FF FF FF 
0898   0A91 FF FF FF FF 
0898   0A95 FF FF FF FF 
0898   0A99 FF FF FF FF 
0898   0A9D FF FF FF FF 
0898   0AA1 FF FF FF FF 
0898   0AA5 FF FF FF FF 
0898   0AA9 FF FF FF FF 
0898   0AAD FF FF FF FF 
0898   0AB1 FF FF FF FF 
0898   0AB5 FF FF FF FF 
0898   0AB9 FF FF FF FF 
0898   0ABD FF FF FF FF 
0898   0AC1 FF FF FF FF 
0898   0AC5 FF FF FF FF 
0898   0AC9 FF FF FF FF 
0898   0ACD FF FF FF FF 
0898   0AD1 FF FF FF FF 
0898   0AD5 FF FF FF FF 
0898   0AD9 FF FF FF FF 
0898   0ADD FF FF FF FF 
0898   0AE1 FF FF FF FF 
0898   0AE5 FF FF FF FF 
0898   0AE9 FF FF FF FF 
0898   0AED FF FF FF FF 
0898   0AF1 FF FF FF FF 
0898   0AF5 FF FF FF FF 
0898   0AF9 FF FF FF FF 
0898   0AFD FF FF FF FF 
0898   0B01 FF FF FF FF 
0898   0B05 FF FF FF FF 
0898   0B09 FF FF FF FF 
0898   0B0D FF FF FF FF 
0898   0B11 FF FF FF FF 
0898   0B15 FF FF FF FF 
0898   0B19 FF FF FF FF 
0898   0B1D FF FF FF FF 
0898   0B21 FF FF FF FF 
0898   0B25 FF FF FF FF 
0898   0B29 FF FF FF FF 
0898   0B2D FF FF FF FF 
0898   0B31 FF FF FF FF 
0898   0B35 FF FF FF FF 
0898   0B39 FF FF FF FF 
0898   0B3D FF FF FF FF 
0898   0B41 FF FF FF FF 
0898   0B45 FF FF FF FF 
0898   0B49 FF FF FF FF 
0898   0B4D FF FF FF FF 
0898   0B51 FF FF FF FF 
0898   0B55 FF FF FF FF 
0898   0B59 FF FF FF FF 
0898   0B5D FF FF FF FF 
0898   0B61 FF FF FF FF 
0898   0B65 FF FF FF FF 
0898   0B69 FF FF FF FF 
0898   0B6D FF FF FF FF 
0898   0B71 FF FF FF FF 
0898   0B75 FF FF FF FF 
0898   0B79 FF FF FF FF 
0898   0B7D FF FF FF FF 
0898   0B81 FF FF FF FF 
0898   0B85 FF 
0899   0B86             
0900   0B86             fifo:
0901   0B86 FF FF FF FF   .fill FIFO_SIZE
0901   0B8A FF FF FF FF 
0901   0B8E FF FF FF FF 
0901   0B92 FF FF FF FF 
0901   0B96 FF FF FF FF 
0901   0B9A FF FF FF FF 
0901   0B9E FF FF FF FF 
0901   0BA2 FF FF FF FF 
0901   0BA6 FF FF FF FF 
0901   0BAA FF FF FF FF 
0901   0BAE FF FF FF FF 
0901   0BB2 FF FF FF FF 
0901   0BB6 FF FF FF FF 
0901   0BBA FF FF FF FF 
0901   0BBE FF FF FF FF 
0901   0BC2 FF FF FF FF 
0901   0BC6 FF FF FF FF 
0901   0BCA FF FF FF FF 
0901   0BCE FF FF FF FF 
0901   0BD2 FF FF FF FF 
0901   0BD6 FF FF FF FF 
0901   0BDA FF FF FF FF 
0901   0BDE FF FF FF FF 
0901   0BE2 FF FF FF FF 
0901   0BE6 FF FF FF FF 
0901   0BEA FF FF FF FF 
0901   0BEE FF FF FF FF 
0901   0BF2 FF FF FF FF 
0901   0BF6 FF FF FF FF 
0901   0BFA FF FF FF FF 
0901   0BFE FF FF FF FF 
0901   0C02 FF FF FF FF 
0901   0C06 FF FF FF FF 
0901   0C0A FF FF FF FF 
0901   0C0E FF FF FF FF 
0901   0C12 FF FF FF FF 
0901   0C16 FF FF FF FF 
0901   0C1A FF FF FF FF 
0901   0C1E FF FF FF FF 
0901   0C22 FF FF FF FF 
0901   0C26 FF FF FF FF 
0901   0C2A FF FF FF FF 
0901   0C2E FF FF FF FF 
0901   0C32 FF FF FF FF 
0901   0C36 FF FF FF FF 
0901   0C3A FF FF FF FF 
0901   0C3E FF FF FF FF 
0901   0C42 FF FF FF FF 
0901   0C46 FF FF FF FF 
0901   0C4A FF FF FF FF 
0901   0C4E FF FF FF FF 
0901   0C52 FF FF FF FF 
0901   0C56 FF FF FF FF 
0901   0C5A FF FF FF FF 
0901   0C5E FF FF FF FF 
0901   0C62 FF FF FF FF 
0901   0C66 FF FF FF FF 
0901   0C6A FF FF FF FF 
0901   0C6E FF FF FF FF 
0901   0C72 FF FF FF FF 
0901   0C76 FF FF FF FF 
0901   0C7A FF FF FF FF 
0901   0C7E FF FF FF FF 
0901   0C82 FF FF FF FF 
0901   0C86 FF FF FF FF 
0901   0C8A FF FF FF FF 
0901   0C8E FF FF FF FF 
0901   0C92 FF FF FF FF 
0901   0C96 FF FF FF FF 
0901   0C9A FF FF FF FF 
0901   0C9E FF FF FF FF 
0901   0CA2 FF FF FF FF 
0901   0CA6 FF FF FF FF 
0901   0CAA FF FF FF FF 
0901   0CAE FF FF FF FF 
0901   0CB2 FF FF FF FF 
0901   0CB6 FF FF FF FF 
0901   0CBA FF FF FF FF 
0901   0CBE FF FF FF FF 
0901   0CC2 FF FF FF FF 
0901   0CC6 FF FF FF FF 
0901   0CCA FF FF FF FF 
0901   0CCE FF FF FF FF 
0901   0CD2 FF FF FF FF 
0901   0CD6 FF FF FF FF 
0901   0CDA FF FF FF FF 
0901   0CDE FF FF FF FF 
0901   0CE2 FF FF FF FF 
0901   0CE6 FF FF FF FF 
0901   0CEA FF FF FF FF 
0901   0CEE FF FF FF FF 
0901   0CF2 FF FF FF FF 
0901   0CF6 FF FF FF FF 
0901   0CFA FF FF FF FF 
0901   0CFE FF FF FF FF 
0901   0D02 FF FF FF FF 
0901   0D06 FF FF FF FF 
0901   0D0A FF FF FF FF 
0901   0D0E FF FF FF FF 
0901   0D12 FF FF FF FF 
0901   0D16 FF FF FF FF 
0901   0D1A FF FF FF FF 
0901   0D1E FF FF FF FF 
0901   0D22 FF FF FF FF 
0901   0D26 FF FF FF FF 
0901   0D2A FF FF FF FF 
0901   0D2E FF FF FF FF 
0901   0D32 FF FF FF FF 
0901   0D36 FF FF FF FF 
0901   0D3A FF FF FF FF 
0901   0D3E FF FF FF FF 
0901   0D42 FF FF FF FF 
0901   0D46 FF FF FF FF 
0901   0D4A FF FF FF FF 
0901   0D4E FF FF FF FF 
0901   0D52 FF FF FF FF 
0901   0D56 FF FF FF FF 
0901   0D5A FF FF FF FF 
0901   0D5E FF FF FF FF 
0901   0D62 FF FF FF FF 
0901   0D66 FF FF FF FF 
0901   0D6A FF FF FF FF 
0901   0D6E FF FF FF FF 
0901   0D72 FF FF FF FF 
0901   0D76 FF FF FF FF 
0901   0D7A FF FF FF FF 
0901   0D7E FF FF FF FF 
0901   0D82 FF FF FF FF 
0901   0D86 FF FF FF FF 
0901   0D8A FF FF FF FF 
0901   0D8E FF FF FF FF 
0901   0D92 FF FF FF FF 
0901   0D96 FF FF FF FF 
0901   0D9A FF FF FF FF 
0901   0D9E FF FF FF FF 
0901   0DA2 FF FF FF FF 
0901   0DA6 FF FF FF FF 
0901   0DAA FF FF FF FF 
0901   0DAE FF FF FF FF 
0901   0DB2 FF FF FF FF 
0901   0DB6 FF FF FF FF 
0901   0DBA FF FF FF FF 
0901   0DBE FF FF FF FF 
0901   0DC2 FF FF FF FF 
0901   0DC6 FF FF FF FF 
0901   0DCA FF FF FF FF 
0901   0DCE FF FF FF FF 
0901   0DD2 FF FF FF FF 
0901   0DD6 FF FF FF FF 
0901   0DDA FF FF FF FF 
0901   0DDE FF FF FF FF 
0901   0DE2 FF FF FF FF 
0901   0DE6 FF FF FF FF 
0901   0DEA FF FF FF FF 
0901   0DEE FF FF FF FF 
0901   0DF2 FF FF FF FF 
0901   0DF6 FF FF FF FF 
0901   0DFA FF FF FF FF 
0901   0DFE FF FF FF FF 
0901   0E02 FF FF FF FF 
0901   0E06 FF FF FF FF 
0901   0E0A FF FF FF FF 
0901   0E0E FF FF FF FF 
0901   0E12 FF FF FF FF 
0901   0E16 FF FF FF FF 
0901   0E1A FF FF FF FF 
0901   0E1E FF FF FF FF 
0901   0E22 FF FF FF FF 
0901   0E26 FF FF FF FF 
0901   0E2A FF FF FF FF 
0901   0E2E FF FF FF FF 
0901   0E32 FF FF FF FF 
0901   0E36 FF FF FF FF 
0901   0E3A FF FF FF FF 
0901   0E3E FF FF FF FF 
0901   0E42 FF FF FF FF 
0901   0E46 FF FF FF FF 
0901   0E4A FF FF FF FF 
0901   0E4E FF FF FF FF 
0901   0E52 FF FF FF FF 
0901   0E56 FF FF FF FF 
0901   0E5A FF FF FF FF 
0901   0E5E FF FF FF FF 
0901   0E62 FF FF FF FF 
0901   0E66 FF FF FF FF 
0901   0E6A FF FF FF FF 
0901   0E6E FF FF FF FF 
0901   0E72 FF FF FF FF 
0901   0E76 FF FF FF FF 
0901   0E7A FF FF FF FF 
0901   0E7E FF FF FF FF 
0901   0E82 FF FF FF FF 
0901   0E86 FF FF FF FF 
0901   0E8A FF FF FF FF 
0901   0E8E FF FF FF FF 
0901   0E92 FF FF FF FF 
0901   0E96 FF FF FF FF 
0901   0E9A FF FF FF FF 
0901   0E9E FF FF FF FF 
0901   0EA2 FF FF FF FF 
0901   0EA6 FF FF FF FF 
0901   0EAA FF FF FF FF 
0901   0EAE FF FF FF FF 
0901   0EB2 FF FF FF FF 
0901   0EB6 FF FF FF FF 
0901   0EBA FF FF FF FF 
0901   0EBE FF FF FF FF 
0901   0EC2 FF FF FF FF 
0901   0EC6 FF FF FF FF 
0901   0ECA FF FF FF FF 
0901   0ECE FF FF FF FF 
0901   0ED2 FF FF FF FF 
0901   0ED6 FF FF FF FF 
0901   0EDA FF FF FF FF 
0901   0EDE FF FF FF FF 
0901   0EE2 FF FF FF FF 
0901   0EE6 FF FF FF FF 
0901   0EEA FF FF FF FF 
0901   0EEE FF FF FF FF 
0901   0EF2 FF FF FF FF 
0901   0EF6 FF FF FF FF 
0901   0EFA FF FF FF FF 
0901   0EFE FF FF FF FF 
0901   0F02 FF FF FF FF 
0901   0F06 FF FF FF FF 
0901   0F0A FF FF FF FF 
0901   0F0E FF FF FF FF 
0901   0F12 FF FF FF FF 
0901   0F16 FF FF FF FF 
0901   0F1A FF FF FF FF 
0901   0F1E FF FF FF FF 
0901   0F22 FF FF FF FF 
0901   0F26 FF FF FF FF 
0901   0F2A FF FF FF FF 
0901   0F2E FF FF FF FF 
0901   0F32 FF FF FF FF 
0901   0F36 FF FF FF FF 
0901   0F3A FF FF FF FF 
0901   0F3E FF FF FF FF 
0901   0F42 FF FF FF FF 
0901   0F46 FF FF FF FF 
0901   0F4A FF FF FF FF 
0901   0F4E FF FF FF FF 
0901   0F52 FF FF FF FF 
0901   0F56 FF FF FF FF 
0901   0F5A FF FF FF FF 
0901   0F5E FF FF FF FF 
0901   0F62 FF FF FF FF 
0901   0F66 FF FF FF FF 
0901   0F6A FF FF FF FF 
0901   0F6E FF FF FF FF 
0901   0F72 FF FF FF FF 
0901   0F76 FF FF FF FF 
0901   0F7A FF FF FF FF 
0901   0F7E FF FF FF FF 
0901   0F82 FF FF FF FF 
0902   0F86             
0903   0F86             scrap_sector:
0904   0F86 FF FF FF FF   .fill 512         ; scrap sector
0904   0F8A FF FF FF FF 
0904   0F8E FF FF FF FF 
0904   0F92 FF FF FF FF 
0904   0F96 FF FF FF FF 
0904   0F9A FF FF FF FF 
0904   0F9E FF FF FF FF 
0904   0FA2 FF FF FF FF 
0904   0FA6 FF FF FF FF 
0904   0FAA FF FF FF FF 
0904   0FAE FF FF FF FF 
0904   0FB2 FF FF FF FF 
0904   0FB6 FF FF FF FF 
0904   0FBA FF FF FF FF 
0904   0FBE FF FF FF FF 
0904   0FC2 FF FF FF FF 
0904   0FC6 FF FF FF FF 
0904   0FCA FF FF FF FF 
0904   0FCE FF FF FF FF 
0904   0FD2 FF FF FF FF 
0904   0FD6 FF FF FF FF 
0904   0FDA FF FF FF FF 
0904   0FDE FF FF FF FF 
0904   0FE2 FF FF FF FF 
0904   0FE6 FF FF FF FF 
0904   0FEA FF FF FF FF 
0904   0FEE FF FF FF FF 
0904   0FF2 FF FF FF FF 
0904   0FF6 FF FF FF FF 
0904   0FFA FF FF FF FF 
0904   0FFE FF FF FF FF 
0904   1002 FF FF FF FF 
0904   1006 FF FF FF FF 
0904   100A FF FF FF FF 
0904   100E FF FF FF FF 
0904   1012 FF FF FF FF 
0904   1016 FF FF FF FF 
0904   101A FF FF FF FF 
0904   101E FF FF FF FF 
0904   1022 FF FF FF FF 
0904   1026 FF FF FF FF 
0904   102A FF FF FF FF 
0904   102E FF FF FF FF 
0904   1032 FF FF FF FF 
0904   1036 FF FF FF FF 
0904   103A FF FF FF FF 
0904   103E FF FF FF FF 
0904   1042 FF FF FF FF 
0904   1046 FF FF FF FF 
0904   104A FF FF FF FF 
0904   104E FF FF FF FF 
0904   1052 FF FF FF FF 
0904   1056 FF FF FF FF 
0904   105A FF FF FF FF 
0904   105E FF FF FF FF 
0904   1062 FF FF FF FF 
0904   1066 FF FF FF FF 
0904   106A FF FF FF FF 
0904   106E FF FF FF FF 
0904   1072 FF FF FF FF 
0904   1076 FF FF FF FF 
0904   107A FF FF FF FF 
0904   107E FF FF FF FF 
0904   1082 FF FF FF FF 
0904   1086 FF FF FF FF 
0904   108A FF FF FF FF 
0904   108E FF FF FF FF 
0904   1092 FF FF FF FF 
0904   1096 FF FF FF FF 
0904   109A FF FF FF FF 
0904   109E FF FF FF FF 
0904   10A2 FF FF FF FF 
0904   10A6 FF FF FF FF 
0904   10AA FF FF FF FF 
0904   10AE FF FF FF FF 
0904   10B2 FF FF FF FF 
0904   10B6 FF FF FF FF 
0904   10BA FF FF FF FF 
0904   10BE FF FF FF FF 
0904   10C2 FF FF FF FF 
0904   10C6 FF FF FF FF 
0904   10CA FF FF FF FF 
0904   10CE FF FF FF FF 
0904   10D2 FF FF FF FF 
0904   10D6 FF FF FF FF 
0904   10DA FF FF FF FF 
0904   10DE FF FF FF FF 
0904   10E2 FF FF FF FF 
0904   10E6 FF FF FF FF 
0904   10EA FF FF FF FF 
0904   10EE FF FF FF FF 
0904   10F2 FF FF FF FF 
0904   10F6 FF FF FF FF 
0904   10FA FF FF FF FF 
0904   10FE FF FF FF FF 
0904   1102 FF FF FF FF 
0904   1106 FF FF FF FF 
0904   110A FF FF FF FF 
0904   110E FF FF FF FF 
0904   1112 FF FF FF FF 
0904   1116 FF FF FF FF 
0904   111A FF FF FF FF 
0904   111E FF FF FF FF 
0904   1122 FF FF FF FF 
0904   1126 FF FF FF FF 
0904   112A FF FF FF FF 
0904   112E FF FF FF FF 
0904   1132 FF FF FF FF 
0904   1136 FF FF FF FF 
0904   113A FF FF FF FF 
0904   113E FF FF FF FF 
0904   1142 FF FF FF FF 
0904   1146 FF FF FF FF 
0904   114A FF FF FF FF 
0904   114E FF FF FF FF 
0904   1152 FF FF FF FF 
0904   1156 FF FF FF FF 
0904   115A FF FF FF FF 
0904   115E FF FF FF FF 
0904   1162 FF FF FF FF 
0904   1166 FF FF FF FF 
0904   116A FF FF FF FF 
0904   116E FF FF FF FF 
0904   1172 FF FF FF FF 
0904   1176 FF FF FF FF 
0904   117A FF FF FF FF 
0904   117E FF FF FF FF 
0904   1182 FF FF FF FF 
0905   1186             transient_area:
0906   1186 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
0907   1187             
0908   1187             .end
tasm: Number of errors = 0
