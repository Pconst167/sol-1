0001   0000             ; ------------------------------------------------------------------------------------------------------------------;
0002   0000             ; solarium - sol-1 homebrew minicomputer operating system kernel.
0003   0000             ; ------------------------------------------------------------------------------------------------------------------;
0004   0000             
0005   0000             ; memory map
0006   0000             ; ------------------------------------------------------------------------------------------------------------------;
0007   0000             ; 0000 ... 7fff - rom space
0008   0000             ; 8000 ... f7ff - ram space
0009   0000             ; f7ff          - stack root
0010   0000             
0011   0000             ; i/o map
0012   0000             ; ------------------------------------------------------------------------------------------------------------------;
0013   0000             ; ff80 - uart 0 (16550)
0014   0000             ; ff90 - uart 1 (16550)
0015   0000             ; ffa0 - rtc    (m48t02)
0016   0000             ; ffb0 - pio 0  (8255)
0017   0000             ; ffc0 - fdd    (5.25" floppy drive block)
0018   0000             ;   - ffc0      output port (377 flip-flop)                  
0019   0000             ;   - ffc1      input port  (244 buffer)                     
0020   0000             ;   - ffc8      wd1770 status/command    
0021   0000             ;   - ffc9      wd1770 track register
0022   0000             ;   - ffca      wd1770 sector register
0023   0000             ;   - ffcb      wd1770 data register
0024   0000             ;      
0025   0000             ; ffd0 - ide    (compact flash / pata)
0026   0000             ; ffe0 - timer  (8253)
0027   0000             ; fff0 - bios configuration nv-ram store area
0028   0000             ; ------------------------------------------------------------------------------------------------------------------;
0029   0000             
0030   0000             ; ------------------------------------------------------------------------------------------------------------------;
0031   0000             ; system constants
0032   0000             ; ------------------------------------------------------------------------------------------------------------------;
0033   0000             _uart0_data       .equ $ff80            ; data
0034   0000             _uart0_dlab_0     .equ $ff80            ; divisor latch low byte
0035   0000             _uart0_dlab_1     .equ $ff81            ; divisor latch high byte
0036   0000             _uart0_ier        .equ $ff81            ; interrupt enable register
0037   0000             _uart0_fcr        .equ $ff82            ; fifo control register
0038   0000             _uart0_lcr        .equ $ff83            ; line control register
0039   0000             _uart0_lsr        .equ $ff85            ; line status register
0040   0000             
0041   0000             _uart1_data       .equ $ff90            ; data
0042   0000             _uart1_dlab_0     .equ $ff90            ; divisor latch low byte
0043   0000             _uart1_dlab_1     .equ $ff91            ; divisor latch high byte
0044   0000             _uart1_ier        .equ $ff91            ; interrupt enable register
0045   0000             _uart1_fcr        .equ $ff92            ; fifo control register
0046   0000             _uart1_lcr        .equ $ff93            ; line control register
0047   0000             _uart1_lsr        .equ $ff95            ; line status register
0048   0000             
0049   0000             _ide_base         .equ $ffd0            ; ide base
0050   0000             _ide_r0           .equ _ide_base + 0    ; data port
0051   0000             _ide_r1           .equ _ide_base + 1    ; read: error code, write: feature
0052   0000             _ide_r2           .equ _ide_base + 2    ; number of sectors to transfer
0053   0000             _ide_r3           .equ _ide_base + 3    ; sector address lba 0 [0:7]
0054   0000             _ide_r4           .equ _ide_base + 4    ; sector address lba 1 [8:15]
0055   0000             _ide_r5           .equ _ide_base + 5    ; sector address lba 2 [16:23]
0056   0000             _ide_r6           .equ _ide_base + 6    ; sector address lba 3 [24:27 (lsb)]
0057   0000             _ide_r7           .equ _ide_base + 7    ; read: status, write: command       
0058   0000             
0059   0000             _7seg_display     .equ $ffb0            ; bios post code hex display (2 digits) (connected to pio a)
0060   0000             _bios_post_ctrl   .equ $ffb3            ; bios post display control register, 80h = as output
0061   0000             _pio_a            .equ $ffb0    
0062   0000             _pio_b            .equ $ffb1
0063   0000             _pio_c            .equ $ffb2
0064   0000             _pio_control      .equ $ffb3            ; pio control port
0065   0000             
0066   0000             _fdc_config       .equ $ffc0            ; 0 = select_0, 1 = select_1, 2 = side_select, 3 = dden, 4 = in_use_or_head_load, 5 = wd1770_rst
0067   0000             _fdc_status_1     .equ $ffc1            ; 0 = drq, 1 = ready
0068   0000             _fdc_wd_stat_cmd  .equ $ffc8            ; status / command register
0069   0000             _fdc_wd_track     .equ $ffc9            ; track register
0070   0000             _fdc_wd_sector    .equ $ffca            ; sector register
0071   0000             _fdc_wd_data      .equ $ffcb            ; data register
0072   0000             
0073   0000             _timer_c_0        .equ $ffe0            ; timer counter 0
0074   0000             _timer_c_1        .equ $ffe1            ; timer counter 1
0075   0000             _timer_c_2        .equ $ffe2            ; timer counter 2
0076   0000             _timer_ctrl       .equ $ffe3            ; timer control register
0077   0000             
0078   0000             stack_begin       .equ $f7ff            ; beginning of stack
0079   0000             fifo_size         .equ 1024
0080   0000             
0081   0000             text_org          .equ $400             ; code origin address for all user processes
0082   0000             
0083   0000             
0084   0000             ; ------------------------------------------------------------------------------------------------------------------;
0085   0000             ; global system variables
0086   0000             ; ------------------------------------------------------------------------------------------------------------------;
0087   0000             
0088   0000             ; ------------------------------------------------------------------------------------------------------------------;
0089   0000             ; irq table
0090   0000             ; highest priority at lowest address
0091   0000             ; ------------------------------------------------------------------------------------------------------------------;
0092   0000 2C 00       .dw int_0_fdc
0093   0002 33 00       .dw int_1
0094   0004 34 00       .dw int_2
0095   0006 35 00       .dw int_3
0096   0008 36 00       .dw int_4
0097   000A 37 00       .dw int_5
0098   000C 38 00       .dw int_6
0099   000E 39 00       .dw int_7_uart0
0100   0010             
0101   0010             ; ------------------------------------------------------------------------------------------------------------------;
0102   0010             ; kernel reset vector
0103   0010             ; ------------------------------------------------------------------------------------------------------------------;
0104   0010 C4 02       .dw kernel_reset_vector
0105   0012             
0106   0012             ; ------------------------------------------------------------------------------------------------------------------;
0107   0012             ; exception vector table
0108   0012             ; total of 7 entries, starting at address $0012
0109   0012             ; ------------------------------------------------------------------------------------------------------------------;
0110   0012 33 02       .dw trap_privilege
0111   0014 3F 02       .dw trap_div_zero
0112   0016 4C 02       .dw trap_undef_opcode
0113   0018 00 00       .dw 0
0114   001A 00 00       .dw 0
0115   001C 00 00       .dw 0
0116   001E 00 00       .dw 0
0117   0020             
0118   0020             ; ------------------------------------------------------------------------------------------------------------------;
0119   0020             ; system call vector table
0120   0020             ; starts at address $0020
0121   0020             ; ------------------------------------------------------------------------------------------------------------------;
0122   0020 53 02       .dw syscall_io
0123   0022 27 02       .dw syscall_reboot
0124   0024 F3 00       .dw syscall_fdc_format
0125   0026 6B 00       .dw syscall_fdc_read
0126   0028 B5 00       .dw syscall_fdc_read_sec
0127   002A 38 01       .dw syscall_fdc_write_sec
0128   002C             
0129   002C             ; ------------------------------------------------------------------------------------------------------------------;
0130   002C             ; system call aliases
0131   002C             ; ------------------------------------------------------------------------------------------------------------------;
0132   002C             sys_io               .equ 0
0133   002C             sys_reboot           .equ 1
0134   002C             sys_fdc_format       .equ 2
0135   002C             sys_fdc_read         .equ 3
0136   002C             sys_fdc_read_sec     .equ 4
0137   002C             sys_fdc_write_sec    .equ 5
0138   002C             
0139   002C             ; ------------------------------------------------------------------------------------------------------------------;
0140   002C             ; irqs' code block
0141   002C             ; ------------------------------------------------------------------------------------------------------------------;
0142   002C             ; 5.25" floppy drive controller irq
0143   002C             int_0_fdc:
0144   002C 3B 58 00      mov d, s_fdc1
0145   002F 07 76 07      call _puts
0146   0032 06            sysret
0147   0033             int_1:
0148   0033 06            sysret
0149   0034             int_2:
0150   0034 06            sysret
0151   0035             int_3:
0152   0035 06            sysret
0153   0036             int_4:
0154   0036 06            sysret
0155   0037             int_5:
0156   0037 06            sysret
0157   0038             
0158   0038             ; ------------------------------------------------------------------------------------------------------------------;
0159   0038             ; process swapping
0160   0038             ; ------------------------------------------------------------------------------------------------------------------;
0161   0038             int_6:  
0162   0038 06            sysret
0163   0039             
0164   0039             ; ------------------------------------------------------------------------------------------------------------------;
0165   0039             ; uart0 interrupt
0166   0039             ; ------------------------------------------------------------------------------------------------------------------;
0167   0039             int_7_uart0:
0168   0039 D7            push a
0169   003A DA            push d
0170   003B E1            pushf
0171   003C 14 77 09      mov a, [fifo_in]
0172   003F 3C            mov d, a
0173   0040 1D 80 FF      mov al, [_uart0_data]       ; get character
0174   0043 3E            mov [d], al                 ; add to fifo
0175   0044 14 77 09      mov a, [fifo_in]
0176   0047 77            inc a
0177   0048 AF 4A 0E      cmp a, fifo + fifo_size     ; check if pointer reached the end of the fifo
0178   004B C7 51 00      jne int_7_continue
0179   004E 10 4A 0A      mov a, fifo  
0180   0051             int_7_continue:  
0181   0051 42 77 09      mov [fifo_in], a            ; update fifo pointer
0182   0054 EE            popf
0183   0055 E7            pop d
0184   0056 E4            pop a  
0185   0057 06            sysret
0186   0058             
0187   0058 0A 0D 69 72 s_fdc1:.db "\n\rirq0 serviced.\n\r",0
0187   005C 71 30 20 73 
0187   0060 65 72 76 69 
0187   0064 63 65 64 2E 
0187   0068 0A 0D 00 
0188   006B             
0189   006B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0190   006B             ; floppy drive system calls
0191   006B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0192   006B             ; data for formatting a floppy drive in single density mode (128 bytes per sector):
0193   006B             ; fdc_40_ff:
0194   006B             ;   .fill 40,  $ff    ; or 00                                                                                
0195   006B             ; fdc_128_format_inner:
0196   006B             ;   .fill 6,   $00    ;                                                                            <--|        
0197   006B             ;   .fill 1,   $fe    ; id address mark                                                               |        
0198   006B             ;   .fill 1,   $00    ; track number  0 thru 39                                                       |                    
0199   006B             ;   .fill 1,   $00    ; side number 00 or 01                                                          |                
0200   006B             ;   .fill 1,   $01    ; sector number  0x01 through 0x10                                              |                              
0201   006B             ;   .fill 1,   $00    ; sector length                                                                 |                        
0202   006B             ;   .fill 1,   $f7    ; 2 crc's written                                                               | write 16 times                 
0203   006B             ;   .fill 11,  $ff    ; or 00                                                                         |                      
0204   006B             ;   .fill 6,   $00    ;                                                                               |                        
0205   006B             ;   .fill 1,   $fb    ; data address mark                                                             |                                  
0206   006B             ;   .fill 128, $e5    ; data (ibm uses e5)                                                            |                                      
0207   006B             ;   .fill 1,   $f7    ; 2 crc's written                                                               |                                                        
0208   006B             ;   .fill 10,  $ff    ; or 00                                                                      <--|                                                  
0209   006B             ; fdc_128_format_end:
0210   006B             ;   .fill 369, $ff    ; or 00. continue writing until wd1770 interrupts out. approx 369 bytes.                                                                
0211   006B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212   006B             ; _fdc_config       .equ $ffc0 
0213   006B             ; _fdc_status_1     .equ $ffc1
0214   006B             ; _fdc_wd_stat_cmd  .equ $ffc8
0215   006B             ; _fdc_wd_track     .equ $ffc9
0216   006B             ; _fdc_wd_sector    .equ $ffca
0217   006B             ; _fdc_wd_data      .equ $ffcb
0218   006B             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0219   006B             
0220   006B             syscall_fdc_read:
0221   006B 1D CB FF      mov al, [_fdc_wd_data]      ; read data register to clear any errors
0222   006E 1D C8 FF      mov al, [_fdc_wd_stat_cmd]      ; read status register to clear any errors
0223   0071 19 E8         mov al, %11101000         
0224   0073 3D C8 FF      mov [_fdc_wd_stat_cmd], al
0225   0076 07 E5 01      call fdc_wait_64us
0226   0079             ;fdc_wait_busy_high1:
0227   0079             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0228   0079             ;  test al, $01                ; 
0229   0079             ;  jz fdc_wait_busy_high1
0230   0079 FD 4F 4A 10   mov di, transient_area
0231   007D             fdc_read_loop: ; for each byte, we need to wait for drq to be high
0232   007D 1D C8 FF      mov al, [_fdc_wd_stat_cmd]      ; 
0233   0080 93 01         test al, $01                ; check busy bit
0234   0082 C6 91 00      jz fdc_read_end
0235   0085 93 02         test al, $02                ; check drq bit
0236   0087 C6 7D 00      jz fdc_read_loop
0237   008A 1D CB FF      mov al, [_fdc_wd_data]     ; 
0238   008D F7            stosb
0239   008E 0A 7D 00      jmp fdc_read_loop
0240   0091             ;we need to check if writing to data reg causes a spurious read. so lets check inside the writing loop, how many times we actually write the bytes
0241   0091             ;say the 40 byte loop. if we find that we only write ~20 times, then this indcates this problem.
0242   0091             ;because for every write, if it also reads, then that clears drq, so we need to wait for next drq.
0243   0091             fdc_read_end:
0244   0091 50            mov a, di
0245   0092 5F 4A 10      sub a, transient_area
0246   0095 3B A8 00      mov d, sss
0247   0098 07 76 07      call _puts
0248   009B 07 9F 07      call print_u16d
0249   009E 07 23 07      call printnl
0250   00A1 26 12 0C      mov b, 3090
0251   00A4 07 14 04      call cmd_hexd
0252   00A7 06            sysret
0253   00A8 0A 74 72 61 sss:.db "\ntrack read\n", 0
0253   00AC 63 6B 20 72 
0253   00B0 65 61 64 0A 
0253   00B4 00 
0254   00B5             
0255   00B5             
0256   00B5             ; sector in al
0257   00B5             ; track in ah
0258   00B5             syscall_fdc_read_sec:
0259   00B5 3D CA FF      mov [_fdc_wd_sector], al
0260   00B8 1A            mov al, ah
0261   00B9 3D C9 FF      mov [_fdc_wd_track], al
0262   00BC 19 88         mov al, %10001000         
0263   00BE 3D C8 FF      mov [_fdc_wd_stat_cmd], al
0264   00C1 07 E5 01      call fdc_wait_64us
0265   00C4             ;fdc_wait_busy_high2:
0266   00C4             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0267   00C4             ;  test al, $01                ; 
0268   00C4             ;  jz fdc_wait_busy_high2
0269   00C4 FD 4F 4A 10   mov di, transient_area
0270   00C8             fdc_read_loop2: ; for each byte, we need to wait for drq to be high
0271   00C8 1D C8 FF      mov al, [_fdc_wd_stat_cmd]      ; read lost data flag 10+3+5+8+5+8
0272   00CB 93 01         test al, $01                ; check drq bit
0273   00CD C6 DC 00      jz fdc_read_end2
0274   00D0 93 02         test al, $02                ; check drq bit
0275   00D2 C6 C8 00      jz fdc_read_loop2
0276   00D5 1D CB FF      mov al, [_fdc_wd_data]     ; 
0277   00D8 F7            stosb
0278   00D9 0A C8 00      jmp fdc_read_loop2
0279   00DC             fdc_read_end2:
0280   00DC 50            mov a, di
0281   00DD 5F 4A 10      sub a, transient_area
0282   00E0 3B A8 00      mov d, sss
0283   00E3 07 76 07      call _puts
0284   00E6 07 9F 07      call print_u16d
0285   00E9 07 23 07      call printnl
0286   00EC 26 80 00      mov b, 128
0287   00EF 07 14 04      call cmd_hexd
0288   00F2 06            sysret
0289   00F3             
0290   00F3             ; when writing the actual code for formatting multiple tracks, remember to change the track number byte
0291   00F3             ; in the ram formatting block because they are all set as 00 right now
0292   00F3             ; bl: track number
0293   00F3             syscall_fdc_format:
0294   00F3 FD 3D C9 FF   mov [_fdc_wd_track], bl
0295   00F7 3B ED 01      mov d, s_format_begin
0296   00FA 07 76 07      call _puts
0297   00FD 1D CB FF      mov al, [_fdc_wd_data]      ; read data register to clear any errors
0298   0100 1D C8 FF      mov al, [_fdc_wd_stat_cmd]      ; read status register to clear any errors
0299   0103             fdc_header_loop_start:
0300   0103 19 FA         mov al, %11111010               ; write track command: {1111, 0: enable spin-up seq, 1: settling delay, 1: no write precompensation, 0}
0301   0105 3D C8 FF      mov [_fdc_wd_stat_cmd], al
0302   0108             ; write the first data block for formatting which is 40 bytes of 0xff:
0303   0108 07 E5 01      call fdc_wait_64us
0304   010B             ;fdc_wait_busy_high:
0305   010B             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0306   010B             ;  test al, $01                ; 
0307   010B             ;  jz fdc_wait_busy_high
0308   010B FD 4D 4A 10   mov si, transient_area
0309   010F             fdc_format_drq:
0310   010F 1D C8 FF      mov al, [_fdc_wd_stat_cmd]  ; 10
0311   0112 93 01         test al, $01                ; 4
0312   0114 C6 23 01      jz fdc_format_end           ; 8
0313   0117 93 02         test al, $02                ; 4
0314   0119 C6 0F 01      jz fdc_format_drq           ; 8
0315   011C F6            lodsb                       ; 7
0316   011D 3D CB FF      mov [_fdc_wd_data], al      ; 10   
0317   0120 0A 0F 01      jmp fdc_format_drq
0318   0123             fdc_format_end:
0319   0123 3B 2A 01      mov d, sss1
0320   0126 07 76 07      call _puts
0321   0129 06            sysret
0322   012A             
0323   012A 0A 66 6F 72 sss1:.db "\nformat done\n", 0
0323   012E 6D 61 74 20 
0323   0132 64 6F 6E 65 
0323   0136 0A 00 
0324   0138             
0325   0138             
0326   0138             ; sector in al
0327   0138             ; track in ah
0328   0138             syscall_fdc_write_sec:
0329   0138 3D CA FF      mov [_fdc_wd_sector], al
0330   013B 1A            mov al, ah
0331   013C 3D C9 FF      mov [_fdc_wd_track], al
0332   013F 19 AA         mov al, %10101010            ; 101, 0:single sector, 1: disable spinup, 0: no delay, 1: no precomp, 0: normal data mark
0333   0141 3D C8 FF      mov [_fdc_wd_stat_cmd], al
0334   0144 07 E5 01      call fdc_wait_64us
0335   0147             ;fdc_wait_busy_high2:
0336   0147             ;  mov al, [_fdc_wd_stat_cmd]      ; 
0337   0147             ;  test al, $01                ; 
0338   0147             ;  jz fdc_wait_busy_high2
0339   0147 FD 4D CA 09   mov si, fdc_sec_data
0340   014B             fdc_write_loop2: ; for each byte, we need to wait for drq to be high
0341   014B 1D C8 FF      mov al, [_fdc_wd_stat_cmd]  ; 10
0342   014E 93 01         test al, $01                ; 4
0343   0150 C6 5F 01      jz fdc_write_end           ; 8
0344   0153 93 02         test al, $02                ; 4
0345   0155 C6 4B 01      jz fdc_write_loop2           ; 8
0346   0158 F6            lodsb                       ; 7
0347   0159 3D CB FF      mov [_fdc_wd_data], al      ; 10   
0348   015C 0A 4B 01      jmp fdc_write_loop2
0349   015F             fdc_write_end:
0350   015F 3B 66 01      mov d, sss2
0351   0162 07 76 07      call _puts
0352   0165 06            sysret
0353   0166 0A 73 65 63 sss2:.db "\nsector written\n",0
0353   016A 74 6F 72 20 
0353   016E 77 72 69 74 
0353   0172 74 65 6E 0A 
0353   0176 00 
0354   0177             
0355   0177             
0356   0177             fdc_format_mem:
0357   0177 3B 01 00      mov d, 1
0358   017A FD 4F 4A 10   mov di, transient_area
0359   017E 38 28 00      mov c, 40
0360   0181 19 FF         mov al, $ff
0361   0183             fdc_l0: 
0362   0183 F7            stosb
0363   0184 7E            dec c
0364   0185 C7 83 01      jnz fdc_l0
0365   0188             
0366   0188             fdc_inner_loop:
0367   0188 38 06 00      mov c, 6
0368   018B 19 00         mov al, $00
0369   018D             fdc_l1:
0370   018D F7            stosb
0371   018E 7E            dec c
0372   018F C7 8D 01      jnz fdc_l1
0373   0192             
0374   0192             ; address mark
0375   0192             fdc_l2:
0376   0192 19 FE         mov al, $fe
0377   0194 F7            stosb
0378   0195             
0379   0195             ; track number
0380   0195             fdc_l3:
0381   0195 19 00         mov al, $00
0382   0197 F7            stosb
0383   0198             
0384   0198             ; side number
0385   0198             fdc_l4:
0386   0198 19 00         mov al, $00
0387   019A F7            stosb
0388   019B             
0389   019B             ; sector number
0390   019B             fdc_l5:
0391   019B 13            mov a, d
0392   019C F7            stosb
0393   019D             
0394   019D             ; sector length 128 bytes
0395   019D             fdc_l6:
0396   019D 19 00         mov al, $00
0397   019F F7            stosb
0398   01A0             
0399   01A0             ; 2 crc's
0400   01A0             fdc_l7:
0401   01A0 19 F7         mov al, $f7
0402   01A2 F7            stosb
0403   01A3             
0404   01A3             ; 11 times $ff
0405   01A3 38 0B 00      mov c, 11
0406   01A6 19 FF         mov al, $ff
0407   01A8             fdc_l8:
0408   01A8 F7            stosb
0409   01A9 7E            dec c
0410   01AA C7 A8 01      jnz fdc_l8
0411   01AD             
0412   01AD             ; 6 times 00
0413   01AD 38 06 00      mov c, 6
0414   01B0 19 00         mov al, $00
0415   01B2             fdc_l9:
0416   01B2 F7            stosb
0417   01B3 7E            dec c
0418   01B4 C7 B2 01      jnz fdc_l9
0419   01B7             
0420   01B7             ; data address mark
0421   01B7 19 FB         mov al, $fb
0422   01B9             fdc_l10:
0423   01B9 F7            stosb
0424   01BA             
0425   01BA             ; sector data
0426   01BA 38 00 00      mov c, 0
0427   01BD             fdc_l11:
0428   01BD 84            mov al, cl
0429   01BE F7            stosb
0430   01BF 78            inc c
0431   01C0 C2 80 00      cmp c, 128
0432   01C3 C7 BD 01      jne fdc_l11
0433   01C6             
0434   01C6             ; 2 crc's
0435   01C6             fdc_l12:
0436   01C6 19 F7         mov al, $f7
0437   01C8 F7            stosb
0438   01C9             
0439   01C9             ; 10 times $ff
0440   01C9 38 0A 00      mov c, 10
0441   01CC 19 FF         mov al, $ff
0442   01CE             fdc_l13:
0443   01CE F7            stosb
0444   01CF 7E            dec c
0445   01D0 C7 CE 01      jnz fdc_l13
0446   01D3             
0447   01D3             ; check whether we did this 16 times
0448   01D3 79            inc d
0449   01D4 C5 11 00      cmp d, 17
0450   01D7 C7 88 01      jne fdc_inner_loop
0451   01DA             
0452   01DA             ; loop ~369 times
0453   01DA 38 90 01      mov c, 400
0454   01DD 19 FF         mov al, $ff
0455   01DF             fdc_format_footer:
0456   01DF             fdc_footer_drq_loop:
0457   01DF F7            stosb
0458   01E0 7E            dec c
0459   01E1 C7 DF 01      jnz fdc_footer_drq_loop
0460   01E4             
0461   01E4 09            ret
0462   01E5             
0463   01E5             ; fetch is 2 cycles long when 'display_reg_load' is false.
0464   01E5             ; 64us amounts to 160 cycles of the 2.5mhz clock
0465   01E5             ; call u16 is 14 cycles long
0466   01E5             ; 160 - 5 - 14 = 
0467   01E5             fdc_wait_64us:
0468   01E5 3A 01         mov cl, 1                       ; 5 cycles
0469   01E7             fdc_wait_64_loop:
0470   01E7 81            dec cl                           ; 3 cycles
0471   01E8 C7 E7 01      jnz fdc_wait_64_loop             ; 8 cycles
0472   01EB 09            ret
0473   01EC             
0474   01EC 00          fdc_irq: .db 0
0475   01ED 0A 66 6F 72 s_format_begin:   .db "\nformatting starting...\n", 0
0475   01F1 6D 61 74 74 
0475   01F5 69 6E 67 20 
0475   01F9 73 74 61 72 
0475   01FD 74 69 6E 67 
0475   0201 2E 2E 2E 0A 
0475   0205 00 
0476   0206 0A 66 6F 72 s_format_done:    .db "\nformatting done.\n", 0
0476   020A 6D 61 74 74 
0476   020E 69 6E 67 20 
0476   0212 64 6F 6E 65 
0476   0216 2E 0A 00 
0477   0219 0A 66 64 63 s_fdc_status:     .db "\nfdc status: ", 0
0477   021D 20 73 74 61 
0477   0221 74 75 73 3A 
0477   0225 20 00 
0478   0227             
0479   0227             ; reboot system
0480   0227             syscall_reboot:
0481   0227 FD D7 FF FF   push word $ffff 
0482   022B FD DB 00      push byte %00000000             ; dma_ack = 0, interrupts disabled, mode = supervisor, paging = off, halt=0, display_reg_load=0, dir=0
0483   022E FD D7 C0 01   push word bios_reset_vector     ; and then push reset vector of the shell to the stack
0484   0232 06            sysret
0485   0233             
0486   0233             ; ------------------------------------------------------------------------------------------------------------------;
0487   0233             ; exceptions code block
0488   0233             ; ------------------------------------------------------------------------------------------------------------------;
0489   0233             ; privilege exception
0490   0233             ; ------------------------------------------------------------------------------------------------------------------;
0491   0233             trap_privilege:
0492   0233 0A 27 02      jmp syscall_reboot
0493   0236 DA            push d
0494   0237 3B 98 09      mov d, s_priviledge
0495   023A 07 76 07      call _puts
0496   023D E7            pop d
0497   023E 06            sysret
0498   023F             
0499   023F             ; ------------------------------------------------------------------------------------------------------------------;
0500   023F             ; divide by zero exception
0501   023F             ; ------------------------------------------------------------------------------------------------------------------;
0502   023F             trap_div_zero:
0503   023F D7            push a
0504   0240 DA            push d
0505   0241 E1            pushf
0506   0242 3B AF 09      mov d, s_divzero
0507   0245 07 76 07      call _puts
0508   0248 EE            popf
0509   0249 E7            pop d
0510   024A E4            pop a
0511   024B 06            sysret ; enable interrupts
0512   024C             
0513   024C             ; ------------------------------------------------------------------------------------------------------------------;
0514   024C             ; undefined opcode exception
0515   024C             ; ------------------------------------------------------------------------------------------------------------------;
0516   024C             trap_undef_opcode:
0517   024C 06            sysret
0518   024D             
0519   024D             ;----------------------------------------------------------------------------------------------------;
0520   024D             ; io syscall
0521   024D             ;----------------------------------------------------------------------------------------------------;
0522   024D             ; baud  divisor
0523   024D             ; 50    2304
0524   024D             ; 110   1047
0525   024D             ; 300    384
0526   024D             ; 600    192
0527   024D             ; 1200    96
0528   024D             ; 9600    12
0529   024D             ; 19200    6
0530   024D             ; 38400    3
0531   024D             syscall_io_jmp:
0532   024D 80 02         .dw syscall_io_putchar
0533   024F 8D 02         .dw syscall_io_getch
0534   0251 57 02         .dw syscall_io_uart_setup
0535   0253             syscall_io:
0536   0253 FD 0A 4D 02   jmp [syscall_io_jmp + al]
0537   0257             ; bit7 is the divisor latch access bit (dlab). it must be set high (logic 1) to access the divisor latches
0538   0257             ; of the baud generator during a read or write operation. it must be set low (logic 0) to access the receiver
0539   0257             ; buffer, the transmitter holding register, or the interrupt enable register.
0540   0257             syscall_io_uart_setup:
0541   0257 1D 72 09      mov al, [sys_uart0_lcr]
0542   025A 8B 80         or al, $80                ; set dlab access bit
0543   025C 3D 83 FF      mov [_uart0_lcr], al      ; 8 data, 2 stop, no parity by default
0544   025F 1D 75 09      mov al, [sys_uart0_div0]
0545   0262 3D 80 FF      mov [_uart0_dlab_0], al   ; divisor latch byte 0
0546   0265 1D 76 09      mov al, [sys_uart0_div1]
0547   0268 3D 81 FF      mov [_uart0_dlab_1], al   ; divisor latch byte 1      
0548   026B             
0549   026B 1D 72 09      mov al, [sys_uart0_lcr]
0550   026E 87 7F         and al, $7f               ; clear dlab access bit 
0551   0270 3D 83 FF      mov [_uart0_lcr], al
0552   0273 1D 73 09      mov al, [sys_uart0_inten]
0553   0276 3D 81 FF      mov [_uart0_ier], al      ; interrupts
0554   0279 1D 74 09      mov al, [sys_uart0_fifoen]
0555   027C 3D 82 FF      mov [_uart0_fcr], al      ; fifo control
0556   027F 06            sysret
0557   0280             
0558   0280             ; char in ah
0559   0280             syscall_io_putchar:
0560   0280             syscall_io_putchar_l0:
0561   0280 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0562   0283 87 20         and al, $20
0563   0285 C6 80 02      jz syscall_io_putchar_l0    
0564   0288 1A            mov al, ah
0565   0289 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0566   028C 06            sysret
0567   028D             
0568   028D             ; char in ah
0569   028D             ; al = sucess code
0570   028D             syscall_io_getch:
0571   028D D8            push b
0572   028E DA            push d
0573   028F FD 0C         sti
0574   0291             syscall_io_getch_l0:  
0575   0291 14 79 09      mov a, [fifo_out]
0576   0294 29 77 09      mov b, [fifo_in]
0577   0297 B0            cmp a, b
0578   0298 C6 91 02      je syscall_io_getch_l0
0579   029B 3C            mov d, a
0580   029C 77            inc a
0581   029D AF 4A 0E      cmp a, fifo + fifo_size      ; check if pointer reached the end of the fifo
0582   02A0 C7 A6 02      jne syscall_io_getch_cont
0583   02A3 10 4A 0A      mov a, fifo  
0584   02A6             syscall_io_getch_cont:  
0585   02A6 42 79 09      mov [fifo_out], a             ; update fifo pointer
0586   02A9 1E            mov al, [d]                   ; get char
0587   02AA 23            mov ah, al
0588   02AB 1D 71 09      mov al, [sys_echo_on]
0589   02AE B9 01         cmp al, 1
0590   02B0 C7 BF 02      jne syscall_io_getch_noecho 
0591   02B3             ; here we just echo the char back to the console
0592   02B3             syscall_io_getch_echo_l0:
0593   02B3 1D 85 FF      mov al, [_uart0_lsr]         ; read line status register
0594   02B6 87 20         and al, $20                 ; isolate transmitter empty
0595   02B8 C6 B3 02      jz syscall_io_getch_echo_l0
0596   02BB 1A            mov al, ah
0597   02BC 3D 80 FF      mov [_uart0_data], al        ; write char to transmitter holding register
0598   02BF             syscall_io_getch_noecho:
0599   02BF 19 01         mov al, 1                    ; al = 1 means a char successfully received
0600   02C1 E7            pop d
0601   02C2 E5            pop b
0602   02C3 06            sysret
0603   02C4             
0604   02C4             ; ---------------------------------------------------------------------
0605   02C4             ; kernel reset vector
0606   02C4             ; ---------------------------------------------------------------------
0607   02C4             kernel_reset_vector:  
0608   02C4 FD 49 FF F7   mov bp, stack_begin
0609   02C8 FD 47 FF F7   mov sp, stack_begin
0610   02CC               
0611   02CC 19 81         mov al, %10000001             ; mask out timer interrupt
0612   02CE FD 0F         stomsk                        
0613   02D0 FD 0C         sti  
0614   02D2             
0615   02D2 0C            lodstat
0616   02D3 87 DF         and al, %11011111             ; disable display register loading
0617   02D5 0D            stostat
0618   02D6               
0619   02D6             ; reset fifo pointers
0620   02D6 10 4A 0A      mov a, fifo
0621   02D9 3B 77 09      mov d, fifo_in
0622   02DC 43            mov [d], a
0623   02DD 3B 79 09      mov d, fifo_out
0624   02E0 43            mov [d], a  
0625   02E1 19 02         mov al, 2
0626   02E3 05 00         syscall sys_io                ; enable uart in interrupt mode
0627   02E5               
0628   02E5 3B 7B 09      mov d, s_kernel_started
0629   02E8 07 76 07      call _puts
0630   02EB             
0631   02EB 3B 3E 05      mov d, str0
0632   02EE 07 76 07      call _puts
0633   02F1               ; first, select drive 1 and de-select drive 0
0634   02F1 3B C0 FF      mov d, $ffc0
0635   02F4 2E 0E         mov bl, %00001110     ; %00001001 : turn led on, disable double density, select side 0, select drive 0, do not select drive 1
0636   02F6 FD 3E         mov [d], bl
0637   02F8             
0638   02F8             
0639   02F8             menu:
0640   02F8 3B A1 04      mov d, s_menu
0641   02FB 07 76 07      call _puts
0642   02FE 07 43 06      call getch
0643   0301 76 30         cmp ah, '0'
0644   0303 C6 36 03      je step_in
0645   0306 76 31         cmp ah, '1'
0646   0308 C6 4E 03      je step_out
0647   030B 76 32         cmp ah, '2'
0648   030D C6 42 03      je restore
0649   0310 76 33         cmp ah, '3'
0650   0312 C6 5A 03      je status1
0651   0315 76 34         cmp ah, '4'
0652   0317 C6 6C 03      je status2
0653   031A 76 35         cmp ah, '5'
0654   031C C6 7E 03      je format
0655   031F 76 36         cmp ah, '6'
0656   0321 C6 98 03      je read
0657   0324 76 37         cmp ah, '7'
0658   0326 C6 AB 03      je read_sec
0659   0329 76 38         cmp ah, '8'
0660   032B C6 05 04      je fdc_options
0661   032E 76 39         cmp ah, '9'
0662   0330 C6 ED 03      je fdc_write_sec
0663   0333 0A F8 02      jmp menu
0664   0336             step_in:
0665   0336 3B C8 FF      mov d, $ffc8    ; wd1770
0666   0339 19 02         mov al, 2       ; setparam call
0667   033B 2E 53         mov bl, %01010011     ; step in
0668   033D FD 3E         mov [d], bl
0669   033F 0A F8 02      jmp menu
0670   0342             restore:
0671   0342             ; send restore command
0672   0342 3B C8 FF      mov d, $ffc8    ; wd1770
0673   0345 19 02         mov al, 2       ; setparam call
0674   0347 2E 03         mov bl, $03     ; restore command, 30ms rate
0675   0349 FD 3E         mov [d], bl
0676   034B 0A F8 02      jmp menu
0677   034E             step_out:
0678   034E 3B C8 FF      mov d, $ffc8    ; wd1770
0679   0351 19 02         mov al, 2       ; setparam call
0680   0353 2E 73         mov bl, %01110011     ; step out
0681   0355 FD 3E         mov [d], bl
0682   0357 0A F8 02      jmp menu
0683   035A             status1:
0684   035A 07 23 07      call printnl
0685   035D 3B C1 FF      mov d, $ffc1    ; wd1770 status 1
0686   0360 19 04         mov al, 4       ; getparam call
0687   0362 32            mov bl, [d]
0688   0363 07 16 08      call print_u8x   ; print bl
0689   0366 07 23 07      call printnl
0690   0369 0A F8 02      jmp menu
0691   036C             status2:
0692   036C 07 23 07      call printnl
0693   036F 3B C8 FF      mov d, $ffc8    ; wd1770 status 
0694   0372 19 04         mov al, 4       ; getparam call
0695   0374 32            mov bl, [d]
0696   0375 07 16 08      call print_u8x   ; print bl
0697   0378 07 23 07      call printnl
0698   037B 0A F8 02      jmp menu
0699   037E             format:
0700   037E 07 77 01      call fdc_format_mem ; fill ram with format
0701   0381 3B 98 04      mov d, s_track
0702   0384 07 76 07      call _puts
0703   0387 07 61 08      call scan_u8x   ; in al
0704   038A 2F            mov bl, al      ; track needs to be in bl
0705   038B 19 00         mov al, 0       ; 0 = format
0706   038D 05 02         syscall sys_fdc_format
0707   038F 3B 06 02      mov d, s_format_done
0708   0392 07 76 07      call _puts
0709   0395 0A F8 02      jmp menu
0710   0398             read:
0711   0398 FD 4F 4A 10   mov di, transient_area
0712   039C 38 A0 0F      mov c, 4000
0713   039F 19 33         mov al, $33
0714   03A1             read_l0:
0715   03A1 F7            stosb
0716   03A2 7E            dec c
0717   03A3 C7 A1 03      jnz read_l0
0718   03A6 05 03         syscall sys_fdc_read
0719   03A8 0A F8 02      jmp menu
0720   03AB             read_sec:
0721   03AB FD 4F 4A 10   mov di, transient_area
0722   03AF 38 80 00      mov c, 128
0723   03B2 19 55         mov al, $55
0724   03B4             read_l1:
0725   03B4 F7            stosb
0726   03B5 7E            dec c
0727   03B6 C7 B4 03      jnz read_l1
0728   03B9 3B D1 03      mov d, s1
0729   03BC 07 76 07      call _puts
0730   03BF 07 61 08      call scan_u8x
0731   03C2 23            mov ah, al
0732   03C3 3B DA 03      mov d, s2
0733   03C6 07 76 07      call _puts
0734   03C9 07 61 08      call scan_u8x ; in al 
0735   03CC 05 04         syscall sys_fdc_read_sec
0736   03CE 0A F8 02      jmp menu
0737   03D1 0A 74 72 61 s1:.db "\ntrack: ", 0
0737   03D5 63 6B 3A 20 
0737   03D9 00 
0738   03DA 0A 73 65 63 s2:.db "\nsector: ", 0
0738   03DE 74 6F 72 3A 
0738   03E2 20 00 
0739   03E4 0A 76 61 6C ss3:.db "\nvalue: ", 0
0739   03E8 75 65 3A 20 
0739   03EC 00 
0740   03ED             
0741   03ED             
0742   03ED             fdc_write_sec:
0743   03ED 3B D1 03      mov d, s1
0744   03F0 07 76 07      call _puts
0745   03F3 07 61 08      call scan_u8x
0746   03F6 23            mov ah, al
0747   03F7 3B DA 03      mov d, s2
0748   03FA 07 76 07      call _puts
0749   03FD 07 61 08      call scan_u8x ; in al
0750   0400 05 05         syscall sys_fdc_write_sec
0751   0402 0A F8 02      jmp menu
0752   0405             
0753   0405             fdc_options:
0754   0405 3B E4 03      mov d, ss3
0755   0408 07 76 07      call _puts
0756   040B 07 61 08      call scan_u8x
0757   040E 3D C0 FF      mov [_fdc_config], al
0758   0411 0A F8 02      jmp menu
0759   0414             
0760   0414             ; b : len
0761   0414             cmd_hexd:
0762   0414 10 4A 10      mov a, transient_area
0763   0417 42 94 04      mov [start], a
0764   041A 11            mov a, b
0765   041B 42 96 04      mov [length], a
0766   041E             
0767   041E 14 94 04    	mov a, [start]
0768   0421 3C            mov d, a        ; dump pointer in d
0769   0422 38 00 00      mov c, 0
0770   0425             dump_loop:
0771   0425 84            mov al, cl
0772   0426 87 0F         and al, $0f
0773   0428 C6 77 04      jz print_base
0774   042B             back:
0775   042B 1E            mov al, [d]        ; read byte
0776   042C 2F            mov bl, al
0777   042D 07 16 08      call print_u8x
0778   0430 10 00 20      mov a, $2000
0779   0433 05 00         syscall sys_io      ; space
0780   0435 84            mov al, cl
0781   0436 87 0F         and al, $0f
0782   0438 B9 0F         cmp al, $0f
0783   043A C6 51 04      je print_ascii
0784   043D             back1:
0785   043D 79            inc d
0786   043E 78            inc c
0787   043F 14 96 04      mov a, [length]
0788   0442 B1            cmp a, c
0789   0443 C7 25 04      jne dump_loop
0790   0446               
0791   0446 10 00 0A      mov a, $0a00
0792   0449 05 00         syscall sys_io
0793   044B 10 00 0D      mov a, $0d00
0794   044E 05 00         syscall sys_io
0795   0450               ;call printnl
0796   0450             
0797   0450 09            ret
0798   0451             print_ascii:
0799   0451 63 10 00      sub d, 16
0800   0454 26 10 00      mov b, 16
0801   0457             print_ascii_l:
0802   0457 79            inc d
0803   0458 1E            mov al, [d]        ; read byte
0804   0459 B9 20         cmp al, $20
0805   045B C8 63 04      jlu dot
0806   045E B9 7E         cmp al, $7e
0807   0460 D0 6B 04      jleu ascii
0808   0463             dot:
0809   0463 10 00 2E      mov a, $2e00
0810   0466 05 00         syscall sys_io
0811   0468 0A 70 04      jmp ascii_continue
0812   046B             ascii:
0813   046B 23            mov ah, al
0814   046C 19 00         mov al, 0
0815   046E 05 00         syscall sys_io
0816   0470             ascii_continue:
0817   0470 FD A9 57 04   loopb print_ascii_l
0818   0474 0A 3D 04      jmp back1
0819   0477             print_base:
0820   0477 10 00 0A      mov a, $0a00
0821   047A 05 00         syscall sys_io
0822   047C 10 00 0D      mov a, $0d00
0823   047F 05 00         syscall sys_io
0824   0481 2D            mov b, d
0825   0482 61 4A 10      sub b, transient_area
0826   0485 07 D2 07      call print_u16x        ; display row
0827   0488 55 4A 10      add b, transient_area
0828   048B 10 00 20      mov a, $2000
0829   048E 05 00         syscall sys_io
0830   0490 0A 2B 04      jmp back
0831   0493             
0832   0493 09            ret
0833   0494             
0834   0494 00 00       start:  .dw 0
0835   0496 00 04       length: .dw 1024
0836   0498             
0837   0498             
0838   0498 0A 74 72 61 s_track: .db "\ntrack: ", 0
0838   049C 63 6B 3A 20 
0838   04A0 00 
0839   04A1             
0840   04A1 0A 30 2E 20 s_menu: .db "\n0. step in\n"
0840   04A5 73 74 65 70 
0840   04A9 20 69 6E 0A 
0841   04AD 31 2E 20 73         .db "1. step out\n", 
0841   04B1 74 65 70 20 
0841   04B5 6F 75 74 0A 
0842   04B9 32 2E 20 72         .db "2. restore\n", 
0842   04BD 65 73 74 6F 
0842   04C1 72 65 0A 
0843   04C4 33 2E 20 72         .db "3. read status 1\n", 
0843   04C8 65 61 64 20 
0843   04CC 73 74 61 74 
0843   04D0 75 73 20 31 
0843   04D4 0A 
0844   04D5 34 2E 20 72         .db "4. read status 2\n", 
0844   04D9 65 61 64 20 
0844   04DD 73 74 61 74 
0844   04E1 75 73 20 32 
0844   04E5 0A 
0845   04E6 35 2E 20 66         .db "5. format track\n", 
0845   04EA 6F 72 6D 61 
0845   04EE 74 20 74 72 
0845   04F2 61 63 6B 0A 
0846   04F6 36 2E 20 72         .db "6. read track\n", 
0846   04FA 65 61 64 20 
0846   04FE 74 72 61 63 
0846   0502 6B 0A 
0847   0504 37 2E 20 72         .db "7. read sector\n", 
0847   0508 65 61 64 20 
0847   050C 73 65 63 74 
0847   0510 6F 72 0A 
0848   0513 38 2E 20 63         .db "8. config\n", 
0848   0517 6F 6E 66 69 
0848   051B 67 0A 
0849   051D 39 2E 20 77         .db "9. write sector\n", 
0849   0521 72 69 74 65 
0849   0525 20 73 65 63 
0849   0529 74 6F 72 0A 
0850   052D 0A 73 65 6C         .db "\nselect option: ", 0
0850   0531 65 63 74 20 
0850   0535 6F 70 74 69 
0850   0539 6F 6E 3A 20 
0850   053D 00 
0851   053E             
0852   053E 0A 73 65 6C str0:   .db "\nselecting drive 1...\n", 0
0852   0542 65 63 74 69 
0852   0546 6E 67 20 64 
0852   054A 72 69 76 65 
0852   054E 20 31 2E 2E 
0852   0552 2E 0A 00 
0853   0555 0A 77 61 69 str1:   .db "\nwaiting...\n", 0
0853   0559 74 69 6E 67 
0853   055D 2E 2E 2E 0A 
0853   0561 00 
0854   0562             
0855   0562             
0856   0562             
0857   0562             ; file includes
0858   0562             .include "bios.exp"         ; to obtain the bios_reset_vector location (for reboots)
0001+  0562             boot_origin      .EQU  $8004
0002+  0562             bios_uart        .EQU  $0002
0003+  0562             bios_ide         .EQU  $0003
0004+  0562             bios_reset_vector .EQU  $01c0
0005+  0562             ide_buffer       .EQU  $8204
0859   0562             .include "lib/stdio.asm"
0001+  0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  0562             ; stdio.s
0003+  0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  0562             .include "lib/string.asm"
0001++ 0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002++ 0562             ; string.s
0003++ 0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004++ 0562             
0005++ 0562             
0006++ 0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0007++ 0562             ; _strrev
0008++ 0562             ; reverse a string
0009++ 0562             ; d = string address
0010++ 0562             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011++ 0562             ; 01234
0012++ 0562             _strrev:
0013++ 0562 4B          	pusha
0014++ 0563 07 A9 05    	call _strlen	; length in c
0015++ 0566 12          	mov a, c
0016++ 0567 AF 01 00    	cmp a, 1
0017++ 056A D0 84 05    	jleu _strrev_end	; check string length. string len must be > 1
0018++ 056D 7D          	dec a
0019++ 056E FD 4E       	mov si, d	; beginning of string
0020++ 0570 FD 50       	mov di, d	; beginning of string (for destinations)
0021++ 0572 59          	add d, a	; end of string
0022++ 0573 12          	mov a, c
0023++ 0574 FD 9B       	shr a		; divide by 2
0024++ 0576 39          	mov c, a	; c now counts the steps
0025++ 0577             _strrev_l0:
0026++ 0577 32          	mov bl, [d]	; save load right-side char into bl
0027++ 0578 F6          	lodsb		; load left-side char into al; increase si
0028++ 0579 3E          	mov [d], al	; store left char into right side
0029++ 057A 1B          	mov al, bl
0030++ 057B F7          	stosb		; store right-side char into left-side; increase di
0031++ 057C 7E          	dec c
0032++ 057D 7F          	dec d
0033++ 057E C2 00 00    	cmp c, 0
0034++ 0581 C7 77 05    	jne _strrev_l0
0035++ 0584             _strrev_end:
0036++ 0584 4C          	popa
0037++ 0585 09          	ret
0038++ 0586             	
0039++ 0586             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0040++ 0586             ; _strchr
0041++ 0586             ; search string in d for char in al
0042++ 0586             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0043++ 0586             _strchr:
0044++ 0586             _strchr_l0:
0045++ 0586 32          	mov bl, [d]
0046++ 0587 C1 00       	cmp bl, 0
0047++ 0589 C6 94 05    	je _strchr_end
0048++ 058C BA          	cmp al, bl
0049++ 058D C6 94 05    	je _strchr_end
0050++ 0590 79          	inc d
0051++ 0591 0A 86 05    	jmp _strchr_l0
0052++ 0594             _strchr_end:
0053++ 0594 1B          	mov al, bl
0054++ 0595 09          	ret
0055++ 0596             
0056++ 0596             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0057++ 0596             ; _strstr
0058++ 0596             ; find sub-string
0059++ 0596             ; str1 in si
0060++ 0596             ; str2 in di
0061++ 0596             ; si points to end of source string
0062++ 0596             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0063++ 0596             _strstr:
0064++ 0596 DB          	push al
0065++ 0597 DA          	push d
0066++ 0598 E3          	push di
0067++ 0599             _strstr_loop:
0068++ 0599 F3          	cmpsb					; compare a byte of the strings
0069++ 059A C7 A5 05    	jne _strstr_ret
0070++ 059D FC 00 00    	lea d, [di + 0]
0071++ 05A0 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0072++ 05A2 C7 99 05    	jne _strstr_loop				; equal chars but not at end
0073++ 05A5             _strstr_ret:
0074++ 05A5 F0          	pop di
0075++ 05A6 E7          	pop d
0076++ 05A7 E8          	pop al
0077++ 05A8 09          	ret
0078++ 05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079++ 05A9             ; length of null terminated string
0080++ 05A9             ; result in c
0081++ 05A9             ; pointer in d
0082++ 05A9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083++ 05A9             _strlen:
0084++ 05A9 DA          	push d
0085++ 05AA 38 00 00    	mov c, 0
0086++ 05AD             _strlen_l1:
0087++ 05AD BD 00       	cmp byte [d], 0
0088++ 05AF C6 B7 05    	je _strlen_ret
0089++ 05B2 79          	inc d
0090++ 05B3 78          	inc c
0091++ 05B4 0A AD 05    	jmp _strlen_l1
0092++ 05B7             _strlen_ret:
0093++ 05B7 E7          	pop d
0094++ 05B8 09          	ret
0095++ 05B9             
0096++ 05B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0097++ 05B9             ; strcmp
0098++ 05B9             ; compare two strings
0099++ 05B9             ; str1 in si
0100++ 05B9             ; str2 in di
0101++ 05B9             ; create a string compairon instrucion ?????
0102++ 05B9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0103++ 05B9             _strcmp:
0104++ 05B9 DB          	push al
0105++ 05BA DA          	push d
0106++ 05BB E3          	push di
0107++ 05BC E2          	push si
0108++ 05BD             _strcmp_loop:
0109++ 05BD F3          	cmpsb					; compare a byte of the strings
0110++ 05BE C7 C9 05    	jne _strcmp_ret
0111++ 05C1 FB FF FF    	lea d, [si +- 1]
0112++ 05C4 BD 00       	cmp byte[d], 0				; check if at end of string (null)
0113++ 05C6 C7 BD 05    	jne _strcmp_loop				; equal chars but not at end
0114++ 05C9             _strcmp_ret:
0115++ 05C9 EF          	pop si
0116++ 05CA F0          	pop di
0117++ 05CB E7          	pop d
0118++ 05CC E8          	pop al
0119++ 05CD 09          	ret
0120++ 05CE             
0121++ 05CE             
0122++ 05CE             ; strcpy
0123++ 05CE             ; copy null terminated string from si to di
0124++ 05CE             ; source in si
0125++ 05CE             ; destination in di
0126++ 05CE             _strcpy:
0127++ 05CE E2          	push si
0128++ 05CF E3          	push di
0129++ 05D0 DB          	push al
0130++ 05D1             _strcpy_l1:
0131++ 05D1 F6          	lodsb
0132++ 05D2 F7          	stosb
0133++ 05D3 B9 00       	cmp al, 0
0134++ 05D5 C7 D1 05    	jne _strcpy_l1
0135++ 05D8             _strcpy_end:
0136++ 05D8 E8          	pop al
0137++ 05D9 F0          	pop di
0138++ 05DA EF          	pop si
0139++ 05DB 09          	ret
0140++ 05DC             
0141++ 05DC             ; strcat
0142++ 05DC             ; concatenate a null terminated string into string at di, from string at si
0143++ 05DC             ; source in si
0144++ 05DC             ; destination in di
0145++ 05DC             _strcat:
0146++ 05DC E2          	push si
0147++ 05DD E3          	push di
0148++ 05DE D7          	push a
0149++ 05DF DA          	push d
0150++ 05E0 50          	mov a, di
0151++ 05E1 3C          	mov d, a
0152++ 05E2             _strcat_goto_end_l1:
0153++ 05E2 BD 00       	cmp byte[d], 0
0154++ 05E4 C6 EB 05    	je _strcat_start
0155++ 05E7 79          	inc d
0156++ 05E8 0A E2 05    	jmp _strcat_goto_end_l1
0157++ 05EB             _strcat_start:
0158++ 05EB FD 50       	mov di, d
0159++ 05ED             _strcat_l1:
0160++ 05ED F6          	lodsb
0161++ 05EE F7          	stosb
0162++ 05EF B9 00       	cmp al, 0
0163++ 05F1 C7 ED 05    	jne _strcat_l1
0164++ 05F4             _strcat_end:
0165++ 05F4 E7          	pop d
0166++ 05F5 E4          	pop a
0167++ 05F6 F0          	pop di
0168++ 05F7 EF          	pop si
0169++ 05F8 09          	ret
0170++ 05F9             
0171++ 05F9             
0005+  05F9             
0006+  05F9             
0007+  05F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0008+  05F9             ; convert ascii 'o'..'f' to integer 0..15
0009+  05F9             ; ascii in bl
0010+  05F9             ; result in al
0011+  05F9             ; ascii for f = 0100 0110
0012+  05F9             ; ascii for 9 = 0011 1001
0013+  05F9             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0014+  05F9             hex_ascii_encode:
0015+  05F9 1B            mov al, bl
0016+  05FA 93 40         test al, $40        ; test if letter or number
0017+  05FC C7 02 06      jnz hex_letter
0018+  05FF 87 0F         and al, $0f        ; get number
0019+  0601 09            ret
0020+  0602             hex_letter:
0021+  0602 87 0F         and al, $0f        ; get letter
0022+  0604 6A 09         add al, 9
0023+  0606 09            ret
0024+  0607             
0025+  0607             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0026+  0607             ; atoi
0027+  0607             ; 2 letter hex string in b
0028+  0607             ; 8bit integer returned in al
0029+  0607             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0030+  0607             _atoi:
0031+  0607 D8            push b
0032+  0608 07 F9 05      call hex_ascii_encode      ; convert bl to 4bit code in al
0033+  060B 30            mov bl, bh
0034+  060C DB            push al          ; save a
0035+  060D 07 F9 05      call hex_ascii_encode
0036+  0610 EA            pop bl  
0037+  0611 FD 9E 04      shl al, 4
0038+  0614 8C            or al, bl
0039+  0615 E5            pop b
0040+  0616 09            ret  
0041+  0617             
0042+  0617             
0043+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0044+  0617             ; scanf
0045+  0617             ; no need for explanations!
0046+  0617             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0047+  0617             scanf:
0048+  0617 09            ret
0049+  0618             
0050+  0618             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0051+  0618             ; itoa
0052+  0618             ; 8bit value in bl
0053+  0618             ; 2 byte ascii result in a
0054+  0618             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0055+  0618             _itoa:
0056+  0618 DA            push d
0057+  0619 D8            push b
0058+  061A A7 00         mov bh, 0
0059+  061C FD A4 04      shr bl, 4  
0060+  061F 74            mov d, b
0061+  0620 1F B2 08      mov al, [d + s_hex_digits]
0062+  0623 23            mov ah, al
0063+  0624               
0064+  0624 E5            pop b
0065+  0625 D8            push b
0066+  0626 A7 00         mov bh, 0
0067+  0628 FD 87 0F      and bl, $0f
0068+  062B 74            mov d, b
0069+  062C 1F B2 08      mov al, [d + s_hex_digits]
0070+  062F E5            pop b
0071+  0630 E7            pop d
0072+  0631 09            ret
0073+  0632             
0074+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0075+  0632             ; hex string to binary
0076+  0632             ; di = destination address
0077+  0632             ; si = source
0078+  0632             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0079+  0632             _hex_to_int:
0080+  0632             _hex_to_int_l1:
0081+  0632 F6            lodsb          ; load from [si] to al
0082+  0633 B9 00         cmp al, 0        ; check if ascii 0
0083+  0635 C6 42 06      jz _hex_to_int_ret
0084+  0638 36            mov bh, al
0085+  0639 F6            lodsb
0086+  063A 2F            mov bl, al
0087+  063B 07 07 06      call _atoi        ; convert ascii byte in b to int (to al)
0088+  063E F7            stosb          ; store al to [di]
0089+  063F 0A 32 06      jmp _hex_to_int_l1
0090+  0642             _hex_to_int_ret:
0091+  0642 09            ret    
0092+  0643             
0093+  0643             
0094+  0643             
0095+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0096+  0643             ; getchar
0097+  0643             ; char in ah
0098+  0643             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0099+  0643             getch:
0100+  0643 DB            push al
0101+  0644             getch_retry:
0102+  0644 19 01         mov al, 1
0103+  0646 05 00         syscall sys_io      ; receive in ah
0104+  0648 E8            pop al
0105+  0649 09            ret
0106+  064A             
0107+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0108+  064A             ; putchar
0109+  064A             ; char in ah
0110+  064A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0111+  064A             _putchar:
0112+  064A DB            push al
0113+  064B 19 00         mov al, 0
0114+  064D 05 00         syscall sys_io      ; char in ah
0115+  064F E8            pop al
0116+  0650 09            ret
0117+  0651             
0118+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0119+  0651             ;; input a string
0120+  0651             ;; terminates with null
0121+  0651             ;; pointer in d
0122+  0651             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0123+  0651             _gets:
0124+  0651 D7            push a
0125+  0652 DA            push d
0126+  0653             _gets_loop:
0127+  0653 19 01         mov al, 1
0128+  0655 05 00         syscall sys_io      ; receive in ah
0129+  0657 76 1B         cmp ah, 27
0130+  0659 C6 7A 06      je _gets_ansi_esc
0131+  065C 76 0A         cmp ah, $0a        ; lf
0132+  065E C6 D6 06      je _gets_end
0133+  0661 76 0D         cmp ah, $0d        ; cr
0134+  0663 C6 D6 06      je _gets_end
0135+  0666 76 5C         cmp ah, $5c        ; '\\'
0136+  0668 C6 9C 06      je _gets_escape
0137+  066B 76 08         cmp ah, $08      ; check for backspace
0138+  066D C6 76 06      je _gets_backspace
0139+  0670 1A            mov al, ah
0140+  0671 3E            mov [d], al
0141+  0672 79            inc d
0142+  0673 0A 53 06      jmp _gets_loop
0143+  0676             _gets_backspace:
0144+  0676 7F            dec d
0145+  0677 0A 53 06      jmp _gets_loop
0146+  067A             _gets_ansi_esc:
0147+  067A 19 01         mov al, 1
0148+  067C 05 00         syscall sys_io        ; receive in ah without echo
0149+  067E 76 5B         cmp ah, '['
0150+  0680 C7 53 06      jne _gets_loop
0151+  0683 19 01         mov al, 1
0152+  0685 05 00         syscall sys_io          ; receive in ah without echo
0153+  0687 76 64         cmp ah, 'd'
0154+  0689 C6 94 06      je _gets_left_arrow
0155+  068C 76 63         cmp ah, 'c'
0156+  068E C6 98 06      je _gets_right_arrow
0157+  0691 0A 53 06      jmp _gets_loop
0158+  0694             _gets_left_arrow:
0159+  0694 7F            dec d
0160+  0695 0A 53 06      jmp _gets_loop
0161+  0698             _gets_right_arrow:
0162+  0698 79            inc d
0163+  0699 0A 53 06      jmp _gets_loop
0164+  069C             _gets_escape:
0165+  069C 19 01         mov al, 1
0166+  069E 05 00         syscall sys_io      ; receive in ah
0167+  06A0 76 6E         cmp ah, 'n'
0168+  06A2 C6 C1 06      je _gets_lf
0169+  06A5 76 72         cmp ah, 'r'
0170+  06A7 C6 C8 06      je _gets_cr
0171+  06AA 76 30         cmp ah, '0'
0172+  06AC C6 CF 06      je _gets_null
0173+  06AF 76 5C         cmp ah, $5c  ; '\'
0174+  06B1 C6 BA 06      je _gets_slash
0175+  06B4 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0176+  06B5 3E            mov [d], al
0177+  06B6 79            inc d
0178+  06B7 0A 53 06      jmp _gets_loop
0179+  06BA             _gets_slash:
0180+  06BA 19 5C         mov al, $5c
0181+  06BC 3E            mov [d], al
0182+  06BD 79            inc d
0183+  06BE 0A 53 06      jmp _gets_loop
0184+  06C1             _gets_lf:
0185+  06C1 19 0A         mov al, $0a
0186+  06C3 3E            mov [d], al
0187+  06C4 79            inc d
0188+  06C5 0A 53 06      jmp _gets_loop
0189+  06C8             _gets_cr:
0190+  06C8 19 0D         mov al, $0d
0191+  06CA 3E            mov [d], al
0192+  06CB 79            inc d
0193+  06CC 0A 53 06      jmp _gets_loop
0194+  06CF             _gets_null:
0195+  06CF 19 00         mov al, $00
0196+  06D1 3E            mov [d], al
0197+  06D2 79            inc d
0198+  06D3 0A 53 06      jmp _gets_loop
0199+  06D6             _gets_end:
0200+  06D6 19 00         mov al, 0
0201+  06D8 3E            mov [d], al        ; terminate string
0202+  06D9 E7            pop d
0203+  06DA E4            pop a
0204+  06DB 09            ret
0205+  06DC             
0206+  06DC             
0207+  06DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0208+  06DC             ;; input text
0209+  06DC             ;; terminated with ctrl+d
0210+  06DC             ;; pointer in d
0211+  06DC             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0212+  06DC             _gettxt:
0213+  06DC D7            push a
0214+  06DD DA            push d
0215+  06DE             _gettxt_loop:
0216+  06DE 19 01         mov al, 1
0217+  06E0 05 00         syscall sys_io      ; receive in ah
0218+  06E2 76 04         cmp ah, 4      ; eot
0219+  06E4 C6 1D 07      je _gettxt_end
0220+  06E7 76 08         cmp ah, $08      ; check for backspace
0221+  06E9 C6 19 07      je _gettxt_backspace
0222+  06EC 76 5C         cmp ah, $5c        ; '\'
0223+  06EE C6 F7 06      je _gettxt_escape
0224+  06F1 1A            mov al, ah
0225+  06F2 3E            mov [d], al
0226+  06F3 79            inc d
0227+  06F4 0A DE 06      jmp _gettxt_loop
0228+  06F7             _gettxt_escape:
0229+  06F7 19 01         mov al, 1
0230+  06F9 05 00         syscall sys_io      ; receive in ah
0231+  06FB 76 6E         cmp ah, 'n'
0232+  06FD C6 0B 07      je _gettxt_lf
0233+  0700 76 72         cmp ah, 'r'
0234+  0702 C6 12 07      je _gettxt_cr
0235+  0705 1A            mov al, ah        ; if not a known escape, it is just a normal letter
0236+  0706 3E            mov [d], al
0237+  0707 79            inc d
0238+  0708 0A DE 06      jmp _gettxt_loop
0239+  070B             _gettxt_lf:
0240+  070B 19 0A         mov al, $0a
0241+  070D 3E            mov [d], al
0242+  070E 79            inc d
0243+  070F 0A DE 06      jmp _gettxt_loop
0244+  0712             _gettxt_cr:
0245+  0712 19 0D         mov al, $0d
0246+  0714 3E            mov [d], al
0247+  0715 79            inc d
0248+  0716 0A DE 06      jmp _gettxt_loop
0249+  0719             _gettxt_backspace:
0250+  0719 7F            dec d
0251+  071A 0A DE 06      jmp _gettxt_loop
0252+  071D             _gettxt_end:
0253+  071D 19 00         mov al, 0
0254+  071F 3E            mov [d], al        ; terminate string
0255+  0720 E7            pop d
0256+  0721 E4            pop a
0257+  0722 09            ret
0258+  0723             
0259+  0723             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0260+  0723             ; print new line
0261+  0723             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0262+  0723             printnl:
0263+  0723 D7            push a
0264+  0724 10 00 0A      mov a, $0a00
0265+  0727 05 00         syscall sys_io
0266+  0729 10 00 0D      mov a, $0d00
0267+  072C 05 00         syscall sys_io
0268+  072E E4            pop a
0269+  072F 09            ret
0270+  0730             
0271+  0730             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0272+  0730             ; _strtoint
0273+  0730             ; 4 digit hex string number in d
0274+  0730             ; integer returned in a
0275+  0730             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0276+  0730             _strtointx:
0277+  0730 D8            push b
0278+  0731 32            mov bl, [d]
0279+  0732 37            mov bh, bl
0280+  0733 33 01 00      mov bl, [d + 1]
0281+  0736 07 07 06      call _atoi        ; convert to int in al
0282+  0739 23            mov ah, al        ; move to ah
0283+  073A 33 02 00      mov bl, [d + 2]
0284+  073D 37            mov bh, bl
0285+  073E 33 03 00      mov bl, [d + 3]
0286+  0741 07 07 06      call _atoi        ; convert to int in al
0287+  0744 E5            pop b
0288+  0745 09            ret
0289+  0746             
0290+  0746             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0291+  0746             ; _strtoint
0292+  0746             ; 5 digit base10 string number in d
0293+  0746             ; integer returned in a
0294+  0746             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0295+  0746             _strtoint:
0296+  0746 E2            push si
0297+  0747 D8            push b
0298+  0748 D9            push c
0299+  0749 DA            push d
0300+  074A 07 A9 05      call _strlen      ; get string length in c
0301+  074D 7E            dec c
0302+  074E FD 4E         mov si, d
0303+  0750 12            mov a, c
0304+  0751 FD 99         shl a
0305+  0753 3B CA 08      mov d, table_power
0306+  0756 59            add d, a
0307+  0757 38 00 00      mov c, 0
0308+  075A             _strtoint_l0:
0309+  075A F6            lodsb      ; load ascii to al
0310+  075B B9 00         cmp al, 0
0311+  075D C6 70 07      je _strtoint_end
0312+  0760 6F 30         sub al, $30    ; make into integer
0313+  0762 22 00         mov ah, 0
0314+  0764 2A            mov b, [d]
0315+  0765 AC            mul a, b      ; result in b since it fits in 16bits
0316+  0766 11            mov a, b
0317+  0767 28            mov b, c
0318+  0768 54            add a, b
0319+  0769 39            mov c, a
0320+  076A 63 02 00      sub d, 2
0321+  076D 0A 5A 07      jmp _strtoint_l0
0322+  0770             _strtoint_end:
0323+  0770 12            mov a, c
0324+  0771 E7            pop d
0325+  0772 E6            pop c
0326+  0773 E5            pop b
0327+  0774 EF            pop si
0328+  0775 09            ret
0329+  0776             
0330+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0331+  0776             ; print null terminated string
0332+  0776             ; pointer in d
0333+  0776             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0334+  0776             _puts:
0335+  0776 D7            push a
0336+  0777 DA            push d
0337+  0778             _puts_l1:
0338+  0778 1E            mov al, [d]
0339+  0779 B9 00         cmp al, 0
0340+  077B C6 87 07      jz _puts_end
0341+  077E 23            mov ah, al
0342+  077F 19 00         mov al, 0
0343+  0781 05 00         syscall sys_io
0344+  0783 79            inc d
0345+  0784 0A 78 07      jmp _puts_l1
0346+  0787             _puts_end:
0347+  0787 E7            pop d
0348+  0788 E4            pop a
0349+  0789 09            ret
0350+  078A             
0351+  078A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0352+  078A             ; print n size string
0353+  078A             ; pointer in d
0354+  078A             ; size in c
0355+  078A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0356+  078A             _putsn:
0357+  078A DB            push al
0358+  078B DA            push d
0359+  078C D9            push c
0360+  078D             _putsn_l0:
0361+  078D 1E            mov al, [d]
0362+  078E 23            mov ah, al
0363+  078F 19 00         mov al, 0
0364+  0791 05 00         syscall sys_io
0365+  0793 79            inc d
0366+  0794 7E            dec c  
0367+  0795 C2 00 00      cmp c, 0
0368+  0798 C7 8D 07      jne _putsn_l0
0369+  079B             _putsn_end:
0370+  079B E6            pop c
0371+  079C E7            pop d
0372+  079D E8            pop al
0373+  079E 09            ret
0374+  079F             
0375+  079F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0376+  079F             ; print 16bit decimal number
0377+  079F             ; input number in a
0378+  079F             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0379+  079F             print_u16d:
0380+  079F D7            push a
0381+  07A0 D8            push b
0382+  07A1 FD D8         push g
0383+  07A3 26 10 27      mov b, 10000
0384+  07A6 AE            div a, b      ; get 10000's coeff.
0385+  07A7 07 CB 07      call print_number
0386+  07AA 11            mov a, b
0387+  07AB 26 E8 03      mov b, 1000
0388+  07AE AE            div a, b      ; get 1000's coeff.
0389+  07AF 07 CB 07      call print_number
0390+  07B2 11            mov a, b
0391+  07B3 26 64 00      mov b, 100
0392+  07B6 AE            div a, b
0393+  07B7 07 CB 07      call print_number
0394+  07BA 11            mov a, b
0395+  07BB 26 0A 00      mov b, 10
0396+  07BE AE            div a, b
0397+  07BF 07 CB 07      call print_number
0398+  07C2 1B            mov al, bl      ; 1's coeff in bl
0399+  07C3 07 CB 07      call print_number
0400+  07C6 FD F1         pop g
0401+  07C8 E5            pop b
0402+  07C9 E4            pop a
0403+  07CA 09            ret
0404+  07CB             
0405+  07CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0406+  07CB             ; print al
0407+  07CB             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0408+  07CB             print_number:
0409+  07CB 6A 30         add al, $30
0410+  07CD 23            mov ah, al
0411+  07CE 07 4A 06      call _putchar
0412+  07D1 09            ret
0413+  07D2             
0414+  07D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0415+  07D2             ; print 16bit hex integer
0416+  07D2             ; integer value in reg b
0417+  07D2             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0418+  07D2             print_u16x:
0419+  07D2 D7            push a
0420+  07D3 D8            push b
0421+  07D4 DD            push bl
0422+  07D5 30            mov bl, bh
0423+  07D6 07 18 06      call _itoa        ; convert bh to char in a
0424+  07D9 2F            mov bl, al        ; save al
0425+  07DA 19 00         mov al, 0
0426+  07DC 05 00         syscall sys_io        ; display ah
0427+  07DE 24            mov ah, bl        ; retrieve al
0428+  07DF 19 00         mov al, 0
0429+  07E1 05 00         syscall sys_io        ; display al
0430+  07E3             
0431+  07E3 EA            pop bl
0432+  07E4 07 18 06      call _itoa        ; convert bh to char in a
0433+  07E7 2F            mov bl, al        ; save al
0434+  07E8 19 00         mov al, 0
0435+  07EA 05 00         syscall sys_io        ; display ah
0436+  07EC 24            mov ah, bl        ; retrieve al
0437+  07ED 19 00         mov al, 0
0438+  07EF 05 00         syscall sys_io        ; display al
0439+  07F1             
0440+  07F1 E5            pop b
0441+  07F2 E4            pop a
0442+  07F3 09            ret
0443+  07F4             
0444+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0445+  07F4             ; input 16bit hex integer
0446+  07F4             ; read 16bit integer into a
0447+  07F4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0448+  07F4             scan_u16x:
0449+  07F4 F8 10 00      enter 16
0450+  07F7 D8            push b
0451+  07F8 DA            push d
0452+  07F9             
0453+  07F9 FA F1 FF      lea d, [bp + -15]
0454+  07FC 07 51 06      call _gets        ; get number
0455+  07FF             
0456+  07FF 32            mov bl, [d]
0457+  0800 37            mov bh, bl
0458+  0801 33 01 00      mov bl, [d + 1]
0459+  0804 07 07 06      call _atoi        ; convert to int in al
0460+  0807 23            mov ah, al        ; move to ah
0461+  0808             
0462+  0808 33 02 00      mov bl, [d + 2]
0463+  080B 37            mov bh, bl
0464+  080C 33 03 00      mov bl, [d + 3]
0465+  080F 07 07 06      call _atoi        ; convert to int in al
0466+  0812             
0467+  0812 E7            pop d
0468+  0813 E5            pop b
0469+  0814 F9            leave
0470+  0815 09            ret
0471+  0816             
0472+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0473+  0816             ; print 8bit hex integer
0474+  0816             ; integer value in reg bl
0475+  0816             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0476+  0816             print_u8x:
0477+  0816 D7            push a
0478+  0817 DD            push bl
0479+  0818             
0480+  0818 07 18 06      call _itoa        ; convert bl to char in a
0481+  081B 2F            mov bl, al        ; save al
0482+  081C 19 00         mov al, 0
0483+  081E 05 00         syscall sys_io        ; display ah
0484+  0820 24            mov ah, bl        ; retrieve al
0485+  0821 19 00         mov al, 0
0486+  0823 05 00         syscall sys_io        ; display al
0487+  0825             
0488+  0825 EA            pop bl
0489+  0826 E4            pop a
0490+  0827 09            ret
0491+  0828             
0492+  0828             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0493+  0828             ; print 8bit decimal unsigned number
0494+  0828             ; input number in al
0495+  0828             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0496+  0828             print_u8d:
0497+  0828 D7            push a
0498+  0829 D8            push b
0499+  082A FD D8         push g
0500+  082C 22 00         mov ah, 0
0501+  082E 26 64 00      mov b, 100
0502+  0831 AE            div a, b
0503+  0832 D8            push b      ; save remainder
0504+  0833 B9 00         cmp al, 0
0505+  0835 C6 3F 08      je skip100
0506+  0838 6A 30         add al, $30
0507+  083A 23            mov ah, al
0508+  083B 19 00         mov al, 0
0509+  083D 05 00         syscall sys_io  ; print coeff
0510+  083F             skip100:
0511+  083F E4            pop a
0512+  0840 22 00         mov ah, 0
0513+  0842 26 0A 00      mov b, 10
0514+  0845 AE            div a, b
0515+  0846 D8            push b      ; save remainder
0516+  0847 B9 00         cmp al, 0
0517+  0849 C6 53 08      je skip10
0518+  084C 6A 30         add al, $30
0519+  084E 23            mov ah, al
0520+  084F 19 00         mov al, 0
0521+  0851 05 00         syscall sys_io  ; print coeff
0522+  0853             skip10:
0523+  0853 E4            pop a
0524+  0854 1B            mov al, bl
0525+  0855 6A 30         add al, $30
0526+  0857 23            mov ah, al
0527+  0858 19 00         mov al, 0
0528+  085A 05 00         syscall sys_io  ; print coeff
0529+  085C FD F1         pop g
0530+  085E E5            pop b
0531+  085F E4            pop a
0532+  0860 09            ret
0533+  0861             
0534+  0861             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0535+  0861             ; input 8bit hex integer
0536+  0861             ; read 8bit integer into al
0537+  0861             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0538+  0861             scan_u8x:
0539+  0861 F8 04 00      enter 4
0540+  0864 D8            push b
0541+  0865 DA            push d
0542+  0866             
0543+  0866 FA FD FF      lea d, [bp + -3]
0544+  0869 07 51 06      call _gets        ; get number
0545+  086C             
0546+  086C 32            mov bl, [d]
0547+  086D 37            mov bh, bl
0548+  086E 33 01 00      mov bl, [d + 1]
0549+  0871 07 07 06      call _atoi        ; convert to int in al
0550+  0874             
0551+  0874 E7            pop d
0552+  0875 E5            pop b
0553+  0876 F9            leave
0554+  0877 09            ret
0555+  0878             
0556+  0878             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0557+  0878             ; input decimal number
0558+  0878             ; result in a
0559+  0878             ; 655'\0'
0560+  0878             ; low--------high
0561+  0878             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0562+  0878             scan_u16d:
0563+  0878 F8 08 00      enter 8
0564+  087B E2            push si
0565+  087C D8            push b
0566+  087D D9            push c
0567+  087E DA            push d
0568+  087F FA F9 FF      lea d, [bp +- 7]
0569+  0882 07 51 06      call _gets
0570+  0885 07 A9 05      call _strlen      ; get string length in c
0571+  0888 7E            dec c
0572+  0889 FD 4E         mov si, d
0573+  088B 12            mov a, c
0574+  088C FD 99         shl a
0575+  088E 3B CA 08      mov d, table_power
0576+  0891 59            add d, a
0577+  0892 38 00 00      mov c, 0
0578+  0895             mul_loop:
0579+  0895 F6            lodsb      ; load ascii to al
0580+  0896 B9 00         cmp al, 0
0581+  0898 C6 AB 08      je mul_exit
0582+  089B 6F 30         sub al, $30    ; make into integer
0583+  089D 22 00         mov ah, 0
0584+  089F 2A            mov b, [d]
0585+  08A0 AC            mul a, b      ; result in b since it fits in 16bits
0586+  08A1 11            mov a, b
0587+  08A2 28            mov b, c
0588+  08A3 54            add a, b
0589+  08A4 39            mov c, a
0590+  08A5 63 02 00      sub d, 2
0591+  08A8 0A 95 08      jmp mul_loop
0592+  08AB             mul_exit:
0593+  08AB 12            mov a, c
0594+  08AC E7            pop d
0595+  08AD E6            pop c
0596+  08AE E5            pop b
0597+  08AF EF            pop si
0598+  08B0 F9            leave
0599+  08B1 09            ret
0600+  08B2             
0601+  08B2             
0602+  08B2 30 31 32 33 s_hex_digits:    .db "0123456789abcdef"  
0602+  08B6 34 35 36 37 
0602+  08BA 38 39 61 62 
0602+  08BE 63 64 65 66 
0603+  08C2 1B 5B 32 6A s_telnet_clear:  .db "\033[2j\033[h", 0
0603+  08C6 1B 5B 68 00 
0604+  08CA             
0605+  08CA             table_power:
0606+  08CA 01 00         .dw 1
0607+  08CC 0A 00         .dw 10
0608+  08CE 64 00         .dw 100
0609+  08D0 E8 03         .dw 1000
0610+  08D2 10 27         .dw 100000860   08D4             .include "lib/ctype.asm"
0001+  08D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0002+  08D4             ; ctype.s
0003+  08D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0004+  08D4             
0005+  08D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0006+  08D4             ;; c character classification is an operation provided by a group of functions in the ansi c standard library
0007+  08D4             ;; for the c programming language. these functions are used to test characters for membership in a particular
0008+  08D4             ;; class of characters, such as alphabetic characters, control characters, etc. both single-byte, and wide
0009+  08D4             ;; characters are supported.
0010+  08D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0011+  08D4             ;; _isalnum 
0012+  08D4             ;; _isalpha 
0013+  08D4             ;; islower 
0014+  08D4             ;; isupper 
0015+  08D4             ;; _isdigit 
0016+  08D4             ;; isxdigit
0017+  08D4             ;; iscntrl 
0018+  08D4             ;; isgraph 
0019+  08D4             ;; _isspace 
0020+  08D4             ;; isblank 
0021+  08D4             ;; isprint 
0022+  08D4             ;; ispunct 
0023+  08D4             ;; tolower 
0024+  08D4             ;; toupper
0025+  08D4             
0026+  08D4             
0027+  08D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0028+  08D4             ;; is alphanumeric
0029+  08D4             ;; sets zf according with result
0030+  08D4             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0031+  08D4             _isalnum:
0032+  08D4 07 F1 08    	call _isalpha
0033+  08D7 C6 DD 08    	je _isalnum_exit
0034+  08DA 07 DE 08    	call _isdigit
0035+  08DD             _isalnum_exit:
0036+  08DD 09          	ret	
0037+  08DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0038+  08DE             ;; is digit
0039+  08DE             ;; sets zf according with result
0040+  08DE             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0041+  08DE             _isdigit:
0042+  08DE DB          	push al
0043+  08DF B9 30       	cmp al, '0'
0044+  08E1 C8 ED 08    	jlu _isdigit_false
0045+  08E4 B9 39       	cmp al, '9'
0046+  08E6 D1 ED 08    	jgu _isdigit_false
0047+  08E9 87 00       	and al, 0	; set zf
0048+  08EB E8          	pop al
0049+  08EC 09          	ret
0050+  08ED             _isdigit_false:
0051+  08ED 8B 01       	or al, 1	; clear zf
0052+  08EF E8          	pop al
0053+  08F0 09          	ret	
0054+  08F1             	
0055+  08F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0056+  08F1             ;; is alpha
0057+  08F1             ;; sets zf according with result
0058+  08F1             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0059+  08F1             _isalpha:
0060+  08F1 DB          	push al
0061+  08F2 B9 5F       	cmp al, '_'
0062+  08F4 C6 14 09    	je _isalpha_true
0063+  08F7 B9 2E       	cmp al, '.'
0064+  08F9 C6 14 09    	je _isalpha_true
0065+  08FC B9 61       	cmp al, 'a'
0066+  08FE C8 10 09    	jlu _isalpha_false
0067+  0901 B9 7A       	cmp al, 'z'
0068+  0903 D1 10 09    	jgu _isalpha_false
0069+  0906 B9 7A       	cmp al, 'z'
0070+  0908 D0 14 09    	jleu _isalpha_true
0071+  090B B9 61       	cmp al, 'a'
0072+  090D C9 14 09    	jgeu _isalpha_true
0073+  0910             _isalpha_false:
0074+  0910 8B 01       	or al, 1	; clear zf
0075+  0912 E8          	pop al
0076+  0913 09          	ret
0077+  0914             _isalpha_true:
0078+  0914 87 00       	and al, 0	; set zf
0079+  0916 E8          	pop al
0080+  0917 09          	ret
0081+  0918             
0082+  0918             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0083+  0918             ;; is path-alpha
0084+  0918             ;; sets zf according with result
0085+  0918             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0086+  0918             ispath:
0087+  0918 DB          	push al
0088+  0919 07 DE 08    	call _isdigit
0089+  091C C6 46 09    	je ispath_true
0090+  091F B9 5F       	cmp al, '_'
0091+  0921 C6 46 09    	je ispath_true
0092+  0924 B9 2F       	cmp al, '/'
0093+  0926 C6 46 09    	je ispath_true
0094+  0929 B9 2E       	cmp al, '.'
0095+  092B C6 46 09    	je ispath_true
0096+  092E B9 61       	cmp al, 'a'
0097+  0930 C8 42 09    	jlu ispath_false
0098+  0933 B9 7A       	cmp al, 'z'
0099+  0935 D1 42 09    	jgu ispath_false
0100+  0938 B9 7A       	cmp al, 'z'
0101+  093A D0 46 09    	jleu ispath_true
0102+  093D B9 61       	cmp al, 'a'
0103+  093F C9 46 09    	jgeu ispath_true
0104+  0942             ispath_false:
0105+  0942 8B 01       	or al, 1	; clear zf
0106+  0944 E8          	pop al
0107+  0945 09          	ret
0108+  0946             ispath_true:
0109+  0946 87 00       	and al, 0	; set zf
0110+  0948 E8          	pop al
0111+  0949 09          	ret
0112+  094A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0113+  094A             ;; is space
0114+  094A             ;; sets zf according with result
0115+  094A             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0116+  094A             _isspace:
0117+  094A B9 20       	cmp al, $20		; ' '
0118+  094C C6 60 09    	je _isspace_exit
0119+  094F B9 09       	cmp al, $09		; '\t'
0120+  0951 C6 60 09    	je _isspace_exit
0121+  0954 B9 0A       	cmp al, $0a		; '\n'
0122+  0956 C6 60 09    	je _isspace_exit
0123+  0959 B9 0D       	cmp al, $0d		; '\r'
0124+  095B C6 60 09    	je _isspace_exit
0125+  095E B9 0B       	cmp al, $0b		; '\v'
0126+  0960             _isspace_exit:
0127+  0960 09          	ret	
0128+  0961             
0129+  0961             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0130+  0961             ; to lower
0131+  0961             ; input in al
0132+  0961             ; output in al
0133+  0961             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0134+  0961             _to_lower:
0135+  0961 B9 7A       	cmp al, 'z'
0136+  0963 D1 68 09    	jgu _to_lower_ret
0137+  0966 6A 20       	add al, $20				; convert to lower case
0138+  0968             _to_lower_ret:
0139+  0968 09          	ret
0140+  0969             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0141+  0969             ; to upper
0142+  0969             ; input in al
0143+  0969             ; output in al
0144+  0969             ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0145+  0969             _to_upper:
0146+  0969 B9 61       	cmp al, 'a'
0147+  096B C8 70 09    	jlu _to_upper_ret
0148+  096E 6F 20       	sub al, $20			; convert to upper case
0149+  0970             _to_upper_ret:
0150+  0970 09          	ret
0151+  0971             
0861   0971             
0862   0971             ; kernel parameters
0863   0971             sys_echo_on:
0864   0971 01            .db 1
0865   0972             sys_uart0_lcr:
0866   0972 07            .db $07 ; 8 data bits, 2 stop bit, no parity
0867   0973             sys_uart0_inten:
0868   0973 01            .db 1
0869   0974             sys_uart0_fifoen:
0870   0974 00            .db 0
0871   0975             sys_uart0_div0:
0872   0975 0C            .db 12  ;
0873   0976             sys_uart0_div1:
0874   0976 00            .db 0   ; default baud = 9600
0875   0977             ; baud  divisor
0876   0977             ; 50    2304
0877   0977             ; 110   1047
0878   0977             ; 300    384
0879   0977             ; 600    192
0880   0977             ; 1200    96
0881   0977             ; 9600    12
0882   0977             ; 19200    6
0883   0977             ; 38400    3
0884   0977             
0885   0977             
0886   0977             fifo_in:
0887   0977 4A 0A         .dw fifo
0888   0979             fifo_out:
0889   0979 4A 0A         .dw fifo
0890   097B             
0891   097B             
0892   097B             s_kernel_started:
0893   097B 6B 65 72 6E   .db "kernel started(version 1.0)\n", 0
0893   097F 65 6C 20 73 
0893   0983 74 61 72 74 
0893   0987 65 64 28 76 
0893   098B 65 72 73 69 
0893   098F 6F 6E 20 31 
0893   0993 2E 30 29 0A 
0893   0997 00 
0894   0998             s_priviledge:
0895   0998 0A 65 78 63   .db "\nexception: privilege\n", 0
0895   099C 65 70 74 69 
0895   09A0 6F 6E 3A 20 
0895   09A4 70 72 69 76 
0895   09A8 69 6C 65 67 
0895   09AC 65 0A 00 
0896   09AF             s_divzero:
0897   09AF 0A 65 78 63   .db "\nexception: zero division\n", 0
0897   09B3 65 70 74 69 
0897   09B7 6F 6E 3A 20 
0897   09BB 7A 65 72 6F 
0897   09BF 20 64 69 76 
0897   09C3 69 73 69 6F 
0897   09C7 6E 0A 00 
0898   09CA             
0899   09CA             fdc_sec_data:
0900   09CA FF EE E0 55   .db $ff, $ee, $e0, $55, $66, $33, $42, $aa, $ae, $67, $23, $11, $23, $56, $88, $99,
0900   09CE 66 33 42 AA 
0900   09D2 AE 67 23 11 
0900   09D6 23 56 88 99 
0901   09DA 1F 2E 40 53   .db $1f, $2e, $40, $53, $63, $43, $52, $1a, $a4, $67, $03, $31, $43, $56, $48, $f9,
0901   09DE 63 43 52 1A 
0901   09E2 A4 67 03 31 
0901   09E6 43 56 48 F9 
0902   09EA 2F 3E 50 57   .db $2f, $3e, $50, $57, $62, $53, $21, $2a, $a3, $17, $73, $41, $53, $46, $38, $b9,
0902   09EE 62 53 21 2A 
0902   09F2 A3 17 73 41 
0902   09F6 53 46 38 B9 
0903   09FA 6F 4E 20 56   .db $6f, $4e, $20, $56, $67, $63, $20, $6a, $a2, $27, $53, $61, $23, $16, $28, $e9,
0903   09FE 67 63 20 6A 
0903   0A02 A2 27 53 61 
0903   0A06 23 16 28 E9 
0904   0A0A AF 7E 10 52   .db $af, $7e, $10, $52, $62, $73, $18, $5a, $a1, $37, $43, $51, $13, $26, $18, $a9,
0904   0A0E 62 73 18 5A 
0904   0A12 A1 37 43 51 
0904   0A16 13 26 18 A9 
0905   0A1A 6F 3E 90 51   .db $6f, $3e, $90, $51, $63, $03, $18, $4a, $a5, $67, $33, $41, $43, $36, $68, $c9,
0905   0A1E 63 03 18 4A 
0905   0A22 A5 67 33 41 
0905   0A26 43 36 68 C9 
0906   0A2A 8F 5E 60 55   .db $8f, $5e, $60, $55, $68, $23, $18, $3a, $a3, $57, $23, $31, $73, $36, $48, $b9,
0906   0A2E 68 23 18 3A 
0906   0A32 A3 57 23 31 
0906   0A36 73 36 48 B9 
0907   0A3A 2F 1E 40 53   .db $2f, $1e, $40, $53, $69, $13, $19, $3a, $a1, $48, $23, $21, $53, $46, $38, $a9
0907   0A3E 69 13 19 3A 
0907   0A42 A1 48 23 21 
0907   0A46 53 46 38 A9 
0908   0A4A             
0909   0A4A             
0910   0A4A             fifo:
0911   0A4A FF FF FF FF   .fill fifo_size
0911   0A4E FF FF FF FF 
0911   0A52 FF FF FF FF 
0911   0A56 FF FF FF FF 
0911   0A5A FF FF FF FF 
0911   0A5E FF FF FF FF 
0911   0A62 FF FF FF FF 
0911   0A66 FF FF FF FF 
0911   0A6A FF FF FF FF 
0911   0A6E FF FF FF FF 
0911   0A72 FF FF FF FF 
0911   0A76 FF FF FF FF 
0911   0A7A FF FF FF FF 
0911   0A7E FF FF FF FF 
0911   0A82 FF FF FF FF 
0911   0A86 FF FF FF FF 
0911   0A8A FF FF FF FF 
0911   0A8E FF FF FF FF 
0911   0A92 FF FF FF FF 
0911   0A96 FF FF FF FF 
0911   0A9A FF FF FF FF 
0911   0A9E FF FF FF FF 
0911   0AA2 FF FF FF FF 
0911   0AA6 FF FF FF FF 
0911   0AAA FF FF FF FF 
0911   0AAE FF FF FF FF 
0911   0AB2 FF FF FF FF 
0911   0AB6 FF FF FF FF 
0911   0ABA FF FF FF FF 
0911   0ABE FF FF FF FF 
0911   0AC2 FF FF FF FF 
0911   0AC6 FF FF FF FF 
0911   0ACA FF FF FF FF 
0911   0ACE FF FF FF FF 
0911   0AD2 FF FF FF FF 
0911   0AD6 FF FF FF FF 
0911   0ADA FF FF FF FF 
0911   0ADE FF FF FF FF 
0911   0AE2 FF FF FF FF 
0911   0AE6 FF FF FF FF 
0911   0AEA FF FF FF FF 
0911   0AEE FF FF FF FF 
0911   0AF2 FF FF FF FF 
0911   0AF6 FF FF FF FF 
0911   0AFA FF FF FF FF 
0911   0AFE FF FF FF FF 
0911   0B02 FF FF FF FF 
0911   0B06 FF FF FF FF 
0911   0B0A FF FF FF FF 
0911   0B0E FF FF FF FF 
0911   0B12 FF FF FF FF 
0911   0B16 FF FF FF FF 
0911   0B1A FF FF FF FF 
0911   0B1E FF FF FF FF 
0911   0B22 FF FF FF FF 
0911   0B26 FF FF FF FF 
0911   0B2A FF FF FF FF 
0911   0B2E FF FF FF FF 
0911   0B32 FF FF FF FF 
0911   0B36 FF FF FF FF 
0911   0B3A FF FF FF FF 
0911   0B3E FF FF FF FF 
0911   0B42 FF FF FF FF 
0911   0B46 FF FF FF FF 
0911   0B4A FF FF FF FF 
0911   0B4E FF FF FF FF 
0911   0B52 FF FF FF FF 
0911   0B56 FF FF FF FF 
0911   0B5A FF FF FF FF 
0911   0B5E FF FF FF FF 
0911   0B62 FF FF FF FF 
0911   0B66 FF FF FF FF 
0911   0B6A FF FF FF FF 
0911   0B6E FF FF FF FF 
0911   0B72 FF FF FF FF 
0911   0B76 FF FF FF FF 
0911   0B7A FF FF FF FF 
0911   0B7E FF FF FF FF 
0911   0B82 FF FF FF FF 
0911   0B86 FF FF FF FF 
0911   0B8A FF FF FF FF 
0911   0B8E FF FF FF FF 
0911   0B92 FF FF FF FF 
0911   0B96 FF FF FF FF 
0911   0B9A FF FF FF FF 
0911   0B9E FF FF FF FF 
0911   0BA2 FF FF FF FF 
0911   0BA6 FF FF FF FF 
0911   0BAA FF FF FF FF 
0911   0BAE FF FF FF FF 
0911   0BB2 FF FF FF FF 
0911   0BB6 FF FF FF FF 
0911   0BBA FF FF FF FF 
0911   0BBE FF FF FF FF 
0911   0BC2 FF FF FF FF 
0911   0BC6 FF FF FF FF 
0911   0BCA FF FF FF FF 
0911   0BCE FF FF FF FF 
0911   0BD2 FF FF FF FF 
0911   0BD6 FF FF FF FF 
0911   0BDA FF FF FF FF 
0911   0BDE FF FF FF FF 
0911   0BE2 FF FF FF FF 
0911   0BE6 FF FF FF FF 
0911   0BEA FF FF FF FF 
0911   0BEE FF FF FF FF 
0911   0BF2 FF FF FF FF 
0911   0BF6 FF FF FF FF 
0911   0BFA FF FF FF FF 
0911   0BFE FF FF FF FF 
0911   0C02 FF FF FF FF 
0911   0C06 FF FF FF FF 
0911   0C0A FF FF FF FF 
0911   0C0E FF FF FF FF 
0911   0C12 FF FF FF FF 
0911   0C16 FF FF FF FF 
0911   0C1A FF FF FF FF 
0911   0C1E FF FF FF FF 
0911   0C22 FF FF FF FF 
0911   0C26 FF FF FF FF 
0911   0C2A FF FF FF FF 
0911   0C2E FF FF FF FF 
0911   0C32 FF FF FF FF 
0911   0C36 FF FF FF FF 
0911   0C3A FF FF FF FF 
0911   0C3E FF FF FF FF 
0911   0C42 FF FF FF FF 
0911   0C46 FF FF FF FF 
0911   0C4A FF FF FF FF 
0911   0C4E FF FF FF FF 
0911   0C52 FF FF FF FF 
0911   0C56 FF FF FF FF 
0911   0C5A FF FF FF FF 
0911   0C5E FF FF FF FF 
0911   0C62 FF FF FF FF 
0911   0C66 FF FF FF FF 
0911   0C6A FF FF FF FF 
0911   0C6E FF FF FF FF 
0911   0C72 FF FF FF FF 
0911   0C76 FF FF FF FF 
0911   0C7A FF FF FF FF 
0911   0C7E FF FF FF FF 
0911   0C82 FF FF FF FF 
0911   0C86 FF FF FF FF 
0911   0C8A FF FF FF FF 
0911   0C8E FF FF FF FF 
0911   0C92 FF FF FF FF 
0911   0C96 FF FF FF FF 
0911   0C9A FF FF FF FF 
0911   0C9E FF FF FF FF 
0911   0CA2 FF FF FF FF 
0911   0CA6 FF FF FF FF 
0911   0CAA FF FF FF FF 
0911   0CAE FF FF FF FF 
0911   0CB2 FF FF FF FF 
0911   0CB6 FF FF FF FF 
0911   0CBA FF FF FF FF 
0911   0CBE FF FF FF FF 
0911   0CC2 FF FF FF FF 
0911   0CC6 FF FF FF FF 
0911   0CCA FF FF FF FF 
0911   0CCE FF FF FF FF 
0911   0CD2 FF FF FF FF 
0911   0CD6 FF FF FF FF 
0911   0CDA FF FF FF FF 
0911   0CDE FF FF FF FF 
0911   0CE2 FF FF FF FF 
0911   0CE6 FF FF FF FF 
0911   0CEA FF FF FF FF 
0911   0CEE FF FF FF FF 
0911   0CF2 FF FF FF FF 
0911   0CF6 FF FF FF FF 
0911   0CFA FF FF FF FF 
0911   0CFE FF FF FF FF 
0911   0D02 FF FF FF FF 
0911   0D06 FF FF FF FF 
0911   0D0A FF FF FF FF 
0911   0D0E FF FF FF FF 
0911   0D12 FF FF FF FF 
0911   0D16 FF FF FF FF 
0911   0D1A FF FF FF FF 
0911   0D1E FF FF FF FF 
0911   0D22 FF FF FF FF 
0911   0D26 FF FF FF FF 
0911   0D2A FF FF FF FF 
0911   0D2E FF FF FF FF 
0911   0D32 FF FF FF FF 
0911   0D36 FF FF FF FF 
0911   0D3A FF FF FF FF 
0911   0D3E FF FF FF FF 
0911   0D42 FF FF FF FF 
0911   0D46 FF FF FF FF 
0911   0D4A FF FF FF FF 
0911   0D4E FF FF FF FF 
0911   0D52 FF FF FF FF 
0911   0D56 FF FF FF FF 
0911   0D5A FF FF FF FF 
0911   0D5E FF FF FF FF 
0911   0D62 FF FF FF FF 
0911   0D66 FF FF FF FF 
0911   0D6A FF FF FF FF 
0911   0D6E FF FF FF FF 
0911   0D72 FF FF FF FF 
0911   0D76 FF FF FF FF 
0911   0D7A FF FF FF FF 
0911   0D7E FF FF FF FF 
0911   0D82 FF FF FF FF 
0911   0D86 FF FF FF FF 
0911   0D8A FF FF FF FF 
0911   0D8E FF FF FF FF 
0911   0D92 FF FF FF FF 
0911   0D96 FF FF FF FF 
0911   0D9A FF FF FF FF 
0911   0D9E FF FF FF FF 
0911   0DA2 FF FF FF FF 
0911   0DA6 FF FF FF FF 
0911   0DAA FF FF FF FF 
0911   0DAE FF FF FF FF 
0911   0DB2 FF FF FF FF 
0911   0DB6 FF FF FF FF 
0911   0DBA FF FF FF FF 
0911   0DBE FF FF FF FF 
0911   0DC2 FF FF FF FF 
0911   0DC6 FF FF FF FF 
0911   0DCA FF FF FF FF 
0911   0DCE FF FF FF FF 
0911   0DD2 FF FF FF FF 
0911   0DD6 FF FF FF FF 
0911   0DDA FF FF FF FF 
0911   0DDE FF FF FF FF 
0911   0DE2 FF FF FF FF 
0911   0DE6 FF FF FF FF 
0911   0DEA FF FF FF FF 
0911   0DEE FF FF FF FF 
0911   0DF2 FF FF FF FF 
0911   0DF6 FF FF FF FF 
0911   0DFA FF FF FF FF 
0911   0DFE FF FF FF FF 
0911   0E02 FF FF FF FF 
0911   0E06 FF FF FF FF 
0911   0E0A FF FF FF FF 
0911   0E0E FF FF FF FF 
0911   0E12 FF FF FF FF 
0911   0E16 FF FF FF FF 
0911   0E1A FF FF FF FF 
0911   0E1E FF FF FF FF 
0911   0E22 FF FF FF FF 
0911   0E26 FF FF FF FF 
0911   0E2A FF FF FF FF 
0911   0E2E FF FF FF FF 
0911   0E32 FF FF FF FF 
0911   0E36 FF FF FF FF 
0911   0E3A FF FF FF FF 
0911   0E3E FF FF FF FF 
0911   0E42 FF FF FF FF 
0911   0E46 FF FF FF FF 
0912   0E4A             
0913   0E4A             scrap_sector:
0914   0E4A FF FF FF FF   .fill 512         ; scrap sector
0914   0E4E FF FF FF FF 
0914   0E52 FF FF FF FF 
0914   0E56 FF FF FF FF 
0914   0E5A FF FF FF FF 
0914   0E5E FF FF FF FF 
0914   0E62 FF FF FF FF 
0914   0E66 FF FF FF FF 
0914   0E6A FF FF FF FF 
0914   0E6E FF FF FF FF 
0914   0E72 FF FF FF FF 
0914   0E76 FF FF FF FF 
0914   0E7A FF FF FF FF 
0914   0E7E FF FF FF FF 
0914   0E82 FF FF FF FF 
0914   0E86 FF FF FF FF 
0914   0E8A FF FF FF FF 
0914   0E8E FF FF FF FF 
0914   0E92 FF FF FF FF 
0914   0E96 FF FF FF FF 
0914   0E9A FF FF FF FF 
0914   0E9E FF FF FF FF 
0914   0EA2 FF FF FF FF 
0914   0EA6 FF FF FF FF 
0914   0EAA FF FF FF FF 
0914   0EAE FF FF FF FF 
0914   0EB2 FF FF FF FF 
0914   0EB6 FF FF FF FF 
0914   0EBA FF FF FF FF 
0914   0EBE FF FF FF FF 
0914   0EC2 FF FF FF FF 
0914   0EC6 FF FF FF FF 
0914   0ECA FF FF FF FF 
0914   0ECE FF FF FF FF 
0914   0ED2 FF FF FF FF 
0914   0ED6 FF FF FF FF 
0914   0EDA FF FF FF FF 
0914   0EDE FF FF FF FF 
0914   0EE2 FF FF FF FF 
0914   0EE6 FF FF FF FF 
0914   0EEA FF FF FF FF 
0914   0EEE FF FF FF FF 
0914   0EF2 FF FF FF FF 
0914   0EF6 FF FF FF FF 
0914   0EFA FF FF FF FF 
0914   0EFE FF FF FF FF 
0914   0F02 FF FF FF FF 
0914   0F06 FF FF FF FF 
0914   0F0A FF FF FF FF 
0914   0F0E FF FF FF FF 
0914   0F12 FF FF FF FF 
0914   0F16 FF FF FF FF 
0914   0F1A FF FF FF FF 
0914   0F1E FF FF FF FF 
0914   0F22 FF FF FF FF 
0914   0F26 FF FF FF FF 
0914   0F2A FF FF FF FF 
0914   0F2E FF FF FF FF 
0914   0F32 FF FF FF FF 
0914   0F36 FF FF FF FF 
0914   0F3A FF FF FF FF 
0914   0F3E FF FF FF FF 
0914   0F42 FF FF FF FF 
0914   0F46 FF FF FF FF 
0914   0F4A FF FF FF FF 
0914   0F4E FF FF FF FF 
0914   0F52 FF FF FF FF 
0914   0F56 FF FF FF FF 
0914   0F5A FF FF FF FF 
0914   0F5E FF FF FF FF 
0914   0F62 FF FF FF FF 
0914   0F66 FF FF FF FF 
0914   0F6A FF FF FF FF 
0914   0F6E FF FF FF FF 
0914   0F72 FF FF FF FF 
0914   0F76 FF FF FF FF 
0914   0F7A FF FF FF FF 
0914   0F7E FF FF FF FF 
0914   0F82 FF FF FF FF 
0914   0F86 FF FF FF FF 
0914   0F8A FF FF FF FF 
0914   0F8E FF FF FF FF 
0914   0F92 FF FF FF FF 
0914   0F96 FF FF FF FF 
0914   0F9A FF FF FF FF 
0914   0F9E FF FF FF FF 
0914   0FA2 FF FF FF FF 
0914   0FA6 FF FF FF FF 
0914   0FAA FF FF FF FF 
0914   0FAE FF FF FF FF 
0914   0FB2 FF FF FF FF 
0914   0FB6 FF FF FF FF 
0914   0FBA FF FF FF FF 
0914   0FBE FF FF FF FF 
0914   0FC2 FF FF FF FF 
0914   0FC6 FF FF FF FF 
0914   0FCA FF FF FF FF 
0914   0FCE FF FF FF FF 
0914   0FD2 FF FF FF FF 
0914   0FD6 FF FF FF FF 
0914   0FDA FF FF FF FF 
0914   0FDE FF FF FF FF 
0914   0FE2 FF FF FF FF 
0914   0FE6 FF FF FF FF 
0914   0FEA FF FF FF FF 
0914   0FEE FF FF FF FF 
0914   0FF2 FF FF FF FF 
0914   0FF6 FF FF FF FF 
0914   0FFA FF FF FF FF 
0914   0FFE FF FF FF FF 
0914   1002 FF FF FF FF 
0914   1006 FF FF FF FF 
0914   100A FF FF FF FF 
0914   100E FF FF FF FF 
0914   1012 FF FF FF FF 
0914   1016 FF FF FF FF 
0914   101A FF FF FF FF 
0914   101E FF FF FF FF 
0914   1022 FF FF FF FF 
0914   1026 FF FF FF FF 
0914   102A FF FF FF FF 
0914   102E FF FF FF FF 
0914   1032 FF FF FF FF 
0914   1036 FF FF FF FF 
0914   103A FF FF FF FF 
0914   103E FF FF FF FF 
0914   1042 FF FF FF FF 
0914   1046 FF FF FF FF 
0915   104A             transient_area:
0916   104A 00            .db 0             ; beginning of the transient memory area. used for disk reads and other purposes    
0917   104B             
0918   104B             .end
tasm: Number of errors = 0
