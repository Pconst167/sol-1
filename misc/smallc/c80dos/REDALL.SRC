


/* >>>>> MODIFIED SOURCE TO IBM PC VERSION OF THE RED EDITOR. (rdk) <<<<< */


         RED's readme file                                February 4, 1985



            This is  RED's  "read  me"  file.   You  should read this file
	 before using RED or attempting to modify it.  This disk  contains
	 version 6.1 of RED for the IBM PC.

	    You are  getting one of the first copies of the IBM version of
         RED.  While most of RED's code has been stable for a  long  time,
	 there	are  some potential problems with distributing RED for the
	 IBM PC family.   In  particular,   the  code  that  controls  the
	 screen  has  been tested only on a Leading Edge compatible and an
	 IBM PC.  The code has not been tested on either an XT	or  an	AT
	 or on any machine with a color card.

	    If you  have any problem with RED pleas call me collect.  Just
         use the name 'Beta' and I'll accept the charges.  PLEASE do  this
         quickly--you'll  be  helping yourself, helping me and helping all
	 my other customers as well.  In addition,  a reward of  $5.12	is
         cheerfully  paid  to  the first person who finds any bug in RED's
         code.  Typo's in the code  or  in  the  documentation  are  worth
	 $1.28.




			  RED is preconfigured for the PC

	    This disk  contains  the  file  RED.EXE which has already been
	 configured for the IBM PC.  Thus, RED is ready  to  run  and  you
	 can  ignore  Chapter  1  of  the manual.  Indeed, you MUST ignore
	 Chapter 1 of the manual since the configuration  program  is  not
	 supplied for the IBM version of RED.

	    Before you	get  all  excited and fire up RED, please read the
	 next several paragraphs.  The version	of  RED  on  file  RED.EXE
	 works	 somewhat  differently	from  what  is	described  in  the
	 manual.  These changes were made possible because the	PC  has  a
	 standard  keyboard  with some extra keys on it and because the PC
	 usually comes with more memory than older computers.

	 1) You can use the arrow keys, the Home  and  End  keys  and  the
	 Page  up and the Page down keys on the numeric keypad to move the
	 cursor.

	 2)  The Insert and Delete keys on the numeric keypad  insert  and
	 delete  one  line.  The Insert key inserts the new line ABOVE the
	 current line--thus,  the Insert key  works  like  the	LINE  FEED
	 (^j)  key.   The  Delete key on the keypad works just like the ^z
	 key.

	 3)  You  can  get  a  list  of  commands  by  typing  the  "help"
	 command.

	 4)   The  quit  command  comes  as  "standard	equipment" in this
	 version of RED.  Thus, you can exit RED without erasing the  work
	 file  just  by  saying  "quit."   The	next  time you invoke RED,
	 editing will commence just where you left off.  The work file	is


					-1-




         RED's readme file                                February 4, 1985


	 called  @DATA@.TMP and will be left in the current directory.	Do
	 NOT erase this file or work may be lost.

	    A point of clarification.  If you  have  previously  used  the
	 quit  command so that the work file is in your current directory,
	 any argument you put on the command line will	be  ignored.   RED
	 always reloads the work file if it exists.

	 5)  RED.EXE  comes up by default as a "hybrid style" editor.  RED
	 switches to edit mode after all commands and whenever the  up	or
	 down  function  keys  are  pressed.   RED switches to insert mode
	 whenever  the	insert	up  or	insert	down  function	keys   are
	 pressed.   You  can  change  this  behavior  while RED is running
	 using	the  def0ins,	def1ins,  def2ins,   def0edit,	 def1edit,
	 def2edit,  def0over,  def1over  or def2over commands as described
         in the Reference Guide.   If  you  would  like  to  change  RED's
	 default  behavior,  change  the  DEFIMODE,  DEF1MODE and DEF2MODE
	 constants in file RED1.H to whichever value of EDITMODE,  INSMODE
	 or  OVERMODE  that  you  prefer.  Then recompile RED as described
	 below.

	    OK, you should try using RED now.  You need to read  the  rest
	 of this file only if you want to change RED in some way.




				 How to change RED

	    The code  on  this	disk  was  compiled  and  linked using the
	 DeSmet C compiler.  If you have any other compiler you will  need
         to  read  the  last chapter of the RED's Manual for more detailed
	 instructions for  porting  RED.   Basically,  you  will  have	to
	 examine  the  files red6.c and red8.c and rewrite them as needed.
	 You should NOT have to change any other file to get  RED  working
	 on another compiler.

            If you  want  to  change  the functions of RED's keys, look at
	 the definitions in RED.H and the code in  the	function  syscin()
	 on  RED8.C.  You may have to change code in BOTH RED.H and RED8.C
	 to get the effect you want.

	    By the way, I would like to  get  the  code  working  for  the
         Lattice  C  compiler.   I  have  the  compiler,  but really don't
         understand the  workings  of  IBM's  screen  yet,  so  I  haven't
	 rewritten  red6.c  for the Lattice compiler.  (The DeSmet library
	 does all the work--I could use it  without  really  understanding
	 anything.)   I  would	appreciate  it	if someone would send me a
         version  of  red6.c  which  will  work  with  Lattice's  run-time
	 library.

	    Some notes for those of you using DeSmet C:

	 1)   The  file REDCOMP.BAT will compile and link RED.	When using
	 REDCOMP.BAT you must have a copy of STDIO.H (DeSmet version)	in
	 the same directory as REDCOMP.BAT.


					-2-




         RED's readme file                                February 4, 1985



	 2)   The  file REDLINK.BAT will link RED.  When using REDLINK.BAT
	 you  must  have  copies  of  PCIO.O  and  REDFILES  in  the  same
	 directory   as   REDCOMP.BAT.	 The  file  PCIO.O  is	gotten	by
	 assembling PCIO.A (which is supplied with the DeSmet compiler).





















































					-3-

*/

/* END OF THE READ.ME FILE (rdk) */


/* NOW FOLLOWS THE COMPLETE ALL-IN-ONE SOURCE TO THE EDITOR (rdk) */












/* >>>>> RED EDITOR FOR THE IBM PC WITH MODIFICATIONS BY R. D. KEYS <<<<< */

/*
	Header file for RED -- Desmet C version
	Source:  red.h or redh.des
	Version: see below

	Copyright (C) 1983, 1984, 1985 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#define VERSION "Desmet C version 6.3 for MSDOS: April 25, 1985"


/*
	The following constants select the compiler and enable features.
        If     #define'd,  the feature is enabled.
        If NOT #define'd,  the feature is disabled.


	IBM:		code is for the IBM PC/XT/AT
	DESMET: 	code is for the Desmet C compiler.
	LATTICE:	code is for the Lattice C compiler.

	HASSTATIC:	the selected compiler supports statics.
	HASLONG:	the selected compiler supports longs.
	CAST:		the selected compiler supports casts.
	INTSIZE:	must evaluate to sizeof(int).

	HASEDIT:	enables edit mode.
	HELPCMND:	enables help commands.
	SWAP:		enables auto-swapping of dirty blocks.
	SUSPEND:	enables quit and auto-restart of RED.
	DEBUG:		enables checking of block formats.
	ASM:		enables assembly language code.
*/

#define IBM		1
#define DESMET		1
#define HASSTATIC	1
#define CAST		1
#define INTSIZE sizeof(int)
#define SUSPEND 	1
#define HELPCMND	1
#define DEBUG		1

#include <stdio.h>
#include "red1.h"
#include "redbuf.h"


/*
	Define the size of the buffer used by setjmp() and longjmp().
*/

#define JBUFSIZE	12


/*
	Define the standard signon messages.
*/

#define SIGNON	"Welcome to the PC version of RED. (Modified by RDK)."
#define COPYRIGHT "Copyright (C) 1985 by Edward K. Ream."

#ifdef HELPCMND
#define XSIGN  "Type HELP in the command mode to print a help message."
#define XSIGN1 ""
#else
#define XSIGN  ""
#define XSIGN1 ""
#endif


/*
	Define constants describing a text line.
	These constants must be less than the maximum block
	size defined in redbuf.h.
*/

#define MAXLEN	200	/* max chars per line */
#define MAXLEN1 201	/* MAXLEN + 1 */


/*
	Define operating system constants.
*/

#define SYSFNMAX 20		/* max length of a path name */

#define TEMPFILE "@@TEMP@@.TMP" /* name of temp file */
#define DATAFILE "@@DATA@@.TMP" /* name of work file */


/*
	Define misc. constants.
*/

#define EOS	0	/* code sometimes assumes \0	*/
#define ERROR	-1	/* error code			*/
#define OK	0	/* opposite of ERROR		*/
#define YES	1	/* must be nonzero		*/
#define NO	0	/* must be zero 		*/
#define CR	13	/* carriage return		*/
#define LF	10	/* line feed			*/
#define NEWLINE 10	/* newline character		*/
#define TAB	9	/* tab character		*/
#define CPMEOF 0x1a	/* end-of-file mark for CP/M	*/
#define HUGE	32000	/* practical infinity		*/


/*
	Declare globals variables.
*/

extern
int	hasdn;			/* describe terminals.	    */
extern
int	hasup;
extern
int	hasins;
extern
int	hasdel;
extern
int	hasint;
extern
int	hascol;
extern
int	haswrap;
extern
int	hascins;
extern
int	hascdel;

extern
char gfile [SYSFNMAX];	/* true global variables.   */
extern
char DISKERR [JBUFSIZE];

extern				/* used by buffer routines. */
int	DATARES;
extern
int	bfatal;
extern
int	bcflag;
extern
int	bline;
extern
int	bmaxline;
extern
int	bstart;
extern
int	bhead;
extern
int	btail;
int	bmaxdiskp;
extern
int	bmaxput;
extern
int	bdatafd;
extern
int	buserfd;
extern
int	bfree;
extern
char	bbuff [DATASIZE];
extern
struct BLOCK * bbp;
extern
struct BLOCK * bbpp [MAXRES];
extern
char *	brbufp;
extern
int	brbufc;
extern
int	brcount;
extern
int	bravail;
extern
int	brout;
extern
int	bwcount;



/*
	RED special key definitions and compiler options.
	Source:  red1.h
	Version: February 15, 1985
*/


/*
Define how modes change initially.
*/

#define DEFIMODE CMNDMODE	/* Initial mode & mode after commands.	*/
#define DEF1MODE INSMODE	/* Mode after UPINS and DOWNINS.	*/
#define DEF2MODE EDITMODE	/* Mode after UP and DOWN.		*/


/*
Define which keys are used for special edit functions.
*/

#define AGAIN 1 		/* control a (again)	*/
#define ESCAPE 27		/* escape sequence	*/

#define UPINS 10		/* line feed		*/
#define DOWNINS 13		/* carriage return	*/

#define UP 21			/* control u (up)	*/
#define DOWN 4			/* control d (down)	*/
#define LEFT 12 		/* control l (left)	*/
#define RIGHT 18		/* control r (right)	*/

#define WORDB 2 	/* control b (back)	*/
#define WORDF 6 	/* control f (forward)	*/

#define DEL1 8			/* control h (BS)	*/
#define DEL2 127		/* del			*/
#define ZAP 26			/* control z (zap)	*/
#define UNDO 24 		/* control x (undo)	*/

#define SPLIT 19		/* control s (split)	*/
#define JOIN 7			/* control g (glue)	*/
#define VERBATUM 22		/* control v (verbatum) */

#define INS 14			/* control n (iNsert)	*/
#define CMND 3			/* control c (command)	*/
#define EDIT 5			/* control e (edit)	*/
#define OVER 20 		/* control t (Overtype) */

#define SCRNDN 15		/* control o		*/
#define SCRNUP 23		/* control w		*/
#define PAGEUP 17		/* control q		*/
#define PAGEDN 16		/* control p		*/


/*
Define length and width of screen and printer.
*/

#define SCRNW 80
#define SCRNW1 79
#define SCRNL 24
#define SCRNL1 23
#define SCRNL2 22
#define LISTW 132



/*
	Header for global buffer constants, structures.
	Source:  redbuf.h
	Version: November 15, 1983

	Copyright (C) 1983 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/


/*
You may tune these constants for better disk performance.

DATASIZE:  The size of that part of struct BLOCK which is
	    written to the disk.  Make sure that DATASIZE
	    is a multiple of the size of your disk sectors.

MAXRES:    The maximum number of BLOCKS resident in memory.
	    The code assumes this number is AT LEAST 3.
	    The actual number of resident blocks is DATARES.
	    DATARES is set by calling alloc(DATASIZE) until
	    MAXRES blocks are allocated or until alloc() fails.
*/

#define DATASIZE 1024
#define MAXRES	 100


/* Do not touch these constants. */

#define CPMSIZE 128
#define READSIZE  (DATASIZE/CPMSIZE)

/*
	Partially define the format of a block.  The end of
	the data area contains an "index table" of indices
	into the front of the data area.  Each index is the
	index of the last byte of a line.

	Thus, it is possible to calculate the starting address
	and length of each line in the block WITHOUT searching
	through either the data field or the index table.

	The dback and dnext fields in the header are used
	to doubly-link the disk blocks so that stepping
	through the blocks either forward or backwards is
	efficient.  -1 denotes the end of each list.

	When blocks become totally empty they are entered
	on a list of free blocks.  The links of this list
	are kept in the blocks themselves in the dnext field.
	The bfree variable is the head of this list.
*/

/*
	Warning!!  RED will crash if the following two
		   defines are not right.

		   They should be equal to 3*sizeof(int)
*/

#define HEADERSIZE 6		/* size of the block header	*/
#define STATUSSIZE 6		/* size of the status table	*/

#define BUFFSIZE  (DATASIZE - HEADERSIZE)
#define BLOCKSIZE (DATASIZE + STATUSSIZE)

struct BLOCK {

	/*	The block header.				*/

	int	dback;	/* # of previous block		*/
	int	dnext;	/* # of next block		*/
	int	dlines; /* # of lines on block		*/

	/*	The data area and index table.			*/

	char	ddata [BUFFSIZE];

	/*	The status table -- not written to disk.	*/

	int	dlru;		/* lru count		*/
	int	dstatus;	/* FULL, FREE or DIRTY	*/
	int	ddiskp; /* disk pointer 	*/
};


/*
	Define the entries in the dstatus field.
*/

#define FREE	1	/* status:  block is available	*/
#define FULL	2	/* status:  block is allocated	*/
#define DIRTY	3	/* status:  must swap out	*/





/*
	RED main program -- Full C version

	Source:  red2.c
	Version: February 7, 1985; April 25, 1985

	Copyright (C) 1985 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"


/*
	Define the possible values of mode and lastmode.
*/

#define CMNDMODE 1	/* command mode 	*/
#define INSMODE  2	/* insert mode		*/
#define EDITMODE 3	/* edit mode		*/
#define OVERMODE 4	/* overtype mode	*/
#define ESCAPEMODE 5	/* escape mode		*/
#define EXITMODE 6	/* exit the editor	*/

/*
	Define internal function numbers.
*/

#define BOL	129
#define EOL	130
#define MIDDLE	133
#define KILL	134
#define SEARCH	135
#define GOTO	136
#define XCHNG	137
#define UPHALF 138
#define DNHALF 139

#define HOME	200	/* These values must match values from keyboard. */
#define ENDPG	201

int def0mode;	/* initial mode and mode after commands. */
int def1mode;	/* mode after UPINS, DOWNINS. */
int def2mode;	/* mode after UP, DOWN		*/

main(argc, argv)
int  argc;
char **argv;
{
	int mode;	/* current mode.			*/
	int lastmode;	/* last mode (used by ESCAPEMODE).	*/
	int lastc;	/* last command (used by AGAIN).	*/
	int holdc;	/* queued input character.		*/
	int c;		/* current input character.		*/
	char args [MAXLEN];
	char buffer [SCRNW1];
	int v;
	int x,y,topline;

	/* Ready the system module. */
	sysinit();

	/* Output from fmt module goes to screen. */
	fmtassn(NO);

	/* Clear filename [] for save(), resave(). */
	gfile [0] = EOS;

	/* Ready the work file if it exists. */
	if (setjmp(DISKERR) == ERROR) {
		/* Error in bufinit(). */
		return;
	}
	else {
		bufinit();
	}

	/* Start off in the default mode. */
	lastmode = mode = DEFIMODE;
	def0mode = mode;
	def1mode = DEF1MODE;
	def2mode = DEF2MODE;

	/* Set tabs, clear the screen and sign on. */
	fmtset(8);
	outinit();
	outclr();
	pmtclr();
	edclr();
	edgetln();		/* Initialize window module. */
	outxy(0,SCRNL1);

	pmthold(YES);
	message(SIGNON);
	message(VERSION);
	message(COPYRIGHT);
	message("");
	message(XSIGN);
	message(XSIGN1);
	message("");
	pmthold(NO);

	/* Set error recovery point for auto-load code. */
	if (setjmp(DISKERR) == ERROR) {
		/* Error in load() in argc >= 2 case below. */
		argc = 0;
	}

	/* Never auto-load a file if a previous session was resumed. */
	if (bufchng() == YES) {
		/* Draw the first part of the resumed file. */
		bufgo(1);
		edclr();
		edgo(1,0);
	}
	else if (argc >= 2) {
		/* Auto-load a file from the command line. */
		pmtmode("-- loading --");
		strcpy(args, "load ");
		strcat(args, argv [1]);
		if (load(args) == YES) {
			syswait();
		}
		else {
			/* Preserve the signon message. */
			bufout(1,1,2);
			outxy(0,1);
		}
	}
	else {
		/* No file was loaded. Preserve the signon message. */
		bufout(1,1,2);
		outxy(0,1);
	}

	/* Set the disk error recovery point. */
	setjmp(DISKERR);

	lastc = NULL;
	holdc = NULL;
	for (;;) {

		/* Update the mode on the prompt line. */
		switch(mode) {
		case EDITMODE:		pmtmode("edit:");	break;
		case INSMODE:		pmtmode("insert:");	break;
		case OVERMODE:		pmtmode("overtype:");	break;
		case ESCAPEMODE:	pmtmode("escape:");	break;
		}

		/* Get the next character. */
		if (holdc != NULL) {
			c = holdc;
			holdc = NULL;
		}
		else {
			c = syscin();
		}

		/* Substitute the last command for the AGAIN key. */
		if (c == AGAIN) {
			c = lastc;
		}

		/* Translate escapes and edit mode commands. */
		if (mode == EDITMODE || mode == ESCAPEMODE) {
			c = tolower(c);
			switch(c) {
                        case ' ':       c = RIGHT;      break;
                        case 'b':       c = BOL;        break;
                        case 'd':       c = SCRNDN;    break;
                        case 'e':       c = EOL;        break;
                        case 'h':       c = HOME;       break;
                        case 'g':       c = GOTO;       break;
                        case 'k':       c = KILL;       break;
                        case 'm':       c = MIDDLE;     break;
                        case 'p':       c = PAGEDN;    break;
                        case 'q':       c = PAGEUP;    break;
                        case 's':       c = SEARCH;     break;
                        case 'u':       c = SCRNUP;    break;
                        case 'x':       c = XCHNG;      break;
                        case 'z':       c = ENDPG;     break;
                        case '-':       c = UPHALF;    break;
                        case '+':       c = DNHALF;    break;
			default:
				break;
			}
		}

		/* Remember the what the last function was. */
		lastc = c;

		/* Restore previous mode in escape mode. */
		if (mode == ESCAPEMODE) {
			mode = lastmode;
		}

		/* Do the requested function. */
		switch(c) {

		case NULL:	break;

		case CMND:	mode = command();
				if (mode == EXITMODE) {
					outxy(0, SCRNL1);
					fmtcrlf();
					return;
				}
				break;

		case EDIT:	lastmode = mode = EDITMODE;
				break;

		case INS:	lastmode = mode = INSMODE;
				break;

		case OVER:	lastmode = mode = OVERMODE;
				break;


		case ESCAPE:	lastmode = mode;
				mode = ESCAPEMODE;
				break;

		case UPINS:	ednewup();
				lastmode = mode = def1mode;
				break;

		case DOWNINS:	ednewdn();
				lastmode = mode = def1mode;
				break;

		case UP:	edup();
				mode = def2mode;
				break;

		case DOWN:	eddn();
				mode = def2mode;
				break;

		case LEFT:	edleft();	break;
		case RIGHT:	edright();	break;
		case WORDF:	edfword();	break;
		case WORDB:	edbword();	break;

		case JOIN:	edjoin();	break;
		case SPLIT:	edsplit();	break;
		case UNDO:	edabt();	break;
		case DEL1:	eddel();	break;
		case DEL2:	ed2del();	break;
		case ZAP:	edzap();	break;

		case VERBATUM:
			pmtmode("verbatum:");
			edins(syscin());
			break;

		case SCRNDN:
			syswait();
			while (chkkey() == NO) {
				eddn();
				if (bufnrbot()) {
					eddn();
					break;
				}
			}
			break;

		case PAGEDN:
			edgo(min(
				bufmax(),
				bufln()+(SCRNL1-outgety())+SCRNL/2
				),
			     0);
			break;

		case PAGEUP:
			edgo(max(0,bufln()-outgety()-SCRNL/2+3),
			     0);
			break;

		case UPHALF:
			/* Move up a half page. */
			edgo(max(0,bufln()-(SCRNL2/2)),0);
			break;

		case DNHALF:
			/* Move down a half page. */
			edgo(min(bufmax(),bufln()+(SCRNL2/2)),0);
			break;

		case SCRNUP:
			syswait();
			while (bufattop() == NO && chkkey() == NO) {
				edup();
			}
			break;

		case HOME:
			edgo(max(0,bufln()-outgety()+1),0);
			lastc = PAGEUP;
			break;

		case ENDPG:
			edgo(min(bufmax(),bufln()+SCRNL1-outgety()),0);
			lastc = PAGEDN;
			break;

		case MIDDLE:
			edgo(min(bufmax(),bufln()+SCRNL1/2-outgety()+1),0);
			break;

		case BOL:
			edbegin();
			lastc = HOME;
			break;

		case EOL:
			edend();
			lastc = ENDPG;
			break;

		case GOTO:
			pmtmode("goto: ");
			getcmnd(buffer);
			if(number(buffer,&v)) {
				edgo(v, 0);
			}
			break;

		case KILL:
			pmtmode("kill:");
			c = syscin();
			if (control(c)) {
				holdc = c;
			}
			else {
				edkill(c);
			}
			break;

		case SEARCH:
			pmtmode("search:");
			c = syscin();
			if (control(c)) {
				holdc = c;
			}
			else {
				edsrch(c);
			}
			break;

		case XCHNG:
			pmtmode("eXchange:");
			edchng(syscin());
			break;

		default:

			if (control(c)) {
				break;
			}

			if (mode == INSMODE) {
				edins(c);
			}
			else if (mode == OVERMODE) {
				edchng(c);
			}
		}
	}
}


/*
	Return TRUE if c is a control char.
*/

control(c)
char c;
{
	return c != TAB && (c >= 127 || c < 32);
}


/*
	Handle command mode.
*/

command()
{
	int  k, v;
	char c;
	char args [SCRNW1];
	char *argp, *skipbl();

	/* Make sure the current line is saved. */
	edrepl();

	pmtmode("command: ");
	getcmnd(args);
	c = args [0];

	switch(c) {
	case EDIT:	return EDITMODE;
	case INS:	return INSMODE;
	case OVER:	return OVERMODE;
	}

        /* Only one command may start with the letter 'g' */
        if (tolower(args [0]) == 'g'){
		argp = skipbl(args+1);
		if (argp [0] == EOS) {
			/* Do nothing. */
			;
		}
		else if (number(argp, &v) == YES) {
			edgo(v, 0);
		}
		else {
			cmndmess("Bad line number.");
		}
	}
	else if (lookup(args,"change")) {
		change(args);
	}
	else if (lookup(args,"clear")) {
		/* clear() conflicts with AZTEC func. */
		clear1();
		pmtfn();
	}
	else if (lookup(args,"copy")) {
		copy(args);
	}
	else if (lookup(args,"def0ins")) {
		def0mode = INSMODE;
	}
	else if (lookup(args,"def0over")) {
		def0mode = OVERMODE;
	}
	else if (lookup(args,"def0edit")) {
		def0mode = EDITMODE;
	}
	else if (lookup(args,"def1ins")) {
		def1mode = INSMODE;
	}
	else if (lookup(args,"def1over")) {
		def1mode = OVERMODE;
	}
	else if (lookup(args,"def1edit")) {
		def1mode = EDITMODE;
	}
	else if (lookup(args,"def2ins")) {
		def2mode = INSMODE;
	}
	else if (lookup(args,"def2over")) {
		def2mode = OVERMODE;
	}
	else if (lookup(args,"def2edit")) {
		def2mode = EDITMODE;
	}
	else if (lookup(args,"delete")) {
		delete(args);
	}
	else if (lookup(args,"dos") || lookup(args, "exit")) {
		if (chkbuf() == YES) {
			bufend();
			return EXITMODE;
		}
	}

	/* comment out -----
	else if (lookup(args,"dump")) {
		bufdump();
	}
	----- end comment out */

	else if (lookup(args,"extract")) {
		extract(args);
	}
	else if (lookup(args, "findr")) {
		findr(args);
	}
	else if (lookup(args,"find")) {
		find(args);
	}

#ifdef HELPCMND
	else if (lookup(args, "help")) {
		help();
	}
#endif

	else if (lookup(args,"inject")) {
		inject(args);
	}
	else if (lookup(args,"list")) {
		list(args);
	}
	else if (lookup(args,"load") || lookup(args, "red")) {
		load(args);
		pmtfn();
	}
	else if (lookup(args,"move")) {
		move(args);
	}
	else if (lookup(args,"name")) {
		name(args);
		pmtfn();
	}
	else if (lookup(args, "nowrap")) {
		haswrap = NO;
	}
	else if (lookup(args,"resave")) {
		resave();
	}
	else if (lookup(args,"save")) {
		save();
	}
	else if (lookup(args,"search")) {
		search(args);
	}

#ifdef SUSPEND
	else if (lookup(args,"quit")) {
		/* Make sure the file is named. */
		if (gfile [0] == EOS) {
			cmndmess("File not named.");
		}
		else {
			bufsusp();
			return EXITMODE;
		}
	}
#endif

	else if (lookup(args,"tabs")) {
		tabs(args);
	}
	else if (lookup(args, "wrap")) {
		haswrap = YES;
	}
	else if (lookup(args,"")) {
		;
	}
	else {
		cmndmess("Command not found.");
	}

	/* Do not exit. */
	return def0mode;
}


/*
	Return TRUE if line starts with command.
*/

lookup(line,cmnd)
char *line, *cmnd;
{
	while(*cmnd) {
		/* Watch out:  tolower may be a macro. */
		if (tolower(*line) != *cmnd) {
			return NO;
		}
		else {
			line++;
			cmnd++;
		}
	}
        return *line == EOS || *line == ' ' || *line == TAB;
}


/*
	Get next command into argument buffer.
*/

getcmnd(args)
char *args;
{
	int i, xpos, x, y;
	int length;
	char c;

	/* Remember the cursor position. */
	x      = outgetx();
	y      = outgety();
	xpos   = pmtlast();
	outxy(xpos, 0);

	length = 0;
	while ((c = syscin()) != CR) {
		pmtupd();

		if (c == EDIT || c == INS || c == OVER) {
			args [0] = c;
			length = 1;
			break;
		}

		if ( (c == DEL1 || c == LEFT) && length > 0) {
			outxy(xpos, 0);
			outdeol();
			length--;
			/* Redraw the field. */
			for (i = 0; i < length; i++) {
				if (args [i] == TAB) {
                                        outchar(' ');
				}
				else {
					outchar(args [i]);
				}
			}
		}
		else if (c == UNDO) {
			outxy(xpos, 0);
			outdeol();
			length = 0;
		}
		else if (c == TAB && length + xpos < SCRNW1) {
			args [length++] = TAB;
                        outchar(' ');
		}
		else if (c < 32 || c == 127) {
			/* Ignore control characters. */
			continue;
		}
		else {
			if (length + xpos < SCRNW1) {
				args [length++] = c;
				outchar(c);
			}
		}
	}
	args [length] = EOS;

	/* Restore the cursor. */
	outxy(x, y);
}





/*
	RED command mode commands -- Full C version

	Source:  red3.c
	Version: October 10, 1984; December 3, 1984; February 4, 1985
	February 4, 1985: add return status to load().

	Copyright (C) 1983, 1984, 1985 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
*/

#include "red.h"


/*
	Changes lines.
*/

change(args)
char *args;
{
	int  from, to, junk;

	/* Check the arguments. */
	if (get3args(args,&from,1,&to,HUGE,&junk,-1)==ERROR) {
		return;
	}

	/* rflag = YES;  wflag = NO;  cflag = YES */
	srch1(from, to, YES, NO, YES);
}


/*
	Clear main buffer and file name.
	WARNING:  clear() is an AZTEC library function.
*/

clear1()
{
	/* Make sure it is ok to clear buffer. */
	if (chkbuf() == YES) {
		gfile [0] = 0;
		outclr();
		bufnew();
		edgetln();
		outxy(0, 1);
		bufout(1, 1, 2);
		pmtzap();		/* 1/7/84 */
	}
}


/*
	Copy a block of memory without erasing it.
*/

copy(args)
char *args;
{
	movecopy(args, "usage: copy <block> <n>", "-- copying --", NO);
}


/*
	Delete multiple lines.
*/

delete(args)
char *args;
{
	int from, to, dummy;

	/* Check the request. */
	if(get3args(args,&from,bufln(),&to,-1,&dummy,-1)==ERROR){
		return;
	}
	if (to == -1) {
		to = from;
	}

        /* Say we've started. */
	pmtmode("-- deleting --");

	/* Go to first line to be deleted. */
	bufgo(from);

	/* Delete all line between from and to. */
	bufdeln(to-from+1);

	/* Redraw the screen. */
	bufgo(from);
	edclr();
	edgo(from, 0);
}


/*
	Extract command.
	Copy lines to a file.
*/

extract(args)
char *args;
{
	char locfn [SYSFNMAX];
	int  from, to, junk;
	char *skiparg(), *skipbl();


	/* Get file name which follows command. */
	if (name1(args, locfn) == ERROR) {
		return;
	}
	if (locfn [0] == EOS) {
		cmndmess("usage: extract <filename> first last");
		return;
	}

	/* Skip over command,  so get3args() will skip filename. */
	args = skiparg(args);
	args = skipbl (args);

	/* Get optional line numbers. */
	get3args(args, &from, bufln(), &to, -1, &junk, -1);
	if (to == -1) {
		to = from;
	}

	/* Extract the file. */
	xtrct(locfn, from, to, "-- extracting --");
}


/*
	Search for a pattern.
	find -- search forward.  findr -- search backwards.
*/

find(args)
char *args;
{
	int  start, last, junk;

	/* Get starting place for search. */
	if(get3args(args,&start,bufln()+1,&last,HUGE,&junk,-1)==ERROR){
		return -1;
	}

	/* rflag = NO;	wflag = YES;  cflag = NO */
	srch1 (start, last, NO, YES, NO);
}


/*
	Same as find(),  but in reverse.
*/

findr(args)
char *args;
{
	int  start, junk;

	/* Get starting place for search. */
	if (get3args(args,&start,bufln()-1,&junk,-1,&junk,-1)==ERROR){
		return -1;
	}

	/* rflag = NO;	wflag = YES;  cflag = NO */
	return srch1 (max(start,1), 1, NO, YES, NO);
}


#ifdef HELPCMND
#define MESS message
help()
{

MESS  ("Command Default args   Description");
MESS  ("");
MESS  ("change 1 9999		Change all lines in <line range>");
MESS  ("clear			Reset the editor");
MESS  ("copy   <block> <n>	Copy lines in <block> after line <n>");
MESS  ("delete <current line>	Delete one or more lines");
MESS  ("exit			Exit from the editor");
MESS  ("extract <file> <block>	Create a file from a block");
MESS  ("find	<current line>	Search for a pattern");
MESS  ("findr	<current line>	Backward find");
MESS  ("g <n>			Enter edit mode at line <n>");
MESS  ("help			Print this message");
MESS  ("inject <file>		Add a line to the buffer");
MESS  ("list	1 9999		List lines to the printer");
MESS  ("load   <file>		Replace the buffer with <filename>");
MESS  ("move   <block> <n>	Move lines of <block> after line <n>");
MESS  ("name   <file>		Set filename");
MESS  ("nowrap			Disable line wrapping");
#ifdef SUSPEND
MESS  ("quit			Exit and save work file");
#endif
MESS  ("resave			Save the buffer to an existing file");
MESS  ("save			Save the buffer to a new file");
MESS  ("search	1 9999		Search for pattern");
MESS  ("tabs	8		Set tabs to every <n> columns");
MESS  ("wrap			Enable line wrapping");

	/* Wait for any character and redraw the screen. */
	pmtupd();
	syscin();
	pmtzap();
	edclr();
	edgo(bufln(), 0);

}
#endif


/*
	Inject command.
	Load a file into main buffer at current location.
	This command does NOT change the current file name.
*/

inject(args)
char *args;
{
	char locfn [SYSFNMAX];
	int  oldline, junk;
	char *skiparg(), *skipbl();


	/* Get file name which follows command. */
	if (name1(args, locfn) == ERROR) {
		return;
	}
	if (locfn [0] == EOS) {
		cmndmess("usage: inject <filename> line");
		return;
	}

	/* Skip over command,  so get3args() will skip filename. */
	args = skiparg(args);
	args = skipbl (args);

	/* Get optional line number. */
	get3args(args, &oldline, bufln(), &junk, -1, &junk, -1);

	/* Load the file at oldline. */
	append(locfn, oldline, "-- injecting --");

	/* Redraw the screen. */
	bufgo(oldline);
	edclr();
	edgo(oldline, 0);
}


/*
	Print lines to list device.
*/

list(args)
char *args;
{
	char linebuf [MAXLEN1];
	int n;
	int from, to, dummy, line, oldline;

        /* Save the buffer's current line. */
	oldline = bufln();

	/* Get starting, ending lines to print. */
	if (get3args(args,&from,1,&to,HUGE,&dummy,-1)==ERROR) {
		return;
	}

        /* Say we've started. */
	pmtmode("-- listing --");

	/* Print lines one at a time to list device. */
	line = from;
	while (line <= to) {

		/* Make sure prompt goes to console. */
		fmtassn(NO);

		/* Check for interrupt. */
		if (chkckey() == YES) {
			break;
		}

		/* Print line to list device. */
		fmtassn(YES);

		bufgo(line++);
		if (bufatbot()) {
			break;
		}
		n = bufgetln(linebuf,MAXLEN1);
		n = min(n,MAXLEN);
		linebuf [n] = NEWLINE;
		fmtsout(linebuf,0);
		fmtcrlf();
	}

	/* Redirect output to console. */
	fmtassn(NO);

	/* Restore cursor. */
	bufgo(oldline);
}


/*
	Load file into buffer.
	Return YES if the file was loaded correctly.
*/

load (args)
char *args;
{
	char buffer [MAXLEN];	/* disk line buffer */
	char locfn  [SYSFNMAX];  /* file name */
	int n;
	int topline;

	/* Get filename following command. */
	if (name1(args,locfn) == ERROR) {
		return NO;
	}

	if (locfn [0] == EOS) {
		cmndmess("No file argument.");
		return NO;
	}

	/* Give user a chance to save the buffer. */
	if (chkbuf() == NO) {
		return NO;
	}

	/* Open the new file. */
	if (sysexists(locfn) == NO) {
		cmndmess("File not found.");
		return NO;
	}

        /* Say we've started. */
	pmtmode("-- loading --");

	/* Update file name. */
	syscopfn(locfn, gfile);
	pmtfn();
	pmtupd();

	/* Clear the buffer. */
	bufnew();

	/* Read the whole file into the buffer. */
	readfile(gfile);

	/* Indicate that the buffer is fresh. */
	bufsaved();

	/*	Set current line to line 1.
		Redraw the screen.
	*/
	bufgo(1);
	edclr();
	edgo (1, 0);
	return YES;
}


/*
	Move a block of lines.
*/

move(args)
char *args;
{
	/* Copy a block,  then delete it. */
	movecopy(args, "usage: move <block> <n>", "-- moving --", YES);
}


/*
	Change current file name.
*/

name(args)
char *args;
{
	name1(args, gfile);
}

name1(args, filename)
char *args, *filename;
{
	char *skiparg(), *skipbl();

	/* Skip command. */
	args = skiparg(args);
	args = skipbl(args);

	/* Copy filename. */
	syscopfn(args, filename);
	return OK;
}


/*
	Save the buffer in an already existing file.
*/

resave()
{
	int n, oldline;

	/* Save line number. */
	oldline = bufln();

	/* Make sure file has a name. */
	if (gfile [0] == EOS) {
		cmndmess("File not named.");
		return;
	}

	/* The file must exist for resave. */
	if (sysexists(gfile) == NO) {
		cmndmess("File not found.");
		return;
	}

        /* Say we've started. */
	pmtmode("-- resaving --");

	/* Write out the whole buffer. */
	writefile(gfile);

	/* Indicate that the buffer has been saved. */
	bufsaved();

	/* Restore line number. */
	bufgo(oldline);
}


/*
	Save the buffer in a new file.
*/

save()
{
	int file, n, oldline;

	/* Save current line number. */
	oldline = bufln();

	/* Make sure the file is named. */
	if (gfile [0] == EOS) {
		cmndmess("File not named.");
		return;
	}

	/* File must NOT exist for save. */
	if (sysexists(gfile) == YES) {
		cmndmess("File exists.");
		return;
	}

        /* Say we've started. */
	pmtmode("-- saving --");

	/* Write out the whole buffer. */
	writefile(gfile);

	/* Indicate buffer saved. */
	bufsaved();

	/* Restore line number. */
	bufgo(oldline);
}


/*
	Search for a pattern.
*/

search(args)
char *args;
{
	int from, to, junk;

	/* Check the request. */
	if (get3args(args,&from,1,&to,HUGE,&junk,-1)==ERROR) {
		return;
	}

	/* rflag = NO,	wflag = NO, cflag = YES. */
	srch1(from, to, NO, NO, YES);
}


/*
	Search/change utility routine.
	Redraw the screen if the pattern is found.

	spat[]	 contains the search pattern.
	rpat[]	 contains the change pattern.
	sstart	 is first line to search.
	send	  is last  line to search.
	rflag	  is YES if change pattern is used.
	wflag	  is YES if search wraps around.
	cflag	  is YES if search continues after a match.
*/

int
srch1(sstart, send, rflag, wflag, cflag)
int   sstart, send, rflag, wflag, cflag;
{
	char spat [MAXLEN1];
	char rpat [MAXLEN1];

	int oldbuf;
	int oldstart, oldend;
	int aflag, oldplen;
	int startanchor,  endanchor;
	int code;

	/* Get search mask. */
	pmtmode("Search mask? ");
	getcmnd(spat);
	if (strlen(spat) == 0) {
		return;
	}

	if (rflag) {
		pmtmode("Change mask? ");
		getcmnd(rpat);
	}

	/* Remember the current line. */
	oldbuf = bufln();

	/* Go to first line. */
	bufgo(sstart);
	if (bufatbot()) {
		bufup();
	}

	/* Remember the initial params. */
	oldstart = bufln();
	sstart	= bufln();
	oldend	 = send;
	oldplen = strlen(spat);

	/* Set start-of-line anchor. */
        startanchor = (spat [0] == '^') ? 1 : 0;

	/* Set end-of-line anchor. */
        endanchor = (spat [oldplen - 1] == '$') ? 1 : 0;

	/* Delete trailing anchor from search pattern. */
	spat [oldplen - endanchor] = EOS;

	/* Adjust plen to reflect only non-anchor characters. */
	oldplen -= (startanchor + endanchor);

	/* Enable prompts in srch2(). */
	aflag = 0;

	pmtmode("-- searching --");

	/* Search all lines in between sstart and send. */
	if (sstart <= send) {
		while (sstart <= send) {

			/* Check for user abort. */
			if (chkckey() == YES) {
				break;
			}

			code = srch2( spat, rpat, rflag,
				      cflag, &aflag,
				      startanchor,  endanchor,
				      oldplen);

			if (code == YES) {
				return;
			}
			else if (code == NO) {
				/* Remember the last match point. */
				oldbuf = bufln();
				pmtmode("-- searching --");
			}

			if (bufnrbot() && wflag == NO) {
				break;
			}
			else if (bufnrbot() && wflag == YES) {
				/* Wrap around search. */
				wflag = NO;
				bufgo(1);
				sstart = 1;
				send	= oldstart;
			}
			else {
				bufgo(++sstart);
			}

		}

		/*  Return to the last line with a match. */
                if (aflag == 'a') {    /* 4/24/84 */
			/* Force redraw. */
			edclr();
		}
		edgo(oldbuf, 0);
		return;
	}
	else {
		send = max(1, send);
		while(sstart >= send) {

			/* Check for user abort. */
			if (chkckey() == YES) {
				break;
			}

			code = srch2( spat, rpat, rflag,
				      cflag, &aflag,
				      startanchor,  endanchor,
				      oldplen);

			if (code == YES) {
				return;
			}
			else if (code == NO) {
				oldbuf = bufln();
			}

			if (bufln() == 1 && wflag == NO) {
				break;
			}
			else if (bufln() == 1 && wflag == YES) {
				wflag = NO;
				bufgo(HUGE);
				bufup();
				sstart = bufln();
				send	= oldstart;
			}
			else {
				bufgo(--sstart);
			}
		}

		/* Return to the last line that matched. */
                if (aflag == 'a') {    /* 4/25/84 */
			/* Force redraw of screen. */
			edclr();
		}
		edgo(oldbuf, 0);
		return;
	}
}



/*
	Search one line for all instances of oldpat.
	If rflag is YES, replace them by newpat.
	If cflag is NO,  exit after finding the first instance.
        If aflag is 'a', do not prompt the user.
	plen == strlen(oldpat).

	Return YES   if search should stop.
	Return No    if search should continue.
	Return ERROR if no match found.
*/

srch2(oldpat, newpat, rflag, cflag, aflag, sanchor,  eanchor, plen)
char * oldpat, * newpat;
int  rflag, cflag;
int  * aflag;
int  sanchor,	eanchor, plen;
{
	char oldline [MAXLEN1];
	char newline [MAXLEN1];
	int  oldlength, col, mode, match, xpos;

	/* Get the current line into oldline[] */
	oldlength = bufgetln(oldline, MAXLEN1);
	oldlength = min(oldlength, MAXLEN);
	oldline [oldlength] = EOS;

	/* No match is possible if oldpat[] is too long. */
	if (sanchor && eanchor && plen != oldlength) {
		return ERROR;
	}
	else if (plen > oldlength) {
		return ERROR;
	}

	/* Set starting column. */
	col = (eanchor) ? oldlength - plen : 0;

	/* Set prompting mode. */
	mode = * aflag;

	/* Remember whether any match was seen on this line. */
	match = NO;

	/* Search column by column. */
	while (col < oldlength) {
		if (amatch(oldline + col, oldpat + sanchor) == NO) {
			if (sanchor || eanchor) {
				return ERROR;
			}
			else {
				col++;
				continue;
			}
		}
		else {
			/* Remember that a match was seen. */
			match = YES;
		}

		/* Show the screen before any replacement. */
                if (mode != 'a') {      /* 3/1/84 */
			edgo(bufln(), col);
			syswait();
			xpos = outgetx();
		}

		/* Draw the proposed change on the screen. */
		if (rflag == YES) {
			replace(oldline, newline,
				oldpat + sanchor, newpat, col);
			bufrepl(newline, strlen(newline));
                        if (mode != 'a') {      /* 3/1/84 */
				outxy(0, outgety());
				bufoutln(bufln());
				outxy(xpos, outgety());
			}
		}

		/* Stop the search if continue flag is NO. */
		if (cflag == NO) {
			return YES;
		}

                /* Prompt the user unless in 'all' mode. */
                if (mode == 'a') {
			/* Update the search line. */
			oldlength = bufgetln(oldline, MAXLEN1);
			oldlength = min(oldlength, MAXLEN);
			oldline [oldlength] = EOS;
			col	+= strlen(newpat);
		}
		else if (rflag == NO) {
			/* Give search-mode prompt. */
			pmtmode("next, exit? ");
			mode = syscin();
			mode = tolower(mode);
                        if (mode != 'n') {
				return YES;
			}
			else {
				/* Do not rescan matched pattern. */
				col += plen;
			}
		}
		else {
			/* Give change-mode prompt. */
			pmtmode("yes, no, all, exit? ");
			mode = syscin();
			mode = tolower(mode);
			*aflag = mode;

                        if (mode == 'y' || mode == 'a') {
				/* Update the search pattern. */
				oldlength = bufgetln(oldline, MAXLEN1);
				oldlength = min(oldlength, MAXLEN);
				oldline [oldlength] = EOS;
			}
			else {
				/* Undo the change. */
				bufrepl(oldline, strlen(oldline));
				outxy(0, outgety());
				bufoutln(bufln());
				outxy(xpos, outgety());
			}

                        if (mode == 'y' || mode == 'a') {
				/* Do not rescan replacement text. */
				col += strlen(newpat);
			}
                        else if (mode == 'n') {
				/* Continue the search on this line. */
				col += strlen(oldpat);
			}
			else {
                                /* Default is 'e' */
				return YES;
			}
		}

		/* Anchored searches examine line only once. */
		if (sanchor || eanchor) {
			return NO;
		}
	}

	/* Indicate whether any match was found on the line. */
	return (match) ? NO : ERROR;
}


/*
	Set tab stops for fmt routines.
*/

tabs(args)
char *args;
{
	int n, junk;

	/* Default is every 8 columns. */
	if (get3args(args,&n,8,&junk,-1,&junk,-1)==ERROR){
		return;
	}
	fmtset(n);

	/* Redraw the screen. */
	edclr();
	edgo(bufln(), 0);
}


/*
	----- Utility routines start here -----
*/


/*
	Insert file whose name is fname after line where.
	(where can be zero,  in which case insert at start of file.)
	Use promt as the promt line mode while doing so.
*/

append(fname, where, prompt)
char *fname;
int where;
char *prompt;
{
	FILE *fd, *sysfopen();
	char buffer [MAXLEN];	/* disk line buffer */
	int  oldline, n;

#ifdef BDS
	char filebuf [BUFSIZ];	/* file buffer */
#else
	char filebuf [1];	/* dummy */
#endif

	/* Open the new file. */
	fd = sysfopen(fname, filebuf);
	if (fd == NULL) {
		cmndmess("File not found.");
		return;
	}

        /* Say that we've started. */
	pmtmode(prompt);

	/* Go to after proper line,  unless line is zero. */
	bufgo(where);
	if (where) {
		bufdn();
	}

	/* Read the file into the buffer. */
	while ((n = sysfgets(fd,buffer,MAXLEN)) >= 0) {
		if (n > MAXLEN) {
			cmndmess("line truncated.");
			n = MAXLEN;
		}
		bufins(buffer,n);
		bufdn();
	}

	/* Close the file. */
	sysfclose(fd);
}


/*
	Create a file named fname from start to finish.
	Set the prompt mode to prompt while doing so.
*/

xtrct(fname, start, finish, prompt)
char * fname;
int start, finish;
char * prompt;
{
	FILE *fd, *sysfopen(), *sysfcreat();
	int i;
	int count, length;
	int oldline;
	char buffer [MAXLEN1];

#ifdef BDS
	char filebuf [BUFSIZ];
#else
	char filebuf [1];	/* dummy */
#endif

        /* Say we've started. */
	pmtmode(prompt);

	/* Open a temporary file. */
	fd = sysfcreat(fname, filebuf);
	if (fd == NULL) {
		cmndmess("Can not open temporary file.");
		return;
	}

	/* Save the current line. */
	oldline = bufln();

	/* Copy the block to the temp file. */
	bufgo(start);
	for (count = finish - start + 1; count; count--) {
		length = bufgetln(buffer, MAXLEN);
		if (length < 0) {
			cmndmess("Error reading line.");
		}
		for (i = 0; i < length; i++) {
			sysputc(buffer [i], fd);
		}
		sysputc(CR, fd);
		sysputc(LF, fd);
		bufdn();
		if (bufatbot()) {
			break;
		}
	}

	/* Close the file. */
	sysfflush(fd);
	sysfclose(fd);

	/* Restore the current line. */
	bufgo(oldline);
}


/*
	Move or copy a block of lines.
*/

movecopy(args, usage, prompt, erase)
char *args, *usage, *prompt;
int erase;
{
	int count, i, length;
	int fstart, fend, tstart;
	char buffer [MAXLEN1];

	/* Get two or three args. */
	if (get3args(args,&fstart,-1,&fend,-1,&tstart,-1)==ERROR){
		return;
	}
	if (fstart == -1 || fend == -1) {
		cmndmess(usage);
		return;
	}
	if (tstart == -1) {
		tstart = fend;
		fend   = fstart;
	}

	/* Make sure the last line exists. */
	bufgo(max(fstart, tstart));
	if (bufatbot()) {
		bufup();
		if (fstart >= tstart) {
			fend = bufln();
		}
		else {
			tstart = bufln();
		}
	}

	/*
        The 'to block' and 'from block' must not overlap.
	fstart must be > 0, tstart must be >=  0.
	*/
	if (fend < fstart ||
	    fstart <= 0 ||
	    tstart < 0 ||
	    (tstart >=	fstart && tstart < fend)
	   ) {
		cmndmess(usage);
		return;
	}

	/* Extract block to TEMPFILE. */
	xtrct(TEMPFILE, fstart, fend, prompt);

	/* Inject TEMPFILE at tstart. */
	append(TEMPFILE, tstart, prompt);

	if (erase) {
		count = fend - fstart + 1;
                /* Erase 'from block'. */
		if (fstart < tstart) {
			bufgo(fstart);
		}
		else {
			bufgo(fstart + count);
		}
		bufdeln(count);
	}

	/* Erase the TEMPFILE. */
	sysunlink(TEMPFILE);

	/* Redraw the screen. */
	bufgo(tstart);
	edclr();
	edgo(tstart, 0);
}


/*
	Return YES if buffer may be drastically changed.
*/

chkbuf()
{
	int c;
	int x, y;

	/* Save cursor position. */
	x = outgetx();
	y = outgety();

	if (bufchng() == NO) {
		return YES;
	}

	pmtmess("", "Buffer not saved.	Proceed ?  ");
	c = syscout(syscin());

	/* Restore cursor postion. */
	outxy(x, y);

	/* Watch out:  tolower may be a macro. */
        if (tolower(c) == 'y') {
		return YES;
	}
	else {
		return NO;
	}
}


/*
	Print message.
*/

message(s)
char *s;
{
	fmtsout(s,0);
	fmtcrlf();
}


/*
	Get one, two or three arguments.
	Missing arguments are set to default values.
*/

get3args(args, val1, def1, val2, def2, val3, def3)
char *args;
int  *val1, *val2, *val3;
int  def1, def2, def3;
{
	char *skiparg(), *skipbl();

	/* Skip the command. */
	args = skiparg (args);
	args = skipbl (args);

	/* Set defaults. */
	*val1 = def1;
	*val2 = def2;
	*val3 = def3;

	/* Check first arg. */
	if (*args == EOS) {
		return OK;
	}
	if (number (args, val1) == NO) {
		cmndmess("Bad argument.");
		return ERROR;
	}

	/* Skip over first argument. */
	args = skiparg(args);
	args = skipbl(args);

	/* Check second argument. */
	if (*args == EOS) {
		return OK;
	}
	if (number(args, val2) == NO) {
		cmndmess("Bad argument.");
		return ERROR;
	}

	/* Skip over third argument. */
	args = skiparg(args);
	args = skipbl(args);

	/* Check third argument. */
	if (*args == EOS) {
		return OK;
	}

	if (number (args, val3) == NO) {
		cmndmess("Bad argument.");
		return ERROR;
	}
	else {
		return OK;
	}
}


/*
	Skip over all except EOS, and blanks.
*/

char *
skiparg(args)
char *args;
{
        while (*args != EOS && *args != ' ') {
		args++;
	}
	return args;
}


/*
	Skip over all blanks.
*/

char *
skipbl(args)
char *args;
{
        while (*args == ' ') {
		args++;
	}
	return args;
}


/*
	Return YES if the user has pressed any key.
*/

chkkey()
{
	int c;

	c = syscstat();
	return (c == -1) ? NO : YES;
}


/*
	Return YES if the user has pressed any control key.
*/

chkckey()
{
	int c;

	c = syscstat();
	return (c != -1 && ((c & 0x7f) < 32)) ? YES : NO;
}


/*
	Return YES if the pattern in pat[] starts at line [0].
	A question mark in pat[] matches any character.
*/

amatch(line, pat)
char *line, *pat;
{
	while(*pat != EOS) {
		if (*pat == *line) {
			pat++;
			line++;
		}
                else if (*pat == '?' && *line != EOS) {
			pat++;
			line++;
		}
		else {
			return NO;
		}
	}
	return YES;
}


/*
	Replace oldpat in oldline by newpat starting at col.
	Put result in newline.
	Return number of characters in newline.
*/

replace(oldline,newline,oldpat,newpat,col)
char *oldline, *newline, *oldpat, *newpat;
int col;
{
	int k;
	char *tail, *pat;

	/* Copy oldline preceding col to newline. */
	k = 0;
	while (k < col) {
		newline [k++] = *oldline++;
	}

	/* Remember where end of oldpat in oldline is. */
	tail = oldline;
	pat = oldpat;
	while (*pat++ != EOS) {
		tail++;
	}

	/*
		Copy newpat to newline.
		Use oldline and oldpat to resolve question
		marks in newpat.
	*/
	while (*newpat != EOS) {
		if (k > MAXLEN-1) {
			cmndmess("New line too long.");
			return ERROR;
		}
                if (*newpat != '?') {
			/* Copy newpat to newline. */
			newline [k++] = *newpat++;
			continue;
		}

                /* Scan for '?' in oldpat. */
                while (*oldpat != '?') {
			if (*oldpat == EOS) {
				cmndmess(
                                "Too many ?'s in change mask."
				);
				return ERROR;
			}
			oldpat++;
			oldline++;
		}

		/* Copy char from oldline to newline. */
		newline [k++] = *oldline++;
		oldpat++;
		newpat++;
	}

	/* Copy oldline after oldpat to newline. */
	while (*tail != EOS) {
		if (k >=  MAXLEN-1) {
			cmndmess("New line too long.");
			return ERROR;
		}
		newline [k++] = *tail++;
	}
	newline [k] = EOS;
	return k;
}


/*
	Print a cmndmess on the command line and wait for a key.
*/

cmndmess(mess)
char * mess;
{
	int x, y;

	/* Save cursor. */
	x = outgetx();
	y = outgety();

	pmtmess("", mess);

	/* Wait for any key. */
	syscin();

	/* Restore cursor. */
	outxy(x, y);
}





/*
	RED window module -- Full C version

	Source:  red4.c
	Version: November 14, 1983;  December 10, 1983; January 9, 1985

	Copyright (C) 1983 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/


#include "red.h"


#ifdef HASSTATIC

static
char	editbuf[MAXLEN];	/* the edit buffer	*/
static
int	editp;			/* cursor: buffer index */
static
int	editpmax;		/* length of buffer	*/
static
int	edcflag;		/* buffer change flag	*/
static
int	edaflag;		/* auto mode flag	*/
static
int	edtop;			/* current top of screen */

#endif


/*
	Abort any changes made to current line.
*/

edabt()
{
	/* Get unchanged line and reset cursor. */
	edgetln();
	edredraw();
	edbegin();
	edcflag = NO;
}


/*
	Put cursor at beginning of current line.
*/

edbegin()
{
	editp = 0;
	outxy(0, outgety());
}


/*
	Move the cursor back one word.
*/

edbword()
{
	int c;

	/* Move up one line if at left margin. */
	if (editp == 0) {
		if (!bufattop()) {
			edup();
			edend();
		}
		return;
	}

	/* Scan for white space. */
	while (--editp > 0) {
		c = editbuf [editp];
                if (c == ' ' || c == TAB) {
			break;
		}
	}

	/* Scan for non-white space. */
	while (editp > 0) {
		c = editbuf [--editp];
                if (c != ' ' && c != TAB) {
			break;
		}
	}

	/* Reset cursor. */
	outxy(edxpos(),outgety());
}


/*
	Change editbuf[editp] to c.
        Don't make change if line would become to long.
*/

edchng(c)
char c;
{
	char oldc;
	int k;

	/* If at right margin then insert char. */
	if (editp >= editpmax) {
		edins(c);
		return;
	}

	/* Change char and print length of line. */
	oldc = editbuf[editp];
	editbuf[editp] = c;
	fmtadj(editbuf, editp, editpmax);

	k = fmtlen(editbuf,editp+1);
	if (k > SCRNW1) {

		/*
			The line would become too long.
			Undo the change.
		*/
		editbuf[editp] = oldc;
		fmtadj(editbuf, editp, editpmax);
	}
	else if (hascins && hascdel && editp < editpmax) {
		/*  Put the old character back (!) */
		editbuf[editp] = oldc;
		fmtadj(editbuf, editp, editpmax);

		/* Delete old character,  insert new. */
		editp++;
		eddel();
		edins(c);
	}
	else {
		/* Set change flag, bump cursor, redraw line. */
		edcflag = YES;
		editp++;
		edadj();
		edredraw();
	}
}


/*
	Indicate that the screen has been changed by
	an agent outside of this module.
*/

edclr()
{
	edtop = -1;
}


/*
	Delete the char to left of cursor if it exists.
*/

eddel()
{
	int i, k;

	/* Just move left one column if past end of line. */
	if (edxpos() < outgetx()) {
		outxy(outgetx()-1, outgety());
		return;
	}

	/* Do nothing if cursor is at left margin. */
	if (editp == 0) {
		return;
	}
	edcflag = YES;

	/* Compress buffer (delete char). */
	k = editp;
	while (k < editpmax) {
		editbuf[k-1] = editbuf[k];
		k++;
	}

	/* Update pointers, update line. */
	editp--;
	editpmax--;
	edredraw();
}


/*
	Delete the character under the cursor.
*/

ed2del()
{
	int i, k;

	/* Just move left one column if past end of line. */
	if (editp > 0 && editp == editpmax && edxpos() <= outgetx()) {
		outxy(outgetx()-1, outgety());
		return;
	}

	/* Do nothing if cursor is at left margin. */
	if (editpmax == 0) {
		return;
	}
	edcflag = YES;

	/* Compress buffer (delete char). */
	k = editp+1;
	while (k < editpmax) {
		editbuf[k-1] = editbuf[k];
		k++;
	}

	/* Adjust the cursor if now at end. */
	if (editp+1 >= editpmax && editp > 0) {
		editp--;
	}
	editpmax--;
	if (editp == editpmax && editp > 0) {
		editp--;
	}
	edredraw();
}


/*
	Edit the next line.  Do not go to end of buffer.
*/

eddn()
{
	int oldx;

	/* Save visual position of cursor. */
	oldx = outgetx();

	/* Replace current edit line. */
	edrepl();

	/* Do not go past last non-null line. */
	if (bufnrbot()) {
		if (edatbot()) {
			edsup(bufln()-SCRNL2+1);
			bufout(bufln() + 1, SCRNL1, 1);
			outxy(0, SCRNL2);
		}
		return;
	}

	/* Move down one line in buffer. */
	bufdn();
	edgetln();

	/*
		Put cursor as close as possible on this
		new line to where it was on the old line.
	*/

	editp = edscan(oldx);

	/* Update screen. */
	if (edatbot()) {
		edsup(bufln()-SCRNL2);
		outxy(oldx, SCRNL1);
	}
	else {
		outxy(oldx, outgety()+1);
	}
	return;
}


/*
	Put cursor at the end of the current line.
        Make sure it doesn't go off the screen.
*/

edend()
{
	editp = editpmax;
	edadj();
	outxy(edxpos(),outgety());
}


/*
	Move the cursor forward one word.
	Move to the next line if at end of line.
*/

edfword()
{
	int c;

	/* Move down one line if at right margin. */
	if (editp == editpmax) {
		eddn();
		edbegin();
		return;
	}

	/* Scan for white space. */
	while (++editp < editpmax) {
		c = editbuf [editp];
                if (c == ' ' || c == TAB) {
			break;
		}
	}

	/* Scan for non-white space. */
	while (editp < editpmax) {
		c = editbuf [++editp];
                if (c != ' ' && c != TAB) {
			break;
		}
	}

	/* Reset cursor. */
	edadj();
	outxy(edxpos(),outgety());
}


/*
	Start editing line n;  set editp to x.

	At one time I thought that the search and change
	commands needed a separate version of this routine
	that would try to draw the line at the top of the
	screen.  However,  that did not provide enough
	context for the person looking at the patterns.
*/

edgo(newline, x)
int newline, x;
{
	int line;
	int oldlast;

	/* Save the status of the screen. */
	oldlast  = edtop + SCRNL2;

	/* Replace current line. */
	edrepl();

	/* Go to new line. */
	bufgo(newline);

	/* Prevent going past end of buffer. */
	if (bufatbot()) {
		bufup();
	}
	newline = bufln();

	/* Do not redraw the whole screen if not needed. */
	if (edtop > 0 && newline >= edtop && newline <= oldlast) {
		/* Just move to new line. */
		line = 1 + (newline - edtop);
	}
	else if (bufln() + SCRNL/2 > bufmax()) {
		/* The line is near the end of file. */
		edtop = max(1,	bufmax() - (SCRNL-3));
		line = 1 + (bufln() - edtop);
		bufout(edtop, 1, SCRNL1);
	}
	else {
		/* Draw the line in the middle of the screen. */
		edtop = max(1, bufln() - SCRNL/2);
		line  = 1 + (bufln() - edtop);
		bufout(edtop, 1, SCRNL1);
	}

	edgetln();
	editp = x;
	outxy(edxpos(), line);
}


/*
	Insert c into the buffer if possible.
	Return YES if the line was auto-split.
*/

edins(c)
char c;
{
	int i, k;
	int oldcflag;

	/* Do nothing if edit buffer is full. */
	if (editpmax >= MAXLEN) {
		return NO;
	}

        /* Provisionally say we've made a change. */
	oldcflag = edcflag;
	edcflag  = YES;

	/* Fill out line if we are past its end. */
	if (editp == editpmax && edxpos() < outgetx()) {
		k = outgetx() - edxpos();
		editpmax = editpmax + k;
		while (k-- > 0) {
                        editbuf [editp++] = ' ';
		}
		editp = editpmax;
	}

	/* Make room for inserted character. */
	k = editpmax;
	while (k > editp) {
		editbuf[k] = editbuf[k-1];
		k--;
	}

	/* Insert character.  Update pointers. */
	editbuf[editp] = c;
	editp++;
	editpmax++;

	/* Find where the cursor will be. */
	fmtadj(editbuf,editp-1,editpmax);
	k = fmtlen(editbuf,editp);

	if (k > SCRNW1 && editp == editpmax && haswrap) {
		/* Auto-split the line (line wrap) */

		/* Scan for start of current word. */
		k = editp - 1;
                while (k >= 0 && editbuf[k] != ' ' && editbuf[k] != TAB) {
			k--;
		}

		/* Never split a word. */
		if (k < 0) {
			eddel();
			edcflag = oldcflag;
			return NO;
		}

		/* Split the line at the current word. */
		editp = k + 1;
		edsplit();
		edend();
		return YES;
	}
	else if (k > SCRNW1) {

		/*
			Cursor would move off the screen.
			Delete what we just inserted.
		*/
		eddel();
		edcflag = oldcflag;
	}
	else {
		/* Set change flag, redraw line. */
		edredraw();
	}
	return NO;
}


/*
	Join (concatenate) the current line with the one above it.
	Put cursor at the join point unless it would be off screen.
*/

edjoin()
{
	int k1, k2;
	int k;

	/* Do nothing if at top of file. */
	if (bufattop()) {
		return;
	}

	/* Replace lower line temporarily. */
	edrepl();

	/* Get upper line into buffer. */
	bufup();
	k1 = bufgetln(editbuf, MAXLEN);

	/* Append lower line to buffer. */
	bufdn();
	k2 = bufgetln(editbuf+k1, MAXLEN-k1);

        /* Abort if the line isn't wide enough. */
	if (k1 + k2 > MAXLEN1) {
		bufgetln(editbuf,MAXLEN);
		return;
	}

	/* Replace upper line, set cursor to middle of line. */
	bufup();
	editpmax = k1 + k2;
	editp = k1;
	edadj();
	edcflag = YES;
	edrepl();

	/* Delete the lower line from the buffer. */
	bufdn();
	bufdel();

	/*
		Delete the lower line on the screen,
		move up and redraw.
	*/

	if (!edattop()) {
		eddel();
		outxy(outgetx(), outgety() - 1);
		bufup();
		edredraw();
	}
	else {
		bufup();
		edtop = bufln();

		/* Redraw the ENTIRE line. */
		fmtadj (editbuf,0,editpmax);
		fmtsubs(editbuf,0,editpmax);
		outxy(edxpos(),outgety());
	}
}


/*
	Delete WORDS until end of line or c found.
*/

edkill(c)
char c;
{
	int k,p;
	int lastc;

	/* Do nothing if at right margin. */
	if (editp == editpmax) {
		return;
	}
	edcflag = YES;

	/*
		Count number of deleted characters.
		The matched char must start a word.
	*/
	k = 1;
        lastc = ' ';
	while ((editp+k) < editpmax) {
		if ( editbuf[editp+k] == c &&
		     (!isalpha(lastc) || !isalpha(c))
		   ) {
			break;
		}
		else {
			lastc = editbuf[editp+k];
			k++;
		}
	}

	/* Compress buffer (delete chars). */
	p = editp+k;
	while (p < editpmax) {
		editbuf[p-k] = editbuf[p];
		p++;
	}

	/* Update buffer size, redraw line. */
	editpmax = editpmax-k;
	edredraw();
}


/*
	Move cursor left one column.
	Never move the cursor off the current line.
*/

edleft()
{
	int k;

	/* If past right margin, move left one column. */
	if (edxpos() < outgetx()) {
		outxy(max(0, outgetx()-1), outgety());
	}

	/* Inside the line.  move left one character. */
	else if (editp != 0) {
		editp--;
		outxy(edxpos(),outgety());
	}
}


/*
	Insert a new blank line below the current line.
*/

ednewdn()
{
	/*
		Make sure there is a current line and
		Put the current line back into the buffer.
	*/
	if (bufatbot()) {
		bufins(editbuf,editpmax);
	}
	edrepl();

	/* Move past current line. */
	bufdn();

	/* Insert place holder:  zero length line. */
	bufins(editbuf,0);

	/* Start editing the zero length line. */
	edgetln();

	/* Update the screen. */
	edind();

}


/*
	Insert a new blank line above the current line.
*/

ednewup()
{
	/* Put current line back in buffer. */
	edrepl();

	/* Insert zero length line at current line. */
	bufins(editbuf,0);

	/* Start editing the zero length line. */
	edgetln();

	/* Update the screen. */
	edinu();
}


/*
	Move cursor right one character.
	Never move the cursor off the current line.
*/

edright()
{
	/* If we are outside the line move right one column. */
	if (edxpos() < outgetx()) {
		outxy (min(SCRNW1, outgetx()+1), outgety());
	}

	/* If we are inside a tab move to the end of it. */
	else if (edxpos() > outgetx()) {
		outxy (edxpos(), outgety());
	}

	/* Move right one character if inside line. */
	else if (editp < editpmax) {
		editp++;
		edadj();
		outxy(edxpos(),outgety());
	}

	/* Else move past end of line. */
	else {
		outxy (min(SCRNW1, outgetx()+1), outgety());
	}
}


/*
	Split the current line into two parts.
	Scroll the first half of the old line up.
*/

edsplit()
{
	int p, q;
	int k;

	/* Indicate that edit buffer has been saved. */
	edcflag = NO;

	/* Replace current line by the first half of line. */
	if (bufatbot()) {
		bufins(editbuf, editp);
	}
	else {
		bufrepl(editbuf, editp);
	}

	/* Redraw the first half of the line. */
	p = editpmax;
	q = editp;
	editpmax = editp;
	editp = 0;
	edredraw();

	/* Move the second half of the line down. */
	editp = 0;
	while (q < p) {
		editbuf [editp++] = editbuf [q++];
	}
	editpmax = editp;
	editp = 0;

	/* Insert second half of the line below the first. */
	bufdn();
	bufins(editbuf, editpmax);

	/* Insert a line on the screen and draw it. */
	edind();
	edredraw();
}


/*
	Move cursor right until end of line or char c found.
	Do not move the cursor off the end of the line.
*/

edsrch(c)
char c;
{
	int lastc;

	/* Do nothing if at right margin. */
	if (editp == editpmax) {
		return;
	}

	/* Scan for search character. */
	editp++;
	if (editpmax == 0) {
                lastc = ' ';
	}
	else {
		lastc == editbuf [editp];
	}
	while (editp < editpmax) {
		if ( editbuf[editp] == c &&
		     (!isalpha(lastc) || !isalpha(c))
		   ) {
			break;
		}
		else {
			lastc = editbuf[editp];
			editp++;
		}
	}

	/* Reset cursor. */
	edadj();
	outxy(edxpos(),outgety());
}


/*
	Move cursor up one line if possible.
*/

edup()
{
	int oldx;

	/* Save visual position of cursor. */
	oldx = outgetx();

	/* Put current line back in buffer. */
	edrepl();

	/* Done if at top of buffer. */
	if (bufattop()) {
		return;
	}

	/* Start editing the previous line. */
	bufup();
	edgetln();

	/*
		Put cursor on this new line as close as
		possible to where it was on the old line.
	*/
	editp = edscan(oldx);

	/* Update screen. */
	if (edattop()) {
		edsdn(bufln());
		outxy(oldx, 1);
	}
	else {
		outxy(oldx, outgety()-1);
	}
}


/*
	Delete the current line.
*/

edzap()
{
	int k;

	/* Delete the line in the buffer. */
	bufdel();

	/* Move up one line if now at bottom. */
	if (bufatbot() && edattop()) {
		bufup();
		edtop = bufln();
		edgetln();
		edredraw();
	}
	else if (bufatbot()) {
		eddel();
		outxy(0, outgety() - 1);
		bufup();
		edgetln();
	}
	else {
		eddel();
		edgetln();
	}
}


/* ----- utility routines (not used outside this file) ----- */


/*
	Adjust the cursor position so the cursor stays on screen.
	This must be called whenever the cursor could move right,
	i.e., in edchng(), edend(), edjoin(), edright() and edsrch().
*/

edadj()
{
	while (fmtlen(editbuf, editp) > SCRNW1) {
		editp--;
	}
}


/*
	Return true if the current edit line is being
	Displayed on the bottom line of the screen.
*/

edatbot()
{
	return outgety() == SCRNL1;
}


/*
	Return true if the current edit line is being
	displayed on the bottom line of the screen.
*/

edattop()
{
	return outgety() == 1;
}


/*
	Redraw edit line from index to end of line and
	reposition cursor.
*/

edredraw()
{
	fmtadj(editbuf,0,editpmax);
	fmtsubs(editbuf,max(0,editp-1),editpmax);
	outxy(edxpos(),outgety());
}


/*
	Return the x position of the cursor on screen.
*/

edxpos()
{
	return fmtlen(editbuf, editp);
}


/*
	Fill edit buffer from current main buffer line.
	The caller must check to make sure the main
	buffer is available.
*/

edgetln()
{
	int k;

	/* Put cursor on left margin, reset flag. */
	editp = 0;
	edcflag = NO;

	/* Get edit line from main buffer. */
	k = bufgetln(editbuf,MAXLEN);
	if (k > MAXLEN) {
		error("line truncated");
		editpmax = MAXLEN;
	}
	else {
		editpmax = k;
	}
	fmtadj(editbuf,0,editpmax);
}


/*
	Replace current main buffer line by edit buffer.
	The edit buffer is NOT changed or cleared.
*/

edrepl()
{
	/* Do nothing if nothing has changed. */
	if (edcflag == NO) {
		return;
	}

        /* Make sure we don't replace the line twice. */
	edcflag = NO;

	/* Insert instead of replace if at bottom of file. */
	if (bufatbot()) {
		bufins(editbuf,editpmax);
	}
	else {
		bufrepl(editbuf,editpmax);
	}
}


/*
	Set editp to the largest index such that
	buf[editp] will be printed <= xpos
*/

edscan(xpos)
int xpos;
{
	editp = 0;
	while (editp < editpmax) {
		if (fmtlen(editbuf,editp) < xpos) {
			editp++;
		}
		else {
			break;
		}
	}
	return editp;
}


/*
	Scroll the screen up.  Topline will be new top line.
*/

edsup(topline)
int topline;
{
	edtop = topline;
	if (hasdel == YES) {

		/* Delete line 1. */
		outxy(0, 1);
		outdel();

		/* Redraw bottom line. */
		bufout(topline+SCRNL2,SCRNL1,1);
	}
	else if (hasup == YES) {

		/* Hardware scroll. */
		outsup();

		/* Redraw bottom line. */
		bufout(topline+SCRNL2,SCRNL1,1);

		/* Restore the prompt line. */
		pmtzap();
	}
	else {

		/* Redraw whole screen. */
		bufout(topline,1,SCRNL1);

		/* Restore the prompt line. */
		pmtzap();
	}
}


/*
	Scroll screen down.  Topline will be new top line.
*/

edsdn(topline)
int topline;
{
	edtop = topline;
	if (hasins == YES) {

		/* Insert a line above line 1. */
		outxy(0, 1);
		outins();

		/* Redraw top line. */
		bufout(topline,1,1);
	}
	else if (hasdn == YES) {

		/* Hardware scroll. */
		outsdn();

		/* Redraw top line. */
		bufout(topline,1,1);

		/* Redraw the prompt line. */
		pmtzap();
	}
	else {

		/* Redraw whole screen. */
		bufout(topline,1,SCRNL1);

		/* Redraw the prompt line. */
		pmtzap();
	}
}


/*
	Insert one line below the current line on the screen.
*/

edind()
{
	int y;

	if (edatbot()) {
		edsup(bufln()-SCRNL2);
		outxy(edxpos(),SCRNL1);
	}
	else if (hasins == YES) {
		y = outgety();
		outxy(0, y+1);
		outins();
		outxy(edxpos(), y+1);
	}
	else {
		y = outgety();
		bufout(bufln(), y+1, SCRNL1-y);
		outxy(edxpos(), y+1);
	}
}


/*
	Insert a line above the current line on the screen.
*/

edinu()
{
	int y;

	if (hasins == YES) {
		y = outgety();
		outins();
		outxy(edxpos(), y);
	}
	else if (edattop()) {
		edsdn(bufln());
		outxy(edxpos(), 1);
	}
	else {
		y = outgety();
		bufout(bufln(), y, SCRNL - y);
		outxy(edxpos(), y);
	}
}


/*
	Delete one line from the screen.
*/

eddel()
{
	int y;

	/* Remember what line we are on. */
	y = outgety();

	if (hasdel == YES) {
		outdel();
		bufout(bufln() + SCRNL1 - y, SCRNL1, 1);
	}
	else if (edattop()) {
		edsup(bufln());
		bufout(bufln() + SCRNL1 - y, SCRNL1, 1);
	}
	else {
		bufout(bufln(), y, SCRNL - y);
	}

	/* Set cursor to beginning of line. */
	outxy(0, y);
}





/*
	RED output format module -- Full C version

	Source:  red5.c
	Version: September 16, 1983;  October 16, 1983

	Copyright (C) 1983 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"

#ifdef HASSTATIC

static
int fmttab;	/* maximal tab length			*/
static
int fmtdev;	/* device flag -- YES/NO = LIST/CONSOLE */
static
int fmtwidth;	/* devide width.  LISTW/SCRNW1		*/

/*
	fmtcol[i] is the first column at which buf[i] is printed.
	fmtsub() and fmtlen() assume fmtcol[] is valid on entry.
*/
static
int fmtcol[MAXLEN1];

#endif


/*
	Direct output from this module to either the console or
	the list device.
*/

fmtassn(listflag)
int listflag;
{
	if (listflag == YES) {
		fmtdev = YES;
		fmtwidth = LISTW;
	}
	else {
		fmtdev = NO;
		fmtwidth = SCRNW1;
	}
}


/*
	Adjust fmtcol[] to prepare for calls on fmtout() and
	fmtlen().

	NOTE:  this routine is needed as an efficiency measure.
	Without fmtadj(), calls on fmtlen() become too slow.
*/

fmtadj(buf,minind,maxind)
char *buf;
int minind, maxind;
{
int k;
	/* Line always starts at left margin. */
	fmtcol[0] = 0;

	/* Start scanning at minind. */
	k = minind;
	while (k<maxind) {
		fmtcol[k+1] = fmtcol[k]+fmtlench(buf[k],fmtcol[k]);
		k++;
	}
}


/*
	Return column at which at which buf[i] will be printed.
*/

fmtlen(buf,i)
char *buf;
int i;
{
	return(fmtcol[i]);
}

/*
	Print buf[i] ... buf[j-1] on current device so long as
	characters will not be printed in last column.
*/

fmtsubs(buf,i,j)
char *buf;
int i, j;
{
	int k;

	if (fmtcol[i] >= fmtwidth) {
		return;
	}

	/* Position the cursor. */
	outxy(fmtcol[i],outgety());
	while (i < j) {
		if (fmtcol[i+1] > fmtwidth) {
			break;
		}
		fmtoutch(buf[i],fmtcol[i]);
		i++;
	}

	/* Clear rest of the line. */
	outdeol();
}


/*
	Print string which ends with NEWLINE or EOS
	to current device.
	Truncate the string if it is too long.
*/

fmtsout(buf,offset)
char *buf; int offset;
{
	char c;
	int col,k;

	col = 0;
	while (c = *buf++) {
		if (c == NEWLINE) {
			break;
		}
		k = fmtlench(c,col);
		if (col + k + offset > fmtwidth) {
			break;
		}
		fmtoutch(c,col);
		col += k;
	}
}


/*
	Return length of char c at column col.
*/

fmtlench(c,col)
char c;
int col;
{
	if (c == TAB) {
		/* tab every fmttab columns */
		return(fmttab-(col%fmttab));
	}
	else if (c<32) {
		/* control char */
		return(2);
	}
	else {
		return(1);
	}
}


/*
	Output one character to current device.
	Convert tabs to blanks.
*/

fmtoutch(c,col)
char c;
int col;
{
	int k;

	if (c == TAB) {
		k = fmtlench(TAB,col);
		while ((k--)>0) {
                        fmtdevch(' ');
		}
	}
	else if (c<32) {
                fmtdevch('^');
		fmtdevch(c+64);
	}
	else {
		fmtdevch(c);
	}
}


/*
	Output character to current device.
*/

fmtdevch(c)
char c;
{
	if (fmtdev == YES) {
		syslout(c);
	}
	else {
		outchar(c);
	}
}

/*
	Output a CR and LF to the current device.
*/

fmtcrlf()
{
	if (fmtdev == YES) {
		syslout(CR);
		syslout(LF);
	}
	else if (hasdel == YES) {
		outxy(0, 1);
		outdel();
		outxy(0, SCRNL1);
		outdelln();
	}
	else {
		outxy(0,SCRNL1);
		syscout(CR);
		syscout(LF);
		pmtzap();
		pmtupd();
	}
}


/*
	Set tabs at every n columns.
*/

fmtset(n)
int n;
{
	fmttab = max(1,n);
}





/*
	RED terminal output module -- Customized for IBM PC.
	Source:  red6.c
	Version: December 1, 1984; March 8, 1985
*/

#include "red.h"


/*
Define the current coordinates of the cursor.
*/

#ifdef HASSTATIC
static
int outx;
static
int outy;
#endif


/*
Return the current coordinates of the cursor.
*/

outgetx()
{
	return outx;
}

outgety()
{
	return outy;
}


/*
Initialize the globals which describe the terminal.
*/

outinit()
{
	hasdn  = NO;
	hasup  = NO;
	hasins = YES;
	hasdel = YES;
	hasint = YES;
	hascol = YES;
	hascins = NO;
	hascdel = NO;
	haswrap = YES;
}


/*
Output one printable character to the screen.
*/

outchar(c)
char c;
{
	syscout(c);
	outx++;
	return c;
}


/*
Position cursor to position x,y on screen.
0,0 is the top left corner.
*/

outxy(x,y)
int x, y;
{
	outx = x;
	outy = y;

#ifdef DESMET
	scrrowcol(y,x);
#endif

}


/*
Erase the entire screen.
Make sure the rightmost column is erased.
*/

outclr()
{
	int i;

#ifdef DESMET
	scrclr();
#else
	for (i = 0; i < SCRNL; i++) {
		outxy(0, i);
		outdelln();
	}
	outxy(0,0);
#endif

}


/*
Delete the line on which the cursor rests.
Leave the cursor at the left margin.
*/

outdelln()
{
	outxy(0,outy);
	outdeol();
}


/*
Delete to end of line.
Assume the last column is blank.
*/

outdeol()
{

#ifdef DESMET
	scrclrl();
#endif

}


/*
Hardware insert line.
*/

outins()
{

#ifdef DESMET
	scrscrdn(1,outy,0,24,79);
#endif

}


/*
Hardware delete line.
*/

outdel()
{
#ifdef DESMET
	scrscrup(1,outy,0,24,79);
#endif

}


/*
Scroll the screen up.
Assume the cursor is on the bottom line.
*/

outsup()
{

#ifndef DESMET
	/* auto scroll */
	outxy(0,SCRNL1);
	syscout(10);
#endif

}


/*
Scroll screen down.
Assume the cursor is on the top line.
*/

outsdn()
{

#ifndef DESMET
	outxy(0,0);
#endif

}


/*
Hardware insert character.
*/

outcins(c)
int c;
{}


/*
Hardware delete character.
*/

outcdel()
{}





/*
	RED prompt line module -- Full C version

	Source:  red7.c
	Version: October 22, 1983;  December 18, 1983

	Copyright (C) 1983 by

		Edward K. Ream
		1850 Summit Ave.
		Madison, WI 53705
		(608) 231 - 2952
*/


#include "red.h"


#ifdef HASSTATIC
static int	pmtzapped;
static int	pmthold;
static int	pmtline;
static int	pmtcol;
static int	pmtnewfn;
static char	pmtmode [MAXLEN];
static int	pmtnewmd;
#endif


/*
	Initialize this module.
*/

pmtclr()
{
	pmtzapped = YES;
	pmthold   = NO;
	pmtnewmd  = YES;
	pmtnewfn  = YES;
}


/*
	Disable updates to the prompt line.
*/

pmthold(flag)
int flag;
{
	pmthold = flag;
}


/*
	Indicate that the prompt line has been overwritten.
*/

pmtzap()
{
	pmtzapped = YES;
}


/*
	Update the prompt line as needed.
*/

pmtupd()
{
	int x, y;

	if (pmthold == YES) {
		return;
	}

	/* Save cursor postion. */
	x = outgetx();
	y = outgety();

	pmt1upd(x);

	/* Restore cursor position. */
	outxy(x, y);
}


pmt1upd(x)
int x;
{
	int i;

	/* Clear the line if it may have been corrupted. */
	if (pmtzapped == YES) {
		outxy(0, 0);
		outdelln();
	}

	/* Update the line field. */
	if (pmtzapped == YES) {
		outxy(0, 0);
		fmtsout("line: ",0);
		putdec(bufln(), 5);
	}
	else if (bufln() != pmtline) {
		outxy(6, 0);
		putdec(bufln(),5);
	}
	pmtline = bufln();

	/* Update the column field. */
	if (hascol == YES && pmtzapped == YES) {
		outxy(12, 0);
		fmtsout("column: ", 12);
		putdec(x, 3);
	}
	else if (hascol == YES &&  x != pmtcol) {
		outxy(20,0);
		putdec(x, 3);
	}
	pmtcol = x;

	/* Update the file name field. */
	if (pmtzapped == YES || pmtnewfn == YES) {
		outxy(25,0);
		if (gfile [0] == EOS) {
			fmtsout(" ..no file.. ",25);
		}
		else {
			fmtsout(gfile,25);
			for (i = 0; i < 14 - strlen(gfile); i++) {
				fmtsout(" ", 0);
			}
		}
	}
	pmtnewfn = NO;

	/* Update the mode field. */
	if (pmtzapped == YES || pmtnewmd == YES) {
		outxy(41,0);
		fmtsout(pmtmode,41);
		outdeol();
	}
	pmtnewmd = NO;

	/* Clear the zapped flag. */
	pmtzapped = NO;
}


/*
	Put error message on prompt line.
	Do NOT restore the cursor.
*/

pmtmess(s1,s2)
char *s1, *s2;
{
	/* Make sure line is correct. */
	pmtzapped = YES;
	pmt1upd(outgetx());

	/* Output error messages. */
	outxy(41, 0);
	outdeol();
	fmtsout(" ", outgetx());
	fmtsout(s1,  outgetx());
	fmtsout(" ", outgetx());
	fmtsout(s2,  outgetx());

	/* Make sure the mode field gets restored. */
	pmtnewmd = YES;
}


/*
	Change the mode immediately.
*/

pmtmode(newmode)
char *newmode;
{
	if (strcmp(newmode, pmtmode) != 0) {
		strcpy(pmtmode, newmode);
		pmtnewmd = YES;
		pmthold(NO);
	}
	pmtupd();	/* 12/18/83 */

}


/*
	Indicate that the global file name has been changed.
*/

pmtfn()
{
	pmtnewfn = YES;
}


/*
	Return the position of the next free spot on the line.
*/

pmtlast()
{
	return 41 + strlen(pmtmode);
}





/*
	RED operating system module -- Full C version

	Source:  red8.c
	Version: December 3, 1984

	Copyright (C) 1983, 1984 by:
		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"

#ifdef HASSTATIC

#define SYSAHEAD 20
static
char sysinbuf[128];		/* file buffer		*/
static
int  sysincnt;			/* index to sysinbuf[]	*/
static
char syscbuf[MAXLEN];		/* typeahead buffer	*/
static
int  sysccnt;			/* index for syscbuf[]	*/
static
int  sysrcnt;			/* repeat count 	*/
static
int  syslastc;			/* last character	*/
static
int  systopl,systopy,sysnl;	/* interrupt info	*/

#endif


/*
	NOTE:  This module should contain ALL routines that
	might have to be changed for different compilers or
	different operating systems.  Please let me know if
	you have to make a change to a routine that is	NOT
        in this module  -- that's a portability bug.

	Some routines in this module probably will probably
	work regardless of operating system.  These I have
	called PORTABLE routines.
*/


/*
	Initialize the system module.

	The storage allocation routines are a real problem.
	The AZTEC and DRI compilers completely botch it.
*/

sysinit()
{
	/*
		System dependent part.
		This code sets the "moat" (in Unix terminology),
		i.e., the amount of space that is guarenteed for
		use by the stack by the memory allocation routines.
                If you don't reserve enough space for the stack
		the inject, extract, move and copy commands will crash.
	*/

#ifdef DESMET
	scrsetup();
	freeall(4000);
#endif

	/*
		PORTABLE part.
	*/
	sysnl	 = 0;
	sysccnt  = 0;
	sysrcnt  = 0;
	syslastc = 0;
}

/*
	Define some simple functions.

	Warning:  some systems object if these "functions"
	are not defined as macros in <stdio.h>.
*/

#ifdef DESMET

min(a, b)
int a, b;
{
	return (a < b) ? a : b;
}

max(a,b)
int a, b;
{
	return (a > b) ? a : b;
}

#endif


/*
	Return a pointer to a block of n contiguous bytes.
	Return NULL (i.e.,  0) if fewer than n bytes remain.
*/

char *
sysalloc(n)
int n;
{
	char *malloc();
	return malloc(n);
}


/*
	Move a block of memory.

	This code MUST work regardless of whether the
	source pointer is above or below the dest pointer.

	The for loop below is PORTABLE,  but this is time-
	critical code;	it should work as fast as possible.
	It may be worth your while to rewrite it in assembly
	language.
*/

sysmove(source, dest, count)
char source [], dest [];
int count;
{

#ifdef DESMET
	move(count, source, dest);
#else
	int i;

	if (count <= 0) {
		return;
	}
	else if (source > dest) {
		/* Copy head first. */
		for (i = 0; i < count; i++) {
			dest [i] = source [i];
		}
	}
	else {
		/* Copy tail first. */
		for (i = count - 1; i >= 0; i--) {
			dest [i] = source [i];
		}
	}
#endif

}


/*
	Save info for interrupted screen update.
	This routine is PORTABLE.
*/

sysintr(systl, systy, sysn)
int systl, systy, sysn;
{
	systopl = systl;
	systopy = systy;
	sysnl	= max(0,sysn);
}


/*
	Return -1 if no character is ready from the keyboard.
	Otherwise, return the character itself.

	This routine handles typeahead buffering.  It would
	also handle the repeat key,  if that feature is used,
	which it is NOT at present.  The code enclosed in
	comments handles the repeat key.
*/

int
syscstat()
{
	int c, i;

	/* Always look for another character. */

#ifdef DESMET
	c = scrcsts();
#endif

	/* comment out --------------- handle the repeat key
	if (c == REP1 && syslastc != 0) {
		sysrcnt = max(1, 2*sysrcnt);
		for (i = 0; i < sysrcnt && sysccnt < MAXLEN; i++) {
			syscbuf [sysccnt++] = syslastc;
		}
	}
	else
	--------------- end comment out */

	if (c != 0) {
		syslastc = c;
		sysrcnt  = 0;
		syscbuf [sysccnt++] = c;
	}

	if (sysccnt > 0) {
		return syscbuf [--sysccnt];
	}
	else {
		return -1;
	}
}


/*
	o  Wait for next character from the console.
	o  Do NOT echo the character.
	o  Print any waiting lines if there is no input ready.
	o  Swap out any dirty blocks if nothing else is happening.
	   (The SWAP constant enables this feature)
*/

int
syscin()
{
	int c;

	while ((c=syscstat()) == -1) {

		/* Output queued ? */
		if (hasint == YES && sysnl > 0) {
			/* Print one line. */
			bufout(systopl, systopy, sysnl);
		}

#ifdef SWAP
		/* Do not interrupt screen activity. */
		if (sysnl == 0) {
			/* Swap out one dirty buffer. */
			swapone();
		}
#endif

	}

#ifdef IBM

	/* Handle cursor keys and the numeric keypad. */
	switch (c) {

		case 200:	return c;	/* Home key.	  */
		case 201:	return c;	/* End key.	  */

		case 202:	return PAGEUP; /* Page up key.	 */
		case 203:	return PAGEDN; /* Page down key. */
		case 206:	return UPINS;	/* Insert key */
		case 207:	return ZAP;	/* Delete Key */

		case 28:	return RIGHT;	/* Arrow keys. */
		case 29:	return LEFT;
		case 30:	return UP;
		case 31:	return DOWN;
	}

#endif

	return c & 0x7f;
}


/*
	Wait for all console output to be finished.
	This routine is PORTABLE.
*/

syswait()
{
	while (hasint == YES && sysnl > 0) {
		bufout(systopl, systopy, sysnl);
	}
}


/*
	Print one character on the console.
*/

syscout(c)
char c;
{

#ifdef DESMET
	co(c);
#endif
	return c;
}


/*
	Print character on the printer.
*/

syslout(c)
char c;
{

#ifdef DESMET
#define PRINTER 5
	os(PRINTER, c);
#endif

	return c;
}


/* ----- BUFFERED file I/O routines -----

	RED uses two types of file routines:

	BUFFERED  file	routines  allow one character at a time
	to be read from or written to a file.	 Buffered files
	are   created  and  opened   with  the	sysfopen()  and
	sysfcreat() routines,	which return a pointer to FILE.
	FILE  is usually defined to be a struct,   but FILE may
	be defined to be anything at all so  long  as  all  the
	buffered file routines agree on what it is.

	UNBUFFERED  routines  allow  blocks  of  characters  to
	be read from a file.   Unbuffered files are created and
	opened	with  the  sysopen()  and  syscreat() routines.
	(Note  the  slightly  different names from the buffered
	counterparts).	 Sysopen() and sycreat() must return an
	integer.

	RED  never  mixes  buffered  and  unbuffered  routines.
	That is,  no BUFFERED routine is ever called to operate
	on a file which  has  been  opened  with  sysopen()  or
	syscreat()  and  no   UNBUFFERED   file routine is ever
	called to operate on a file which has been opened  with
	sysfopen() or sysfcreat().

	Buffered files are open either for reading or writing --
	never  for  both.  RED follows this restriction in order
	to make writing this  module  easier.	 Buffered  INPUT
	files are opened with sysfopen().  Buffered OUTPUT files
	are created with sysfcreat().

	All file routines in this module are SEMI-PORTABLE, i.e.,
	they will work on any system which supports the Unix
	system calls.  If your operating system does not support
	Unix-style calls,  then you may have to do a LOT of work
	to get these calls up and running.
*/


/*
	Create a buffered output file.
	The file is cleared (erased) if it already exists.
	A pointer to FILE is returned if all goes well.
	NULL (0), is returned if the file can not be created.
*/

#ifdef DESMET

int
sysfcreat(filename, buffer)
char *filename;
FILE * buffer;
{
	return creat(filename);
}

#else

FILE *
sysfcreat(filename, buffer)
char *filename;
FILE * buffer;
{
}

#endif


/*
	Open a buffered input file.
	Position the file at its start.
	A pointer to FILE is returned if all goes well.
	NULL (0) is returned if the file does not exist.
*/

#ifdef DESMET

int
sysfopen(filename, buffer)
char *filename;
FILE *buffer;
{
	return fopen(filename, "r");
}

#else

FILE *
sysfopen(filename, buffer)
char *filename;
FILE *buffer;
{
	FILE *fopen();
	return fopen(filename, "r");
}

#endif


/*
	Close a buffered file.
	Return OK (0) or ERROR (-1).
*/

int
sysfclose(fd)
FILE *fd;
{
	return fclose(fd);
}


/*
	Prepare a buffered output file to be closed.
	Return OK (0) or ERROR (-1).

*/

int
sysfflush(fd)
FILE *fd;
{
}


/*
	Get the next charcharacer from a buffered input file.
	The high bit of the character MUST be set to zero.

	ERROR or CPMEOF may be returned on end-of-file.
	RED checks for either,	so choose whichever (or both)
	is easiest for your system.
*/

int
sysgetc(fd)
FILE *fd;
{
	int c;

	c = getc(fd);

	/* Be careful not to mask off bit on EOF. */
	return (c == ERROR) ? ERROR : c & 0x7f;

}


/*
	Read the next line from buffered input file.
	End the line with an NEWLINE.
	Return the count of the characters read.
	Return ERROR (-1) on end-of-file.
*/

int
sysfgets(fd, buffer, maxlen)
FILE *fd;
char *buffer;
int maxlen;
{
	int c, count;

	count = 0;
	while(1) {
		c = sysgetc(fd);
		if (c == CR) {
			/* Ignore pseudo newline. */
			continue;
		}
		else if (c == CPMEOF || c == ERROR) {
			buffer [min(count, maxlen-2)] = NEWLINE;
			buffer [min(count, maxlen-1)] = EOS;
			return ERROR;
		}
		else if (c == NEWLINE) {
			buffer [min(count, maxlen-2)] = NEWLINE;
			buffer [min(count, maxlen-1)] = EOS;
			return count;
		}
		else if (count < maxlen - 2) {
			buffer [count++] = c;
		}
		else {
			count++;
		}
	}
}


/*
	Put one character to a buffered output file.
	Returns the character itself,  or ERROR if the
	disk becomes full.
*/

int
sysputc(c, fd)
char c;
FILE *fd;
{
	return putc(c, fd);
}


/* ----- UNBUFFERED file I/O routines -----

	See comments  at the start of the section
	concerning BUFFERED I/O routines.
*/


/*
	Create an unbuffered file.  Erase it if it exists.
	Leave it open for read/write access.
	Return a small positive int or ERROR  (-1).
*/

int
syscreat(filename)
char * filename;
{
	return creat(filename);
}


/*
	Open an existing file for unbuffered i/o.
		Mode 0 -- read only access
		Mode 1 -- write only access
		Mode 2 -- read/write access
	Return OK (0) or ERROR (-1).
*/

int
sysopen(name, mode)
char *name;
int mode;
{
	return open(name, mode);
}


/*
	Close an unbuffered file.
	Return OK (0) or ERROR (-1).
*/

int
sysclose(fd)
int fd;
{
	return close(fd);
}


/*
	Erase the file from the file system.
	RED makes sure that the file is NOT open when
	sysunlink() is called.
	Return ERROR (-1) if the file does not exist or
	can not be erased.
*/

int
sysunlink(filename)
char * filename;
{
	return unlink(filename);
}


/*
	Rename the old file to be the new file.
	RED makes sure that the file is NOT open when
	sysrename() is called.
*/

sysrename(oldname, newname)
char *oldname, *newname;
{
	rename(oldname, newname);
}


/*
	Seek to the specified block of an unbuffered file.
	Return OK (0) or ERROR (-1).
*/

int
sysseek(fd, block)
int fd, block;
{

#ifdef DESMET
	return (lseek(fd, (long) DATASIZE * block, 0) == -1L) ? ERROR : OK;
#endif

}


/*
	Read one block (READSIZE sectors) from an unbuffered
	file into the buffer of size DATASIZE.
	Return the number of sectors read or -1 if an
	end-of-file occurs immediately.
	If less than a full block is read,  put a CPMEOF mark
	after the last byte.
*/

int
sysread(fd, buffer)
int fd;
char * buffer;
{
	int n;

	n = read(fd, buffer, DATASIZE);
	if (n == ERROR) {
		return 0;
	}
	else if (n == DATASIZE) {
		return READSIZE;
	}
	else {
		/* Force an end-of-file mark */
		buffer [n] = CPMEOF;
		return READSIZE;
	}
}


/*
	Write n sectors from the buffer to an unbuffered file.
	Return n if all goes well.
	Return ERROR (-1) if there is some problem.
*/

int
syswrite(fd, buffer, n)
int fd;
char * buffer;
int n;
{

#ifdef DESMET
	return (write(fd, buffer, n*CPMSIZE) == -1) ? ERROR : n;
#endif

}


/*
	Return YES if the file exists and NO otherwise.
	This routine is PORTABLE.
*/

int
sysexists(filename)
char * filename;
{
	int fd;
	if ((fd = sysopen(filename, 0)) != ERROR) {
		sysclose(fd);
		return YES;
	}
	else {
		return NO;
	}
}


/*
	Copy a file name from args to buffer.
	This routine is SEMI-PORTABLE,	since it depends,
	to a certain extent,  on what constitutes a file name.
*/

syscopfn(args,buffer)
char *args, *buffer;
{
	int n;

	for (n = 0;
             n < SYSFNMAX -1 && args [n] != EOS && args [n] != ' ';
	     n++) {

		buffer [n] = args [n];
	}
	buffer[n] = EOS;
}





/*
	RED general utilities -- Full C version

	Source:  red9.c
	Version: September 21, 1983

	Copyright (C) 1983 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"


/*
	Return YES if the first token in args is a number.
	Return the value of the number in  *val.
*/

number(args,val)
char *args;
int  *val;
{
	if (!isdigit(args [0])) {
		return NO;
	}
	else {
		*val = atoi(args);
		return YES;
	}
}


/*
	Output adecimal integer n in field width >= w.
	Left justify the number in the field.
*/

putdec(n,w)
int n,w;
{
	char chars[10];
	int i,nd;

	nd = itoc(n,chars,10);
	i  = 0;
	while (i < nd) {
		syscout(chars[i++]);
	}
	i = nd;
	while (i++ < w) {
                syscout(' ');
	}
}


/*
	Convert integer n to character string in str.
*/

itoc(n,str,size)
int n;
char *str;
int size;
{
	int absval;
	int len;
	int i,j,k;

	absval = abs(n);

	/* Generate digits. */
	str[0] = 0;
	i = 1;
	while (i < size) {
                str[i++] = (absval % 10)+'0';
		absval	 = absval / 10;
		if (absval == 0) {
			break;
		}
	}

	/* Generate sign. */
	if (i < size && n < 0) {
                str[i++] = '-';
	}
	len = i-1;

	/* Reverse sign, digits. */
	i--;
	j = 0;
	while (j < i) {
		k      = str[i];
		str[i] = str[j];
		str[j] = k;
		i--;
		j++;
	}
	return len;
}


/*
	User error routine.
*/

error(message)
char *message;
{
	int x, y;

	/* Save cursor. */
	x = outgetx();
	y = outgety();

	pmtmess("Error: ",message);

	/* Wait for any key. */
	syscin();

	/* Restore cursor. */
	outxy(x, y);
}


/*
	User warning routine.
*/

warning(message)
char *message;
{
	int x, y;

	/* Save cursor. */
	x = outgetx();
	y = outgety();

	pmtmess("Warning: ",message);

	/* Wait for any key. */
	syscin();

	/* Restore cursor. */
	outxy(x, y);
}





/*
	RED buffer routines -- Full C version
	Part 1 -- goto, output and status routines.

	Source:  red10.c
	Version: May 24, 1984; June 17, 1984
	Bug fix in bufsusp: February 4, 1985

	Copyright (C) 1983, 1984, 1985 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"


/*
	Boundary conditions:

	1.  Only bufins() can extend the buffer, NOT
	    bufgo() and bufdn().

	2.  bufatbot() is true when the current line is
	    PASSED the last line of the buffer.  Both
	    bufgo() and bufdn() can cause bufatbot() to
	    become true.  bufgetln() returns a zero length
	    line if bufatbot() is true.

	3.  bmaxline is the number of lines in the buffer.
	    However, bline == bmaxline + 1 is valid and
	    it means that bline points at a null line.

	4.  All buffer routines assume that the variables
	    bbp, bline and bstart describe the current
	    line when the routine is called.  Thus, any
	    routine which changes the current line must
	    update these variables.
*/


/*
	Define the format of the status line used only by
	the bufsusp() and bufinit() routines.
*/

#define MAGIC 1234
#define STATUSLENGTH (25+SYSFNMAX)

struct STATUS {
	char stype	[5];	/* Magic byte		*/
	char stail	[5];	/* saved btail	*/
	char smaxdiskp [5];	/* saved bmaxdiskp	*/
	char smaxline	[5];	/* saved bmaxline	*/
	char sfree	[5];	/* saved bfree	*/
	char sfile [SYSFNMAX];	/* saved file name	*/
};


/*
	## bufatbot()
	Return YES if at bottom of buffer (past the last line).
*/

bufatbot()
{
	return (bline > bmaxline);
}


/*
	## bufattop()
	Return YES if at top of buffer.
*/

bufattop()
{
	return (bline == 1);
}


/*
	## bufchng()
	Return YES if the buffer has been changed.
*/

bufchng()
{
	return bcflag;
}


/*
	## bufclr()
	Clear the slot table.  This should be done after
	readfile() overwrites	the slot table.
*/

bufclr()
{
	struct BLOCK *bp;
	int i;

	for (i = 0; i < DATARES; i++) {
		bp = bbpp [i];
		bp -> dback   = ERROR;
		bp -> dnext   = ERROR;
		bp -> dlines  = 0;
		bp -> dstatus = FREE;
		bp -> dlru    = i;
		bp -> ddiskp  = ERROR;
	}
}


/*
	## bufdn()
	Move towards end of buffer.
*/

bufdn()
{
	if (bufatbot()) {
		return;
	}
	else {
		bline++;
		bufgofw();
	}
}


/*
	## bufend()
	Clean up any temporary files.
*/

bufend()
{
	if (bdatafd != ERROR) {
		sysclose(bdatafd);	/* Bug fix: 6/17/84 */
		bdatafd = ERROR;	/* Bug fix: 6/17/84 */
		sysunlink(DATAFILE);
	}
}


/*
	## bufgo(n)
	Go to line n.
	Set bbp, bline, bstart.
*/

bufgo(n)
int n;
{
	struct BLOCK *swapin();
	int distance, oldline;

	/* Put the request in range. */
	oldline  = bline;
	bline	 = min(n, bmaxline + 1);
	bline	 = max(1, bline);
	distance = bline - oldline;

	if (distance == 0) {

		/* We are already at the requested line. */
		return;
	}
	else if (distance == 1) {

		/* Go forward from here. */
		bufgofw();
		return;
	}
	else if (distance == -1) {

		/* Go back from here. */
		bufgobk();
		return;
	}
	else if (distance > 0) {
		if ( bline >
		     oldline + ((bmaxline - oldline) / 2)
		   ) {

			/* Search back from end of file. */
			bbp  = swapin(btail);
			bstart =
			    1 + bmaxline - bbp -> dlines;
			bufgobk();
			return;
		}
		else {

			/* Search forward from here. */
			bufgofw();
			return;
		}
	}
	else {
		if (bline < oldline / 2) {

			/* Search from start of file. */
			bbp	= swapin(bhead);
			bstart = 1;
			bufgofw();
			return;
		}
		else {

			/* Search back from here. */
			bufgobk();
			return;
		}
	}
}


/*
	## bufgobk()
	Search backwards from block for bline.
	The starting line number of the block is bstart.
	Set bbp and bstart.
*/

bufgobk ()
{
	struct BLOCK *swapin();
	int diskp;

	if (bbp == ERROR ||
	    bstart < 1 || bstart > bmaxline ||
	    bline  < 1 || bline  > bmaxline + 1) {

		canthappen("bufgobk 1");
	}

	/* Scan backward for the proper block. */
	while (bstart > bline) {

		/* Get the previous block in memory. */
		diskp = bbp -> dback;
		if (diskp == ERROR) {
			canthappen("bufgobk 2");
		}
		bbp = swapin(diskp);

		/* Calculate the start of the next block. */
		bstart -= bbp -> dlines;
		if (bstart <= 0) {
			canthappen("bufgobk 3");
		}
	}
}


/*
	## bufgofw()
	Search forward from parcel par for line n.
	Set bbp and bstart.
*/

bufgofw ()
{
	struct BLOCK *swapin();
	int diskp;

	/* The last line is always null. */
	if (bufatbot()) {
		return;
	}

	if (bbp == ERROR ||
	    bstart < bstart ||
	    bstart < 1 || bstart > bmaxline ||
	    bline  < 1 || bline  > bmaxline + 1) {

		canthappen("bufgofw 1");
	}

	/* Scan forward to the proper block. */
	while (bstart + bbp -> dlines <= bline) {

		/* Get the start of the next block. */
		bstart += bbp -> dlines;

		/* Swap in the next block. */
		diskp = bbp -> dnext;
		if (diskp == ERROR || bstart > bmaxline) {
			canthappen("bufgofw 2");
		}
		bbp = swapin(diskp);
	}
}


/*
	## bufinit()
	Initialize the buffer module.
	If the work file exists,  read block 0 into slot 0.
	Otherwise,  call bufnew to clear everything.
*/

bufinit()
{
	char *sysalloc();
	struct BLOCK *bp;
	struct STATUS *sp;
	int i, type;
	char *p;

	/* The data file has not been opened yet. */
	bdatafd = ERROR;

	/* Dynamically allocate all slots. */
	for (i = 0; i < MAXRES; i++) {

		p = sysalloc (BLOCKSIZE);
		if (p == 0) {
			break;
		}

#ifdef CAST
		bbpp [i] = (struct BLOCK *) p;
#else
		bbpp [i] = p;
#endif

	}

	/* Set pseudo constant. */
	DATARES = i;

	/* The code requires at least three buffers. */
	if (DATARES < 3) {
		error("Not enough room for buffers.");
		exit();
	}

#ifdef SUSPEND
	/* Do nothing if no work file. */
	if (sysexists(DATAFILE) == NO) {
		bufnew();
		return;
	}
	else {
		bdatafd = sysopen(DATAFILE, 2);
		if (bdatafd == ERROR) {
			error("Can not re-open work file.");
			exit();
		}
	}

	/* Read the first block of the work file. */
	bbp = bbpp [0];
	sysread(bdatafd, bbp);

	/*
                Restore RED's status which was written by
		the bufsusp() routine.
	*/
	bhead = 0;

	/* comment out -----
	sscanf(bbp -> ddata, "%x %x %x %x %x %s\0",
		&type,
		&btail, &bmaxdiskp, &bmaxline, &bfree,
		gfile);
	bmaxput = bmaxdiskp;
	----- end comment out */

#ifdef CAST
	sp = (struct STATUS *) bbp -> ddata;
#else
	sp = bbp -> ddata;
#endif

	type	    = atoi(sp -> stype);
	btail	    = atoi(sp -> stail);
	bmaxdiskp = atoi(sp -> smaxdiskp);
	bmaxline  = atoi(sp -> smaxline);
	bfree	    = atoi(sp -> sfree);
	strcpy(gfile, sp -> sfile);

	bmaxput   = bmaxdiskp;	/* Bug fix: 5/24/84 */

	if (type != MAGIC) {
		/* Do NOT erase the work file!! */
		error("Previous work file garbled.");
		exit();
	}

	/* Free all slots. */
	bufclr();

	/* Delete the status line. */
	bline = bstart = 1;
	swapin(0);
	bufdel();

	/* Make sure that the buffer will be saved. */
	bcflag = YES;

	/* Do not erase work file on disk error. */
	bfatal = NO;
#else
	bufnew();
#endif

}


/*
	## bufln()
	Return the current line number.
*/

bufln()
{
	return bline;
}


/*
	Return the maximum line number.
*/

bufmax()
{
	return bmaxline;
}


/*
	## bufnew()
	Clear the buffer module.
*/

bufnew()
{
	struct BLOCK *bp;

	/* Free all slots. */
	bufclr();

	/* Allocate the first slot. */
	bbp	    = bbpp [0];
	bhead	    = 0;
	btail	    = 0;
	bmaxdiskp = 0;
	bmaxput   = 0;
	bbp -> ddiskp  = 0;
	bbp -> dstatus = DIRTY;

	/* Make sure temp file is erased. */
	if (bdatafd != ERROR) {
		sysclose(bdatafd);
		bdatafd = ERROR;
		sysunlink(DATAFILE);
	}
	bfree = ERROR;

	/* Set the current and last line counts. */
	bline	   = 1;
	bmaxline = 0;
	bstart	  = 1;

	/* Indicate that the buffer has not been changed */
	bcflag = NO;

	/* Do not erase work file on disk error. */
	bfatal = NO;
}


/*
	## bufnrbot()
	Return YES if buffer is near the bottom line.
*/

bufnrbot()
{
	return (bline >= bmaxline);
}


/*
	## bufout(topline, topy, nlines)
	Put nlines lines from buffer starting with line topline at
	position topy of the screen.
*/

bufout(topline, topy, nlines)
int topline, topy, nlines;
{
	int l, x, y;

	x = outgetx();
	y = outgety();
	l = bline;

	while (nlines > 0) {
		outxy(0, topy++);
		bufoutln(topline++);
		nlines--;
		if (hasint == YES) {
			sysintr(topline,topy,nlines);
			break;
		}
	}
	outxy(x,y);
	bufgo(l);
}


/*
	## bufoutln(line)
	Print one line on screen.
*/

bufoutln(line)
int line;
{
	char buffer [MAXLEN1];
	int n;

	bufgo(line);

	if ( (bmaxline == 0 && line == 2) ||
	     (bmaxline >  0 && line == bmaxline + 1)) {
		fmtsout("---------------- End of file. ----------------",0);
		outdeol();
	}
	else if (line > bmaxline) {
		outdeol();
	}
	else {
		n = bufgetln(buffer, MAXLEN);
		n = min(n, MAXLEN);
		buffer [n] = NEWLINE;
		fmtsout(buffer, 0);
		outdeol();
	}
}



/*
	#bufrepl(line, n)
	Replace current line with the line that p points to.
	The new line is of length n.
*/

bufrepl(line, n)
char line [];
int n;
{
	/* Do not replace null line.  Just insert. */
	if (bufatbot()) {
		bufins(line, n);
		return;
	}

	/* Do not combine blocks until after insertion. */
	bufd(1);
	bufins(line, n);
	combine();
}


/*
	## bufreset(windowfile)
	Save the work file in a temporary file in preparation
	for changing windows on the screen.

	NOTE:  This routine is not used at present.
*/

bufreset(windowfile)
char windowfile;
{
	/* Make sure the work file is written. */
	swapall();

	/* Close the work file. */
	sysclose(bdatafd);
	bdatafd = ERROR;

	/* Rename the work file to be the window file. */
	sysrename(DATAFILE, windowfile);
}


/*
	## bufsaved()
	Indicate that the file has been saved.
*/

bufsaved()
{
	bcflag = NO;
}


/*
	## bufsusp()
        Suspend RED's execution for restart later.
*/

#ifdef SUSPEND
bufsusp()
{
	struct STATUS *sp;
	int length, i;
	char line [MAXLEN];

	/* Bug fix 2/4/85: make sure the data file is open. */
	if (bdatafd == ERROR) {
		bdatafd = dataopen();
	}

	/*
		Allocate space for the line.
		(This will ALWAYS be in block 0.)
	*/
	bufgo(1);
	for (i = 0; i < STATUSLENGTH; i++) {
                line [i] = ' ';
	}
	bufins(line, STATUSLENGTH);

	/*
		Set up the file status line.
		The bufinit() routines reads this line.

		The call to sprintf will also work but takes
		up about 400 hex bytes more space.
	*/

	/* comment out ----- (sprintf is a BIG function.)
	sprintf(line, "%4x %4x %4x %4x %4x %s\0",
		MAGIC, btail, bmaxdiskp, bmaxline,
		bfree, gfile);
	----- end comment out */

#ifdef CAST
	sp = (struct STATUS *) line;
#else
	sp = line;
#endif

	length = itoc(MAGIC, sp -> stype, 5);
	sp -> stype [length] = EOS;

	length = itoc(btail, sp -> stail, 5);
	sp -> stail [length] = EOS;

	length = itoc(bmaxdiskp, sp -> smaxdiskp, 5);
	sp -> smaxdiskp [length] = EOS;

	length = itoc(bmaxline, sp -> smaxline, 5);
	sp -> smaxline [length] = EOS;

	length = itoc(bfree, sp -> sfree, 5);
	sp -> sfree [length] = EOS;

	strcpy(sp -> sfile, gfile);

	/*
		Rewrite the status line WITHOUT changing
		the disk status.  This is fairly tricky;
		a call to bufrepl() here would not work.
	*/
	sysmove(line, bbp -> ddata, STATUSLENGTH);

	/* Make sure that work file is completely written. */
	swapall();
	sysclose(bdatafd);
}
#endif


/*
	## bufup()
	Move towards the head of the file.
*/

bufup()
{
	if (bufattop()) {
		return;
	}
	else {
		bline--;
		bufgobk();
	}
}





/*
	RED buffer routines -- Full C version
	Part 2 -- line routines.

	Source:  red11.c
	Version: September 18, 1983;  February 20, 1984

	Copyright (C) 1983 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"


/*
	## bgetnum(charptr)
	Get an integer given a pointer to char.

	## bputnum(charptr)
	Put an integer given a pointer to char.

	W A R N I N G:	These routines are used to get and
	put entries in the index table.  Make SURE that
	the INTSIZE constant does, in fact,  correspond
	to the size on an int.	 If it does not,  the buffer
	routines will die a horrible death.
*/

int
bgetnum(p)
char *p;
{

#ifdef CAST
	return * (int *) p;
#else
	int *ip;

	ip = p;
	return *ip;
#endif

}

bputnum(p, num)
char *p;
int num;
{

#ifdef CAST
	* (int *) p = num;
#else
	int *ip;

	ip = p;
	*ip = num;
#endif

}


/*
	The following routines manage the index table,
	which grows down from the end of each block.

	## btab(bp, index)
	## b1tab(index)
	Get an entry of the index table.

	## bsettab(bp, index, value)
	## b1settab(index, value)
	Set an entry of the index table.
*/

int
b1tab(index)
int index;
{
	return btab(bbp, index);
}

int
btab(bp, index)
struct BLOCK *bp;
int index;
{
	return bgetnum(
		bp->ddata + BUFFSIZE - (INTSIZE*(index+1)));
}

b1settab(index, value)
int index, value;
{
	bsettab(bbp, index, value);
}

bsettab(bp, index, value)
struct BLOCK  *bp;
int index, value;
{
	bputnum(bp->ddata + BUFFSIZE - (INTSIZE*(index+1)),
		 value);
}


/*
	## blen(bp, line)
	## b1len(line)
	Return the length of a line.

	## bptr(bp, line)
	## b1ptr(line)
	Return a pointer to a line.

	## bprefix(bp, line)
	## b1prefix(line)
	Return the number of chars befor the start of a line.
*/

int
b1length(line)
int line;
{
	return blength(bbp, line);
}

int
blength(bp, line)
struct BLOCK *bp;
int line;
{
	if (line < 0 || line >= bp -> dlines) {
		canthappen("blen");
	}

	if (bufatbot()) {
		/* The last line is always null. */
		return 0;
	}
	else if (line == 0) {
		return btab(bp, line);
	}
	else {
		return btab(bp, line) - btab(bp, line - 1);
	}
}

char *
b1ptr(line)
{
	char *bptr();

	return bptr(bbp, line);
}

char *
bptr(bp, line)
struct BLOCK  *bp;
int line;
{
	if (line < 0 || line >= bp -> dlines) {
		canthappen("bptr");
	}
	if (line == 0) {
		return bp -> ddata;
	}
	else {
		return bp -> ddata + btab(bp, line - 1);
	}
}

int
b1prefix(line)
int line;
{
	return bprefix(bbp, line);
}

int
bprefix(bp, line)
struct BLOCK *bp;
int line;
{
	if (line < 0 || line >= bp -> dlines) {
		canthappen("bprefix");
	}
	if (line == 0) {
		return 0;
	}
	else {
		return btab (bp, line - 1);
	}
}


/*
	The following routines make accessing fields of blocks
	a bit easier.  They also save a few bytes of memory.

	## b1nlines()
	## bnlines(bp)
	Return the number of lines in a block.

	## b1avail()
	## b1avail(bp)
	Return the number of free characters in a block.
*/

int
b1nlines()
{
	return bbp -> dlines;
}

int
bnlines(bp)
struct BLOCK *bp;
{
	return bp -> dlines;
}

int
b1avail()
{
	return bavail(bbp);
}

int
bavail(bp)
struct BLOCK *bp;
{
	if (bp -> dlines == 0) {
		return BUFFSIZE;
	}
	else {
		return BUFFSIZE - btab(bp, bp->dlines-1) -
		       (INTSIZE * bp->dlines);
	}
}


/*
	## bufdel()
	Delete the current line.
*/

bufdel()
{
	bufd(1);
	combine();
}


/*
	## bufdeln(n)
	Delete multiple lines starting with the current line.
	nlines is the number of lines to delete.
*/

bufdeln(nlines)
int nlines;
{
	bufd(nlines);
	combine();
}


/*
	## bufd(n)
	Internal delete routine.

	This routine does not combine blocks so that bufrepl()
	can wait to the last possible moment to call combine().
*/

bufd(nlines)
int nlines;
{
	int lines, slines;

	while (nlines > 0 && !bufatbot()) {

		/* The current block will become dirty. */
		isdirty(bbp);
		bcflag = YES;

		/*
			Precompute the number of lines in the
			block and the number of lines befor
			the current line.
		*/

		lines  = bbp -> dlines;
		slines = bline - bstart;

		/* Delete lines block by block. */
		if (slines == 0 && nlines >= lines) {

			/* Delete the whole block. */
			delbl(lines);
			nlines -= lines;
			checkblock("delete 1");
		}
		else if (nlines >= lines - slines) {

			/* Delete tail of the block. */
			deltail(slines, lines - slines);
			nlines -= (lines - slines);
			checkblock("delete 2");
		}
		else {
			/* Delete from middle of the block. */
			delmid(nlines);
			checkblock("delete 3");
			break;
		}
	}
}


/*
	## delbl(nlines)
        Delete the current block containing 'nlines' lines.

	There is much more to this code than meets the eye.
	First,	notice that using combine() here would slow
	down the a  multiple-line  delete  much  too  much.
	Second,  we never want to call freeblock() for the
	first block since we want any recovery	program  to
	find  the  first block of the work file at block 0.
	Third,	the  call  to  combine()  at the end of the
	bufdeln() routine will eventually fill up  block  0
	unless the entire file is deleted.
*/

delbl(nlines)
int nlines;
{
	struct BLOCK *bp1, *swapin(), *oldblock;
	int back, next, current;

	/* Point to the previous and next blocks. */
	back	= bbp -> dback;
	next	= bbp -> dnext;
	current = bbp -> ddiskp;

	/* Remember the current slot. */
	oldblock = bbp;

	/* Special case block 0. */
	if (current == 0) {

		/* Zero the block but do not actually delete. */
		bbp -> dlines = 0;
		isdirty(oldblock);

		/* Move to next block. */
		if (next != ERROR) {
			bbp = swapin(next);
		}
		bstart = bline = 1;
	}
	else if (next != ERROR) {

		/* Move to the START of the next block. */
		bbp	= swapin(next);
		bstart = bline;

		/* Adjust back pointer of new block. */
		bbp -> dback = back;
		isdirty(bbp);

		/* Adjust next pointer. */
		bp1 = swapin(back);
		bp1 -> dnext = next;
		isdirty(bp1);

		/* Actually delete the old block. */
		freeblock(oldblock);
	}
	else if (back != ERROR) {

		/*
			Move the the END of the previous block.
			Set bufatbot() true.
		*/
		bbp	 = swapin(back);
		bstart -= bbp -> dlines;
		bline	 = bstart + bbp -> dlines;

		/* Adjust forward pointer of new block. */
		bbp -> dnext = next;
		isdirty(bbp);

		/* Adjust pointer to the last block. */
		btail = back;

		/* Actually delete the old slot. */
		freeblock(oldblock);
	}
	else {
		/* Only block 0 has both links == ERROR. */
		canthappen("delbl");
	}

	/* Adjust total number of lines. */
	bmaxline -= nlines;
}


/*
	## delmid(dlines)
	Delete dlines from the current block.
	There is at least one line after the deleted lines.
*/

delmid(dlines)
int dlines;
{
	char * source, * dest;
	int  i, length, limit, line, nlines, offset;

	/* Compute some constants. */
	line   = bline - bstart;
	nlines = bbp -> dlines;

	/* Compress the block. */
	source = b1ptr(line + dlines);
	dest   = b1ptr(line);
	length = b1tab(nlines - 1) - b1tab(line + dlines - 1);
	sysmove(source, dest, length);

	/* Compress the index table. */
	offset = b1prefix(line + dlines) - b1prefix(line);
	limit  = nlines - dlines;
	for (i = line; i < limit; i++) {
		b1settab(i, b1tab(i + dlines) - offset);
	}

	/* Adjust the counts. */
	bbp -> dlines -= dlines;
	bmaxline	-= dlines;
}


/*
	## deltail(slines, nlines)
	Delete the current line and all followings lines in
	the current block.
	slines is the number of preceeding lines in the block.
*/

deltail(slines, nlines)
int slines, nlines;
{
	int next;
	struct BLOCK *swapin();

	/* Adjust the line count. */
	bbp -> dlines = slines;
	isdirty(bbp);

	next = bbp -> dnext;
	if (next != ERROR) {
		/* Move the current block forward. */
		bbp	= swapin(next);
		bstart = bline;
	}

	/* Adjust the total number of lines. */
	bmaxline -= nlines;
}


/*
	## bufgetln(line, linelen)
	Copy the current line from the buffer to line [].
	The size of line [] is linelen.
	Return k = the length of the line.
	If k > linelen then truncate k - linelen characters.
*/

bufgetln(line, linelen)
char	*line;
int	linelen;
{
	int	count, limit;
	char	*src;

	/* Return null line at the bottom of the buffer. */
	if (bufatbot()) {
		line [0] = NEWLINE;
		return 0;
	}

	/* Copy line to buffer. */
	src   = b1ptr	  (bline - bstart);
	count = b1length (bline - bstart);
	limit = min(count, linelen - 1);
	sysmove(src, line, limit);

	/* End with NEWLINE. */
	line [limit] = NEWLINE;

	/* Return the number of characters in the line. */
	return count;
}


/*
	## bufins(insline, inslen)
	Insert line before the current line.  Thus, the line
	number of the current line does not change.  The line
	ends with NEWLINE.

	This is fairly crude code, as it can end up splitting
	the current block into up to three blocks.  However,
	the combine() routine does an effective job of keeping
	the size of the average block big enough.
*/

bufins(insline, inslen)
char insline [];
int  inslen;
{
	struct BLOCK *bp2, *splitblock();
	char *dest, *source;
	int  i, length, line, nlines, prefix;

	if (inslen > BUFFSIZE) {
		canthappen("bufins 1");
	}

	/* See if the new line will fit. */
	if (inslen + INTSIZE > b1avail()) {

		/* Split off the trailing lines. */
		bp2 = splitblock();

		/* See if there is enough room in the old block. */
		if (inslen + INTSIZE > b1avail()) {

			/* Move on to the next block. */
			bstart += bbp -> dlines;
			bbp	 = bp2;

			/*
			At this point,	the new line is the
			the first line of the block.  Alas,
			we may still have to split off the
			trailing lines so the new line will fit.
			*/

			if (inslen + INTSIZE > b1avail()) {

				/* Split the block a second time. */
				splitblock();
			}
		}
	}

	if (inslen + INTSIZE > b1avail()) {
		canthappen("bufins 2");
	}


	/*
		At this point,	we know that the new line can
		be inserted before the current line with room
		for any following lines.
	*/

	isdirty(bbp);
	line   = bline - bstart;
	nlines = bbp -> dlines;

	if (nlines == 0) {

		/* Copy line to empty block. */
		sysmove(insline, bbp -> ddata, inslen);

		/* Create an index table. */
		b1settab(0, inslen);
	}
	else if (line >= nlines) {

		/* Copy line to end of block. */
		sysmove(insline,
			bbp -> ddata + b1tab(nlines - 1),
			inslen);

		/* Append index to index table. */
		b1settab(nlines, b1tab(nlines - 1) + inslen);
	}
	else {

		/* Make a hole at the current line. */
		source = b1ptr(line);
		dest   = b1ptr(line) + inslen;
		prefix = b1prefix(line);
		length = b1tab(nlines - 1) - prefix;
		sysmove(source, dest, length);

		/* Copy the new line into the hole. */
		sysmove(insline, source, inslen);

		/* Make a hole in the index table. */
		for (i = nlines; i > line; i--) {
			b1settab(i, b1tab(i - 1) + inslen);
		}

		/* Copy the new index into the hole. */
		b1settab(line, prefix + inslen);
	}

	/*
		Special case: inserting a null line at the
		end of the file is not a significant change.
	*/
	if ( ! (inslen == 0 && bufnrbot()) ) {
		bcflag = YES;
	}

	/* Bump the counts. */
	bbp -> dlines++;
	bmaxline++;

	/*
		It DOES make sense to call combine here.
		In the most common case,  after a split the
		current block might be small enough to be
		combined with the preceding block.
	*/
	combine();

	/* Check the format of the block. */
	checkblock("bufins");
}


/*
	## combine()
	Combine the current block with the preceeding and
	following blocks if possible.
	Make the new block the current bloc.
*/

combine()
{
	combine(bbp -> dback,  bbp -> ddiskp);
	combine(bbp -> ddiskp, bbp -> dnext);
}


/*
	## combine(diskp1, diskp2)
	Combine two blocks into one if possible.
	Make the new block the current block.

	Note that nline1 can be 0 because of the special case
	code in the delbl() routine.  nline2 is never 0.
*/

combine(diskp1, diskp2)
int diskp1, diskp2;
{
	struct BLOCK *bp1, *bp2, *bp3, *swapin();
	char	*source, *dest;
	int	i, length, limit, nlines1, nlines2, offset;

	/* Make sure the call makes sense. */
	if (diskp1 == ERROR || diskp2 == ERROR) {
		return;
	}

	/* Get the two blocks. */
	bp1 = swapin(diskp1);
	bp2 = swapin(diskp2);

	if ( bp1 -> dnext != diskp2 ||
	     bp2 -> dback != diskp1
	   ) {
		canthappen("combine 1");
	}

	/* Do nothing if the blocks are too large. */
	if (bavail(bp1) + bavail(bp2) < BUFFSIZE) {
		return;
	}

	/* Compute the number of lines in each block. */
	nlines1 = bp1 -> dlines;
	nlines2 = bp2 -> dlines;
	if (nlines2 <= 0) {
		canthappen("combine");
	}

	/* Copy buffer 2 to end of buffer 1. */

	source = bp2 -> ddata;
	if (nlines1 == 0) {
		dest   = bp1 -> ddata;
		offset = 0;
	}
	else {
		dest   = bp1 -> ddata + btab(bp1, nlines1-1);
		offset = btab(bp1, nlines1 - 1);
	}
	length = btab(bp2, nlines2 - 1);
	sysmove(source, dest, length);

	/* Copy table 2 to table 1. */
	for (i = 0; i < nlines2; i++) {
		bsettab(bp1, i + nlines1,
			 btab(bp2, i) + offset);
	}

	/* Both blocks are now dirty. */
	isdirty(bp1);
	isdirty(bp2);

	/* Adjust the back pointer of the next block. */
	if (bp2 -> dnext != ERROR) {
		bp3 = swapin(bp2 -> dnext);
		bp3 -> dback = bp1 -> ddiskp;
		isdirty(bp3);
	}

	/*
		Adjust the current block if needed.
		The value of bstart must be decremented
		by the OLD value of bp1 -> dlines.
	*/

	if (bbp == bp2) {
		bbp	 = bp1;
		bstart -= bp1 -> dlines;
	}

	/* Adjust the header for block 1. */
	bp1 -> dlines += bp2 -> dlines;
	bp1 -> dnext	= bp2 -> dnext;

	/* Adjust the pointers to the last block. */
	if (diskp2 == btail) {
		btail = diskp1;
	}

	/* Slot 2 must remain in core until this point. */
	freeblock(bp2);

	/* Check the format of the block. */
	checkblock("combine");
}


/*
	## freeblock(block)
	Put the block in the slot on the free list.
*/

freeblock(bp)
struct BLOCK * bp;
{
	/*
		Each block in the free list contains the
		pointer to the next block in the dnext field.
	*/
	bp -> dnext = bfree;
	bfree = bp -> ddiskp;

	/* Erase the block. */
	bp -> dlines = 0;

	/* Make sure the block is rewritten. */
	isdirty(bp);
}


/*
	## newblock(blockp)
	Create a new block linked after the current block.
	Return a pointer to the new block.
*/

struct BLOCK *
newblock (blockp)
{
	struct BLOCK *bp1, *bp2, *swapin(), *swapnew();
	int diskp;

	/* Get a free disk sector. */
	if (bfree != ERROR) {

		/* Take the first block on the free list. */
		diskp = bfree;

		/* Put the block in a free slot. */
		bp1 = swapin(diskp);

		/* Adjust the head of the free list. */
		bfree = bp1 -> dnext;
	}
	else {
		/* Get a free slot. */
		diskp = ++bmaxdiskp;
		bp1   = swapnew(diskp);
	}

	/* Link the new block after the current block. */
	bp1  -> dnext = bbp -> dnext;
	bp1  -> dback = bbp -> ddiskp;
	bbp -> dnext = diskp;
	if (bp1 -> dnext != ERROR) {
		bp2 = swapin(bp1 -> dnext);
		bp2 -> dback = diskp;
		isdirty(bp2);
	}

	/* The block is empty. */
	bp1 -> dlines = 0;
	isdirty(bp1);

	/* Return a pointer to the new block. */
	return bp1;
}


/*
	## splitblock()
	Split the current block before the current line.
	The current line, and following lines are put in
	a new block.
*/

struct BLOCK *
splitblock()
{
	struct	BLOCK *bp2;
	char	*dest, *source;
	int	nlines, nlines1, nlines2;
	int	i, length, line, offset;

	/* Create a new block. */
	bp2 = newblock();

	/* Mark both blocks as dirty. */
	isdirty(bbp);
	isdirty(bp2);

	/*
		Count the lines in each block.
		Adjust nline1 and nlines1 if bufatbot().
	*/
	line	= bline - bstart;
	nlines	= bbp -> dlines;
	nlines1 = min(nlines, bline - bstart);
	nlines2 = max(0, nlines - nlines1);

	/* Copy data area to new block. */
	if (!bufatbot()) {
		offset = b1prefix(line);
		source = bbp -> ddata + offset;
		dest   = bp2  -> ddata;
		length = b1tab(nlines - 1) - offset;
		sysmove(source, dest, length);
	}

	/* Copy index to new block. */
	for(i = 0; i < nlines2; i++) {
		bsettab(bp2, i, b1tab(i + nlines1) - offset);
	}

	/* Adjust the headers. */
	bp2  -> dlines = nlines2;
	bbp -> dlines = nlines1;

	/* Adjust the pointer to the last block. */
	if (bbp -> ddiskp == btail) {
		btail = bp2 -> ddiskp;
	}

	/* Return a pointer to the new block. */
	return bp2;
}





/*
	RED buffer routines -- Full C version
	Part 3 -- file routines

	Source:  red12.c
	Version: April 2, 1984;  April 20, 1984; March 8, 1985

	Copyright (C) 1983, 1984, 1985 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"


/*
	## dataopen()
	Open the data file.
*/

int
dataopen()
{
	/* Erase the data file if it exists. */
	sysunlink(DATAFILE);

	/* Create the data file. */
	bdatafd = syscreat(DATAFILE);
	if (bdatafd == ERROR) {
		diskerror("Can not open swap file.");
	}

	/* Close the file, reopen it for read/write access. */
	sysclose(bdatafd);
	bdatafd = sysopen(DATAFILE, 2);
	return bdatafd;
}


/*
	## dolru(bp)
	Make the slot the MOST recently used slot.
*/

dolru(bp)
struct BLOCK *bp;
{
	struct BLOCK *bp1;
	int i, lru;

	/*
		Change the relative ordering of all slots
		which have changed more recently than slot.
	 */
	lru = bp -> dlru;
	for (i = 0; i < DATARES; i++) {
		bp1 = bbpp [i];
		if (bp1 -> dlru < lru) {
			bp1 -> dlru++;
		}
	}

	/* The slot is the most recently used. */
	bp -> dlru = 0;
}


/*
	## diskerror(message)
	## diskfull()
	Disk error routines
*/

diskerror(message)
char	*message;
{
	error(message);

	/* Clear the buffer if no recovery is possible. */
	if (bfatal == YES) {
		bufnew();
	}

	/* Abort the operation that caused the error. */
	longjmp(DISKERR, ERROR);
}

diskfull()
{
	diskerror("Disk or directory full?");
}

diskrdy()
{
	diskerror("Drive not ready?");
}


/*
	## isdirty(slot)
	Indicate that a slot must be saved on the disk.
*/

isdirty(bp)
struct BLOCK *bp;
{
	bp -> dstatus = DIRTY;
}


/*
	## putblock(blockp, diskp)
	Put out the block-sized buffer to the disk sector.
*/

putblock(bp, diskp)
struct	BLOCK *bp;
int	diskp;
{
	int s;

	/* Make sure blocks are written in order. */
	if (diskp > bmaxput + 1) {
		swapsync(bmaxput + 1, diskp - 1);
	}
	bmaxput = max(bmaxput, diskp);

	/* Seek to the correct sector of the data file. */
	s = sysseek(bdatafd, diskp);
	if (s == -1) {
		diskfull();
	}

	/* Write the block to the data file. */

#ifdef CAST
	if (syswrite(bdatafd, (char *) bp,
	    READSIZE) != READSIZE) {
		diskfull();
	}
#else
	if (syswrite(bdatafd, bp,
	    READSIZE) != READSIZE) {
		diskfull();
	}
#endif

}


/*
	## putbuf(avail)
	Fill in the header fields of the output buffer and
	write it to the disk.
	avail is the number of free characters in the buffer.
*/

char *
putbuf(avail)
int avail;
{
	struct BLOCK *bp;

	/*
		Fill in the back and next links immediately.
		This can be done because we are not waiting
		for the LRU algorithm to allocated disk blocks.
		The last block that putbuf() writes will have
		an incorrect next link.  Readfile() will make
		the correction.
	*/

#ifdef CAST
	bp = (struct BLOCK *) bbuff;
#else
	bp = bbuff;
#endif

	bp -> dback  = bmaxdiskp - 1;
	bp -> dnext  = bmaxdiskp + 1;
	bp -> dlines = bline - bstart;

	if (avail < 0) {
		canthappen("putbuf");
	}

	/* Update block and line counts. */
	bmaxdiskp++;
	bstart = bline;

	/* Write the block. */
	putblock(bbuff, bmaxdiskp - 1);
}


/*
	## putslot(bp)
	Write out the slot to the data file.
*/

putslot(bp)
struct BLOCK *bp;
{
	if (bp -> ddiskp == ERROR) {
		canthappen("putslot");
	}
	putblock(bp, bp -> ddiskp);
}


/*
	## readfile(filename)
	Read a file into the buffer.

	This version of readfile puts an index table at
        the end of each block.  The index table's entry
	for each line tells the distance of the LAST character
	of the line from the start of the data buffer.

	The global variables brcount, brbufp, and brbufc
	are used to communicate with read1().  Using these
	variables speeds the code by a factor of 3!

	The "global" variables bravail and brout are used
	only by readfile() -- again, purely to speed the code.
*/

readfile(filename)
char filename [];
{
	struct BLOCK *bp, *swapin();

	/* global:  char * brbufp   pointer to buffer	*/
	/* global:  int    brbufc   index into buffer	*/
	/* global:  int    brcount  number of buffer	*/

	/* global:  int    bravail  available chars	*/
	/* global:  int    brout    index into outbuf	*/

	char	*outbuf;	/* the output buffer	*/
	int	outsave;	/* line starts here	*/
	int	c, i, j;

	/* Clear the swapping buffers and the files. */
	bufnew();
	bbp -> dstatus = FREE;

	/* Open the user file for reading only. */
	buserfd = sysopen(filename, 0);
	if (buserfd == ERROR) {
		diskerror("File not found.");
	}

	/* Clear the buffer on any disk error. */
	bfatal = YES;

	/* Open the data file. */
	dataopen();

	/* The file starts with line 1. */
	bline = 1;
	bstart = 1;

	/* There are no blocks in the file yet. */
	bhead = btail = ERROR;
	bmaxdiskp = 0;

	/* Point outbuf to start of the output data area. */
	outbuf = bbuff + HEADERSIZE;

	/* Force an initial read in read1(). */
	brcount = DATASIZE;
	brbufc	= DATARES;

	/* Zero the pointers into the output buffer. */
	brout = outsave = 0;

	/* Allocate space for the first table entry. */
	bravail = BUFFSIZE - INTSIZE;

	/* Set the current line counts. */
	bline = bstart = 1;

	for(;;) {

		if (bravail <= 0 && outsave == 0) {
			/* The line is too long. */
			error ("Line split.");

			/* End the line. */
			bsettab( bbuff,
				  bline - bstart,
				  brout
				);
			bline++;

			/* Clear the output buffer. */
			putbuf(bravail);
			brout = outsave = 0;
			bravail = BUFFSIZE - INTSIZE;
		}

		else if (bravail <= 0) {

			/*
				Deallocate last table entry and
				reallocate space used by the
				partial line.
			*/
			bravail += (INTSIZE + brout - outsave);

			/* Write out the buffer. */
			putbuf(bravail);

			/* Move the remainder to the front. */
			sysmove(outbuf + outsave,
				outbuf,
				brout - outsave);

			/* Reset restart point. */
			brout	 = brout - outsave;
			outsave = 0;
			bravail = BUFFSIZE - INTSIZE - brout;
		}

		c = read1();

		if (c == CPMEOF) {

			if (brout != outsave) {

				/* Finish the last line. */
				bsettab( bbuff,
					  bline-bstart,
					  brout /* 3/8/85 */
					);
				bline++;
				outsave = brout;
			}
			else {
				/* No last line after all. */
				bravail += INTSIZE;
			}

			/* bug fix:  2/20/84, 4/2/84 */
			if (bravail !=	BUFFSIZE) {
				putbuf(bravail);
			}
			break;
		}

		else if (c == NEWLINE) {

			/* Finish the line. */
			bsettab( bbuff,
				  bline - bstart,
				  brout
				);
			bravail -= INTSIZE;

			/* Set restart point. */
			bline++;
			outsave = brout;
		}

		else if (c == CR) {
                        /* Ignore CP/M's pseudo-newline. */
			continue;
		}

		else {

			/* Copy normal character. */
			outbuf [brout++] = c;
			bravail--;
		}
	}

        /* Close the user' file. */
	sysclose(buserfd);

	/* Special case:  null file. */
	if (bmaxdiskp == 0) {
		bufnew();
		return;
	}

	/* Rewrite the last block with correct next field. */

#ifdef CAST
	bp = (struct BLOCK *) bbuff;
#else
	bp = bbuff;
#endif

	bp -> dnext = ERROR;
	putblock(bbuff, bmaxdiskp - 1);

	/* Set the pointers to the first and last blocks. */
	bmaxdiskp--;
	bhead = 0;
	btail = bmaxdiskp;

	/*
		Clear all slots.  This is REQUIRED since
		readfile has just overwritten all slots.
	*/
	bufclr();

	/* Move to the start of the file. */
	bmaxline = bline - 1;
	bline = 1;
	bstart = 1;
	bbp = swapin(bhead);

	bfatal = NO;
}


/*
	## read1()
	Get one character from the input file.

	This version of read1 uses all slots as an input buffer.
	The slots to not need to be contiguous in memory
	(which they are generally are NOT because of hidden
	header information used only by sysalloc()).

	This version uses the globals brcount, brbufc and
	brbufp to speed up the code.
*/

read1()
{
	if (brcount == DATASIZE) {

		if (brbufc >= DATARES - 1) {

			/* Read into buffers. */
			read2();
			brcount = brbufc = 0;
		}
		else {

			/* Switch to next buffer. */
			brbufc++;
			brcount = 0;
		}

#ifdef CAST
		brbufp = (char *) bbpp [brbufc];
#else
		brbufp = bbpp [brbufc];
#endif

	}

	/* Get the character and mask off parity bit. */
	return brbufp [brcount++] & 0x7f;
}


/*
	## Read2()
	Read user file into all slots.
*/

read2()
{
	int i, s;

	for (i = 0; i < DATARES; i++) {

		/* Point at the next slot. */

#ifdef CAST
		brbufp = (char *) bbpp [i];
#else
		brbufp = bbpp [i];
#endif

		/* Read the next sector. */
		s = sysread(buserfd, brbufp);

		if (s == ERROR) {
			diskrdy();
		}

		/* Force a CPM end of file mark. */
		if (s < READSIZE) {
			brbufp [s * CPMSIZE] = CPMEOF;
			break;
		}
	}
}


/*
	## swapall()
	Swap out all dirty blocks.
*/

swapall()
{
	struct BLOCK *bp;
	int i;

	for (i = 0; i < DATARES; i++) {
		bp = bbpp [i];
		if (bp -> dstatus == DIRTY) {
			putslot (bp);
			bp -> dstatus = FULL;
		}
	}
}


/*
	Swap out the first dirty block.   This routine does
	not swap the dirty block since that would waste time.
	This routines is called when nothing else is happening.
*/

#ifdef SWAP
swapone()
{
	struct BLOCK *bp;
	int i;

	for (i = 0; i < DATARES; i++) {
		bp = bbpp [i];
		if (bp != bbp && bp -> dstatus == DIRTY) {
			putslot (bp);
			bp -> dstatus = FULL;
			break;
		}
	}
}
#endif


/*
	## swapin(diskp)
	Get the block from the disk into a slot in memory.
	Return a pointer to the block.
*/

struct BLOCK *
swapin(diskp)
int diskp;
{
	struct BLOCK *bp, *swapnew();
	int i, status;

	if (diskp < 0 || diskp > bmaxdiskp) {
		canthappen("swapin 1");
	}

	/* See whether the block is already in a slot. */
	for (i = 0; i < DATARES; i++) {
		bp = bbpp [i];
		if (bp -> dstatus != FREE &&
		    bp -> ddiskp  == diskp) {

			/* Reference the block. */
			dolru(bp);

			/* Point to the slot. */
			return bp;
		}
	}

	/* Clear a slot for the block. */
	bp = swapnew(diskp);

	/* Read from temp file to block. */
	status = sysseek(bdatafd, diskp);
	if (status == -1) {
		diskrdy();
	}

	/* Read the block into the slot. */

#ifdef CAST
	status = sysread(bdatafd, (char *) bp);
#else
	status = sysread(bdatafd, bp);
#endif

	if (status == ERROR) {
		diskrdy();
	}

	/* Swapnew() has already called dolru(). */

	/* Return a pointer to the block. */
	return bp;
}


/*
	## swapnew(diskp)
	Free a slot for a block located at diskp.
	Swap out the least recently used block if required.
	Return a pointer to the block.
*/

struct BLOCK *
swapnew(diskp)
int diskp;
{
	struct BLOCK *bp, *swapout();
	int i;

	/* Search for an available slot. */
	for (i = 0; i < DATARES; i++) {
		bp = bbpp [i];
		if (bp -> dstatus == FREE) {
			break;
		}
	}

	/* Swap out a block if all blocks are full. */
	if (i == DATARES) {
		bp = swapout();
	}

	/* Make sure the block will be written. */
	bp -> dstatus = FULL;
	bp -> ddiskp  = diskp;

	/* Reference the slot. */
	dolru(bp);

	/* Return a pointer to the slot. */
	return bp;
}


/*
	## swapout()
	Swap out the least recently used (LRU) slot.
	Return a pointer to the block.
*/

struct BLOCK *
swapout()
{
	struct BLOCK *bp;
	int i;

	/* Open the temp file if it has not been opened. */
	if (bdatafd == ERROR) {
		bdatafd = dataopen();
	}

	/* Find the least recently used slot. */
	for (i = 0; ;i++) {
		bp = bbpp [i];
		if (bp -> dlru == DATARES - 1) {
			break;
		}
	}

	/* Do the actual swapping out if memory is dirty. */
	if (bp -> dstatus == DIRTY) {
		putslot(bp);
		return bp;
	}

	/* ddiskp is not ERROR if status is not DIRTY. */
	if (bp -> ddiskp == ERROR) {
		canthappen("swapout");
	}

	/* Indicate that the slot is available. */
	bp -> dstatus = FREE;
	bp -> ddiskp  = ERROR;

	/* Return a pointer to the block. */
	return bp;
}


/*
	## swapsync()
	Swap out blocks found between low and high on the disk.
*/

swapsync(low, high)
int low, high;
{
	struct BLOCK *bp;
	int disk, i;

	/* Search the slot table for each disk. */
	for (disk = low; disk <= high; disk++) {
		for (i = 0; i < DATARES; i++) {
			bp = bbpp [i];
			if (bp -> ddiskp == disk) {

				/* Write the slot. */
				putslot(bp);
				bp -> dstatus = FULL;
				break;
			}
		}
		if (i == DATARES) {
			canthappen("swapsync");
		}
	}
}


/*
	## writefile(filename)
	Write the entire buffer to file.
*/

writefile(filename)
char *filename;
{
	/* global:  bwcount */

	struct BLOCK *bp;
	char *data;
	int slot, line, nlines, length, next, count;
	int c;

	/* Open the user file.	Erase it if it exists. */
	buserfd = syscreat(filename);
	if (buserfd == ERROR) {
		diskfull();
	}

	/* Copy each block of the file. */
	bwcount = 0;
	for (next = bhead; next != ERROR; ) {

		/* Swap in the next block. */
		bp = swapin(next);

		/* Get data from the header of the block. */
		next   = bp -> dnext;
		nlines = bp -> dlines;
		data   = bp -> ddata;

		/* Copy each line of the block. */
		count = 0;
		for (line = 0; line < nlines; line++) {

			/* Get length of the line. */
			if (line == 0) {
				length = btab(bp, line);
			}
			else {
				length = btab(bp,line) -
					 btab(bp,line - 1);
			}

			/* Copy each char of the line. */
			for (; length; length--) {
				c = data [count++];
				write1(c);
			}

			/* Add CR and LF at end. */
			write1(CR);
			write1(LF);
		}
	}

	/* Force an end of file mark. */
	write1(CPMEOF);

	/* Flush the buffer and close the file. */
	wrflush();
	sysclose(buserfd);

	/* Kludge:  go to line 1 for a reference point. */
	bbp   = swapin(bhead);
	bline = bstart = 1;
}


/*
	## write1(c)
        Write one character to the user's file.
	bwcount is the current position in the file buffer.
*/

write1(c)
char c;
{
	bbuff [bwcount++] = c;
	if (bwcount == CPMSIZE) {
		if (syswrite(buserfd, bbuff, 1) != 1) {
			diskfull();
		}
		bwcount = 0;
	}
}


/*
	## wrflush()
        Flush bbuff to the user's file.
*/

wrflush()
{
	if (bwcount == 0) {
		return;
	}
	if (syswrite(buserfd, bbuff, 1) != 1) {
		diskfull();
	}
}





/*
	RED buffer routines -- Full C version
	Part 4 -- debugging routines.

	Source:  red13.c
	Version: April 26, 1984; December 3, 1984

	Copyright (C) 1983, 1984 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "red.h"
#define PRINTER stdout


/*
	The observer effect:  None of the routines of this file
	should ever call swapin() because swapin() causes
	all kinds changes to the data structures which these
	routines are trying to print out.
*/


/*
	Dump global variables, all resident slots and
	the current block.
*/

bufdump()
{
	outxy(0,SCRNL1);
	dumpvars();
	dumpmemory();
	dumpblock(bbp);

	pmtzap();
	pmtupd();
	syscin();
	pmtzap();
	edclr();
	edgo(bufln(), 0);
}


/*
	System error routine.
*/

canthappen(message)
char *message;
{
        pmtmess(message, ":can't happen");
	bufdump();

#ifdef DESMET
	longjmp(DISKERR, ERROR);
#else
	exit();
#endif

}


/*
	Check the current block for consistency.
*/

checkblock(message)
char *message;
{
#ifdef DEBUG
	int avail, i, nlines, total;

	nlines = bbp -> dlines;
	avail  = b1avail();

	if (bbp == ERROR ||
	    bline < 0 || bline > bmaxline + 1) {

		error("In check block 1.");
		canthappen(message);
	}

	if ( nlines < 0 ||
	     nlines >= BUFFSIZE ||
	     avail  < 0
	   ) {

		error("In Check block 2.");
		canthappen(message);
	}

	/* Make sure there are at least enough lines. */
	for (i = 0; i < nlines; i++) {
		total = b1tab(i);
		if (total < 0 || total > BUFFSIZE - avail) {

			error("In check block 3.");
			canthappen(message);
		}
	}
#endif
}


/*
	Dump the current block.
*/

dumpblock(bp)
struct BLOCK *bp;
{
	char *buffer;
	int  c, count, i, j, limit, nlines, offset;

#ifdef AZTEC
	FILE *PRINTER;

	PRINTER = fopen("con:", "w");
#endif

	nlines = bp -> dlines;
	buffer = bp -> ddata;
	offset = 0;

	for (i = 0; i < nlines; i++) {

		limit = btab(bp, i);
		count = limit - offset;

		fprintf(PRINTER,
		"line %3d, offset %3d, length %3d, total %3d:  ",
		i + 1, offset, count, limit);

		if (count < 0) {
			return;
		}

		if (count >= 50) {
			fprintf(PRINTER, "\n");
		}
		for (j = 0; j < count && j < 80; j++) {
			c = buffer [offset + j] & 127;
                        if (c == '\t') {
				fprintf(PRINTER, " ");
			}
			else if (c < 32) {
				fprintf(PRINTER,"^%c", c + 64);
			}
			else {
				fprintf(PRINTER, "%c", c);
			}
		}
		fprintf(PRINTER, "\n");
		offset = limit;
	}

#ifdef AZTEC
	fclose(PRINTER);
#endif

}


/*
	Dump all the resident slots.
*/

dumpmemory()
{
	struct BLOCK *bp;
	int i;

#ifdef AZTEC
	FILE *PRINTER;

	PRINTER = fopen("con:", "w");
#endif

	for (i = 0; i < DATARES; i++) {
		bp = bbpp [i];

		fprintf(PRINTER, "slot %2d, ", i);

#ifdef HASLONG
		fprintf(PRINTER,
		"address %4lx, back %3d, diskp %3d, next %3d, ",
		bp, bp -> dback, bp -> ddiskp, bp -> dnext);
#else
		fprintf(PRINTER,
		"address %4x, back %3d, diskp %3d, next %3d, ",
		bp, bp -> dback, bp -> ddiskp, bp -> dnext);
#endif

		fprintf(PRINTER,
		"lines %3d, lru %3d, status %3d, avail %3d\n",
		bp -> dlines, bp -> dlru,  bp -> dstatus,
		bavail(bp));
	}

#ifdef AZTEC
	fclose(PRINTER);
#endif

}


/*
	Dump all global variables.
*/

dumpvars()
{

#ifdef AZTEC
	FILE *PRINTER;

	PRINTER = fopen("con:", "w");
#endif

	fprintf(PRINTER,
	"start %d line %d, maxline %d\n",
	bstart, bline, bmaxline);

	fprintf(PRINTER,
	"head %d, tail %d, free %d, maxdiskp %d\n",
	bhead, btail, bfree, bmaxdiskp);

#ifdef HASLONG
	fprintf(PRINTER,
	"address %lx, back %d, diskp %d, next %d, avail %d, ",
	bbp, bbp -> dback,  bbp -> ddiskp,
	bbp -> dnext, b1avail());
#else
	fprintf(PRINTER,
	"address %x, back %d, diskp %d, next %d, avail %d, ",
	bbp, bbp -> dback,  bbp -> ddiskp,
	bbp -> dnext, b1avail());
#endif

	fprintf(PRINTER,
	"lines %d, lru %d, status %d\n",
	bbp -> dlines, bbp -> dlru,  bbp -> dstatus);

#ifdef AZTEC
	fclose(PRINTER);
#endif

}





/*
	Definition file for global variables -- IBM version
	This file is NOT used in the BDS C version.

	Source:  redglob.c
	Version: November 18, 1983

	Copyright (C) 1983 by:

		Edward K. Ream
		1850 Summit Avenue
		Madison, WI 53705
		(608) 231 - 2952
*/

#include "redbuf.h"


/* >>>>> COMMENT OUT - LOOK FOR IT IN HEADER FILES (RDK) <<<<< */
/*
#define SYSFNMAX 20
#define JBUFSIZE 12
*/

/*
	Define global file name.
*/
/* >>>>> COMMENT OUT - LOOK FOR IT IN HEADER FILES (RDK) <<<<< */
/*
char gfile [SYSFNMAX];	/* file name for (re)save */
*/

/*
	Define the global recovery point for disk errors.
*/
/* >>>>> COMMENT OUT - LOOK FOR IT IN HEADER FILES (RDK) <<<<< */
/*
char DISKERR [JBUFSIZE];
*/

/*
	Define globals used to describe the terminal.
	At present,  they are set by the outinit routine,
	but the sysinit routine would be a better place if
	you want to support multiple terminals without
	recompiling RED.
*/

int	hasdn;	 /* has scroll down			*/
int	hasup;	 /* has scroll up			*/
int	hasins;  /* has insert line (ABOVE current line)*/
int	hasdel;  /* has delete line			*/
int	hasint;  /* use interrupt driven screen 	*/
int	hascol;  /* put columns on prompt line		*/
int	hascins; /* has insert character		*/
int	hascdel; /* has delete character		*/
int	haswrap; /* enables line wrapping		*/


/*
	Allocate memory for variables global to the
	buffer routines.
*/
int	DATARES;	/* pseudo constant		*/
			/* no greater than MAXRES	*/

int	bfatal; /* clear buffer on error	*/
int	bcflag; /* buffer changed flag		*/

int	bline;	/* current line number		*/
int	bmaxline;	/* highest line number		*/
int	bstart; /* first line of current block	*/

int     bhead;         /* first block's disk pointer   */
int     btail;         /* last block's disk pointer    */
int	bmaxdiskp;	/* last block allocated 	*/
int	bmaxput;	/* last block written		*/

int	bdatafd;	/* file descriptor of data file */
int	buserfd;	/* file descriptor of user file */
int	bfree;	/* head of list of free blocks	*/

char	bbuff [DATASIZE];	/* temporary buffer.	*/

struct BLOCK * bbp;	/* mem pointer to current block */


/*
	Define an array of pointers to each slot.
	The DATARES pseudo constant tells how many
	slots have actually been allocated.
*/

struct BLOCK * bbpp [MAXRES];


/*
	Define variables used only by readfile() and read1().
	They are used to speed up the code.
*/

char *	brbufp; /* pointer to input buffer	*/
int	brbufc; /* number of current buffer	*/
int	brcount;	/* index into input buffer	*/

int	bravail;	/* number of free characters	*/
int	brout;	/* index into outbuf		*/

/*
	Define variables used only by writefile() and write1().
	They are used to speed up the code.
*/

int	bwcount;	/* index into buffer		*/






/* END OF THE SOURCE TO THE EDITOR (rdk) */

\]^_`abcdefghijklmnopqrstuvwxyz{|}~