 
           LX - Linear eXecutable Module Format Description 
 
                            June 3, 1992 
 
 
 
   Figure 1. 32-bit Linear EXE File Layout 
 
       00h +------------------+  <--+ 
           | DOS 2 Compatible |     | 
           |    EXE Header    |     | 
       1Ch +------------------+     | 
           |      unused      |     | 
           +------------------+     | 
       24h |  OEM Identifier  |     | 
       26h |  OEM Info        |     | 
           |                  |     |-- DOS 2.0 Section 
       3Ch |  Offset to       |     |   (Discarded) 
           |  Linear EXE      |     | 
           |  Header          |     | 
       40h +------------------+     | 
           |   DOS 2.0 Stub   |     | 
           |   Program &      |     | 
           |   Reloc. Table   |     | 
           +------------------+  <--+ 
           |                  | 
       xxh +------------------+  <--+ 
           |    Executable    |     | 
           |       Info       |     | 
           +------------------+     | 
           |      Module      |     | 
           |       Info       |     | 
           +------------------+     |-- Linear Executable 
           |  Loader Section  |     |   Module Header 
           |       Info       |     |   (Resident) 
           +------------------+     | 
           |   Table Offset   |     | 
           |       Info       |     | 
           +------------------+  <--+ 
           |   Object Table   |     | 
           +------------------+     | 
           | Object Page Table|     | 
           +------------------+     | 
           |  Resource Table  |     | 
           +------------------+     | 
           |  Resident Name   |     | 
           |      Table       |     | 
           +------------------+     |-- Loader Section 
           |   Entry Table    |     |   (Resident) 
           +------------------+     | 
           |   Module Format  |     | 
           | Directives Table |     | 
           |    (Optional)    |     | 
           +------------------+     | 
           |     Resident     |     | 
           | Directives Data  |     | 
           |    (Optional)    |     | 
           |                  |     | 
           |  (Verify Record) |     | 
           +------------------+     | 
           |     Per-Page     |     | 
           |     Checksum     |     | 
           +------------------+  <--+ 
           | Fixup Page Table |     | 
           +------------------+     | 
           |   Fixup Record   |     | 
           |       Table      |     | 
           +------------------+     |-- Fixup Section 
           |   Import Module  |     |   (Optionally Resident) 
           |    Name Table    |     | 
           +------------------+     | 
           | Import Procedure |     | 
           |    Name Table    |     | 
           +------------------+  <--+ 
           |   Preload Pages  |     | 
           +------------------+     | 
           |    Demand Load   |     | 
           |       Pages      |     | 
           +------------------+     | 
           |  Iterated Pages  |     | 
           +------------------+     | 
           |   Non-Resident   |     |-- (Non-Resident) 
           |    Name Table    |     | 
           +------------------+     | 
           |   Non-Resident   |     | 
           | Directives Data  |     | 
           |    (Optional)    |     | 
           |                  |     | 
           |  (To be Defined) |     | 
           +------------------+  <--+ 
           |    Debug Info    |     |-- (Not used by Loader) 
           +------------------+  <--+ 
 
 
 
 Figure 2. 32-bit Linear EXE Header 
 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       00h | "L"   "X" |B-ORD|W-ORD|     FORMAT LEVEL      | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       08h | CPU TYPE  |  OS TYPE  |    MODULE VERSION     | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       10h |     MODULE FLAGS      |   MODULE # OF PAGES   | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       18h |     EIP OBJECT #      |          EIP          | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       20h |     ESP OBJECT #      |          ESP          | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       28h |       PAGE SIZE       |   PAGE OFFSET SHIFT   | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       30h |  FIXUP SECTION SIZE   | FIXUP SECTION CHECKSUM| 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       38h |  LOADER SECTION SIZE  |LOADER SECTION CHECKSUM| 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       40h |    OBJECT TABLE OFF   |  # OBJECTS IN MODULE  | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       48h | OBJECT PAGE TABLE OFF | OBJECT ITER PAGES OFF | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       50h | RESOURCE TABLE OFFSET |#RESOURCE TABLE ENTRIES| 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       58h | RESIDENT NAME TBL OFF |   ENTRY TABLE OFFSET  | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       60h | MODULE DIRECTIVES OFF | # MODULE DIRECTIVES   | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       68h | FIXUP PAGE TABLE OFF  |FIXUP RECORD TABLE OFF | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       70h | IMPORT MODULE TBL OFF | # IMPORT MOD ENTRIES  | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       78h |  IMPORT PROC TBL OFF  | PER-PAGE CHECKSUM OFF | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       80h |   DATA PAGES OFFSET   |    #PRELOAD PAGES     | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       88h | NON-RES NAME TBL OFF  | NON-RES NAME TBL LEN  | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       90h | NON-RES NAME TBL CKSM |   AUTO DS OBJECT #    | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       98h |    DEBUG INFO OFF     |    DEBUG INFO LEN     | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       A0h |   #INSTANCE PRELOAD   |   #INSTANCE DEMAND    | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       A8h |       HEAPSIZE        | 
           +-----+-----+-----+-----+ 
 
 Note: The OBJECT ITER PAGES OFF must either be 0 or set to the 
 same value as DATA PAGES OFFSET in OS/2 2.0. Ie., iterated pages are 
 required to be in the same section of the file as regular pages. 
 
 Note: Table offsets  in the Linear  EXE Header may be set to 
 zero  to indicate that the table does not  exist in the  EXE 
 file and it's size is zero. 
 
     "L" "X" = DW  Signature word. 
         The signature word is used by the loader to identify 
         the EXE file as  a valid  32-bit  Linear  Executable 
         Module  Format.  "L" is low order byte. "X"  is high 
         order byte. 
 
     B-ORD = DB  Byte Ordering. 
         This byte specifies the byte ordering for the linear 
         EXE format.  The values are: 
 
             00H - Little Endian Byte Ordering. 
             01H - Big Endian Byte Ordering. 
 
     W-ORD = DB  Word Ordering. 
         This byte specifies the Word ordering for the linear 
         EXE format.  The values are: 
 
             00H - Little Endian Word Ordering. 
             01H - Big Endian Word Ordering. 
 
     Format Level = DD  Linear EXE Format Level. 
         The  Linear EXE Format Level is set  to  0  for  the 
         initial version  of  the 32-bit linear  EXE  format. 
         Each  incompatible  change to the  linear EXE format 
         must increment this value.  This  allows the  system 
         to recognized future EXE file versions  so  that  an 
         appropriate  error message  may  be displayed  if an 
         attempt is made to load them. 
 
     CPU Type = DW  Module CPU Type. 
         This  field specifies the type  of  CPU required  by 
         this module to run.  The values are: 
 
             01H  -  80286  or  upwardly  compatible  CPU  is 
             required to execute this module. 
             02H  -  80386  or  upwardly  compatible  CPU  is 
             required to execute this module. 
             03H  -  80486  or  upwardly  compatible  CPU  is 
             required to execute this module. 
 
     OS Type = DW  Module OS Type. 
         This field specifies the type  of  Operating  system 
         required to run  this module.  The currently defined 
         values are: 
 
             00H - Unknown (any "new-format" OS) 
             01H - OS/2 (default) 
             02H - Windows 
             03H - DOS 4.x 
             04H - Windows 386 
 
     MODULE VERSION = DD  Version of the linear EXE module. 
         This is useful for differentiating between revisions 
         of dynamic linked modules.  This  value is specified 
         at link time by the user. 
 
     MODULE FLAGS = DD  Flag bits for the module. 
         The module flag bits have the following definitions. 
 
             00000001h = Reserved for system use. 
             00000002h = Reserved for system use. 
             00000004h = Per-Process Library Initialization. 
                 The setting  of this  bit  requires the  EIP 
                 Object  #  and  EIP  fields  to  have  valid 
                 values.  If the EIP Object # and EIP  fields 
                 are  valid  and this  bit is  NOT  set, then 
                 Global Library  Initialization  is  assumed. 
                 Setting this bit for an EXE file is invalid. 
 
             00000008h = Reserved for system use. 
             00000010h = Internal fixups for the  module have 
             been applied. 
                 The  setting   of  this  bit  in  a   Linear 
                 Executable Module indicates that each object 
                 of  the module  has a preferred load address 
                 specified  in  the Object  Table  Reloc Base 
                 Addr.  If the module's  objects  can  not be 
                 loaded at  these  preferred  addresses, then 
                 the   relocation  records  that  have   been 
                 retained in the file data will be applied. 
 
             00000020h = External fixups for  the module have 
             been applied. 
             00000040h = Reserved for system use. 
             00000080h = Reserved for system use. 
             00000100h = Incompatible with PM windowing. 
             00000200h = Compatible with PM windowing. 
             00000300h = Uses PM windowing API. 
             00000400h = Reserved for system use. 
             00000800h = Reserved for system use. 
             00001000h = Reserved for system use. 
             00002000h = Module is not loadable. 
                 When  the 'Module is  not loadable' flag  is 
                 set, it indicates that  either  errors  were 
                 detected at link  time or that the module is 
                 being  incrementally  linked  and  therefore 
                 can't be loaded. 
 
             00004000h = Reserved for system use. 
             00038000h = Module type mask. 
             00000000h = Program module. 
                 A module  can not  contain  dynamic links to 
                 other modules that have the 'program module' 
                 type. 
 
             00008000h = Library module. 
             00018000h = Protected Memory Library module. 
             00020000h = Physical Device Driver module. 
             00028000h = Virtual Device Driver module. 
             40000000h = Per-process Library Termination. 
                 The  setting of this bit  requires  the  EIP 
                 Object  #  and  EIP  fields  to  have  valid 
                 values.  If the EIP Object  # and EIP fields 
                 are  valid  and  this bit  is NOT  set, then 
                 Global  Library   Termination   is  assumed. 
                 Setting this bit for an EXE file is invalid. 
 
     MODULE # PAGES = DD  Number of pages in module. 
 
         This field specifies the number of  pages physically 
         contained in  this module.  In  other  words,  pages 
         containing  either enumerated or  iterated data,  or 
         zero-fill pages  that have relocations,  not invalid 
         or zero-fill  pages implied by  the  Virtual Size in 
         the Object  Table being  larger  than  the number of 
         pages actually in  the linear EXE file.  These pages 
         are  contained in the  'preload pages', 'demand load 
         pages'  and  'iterated  data pages' sections of  the 
         linear EXE module.  This  is  used  to determine the 
         size  of the page information tables  in  the linear 
         EXE module. 
 
     EIP OBJECT #  = DD The Object number to which  the Entry 
     Address is relative. 
         This specifies the object to which the Entry Address 
         is  relative.  This must be a  nonzero  value  for a 
         program module to be correctly loaded.  A zero value 
         for a library module indicates that no library entry 
         routine exists.  If  this  value  is zero, then both 
         the  Per-process Library Initialization bit and  the 
         Per-process Library Termination bit must be clear in 
         the module flags,  or  else the loader will fail  to 
         load   the  module.  Further,  if  the   Per-process 
         Library Termination  bit is set, then the  object to 
         which  this field  refers  must  be a 32-bit  object 
         (i.e., the Big/Default bit must be set in the object 
         flags; see below). 
 
     EIP = DD  Entry Address of module. 
         The  Entry  Address  is  the  starting  address  for 
         program modules and  the  library initialization and 
         Library termination address for library modules. 
 
     ESP OBJECT # = DD The Object number to  which the ESP is 
     relative. 
         This  specifies the object to which the starting ESP 
         is relative.  This  must be  a  nonzero  value for a 
         program  module to be correctly  loaded.  This field 
         is ignored for a library module. 
 
     ESP = DD  Starting stack address of module. 
         The  ESP defines the starting stack  pointer address 
         for program modules.  A zero  value  in  this  field 
         indicates   that   the  stack  pointer   is  to   be 
         initialized  to the  highest  address/offset in  the 
         object.  This field is ignored for a library module. 
 
     PAGE SIZE = DD  The size of one page for this system. 
         This  field  specifies  the  page size  used  by the 
         linear EXE  format and the  system.  For the initial 
         version of this linear  EXE format the page  size is 
         4Kbytes.  (The 4K page size  is specified by a value 
         of 4096 in this field.) 
 
     PAGE OFFSET  SHIFT = DD  The shift left  bits  for  page 
     offsets. 
         This  field  gives the number  of bit  positions  to 
         shift left when interpreting  the  Object Page Table 
         entries' page  offset  field.  This  determines  the 
         alignment  of the page information in the file.  For 
         example, a value of  4 in this field would align all 
         pages in the  Data Pages and Iterated Pages sections 
         on 16  byte  (paragraph)  boundaries.  A Page Offset 
         Shift of 9 would align all pages on a 512 byte (disk 
         sector) basis.  The default  value for this field is 
         12 (decimal), which give a 4096 byte alignment.  All 
         other offsets are byte aligned. 
 
     FIXUP  SECTION  SIZE  =  DD  Total  size  of  the  fixup 
     information in bytes. 
         This includes the following 4 tables: 
 
             - Fixup Page Table 
             - Fixup Record Table 
             - Import Module name Table 
             - Import Procedure Name Table 
 
     FIXUP  SECTION  CHECKSUM   =   DD   Checksum  for  fixup 
     information. 
         This is a cryptographic checksum covering all of the 
         fixup  information.  The  checksum   for  the  fixup 
         information  is kept separate because the fixup data 
         is  not  always loaded into  main  memory  with  the 
         'loader  section'.  If  the  checksum feature is not 
         implemented, then the  linker will set  these fields 
         to zero. 
 
     LOADER  SECTION  SIZE  =  DD  Size  of  memory  resident 
     tables. 
         This  is  the  total  size  in bytes of  the  tables 
         required to be memory resident for the module, while 
         the module is in use.  This total size  includes all 
         tables from the Object  Table down to  and including 
         the Per-Page Checksum Table. 
 
     LOADER  SECTION  CHECKSUM  =  DD  Checksum   for  loader 
     section. 
         This is a cryptographic checksum covering all of the 
         loader section information.  If the checksum feature 
         is not implemented,  then the linker  will set these 
         fields to zero. 
 
     OBJECT TABLE OFF = DD  Object Table offset. 
         This offset  is  relative  to  the  beginning of the 
         linear EXE header. 
 
     # OBJECTS IN MODULE = DD  Object Table Count. 
         This defines the number of entries in Object Table. 
 
     OBJECT PAGE TABLE OFFSET = DD  Object Page Table offset 
         This offset is  relative  to  the beginning  of  the 
         linear EXE header. 
 
     OBJECT  ITER  PAGES  OFF  =  DD  Object  Iterated  Pages 
     offset. 
         This offset is relative to the beginning of  the EXE 
         file. 
 
     RESOURCE TABLE OFF = DD  Resource Table offset. 
         This offset is relative  to  the  beginning  of  the 
         linear EXE header. 
 
     # RESOURCE  TABLE  ENTRIES  = DD  Number  of entries  in 
     Resource Table. 
 
     RESIDENT NAME TBL OFF = DD  Resident Name Table offset. 
         This offset is  relative  to  the  beginning  of the 
         linear EXE header. 
 
     ENTRY TBL OFF = DD  Entry Table offset. 
         This  offset  is  relative  to the beginning of  the 
         linear EXE header. 
 
     MODULE DIRECTIVES  OFF  =  DD  Module  Format Directives 
     Table offset. 
         This  offset  is  relative  to  the beginning of the 
         linear EXE header. 
 
     #  MODULE  DIRECTIVES  =  DD  Number  of  Module  Format 
     Directives in the Table. 
         This field specifies the number  of  entries in  the 
         Module Format Directives Table. 
 
     FIXUP PAGE TABLE OFF = DD  Fixup Page Table offset. 
         This  offset  is  relative to the  beginning of  the 
         linear EXE header. 
 
     FIXUP RECORD TABLE OFF = DD  Fixup Record Table Offset 
         This  offset is relative to  the  beginning  of  the 
         linear EXE header. 
 
     IMPORT  MODULE  TBL  OFF = DD  Import  Module Name Table 
     offset. 
         This  offset is relative  to  the  beginning of  the 
         linear EXE header. 
 
     # IMPORT MOD ENTRIES = DD  The  number of entries in the 
     Import Module Name Table. 
 
     IMPORT PROC TBL OFF  =  DD  Import Procedure  Name Table 
     offset. 
         This offset  is relative  to  the  beginning of  the 
         linear EXE header. 
 
     PER-PAGE CHECKSUM  OFF  =  DD  Per-Page  Checksum  Table 
     offset. 
         This  offset is  relative  to  the beginning of  the 
         linear EXE header. 
 
     DATA PAGES OFFSET = DD   Data Pages Offset. 
         This offset is  relative to the beginning of the EXE 
         file. 
 
     # PRELOAD PAGES = DD  Number  of  Preload pages for this 
     module. Note that OS/2 2.0 does not respect the preload 
     of pages as specified in the executable file for performance 
     reasons. 
 
     NON-RES NAME  TBL  OFF  =  DD  Non-Resident  Name  Table 
     offset. 
         This offset is relative to the beginning of  the EXE 
         file. 
 
     NON-RES  NAME  TBL  LEN = DD  Number  of  bytes  in  the 
     Non-resident name table. 
 
     NON-RES  NAME TBL CKSM  =  DD  Non-Resident  Name  Table 
     Checksum. 
         This is a cryptographic checksum of the Non-Resident 
         Name Table. 
 
     AUTO  DS OBJECT  #  =  DD  The Auto Data  Segment Object 
     number. 
         This is the object number for  the Auto Data Segment 
         used by 16-bit modules.  This field is supported for 
         16-bit compatibility only and is not used by  32-bit 
         modules. 
 
     DEBUG INFO OFF = DD  Debug Information offset. 
         This offset  is relative  to  the  beginning  of the 
         linear EXE header. 
 
     DEBUG INFO LEN = DD  Debug Information length. 
         The length of the debug information in bytes. 
 
      #  INSTANCE  PRELOAD  = DD Instance  pages  in  preload 
     section. 
         The  number  of instance  data pages  found  in  the 
         preload section. 
 
      #  INSTANCE  DEMAND  =  DD  Instance  pages  in  demand 
     section. 
         The  number  of instance  data pages  found  in  the 
         demand section. 
 
      HEAPSIZE = DD Heap size added to the Auto DS Object. 
         The heap size is the  number  of  bytes added to the 
         Auto  Data  Segment  by the loader.  This  field  is 
         supported for  16-bit compatibility only and is  not 
         used by 32-bit modules. 
 
 
 
 
 
     Program (EXE) startup registers and Library entry registers 
 
 
     Program startup registers are defined as follows. 
 
         EIP = Starting program entry address. 
 
         ESP = Top of stack address. 
 
         CS = Code selector for base of linear address space. 
 
         DS =  ES  = SS = Data  selector  for  base of linear 
         address space. 
 
         FS =  Data selector  of  base of Thread  Information 
         Block (TIB). 
 
         GS = 0. 
 
         EAX = EBX = 0. 
 
         ECX = EDX = 0. 
 
         ESI = EDI = 0. 
 
         EBP = 0. 
 
         [ESP+0] =  Return  address to  routine  which  calls 
         DosExit(1,EAX). 
 
         [ESP+4] = Module handle for program module. 
 
         [ESP+8] = Reserved. 
 
         [ESP+12] = Environment data object address. 
 
         [ESP+16]   =   Command  line   linear   address   in 
         environment data object. 
 
 
     Library initialization registers are defined as follows. 
 
         EIP = Library entry address. 
 
         ESP = User program stack. 
 
         CS = Code selector for base of linear address space. 
 
         DS  = ES = SS = Data  selector  for  base  of linear 
         address space. 
 
         Note that a  32-bit Protected Memory Library  module 
         will be  given  a  GDT  selector in  the  DS  and ES 
         registers (PROTDS)  that  addresses the  full linear 
         address  space  available  to  a  application.  This 
         selector  should  be  saved  by  the  initialization 
         routine.  Non-Protected  Memory Library modules will 
         receive a selector (FLATDS) that  addresses the same 
         amount of linear  address  space as an application's 
         .EXE can. 
 
         FS  = Data selector  of base  of  Thread Information 
         Block (TIB). 
 
         GS = 0. 
 
         EAX = EBX = 0. 
 
         ECX = EDX = 0. 
 
         ESI = EDI = 0. 
 
         EBP = 0. 
 
         [ESP+0] = Return address to system, (EAX)  =  return 
         code. 
 
         [ESP+4] = Module handle for library module. 
 
         [ESP+8] = 0 (Initialization) 
 
     Note that a  32-bit  library may specify  that its entry 
     address is  in  a 16-bit code object.  In this case, the 
     entry registers are the same  as for  entry to a library 
     using the Segmented  EXE format.  These  are  documented 
     elsewhere.  This  means  that  a  16-bit  library may be 
     relinked to take advantage of the benefits of the Linear 
     EXE format (notably, efficient paging). 
 
 
     Library termination registers are defined as follows. 
 
         EIP = Library entry address. 
 
         ESP = User program stack. 
 
         CS = Code selector for base of linear address space. 
 
         DS  =  ES  = SS  = Data  selector for base of linear 
         address space. 
 
         FS  =  Data  selector of base of  Thread Information 
         Block (TIB). 
 
         GS = 0. 
 
         EAX = EBX = 0. 
 
         ECX = EDX = 0. 
 
         ESI = EDI = 0. 
 
         EBP = 0. 
 
         [ESP+0] = Return address to system. 
 
         [ESP+4] = Module handle for library module. 
 
         [ESP+8] = 1 (Termination) 
 
     Note  that  Library  termination  is  not  allowed   for 
     libraries with 16-bit entries. 
 
 
 
 
 
     Object Table 
 
 
 The number of entries in the Object Table  is given by the # 
 Objects in Module  field  in the linear EXE header.  Entries 
 in the Object Table are numbered starting from one. 
 
 Each Object Table entry has the following format: 
 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       00h |     VIRTUAL SIZE      |    RELOC BASE ADDR    | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       08h |     OBJECT FLAGS      |    PAGE TABLE INDEX   | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       10h |  # PAGE TABLE ENTRIES |       RESERVED        | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
 
     VIRTUAL SIZE = DD  Virtual memory size. 
         This  is  the  size  of  the  object  that  will  be 
         allocated  when the object is loaded.  The  object's 
         virtual  size (rounded  up to  the page  size value) 
         must be  greater than or equal to the total  size of 
         the  pages  in the  EXE  file  for the object.  This 
         memory size must also be large enough to contain all 
         of the iterated data and uninitialized  data in  the 
         EXE file. 
 
     RELOC BASE ADDR = DD Relocation Base Address. 
         The relocation base  address the object is currently 
         relocated to.  If the internal relocation fixups for 
         the  module have been  removed, this is  the address 
         the object will be allocated at by the loader. 
 
     OBJECT FLAGS = DW  Flag bits for the object. 
         The object flag bits have the following definitions. 
 
             0001h = Readable Object. 
             0002h = Writable Object. 
             0004h = Executable Object. 
                 The readable,  writable and executable flags 
                 provide    support    for    all    possible 
                 protections.  In systems where  all of these 
                 protections are not  supported,  the  loader 
                 will   be   responsible   for   making   the 
                 appropriate protection match for the system. 
 
             0008h = Resource Object. 
             0010h = Discardable Object. 
             0020h = Object is Shared. 
             0040h = Object has Preload Pages. 
             0080h = Object has Invalid Pages. 
             0100h = Object has Zero Filled Pages. 
             0200h = Object is Resident (valid for VDDs, PDDs 
             only). 
             0300h = Object is Resident  &  Contiguous (VDDs, 
             PDDs only). 
             0400h  =  Object is  Resident  & 'long-lockable' 
             (VDDs, PDDs only). 
             0800h = Reserved for system use. 
             1000h = 16:16 Alias Required (80x86 Specific). 
             2000h   =   Big/Default   Bit   Setting   (80x86 
             Specific). 
                 The 'big/default'  bit , for data  segments, 
                 controls the setting of the Big  bit  in the 
                 segment descriptor.  (The Big bit, or B-bit, 
                 determines whether ESP or SP is used  as the 
                 stack pointer.)  For code segments, this bit 
                 controls the setting of the  Default  bit in 
                 the segment descriptor.  (The  Default  bit, 
                 or  D-bit, determines  whether  the  default 
                 word  size  is 32-bits or 16-bits.  It  also 
                 affects   the    interpretation    of    the 
                 instruction stream.) 
 
             4000h =  Object is  conforming  for  code (80x86 
             Specific). 
             8000h  =  Object  I/O  privilege   level  (80x86 
             Specific). 
                 Only used for 16:16 Alias Objects. 
 
     PAGE TABLE INDEX = DD  Object Page Table Index. 
         This specifies the number of  the first  object page 
         table  entry for this object.  The object page table 
         specifies where in the EXE file a page  can be found 
         for   a   given   object   and   specifies  per-page 
         attributes. 
 
         The object table entries are ordered by logical page 
         in the  object  table.  In  other  words  the object 
         table entries  are sorted based  on  the object page 
         table index value. 
 
     #  PAGE TABLE ENTRIES  =  DD  #  of  object  page  table 
     entries for this object. 
         Any logical pages at the  end  of an  object that do 
         not  have  an   entry   in  the  object  page  table 
         associated  with them are handled as zero  filled or 
         invalid pages by the loader. 
 
         When the last  logical pages  of an  object  are not 
         specified with an object page table entry,  they are 
         treated as either zero filled pages or invalid pages 
         based on the last entry in the object page table for 
         that object.  If  the last entry was  neither a zero 
         filled  or invalid  page, then the additional  pages 
         are treated as zero filled pages. 
 
     RESERVED = DD  Reserved for future use.  Must  be set to 
     zero. 
 
 
 
     Object Page Table 
 
 
 The  Object  page table provides information about a logical 
 page in  an object.  A  logical  page  may be  an enumerated 
 page, a pseudo page or an iterated  page.  The  structure of 
 the  object page table in conjunction with the  structure of 
 the  object table allows for efficient access of a page when 
 a page fault occurs, while  still allowing the physical page 
 data to be located  in the preload page, demand load page or 
 iterated data  page sections in the linear  EXE  module. The 
 logical page entries  in the Object Page Table  are numbered 
 starting from one.  The Object Page Table is parallel to the 
 Fixup  Page Table  as  they are both indexed by the  logical 
 page number. 
 
 Each Object Page Table entry has the following format: 
 
          63                     32 31       16 15         0 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
       00h |    PAGE DATA OFFSET   | DATA SIZE |   FLAGS   | 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
 
     PAGE DATA OFFSET = DD  Offset  to  the page  data in the 
     EXE file. 
         This field, when bit shifted left by the PAGE OFFSET 
         SHIFT from the  module header, specifies  the offset 
         from  the beginning of  the Preload Page section  of 
         the  physical  page  data  in   the  EXE  file  that 
         corresponds to this logical  page  entry.  The  page 
         data  may  reside in the  Preload Pages, Demand Load 
         Pages or the Iterated Data Pages sections. 
 
         If  the  FLAGS  field  specifies  that  this  is   a 
         zero-Filled page  then the  PAGE DATA  OFFSET  field 
         will contain a 0. 
 
         If the logical page is specified as an iterated data 
         page,  as  indicated  by the FLAGS field, then  this 
         field specifies the  offset into the  Iterated  Data 
         Pages section. 
 
         The logical page number  (Object Page  Table index), 
         is  used  to index  the Fixup Page Table to find any 
         fixups associated with the logical page. 
 
 
     DATA SIZE = DW  Number of bytes of data for this page. 
         This field specifies the actual number of bytes that 
         represent the page in  the  file.  If  the PAGE SIZE 
         field  from the  module header is greater  than  the 
         value of this  field and the FLAGS field indicates a 
         Legal Physical  Page,  the remaining bytes are to be 
         filled with zeros.  If  the FLAGS field indicates an 
         Iterated  Data Page,  the iterated data records will 
         completely fill out the remainder. 
 
 
     FLAGS =  DW  Attributes  specifying  characteristics  of 
     this logical page. 
         The bit definitions for this word field follow, 
 
             00h = Legal Physical Page  in the module (Offset 
             from Preload Page Section). 
             01h  = Iterated Data Page (Offset from  Iterated 
             Data Pages Section). 
             02h = Invalid Page (zero). 
             03h = Zero Filled Page (zero). 
             04h = Range of Pages. 
 
 
 
 
     Resource Table 
 
 
 The resource table is  an array of  resource  table entries. 
 Each resource  table entry  contains  a type ID and name ID. 
 These entries  are used to locate resource objects contained 
 in the Object table.  The number  of entries in the resource 
 table is defined by the  Resource Table Count located in the 
 linear EXE  header.  More than one resource may be contained 
 within  a  single  object.  Resource table entries are in  a 
 sorted  order,  (ascending,  by Resource Name ID  within the 
 Resource  Type  ID).  This  allows  the  DosGetResource  API 
 function to use a binary search when looking  up  a resource 
 in  a 32-bit module instead of the linear  search being used 
 in the current 16-bit module. 
 
 Each resource entry has the following format: 
 
           +-----+-----+-----+-----+ 
       00h |  TYPE ID  |  NAME ID  | 
           +-----+-----+-----+-----+ 
       04h |     RESOURCE SIZE     | 
           +-----+-----+-----+-----+-----+-----+ 
       08h |   OBJECT  |        OFFSET         | 
           +-----+-----+-----+-----+-----+-----+ 
 
 
     TYPE ID = DW  Resource type ID. 
         The type of resources are: 
 
             BTMP = Bitmap 
             EMSG = Error message string 
             FONT = Fonts 
 
     NAME ID = DW  An ID used as a name for the resource when 
     referred to. 
 
     RESOURCE SIZE =  DD  The  number of  bytes the  resource 
     consists of. 
 
     OBJECT = DW  The number of the object which contains the 
     resource. 
 
     OFFSET  = DD  The  offset  within the  specified  object 
     where the resource begins. 
 
 
 
 
 
     Resident or Non-resident Name Table Entry 
 
 
 The  resident and  non-resident name tables define the ASCII 
 names  and  ordinal  numbers  for  exported  entries  in the 
 module.  In  addition the first  entry in the resident  name 
 table contains  the  module name. These tables  are  used to 
 translate a procedure name  string into an ordinal number by 
 searching for a matching name string.  The ordinal number is 
 used  to  locate the  entry  point information in the  entry 
 table. 
 
 The resident name  table is kept  resident  in system memory 
 while the  module is loaded.  It is intended to contain  the 
 exported  entry point names  that  are frequently dynamicaly 
 linked to  by  name.  Non-resident  names  are  not  kept in 
 memory and are read from the  EXE file when a  dynamic  link 
 reference  is made.  Exported  entry  point  names  that are 
 infrequently dynamicaly linked to by  name  or are  commonly 
 referenced  by  ordinal  number  should  be  placed  in  the 
 non-resident name  table.  The trade off made for references 
 by name is performance vs memory usage. 
 
 Import  references  by  name  require  these  tables  to  be 
 searched  to  obtain the entry point ordinal number.  Import 
 references  by  ordinal  number  provide the fastest  lookup 
 since the search of these tables is not required. 
 
 The strings are CASE SENSITIVE and are NOT NULL TERMINATED. 
 
 Each name table entry has the following format: 
 
           +-----+-----+-----+-----+     +-----+-----+-----+ 
       00h | LEN |    ASCII STRING  . . .      | ORDINAL # | 
           +-----+-----+-----+-----+     +-----+-----+-----+ 
 
 
     LEN = DB  String Length. 
         This  defines the length  of the string in bytes.  A 
         zero length indicates there  are no more  entries in 
         table.  The length of  each  ascii  name  string  is 
         limited to 127 characters. 
 
         The high bit in  the LEN field (bit 7) is defined as 
         an Overload bit.  This bit signifies that additional 
         information is contained in  the  linear  EXE module 
         and will be  used in the  future  for parameter type 
         checking. 
 
     ASCII STRING = DB  ASCII String. 
         This is a variable length string  with  it's  length 
         defined  in  bytes by the LEN field.  The string  is 
         case case sensitive and is not null terminated. 
 
     ORDINAL # = DW  Ordinal number. 
         The ordinal number  in  an  ordered  index  into the 
         entry table for this entry point. 
 
 
 
 
 
     Entry Table 
 
 
 The entry table contains object  and offset information that 
 is used to resolve fixup  references  to  the  entry  points 
 within this module.  Not all entry points in the entry table 
 will be exported, some entry points will only be used within 
 the module.  An  ordinal number is  used to  index  into the 
 entry table.  The entry table entries  are numbered starting 
 from one. 
 
 The  list  of  entries  are compressed into 'bundles', where 
 possible.  The entries within  each bundle are all the  same 
 size.  A bundle starts with  a  count field  which indicates 
 the number of entries in the bundle.  The  count is followed 
 by a  type field  which identifies the  bundle format.  This 
 provides  both  a  means  for  saving  space as  well  as  a 
 mechanism for extending the bundle types. 
 
 The type field  allows  the  definition of 256 bundle types. 
 The following bundle types will initially be defined: 
 
     Unused Entry. 
     16-bit Entry. 
     286 Call Gate Entry. 
     32-bit Entry. 
     Forwarder Entry. 
 
 The bundled entry table has the following format: 
 
           +-----+-----+-----+-----+-----+ 
       00h | CNT |TYPE | BUNDLE INFO . . . 
           +-----+-----+-----+-----+-----+ 
 
 
     CNT = DB  Number of entries. 
         This is the number of entries in this bundle. 
 
         A  zero value for  the number of entries  identifies 
         the  end of the entry  table.  There  is no  further 
         bundle  information when  the number  of entries  is 
         zero.  In other words the entry  table is terminated 
         by a single zero byte. 
 
     TYPE = DB  Bundle type. 
         This  defines the  bundle type  which determines the 
         contents of the BUNDLE INFO. 
 
             The follow types are defined: 
 
                 00h = Unused Entry. 
                 01h = 16-bit Entry. 
                 02h = 286 Call Gate Entry. 
                 03h = 32-bit Entry. 
                 04h = Forwarder Entry. 
                 80h = Parameter Typing Information Present. 
                     This   bit  signifies   that  additional 
                     information  is contained in the  linear 
                     EXE module  and  will  be  used  in  the 
                     future for parameter type checking. 
 
 
     The following is the format for each bundle type: 
 
               +-----+-----+ 
           00h | CNT |TYPE | 
               +-----+-----+ 
 
         CNT = DB  Number of entries. 
             This is the number of unused entries to skip. 
 
         TYPE = DB  0 (Unused Entry) 
 
               +-----+-----+-----+-----+ 
           00h | CNT |TYPE |   OBJECT  | 
               +-----+-----+-----+-----+ 
           04h |FLAGS|  OFFSET   | 
               +-----+-----+-----+ 
           07h | ... |   . . .   | 
               +     +     +     + 
 
 
         CNT = DB  Number of entries. 
             This is the  number of 16-bit  entries  in  this 
             bundle.  The flags and offset value are repeated 
             this number of times. 
 
         TYPE = DB  1 (16-bit Entry) 
 
             OBJECT = DW  Object number. 
                 This is the object number for the entries in 
                 this bundle. 
 
             FLAGS = DB  Entry flags. 
                 These  are the  flags for this entry  point. 
                 They have the following definition. 
 
                     01h = Exported entry flag. 
                     F8h = Parameter word count mask. 
 
             OFFSET = DW  Offset in object. 
                 This is the  offset  in the  object for  the 
                 entry point defined at this ordinal number. 
 
 
               +-----+-----+-----+-----+ 
           00h | CNT |TYPE |   OBJECT  | 
               +-----+-----+-----+-----+-----+ 
           04h |FLAGS|  OFFSET   | CALLGATE  | 
               +-----+-----+-----+-----+-----+ 
           09h | ... |   . . .   |   . . .   | 
               +     +     +     +     +     + 
 
 
         CNT = DB  Number of entries. 
             This is  the number of 286  call gate entries in 
             this  bundle.  The  flags,  callgate, and offset 
             value are repeated this number of times. 
 
         TYPE = DB  2 (286 Call Gate Entry) 
             The 286 Call Gate Entry  Point type is needed by 
             the loader only  if ring  2 segments  are to  be 
             supported.  286  Call  Gate  entries  contain  2 
             extra bytes  which  are  used by  the  loader to 
             store an LDT callgate selector value. 
 
         OBJECT = DW  Object number. 
             This is the  object  number  for the  entries in 
             this bundle. 
 
         FLAGS = DB  Entry flags. 
             These are the flags  for this entry point.  They 
             have the following definition. 
 
                 01h = Exported entry flag. 
                 F8h = Parameter word count mask. 
 
         OFFSET = DW  Offset in object. 
             This is the offset in the object  for  the entry 
             point defined at this ordinal number. 
 
         CALLGATE = DW  Callgate selector. 
             The callgate  selector is a  reserved field used 
             by the  loader  to store a  call  gate  selector 
             value for references  to  ring  2  entry points. 
             When a  ring 3 reference to a ring 2 entry point 
             is  made,  the  callgate  selector with  a  zero 
             offset is place in the relocation fixup address. 
             The  segment  number  and  offset  in segment is 
             placed in the LDT callgate. 
 
 
               +-----+-----+-----+-----+ 
           00h | CNT |TYPE |   OBJECT  | 
               +-----+-----+-----+-----+-----+ 
           04h |FLAGS|        OFFSET         | 
               +-----+-----+-----+-----+-----+ 
           09h | ... |         . . .         | 
               +     +     +     +     +     + 
 
         CNT = DB  Number of entries. 
             This is  the  number  of  32-bit entries in this 
             bundle.  The flags and offset value are repeated 
             this number of times. 
 
         TYPE = DB  3 (32-bit Entry) 
             The 32-bit Entry type will  only be  defined  by 
             the linker when the offset in the object can not 
             be specified by a 16-bit offset. 
 
         OBJECT = DW  Object number. 
             This  is  the object  number for the  entries in 
             this bundle. 
 
         FLAGS = DB  Entry flags. 
             These are the  flags for this entry point.  They 
             have the following definition. 
 
                 01h = Exported entry flag. 
                 F8h = Parameter dword count mask. 
 
         OFFSET = DD  Offset in object. 
             This is  the  offset in the object for the entry 
             point defined at this ordinal number. 
 
           +-----+-----+-----+-----+ 
       00h | CNT |TYPE | RESERVED  | 
           +-----+-----+-----+-----+-----+-----+-----+ 
       04h |FLAGS| MOD ORD#  | OFFSET / ORDNUM       | 
           +-----+-----+-----+-----+-----+-----+-----+ 
       09h | ... |    ...    |          ...          | 
           +     +     +     +     +     +     +     + 
 
     CNT = DB  Number of entries. 
         This  is  the number  of forwarder  entries in  this 
         bundle.  The  FLAGS,  MOD  ORD#,  and  OFFSET/ORDNUM 
         values are repeated this number of times. 
 
     TYPE = DB  4 (Forwarder Entry) 
 
     RESERVED = DW 0 
         This field is reserved for future use. 
 
     FLAGS = DB  Forwarder flags. 
         These  are the flags  for  this  entry  point.  They 
         have the following definition. 
 
             01h = Import by ordinal. 
             F7h = Reserved for future use; should be zero. 
 
     MOD ORD# = DW Module Ordinal Number 
         This  is the index into the Import Module Name Table 
         for this forwarder. 
 
     OFFSET  /  ORDNUM = DD Procedure  Name Offset  or Import 
     Ordinal Number 
         If the FLAGS field indicates import by ordinal, then 
         this field  is  the  ordinal number  into  the Entry 
         Table of the target module, otherwise this  field is 
         the  offset  into the Procedure Names Table  of  the 
         target module. 
 
 A Forwarder entry (type  = 4) is  an entry point whose value 
 is an imported  reference.  When  a load  time  fixup occurs 
 whose target is a forwarder, the  loader obtains the address 
 imported by the forwarder and  uses that imported address to 
 resolve the fixup. 
 
 A forwarder  may refer  to an entry point  in another module 
 which  is itself a  forwarder, so there  can be a  chain  of 
 forwarders.  The  loader  will traverse the chain  until  it 
 finds a non-forwarded entry point which terminates the chain 
 ,  and  use  this to  resolve  the original fixup.  Circular 
 chains are detected by the loader  and result in a load time 
 error.  A  maximum of 1024 forwarders is allowed in a chain; 
 more than this results in a load time error. 
 
 Forwarders  are useful for merging and recombining API calls 
 into  different  sets   of   libraries,   while  maintaining 
 compatibility with applications.  For example, if one wanted 
 to  combine MONCALLS,  MOUCALLS,  and VIOCALLS into a single 
 libraries, one  could  provide entry  points  for  the three 
 libraries  that   are  forwarders  pointing  to  the  common 
 implementation. 
 
 
 
     Module Format Directives Table 
 
 
 The Module Format Directives Table is an optional table that 
 allows additional options to  be specified.  It also  allows 
 for  the extension of the  linear  EXE  format  by  allowing 
 additional tables  of  information to be added to the linear 
 EXE  module  without affecting the format  of the linear EXE 
 header.  Likewise,  module format directives provide a place 
 in   the   linear  EXE  module  for  'temporary  tables'  of 
 information,  such as  incremental linking  information  and 
 statistic information  gathered  on the module.  When  there 
 are no module format directives for a linear EXE module, the 
 fields  in  the linear EXE  header  referencing  the  module 
 format directives table are zero. 
 
 Each Module  Format Directive Table entry  has the following 
 format: 
 
           +-----+-----+-----+-----+-----+-----+----+----+ 
       00h | DIRECT #  | DATA LEN  |     DATA OFFSET     | 
           +-----+-----+-----+-----+-----+-----+----+----+ 
 
     DIRECT # = DW  Directive number. 
         The directive number specifies the type of directive 
         defined.  This  can be used to  determine the format 
         of  the  information  in  the  directive  data.  The 
         following directive numbers have been defined: 
 
             8000h = Resident Flag Mask. 
                 Directive numbers with this bit set indicate 
                 that the directive data is in  the  resident 
                 area and will  be kept  resident  in  memory 
                 when the module is loaded. 
 
             8001h = Verify Record Directive. (Verify  record 
             is a resident table.) 
             0002h = Language Information Directive. (This is 
             a non-resident table.) 
             0003h = Co-Processor Required Support Table. 
             0004h = Thread State Initialization Directive. 
 
         Additional directives can be  added as needed in the 
         future, as long as  they  do  not overlap previously 
         defined directive numbers. 
 
     DATA LEN = DW  Directive data length. 
         This specifies the length in  byte of  the directive 
         data for this directive number. 
 
     DIRECTIVE OFFSET = DD  Directive data offset. 
         This  is the offset to  the directive data for  this 
         directive number.  It  is  relative to beginning  of 
         linear EXE header for a resident table, and relative 
         to  the  beginning of the EXE  file for non-resident 
         tables. 
 
 
 
 
 
     Verify Record Directive Table 
 
 
 The Verify Record Directive Table  is an optional table.  It 
 maintains a record  of  the pages in  the EXE file that have 
 been  fixed up  and written back to the  original linear EXE 
 module, along with the  module  dependencies used to perform 
 these fixups.  This table  provides  an  efficient means for 
 verifying the  virtual  addresses  required for the fixed up 
 pages when the module is loaded. 
 
 Each Verify Record entry has the following format: 
 
           +-----+-----+ 
       00h |# OF ENTRY | 
           +-----+-----+-----+-----+-----+-----+ 
       02h | MOD ORD # |  VERSION  | MOD # OBJ | 
           +-----+-----+-----+-----+-----+-----+ 
       08h | OBJECT #  | BASE ADDR |  VIRTUAL  | 
           +-----+-----+-----+-----+-----+-----+ 
       0Eh |   . . .   |   . . .   |   . . .   | 
           +     +     +     +     +     +     + 
 
     # OF ENTRY = DW  Number of module dependencies. 
         This field specifies how many  entries there  are in 
         the verify record directive table.  This is equal to 
         the number of modules referenced by this module. 
 
     MOD  ORD # = DW  Ordinal index  into  the  Import Module 
     Name Table. 
         This value is an ordered  index  in  to  the  Import 
         Module Name Table for the referenced module. 
 
     VERSION = DW  Module Version. 
 
         This  is the version of  the  referenced module that 
         the fixups  were originally performed.  This is used 
         to insure the same version  of the referenced module 
         is  loaded  that  was  fixed up  in this module  and 
         therefore   the   fixups  are  still  correct.  This 
         requires  the  version number  in  a  module  to  be 
         incremented anytime the entry point offsets change. 
 
     MOD # OBJ = DW  Module # of Object Entries. 
         This field is used to  identify the number of object 
         verify  entries  that   follow  for  the  referenced 
         module. 
 
     OBJECT # = DW  Object # in Module. 
         This  field  specifies  the  object  number  in  the 
         referenced module that is being verified. 
 
     BASE ADDR = DW  Object load base address. 
         This is  the  address that the object was  loaded at 
         when the fixups were performed. 
 
     VIRTUAL = DW  Object virtual address size. 
         This field specifies the  total  amount  of  virtual 
         memory required for this object. 
 
 
 
 
 
     Per-Page Checksum 
 
 
 The  Per-Page   Checksum   table   provides   space   for  a 
 cryptographic  checksum for each  physical  page  in the EXE 
 file. 
 
 The checksum table is arranged such that the first entry  in 
 the table corresponds to the first logical page of code/data 
 in the EXE file (usually a preload page) and the  last entry 
 corresponds to  the  last  logical  page  in  the  EXE  file 
 (usually a iterated data page). 
 
                     +-----+-----+-----+-----+ 
    Logical Page #1  |        CHECKSUM       | 
                     +-----+-----+-----+-----+ 
    Logical Page #2  |        CHECKSUM       | 
                     +-----+-----+-----+-----+ 
                               . . . 
 
                     +-----+-----+-----+-----+ 
    Logical Page #n  |        CHECKSUM       | 
                     +-----+-----+-----+-----+ 
 
 
     CHECKSUM = DD  Cryptographic checksum. 
 
 
 
 
 
     Fixup Page Table 
 
 
 The Fixup Page Table provides a simple  mapping of a logical 
 page number to an  offset  into  the Fixup Record  Table for 
 that page. 
 
 This table is parallel to the Object Page Table, except that 
 there is one  additional entry in this table to indicate the 
 end of the Fixup Record Table. 
 
 The format of each entry is: 
 
                   +-----+-----+-----+-----+ 
  Logical Page #1  |  OFFSET FOR PAGE #1   | 
                   +-----+-----+-----+-----+ 
  Logical Page #2  |  OFFSET FOR PAGE #2   | 
                   +-----+-----+-----+-----+ 
                             . . . 
                   +-----+-----+-----+-----+ 
  Logical Page #n  |  OFFSET FOR PAGE #n   | 
                   +-----+-----+-----+-----+ 
                   |OFF TO END OF FIXUP REC|   This is equal to: 
                   +-----+-----+-----+-----+   Offset for page #n + Size 
                                               of fixups for page #n 
 
 
     OFFSET FOR PAGE # = DD  Offset for fixup record for this 
     page. 
         This  field specifies the offset, from the beginning 
         of the fixup record table, to the first fixup record 
         for this page. 
 
     OFF TO  END  OF FIXUP REC = DD  Offset to the end of the 
     fixup records. 
         This field specifies  the offset  following the last 
         fixup record in the fixup record table.  This is the 
         last entry in the fixup page table. 
 
         The fixup records are kept in order by logical  page 
         in the fixup record table.  This  allows the end  of 
         each page's fixup records  is defined by  the offset 
         for  the  next logical  page's fixup  records.  This 
         last  entry provides  support of this mechanism  for 
         the last page in the fixup page table. 
 
 
 
 
 
     Fixup Record Table 
 
 
 The  Fixup  Record Table contains entries  for all fixups in 
 the linear EXE module.  The fixup records for a logical page 
 are  grouped together and kept  in  sorted order by  logical 
 page number.  The  fixups for  each page are  further sorted 
 such that all external fixups  and internal selector/pointer 
 fixups come before internal non-selector/non-pointer fixups. 
 This allows  the  loader  to  ignore internal fixups  if the 
 loader  is  able  to  load  all  objects  at  the  addresses 
 specified in the object table. 
 
 Each relocation record has the following format: 
 
           +-----+-----+-----+-----+ 
       00h | SRC |FLAGS|SRCOFF/CNT*| 
           +-----+-----+-----+-----+-----+-----+ 
   03h/04h |           TARGET DATA *           | 
           +-----+-----+-----+-----+-----+-----+ 
           | SRCOFF1 @ |   . . .   | SRCOFFn @ | 
           +-----+-----+----   ----+-----+-----+ 
 
         * These fields are variable size. 
         @ These fields are optional. 
 
 
     SRC = DB  Source type. 
         The source type specifies the  size  and type of the 
         fixup to  be  performed  on  the  fixup source.  The 
         source type is defined as follows: 
 
             0Fh = Source mask. 
             00h = Byte fixup (8-bits). 
             01h = (undefined). 
             02h = 16-bit Selector fixup (16-bits). 
             03h = 16:16 Pointer fixup (32-bits). 
             04h = (undefined). 
             05h = 16-bit Offset fixup (16-bits). 
             06h = 16:32 Pointer fixup (48-bits). 
             07h = 32-bit Offset fixup (32-bits). 
             08h   =   32-bit  Self-relative   offset   fixup 
             (32-bits). 
             10h = Fixup to Alias Flag. 
                 When the 'Fixup to Alias' Flag is  set,  the 
                 source fixup refers to  the 16:16  alias for 
                 the  object.  This is only  valid for source 
                 types  of 2, 3, and 6.  For  fixups such  as 
                 this, the linker and loader will be required 
                 to   perform   additional   checks  such  as 
                 ensuring that the  target  offset  for  this 
                 fixup is less than 64K. 
 
             20h = Source List Flag. 
 
                 When  the  'Source  List'  Flag is set,  the 
                 SRCOFF field  is compressed  to  a byte  and 
                 contains the number of source offsets, and a 
                 list  of source  offsets  follows the end of 
                 fixup  record (after  the  optional additive 
                 value). 
 
     FLAGS = DB  Target Flags. 
         The target flags specify how the target  information 
         is interpreted.  The  target flags  are  defined  as 
         follows: 
 
             03h = Fixup target type mask. 
             00h = Internal reference. 
             01h = Imported reference by ordinal. 
             02h = Imported reference by name. 
             03h = Internal reference via entry table. 
             04h = Additive Fixup Flag. 
                 When set, an additive value trails the fixup 
                 record (before the  optional  source  offset 
                 list). 
 
             08h = Reserved.  Must be zero. 
             10h = 32-bit Target Offset Flag. 
                 When  set, the  target  offset  is  32-bits, 
                 otherwise it is 16-bits. 
 
             20h = 32-bit Additive Fixup Flag. 
                 When set,  the  additive value  is  32-bits, 
                 otherwise it is 16-bits. 
 
             40h = 16-bit Object Number/Module Ordinal Flag. 
                 When  set,  the   object  number  or  module 
                 ordinal number  is 16-bits, otherwise  it is 
                 8-bits. 
 
             80h = 8-bit Ordinal Flag. 
                 When  set,  the  ordinal number  is  8-bits, 
                 otherwise it is 16-bits. 
 
     SRCOFF =  DW/CNT  = DB  Source  offset  or source offset 
     list count. 
         This field contains  either  an  offset  or  a count 
         depending on the  Source  List Flag.  If the  Source 
         List Flag is  set,  a list of source offsets follows 
         the additive field and this field contains the count 
         of  the  entries   in   the   source   offset  list. 
         Otherwise, this is the single source offset for  the 
         fixup.  Source offsets are relative to the beginning 
         of the page where the fixup is to be made. 
 
         Note that for fixups that  cross page  boundaries, a 
         separate  fixup  record is  specified for each page. 
         An offset is still used for the 2nd  page but it now 
         becomes a negative offset since the fixup originated 
         on  the  preceding page.  (For  example, if only the 
         last one byte of a 32-bit address is on the page  to 
         be fixed up, then the offset would  have  a value of 
         -3.) 
 
     TARGET DATA = Target data for fixup. 
         The  format of the  TARGET  DATA  is  dependent upon 
         target flags. 
 
     SRCOFF1 - SRCOFFn = DW[]  Source offset list. 
         This list is present if the  Source List Flag is set 
         in the Target Flags field.  The number of entries in 
         the  source offset list is defined in the SRCOFF/CNT 
         field.  The  source  offsets  are  relative  to  the 
         beginning of the  page where  the fixups are  to  be 
         made. 
 
               +-----+-----+-----+-----+ 
           00h | SRC |FLAGS|SRCOFF/CNT*| 
               +-----+-----+-----+-----+-----+-----+ 
       03h/04h |  OBJECT * |        TRGOFF * @     | 
               +-----+-----+-----+-----+-----+-----+ 
               | SRCOFF1 @ |   . . .   | SRCOFFn @ | 
               +-----+-----+----   ----+-----+-----+ 
 
             * These fields are variable size. 
             @ These fields are optional. 
 
 
         OBJECT = D[B|W]  Target object number. 
             This field is an index into the current module's 
             Object Table to  specify  the target Object.  It 
             is  a  Byte  value  when   the   '16-bit  Object 
             Number/Module Ordinal  Flag' bit  in  the target 
             flags field is clear and  a Word  value when the 
             bit is set. 
 
 
         TRGOFF = D[W|D]  Target offset. 
             This  field  is  an  offset  into  the specified 
             target  Object.  It  is  not  present  when  the 
             Source Type  specifies a  16-bit Selector fixup. 
             It  is  a  Word value when  the  '32-bit  Target 
             Offset Flag'  bit  in the target flags field  is 
             clear and a Dword value when the bit is set. 
 
               +-----+-----+-----+-----+ 
           00h | SRC |FLAGS|SRCOFF/CNT*| 
               +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+ 
       03h/04h | MOD ORD# *| PROCEDURE NAME OFFSET*|     ADDITIVE * @      | 
               +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+ 
               | SRCOFF1 @ |   . . .   | SRCOFFn @ | 
               +-----+-----+----   ----+-----+-----+ 
 
             * These fields are variable size. 
             @ These fields are optional. 
 
 
         MOD ORD # =  D[B|W]  Ordinal  index into the  Import 
         Module Name Table. 
             This value  is an ordered index in to the Import 
             Module Name Table  for the module containing the 
             procedure entry point.  It is a Byte value  when 
             the '16-bit  Object Number/Module  Ordinal' Flag 
             bit  in the target flags  field is  clear  and a 
             Word  value  when  the  bit  is set.  The loader 
             creates a table of pointers with each pointer in 
             the  table  corresponds to the  modules named in 
             the  Import  Module Name Table.  This  value  is 
             used  by  the loader  to  index into  this table 
             created by the  loader  to locate the referenced 
             module. 
 
         PROCEDURE NAME  OFFSET  =  D[W|D]  Offset  into  the 
         Import Procedure Name Table. 
             This   field   is  an  offset  into  the  Import 
             Procedure Name Table.  It  is a Word  value when 
             the  '32-bit  Target Offset  Flag'  bit  in  the 
             target flags field  is clear and  a Dword  value 
             when the bit is set. 
 
         ADDITIVE = D[W|D]  Additive fixup value. 
             This field exists in the fixup  record only when 
             the 'Additive  Fixup  Flag'  bit  in  the target 
             flags field is set.  When  the  'Additive  Fixup 
             Flag' is clear the fixup record does not contain 
             this  field  and is immediately followed by  the 
             next fixup record (or  by the source offset list 
             for this fixup record). 
 
             This value is added to the address  derived from 
             the  target entry point.  This field  is  a Word 
             value when the '32-bit Additive Flag' bit in the 
             target flags field is  clear  and a  Dword value 
             when the bit is set. 
 
               +-----+-----+-----+-----+ 
           00h | SRC |FLAGS|SRCOFF/CNT*| 
               +-----+-----+-----+-----+-----+-----+-----+-----+ 
       03h/04h | MOD ORD# *|IMPORT ORD*|     ADDITIVE * @      | 
               +-----+-----+-----+-----+-----+-----+-----+-----+ 
               | SRCOFF1 @ |   . . .   | SRCOFFn @ | 
               +-----+-----+----   ----+-----+-----+ 
 
             * These fields are variable size. 
             @ These fields are optional. 
 
 
         MOD ORD  # = D[B|W]  Ordinal index  into  the Import 
         Module Name Table. 
             This value is an ordered index  in to the Import 
             Module  Name Table for the module containing the 
             procedure  entry point.  It is a Byte value when 
             the '16-bit Object Number/Module  Ordinal'  Flag 
             bit in the target flags  field is  clear  and  a 
             Word  value  when  the  bit  is set.  The loader 
             creates a table of pointers with each pointer in 
             the table  corresponds  to the  modules named in 
             the  Import Module  Name Table.  This  value  is 
             used by the loader  to  index  into  this  table 
             created  by the loader to locate the  referenced 
             module. 
 
         IMPORT ORD = D[B|W|D]  Imported ordinal number. 
             This is the imported procedure's ordinal number. 
             It is a Byte value when  the '8-bit Ordinal' bit 
             in the target flags  field is set.  Otherwise it 
             is  a Word value when the '32-bit Target  Offset 
             Flag' bit in the target flags field is clear and 
             a Dword value when the bit is set. 
 
         ADDITIVE = D[W|D]  Additive fixup value. 
             This field exists in the fixup  record only when 
             the  'Additive Fixup Flag'  bit  in  the  target 
             flags field is set.  When  the  'Additive  Fixup 
             Flag' is clear the fixup record does not contain 
             this field  and  is  immediately followed by the 
             next fixup record (or  by the source offset list 
             for this fixup record). 
 
             This value is  added to the address derived from 
             the  target entry point.  This field is  a  Word 
             value when the '32-bit Additive Flag' bit in the 
             target flags field  is  clear and a Dword  value 
             when the bit is set. 
 
               +-----+-----+-----+-----+ 
           00h | SRC |FLAGS|SRCOFF/CNT*| 
               +-----+-----+-----+-----+-----+-----+ 
       03h/04h |  ORD # *  |     ADDITIVE * @      | 
               +-----+-----+-----+-----+-----+-----+ 
               | SRCOFF1 @ |   . . .   | SRCOFFn @ | 
               +-----+-----+----   ----+-----+-----+ 
 
             * These fields are variable size. 
             @ These fields are optional. 
 
         ENTRY #  =  D[B|W]  Ordinal  index  into  the  Entry 
         Table. 
             This field is an index into the current module's 
             Entry  Table  to  specify the target Object  and 
             offset.  It  is a Byte  value when  the  '16-bit 
             Object Number/Module  Ordinal' Flag bit  in  the 
             target flags field is  clear  and  a  Word value 
             when the bit is set. 
 
         ADDITIVE = D[W|D]  Additive fixup value. 
             This field exists in the  fixup record only when 
             the  'Additive Fixup  Flag'  bit  in the  target 
             flags  field is set.  When the  'Additive  Fixup 
             Flag' is clear the fixup record does not contain 
             this  field and is  immediately followed  by the 
             next fixup record (or by the source  offset list 
             for this fixup record). 
 
             This value  is added to the address derived from 
             the  target  entry point.  This field is a  Word 
             value when the '32-bit Additive Flag' bit in the 
             target  flags  field  is clear and a Dword value 
             when the bit is set. 
 
 
 
 
 
  Import Module Name Table 
 
 
 The import module name table defines the module name strings 
 imported through dynamic link references.  These strings are 
 referenced through the imported relocation fixups. 
 
 To determine the  length  of the  import  module  name table 
 subtract the import module name table offset from the import 
 procedure  name  table offset.  These values are located  in 
 the  linear EXE header.  The end  of the import module  name 
 table  is  not  terminated by  a special  character,  it  is 
 followed directly by the import procedure name table. 
 
 The strings are CASE SENSITIVE and NOT NULL TERMINATED. 
 
 Each name table entry has the following format: 
 
           +-----+-----+-----+-----+     +-----+ 
       00h | LEN |    ASCII STRING  . . .      | 
           +-----+-----+-----+-----+     +-----+ 
 
     LEN = DB  String Length. 
         This defines the length of the string in bytes.  The 
         length of each ascii name string is  limited  to 127 
         characters. 
 
     ASCII STRING = DB  ASCII String. 
         This is a  variable  length string with it's  length 
         defined in bytes by the  LEN  field.  The  string is 
         case sensitive and is not null terminated. 
 
 
 
 
 
     Import Procedure Name Table 
 
 
 The import procedure name table defines  the  procedure name 
 strings  imported  by  this  module   through  dynamic  link 
 references.   These   strings  are  referenced  through  the 
 imported relocation fixups. 
 
 To determine the length  of the import procedure  name table 
 add the fixup section size  to the  fixup page table offset, 
 this computes the  offset to  the end of the  fixup section, 
 then subtract the import procedure name table offset.  These 
 values are located  in  the linear  EXE header.  The  import 
 procedure name table is followed by the data pages  section. 
 Since the  data pages  section is aligned  on a 'page  size' 
 boundary, padded space  may  exist  between the  last import 
 name  string  and the first page in  the data pages section. 
 If this padded space exists it will be zero filled. 
 
 The strings are CASE SENSITIVE and NOT NULL TERMINATED. 
 
 Each name table entry has the following format: 
 
           +-----+-----+-----+-----+     +-----+ 
       00h | LEN |    ASCII STRING  . . .      | 
           +-----+-----+-----+-----+     +-----+ 
 
     LEN = DB  String Length. 
         This defines the length of the string in bytes.  The 
         length of each ascii  name  string is limited to 127 
         characters. 
 
         The high bit  in the LEN field (bit 7) is defined as 
         an Overload bit.  This bit signifies that additional 
         information  is  contained in the  linear EXE module 
         and will  be  used in the future for  parameter type 
         checking. 
 
     ASCII STRING = DB  ASCII String. 
         This is  a variable  length string  with it's length 
         defined in bytes by the LEN  field.  The  string  is 
         case sensitive and is not null terminated. 
 
 
 
 
 
     Preload Pages 
 
 
 The  Preload Pages section  is an  optional section  in  the 
 linear EXE module that coalesces a 'preload page set' into a 
 contiguous section.  The  preload page set can be defined as 
 the set of first used pages in the module.  The preload page 
 set can be specified by the application developer or can  be 
 derived by a  tool that  analyzes the programs memory  usage 
 while  it  is  running.  By grouping the  preload  page  set 
 together, the preload pages can be read  from the linear EXE 
 module with one disk read. 
 
 The structure of  the preload pages is no different than  if 
 they  were  demand  loaded.  They  are  non-iterated  pages. 
 Their sizes are determined  by the Object Page Table entries 
 that  correspond.  If  the  specified size is less than  the 
 PAGE SIZE field given in the linear  EXE  module  header the 
 remainder of the page is filled with zeros when loaded. 
 
 All pages  begin on a  PAGE  OFFSET  SHIFT boundary from the 
 base of the preload page section, as specified in the linear 
 EXE  header.  The  pages are ordered by logical  page number 
 within this section. 
 
Note: OS/2 2.0 does not respect preload pages. Performance tests 
showed that better system performance was obtained by not 
respecting the preload request in the executable file. 
 
 
 
 
     Demand Load Pages 
 
 
 The   Demand   Loaded   Pages  section   contains   all  the 
 non-iterated  pages  for a linear  EXE  module that are  not 
 preloaded.  When  required,  the whole  page is loaded  into 
 memory  from  the module.  The characteristics  of  each  of 
 these pages is specified  in the  Object Page  Table.  Every 
 page begins on a PAGE OFFSET SHIFT  boundary  aligned offset 
 from the demand  loaded pages base specified  in the  linear 
 EXE header.  Their  sizes are determined by the  Object Page 
 Table  entries that correspond.  If  the  specified size  is 
 less than the PAGE SIZE field given in the linear EXE module 
 header the  remainder  of the page is filled with zeros when 
 loaded.  The pages are ordered by logical page number within 
 this section. 
 
 
 
 
     Iterated Data Pages 
 
 
 The Iterated Data Pages section contains all the pages for a 
 linear EXE module that are iterated.  When required, the set 
 of iteration records are loaded into  memory from the module 
 and  expanded  to  reconstitute  the  page.  Every   set  of 
 iteration records begins on  a PAGE OFFSET SHIFT offset from 
 the  OBJECT ITER  PAGES  OFF  specified  in  the linear  EXE 
 header.  Their sizes are determined by the Object Page Table 
 entries  that correspond.  The  pages are ordered by logical 
 page number within this section. 
 
 This  record structure is used to describe the iterated data 
 for an object on a per-page basis. 
 
           +-----+-----+-----+-----+ 
       00h |#ITERATIONS|DATA LENGTH| 
           +-----+-----+-----+-----+-----+ 
       04h |DATA BYTES |   . . .   | ... | 
           +-----+-----+-----+-----+-----+ 
 
 Figure 19. Object Iterated Data Record (Iteration Record) 
 
     #ITERATIONS = DW  Number of iterations. 
         This specifies the number of  times that the data is 
         replicated. 
 
     DATA LENGTH = DW  The size of the data pattern in bytes. 
         This specifies the number of bytes of  data of which 
         the pattern consists.  The maximum size is  one half 
         of the PAGE SIZE (given in the module header).  If a 
         pattern exceeds  this value then the data page  will 
         not be condensed into iterated data. 
 
     DATA  =  DB  *  DATA  LENGTH  The  Data  pattern  to  be 
     replicated. 
         The next iteration record  will  immediately  follow 
         the  last  byte of the  pattern.  The  offset of the 
         next iteration record is easily calculated from  the 
         offset  of  this record  by adding  the  DATA LENGTH 
         field  and  the sizes  of the  #ITERATIONS  and DATA 
         LENGTH fields. 
 
 
 
 
 
     Debug Information 
 
 
 The debug information  is  defined by  the debugger  and  is 
 not controlled by the linear EXE format or linker.  The only 
 data defined by the linear EXE format relative  to the debug 
 information is  it's offset  in  the  EXE file and length in 
 bytes as defined in the linear EXE header. 
 
 To  support multiple debuggers the first word of  the  debug 
 information is  a type  field which determines the format of 
 the debug information. 
 
           00h   01h   02h   03h   04h 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
           | 'N' | 'B' | '0' |  n  |   DEBUGGER DATA  . . . . 
           +-----+-----+-----+-----+-----+-----+-----+-----+ 
 
 
     TYPE = DB DUP 4 Format type. 
         This defines  the type of debugger data  that exists 
         in  the  remainder of  the  debug  information.  The 
         signature consists  of  a  string  of four (4) ASCII 
         characters:   "NB0"    followed    by   the    ASCII 
         representation  for 'n'.  The  values  for  'n'  are 
         defined as follows. 
 
         These format types are defined. 
 
             00h = 32-bit CodeView debugger format. 
             01h = AIX debugger format. 
             02h = 16-bit CodeView debugger format. 
             04h = 32-bit OS/2 PM debugger (IBM) format. 
 
     DEBUGGER DATA = Debugger specific data. 
         The  format  of the debugger data  is defined by the 
         debugger that is being used. 
 
         The  values  defined  for  the  type  field are  not 
         enforced by the  system.  It is  the  responsibility 
         of  the  linker  or  debugging tools to  follow  the 
         convention for the type field that is defined here. 
