"Mapping the Amiga" by Rhett Anderson and Randy Thompson.  A comprehensive
guide to the inner world of the Amiga.  Covers libraries and hardware
registers.  Examples in C, Assembly Language, and Modula 2.


Preface

There are so many programming books for the Amiga. Why should there be 
another one?
Frankly, we wrote this book for ourselves. When we sit down to program, 
we find that no single book is enough. The typical Amiga programmer may 
have Commodore's official reference manuals, several Sybex, Abacus, and 
COMPUTE! books, the complete set of Amiga Transactor magazines, and even 
several printouts of downloaded programming information and source code, all 
scattered across desks, chairs, and, of course, the floor. As you know, program-
ming the Amiga is a tough job. You might spend an hour just tracking down 
the right source. What is the solution to this problem?
We turned for inspiration to two books that helped us in the past: Mapping 
the Atari by Ian Chadwick (1983, COMPUTE! Books) and Mapping the Commo-
dore 64 by Sheldon Leemon (1984, COMPUTE! Books). These books had it 
all-explanations of how the respective machines organized memory, detailed 
listings of what various memory locations were and how to use them, descrip-
tions of input/output registers, and discussions of the functions of various 
ROM routines.
These books were so detailed a programmer could literally write a program 
without putting fingerprints on a single other book.
But of course you can't really do the same thing for the Amiga. The above-
mentioned books were slightly over 200 pages. This book is more than twice as 
large and comes nowhere near to saying everything that can be said about the 
Amiga. If the Apple II's built-in software and hardware is an apartment, and the 
Commodore 64's is a townhouse, then the Amiga's is a Manhattan city block.
And the problem is not just a matter of scale. Unlike earlier computers, the 
Amiga doesn't set aside areas of memory for this or that purpose. Instead, the 
Amiga has libraries of routines, which can show up virtually anywhere in the 
RAM space of the machine. These routines aren't even all in ROM; some are 
loaded from disk. The screen is not in a fixed location. Commodore even 
threatens that the locations of the memory-mapped custom chips may change 
at any time. The Amiga doesn't go through all these contortions to be contrary. 
Instead, this level of indirection provides the Amiga with prodigious flexibility. 
Libraries and devices are easily upgraded and added. Peripherals and input de-
vices are easily accommodated.
 

Aware of the problems of scale and flexibility, we set out to accomplish a 
different and (somewhat) more reasonable task: to enable a programmer to use 
our book as a reference work that answers 90 percent of his or her questions. 
This task took the two of us a year. We couldn't have done it alone. We'd like 
to thank Stephen Levy, our editor, for his patience. We would also like to 
thank our friends and co-workers at Amiga Resource and COMPUTE!, and also, 
especially, our wives, for putting up with months of odd moods and the occa-
sional bout of crankiness. A special thanks goes out to Sheldon Leemon for his 
many suggestions and observations.

How to Use This Book:
First, we suggest a little window shopping. Browse among the chapters and the 
appendices. Ever wonder how the blitter works? Curious about the HAM video 
mode? Cruise through the Hardware chapter. Want to know how the Amiga 
organizes its data? Want to know how to use the Amiga's built-in functions? 
The Structures and Libraries chapters tell you. Becoming familiar with the 
structure and content of the book will pay off later.
If you're an expert programmer, we suggest a quick scan of the book. 
You'll probably use this book as a reference. Read the introductions to each 
chapter, and don't forget to check out the appendices.
The majority of the book consists of tables and charts-a compilation of 
vital programming information organized in understandable and usable for-
mats. Much of this information can't be found in any other single place. For ex-
ample, where else can you find a complete listing of library functions that gives 
the syntax of each function in C, machine language, and Modula-2?
Each major section of the book begins with an introduction that explains 
how to use the information that follows. So even if you're a beginner, you'll 
find this book a great way to learn about the Amiga's inner workings.
If you already have a stable of Amiga programming books, notice how the 
layouts of those books compare with ours. For instance, some books group 
functions by the library in which they're found; Mapping the Amiga orders the 
functions alphabetically. Knowing this can save you some time and help you 
learn how to use Mapping in conjunction with your other programming books.
If you don't have any other Amiga programming books, we'd like to sug-
gest a few. Commodore's set of reference manuals (published by Addison Wes-
ley) are invaluable. Be sure to get the latest set; new examples and tables have 
been included in every update so far. Sybex sells three excellent books: Eugene 
Mortimore's two-volume Amiga Programmer's Handbook and Rob Peck's Pro-
gramming the Amiga. Abacus publishes many Amiga books. Our favorites are 
Amiga System Programmer's Guide and Amiga Graphics Inside & Out. COMPUTE!
books also has many titles. We often turn to COMPUTE!'s Amiga Programming 
Guide and Sheldon Leemon's Inside Amiga Graphics. You'll also want a manual 
for the language you're using.

Programming and Mapping:
You can program the Amiga in just about any language you've ever heard of 
(with the possible exception of COBOL). Each language has different syntax, 
requirements, and interfacing details. For this book, we've supported the lan-
guages most familiar to us: Lattice C, M2S's M2Sprint Modula-2, and machine 
language. All programming examples given in this book were written using one 
of these languages. Users of other C and Modula-2 implementations should 
have little trouble using this book. If you use a different language, see the man-
ual for information about how structure offsets are named and what parameters 
are passed to the various system functions.
We hope this book will be useful to you. Don't hesitate to let us know 
what helped you and what you found lacking. Send mail to:

Rhett & Randy
COMPUTE! Publications
324 W. Wendover Ave., Suite 200
Greensboro, NC 27408

You might also be able to find us on your favorite online service, such as 
CompuServe, PLink, or GEnie. Ask your friendly local sysop.
As Bill Wilkinson said in the introduction to Mapping the Atari, good luck 
and happy mapping.
 
Notes from BSI: It took about eight hours to scan and fix the majority of
the typos caused by the scanner (HP ScanJet+) reading bold text incorrect-
ly.  For that reason, I have not scanned the "Structures" part of the book.
You can use you include files for DevPac2 instead.  (Or with Lattice, or
with...)  However, I have included the "hardware" part since I manually
typed that up when I first got my Amiga so I could learn where all the
hardware registers are.  Enjoy the text.  Any questions can be left to me
(Bansai) on Motherboard East 1.5 at 1(215)792-0167.  Slates!
-------------------------
Library Functions

The Amiga is an incredibly capable machine. It has so much to offer, from digi-
tized sounds and dazzling color graphics to a window-based user interface and 
a true multitasking operating system. Library functions are the key to accessing 
these features.
The Amiga's library functions are similar to the Commodore 64's ROM
Kernal subroutines, the IBM PC's BIOS interrupt calls, and the Apple Macin-
tosh's Toolbox procedures-they are a collection of routines that allow you to 
control almost every aspect of your computer. They're called functions because 
the majority of them were written in the C programming language. In C, all
user-defined commands are referred to as functions.

Linked Libraries
There are really two types of libraries on the Amiga: linked libraries and shared 
libraries. (Note: Amiga Basic and Modula-2 do not use linked libraries.)
Linked libraries are a collection of external functions that you make part of 
your program. When you link your program with Alink or Blink, each linked li-
brary function you use is brought in from one of the specified .lib files and
stuffed into your program. The Lattice C file lc.lib and the Manx C file c.lib are 
both examples of linked libraries.
The functions offered by a linked library are dependent upon your compil-
er or assembler. However, one linked library is common-amiga.lib. The
amiga.lib library offers common functions such as printf( ), atoi( ), and
BeginIO( ). Only amiga.lib is documented in this chapter. Language-specific 
linked libraries are explained in the manual that came with your compiler or 
assembler.
Using an amiga.lib function in C is incredibly easy: Simply call the func-
tion by name and then link your program with amiga.lib. For Lattice C users, 
linking with amiga.lib is automatic when you use the compiler's -L option.
Other compilers simply have you provide the amiga.lib filename as one of the 
library parameters in the Alink or Blink command sequence.
Accessing amiga.lib from machine language is a bit tougher. First you must 
declare that function with an XREF statement, preceding the function name with 
an underline character (xref _CreateExtIO, for example). Second, you must 
push the function arguments onto the stack, not place them into registers. To 
actually call the function you simply JSR to the function name, as in JSR
_CreateExtIO. Finally, you must remove the function arguments from the 
stack- the function does not do this for you. A simple addq.l #8,sp would suf-
fice for CreateExtIO( ) since this function accepts two long words (eight bytes) 
worth of arguments.
All of the amiga.lib functions are described in the function tables found at 
the end of this chapter. Here's the entry for amiga.lib's printf( ) function:
-------------------------
printf
Description:		prints a formatted string to the standard output (Lattice and Manx
			users: if you link with lc.lib or c.lib, this is not the function you're
			calling)
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:       		printf(string, values...)
C:            		void printf(char *, long...)
Machine Language: 	move.l #value,-(sp) ;may have several values
			pea string
			jsr _printf
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available
Arguments:string = pointer to string containing optional C formatting com-
	mands (%); if you're passing longword values on the stack (as
	shown above), be sure to follow the percent symbol with a lower-
	case L
	values = values or addresses of strings to print; this routine
	knows how many values are on the stack by checking the number
	of formatting commands in the string argument
Result:	none
-------------------------
The Machine Language entry in this table illustrates how you might call 
the printf( ) function from machine language. Specifically, it shows the order in 
which you must push the function's arguments onto the stack. In all cases, the 
arguments are pushed onto the stack in the order opposite to that shown in the 
Syntax entry (right to left instead of left to right).
In these crude machine language examples, all pointer arguments are 
placed onto the stack using a PEA instruction. In actual use, the argument's ad-
dress may be contained in a register or a memory location, in which case you 
would MOVE it onto the stack. The examples shown here use PEA simply so 
you understand that the function expects an address and not an actual value. If 
the argument is supposed to be a value, we place it onto the stack via a MOVE 
instruction.
  
For a real-world example, the following machine language program makes 
use of amiga.lib's printf( ) function to output the solution to a simple equation:
-------------------------
Program 1-1. Simple Addition

* Machine language example for using the printf( ) linked library function
* -Be sure to link with amiga.lib

* Hard-coded function offsets 
OpenLibrary  equ -552 
CloseLibrary equ -414 
Output       equ -60

AbsExecBase equ 4	;Absolute location of ExecBase pointer

   XREF printf	;Declaration for amiga.lib function
   XDEF SysBase	;Make this available to amiga.lib
   XDEF DOSBase	;Make this available to amiga lib
   XDEF stdout	;Make this available to amiga lib

SECTION code,CODE

* Short-but-effective startup code
   movea.l AbsExecBase,a6	;Pointer to IntuitionBase in a6
   move.l a6, SysBase		;Store it in external location for amiga.lib
   clr.l d0			;Version number goes in d0
   movea.l #DOSName,a1		;Pointer to library's name goes in a1
   ]sr OpenLibrary(a6)		;Open DOS library and return libBase in d0
   move.l d0, d0SBase		;Save library base pointer
   beq.s Abort2			;Abort if dos.library could not be opened
   move.l d0,a6			;Pointer to DOSBase in a6
   jsr Output(a6)		;Call Output to get an output file handle
   move.l d0, stdout		;and store it for amiga.lib
   beq.s Abortl			;Abort if unable to get a file handle

* Main program that adds Num1 and Num2 
move.l Num1,d0              	;Get Num1 into d0 
add.l Num2,d0              	;Add the two numbers and put result in d0

* Call printf( ) to print the addition result in decimal and in hex format
   move.l d0,-(sp)	;Push result onto stack for hex output
   move.l d0,-(sp)	;Push result onto stack for decimal output
   move.l Num2,-(sp)	;Push Num2 value on stack
   move.l Num1,-(sp)	;Push Num1 value on stack
   pea formatString	;Push address of formatString onto stack
   jsr printf		;Call printf( )
   add.l #20,sp		;Remove arguments from stack-
			;(5 arguments * 4 bytes = 20 bytes)

* Close DOS library
Abort1:
   move.l DOSBase,a1	;Pointer to DOSBase in a1
   move.l SysBase,a6	;Pointer to ExecBase in a6
   jsr CloseLibrary(a6)	;Call CloseLibrary( )

* Exit program
Abort2:
   clr.l d0		;Set return code
   rts			;Drop out of program
   

SECTION data,DATA

Num1:

   dc.l 8723	;Value 1 that will be added to
Num2:
   dc.l 434	;Value 2

 SysBase:
   dc.l 0	;Location to hold ExecBase pointer
 DOSBase:
   dc.l 0	;Location to hold DOSBase pointer
 stdout:
   dc.l 0	;Location to hold output handle

DOSName:
   dc.b 'dos.library',0	;Name of dos library

* The following statements define the format string to be used by printf( ) 
* Note that a lowercase L follows all percent symbols (%)-this is required 
* if you pass your values as 32-bit quantities, as we do in this program 
formatString: 
dc.b '%ld + %ld = %ld (%lx hex)',10,0

END
-------------------------
Shared Libraries 
When someone refers to an Amiga library, they're usually talking about a 
shared library. The same is true of this book.
As the name implies, a shared library is accessible to all Amiga programs. 
When you use a shared library function, its code does not become part of your 
program on disk; shared libraries are located in ROM (writable control memory 
on the Amiga 1000) or loaded into RAM from the libs directory of your Work-
bench disk.
Shared libraries are more memory conservative than linked libraries. Every 
program that accesses a function from a linked library must contain its own 
copy of that function. Only one copy of a shared library function ever needs to 
be in memory because all programs have access to it.
At this writing, there are 15 libraries available with Kickstart/Workbench 
1.3, each one covering a different aspect of the Amiga. For graphics program-
ming, you use the graphics.library; for creating windows, requesters, and pull-
down menus, you use the intuition.library; for disk access, you use the 
dos.library.
The clist.library has been removed from Kickstart 1.2 and 1.3, but it is 
available with Kickstart 1.1 and is documented here for the sake of complete-
ness. Two special libraries-romboot.library and version.library-are not cov-
ered in this chapter since the functions they contain are private to the Amiga's 
system software and cannot be called by the user.
------------------------- 
Opening and Closing Libraries 
A library must be opened before you can access its functions. Like your local 
Seven-Eleven store, the Exec library is always open. This works out rather well 
considering OpenLibrary( ), the one function required to open other libraries, is 
contained in Exec. When you link with startup code such as Lattice's c.o, the 
DOS library is opened for you as well. If you program with M2Sprint, you'll 
find that several libraries are automatically opened for you. 
You open a library using the aptly named OpenLibrary( ) function. 
OpenLibrary( ) expects two arguments: the library name and the library version 
number. (See Table 1-2 for a complete list of available libraries.) The sample 
code below shows the C, machine language, and Modula-2 syntax for using the 
OpenLibrary( ) function.

In C: 
libBase = OpenLibrary(libraryName,version);

In machine language: 
move.l ExecBase,a6   	;Pointer to ExecBase 
lea libraryName,a1 	;Pointer to the library's name goes in a1 
moveq #version,d0    	;Version number goes in d0 
jsr OpenLibrary(a6) 	;Open library and return libBase in d0 
move.l d0,libBase    	;Save library base pointer

In Modula-2: 
libBase := OpenLibrary(libraryName,version);

where libBase is the name of the library's base pointer, libraryName is the 
name of the library, and version is the lowest acceptable version of the library 
you require. In most cases, you should use a version number of 0 or 33. The 
following table explains all the possible version numbers you can use: 

Table 1 1. Library Version Numbers 
Version Number 	Kickstart Version
0		Any version
30		Kickstart version 1.0
31		NTSC Kickstart version 1.1
32		PAL Kickstart version 1.1
33		Kickstart 1.2 (the oldest version still supported)
34		Kickstart 1.3

If you specify a version that is higher than what is available on the Amiga 
you run your program, OpenLibrary( ) will fail and return a NULL value. If the 
library is opened successfully, the base address of the library is returned in libBase.
   

Table 1-2 shows the library base pointer names (libBase) and their corre-
sponding library names (libraryName) that you should use when opening a li-
brary. In machine language, you can use practically any name you choose, as 
long as you define an area in memory to store the pointer and label that loca-
tion using the name you select. By convention, it's recommended you use the 
library base pointer name provided in Table 1-2 and precede it with an under-
line character, as in the name _DOSBase. In Lattice C, you must use the names 
given below. If you don't, your program will compile and link correctly, and 
then happily guru when it is run.

Table 1-2. Library Names
Library Name			Library Base Pointer Name
clist.library			ClistBase (unavailable in Kickstart 1.2 and 1.3)
diskfont.library		DiskfontBase
dos.library			DOSBase (normally opened by startup code)
exec.library			ExecBase (ExecBase found at location 4)
expansion.library		ExpansionBase
graphics.library		GfxBase
icon.library			IconBase
intuition.library		IntuitionBase
layers.library			LayersBase
mathffp.library			MathBase
mathieeedoubbas.library		MathleeeDoubBasBase
mathieeedoubtrans.library	MathleeeDoubTransBase
mathtrans.library		MathTransBase
romboot.library			(system private-not accessible to user)
translator.library		TranslatorBase
version.library			(system private-not accessible to user)

When your program is finished, you must be sure to close all of the librar-
ies you opened. To accomplish this you use yet another aptly named Exec 
function, CloseLibrary( ). The only argument that the CloseLibrary( ) function 
requires is the base address of the library you wish to close. This is the same 
base address that was returned by OpenLibrary( ). Here are some examples on
using CloseLibrary( ):

In C and Modula-2 use:
CloseLibrary(libBase);

In machine language:
move.l libBase,a1	;libBase goes in register a1
move.l ExecBase,a6	;Pointer to ExecBase goes in a6
jsr CloseLibrary(a6) 	;Close the library
   

If you neglect to close a library, you run the risk of wasting memory since 
the system will not know if it can throw out an unused, RAM-based library.
-------------------------
Calling Functions 
The end of this chapter contains an alphabetical listing of every user-accessible 
Amiga library function. Each table entry gives the function's name; a brief de-
scription of that function; the library in which the function is contained; its 
negative offset from the library base (useful to the "take charge" machine lan-
guage programmer); the Modula-2 module in which it is contained; its syntax; 
its C, machine language, and Modula-2 usage; a description of its arguments 
(sometimes referred to as parameters); and a description of the value (if any) 
that is returned by the function. For example, here's the entry for Intuition's 
OpenWindow( ) function:

OpenWindow 
Description:     	opens an Intuition window 
Library:        	intuition.library 
Offset:         	-$00CC (-204) 
Modula-2 Module: 	Intuition 
Syntax:        		window = OpenWindow(newWindow) 
C:            		struct Window *OpenWindow(struct NewWindow *) 
Machine Language: 	d0 = OpenWindow(a0) 
Modula-2:       	OpenWindow(VAR newWindow: NewWindow): WindowPtr 
Arguments:     		newWindow = NewWindow structure that describes window to 
			open 
Result:		        window = pointer to Window structure; NULL if unsuccessful

The Syntax section gives you a general idea of what the function expects 
and what it returns. If you look at the C description, you can see that 
OpenWindow( ) expects a pointer to a NewWindow structure and returns a 
pointer to a Window structure. The Machine Language description shows that 
the Window pointer should be placed in a0 and the pointer to the opened Win-
dow is returned in d0 (all functions that return values return them in d0). For 
Modula-2, you can see you must pass the function a NewWindow structure 
and the value it returns is of type WindowPtr. The following C, machine lan-
guage, and Modula-2 programs are examples of how you can use this infor-
mation to open a window. Five library functions are used in these program: 
OpenLibrary( ), OpenWindow( ), Wait( ), CloseWindow( ), and CloseLibrary( ).
-------------------------  
Program 1-2. C Window

C code that opens a window and waits for you to close it

#include <intuition/intuition.h> /* Include Intuition stuff */

struct IntuitionBase *IntuitionBase = NULL; /* Define IntuitionBase */ 
struct Window *MyWindow = NULL; /* Define Window pointer */ 
struct NewWindow MyNewWindow = { /* Set up NewWindow structure */ 
0,12, 
200,100, 
-1 , -1 , 
CLOSEWINDOW, 
WINDOWCLOSE | WINDOWDEPTH | WINDOWDRAG | WINDOWSIZING | ACTIVATE, 
NULL, 
NULL, 
"Close Me", 
NULL, 
NULL, 
80,24, 
-1 , -1 , 
WBENCHSCREEN 
};

void main()

/* Open intuition.library */ 
if ((IntuitionBase=(struct IntuitionBase *) 
OpenLibrary("intuition.library",0))==NULL) 
exit(0);

/* Open window */ 
if ((MyWindow=(struct Window *)OpenWindow(&MyNewWindow))==NULL) ( 
CloseLibrary(IntuitionBase); 
exit(0);

/* Wait for user to click close box */ 
Wait(l<<MyWindow->UserPort->mp SigBit);

CloseWindow(MyWindow); /* Close window */ 
CloseLibrary(IntuitionBase); /* Close intuition.library */
-------------------------
Program 1-3. Machine Language Window

*Open a window and wait for user to close it

*Include Intuition stuff
INCLUDE "intuition/intuition.i"

*Address that holds pointer to ExecBase (this is ALWAYS 4) 
ExecBase equ 4

* Hard-coded function offsets-no need to link with amiga.lib with these! 
OpenLibrary equ -552 
CloseLibrary equ -414 
OpenWindow equ -204 
CloseWindow equ -72
 

Wait equ -318

   SECTION code,CODE

*Open intuition.library
   movea.l #IntuitionName,a1	;Library name in a1
   move.l #0,d0			;Version number in d0
   movea.l ExecBase,a6		;Pointer to ExecBase in a6
   jsr OpenLibrary(a6)		;Call OpenLibrary( )
   move.l d0, IntuitionBase	;Save intuition.library base
   beq.s Abort2			;Exit program if OpenLibrary fails

*Open a window
   movea.l #MyNewWindow,a0	;Pointer to NewWindow in a0
   move.l IntuitionBase,a6	;Pointer to IntuitionBase in a6
   jsr OpenWindow(a6)		;Call OpenWindow( )
   move.l d0,MyWindow		;Save pointer to newly opened window
   beq.s Abort1			;Exit program in OpenWindow fails

*Wait for user to click close box 
movea.l MyWindow,a0          	;Pointer to window's 
movea.l wd_UserPort(a0),a0 	;user port in a0
   move.b MP SIGBIT(a0),d1	;Window's signal bits
   moveq.l #l,d0		;Convert bit number to mask
   lsl.l d1,d0			;and place the result in d0
   movea.l ExecBase,a6		;Pointer to ExecBase in a6
   jsr Wait(a6)			;Call Wait( )

*Close the window
   movea.l MyWindow,a0		;Pointer to window in a0
   move.l IntuitionBase,a6	;Pointer to IntuitionBase in a6
   jsr CloseWindow(a6)		;Call CloseWindow( )

*Close intuition.library
Abort1:
   move.l IntuitionBase,a1	;Pointer to IntuitionBase in a1
   movea.l ExecBase,a6		;Pointer to ExecBase in a6
   jsr CloseLibrary(a6)		;Call CloseLibrary( )

*Exit the program
Abort2:
   clr.l d0	;Set return code
   rts	;Drop out of program

SECTION data,DATA

*NewWindow structure 
MyNewWindow: 
dc.w 0,12 
dc.w 200,100 
dc.b -1,-1 
dc.l CLOSEWINDOW 
dc.l WINDOWCLOSE|WINDOWDEPTH|WINDOWDRAG|WINDOWSIZING|ACTIVATE 
dc.l 0 
dc.l 0 
dc.l WindowTitle 
dc.l 0 
dc.l 0 
dc.w 80,24 
dc.w -1,-1 
dc.w WBENCHSCREEN
  

IntuitionName: 
dc.b 'intuition.library',0 ;Library name
WindowTitle:
   dc.b 'Close Me',0	;Text to appear in window's drag bar

   SECTION mem,BSS

_IntuitionBase:
   ds.l l	;Place to store IntuitionBase
MyWindow
   ds.l l	;Place to store Window pointer

END
-------------------------
Program 1-4. Modula-2 Window

MODULE SharedLibExample;
(* Modula-2 code that opens a window and waits for you to close it *)

FROM Intuition IMPORT NewWindow, WindowFlagSet, WindowFlags, IDCMPFlags, 
IDCMPFlagSet, ScreenFlagSet, WBenchScreen, WindowPtr, OpenWindow, 
CloseWindow;
FROM SYSTEM IMPORT BYTE, ADR, ADDRESS;
FROM Ports IMPORT WaitPort;

VAR 
newWindow: NewWindow; 
myWindowPtr: WindowPtr; 
dummy: ADDRESS;

BEGIN

(* Setup NewWindow structure *)

WITH newWindow DO 
LeftEdge := 0; TopEdge := 12; 
Width := 200; Height := 100; 
DetailPen := BYTE(0); BlockPen := BYTE(l); 
Title := ADR("Close Me"); 
Flags := WindowFlagSet{Activate,WindowClose,WindowDepth, 
WindowDrag,WindowSizing}; 
IDCMPFlags := IDCMPFlagSet{CloseWindowFlag}; 
Type := WBenchScreen; 
FirstGadget := NIL; 
CheckMark := NIL; 
Screen := NIL; 
BitMap := NIL; 
MinWidth := 80; MinHeight := 24; 
MaxWidth := -1; MaxHeight 
END;

(* Try to open window *)

myWindowPtr := OpenWindow(ADR(newWindow));

IF myWindowPtr # NIL THEN 
dummy := WaitPort(myWindowPtr^.UserPort); 
CloseWindow(myWindowPtr); 
END;
END SharedLibExample.
-------------------------  
Machine Language and Function Offsets 
In machine language, library functions are called with a JSR using address indi-
rect with displacement addressing mode, which generates the destination ad-
dress from the contents of register a6. For example, our previous machine 
language window program contains the following instructions:

OpenWindow equ -552

move.l _IntuitionBase,a6 ;Pointer to IntuitionBase in a6 
jsr OpenWindow(a6) ;Call OpenWindow( )

The MOVE instruction puts the base address of the Intuition library in reg-
ister a6. The label OpenWindow contains the offset of OpenWindow( ) function 
from the base address of Intuition. The JSR instruction combines the base ad-
dress with the offset to produce an actual destination address. By putting the 
base address in a6, we also tell OpenWindow( ) where its current library base is.
To tell you the truth, our machine language program is breaking a few 
rules because it hard codes the library offsets in the beginning of the program 
using EQU directives. Purists obtain their function offsets using XREF state-
ments. If we were to program this "by the book," the above lines would read 
xref _LVOOpenLibrary

move.l _IntuitionBase,a6      	;Pointer to IntuitionBase in a6 
jsr _LVOOpenWindow(a6) 		;Call OpenWindow( )

so the OpenWindow( ) offset would be obtained at link time. All of the pro-
gram's library calls could (and some would say, should) be coded this way.
Where does the _LVOOpenLibrary offset come from? Besides containing 
linked library functions, amiga.lib also contains the function offsets for every 
Amiga library. That's why so many machine language programs must be linked 
with amiga.lib. If you use the XREF method, you must precede all function 
names with an _LVO in order for amiga.lib to recognize them. If you hard-
code your offsets as we did in Program 1-3, however, you can call the func-
tions whatever you like-you won't even have to take the time to link with 
amiga.lib (unless, of course, you used one of amiga.lib's linked library 
functions).
------------------------- 
Final Notes 
There are a few macros included in the following function list. Accessing a 
macro is much like accessing a library function. In Modula-2, all supported 
macros are defined as standard procedures and placed into modules. With C 
and machine language, they are actual compiler/assembler macros that must be 
included in your source code. The include file, header file, and Modula-2 mod-
ule that contains the macro definitions are included in the macro's table entry.
A few last minute points should be made regarding the terminology used 
in the following list of functions: By convention, a NULL value is equivalent to 
0. The Modula-2 equivalent of NULL is NIL, which is defined as ADDRESS(0). 
In C, TRUE represents a nonzero value (usually equal to 1) and FALSE equals 
0. In Modula-2, TRUE and FALSE are elements of the type BOOLEAN. If you 
see an _fptr in a C usage description, it specifies a pointer to a function.
The following table is mainly for reference purposes-it's a place you can 
look up information about any Amiga library function, quickly and easily. For 
more details about using a specific function, we suggest you refer to the auto-
docs section of the Commodore-Amiga ROM Kernel Reference Manual.

-------------------------Functions Start Here-------------------------
AbortIO
Description:     	attempts to abort an I/O request already in progress
Library:        	exec.library
Offset:         	-$01E0 (-480)
Modula-2 Module: 	IO
Syntax:        		error = AbortIO(ioRequest)
C:            		long AbortIO(struct IORequest *)
Machine Language: 	d0 = AbortIO(a1)
Modula-2:		AbortIO(ioRequest: ADDRESS): LONGINT
Arguments:		ioRequest = IORequest block containing I/O request to abort
Result:			error = 0 if successful; nonzero error value if unsuccessful
-------------------------
ActivateGadget
Description:		activates a string gadget so the user does not have to click in the
			gadget box to bring up a cursor
Library:		intuition.library
Offset:			-$01CE (-462)
Modula-2 Module: 	Intuition
Syntax:			success = ActivateGadget(gadget, window, requester)
C:            long ActivateGadget(struct Gadget *, struct Window *, struct 
Requester *)
Machine Language: 	d0 = ActivateGadget(a0, a1, a2)
Modula-2:		ActivateGadget(gadget: GadgetPtr; window: WindowPtr; request-
			er: RequesterPtr): BOOLEAN
Arguments:		gadget = string gadget to activate
			window = window containing gadget
			requester = requester to receive gadgets; NULL if gadgets are not
			to be part of a requester
Result:			success = TRUE if successful; FALSE if arguments are bogus
-------------------------
ActivateWindow
Description:		activates a window
Library:		intuition.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Intuition
Syntax:        		ActivateWindow(window)
C:            		long ActivateWindow(struct Window *)
Machine Language: 	ActivateWindow(a0)
Modula-2:		ActivateWindow(window: WindowPtr)
Arguments:		window = window to activate
Result:			none
-------------------------
AddAnimOb
Description:		adds an AnimOb to the linked list of AnimObs
Library:		graphics.library
Modula-2 Module: 	Gels
Offset:         	-$009C (-156)
Syntax:        		AddAnimOb(anOb, anKey, rastPort)
C:            		void AddAnimOb(struct AnimOb *, long, struct RastPort *)
Machine Language: 	AddAnimOb(a0, a1, a2)
Modula-2:		AddAnimOb(anOb: AnimObPtr; anKey: ADDRESS; rastPort:
			RastPortPtr)
Arguments:		anOb = AnimOb structure to be added to list
			anKey = address of pointer to the first AnimOb in the list
			(anKey=NULL if none in list so far)
			rastPort = RastPort structure
Result:			none
-------------------------
AddBob
Description:     	adds a Bob to GEL list
Library:        	graphics.library
Offset:         	-$0060 (-96)
Modula-2 Module: 	Gels
Syntax:        		AddBob(bob, rastPort)
C:           		void AddBob(struct Bob *, struct RastPort *)
Machine Language: 	AddBob(a0, a1)
Modula-2:		AddBob(bob: BobPtr; VAR rastPort: RastPortPtr)
Arguments:		bob = Bob structure to be added to GEL list
			rastPort = RastPort structure
Result:			none
-------------------------
AddConfigDev
Description:		adds a new ConfigDev structure to the system's list of configura-
			tion devices
Library:		expansion.library
Offset:			-$001E (-30)
Modula-2 Module: 	ConfigVars
Syntax:        		AddConfigDev(configDev)
C:            		void AddConfigDev(long)
Machine Language: 	AddConfigDev(a0)
Modula-2:		AddConfigDev(configDev: ConfigDevPtr)
Arguments:		configDef = a valid ConfigDev structure
Result:			none
-------------------------
AddDevice
Description:		adds a device to the system
Library:		exec.library
Offset:			-$01B0 (-432)
Modula-2 Module: 	Devices
Syntax:        		AddDevice(device)
C:            		void AddDevice(struct Device *)
Machine Language: 	AddDevice(a1)
Modula-2:      		AddDevice(device: DevicePtr)
Arguments:     		device = initialized device node
Result:			none
-------------------------
AddDosNode
Description:     	mounts a disk
Library:        	expansion.library
Offset:         	-$0096 (-150)
Modula-2 Module: 	Expansion
Syntax:        		AddDosNode(bootPri, flags, deviceNode)
C:            		void AddDosNode(long, long, struct dosNode *)
Machine Language: 	AddDosNode(d0, d1, a0)
Modula-2:		AddDosNode(bootPri: INTEGER; flags: BITSET; deviceNode:
			DeviceNodePtr): BOOLEAN
Arguments:		bootPri = boot priority of disk-+5 for floppy disk, 0 for hard
			disk,-5 for a network disk,-128 non-bootable device
			flags = ADN_STARTPROC (1) to start handler process
			immediately
			dosNode = initialized device node, as returned by
			MakeDosNode( )
Result:			none
-------------------------
AddFont
Description:		adds a font to the system
Library:		graphics.library
Offset:			-$01E0 (-480)
Modula-2 Module: 	Text
Syntax:        		AddFont(textFont)
C:            		void AddFont(struct TextFont *)
Machine Language: 	AddFont(a1)
Modula-2:		AddFont(textFont: TextFontPtr)
Arguments:		textFont = TextFont structure (in public RAM) to add
Result:			none
-------------------------
AddFreeList
Description:		adds memory to the free list
Library:		icon.library
Offset:			-$0048 (72)
Modula-2 Module: 	Icon
Syntax:        		status = AddFreeList(free, mem, len)
C:            		long AddFreeList(struct FreeList *, char *, long)
Machine Language: 	d0 = AddFreeList(a0, a1, a2)
Modula-2:       	AddFreeList(free: FreeListPtr; mem: ADDRESS; len:
			LONGCARD): BOOLEAN
Arguments:		free = FreeList structure
			mem = memory to record
			len = length of the memory to record
Result:			status = nonzero value if the call succeeded
-------------------------
AddGadget
Description:		adds gadget to window
Library:		intuition.library
Offset:			-$002A (-42)
Modula-2 Module: 	Intuition
Syntax:        		position = AddGadget(window, gadget, position)
C:            		long AddGadget(struct Window *, struct Gadget *, long)
Machine Language: 	d0 = AddGadget(a0, a1, d0)
Modula-2:		AddGadget(window: WindowPtr; gadget: GadgetPtr; position:
			INTEGER): INTEGER
Arguments:		window = window to contain gadget
			gadget = gadget to add
			position = position in gadget list for new gadget; -1 for end of
			list
Result:			position = position where gadget is actually added
-------------------------
AddGList
Description:		adds or inserts a gadget list to an existing gadget list
Library:		intuition.library
Offset:			-$01B6 (-438)
Modula-2 Module: 	Intuition
Syntax: 	    	position = AddGList(window, gadget, position, numGadgets, 
			requester)
C:		        long AddGList(struct Window *, Gadget *, long, long, struct
			Requester *)
Machine Language: 	d0 = AddGList(a0, a1, d0, d1, a2)
Modula-2:		AddGList(window: WindowPtr; gadget: GadgetPtr; position:
			INTEGER; numGadgets: INTEGER; requester: RequesterPtr):
			CARDINAL

Arguments:		window = window to receive gadgets
			gadget = first gadget in new gadget list
			position = position in existing gadget list where new gadget list
			should be added
			numGadgets = number of gadgets to add
			requester = requester to receive gadgets; NULL if gadgets are not
			to be part of a requester
Result:			position = position where gadget list is actually added
-------------------------  
AddHead
Description:   		inserts a node at the head of a list
Library:        	exec.library
Offset:         	-$00F0 (-240)
Modula-2 Module: 	Lists
Syntax:        		AddHead(list, node)
C:            		void AddHead(struct List *, struct Node *)
Machine Language:	AddHead(a0, a1)
Modula-2:		AddHead(list: ListPtr; VAR node: NodePtr)
Arguments:		list = list header
			node = node to insert
Result:			none
-------------------------
AddIntServer
Description:		adds an interrupt server to the system
Library:		exec.library
Offset:			-$00A8 (-168)
Modula-2 Module: 	Interrupts
Syntax:        		AddlntServer(intNum, interrupt)
C:            		void AddIntServer(long, struct Interrupt *)
Machine Language: 	AddIntServer(d0, a1)
Modula-2:		AddIntServer(intNum: CARDINAL; interrupt: InterruptPtr)
Arguments:		intNum = portia interrupt bit (0-4)
			interrupt = interrupt server node
Result:			none
------------------------
AddLibrary
Description:		adds a library to the system
Library:		exec.library
Offset:			-$018C (-396)
Modula-2 Module: 	Libraries
Syntax:       		AddLibrary(library)
C:            		void AddLibrary(struct Library *)
Machine Language: 	AddLibrary(a1)
Modula-2:       	AddLibrary(library:LibraryPtr)
Arguments:      	library = initialized Library structure
Result:			none
-------------------------
AddMemList
Description:		adds memory to the system's pool of free memory
Library:        	exec.library
Offset:         	-$026A (-618)
Modula-2 Module: 	Memory
Syntax:        		AddMemList(size, attributes, pri, base, name)
C:            		void AddMemList(long, long, long, char *, char *)
Machine Language: 	AddMemList(d0, d1, d2, a0, a1)
Modula-2:		AddMemList(size: LONGCARD; attributes: MemReqSet; pri:
			INTEGER; base: ADDRESS; name: STRPTR)
Arguments:		size = size of memory block in bytes
			attributes = type of memory-MEMF_PUBLIC, MEMF_CHIP,
			MEMF_FAST, MEMB_CLEAR
			pri = priority of memory-CHIP memory has a priority of -10;
			16-bit expansion memory has a priority of 0
			base = address of the first location in the memory block
			name = name to be used in memory header; NULL for no name
Result:			none
-------------------------
AddPort
Description:		adds a message port to the system
Library:		exec.library
Offset:			-$0162 (-354)
Modula-2 Module: 	Ports
Syntax:        		AddPort(port)
C:            		void AddPort(struct MsgPort *)
Machine Language: 	AddPort(a1)
Modula-2:		AddPort(port: MsgPortPtr)
Arguments:		port = message port to add
Result:			none
-------------------------
AddResouree
Description:		adds a resource to the system
Library:		exec.library
Offset:			-$01E6 (-486)
Modula-2 Module: 	Resources
Syntax:        		AddResource(resource)
C:            		void AddResource(struct Resource *)
Machine Language: 	AddResource(a1)
Modula-2:		AddResource(resource: ResourcePtr)
Arguments:		resource = resource node
Result:			none
-------------------------
AddSemaphore
Description:		attaches a signal semaphore to the system
Library:		exec.library
Offset:			-$0258 (-600)
Modula-2 Module: 	Semaphores
Syntax:        		AddSemaphore(signalSemaphore)
C:            		void AddSemaphore(struct SignalSemaphore *)
Machine Language: 	AddSemaphore(a1)
Modula-2:		AddSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
AddTail
Description:		appends a node to the tail of a list
Library:		exec.library
Offset:			-$00F6 (-246)
Modula-2 Module: 	Lists
Syntax:        		AddTail(list, node)
C:            		void AddTail(struct List *, struct Node *)
Machine Language: 	AddTail(a0, a1)
Modula-2:		AddTail(list: ListPtr; node: NodePtr)
Arguments:		list = list header
			node = node to insert
Result:			none
-------------------------
AddTask
Description:		adds a task to the system
Library:		exec.library
Offset:			-$011A (-282)
Modula-2 Module: 	Tasks
Syntax:        		AddTask(task, initialPC, finalPC)
C:            		void AddTask(struct Task *, char *, char *)
Machine Language: 	AddTask(a1, a2, a3)
Modula-2:		AddTask(task: TaskPtr; initialPC, finalPC:ADDRESS)
Arguments:		task = task control block
			initialPC = initial entry point
			finalPC = address of entry point of finalization code
Result:			none
-------------------------
AddTOF
Description:		adds a task to the TopOfFrame (vertical-blanking interval) inter-
			rupt server chain
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:       		AddTOF(i, p, a)
C:            		void AddTOF(struct Isrvstr *, APTR, APTR)
Machine Language: 	pea a
			pea p
			pea i
			jsr _AddTOF
			add.l #12,sp
Modula-2:		not available
Arguments:		i = Isrvstr structure
			p = entry point of routine to call at every vertical blank
			a = array of long words that will receive routine's arguments
Result:			none
-------------------------
AddVSprite
Description:		adds VSprite to GEL list
Library:		graphics.library
Offset:			-$0066 (-102)
Modula-2 Module: 	Gels
Syntax:       		AddVSprite(vSprite, rastPort)
C:            		void AddVSprite(struct VSprite *, struct RastPort *)
Machine Language: 	AddVSprite(a0, a1)
Modula-2:      		AddVSprite(vSprite: VSpritePtr; rastPort: RastPortPtr)
Arguments:     		vSprite = initialized VSprite structure
			rastPort = RastPort structure
Result:			none
-------------------------   
afp
Description:     	converts an ASCII string into a fast floating point number
Library:        	amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		fnum = afp(string)
C:           		float afp(char *)
Machine Language: 	pea string
			jsr _afp ;fnum returned in d0/d1
			addq.l #4,sp
Modula-2:		not available; use ConvStrToReal in RealConversions module
Arguments:		string = string to convert
Result:			fnum = floating point equivalent of string arguments
-------------------------
Alert
Description:		alerts the user of a serious error
Library:		exec.library
Offset:			-$006C (-108)
Modula-2 Module: 	Alerts
Syntax:        		Alert(alertNum, flags)
C:            		void Alert(long, char *)
Machine Language: 	Alert(d7, a5)
Modula-2:		Alert(alertNum: LONGCARD; flags: LONGCARD)
Arguments:		alertNum = alert number
			flags = second part of Guru Meditation number (usually the ad-
			dress of the offending task)
Result:			none
-------------------------
AllocAbs
Description:		allocates a block of memory from a specified location
Library:		exec.library
Offset:			-$00CC (-204)
Modula-2 Module:	 Memory
Syntax:        		memoryBlock = AllocAbs(byteSize, location)
C:            		void *AllocAbs(long, void *)
Machine Language: 	d0 = AllocAbs(d0, a1)
Modula-2:     		AllocAbs(byteSize: LONGCARD; location: ADDRESS): ADDRESS
Arguments:     		byteSize = size of desired block in bytes
			location = address where the memory must be
Result:			memoryBlock = pointer to allocated block; NULL if unsuccessful
------------------------- 
Allocate
Description:		allocates a block of memory
Library:        	exec.library
Offset:         	-$00BA (-186)
Modula-2 Module: 	Memory
Syntax:        		memoryBlock = Allocate(freeList, byteSize)
C:            		void *Allocate(struct MemHeader *, long)
Machine Language: 	d0 = Allocate(a0, d0)
Modula-2:		Allocate(freeList: MemHeaderPtr; byteSize: LONGCARD):
			ADDRESS
Arguments:		freeList = memory list header
			byteSize = size of desired block in bytes
Result:			memoryBlock = pointer to allocated block; NULL if unsuccessful.
-------------------------
AllocBoardMem
Description:		allocates expansion board memory
Library:		expansion.library
Offset:			-$002A (-42)
Modula-2 Module: 	Expansion
Syntax:        		startSlot = AllocBoardMem(slotSpec)
C:           		long AllocBoardMem(long)
Machine Language: 	d0 = AllocBoardMem(d0)
Modula-2:		AllocBoardMem(slotSpec: INTEGER): INTEGER
Arguments:		slotSpec = number of slots to allocate
Result:			startSlot = slot allocated; -1 if unsuccessful
------------------------
AllocCList
Description:		allocates and initializes a clist
Library:		clist.library
Offset:			$0024 (-36)
Modula-2 Module: 	none
Syntax:        		cList = AllocCList(cLPool)
C:            		long AllocCList(long)
Machine Language: 	d0 = AllocCList(a1)
Modula-2:      		not available
Arguments:     		cLPool = initialized CListPool
Result:			cList = longword cList descriptor; negative if unsuccessful.
------------------------- 
AllocConfigDev
Description:  		allocates a ConfigDev structure
Library:        	expansion.library
Offset:         	-$0030 (-48)
Modula-2 Module: 	ConfigVars
Syntax:        		configDev = AllocConfigDev( )
C:            		struct ConfigDev *AllocConfigDev(void)
Machine Language: 	d0 = AllocConfigDev( )
Modula-2:		AllocConfigDev( ): ConfigDevPtr
Arguments:		none
Result:			configDef = a valid ConfigDev structure; NULL if unsuccessful
-------------------------
AllocEntry
Description:		allocates many regions of memory
Library:		exec.library
Offset:			-$00DE (-222)
Modula-2 Module: 	Memory
Syntax:        		memlist = AllocEntry(memlist)
C:            		struct MemList *AllocEntry(stuct MemList *)
Machine Language: 	d0 = AllocEntry(a0)
Modula-2:       	AllocEntry(memList: MemListPtr): MemListPtr
Arguments:      	memList = initialized cList pool
Result:         	memList = different memList filled with allocated memory
------------------------
AllocExpansionMem
Description:     	allocates expansion memory
Library:        	expansion.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Expansion
Syntax:        		startSlot = AllocExpansionMem(numSlots, slotOffset)
C:            		CPTR AllocExpansionMem(long, long)
Machine Language: 	d0 = AllocExpansionMem(d0, d1)
Modula-2:      		AllocExpansionMem(numSlots, slot Offset: INTEGER): INTEGER
Arguments:     		numSlots = number slots to allocate
			slotOffset = boundary offset
Result:			startSlot = slot allocated; -1 if unsuccessful
------------------------- 
AllocMem
Description:		allocates many regions of memory
Library:        	exec.library
Offset:         	-$00C6 (-198)
Modula-2 Module: 	Memory
Syntax:        		memoryBlock = AllocMem(byteSize, requirements)
C:            		void *AllocMem(long, long)
Machine Language: 	d0 = AllocMem(d0, d1)
Modula-2:		AllocMem(byteSize: LONGCARD; requirements: MemReqSet):
			ADDRESS
Arguments:		byteSize = size of desired block in bytes
			requirements = type of memory-MEMF_PUBLIC,
			MEMF_CHIP, MEMF_FAST, MEMB_CLEAR
Result:			memoryBlock = pointer to allocated block
-------------------------
AllocRaster
Description:		allocates space for a bit plane
Library:		graphics.library
Offset:			-$01EC (-492)
Modula-2 Module: 	Rasters
Syntax:        		raster = AllocRaster(width, height)
C:            		PLANEPTR AllocRaster(long, long)
Machine Language: 	d0 = AllocRaster(d0, d1)
Modula-2:		AllocRaster(width, height: CARDINAL): PlanePtr
Arguments:		width = width of bitplane in pixels
			height = height of bitplane in pixels
Result:			raster = pointer to allocated memory; NULL if unsuccessful
-------------------------
AllocRemember
Description:		calls AllocMem and creates a link node
Library:		intuition.library
Offset:			-$018C (-396)
Modula-2 Module: 	Intuition
Syntax:        		memoryBlock = AllocRemember(rememberKey, size, flags)
C:            		char *AllocRemember(struct Remember *, long, long)
Machine Language: 	d0 = AllocRemember(a0, d0, d1)
Modula-2:      		AllocRemember(VAR rememberKey: RememberPrt; size:
			LONGCARD; flags: MemReqSet): ADDRESS
Arguments:		rememberKey = address of pointer to Remember structure
			size = size of desired block in bytes
 			flags = type of memory-MEMF_PUBLIC, MEMF_CHIP, 
			MEMF_FAST, MEMB_CLEAR
Result:			memoryBlock = pointer to allocated block
-------------------------
AllocSignal
Description:		allocates a signal bit
Library:		exec.library
Offset:			-$014A (-330)
Modula-2 Module: 	Tasks
Syntax:        		signalNum = AllocSignal(signalNum)
C:            		long AllocSignal(long)
Machine Language: 	d0 = AllocSignal(d0)
Modula-2:		AllocSignal(signalNum: SIGNAL): SIGNAL
Arguments:		signalNum = desired signal number (0-31); -1 for no preference
Result:			signalNum = signal number allocated; -1 if no signal is
			available
-------------------------
AllocTrap
Description:		allocates a processor trap vector
Library:		exec.library
Offset:			-$0156 (-342)
Modula-2 Module: 	Tasks
Syntax:        		trapNum = AllocTrap(trapNum)
C:            		long AllocTrap(long)
Machine Language: 	d0 = AllocTrap(d0)
Modula-2:		AllocTrap(trapNum: TRAP): TRAP
Arguments:		trapNum = desired trap number (0-15); -1 for no preference
Result:			trapNum = trap number allocated; -1 if no trap is available
-------------------------
AllocWBObject
Description:		allocates a Workbench object
Library:		icon.library
Offset:			-$0042 (-66)
Modula-2 Module: 	none
Syntax:        		object = AllocWBObject( )
C:            		struct WBObject AllocWBObject(void)
Machine Language: 	d0 = AllocWBObject( )
Modula-2:       	not available
Arguments:      	none
Result:			object = the WBObject; NULL if unsuccessful
-------------------------
AndRectRegion
Description:		performs a two-dimensional AND operation of a rectangle with a
			region, leaving the result in the region
Library:		graphics.library
Offset:			-$01F8 (-504)
Modula-2 Module: 	Regions
Syntax:        		AndRectRegion(region, rectangle)
C:            		void AndRectRegion(struct Region *, struct Rectangle *)
Machine Language: 	AndRectRegion(a0, a1)
Modula-2:		AndRectRegion(region: RegionPtr; rectangle: RectanglePtr)
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			none
-------------------------
AndRegionRegion
Description:		performs a two-dimensional AND operation of one region with a
			second region, leaving the result in second region
Library:		graphics.library
Offset:			-$0270 (-624)
Modula-2 Module: 	Regions
Syntax:        		success = AndRegionRegion(region1, region2)
C:            		long AndRegionRegion(struct Region *, struct Region *)
Machine Language: 	d0 = AndRegionRegion(a0, a1)
Modula-2:		AndRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:	success = 	TRUE if successful; FALSE if unsuccessful
-------------------------
Animate
Description:		processes every AnimOb in the current animation list
Library:		graphics.library
Offset:			-$00A2 (-162)
Modula-2 Module: 	Gels
Syntax:        		Animate(anKey, rastPort)
C:            		void Animate(long, struct RastPort *)
Machine Language: 	Animate(a0, a1)
Modula-2:       	Animate(ankey: ADDRESS; rastPort: RastPortPtr)
Arguments:     		anKey = address of variable that points to the head AnimOb
			rastPort = RastPort structure
Result:			none
-------------------------
AreaCircle (macro)
Description:     	adds a circle to the list of points used to fill an area
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Areas
Syntax:        		error = AreaCircle(rastPort, cx, cy, radius)
C:            		long AreaCircle(struct RastPort *, long, long, long)
Machine Language: 	not available, use AreaEllipse
Modula-2:		AreaCircle(rp: RastPortPtr; cx, cy, radius: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of circle's center
			cy = vertical coordinate of circle's center
			radius = circle's radius
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaDraw
Description:		adds a point to the list of points used to fill an area
Library:		graphics.library
Offset:			-$0102 (-258)
Modula-2 Module: 	Areas
Syntax:        		error = AreaDraw(rastPort, x, y)
C:            		long AreaDraw(struct RastPort *, long, long)
Machine Language: 	d0 = AreaDraw(a1, d0, d1)
Modula-2:		AreaDraw(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaEllipse
Description:		adds an ellipse to the list of points used to fill an area
Library:		graphics.library
Offset:			-$00BA (-186)
Modula-2 Module: 	Areas
Syntax:        		error = AreaEllipse(rastPort, cx, cy, a, b)
C:            		long AreaEllipse(struct RastPort *, long, long, long, long)
Machine Language: 	d0 = AreaEllipse(a1, d0, d1, d2, d3)
Modula-2:       	AreaEllipse(rastPort: RastPortPtr; cx, cy, a, b: INTEGER):
			INTEGER
-------------------------
AttemptLockLayerRom
Description:		attempts to lock a Layer structure
Library:        	graphics.library
Offset:         	-$028E (-582)
Modula-2 Module: 	Clip
Syntax:        		success = AttemptLockLayerRom(layer)
C:            		long AttemptLockLayerRom(struct Layer *)
Machine Language: 	d0 = AttemptLockLayerRom(a5)
Modula-2:		AttemptLockLayerRom(layer: LayerPtr): BOOLEAN
Arguments:		layer = Layer structure to lock
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
AttemptSemaphore
Description:		attempts to obtain access to a SignalSemaphore structure
Library:		exec.library
Offset:			-$0240 (-576)
Modula-2 Module: 	Semaphores
Syntax:        		success = AttemptSemaphore(signalSemaphore)
C:            		long AttemptSemaphore(struct SignalSemaphore *)
Machine Language: 	d0 = AttemptSemaphore(a0)
Modula-2:		AttemptSemaphore(signalSemaphore: SignalSemaphorePtr):
			BOOLEAN
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			success = TRUE if successful; FALSE if another task is using
			specified SignalSemaphore structure
-------------------------
AutoRequest
Description:		automatically creates and gets a response from a requester
Library:		intuition.library
Offset:			-$015C (-348)
Modula-2 Module: 	Intuition
Syntax:        		response = AutoRequest(window, bodyText, positiveText,
			negativeText, positiveFlags, negativeFlags, width, height)
C:            		long AutoRequest(struct Window *, struct IntuiText *, struct
			IntuiText *, struct IntuiText *, long, long, long)
Machine Language: 	d0 = AutoRequest(a0, a1, a2, a3, d0, d1, d2, d3)
Modula-2:      		AutoRequest(window: WindowPtr; bodyText, positiveText,
			negativeText: IntuiTextPtr; positiveFlags, negativeFlags:
			IDCMPFlagsSet; width, height: INTEGER): BOOLEAN
Arguments:		window = Window structure
			bodyText = IntuiText structure
			positiveText = IntuiText structure
			negativeText = IntuiText structure
			positiveFlags = flags for the IDCMP
			negativeFlags = flags for the IDCMP
			width = width of requester
			height = height of requester
Result:			response = TRUE for a positive response; FALSE for a negative
			response
-------------------------
AvailFonts
Description:		builds an array of all available fonts on disk and/or in memory
Library:		diskfont.library
Offset:			-$0024 (-36)
Modula-2 Module: 	DiskFont
Syntax:        		error = AvailFonts(buffer, bufBytes, types)
C:            		long AvailFonts(char *, long, long)
Machine Language: 	d0 = AvailFonts(a0, d0, d1)
Modula-2:		AvailFonts(buffer: ADDRESS; bufBytes: LONGCARD; types:
			AFTypeSet): LONGCARD
Arguments:		buffer = memory buffer used to hold the array
			bufBytes = size of buffer in bytes
			types = type of fonts to search for-AFF_MEMORY and/or
			AFF_DISK
Result:			error = 0 if successful, otherwise, error contains the number of
			additional bytes that must be added to the buffer size (bufBytes)
			to contain all of the font information
-------------------------
AvailMem
Description:		returns memory available given certain requirements
Library:		exec.library
Offset:			-$00D8 (-216)
Modula-2 Module: 	Memory
Syntax:        		size = AvailMem(requirements)
C:            		long AvailMem(long)
Machine Language: 	d0 = AvailMem(d1)
Modula-2:      		AvailMem(requirements: MemReqSet): LONGCARD
Arguments:     		requirements = type of memory required-MEMF_PUBLIC,
			MEMF_CHIP, MEMF_FAST, MEMB_CLEAR
Result:			size = total free space remaining
------------------------- MISSING IN ORIGINAL TEXT!!!! -------------------------
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of ellipse's center
			cy = vertical coordinate of ellipse's center
			a = horizontal radius of ellipse (must be greater than O)
			b = vertical radius of ellipse (must be greater than O)
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
AreaEnd
Description:		fills an area using a list of vertices
Library:		graphics.library
Offset:			-$0108 (-264)
Modula-2 Module: 	Areas
Syntax:        		error = AreaEnd(rastPort)
C:            		long AreaEnd(struct RastPort *)
Machine Language: 	d0 = AreaEnd(a1)
Modula-2:		AreaEnd(rastPort: RastPortPtr): INTEGER
Arguments:		rastPort = RastPort structure
Result:			error = 0 if successful; -1 if unsuccessful
-------------------------
AreaMove
Description:		closes the current polygon described by a table of vertices and de-
			fines the starting point for a new polygon
Library:		graphics.library
Offset:			-$00FC (-252)
Modula-2 Module: 	Areas
Syntax:        		error = AreaMove(rastPort, x, y)
C:            		long AreaMove(struct RastPort *, long, long)
Machine Language: 	d0 = AreaMove(a1, d0, d1)
Modula-2:		AreaMove(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			error = 0 if successful; -1 if no room left in list of points
-------------------------
arnd
Description:		rounds a floating point number contained in an ASCII string
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		arnd(place, exp, string)
C:			void arnd(long, long, char *)
Machine Language: 	pea string 
			move.l #exp,-(sp) 
			move.l #place,-(sp) 
			jsr _arnd 		;string contents are modified 
			add.l #12,sp
Modula-2:		not available
Arguments:		place = number of desired decimal places
			exp = exponent value of number in string argument
			string = string containing number to round
Result:			string argument is modified to contain rounded number
-------------------------
AskFont
Description:		puts text attributes of the current font in the specified TextAttr
			structure
Library:		graphics.library
Offset:			-$01DA (-474)
Modula-2 Module: 	Text
Syntax:        		AskFont(rastPort, textAttr)
C:            		void AskFont(struct RastPort *, struct TextAttr *)
Machine Language: 	AskFont(a1, a0)
Modula-2:		AskFont(rastPort: RastPortPtr; textAttr: TextAttrPtr)
Arguments:		rastPort = RastPort structure
			textAttr = TextAttr structure to be filled
Result:			returns results in textAttr argument
-------------------------
AskSoftStyle
Description:		returns the soft style bits of the current font
Library:		graphics.library
Offset:			-$0054 (-84)
Modula-2 Module: 	Text
Syntax:        		enable = AskSoftStyle(rastPort)
C:            		long AskSoftStyle(struct RastPort *)
Machine Language: 	d0 = AskSoftStyle(a1)
Modula-2:      		AskSoftStyle(rastPort: RastPortPtr): FontStyleSet
Arguments:     		rastPort = RastPort structure
Result:			enable = valid style bits
-------------------------
BeginIO 
Description: 		initiates an IO request like SendIO( ), but does not clear io_Flags 
			field 
Library:	        amiga.lib (linked library) 
Modula-2 Module: 	IO 
Syntax:        		BeginIO(ioRequest) 
C:            		void BeginIO(struct IORequest *) 
Machine Language: 	pea ioRequest
			jsr _BeginIO
			addq.l #4,sp
Modula-2:		BeginIO(ioRequest: ADDRESS)
Arguments:		IORequest = initialized IORequest structure
Result:			none
-------------------------
BeginRefresh
Description:		sets up a window for optimized refreshing
Library:		intuition.library
Offset:			-$0162 (-354)
Modula-2 Module: 	Intuition
Syntax:        		BeginRefresh(window)
C:            		void BeginRefresh(struct Window *)
Machine Language: 	BeginRefresh(a0)
Modula-2:		BeginRefresh(window: WindowPtr)
Arguments:		window = window that needs updating
Result:			none
-------------------------
BeginUpdate
Description:		prepares to repair a damaged layer
Library:		layers.library
Offset:			-$004E (-78)
Modula-2 Module: 	Layers
Syntax:        		success = BeginUpdate(layer)
C:            		long BeginUpdate(struct Layer *)
Machine Language: 	d0 = BeginUpdate(a0)
Modula-2:      		BeginUpdate(layer: LayerPtr): BOOLEAN
Arguments:     		layer = Layer to be repaired
Result:			TRUE if successful; FALSE if unsuccessful
------------------------- 
BehindLayer
Description:     	moves a layer behind other layers
Library:        	layers.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Layers
Syntax:       		success = BehindLayer(dummy, layer)
C:            		long BehindLayer(struct Layer_Info, struct Layer *)
Machine Language: 	d0 = BehindLayer(a0, a1)
Modula-2:		BehindLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = Layer to move behind other layers
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
BltBitMap
Description:		uses the blitter chip to move (blit) a rectangular region of bits from
			a BitMap to a BitMap
Library:		graphics.library
Offset:			-$001E (-30)
Modula-2 Module: 	Blitter
Syntax:   		planes = BltBitMap(scrBitMap, srcX, srcY, destBitMap, destX, 
			destY, sizeX, sizeY, miniterm, mask, tempA)

C:		        long BltBitMap(struct BitMap *, long, long, struct BitMap *, long, 
			long, long, long, long, long, char *)
Machine Language: 	d0 = BltBitMap(a0, d0, d1, a1, d2, d3, d4, d5, d6, d7, a2)
Modula-2:		BltBitMap(scrBitMap: BitMapPtr; srcX, srcY: INTEGER;
			destBitMap: BitMapPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER; miniterm: BYTE; mask: BITSET; tempA: ADDRESS):
			LONGCARD
Arguments:		scrBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destBitMap = destination BitMap structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
			mask = bit planes to be affected
			tempA = pointer to chip memory for one source line or NULL
Result:			planes = actual number of planes involved in blit
-------------------------
BltBltMapRastPort
Description:		moves a rectangular region from a BitMap to a RastPort
Library: 		graphics.library
Offset: 	        -$025E (-606)
Modula-2 Module:	Blitter
Syntax:        		BltBitMapRastPort(srcBitMap, srcX, srcY, destRastPort, destX, 
			destY, sizeX, sizeY, miniterm)
C:		        void BltBitMapRastPort(struct BitMap *, long, long, struct RastPort
			*, long, long, long, long, long)
Machine Language: 	BltBitMapRastPort(a0, d0, d1, a1, d2, d3, d4, d5, d6)
Modula-2:		BltBitMapRastPort(srcBitMap: BitMapPtr; srcX, srcY: INTEGER;
			destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER; miniterm: BYTE)
Arguments:		srcBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
Result:			none
-------------------------
BltClear
Description:		fills a section of chip memory with zeros
Library:		graphics.library
Offset:			-$012C (-300)
Modula-2 Module: 	Blitter
Syntax:        		BltClear(memBlock, byteCount, flags)
C:            		void BltClear(char *, long, long)
Machine Language: 	BltClear(a1, d0, d1)
Modula-2:      		BltClear(memBlock: ADDRESS; byteCount: LONGCARD; flags:
			BltClearFlagSet)

Arguments:		memBlock = memory to clear (must start on a word boundary)
			byteCount = number of bytes to clear
			flags = set bit 0 to force function to wait until memory is cleared;
			set bit 1 if byteCount is to be interpreted as the number of rows
			and bytes per row to clear; clear bit 1 if byteCount is to be inter-
			preted as an even number of bytes
Result:			none
-------------------------
BltMaskBitMapRastPort
Description: 		moves a rectangular region from a BitMap to a RastPort through a 
			mask
Library:	        graphics.library
Offset:         	-$027C (-636)
Modula-2 Module: 	Blitter
Syntax:        		BltMaskBitMapRastPort(srcBitMap, srcX, srcY, destRastPort, destX, 
			destY, sizeX, sizeY, miniterm, mask)
C:		        void BltMaskBitMapRastPort(struct BitMap *, long, long, struct 
			RastPort *, long, long, long, long, long, APTR)
Machine Language: 	BltMaskBitMapRastPort(a0, d0, d1, a1, d2, d3, d4, d5, d6, a2)
Modula-2:		BltMaskBitMapRastPort(srcBitMap: BitMapPtr; srcX, srcY: INTE-
			GER; destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX,
			sizeY: INTEGER; miniterm: BYTE; mask: PlanePtr)
Arguments:		srcBitMap = source BitMap structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
			mask = pointer to bit-plane mask
Result:			none
-------------------------
BltPattern
Description:		draws through a mask using standard drawing rules
Library:		graphics.library
Offset:			-$0138 (-312)
Modula-2 Module: 	Blitter
Syntax:			BltPattern(destRastPort, pattern, x1, y1, x2, y2, width)
C:		        void BltPattern(struct RastPort *, struct RastPort *, long, long, 
			long, long, long)
Machine Language: 	BltPattern(a1, a0, d0, d1, d2, d3, d4)
Modula-2:		BltPattern(destRastPort: RastPortPtr; pattern: ADDRESS; x1, y1:
			INTEGER; x2, y2: INTEGER; width: INTEGER)
Arguments:		destRastPort = destination RastPort
			pattern = two-dimensional mask pattern
			x1 = horizontal coordinate of upper left corner in destination
			RastPort
			y1 = vertical coordinate of upper left corner in destination
			RastPort
			x2 = horizontal coordinate of lower right corner in destination
			RastPort
			y2 = vertical coordinate of lower right corner in destination
			RastPort
			width = width of mask in bytes
Result:			none
-------------------------
BltTemplate
Description:		"cookie cuts" a shape in a rectangle to a RastPort
Library:		graphics.library
Offset:			-$0024 (-36)
Modula-2 Module: 	Blitter
Syntax:		        BltTemplate(source, srcX, srcMod, destRastPort, destX, destY, 
			sizeX, sizeY)
C:		        void BltTemplate(char *, long, long, struct RastPort *, long, long, 
			long, long)
Machine Language: 	BltTemplate(a0, d0, d1, a1, d2, d3, d4, d5)
Modula-2:		BltTemplate(source: PlanePTR; srcX, srcMod: INTEGER;
			destRastPort: RastPortPtr; destX, destY: INTEGER; sizeX, sizeY:
			INTEGER) (changes)
Arguments:		source = template mask
			srcX = horizontal offset into template mask (0-15)
			srcMod = number of bytes per row in template mask
			destRastPort = destination RastPort
			destX = horizontal coordinate of upper left corner in destination
			RastPort
			destY = vertical coordinate of upper left corner in destination
			RastPort
			sizeX = width of rectangular template
			sizeY = height of rectangular template
Result:			none
-------------------------
BNDRYOFF (macro)
Description:    	turns boundary mode off
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Pens
Syntax:        		BNDRYOFF(rastPort)
C:            		void BNDRYOFF(struct RastPort *)
Machine Language: 	not available
Modula-2:		BNDRYOFF(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure
Result:			none
-------------------------
BuildSysRequest
Description:		builds and displays a system requester
Library:		intuition.library
Offset:			-$0168 (-360)
Modula-2 Module: 	Intuition
Syntax:		        window = BuildSysRequest(window, bodyText, positiveText, 
			negativeText, flags, width, height)
C:		        struct Window *BuildSysRequest(struct Window *, struct IntuiText 
			*, struct IntuiText *, struct IntuiText *, long, long, long)
Machine Language: 	d0 = BuildSysRequest(a0, a1, a2, a3, d0, d1, d2)
Modula-2:		BuildSysRequest(window: WindowPtr; bodyText, positiveText,
			negativeText: IntuiTextPtr; flags: IDCMPFlagsSet; width, height:
			INTEGER): ADDRESS
Arguments:		window = Window to contain requester
			bodyText = IntuiText structure containing requester's main text
			positiveText = IntuiText structure containing text for positive
			gadget
			negativeText = IntuiText structure containing text for negative
			gadget
			flags = IDCMP flags for initialization of window containing
			requester
			width = requester width
			height = requester height
Result:			window = pointer to window containing requester; if requester
			could not be opened, DisplayAlert( ) is called and this function re-
			turns TRUE if the left mouse button is pressed and FALSE if the
			right mouse button is pressed
------------------------- 
BumpRevision
Description:  		creates a new name for the copy of a file, directory, or disk
Library:       		icon.library
Offset:         	-$006C (-108)
Modula-2 Module: 	Icon
Syntax:        		newname = BumpRevision(newbuf, oldname)
C:            		long BumpRevision(char *, char *)
Machine Language: 	d0 = BumpRevision(a0, a1)
Modula-2:		BumpRevision(newbuf, oldname: STRPTR)
Arguments:		newbuf = buffer to contain the new name (must be at least 31
			characters long)
			oldname = old name
Result:			newname = pointer to the new name contained in newbuf
-------------------------
Cause
Description:		causes a software interrupt
Library:		exec.library
Offset:			-$00B4 (-180)
Modula-2 Module: 	Interrupts
Syntax:        		Cause(interrupt)
C:            		void Cause(struct Interrupt *)
Machine Language: 	Cause(a1)
Modula-2:		Cause(interrupt: InterruptPtr)
Arguments:		interrupt = initialized interrupt node
Result:			none
-------------------------
CBump
Description:		moves to the next position in user copper list
Library:		exec.library
Offset:			-$016E (-366)
Modula-2 Module: 	Copper
Syntax:        		CBump(copList)
C:            		void CBump(struct UCopList *)
Machine Language: 	CBump(a1)
Modula-2:      		CBump(copList: UCopListPtr)
Arguments:     		copList = UCopList structure
Result:			none
-------------------------
CEND (macro)
Description:    	adds the final instruction to a user copper list
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Copper
Syntax:        		CEND(copList)
C:            		void CEND(struct UCopList *)
Machine Language: 	not available
Modula-2:		CEND(VAR copList: UCopList)
Arguments:		copList = UCopList structure
Result:			none
------------------------
ChangeSprite
Description:		changes the shape of a sprite
Library:		graphics.library
Offset:			-$01A4 (-420)
Modula-2 Module: 	Sprites
Syntax:        		ChangeSprite(viewPort, simpleSprite, newdata)
C:            		void ChangeSprite(struct ViewPort *, struct SimpleSprite *, short *)
Machine Language: 	ChangeSprite(a0, a1, a2)
Modula-2:		ChangeSprite(viewPort: ViewPortPtr; simpleSprite:
			SimpleSpritePtr; newdata: ADDRESS)
Arguments:		viewPort = ViewPort structure
			simpleSprite = initialized SimpleSprite structure
			newdata = table of sprite shape data
Result:			none
-------------------------
CheckIO
Description:		gets the status of an IO request
Library:		exec.library
Offset:			-$01D4 (-468)
Modula-2 Module: 	IO
Syntax:        		status = CheckIO(ioRequest)
C:            		long CheckIO(struct IORequest *)
Machine Language: 	d0 = CheckIO(a1)
Modula-2:       	CheckIO(ioRequest: ADDRESS): ADDRESS
Arguments:     		ioRequest = IORequest block
Result:         	status = NULL if I/O is still in progress; pointer to IORequest
			block if I/O has completed
-------------------------
CINIT (macro)
Description:     	initializes a user copper list
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Copper
Syntax:        		copList = CINIT(copList, num)
C:            		struct UCopList *CINIT(struct UCopList *, short)
Machine Language: 	not available
Modula-2:		CINIT(copList: UCopListPtr; num: CARDINAL): UCopListPtr
Arguments:		copList = UCopList structure
			num = number of instructions buffer must hold
Result:			copList = pointer to an initialized UCopList structure, ready to
			accept copper instructions
-------------------------
ClearDMRequest
Description:		clears the DMRequest of a window
Library:		intuition.library
Offset:			-$0030 (-48)
Modula-2 Module: 	Intuition
Syntax:        		success = ClearDMRequest(window)
C:            		long ClearDMRequest(struct Window *)
Machine Language: 	d0 = ClearDMRequest(a0)
Modula-2:		ClearDMRequest(window: WindowPtr): BOOLEAN
Arguments:		window = window from which DMRequest is to be cleared
Result:			success = TRUE if successful; FALSE if unsuccessful (DMRequest
			is still in use)
-------------------------
ClearEOL
Description:		clears from the current position to the end of the line
Library:		graphics.library
Offset:			-$002A (-42)
Modula-2 Module: 	Text
Syntax:        		ClearEOL(rastPort)
C:            		void ClearEOL(struct RastPort *)
Machine Language: 	ClearEOL(a1)
Modula-2:       	ClearEOL(rastPort: RastPortPtr)
Arguments:     		rastPort = RastPort structure to clear
Result:			none
------------------------- 
ClearMenuStrip
Description:  		clears (detaches) a window's menu strip
Library:        	intuition.library
Offset:         	-$0036 (-54)
Modula-2 Module: 	Intuition
Syntax:        		ClearMenuStrip(window)
C:            		void ClearMenuStrip(struct Window *)
Machine Language: 	ClearMenuStrip(a0)
Modula-2:		ClearMenuStrip(window: WindowPtr)
Arguments:		window = Window structure
Result:			none
-------------------------
ClearPointer
Description:		returns the mouse pointer to its default shape
Library:		intuition.library
Offset:			-$003C (-60)
Modula-2 Module: 	Intuition
Syntax:        		ClearPointer(region)
C:            		void ClearPointer(struct Region *)
Machine Language: 	ClearPointer(a0)
Modula-2:		ClearPointer(window: WindowPtr)
Arguments:		window = Window structure
Result:			none
-------------------------
ClearRectRegion
Description:		performs a two-dimensional clearing operation of a clipping rec
			tangle with a region, leaving the result in the region
Library:		graphics.library
Offset:			-$020A (-522)
Modula-2 Module: 	Regions
Syntax:        		success = ClearRectRegion(region, rectangle)
C:            		long ClearRectRegion(struct Region *, struct Rectangle *)
Machine Language: 	d0 = ClearRectRegion(a0, a1)
Modula-2:		ClearRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region to clear
			rectangle = Rectangle to be used as the clipping rectangle
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
ClearRegion
Description:    	removes all rectangles from a region
Library:        	graphics.library
Offset:         	-$0210 (-528)
Modula-2 Module: 	Regions
Syntax:        		ClearRegion(region)
C:            		void ClearRegion(struct Region *)
Machine Language: 	ClearRegion(a0)
Modula-2:		ClearRegion(region: RegionPtr)
Arguments:		region = Region to clear
Result:			none
-------------------------
ClearScreen
Description:		clears from the current position to the end of the RastPort
Library:		graphics.library
Offset:			-$0030 (-48)
Modula-2 Module: 	Text
Syntax:        		ClearScreen(rastPort)
C:            		void ClearScreen(struct RastPort *)
Machine Language: 	ClearScreen(a1)
Modula-2:		ClearScreen(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort to clear
Result:			none
-------------------------
ClipBlit
Description:		copies bit-map data (and optionally manipulates) from one
			RastPort to another
Library:		graphics.library
Offset:			-$0228 (-552)
Modula-2 Module: 	Blitter
Syntax:        		ClipBlit(scrRastPort, srcX, srcY, destRastPort, destX, destY, sizeX,
			sizeY, miniterm)
C:            		void ClipBlit(struct RastPort * long, long, struct RastPort *, long,
			long, long, long, long)
Machine Language: 	ClipBlit(a0, d0, d1, a1, d2, d3, d4, d5, d6)
Modula-2:       	ClipBlit(scrRPort: RastPortPtr; srcX, srcY: INTEGER; destRPort:
			RastPortPtr; destX, destY: INTEGER; sizeX, sizeY: INTEGER;
			miniterm: BYTE)
Arguments:		scrRastPort = source RastPort structure
			srcX = horizontal coordinate of upper left corner of source
			rectangle
			srcY = vertical coordinate of upper left corner of source rectangle
			destRastPort = destination RastPort structure
			destX = horizontal coordinate of upper left corner of destination
			rectangle
			destY = vertical coordinate of upper left corner of destination
			rectangle
			sizeX = width of rectangle
			sizeY = height of rectangle
			miniterm = logic function to apply to rectangle
Result:			none
-------------------------
Close
Description:		closes an open file
Library:		dos.library
Offset:			-$0024 (-36)
Modula-2 Module: 	DOS
Syntax:        		Close(file)
C:            		void Close(BPTR)
Machine Language: 	Close(d1)
Modula-2:		Close(file: FileHandle)
Arguments:		file = BCPL pointer to file handle of file to close
Result:			none
-------------------------
CloseDevice
Description:		terminates access to a device
Library:		exec.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Devices
Syntax:        		CloseDevice(ioRequest)
C:            		void CloseDevice(struct IORequest *)
Machine Language: 	CloseDevice(a1)
Modula-2:       	CloseDevice(ioRequest: ADDRESS)
Arguments:     		ioRequest = IORequest structure
Result:			none
-------------------------
CloseFont
Description:     	tells the system that an opened font is no longer in use
Library:        	graphics.library
Offset:         	-$004E (-78)
Modula-2 Module: 	Text
Syntax:        		CloseFont(font)
C:            		void CloseFont(struct TextFont *)
Machine Language: 	CloseFont(a1)
Modula-2:		CloseFont(textfont: TextFontPtr)
Arguments:		font = font descriptor as returned by OpenFont( ) or
			OpenDiskFont( )
Result:			none
-------------------------
CloseLibrary
Description:		tells the system that an opened library is no longer in use
Library:		exec.library
Offset:			-$019E (-414)
Modula-2 Module: 	Libraries
Syntax:        		CloseLibrary(library)
C:           		void CloseLibrary(struct Library *)
Machine Language: 	CloseLibrary(a1)
Modula-2:		CloseLibrary(library: LibraryPtr)
Arguments:		library = base address of a library, as returned by OpenLibrary( )
Result:			none
-------------------------
CloseScreen
Description:		closes an Intuition screen
Library:		intuition.library
Offset:			-$0042 (-66)
Modula-2 Module: 	Intuition
Syntax:        		CloseScreen(screen)
C:            		void CloseScreen(struct Screen *)
Machine Language: 	CloseScreen(a0)
Modula-2:       	CloseScreen(screen: ScreenPtr)
Arguments:     		screen = screen to close
Result:			none
-------------------------
CloseWindow
Description:     	closes an Intuition window
Library:        	intuition.library
Offset:         	-$0048 (-72)
Modula-2 Module: 	Intuition
Syntax:        		CloseWindow(window)
C:            		void CloseWindow(struct Window *)
Machine Language: 	CloseWindow(a0)
Modula-2:		CloseWindow(window: WindowPtr)
Arguments:		window = window to close
Result:			none
-------------------------
CloseWorkBench
Description:		attempts to close the Workbench screen
Library:		intuition.library
Offset:			-$004E (-78)
Modula-2 Module: 	Intuition
Syntax:        		success = CloseWorkBench( )
C:            		long CloseWorkBench(void)
Machine Language: 	d0 = CloseWorkBench( )
Modula-2:		CloseWorkBench( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
CMove
Description:		appends a copper move instruction to a user copper list without
			bumping the copper instruction pointer to the next instruction
Library:		graphics.library
Offset:			-$0174 (-372)
Modula-2 Module: 	Copper
Syntax:        		CMove(copList, r, v)
C:            		void CMove(struct UCopList *, long, long)
Machine Language: 	CMove(a1, d0, d1)
Modula-2:		CMove(copList: UCopListPtr; r: ADDRESS; v: WORD)
Arguments:		copList = UCopList structure
			a = address of hardware register to receive value
			v = value to store in hardware register
Result:			none
-------------------------
CMOVE (macro)
Description:		appends a copper move instruction to a user copper list and
			bumps the copper instruction pointer to the next instruction
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module: 	Copper
Syntax:        		CMOVE(copList, r, v)
C:            		void CMOVE(struct UCopList *, APTR, short)
Machine Language: 	not available
Modula-2:		CMOVE(copList: UCopListPtr; r: ADDRESS; v: WORD)
Arguments:		copList = UCopList structure
			a = address of hardware register to receive value
			v = value to store in hardware register
Result:			none
-------------------------
ConcatCList
Description:		concatenates two character lists
Library:		clist.library
Offset:			-$009C (-156)
Modula-2 Module: 	none
Syntax:        		error = ConcatCList(srcCList, destCList)
C:            		long ConcatCList(long, long)
Machine Language: 	d0 = ConcatCList(a0, a1)
Modula-2:		not available
Arguments:		srcCList = source character list
			destCList = destination character list
Result:			error = Zero if successful; Nonzero if unsuccessful (out of
			memory)
-------------------------
ConfigBoard
Description:		configures an expansion board
Library:		expansion.library
Offset:			-$003C (-60)
Modula-2 Module: 	Expansion
Syntax:        		error = ConfigBoard(board, configDev)
C:            		long ConfigBoard(long, long)
Machine Language: 	d0 = ConfigBoard(a0, a1)
Modula-2:       	ConfigBoard(board: ADDRESS; configDev: ADDRESS):
			BOOLEAN
Arguments:		board = base address of expansion board (most likely
			E_EXPANSIONBASE)
			configDev = initialized ConfigDev structure
Result:			error = nonzero if unsuccessful
-------------------------
ConfigChain
Description:		configures the entire system
Library:		expansion.library
Offset:			-$0042 (-66)
Modula-2 Module: 	Expansion
Syntax:        		error = ConfigChain(baseAddr)
C:            		long ConfigChain(long)
Machine Language: 	d0 = ConfigChain(a0)
Modula-2:		ConfigChain(baseAddr: ADDRESS): BOOLEAN
Arguments:		baseAddr = base address (most likely E_EXPANSIONBASE)
Result:			error = nonzero if unsuccessful
-------------------------
CopyCList
Description:		copies a character list to a new character list
Library:		clist.library
Offset:			-$0090 (-144)
Modula-2 Module: 	none
Syntax:       		cList = CopyCList(cList)
C:            		long CopyCList(long)
Machine Language: 	d0 = CopyCList(a0)
Modula-2:		not available
Arguments:		cList = original character list
Result:			cList = new character list; Negative is unsuccessful (not enough
			memory)
-------------------------
CopyMem
Description:		copies the contents of RAM from one location to another
Library:		exec.library
Offset:			-$0270 (-624)
Modula-2 Module: 	Memory
Syntax:        		CopyMem(srcPointer, destPointer, size)
C:            		void CopyMem(char *, char *, long)
Machine Language: 	CopyMem(a0, a1, d0)
Modula-2:		CopyMem(srcPointer, destPointer: ADDRESS; size: LONGCARD)
Arguments:		srcPointer = pointer to memory block to be copied
			destPointer = pointer to destination memory block
			size = size of memory block in bytes
Result:			none
-------------------------
CopyMemQuick
Description:		performs an optimized copy of RAM with some restrictions
Library:		exec.library
Offset:			-$0276 (-630)
Modula-2 Module: 	Memory
Syntax:        		CopyMemQuick(srcPointer, destPointer, size)
C:            		void CopyMemQuick(char *, char *, long)
Machine Language: 	CopyMemQuick(a0, a1, d0)
Modula-2:		CopyMemQuick(srcPointer, destPointer: ADDRESS; size:
			LONGCARD)
Arguments:		srcPointer = pointer to the long-word aligned memory block to
			be copied
			destPointer = pointer to the long-word aligned destination mem-
			ory block
			size = size of memory block in bytes
Result:			none
-------------------------
CopySBitMap
Description:		copies all bits from a SuperBitMap into the Layer bitmap
Library:		graphics.library
Offset:			-$01C2 (-450)
Modula-2 Module: 	Clip
Syntax:        		CopySBitMap(layer)
C:            		void CopySBitMap(struct Layer *)
Machine Language: 	CopySBitMap(a0)
Modula-2:		CopySBitMap(layer: LayerPtr)
Arguments:		layer = pointer to a locked Layer that has a SuperBitMap
Result:			none
-------------------------
CreateBehindlayer
Description:		creates a new layer behind all existing layers
Library:		layers.library
Offset:			-$002A (-42)
Modula-2 Module: 	Layers
Syntax:        		layer = CreateBehindLayer(layerInfo, bitMap, x0, y0, x1, y1, 
			flags, superBitMap)
C:            		struct Layer *CreateBehindLayer(struct LayerInfo *, struct Bit-
			Map *, long, long, long, long, long, struct BitMap *)
Machine Language: 	d0 = CreateBehindLayer(a0, a1, d0, d1, d2, d3, d4, a2)
Modula-2:		CreateBehindLayer(layerInfo: LayerInfoPtr; bitMap: BitMapPtr; x0,
			y0, x1, y1: LONGINT; flags: LayerFlagSet; superBitMap:
			BitMapPtr): LayerPtr
Arguments:		layerInfo = info structure of Layer to create
			bitMap = common BitMap used by all Layers
			x0 = horizontal coordinate of upper left corner of Layer
			y0 = vertical coordinate of upper left corner of Layer
			x1 = horizontal coordinate of lower right corner of Layer
			y1 = vertical coordinate of lower right corner of Layer
			flags = type of Layer
			superBitMap = NULL or a SuperBitMap
Result:			layer = pointer to Layer structure if successful; NULL if
			unsuccessful
-------------------------
CreateDir
Description:		creates a new directory
Library:		dos.library
Offset:			-$0078 (-120)
Modula-2 Module: 	DOS
Syntax:        		lock = CreateDir(name)
C:            		BPTR CreateDir(char *)
Machine Language: 	d0 = CreateDir(d1)
Modula-2:		CreateDir(name: STRPTR): FileLock
Arguments:		name = NULL terminate string that specifies the new directory
			name
Result:			lock = BCPL pointer to a lock
-------------------------
CreateExtIO
Description:		allocates memory for and initializes an IO request block
Library:		amiga.lib (linked library)
Modula-2 Module: 	IOUtils
Syntax:        		block = CreateExtIO(ioReplyPort, size)
C:            		struct IORequest *CreateExtIO(struct MsgPort *, long)
Machine Language: 	move.l #size,-(sp)
			pea ioReplyPort
			jsr _CreateExtIO ;block returned in d0
			addq.l #8,sp
Modula-2:		CreateExtIO(ioReplyPort: MsgPortPtr; size: CARDINAL):
			ADDRESS
Arguments:		ioReplyPort = initialized MsgPort
			size = IORequest block size
Result:			block = pointer to newly created IORequest block; NULL if un-
			successful (not enough memory)
-------------------------
CreatePort
Description:		allocates memory for and initializes a message port
Library:		amiga.lib (linked library)
Modula-2 Module: 	PortUtils
Syntax:        		port = CreatePort(name, pri)
C:            		struct MsgPort *CreatePort(char *, long)
Machine Language: 	move.l #pri,-(sp)
			pea name
			jsr _CreatePort ;port returned in d0
			addq.l #8,sp
Modula-2:		CreatePort(name: STRPTR; pri: INTEGER): MsgPortPtr
Arguments:		name = name of public port to create; NULL for private port
			pri = priority to assign to port
Result:			port = pointer to newly created message port; NULL if unsuc-
			cessful (not enough memory)
-------------------------
CreateProc
Description:		creates a new process
Library:		dos.library
Offset:			-$008A (-138)
Modula-2 Module: 	DOSProcess
Syntax:        		process = CreateProc(name, pri, segment, stackSize)
C:            		struct MsgPort *CreateProc(char *, long, BPTR, long)
Machine Language: 	d0 = CreateProc(d1, d2, d3, d4)
Modula-2:		CreateProc(name: STRPTR; pri: LONGINT; segment: BPTR;
			stackSize: LONGINT): ProcessID
Arguments:		name = NULL terminated string that specifies the new process
			name
			priority = priority to be given to process
			segment = segment list, as returned by LoadSeg( )
			stackSize = size of root stack in bytes
Result:			process = pointer to newly created IORequest block; NULL if un-
			successful (not enough memory)
-------------------------
CreateTask
Description:		creates a task
Library:        	amiga.lib (linked library)
Modula-2 Module: 	TaskUtils
Syntax:       		task = CreateTask(name, pri, initPC, stackSize)
C:            		struct Task *CreateTask(char *, long, _fptr, long)
Machine Language: 	move.l #stackSize,-(sp)
			pea initPC
			move.l #pri,-(sp)
			pea name
			jsr _CreateTask ;task returned in d0
			add.l #16,sp
Modula-2:		CreateTask(name: STRPTR; pri: INTEGER; initP
C:			PROC; stackSize: LONGCARD): TaskPtr
Arguments:		name = name of task
			pri = exec task priority (-128 through 127, usually 0)
			stackSize = size of stack in bytes
Result:			task = pointer to newly created task; NULL if unsuccessful (not
			enough memory)
-------------------------
CreateUpfrontLayer
Description:		creates a new layer on top of all existing layers
Library:		layers.library
Offset:		        -$0024 (-36)
Modula-2 Module: 	Layers
Syntax:		        layer = CreateUpfrontLayer(layerInfo, bitMap, x0, y0, x1, y1, 
			flags, superBitMap)
C:		        struct Layer *CreateUpfrontLayer(struct Layer_Info *, struct Bit-
			Map *, long, long, long, long, long, struct BitMap *)
Machine Language: 	d0 = CreateUpfrontLayer(a0, a1, d0, d1, d2, d3, d4, a2)
Modula-2:		CreateUpfrontLayer(layerInfo: LayerInfoPtr; bitMap: BitMapPtr;
			x0, y0, x1, y1: LONGINT; flags: LayerFlagSet; superBitMap:
			BitMapPtr): LayerPtr
Arguments:		layerInfo = info structure of Layer to create
			bitMap = common BitMap used by all Layers
			x0 = horizontal coordinate of upper left corner of Layer
			y0 = vertical coordinate of upper left corner of Layer
			x1 = horizontal coordinate of lower right corner of Layer
			y1 = vertical coordinate of lower right corner of Layer
			flags = type of Layer
			superBitMap = NULL or pointer to SuperBitMap
Result:			layer = pointer to Layer structure if successful; NULL if
			unsuccessful
-------------------------   
CurrentDir
Description:		changes the current directory and returns the old current directory
Library:        	dos.library
Offset:         	-$007E (-126)
Modula-2 Module: 	DOS
Syntax:        		oldlock = CurrentDir(lock)
C:            		BPTR CurrentDir(BPTR)
Machine Language: 	d0 = CurrentDir(d1)
Modula-2:		CurrentDir(lock: FileLock): FileLock
Arguments:		lock = BCPL pointer to lock associated with new current
			directory
Result:			oldlock = BCPL pointer to lock associated with old directory
-------------------------
CurrentTime
Description:		returns the current system time
Library:		intuition.library
Offset:       		-$0054 (-84)
Modula-2 Module: 	Intuition
Syntax:        		CurrentTime(seconds, micros)
C:            		void CurrentTime(long *, long *)
Machine Language: 	CurrentTime(d0, d1)
Modula-2:		CurrentTime(VAR seconds, micros: LONGCARD)
Arguments:		seconds = pointer to four-byte (LONG) variable to receive sec-
			onds value
			micros = pointer to four-byte (LONG) variable to receive micro-
			seconds value
Result:			returned in seconds and micros arguments
-------------------------
CWait
Description:		appends copper wait instruction to a user copper list without
			bumping the copper instruction pointer to the next instruction
Library:		graphics.library
Offset:       		-$017A (-378)
Modula-2 Module: 	CopperUtil
Syntax:        		CWait(copList, vert, horiz)
C:            		void CWait(struct UCopList *, short, short)
Machine Language: 	not available
Modula-2:		CWait(copList: UCopListPtr; vert, horiz: INTEGER)
Arguments:		copList = UCopList structure
			vert = vertical beam position relative to top of ViewPort
			horiz = horizontal beam position (must be less than 223)
Result:			none
-------------------------
CWAIT (macro)
Description:		appends copper wait instruction to a user copper list and bumps
			the copper instruction pointer to the next instruction
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	CopperUtil
Syntax:        		CWAIT(copList, vert, horiz)
C:            		void CWAIT(struct UCopList *, short, short)
Machine Language: 	not available
Modula-2:		CWAIT(copList: UCopListPtr; vert, horiz: INTEGER)
Arguments:		copList = UCopList structure
			vert = vertical beam position relative to top of ViewPort
			horiz = horizontal beam position (must be less than 223)
Result:			none
-------------------------
DateStamp
Description:		returns the current date and time in internal format
Library:		dos.library
Offset:           	-$00C0 (-192)
Modula-2 Module: 	DOS
Syntax:        		DateStamp(v)
C:            		long *DateStamp(long *)
Machine Language: 	DateStamp(d1)
Modula-2:		DateStamp(v: DateStampRecPtr)
Arguments:		v = pointer to the first element of an array of three long words
Result:			v argument points to result in RAM
-------------------------
dbf
Description:		converts a fast floating point dual-binary number to plain fast
			floating point format
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		fnum = dbf(exp, mant)
C:			float dbf(long, long)
Machine Language: 	move.l #mant,-(sp)
			move.l #exp,-(sp) 
			jsr _dfb ;fnum returned in d0/d1 
			addq.l #8,sp
Modula-2:		not available
Arguments:		exp = 16 bit integer representing the sign (bit 16 equals 0 for
			positive or 1 for negative) and base ten exponent (bits 0-15)
			mant = integer representing the mantissa
Result:			fnum = floating point equivalent of value specified by exp and
			mant arguments
-------------------------
Deallocate
Description:		deallocates a block of previously allocated memory
Library:		exec.library
Offset:       		-$00C0 (-192)
Modula-2 Module: 	Memory
Syntax:        		Deallocate(freeList, memoryBlock, byteSize)
C:            		void Deallocate(struct MemHeader *, void *, long)
Machine Language: 	Deallocate(a0, a1, d0)
Modula-2:		Deallocate(freeList: MemHeaderPtr; memoryBlock: ADDRESS;
			byteSize: LONGCARD)
Arguments:		freeList = memory list header
			memoryBlock = memory block to deallocate
			byteSize = size of memory block in bytes
Result:			none
-------------------------
Debug
Description:		runs the system debugger or the debugger installed by
			SetFunction
Library:		exec.library
Offset:       		-$0072 (-114)
Modula-2 Module: 	Exec
Syntax:        		Debug(num)
C:            		void Debug(long)
Machine Language: 	Debug(d0)
Modula-2:      		Debug(num: LONGCARD)
Arguments:     		num = should be set to 0
Result:			none
-------------------------  
Delay
Description:     	delays a process for a specified amount of time
Library:        	dos.library
Offset:         	-$00C6 (-198)
Modula-2 Module: 	DOSProcess
Syntax:        		Delay(ticks)
C:            		void Delay(long)
Machine Language: 	Delay(d1)
Modula-2:		Delay(ticks: LONGINT)
Arguments:		ticks = number of ticks to wait (50 ticks per second)
Result:	none
-------------------------
DeleteExtIO
Description:		returns memory allocated by CreateExtIO
Library:		amiga.lib (linked library)
Modula-2 Module: 	IOUtils
Syntax:        		DeleteExtIO(ioRequest, size)
C:            		void DeleteExtIO(struct IORequest *, long)
Machine Language: 	move.l #size,-(sp)
			pea ioRequest
			jsr _DeleteExtIO
			addq.l #4,sp
Modula-2:		DeleteExtIO(ioReq: ADDRESS; size: CARDINAL)
Arguments:		ioRequest = IORequest block to delete
			size = size of IORequest block in bytes
Result:			none
-------------------------
DeleteFile
Description:		deletes a file or directory
Library:		dos.library
Offset:       		-$0048 (-72)
Modula-2 Module: 	DOS
Syntax:        		success = DeleteFile(name)
C:            		long DeleteFile(char *)
Machine Language: 	d0 = DeleteFile(d1)
Modula-2:       	DeleteFile(name: STRPTR): BOOLEAN
Arguments:      	name = NULL terminated string that specifies the file to delete
Result:			TRUE if successful; FALSE if unsuccessful
-------------------------
DeleteLayer
Description:		deletes a layer from a layer list
Library:        	layers.library
Offset:         	-$005A (-90)
Modula-2 Module: 	Layers
Syntax:        		success = DeleteLayer(dummy, layer)
C:            		long DeleteLayer(struct Layer_Info, struct Layer *)
Machine Language: 	d0 = DeleteLayer(a0, a1)
Modula-2:		DeleteLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = layer to delete
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
DeletePort
Description:		frees a message port created by CreatePort( )
Library:		amiga.lib (linked library)
Modula-2 Module: 	PortUtils
Syntax:        		DeletePort(msgPort)
C:            		void DeletePort(struct MsgPort *)
Machine Language: 	pea msgPort
			jsr _DeletePort
			addq.l #4,sp
Modula-2:		DeletePort(msgPort: MsgPortPtr)
Arguments:		msgPort = message port to delete
Result:			none
-------------------------
DeleteTask
Description:		deletes a task created with CreateTask( )
Library:		amiga.lib (linked library)
Modula-2 Module: 	TaskUtils
Syntax:        		DeleteTask(task)
C:            		void DeleteTask(struct Task *)
Machine Language: 	pea task
			jsr _DeleteTask
			addq.l #4,sp
Modula-2:		DeleteTask(task: TaskPtr)
Arguments:		task = Task to delete
Result:			none
-------------------------
DeviceProc
Description:		returns the process identifier of specified process
Library:        	dos.library
Offset:         	-$00AE (-174)
Modula-2 Module: 	DOSProcess
Syntax:        		process = DeviceProc(name)
C:            		struct MsgPort *DeviceProc(char *)
Machine Language: 	d0 = DeviceProc(d1)
Modula-2:		DeviceProc(name: STRPTR): ProcessID
Arguments:		name = NULL terminated string that specifies the device name
Result:			process = BCPL pointer to a process; NULL if unsuccessful
-------------------------
Disable
Description:		disables interrupt processing
Library:		exec.library
Offset:        		-$0078 (-120)
Modula-2 Module: 	Interrupts
Syntax:        		Disable( )
C:            		void Disable(void)
Machine Language: 	Disable( )
Modula-2:		Disable( )
Arguments:		none
Result:			none
-------------------------
DisownBlitter
Description:		frees blitter for use by other programs
Library:		graphics.library
Offset:        		-$01CE (-462)
Modula-2 Module: 	Blitter
Syntax:        		DisownBlitter( )
C:            		void DisownBlitter(void)
Machine Language: 	DisownBlitter( )
Modula-2:       	DisownBlitter( )
Arguments:      	none
Result:			none
-------------------------
DisplayAlert
Description: 		creates an Alert
Library:        	intuition.library
Offset:         	-$005A (-90)
Modula-2 Module: 	Intuition
Syntax:        		response = DisplayAlert(alertNumber, message, height)
C:            		long DisplayAlert(long, char *, long)
Machine Language: 	d0 = DisplayAlert(d0, a0, d1)
Modula-2:		DisplayAlert(alertNumber: LONGCARD; message: ADDRESS;
			height: CARDINAL): BOOLEAN
Arguments:		alertNumber = AlertMessage number
			message = NULL terminated Alert message string
			height = minimum display lines required for your message
Result:			response = TRUE or FALSE, depending on alert type and user
			response
-------------------------
DisplayBeep
Description:		flashes the video display and emits a beep
Library:		intuition.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	Intuition
Syntax:        		DisplayBeep(screen)
C:            		void DisplayBeep(struct Screen *)
Machine Language: 	DisplayBeep(a0)
Modula-2:       	DisplayBeep(screen: ScreenPtr)
Arguments:     		screen = screen to beep
Result:        		none
-------------------------
DisposeFontContents (available in library version 34)
Description:     	frees the array of FontContents returned by NewFontContents( )
Library:        	diskfont.library
Offset:         	-$0030 (-48)
Modula-2 Module: 	none
Syntax:        		DisposeFontContents(fontContentsHeader)
C:            		void DisposeFontContents(struct FontContentsHeader *)
Machine Language: 	DisposeFontContents(a1)
Modula-2:       	not available
Arguments:     		fontContentsHeader = FontContentsHeader as returned by
			NewFontContents( )
Result:			none
-------------------------  
DisposeLayerInfo
Description:		returns memory used by a LayerInfo structure
Library:        	layers.library
Offset:         	-$0096 (-150)
Modula-2 Module: 	Layers
Syntax:        		DisposeLayerInfo(layerInfo)
C:            		void DisposeLayerInfo(struct Layer_Info *)
Machine Language: 	DisposeLayerInfo(a0)
Modula-2:		DisposeLayerInfo(layerInfo: layerInfoPtr)
Arguments:		layerInfo = LayerInfo structure to remove
Result:			none
-------------------------
DisposeRegion
Description:		returns memory used by a Region structure and its
			RegionRectangles
Library:		graphics.library
Offset:        		-$0216 (-534)
Modula-2 Module: 	Regions
Syntax:        		DisposeRegion(region)
C:            		void DisposeRegion(struct Region *)
Machine Language: 	DisposeRegion(a0)
Modula-2:		DisposeRegion(region: RegionPtr)
Arguments:		region = Region structure to remove
Result:			none
-------------------------
DoCollision
Description:		tests all GELs in GEL list for GEL-to-GEL collisions
Library:		graphics.library
Offset:        		-$006C (-108)
Modula-2 Module: 	Gels
Syntax:        		DoCollision(rastPort)
C:            		void DoCollision(struct RastPort *)
Machine Language: 	DoCollision(a1)
Modula-2:       	DoCollision(rastPort: RastPortPtr)
Arguments:     		rastPort = RastPort with GEL list
Result:			none
-------------------------  
DoIO
Description:		performs IO command and waits for completion
Library:       		exec.library
Offset:        		-$01C8 (-465)
Modula-2 Module: 	IO
Syntax:        		error = DoIO(ioRequest)
C:            		long DoIO(struct IORequest *)
Machine Language: 	d0 = DoIO(a1)
Modula-2:		DoIO(ioRequest: ADDRESS): INTEGER
Arguments:		ioRequest = initialized IORequest structure
Result:			error = zero if successful; nonzero if unsuccessful
-------------------------
DoubleClick
Description:		test two time values for double-click timing
Library:		intuition.library
Offset:       		-$0066 (-102)
Modula-2 Module: 	Intuition
Syntax:        		double = DoubleClick(startSecs, startMicros, currentSecs,
			currentMicros)
C:            		long DoubleClick(long, long, long, long)
Machine Language: 	d0 = DoubleClick(d0, d1, d2, d3)
Modula-2:		DoubleClick(startSecs, startMicros, currentSecs, currentMicros:
			LONGCARD): BOOLEAN
Arguments:		startSecs = seconds value at time of first click
			startMicros = micros value at time of first click
			currentSecs = seconds value at time of second click
			currentMicros = micros value at time of second click
Result:			double = TRUE if valid double click; FALSE if not
-------------------------
Draw
Description:		draws a line from current pen position to specified point
Library:		graphics.library
Offset:       		-$00F6 (-246)
Modula-2 Module: 	Pens
Syntax:        		Draw(rastPort, x, y)
C:            		long Draw(struct RastPort *, long, long)
Machine Language:	Draw(a1, d0, d1)
Modula-2:		Draw(rastPort: RastPortPtr; x, y: INTEGER)
Arguments:		rastPort = RastPort to draw line in
			x = horizontal coordinate of line's destination
			y = vertical coordinate of line's destination
Result:			none
-------------------------
DrawBorder
Description:		draws a border
Library:		intuition.library
Offset:       		-$006C (-108)
Modula-2 Module: 	Intuition
Syntax:        		DrawBorder(rastPort, border, leftOffset, topOffset)
C:            		long DrawBorder(struct RastPort *, struct Border *, long, long)
Machine Language: 	DrawBorder(a0, a1, d0, d1)
Modula-2:		DrawBorder(rastPort: RastPortPtr; border: BorderPtr; leftOffset,
			topOffset: INTEGER)
Arguments:		rastPort = RastPort to draw border in
			border = Border to be drawn
			leftOffset = horizontal placement offset for border
			topOffset = vertical placement offset for border
Result:			none
-------------------------
DrawCircle (macro)
Description:     	draws a circle in the specified RastPort
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module: 	Pens
Syntax:        		DrawCircle(rastPort, cx, cy, radius)
C:            		void DrawCircle(struct RastPort *, long, long, long)
Machine Language: 	not available, use DrawEllipse instead
Modula-2:		DrawCircle(rastPort: RastPortPtr; cx, cy, radius: INTEGER)
Arguments:		rastPort = RastPort structure
			cx = horizontal coordinate of circle's center
			cy = vertical coordinate of circle's center
			radius = circle's radius
Result:			none
-------------------------
DrawEllipse
Description:     	draws an elliptical outline within a rectangular outline
Library:       		graphics.library
Offset:         	-$00B4 (-180)
Modula-2 Module: 	Pens
Syntax:        		DrawEllipse(rastPort, cx, cy, a, b)
C:            		void DrawEllipse(struct RastPort *, long, long, long, long)
Machine Language: 	DrawEllipse(a1, d0, d1, d2, d3)
Modula-2:		DrawEllipse(rastPort: RastPortPtr; cx, cy, a, b: INTEGER)
Arguments:		rastPort = RastPort into which ellipse will be drawn
			cx = horizontal coordinate of ellipse's center, relative to the
			RastPort
			cy = vertical coordinate of ellipse's center, relative to the RastPort
			a = ellipse's horizontal radius (must be greater than O)
			b = ellipse's vertical radius (must be greater than O)
Result:			none
-------------------------
DrawGList
Description:		processes a GEL list, drawing bobs and constructing a copper list
			for VSprites
Library:		graphics.library
Offset:       		-$0072 (-114)
Modula-2 Module: 	Gels
Syntax:        		DrawGList(rastPort, viewPort)
C:            		void DrawGList(struct RastPort *, struct ViewPort *)
Machine Language: 	DrawGList(a1, a0)
Modula-2:		DrawGList(rastPort: RastPortPtr; viewPort: ViewPortPtr)
Arguments:		rastPort = RastPort where bobs will be drawn
			viewPort = ViewPort in which VSprites will be created
Result:			none
-------------------------
DrawImage
Description:		draw the specified image
Library:		intuition.library
Offset:       		-$0072 (-114)
Modula-2 Module:	Intuition
Syntax:       		DrawImage(rastPort, image, leftOffset, topOffset)
C:            		long DrawImage(struct RastPort *, struct Image *, long, long)
Machine Language: 	DrawImage(a0, a1, d0, d1)
Modula-2:		DrawImage(rastPort: RastPortPtr; image: ImagePtr; leftOffset,
			topOffset: INTEGER)
Arguments:		rastPort = RastPort where image will be drawn
			image = Image to be drawn
			leftOffset = horizontal placement offset for image
			topOffset = vertical placement offset for image
Result:			none
-------------------------
Duplock
Description:		duplicates a lock
Library:		dos.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	DOS
Syntax:        		newlock = DupLock(lock)
C:            		BPTR DupLock(BPTR)
Machine Language: 	d0 = DupLock(d1)
Modula-2:		DupLock(lock: FileLock): FileLock
Arguments:		lock = lock to duplicate
Result:			newlock = duplicate lock
-------------------------
Enable
Description:		enables interrupt processing
Library:		exec.library
Offset:       		-$007E (-126)
Modula-2 Module: 	Interrupts
Syntax:        		Enable( )
C:            		void Enable(void)
Machine Language: 	Enable( )
Modula-2:		Enable( )
Arguments:		none
Result:			none
-------------------------
EndRefresh
Description:		ends optimized refresh of a window
Library:		intuition.library
Offset:       		-$016E (-366)
Modula-2 Module: 	Intuition
Syntax:        		EndRefresh(window, complete)
C:            		void EndRefresh(struct Window *, long)
Machine Language: 	EndRefresh(a0, d0)
Modula-2:		EndRefresh(window: WindowPtr; complete: BOOLEAN)
Arguments:		window = window in optimized-refresh mode
			complete = TRUE if window is completely refreshed; FALSE if
			not
Result:			none
-------------------------
EndRequest
Description:		removes requester from window
Library:		intuition.library
Offset:       		-$0078 (-120)
Modula-2 Module: 	Intuition
Syntax:        		EndRequest(requester, window)
C:            		void EndRequest(struct Requester *, struct Window *)
Machine Language: 	EndRequest(a0, a1)
Modula-2:		EndRequest(requester: RequesterPtr; window: WindowPtr)
Arguments:		requester = requester to remove
			window = window which is associated with requester
Result:			none
-------------------------
EndUpdate
Description:		removes damage list and restores layer to normal state
Library:		layers.library
Offset:       		-$0054 (-84)
Modula-2 Module:	Layers
Syntax:        		EndUpdate(layer, flag)
C:            		void EndUpdate(struct Layer *, long)
Machine Language: 	EndUpdate(a0, d0)
Modula-2:		EndUpdate(layer: LayerPtr; flag: BOOLEAN)
Arguments:		layer = layer to return to normal state
			flag = TRUE if update was complete-damage list will be
			cleared; FALSE if update was not complete-damage list will be
			retained
Result:	none
-------------------------
Enqueue
Description:		inserts or appends node to a system queue
Library:		exec.library
Offset:       		-$010E (-270)
Modula-2 Module: 	Lists
Syntax:			Enqueue(list, node)
C:     			void Enqueue(struct List *, struct Node *)
Machine Language: 	Enqueue(a0, a0)
Modula-2:		Enqueue(list: ListPtr; node: NodePtr)
Arguments:		list = system queue header
			node = node to insert or append
Result:			none
-------------------------
Examine
Description:		examines a directory or file
Library:		dos.library
Offset:       		-$0066 (-102)
Modula-2 Module: 	DOS
Syntax:        		success = Examine(lock, infoBlock)
C:            		long Examine(BPTR, struct FileInfoBlock *)
Machine Language: 	d0 = Examine(d1, d2)
Modula-2:		Examine(lock: FileLock; infoBlock: FileInfoBlockPtr): BOOLEAN
Arguments:		lock = lock of directory or file to examine
			infoBlock = info block to receive directory or file information
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Execute
Description:		executes a CLI command
Library:		dos.library
Offset:       		-$00DE (-222)
Modula-2 Module: 	DOSLoader
Syntax:        		success = Execute(command, input, output)
C:            		long Execute(char *, BPTR, BPTR)
Machine Language: 	d0 = Execute(d1, d2, d3)
Modula-2:		Execute(command: STRPTR; input, output: FileHandle):
			BOOLEAN
Arguments:		command = NULL terminated string containing CLI command
			input = file handle for input redirection; NULL if none
			output = file handle for output redirection; NULL if none
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Exit
Description:		ends a program
Library:		dos.library
Offset:       		-$0090 (-144)
Modula-2 Module: 	DOSProcess
Syntax:		        Exit(returnCode)
C:            		void Exit(long)
Machine Language: 	Exit(d1)
Modula-2:		Exit(returnCode: LONGINT)
Arguments:		returnCode = return code passed to parent (usually the CLI)-by
			convention, a value of zero implies no error
Result:			none
-------------------------
ExNext
Description:		examines the next entry in a directory
Library:		dos.library
Offset:         	-$006C (-108)
Modula-2 Module: 	DOS
Syntax:        		success = ExNext(lock, infoBlock)
C:            		long ExNext(BPTR, struct FilelnfoBlock *)
Machine Language: 	d0 = ExNext(d1, d2)
Modula-2:		ExNext(lock: FileLock; infoBlock: FileInfoBlockPtr): BOOLEAN
Arguments:		lock = lock of directory to examine
			infoBlock = info block to receive entry information
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
FastRand
Description:		generates a somewhat random integer
Library:		amiga.lib (linked library)
Modula-2 Module: 	none
Syntax:        		rnd = FastRand(seed)
C:            		long FastRand(long)
Machine Language: 	move.l #long,-(sp)
			jsr _FastRand ;rnd returned in d0
			addq.l #4,sp
Modula-2:		not available, use Random in RandomNumbers module
Arguments:		seed = value used to seed random number
Result:			rnd = random number calculate using the following C equation:
			rnd=(seed << 1) ^ 0x1872B41
-------------------------
FattenLayerInfo
Description:		converts 1.0 LayerInfo structure to 1.1-1.3-compatible LayerInfo
			structure
Library:		layers.library
Offset:         	-$009C (-156)
Modula-2 Module: 	none
Syntax:        		FattenLayerInfo(layerInfo)
C:            		void FattenLayerInfo(struct Layer_Info *)
Machine Language: 	FattenLayerInfo(a0)
Modula-2:		not available
Arguments:		layerInfo = LayerInfo structure to update
Result:			none
-------------------------
FindConfigBoard
Description:		finds a matching ConfigDev entry
Library:		expansion.library
Offset:          	-$0048 (-72)
Modula-2 Module: 	none
Syntax:        		configDev = FindConfigBoard(oldConfigDev, manufacturer,
			product)
C:            		struct ConfigDev *FindConfigBoard(long, long, long)
Machine Language: 	d0 = FindConfigBoard(a0, d0, d1)
Modula-2:		not available
Arguments:		oldConfigDev = ConfigDev structure just before the location in
			ConfigDev list where search should begin; NULL to start search at
			the beginning of the list
			manufacturer = manufacturer code to search for; -1 to ignore
			manufacturer code
			product = product code to search for; -1 to ignore product coed
Result:			configDev = first ConfigDev structure that matches the manufac-
			turer and product codes specified; NULL if no more matches
-------------------------
FindName
Description:		finds a system list node
Library:		exec.library
Offset:         	-$0114 (-276)
Modula-2 Module: 	Lists
Syntax:        		node = FindName(start, name)
C:            		struct Node *FindName(struct List *, char *)
Machine Language: 	d0 = FindName(a0, a1)
Modula-2:		FindName(start: ADDRESS; name: STRPTR): NodePtr
Arguments:		start = list header or list node to start search (if node this one is
			skipped)
			name = NULL terminated string that specifies name of node
Result:			node = pointer to specified node; NULL if unsuccessful
-------------------------  
FindPort
Description:     	finds a public message port
Library:        	exec.library
Offset:         	-$0186 (-390)
Modula-2 Module: 	Ports
Syntax:        		port = FindPort(name)
C:            		struct MsgPort *FindPort(char *)
Machine Language: 	d0 = FindPort(a1)
Modula-2:		FindPort(name: STRPTR): MsgPortPtr
Arguments:		name = NULL terminated string that specifies name of port
Result:			port = pointer to specified port; NULL if unsuccessful
-------------------------
FindResident
Description:		finds a Resident structure
Library:		exec.library
Offset:        		-$0060 (-96)
Modula-2 Module: 	Resident
Syntax:        		resident = FindResident(name)
C:            		struct Resident *FindResident(char *)
Machine Language: 	d0 = FindResident(a1)
Modula-2:		FindResident(name: STRPTR): ResidentPtr
Arguments:		name = NULL terminated string that specifies name of Resident
			structure
Result:			resident = pointer to specified Resident structure; NULL if
			unsuccessful
-------------------------
FindSemaphore
Description:		finds a SignalSemaphore structure
Library:		exec.library
Offset:        		-$0252 (-612)
Modula-2 Module: 	Semaphores
Syntax:        		semaphore = FindSemaphore(name)
C:            		struct SignalSemaphore *FindSemaphore(char *)
Machine Language: 	d0 = FindSemaphore(a1)
Modula-2:		FindSemaphore(name: STRPTR): SignalSemaphorePtr
Arguments:		name = NULL terminated string that specifies name of
			semaphore
Result:			semaphore = pointer to specified SignalSemaphore structure;
			NULL if unsuccessful
-------------------------  
FindTask
Description:     	finds a task
Library:        	exec.library
Offset:         	-$0126 (-294)
Modula-2 Module: 	Tasks
Syntax:        		task = FindTask(name)
C:            		struct Task *FindTask(char *)
Machine Language:	d0 = FindTask(a1)
Modula-2:		FindTask(name: STRPTR): TaskPtr
Arguments:		name = NULL terminated string that specifies name of task
Result:			task = pointer to specified task; NULL if unsuccessful
-------------------------
FindToolType
Description:		finds value of a ToolType variable
Library:		icon.library
Offset:       		-$0060 (-96)
Modula-2 Module: 	Icon
Syntax:        		value = FindToolType(toolTypeArray, typeName)
C:            		struct char *FindToolType(char *, char *)
Machine Language: 	d0 = FindToolType(a0, a1)
Modula-2:		FindToolType(toolTypeArray: StrArrayPtr; typeName: STRPTR):
			ADDRESS
Arguments:		toolTypeArray = pointer to an array of strings containing tool
			types
			typeName = NULL terminated string that specifies tool type to
			find
Result:			value = pointer to string containing specified tool type; NULL if
			typeName not found in toolTypeArray
-------------------------
Flood
Description:	floods (fills) an area of a RastPort
Library:	graphics.library
Offset:       -$014A (-330)
Modula-2 Module: Pens
Syntax:        Flood(rastPort, mode, x, y)
C:            void Flood(struct RastPort *, long, long, long)
Machine Language: Flood(a1, d2, d0, d1)
Modula-2:		Flood(rastPort: RastPortPtr; mode: LONGCARD; x, y: INTEGER)  
Arguments:	rastPort = RastPort to fill
	mode = type of fill- 0 (fill pixels that are the same color as
	AOLPen) or 1 (fill pixels that are the same color as pixel at x,y)
	x = horizontal coordinate where fill will begin
	y = vertical coordinate where fill will begin

Result:			none
-------------------------
FlushCList
Description:		clears a character list
Library:		clist.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			FlushCList(cList)
C:			void FlushCList(long)
Machine Language:	FlushCList(a0)
Modula-2:		not available
Arguments:		cList = CList header-as returned by AllocCList( )
			or StrToCL( )-used to manage character list to clear
Result:			none
-------------------------
Forbid
Description:		prevents task rescheduling
Library:		exec.library
Offset:			-$0084 (-132)
Modula-2 Module:	Interrupts
Syntax:			Forbid( )
C:			void Forbid(void)
Machine Language:	Forbid( )
Modula-2:		Forbid( )
Arguments:		none
Result:			none
-------------------------
fpa
Description:		converts a fast floating point number into an ASCII string
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			exp = fpa(fnum, string)
C:			long fpa(float, char *)
Machine Language:	pea string 
			move.l fnum,-(sp)
			jsr _fpa ;exp returned in d0 and string equals fnum 
			addq.l #8,sp
Modula-2:		not available
Arguments:		fnum = floating point number to convert
			string = address of string to receive ASCII equivalent of fnum
			argument
Result:			exp = integer exponent of fnum
-------------------------
fpbcd
Description:		converts a fast floating point number into BCD format
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			fpbcd(fnum, string)
C:			void fpbcd(float, char *)
Machine Language:	pea string
			move.l fnum,-(sp)
			jsr _fpbcd ;BCD equivalent of fnum returned in string
			addq.l #8,sp
Modula-2:		not available
Arguments:		fnum = floating point number to convert
			string = address of five-byte string to receive BCD equivalent of
			fnum argument
Result:			string argument receives the BCD equivalent of fnum argument
-------------------------
FreeBoardMem
Description:		frees expansion board memory (opposite of AllocBoardMem( )
Library:		expansion.library
Offset:			-$004E (-78)
Modula-2 Module:	Expansion
Syntax:			FreeBoardMem(startSlot, slotSpec)
C:			void FreeBoardMem(long, long)
Machine Language:	d0 = FreeBoardMem(d0, d1)
Modula-2:		FreeBoardMem(startslot, slotSpeC: INTEGER)
Arguments:		startSlot = slot number as returned by AllocBoardMem( )
			slotSpec = number of slots to free
Result:			none
-------------------------
Modula-2:		FreeMem(memoryBlock: ADDRESS: byteSize: LONGCARD)
Arguments:		memoryBlock = pointer to memory block to free
			byteSize = size of block in bytes
Result:			none
-------------------------  
FreeCList
Description:		releases character list descriptor and any resources it uses
Library:        	clist.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			FreeCList(cList)
C:			void FreeCList(long)
Machine Language:	FreeCList(a0)
Modula-2:		not available
Arguments:		cList = descriptor of character list to free
Result:			none
-------------------------
FreeColorMap
Description:		returns memory used by a ColorMap structure
Library:		graphics.library
Offset:			-$0240 (-576)
Modula-2 Module:	Views
Syntax:			FreeColorMap(colorMap)
C:			void FreeColorMap(struct ColorMap *)
Machine Language:	FreeColorMap(a0)
Modula-2:		FreeColorMap(colorMap: ColorMapPtr)
Arguments:		colorMap = ColorMap structure to free
Result:			none
-------------------------
FreeConfigDev
Description:		frees a ConfigDev structure
Library:		expansion.library
Offset:			-$0054 (-84)
Modula-2 Module:	ConfigVars
Syntax:			FreeConfigDev(configDev)
C:			void FreeConfigDev(struct ConfigDev *)
Machine Language:	FreeConfigDev(a0)
Modula-2:       	FreeConfigDev(configDev: ConfigDevPtr)
Arguments:     		configDev = ConfigDev structure as returned by AllocConfigDev( )
Result:			none
-------------------------  
FreeCopList
Description:		returns memory allocated for an intermediate copper list
Library:        	graphics.library
Offset:			-$0222 (-546)
Modula-2 Module:	Copper
Syntax:			FreeCopList(copList)
C:			void FreeCopList(struct CopList *)
Machine Language:	FreeCopList(a0)
Modula-2:		FreeCopList(copList: CopListPtr)
Arguments:		copList = CopList structure to free
Result:			none
-------------------------
FreeCprList
Description:		returns memory allocated for a hardware copper list
Library:		graphics.library
Offset:			-$0234 (-564)
Modula-2 Module:	Copper
Syntax:			FreeCprList(cprlist)
C:			void FreeCprList(struct cprlist *)
Machine Language:	FreeCprList(a0)
Modula-2:		FreeCprList(cprlist: cprlistPtr)
Arguments:		cprlist = cprlist structure to free
Result:			none
-------------------------
FreeDiskObject
Description:		frees memory allocated for a Workbench disk object
Library:		icon.library
Offset:			-$005A (-90)
Modula-2 Module:	Icon
Syntax:			FreeDiskObject(diskObj)
C:			void FreeDiskObject(struct DiskObject *)
Machine Language:	FreeDiskObject(a0)
Modula-2:		FreeDiskObject(diskObj: DiskObjectPtr)
Arguments:		diskObj = DiskObject structure to free
Result:			none
-------------------------  
FreeEntry
Description:		frees many regions of memory
Library:		exec.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Memory
Syntax:			FreeEntry(memList)
C:			void FreeEntry(struct MemList *)
Machine Language:	FreeEntry(a0)
Modula-2:		FreeEntry(memList: MemListPtr)
Arguments:		memList = MemList structure
Result:			none
-------------------------
FreeExpansionMem
Description:		frees expansion memory
Library:		expansion.library
Offset:			-$005A (-90)
Modula-2 Module:	Expansion
Syntax:			FreeExpansionMem(startSlot, numSlots)
C:			void FreeExpansionMem(long, long)
Machine Language:	FreeExpansionMem(d0, d1)
Modula-2:		FreeExpansionMem(startSlot, numSlots: INTEGER)
Arguments:		startSlot = slot number as returned by AllocExpansionMem( )
			slotSpec = number of slots to free
Result:			none
-------------------------
FreeFreeList
Description:		frees all memory in a free list
Library:		icon.library
Offset:			-$0036 (-54)
Modula-2 Module:	Icon
Syntax:			FreeFreeList(freeList)
C:			void FreeFreeList(struct FreeList *)
Machine Language:	FreeFreeList(a0)
Modula-2:		FreeFreeList(freeList: FreeListPtr)
Arguments:		memList = FreeList structure
Result:			none
-------------------------
FreeGBuffers
Description:		frees memory allocated by GetGBuffers( )
Library:		graphics.library
Offset:			-$0258 (-600)
Modula-2 Module:	Gels
Syntax:			FreeGBuffers(animOb, rastPort, dBuffer)
C:			void FreeGBuffers(struct AnimOb *, struct RastPort *, long)
Machine Language:	FreeGBuffers(a0, a1, d0)
Modula-2:		FreeGBuffers(animOb: AnimObPtr; rastPort: RastPortPtr; dBuffer:
			BOOLEAN)
Arguments:		animOb = AnimOb structure
			rastPort = Rastport structure
			dBuffer = double-buffer flag-TRUE for double-buffering
Result:			none
-------------------------
FreeMem
Description:		frees memory allocated by GetGBuffers( )
Library:		exec.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Memory
Syntax:			FreeMem(memoryBlock, byteSize)
C:			void FreeMem(void *, long)
Machine Language:	FreeMem(a1, d0)
Modula-2:		FreeMem(memoryBlock: ADDRESS: byteSize: LONGCARD)
Arguments:		memoryBlock = pointer to memory block to free
			byteSize = size of block in bytes
Result:			none
-------------------------
FreeRaster
Description:		frees memory allocated by AllocRaster( )
Library:		graphics.library
Offset:			-$01F2 (-498)
Modula-2 Module:	Rasters
Syntax:			FreeRaster(p, width, height)
C:			void FreeRaster(PLANEPTR, long, long)
Machine Language:	FreeRaster(a0, d0, d1)
Modula-2:		FreeRaster(p: PlanePtr; width, height: CARDINAL)
Arguments:		p = memory block returned by AllocRaster( )
		width = width of bitplanes in pixels
		height = height of bitplanes in pixels
Result:			none
-------------------------  
FreeRemember
Description:		frees memory allocated by AllocRemember( )
Library:		intuition.library
Offset:			-$0198 (-408)
Modula-2 Module:	Intuition
Syntax:			FreeRemember(rememberKey, reallyForget)
C:			void FreeRemember(struct Remember *, long)
Machine Language:	FreeRemember(a0, d0)
Modula-2:		FreeRemember(rememberKey: RememberPrt; reallyForget:
			BOOLEAN)
Arguments:		rememberKey = address of pointer to Remember structure
			reallyForget = TRUE to free memory and link nodes; FALSE to
			free only link nodes
Result:			none
-------------------------
FreeSignal
Description:		frees a signal bit
Library:		exec.library
Offset:			-$0150 (-336)
Modula-2 Module:	Tasks
Syntax:			FreeSignal(signalNum)
C:			void FreeSignal(long)
Machine Language:	FreeSignal(d0)
Modula-2:		FreeSignal(signalNum: SIGNAL)
Arguments:		signalNum = signal number to free (0-31)
Result:			none
-------------------------
FreeSprite
Description:		makes sprite available for others to use
Library:		graphics.library
Offset:			-$019E (-414)
Modula-2 Module:	Sprites
Syntax:			FreeSprite(pick)
C:			void FreeSprite(long)
Machine Language:	FreeSprite(d0)
Modula-2:		FreeSprite(pick: INTEGER)
Arguments:		pick = number of sprite to free (0-7)
Result:			none
-------------------------
FreeSysRequest
Description:		frees memory allocated by BuildSysRequest( )
Library:		intuition.library
Offset:			-$0174 (-372)
Modula-2 Module:	Intuition
Syntax:			FreeSysRequest(window)
C:			void FreeSysRequest(struct Window *)
Machine Language:	FreeSysRequest(a0)
Modula-2:		FreeSysRequest(window: WindowPtr)
Arguments:		window = Window structure as returned by BuildSysRequest( )
Result:			none
-------------------------
FreeTrap
Description:		frees a processor trap
Library:		exec.library
Offset:			-$015C (-348)
Modula-2 Module:	Tasks
Syntax:			FreeTrap(trapNum)
C:			void FreeTrap(long)
Machine Language:	FreeTrap(d0)
Modula-2:		FreeTrap(trapNum: TRAP)
Arguments:		trapNum = trap number to free (0-15)
Result:			none
-------------------------
FreeVPortCoplists
Description:		frees all intermediate copper lists and their headers from a
			ViewPort
Library:		graphics.library
Offset:			-$021C (-540)
Modula-2 Module:	Views
Syntax:			FreeVPortCopLists(viewPort)
C:			void FreeVPortCopLists(struct ViewPort *)
Machine Language:	FreeVPortCopLists(a0)
Modula-2:		FreeVPortCopLists(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure containing copper lists
Result:			none
-------------------------  
FreeWBObject
Description:		frees memory allocated for a Workbench object
Library:		icon.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			FreeWBObject(object)
C:			void FreeWBObject(struct WBObject *)
Machine Language:	FreeWBObject(a0)
Modula-2:		not available
Arguments:		object = WBObject structure to free
Result:			none
--------------------------
GetCC
Description:		gets 68000/68010 condition codes
Library:		exec.library
Offset:			-$0210 (-528)
Modula-2 Module:	Exec
Syntax:			condition = GetCC( )
C:			long GetCC(void)
Machine Language:	d0 = GetCC( )
Modula-2:		GetCC( ): BITSET
Arguments:		none
Result:			condition = 68000/68010 condition code
-------------------------
GetCLBuf
Description:		converts character list into contiguous data
Library:		clist.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			length = GetCLBuf(cList, buffer, maxLength)
C:			long GetCLBuf(long, char *, long)
Machine Language:	d0 = GetCLBuf(a0, a1, d1)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			buffer = buffer to hold data
			maxLength = maximum size of buffer in bytes
Result:			length = number of bytes copied into buffer
-------------------------  
GetCLChar
Description:		gets a byte from the beginning of a character list
Library:		clist.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			byte = GetCLChar(cList)
C:			long GetCLChar(long)
Machine Language:	d0 = GetCLChar(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			byte = byte from beginning of character list; -1 if no data
-------------------------
GetCLWord
Description:		gets a word from the beginning of a character list
Library:		clist.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			word = GetCLWord(cList)
C:			long GetCLWord(long)
Machine Language:	d0 = GetCLWord(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			word = word from beginning of character list; -1 if no data
-------------------------
GetColorMap
Description:		allocates and initializes a ColorMap structure
Library:		graphics.library
Offset:			-$023A (-570)
Modula-2 Module:	Views
Syntax:			colorMap = GetColorMap(entries)
C:			struct ColorMap *GetColorMap(long)
Machine Language:	d0 = GetColorMap(d0)
Modula-2:		GetColorMap(colorMap: LONGINT): ColorMapPtr
Arguments:		entries = number of entries for this color map
Result:			colorMap = pointer to ColorMap structure; O if unsuccessful
-------------------------  
GetCurrentBinding
Description:		sets static board configuration area
Library:		expansion.library
Offset:			-$008A (-138)
Modula-2 Module:	none
Syntax:			actual = GetCurrentBinding(currentBinding, size)
C:			long GetCurrentBinding(long, long)
Machine Language:	d0 = GetCurrentBinding(a0, d0)
Modula-2:		not available
Arguments:		currentBinding = CurrentBinding structure
			size = size of user's BindDriver structure
Result:			actual = actual size of the CurrentBinding structure
-------------------------
GetDefPrefs
Description:		gets a copy of the default Preferences
Library:		intuition.library
Offset:			-$007E (-126)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = GetDefPrefs(prefBuffer, size)
C:			struct Preferences *GetDefPrefs(struct Preferences *, long)
Machine Language:	d0 = GetDefPrefs(a0, d0)
Modula-2:		GetDefPrefs(prefBuffer: ADDRESS; size: INTEGER): ADDRESS
Arguments:		prefBuffer = buffer to receive copy of default Preferences
			size = size of buffer in bytes
Result:			prefBuffer = pointer to your buffer
-------------------------
GetDiskObject
Description:		reads a Workbench DiskObject (.info file) from disk
Library:		icon.library
Offset:			-$004E (-78)
Modula-2 Module:	Icon
Syntax:			diskObj = GetDiskObject(name)
C:			struct DiskObject *GetDiskObject(char *)
Machine Language:	d0 = GetDiskObject(a0)
Modula-2:		GetDiskObject(name: STRPTR): DiskObjectPtr
Arguments:		name = name of Workbench object (.info file)
Result:			diskObj = pointer to DiskObject structure; 0 if unsuccessful
-------------------------  
GetGBuffers
Description:		attempts to allocate all buffers of an enter AnimOb
Library:		graphics.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Gels
Syntax:			success = GetGBuffers(animOb, rastPort, dBuffer)
C:			long GetGBuffers(struct AnimOb *, struct RastPort *, long)
Machine Language:	d0 = GetGBuffers(a0, a1, d0)
Modula-2:		GetGBuffers(animOb: AnimObPtr; rastPort: RastPortPtr; dBuffer:
			BOOLEAN): BOOLEAN
Arguments:		animOb = AnimOb structure
			rastPort = Rastport structure
			dBuffer = double-buffer flag-TRUE for double-buffering
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
GetIcon
Description:		reads a DiskObject structure from disk
Library:		icon.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			status = GetIcon(name, icon, free)
C:			long GetIcon(char *, struct DiskObject *, struct FreeList *)
Machine Language:	d0 = GetIcon(a0, a1, a2)
Modula-2:		not available
Arguments:		name = name of icon (.info file)
			icon = DiskObject structure
			free = FreeList structure
Result:			status = nonzero if successful
-------------------------
GetMsg
Description:		gets next message from a message port
Library:		exec.library
Offset:			-$0174 (-372)
Modula-2 Module:	Ports
Syntax:			message = GetMsg(port)
C:			struct Message *GetMsg(struct MsgPort *)
Machine Language:	d0 = GetMsg(a0)
Modula-2:		GetMsg(port: MsgPortPtr): ADDRESS
Arguments:		port = receiving message port
Result:			message = pointer to first message; NULL if no message
-------------------------
GetPrefs
Description:		gets Preferences' current settings
Library:		intuition.library
Offset:			-$0084 (-132)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = GetDefPrefs(prefBuffer, size)
C:			struct Preferences *GetDefPrefs(struct Preferences *, long)
Machine Language:	d0 = GetDefPrefs(a0, d0)
Modula-2:		GetDefPrefs(prefBuffer: ADDRESS; size: INTEGER): ADDRESS
Arguments:		prefBuffer = buffer to receive copy of Preferences
			size = size of buffer in bytes
Result:			prefBuffer = pointer to your buffer
-------------------------
GetRGB4
Description:		gets the value of an entry in a ColorMap structure
Library:		graphics.library
Offset:			-$0246 (-582)
Modula-2 Module:	Views
Syntax:			value = GetRGB4(colorMap, entry)
C:			long GetRGB4(struct ColorMap *, long)
Machine Language:	d0 = GetRGB4(a0, d0)
Modula-2:		GetRGB4(colorMap: ColorMapPtr; entry: LONGINT): INTEGER
Arguments:		colorMap = ColorMap structure
			entry = index into color table, specifying desired entry
Result:			value = two-byte, right-justified RGB value with four bits per
			color-red, green, blue; -1 if no valid entry
-------------------------
GetSereenData
Description:		copies all or part of a Screen structure into buffer; opens specifled
			screen if not already open
Library:		intuition.library
Offset:			-$01AA (-426)
Modula-2 Module:	Intuition
Syntax:			success = GetScreenData(buffer, size, type, screen)
C:			long GetScreenData(char *, long, long, struct Screen *)
Machine Language:	d0 = GetScreenData(a0, d0, d1, a1)
Modula-2:		GetScreenData(buffer: ADDRESS; size: CARDINAL; type:
			ScreenFlagSet; screen: ScreenPtr): BOOLEAN
Arguments:		buffer = buffer in which data will be placed
			size = size of buffer in bytes
			type = screen type-CUSTOMSCREEN, WORKBENCHSCREEN
			screen = custom Screen structure; ignored if type argument
			equals WORKBENCHSCREEN

Result:			success = TRUE if successful; FALSE if screen not available and
			could not be opened
-------------------------
GetSprite
Description:		allocates hardware sprite for simple sprite manager
Library:		graphics.library
Offset:			-$0198 (-408)
Modula-2 Module:	Sprites
Syntax:			spriteNumber = GetSprite(sprite, pick)
C:			long GetSprite(struct SimpleSprite *, long)
Machine Language:	d0 = GetSprite(a0, d0)
Modula-2:		GetSprite(sprite: SimpleSpritePtr; pick: INTEGER): INTEGER
Arguments:		sprite = SimpleSprite structure
			pick = number of desired sprite (0-7); -1 for next available
			sprite
Result:			spriteNumber = number of sprite allocated; -1 if sprite
			unavailable
-------------------------
GetWBObject
Description:		reads in a Workbench object from disk
Library:		icon.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			object = GetWBObject(name)
C:			struct WBObject *GetWBObject(char *)
Machine Language:	d0 = GetWBObject(a0)
Modula-2:		not available
Arguments:		name = NULL terminated string that specifies name of Work-
			bench object
Result:			object = pointer to Workbench object; 0 if unsuccessful
------------------------- 
IEEEDPAbs
Description:		obtains the absolute value of an IEEE double-precision floating-
			point number
Library:		mathieeedoubbas.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAbs(fnum2)
C:			double IEEEDPAbs(double)
Machine Language:	d0/d1 = IEEEDPAbs(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = absolute value of fnum2 in IEEE double-precision
			floating-point format
-------------------------
IEEEDPAcos
Description:		obtains the arccosine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAcos(fnum2)
C:			double IEEEDPAcos(double)
Machine Language:	d0/d1 = IEEEDPAcos(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the cosine of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPAdd
Description:		adds two IEEE double-precision floating-point numbers
Library:		mathieeedoubbas.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAdd(fnum2, fnum3)
C:			double IEEEDPAdd(double, d0uble)
Machine Language:	d0/d1 = IEEEDPAdd(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = fnum2 plus fnum3 in IEEE double-precision floating-
			point format
-------------------------
IEEEDPAsin
Description:		obtains the arcsine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			fnum2 = IEEEDPAsin(fnum2)
C:			double IEEEDPAsin(double)
Machine Language:	d0/d1 = IEEEDPAsin(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the sine of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPAtan
Description:		obtains the arctangent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPAtan(fnum2)
C:			double IEEEDPAtan(double)
Machine Language:	d0/d1 = IEEEDPAtan(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing the tangent of an angle
Result:			fnum1 = IEEE double-precision floating-point value of fnum2 an-
			gle in radians
-------------------------
IEEEDPCeil
Description:		obtains the Ceil function of an IEEE double-precision floating-
			point number (rounds it up)
Library:		mathieeedoubbas.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCeil(fnum2)
C:			double IEEEDPCeil(double)
Machine Language:	d0/d1 = IEEEDPCeil(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point integer value that's
			closest to, but not less than the value of fnum2
-------------------------
IEEEDPCmp
Description:		compares two IEEE double-precision floating-point numbers
Library:		mathieeedoubbas.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			flag = IEEEDPCmp(fnum1, fnum2)
C:			long IEEEDPCmp(double, d0uble)
Machine Language:	d0 = IEEEDPCmp(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum1 = IEEE double-precision floating-point number
			fnum2 = IEEE double-precision floating-point number
Result:			flag = -1 if fnum1<fnum2; +1 if fnum1>fnum2; 0 if
			fnum1 = fnum2
-------------------------
IEEEDPCos
Description:		obtains the cosine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCos(fnum2)
C:			double IEEEDPCos(double)
Machine Language:	d0/d1 = IEEEDPCos(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point cosine of fnum2
-------------------------
IEEEDPCosh
Description:		obtains the hyperbolic cosine of an IEEE double-precision float-
			ing-point number
Library:		mathieeedoubtrans.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPCosh(fnum2)
C:			double IEEEDPCosh(double)
Machine Language:	d0/d1 = IEEEDPCosh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic cosine
			of fnum2
-------------------------
IEEEDPDiv
Description:		divides one IEEE double-precision floating-point number by
			another
Library:		mathieeedoubbas.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPDiv(fnum2, fnum3)
C:			double IEEEDPDiv(double, d0uble)
Machine Language:	d0/d1 = IEEEDPDiv(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point dividend
			fnum3 = IEEE double-precision floating-point divisor
Result:			fnum1 = IEEE double-precision floating-point format results of
			fnum2 divided by fnum3
-------------------------
IEEEDPExp
Description:		obtains the exponent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPExp(fnum2)
C:			double IEEEDPExp(double)
Machine Language:	d0/d1 = IEEEDPExp(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point value representing
			e raised to the power of fnum2
-------------------------
IEEEDPFieee
Description:		converts a IEEE single-precision floating-point number to an IEEE
			double-precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPFieee(fnum2)
C:			double IEEEDPFieee(float)
Machine Language:	d0/d1 = IEEEDPFieee(d0)
Modula-2:		not available
Arguments:		fnum2 = IEEE single-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point equivalent to
			fnum2
-------------------------
IEEEDPFix
Description:		converts an IEEE double-precision floating-point number to an
			integer
Library:		mathieeedoubbas.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			inum = IEEEDPFix(fnum)
C:			long IEEEDPFix(double)
Machine Language:	d0 = IEEEDPFix(d0/d1)
Modula-2:		not available
Arguments:		fnum = IEEE double-precision floating-point number
Result:			inum = integer equivalent to fnum
-------------------------
IEEEDPFloor
Description:		obtains the Floor function of an IEEE double-precision floating-
			point number (rounds it down)
Library:		mathieeedoubbas.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPFloor(fnum2)
C:			double IEEEDPFloor(double)
Machine Language:	d0/d1 = IEEEDPFloor(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point integer value that's
			closest to, but not greater than the value of fnum2
-------------------------
IEEEDPFlt
Description:		converts an integer to an IEEE double-precision floating-point
			number
Library:		mathieeedoubbas.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum = IEEEDPFlt(inum)
C:			double IEEEDPFlt(long)
Machine Language:	d0/d1 = IEEEDPFlt(d0)
Modula-2:		not available
Arguments:		inum = signed integer to be converted
Result:			fnum = IEEE double-precision floating-point equivalent to inum
-------------------------
IEEEDPLog
Description:		obtains the natural logarithm of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPLog(fnum2)
C:			double IEEEDPLog(double)
Machine Language:	d0/d1 = IEEEDPLog(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:		        fnum1 = IEEE double-precision floating-point natural logarithm
			(base e) of fnum2
-------------------------
IEEEDPlog10
Description:		obtains the naparian logarithm (base 10) of an IEEE double-
			precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPLog10(fnum2)
C:			double IEEEDPLog10(double)
Machine Language:	d0/d1 = IEEEDPLog10(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point naparian logarithm
			(base 10) of fnum2
-------------------------
IEEEDPMul
Description:		multiplies one IEEE double-precision floating-point number by
			another
Library:		mathieeedoubbas.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPMul(fnum2, fnum3)
C:			double IEEEDPMul(double, d0uble)
Machine Language:	d0/d1 = IEEEDPMul(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = product of fnum2 and fnum3 in IEEE double-precision
			floating-point format
-------------------------
IEEEDPNeg
Description:		negates the value of an IEEE double-precision floating-point number
Library:		mathieeedoubbas.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPNeg(fnum2)
C:			double IEEEDPNeg(double)
Machine Language:	d0/d1 = IEEEDPNeg(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number to negate
Result:			fnum1 = negative fnum2 in IEEE double-precision floating-point
			format
-------------------------
IEEEDPPow
Description:		obtains the exponentiation of two IEEE double-precision floating-
			point numbers
Library:		mathieeedoubtrans.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPPow(fnum2, fnum3)
C:			double IEEEDPPow(double, d0uble)
Machine Language:	d0/d1 = IEEEDPPow(d2/d3, d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point value of fnum2
			raised to the power of fnum3
-------------------------
IEEEDPSin
Description:		obtains the sine of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSin(fnum2)
C:			double IEEEDPSin(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSin(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point sine of fnum2
-------------------------
IEEEDPSincos
Description:		obtains the sine and cosine of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSincos(fnum2, fnum3)
C:			double IEEEDPSincos(double, d0uble *)
Machine Language:	d0/d1 = IEEEDPSincos(d0/d1, a0)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = pointer to an IEEE double-precision floating point num-
			ber to receive the cosine of fnum2
Result:			fnum1 = IEEE double-precision floating-point sine of fnum2 (co-
			sine is returned in fnum3)
-------------------------
IEEEDPSinh
Description:		obtains the hyperbolic sine of an IEEE double-precision floating-
			point number
Library:		mathieeedoubtrans.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSinh(fnum2)
C:			double IEEEDPSinh(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSinh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic sine of
			fnum2
-------------------------
IEEEDPSqrt
Description:		obtains the square root of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSqrt(fnum2)
C:			double IEEEDPSqrt(double)
Machine Language:	d0/d1 = IEEEDPSqrt(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE double-precision floating-point square root of
			fnum2
-------------------------
IEEEDPSub
Description:		subtracts one IEEE double-precision floating-point number from
			another
Library:		mathieeedoubbas.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPSub(fnum2, fnum3)
C:			double IEEEDPSub(double, d0uble)
Machine Language:	d0/d1 = IEEEDPSub(d0/d1, d2/d3)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
			fnum3 = IEEE double-precision floating-point number
Result:			fnum1 = fnum2 minus fnum3 in IEEE double-precision floating-
			point format
-------------------------
IEEEDPTan
Description:		obtains the tangent of an IEEE double-precision floating-point
			number
Library:		mathieeedoubtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTan(fnum2)
C:			double IEEEDPTan(double, d0uble)
Machine Language:	d0/d1 = IEEEDPTan(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point tangent of fnum2
-------------------------
IEEEDPTanh
Description:		obtains the hyperbolic tangent of an IEEE double-precision
			floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTanh(fnum2)
C:			double IEEEDPTanh(double, d0uble)
Machine Language:	d0/d1 = IEEEDPTanh(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number represent-
			ing an angle in radians
Result:			fnum1 = IEEE double-precision floating-point hyperbolic tangent
			of fnum2
------------------------- 
IEEEDPTIeee
Description:		converts an IEEE double-precision floating-point number to an
			IEEE single-precision floating-point number
Library:		mathieeedoubtrans.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			fnum1 = IEEEDPTieee(fnum2)
C:			float IEEEDPTieee(double)
Machine Language:	d0 = IEEEDPTieee(d0/d1)
Modula-2:		not available
Arguments:		fnum2 = IEEE double-precision floating-point number
Result:			fnum1 = IEEE single-precision floating-point equivalent to fnum2
-------------------------
IEEEDPTst
Description:		compares an IEEE double-precision floating-point number with
			zero
Library:		mathieeedoubbas.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			flag = IEEEDPTst(fnum)
C:			long IEEEDPTst(double)
Machine Language:	d0 = IEEEDPTst(d0/d1)
Modula-2:		not available
Arguments:		fnum = IEEE double-precision floating-point number
Result:			flag = -1 if fnum <0; +1 if fnum >0; 0 if fnum=0
-------------------------
IncrCLMark
Description:		increments character list mark to the next position
Library:		clist.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			error = IncrCLMark(cList)
C:			long IncrCLMark(long)
Machine Language:	d0 = IncrCLMark(a0)
Modula-2:      		not available
Arguments:		cList = character list descriptor
Result:			error = 0 if successful; nonzero if next offset is not in the charac-
			ter list
-------------------------
Info
Description:		returns information about a disk or disk file
Library:		dos.library
Offset:			-$0072 (-114)
Modula-2 Module:	DOS
Syntax:			success = Info(lock, infoData)
C:		        long Info(BPTR, struct InfoData *)
Machine Language:	d0 = Info(d1, d2)
Modula-2:		Info(lock: FileLock; infoData: InfoDataPtr): BOOLEAN
Arguments:		lock = BCPL pointer to a lock
			infoData = InfoData structure to be filled
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
InitArea
Description:		initializes vector collection matrix
Library:		graphics.library
Offset:			-$011A (-282)
Modula-2 Module:	Areas
Syntax:			InitArea(areaInfo, buffer, maxVectors)
C:		        long InitArea(struct AreaInfo *, short *, long)
Machine Language:	InitArea(a0, a1, d0)
Modula-2:		InitArea(areaInfo: AreaInfoPtr; buffer: ADDRESS; maxVectors:
			INTEGER)
Arguments:		areaInfo = AreaInfo structure
			buffer = pointer to memory block where vectors will be stored-
			must start on word boundary and should be 5*maxVectors bytes
			long
			maxVectors = maximum number of vectors
Result:			none
-------------------------
InitBitMap
Description:		initializes a BitMap structure
Library:		graphics.library
Offset:			-$0186 (-390)
Modula-2 Module:	Graphics
Syntax:			InitBitMap(bitMap, depth, width, height)
C:			void InitBitMap(struct Bitmap *, long, long, long)
Machine Language:	InitBitMap(a0, d0, d1, d2)
Modula-2:		InitBitMap(bitMap: BitMapPtr; depth, width, height: INTEGER)
Arguments:		bitMap = BitMap structure
			depth = number of bit planes to be used
			width = width of each bit plane in bits
			height = height of each bit plane in lines
Result:			none
-------------------------
InitCLPool
Description:		initializes a character list pool
Library:		clist.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			error = InitCLPool(cLPool, size)
C:			long InitCLPool(long, long)
Machine Language:	d0 = InitCLPool(a0, d0)
Modula-2:		not available
Arguments:		cLPool = data area to be used as character list pool
			size = size of pool in bytes
Result:			error = 0 if successful; nonzero if pool size is too small
-------------------------
InitCode
Description:		initializes resident modules with a startup class value and version
			number
Library:		exec.library
Offset:			-$0048 (-72)
Modula-2 Module: 	Resident
Syntax:			InitCode(startClass, version)
C:			void InitCode(long, long)
Machine Language:	InitCode(d0, d1)
Modula-2:		InitCode(startClass, version: LONGCARD)
Arguments:		startClass = startup class of resident module-COLDSTART,
			COOLSTART, or WARMSTART
			version = version number of resident module
Result:			none
-------------------------
InitGels
Description:		initializes a GEL list
Library:		graphics.library
Offset:			-$0078 (-120)
Modula-2 Module:	Gels
Syntax:			InitGels(head, tail, gelsInfo)
C:			void InitGels(struct VSprite *, struct VSprite *, struct GelsInfo *)
Machine Language:	InitGels(a0, a1, a2)
Modula-2:		InitGels(head, tail: VSpritePtr; gelsInfo: GelsInfoPtr)
Arguments:		head = VSprite structure to be used as head of GEL list
			tail = VSprite structure to be used as tail of GEL list
			gelsInfo = GelsInfo structure to be initialized
Result:			none
-------------------------
InitGMasks
Description:		initializes all masks of an AnimOb structure
Library:		graphics.library
Offset:			-$00AE (-174)
Modula-2 Module:	Gels
Syntax:			InitGMasks(animOb)
C:			void InitGMasks(struct AnimOb *)
Machine Language:	InitGMasks(a0)
Modula-2:		InitGMasks(animOb: AnimObPtr)
Arguments:		animOb = AnimOb structure containing masks to initialize
Result:			none
-------------------------
InitLayers
Description:		initializes a Layer_Info structure
Library:		layers.library
Offset:			-$001E (-30)
Modula-2 Module:	none
Syntax:			InitLayers(layerInfo)
C:			void InitLayers(struct Layer_Info *)
Machine Language:	InitLayers(a0)
Modula-2:		not available
Arguments:		layerInfo = Layer_Info structure to initialize
Result:			none
-------------------------
InitMasks
Description:		initializes the BorderLine and CollMask values used by a VSprite
			structure
Library:		graphics.library
Offset:			-$007E (-126)
Modula-2 Module:	Gels
Syntax:			InitMasks(vSprite)
C:			void InitMasks(struct VSprite *)
Machine Language:	InitMasks(a0)
Modula-2:		InitMasks(vSprite: VSpritePtr)
Arguments:		vSprite = VSprite structure containing BorderLine and CollMask
			values to initialize
Result:			none
-------------------------
InitRastPort
Description:		initializes a RastPort structure
Library:		graphics.library
Offset:			-$00C6 (-198)
Modula-2 Module:	Rasters
Syntax:			InitRastPort(rastPort)
C:			void InitRastPort(struct RastPort *)
Machine Language:	InitRastPort(a1)
Modula-2:		InitRastPort(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure to initialize
Result:			none
-------------------------
InitRequester
Description:		initializes a Requester structure
Library:		intuition.library
Offset:			-$008A (-138)
Modula-2 Module:	Intuition
Syntax:			InitRequester(requester)
C:			void InitRequester(struct Requester *)
Machine Language:	InitRequester(a0)
Modula-2:		InitRequester(requester: RequesterPtr)
Arguments:		requester = Requester structure to initialize
Result:			none
-------------------------
InitResident
Description:		initializes a resident module
Library:		exec.library
Offset:			-$0066 (-102)
Modula-2 Module:	Resident
Syntax:			InitResident(resident, segList)
C:			void InitResident(struct Resident *, char *)

Machine Language:	InitResident(a1, d1)
Modula-2:		InitResident(resident: ResidentPtr; segList: ADDRESS)
Arguments:		resident = Resident structure representing resident module to
			initialize
			segList = a segment list
Result:			none
-------------------------
InitSemaphore
Description:		initializes a SignalSemaphore structure
Library:		exec.library
Offset:			-$022E (-558)
Modula-2 Module:	Semaphores
Syntax:			InitSemaphore(signalSemaphore)
C:			void InitSemaphore(struct SignalSemaphore *)
Machine Language:	InitSemaphore(a0)
Modula-2:		InitSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = SignalSemaphore structure to initialize
Result:			none
-------------------------
InitStruct
Description:		clears an area of memory following rules defined by a table
Library:		exec.library
Offset:			-$004E (-78)
Modula-2 Module:	Memory
Syntax:			InitStruct(initTable, memBlock, size)
C:			void InitStruct(char *, char *, long)
Machine Language:	InitStruct(a1, a2, d0)
Modula-2:		InitStruct(initTable, memBlock: ADDRESS; size: CARDINAL)
Arguments:		initTable = pointer to the commands and data used to initialize
			memory
			memBlock = pointer to memory to be initialized
			size = size of memory to clear before it is initialized with
			initTable; 0 for no initial clearing of memory
Result:			none
-------------------------
InitTmpRas
Description:		initializes chip RAM for use by area-fill, flood-fill, and text
			functions
Library:		graphics.library
Offset:			-$01D4 (-468)
Modula-2 Module:	Rasters
Syntax:			InitTmpRas(tmpRas, buffer, size)
C:			void InitTmpRas(struct TmpRas *, char *, long)
Machine Language:	InitTmpRas(a0, a1, d0)
Modula-2:		InitTmpRas(tmpRas: TmpRasPtr; buffer: PlanePtr; size:
			LONGCARD)
Arguments:		tmpRas = TmpRas structure to be linked into a RastPort
			buffer = pointer to chip RAM memory
			size = size of buffer in bytes
Result:			none
-------------------------
InitView
Description:		initializes a View structure
Library:		graphics.library
Offset:			-$0168 (-360)
Modula-2 Module:	Views
Syntax:			InitView(view)
C:			void InitView(struct View *)
Machine Language:	InitView(a1)
Modula-2:		InitView(view: ViewPtr)
Arguments:		view = View structure to initialize
Result:			none
-------------------------
InitVPort
Description:		initializes a ViewPort structure
Library:		graphics.library
Offset:			-$00CC (-204)
Modula-2 Module:	Views
Syntax:			InitVPort(viewPort)
C:			void InitVPort(struct ViewPort *)
Machine Language:	InitVPort(a0)
Modula-2:      		InitVPort(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure to initialize
Result:			none
-------------------------  
Input
Description:		gets the initial input file handle assigned to a program
Library:		dos.library
Offset:			-$0036 (-54)
Modula-2 Module:	DOS
Syntax:			file = Input( )
C:			BPTR Input(void)
Machine Language:	d0 = Input( )
Modula-2:		Input( ): FileHandle
Arguments:		none
Result:			file = BCPL pointer to a file handle
-------------------------
Insert
Description:		inserts a Node structure into a doubly-linked list
Library:		exec.library
Offset:			-$00EA (-234)
Modula-2 Module:	Lists
Syntax:			Insert(list, node, listNode)
C:			void Insert(struct List *, struct Node *, struct Node *)
Machine Language:	Insert(a0, a1, a2)
Modula-2:		Insert(list: ListPtr; node, listNode: NodePtr)
Arguments:		list = target List header
			node = Node structure to insert
			listNode = node after which to insert; NULL to insert at head
Result:			none
-------------------------
InstallClipRegion
Description:		installs a clip region into a layer
Library:		layers.library
Offset:			-$00AE (-174)
Modula-2 Module:	Layers
Syntax:			oldClipRegion = InstallClipRegion(layer, region)
C:			struct Region *InstallClipRegion(struct Layer *, struct Region *)
Machine Language:	d0 = InstallClipRegion(a0, a1)
Modula-2:		InstallClipRegion(layer: LayerPtr; region: RegionPtr): RegionPtr
Arguments:		layer = Layer structure to which region will be added
			region = Region structure to be added to layer
Result:			oldClipRegion = previous clip region that was installed; NULL if
			no previous clip region
------------------------- 
IntuiTextLength
Description:		returns the pixel width of an IntuiText string
Library:		intuition.library
Offset:			-$014A (-330)
Modula-2 Module:	Intuition
Syntax:			length = IntuiTextLength(intuiText)
C:			long IntuiTextLength(struct IntuiText *)
Machine Language:	d0 = IntuiTextLength(a0)
Modula-2:		IntuiTextLength(intuiText: IntuiTextPtr): CARDINAL
Arguments:		intuiText = IntuiText structure
Result:			length = pixel width of text
-------------------------
Intuition
Description:		sets Intuition's main entry point, where input events arrive and
			are dispatched
Library:		intuition.library
Offset:			-$0024 (-36)
Modula-2 Module:	Intuition
Syntax:			Intuition(inputEvent)
C:			void Intuition(struct InputEvent *)
Machine Language:	Intuition(a0)
Modula-2:		Intuition(inputEvent: InputEventPtr)
Arguments:		inputEvent = first input event in a linked list of InputEvent
			structures
Result:			none
-------------------------
IoErr
Description:		gets extra information from the system
Library:		dos.library
Offset:			-$0084 (-132)
Modula-2 Module:	DOS
Syntax:			error = IoErr( )
C:			long IoErr(void)
Machine Language:	d0 = IoErr( )
Modula-2:		IoErr( ): LONGINT
Arguments:		none
Result:			error = error code or other error information
------------------------- 
IsInteractive
Description:		finds out whether a file is connected to a virtual terminal
Library:		dos.library
Offset:			-$00D8 (-216)
Modula-2 Module:	DOS
Syntax:			status = IsInteractive(file)
C:			long IsInteractive(BPTR)
Machine Language:	d0 = IsInteractive(d1)
Modula-2:		IsInteractive(file: FileHandle): BOOLEAN
Arguments:		file = BCPL pointer to a file handle
Result:			status = TRUE if file is connected to a virtual terminal; FALSE if
			not
-------------------------
ItemAddress
Description:		returns address of specified MenuItem
Library:		intuition.library
Offset:			-$0090 (-144)
Modula-2 Module:	Intuition
Syntax:			address = ItemAddress(menuStrip, menuNumber)
C:			struct MenuItem *ItemAddress(struct Menu *, long)
Machine Language:	d0 = ItemAddress(a0, d0)
Modula-2:		ItemAddress(menuStrip: MenuPtr; menuNumber: CARDINAL):
			MenuItemPtr
Arguments:		menuStrip = first menu in your menu strip
			menuNumber = value with packed data that specifies the menu
			and item (and optionally subitem)
Result:			address = pointer to specified MenuItem; NULL if menuNumber
			equals NULL
-------------------------
ITEMNUM (macro)
Description:		extracts the menu item number from a value
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	Intuition
Syntax:			itemNumber = ITEMNUM(menuValue)
C:			long ITEMNUM(long)
Machine Language:	not available
Modula-2:		ITEMNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			itemNumber = item number (0-63); equals NOITEM if no menu
			was selected
-------------------------
LoadRGB4
Description:		loads color register values from a data table
Library:		graphics.library
Offset:			-$00C0 (-192)
Modula-2 Module:	Views
Syntax:			LoadRGB4(viewPort, colormap, pens)
C:			void LoadRGB4(struct ViewPort *, short *, long)
Machine Language:	LoadRGB4(a0, a1, d0)
Modula-2:		LoadRGB4(viewPort: ViewPortPtr; colormap: ADDRESS; pens:
			INTEGER)
Arguments:		viewPort = ViewPort whose colors you want to change
			colormap = pointer to array of 16-bit color values, where the firs
			four bits are zero, the second contains red, the third green, and
			the fourth blue
			pens = number of consecutive color registers to load
Result:			none
-------------------------
LoadSeg
Description:		loads an AmigaDOS load module into memory
Library:		dos.library
Offset:			-$0096 (-150)
Modula-2 Module:	DOSLoader
Syntax:			segment = LoadSeg(name)
C:			BPTR LoadSeg(char *)
Machine Language:	d0 = LoadSeg(d1)
Modula-2:		LoadSeg(name: STRPTR): BPTR
Arguments:		name = NULL terminated string that specifies the filename of
			load module
Result:			segment = BCPL pointer to a segment; 0 if unsuccessful
-------------------------
LoadView
Description:		creates a display using a new copper list
Library:		graphics.library
Offset:			-$00DE (-222)
Modula-2 Module:	Views
Syntax:			LoadView(view)
C:			void LoadView(struct View *)
Machine Language:	LoadView(a1)
Modula-2:		LoadView(view: ViewPtr)
Arguments:		view = View structure with pointer to copper list
Result:			none
-------------------------
Lock
Description:		locks a directory or file
Library:		dos.library
Offset:			-$0054 (-84)
Modula-2 Module:	DOS
Syntax:			lock = Lock(name, accessMode)
C:			BPTR Lock(char *, long)
Machine Language:	d0 = Lock(d1, d2)
Modula-2:		Lock(name: STRPTR; accessMode: LONGINT): FileLock
Arguments:		name = NULL terminated string that specifies name of file or
			directory
			accessMode = type of lock-ACCESS_READ (shared) or
			ACCESS_WRITE (exclusive)
Result:			lock = BCPL pointer to a lock
-------------------------
LockIBase
Description:		locks IntuitionBase to keep other tasks (or the system) from
			changing it
Library:		intuition.library
Offset:			-$019E (-414)
Modula-2 Module:	IntuitionBase
Syntax:			lockValue = LockIBase(lockNumber)
C:			long LockIBase(long)
Machine Language:	d0 = LockIBase(d0)
Modula-2:		LockIBase(lockNumber: LONGCARD): LONGCARD
Arguments:		lockNumber = Intuition lock desired (should be zero)
Result:			lockValue = value to use to unlock IntuitionBase via
			UnlockIBase( )
-------------------------
LockLayer
Description:		locks a layer to protect it from graphics output
Library:		layers.library
Offset:			-$0060 (-96)
Modula-2 Module:	Layers
Syntax:			LockLayer(dummy, layer)
C:			void LockLayer(struct Layer_Info *, struct Layer *)
Machine Language:	LockLayer(a0, a1)
Modula-2:		LockLayer(layer: LayerPtr)
Arguments:		dummy = unused
			layer = Layer structure
Result:			none
-------------------------
LockLayerInfo
Description:		locks a Layer_Info structure to keep other tasks from changing it
Library:		layers.library
Offset:			-$0078 (-120)
Modula-2 Module:	Layers
Syntax:			LockLayerInfo(layerInfo)
C:			void LockLayerInfo(struct Layer_Info *)
Machine Language:	LockLayerInfo(a0, a1)
Modula-2:		LockLayerInfo(layerInfo: LayerInfoPtr)
Arguments:		layerInfo = Layerlnfo structure to lock
Result:			none
-------------------------
LockLayerRom
Description:		locks a Layer structure to keep other tasks from changing it
Library:		layers.library
Offset:			-$01B0 (-432)
Modula-2 Module:	Clip
Syntax:			LockLayerRom(layer)
C:			void LockLayerRom(struct Layer *)
Machine Language:	LockLayerRom(a5)
Modula-2:      		LockLayerRom(layer: LayerPtr)
Arguments:		layer = Layer structure to lock
Result:			none
-------------------------
LockLayers
Description:		stops graphic output to all layers in a Layer_Info structure
Library:		layers.library
Offset:			-$006C (-108)
Modula-2 Module:	Layers
Syntax:			LockLayers(layerInfo)
C:		        void LockLayers(struct Layer_Info *)
Machine Language:	LockLayers(a0)
Modula-2:		LockLayers(layerInfo: LayerInfoPtr)
Arguments:		layerlnfo = Layerlnfo structure with list of layers to lock
Result:			none
-------------------------
MakeDosNode
Description:		initializes the DeviceNode structure required to enter a DOS disk
			device into the system
Library:		expansion.library
Offset:			-$0090 (-144)
Modula-2 Module:	Expansion
Syntax:			deviceNode = MakeDosNode(parameterPacket)
C:           		struct DeviceNode *MakeDosNode(long *)
Machine Language:	d0 = MakeDosNode(a0)
Modula-2:		MakeDosNode(parameterPacket: ADDRESS): DeviceNodePtr
Arguments:		parameterPacket = array of long words containing the DOS han-
			dler name, exec device name, unit number (for OpenDevice( )),
			flags (for OpenDevice( )), number of long words used to describe
			the handler environment, and the file handler environment, in
			that order.
Result:			deviceNode = pointer to initialized DeviceNode structure; NULL
			if not enough memory
-------------------------
MakeFunctions
Description:		constructs a jump table of the type used by resources, libraries,
			and devices
Library:		exec.library
Offset:			-$005A (-90)
Modula-2 Module:	Libraries
Syntax:			size = MakeFunctions(destination, funcArray, funcDispBase)
C:			void MakeFunctions(char *, long *, long)
Machine Language:	d0 = MakeFunctions(a0, a1, a2)
Modula-2:		MakeFunctions(destination, funcArray, funcDispBase: ADDRESS):
			LONGCARD
Arguments:		destination = target address for function jump table
			funcArray = pointer to array of function pointers or
			displacements
			funcDispBase = pointer to base about which all function displace-
			ments are relative; 0 if functionArray contains absolute pointers
Result:			size = size of new table in bytes (Modula-2 only)
-------------------------
MakeLibrary
Description:		constructs a library vector and data area
Library:		exec.library
Offset:			-$0054 (-84)
Modula-2 Module:	Libraries
Syntax:			library = MakeLibrary(vectors, structure, init, dataSize, segList)
C:			struct Library *MakeLibrary(long *, char *, _fptr, long, char *)
Machine Language:	d0 = MakeLibrary(a0, a1, a2, d0, d1)
Modula-2:		MakeLibrary(vectors, structure: ADDRESS; init: MAKELIBPROC;
			dataSize: LONGCARD; segList: ADDRESS): LibraryPtr
Arguments:		vectors = pointer to an array of function displacements-if first
			word is -1 array contains relative word displacements; otherwise
			array contains absolute function pointers
			structure = pointer to an InitStruct data region; can be NULL
			init = entry point that will be called before adding the library;
			can be NULL
			dataSize = size of library data area, including the standard library
			node data
			segList = pointer to a memory segment list (used by DOS)
Result:			library = reference address of library
-------------------------
MakeScreen
Description:		executes an Intuition-integrated MakeVPort( ) of a custom screen
Library:		intuition.library
Offset:			-$017A (-378)
Modula-2 Module:	Intuition
Syntax:			MakeScreen(screen)
C:			void MakeScreen(struct Screen *)
Machine Language:	MakeScreen(a0)
Modula-2:		MakeScreen(screen: ScreenPtr)
Arguments:		screen = custom screen
Result:			none
-------------------------
MakeVPort
Description:		constructs intermediate copper list for a ViewPort
Library:		graphics.library
Offset:			-$00D8 (-216)
Modula-2 Module:	Views
Syntax:			MakeVPort(view, viewPort)
C:			void MakeVPort(struct View *, struct ViewPort *)
Machine Language:	MakeVPort(a0, a1)
Modula-2:		MakeVPort(view: ViewPtr; viewPort: ViewPortPtr)
Arguments:		view = View structure
			viewPort = ViewPort structure
Result:			none
-------------------------
MarkCList
Description:		marks a position in a character list
Library:		clist.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			error = MarkCList(cList, offset)
C:			long MarkCList(long, long)
Machine Language:	d0 = MarkCList(a0, a1)
Modula-2:		not available
Arguments:		cList = CList descriptor
			offset = byte offset into character list of position to mark
Result:			error = 0 if successful; nonzero if offset not in character list
-------------------------
MatchToolValue
Description:		checks a tool type variable for a particular value
Library:		icon.library
Offset:			-$0066 (-102)
Modula-2 Module:	Icon
Syntax:			result = MatchToolValue(typeString, value)
C:			long MatchToolValue(char *, char *)
Machine Language:	d0 = MatchToolValue(a0, a1)
Modula-2:		MatchToolValue(typeString, value: STRPTR): BOOLEAN
Arguments:		typeString = a ToolType value, as returned by FindToolType(
			value = value you are looking for
Result:			result = 0 if successful; nonzero if unsuccessful
------------------------- 
MENUNUM (macro)
Description:		extracts the menu number from a value
C Include File: 	include/intuition/intuition.h
ML Include File: 	none
Modula-2 Module:	Intuition
Syntax:			menuNumber = MENUNUM(menuValue)
C:			long MENUNUM(long)
Machine Language:	not available
Modula-2:		MENUNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			menuNumber = menu number (0-31); equals NOMENU if no
			menu was selected
-------------------------
ModifyIDCMP
Description:		modifies the state of a window's IDCMP
Library:		intuition.library
Offset:			-$0096 (-150)
Modula-2 Module:	Intuition
Syntax:			ModifyIDCMP(window, flags)
C:			void ModifyIDCMP(struct Window *, long)
Machine Language:	ModifyIDCMP(a0, d0)
Modula-2:		ModifyIDCMP(window: WindowPtr; flags: IDCMPFlagsSet)
Arguments:		window = window containing IDCMP
			flags = IDCMP flags
Result:			none
-------------------------
ModifyProp
Description:		modifies current state of proportional gadgets (see
			NewModifyProp)
Library:		intuition.library
Offset:			-$009C (-156)
Modula-2 Module:	Intuition
Syntax:			ModifyProp(propGadget, window, requester, flags, horizPot,
			vertPot, horizBody, vertBody)
C:			void ModifyProp(struct Gadget *, struct Window *, struct Request-
			er *, long, long, long, long, long)
Machine Language:	ModifyProp(a0, a1, a2, d0, d1, d2, d3, d4)
Modula-2:		ModifyProp(propGadget: GadgetPtr; window: WindowPtr; re-
			quester: RequesterPtr; flags: PropFlagSet; horizPot, vertPot,
			horizBody, vertBody: CARDINAL)
Arguments:		propGadget = proportional gadget to modify
			window = window containing proportional gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
			flags = new flags value
			horizPot = new horizontal pot value (position)
			vertPot = new vertical pot value (position)
			horizBody = new horizontal body value (size of slider)
			vertBody = new vertical body value (size of slider)
Result:			none
-------------------------
Move
Description:		moves the drawing pen to the specified position without drawing
			anything
Library:		layers.library
Offset:			-$00F0 (-240)
Modula-2 Module:	Drawing
Syntax:			Move(rastPort, x, y)
C:			void Move(struct RastPort *, long, long)
Machine Language:	Move(a0, d0, d1)
Modula-2:		Move(rastPort: RastPortPtr; x, y: INTEGER)
Arguments:		rastPort = RastPort structure
			x = new horizontal coordinate
			y = new vertical coordinate
Result:			none
-------------------------
MoveLayer
Description:		moves a nonbackdrop layer to a new position in the bitmap
Library:		layers.library
Offset:			-$003C (-60)
Modula-2 Module:	Layers
Syntax:			success = MoveLayer(dummy, layer, dx, dy)
C:			long MoveLayer(struct Layerlnfo *, struct Layer *, long, long)
Machine Language:	d0 = MoveLayer(a0, a1, d0, d1)
Modula-2:		MoveLayer(layer: LayerPtr; dx, dy: LONGINT): BOOLEAN
Arguments:		dummy = unused
			layer = nonbackdrop Layer structure
			dx = offset by which to move layer horizontally
			dy = offset by which to move layer vertically
Result:			success = TRUE is successful; FALSE if unsuccessful
-------------------------
MoveLayerInFrontOf
Description:		moves a layer in front of another layer
Library:		layers.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Layers
Syntax:			success = MoveLayerInFrontOf(layer, target)
C:			long MoveLayerInFrontOf(struct Layer *, struct Layer *)
Machine Language:	d0 = MoveLayerInFrontOf(d0, a1)
Modula-2:		MoveLayerInFrontOf(layer, target: LayerPtr): BOOLEAN
Arguments:		layer = layer to move
			target = layer to have another layer placed on top of
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
MoveScreen
Description:		moves a screen vertically
Library:		intuition.library
Offset:			-$00A2 (-162)
Modula-2 Module:	Intuition
Syntax:			MoveScreen(screen, dx, dy)
C:			void MoveScreen(struct Screen *, long, long)
Machine Language:	MoveScreen(a0, d0, a1)
Modula-2:		MoveScreen(screen: ScreenPtr; dx, dy: INTEGER)
Arguments:		screen = screen to move
			dx = offset by which to move screen horizontally
			dy = offset by which to move screen vertically (not implemented
			as of system version 1.3)
Result:			none
-------------------------
MoveSprite
Description:		moves a sprite to specified location
Library:		graphics.library
Offset:			-$01AA (-426)
Modula-2 Module:	Sprites
Syntax:			MoveSprite(viewPort, sprite, x, y)
C:			long MoveSprite(struct ViewPort *, struct SimpleSprite *, long,
			long)
Machine Language:	MoveSprite(a0, a1, d0, d1)
Modula-2:		MoveSprite(viewPort: ViewPortPtr; sprite: SimpleSpritePtr; x, y:
			INTEGER)
Arguments:		viewPort = ViewPort structure
			sprite = SimpleSprite structure
			x = new horizontal position of sprite
			y = new vertical position of sprite
Result:			none
-------------------------
MoveWindow
Description:		moves a window
Library:		intuition.library
Offset:			-$00A8 (-168)
Modula-2 Module:	Intuition
Syntax:			MoveWindow(window, dx, dy)
C:			void MoveWindow(struct Window *, long, long)
Machine Language:	MoveWindow(a0, d0, a1)
Modula-2:		MoveWindow(window: WindowPtr; dx, dy: INTEGER)
Arguments:		window = window to move
			dx = offset by which to move window horizontally
			dy = offset by which to move window vertically
Result:			none
-------------------------
MrgCop
Description:		merges coprocessor instructions to form one instruction list
Library:		graphics.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Views
Syntax:			MrgCop(view)
C:			void MrgCop(struct View *)
Machine Language:	MrgCop(a1)
Modula-2:		MrgCop(view: ViewPtr)
Arguments:		view = View structure
Result:			none
-------------------------
NewFontContents
Description:		creates an array of FontContents entries describing all fonts asso-
			ciated with specified font name
Library:		diskfont.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fontContentsHeader = NewFontContents(fontsLock, fontName)
C:			struct FontContentsHeader *NewFontContents(BPTR, char *)
Machine Language:	d0 = NewFontContents(a0, a1)
Modula-2:		not available
Arguments:		fontsLock = BCPL pointer to a lock on the directory containing
			the fonts contents file (usually FONTS: directory)
			fontName = filename of font contents file (for example,
			"Diamond.font")
Result:			fontContentsHeader = pointer to a FontContentsHeader
-------------------------
NewLayerInfo
Description:		creates a Layer_Info structure
Library:		layers.library
Offset:			-$0090 (-144)
Modula-2 Module:	Layers
Syntax:			layerInfo = NewLayerInfo( )
C:			struct Layer_Info *NewLayerInfo(void)
Machine Language:	d0 = NewLayerInfo( )
Modula-2:		NewLayerInfo( ): LayerInfoPtr
Arguments:		none
Result:			layerInfo = pointer to initialized Layer_Info structure; NULL if
			unsuccessful
-------------------------
NewList
Description:		initializes a list header
Library:		amiga.lib (linked library)
ML Include File:	none
Modula-2 Module:	Lists
Syntax:			NewList(list)
C:			void NewList(struct List *)
Machine Language:	not available
Modula-2:		NewList(VAR list: List)
Arguments:		list = List structure
Result:			none
-------------------------
NewModifyProp
Description:		modifies current state of proportional gadgets, with selective gad-
			get refresh
Library:		intuition.library
Offset:			-$01D4 (-468)
Modula-2 Module:	Intuition
Syntax:			NewModifyProp(propGadget, window, requester, flags, horizPot, 
			vertPot, horizBody, vertBody, gadgetNumber)
C:		        void NewModifyProp(struct Gadget *, struct Window *, struct Re-
			quester *, long, long, long, long, long, long)
Machine Language:	NewModifyProp(a0, a1, a2, d0, d1, d2, d3, d4, d5)
Modula-2:		NewModifyProp(propGadget: GadgetPtr; window: WindowPtr; re-
			quester: RequesterPtr; flags: PropFlagSet; horizPot, vertPot,
			horizBody, vertBody: CARDINAL; gadgetNumber: INTEGER)
Arguments:		propGadget = proportional gadget to modify
			window = window containing proportional gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
			flags = new flags value
			horizPot = new horizontal pot value (position)
			vertPot = new vertical pot value (position)
			horizBody = new horizontal body value (size of slider)
			vertBody = new vertical body value (size of slider)
			gadgetNumber = number of gadgets to refresh after gadget modi-
			fication; -1 to refresh all gadgets to the end of gadget list
Result:			none
-------------------------
NewRegion
Description:		creates an empty Region structure
Library:		graphics.library
Offset:			-$0204 (-516)
Modula-2 Module:	Regions
Syntax:			region = NewRegion( )
C:		        struct Region *NewRegion(void)
Modula-2:		NewRegion(VAR list: List)
			NewRegion( ): RegionPrt
Arguments:		none
Result:			region = pointer to initialized Region structure; NULL if not
			enough memory
-------------------------
ObtainConfigBinding 
Description:		attempts to get permission to bind drivers 
Library:		expansion.library 
Offset:			-$0078 (-120) 
Modula-2 Module:	none
Syntax:			ObtainConfigBinding( )
C:			void ObtainConfigBinding(void)
Machine Language:	ObtainConfigBinding( )
Modula-2:		not available
Arguments:		none
Result:			none
------------------------
ObtainSemaphore
Description:		obtains exclusive use of a signal semaphore
Library:		exec.library
Offset:			-$0234 (-564)
Modula-2 Module:	Semaphores
Syntax:			ObtainSemaphore(signalSemaphore)
C:			void ObtainSemaphore(struct SignalSemaphore *)
Machine Language:	ObtainSemaphore(a0)
Modula-2:      		ObtainSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
ObtainSemaphoreList
Description:		obtains exclusive use of a list of signal semaphores
Library:		exec.library
Offset:			-$0246 (-582)
Modula-2 Module:	Semaphores
Syntax:			ObtainSemaphoreList(list)
C:			void ObtainSemaphoreList(struct List *)
Machine Language:	ObtainSemaphoreList(a0)
Modula-2:		ObtainSemaphoreList(list: SignalSemaphorePtr)
Arguments:		list = List structure representing a list of signal semaphores
Result:			none
-------------------------
OFFDISPLAY (macro)
Description:		clears the display DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			OFF_DISPLAY( )
C:			void OFF_DISPLAY(void)
Machine Language:	not available
Modula-2:		OFFDISPLAY( )
Arguments:		none
Result:			none
-------------------------
OffGadget
Description:		disables a gadget
Library:		intuition.library
Offset:			-$00AE (-174)
Modula-2 Module:	Intuition
Syntax:			OffGadget(gadget, window, requester)
C:			void OffGadget(struct Gadget , struct Window *, struct Requester *)
Machine Language:	OffGadget(a0, a1, a2)
Modula-2:		OffGadget(gadget: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr)
Arguments:		gadget = gadget to disable
			window = window containing gadget
			requester = Requester structure; NULL if gadget is not part of a
			requester
Result:			none
-------------------------
OffMenu
Description:		disables a menu or menu item
Library:		intuition.library
Offset:			-$00B4 (-180)
Modula-2 Module:	Intuition
Syntax:			OffMenu(window, menuNumber)
C:			void OffMenu(struct Window *, long)
Machine Language:	OffMenu(a0, d0)
Modula-2:		OffMenu(window: WindowPtr; menuNumber: CARDINAL)
Arguments:		window = window containing menu or menu item
			menuNumber = number specifying menu or menu item to dis-
			able-bits 0-4 specify menu number, bits 5-10 specify menu
			item, and bits 11-15 specify menu subitems
Result:			none
-------------------------
OFF_SPRITE (macro)
Description:		clears the sprite DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			OFF_SPRITE( )
C:			void OFF_SPRITE(void)
Machine Language:	not available
Modula-2:		OFFSPRITE( )
Arguments:		none
Result:			none
-------------------------
OFF_VBLANK (macro) 
Description:		clears the vertical blanking interrupt (bit 5) in the interrupt control 
			register 
C Include File: 	include/graphics/gfxmacros.h 
ML Include File: 	none 
Modula-2 Module:	none 
Syntax:			OFF_VBLANK( ) 
C:			void OFF_VBLANK(void) 
Machine Language:	not available
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
OldOpenLibrary
Description:		obsolete version of the OpenLibrary( ) function which gains access
			to a library without requiring a version number; do not use this
			function-use OpenLibrary( ) instead
Library:		exec.library
Offset:			-$0198 (-408)
Modula-2 Module:	none
Syntax:			library = Old0penLibrary(name)
C:			struct Library *Old0penLibrary(char *)
Machine Language:	d0 = Old0penLibrary(a1)
Modula-2:		not available
Arguments:		name = name of desired library
Result:			library = base pointer to desired library; NULL if library cannot
			be found
-------------------------
ON_DISPLAY (macro)
Description:		sets the display DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			ON_DISPLAY( )
C:			void ON_DISPLAY(void)
Machine Language:	not available
Modula-2:		ONDISPLAY( )
Arguments:		none
Result:			none
-------------------------
OnGadget
Description:		enables a gadget
Library:		intuition.library
Offset:			-$00BA (-186)
Modula-2 Module:	Intuition
Syntax:			OnGadget(gadget, window, requester)
C:			void OnGadget(struct Gadget *, struct Window *, struct Requester *)
Machine Language:	OnGadget(a0, a1, a2)
Modula-2:		OnGadget(gadget: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr)
Arguments:		gadget = gadget to enable
			window = window containing gadget
requester = Requester structure; NULL if gadget is not part of a
			requester
Result:			none
-------------------------
OnMenu
Description:		enables a menu or menu item
Library:		intuition.library
Offset:			-$00C0 (-192)
Modula-2 Module:	Intuition
Syntax:			OnMenu(window, menuNumber)
C:			void OnMenu(struct Window *, long)
Machine Language:	OnMenu(a0, d0)
Modula-2:		OnMenu(window: WindowPtr; menuNumber: CARDINAL)
Arguments:		window = window containing menu or menu item
			menuNumber = number specifying menu or menu item to en-
			able-bits 0-4 specify menu number, bits 5-10 specify menu
			item, and bits 11-15 specify menu subitems
Result:			none	
-------------------------  
ON_SPRITE (macro)
Description:		sets the sprite DMA bit in the DMA control register
C Include File: 	include/graphics/gfxmacros.h
ML Include File: 	none
Modula-2 Module:	CustomHardware
Syntax:			ON_SPRITE( )
C:			void ON_SPRITE(void)
Machine Language:	ON_SPRITE( )
Modula-2:		ONSPRITE( )
Arguments:		none
Result:			none
-------------------------
ON_VBLANK (macro) 
Description:		sets the vertical blanking interrupt (bit 5) in the interrupt control 
			register 
C Include File: 	include/graphics/gfxmacros.h 
ML Include File: 	none 
Modula-2 Module:	none 
Syntax:			ON_VBLANK( ) 
C:			void ON_VBLANK(void) 
Machine Language:	ON_VBLANK( )
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
Open
Description:		opens a file for input or output
Library:		dos.library
Offset:			-$001E (-30)
Modula-2 Module:	DOS
Syntax:			file = Open(name, accessMode)
C:			BPTR Open(char *, long)
Machine Language:	d0 = Open(d1, d2)
Modula-2:		Open(name: STRPTR; accessMode: LONGINT): FileHandle
Arguments:		name = NULL terminated string specifying filename
			accessMode = type of file access desired-MODE_OLDFILE for
			reading, MODE_NEWFILE for writing
Result:			file = BCPL pointer to file handle; NULL if unsuccessful
-------------------------
OpenDevice
Description:		provides access to a device and initializes an IO request block for
			access to the device
Library:		exec.library
Offset:			-$01BC (-444)
Modula-2 Module:	Devices
Syntax:			error = OpenDevice(name, unitNumber, ioRequest, flags)
C:			long OpenDevice(char *, long, struct IORequest *, long)
Machine Language:	d0 = OpenDevice(a0, d0, a1, d2)
Modula-2:		OpenDevice(name: STRPTR; unitNumber: LONGCARD;
			ioRequest: ADDRESS; flags: LONGBITSET): INTEGER
Arguments:		name = NULL terminated string specifying device name
			unitNumber = desired unit number for device (device specific)
			ioRequest = IORequest block to initialize
			flags = additional device information (device specific)
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
OpenDiskFont
Description:		gains access to a disk-resident font
Library:		diskfont.library
Offset:			-$001E (-30)
Modula-2 Module:	DiskFont
Syntax:			font = OpenDiskFont(textAttr)
C:			struct TextFont *OpenDiskFont(struct TextAttr *)
Machine Language:	d0 = OpenDiskFont(a0)
Modula-2:		OpenDiskFont(textAttr: TextAttrPtr): TextFontPtr
Arguments:		textAttr = TextAttr structure that describes the desired font
Result:			font = pointer to desired TextFont structure; 0 if unsuccessful
-------------------------
OpenFont
Description:		gains access to a memory-resident font
Library:		graphics.library
Offset:			-$0048 (-72)
Modula-2 Module:	Text
Syntax:			font = OpenFont(textAttr)
C:			struct TextFont *OpenFont(struct TextAttr *)
Machine Language:	d0 = OpenFont(a0)
Modula-2:		OpenFont(textAttr: TextAttrPtr): TextFontPtr
Arguments:		textAttr = TextAttr structure that describes the desired font
Result:			font = pointer to desired TextFont structure; 0 if unsuccessful
------------------------- 
OpenLibrary
Description:		gains access to a library
Library:		exec.library
Offset:			-$0228 (-552)
Modula-2 Module:	Libraries
Syntax:			library = OpenLibrary(name, version)
C:			struct Library *OpenLibrary(char *, long)
Machine Language:	d0 = OpenLibrary(a1, d0)
Modula-2:		OpenLibrary(name: STRPTR; version: LONGCARD): LibraryPtr
Arguments:		name = name of desired library
			version = lowest acceptable library version number; 0 if you
			don't care
Result:			library = base pointer to desired library; NULL if library cannot
			be found
-------------------------
OpenResource
Description:		gains access to a resource
Library:		exec.library
Offset:			-$01F2 (-498)
Modula-2 Module:	Resources
Syntax:			resource = OpenResource(name)
C:			struct Resource *OpenResource(char *)
Machine Language:	d0 = OpenResource(a1)
Modula-2:		OpenResource(name: STRPTR): ResourcePtr
Arguments:		name = name of desired resource
Result:			resource = pointer to resource; NULL if unsuccessful
-------------------------
OpenScreen
Description:		opens an Intuition screen
Library:		intuition.library
Offset:			-$00C6 (-198)
Modula-2 Module:	Intuition
Syntax:			screen = OpenScreen(newScreen)
C:			struct Screen *OpenScreen(struct NewScreen *)
Machine Language:	d0 = OpenScreen(a0)
Modula-2:		OpenScreen(newScreen: NewScreenPtr): ScreenPtr
Arguments:		newScreen = NewScreen structure that describes screen to open
Result:			screen = pointer to Screen structure; NULL if unsuccessful
------------------------- 
OpenWindow
Description:		opens an Intuition window
Library:		intuition.library
Offset:			-$00CC (-204)
Modula-2 Module:	Intuition
Syntax:			window = OpenWindow(newWindow)
C:			struct Window *OpenWindow(struct NewWindow *)
Machine Language:	d0 = OpenWindow(a0)
Modula-2:		OpenWindow(newWindow: NewWindowPtr): WindowPtr
Arguments:		newWindow = NewWindow structure that describes window to
			open
Result:			window = pointer to Window structure; NULL if unsuccessful
-------------------------
OpenWorkBench
Description:		opens the Workbench screen
Library:		intuition.library
Offset:			-$00D2 (-210)
Modula-2 Module:	Intuition
Syntax:			success = OpenWorkBench( )
C:			long OpenWorkBench(void)
Machine Language:	d0 = OpenWorkBench( )
Modula-2:		OpenWorkBench( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if successful (value represents pointer to Work-
			Bench screen-this may change in system versions greater than
			1.3); FALSE (NULL) if unsuccessful
-------------------------
OrRectRegion
Description:		performs a two-dimensional OR operation of a rectangle with a
			region, leaving the result in the region
Library:		graphics.library
Offset:			-$01FE (-510)
Modula-2 Module:	Regions
Syntax:			success = OrRectRegion(region, rectangle)
C:			long OrRectRegion(struct Region *, struct Rectangle *)
Machine Language:	d0 = OrRectRegion(a0, a1)
Modula-2:		OrRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			success = TRUE if successful; FALSE if unsuccessful
------------------------- 
OrRegionRegion
Description:		performs a two-dimensional OR operation of one region with a
			second region, leaving the result in second region
Library:		graphics.library
Offset:			-$0264 (-612)
Modula-2 Module:	Regions
Syntax:			success = OrRegionRegion(region1, region2)
C:			long OrRegionRegion(struct Region *, struct Region *)
Machine Language:	d0 = OrRegionRegion(a0, a1)
Modula-2:		OrRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
Output
Description:		gets the initial output file handle assigned to a program
Library:		dos.library
Offset:			-$003C (-60)
Modula-2 Module:	DOS
Syntax:			file = Output( )
C:			BPTR Output(void)
Machine Language:	d0 = Output( )
Modula-2:		Output( ): FileHandle
Arguments:		none
Result:			file = BCPL pointer to a file handle
-------------------------
OwnBlitter
Description:		reserves the blitter for private use
Library:		graphics.library
Offset:			-$01C8 (-456)
Modula-2 Module:	Blitter
Syntax:			OwnBlitter( )
C:			void OwnBlitter(void)
Machine Language:	OwnBlitter( )
Modula-2:		OwnBlitter( )
Arguments:		none
Result:			none
------------------------- 
ParentDir
Description:		obtains the parent directory of a file or directory
Library:		dos.library
Offset:			-$00D2 (-210)
Modula-2 Module:	DOS
Syntax:			lock = ParentDir(lock)
C:			BPTR ParentDir(BPTR)
Machine Language:	d0 = ParentDir(d1)
Modula-2:		ParentDir(lock: FileLock): FileLock
Arguments:		lock = BCPL pointer to lock associated with child file or directory
Result:			lock = BCPL pointer to lock associated with parent directory
-------------------------
PeekCLMark
Description:		gets byte located in mark position of a character list
Library:		clist.library
Offset:			-$0084 (-132)
Modula-2 Module:	none
Syntax:			byte = PeekCLMark(cList)
C:			long PeekCLMark(long)
Machine Language:	d0 = PeekCLMark(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor
Result:			byte = byte located in mark position of character list
-------------------------
Permit
Description:		permits task rescheduling halted by Forbid( )
Library:		exec.library
Offset:			-$008A (-138)
Modula-2 Module:	Interrupts
Syntax:			Permit( )
C:			void Permit(void)
Machine Language:	Permit( )
Modula-2:		Permit( )
Arguments:		none
Result:			none
-------------------------
PolyDraw
Description:		draws a series of connected lines from current pen position to
			points specified by a table of (x,y) coordinates
Library:		graphics.library
Offset:			-$0150 (-336)
Modula-2 Module:	Pens
Syntax:			PolyDraw(rastPort, count, array)
C:			long PolyDraw(struct RastPort *, long, short *)
Machine Language:	PolyDraw(al, d0, a0)
Modula-2:		PolyDraw(rastPort: RastPortPtr; count: INTEGER; array:
			ADDRESS)
Arguments:		rastPort = RastPort to draw lines in
			count = number of coordinates in array
			array = pointer to array of coordinates
Result:			none
-------------------------
printf
Description:		prints a formatted string to the standard output (Lattice and Manx
			users: if you link with lc.lib or c.lib, this is not the function you're
			calling)
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			printf(string, values...)
C:			void printf(char *, long...)
Machine Language:	move.l #value,-(sp) ;may have several values 
			pea string 
			jsr _printf 
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available
Arguments:		string = string containing optional C formatting commands (%); if
			you're passing longword values on the stack (as shown above) be
			sure to follow the percent symbol with a lowercase L
			values = values or addresses of strings to print; this routine
			knows how many values are on the stack by checking the number
			of formatting commands in the string argument
Result:			none
-------------------------
PrintIText
Description:		prints text according to its IntuiText specifications
Library:		intuition.library
Offset:			-$00D8 (-216)
Modula-2 Module:	Intuition
Syntax:			PrintIText(rastPort, intuiText, leftEdge, topEdge)
C:		        void PrintIText(struct RastPort *, struct IntuiText *, long, long)
Machine Language:	PrintIText(a0, a1, d0, d1)
Modula-2:		PrintIText(rastPort: RastPortPtr; intuiText: IntuiTextPtr; leftEdge,
			topEdge: INTEGER)
Arguments:		rastPort = RastPort structure to receive text
			intuiText = IntuiText structure containing text
			leftEdge = horizontal position of text within RastPort
			topEdge = vertical position of text within RastPort
Result:			none
-------------------------
Procure
Description:		obtains a message-based semaphore
Library:		exec.library
Offset:			-$021C (-540)
Modula-2 Module:	Semaphores
Syntax:			success = Procure(semaphore, message)
C:		        long Procure(struct Semaphore *, struct Message *)
Machine Language:	d0 = Procure(a0, a1)
Modula-2:		Procure(semaphore: SemaphorePtr; message: MessagePtr):
 			BOOLEAN
Arguments:		semaphore = Semaphore structure
			message = Message structure to be used if desired semaphore is
			unavailable
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
PutCLBuf
Description:		converts contiguous data into a character list
Library:		clist.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			error = PutCLBuf(cList, buffer, length)
C:		        long PutCLBuf(long, char *, long)
Machine Language:	d0 = PutCLBuf(a0, a1, d1)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			buffer = buffer containing data to be converted
			length = size of buffer in bytes
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutCLChar
Description:		adds a byte to the end of a character list
Library:		clist.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			error = PutCLChar(cList, byte)
C:			long PutCLChar(long, long)
Machine Language:	d0 = PutCLChar(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			byte = byte to be added to end of character list
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutCLWord
Description:		adds a word to the end of a character list
Library:		clist.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			error = PutCLWord(cList, word)
C:			long PutCLWord(long)
Machine Language:	d0 = PutCLWord(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			word = word to be added to end of character list
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
PutDiskObject
Description:		writes a Workbench DiskObject to disk as an .info file
Library:		icon.library
Offset:			-$0054 (-84)
Modula-2 Module:	Icon
Syntax:			success = PutDiskObject(name, diskObj)
C:			long PutDiskObject(char *, struct DiskObject *)
Machine Language:	d0 = PutDiskObject(a0, a1)
Modula-2:		PutDiskObject(name: STRPTR; diskObj: DiskObjectPtr): BOOLEAN
Arguments:		name = name of object
			diskObj = DiskObject structure (.info file)
Result:			success = nonzero if successful
-------------------------
PutIcon
Description:		writes a DiskObject to disk as an .info file
Library:		icon.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			success = PutIcon(name, icon)
C:           long PutIcon(char *, struct DiskObject *)
Machine Language:	d0 = PutIcon(a0, a1)
Modula-2:		not available
Arguments:		name = name of icon (.info file)
			icon = DiskObject structure
Result:			success = nonzero if successful
-------------------------
PutMsg
Description:		gets next message from a message port
Library:		exec.library
Offset:			-$016E (-366)
Modula-2 Module:	Ports
Syntax:			PutMsg(port, message)
C:		        void PutMsg(struct MsgPort *, struct Message *)
Machine Language:	PutMsg(a0, a1)
Modula-2:		PutMsg(port: MsgPortPtr; message: ADDRESS)
Arguments:		port = message port to receive message
			message = Message structure containing message to send
Result:			none
-------------------------
PutWBObject
Description:		writes a WBObject to disk as an .info file
Library:		icon.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			success = PutWBObject(name, object)
C:			long PutWBObject(char *, struct WBObject *)
Machine Language:	d0 = PutWBObject(a0, a1)
Modula-2:		not available
Arguments:		name = name of WBObject (.info file)
			object = WBObject structure
Result:			success = nonzero if successful
------------------------- 
QBlit
Description:		queues up a blitter request
Library:		graphics.library
Offset:			-$0114 (-276)
Modula-2 Module:	Blitter
Syntax:			QBlit(blitNode)
C:			void QBlit(struct BlitNode *)
Machine Language:	QBlit(a1)
Modula-2:		QBlit(blitNode: bltnodePtr)
Arguments:		blitNode = BlitNode structure containing link information and
			address of your blitter routine
Result:			none
-------------------------
QBSlit
Description:		queues and synchronizes a blitter request with the video beam
Library:		graphics.library
Offset:			-$0126 (-294)
Modula-2 Module:	Blitter
Syntax:			QBSlit(blitNode)
C:			void QBSlit(struct BlitNode *)
Machine Language:	QBSlit(a1)
Modula-2:		QBSlit(blitNode: bltnodePtr)
Arguments:		blitNode = BlitNode structure containing link information and
			address of your blitter routine
Result:			none
-------------------------
RangeRand
Description:		generates a random integer within a specified range
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			rnd = RangeRand(range)
C:			long RangeRand(long)
Machine Language:	move.l range,-(sp)
			jsr _RangRand ;rnd returned in d0
			addq.l #4,sp
Modula-2:		not available
Arguments:		range = highest integer acceptable
Result:			rnd = random number between 0 and value of range argument
-------------------------
RASSIZE (macro)
Description:		calculates the memory requirements for a raster bitmap of the
			specified with and height
C Include File:		include/graphics/gfx.h
ML Include File:	none
Modula-2 Module:	Graphics
Syntax:			bytes = RASSIZE(width, height)
C:			long RASSIZE(long, long)
Machine Language:	not available
Modula-2:		RASSIZE(width, height: LONGCARD)
Arguments:		width = width of hypothetical bitmap in pixels
			height = height of hypothetical bitmap in pixels
Result:			bytes = number of bytes required to contain raster bitmap
-------------------------
RawDoFmt
Description:		formats data into a character stream using C formatting
			commands (%)
Library:		exec.library
Offset:			-$020A (-522)
Modula-2 Module:	Exec
Syntax:			RawDoFmt(formatString, dataStream, putChProc, putChData)
C:			void RawDoFmt(char *, APTR, void (*)(), APTR)
Machine Language:	RawDoFmt(a0, a1, a2, a3)
Modula-2:		RawDoFmt(formatString, dataStream: ADDRESS; putChProc:
			PROC; putChData: ADDRESS)
Arguments:		formatString = string with optional C formatting commands (%)
			dataStream = stream of data that is interpreted according to the
			formatString
			putChProc = address of procedure to call with each character to
			be output, where procedure is called as PutChProc(char,
			putChData)
			putChData = value to pass to PutChProc
Result:			none
-------------------------
Read
Description:		reads data from a file
Library:		dos.library
Offset:			-$002A (-42)
Modula-2 Module:	DOS
Syntax:			actualLength = Read(file, buffer, length)
C:			long Read(BPTR, char *, long)
Machine Language:	d0 = Read(d1, d2, d3)
Modula-2:		Read(file: FileHandle; buffer: ADDRESS; length: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			buffer = address of memory block to receive data
			length = number of bytes to read (must not exceed buffer size)
Result:			actualLength = actual number of bytes received
-------------------------
ReadExpansionByte
Description:		reads a byte nybble-by-nybble from a new-style expansion board
Library:		expansion.library
Offset:			-$0060 (-96)
Modula-2 Module:	Expansion
Syntax:			byte = ReadExpansionByte(board, offset)
C:			long ReadExpansionByte(long, long)
Machine Language:	d0 = ReadExpansionByte(a0, d0)
Modula-2:		ReadExpansionByte(board: ADDRESS; offset: LONGCARD):
			INTEGER	
Arguments:		board = base address of expansion board
			offset = logical offset from board base
Result:			byte = data received; -1 if an error occurred
-------------------------
ReadExpansionRom
Description:		reads a new-style expansion board's configuration ROM space
Library:		expansion.library
Offset:			-$0066 (-102)
Modula-2 Module:	Expansion
Syntax:			error = ReadExpansionRom(board, configDev)
C:			long ReadExpansionRom(long, long)
Machine Language:	d0 = ReadExpansionRom(a0, a1)
Modula-2:		ReadExpansionRom(board: ADDRESS; configDev: ADDRESS):
			BOOLEAN
Arguments:		board = base address of expansion board
			configDev = ConfigDev structure to receive ROM data
Result:			error = 0 if successful; nonzero if an error occurred
-------------------------
ReadPixel
Description:		finds the color register (pen) used to color a specific pixel
Library:		graphics.library
Offset:			-$013E (-318)
Modula-2 Module:	Pens
Syntax:			pen = ReadPixel(rastPort, x, y)
C:			long ReadPixel(struct RastPort *, long, long)
Machine Language:	d0 = ReadPixel(a0, d0, d1)
Modula-2:		ReadPixel(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure
			x = horizontal coordinate of pixel
			y = vertical coordinate of pixel
Result:			pen = pen number; -1 if pixel lies outside boundaries of rastport
-------------------------
RectFill
Description:		fills a rectangular area using the current pen color, outline color,
			secondary color, and pattern
Library:		graphics.library
Offset:			-$0132 (-306)
Modula-2 Module:	Pens
Syntax:			RectFill(rastPort, xmin, ymin, xmax, ymax)
C:			void RectFill(struct RastPort *, long, long, long, long)
Machine Language:	RectFill(a0, d0, d1, d2, d3)
Modula-2:		RectFill(rastPortPtr: RastPort; xmin, ymin, xmax, ymax: INTEGER)
Arguments:		rastPort = RastPort structure
			xmin = horizontal coordinate rectangle's upper left corner
			ymin = vertical coordinate rectangle's upper left corner
			xmax = horizontal coordinate rectangle's lower right corner
			ymax = vertical coordinate rectangle's lower right corner
Result:			none
-------------------------
RefreshGadgets
Description:		redraws a gadget and all following gadgets in gadget list
Library:		intuition.library
Offset:			-$00DE (-222)
Modula-2 Module:	Intuition
Syntax:			RefreshGadgets(gadgets, window, requester)
C:			void RefreshGadgets(struct Gadget *, struct Window *, struct Re-
			quester *)

Machine Language:	RefreshGadgets(a0, a1, a2)
Modula-2:		RefreshGadgets(gadgets: GadgetPtr; window: WindowPtr; request-
			er: RequesterPtr)
Arguments:		gadgets = first gadget in list of gadgets to refresh
			window = window containing gadgets
			requester = requester containing gadget; NULL if gadget is not
			part of a requester
Result:			none
-------------------------
RefreshGList
Description:		redraws a gadget and specified number of following gadgets in
			gadget list
Library:		intuition.library
Offset:			-$01BO (-432)
Modula-2 Module:	Intuition
Syntax:			RefreshGList(gadgets, window, requester, numGadgets)
C:			void RefreshGList(struct Gadget *, struct Window *, struct Re-
			quester *, long)
Machine Language:	RefreshGList(a0, a1, a2, d0)
Modula-2:		RefreshGList(gadgets: GadgetPtr; window: WindowPtr; requester:
			RequesterPtr; numGadgets: INTEGER)
Arguments:		gadgets = first gadget in list of gadgets to refresh
			window = window containing gadgets
			requester = requester containing gadget; NULL if gadget is not
			part of a requester
			numGadgets = number of gadgets to refresh; -1 to refresh to
			end of gadget list
Result:			none
-------------------------
RefreshWindowFrame
Description:		redraws a window's border, title bar, and gadgets
Library:		intuition.library
Offset:			-$01C8 (-456)
Modula-2 Module:	Intuition
Syntax:			RefreshWindowFrame(window)
C:			void RefreshWindowFrame(struct Window *)
Machine Language:	RefreshWindowFrame(a0)
Modula-2:		RefreshWindowFrame(window: WindowPtr)
Arguments:		window = window to refresh
Result:			none
------------------------- 
ReleaseConfigBinding
Description:		allows others to bind drivers
Library:		expansion.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			ReleaseConfigBinding( )
C:			void ReleaseConfigBinding(void)
Machine Language:	ReleaseConfigBinding( )
Modula-2:		not available
Arguments:		none
Result:			none
-------------------------
ReleaseSemaphore
Description:		releases a signal semaphore for use by other tasks
Library:		exec.library
Offset:			-$023A (-5 70)
Modula-2 Module:	Semaphores
Syntax:			ReleaseSemaphore(signalSemaphore)
C:			void ReleaseSemaphore(struct SignalSemaphore *)
Machine Language:	ReleaseSemaphore(a0)
Modula-2:		ReleaseSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = initialized SignalSemaphore structure
Result:			none
-------------------------
ReleaseSemaphoreList
Description:		releases a list of signal semaphores for other tasks
Library:		exec.library
Offset:			-$024C (-588)
Modula-2 Module:	Semaphores
Syntax:			ReleaseSemaphoreList(list)
C:			void ReleaseSemaphoreList(struct List *)
Machine Language:	ReleaseSemaphoreList(a0)
Modula-2:		ReleaseSemaphoreList(list: SignalSemaphorePtr)
Arguments:		list = List structure representing a list of signal semaphores
Result:			none
-------------------------
RemakeDisplay
Description:		redraws every intuition screen
Library:		intuition.library
Offset:			-$0180 (-384)
Modula-2 Module:	Intuition
Syntax:			RemakeDisplay( )
C:			void RemakeDisplay(void)
Machine Language:	RemakeDisplay( )
Modula-2:		RemakeDisplay( )
Arguments:		none
Result:			none
-------------------------
RemBob (macro)
Description:		removes a Bob from current GEL list
C Include File:		include/graphics/gels.h
ML Include File:	graphics/gels.i
Modula-2 Module:	none
Syntax:			RemBob(bob, rastPort)
C:			void RemBob(struct Bob *, struct RastPort *)
Machine Language:	RemBob(a0)
Modula-2:		not available
Arguments:		bob = Bob structure to remove
			rastPort = controlling RastPort structure (not needed in
			Modula-2)
Result:			none
-------------------------
RemConfigDev
Description:		removes a ConfigDev structure from the system
Library:		expansion.library
Offset:			-$006C (-108)
Modula-2 Module:	ConfigVars
Syntax:			RemConfigDev(configDev)
C:			void RemConfigDev(long)
Machine Language:	RemConfigDev(a0)
Modula-2:		RemConfigDev(configDev: ConfigDevPtr)
Arguments:		configDev = ConfigDev structure
Result:			none
------------------------- 
RemDevice
Description:		removes a device from the system
Library:		exec.library
Offset:			-$01B6 (-438)
Modula-2 Module:	Devices
Syntax:			error= RemDevice(device)
C:			long RemDevice(struct Device *)
Machine Language:	d0 = RemDevice(a1)
Modula-2:		RemDevice(device: DevicePtr)
Arguments:		device = device node
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
RemFont
Description:		removes a font from the system
Library:		graphics.library
Offset:			-$01E6 (-486)
Modula-2 Module:	Text
Syntax:			error = RemFont(textFont)
C:			long RemFont(struct TextFont *)
Machine Language:	d0 = RemFont(a1)
Modula-2:		RemFont(textFont: TextFontPtr)
Arguments:		textFont = TextFont structure to remove
Result:			error = 0 if successful; nonzero if unsuccessful (no value returned
			by Modula-2)
-------------------------
RemHead
Description:		removes a node from the head of a list
Library:		exec.library
Offset:			-$0102 (-258)
Modula-2 Module:	Lists
Syntax:			node = RemHead(list)
C:			struct Node *RemHead(struct List *)
Machine Language:	d0 = RemHead(a0)
Modula-2:		RemHead(list: ListPtr): NodePtr
Arguments:		list = list header
Result:			node = node removed; NULL if list is was already empty
------------------------- 
RemIBob
Description:		immediately removes a Bob from the GEL list and erases it from
			the RastPort display
Library:		graphics.library
Offset:			-$0084 (-132)
Modula-2 Module:	Gels
Syntax:			RemIBob(bob, rastPort, viewPort)
C:			void RemIBob(struct Bob *, struct RastPort *, struct ViewPort *)
Machine Language:	RemIBob(a0, a1, a2)
Modula-2:		RemIBob(bob: BobPtr; rastPort: RastPortPtr; viewPort:
			ViewPortPtr)
Arguments:		bob = Bob structure to remove from GEL list
			rastPort = RastPort structure
			viewPort = ViewPort structure
Result:			none
-------------------------
RemIntServer
Description:		removes an interrupt server from the system
Library:		exec.library
Offset:			-$00AE (-174)
Modula-2 Module:	Interrupts/
Syntax:			RemIntServer(intNum, interrupt)
C:			void RemIntServer(long, struct Interrupt *)
Machine Language:	RemIntServer(d0, a1)
Modula-2:		RemIntServer(intNum: CARDINAL; interrupt: InterruptPtr)
Arguments:		intNum = portia interrupt bit (0-4)
			interrupt = interrupt server node
Result:			none
-------------------------
RemLibrary
Description:		removes a library from the system
Library:		exec.library
Offset:			-$0192 (-402)
Modula-2 Module:	Libraries
Syntax:			error= RemLibrary(library)
C:			long RemLibrary(struct Library *)
Machine Language:	d0 = RemLibrary(a1)
Modula-2:		RemLibrary(Library: LibraryPtr)
Arguments:		library = Library structure to remove
Result:			error = 0 if successful; nonzero if unsuccessful
-------------------------
Remove
Description:		removes a node from a list
Library:		exec.library
Offset:			-$00FC (-252)
Modula-2 Module:	Lists
Syntax:			Remove(node)
C:			void Remove(struct Node *)
Machine Language:	Remove(a1)
Modula-2:		Remove(node: NodePtr)
Arguments:		node = node to remove
Result:			none
-------------------------
RemoveGadget	  
Description:		removes gadget from a window
Library:		intuition.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Intuition
Syntax:			position = RemoveGadget(window, gadget)
C:			long RemoveGadget(struct Window *, struct Gadget *)
Machine Language:	d0 = RemoveGadget(a0, a1)
Modula-2:		RemoveGadget(window: WindowPtr; gadget: GadgetPtr):
			INTEGER
Arguments:		window = window that contains gadget
			gadget = gadget to remove
Result:			position = position in gadget list where gadget was located; -1 if
			gadget was not found
-------------------------
RemoveGList
Description:		removes a series of gadgets from a gadget list
Library:		intuition.library
Offset:			-$01BC (-444)
Modula-2 Module:	Intuition
Syntax:			position = RemoveGList(window, gadget, numGadgets)
C:			long RemoveGList(struct Window *, Gadget *, long)
Machine Language:	d0 = RemoveGList(a0, a1, d0)

Modula-2:		RemoveGList(window: WindowPtr; gadget: GadgetPtr;
			numGadgets: INTEGER): INTEGER
Arguments:		window = window containing gadgets
			gadget = first gadget in gadget list to remove
			numGadgets = number of gadgets to remove
Result:			position = position of removed gadget list; -1 if gadget was not
			found
-------------------------
RemPort
Description:		removes a message port from the system
Library:		exec.library
Offset:			-$0168 (-360)
Modula-2 Module:	Ports
Syntax:			RemPort(port)
C:			void RemPort(struct MsgPort *)
Machine Language:	RemPort(a1)
Modula-2:		RemPort(port: MsgPortPtr)
Arguments:		port = message port to remove
Result:			none
-------------------------
RemResource
Description:		removes a resource from the system
Library:		exec.library
Offset:			-$01EC (-492)
Modula-2 Module:	Resources
Syntax:			RemResource(resource)
C:			void RemResource(struct Resource *)
Machine Language:	RemResource(a1)
Modula-2:		RemResource(resource: ResourcePtr)
Arguments:		resource = resource to remove
Result:			none
-------------------------
RemSemaphore
Description:		removes signal semaphore from the system
Library:		exec.library
Offset:			-$025E (-606)
Modula-2 Module:	Semaphores
Syntax:			RemSemaphore(signalSemaphore)
C:			void RemSemaphore(struct SignalSemaphore *)
Machine Language:	RemSemaphore(a1)
Modula-2:		RemSemaphore(signalSemaphore: SignalSemaphorePtr)
Arguments:		signalSemaphore = signal semaphore to remove
Result:			none
-------------------------
RemTail
Description:		removes node from the tail of a list
Library:		exec.library
Offset:			-$0108 (-264)
Modula-2 Module:	Lists
Syntax:			node = RemTail(list)
C:			struct Node *RemTail(struct List *)
Machine Language:	d0 = RemTail(a0)
Modula-2:		RemTail(list: ListPtr): NodePtr
Arguments:		list = list header
Result:			node = pointer to removed node; NULL if list is already empty
-------------------------
RemTask
Description:		removes a task from the system
Library:		exec.library
Offset:			-$0120 (-288)
Modula-2 Module:	Tasks
Syntax:			RemTask(task)
C:			void RemTask(struct Task *)
Machine Language:	RemTask(a1)
Modula-2:		RemTask(task: TaskPtr)
Arguments:		task = task to remove
Result:			none
-------------------------
RemTOF
Description:		removes a task from the TopOfFrame (vertical-blanking interval)
			interrupt server chain
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			RemTOF(i)
C:			void RemTOF(struct Isrvstr *)
Machine Language:	pea i
			jsr _RemTOF
			addq.l #4,sp
Modula-2:		not available
Arguments:		i = Isrvstr structure
Result:			none
-------------------------
RemVSprite
Description:		removes a VSprite from the GEL list
Library:		graphics.library
Offset:			-$008A (-138)
Modula-2 Module:	Gels
Syntax:			RemVSprite(vSprite)
C:			void RemVSprite(struct VSprite *)
Machine Language:	RemVSprite(a0)
Modula-2:		RemVSprite(vSprite: VSpritePtr)
Arguments:		vSprite = VSprite to remove
Result:			none
-------------------------
Rename
Description:		renames a directory or file
Library:		dos.library
Offset:			-$004E (-78)
Modula-2 Module:	DOS
Syntax:			success = Rename(oldName, newName)
C:			long Rename(char *, char *)
Machine Language:	d0 = Rename(d1, d2)
Modula-2:		Rename(oldName, newName: STRPTR): BOOLEAN
Arguments:		oldName = current name of file/directory (can include
			drive/directory path)
			newName = new name for file (can include drive/directory path)
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
ReplyMsg
Description:		replies to a message
Library:		exec.library
Offset:			-$017A (-378)
Modula-2 Module:	Ports
Syntax:			ReplyMsg(message)
C:			void ReplyMsg(struct MsgPort *)
Machine Language:	ReplyMsg(a1)
Modula-2:		ReplyMsg(message: ADDRESS)
Arguments:		message = message to reply to
Result:			none
-------------------------
ReportMouse
Description:		tells intuition whether or not to report the mouse movements as-
			sociated with a window
Library:		intuition.library
Offset:			-$00EA (-234)
Modula-2 Module:	Intuition
Syntax:			ReportMouse(window, flag)
C:			void ReportMouse(struct Window *, long)
Machine Language:	ReportMouse(a0, d0)
Modula-2:		ReportMouse(window: WindowPtr; flag: BOOLEAN)
Arguments:		window = window to be affected
			flag = TRUE to activate mouse movement reports; FALSE to stop
			mouse movement reports
Result:			none
-------------------------
Request
Description:		activates a requester
Library:		intuition.library
Offset:			-$00F0 (-240)
Modula-2 Module:	Intuition
Syntax:			success = Request(requester, window)
C:			long Request(struct Requester, struct Window *)
Machine Language:	d0 = Request(a0, a1)
Modula-2:		Request(requester: RequesterPtr; window: WindowPtr): BOOLEAN
Arguments:		requester = requester to display
			window = window in which requester will appear in
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
RethinkDisplay
Description:		performs a complete overhaul on the Intuition display-screens,
			ViewPorts, everything
Library:		intuition.library
Offset:			-$0186 (-390)
Modula-2 Module:	Intuition
Syntax:			RethinkDisplay( )
C:			void RethinkDisplay(void)
Machine Language:	RethinkDisplay( )
Modula-2:		RethinkDisplay( )
Arguments:		none
Result:			none
-------------------------
ScreenToBack
Description:		moves specified screen to back of the display
Library:		intuition.library
Offset:			-$00F6 (-246)
Modula-2 Module:	Intuition
Syntax:			ScreenToBack(screen)
C:			void ScreenToBack(struct Screen *)
Machine Language:	ScreenToBack(a0)
Modula-2:		ScreenToBack(screen: ScreenPtr)
Arguments:		screen = screen to move
Result:			none
-------------------------
ScreenToFront
Description:		moves specified screen to front of the display
Library:		intuition.library
Offset:			-$00FC (-252)
Modula-2 Module:	Intuition
Syntax:			ScreenToFront(screen)
C:			void ScreenToFront(struct Screen *)
Machine Language:	ScreenToFront(a0)
Modula-2:		ScreenToFront(screen: ScreenPtr)
Arguments:		screen = screen to move
Result:			none
-------------------------
ScrollLayer
Description:		copies data from a SuperBitMap to a layer so as to reposition the
			display over the bitmap
Library:		layers.library
Offset:			-$0048 (-72)
Modula-2 Module:	Layers
Syntax:			ScrollLayer(dummy, layer, dx, dy)
C:			void ScrollLayer(struct Layer_Info *, struct Layer *, long, long)
Machine Language:	ScrollLayer(a0, a1, d0, d1)
Modula-2:		ScrollLayer(layer: LayerPtr; dx, dy: LONGINT)
Arguments:		dummy = unused
			layer = Layer structure
			dx = offset by which to move layer horizontally
			dy = offset by which to move layer vertically
Result:			none
-------------------------
ScrollRaster
Description:		scrolls the contents of a rectangular area of a RastPort
Library:		graphics.library
Offset:			-$018C (-396)
Modula-2 Module:	Rasters
Syntax:			ScrollRaster(rastPort, dx, dy, x1, y1, x2, y2)
C:			void ScrollRaster(struct RastPort *, long, long, long, long, long, 
			long)
Machine Language:	ScrollRaster(a0, d0, d1, d2, d3, d4, d5)
Modula-2:		ScrollRaster(rastPort: RastPortPtr; dx, dy: INTEGER; x1, y1, x2,
			y2: INTEGER)
Arguments:		rastPort = RastPort structure
			dx = offset by which to scroll the rectangle
			dy = offset by which to scroll the rectangle
			x1 = horizontal position of the left edge of the rectangle
			y1 = vertical position of the top edge of the rectangle
			x2 = horizontal position of the right edge of the rectangle
			y2 = vertical position of the bottom edge of the rectangle
Result:			none
-------------------------
ScrollVPort
Description:		scrolls the contents of a rectangular area of a ViewPort by reinter-
			preting the RasInfo information in a ViewPort
Library:		graphics.library
Offset:			-$024C (-588)
Modula-2 Module:	Views
Syntax:			ScrollVPort(viewPort)
C:			void ScrollVPort(struct ViewPort *)
Machine Language:	ScrollVPort(a0)
Modula-2:		ScrollVPort(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure to update
Result:			none
-------------------------
Seek
Description:		moves the file pointer to a specified position in a file
Library:		dos.library
Offset:			-$0042 (-66)
Modula-2 Module:	DOS
Syntax:			oldPosition = Seek(file, position, mode)
C:			long Seek(BPTR, long, long)
Machine Language:	d0 = Seek(d1, d2, d3)
Modula-2:		Seek(file: FileHandle; position: LONGINT; mode: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			position = offset by which to move file pointer
			mode = flag specifying how to interpret position offset-
			OFFSET_BEGINNING (-1), OFFSET_CURRENT (0), or
			OFFSET_END (1)
Result:			oldPosition = old file position; -1 if unsuccessful
-------------------------
SendIO
Description:		sends an IO request
Library:		exec.library
Offset:			-$01CE (-462)
Modula-2 Module:	IO
Syntax:			SendIO(ioRequest)
C:			void SendIO(struct IORequest *)
Machine Language:	SendIO(a1)
Modula-2:		SendIO(ioRequest: ADDRESS)
Arguments:		IORequest = an initialized IORequest structure
Result:			none
-------------------------
SetAfPt (macro)
Description:		sets area fill pattern
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetAfPt(rastPort, pattern, size)
C:			void SetAfPt(struct RastPort *, char *, long)
Machine Language:	not available
Modula-2:      		SetAfPat(rastPort: RastPortPtr; pattern: ADDRESS; size:
			CARDINAL)
Arguments:		rastPort = RastPort structure
			pattern = pointer to the first word in an area-fill pattern
			size = size of area pattern (size to the power of two equals the
			number of words in pattern)
Result:			none
-------------------------
SetAPen
Description:		sets the primary pen color
Library:		graphics.library
Offset:			-0156 (-342)
Modula-2 Module:	Pens
Syntax:			SetAPen(rastPort, pen)
C:			void SetAPen(struct RastPort *, long)
Machine Language:	SetAPen(a1, d0)
Modula-2:		SetAPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetBPen
Description:		sets the secondary pen color
Library:		graphics.library
Offset:			-015C (-348)
Modula-2 Module:	Drawing
Syntax:			SetBPen(rastPort, pen)
C:			void SetBPen(struct RastPort *, long)
Machine Language:	SetBPen(al, d0)
Modula-2:		SetBPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetCollision
Description:		sets a collision vector to point to a user-written routine
Library:		graphics.library
Offset:			-0090 (-144)
Modula-2 Module:	Gels
Syntax:			SetCollision(number, routine, gelsInfo)
C:			void SetCollision(long, _fgptr, struct GelsInfo *)
Machine Language:	SetCollision(d0, a0, a1)
Modula-2:		SetCollision(number: LONGCARD; routine: PROC; gelsInfo:
			GelsInfoPtr)
Arguments:		number = collision vector number
			routine = pointer to user's collision routine
			gelsInfo = GelsInfo structure
Result:			none
-------------------------
SetComment
Description:		adds a comment to a file
Library:		dos.library
Offset:			-00B4 (-180)
Modula-2 Module:	DOS
Syntax:			success = SetComment(name, comment)
C:			long SetComment(char *, char *)
Machine Language:	d0 = SetComment(d1, d2)
Modula-2:		SetComment(name, comment: STRPTR): BOOLEAN
Arguments:		name = filename of file to comment
			comment = comment to add to file
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
SetCurrentBinding
Description:		sets static board configuration area
Library:		expansion.library
Offset:			-$0084 (-132)
Modula-2 Module:	none
Syntax:			SetCurrentBinding(currentBinding, size)
C:			void SetCurrentBinding(long, long)
Machine Language:	SetCurrentBinding(a0, d0)
Modula-2:      		not available
Arguments:		currentBinding = CurrentBinding structure
			size = size of user's BindDriver structure
Result:			none
-------------------------
SetDMRequest
Description:		attaches a DMRequester (a requester activated when the mouse's
			menu button is double clicked) to a window
Library:		intuition.library
Offset:			-0102 (-258)
Modula-2 Module:	Intuition
Syntax:			success = SetDMRequest(window, dmRequester)
C:			long SetDMRequest(struct Window *, struct Requester *)
Machine Language:	d0 = SetDMRequest(a0, a1)
Modula-2:		SetDMRequest(window: WindowPtr; dmRequester: RequesterPtr)
Arguments:		window = window to which the requester will be added
			dmRequester = requester to attach
Result:			success = TRUE if successful; FALSE if unsuccessful (nothing re-
			turned by Modula-2)
-------------------------
SetDrMd
Description:		sets a drawing mode for drawing routines
Library:		graphics.library
Offset:			-0162 (-354)
Modula-2 Module:	Pens
Syntax:			SetDrMd(rastPort, mode)
C:			void SetDrMd(struct RastPort *, long)
Machine Language:	SetDrMd(a1, d0)
Modula-2:		SetDrMd(rastPort: RastPortPtr; mode: DrawingModeSet)
Arguments:		rastPort = RastPort structure
			mode = drawing mode JAM1, JAM2, COMPLEMENT,
			INVERSVID)
Result:			none
-------------------------
SetDrPt (macro)
Description:		sets a pattern to use for line drawing
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetDrPt(rastPort, pattern)
C:			void SetDrPt(struct RastPort *, long)
Machine Language:	not available
Modula-2:		SetDrPt(rastPort: RastPortPtr; pattern: BITSET)
Arguments:		rastPort = RastPort structure
			pattern = 16-bit drawing pattern
Result:			none
-------------------------
SetExcept
Description:		defines which signals cause an exception
Library:		exec.library
Offset:			-0138 (-312)
Modula-2 Module:	Tasks
Syntax:			oldSignals = SetExcept(newSignals, signalMask)
C:			long SetExcept(long, long)
Machine Language:	d0 = SetExcept(d0, d1)
Modula-2:		SetExcept(newSignals, signalMask: SignalSet): SignalSet
Arguments:		newSignals = new values for signals specified in signalMask
			signalMask = set of signals to be affected
Result:			oldSignals = prior exception signals
-------------------------
SetFont
Description:		sets the font to be used for drawing text in a rastport
Library:		graphics.library
Offset:			-0042 (-66)
Modula-2 Module:	Text
Syntax:			SetFont(rastPort, font)
C:			void SetFont(struct RastPort *, struct TextFont *)
Machine Language:	SetFont(a1/ a0)
Modula-2:		SetFont(rastPort: RastPortPtr; font: TextFontPtr)
Arguments:		rastPort = RastPort structure
			font = font descriptor obtained from OpenFont( ) function
Result:			none
-------------------------
SetFunction
Description:		changes a function vector in a library
Library:		exec.library
Offset:			-01A4 (-420)
Modula-2 Module:	Libraries
Syntax:			oldFunc = SetFunction(library, offset, newFunc)
C:			_fptr SetFunction(struct Library *, long,_fptr)
Machine Language:	d0 = SetFunction(a1, a0, d0)
Modula-2:		SetFunction(library: LibraryPtr; offset: INTEGER; newFunc:
			PROC): PROC
Arguments:		library = library to change
			offset = offset of function vector to change
			newFunc = address of new function
Result:			oldFunc = address of old function
-------------------------
SetIntVector
Description:		changes a system interrupt vector
Library:		exec.library
Offset:			-00A2 (-162)
Modula-2 Module:	Interrupts
Syntax:			oldInt = SetIntVector(intNum, newInt)
C:			struct Interrupt *SetIntVector(long, struct Interrupt *)
Machine Language:	d0 = SetIntVector(d0, a1)
Modula-2:		SetIntVector(intNum: CARDINAL; newInt: InterruptPtr):
			InterruptPtr
Arguments:		intNum = Portia interrupt bit number (0-14)
			newInt = initialized Interrupt structure
Result:			oldInt = old Interrupt structure
-------------------------
SetMenuStrip
Description:		attaches a menu strip to a window
Library:		intuition.library
Offset:			-0108 (-264)
Modula-2 Module:	Intuition
Syntax:			SetMenuStrip(window, menu)
C:			void SetMenuStrip(struct Window *, struct Menu *)
Machine Language:	SetMenuStrip(a0, a1)
Modula-2:		SetMenuStrip(window: WindowPtr; menu: MenuPtr)
Arguments:		window = window to receive menu strip
			menu = first menu in menu strip
Result:			none
-------------------------
SetOPen (macro)
Description:		sets the color of the pen used for outlining figures and tums on
			outlining
C Include File:		include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetOPen(rastPort, pen)
C:			void SetOPen(struct RastPort *, long)
Machine Language:	not available
Modula-2:		SetOPen(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = pen number (0-255)
Result:			none
-------------------------
SetPointer
Description:		sets the shape of a window's sprite mouse pointer
Library:		intuition.library
Offset:			-010E (-270)
Modula-2 Module:	Intuition
Syntax:			SetPointer(window, pointer, height, width, xOffset, yOffset)
C:			void SetPointer(struct Window *, short *, long, long, long, long)
Machine Language:	SetPointer(a0, a1, d0, d1, d2, d3)
Modula-2:		SetPointer(window: WindowPtr; pointer: ADDRESS; height,
			width: CARDINAL; xOffset, y: INTEGER)
Arguments:		window = window to receive new pointer
			pointer = sprite data defining new shape
			height = height of sprite in lines
			width = width of sprite in pixels (less than or equal to 16)
			xOffset = horizontal offset of pointer hot spot
			yOffset = vertical offset of pointer hot spot
Result:			none
-------------------------
SetPrefs
Description:		changes Preferences' current settings
Library:		intuition.library
Offset:			-$0144 (-324)
Modula-2 Module:	Preferences
Syntax:			prefBuffer = SetPrefs(prefBuffer, size, inform)
C:			struct Preferences *SetPrefs(struct Preferences *, long, long)
Machine Language:	d0 = SetPrefs(a0, d0, d1)
Modula-2:		SetPrefs(prefBuffer: ADDRESS; size: INTEGER; inform:
			BOOLEAN)
Arguments:		prefBuffer = buffer which contains your desired Preferences
			settings
			size = size of buffer in bytes
			inform = TRUE if you want to send a NEWPREFS message to all
			interested windows
Result:			prefBuffer = pointer to your prefBuffer
------------------------- 
SetProtection
Description:		sets a file or directories protection bits
Library:		dos.library
Offset:			-00BA (-186)
Modula-2 Module:	DOS
Syntax:			success = SetProtection(name, mask)
C:			long SetProtection(char *, long)
Machine Language:	d0 = SetProtection(d1, d2)
Modula-2:		SetProtection(name: STRPTR; mask: ProtectionSet): BOOLEAN
Arguments:		name = file or directory name
			mask = protection bits to set
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
SetRast
Description:		sets the entire rastport to a specified color
Library:		graphics.library
Offset:			-00EA (-234)
Modula-2 Module:	Rasters
Syntax:			SetRast(rastPort, pen)
C:			void SetRast(struct RastPort *, long)
Machine Language:	SetRast(a1, d0)
Modula-2:		SetRast(rastPort: RastPortPtr; pen: CARDINAL)
Arguments:		rastPort = RastPort structure
			pen = color register used to color the rastport (0-31)
Result:			none
-------------------------
SetRGB4
Description:		sets the red, green, and blue values for a viewport's color register
Library:		graphics.library
Offset:			-0120 (-288)
Modula-2 Module:	Views
Syntax:			SetRGB4(viewPort, pen, red, green, blue)
C:			void SetRGB4(struct ViewPort *, long, long, long, long)
Machine Language:	SetRGB4(a0, d0, d1, d2, d3)
Modula-2:		SetRGB4(viewPort: ViewPortPtr; pen: INTEGER; red, green, blue:
			CARDINAL)
Arguments:		viewPort = ViewPort structure
			pen = color register to set (0-31)
			red = red color level (0-15)
			green = green color level (0-15)
			blue = blue color level (0-15)
Result:			none
-------------------------
SetRGB4CM
Description:		sets the red, green, and blue values for a colormap's color register
Library:		graphics.library
Offset:			-0276 (-630)
Modula-2 Module:	Views
Syntax:			SetRGB4CM(colorMap, pen, red, green, blue)
C:			void SetRGB4CM(struct ColorMap *, long, long, long, long)
Machine Language:	SetRGB4CM(a0, d0, d1, d2, d3)
Modula-2:		SetRGB4CM(colorMap: ColorMapPtr; pen: INTEGER; red, green,
			blue: CARDINAL)
Arguments:		colorMap = ColorMap structure
			pen = color register to set (0-31)
			red = red color level (0-15)
			green = green color level (0-15)
			blue = blue color level (0-15)
Result:			none
-------------------------
SetSignal
Description:		defines the state of a task's signals
Library:		exec.library
Offset:			-0132 (-306)
Modula-2 Module:	Tasks
Syntax:			oldSignals = SetSignal(newSignals, signalMask)
C:			long SetSignal(long, long)
Machine Language:	d0 = SetSignal(d0, d1)
Modula-2:		SetSignal(newSignals, signalMask: SignalSet): SignalSet
Arguments:		newSignals = new values for signals specified in signalMask
			signalMask = set of signals to be affected
Result:			oldSignals = prior values for signals
------------------------- 
SetSoftStyle
Description:		sets the style for the current font
Library:		graphics.library
Offset:			-005A (-90)
Modula-2 Module:	Text
Syntax:			newStyle = SetSoftStyle(rastPort, style, enable)
C:			long SetSoftStyle(struct RastPort *, long, long)
Machine Language:	d0 = SetSoftStyle(a1, d0, d1, a6)
Modula-2:		SetSoftStyle(rastPort: RastPortPtr; style, enable: FontStyleSet):
			FontStyleSet
Arguments:		rastPort = RastPort structure
			style = new font style
			enable = mask that determines which style bit can be changed;
			can be derived from AskSoftStyle( ) function
Result:			newStyle = resulting font style
-------------------------
SetSR
Description:		gets and/or sets the processor's status register
Library:		exec.library
Offset:			-0090 (-144)
Modula-2 Module:	Exec
Syntax:			oldSR = SetSR(newSR, mask)
C:			long SetSR(long, long)
Machine Language:	d0 = SetSR(d0, d1)
Modula-2:		SetSR(newSR: BITSET; mask: BITSET): BITSET
Arguments:		newSR = new value for bits specified in mask
			mask = bits to be affected
Result:			oldSR = prior value of status register
-------------------------
SetTaskPri
Description:		gets and sets the priority of a task
Library:		exec.library
Offset:			-012C (-300)
Modula-2 Module:	Tasks
Syntax:			oldPriority = SetTaskPri(task, newPriority)
C:			long SetTaskPri(struct Task *, long)
Machine Language:	d0 = SetTaskPri(a1, d0)
Modula-2:		SetTaskPri(task: TaskPtr; newPriority: INTEGER): INTEGER
Arguments:		task = task to be affected
			newPriority = new priority value (0-8)
Result:			oldPriority = old task priority (0-8)
-------------------------
SetWindowTitles
Description:		sets the titles for both a window and its screen
Library:		intuition.library
Offset:			-0114 (-276)
Modula-2 Module:	Intuition
Syntax:			SetWindowTitles(window, windowTitle, screenTitle)
C:			void SetWindowTitles(struct Window *, char *, char *)
Machine Language:	SetWindowTitles(a0, a1, a2)
Modula-2:		SetWindowTitles(window: WindowPtr; windowTitle, screenTitle:
			STRPTR)
Arguments:		window = window to be affected
			windowTitle = new window title (-1 to keep as-is)
			screenTitle = new screen title (-1 to keep as-is)
Result:			none
-------------------------
SetWrMsk (macro)
Description:		sets the write mask for a rastport (locks and unlocks bitplanes)
C Include File:	include/graphics/gfxmacros.h
ML Include File:	none
Modula-2 Module:	Pens
Syntax:			SetWrMsk(rastPort, mask)
C:			void SetWrMsk(struct RastPort *, long)
Arguments:		cList = character list containing substring
			index = starting position of substring
			length = number of bytes to copy
Result:			cList = new character list that contains the substring; -1 if there
			is not enough memory
-------------------------
SHIFTITEM (macro)
Description:		shifts a menu value to define a new value for the menu item
			number
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	none
Syntax:			newValue = SHIFTITEM(menuValue)
C:			long SHIFTITEM(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			newValue = the menuValue ANDed with $3F and shifted to the
			left five times-((menuValue & 0x3F) << 5)
-------------------------
SHIFTMENU (macro)
Description:		extracts the menu number from a value (identical to MENUNUM 
			macro)
C Include File: 	include/intuition/intuition.h
ML Include File: 	none
Modula-2 Module:	none
Syntax:			menuNumber= SHIFTMENU(menuValue)
C:			long SHIFTMENU(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			menuNumber = menu number (0-31); equals NOMENU if no
			menu was selected
-------------------------
SHIFTSUB (macro)
Description:		shifts a menu value to define a new value for the menu subitem
			number
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	none
Syntax:			newValue = SHIFTSUB(menuValue)
C:			long SHIFTSUB(long)
Machine Language:	not available
Modula-2:		not available
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			newValue = the menuValue ANDed with $1F and shifted to the
			left 11 times-((menuValue & 0x1F) << 11)
-------------------------
ShowTitle
Description:		determines whether the screen title bar will be displayed in front
			of a backdrop window
Library:		intuition.library
Offset:			-011A (-282) 
Modula-2 Module:	Intuition
Syntax:			ShowTitle(screen, showIt)
C:			void ShowTitle(struct Screen *, long)
Machine Language:	ShowTitle(a0, d0)
Modula-2:		ShowTitle(screen: ScreenPtr; showIt: BOOLEAN)
Arguments:		screen = screen to be affected
			showIt = flag that indicates whether or not to display the screen's
			title bar in front of a backdrop window (TRUE means show the
			title bar; FALSE means hide it)
Result:			none
-------------------------
Signal
Description:		signals a task with specified signals
Library:		exec.library
Offset:			-0144 (-324)
Modula-2 Module:	Tasks
Syntax:			Signal(task, signals)
C:			void Signal(struct Task *, long)
Machine Language:	Signal(d0, d1)
Modula-2:		Signal(task: TaskPtr; signals: SignalSet)
Arguments:		task = task to be signaled
			signals = signals to send
Result:			none
-------------------------
SizeCList
Description:		gets the size of a character list in bytes
Library:		clist.library
Offset:			-0036 (-54)
Modula-2 Module:	none
Syntax:			size = SizeCList(cList)
C:			long SizeCList(long)
Machine Language:	d0 = SizeCList(a0)
Modula-2:      		not available
Arguments:		cList = character list in question
Result:			size = number of bytes in character list
-------------------------
SizeLayer
Description:		changes the size of a nonbackdrop layer
Library:		layers.library
Offset:			-0042 (-66)
Modula-2 Module:	Layers
Syntax:			SizeLayer(dummy, layer, dx, dy)
C:			long SizeLayer(struct Layer_Info *, struct Layer *, long, long)
Machine Language:	d0 = SizeLayer(a0, a1, d0, d1)
Modula-2:		SizeLayer(layer: LayerPtr; dx, dy: LONGINT): BOOLEAN
Arguments:		dummy = unused
			layer = a nonbackdrop Layer structure
			dx = amount to add to layer's horizontal size (may be negative)
			dy = amount to add to layer's vertical size (may be negative)
Result:			TRUE if successful; FALSE if unsuccessful
-------------------------
SizeWindow
Description:		resizes a window
Library:		intuition.library
Offset:			-0120 (-288)
Modula-2 Module:	Intuition
Syntax:			SizeWindow(window, dx, dy)
C:			void SizeWindow(struct Window *, long, long)
Machine Language:	SizeWindow(a0, d0, d1)
Modula-2:		SizeWindow(window: WindowPtr; dx, dy: INTEGER)
Arguments:		window = window to be resized
			dx = amount to add to window's horizontal size (may be
			negative)
			dy = amount to add to window's vertical size (may be negative)
Result:			none
-------------------------
SortGList
Description:		sorts the GEL list by vertical position of each element, prior to
			displaying the GELs
Library:		graphics.library
Offset:			-0096 (-150)
Modula-2 Module:	Gels
Syntax:			SortGList(rastPort)
C:			void SortGList(struct RastPort *)
Machine Language:	SortGList(a1)
Modula-2:		SortGList(rastPort: RastPortPtr)
Arguments:		rastPort = RastPort structure containing the GelsInfo
Result:			none
-------------------------
SPAbs
Description:		obtains the absolute value of a floating-point number
Library:		mathffp.library
Offset:			-$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = SPAbs(fnum2)
C:			float SPAbs(float)
Machine Language:	d0 = SPAbs(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = absolute value of fnum2 in floating-point format
-------------------------
SPAcos
Description:		obtains the arcosine of a floating-point number
Library:		mathtrans.library
Offset:			-$0078 (-120)
Modula-2 Module:	none
Syntax:			fnum1 = SPAcos(fnum2)
C:			float SPAcos(float)
Machine Language:	d0 = SPAcos(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the cosine of an
			angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPAdd
Description:		adds two floating-point numbers
Library:		mathffp.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = SPAdd(fnum2, fnum3)
C:			float SPAdd(float, float)
Machine Language:	d0 = SPAdd(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = fnum2 plus fnum3 in floating-point format
-------------------------
SPAsin
Description:		obtains the arcsine of a floating-point number
Library:		mathtrans.library
Offset:			-$0072 (-114)
Modula-2 Module:	none
Syntax:			fnum1 = SPAsin(fnum2)
C:			float SPAsin(float)
Machine Language:	d0 = SPAsin(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the sine of an angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPAtan
Description:		obtains the arctangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = SPAtan(fnum2)
C:			float SPAtan(float)
Machine Language:	d0 = SPAtan(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing the tangent of an
			angle
Result:			fnum1 = floating-point value of fnum2 angle in radians
-------------------------
SPCmp
Description:		compares two floating-point numbers
Library:		mathffp.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			flag = SPCmp(fnum1, fnum2)
C:			long SPCmp(float, float)
Machine Language:	d0 = SPCmp(d1, d0)
Modula-2:		not available
Arguments:		fnum1 = floating-point number
			fnum2 = floating-point number
Result:			flag = -1 if fnum1<fnum2; +1 if fnum1>fnum2; 0 if
			fnum1 = fnum2
-------------------------
SPCos
Description:		obtains the cosine of a floating-point number
Library:		mathtrans.library
Offset:			-$002A (-42)
Modula-2 Module:	none
Syntax:			fnum1 = SPCos(fnum2)
C:			float SPCos(float)
Machine Language:	d0 = SPCos(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point cosine of fnum2
-------------------------
SPCosh
Description:		obtains the hyperbolic cosine of a floating-point number
Library:		mathtrans.library
Offset:			-$0042 (-66)
Modula-2 Module:	none
Syntax:			fnum1 = SPCosh(fnum2)
C:			float SPCosh(float)
Machine Language:	d0 = SPCosh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic cosine of fnum2
-------------------------
SPDiv
Description:		divides one floating-point number by another
Library:		mathffp.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = SPDiv(fnum2, fnum3)
C:			float SPDiv(float, float)
Machine Language:	d0 = SPDiv(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point dividend
			fnum3 = floating-point divisor
Result:			fnum1 = floating-point format results of fnum2 divided by fnum3
-------------------------
SPExp
Description:		obtains the exponent of a floating-point number
Library:		mathtrans.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = SPExp(fnum2)
C:			float SPExp(float)
Machine Language:	d0 = SPExp(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point value representing e (approx. 2.71728)
			raised to the power of fnum2
-------------------------
SPFieee
Description:		converts a single-precision IEEE number to a Motorola fast float-
			ing point number
Library:		mathtrans.library
Offset:			-$006C (-108)
Modula-2 Module:	none
Syntax:			fnum = SPFieee(ieeenum)
C:			float SPFieee(long)
Machine Language:	d0 = SPFieee(d0)
Modula-2:		not available
Arguments:		ieeenum = single-precision floating-point number
Result:			fnum = Motorola fast floating point equivalent to fnum
-------------------------
SPFlt
Description:		converts an integer to floating-point number
Library:		mathffp.library
Offset:			-$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum = SPFlt(inum)
C:			float SPFlt(long)
Machine Language:	d0 = SPFlt(d0)
Modula-2:		not available
Arguments:		inum = signed integer to be converted
Result:			fnum = floating-point equivalent to inum
-------------------------
SplitCList
Description:		splits a character list in two, breaking it at the mark (obtained via
			the MarkList( ) function)
Library:		clist.library
Offset:			-008A (-138)
Modula-2 Module:	none
Syntax:			tailCList = SplitCList(cList)
C:			long SplitCList(long)
Machine Language:	d0 = SplitCList(a0)
Modula-2:		not available
Arguments:		cList = character list to split
Result:			tailCList = new character list that contains the tail end of the
			original character list; -1 if there is not enough memory
-------------------------
SPLog
Description:		obtains the natural logarithm of a floating-point number
Library:		mathtrans.library
Offset:			-$0054 (-84)
Modula-2 Module:	none
Syntax:			fnum1 = SPLog(fnum2)
C:			float SPLog(float)
Machine Language:	d0 = SPLog(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point natural logarithm (base e) of fnum2
-------------------------
SPLog10
Description:		obtains the naparian logarithm (base 10) of a floating-point number
Library:		mathtrans.library
Offset:			-$007E (-126)
Modula-2 Module:	none
Syntax:			fnum1 = SPLog10(fnum2)
C:			float SPLoglO(float)
Machine Language:	d0 = SPLog10(d0)
Modula-2:      not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point naparian logarithm (base 10) of fnum2
-------------------------
SPMul
Description:		multiplies one floating-point number by another
Library:		mathffp.library
Offset:			-$004E (-78)
Modula-2 Module:	none
Syntax:			fnum1 = SPMul(fnum2, fnum3)
C            float SPMul(float, float)
Machine Language:	d0 = SPMul(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = product of fnum2 and fnum3 in floating-point format
-------------------------
SPNeg
Description:		negates the value of a floating-point number
Library:		mathffp.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = SPNeg(fnum2)
C:			float SPNeg(float)
Machine Language:	d0 = SPNeg(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number to negate
Result:			fnum1 = negative fnum2 in floating-point format
-------------------------
SPPow
Description:		obtains the exponentiation of two floating-point numbers
Library:		mathtrans.library
Offset:			-$005A (-90)
Modula-2 Module:	none
Syntax:			fnum1 = SPPow(fnum2, fnum3)
C:			float SPPow(float, float)
Machine Language:	d0 = SPPow(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = floating-point value of fnum2 raised to the power of
			fnum3
-------------------------
sprintf
Description:		outputs a formatted string into a string (Lattice and Manx users: if 
			you link with lc.lib or c.lib, this is not the function you're calling)
Library:		amiga.lib (linked library)
Modula-2 Module:	none
Syntax:			sprintf(destinationString, formatString, values...)
C:			void sprintf(char *, char *, long...)
Machine Language:	move.l #value,-(sp) ;may have several values 
			pea formatString 
			pea destinationString 
			jsr _printf 
			add.l #8,sp ;(2 arguments * 4 bytes = 8)
Modula-2:		not available

Arguments:		destinationString = address of string to receive output
			 formatString = string containing optional C formatting commands
			 (%); if you're passing longword values on the stack (as shown
			 above) be sure to follow the percent symbol with a lowercase L
			 values = values or addresses of strings to print; this routine
			 knows how many values are on the stack by checking the number
			 of formatting commands in formatString argument
Result:			 none
-------------------------
SPSin
Description:		 obtains the sine of a floating-point number
Library:		 mathtrans.library
Offset:			 -$0024 (-36)
Modula-2 Module:	none
Syntax:			fnum1 = SPSin(fnum2)
C:			float SPSin(float, float)
Machine Language:	d0 = SPSin(d0)
Modula-2:		 not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point sine of fnum2
-------------------------
SPSincos
Description:		 obtains the sine and cosine of a floating-point number
Library:		 mathtrans.library
Offset:			 -$0036 (-54)
Modula-2 Module:	none
Syntax:			fnum1 = SPSincos(fnum2, fnum3)
C:			float SPSincos(float, float *)
Machine Language:	d0 = SPSincos(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = pointer to floating point number to receive the cosine of
			fnum2
Result:			fnum1 = floating-point sine of fnum2 (cosine is returned in
			fnum3)
-------------------------
SPSinh
Description:		obtains the hyperbolic sine of a floating-point number
Library:		mathtrans.library
Offset:			-$003C (-60)
Modula-2 Module:	none
Syntax:			fnum1 = SPSinh(fnum2)
C:			float SPSinh(float, float)
Machine Language:	d0 = SPSinh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic sine of fnum2
-------------------------
SPSqrt
Description:		obtains the square root of a floating-point number
Library:		mathtrans.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			fnum1 = SPSqrt(fnum2)
C:			float SPSqrt(float)
Machine Language:	d0 = SPSqrt(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
Result:			fnum1 = floating-point square root of fnum2
-------------------------
SPSub
Description:		subtracts one floating-point number from another
Library:		mathffp.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = SPSub(fnum2, fnum3)
C:			float SPSub(float, float)
Machine Language:	d0 = SPSub(d1, d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number
			fnum3 = floating-point number
Result:			fnum1 = fnum2 minus fnum3 in floating-point format
-------------------------
SPTan
Description:		obtains the tangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			fnum1 = SPTan(fnum2)
C:			float SPTan(float, float)
Machine Language:	d0 = SPTan(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point tangent of fnum2
-------------------------
SPTanh
Description:		obtains the hyperbolic tangent of a floating-point number
Library:		mathtrans.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			fnum1 = SPTanh(fnum2)
C:			float SPTanh(float, float)
Machine Language:	d0 = SPTanh(d0)
Modula-2:		not available
Arguments:		fnum2 = floating-point number representing an angle in radians
Result:			fnum1 = floating-point hyperbolic tangent of fnum2
-------------------------
SPTieee
Description:		converts a Motorola fast floating point number to a single-
			precision IEEE number
Library:		mathtrans.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			ieeenum = SPTieee(fnum)
C:			float SPTieee(float)
Machine Language:	d0 = SPTieee(d0)
Modula-2:		not available
Arguments:		fnum = Motorola fast floating point number
Result:			ieeenum = single-precision floating-point equivalent to fnum
-------------------------
SPTst
Description:		compares a floating-point number with zero
Library:		mathffp.library
Offset:			-$0030 (-48)
Modula-2 Module:	none
Syntax:			flag = SPTst(fnum)
C:			long SPTst(float)
Machine Language:	d0 = SPTst(d0)
Modula-2:		not available
Arguments:		fnum = floating-point number
Result:			flag = -1 if fnum<0; +1 if fnum>0; 0 if fnum=0
-------------------------
SubCList
Description:		copies a substring from a character list
Library:		clist.library
Offset:			-0096 (-150)
Modula-2 Module:	none
Syntax:			cList = SubCList(cList, index, length)
C:			long SubCList(long, long, long)
Machine Language:	d0 = SubCList(a0, d0, d1)
Modula-2:		not available
Arguments:		cList = character list containing substring
			index = starting position of substring
			length = number of bytes to copy
Result:			cList = new character list that contains the substring; -1 if there
			is not enough memory
-------------------------
SUBNUM (macro)
Description:		extracts the menu subitem number from a value
C Include File:		include/intuition/intuition.h
ML Include File:	none
Modula-2 Module:	Intuition
Syntax:			subNumber= SUBNUM(menuValue)
C:			long SUBNUM(long)
Machine Language:	not available
Modula-2:		SUBNUM(menuValue: CARDINAL): CARDINAL
Arguments:		menuValue = 16-bit packed number representing the menu num-
			ber, item number, and subitem number
Result:			itemNumber = item number (0-31); equals NOSUB if no menu
			was selected
-------------------------
SumKickData
Description:		computes the checksum for a Kickstart delta list
Library:		exec.library
Offset:			-0264 (-612)
Modula-2 Module:	Resident
Syntax:			SumKickData( )
C:			void SumKickData(void)
Machine Language:	SumKickData( )
Modula-2:		SumKickData( )
Arguments:		none
Result:			none
-------------------------
SumLibrary
Description:		verifies a library's checksum; alerts user if checksum is incorrect
Library:		exec.library
Offset:			-01AA (-426)
Modula-2 Module:	Libraries
Syntax:			SumLibrary(library)
C:			void SumLibrary(struct Library *)
Machine Language:	SumLibrary(a1)
Modula-2:		SumLibrary(
Library:		LibraryPtr)
Arguments:		library = library to verify
Result:			none
-------------------------
SuperState
Description:		engage supervisor mode using user-defined stack
Library:		exec.library
Offset:			-$0096 (-150)
Modula-2 Module:	Interrupts
Syntax:			sysStack = SuperState( )
C:			long SuperState(void)
Machine Language:	d0 = SuperState( ) 
Modula-2:		SuperState( ): ADDRESS 
Arguments:		none 
Result:			sysStack = pointer to system stack; NULL if already in supervisor 
			mode
-------------------------
SwapBitsRastPortClipRect
Description:		engage supervisor mode using user-defined stack
Library:		layers.library
Offset:			-007E (-126)
Modula-2 Module:	Layers
Syntax:			SwapBitsRastPortClipRect(rastPort, clipRect)
C:			void SwapBitsRastPortClipRect(struct RastPort *, struct ClipRect *)
Machine Language:	SwapBitsRastPortClipRect(a0, a1)
Modula-2:		SwapBitsRastPortClipRect(rastPort: RastPortPtr; clipRect:
			ClipRectPtr)
Arguments:		rastPort = RastPort structure
			clipRect = ClipRect to swap bits with
Result:			none
-------------------------
SyncSBitMap
Description:		copies all bits from a layer's ClipRects into the SuperBitMap
Library:		layers.library
Offset:			-01BC (-444)
Modula-2 Module:	Clip
Syntax:			SyncSBitMap(layer)
C:			void SyncSBitMap(struct Layer *)
Machine Language:	SyncSBitMap(a0)
Modula-2:		SyncSBitMap(layer: LayerPtr)
Arguments:		layer = a locked layer that contains a SuperBitMap
Result:			none
-------------------------
Text
Description:		prints text in a RastPort using the current font
Library:		graphics.library
Offset:			-$003C (-60)
Modula-2 Module:	Text
Syntax:			Text(rastPort, string, length)
C:			void Text(struct RastPort *, char *, long)
Machine Language:	Text(a1, a0, d0)
Modula-2:		Text(rastPort: RastPortPtr; string: STRPTR; length: CARDINAL)
Arguments:		rastPort = RastPort where text is to be output
			string = text to print
			length = number of characters in string
Result:			none
-------------------------
Textlength
Description:		finds the length (in bits) that a string of characters would occupy
			if printed to a RastPort using the current text font
Library:		graphics.library
Offset:			-$0036 (-54)
Modula-2 Module:	Text
Syntax:			size = TextLength(rastPort, string, length)
C:			long TextLength(struct RastPort *, char *, long)
Machine Language:	d0 = TextLength(a1, a0, d0)
Modula-2:		TextLength(rastPort: RastPortPtr; string: STRPTR; length: CARDI-
			NAL): CARDINAL
Arguments:		rastPort = RastPort where text would be output
			string = text to print
			length = number of characters in string
Result:			size = number of pixels (horizontally) required to print the speci-
			fied text
-------------------------
ThinLayerInfo
Description:		converts a 1.1 LayerInfo structure into a 1.0 LayerInfo structure,
			thus returning the extra memory allocate by FattenLayerInfo (this
			is an obsolete function)
Library:		layers.library
Offset:			-$00A2 (-162)
Modula-2 Module:	none
Syntax:			ThinLayerInfo(layerInfo)
C:			void ThinLayerInfo(struct Layer_Info *)
Machine Language:	ThinLayerInfo(a0)
Modula-2:		not available
Arguments:		layerInfo = LayerInfo structure to convert
Result:			none
------------------------- 
Translate
Description:		converts an English string into phonetics
Library:		translator.library
Offset:			-$001E (-30)
Modula-2 Module:	Translator
Syntax:			error = Translate(instring, inlen, outbuf, outlen)
C:			long Translate(char *, long, char *, long)
Machine Language:	d0 = Translate(a1, d0, a1, d1)
Modula-2:		Translate(instring: STRPTR; inlen: LONGCARD; outbuf: STRPTR;
			outlen: LONGCARD): LONGINT
Arguments:		instring = English string to convert
			inlen = number of characters in instring
			outbuf = buffer to hold phonetic codes
			outlen = size of outbuf in bytes
Result:			error = 0 if successful; negative number representing position in
			instring where function was forced to stop because the output
			buffer overflowed
-------------------------
TypeOfMem
Description:		determines the attributes of a given memory address
Library:		exec.library
Offset:			-$0216 (-534)
Modula-2 Module:	Memory
Syntax:			attributes = TypeOfMem(address)
C:			long TypeOfMem(void *)
Machine Language:	d0 = TypeOfMem(a0)
Modula-2:		TypeOfMem(address: ADDRESS): MemReqSet
Arguments:		address = memory address
Result:			attributes = type of memory-MEMF_CHIP, MEMF_FAST,
			MEMF_PUBLIC
-------------------------
UnGetCLChar
Description:		adds a byte to the beginning of a character list
Library:		clist.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			error = UnGetCLChar(cList, byte)
C:			long UnGetCLChar(long, long)
Machine Language:	d0 = UnGetCLChar(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			byte = byte to add to beginning of character list
Result:			error = 0 if successful
-------------------------
UnGetCLWord
Description:		adds a word to the beginning of a character list
Library:		clist.library
Offset:			-$0060 (-96)
Modula-2 Module:	none
Syntax:			error = UnGetCLWord(cList, word)
C:			long UnGetCLWord(long, long)
Machine Language:	d0 = UnGetCLWord(a0, d0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
			word = word to add to beginning of character list
Result:			error = 0 if successful; 1 if unsuccessful
-------------------------
UnLoadSeg
Description:		removes a segment from memory
Library:		dos.library
Offset:			-$009C (-156)
Modula-2 Module:	DOSLoader
Syntax:			UnLoadSeg(segment)
C:			void UnLoadSeg(BPTR)
Machine Language:	UnLoadSeg(d1)
Modula-2:		UnLoadSeg(segment: BPTR): BOOLEAN
Arguments:		segment = BCPL pointer to a segment as returned by LoadSeg( )
Result:			none
-------------------------
UnLock
Description:		unlocks a directory or file
Library:		dos.library
Offset:			-$005A (-90)
Modula-2 Module:	DOS
Syntax:			UnLock(lock)
C:			void UnLock(BPTR)
Machine Language:	UnLock(d1)
Modula-2:		UnLock(lock: FileLock)
Arguments:		lock = BCPL pointer to a lock
Result:			none
-------------------------
UnlockIBase
Description:		releases the lock on IntuitionBase so Intuition can change the
			structure as it pleases
Library:		intuition.library
Offset:			-$01A4 (-420)
Modula-2 Module:	IntuitionBase
Syntax:			UnLockIBase(lockNumber)
C:			void UnLockIBase(long)
Machine Language:	UnLockIBase(a0)
Modula-2:		UnLockIBase(lockNumber: LONGCARD)
Arguments:		lockNumber = Intuition lock value as returned by LockIBase( )
Result:			none
-------------------------
UnlockLayer
Description:		unlocks a Layer so the graphics routines can use it
Library:		layers.library
Offset:			-$0066 (-102)
Modula-2 Module:	Layers
Syntax:			UnLockLayer(layer)
C:			void UnLockLayer(struct Layer *)
Machine Language:	UnLockLayer(a0)
Modula-2:		UnLockLayer(layer: LayerPtr)
Arguments:		layer = Layer structure to unlock
Result:			none
-------------------------
UnlockLayerInfo
Description:		unlocks a Layer_Info structure
Library:		layers.library
Offset:			-$008A (-138)
Modula-2 Module:	Layers
Syntax:			UnlockLayerInfo(layerlnfo)
C:			void UnlockLayerInfo(struct Layer_Info *)
Machine Language:	UnlockLayerInfo(a0, a1)
Modula-2:		UnlockLayerInfo(layerlnfo: LayerlnfoPtr)
Arguments:		layerlnfo = Layer_Info structure to unlock
Result:			none
-------------------------
UnlockLayerRom
Description:		unlocks a Layer so the graphics routines can use it (this function
			uses ROM code as opposed to LockLayerRom( )'s RAM-based
			code)
Library:		graphics.library
Offset:			-$01B6 (-438)
Modula-2 Module:	RomLayers
Syntax:			UnLockLayerRom(layer)
C:			void UnLockLayerRom(struct Layer *)
Machine Language:	UnLockLayerRom(a5)
Modula-2:		UnLockLayerRom(layer: LayerPtr)
Arguments:		layer = Layer structure to unlock
Result:			none
-------------------------
UnlockLayers
Description:		unlocks all layers so the graphics routines can use them
Library:		layers.library
Offset:			-$0072 (-114)
Modula-2 Module:	Layers
Syntax:			UnLockLayers(layerInfo)
C:			void UnLockLayers(struct Layer_Info *)
Machine Language:	UnLockLayers(a0)
Modula-2:		UnLockLayers(layerInfo: LayerInfoPtr)
Arguments:		layerInfo = Layer_Info structure
Result:			none
-------------------------
UnPutCLChar
Description:		gets a byte from the end of a character list
Library:		clist.library
Offset:			-$0048 (-72)
Modula-2 Module:	none
Syntax:			byte= UnPutCLChar(cList)
C:			long UnPutCLChar(long)
Machine Language:	d0 = UnPutCLChar(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			byte = byte from end of character list; -1 no data
-------------------------
UnPutCLWord
Description:		gets a word from the end of a character list
Library:		clist.library
Offset:			-$0066 (-102)
Modula-2 Module:	none
Syntax:			word = UnPutCLWord(cList)
C:			long UnPutCLWord(long)
Machine Language:	d0 = UnPutCLWord(a0)
Modula-2:		not available
Arguments:		cList = character list descriptor, as returned by AllocCList( ) or
			StrToCL( )
Result:			word = word from end of character list; -1 if no data
-------------------------
UpFrontLayer
Description:		moves a layer in front of all other layers
Library:		layers.library
Offset:			-$0030 (-48)
Modula-2 Module:	Layers
Syntax:			success = UpFrontLayer(dummy, layer)
C:			long UpFrontLayer(struct Layer_Info *, struct Layer *)
Machine Language:	d0 = UpFrontLayer(a0, a1)
Modula-2:		UpfrontLayer(layer: LayerPtr): BOOLEAN
Arguments:		dummy = unused
			layer = pointer to Layer to move behind other layers
Result:			success = TRUE if successful; FALSE if unsuccessful
-------------------------
UserState
Description:		return to user state and system stack (do NOT call if computer is
			already in user state)
Library:		exec.library
Offset:			-009C (-156)
Modula-2 Module:	Interrupts
Syntax:			UserState(sysStack)
C:			void UserState(char *)
Machine Language:	UserState(d0)
Modula-2:		UserState(sysStack: ADDRESS)
Arguments:		sysStack = system stack pointer as returned by SuperState( )
Result:			none
-------------------------
Vacate
Description:		releases a semaphore locked by Procure( )
Library:		exec.library
Offset:			-$0222 (-546)
Modula-2 Module:	Semaphores
Syntax:			Vacate(semaphore)
C:			void Vacate(struct Semaphore *)
Machine Language:	Vacate(a0)
Modula-2:		Vacate(semaphore: SemaphorePtr)
Arguments:		semaphore = Semaphore structure to release
Result:			none
-------------------------
VBeamPos
Description:		returns the current position of the vertical video beam
Library:		graphics.library
Offset:			-$0180 (-384)
Modula-2 Module:	Views
Syntax:			pos = VBeamPos( )
C:			long VBeamPos(void)
Machine Language:	d0 = VBeamPos( )
Modula-2:		VBeamPos( ): CARDINAL
Arguments:		none
Result:			pos = current beam position (0-511)
-------------------------
ViewAddress
Description:		returns the address of Intuition's View structure
Library:		intuition.library
Offset:			-$0126 (-294)
Modula-2 Module:	Intuition
Syntax:			view = ViewAddress( )
C:			struct View *ViewAddress(void)
Machine Language:	d0 = ViewAddress( )
Modula-2:		ViewAddress( ): ViewPtr
Arguments:		none
Result:			view = address of the Intuition View structure
------------------------- 
ViewPortAddress
Description:		returns the address of a window's ViewPort structure
Library:		intuition.library
Offset:			-$012C (-300)
Modula-2 Module:	Intuition
Syntax:			viewPort = ViewPortAddress(window)
C:			struct ViewPort *ViewPortAddress(struct Window *)
Machine Language:	d0 = ViewPortAddress(a0)
Modula-2:		ViewPortAddress(window: WindowPtr): ViewPortPtr
Arguments:		window = Window structure
Result:			viewPort = address of window's ViewPort structure
-------------------------
Wait
Description:		waits for one or more signals
Library:		exec.library
Offset:			-$013E (-318)
Modula-2 Module:	Tasks
Syntax:			signals = Wait(signalSet)
C:			long Wait(long)
Machine Language:	d0 = Wait(d0)
Modula-2:		Wait(signalSet: SignalSet): SignalSet
Arguments:		signalSet = set of signals to wait for
Result:			signals = signals that have occurred
-------------------------
WaitBlit
Description:		waits for the blitter to finish what it's doing
Library:		graphics.library
Offset:			-$00E4 (-228)
Modula-2 Module:	Blitter
Syntax:			WaitBlit( )
C:			void WaitBlit(void)
Machine Language:	WaitBlit( )
Modula-2:		WaitBlit( )
Arguments:		none
Result:			none
------------------------- 
WaitBOVP
Description:		waits for the vertical beam to reach the bottom of a ViewPort
Library:		graphics.library
Offset:			-$0192 (-402)
Modula-2 Module:	Views
Syntax:			WaitBOVP(viewPort)
C:			void WaitBOVP(struct ViewPort *)
Machine Language:	WaitBOVP(a0)
Modula-2:		WaitBOVP(viewPort: ViewPortPtr)
Arguments:		viewPort = ViewPort structure
Result:			none
-------------------------
WaitForChar
Description:		waits a specified amount of time for a character to become avail-
			able from a virtual terminal
Library:		dos.library
Offset:			-$00CC (-204)
Modula-2 Module:	DOS
Syntax:			avail = WaitForChar(file, timeout)
C:			long WaitForChar(BPTR, long)
Machine Language:	d0 = WaitForChar(d1, d2)
Modula-2:		WaitForChar(file: FileHandle; timeout: LONGINT): BOOLEAN
Arguments:		file = BCPL pointer to a file handle
			timeout = number of microseconds to wait for character
Result:			avail = TRUE if a character is available
-------------------------
WaitIO
Description:		waits for an I/O request to be executed
Library:		exec.library
Offset:			-$01DA (-474)
Modula-2 Module:	IO
Syntax:			error = WaitIO(ioRequest)
C:			long WaitIO(struct IORequest *)
Machine Language:	d0 = WaitIO(a1)
Modula-2:		WaitIO(ioRequest: ADDRESS): INTEGER
Arguments:		ioRequest = IORequest block
Result:			error = 0 if successful
-------------------------
WaitPort
Description:		waits for a message
Library:		exec.library
Offset:			-$0180 (-384)
Modula-2 Module:	Ports
Syntax:			message = WaitPort(port)
C:			struct Message *WaitPort(struct MsgPort *)
Machine Language:	d0 = WaitPort(a0)
Modula-2:		WaitPort(port: MsgPortPtr): ADDRESS
Arguments:		port = message port to receive message
Result:			message = pointer to first available message
-------------------------
WaitTOF
Description:		waits for the next vertical blank
Library:		graphics.library
Offset:			-$010E (-270)
Modula-2 Module:	Views
Syntax:			WaitTOF( )
C:			void WaitTOF(void)
Machine Language:	WaitTOF( )
Modula-2:		WaitTOF( )
Arguments:		none
Result:			none
-------------------------
WBenchToBack
Description:		moves the Workbench screen behind all other screens
Library:		intuition.library
Offset:			-$0150 (-336)
Modula-2 Module:	Intuition
Syntax:			success = WBenchToBack( )
C:			long WBenchToBack(void)
Machine Language:	d0 = WBenchToBack( )
Modula-2:		WBenchToBack( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if Workbench screen is open
-------------------------
WBenchToFront
Description:		moves the Workbench screen in front of all other screens
Library:		intuition.library
Offset:			-$0156 (-342)
Modula-2 Module:	Intuition
Syntax:			success = WBenchToFront( )
C:			long WBenchToFront(void)
Machine Language:	d0 = WBenchToFront( )
Modula-2:		WBenchToFront( ): BOOLEAN
Arguments:		none
Result:			success = TRUE if Workbench screen is open
-------------------------
WhichLayer
Description:		finds the layer which contains the specified point
Library:		layers.library
Offset:			-$0084 (-132)
Modula-2 Module:	Layers
Syntax:			layer = WhichLayer(layerlnfo, x, y)
C:			struct Layer *WhichLayer(struct Layer_Info *, long, long)
Machine Language:	d0 = WhichLayer(a0, d0, d1)
Modula-2:		WhichLayer(layerlnfo: LayerlnfoPtr; x, y: LONGCARD): LayerPtr
Arguments:		layerlnfo = Layerlnfo structure
			x = horizontal coordinate of point
			y = vertical coordinate of point
Result:			layer = pointer to top-most layer containing this point; NULL if
			point is not in a layer
-------------------------
WindowLimits
Description:		sets the minimum and maximum size of a window
Library:		intuition.library
Offset:			-$013E (-318)
Modula-2 Module:	Intuition
Syntax:			success = WindowLimits(window, minWidth, minHeight,
			maxWidth, minHeight)
C:			long WindowLimits(struct Window *, long, long, long, long)
Machine Language:	d0 = WindowLimits(a0, d0, d1, d2, d3)
Modula-2:		WindowLimits(window: WindowPtr; minWidth, minHeight,
			maxWidth, maxHeight: LONGINT): BOOLEAN
Arguments:		window = window to set size limits for
			minWidth = window's new minimum width
			minHeight = window's new minimum height
			maxWidth = window's new maximum width
			maxHeight = window's new minimum height
Result:			success = TRUE if all limits are set; FALSE if any of the limits are
			out of range, in which case only the legal limits are set
-------------------------
WindowToBack
Description:		moves a window to the back of all other windows
Library:		intuition.library
Offset:			-$0132 (-306)
Modula-2 Module:	Intuition
Syntax:			WindowToBack(window)
C:			void WindowToBack(struct Window *)
Machine Language:	WindowToBack(a0)
Modula-2:		WindowToBack(window: WindowPtr)
Arguments:		window = window to move to back of display
Result:			none
-------------------------
WindowToFront
Description:		moves a window in front of all other windows
Library:		intuition.library
Offset:			-$0138 (-312)
Modula-2 Module:	Intuition
Syntax:			WindowToFront(window)
C:			void WindowToFront(struct Window *)
Machine Language:	WindowToFront(a0)
Modula-2:		WindowToFront(window: WindowPtr)
Arguments:		window = window to move to front of display
Result:			none
-------------------------
Write
Description:		writes bytes of data to a file
Library:		dos.library
Offset:			-$0030 (-48)
Modula-2 Module:	DOS
Syntax:			length = Write(file, buffer, length)
C:			long Write(BPTR, char *, long)
Machine Language:	d0 = Write(d1, d2, d3)
Modula-2:		Write(file: FileHandle; buffer: ADDRESS; length: LONGINT):
			LONGINT
Arguments:		file = BCPL pointer to a file handle
			buffer = pointer to start of buffer containing data to write
			length = number of bytes to write
Result:			length = number of bytes successfully written; -1 if error
			occurred
-------------------------
WriteExpansionByte
Description:		writes a byte to a new-style memory expansion board-nybble by
			nybble
Library:		expansion.library
Offset:			-$0072 (-114)
Modula-2 Module:	Expansion
Syntax:			error = WriteExpansionByte(board, offset, byte)
C:			long WriteExpansionByte(long, long, long)
Machine Language:	d0 = WriteExpansionByte(a0, d0, d1)
Modula-2:		WriteExpansionByte(board: ADDRESS; offset: LONGCARD; byte:
			BYTE): BOOLEAN
Arguments:		board = base of a new-style expansion board
			offset = logical offset from the configdev base
			byte = byte to write to board
Result:			error = 0 if successful
-------------------------
WritePixel
Description:		colors a single pixel with the current foreground drawing pen
Library:		graphics.library
Offset:			-$0144 (-324)
Modula-2 Module:	Pens
Syntax:			error = WritePixel(rastPort, x, y)
C:			long WritePixel(struct RastPort *, long, long)
Machine Language:	d0 = WritePixel(a1, d0, d1 )
Modula-2:		WritePixel(rastPort: RastPortPtr; x, y: INTEGER): INTEGER
Arguments:		rastPort = RastPort structure containing pixel to color
			x = horizontal coordinate of pixel
			y = vertical coordinate of pixel
Result:			error = 0 if successful; -1 if pixel is outside specified RastPort
-------------------------
XorRectRegion
Description:		performs a 2d XOR operation of a rectangle with a region, leaving
			the results in the region
Library:		graphics.library
Offset:			-$022E (-558)
Modula-2 Module:	Regions
Syntax:			status = XorRectRegion(region, rectangle)
C:			long XorRectRegion(struct Region *, struct Rectangle *)
Machine Language:	d0 = XorRectRegion(a0, a1)
Modula-2:		XorRectRegion(region: RegionPtr; rectangle: RectanglePtr):
			BOOLEAN
Arguments:		region = Region structure
			rectangle = Rectangle structure
Result:			status = TRUE if successful; FALSE if out of memory
-------------------------
XorRegionRegion
Description:		performs a 2d XOR operation of one region with a second region,
			leaving the results in the second region
Library:		graphics.library
Offset:			-$026A (-618)
Modula-2 Module:	Regions
Syntax:			status = XorRegionRegion(region1, region2)
C:			long XorRegionRegion(struct Region *, struct Region *)
Machine Language:	d0 = XorRegionRegion(a0, a1)
Modula-2:		XorRegionRegion(region1, region2: RegionPtr): BOOLEAN
Arguments:		region1 = Region structure
			region2 = Region structure
Result:			status = TRUE if successful; FALSE if out of memory
-------------------------
Amiga Hardware Registers

The Amiga's hardware is accessed via registers- locations within a chip
that control it's operation or return status information about the chip.  A
register is accessed by R/W operations just like RAM.

Warning: You should never attempt to read a write-only register.  Doing so
will place a random value in that register and possibly cause a lockup.  For
the same reason, never use BCLR or BSET on a write-only register as these
two instructions perform a read prior to clearing or setting the specified
bit.  Write-only registers will be annotated with a (*W), and read-only
registers with a (*R) in the Status header.  A third type of register is a
Strobe register.  These are used by the Amiga to signify that an event has
occurred.  You should NEVER READ OR WRITE to a strobe register as the
operation may falsely trigger the strobe and confuse the Amiga.

SET/CLR Bit: Some registers contain a bit labeled "SET/CLR".  This is a
special bit that allows you to set or clear the register's other bits
without using AND or OR.  SET/CLR will always be bit 15.  What happens to a
register that contains a SET/CLR bit depends on the way you set this bit.
If it is set to zero, any other bit that is written to with a one will be
cleared.  If bit 15 is set to one, any other bit that is written to with a
one will be set to one.  All bits written to with a zero remain unaffected.
So, to clear all the bits, use $7FFF.  To set all bits, use $FFFF.  The
SET/CLR bit is useful ONLY on write-only registers.  On read only registers,
this bit always returns a value of zero.

Now that you realize how the bit operations work, here are the custon chip
register addresses and explanations:

----------------------------------------------------------------------------
$DFF000 BLTDDAT      Blitter Destination Data (early read dummy address)
Status: DMA Only     Agnus
                     Just before a word of data is moved into RAM by the
                     blitter, it's stored here.  This register cannot be
                     accessed by the 68K or the copper.  It's used
                     exclusively by the blitter DMA.  Writing to it does
                     nothing.  Reading returns a seemingly random number
----------------------------------------------------------------------------
$DFF002 DMACONR      DMA Enable Read
Status: *R           Agnus/Paula
                     0  AUD0EN   1 = Audio channel 0 DMA enabled
                     1  AUD1EN
                     2  AUD2EN
                     3  AUD3EN
                     4  DSKEN    1 = Disk DMA enabled
                     5  SPREN    1 = Sprite DMA enabled
                     6  BLTEN    1 = Blitter DMA enabled
                     7  COPEN    1 = Copper DMA enabled
                     8  BPLEN    1 = Bit-plane DMA enabled
                     9  DMAEN    0 = DMA for all channels disabled
                     10 BLTPRI   1 = Blitter has full priority over 68K
                                 0 = Blitter has partial priority
                     11 UNUSED
                     12 UNUSED
                     13 BZERO    1 = If the last blitter operation output 
                                     zeroes only.  No bits were set in
                                     destination RAM.
                     14 BBUSY    1 = Blitter is busy ("blitting") See note
                     15 SETCLR   UNUSED

Note: Because of timing problems with 68020/68030 processors, you must wait
a short while before testing BBUSY.  A "btst #14,DMACONR" before the test
will provide the appropriate delay.  (i.e.: BTST twice)
----------------------------------------------------------------------------
$DFF004 VPOSR        Vertical Beam Position Read
Status: *R           Agnus
                     0  V8       The high bit of the vertical beam position
                                 (1 = pos > 255)
                  1-14  UNUSED
                    15  LOF      Interlace Long Frame Flag (1 = a long frame
                                 is being drawn (even), 0 = a short frame
                                 (odd))

----------------------------------------------------------------------------
$DFF006 VHPOSR       Vertical/Horizontal Beam Position Read
Status: *R           Agnus
                   0-7  H1-H8    Video beam's horizontal position in
                                 increments of two lo-res pixels
                  8-15  V0-V7    Low 8 bits of video beam's horizontal pos

Note: If bit 3 in register BPLCON0 ($DFF100) is set, the Amiga returns the
light pen position and NOT the raster position!  Also, the location and size
of the visible screen area changes accordingly with the DIWSTRT and DIWSTOP
(Display Window Start/Stop @ $DFF08E / $DFF090).  These registers are
changed by Preferences each time you adjust the display-centering gadget.
Normal Visible Screen area is - horizontal : $40 - $E0
                                  vertical : $2C - $F4
----------------------------------------------------------------------------
$DFF008 DSKDATR      Disk Data Read (early read dummy address -Disk DMA)
                     SEE $DFF000 (BLTDDAT) for explanation.
----------------------------------------------------------------------------
$DFF00A JOY0DAT      Joystick/Mouse Port 0 Data
$DFF00C JOY1DAT                     Port 1 Data
Status: *R          Denise
                     For Mouse Use:
                   0-7           Horizontal Position Counter
                  8-15           Vertical Position Counter
                     For Joystick Use:
                     0 EOR BIT 1 Down (1 = stick down)
                     1           Right(1 = stick right)
                     8 EOR BIT 9 Up   (1 = stick up)
                     9           Left (1 = stick left)
                     For Paddle Use:
                     1           Right paddle fire button (1 = fire)
                     9           Left paddle fire button  (1 = fire)
----------------------------------------------------------------------------
$DFF00E CLXDAT       Collision Data
Status: *R           Denise
if set to one...     0  Even bit plane collided with odd bit plane
                     1  Odd plane collided with sprite 0 or 1
                     2                     with sprite 2 or 3
                     3                                 4 or 5
                     4                                 6 or 7
                     5  Even plane collide with sprite 0 or 1
                     6                                 2 or 3
                     7                                 4 or 5
                     8                                 6 or 7
                     9  Sprite 0 or 1 collide with 2 or 3
                    10         0 or 1              4 or 5
                    11         0 or 1              6 or 7
                    12         2 or 3              4 or 5
                    13         2 or 3              6 or 7
                    14         4 or 5              6 or 7
                    15  UNUSED

Note: When you read this register, all bits are cleared, so be sure to save
it if you need it's contents if you want to check for more than one type of
collision.  Bitplane collisions are extremely flexible.  See CLXCON
($DFF098) for more info.D
----------------------------------------------------------------------------
$DFF010 ADKCONR      Audio/Disk Control Read
Status: *R           Paula
                     0 ATVOL0 1 = Audio channel 0 modulates channel 1 volume
                     1 ATVOL1 1 =               1                   2
                     2 ATVOL2 1 =               2                   3
                     3 ATVOL3 1 = Output of audio channel 3 disabled
                     4 ATPER0 1 = Audio channel 0 modulates channel 1 period
                     5 ATPER1 1 =               1                   2
                     6 ATPER2 1 =               2                   3
                     7 ATPER3 1 = Output of audio channel 3 disabled
                     8 FAST   1 = MFM:2 us per bit disk operation (normDOS)
                              0 = GCR:4 us per bit disk op (double density)
                     9 MSBSYNC    1 = GCR-format synchronization for disk
                                      operations enabled (not used by DOS)
                    10 WORDSYNC   1 = Disk Controller is synchronizing on
                                      the data word found in the DSKSYNC
                                      register ($DFF07E) typically set to
                                      $4489 for MFM.
                    11 UARTBRK    1 = RS232 break-signal is occuring on the
                                      serial TxD line.
                    12 MFMPREC    1 = MFM selected
                                  0 = GCR selected
                 13-14 PRECOMP    Disk precompensation time (00=none,
                                  01=140 nsec, 10=280 nsec, 11=560 nsec)
                    15 SETCLR     UNUSED

Note: ADKCONR is a read version of ADKCON ($DFF09E).  See that register for
a complete explanation of each bit.
----------------------------------------------------------------------------
$DFF012 POT0DAT      Pot (Paddle/Proportional Joystick) Port 0/1 Data Read
$DFF014 POT1DAT 
Status: *R           Paula
                       For Paddle Use:
                   0-7 Left Paddle Counter (0 = completely CCW)
                  8-15 Right Paddle Counter(0 = completely CCW)
                       For Proportional Joystick Use:
                   0-7 Horizontal Counter (0 = stick pushed left)
                  8-15 Vertical Counter   (0 = stick pushed down)
----------------------------------------------------------------------------
$DFF016 POTGOR       Pot Port Data Read
Status: *R           Paula
                     0 START  Trigger bit for starting pot counters
                              (always reads zero)
                   1-7 UNUSED Reserved for Chip ID
                     8 DATLX  Current state of pin 9 on game port 1 (0/1)
                     9 OUTLX  Output enable for pin 9 on game port 1 (zero)
                    10 DATLY  Current state of pin 5 on game port 1 (0/1)
                    11 OUTLY  Output enable for pin 5 on game port 1 (zero)
                    12 DTARX  Current state of pin 9 on game port 0 (0/1)
                    13 OUTRX  Output enable for pin 9 on game port 0 (zero)
                    14 DATRY  Current state of pin 5 on game port 0 (0/1)
                    15 OUTRY  Output enable for pin 5 on game port 0 (zero)

Notes: This is the read address for the POTGO register ($DFF034).  Most of
the bits in this register are write-only and always return a zero when read.
Only bits 8, 10, 12, and 14 return valid data.  The remaining bits are
controlled via the POTGO register.  (See for more info on these bits)
   The Amiga's game ports are quite versatile.  Pins 5 and 9 of either port
can be programmed to receive and send digital data.  This register allows
you to read the current high-low state of these pins.
   Simply read the desired pin's DATxx bit to determine its status.  (0 =
0v, 1 = +5v)  The positive voltage sent to these pins should never exceed 5
volts or 400 mA.  ONLY THE VOLTAGE FROM PIN 7 SHOULD BE CONNECTED TO PIN 5
OR 9.  PIN 7 CARRIES +5 VOLTS FROM THE AMIGA'S OWN POWER SUPPLY.
   The right mouse button is wired to game port pins 8 and 9.  When the
button is pressed, these two pins connect.  Pin 8 is grounded, so any
voltage that 9 carries gets shorted to ground.
   To sense whether the right mouse button is being pressed on a mouse
plugged into game port 0, you must first set pin 9 to output.  (i.e.:
OUTLY = 1 or write $0C00 to POTGO.  For a mouse plugged into port 1, use
OUTRY and DATRY instead.)  Finally, wait about 300 msec for the voltage to
reach the game port - and then read the status of pin 9 via the DATLY bit in
POTGOR.  If this bit equals one, the pin is not grounded, thus the button is
not pressed.  If it equals zero, the pin is grounded, and the button has
been pressed.
   Because Intuition automatically handles game port 0 mouse events, you'll
have to turn off multitasking if you wish to control this port directly via
the hardware.  Even accessing port 1 may cause problems since any
manipulation of POTGO affects all of the bits.  Such confusion usually
results in the Amiga thinking that the right mouse button is being clicked
when it really isn't.
   Rather than calculate a 300 msec delay, you may write a #$C000 to POTGO
and wait for one vertical blanking period with the following:
            WaitVertB:
               move.l VPOSR,d0
               and.l  #$0001FF00,d0
               bne    WaitVertB
               rts
----------------------------------------------------------------------------
$DFF018 SERDATR      Serial Data Input and Status Read
Status: *R           Paula
                   0-7 DB0-DB7   Byte of data read from serial port
                     8 DB8/STP   Ninth data bit or stop bit
                     9 STP       Stop bit if set up for 9 data bits
                    10 UNUSED
                    11 RxD       Current status of serial port's RxD line
                    12 TSRE      Transmit shift register empty (if 1)
                    13 TBE       Transmit buffer empty (if 1)
                    14 RBF       Receive buffer is full(if 1)
                    15 OVRUN     Receive buffer overrun (if 1)
----------------------------------------------------------------------------
$DFF01A DSKBYTR      Disk Data Byte and Disk Status Read
Status: *R           Paula
                   0-7 DATA      Byte of data read from disk
                  8-11 UNUSED
                    12 WORDEQUAL Disk Sync pattern found (if 1)
                    13 DISKWRITE Disk controller writing (if 1)
                                 Disk controller reading (if 0)
                    14 DMAOEN    Disk DMA is active (if 1)
                    15 BYTEREADY Bits 0-7 of this register will hold new
                                 data if bit 15 is set.

Notes: Considering the fact that disk data can be transferred to and from
memory automatically through DMA, it is neither necessary nor recommended
that you read data one byte at a time via 0-7, and 15.
   Bit 12: WORDEQUAL holds a one for only 2 usec!  (The time for one MFM bit
to pass under the head.)  AmigaDos uses $4489 for the sync.
----------------------------------------------------------------------------
$DFF01C INTENAR      Interrupt Enable Read
Status: *R           Paula
                     0 TBE    1 = Serial transmit buffer empty interrupt
                                  enabled (level 1)
                     1 DSKBLK 1 = Disk block done int enabled (level 1)
                     2 SOFT   1 = Software interrupts enabled (level 1)
                     3 PORTS  1 = CIA-A and expansion port interrupts
                                  enabled (level 2)
                     4 COPER  1 = Copper interrupt enabled (level 3)
                     5 VERTB  1 = Vertical Blank Int enabled (level 3)
                     6 BLIT   1 = Blitter ready int enabled (level 4)
                     7 AUD0   1 = Audio channel 1 int enabled (level 4)
                     8 AUD1                     2
                     9 AUD2                     3
                    10 AUD3                     4
                    11 DBF    1 = Serial receive buffer full interrupt
                                  enabled (level 5)
                    12 DSKSYN 1 = Disk sync pattern found int enab (lev 5)
                    13 EXTER  1 = CIA-B and expansion port int enab(lev 6)
                    14 INTEN      Master interrupt off switch  (0 = All
                                  ints listed above disabled)
                    15 SETCLR UNUSED by INTENAR

Notes: The Amiga's hardware is capable of generating 14 interrupts on seven
levels.  Level 1-6 are maskable, and level 7 is an NMI.  This register tells
you which ints are enabled or disabled.  To enable or disable an interrupt,
use this register's write address, INTENA ($DFF09A).  To force an interrupt
to take place, use register INTREQ ($DFF09C).  To actually find out what
type of interrupt is taking place, read INTREQR at $DFF01E.
   When the uP receives an interrupt signal, it takes the level number,
multiplies it by two, and adds $FFFFF1 to the result.  This calculation
produces the address of a byte long memory offset contained in ROM.  The
memory offset is then multiplied by four to obtain the address of the
interrupt's auto vector - a location that contains the pointer to the
corresponding interrupt processing routine.  Under the current version of
ROM, these four byte pointers are stored in locations $64, $68, $6C, $70,
$74, $78, and $7C, for the level 1-7 interrupts respectively.
   To prioritize interrupts that share the same level number, Exec has
assigned each interrupt a pseudo priority number.  Again, the higher this
number, the higher the priority:
      Interrupt               680x0 Level    Pseudo-Priority
      ---------                  -----            -----
      Software                     1                1
      Disk Block Done              1                2
      Transmit Buffer Empty        1                3
      CIA-A (exp bus pin 19)       2                1
      Copper                       3                1
      Vertical Blank               3                2
      Blitter Done                 3                3
      Audio Channel 2              4                1
      Audio Channel 0              4                2
      Audio Channel 3              4                3
      Audio Channel 1              4                4
      Read Buffer Full             5                1
      Disk Sync Pattern Found      5                2
      CIA-B (exp bus pin 22)       6                1

   If you plan on handling interrupts completely on your own, note that
interrupt processing routines are always executed in SUPERVISOR mode.  As a
minimum, your routine should clear the corresponding bit in the INTREQ
register to clear that interrupt.  Use the 680x0 instruction RTE to return
from an interrupt.
   To cause a raster interrupt to occur, simply make the copper wait for the
desired line, then store #$8010 in INTREQ:
      wait 0,100         ; wait for line 100
      move #$8010,INTREQ ; trigger interrupt
----------------------------------------------------------------------------
$DFF01E INTREQR      Interrupt Request
Status: *R           Paula
                     The bit by bit explanations are exactly the same
                     except that "enabled" is replaced with "requested".
                     See INTENAR ($DFF01C) for details.
----------------------------------------------------------------------------
$DFF020 DSKPTH       Disk Pointer
$DFF022 DSKPTL
Status: *W           Agnus
                     This is where you store the starting address of your
                     disk data prior to activating disk DMA.  DSKPT is
                     broken into a High and Low portion.  Note that if your
                     Amiga does not have a 1MB Agnus, you cannot specify
                     an address above $7FFFF.  Otherwise, it is $FFFFF.
                     The low bit is always interpreted as zero, so the
                     data must begin at an even location.
----------------------------------------------------------------------------
$DFF024 DSKLEN       Disk Data Length
Status: *W           Paula
                  0-13 LENGTH Number of words to read or write
                    14 WRITE  1 = Activate write mode  0 = read mode
                    15 DMAENA 1 = Enable Disk DMA  0 = Disable Disk DMA

Notes: You must write the same value TWICE in a row in order for the value
to take effect.  This double write rule was incorporated to safeguard
against accidental disk activity - programs that lose control and start
trashing memory can't just shove a number into this register and initiate
potentially harmful disk activity.
   Since the length must be stored in 14 bits, the data cannot be longer
than 32766 bytes.  The DMA hardware uses this length value as a counter.
Every time a word of data is transferred to or from disk, this counter is
decremented, and the address in the DSKPT register incremented.  Transfer
stops when this value reaches zero.
   Because of a bug in the Amiga Hardware, the last three bits of data are
missing.  To remedy this, save one more word than necessary.
   Before and after doing any disk operations, set this register to #$0000
to enable read mode and disable disk DMA.
   Bit 15: Setting this bit initiates disk DMA.  It will not start, however,
until the DMAENA bit in the ADKCON register ($DFF09E) is also set.  You'll
have to set both of these bits in order to perform any DMA-controlled disk
operations.  NEVER start disk DMA unless a previous operation is complete or
you may wind up trashing the data on the disk!  To find out when a read or
write operation is complete, use the disk block done interrupt, which can be
detected through the use of the DSKBLK bit (1) in the INTEQR register at
$DFF01E.
----------------------------------------------------------------------------
$DFF026 DSKDAT       Disk DMA Write
Status: *W           Paula
                     This is the data buffer used by the disk DMA when
                     transferring data.  It is the write address of the
                     DSKDATR register ($DFF008).
----------------------------------------------------------------------------
$DFF028 REFPTR       Refresh Pointer
Status: *W           Agnus
                     The Amiga uses this register as a RAM refresh address
                     register.  Do not modify the value there or you may
                     corrupt the contents of RAM!  It is for diagnostic
                     purposes only.
----------------------------------------------------------------------------
$DFF02A VPOSW        Vertical Beam Position Write
Status: *W           Agnus
                     This is the write address of the VPOSR register
                     located at $DFF004.  Note the warnings that apply for
                     the refresh pointer as they also apply.
----------------------------------------------------------------------------
$DFF02C VHPOSW       Vertical/Horizontal Beam Position Write
Status: *W           Agnus
                     This is the write address of the VHPOSR register
                     located at $DFF006.  Note the warnings that apply for
                     the refresh pointer as they also apply.

----------------------------------------------------------------------------
$DFF02E COPCON       Coprocessor Control
Status: *W           Agnus
                     0 UNUSED
                     1 CDANG  Copper Danger Bit (1 = Copper can access
                              blitter registers  0 = Copper cannot.)
                  2-15 UNUSED

Notes: A one value allows access to $DFF040+, and a zero value $DFF080+.
For instructions on the copper and its instruction set, see locations
$DFF080-$DFF08C.
----------------------------------------------------------------------------
$DFF030 SERDAT       Serial Data Output
Status: *W           Paula
                   0-7 DB0-DB7   Byte of data to be output
                     8 DB8/STP   Ninth data bit or stop bit
                     9 STP       Stop Bit if sending nine data bits
                 10-15 UNUSED    (See below)

Notes: To send data out the serial port, simply store it here.  Upon
receiving a nonzero value, the contents of the register are shifted out the
serial port - low bit first, high bit last until its contents are empty
(equal zero).  Since the start bit is sent automatically, DO NOT include it
as part of your data.  Because you must send at least one stop bit, SERDAT
should never equal zero.
   By convention, only 8 or 9 data bits should be stored in this register at
any on time.  However, because this is a true 16 bit register, up to 15 data
bits and one stop bit can be output in just one shot - an interesting, if
questionably useful feature.
----------------------------------------------------------------------------
$DFF032 SERPER       Serial Period (Transfer Rate) and Data Bit Control
Status: *W           Paula
                  0-14 RATE   Bit transfer rate specified in increments of
                              279.4 nsec.
                    15 LONG   Number of data bits to expect when receiving
                              data (1 = nine  0 = eight data bits)

Notes: The value stored in bits 0-14 determine how many bus cycles occur
between each bit sent or received through the serial port.  So, if one bit
is to be sent every X bus cycles, use X-1.  Serial transfer rates are
usually specified in baud rates, not bus cycles.  Use this formula to
translate the baud rate into the period value this regiester expects:
      Period = (3579546 / Baudrate) - 1
   The period value for the six most common baud rates are:
         Baud Rate   Period
         ---------   ------
            300       11931
            600       5965
           1200       2982
           2400       1490
           4800        745
           9600        372
   Bit 15: Affects incoming, not outgoing data length.
----------------------------------------------------------------------------
$DFF034 POTGO        Pot Port Data
Status: *W           Paula
                     See POTGOR at $DFF016 for an explanation on how this
                     write register works.
----------------------------------------------------------------------------
$DFF036 JOYTEST      JOY0DAT and JOY1DAT Write
Status: *W           Denise
                     This register allows you to set the contents of the
                     JOY0DAT and JOY1DAT registers at $DFF00A / $DFF00C.
                     The value stored here affects both registers,
                     allowing you to reset the mouse position counters for
                     both ports with just one instruction.
----------------------------------------------------------------------------
$DFF038 STREQU       Short Frame Vertical Blank Strobe
$DFF03A STRVBL       Normal Vertical Blank Strobe
$DFF03C STRHOR       Horizontal Sync Strobe
$DFF03E STRLONG      Long Raster Strobe
Status: Strobe       Denise (Denise/Paula on STRHOR)
                     Do not read to or write from any of these registers.
                     Doing so would falsely trigger the strobe and confuse
                     the Amiga.
----------------------------------------------------------------------------
Location Range: $DFF040-$DFF074  The Blitter Registers

   The blitter takes care of almost all of the Amiga's bitmapped graphics
manipulation, from drawing lines to moving objects and filling outlined
areas.  Intuition, for example, uses the blitter for such things as drawing
gadgets and printing text.  And one of the best things about the blitter is
that it executes independently, allowing the Amiga to animate objects while
the uP is hard at work executing program instructions.

   Copy Mode: The blitter's main task is to copy data from one area of
memory to another.  This operation is specified as a blit.  The blitter was
specifically designed to copy bitmap data, however, you can use the blitter
to copy whatever type of data you choose.
   Data to be copied may come from up to three different locations in
memory, but you can have only one destination address.  The blitter refers
to the source addresses as A, B, and C.  The destination area is called D.
   When using more than one source address, the blitter must combine the
data from the different sources before it can be written back out.  To do
this, it performs any combination of eight different logic operations called
miniterms.  Miniterms allow you to combine the bits from A, B, and C in 256
different ways before they reach their destination.  This provides the
programmer with great flexibility when copying bitmapped images.  Shapes can
be inverted, merged, "cookie cut", and so on.  Bits 0-7 in the BLTCON0
register at $DFF040 control the miniterm settings.
   The most common use for the blitter is to move rectangular areas of a
bitmapped screen.  Because of the way screen bitmaps are laid out, it would
be impractical if all you could do was to copy consecutive bytes in memory.
Instead, you must be able to skip several bytes between each horizontal
screen line.  That way, you don't have to copy objects that take up the
entire width of the screen.
   The BLTAMOD-BLTDMOD registers ($DFF060-$DFF066) allow you to specify the
difference between the width of the object being copied and the width of the
bitmap.  The BLTSIZE register at $DFF058 defines width and height of the
source and destination area.  Together these registers allow the blitter to
copy any rectangular area of a bitmap.
   The memory addresses of A, B, and C go in registers BLTAPT, BLTBPT, and
BLTCPT ($DFF050, $DFF04C, and $DFF048) respectively, and the D address goes
in register BLTDPT ($DFF054).  When specifying A, B, C, or D, you must
provide the blitter with an even, word aligned address.
   Because bitmapped objects don't always begin on a word aligned address,
and their width isn't always an even multiple of 16 (16 bits = 1 word), the
blitter can mask out certain bits in the first and last word of each
horizontal line copied from source A.  This way, you can copy an area that
starts at any pixel location and is of any pixel width you desire.  The
first word mask for source A goes in register BLTAFWM ($DFF044).  The last
word mask goes in register BLTALWM ($DFF046).  In effect, the first word of
each line is ANDed with BLTAFWM and the last word of each line is ANDed with
BLTALWM before they are written to destination RAM.
   To move bitmapped images horizontally with pixel accuracy, it is
necessary to shift the image's data one bit at a time.  Using bits 12-15 in
the BLTCON0 and BLTCON1 registers ($DFF040 and $DFF042), you can tell the
blitter to shift source A and/or source B data right 0-15 bits before it's
transferred to it's destination.  The shifting takes place within the
blitter so it does not affect the area of memory actually being copied.
   Shifting is not restricted by word boundaries; a word's low bit is
shifted into the high bit of the following word.  If there is no previous
word of data being copied (i.e. if the current word is the very first word
of data being copied), zeroes are shifted into the word's high bits.
   What happens when you need to shift something left, say a pixel?  Well,
simply shift it right (16-x) times.  The only difference is that your data
is one word further to the right.  Optionaly, you could also run the blitter
in descending mode.  In this mode, data is shifted left by the value stored
in bits 12-15 of the BLTCON0 and BLTCON1 registers.  Here's another reason
for operating the blitter in descending mode:
   The blitter is usually called upon to move objects around the screen.
Generally, a programmer will do this by copying an object's data from a
special buffer area in memory to the screen's bitmap.  (Since the blitter
can only copy to one destination area at a time, you'll have to do a blitter
operation for each bit plane.)  Next, a copy of the screen's background is
copied to the screen to erase the object.  Finally, the object is copied to
a different location on the screen, thus making in move.
   In the previous example, data was copied from two separate areas of
memory.  Sometimes it's desirable to copy to and from areas that overlap.
However, this may cause problems because the blitter may copy a piece of
data into a memory location that hasn't been read yet, thus destroying it.
(i.e. If the destination and source overlap, and the destination is higher
in memory, bye-bye data!)
   To avoid the problem of overlapping data, the blitter can be run in two
modes: ascending and descending.  When should you use descendong mode?
Well, if the end of the source overlaps the start of the destination, use
descending mode.  If the start of the source overlaps the end of the
destination, use ascending mode.  If the source and destination don't
overlap, it doesn't matter what you use.  The DESC bit (1) in the BLTCON1
register at $DFF042 determines the blitter's current mode.
   To initiate a blitter copy operation, you should first select the blitter
copy mode by NOT setting the LINE bit (0) in the BLTCON1 register at
$DFF042.  Second, tell the computer the address of your source data using
the BLTAPT, BLTBPT, BLTCPT, and the destination data at BLTDPT.  (These
addresses should specify the starting or ending addresses of the data
depending on whether the blitter is running in ascending or descending mode,
respectively.)  Third, use BLTCON0 to select the desired miniterms and tell
the computer which sources you're using (A, B, and/or C) and enable the
blitter's D destination channel.  (If you don't enable D, data isn't going
anywhere!)  Fourth, set up any other options you want such as shifting or
masking of data.  Finally, write the width and height of the area to be
copied into the BLTSIZE register at $DFF058.  Writing to BLTSIZE
automatically starts the blitter, so it SHOULD BE THE VERY LAST THING YOU
SET!  During the blitter operation, the BBUSY bit (14) in the DMACONR
register is set equal to one.  When the blitter is finished, this bit is
cleared.
   The following happens during a blitter copy operation: Data is copied one
word at a time from the memory address specified by the BLTxPT registers to
the address found in BLTDPT.  Every time a word is copied, the BLTxPT
registers are incremented (or decremented if in descending mode).  When the
number of words to b copied matches the width in the BLTSIZE register, the
modulation value found in the BLTxMOD registers is added to the BLTxPT
registers and the copying continues on the next line.  When the number of
lines copied equals the height in BLTSIZE, the operation is complete and the
blitter stops.

   Fill Mode: The blitter offers a crude area-fill option that works in
tandem with the data-copy operation described above.  Fill mode is activated
by BLTCON1's IFE (Inclusive Fill Enable) bit or EFE (Exclusive Fill Enable)
bit prior to turning on the blitter.  After the blitter reads data from
memory and manipulates it according to the miniterm settings, the specified
fill operation is performed on the data before it is written to destination
memory.  Fill operations work IN DESCENDING MODE ONLY!  The figure below
illustrates the effect of each type of fill operation has on data:

                           After:
            Before   FCI = 0   FCI = 1

           00011000  00011000  11111111
           00100100  00111100  11100111
           01000010  01111110  11000011
Fill       01000010  01111110  11000011
           00100100  00111100  11100111
           00011000  00011000  11111111

           00011000  00001000  11110111
           00100100  00011100  11100011
Exclusive  01000010  00111110  11000001
Fill       01000010  00111110  11000001
           00100100  00011100  11100011
           00011000  00001000  11110111

   In all fills, the blitter evaluates data one bit at a time, starting at
the rightmost edge and moving to the left.  Before the fill begins, however,
the blitter takes note of the FCI bit (2) of the BLTCON1 register.  The
value of this bit becomes the initial fill value of the blitter's fill bit.
For the sake of clarity, let's assume FCI starts at zero.
   Here's how inclusive fill works: As the blitter moves left, it changes
all zero bits to zero, because zero is the current value of the fill bit.
When the blitter encounters a 1 bit, it toggles the fill bit, changing it to
a one.  Now the blitter changes the following 0 bits to 1, because that is
the current value of the fill bit.  Every time the blitter encounters a 1
bit in the data, the fill bit changes value.  The figure above illustrates
the difference between fills that start with FCI = 0 or FCI = 1.
   Exclusive fills take one extra step when they encounter a 1 bot.  In
addition to toggling the fill bit, the blitter replaces that 1 bit with the
new fill-bit value.
   Both types of fills expect borders to be defined by a single 1 bit - one
bit to tell the blitter that it's inside an area, and the other to tell it
that it's outside.  When the blitter encounters two one bits in a row, it
assumes that there is no space to be filled since there is no zero bit
between pixels.  If the blitter encounters three 1 bits in a row, the
blitter assumes that it has gone in, out, then back in to an area to be
filled.  (The fill bit has been toggled three times.)  This happens when the
blitter runs across an odd number of adjacent bits.
   To execute a fill operation, simply set up the blitter registers for a
standard copy operation, set either the IFE or EFE bit, set the FCI bit to
the desired value, set the DESC to put the blitter in descending mode, then
start the blitter by writing the area size to the BLTSIZE register.  By
setting the blitter's source address equal to the destination address, you
can fill an area without having to copy data from one separate location to
another.

   Line Mode: Besides copying data and filling areas, the blitter has one
more talent: drawing lines.  In line mode, almost all of the blitter
registers change their functions.
   The blitter draws lines at incredible speeds, much faster than the 68000.
Unfortunately, you can't just give the blitter two points and then tell it
to connect the dots.  You need to perform some calculations first.
   Let's say that you want to draw a line from point (x1,y1) to (x2,y2).
From these coordinates you need to figure out the horizontal and vertical
distance between the line's two end points.  This is easily calculated using
the following two formulae:
      dx = abs(x1-x2)
      dy = abs(y1-y2)
   Now you're ready to give the BLTCON1 register at $DFF042 some information
about the physical orientation of the line.
      If (dx >= dy) and (x1 >= x2) set bit 2.
      If (dx < dy)  and (y1 >= y2) set bit 2.
      If (dx >= dy) and (y1 >= y2) set bit 3.
      If (dx < dy)  and (x1 >= x2) set bit 3.
      If (dx >=dy)                 set bit 4.
   Together, these bits define the octant (position relative to the line's
starting position) in which the line will appear.  The following shows how
the Amiga divides the screen into octants:

             \    |    /      * = x1,y1
              \ 3 | 1 /       Note: The numbers shown in this figure
             7 \  |  / 6      represent the combined value of BLTCON1's
                \ | /         bits 2-4.  If the line appears on the border
             -----*-----      of two octants, it does not matter which of
                / | \         the two octants you select.
             5 /  |  \ 4
              / 2 | 0 \
             /    |    \

   Next, you need to determine which value is larger: dx or dy.  Let dmax
equal the greater value, and dmin the lesser value.  Now use these values to
set the following registers:
      dmax = max(dx,dy)
      dmin = min(dx,dy)
         BLTBMOD = 4* dmin
         BLTAMOD = 4 * (dmax-dmin)
         BLTAPTL = (4 * dmin) - (2 * dmax)
   These formulae define the line's slope.  If the result of the last
calculation BLTAPTL is negative, you must store a 1 in the SIGN bit (6) of
the BLTCON1 register.
   Besides holding the line's octant number and the negative/positive status
of the line's slope, BLTCON1 affects the line's physical appearance.  If
you're drawing lines to enclose an area that you plan to fill later using
blitter fill mode, you should set the ONEDOT bit (1) equal to one.  This
tells the blitter to draw lines using only one pixel per raster, thus
providing a single pixel border for your object.
   To create textured lines, BLTCON1's bits 12-15 work in conjunction with
the BLTBDAT register ($DFF072).  The bit pattern found in BLTBDAT defines
the pixel pattern used to draw lines.  For normal solid lines, set all of
BLTBDAT's bits to one.  (i.e. $FFFF)  Other values create dotted or dashed
lines.  Bits 12-15 in BLTCON1 allow you to specify which bit in BLTBDAT,
0-15, defines the status of the first pixel in the line.  For most practical
purposes, BLTCON1's bits 12-15 should be set equal to the value of x1's
lower 4 bits.  (i.e. x1 AND $0F)  This informs the blitter to start the line
off with the value found in BLTBDAT's MSB (15).  IMPORTANT: ALWAYS SET
BLTCON1 PRIOR TO BLTBDAT!
   BLTCON1's bit 5 should always be set to zero, as should bits 7 through
11.  To tell the blitter that you want to draw lines instead of copy data,
the LINE bit (0) must be set to 1.
   The Amiga needs certain information about the size and location of the
screen's bitmap before it can draw a line.  First, store the byte-width
(number of pixels divided by 8) of the bitmap in the BLTCMOD and BLTDMOD
registers ($DFF060 and $DFF066).  Next, you must put the address of the word
containing the starting point of the line into the BLTCPT and BLTDPT
registers.  ($DFF048 and $DFF054)
   Only one bitplane can be written to during a single blitter operation.
So, to draw a line of a particular color on a multiple bitplane screen, it
may be necessary to perform two or more line blits.  In these cases, you set
the registers up for the first bitplane as usual, and perform the blit; then
for subsequent bitplanes, you simply reinitialize the registers with the
same values EXCEPT for the registers BLTCPT and BLTDPT, which must contain
the address of the line's starting point within the new bitplane.
   As with blitter copy mode, you must set bits 0-7 in the BLTCON0 register
($DFF040) to choose a miniterm.  Usually, you should store $CA here, but if
you prefer to XOR your line onto the screen (invert all the pixels found on
the line), store a $4A here.
   BLTCON0's bits 8-11 should be set equal to $B.  (This activates blitter
source A and C, and destination D.)  Store x1's lower four bits (x1 AND $0F)
into BLTCON0's bits 12-15.  The blitter uses this value to determine the bit
position of the line's starting point within the bitplane memory location
specified by registers BLTCPT and BLTDPT.
   Now, set BLTADAT ($DFF074) equal to $8000.  (Set this register only AFTER
you've set BLTCON0)  Only two more registers must be set before you can
activate the blitter: BLTAFWM and BLTALWM.  ($DFF044 and $DFF046)  Store a
$FFFF into both.
   Finally, you're ready to start the blitter by writing to the BLTSIZE
register ($DFF058).  Use the following formula to determine the value that
you should store into this register:
      BLTSIZE = (dmax * 64) + 66
   Because writing to BLTSIZE turns on the blitter, this should be the last
register that you set.

   General Guidelines: When programming the blitter at the hardware level
with multitasking turned on, you must be sure to grab the blitter for your
own exclusive use so other programs don't try to use it.  Using the library
function call OwnBlitter() you can reserve the blitter for your own
personal use.  The function call DisownBlitter() frees the blitter so other
programs can use it.
   Before writing to any of the blitter registers, you must be sure the
blitter isn't currently in operation, even after a call to OwnBlitter().  To
ensure the blitter's dormancy, you can use the function call WaitBlit(), or
you can read the status of the BBUSY bit found in the DMACONR register at
$DFF002.
   Under normal operation conditions, the Amiga's microprocessor has
priority over the blitter when it comes to accessing chip RAM.  Because of
the way memory cycles are allocated, memory conflicts rarely occur between
the blitter and the 68000.  However, if time is a critical factor, you can
give the blitter a higher priority than the 68000 by setting the BLTPRI bit
in the DMACON register ($DFF096).
   The blitter can perform so many special operations on a word of data that
it's important to know the order in which these operations take place.
Masking via the BLTAFWM and BLTALWM register takes effect first (assuming
the data was obtained from A and is either the first or last word of a
horizontal line.); next the data is shifter, if a shift was specified my the
source's shift bits (ASHx or BSHx); the miniterm operations are performed
next; and finally, the data is filled according to the status of BLTCON1's
EFE, IFE, and FCI bits.  Only after all this does the data reach its
destination.
   As a general rule, you should always write zeroes to any unused bits in
a blitter register.  On future versions of the Amiga blitter, these bits may
be used to perform new functions - functions that could freak your program
if mistakingly activated!
   In the following register explanations, a lowercase letter (i.e.: a, b,
c) will be used to specify a normal miniterm descriptor, and a capital
letter it's NOTted equivalent.  (i.e. A, B, C = NOT a, NOT b, NOT c)  This
is for the miniterm descriptors only!
----------------------------------------------------------------------------
$DFF040 BLTCON0      Blitter Control Register 0
Status: *W           Agnus
                     0 LF0    1 = Selects miniterm ABC
                     1 LF1    1 = Selects miniterm ABc
                     2 LF2    1 = Selects miniterm AbC
                     3 LF3    1 = Selects miniterm Abc
                     4 LF4    1 = Selects miniterm aBC
                     5 LF5    1 = Selects miniterm aBc
                     6 LF6    1 = Selects miniterm abC
                     7 LF7    1 = Selects miniterm abc
                     8 USED   1 = Enable DMA for D
                     9 USEC   1 = Enable DMA for C
                    10 USEB   1 = Enable DMA for B
                    11 USEA   1 = Enable DMA for A
                 12-15 ASH0-3 Preshift value for A
                     For Line Mode:
                   0-7 LF0-LF7   Miniterm value, usually $CA
                     8 USED      Set to 1
                     9 USEC      Set to 1
                    10 USEB      Set to 0
                    11 USEA      Set to 1
                 12-15 START0-3  Set to (x1 and #$0F)

   Here's how BLTCON0's bits operate in normal copy mode:
   Bits 0-7: Each of these bits controls a particular miniterm - a logical
operation performed on blitter source data before it reaches its
destination.  To activate a miniterm, simply set its bit equal to one.  You
may select as many or as few as you want.
   Using miniterms, you can slice and dice data in a variety of ways.
Suppose you set bit zero equal to one.  In this case, the miniterm is ABC.
What that means is that a one bit will be output to D only when:
      A=0, B=0, and C=0!  Any other combination results in a zero output.
Conversely, miniterm abc will output a one only when A, B, and C are equal
to one.
   For more complex results, it's possible to activate more than one
miniterm at once.  The resulting miniterms are added together (OR'ed) and
simplified.  Thus:  aBC + aBc can be simplified to aB.  (If the values are
different as in the case of the C's, they cancel out.)  You may expand aB in
the same way to aBC + aBc.
   To fill an area of memory with zeroes, don't select any miniterms.
Consequently, you can fill memory with #$FF's by selecting all of the
miniterms.  The following table contains the miniterm settings avaliable to
graphics.library function calls:
      Miniterm Val   Miniterm Logic    Result of Most Useful Settings
      ------------   --------------    ------------------------------
          #$00       always zero       Clear Destination
          #$10       aBC
          #$20       aBc
          #$30       aB                Copy inverted source to destination
          #$40       abC
          #$50       aC                Invert Destination
          #$60       aBc + abC         Merge (cookie cut) source with dest.
          #$70       aB + aC
          #$80       ABC               Write 1s only where source & dest
                                       overlap
          #$90       abc + aBC
          #$A0       ac
          #$B0       ac + aB
          #$C0       ab                Direct copy of source to destination
          #$D0       ab + aC
          #$E0       ac + ab           Combine (mix) source with destination
          #$F0       always one        Fill Destination

Note: Even if you try to set the lower four bits of a graphics.library
miniterm, the system will zero them out before actually writing this value
to the register's LFx bits.
      If you set the blitter's sources the same way that the
graphics.library does - A points to a mask (usually $FFFF), B points to the
source data, and C points to the Destination data - you can use this table
to determine the miniterm settings for your own blitter routines.
   When blitting with only one or two sources active, choose miniterms that
aren't affected by the value of the unused source(s).

   Bit 8: This bit determines whether the blitter's destination DMA is
enabled.  Seting this bit to one enabled the DMA, and 0 Disables it.  If
destination DMA is disabled, nothing can be written during a blit.  This
seemingly useless feature turns out to be quite useful feature for detecting
collisions between two images.  Simply set up the blitter for sources A and
B to point to the two images, select miniterm logic ab ($C0), activate the
blitter, wait for the blitter to finish, and then check the BZERO bit (13)
of the DMACON register at $DFF002.  If BZERO = 0, the images touch.  Because
the BZERO bit is valid even if the data isn't written to memory, you don't
need to activate destination D for this type of collision detection to work.

   Bits 9-10: These bits determine which of the blitter's sources: A, B,
and/or C are active during a blitter operation.  Writing a one to any of
these bits turns on the DMA for the corresponding source.  When the blitter
is turned on, data is read from the memory specified by the active source's
BLTxDAT register.  For this reason, it is important to PREINITIALIZE the
BLTxDAT register of all unused sources before performing a blit.  If you
don't want inactive sources to affect the results of a blit, choose
miniterms that ignore the values of such sources.

   Bits 12-15: Prior to applying the value of source A to the selected
miniterm operation, the blitter shifts the value the number of times
specified in these bits.  (If the blitter is in ascending mode, the data is
shifted right, otherwise, it is shifted left.)  Obviously, shifting does not
occur if all of these bits are set to zero.
   Whenever you tell the blitter to shift the data in source A, you must
store a modulo value that's one less than normal in the BLTAMOD and BLTDMOD
registers.

   Line Mode - Here's how the register functions in line mode:
   Bits 0-7: These bits control the miniterm setting used to combine the
line's bits (obtained from A) with the bits in the destination bitplane
(obtained from source C).  Source B is used as a mask for generating
patterned lines.  For normal lines, use a miniterm setting of #$CA.  To draw
a line of inverted pixels, use miniterm value #$4A.
   Bits 8-11: The blitter draws lines using source A as a point generator, B
as the static mask, and C for reading the current status of the destination
bitplane, and D for outputting the pixels.  Because we don't want the mask
in source B to change, source B's DMA should be inactive.  All of the
blitter's other channels must be active however.  As a result, you should
always set these bits equal to #$B when using the blitter to draw lines.
   Bits 12-15: These bits must equal the lower four bits of horizontal
coordinate x1.  Although these are referred to as the START bits in line
mode, their contents still specify a shift value, as they do in copy mode.
Here's how it works: In line mode, you must initialize source A's data
register (BLTADAT) with a $8000.  This puts a 1 bit in the leftmost position
in the word.  The value stored in these START bits specifies how far that
data is to be shifted to the right.  By shifting that bit right by the value
found in x1's lower 4 bits, you move the bit into the pixel position of the
line's starting point.

   Now the cheat: Here's a quick and easy formula for calculating the value
that you must store in BLTCON0 when drawing lines:
      3018 + ((x1 and #$0F) * 4096)

   This specifies the miniterm value for a normal line and provides the
blitter with the bit position of x1 within the memory location found in
registers BLTCPT and BLTDPT.  ($DFF048 and $DFF054)  To XOR a line onto the
screen (invert any of the bits located within the line), subtract 128 from
the result of the above calculation.
----------------------------------------------------------------------------
$DFF042 BLTCON1      Blitter Control Register 1
Status: *W           Agnus
                     For Blitter Moves and Fills:
                     0 LINE   1 = activate line draw mode, 0 = normal copy
                     1 DESC   1 = descending operation, 1 = ascending op.
                     2 FCI    Starting bit for fill mode
                     3 IFE    Enables inclusive fill mode
                     4 EFE    Enables exclusive fill mode
                  5-11 UNUSED Always set to zero.
                 12-15 BSH0-3 Preshift value for source B

                     For Line Mode:
                     0 LINE   Set to one
                     1 ONEDOT 1 = Draw lines with only a single pixel per
                                  raster
                     2 AUL    Set if ((dx>=dy)and(x1>=x2) or
                                     ((dx<dy) and(y1>=y2))
                     3 SUD    Set if ((dx>=dy)and(y1>=y2) or
                                     ((dx<dy) and(x1>=x2))
                     4 SUL    Set if dx>=dy
                     5 UNUSED Always set to zero
                     6 SIGN   Set if (4*dmin)<(2*dmax)
                  7-11 UNUSED Always set to zero
                 12-15 TEXTURE0-3 Set to (x1 and #$0F)

   Here's how BLTCON1's bits operate in normal copy mode:
   Bit 0: This bit activates line mode.  It must be set to zero for copy
operations.
   Bit 1: Storing a one here puts the blitter in descending mode.  Do that
whenever your source and destination overlap and the destination data has a
higher address than the source.  You should also use descending mode if you
plan on shifting data left.  You MUST use descending mode for a blitter fill
operation.  When descending mode is active, the BLTAPT, BLTBPT, and BLTCPT
registers ($DFF050, $DFF04C, and $DFF048) must point to the last word in the
memory area to be written to.  Normally, in ascending mode, these registers
point to the start of the memory area.
   Bit 2: The value of this bit determines the initial fill value used by
the blitter in fill mode.  Fill mode is activated by setting either of the
following two bits.
   Bit 3: Activates inclusive fill mode (See above)
   Bit 4: Activates exclusive fill mode (See above)  For normal copy
operations, both this bit and bit 3 should be set to zero.  Fills are
performed on data only after it has been run through the selected miniterm.
   Bits 12-15: Prior to applying the value of source B to the selected
miniterm operation, the blitter shifts the value the number of times
specified in these bits.  (If the blitter's in ascending mode, data's shifted
right.  If the blitter is in descending mode, the data is shifted left.)
Shifting does not occur if you write a zero to these bits.
   Whenever you tell the blitter to shift the data in source B, you must
store a modulo value that is one less than normal in the BLTBMOD and BLTDMOD
registers.

   Line Mode: To activate line mode, set bit zero of this register equal to
one.  Setting the ONEDOT bit (1) tells the blitter to draw lines that have
only one pixel on each horizontal row.  For clear, clean lines, you should
set this bit equal to zero.  But if you are drawing objects that you plan to
fill later using the blitter fill operation, this bit should be set to one.
This way, the area to be filled in will be enclosed by single pixel walls,
just as the blitter expects them to be.  Bit 5, and bits 7-11 should be set
to zero.  The value of the remaining bits depends on the line's coordinates.
   You might be interested to know that this register's TEXTURE bits are
actually used as a shift value, as they are in blitter copy mode.  You see,
blitter source B is used as a mask for creating textured lines.  Because a
line may start at any pixel position, it is necessary to shift the mask
found in BLTBDAT to align its high bit with the line's starting point.  As
with bits 12-15 in the BLTCON0 register, the shift value for source B is
calculated from the lower four bits of x1.
----------------------------------------------------------------------------
$DFF044 BLTAFWM      Source A First Word Mask
Status: *W           Agnus
   This register allows you to mask out the bits found on the left edge of
the bitplane area specified for blitter source A.  The first word of each
horizontal line is ANDed with the value stored in this register before it is
shifted, applied to the miniterm, and copied to memory.  For example, to
ensure that the two leftmost pixels of an area are always set to zero, store
a $3FFF in this register.  In descending mode, this and the following
register swap functions.
   Line Mode: In line mode, you should always store a $FFFF here.
Otherwise, your line may appear broken.
----------------------------------------------------------------------------
$DFF046 BLTALWM      Source A Last Word Mask
Status: *W           Agnus
   This register allows you to mask out the bits found on the right edge of
the bitplane area specified for blitter source A.  The last word of each
horizontal line is ANDed with the value stored in this register before it is
shifted, applied to the miniterm, and copied to memory.  For example, to
ensure that the two rightmost pixels of an are are always set to zero, store
a $FFFC in this register.  In descending mode, this and the previous
register swap functions.
   Line mode: In line mode, you should always store a $FFFF here.
Otherwise, your line may appear broken.
----------------------------------------------------------------------------
$DFF048 BLTCPTH      Blitter Source C Pointer
$DFF04A BLTCPTL
Status: *W           Agnus
   This is where you store the address of source C's bitmap data prior to
activating the blitter.  If you're blitting in ascending order, this address
should specify the starting address of your data.  If you're blitting in
descending order, this address should specify the ending address of your
data - the address of the last word of data.
   The low bit of this 32 bit register is always interpreted as zero, so
blitter bitmap data must begin on an even word boundary address.  (Using
BLTxFWM and BLTxLWM mask registers, however, you can specify bitmapped areas
with pixel accuracy.)  And, unless your Amiga has a 1MB Agnus, your data
cannot be located above $7FFF.  (1MB Agnus, use $FFFFF)
   Line mode: This register, as well as the BLTDPT register ($DFF054), must
contain the starting address of the line to be drawn.  (i.e. the address of
the word that contains the first point of the line.)  Using standard (x1,y1)
coordinates where (0,0) is the upper left corner of the bitplane, you can
calculate this address using the following formula:
   Address = Bitplane + (y1 * BytesPerLine) + (2 * (x1/16))
where Bitplane is the starting address of the destination bitplane and Bytes
Per Line is the width of the bitplane in bytes (number of pixels divided by
eight).  So, to draw a line in a 320 x 200 pixel bitplane found in memory at
16384 starting at coordinate (10,20), you would store a 17185 into this
register because 16384+(20*(320/8))+(2*(10/16)) equals 17185.
----------------------------------------------------------------------------
$DFF04C BLTBPTH      Blitter Source B Pointer
$DFF04E BLTBPTL
Status: *W           Agnus
   This is where you store the source B's bitmap data prior to activating
the blitter.  See register BLTCPT ($DFF048) for details.
   Line Mode: This register is not used in blitter line mode.
----------------------------------------------------------------------------
$DFF050 BLTAPTH      Blitter Source A Pointer
$DFF052 BLTAPTL
Status: *W           Agnus
   This is where you store the address of source A's bitmap data prior to
activating the blitter.  See register BLTCPT ($DFF048) for details.
   Line Mode: Only the low word of this register, BLTAPTL, us used in line
mode.  Its value determines the slope of the line.  Use the following
formula to calculate the value of this register:
      BLTAPTL = (4 * dmin) - (2 * dmax)
where dmin equals min(abs(x1-x2),abs(y1-y2)) and dmax equals
max(abs(x1-x2),abs(y1-y2)).  If this formula produces a negative number, you
must write a 1 to the SIGN bit (6) of the BLTCON1 register at $DFF042.
----------------------------------------------------------------------------
$DFF054 BLTDPTH      Blitter Destination Pointer
$DFF056 BLTDPTL
Status: *W           Agnus
   This is where you store the address of the chip RAM you're blitting into
(usually, this is a location within a bitmap).  If you're blitting in
ascending order, this address should reflect the starting address of your
data.  If you're blitting in descending order, it should reflect the ending
address of the destination data.  This register has the same limitations as
the BLTAPT-BLTCPT registers.  See location $DFF048 for details.
   Line Draw Mode: This register, as well as the BLTCPT register at $DFF048
must contain the starting address of the line to be drawn - that is, the
address of the word that contains the first point in the line.  See $DFF048
for more information.
----------------------------------------------------------------------------
$DFF058 BLTSIZE      Blitter Start and Size
Status: *W           Agnus
                     For Blitter Moves and Fills:
                   0-5 W0-W5  Width of destination area in words
                  6-15 H0-H9  Height of destination area in pixels

                     For Line Mode:
                     0        Set to 0
                     1        Set to 1
                   2-5        Set to 0
                  6-15        Set to (dmax+1)

   The value stored in this register tells the blitter how large your
destination area is.  The lower six bits specify the width of this area in
words - pixels divided by 16.  If these bits are set to zero, the blitter
assumes a width of 64 words, or 1024 pixels.  The height of the area in
pixels goes into the upper nine bits.  A 0 specifies a height of 1024
pixels.  You can use the following formula to calculate the value of this
register:
      BLTSIZE = (Height * 64) + (Pixelwidth / 16)
   The maximum width or height is 1024 pixels.  The minimum width is 16
pixels and the minimum height is one pixel.
   Writing to this register activates the blitter.  As a result, it should
be the last blitter register that you write to.
   If you are shifting source A or source B data, you must specify a
horizontal width that is one greater than normal.

   Line Mode: In line mode, the lower six bits must hold the value 2 while
the upper 9 bits must hold the value of dmax + 1.  Use the following formula
to determine the value that you should store in this register:
      BLTSIZE = (dmax * 64) + 66
where dmax equals max(abs(x1-x2),abs(y1-y2)).
   Because writing to BLTSIZE turns on the blitter, it should be the last
register that you set.
----------------------------------------------------------------------------
$DFF05A - $DFF05E    Currently Unused
----------------------------------------------------------------------------
$DFF060 BLTCMOD      Blitter Source C Modulo
Status: *W           Agnus
   Whenever the blitter finishes writing data to the last word in a
horizontal line, the contents of this register are added to the BLTCPT
register so that it points to the start of the next line.  This allows the
blitter to copy areas within a bitmap that are smaller than the width of the
bitmap itself.  If you're copying an area that is the same width of the
bitplane it is contained in or if you're copying consecutive bytes in
memory, simply write a zero to this register.  Otherwise, this register
should contain the difference between the byte width of the bitplane
containing the area to be copied and the byte width of the area.  Here's a
formula for determining the value that should be stored in this register:
      BLTCMOD = (BitMapWidth / 8) - (2 * (AreaWidth / 16))
where BitMapWidth and AreaWidth are the pixel widths of the source bitmap
and the area to be copied respectively.  Note that this register specifies
width in bytes whereas the BLTSIZE register specifies width in words.  Also,
although this register reflects the bitmap's width in bytes, its low bit is
ignored, so the value here must specify an even number of bytes.
   With a separate BLTxMOD register for each source, it's possible to
combine the data from three bitmaps of different widths.

   Line Mode: For drawing lines, store the byte width (pixel width divided
by 8) of your bitmap in this register.
----------------------------------------------------------------------------
$DFF062 BLTBMOD      Blitter Source B Modulo
Status: *W           Agnus
   Copy Mode: See BLTCMOD above.

   Line Mode: This register should contain the value 4 * dmin, where dmin
equals min(abs(x1-x2),abs(y1-y2)).
----------------------------------------------------------------------------
$DFF064 BLTAMOD      Blitter Source A Modulo
Status: *W           Agnus
   Copy mode: See BLTCMOD above.

   Line Mode: This register should contain the value 4 * (dmin - dmax) with
dmin and dmax defined as above.
----------------------------------------------------------------------------
$DFF066 BLTDMOD      Blitter Destination Modulo
Status: *W           Agnus
   Copy mode: See BLTCMOD above.

   Line Mode: For drawing lines, store the byte width (pixel width divided
by 8) of your bitmap in this register.  This is the same value you must
store in the BLTCMOD register.
----------------------------------------------------------------------------
$DFF068 - $DFF06E    Currently Unused
----------------------------------------------------------------------------
$DFF070 BLTCDAT      Blitter C Source Data
Status: *W           Agnus
   The blitter uses this register as the data register for blitter source C

   Line Mode: This register is not used in line mode.

   Blitter Data Register Notes: The blitter uses these registers as a
temporary holding place for data that is read from memory.  If a source's
DMA is enabled for a blitter operation, words are read from memory and then
stored in the corresponding BLTxDAT register.  Here the data is manipulated
according to the mask registers, the shift bits, the miniterm operation, and
then it is written to destination RAM.
   If a source's DMA is disabled, the data is not read from memory, but the
value found in the source's data register is still used to form the
blitter's output.  For this reason, it's a good idea to initialize the data
register of an unused source prior to starting the blitter.
   You can use the data registers to fill an area of memory with any word
long value.  Simply set up the blitter so that none of the data registers
have DMA enabled, select a miniterm of A, write the desired value into the
BLTADAT register, set up the remaining registers as usual, and activate the
blitter.
   If you plan to shift source A or B during a blitter operation, you must
be sure to initialize the shift bits prior to writing to the source's data
register.  Otherwise, the number written to this register will be shifteed
according to the old shift value.
----------------------------------------------------------------------------
$DFF072 BLTBDAT      Blitter Source B Data
Status: *W           Agnus
   This is the data register for blitter source B.

   Line Mode: Store the bit pattern with which you wish you5r line to be
drawn in this register.  For normal solid lines, store a $FFFF here.  Other
values produce dotter or dashed lines.
----------------------------------------------------------------------------
$DFF074 BLTADAT      Blitter Source A Data
Status: *W           Agnus
   This is the data register for blitter source A.

   Line Mode: This register should be initialized with the value of $8000
for line mode.
----------------------------------------------------------------------------
$DFF076 - $DFF07C    Currently Unused
----------------------------------------------------------------------------
$DFF07E DSKSYNC      Disk Sync Pattern
Status: *W           Paula
   Before reading data from a disk, it's often necessary to sync the
drive's heads on a particular bit pattern.  This register allows you to do
just that.
   When the WORDSYNC bit (10) in the ADKCON register ($DFF09E) is set, the
disk controller's DMA is enabled and the controller prepares to search the
disk for the sync pattern found in this register.  The disk controller
doesn't start searching until this register is written to.  When the sync
pattern is found, it is set to one for two or four usec (Depending on the
format selected: MFM or GCR) as soon as the sync pattern is located.
This event can also be used to trigger a level 6 interrupt.
   In MFM format (the disk format used by AmigaDos), the sync pattern should
be a value that is impossible to create using MFM data coding.  This way, it
can't be confused with actual data.  AmigaDos uses the number $4489 as its
sync pattern.  Here's how you might initiate the search for this value using
machine language:

   ADKCON equ $DFF09E
  DSKSYNC equ $DFF07E
   move.w #$8400,ADKCON
   move.w #$4489,DSKSYNC

   For more information on low-level disk access, see the CIA-B's PRB
register at $BFD100.
----------------------------------------------------------------------------
Copper Registers:

   The copper is designed to free the 680x0 from display tasks.  It has
three instructions: WAIT, MOVE, and SKIP.  It doesn't seem like you can do
much with only three instructions, but by using a variety of tricks and
subterfuges, a copper list can perform loops, take over the blitter, and
even generate an interrupt for the 68000.

   WAIT.  Wait mimics a loop structure which waits for a certain condition
to occur.  Specifically, Wait waits for the x,y coordinates of the raster to
meet or exceed the coordinates you specify.  Thus, wait allows you to
synchronize actions with the video.  (i.e.: Color changes, raster
interrupts, etc.)  Since a typical copper list executes every time the
screen is drawn, the color change will be rock steady.
   The x,y coordinates are not simple pixel coordinates, but beam position
coordinates.  See the descriptions of VPOSR ($DFF004), VHPOSR ($DF006),
VPOSW ($DFF02a), and VHPOSW ($DFF02C).
   Here is what a Wait instruction looks like:
    0  Always set to 0
  1-7  horizontal compare enable bits
 8-14  vertical compare enable bits
   15  the blitter finished disable bit (usually 1)
   16  Always set to 1
17-23  horizontal beam position
24-31  vertical beam position

   Bits 1-7 describe which bits of the horizontal beam counter will be
compared with an x position for which you choose to wait.  Normally, you
should set all of these bits to one.
   Bits 8-14 describe the same for the y position.
   Bit 15 should normally be set to one.  If you set it to zero, the copper
Wait instruction will wait until the beam position meets or exceeds the
given position and the blitter has finished its operation.
   Bits 17-23 indicate the horizontal beam position for which the wait is
waiting.  Note that bits 1-7 are used to decide which bits are actually used
for the comparison.
   Bits 24-31 indicate the same for the vertical - uses 8-14.

   Because the horizontal beam position is maintained to a resolution of two
low resolution pixels, and because the LSB of that position is not used in
wait comparison, WAIT has a resolution of four lo-res or 8 hi-res pixels.
   One potential problem with wait is that you cannot directly wait for a
line greater than 255.  To do this, wait for 255.  Then, wait for line
number x-255.
   A version of the wait command is used to end copper lists.  The command
code is $FFFFFFFE.  (i.e. wait for y=255, x=254)  The loop seems to be
infinite, and in fact is, however note that the copper list is reset DURING
EVERY VERTICAL BLANKING PERIOD!

   MOVE.  The Move instruction transfers data to a hardware register.  The
instruction can store data into any register with an address of $80 or more.
 Note that the register base of $DFF000 is implicit - it is not included in
the instruction.  If the copper danger bit, CDANG is set ($DFF02E bit 1),
the instruction can store data into any register with an address of $40 or
more.  Unless you need the copper to write to the blitter registers, you
should keep CDANG set to zero.
   With the Move instruction, you can set up bitplane pointers, sprite
pointers, color registers, and so on.  A complete, useful copper list will
have MANY move instructions because there are several DMA registers that
have to be reset every frame.  For example, the bitplane registers must be
reset to keep them from continuing where they left off.  Otherwise, you'd
see all of chip RAM rushing through the screen at great speed.
   Keep in mind that Move is not instantaneous.  Two Move instructions will
be separated by four low resolution pixels.
   Here is the format for the Move command:
 0-15 Data
   16 Set to Zero
17-24 Register address
25-31 Unused - set to zero

   Bits 0-15 are a word of data that you wish to transfer to the hardware
register.  If you want to transfer a long word, you must use 2 move
instructions.
   Bits 17-24 specify the offset from $DFF000 which you would like to
modify.  The CDANG bit of the COPCON register determines which values are
considered legal by the copper.

   SKIP.  Most copper lists are composed only of WAIT and MOVE instructions.
The Skip command allows for conditional branching.  It is a command that has
quite a bit of potential that has rarely been tapped.
   Skip is a close relative of WAIT.  As is the case with Wait, Skip decides
what to do based on the position of the video beam.  Instead of waiting for
a beam position though, it alters copper list program flow based on the beam
position.
   The Skip instruction looks like this:
    0 Set to 1
  1-7 horizontal compare enable bits
 8-14 vertical compare enable bits
   15 blitter-finished-disable bit
   16 set to 1
17-23 horizontal beam position
24-31 vertical position

   The Skip command skips the instruction that immediately follows it if the
beam counter meets or exceeds the value you specify.  The instruction that
follows skip is typically a strobe to the COPJMP1 or COPJMP2 registers.
Writing to these registers causes a jump to the address in the COP1LC or
COP2LC registers, respectively.

----------------------------------------------------------------------------
$DFF080 COP1LCH      Copper Program Counter 1
$DFF082 COP1LCL
$DFF084 COP2LCH      Copper Program Counter 2
$DFF086 COP2LCL
Status: *W           Agnus
   The above registers are the copper location registers.  COP1LC is the
default copper PC.  Either of the above are loaded when the COPJMP registers
are strobed.
----------------------------------------------------------------------------
$DFF088 COPJMP1      Copper Jump Strobes
$DFF08A COPJMP2
Status: Strobe       Agnus
   These locations, when written to, cause the respective copper PC (1 or 2)
to be loaded into the copper program counter.  The operation system strobes
COPJMP1 during a vertical blank interrupt.
----------------------------------------------------------------------------
$DFF08C COPINS       Copper Instruction Identity
Status: *W           Agnus
   This location is of questionable use to the programmer.  It is written to
by the hardware and is used to identify the current copper instruction.
----------------------------------------------------------------------------
Location Range: $DFF08E - $DFF094   Position of the screen display
   These four registers define the position of the Amiga's screen.  DIWSTRT
(Display Window Start) defines the screen's upper left corner while DIWSTOP
(Display Window Stop) defines the window's lower right corner.  Anything
outside of this area is considered border area.
   Before explaining how the next two registers, DDFSTRT and DDFSTOP, affect
the display, a brief explanation of bitplane DMA is in order.  Bitplane data
describes what to draw, but it's the responsibility of bitplane DMA to grab
that data from chip RAM and give it to the video hardware via registers
BPL1DAT - BPL6DAT ($DFF110 - $DFF11A).  Shortly after the video hardware
receives new data, it draws that data at the cirrent video beam position.
So where graphics appear onscreen is determined by when bitplane DMA gives
the video hardware its information.  (Anytime bitplane DMA is inactive and
the BPLxDAT registers are empty, the Amiga displays the color specified by
the COLOR00 register.)
   Vertically, bitplane DMA starts the moment it reaches the Y coordinate
found in DIWSTOP.  Horizontal start and stop locations are a bit more
complicated, however, as the computer needs some more time before it can
display fetched data.  On a lo-res display, it takes 8.5 color clocks.  (A
color clock is equal to one memory access cycle, ehich is approximately 280
nsec in duration.  The Amiga can output two lo-res pixels per color clock.)
   Each horizontal line on the computer screen can be thought of as a time
line.  Where along this line bitplane DMA is allowed to start is determined
by the DDFSTRT (Display Data Fetch Start) register.  The DDFSTOP (Display
Data Fetch Stop) register tells the Amiga when the bitplane DMA should stop.
 As you can imagine, unless these registers correspond with the horizontal
coordinates found in the DIW registers, your display will appear cropped
and/or garbled.
   Finding the proper value for the DDFSTRT based on the horizontal
coordinate found in DIWSTRT is easy.  Because the DIWSTRT register specifies
coordinates in lo-res pixels, and the DDFSTRT register is accurate to only
two lo-res pixels, you must first divide DIWSTRT's horizontal coordinate by
two; then, simply subtract the number of color clocks that you need - 4.5
for hi-res, and 8,5 for lo-res.  Here oare the formulae you should use to
calculate the correct value for the DDFSTRT register:
      DDFSTRT = HSTART / 2 - 4.5  for hi-res screens, and
      DDFSTRT = HSTART / 2 - 8.5  for lo-res.
HSTART refers to bits 0-7 of the DIWSTRT register (its horizontal
coordinate).
   Since the default value for HSTART is $81, DDFSTRT defaults to $3C for
hi-res, and $38 for lo-res.
   Calculating the value for DDFSTOP is also easy.  Its value depends on the
screen's width:
      DDFSTOP = DDFSTRT + (4 * ((Width / 16) - 1))  for hi-res screens, and
      DDFSTOP = DDFSTRT + (* * ((Width / 16) - 1))  for lo-res.
Width is the width of the screen in pixels.  So, on a standard 640 pixel
hi-res screen, where DDFSTRT equals $3C, DDFSTOP should be set to $D4.
----------------------------------------------------------------------------
$DFF08E DIWSTRT      Display Window Start
Status: *W           Agnus
                   0-7 HSTART Horizontal coord. of upper left corner
                  8-15 VSTART Vertical coordinate of lower right corner
Notes: Bits 0-7 default to $81, and 8-15 default to $2C.
----------------------------------------------------------------------------
$DFF090 DIWSTOP      Display Window Stop
Status: *W           Agnus
                   0-7 HSTOP  Horizontal coord. of lower right corner
                  8-15 VSTOP  Vertical coord. of lower right corner.
Notes: For bits 0-7, the minimum HSTOP position in $100, which is 1/3 across
the screen.  The value stored here represents an offset from this position.
So, the actual horizontal coordinate of the lower right corner of the screen
is $100 PLUS HSTOP!  You can think of HSTOP as being a nine bit register
with bit 8 always set.  The Default is $C1, which specifies a value of $1C1.
   For bits 8-15, these bits hold the vertical coordinate of the lower right
corner of the screen.  The minimum VSTOP position in $80.  If the value here
is less than $80, VSTOP equals $100 PLUS your VSTOP value.  Simply put,
whatever the state of bit 8 is, bit nine will be opposite!  The default for
NTSC is $F4, and the PAL default is $2C which actually is $12C.  VSTOP
always specifies the vertical position in noninterlace lines, no matter what
mode the computer is in.
----------------------------------------------------------------------------
$DFF092 DDFSTRT      Display Data Fetch Start
Status: *W           Agnus
   This register specifies the horizontal position that the video beam must
reach in order for bitplane DMA to start.  It's value depends on your screen
resolution, and what you store in the HSTART bits (0-7) in the DIWSTRT
register at $DFF09E.
   In hi-res, only bits 2-7 are active.  (specifies an even multiple of 4)
In lo-res, only bits 3-7 are active (an even multiple of 8).  Because of
certain hardware limitations, do not use DDFSTRT values less than $18.  Ans,
because sprite DMA relies on color clocks that occur during raster positions
$16-$34, using DDFSTRT values below $38 will disable certain sprites.  The
lower the number, the more sprites are disabled.  Higher numbered sprites
will be disabled first.
----------------------------------------------------------------------------
$DFF094 DDFSTOP      Display Data Fetch Stop
Status: *W           Agnus
   This register specifies the horizontal position the video beam must reach
in order for bitplane DMA to stop.  The bits used are the same as for
DDFSTRT.  Because of certain hardware limitations, do not use values greater
than $D8.
----------------------------------------------------------------------------
$DFF096 DMACON       DMA Control
Status: *W           Angus/Denise/Paula
   This is the write register for DMACONR.  The only difference is that
SET/CLR is active.  Note that activating audio channel DMA starts the sound
on the specified channel.  (See DMACONR at $DFF002)
----------------------------------------------------------------------------
$DFF098 CLXCON       Collision Control
Status: *W           Denise
                     0 MVP1   Match value for bitplane 1 collisions
                     1 MVP2                            2
                     2 MVP3                            3
                     3 MVP4                            4
                     4 MVP5                            5
                     5 MVP6                            6
                     6 ENBP1  Enable collision detection for bitplane 1
                     7 ENBP2                                          2
                     8 ENBP3                                          3
                     9 ENBP4                                          4
                    10 ENBP5                                          5
                    11 ENBP6                                          6
                    12 ENSP1  Enable collision detection for sprite 1
                    13 ENSP3                                        3
                    14 ENSP5                                        5
                    15 ENSP7                                        7

   The Amiga can detect three types of graphic collisions: sprite - sprite,
sprite - bitplane, and bitplane - bitplane.  The match value in bits 0-5
determine exactly what constitutes a collision: either a 0 or 1.
   Through creative use of 0-5 and 6-11, you can specify that collision
takes place with only a certain color or within a range of colors.
   Bits 6-11.  These bits determine which bit planes are used in collision
detection.  Oddly, the Amiga always seems to think that a bitplane collision
is taking place when all of these bits are set to zero.
   Bits 12-15.  Setting these bits allows you to check for collisions
between the specified sprite, and the next lower one.
----------------------------------------------------------------------------
$DFF09A INTENA       Interrupt Enable
Status: *W           Paula
   This is the write register for INTENAR at $DFF01C.  Note that SET/CLR is
active, and that you must CLEAR the appropriate bit after servicing the
interrupt!
----------------------------------------------------------------------------
Location Range: $DFF09E - $DFF0DE   Audio Registers
   Once you have a waveform sample loaded into chip RAM, turning that data
into sound is relatively simple.  Just tell the computer where is, the
length in words, how fast to play the sound, set the volume, and then signal
that DMA for the desired sound.  The Amiga will continue to play and repeat
your sound until you tell it to stop.
----------------------------------------------------------------------------
$DFF09E ADKCON       Audio/Disk Control (see ADKCONR at $DFF010)
Status: *W           Paula
   Notes on bit 12: MFM vs. GCR formatting:
   Briefing put, MFM format inserts clock bits between each data bit written
to disk.  If two consecutive data bits are zero, a 1 clock bit is inserted
between them.  If either of two consecutive bits is a 1, a 0 clock pulse in
put between them.  Using this coding method, the amount of data written to a
disk is doubled, but the accuracy of reading the data is increased.  You
see, the disk controller has an easier time synchronizing on data that
changes states rather than data that repeats such as a long string of 1's or
0's.
   GCR format handles synchronization problems by encoding every four bits
od data into five bits.  The result is a binary number with no more than two
adjacent 0 bits and no more than eight adjacent 1 bits.  (This format is
used on the Commodore 1541 drives on the C64.)  The following table shows
the 5 bit GCR equivalents of the binary numbers 0000-1111.
      Binary   GCR
      ------   ---
       0000   01010     Note that with GCR, no more than 8 on bits or
       0001   01011     2 off bits are possible.
       0010   10010
       0011   10011
       0100   01110
       0101   01111
       0110   10110
       0111   10111
       1000   01001
       1001   11001
       1010   11010
       1011   11011
       1100   01101
       1101   11101
       1110   11110
       1111   10101

   Notes on bit 13: These set the disk disk controller's precompensation
time, which directly affects the density of the data written to disk.  The
faster the precompensation time, the higher the density.  With AmigaDos,
density is highest on the inside tracks, probably due to the fact that these
is less physical space for these tracks.
----------------------------------------------------------------------------
$DFF0A0 AUD0LCH      Channel 0 Waveform Address
$DFF0A2 AUD0LCL
Status: *W           Agnus
   The low byte of this register is always interpreted as zero, so your data
must begin on a word boundary.  For a 512K Agnus, max address is $7FFFF, and
for a 1MB Agnus, it is $FFFFF.
----------------------------------------------------------------------------
$DFF0A4 AUD0LEN      Channel 0 Waveform Length
Status: *W           Paula
   The length of your data in words is stored here.  So, your data must be
an even number of bytes, and may not exceed 131,070 bytes.  (i.e. 65536
times two.)
   However, it is possible to play waveforms longer than 131,070 bytes due
to the fact that the Amiga buffers the contents of the AUDxLC and AUDxLEN
registers by using backup registers.  So, you may change the AUDxLC and
AUDxLEN registers while the Amiga is playing a sound, and when it is
finished, it will start with the new data!  Any of the Amiga's audio
channels can cause a level 4 interrupt just before your sound starts a new
waveform cycle.  When this interrupt occurs, you know it's safe to change
the registers.  One warning however: Interrupts caused by high-frequency
waveforms can occur quite rapidly.  Even more rapidly than the operating
system can keep up!  It's best to leave the audio interrupts alone, unless
you actually need them.  Just wait a little while before changing the AUDxLC
and AUDxLEN registers and all will work fine.
----------------------------------------------------------------------------
$DFF0A6 AUD0PER      Channel 0 Period
Status: *W           Paula
   A sound's frequency is determined by the value stored here.  The lowest
value you should use is 124, since this is about as fast as the Amiga can
go.  The highest value is 65535.
   How you determine the period depends on how you get your waveform data.
If you use a digitizer and the frequency is in Samples-per-second, use this
equation:  AUDxPER = 3579546 / Samples-per-second
   If you have a group of data that you want played as an "instrument", use
this:      AUDxPER = 3579546 / (Bytes-Length * Frequency to be played)
   Of course, the frequency for a given note may be calculated by the old
standby:   Frequency = Base * 2 ^ (1/12)
   Which calculates the frequency for the next note once given a frequency.
Middle C comes in at 261.4 Hz.
   If you don't want your sound to repeat, you should consider one more
thing: when to stop the sound.  You see, the faster you play the sound, the
faster its going to finish.  To figure out how long to let it play, use the
following equation:
           uSec = .279365 * Period * Length
Where uSec, is of course, the time in microseconds it takes to play your
sound once.
----------------------------------------------------------------------------
$DFF0A8 AUD0VAL      Channel 0 Volume
Status: *W           Paula
   This volume register can accept values between 0 and 64, where 0 is the
lowest setting (at -infinity dB), and 64 is loudest (at -0 dB).
----------------------------------------------------------------------------
$DFF0AA AUD0DAT      Channel 0 Data
Status: *W           Paula
   This is the data buffer used by channel 0.  It's purpose is to output
sounds at a rate higher than the DMA can.  To use it, you must disable
channel 0 DMA and shove the data in onw word at a time.
----------------------------------------------------------------------------
Location Range: $DFF0AC - $DFF0AE   Unused
   The Amiga reserves enough space for eight word-long addresses for each
channel, but uses only six.  The remaining addresses are unused.
----------------------------------------------------------------------------
$DFF0B0/2   AUD1LCH/L    These registers function exactly the same as
$DFF0B4     AUD1LEN      channel 0's.  To Find channel 2's, add $20 to
$DFF0B6     AUD1PER      the AUD0xxx value, and $30 for channel 3.
$DFF0B8     AUD1VOL
$DFF0BA     AUD1DAT
$DFF0BC/E   UNUSED
----------------------------------------------------------------------------
Location Range: $DFF0E0 - $DFF0F6   Bitplane pointer registers
Status: *W      Agnus
   These registers point to the current word of data that is being displayed
from each bitplane.  They are set up by the programmer, but increment as
each word of data is fetched from memory.  Therefore, these registers must
be reset for each screen.  This is usually done by the copper list, but may
also be written directly to by the programmer during the vertical blank
interrupt.  The initial value stored here should be the starting address of
the bitplane.  The value stored here must begin on a word boundary, and all
notes about 512K / 1MB Agnus chips apply here.

$DFF0E0 BPL1PTH/L Bitplane pointers for bitplanes 1-6... 32 bits long
$DFF0E4 BPL2PTH/L with bit zero ignored.
$DFF0E8 BPL3PTH/L
$DFF0EC BPL4PTH/L
$DFF0F0 BPL5PTH/L
$DFF0F4 BLT6PTH/L
----------------------------------------------------------------------------
Location Range: $DFF0F8 - $DFF0FE   Currently Unused.
----------------------------------------------------------------------------
Location Range: $DFF100 - $DFF104   Bitplane Control Registers
   These three register control the modes of the Amiga video display.
Within the bits of these registers are the means of creating just about any
Amiga screen possible.  BPLCON0 ($DFF100) controls how the pixels are
displayed.  Genlocking, interlace, dual playfield mode, HAM, Extra Half
Brite, and Hi-Res are all among its domain.  BPLCON1 ($DFF102) controls the
hardware smooth scrolling of the Amiga.  BPLCON2 ($DFF104) is the priority
register which determines how the playfield and sprites will interact.  A
few terms will be described to facilitate the discussion of these registers:

   Dual Playfield Mode: In this mode, the odd numbered bitplanes are grouped
into one playfield (1), and the even numbered bitplanes into the other. (2)
One playfield has priority over the other, which means that the backgroup's
playfield shows through only when the foreground's pixels color is 0.
   Extra HalfBrite: In EHB, pixels may have any value in the range of 0-63.
Pixels in the range of 0-31 use the normal 32 color registers.  Pixels 32-63
use the lower 32 color registers with the RGB values each shifter one bit
right.  Thus, 32-63 are half as bright.
   Genlock: This is a method of combining computer graphics with an external
video source.  The external source shows through where pixel color 0 is.
   Hold and Modify (HAM): In HAM mode, 16 color registers (4 bits) are used
normally.  In 5 bitplane HAM mode, a bit set in the 5th bitplane signifies
that the pixel should use the color of the pixel immediately to the left,
but with the blue value corresponding to the value of the lower four
bitplanes.  In 6 bitplane mode, the bits in the 5th and 6th bitplanes are
used to specify whether the lower sixteen color registers should be used
normally, or whether the pixel should be based on the pixel immediately to
the left, with the red, green, or blue intensity altered.  HAM images are
the most photographic available on the Amiga.  Six bitplane HAM is typical,
with five bitplane HAM a rarity.
   Interlace: This is a method of doubling vertical resolution by displaying
alternating lines on alternating scans.  See VPOSR at $DFF004.
   Playfield: This is the name for the non-sprite graphics that appear on
the screen as a result of bitplane DMA.  The name is a carryover from the
old Atari VCS.  (gasp!)
----------------------------------------------------------------------------
$DFF100 BPLCON0      Bitplane Control Register 0
Status: *W           Agnus/Denise
                     0 UNUSED
                     1 ERSY   External sync.  (1 = external, genlocked
                              0 = internal, normal)
                     2 LACE   1 = interlace enable
                     3 LPEN   1 = light pen enable
                   4-7 UNUSED
                     8 GAUD   1 = Genlock audio enable
                     9 COLOR  1 = Composite color enable on Amiga 1000,
                              0 = Monochrome display.
                    10 DBLPF  1 = Double (dual) playfield mode
                    11 HOMOD  1 = HAM active
                 12-14 BPU    Number of bitplanes used.  Zero = no bitplanes
                              You cannot use more than 4 for hi-res, and six
                              activates EHB mode.
                    15 HIRES  1 = Hi-res mode  0 = Lo-res mode.

Notes on bit 8: It has been alleged that audio data can be multiplexed on
the BKGD pen during vertical blanking, and bit 8 enables this feature.  In
reality, however, this bit simply goes out on the pixel switch ZD during
blanking periods.
----------------------------------------------------------------------------
$DFF102 BPLCON1      Bitplane Control Register 1
Status: *W           Denise
                   0-3 PF1H   Playfield 1 horizontal scroll
                   4-7 PF2H   Playfield 2 horizontal scroll
   This register allows you to fine scroll the screen horizontally.
Vertical scrolling is trivial.  Simply increment or decrement the starting
address of each bitplane by the width of a screen line in bytes.  Horizontal
scrolling is trickier.  You can perform a coarse 16 pixel scroll by simply
incrementing or decrementing the starting address of the bitplane pointers
by one word, but to scroll at the pixel level, use this register.
   In lo-res, the scrolling is in one pixel increments, and in hi-res, it is
two pixels.  To set up a screen for horizontal scrolling, the screen must be
one word wider than normal.  Do, you must add 2 to DDFSTRT's ($DFF030)
normal value.  You must set the modulo registers (BPLxMOD $DFF108) to the
number of "extra" bytes in each line (those that would not exist if you
weren't doing horizontal scrolling) minus two.  For example, if you're
displaying 40 bytes of an 80 byte wide screen, place the number 38 into the
appropriate BPLxMOD register.
----------------------------------------------------------------------------
$DFF104 BPLCON2      Bitplane Control Register 2
Status: *W           Denise
   This register allows you to determine priorities between the graphic
elements that make up an Amiga screen, namely the eight sprites and two
playfields.

   0-2 PF1P    Playfield 1 vs. sprite priority
   3-5 PF2P    Playfield 2 vs. sprite priority
     6 PF2PRI  Playfield 1 vs. playfield 2 priority (1 = 2 in front,
               0 = 1 in front.)

Notes: Bits 0-5 allow you to specify whether sprites should pass in front of
or behind a given set of bitplanes.  The table below shows the allowable
values.

   bit 2    bit 1    bit 0    (for playfield 1)
   bit 5    bit 4    bit 3    (for playfield 2)
     0        0        0      Playfield has top priority
     0        0        1      Playfield appears behind sprites 0-1
     0        1        0      Playfield appears behind sprites 0-3
     0        1        1      Playfield appears behind sprites 0-5
     1        0        0      Playfield appears behind all sprites
----------------------------------------------------------------------------
$DFF106              Zilch - Unused
----------------------------------------------------------------------------
$DFF108 BPL1MOD      Bitplane Modulo 1
$DFF10A BPL2MOD      Bitplane Modulo 2
Status: *W           Agnus
   These registers control how many bytes are added to the bitplane pointers
at the end of a video line.  Normally, the value is zero.  When the number
is greater than zero, you have an undisplayed segment of the screen to the
right of the visible area.  You can bring this area into view by
incrementing the bitplane pointers, and modifying the smooth scroll
register BPLCON1 at $DFF102.
   As an example, suppose the virtual screen you have is 80 bytes wide, by
the visible screen is 40.  You'll need to specify 40 as the modulo.
   There are two modulo registers, one for each playfield.  Unless you are
using dual playfield mode, both of these registers should be set to the same
value.  Note that the lowest bit is ignored, thus these registers must be
set to an even value.
----------------------------------------------------------------------------
Location Range $DFF10C - $DFF10E    Currently Unused.
----------------------------------------------------------------------------
Location Range $DFF110 - $DFF11A    Bitplane Data Registers
   The Amiga hardware is currently able to display six bitplanes.  If you
look carefully, however, there are gaps that would allow two extra bitplanes
to be inserted.  These registers are typically written to by the bitplane
DMA, but they may also be written to by the programmer directly.  The
parallel data from the six bitplanes is shifted out the left and converted
to a color.  BPL1DAT is the trigger register.  That means that you should
write to BPL2DAT - BPL6DAT first, then write to BPL1DAT to trigger the
serial conversion.

$DFF110 BPL1DAT   Bitplane DMA trigger.  Color Weight = 1
$DFF112 BPL2DAT   Weight = 2
$DFF114 BPL3DAT   Weight = 4
$DFF116 BPL4DAT   Weight = 8
$DFF118 BPL5DAT   Weight = 16
$DFF11A BPL6DAT   Weight = 32 (i.e. HAM / EHB)
----------------------------------------------------------------------------
Location Range $DFF11C - $DFF11E    Currently Unused.
----------------------------------------------------------------------------
Location Range $DFF120 - $DFF17E    Sprite Registers
   The Amiga is known for the animation capabilities of the blitter, but it
also has powerful sprite hardware.  Sprites have some advantages over the
blitter.  Whereas the blitter must render its images to display memory,
sprites are rendered in a separate area of memory.
   There are eight sprites.  Each sprite is 16 pixels wide and an arbitrary
size high.  The pixels are lo-res, even when displayed in hi-res or
interlaced mode.  Each pixels can be one of three colors or transparent.
   Sprites 0 and 1 share color registers 17 - 19.  Sprites 2 and 3 share
21-23, 4 and 5 share 25-27, and 6 and 7 share 29 through 31.  If your screen
uses 4 bitplanes or less, you won't have to worry about sprites sharing the
color registers with the playfield.  Otherwise... you'll have to plan colors
carefully.
   Note that the lower the sprite number, the higher its priority on the
screen.  Sprite priorities relative to the playfield can be assigned.  See
the bitplane control registers $DFF100 - $DFF106.
----------------------------------------------------------------------------
$DFF120 SPR0PTH         Sprite Pointer 0
$DFF122 SPR0PTL
Status: *W              Agnus
   This register holds the address of the Sprite 0 DMA data.  The address
must be in chip RAM.  This register acts as a DMA counter, so you must
initialize it during every vertical blank via the copper list or within a
vertical blank interrupt server.
   The address which you set to this register should contain valid sprite
data in chip RAM.  Use this format (each value is 32 bits):

      Sprite Control Value
      Image data for line 1
      Image data for line 2
      .....................
      Image data for last line

   Repeat this format for each occurrance of the sprite on the screen.  For
instance, you might have the same sprite engine used in three different
vertical areas of the screen.  In this case, you'd have the above format
three times.  At the end of the data, store a $00000000.
   Here is a sample adapted from the Amiga Hardware Reference Manual:
      SPRITE:
         DC.L  $6D607200   ; VSTART, HSTART, and VSTOP
         DC.L  $099007E0   ; Sprite data... $6D
         DC.L  $13C80FF0   ;                $6E
         DC.L  $23C41FF8   ;                $70
         DC.L  $13C80FF0   ;                $71
         DC.L  $099007E0   ;                $72
         DC.L  $00000000   ; End of structure.

   The Amiga is often said to have reusable sprite engines.  This means that
the Amiga can display the same sprite in several different places.  There is
one significant limitation to this ability: You must ensure that there is at
least one blank line vertically between the two instances of the same
sprite.  For example, if you have a sprite that stops displaying on line 25,
you may display a second one on line 27 or greater.
----------------------------------------------------------------------------
$DFF124 SPR1PTH/L Sprite Pointers 1-7
$DFF128 SPR2PTH/L
$DFF12C SPR3PTH/L
$DFF130 SPR4PTH/L
$DFF134 SPR5PTH/L
$DFF138 SPR6PTH/L
$DFF13C SPR7PTH/L
----------------------------------------------------------------------------
$DFF140 SPR0POS         Sprite Position 0 & Control 0
$DFF142 SPR0CTL
Status: *W              Agnus/Denise
   These two 16-bit registers can be thought of as a single 32 bit register
which holds information about how sprite 0 is to be displayed.  Info
included is vertical and horizontal starting locations, vertical stopping
location, and whether the sprite should be attached to its companion (0 and
1, 2 and 3, 4 and 5, 6 and 7).
   The sprite control value consists of the following bits, the number of
which should be stored in the:
                        0 HSTART       lowest bit
                        1 VSTOP        highest bit
                        2 VSTART       highest bit
                      3-6 Always 0
                        7 ATTACHMENT   1 = attached, 0 = not
                     8-15 VSTOP        lowest 8 bits
                    16-23 HSTART       highest 8 bits
                    24-31 VSTART       lowest 8 bits

   The HSTART value is your sprite's intended horizontal position.
Typically, the horizontal position 0 is 64 pixels to the left of the screen.
 This number can change depending on your preferences settings.  Suppose
that you want to position a sprite at the horizontal position which
corresponds to pixel 10.  In this case, add 10 + 64, to get 74.  Place 74 in
HSTART.  If you're setting up your own copper list, you'll know the value to
add to your desired offset.  If you're using a screen set up by the screen,
you can find the offset in the View structure.
   The VSTART value is your sprite's intended vertical position.  Typically,
the vertical position is 0-44 pixels above the top line of the screen.  This
number can change depending on your preferences settings.  Suppose you want
to position a sprite at the vertical position that corresponds with pixel
position 12.  Simply add 12 + 44 to get 56.  Place 56 in VSTART.
   The VSTOP value is the line on which you want your sprite to stop
displaying.  Simply add the height of the sprite to VSTART to get this
value.
   The register's attachment bit (7) is ingored in even numbered sprites.
When you attach two sprites, set HSTART, VSTART, and VSTOP of the two
sprites to the same values.
   Keep in mind that to modify this from within the copper, you will need to
use two Move instructions.  This location is usually not written to by the
programmer.  Instead, it is written to by sprite DMA.
----------------------------------------------------------------------------
$DFF144 SPR0DATA        Sprite Data Register 0
$DFF146 SPR0DATB
Status: *W              Denise
   This location is usually not written to by the programmer.  Instead, it
is written to by the sprite DMA.  If you write to it directly, write to
SPR0DATB (high bit of 4 colors) first then to SPR0DATA.  The data will then
be displayed on every line at the horizontal position specified in SPR0POS
and SPR0CTL until you write to SPR0DATA again.  SPR0DATA acts as a switch to
turn the sprite on.  SPR0CTL acts as the corresponding off switch.  The
weight of the bits for color are as follows:
      SPR0DATA 1
      SPR0DATB 2
      SPR1DATA 4 (if attached)
      SPR1DATB 8 (if attached)
----------------------------------------------------------------------------
Note: Sprites 0,1 share colors as do 2,3; 4,5; and 6,7

$DFF148 SPR1POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF14A SPR1CTL                   1 = COLOR REGISTER 17
$DFF14C SPR1DATA                  2 = COLOR REGISTER 18
$DFF14E SPR1DATB                  3 = COLOR REGISTER 19)
$DFF150 SPR2POS      (SHARES 3'S COLOR REGISTERS...)
$DFF152 SPR2CTL
$DFF154 SPR2DATA
$DFF156 SPR2DATB
$DFF158 SPR3POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF15A SPR3CTL                   1 = COLOR REGISTER 21
$DFF15C SPR3DATA                  2 = COLOR REGISTER 22
$DFF15E SPR3DATB                  3 = COLOR REGISTER 23)
$DFF160 SPR4POS      (SHARES 5'S COLOR REGISTERS...)
$DFF162 SPR4CTL
$DFF164 SPR4DATA
$DFF166 SPR4DATB
$DFF168 SPR5POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF16A SPR5CTL                   1 = COLOR REGISTER 25
$DFF16C SPR5DATA                  2 = COLOR REGISTER 26
$DFF16E SPR5DATB                  3 = COLOR REGISTER 27)
$DFF170 SPR6POS      (SHARES 7'S COLOR REGISTERS...)
$DFF172 SPR6CTL
$DFF174 SPR6DATA
$DFF176 SPR6DATB
$DFF178 SPR7POS      (PIXEL VALUE 0 = TRANSPARENT
$DFF17A SPR7CTL                   1 = COLOR REGISTER 29
$DFF17C SPR7DATA                  2 = COLOR REGISTER 30
$DFF17E SPR7DATB                  3 = COLOR REGISTER 31)
----------------------------------------------------------------------------
Location Range $DFF180 - $DFF1BE    Color Registers
   Each color register contains 12 bits of information, for a total of 4096
colors.  The registers are set up as follows:
      0-3 Blue intensity (0 = no blue, 15 = full blue)
      4-7 Green intensity
     8-11 Red intensity
    12-15 Unused

   There are seven colors which can be represented in 16 intensities.  Those
colors are, along with their hexadecimal values:

Gray     Red      Green    Blue     Yellow      Magenta     Cyan
----     ---      -----    ----     ------      -------     ----
FFF      F00      0F0      00F      FF0         F0F         0FF

   Here is a table of common colors:

Black - 000       Blue - 00F        Green - 0F0       Cyan - 0FF
Red   - 0F0       Purple-F0F        Orange- E70       Yellow-FF0
White - FFF       LtGray-CCC        MdGray- 888       DkGray-444
----------------------------------------------------------------------------
$DFF182 COLOR01   $DFF184 COLOR02   $DFF186 COLOR03   $DFF188 COLOR04
$DFF18A COLOR05   $DFF18C COLOR06   $DFF18E COLOR07   $DFF190 COLOR08
$DFF192 COLOR09   $DFF194 COLOR10   $DFF196 COLOR11   $DFF198 COLOR12
$DFF19A COLOR13   $DFF19C COLOR14   $DFF19E COLOR15   $DFF1A0 COLOR16
$DFF1A2 COLOR17   $DFF1A4 COLOR18   $DFF1A6 COLOR19   $DDD1A8 COLOR20
$DFF1AA COLOR21   $DFF1AC COLOR22   $DFF1AE COLOR23   $DFF1B0 COLOR24
$DFF1B2 COLOR25   $DFF1B4 COLOR26   $DFF1B6 COLOR27   $DFF1B8 COLOR28
$DFF1BA COLOR29   $DFF1BC COLOR30   $DFF1BE COLOR31
----------------------------------------------------------------------------
8520 CIA Chips - Location Range $BFD000-$BFDF00
CIA-B
   Locations $BFD000-$BFDF00 are used to address the Amiga's second Complex
Interface Adaptor (CIA-B).  Since the chip itself is identical to the CIA-A,
which is addressed at $BFE001, the discussion here will be limited to the
use the Amiga makes of this particular chip.  For more general information
on the chip registers, see the corresponding entries for CIA-A.  Unlike the
custom chip registers, the CIA registers are all one byte long and can be
both read from and written to.
----------------------------------------------------------------------------
$BFD000 PRA          Peripheral Data Register for Data Port A
Status: R/W          CIA-B
                     0 BUSY   Centronics busy (parallel port pin 11)
                     1 POUT   Centronics paper out (pin 12)
                     2 SEL    Centronics select (pin 13)
                     3 DSR    RS232 data set ready (serial port pin 6)
                     4 CTS    RS232 clear to send (pin 5)
                     5 DCD    RS232 carrier detect (pin 8)
                     6 RTS    RS232 request to send (pin 4)
                     7 DTR    RS232 data terminal ready (pin 20)
----------------------------------------------------------------------------
$BFD100 PRB          Peripheral Data Register for Data Port B
Status: R/W          CIA-B
                     0 STEP   Move drive head by one track in direction
                              specified by the DIR bit (set to 1, 0,
                              then 1 again to move head.)
                     1 DIR    Direction to move drive head (1 = out to 0,
                              0 = in to track 79+)
                     2 SIDE   Select drive head (1 = bottom, 0 = top)
                     3 SEL0   0 = Select DF0:  1 = not selected
                     4 SEL1   0 = Select DF1:
                     5 SEL2   0 = Select DF2:
                     6 SEL3   0 = Select DF3:
                     7 MTR    Motor on/off status (1 = motor off,
                              0 = motor on)

   Notes:
      Bit 0: After moving the drive's head, it is important that you wait 3
microseconds before performing any other disk activities.  Since software
timing loops will be shorter on accelerated Amigas, use the CIA timers.
      Bit 1: You can check if the drive head of a selected drive is on track
0 by reading bit 4 of the CIA-A chip's PRA register located at $BFE001.
      Bit 2: When you select the head, the value of this bit affects only
the currently selected drives.
      Bits 3-6: You may select more than one drive at a time.  Thus, you can
move the heads on more than one drive simultaneously.
      Bit 7: This bit turns the motors on and off.  The drive LED is
directly wired to the motor power.  This bit should be set before you select
a drive.  If a drive is already selected and you wish to change the state of
its motor, deselect the drive, set this bit, and then reselect the desired
drive.
      When turning on the motor, you must wait for the motor to reach its
full rotation speed before performing any other disk activities.  Bit 5 of
the CIA-A's PRA ($BFE001) is set equal to 0 whenever the drive has reached
full speed and is ready to receive another command.
      Note that all of this assumes that you have disabled multitasking and
have taken full control of the computer.
----------------------------------------------------------------------------
$BFD200 DDRA            Data Direction Register A
Status: R/W             CIA-B
   A bit set in this register causes the corresponding bit in PRA to be
defined as output.  A bit clear causes it to be defined as input.  Note that
bits 0-5 are normally clear, and bits 6-7 are set.
----------------------------------------------------------------------------
$BFD300 DDRB            Data Direction Register B
Status: R/W             CIA-B
   This register controls the I/O of PRB.  All bits MUST be set to 1.
----------------------------------------------------------------------------
Location Range: $BFD400 - $BFD700   CIA-B Timers A & B L/H Bytes
   According to some early Commodore-Amiga manuals, Timer A is reserved for
Commodore 8-bit serial bus communications - the bus system used by the C64
to talk to the 1541, 1571, 1581, as well as C64 compatible printers.  For
all practical purposes, the Amiga has no use for these timers.  Timer B is
also unused by the operating system.  Feel free to use them yourself.  For
more details, see the entry for the CIA-A Timer A & B registers at $BFE401
through $BFE701.

$BFD400 TALO   Timer A Low Byte.  R/W
$BFD500 TAHI   Timer A High Byte. R/W
$BFD600 TBLO   Timer B Low Byte.  R/W
$BFD700 TBHI   Timer B High Byte. R/W
----------------------------------------------------------------------------
Location Range: $BFD800-$BFDB00     CIA-B TOD Counters
   This 24 bit timer serves as a horizontal blank counter for the
graphics.library , and is used to synchronize the output of graphics with
the position of the video beam.
   The CIA-B chip's TICK line is connected to the Agnus chip's _HSYNC line,
so the TOD clock's counter is incremented once every horizontal blank, or
31500 times per second.

$BFD800 TODLO  TOD counter low byte    R/W   CIA-B (0-7)
$BFD900 TODMID TOD counter mid byte    R/W   CIA-B (8-15)
$BFDA00 TODHI  TOD counter high byte   R/W   CIA-B (16-23)
$BFDB00 TODHR  UNUSED - Not connected to the Amiga
-----------------------------------------------------------------------------
$BFDC00 SDR          Serial Data Register
Status: R/W          CIA-B
   The CIA chip has an on-chip serial port, which allows you to send or
receive a byte of data one bit at a time, with the MSB (7) shifted out
first.
   The CIA-B's SP line, which carries bits to the Serial Data Register, is
connected to bit 0 of this chip's data port A, and in turn, to pin 11 of the
parallel port.  The chip's CNT line, which carries the bits that are output
by the Serial Data Register, is connected to bit 1 of this chip's Data Port
A, and in turn, to pin 12 of the parallel port.
   For more information about the use of this register, see the entry for
location $BFEC01.  The Amiga's operating system does not use this register.
----------------------------------------------------------------------------
$BFDD00 ICR          Interrupt Control Register
Status: R/W          CIA-B
            0 R - did Timer A count down to zero? (1 = yes)
              W - enable or disable Timer A IRQ (1 = enabled  0 = disabled)
            1 R - did Timer B count down to zero? (1 = yes)
              W - enable or disable Timer B IRQ (1 = enabled  0 = disabled)
            2 R - did TOD clock reach alarm time? (1 = yes)
              W - enable or disable TOD alarm IRQ (1 = en  0 = dis)
            3 R - did the serial data register finish a byte? (1 = yes)
              W - enable or disable serial data register IRQ (1/0 = en/dis)
            4 R - was a signal sent on the FLAG line? (1 = yes)
              W - enable/disable flag IRQ (1/0 = en/dis)
            5     UNUSED - always returns a zero
            6     UNUSED - always returns a zero
            7 R - did any CIA-A source cause an interrupt? (1 = yes)
              W - set or clear bits of this register.  (1 = bits written to
                  with a 1 will be set, 0 = bits written with a 1 will be
                  cleared.)

   This register is used to control the 5 interrupt sources on the 8520 CIA
chip.  For details on its operation, see $BFED01.
   The main difference between the two CIA chips pertaining to this register
is that on CIA-B, the FLAG line is connected to the disk controller's
DSKINDEX line.  And in order for the Amiga to recognize a CIA-B chip
interrupt, bit 13 or the INTENA register must be set to 1.  See registers
INTENA and INTENAR at $DFF09A and $DFF01C for more information on Amiga
interrupts.
----------------------------------------------------------------------------
Location Range $BFDE00 - $BFDF00    CIA Control Registers A & B
See locations $BFEE01 and $BFEF01 for details.
----------------------------------------------------------------------------
$BFDE00 CRA          Control Register A
Status: R/W          CIA-B
            0 START   Start Timer A (1 = start, 0 = stop)
            1 PBON    Select Timer A output on Data Port B (1 = Timer B
                      output appears on bit 6 for Data Port B)
            2 OUTMODE Data Port B output mode (1 = toggle bit 6, 0 = pulse
                      bit 6 every 10 microprocessor cycles)
            3 RUNMODE Timer A run mode (1 = one shot, 0 = continuous)
            4 LOAD    Force latched value to be loaded to Timer A counter
                      (1 = force load strobe)
            5 INMODE  Timer A input mode (1 = count signals on CNT line at
                      pin 1 of keyboard port, 0 = count every 10 uP cycles)
            6 SPMODE  Serial Port ($BFEC01) mode (1 = output, 0 = input)
            7 UNUSED
----------------------------------------------------------------------------
$BFDF00 CRB          Control Register B
Status: R/W          CIA-B
            0 START   Start Timer B (1 = start, 0 = stop)
            1 PBON    Select Timer B output on Data Port B (1 = Timer B
                      output appears on bit 7 for Data Port B)
            2 OUTMODE Data Port B output mode (1 = toggle bit 7, 0 = pulse
                      bit 7 every 10 microprocesor cycles(
            3 RUNMODE Timer B run mode (1 = one shot, 0 = continuous)
            4 LOAD    Force latched value to be loaded to Timer B counter
                      (1 = force load strobe)
          5-6 INMODE  Timer B input mode
                      00 = count every 10 uP cycles
                      01 Count cycles on CNT line at pin 1 of keyboard port
                      10 Count each time that Timer A counts down to 0.
                      11 Count Timer A 0's when CNT pulses are present
            7 ALARM   Select TOD write status (1 = writing to TOD registers
                      sets counter, 0 = writing to TOD registers sets alarm)
----------------------------------------------------------------------------
Location Range $BFE001-$BFE301   CIA Data Ports A and B
   These registers allow the Amiga to communicate with the outside world.
Bits of data written to the PRA and PRB registers ($BFE001 and $BFE101) can
be sent to external devices, while bits of data those devices send can be
read here.
   A bit can be set up for only input or output, not both at once.  To
define the I/O status of a bit, you use the Data Direction Registers.
Register DDRA ($BFE201) controls data port A, and register DDRB ($BFE301)
controls data port B.  1 = output mode, and 0 = input mode.  Note that DDRA
is preset by the Amiga on power up.  Modifying the contents may cause the
computer to lock up.
----------------------------------------------------------------------------
$BFE001 PRA          Peripheral Data Register for Data Port A
Status: R/W          CIA-A
                     0 OVL    Memory overlay bit (Dont change! Keep 0)
                     1 LED    Power LED/Cutoff filter (1 = LED dimmed and
                              cutoff filter inactive, 0 = LED/filter normal)
                     2 CHNG   Disk Change (1 = no change, 0 = disk has
                              been removed)
                     3 WPRO   1 = Disk Write Protected  0 = Unprotected
                     4 TK0    1 = head not on trk 0, 0 = head on track 0.
                     5 RDY    1 = currently selected drive is ready for
                              commands, 0 = not ready.
                     6 FIR0   Fire button on port 1, pin 6 (0 = pressed)
                     7 FIR1   Fire button on port 2, pin 6 (0 = pressed)

   Notes: On bits 6-7, you may also output data  through pin 6 on either
game port.  Simply set bit 6 or 7 (depending on which port you wish to
output data o) in the DDRA register to 1 for output and then toggle the same
bit in the PRA register.  Setting the PRA bit to one outputs approximately 5
volts on that line.  Setting the PRA bit equal to zero oulls the line low to
zero volts.  It is common courtesy to set the data direction registers back
to their original value after using them.
----------------------------------------------------------------------------
$BFE101 PRB          Peripheral Data Register for Data Port B
Status: R/W          CIA-A
                     0 D0  Parallel port pin 2
                     1 D1  Parallel port pin 3
                     2 D2  Parallel port pin 4
                     3 D3  Parallel port pin 5
                     4 D4  Parallel port pin 6
                     5 D5  Parallel port pin 7
                     6 D6  Parallel port pin 8
                     7 D7  Parallel port pin 9

   Notes: This register is used exclusively by the Amiga's parallel port.
It controls the port's data lines, and is therefore responsible for all
parallel port transmissions.
   For example, whenever the Amiga sends a character to a printer that's
connected to the parallel port, it uses this register.  It just sets all the
bits in the DDRB equal to one and writes the byte of data to be output here.
----------------------------------------------------------------------------
$BFE201 DDRA         Data Direction Register A
Status: R/W          CIA-A
                     0 Select bit 0 PRA I/O (Must be 1 = Output)
                     1            1                  1
                     2            2                  0 = Input
                     3            3                  0
                     4            4                  0
                     5            5                  0
                     6            6         (Normally 0)
                     7            7         (Normally 0)
----------------------------------------------------------------------------
$BFE301 DDRB         Data Direction Register B
Status: R/W          CIA-A
   A bit set or clear here makes the corresponding bit in the PRB set for
output or input, respectively.
----------------------------------------------------------------------------
Location Range $BFE401 - $BFE701    CIA Timers A & B L/H Bytes
   These four timer registers (two for each timer) have different functions
depending on whether you are reading from or writing to them.  When you read
from these registers, you get the present value of the Timer Counter (which
counts down from its initial value to zero).  When you write to these
registers, the value is stored in the Timer Latch, and from there it can be
used to load the Timer Counter using the LOAD bit of the CRA or CRB
registers (see $BFEE01 and $BFEF01).
   These interval timers can hold a 16 bit value from 0 to 65535, in low
byte - high byte format.  Once the Timer Counter is set to an initial value
and the timer is started, the timer will decrement every 10 uP cycles.
Since the clock speed of an NTSC Amiga is 7.159090 MHz, using every count
takes approximatels a millionth of a second.  (10 / 7159090 =
0.0000013968256).  The formula for calculating the amount of time it will
take for the timer to count down from its latch value to zero is:
      Time = Latch Value / Count Speed
where Latch Value is the value written to the low and high timer registers,
and Count Speed is 715909 for NTSC, and 709379 for PAL.
   When Timer A or B reaches 0, it will set bit 0 or 1 in the Interrupt
Control Register at $BFED01.  If the timer interrupt has been enabled, an
interrupt will take place, and the high bit of the Interrupt Control
Register will be set to one.  Alternately, if the PBON bit is set, the timer
will wirte data to bit 6 or 7 on Port B.  After the timer gets to zero, it
will reload the Timer Latch value and either stop or count down again,
depending on whether it is in one-shot or continuous mode (determined by bit
3 of the Control Register).
   Although usually a timer will be used to count every 10 uP cycles, Timer
A can also count external pulses on the CNT line, which is connected to the
Amiga's keyboard.
   Timer B is even more versatile.  In addition to these two sources, Timer
B can count the number of times that Timer A goes to zero.  By setting Timer
A to count the uP clock, and Timer B to count the number of times Times A
reaches 0, you effectively link the two into one 32 bit timer that can count
for more than an hour before resetting.
   In the Amiga, CIA-A Timer A is used to time the transfer of keyboard
data.  Timer B is used by Exec (the core of the Amiga's multitasking
operating system) to synchronize task switching; it also serves as the
timer.device's UNIT_MICROHZ timer.  As a result, neither Timer A or B is
available for general use.
----------------------------------------------------------------------------
$BFE401 TALO            Timer A Low Byte
$BFE501 TAHI            Timer A High Byte
$BFE601 TBLO            Timer B Low Byte
$BFE701 TBHI            Timer B High Byte
Status: R/W             CIA-A
----------------------------------------------------------------------------
Location Range $BFE801 - $BFEB01    CIA-A TOD Counters
   In addition to two general purpose timers, the 8520 CIA has a special
purpose 24-bit counter that can count up to 16777215 ($FFFFFF).  Unlike the
chip's other two timers, the TOD clock counts up, and when the TOD clock
reaches its maximum value, starts over at zero and continues counting.  The
TOD clock can also be set to generate an interrupt whenever it reaches a
determined value.
   The TOD clock increments its counter approximately 60 times per second
(50 for PAL) - the same frequency as the computer's power line tick.
   The TOD registers can be used for two purposes, depending on whether you
are reading from or writing to them.  If you are reading from them, you will
always be reading the timer's current value.  There is a latching feature
associated with the high byte register that freezes the other two bytes
until you read the low byte.  This is to keep inaccurate readings from
occurring.  (Note that the timer will not continue to count until you read
the low byte!)
   Writing to these registers sets either the counter or alarm time
depending on the setting of bit 7 of Control Register B (CRB, $BFEF01).  If
that bit is set to 1, writing to the TOD registers sets the alarm.  If the
bit is set to zero, writing to the TOD registers sets the clock.  In either
case, as with reading the registers, there is a latch function.  This
function stops the clock from updating when you write to the high byte
register.  The clock will not start again until you write to the low byte
register.
   The CIA-A's TOD clock serves as the timer.device's UNIT_VBLANK timer.
Unlike the Timer A driven UNIT_MICROHZ clock (which is also used by Exec),
UNIT_VBLANK is not slowed down if the computer is running several programs
at once.
----------------------------------------------------------------------------
$BFE801 TODLO        TOD Counter Low Byte
$BFE901 TODMID       TOD Counter Mid Byte
$BFEA01 TODHI        TOD Counter High Byte
$BFEB01 TODHR        UNUSED - Not connected to the Amiga
Status: R/W          CIA-A
----------------------------------------------------------------------------
$BFEC01 SDR          Serial Data Register
Status: R/W          CIA-A
   The CIA chip has a built in serial port, which allows you to send or
receive a byte of data one bit at a time, with the MSB (7) shifted out
first.  Control Register A at $BFEE01 allows you to choose input or output
modes.  In input mode, a bit of data is read from the chip's SP line
whenever a signal on the CNT line appears.  After 8 bits are received, and
the data has been placed in the SDR, an interrupt is generated to let you
know that the register should be read.
   In output mode, you write data to the SDR, and it is sent out over the SP
line using Timer A for the baud rate generator.  Whenever a byte of data is
written to using this register, transmission will start as long as Timer A
is running in continuous mode.  Data is sent at half the Timer A rate, and
an output will appear on the CNT line whenever a bit is sent.  After all 8
bits have been sent, an interrupt is generated to indicate that it is time
to load the next byte to send into the Serial Data Register.
   The Amiga usus this register to receive data from the keyboard's KDAT
line (via pin 2 of the keyboard port), and the CNT line is connected to the
keyboard's KCLK line (via pin 1 of the keyboard port).  Data is never sent
to the keyboard, so this register is always operating in input mode.
   By reading this register directly, you can find the RAWKEY value of the
current key being pressed.  A rawkey value specified the physical location
of the key on the keyboard.  Normally, the Amiga's operating system reads
the value from the SDR and uses the computer's current keyboard map table
(such as USA1) to convert it to ASCII.  Keymap tables are important because
different countries use different keyboard layouts.  There are at least 15
different Amiga keyboard configurations in existance.
   The number returned does not have the high bit (7) set during the key
press.  However, when the key is released, bit 7 is set.  Thus, a key's
release value is 128 greater than its depress value.
   You should know the shift or control keys do not modify the rawkey
values.  Instead, the shift or control keys send their own rawkey codes.
   There are six special codes that can be sent via the SDR:
      $78 - Control/Amiga/Amiga
      $F9 - Ignore last character: transmission error
      $FA - 10 character keyboard buffer is full
      $FC - Keyboard self test failed
      $FD - Header: Any following codes were keys pressed on power up
      $FE - Termination code after the keys pressed on power up.
            (i.e.: $FD xx xx ... $FE)
   Using the console.device's RawKeyConvert() functiom, you can convert a
rawkey code to normal ASCII.

----------------------------------------------------------------------------
$BFED01 ICR          Interrupt Control Register
Status: R/W          CIA-A
   Notes: Bit layout is the same as the ICR at $BFDD00.  This register is
used to control the five interrupt sources on the 8520 CIA chip.  These
sources are Timer A, Timer B, the TOD clock, the SDR, and the chip's FLAG
line.  Timer's A & B cause an interrupt when they count down to zero.  The
TOD clock generates an alarm when it reaches the alarm time.  The SDR
generates an interrupt when it compiles 8 bits of input or output.  An
external signal pulling the CIA chip's FLAG line low will also cause an
interrupt (on CIA-A, the FLAG line is connected to the ACK line - pin 10 of
the parallel port).
   Even if the conditions for an interrupt are satisfied, the interrupt must
still be enabled for the interrupt to occur.  This is done by writing to the
ICR.  What happens when you write to this register depends on the way you
set bit 7.  If it is set to 0, any bit you write to with a 1 is cleared.  If
it is set to a 1, any bit that you write to with a 1 is set, and the
corresponding interrupt is enabled.  In either case, any bits written to
with a zero will be unaffected.
   For example, to disable all interrupts from machine language, you could
MOVE.B #$7F,$BFED01.  Don't try this with multitasking turned on, as it will
turn off Timer B, which handles task switching.
   To turn on a Timer B interrupt, a program could MOVE.B #$82,$BFED01.  Bit
7 is set to 1, and so is bit 1, so the interrupt which corresponds with bit
1 (Timer B) is enabled.
   When you read this register, you can tell if any of the conditions for a
CIA interrupt were satisfied because the corresponding bit will be set to a
one.  For example, if Timer A counter down to zero, you would read a #$01
from this register.  If in addition the enable bit that corresponds to that
interrupt source is set to 1 and an interrupt occurs, bit 7 will also be
set.  This allows a multi-interrupt system to read one bit and see if the
source of a particular interrupt is CIA-A.  You should note, however, that
reading this register clears it, so you should preserve its contents if you
want to test more than one bit.  In order for the Amiga to recognize a CIA-A
chip interrupt, bit 3 of the INTENA register must be set to 1.  See
registers INTENA and INTENAR ($DFF09A, $DFF01C) for more information.
----------------------------------------------------------------------------
$BFEE01 CRA          Control Register A
$BFEF01 CRB          Control Register B
Status: R/W          CIA-A
   See $BFDE00 and $BFDF00 for information on the bit layout.
----------------------------------------------------------------------------
This completes "Mapping the Amiga" from Compute! Books.  For information
on system structures, examine your C and assembler Include files.  They
have much better information than the book.
Slates from Bansai
05/26/91
----------------------------------------------------------------------------
Want more cool warez call Spectral Forces 203.327.4104   <<<SPELLJAMMER WHQ>>>
