What is a Real Software Engineer?
(Downloaded from The Cave, Wgtn.)

             Real Software Engineers Don't Read Dumps
             ----------------------------------------
 
Real Software Engineers don't read dumps.  They never generate them, and on
the rare occasions that they come across them, they are vaguely amused
 
Real Software Engineers don't comment their code.  The identifiers are so
mnemonic tat they don't have to
 
Real Software Engineers don't write applications programs; they implement
algorithms.  If someone has an application that the algorithm might help
with, that's nice.  Don't ask them to write the user interface, though
 
Real Software Engineers don't eat quiche
 
If it doesn't have recursive function calls, Real Software Engineers don't
program in it
 
Real Software Engineers don't program in assembler
They become queasy at the very thought
 
Real Software Engineers don't debug programs; they verify correctness.  This
process doesn't necessarily involve executing anything on a computer, except
perhaps a Correctness Verification Aid program
 
Real Software Engineers like C's structured constructs, but they are
suspicious of it because they have heard that it lets you get "close to the
machine"
 
Real Software Engineers don't play tennis.  In general, they don't like any
sport that involves getting hot and sweaty and gross when out of range of a
shower.  (Thus mountain climbing is Right Out.)  They will occasionally wear
their tennis togs to work, but only on very sunny days
 
Real Software Engineers admire PASCAL for its discipline and Spartan purity,
but they find it difficult to actually program in.  They don't tell this to
their friends, because they are afraid it means that they are somehow
unworthy
 
Real Software Engineers don't write in languages that have not actually been
implemented for any machine and for which only the formal spec (in BNF) is
available.  This keeps them from having to take any machine dependencies into
account.  Machine dependencies make Real Software Engineers very uneasy
 
Real Software Engineers don't write in ADA, because the standards bodies have
not quite decided on a formal spec yet
 
Real Software Engineers like writing their own compilers, preferaby in
PROLOG.  (They also like writing them in unimplemented languages, but it
turns out to be difficult to actually RUN these)
 
Real Software Engineers regret the existence of COBOL, FORTRAN, and BASIC.
PL/1 is getting there, but it is not nearly disciplined enough - far too much
built in functions
 
Real Software Engineers aren't too happy about the existence of users,
either.  Users always seem to have the wrong idea about what the
implementation and verification of algorithms is all about
 
Real Software Engineers don't like the idea of some inexplicable and greasy
hardware several aisles away that may stop working at any moment.  They have
a great distrust of hardware people and wish that systems could be virtual at
ALL levels.  They would like personal computers except that they need 8
megabytes to run their Correctness Verification Aid packages


                   Real Programmers Don't Write Specs
                   ----------------------------------
 
Real Programmers don't write specs - users should consider themselves lucky
to get any programs at all and take what they get
 
Real Programmers don't comment their code.  If it was hard to write, it
should be hard to understand
 
Real Programmers don't eat quiche.  They eat Twinkies and Szechwan food
 
Real Programmers don't write in COBOL.  COBOL is for wimpy applications
programmers
 
Real Programmers' programs never work right the first time.  But if you throw
them on the machine, they can be patched into working in "only a few" 30-hour
debugging sessions
 
Real Programmers don't write in FORTRAN.  FORTRAN is for pipe stress freaks
and crystallography weenies
 
Real Programmers never work 9 to 5.  If any Real Programmers are around at
9AM, it's because they were up all night
 
Real Programmers don't write in BASIC.  Actually, no programmers write in
BASIC, after the age of 12
 
Real Programmers don't write in PL/1.  PL/1 is for programmers who can't
decide whether to write in COBOL or FORTRAN
 
Real Programmers don't play tennis, or any other sport that requires you to
change clothes.  Mountain climbing is OK, and Real Programmers wear their
climbing boots to work, in case a mountain should suddenly spring up in the
middle of the machine room
 
Real Programmers don't document.  Documentation is for simps who can't read
the listings or the object deck
 
Real Programmers don't write in PASCAL, or BLISS, or ADA, or any of those
pinko computer science languages.
Strong typing is for people with weak memories
 
Real Programmers can recite powers of 16 up to infinity, write language
translators in SNOBOL to produce COBOL source code, use FORTRAN only for
tricky little programs, never drink lager, never drink decaffelnated coffee,
never smoke low-tar cigarettes
 
Real Programmers explain their work (if ever) to their managers in baby-talk
so they will understand it
 
Real Programmers don't talk to support center 2nd level people.  (Their
working hours are mutually exclusive)
 
Real Programmers start assembly of the whole system at 9AM at high priority
so it will be finished by their evening stand-alone time
 
Real Programmers don't write in APL
Any fool can be obscure in APL
 
Real Programmers think structured programming is a Communist plot
 
Real Programmers don't use schedules
Schedules are for managers toadies
Real Programmers like to keep their man suspense
 
Real Programmers do it middle out
 
Real Programmers enjoy getting CP/M to work on 370 machines and MVS on their
ZX81s
 
Real Programmers write their own assemblers, preferably in LISP
 
Real Programmers know that good human factors design requires only the
application of common sense.  Besides, no one cares about users.  Programs
are written for aesthetic beauty
 
Real Programmers do not wonder where the bits went following a shift
operation.  They do not care


              Real Computer Scientists Don't Write Specs
              ------------------------------------------
 
Real Computer Scientists don't write code.  They occasionally tinker with
"programming systems", but those are so high level that they hardly count,
and rarely count accurately.  (Precision is for applications)
 
Real Computer Scientists don't comment their code.  The identifiers are so
long they can't afford the disk space
 
Real Computer Scientists don't write the user interfaces; they merely argue
over what they should look like
 
Real Computer Scientists don't eat quiche.  They shun Szechwan food since the
hackers discovered it.  Many Real Computer Scientists consider eating an
implemenation detail
 
If it doesn't have a programming environment complete with interface
debugger, structure editor, and extensive cross-module checking, Real
Computer Scientists won't be seen tinkering with it.  They may have to use it
to balance their checkbooks, as their own systems can't
 
Real Computer Scientists don't program in assembler.  They don't write in
anything less portable than a Number Two pencil
 
Real Computer Scientists don't debug programs; they dynamically modify them.
This is safer, since no one has invented a way to do anything dynamic
to FORTRAN, COBOL, or BASIC
 
Real Computer Scientists like C's structured constructs, but they are
suspicious of it because it is compiled.  (Only batch freaks and efficiency
weirdos bother with compilers)
 
Real Computer Scientists play Go.  They have nothing against the concept of
mountain climbing, but the actual climbing is an implementation detail best
left to programmers
 
Real Computer Scientists admire ADA for its overwhelming aesthetic value, but
they find it difficult to actually program in, as it is much too large to
implement.  Most computer scientists don't notice this because they are still
arguing over what else to add to ADA
 
Real Computer Scientists work from 5pm to 9am because that's the only time
they can get the 8 megabytes of main memory they need to edit specs.  (Real
work starts around 2am when enough MIPS are free for their dynamic systems.)
Real Computer Scientists find it hard to share 3081s when they are doing
"real" work
 
Real Computer Scientists only write specs for languages that might run on
future hardware.  Nobody trusts them to write specs for anything homo sapiens
will ever be able to fit on a single planet
 
Real Computer Scientists like planning their own environments to use
bit-mapped graphics.  Bit-mapped graphics is great because no one can afford
it, so their systems can be experimental
 
Real Computer Scientists regret the existence of PL/1, PASCAL, and LISP.  ADA
is getting there, but it still allows people to make mistakes
 
Real Computer Scientists love the concept of users.  Users are always real
impressed by the stuff computer scientists are talking about; it sure sounds
better than the stuff they are being forced to use now
 
Real Computer Scientists despise the idea of actual hardware.  Hardware has
limitations; software doesn't.  It's a real shame that Turing machines are so
poor at I/O
 
Real Computer Scientists love conventions.  No one is expected to lug a 3081
attached to a bit-map screen to a convention, so no one will ever know how
slow their system runs
 
Real Computer Scientists don't run IBM hardware.  If someone will fix it when
it breaks, it's not spacey enough


                             Real users Don't
                             ----------------
 
Real Users don't define requirements...
...If these computer folks are so smart, they should KNOW what we want



