From: Nancy Blachman <decvax!decwrl!sun!idi!resonex!nancy@Ucb-Vax.ARPA>
To: net.unix, net.unix-wizards, net.sources
Subject: Actual tricks, shells, csh aliases and the like, 1 of 3
Date: 16 Oct 84 21:20:53 GMT
Organization: Resonex Inc., Sunnyvale, CA

> [Know anybody with a GREAT .login or .cshrc?]

> I'm interested in collecting the little tricks, shell scripts, awk
> hacks, csh aliases, and such that people have built to make their daily
> life a little easier or more automatic.  Being a fairly new system
> administrator I don't have the big toolbox that years of messing around
> will leave you with.  If you have any hacks you're proud of (or that
> you aren't proud of, but which work anyway), and you're willing to make
> them public, mail them to me.  I'll collect, collate, shuffle, sort,
> munge, judge, select and discard them and then "summarize to the net".

This article concentrates on  aliases, and .cshrc and .login files I received
in response to my solicitation. The second article in this series focuses
shell scripts. The third article centers on C programs and awk scripts.

/\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\/
> Nancy Blachman {allegra,hplabs,ihnp4,sun}!resonex!nancy  (408)720 8600 x37 <
/\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\/

::::::::::::::
aliases/1
::::::::::::::
Date: Thu, 13 Sep 84 07:27:35 est
From: ihnp4!pur-ee!davy (Dave Curry)
To: ihnp4!resonex!nancy
Subject: aliases

Nancy:

        Here's a few handy aliases to put your current working
directory into your prompt:

alias cd chdir \!:\* \; set prompt='${cwd}\[!\]\ ' \; setenv CWD '$cwd'
alias pd pushd \!:\* \; set prompt='${cwd}\[!\]\ ' \; setenv CWD '$cwd'
alias pp popd \!:\* \; set prompt='${cwd}\[!\]\ ' \; setenv CWD '$cwd'

These put the current directory into the environment also, this is
for an editor used here locally which uses this information.  You can delete
that part if you don't need it.

--Dave Curry
ihnp4!pur-ee!davy



::::::::::::::
aliases/2
::::::::::::::
From: hplabs!sdcrdcf!sdcsvax!greg (Greg Noel)
Date: Thu, 13 Sep 84 10:57:51 pdt
Return-Address: ucbvax!sdcsvax!greg or Greg@NOSC
Organization: NCR Corporation, Torrey Pines
To: sdcrdcf!hplabs!resonex!nancy
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

I have three little gems from my bag of tricks that I'd like to show you,
all for the C shell.  The first is an alias for the `pwd' command:
        alias pwd       echo \$cwd
The built-in variable `cwd' always contains the current working directory,
and since `echo' is a built-in command, this is MUCH faster than invoking
a program to calculate the actual location.  The only problem (and I don't
have a solution) is that it gets confused by symbolic links to directories.

The second one is something that turns the directory structure from something
passive into something active:
        alias come      if -e .greg_come source .greg_come
        alias go        if -e .greg_go   source .greg_go
        alias cd        go \; set prev = \$cwd \; chdir \!\* \; \
                                echo \$prev ==\\\> \$cwd \; come
What this does is cause the shell to look for a specific file whenever it
transfers into a directory, and if it is there, source it.  Also, whenever
you leave a directory, it looks for a different file and sources that before
leaving.  I use this to set up location-specific aliases or to have something
happen auto-magicly whenever I work in some diretory -- for example, changing
into my `play' directory invokes a menu that will set up the environment and
run game programs -- different save files for `rogue' or other stuff that
I don't want to carry around with me all the time.  It's more flexible than
it seems at first glance; the only thing I can suggest is to try it and you
will keep finding new ways to use it.

The last one is really a replacement for the `pushd' and `popd' commands --
I didn't like the way they worked, so I did these.  It seperates the action
of pushing a directory from the action of changing directories.  I wanted
this since I also have a whole bunch of aliases to move between widely-
seperated portions of the filesystem (something I do a lot) and it was
easier for me to type `push; u test' (which pushes the current directory
and takes me into the `test' subdirectory of something interesting) than
to type `pushd /long/complicated/path/test'.  This isn't terribly original,
but the gem, and something I find VERY useful is the `back' command, which
takes you to the directory you last left, so you can bouce back and forth
between two directories -- one is the source location and one the test
location, for example.  Anyway, here's what it looks like:
        alias push      set dirstack = \( \$cwd \$dirstack \) \; \
                                echo Pushing \\\[\$\#dirstack] \$cwd \; \!\*
        alias pop       cd \$dirstack\[1] \; set dirstack = \( \$dirstack\[2-] \)
        alias back      set dirstack = \( \$prev \$dirstack \) \; pop
        alias pp        set x = \$dirstack\[1] dirstack\[1] = \$cwd \; cd \$x
Notice that it interacts with the previous alias for `cd' in that it expects
the variable `prev' to have the previous directory (which is what `cd' leaves
in it).  The `pp' alias is sometimes useful -- it pushes the current directory
while transfering to the old top of stack, a simultaneous push-pop.

I hope you found these interesting and entertaining.

-- Greg Noel, NCR Torrey Pines       Greg@sdcsvax.UUCP or Greg@nosc.ARPA

::::::::::::::
cshrc/1
::::::::::::::
From: <hplabs!tektronix!jerryp>
Date: Thursday, 13 Sep 84 09:48:55 PDT
To: resonex!nancy, jerryp
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

Nancy,

I'll mail you a few .cshrc and .login files.  Unfortunately, I'm short on
time... so I can't comment a lot... but I'd be glad to answer any questions
you've got about how they work.

A summary of them:

1)  This .cshrc file comes from the tektronix!tekred machine in Redmond,
Oregon.  Its neat feature is that, when a user "su"'s to someone else's
account, their prompt changes
from    %
to      account>
where the "su"'d name appears before the >.  Very nice, I think.

Also, they do a standard thing around here.  The first line [if ($?prompt)]
checks to see if the .cshrc is being scanned by an interactive shell.  If so,
the commands below are executed.  If not (like a shell escape from "vi"), the
commands aren't executed.  This really speeds up shell escapes!  (I do the
same thing, in a different way, in my .cshrc file.)


2)  This is my .login file.  I should mention that I've got my own calendar
system that's updated every morning at 1 AM by "at".  It sits in my
".calendar" directory.  You'll see a lot of that stuff in the .login file.


3 & 4)  I have *two* .cshrc files.  One, ".cshrc", is the standard file.  It
contains a limited list of aliases and setup commands.  The other, ".cshrc2",
is one I source when I'll be logged on for a long time and doing a lot of
work.  The .cshrc2 has time-saving aliases like "alias m more" in it.

At login, the .cshrc is always read.  This sets my prompt to something like
        <directory,#>
where # is the C-shell history number.  Also, since my system is so busy, I
have a "quick login" setup in .cshrc to let me see my mail immediately and
logout without doing anything else, if I want to.  This quick-login has a
        $
prompt set... the Bourne-shell prompt.

If I want an extended login, I execute the alias "res" (from .cshrc).  It sets
alarms automatically (for meetings, etc... from my .calendar directory) and
re-sets my prompt to something like
        [directory,#]
That way, I know that I've got all my aliases available.

Since my system is overloaded, this dual-.cshrc system saves me time and
hassle... .cshrc2 takes a long time to source.


--Jerry Peek, UNIX Training Instructor, Tektronix, Inc.
US Mail:   MS 76-036, P.O. Box 500, Beaverton, OR 97077
uucp:      {allegra,decvax,hplabs,ihnp4,mit-eddie,ucbvax}!tektronix!jerryp
CSnet:     jerryp@tek
ARPAnet:   jerryp.tek@csnet-relay
Phone:     503/627-1603


---------------------------------------------------------------------------
FILE #1 (.cshrc):

if ($?prompt) then
        set history=20
        set path=(. $home/bin /usr/local /usr/tek /usr/public /usr/ucb /bin /usr/bin)
        set mail=(300 /usr/spool/mail/$home:t /etc/motd)
        source ~/.aliases

        set prompt=`whoami | sed -e 's/ .*//' -e 's/user=//'`
        if ($prompt == $user || $prompt == "") then
                set prompt="% "
        else
                set prompt="$prompt> "
        endif
endif
---------------------------------------------------------------------------
FILE #2 (.login):
uptime                  # show system load
set ignoreeof           # do not logout on EOF (^D)
set noclobber           # do not overwrite files with > or >>
cp ~/.exrc8 ~/.exrc     # set up vi/ex to environment in ~/.exrc8
setenv EDIT /usr/ucb/vi # set default editor to vi
setenv PRINTER uph      # if type "man -Tlpr", use "uph" to store for printing
setenv NEWSBOX ~        # save news (readnews "s") in home directory or beneath

set noglob; eval `tset -srQm 'plugboard:?4025'`; unset noglob

stty new crt            # new tty driver, crt terminal, see newtty(4)
stty tostop hup         # stop background jobs on output, hangup hw on logout
limit filesize 2000     # do not write file > 2,000,000 bytes
limit coredumpsize 0    # prevent core dumps when csh bombs
touch .llog             # set correct last login time for finger
if ($TERM == 'tek4023' || $TERM =~ aaa*inv ) then
        # KEEP more FROM USING THE ul OPTION AND MESSING UP DISPLAY:
        setenv MORE -u
else if (($TERM == qume5) || ($TERM == dumb)) then
        mesg n
        exit 0
endif

# immediate notification (every 60 seconds) of mail:
set mail = (60 /usr/spool/mail/$user /etc/motd)

# check /etc/motd for changes; if any, show them and (maybe) add to calendar:
diff ~/.calendar/last.motd /etc/motd >! /tmp/motd.diff
if ( $status != 0 ) then
        echo "< = old MOTD ... > = new MOTD"
        more /tmp/motd.diff
        echo "To read the new MOTD into the calendar, answer y.  To ignore it, answer q."
        echo -n "Otherwise, hit RETURN: "
        set ans = $<
        if ($ans == "y") then
                cat /etc/motd | tee -a ~/.calendar/calendar >! ~/.calendar/last.motd
                vi + ~/.calendar/calendar
                echo "To reset *today's* calendars, type 'calendar.set -F'."
        else if ($ans == "q") then
                cat /etc/motd >! ~/.calendar/last.motd
        endif
endif

echo "--------------------"
inc             # put new mail, if any, in ~/.mail/inbox

echo "--------------------"

set time = 10   # for jobs that take longer than 10, show how long
# IF THERE ARE LOGIN MESSAGES, SHOW THEM:
if !(-z ~/.calendar/mesg.login) then
        echo "Here are the login messages, "`date '+%a %D'`
        echo ""
        doublespace ~/.calendar/mesg.login
endif

echo "For an uptime graph, type 'upgr'."
---------------------------------------------------------------------------
FILE #3 (.cshrc):
# if this is a non-interactive shell, quit.
if ( ! $?prompt) exit 0

# save login system search path, removing leading "." (thanx to tekig!danr):
if ( ! $?SYSPATH ) setenv SYSPATH "$path[2-]"

# set default places to find commands (put current and .bin directories first):
set path=(. ~/.bin $SYSPATH /usr/public{,/texthelp} /usr3/{barbaraz/.,tcomm/}bin)

# CHECK FOR QUICK LOGIN:
if (! $?LOGGEDIN) then
        echo -n "For quick login (Bourne shell), answer y; otherwise, press RETURN: "
        if ( "$<" =~ y* ) then
                echo "To continue with login, press control-D; to logout, type 'stty 0'"
                /bin/sh -i
                echo "Continuing with standard login..."
        endif
endif
setenv LOGGEDIN x

# set cd search path for directory names which aren't sub-directories:
set cdpath=(~ `finddirs ~/training{,/*} /usr3/tcomm/unix{,/*}` ~/.bin ~/.log ~/.mail ~/stuff ~/tape*)

set history=1000        # keep the last 1000 commands in history

# use /usr/public/prompt to get massaged directory name for prompt-setting:
set prompt = "<`prompt ~ $cwd`,"{\!}"> "

# edit my calendar:
alias calen 'vi ~/.calendar/calendar; echo '"To reset today\'s calendars, type calendar.set -F"''

# change directory, reset prompt:
alias cd 'chdir \!*; set prompt = "<`prompt ~ $cwd`,"{\!}"> "'

# add to specified .log directory
alias log 'echo "Put a .ze at end of file, unless last log of this set.";vi + ~/.log/`cat ~/.log/latestlog`/\!*'

# create newterm command to allow terminal-type change
alias newterm 'set noglob;eval `tset -srQ \!*`;unset noglob'

# sets alarms (if any) and sources '.cshrc2' (my other alias list)
alias res '~/.bin/alarm.set ; source ~/.cshrc2'

alias todo 'vi ~/todo\!*'       # change one of the "to do" lists
---------------------------------------------------------------------------
FILE #4 (.cshrc2):

# notify immediately when background jobs are finished
set notify

# prompt with current directory name, history number:
alias s_p 'set prompt = "[`prompt ~ $cwd`,"{\!}"] "'
s_p

# set 'vi' for 4-character tabs/shifts:
alias 4vi 'cp ~/.exrc{4,}; echo "MODE: programming"'

# set 'vi' for 8-character tabs/shifts:
alias 8vi 'cp ~/.exrc{8,}; echo "MODE: text"'

# set 'vi' for quick work (no .exrc file):
alias qvi 'rm ~/.exrc; echo "MODE: quick"'

# easy way to compile "C" programs (ring bell if filename ends with ".c"):
alias C 'if ("\!*" =~ *.c) yes ;mv \!* ,\!*;echo \!*.c" SENT TO cc";cc \!*.c -o \!*;if (-e \!*) chmod 311 \!*'

# show alarms that (may be) set... and message explaining them:
alias alarms 'echo "These alarms have been set:";cat ~/.calendar/mesg.alarm; \ps | fgrep ".bin/nleave"'

# change back to previous directory:
alias c- 'set x=$cwd; chdir $lastdir; s_p; set lastdir=$x'

# edit my calendar:
alias calen 'v8 ~/.calendar/calendar; echo '"To reset today\'s calendars, type calendar.set -F"''

# see today's calendars:
alias cals 'cat ~/.calendar/mesg.*'

# save current directory for 'c-', change directory, reset prompt:
alias cd 'set lastdir=$cwd; chdir \!*; s_p'

# see mail without inc'ing it:
alias checkm 'see /usr/spool/mail/jerryp'

# same as 'cd', but lists directory, too:
alias cl 'set lastdir=$cwd; chdir \!*; ls -F; s_p'

# same as 'cl', but gives long list:
alias cll 'set lastdir=$cwd; chdir \!*; ls -l; s_p'

alias f 'grep "^\!*" /etc/passwd'       # quick version of "finger -s"

alias H 'history -r | fgrep "\!*"'      # find something in history list
alias h history 5       # show last five lines
alias hi history 10     # show last ten lines
alias his history 20    # show last twenty lines
alias hist 'history 40|m'       # show last forty lines; pipe to 'more'
alias histo 'history 70|m'      # show last seventy lines; pipe to 'more'

# send output of command to 'pr' (with command as header), then to uph:
alias hpr '\!* | pr -h "\!*" | uph'

alias j 'jobs -l >! /tmp/j$$; pushin /tmp/j$$; rm /tmp/j$$'
# show job status (process numbers, too) squeezed onto one line each

alias lc 'ls *.c'       # list all C source code in this directory

# add to specified .log directory
alias log 'echo "Put a .ze at end of file, unless last log of this set.";v8 + ~/.log/`cat ~/.log/latestlog`/\!*'

# list executable files, 5 columns, sorted across 80-wide line:
alias lx 'lf -1 | fgrep \* | pr -t -5 -l1 -w80'

alias m more            # shortened form of 'more' command

# faster pwd (singlequotes prevent expansion before it's executed):
alias pwd 'echo $cwd'

# re-start inverse video on Ann Arbors:
alias reinv 'echo "[7m";clear'

# lock terminal until ^C and login password are entered:
alias somb /usr3/jos/bin/somb

alias showm 'inc;show'  # get new mail

# give more info (how much time I've used) when using "status":
alias status 'source ~/.bin/status'

alias tcpr 'tcprint -p12 -m5 -ff \!* &'         # typical quick "tcprint" use

alias todo 'v8 ~/todo\!*'       # change one of the "to do" lists

alias up uptime

# make uptime graph:
alias upgr '(nohup uptime_graph ~/,up`date +%m%d.%H%M` &)'

# show uptime today's graph:
alias upsh 'uptime_show -20 ~/,up`date +%m%d`*'

# 'vi' for programming:
alias v4 '4vi;vi \!*'

# 'vi' for standard text:
alias v8 '8vi;vi \!*'

# call 'vi' with a search (must use 8vi because search requires a 'wrapscan')
alias vs '8vi; vi +/\!*'

alias write '/usr4/danr/bin/rite -c \!*'   # show each character as it's typed

#UNUSED ALIASES:
#alias cd 'set lastdir=$cwd;chdir \!*;set prompt="`~/.bin/prompt`"'
# change to maps directory:
#alias maps 'cd /usr/spool/news/lib/maps;echo "switching to newsa";su newsa;set $user=jerryp;c-'
# keep "at" job from dying because of long EXINIT:
#alias niterun 'setenv EXINIT "set sw=8";\niterun \!*;8vi'
#alias du ~danr/bin/du  # improved version of "directory usage" query
# format text, save in file".ty", then show it on the crt:
#alias typeup '~/.bin/type \!* >! \!*:r; more \!*:r'
# give description of 'ps' codes before doing the 'ps':
#alias ps 'cat ~/.ps.man;\ps \!*'
# easy way to compile and run "C" programs
# (ring bell if filename ends with ".c"):
#alias c 'if ("\!*" =~ *.c) yes ;mv \!* ,\!*;echo \!*.c" SENT TO cc";cc \!*.c -o \!*;echo "press ^C to stop execution";sleep 2;./\!*'
# easy way to change editor environment files:
#alias adde 'vi ~/.exrc\!*; set ex=(`cat ~/.exrc\!*`); setenv EXINIT "$ex"'
#alias rmm '\rmm \!* &'  # remove mail in background
# faster "man" listings:
#alias man 'echo "man -q:"; \man -q \!*'
# improved spell routine (write-protected dictionary):
#alias spel 'chmod +w ~/.misspell; /usr/public/spel \!*;chmod -w ~/.misspell'
# show whether using ~/.exrc4 or ~/.exrc8:
#alias vi 'echo "MODE: "$EXSTAT;/usr/ucb/vi \!*'
#alias comp '8vi;\comp \!*'     # set 'vi' for text before doing the 'comp'
# show last ten users of "tcprint" program:
#alias tcp tail /usr3/tcomm/.tcprint/log
# favorite "ps" (gives PID, PPID, STAT, TT, TIME, and long description):
#alias p 'ps lwx | cut -c12-22,53- | nfold'

::::::::::::::
cshrc/2
::::::::::::::
Date: Thu, 13 Sep 84 02:16:31 edt
From: ihnp4!seismo!umcp-cs!chris (Chris Torek)
To: ihnp4!resonex!nancy
Subject: Re:  Tricks, shell and awk scripts, ...

Actually Re: [Know anybody with a GREAT .login or .cshrc?]:

I don't know about *great*, but I'm probably one of the candidates for
*slowest* . . . .  FYA (For Your Amusement), here's my .login and .cshrc
on this machine (they're not the same on tove, gyre, gymble, and eneevax).

Chris

: Run this shell script with "sh" not "csh"
PATH=:/bin:/usr/bin:/usr/ucb
export PATH
all=FALSE
if [ $1x = -ax ]; then
        all=TRUE
fi
/bin/echo 'Extracting .cshrc'
sed 's/^X//' <<'//go.sysin dd *' >.cshrc
#
if ($?prompt) then
echo -n '['
set path=(. ~chris/bin ~chris/sys /usr/local/bin /g/local /usr/ucb /bin /usr/bin /usr/games /etc /usr/hosts)
echo -n 'cshrc]'
set ignoreeof history=100 time=2 mail=(10 /usr/spool/mail/chris) cdpath=(~ /g/VOTRAX ~/bin /g/chris ..) S=/usr/spool/uucp CICO=/usr/lib/uucp/uucico
alias hh history;alias h 'history 20';alias j jobs;alias o popd
alias status 'echo $status';alias so source;alias bye logout
alias p pushd;alias done 'echo ';alias kb "rm -i .*.bak *.bak .*.CKP *.CKP"
alias kc "rm -i .*.CKP *.CKP";alias e emacs;alias @@term 'kill -9 $$'
alias af ~chris/af/af;alias cdl "cd \!:1;ls \!:2*";alias lsl "ls -li"
alias lsa "ls -A";alias lsla "ls -lai";alias up "cd ..";alias upl "cd ..;ls"
alias cdll "cd \!:1;lsl \!:2*";alias lsld "lsl -d";alias lslg "lsl -g"
alias upll "cd ..;lsl";alias pl "pushd \!:1;ls \!:2*";alias z logout
alias pll "pushd \!:1;lsl \!:2*";alias ol "popd;ls";alias oll "popd;lsl"
alias cdla "cd \!:1;lsla \!:2*";alias v80 'echo -n "[?2l";set term=VT52'
alias v132 'echo -n "[?2l";set term=VT52.132';alias ansi 'echo -n "<"'
alias fix 'stty newcrt erase  kill ';alias ca 'ex "+1,.|q"'
alias own 'cp \!:1 /tmp/own$$;rm -f \!:1;mv /tmp/own$$ \!:1'
alias save 'cp \!:1 \!:1.old;chmod a-w \!:1.old;chmod +w \!:1'
alias c80 'echo -n "[?3l";set term=DT80';alias suspend 'suspend;dirs'
alias col80 'echo -n "[?3l";colnum 80';alias a alias
alias c132 'echo -n "[?3h";set term=DT80.132'
alias col132 'echo -n "[?3h";colnum 132'
alias hold 'echo -n "[H[J[12;20H[5mI'"'"'ll be right back[m[20H";lock;echo -n "[H[J"'
alias feed '(sleep 3000;echo Feeding time\\!)&'
alias open 'set noglob;eval `/usr/chris/bin/open \!:*`;unset noglob'
alias loav /usr/mark/bin/load
setenv VISUAL /usr/ucb/vi;setenv EDITOR /usr/local/bin/emacs
setenv EPATH :/usr/chris/emacs:/usr/israel/emacs:/usr/emacs/loclib:/usr/emacs/maclib
alias dir ls;alias era rm;alias printman /usr/man/printman;alias d dirs
alias clx 'rm -f /tmp/X_lock.\!:1 /usr/spool/uucp/LCK..\!:1'
alias aasize 'set noglob;eval `/usr/local/bin/aasize \!:1`;unset noglob'
alias aasave 'set noglob;eval `/usr/local/bin/aasave \!:1`;unset noglob'
alias down 'cd `echo */|awk '\''{print $1}'\''`;echo $cwd'
alias downl 'down;ls';alias downll 'down;lsl';alias mark 'set \!:1=$cwd'
alias lso 'lsla | sort +4 -rn';alias edenv 'source ~chris/bin/edenv'
alias aibib 'echo \!*|lookbib -n -p /usr/randy/papers/airefs|page'
alias checkque /usr/lib/mmdf/checkque;alias sum-dial /usr/lib/mmdf/sum-dial
alias deliver 'sh -c "HOME=/ /usr/lib/mmdf/deliver \!:*"'
alias ll 'ls -l';alias tm 'telnet 128.8.0.8'; alias  uptime
endif
umask 22
if ($?prompt) then
        set prompt='[\!] '
        echo ''
endif
//go.sysin dd *
made=TRUE
if [ $made = TRUE ]; then
        /bin/chmod 644 .cshrc
        /bin/echo -n '  '; /bin/ls -ld .cshrc
fi
/bin/echo 'Extracting .login'
sed 's/^X//' <<'//go.sysin dd *' >.login
#
stty erase ^H kill ^X intr  decctlq nl0 cr0 ff0
cd;setenv TERMCAP /usr/chris/.termcap
# cp .exrc1 .exrc
# Set up the terminal
# 4025=Tek4025 sd=dialup x1=Xer 1750 GG=Gigi d4=GT40 aaa=AAA else DT80
# if (`slowtty` == y) then
#       cp .mailrc2 .mailrc
# else
#       cp .mailrc1 .mailrc
# endif
set wantbaud=0
top:
switch ($TERM)
case su:
case network:
        set wantbaud=1
case sd:
case unknown:
        set term=`/ful/chris/bin/selterm`
        goto top
case 4025:
        stty crt tabs;tabset.tek
        breaksw
case h6:
case hp:
case hp2623:
case hp2626:
        stty tabs crt
        breaksw
case v550:
        stty crt;set prompt='[7m[\!][m '
        breaksw
case GG:
        stty crt;unsetenv TERMCAP;set prompt='[7m[\!][m '
        breaksw
case d4:
        set term=gt40;stty crt
        breaksw
case aaa:
case aaa-60:
        set term=aaa prompt='[7m[\!][m ';stty tabs crt;unsetenv TERMCAP
        aakey -f /ful/chris/.aakeys
        if (`tty` =~ /dev/tty*) then
                echo -n 'Lines? [30] '
                set lines=$<
                if ($lines != ) then
                        aasize $lines
                endif
        endif
        breaksw
case h19:
case h19a:
case kb:
        set term=h19a prompt='[7m[\!][m ';stty tabs crt crtkill
        breaksw
case Dq:
case DT80:
case D5:
case vt100:
        set term=DT80 prompt='[7m[\!][m '
        echo -n '[?4l';stty crt
        breaksw
default:
        unsetenv TERMCAP;echo "Wonder what $TERM is?"
        breaksw
endsw
if ($wantbaud == 1) then
        selbaud
endif
unset wantbaud lines
# mailcount
checknews
setenv ROGUEOPTS 'jump,ask,terse,flush,passgo,fruit=hregfx'
setenv PAGER /usr/ucb/page
setenv SPELL_LISTS /ful/chris/.splist
alias logout 'source /ful/chris/.logout.';alias exit logout
# /usr/games/fortune
w; # calend; /usr/chris/bin/ac 22:00
echo ----------------------------------------------------------
# rehist .history
//go.sysin dd *
made=TRUE
if [ $made = TRUE ]; then
        /bin/chmod 644 .login
        /bin/echo -n '  '; /bin/ls -ld .login
fi

::::::::::::::
cshrc/3
::::::::::::::
Date: Fri, 14 Sep 84 14:59:01 pdt
From: hplabs!sdcrdcf!sdcsvax!sdcc6!loral!hlb (Howard Brandell)
To: sdcc6!sdcsvax!sdcrdcf!hplabs!resonex!nancy
Subject: .cshrc

I am sending my entire .cshrc file because I have some things in it
that help me out.

Firstly, note the aliases that allow me to selectively read those
newsgroups of interest.  Aha! You may say I can put it all in the
.newsrc file and have the system inform me when there is news and
read it out simultaneously.  But, sometimes we get news during the
course of the day and I like to check my favorites continuously.

Also, not the aliases for tip.  These allow me to dial my remote
locations with both spped and accuracy. As an aside,  I have
created a .tiprc file which logs all my remote host conversation
into a file.  In this way, nothing is lost.  Note the 'rt' command
which allows me to purge tiplog.

alias a alias
a sd   "msg,gju,glw,kay,sdi"
a ds   "chmod 600 .signature"
a es   "chmod 640 .signature"
a vc   "ccalc"
a m    "mail"
a p    "more"
a rk   "readnews -n net.kids"
a ra   "readnews -n net.micro.apple"
a ri   "readnews -n net.micro.pc"
a rs   "readnews -n sdnet.computing"
a rb   "readnews -n net.sport.baseball"
a rn   "readnews -n net.columbia"
a rw   "readnews -n net.wanted"
a rl   "readnews -n net.legal"
a r    "readnews"
a logs "readnews -n net.sources -l>sources.log"
a motd "cat /etc/motd|more"
a h   "history -r \!*|more"
a t1  "tip 561-7271"
a t2   "tip 452-1869"
a t3   "tip 283-1538"
a t4   "tip 692-1961"
a t5   "tip 270-1166"
a t6   "tip 217-1900"
a rt   "rm tiplog"
a bye   logout
a cd    "cd \!* ; dirs"
a term  'set noglob; eval `tset -n -s \!*`'
a wat   "ps -au | more"
a pv    printenv
a j     "jobs -l"
a f     "finger|more"
a l     ls -F

if ( $?prompt == 1 ) then
        set prompt="\!: "
        set mail=(60 /usr/spool/mail/$USER)
endif
set history =   24
set cdpath = (. ~)

Also note the aliases for the more mundane commands, like mail
and more -c.

Hope this has been of some help.  Please disregard my earlier
transmission as I had some operational difficulties.  Thx.

::::::::::::::
cshrc/4
::::::::::::::
From: sun!dagobah!mike
Date: Mon, 17 Sep 84 23:27:05 pdt
To: sun!resonex!nancy
Subject: .cshrc

set mail=(10 /usr/spool/mail/$user)
set path=(. ~/bin /usr/lfl/bin /usr/ucb /bin /usr/bin /usr/hosts /usr/suntool)
set cdpath  = ( . .. ~ /usr /u0 /u1 /audio)
set mail=(10 /usr/spool/mail/$user)
set msgs=(10 /usr/msgs/bounds)
set history = 50

source  ~/.aliases
set D = /net/dagobah/u0/mike
set d = /net/dim/u0/mike
set k = /net/kessel/u0/mike
set n = /net/nellybell/u0/mike
if (! $?HOST) setenv HOST `hostname`
alias s_prompt 'set prompt = "[$HOST\\\!$cwd]\\
% "'
alias cd 'cd \!*; s_prompt'
s_prompt


::::::::::::::
cshrc/5
::::::::::::::
From: sun!dagobah!mike
Date: Mon, 17 Sep 84 23:27:19 pdt
To: sun!resonex!nancy
Subject: .aliases

alias alice     cu -s 1200 2016654115
alias rabbit    cu -s 1200 2016654150
alias yale      cu -s 1200 2034323510
alias ajax      cu -s 1200 2015828265

alias ts        'setenv TERM `tset - \!* -Q`;set term = $TERM;unsetenv TERMCAP;'
alias aa        "ts aaa-26; aaapf"
alias aaa       aa

alias h         history
alias l         'ls -Fa'
alias lp        l -t
alias ll        'ls -laF | more'
alias wo        /u0/td/bin/who
alias m         'make \!* >>& errors &'
alias mail      Mail
alias ml        /bin/mail
alias lm        ml
alias rml       'rm -f /usr/spool/mail/mike'
alias RM        '/bin/rm -rf'
alias clean     'rm *.o core errors a.out'
alias CLEAN     'RM *.o core errors a.out ~/.REMOVED; mkdir ~/.REMOVED'
alias die       'clear; kill -HUP $$'
alias tlog      tail -f /usr/spool/uucp/LOGFILE
alias ter       tail -f errors

  #
  # For job control:
  # Use 'fg' to bring job into the foreground, 'bg' to run job in background.
  #   'v', to restart vi editor
  #   'W', to restart ice editor
  #   'j', to list out jobs
  #   'k', to kill jobs; 'k 2' kills job [2]; 'k' kills the most recent job (+).
alias v       %vi
alias j       jobs
alias k       'kill %\!*'
alias sysline ~/bin/sysline -Dhmrj


::::::::::::::
cshrc/6
::::::::::::::
Date: Fri, 21 Sep 84 01:17:43 cdt
From: ihnp4!uiucdcs!liberte (Daniel LaLiberte)
To: sun!resonex!nancy
Subject: .cshrc trick

I like my recursive prompt that shows the depth of shell calls with added
">"s.  It also gives a different prompt for my superuser which has the same
home.  Additionally, we have several vaxes, uiucdcs*, networked with
ethernet.  Upgrades are easier with the same .cshrc on all machines.


...
if (! $?PROMPT) setenv PROMPT ""        # initialize
setenv PROMPT "$PROMPT>"                # add ">"
if ($?prompt) then
        set sys = `hostname`
        if ("$prompt" == "% ") then     # regular user
                set prompt = `echo $sys | sed s/uiucdcs//`
        else if ("$prompt" == "# ") then        # super user
                set prompt = "$sys#"
        endif
        set prompt = "$prompt\!$PROMPT "
endif


My login prompt (on uiucdcs) is:

1>

A csh call will produce:

1>>

Remote login to uiucdcsb, for example:

b1>

Superuser on uiucdcsb:

uiucdcsb#1>>


I have an alarm script and a spooled rcp that both use `at`.

Daniel LaLiberte
ihnp4!uiucdcs!liberte


::::::::::::::
cshrc/7
::::::::::::::
Date: Sun, 7 Oct 84 20:35:02 pdt
From: Ken Greer <hplabs!kg>
To: resonex!nancy
Subject: Xmas is early this year...

Here's what I thought were the most interesting things in my
csh profile.

1. Prompt is (curdir hist#), or [curdir hist#] if running as su.
   The brackets stack, so if I login as kg and su to kgsu, my prompt
   is [(curdir hist#)] indicating my previous shell was non-su.
   In both cases, the current directory always appears in prompt.

2. On that subject, I heartily recommend a separate su login
   for each su-er on a system.  This lets everyone have their
   own profile, and when they quit you don't have to change the su passwd,
   just remove their su.

3. The directory stuff. (I prefer it to pushd/popd.)
   ds   - displays directory stack (set to length DSSIZE below).
   go # - go to directory item number #
   back - go to previous directory.
   cd   - stack current directory and go to a new one.  Oldest directories
          fall off end of stack (whose size is DSSIZE).

4. The "e" and "ec" commands let you edit the last or any command.
   If works with a special program.  Would you like that?

5. Delete/Undelete - special program.  Lets you recover deleted
   files up to three days (user selectable).

6. Do you know about my tcsh?  Not sure how it fits in with tricks though.

                                -Ken


# Fancy prompt...
if ($?prompt) then
if (! $?LEFTPROMPT) setenv LEFTPROMPT ""
if (! $?RIGHTPROMPT) setenv RIGHTPROMPT ""
if (`whoami` == root) then
        setenv LEFTPROMPT '['"$LEFTPROMPT"
        setenv RIGHTPROMPT "$RIGHTPROMPT"']'
   set path=(~/bin /usr/local/etc /etc /usr/local/bin /usr/ucb /bin /usr/bin .)
else
        setenv LEFTPROMPT '('"$LEFTPROMPT"
        setenv RIGHTPROMPT "$RIGHTPROMPT"')'
        set path=(~/bin /usr/local/bin /usr/ucb /bin /usr/bin .)
endif
alias setprompt 'set prompt = "${LEFTPROMPT}${cwd} \\!${RIGHTPROMPT} "'
setprompt
alias a alias

# directory manipulation...
set DSSIZE = 10
if (! $?DS) set DS = (~)
a back  'set xx=$DS[$#DS] DS[$#DS]=$cwd; chdir $xx; unset xx; setprompt'
a go    'set xx=$DS[\!*] DS[\!*]=$cwd; chdir $xx; unset xx; setprompt'
a ds    'echo $DS | tr " " "\012" | cat -n'
a cd   'if ($#DS >= $DSSIZE) shift DS; set DS = ($DS $cwd);chdir \!*; setprompt'

# virtual remove...
a rm    del
a rm!   /bin/rm

# edit command...
a e     '/usr/local/bin/ec \!-1:q'
a ec    '/usr/local/bin/ec "\!*:q"'

# misc...
a j     jobs
a ls    '/usr/ucb/ls -F'
a tag   '/usr/ucb/vi -ta \!*'
a ts    'set noglob;eval `tset -s -Q \!*`'
a wd    'echo $cwd'
endif


::::::::::::::
cshrc/8
::::::::::::::
Date: Thu, 13 Sep 84 08:36:47 edt
From: sun!decvax!genrad!teddy!dls (Diana L. Syriac)
To: genrad!decvax!decwrl!sun!idi!resonex!nancy
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

I'm sorry, I don't really have any "tricks" to make life easier, I'm also
a rather new Unix user....except for one:
        I use setenv a lot to define a bunch of directories that I use
        a lot.  For example, I have in my .cshrc:
                setenv obc ~doc/rts/obc
        So anytime I want to get to that directory (or just look at it), I
        just type:      ls $obc/filename
        These environment variables work inside of mail as well as inside of
        emacs.
I suppose you already have that one from other people.

We also have on our system some "local" programs that make life a lot easier:
We have an "lf" and "dir" that replaces "ls" and "ls -l", but with an added
feature:  directories are displayed in bold letter, executables are displayed
in reverse video and special files are displayed in flashing letters.  It's
quite easy to see at a glance what the files are or where you want to go.

We also have a "pushd" and "popd" which replace the "cd" command.
        pushd directory
will pushd a directory onto the "stack", and change to it.  After you're
finished with that directory, just typing
        popd
will put you back to where you were.  There is a "dirs" command to
allow you to look at the "stack" to see where you are, where you've been.
If you use "cd" instead, it's smart enough to change your stack and replace
the current directory with the one specified in "cd". And if you just say
"pushd" by itself, it will SWAP the current directory with the last directory
you were in, making it very easy to toggle between two directories.

Other things that we've done:
        Built a script for the nroff command that is used by most people
on the system, including macros and some "local" filters to make it look
nice on terminal, line printer, and diablo.  I have also created a little
program which can be used in conjunction with nroff to produce "change bars"
at the left margin of documents.  We used the change bars quite a lot under
vms rno.
        We have a set of programs that produce "C" listings, with a table
of contents showing all files AND routines, page numbered and file numbered,
each file has a line number at left margin indicating file and line number
(eg: 3.41 refers to file 3, line 41), and at the very end of listing, there
is a cross-reference of all tokens, giving file.line references.  Part of
this set of programs was taken directly off the net and modified for our
own use.

Well, that's all that I can think of for now.  BUT what I really mailed
to you was for something that I want.  At the last DECUS, one of the speakers
demonstrated a little program that he wrote that allowed him to keep a
running log of what he did every day.  The program started up when he logged
on, and ran in the background.  Every 15 minutes, it would beep at him,
asking him to input a line telling what he was currently doing.  If ignored,
it would beep at him every minute until he input something to it.  I don't
know who the guy was, and I lost his business card, but I'd sure like to
get that program if you have it.  Thanks much.

                        Diana L. Syriac
                        GenRad, Concord, Ma.
                        decvax!genrad!teddy!dls


::::::::::::::
logins/1
::::::::::::::
From: sun!dagobah!mike
Date: Mon, 17 Sep 84 23:26:53 pdt
To: sun!resonex!nancy
Subject: .login

#tset -m dialup:aaa-60 -Q
tset -m dialup:c100-4p -Q
setenv TERM $term
switch ($TERM)
        case dialup:
                set term = aaa-60; setenv TERM $term
                ~/bin/aaapf
                breaksw
        case c100-4:
        case c108-4p:
                sysline
        case c100-4p:
                setkeys
endsw
stty new erase "^?"

biff y
setenv notify true
setenv CWD $cwd
setenv SHELL /bin/csh
setenv MAIL ~/Mail
setenv MANPATH /u0/pn/man:/u0/mike/Man:/usr/lfl/man:/usr/man
setenv INCPATH /usr/lfl/include:/usr/include:/u0/mike/Include
setenv LIBPATH /usr/lfl/lib:/lib:/usr/lib:/u0/mike/Lib
setenv LOADPATH /usr/src/lfl/bin/emacs.unipress/emacs4.2/maclib
setenv EDITOR /usr/ucb/vi
uupoll ucbvax
msgs


::::::::::::::
logins/2
::::::::::::::
Date: Fri, 14 Sep 84 10:42:43 edt
From: Jay Weber  <amd!mordor!ut-sally!seismo!rochester!jay>
To: ut-sally!mordor!dual!amd!resonex!nancy
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

I use the hold option in my .mailrc, which keeps messages around
until you explicitly delete them.  That's a popular option since
it makes it easy to keep around descriptions of things to do, but
it gets hard to tell when you have new mail and how much.  So, I
have this in my .login:

@ newmail= `from $mail[$#mail] |awk 'END{print NR}'` - `cat .mailsize`
if ($newmail == 1) then
  echo "(There is one new mail message.)"
else
  if ($newmail > 1) echo "(There are $newmail new mail messages.)"
endif
------------
and this in my .logout:

if (-r $mail[$#mail]) then
  from $mail[$#mail] | awk 'END{print NR}' >~/.mailsize
endif
------------

Jay Weber
..!seismo!rochester!jay
jay@rochester.arpa


::::::::::::::
logins/3
::::::::::::::
Date: Fri, 14 Sep 84 15:16:00 cdt
To: ctvax!convex!allegra!resonex!nancy
From: allegra!convex!trsvax!gm  (George Moore)
Subject: neat .login's

Nancy,
   Here is some of the aliases I use, as well as part of my .login
file: (We are running 4.1BSD on a 11/780)

  alias back 'set back=$old; set old=$cwd; cd $back; unset back'
  alias cd 'set old=$cwd; chdir \!*; sp'
  alias sp 'set prompt="$cwd> "'
Those aliases allow my prompt to always be my current directory.
You never have to run "pwd" again. Looks kindof strange when you
are in a low directory like /g/usr/src/local/csh, but you get used
to it. It also allows you to cd to some low dir, and then type
"back" and you are back in the directory you started in.

I have this line in my .login:
  sh -c "$HOME/bin/firstlog &"
This line allows you to spin off a background job without the
"[1] 22934"  message messing up your screen. Firstlog is done
below. I have a security program which goes out and checks a few
key files and directories (/etc/passwd, /etc/group, /usr/lib/crontab,
/etc). If anything has changed, it sends me mail informing me of the
fact. But I only wish it run once a day, at the time I first login for
the day. (I don't want it run from crontab, that makes things too
predictable for the users)

---------------------------------------------------------------------
#! /bin/csh
#  Firstlog -- finds out if this is the first time I have logged in
#              today and start-up all sorts of neat stuff if it is.

set date=`/bin/date`
set now=`/usr/ucb/last $user`
if ($date[2] != $now[13] || $date[3] != $now[14]) then
        sh -c "$HOME/personal/security/secure &"
endif
---------------------------------------------------------------------

I hope this helps.                              George Moore
                                                gm@trsvax.UUCP


From: Nancy Blachman <decvax!decwrl!sun!idi!resonex!nancy@Ucb-Vax.ARPA>
To: net.unix,net.unix-wizards,net.sources
Subject: Actual Tricks, shells, csh aliases and the like, 2 of 3
Date: 16 Oct 84 21:22:55 GMT
Organization: Resonex Inc., Sunnyvale, CA

> [Know anybody with a GREAT .login or .cshrc?]

> I'm interested in collecting the little tricks, shell scripts, awk
> hacks, csh aliases, and such that people have built to make their daily
> life a little easier or more automatic.  Being a fairly new system
> administrator I don't have the big toolbox that years of messing around
> will leave you with.  If you have any hacks you're proud of (or that
> you aren't proud of, but which work anyway), and you're willing to make
> them public, mail them to me.  I'll collect, collate, shuffle, sort,
> munge, judge, select and discard them and then "summarize to the net".

This article focuses shell scripts I received in response to my solicitation.
The first article of this series concentrates on  aliases, and .cshrc and
.login files. The third article centers on C programs and awk scripts.

/\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\/
> Nancy Blachman {allegra,hplabs,ihnp4,sun}!resonex!nancy  (408)720 8600 x37 <
/\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\/

::::::::::::::
shells/1
::::::::::::::
Date: Thu, 13 Sep 84 12:49:57 edt
From: allegra!vax135!cornell!tesla!mac (Michael Mc Namara)
To: cornell!vax135!houxm!mhuxl!ulysses!allegra!resonex!nancy
Subject: Cute cshell - sh scripts

    If your are like most UNIX systems, you have a plethora of different
terminals that  your system  is supposed to support.  Sure, with termcap
and terminfo, and programs written to use them, the interface gets easier.
If you only ever login to one particular terminal, you can

set term = "vt131"

or

TERM=vt131
export TERM

in your .login or .profile.

But what if you,  or some of your users,  drift  around using different
terminal types-- You have a terminal room with many different terminals.

Here is a set of shell scripts & C programs that use the "echo terminal
type" command that many terminals support, to do automatic terminal type
identification and setting:  (of course I've only made it work for  the
terminals we have here at Cornell, and some day I should write more of it
in C...)

    This one is written for cshell:

##########################################
#    Identify and set terminal type (csh)#
##########################################
set noglob
echo Please wait...
stty cbreak -echo
# this sequence will cause all terminals we have to echo something
# except for adm's; those users are told to hit 'a' when they see
# please wait
echo ' CZ[c'
sleep 1
# this calls a c program to grab the id string from the terminal
# program is included later...
set type = `/usr/new/rin.login`
stty -cbreak echo new crt
#########################
# the or in the vt100 terminal type is because vt100's respond
# to both ^[Z and ^[[c, but DEC threatens to eliminate one of
# the responces (I forget which).. The extra stty back you see
# with DG terminals (Data General) is because their backspace is
# ^Y instead of ^H ( Home on DG terminals) This involves a modification
# of stty, which you would care about only if you have them--Write to me.
##################
if ( $type == "[?1;0c" || $type == "[?1;0c[?1;0c" ) then
     set term = vt100
     echo "VT101"
else if ( $type == "[?1;2c" || $type == "[?1;2c[?1;2c" ) then
     set term = vt100
     echo "VT100"
else if ( $type == "[?1;11c[?1;11c") then
     set term = ct500
     echo "[7mCIT - 500[m"
else if ( $type == "[?12;5;0;102c" ) then
     set term = vt100
     echo "VT125"
else if ($type == "[?1;2c[?1;2c") then
     set term = vt100
     echo "VT100, with Selenar Graphics"
else if ( $type == "o#\!R" ) then
     set term = dg200
     stty stop undef start undef back
     echo "DDG200E"
else if ( $type == "o#'C3" ) then
     set term = dg450
     stty back
     echo "FS11BFS00 DATA GENERAL DASHER D450"
else if ( $type == "o#'K3" ) then
     set term = dg450
     stty back
     echo "FS11BFS00 DATA GENERAL DASHER D450"
else if ( $type == "/K" ) then
     set term = vt52
     echo "Visual 50"
else if ( $type =~ "\\4*" ) then
     set term = hp2621
     echo HP2621
else if ( $type =~ "a" ) then
     set term = adm3a
     echo "adm3a"
else if ($type == "50" ) then
     set term = w50
     echo "WYSE50"
else
# Ask user for terminal type -- for some reason the above didn't work
set no_name_yet=1
set no_name_yet = 1;
while( $no_name_yet )
   echo -n "Please enter terminal type (hit return for menu) "
   set ttyname = ($< );
   switch( $ttyname )
   case d450:
   case dg450:
      set term=dg450;
      stty back
      set no_name_yet = 0;
      breaksw;
   case vt100:
      set term=vt100;
      set no_name_yet = 0;
      breaksw;
   case v50:
   case vt52:
      set term=vt52;
      set no_name_yet = 0;
      breaksw;
   case hp2621:
   case hp:
      set term=hp2621;
      set no_name_yet = 0;
      breaksw;
   case wyse50:
      set term=w100;
      set no_name_yet = 0;
      breaksw;
   case adm5:
      set term=adm5;
      set no_name_yet = 0;
      breaksw;
   case adm3+:
   case adm3:
   case adm3a:
      set term=adm3+;
      set no_name_yet = 0;
   case d200:
   case dg200:
      set term=dg200;
      stty stop undef start undef back ;
      set no_name_yet = 0;
      breaksw;
   case other:
      echo -n "Enter terminal name: "
      set term=($< );
      set no_name_yet = 0;
      breaksw;
   case '':
      echo Terminal abbreviations are:
      echo "Dasher 450 : dg450"
      echo "Dasher 200 : dg200"
      echo "Visual 50  : v50"
      echo "VT100      : vt100"
      echo "HP 2621    : hp2621"
      echo "ADM5       : adm5"
      echo "ADM3+      : adm3+"
      echo "Use 'other' to specify terminals not on this menu"
      breaksw;
   default:
      echo "I didn't understand that. Hit return for a menu."
   endsw
end
unset no_name_yet
unset ttyname
endif
stty -cbreak
stty echo
unset noglob

Ok, This one is used for Bourne shell lovers:  (I used /bin/test because
one user had an executable file called test somewhere in his path ahead
of where this program lived...That one took days to track down...)


echo "Please Wait..."
stty start  stop   crt new back  -echo cbreak
echo ' CZ[c'
sleep 1
TYPE=`/usr/new/rin.login`
stty echo -cbreak
if ( /bin/test \( $TYPE = "[?1;0c" \) -o \( $TYPE = "[?1;0c[?1;0c" \) ) then
     TERM=vt100
     echo "[7mVT101[m"
elif ( /bin/test \( $TYPE = "[?1;2c" \) -o \( $TYPE = "[?1;2c[?1;2c" \)  ) then
     TERM=vt100
     echo "#3[7mVT100[m"
     echo "#4?[7mVT100[m"
elif ( /bin/test  $TYPE = "[?1;11c[?1;11c") then
     TERM=ct500
     echo "CT 500"
elif ( /bin/test  $TYPE = "o#!R" ) then
     TERM=dg200
     stty stop undef
     stty start undef
     stty crt
     stty back
     echo "D DATA GENERAL DASHER D200E"
elif ( /bin/test $TYPE = "o#'C3" )  then
     TERM=dg450
     stty crt
     stty back
     echo "FS11BFS00 DATA GENERAL DASHER D450"
elif ( /bin/test $TYPE = "/K" ) then
     TERM=vt52
     echo "UVisual 50T"
elif ( /bin/test $TYPE = "50" ) then
     TERM=w50
     clear
     echo "WYSE 50"
elif ( /bin/test $TYPE = "\4088000" ) then
     TERM=hp2621
     echo HP2621
elif ( /bin/test $TYPE = "a" ) then
     TERM=adm3a
     echo ADM3a
else
     stty start
     stty stop
     stty new crt
     set no_name_yet=1
echo
while ($no_name_yet) do {
  echo
  echo Which terminal do you have?
  echo       Hit return for a menu.
  read INP
  case $INP
    in
100 | v | vt100) {
                  TERM=vt100
                  break
             } ;;
adm5)            {
                 TERM=adm5
                 break
             } ;;
adm3+)           {
                 TERM=adm3+
                 break
             } ;;
450 | dg450 | d450)  {
                  TERM=dg450
                  stty back
                  break
             } ;;
200 | dg200 | d200)  {
                  TERM=dg200
                  stty stop undef
                  stty start undef
                  stty back
                  break
             }  ;;
 50 | vt52 | v50)   {
                  TERM=vt52
                  break
             } ;;
 2621 | hp2621 | hp) {
                  TERM=hp2621
                  break
             } ;;
      other) {
                  echo -n Enter terminal name:
                  read tname
                  TERM=$tname
                  break
             } ;;
 ''|?|help)  {    echo Terminal abbreviations are:
                  echo
                  echo Dasher 450:  dg450
                  echo Dasher 200:  dg200
                  echo Visual  50:  vt52
                  echo VT100     :  vt100
                  echo HP 2621   :  hp2621
                  echo ADM3+     :  adm3+
                  echo ADM5      :  adm5
                  echo "Use 'other' to specify other terminals."
                  echo
             } ;;
        * )  {   echo "I did not understand that."
             } ;;
  esac
  }
done
fi
export TERM

*********
And here is the c program that read's in the terminal ID string:


/* rin -- read in a char string which may not be terminated */
char buf[256];
int n;
main ()
{
n = read(0,buf,256);
write(1,buf,n);
printf("\n");
}

***************


        Use them, abuse them.  Of course you have to paw through
your terminal manuanls to discover what (if any) string they respond to,
and test for the response accordingly...

                                        ---MAC



::::::::::::::
shells/2
::::::::::::::
From: hplabs!azure!billp
To: tektronix!hplabs!resonex!nancy
Date: Thursday, 13 Sep 84 09:23:49 PDT
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

Here are some that I like and use a lot.  'del' and 'undelete' are just two
links to the same file.  This way if somebody copies one, they get the
other too
-------------------------------------------------------------------------------
::::::::::::::
: mv
::::::::::::::
: 'prompts if the destination file already exists'
/bin/mv -i $*
-------------------------------------------------------------------------------
::::::::::::::
: cp
::::::::::::::
: 'prompts if the destination file already exists'
/bin/cp -i $*
-------------------------------------------------------------------------------
::::::::::::::
: del, undelete
::::::::::::::
: '"del" throws files into the waste basket'
: 'files preceded by "," are automagically removed after 7 days'
: '"undelete" pulls files out of the waste basket'
: 'if invoked without an argument, both commands list the contents of the'
: 'waste basket.'

case $0 in
*del)
    if test -z "$1"
    then
        ls -lus $HOME/.waste_basket
    else
        for i
        do
            echo -n "deleting "
            tmp=`basename $i`
            /bin/mv -i $i $HOME/.waste_basket/,$tmp
            echo $i
        done
    fi;;

*undelete)
    if test -z "$1"
    then
        ls -lus $HOME/.waste_basket
    else
        for i
        do
            echo -n "recovering "
            tmp=`basename $i`
            /bin/mv -i $HOME/.waste_basket/,$tmp $i
            echo $i
        done
    fi;;
esac
-------------------------------------------------------------------------------
::::::::::::::
: vi
::::::::::::::
: 'backs up file(s) before editing them'
: 'files preceded by "," are automagically removed after 7 days'
for i
do
    if test -f $i
    then
        echo -n "backing up "
        tmp=`basename $i`
        /bin/cp -i $i $HOME/.vi_backup/,$tmp
        echo $i
    fi
done
/usr/ucb/vi $*
-------------------------------------------------------------------------------

        Bill Pfeifer
{ucbvax,decvax,ihnp4,allegra,uw-beaver,hplabs} !tektronix!tekmdp!billp

::::::::::::::
shells/3
::::::::::::::
Date: Thu, 13 Sep 84 13:58:09 pdt
From: turtlevax!ken (Ken Turkowski)
To: resonex!nancy
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

You asked for it, you've got it!  Here's ALL of my personal nifties:
                        Ken
**************************************************

echo x - bin
mkdir bin
echo x - bin/CC
cat >bin/CC <<'!Funky!Stuff!'
#
set outname=a.out
foreach file ($argv)
    if ("$file" =~ *.[cso]) then
        set outname=$file:r
        break
    endif
end
echo cc -o $outname $*
exec cc -o $outname $*
!Funky!Stuff!
echo x - bin/appt
cat >bin/appt <<'!Funky!Stuff!'
#
set notetype=$0
set notetype=$notetype:t
set notefile=~/.$notetype
# if ($notetype == appt) then
#     set notetype=appointment
#     set notefile=~/calendar
# endif

if ($#argv == 0) then
    test -t 0 && echo Please enter your $notetype entry '(^D to end):'
    echo ' ' >> $notefile
    exec cat >> $notefile
endif

switch ($1)
    case -:
        exec vi $notefile
    case -rm:
        cat /dev/null > $notefile
        exec echo The ${notetype}s are removed.
    case -what:
        exec cat $notefile
    default:
        echo '' >> $notefile
        echo "$*" >> $notefile
endsw
!Funky!Stuff!
echo x - bin/asfix
cat >bin/asfix <<'!Funky!Stuff!'
case $# in
    0)
        file=/tmp/afix$$
        trap "cat $file; rm $file; exit" 0
        trap "rm $file; exit" 3 9
        cat > $file ;;
    1)
        file=$1 ;;
    *)
        echo Usage `basename $0` ' [ <file> ]' ;;
esac
ed - $file << EOF
v/[:\.]/s/^/    /
g/:./s/:/:      /
wq
EOF
!Funky!Stuff!
echo x - bin/atcat
cat >bin/atcat <<'!Funky!Stuff!'
#
if ($#argv < 2) then
    set cmd=$0
    echo Usage: "$cmd:t <time> <word> [ <word> ... ]"
    exit
endif
set atcmd="echo $argv[2-] > `tty`"
at $1 << EOF
$atcmd
EOF
!Funky!Stuff!
echo x - bin/atecho
cat >bin/atecho <<'!Funky!Stuff!'
#
if ($#argv < 2) then
    set cmd=$0
    echo Usage: "$cmd:t <time> <word> [ <word> ... ]"
    exit
endif
set atcmd="echo $argv[2-] > `tty`"
at $1 << EOF
$atcmd
EOF
!Funky!Stuff!
echo x - bin/beautify
cat >bin/beautify <<'!Funky!Stuff!'
#
set TMP=/tmp/cb$$
foreach file (argv)
    echo Beautifying $file:
    cb < $file > $TMP
    cat $TMP > $file
end
rm $TMP
!Funky!Stuff!
echo x - bin/blankclean
cat >bin/blankclean <<'!Funky!Stuff!'
sed -e 's/^     $//' -e 's/ *$//' $*
!Funky!Stuff!
echo x - bin/bphone
cat >bin/bphone <<'!Funky!Stuff!'
phonefile=$HOME/.`basename $0`s

echo ' '

case $# in
    0)
        ed - $phonefile << EOF
g/./s/$/\\
/
g/      /s//\\
/g
g/;/s// /g
1,\$p
q
EOF
    exit ;;
esac

case $1 in
    -)
        chmod 644 $phonefile
        vi $phonefile
        chmod 444 $phonefile
        exit ;;
esac

trap "rm /tmp/data$$; exit" 0 2
for name
do
    grep -y "$name" $phonefile >> /tmp/data$$
done
ed - /tmp/data$$ << EOF
g/./s/$/\\
/
g/      /s//\\
/g
g/;/s// /g
1,\$p
q
EOF
!Funky!Stuff!
echo x - bin/catalog
cat >bin/catalog <<'!Funky!Stuff!'
# catalog - produce complete file structure list from directory
#
# Parameters:   1: directory name (optional)
#               2: indentation string (empty on first call)
#
# Produces on standard output the file structure emanating from
#   the current directory.  Each descent into a subdirectory
#    is indicated by further indentation.  Directories are indicated
#    by surrounding [], and executable files are prefaced with a *.
#
if ( $#argv == 0) then
   echo "file structure from directory `pwd`"
   date
   echo ''
else
   cd $1
endif
foreach i ( * )
   if ( -d $i ) then
         echo "${2}[ $i ]"
         $0 $i "$2  . "
   endif
         if ( "$i" != '*' ) then
            if ( -x $i ) then
               echo "${2} *$i "
            else
               echo "${2}  $i "
            endif
         endif
   endif
end
!Funky!Stuff!
echo x - bin/circum
cat >bin/circum <<'!Funky!Stuff!'
there=$1
shift
otherstuff="$*"
back=`whoami`
last=`hostname`
IFS='    !
'
for link in $there
do
    back="$last!$back"
    last=$link
done
IFS='
'
echo mail $there!$back
(date; echo "$otherstuff") | mail -s "Circumlocution to $last" $there!$back
!Funky!Stuff!
echo x - bin/comfmt
cat >bin/comfmt <<'!Funky!Stuff!'
exec fmt | \
sed -e '1s/^\([  ]*\)/\1\/\* /' -e '2,$s/^\([    ]*\)/\1 \* /' -e '${P
s/\*.*/*\//
}'
!Funky!Stuff!
echo x - bin/comstrip
cat >bin/comstrip <<'!Funky!Stuff!'
exec sed -e 's/\/\*//' -e 's/\*\///' -e 's/^[   ]*\** *//'
!Funky!Stuff!
echo x - bin/decvert
cat >bin/decvert <<'!Funky!Stuff!'
#
if ($#argv == 0) then
    set args=`cat`
    if ($#args != 0) $0 $args
    exit
endif

foreach hexnum ($argv)
dc << EOF
16i
${hexnum}p
EOF
end
!Funky!Stuff!
echo x - bin/f77
cat >bin/f77 <<'!Funky!Stuff!'
PATH=/usr/bin
SPECLIB=/usr/ken/cmd/lib/libc.a
exec f77 "$@" $SPECLIB
!Funky!Stuff!
echo x - bin/famove
cat >bin/famove <<'!Funky!Stuff!'
#
if ($#argv != 2) then
    echo Usage: $0 '<source family root> <destination family root>'
    exit
endif
foreach file ($1.*)
    set suffix=`expr $file : "$1\.\(.*\)"`
    echo mv $file $2.$suffix
    mv $file $2.$suffix
end
if (-e $1) then
    echo mv $1 $2
    mv $1 $2
endif
!Funky!Stuff!
echo x - bin/gredit
cat >bin/gredit <<'!Funky!Stuff!'
#
set CAESAR=/mnt/cad/bin/caesar
set SEARCHPATH=(-p ::/usr/ken/caesar/symlib)
set COLORMAP=(-c mumap.cmap)
set GRTERM=ttyh7
set caesarfile=()
foreach parm ($argv)
    if ($?flag) then
        switch ($flag)
            case g:
                set GRTERM=$parm
                breaksw
            case p:
                set SEARCHPATH=(-p "$parm")
                breaksw
            case R:
                set SEARCHPATH=($SEARCHPATH:$parm)
                breaksw
            case c:
                set COLORMAP=(-c $parm)
                breaksw
        endsw
        unset flag
        continue
    endif
    if ($parm =~ -*) then
        switch ($parm)
            case -g:
                set flag=g
                continue
            case -p:
                set flag=p
                continue
            case -P:
                set SEARCHPATH=()
                continue
            case -R:
                set flag=R
                continue
            case -C:
                set COLORMAP=()
                continue
            case -c:
                set flag=c
                continue
        endsw
    else
        set caesarfile=($caesarfile $parm)
    endif
end
onintr -
$CAESAR -g $GRTERM $SEARCHPATH $COLORMAP $caesarfile
!Funky!Stuff!
echo x - bin/grindall
cat >bin/grindall <<'!Funky!Stuff!'
#
set flags=
set fileargs=
onintr cleanup
foreach file ($argv)
    if ($file =~ -*) then
        if ($file == -t) then
            set stdout
        else
            set flags=($flags $file)
        endif
    else
        set fileargs=($fileargs $file)
    endif
end

if ($?stdout) then
    foreach file ($fileargs)
        vgrind -t $flags $file
    end
else
    foreach file ($fileargs)
        vgrind -t $flags $file >> /usr/tmp/grind$$
    end
    vpr -T $fileargs[1] -t /usr/tmp/grind$$
endif

cleanup:
rm /usr/tmp/grind$$
!Funky!Stuff!
echo x - bin/hardasm
cat >bin/hardasm <<'!Funky!Stuff!'
#
grasm -1 -l -x $* |& pr -f -h "grasm -l -x $*" | vpr -l
!Funky!Stuff!
echo x - bin/hexvert
cat >bin/hexvert <<'!Funky!Stuff!'
#
if ($#argv == 0) then
    set args=`cat`
    if ($#args != 0) $0 $args
    exit
endif

foreach decnum ($argv)
dc << EOF
16o
${decnum}p
EOF
end
!Funky!Stuff!
echo x - bin/job
cat >bin/job <<'!Funky!Stuff!'
PATH=/usr/ken/cmd/bin:/usr/ucb:/bin:/usr/bin
case $# in
    0)
        exec echo Usage: `basename $0` '-;' or $0 '<job description>' ;;
esac
case $1 in
    -)
        exec ex $HOME/.joblog ;;
    -h | -hr | -hrs)
        shift
        hrs=$1
        shift
        exec echo '   job:' $hrs hours # $* >> $HOME/.joblog ;;
    -tail)
        exec tail -22 $HOME/.joblog ;;
    -today)
        {
            while read line
            do
                case $line in
                    *login*)
                        login="$line" ;;
                esac
            done
            echo -n "$login" "for "
            diffdate "$login" "`date`"
        } < $HOME/.joblog ;;
    -login)
        echo ' login:' "`date`" >> $HOME/.joblog ;;
    -summary)
        cat $HOME/.joblog |
            while read line
            do
                case $line in
                    *login*)
                        login="$line" ;;
                    *logout*)
                        logout="$line"
                        echo -n "$login" "for "
                        diffdate "$login" "$logout"
                esac
            done ;;
    *)
        exec echo '   job:' "`date`" # $* >> $HOME/.joblog ;;
esac
!Funky!Stuff!
echo x - bin/ledger
cat >bin/ledger <<'!Funky!Stuff!'
#
set notetype=$0
set notetype=$notetype:t
set notefile=~/.$notetype
# if ($notetype == appt) then
#     set notetype=appointment
#     set notefile=~/calendar
# endif

if ($#argv == 0) then
    test -t 0 && echo Please enter your $notetype entry '(^D to end):'
    echo ' ' >> $notefile
    exec cat >> $notefile
endif

switch ($1)
    case -:
        exec vi $notefile
    case -rm:
        cat /dev/null > $notefile
        exec echo The ${notetype}s are removed.
    case -what:
        exec cat $notefile
    default:
        echo '' >> $notefile
        echo "$*" >> $notefile
endsw
!Funky!Stuff!
echo x - bin/lstree
cat >bin/lstree <<'!Funky!Stuff!'
#
if ($#argv == 0) then
    set root=.
else
    set root=($*)
endif
exec find $root -print | sort | sed -e 's/[^ \/]*\//    /g'
!Funky!Stuff!
echo x - bin/match
cat >bin/match <<'!Funky!Stuff!'
cat $2 |
while read x
do
    for word in $x
    do
        case $word in
            $1)
                echo $word ;;
        esac
    done
done
!Funky!Stuff!
echo x - bin/narrow
cat >bin/narrow <<'!Funky!Stuff!'
echo \!
!Funky!Stuff!
echo x - bin/outmesg
cat >bin/outmesg <<'!Funky!Stuff!'
#
set notetype=$0
set notetype=$notetype:t
set notefile=~/.$notetype
# if ($notetype == appt) then
#     set notetype=appointment
#     set notefile=~/calendar
# endif

if ($#argv == 0) then
    test -t 0 && echo Please enter your $notetype entry '(^D to end):'
    echo ' ' >> $notefile
    exec cat >> $notefile
endif

switch ($1)
    case -:
        exec vi $notefile
    case -rm:
        cat /dev/null > $notefile
        exec echo The ${notetype}s are removed.
    case -what:
        exec cat $notefile
    default:
        echo '' >> $notefile
        echo "$*" >> $notefile
endsw
!Funky!Stuff!
echo x - bin/path
cat >bin/path <<'!Funky!Stuff!'
IFS="${IFS}:"
for cmddir in $PATH
do
    test -s $cmddir/$1 && echo "        $cmddir/$1"
done
!Funky!Stuff!
echo x - bin/pphone
cat >bin/pphone <<'!Funky!Stuff!'
phonefile=$HOME/.`basename $0`s

echo ' '

case $# in
    0)
        ed - $phonefile << EOF
g/./s/$/\\
/
g/      /s//\\
/g
g/;/s// /g
1,\$p
q
EOF
    exit ;;
esac

case $1 in
    -)
        chmod 644 $phonefile
        vi $phonefile
        chmod 444 $phonefile
        exit ;;
esac

trap "rm /tmp/data$$; exit" 0 2
for name
do
    grep -y "$name" $phonefile >> /tmp/data$$
done
ed - /tmp/data$$ << EOF
g/./s/$/\\
/
g/      /s//\\
/g
g/;/s// /g
1,\$p
q
EOF
!Funky!Stuff!
echo x - bin/progression
cat >bin/progression <<'!Funky!Stuff!'
last=
for backup in $1_??
do
    case $last in
        "")
            last=$backup
            continue;
    esac
    echo ''
    echo From $last to $backup:
    diff $last $backup
    last=$backup
done
echo ''
echo From $last to $1:
diff $last $1
!Funky!Stuff!
echo x - bin/query
cat >bin/query <<'!Funky!Stuff!'
#
set notetype=$0
set notetype=$notetype:t
set notefile=~/.$notetype
# if ($notetype == appt) then
#     set notetype=appointment
#     set notefile=~/calendar
# endif

if ($#argv == 0) then
    test -t 0 && echo Please enter your $notetype entry '(^D to end):'
    echo ' ' >> $notefile
    exec cat >> $notefile
endif

switch ($1)
    case -:
        exec vi $notefile
    case -rm:
        cat /dev/null > $notefile
        exec echo The ${notetype}s are removed.
    case -what:
        exec cat $notefile
    default:
        echo '' >> $notefile
        echo "$*" >> $notefile
endsw
!Funky!Stuff!
echo x - bin/releave
cat >bin/releave <<'!Funky!Stuff!'
#
set tty=`tty`
set tty=`expr $tty : '.*tty\(.*\)'`
set leaveproc=`ps gt$tty | grep -w leave`
kill -9 $leaveproc[1]
date
leave $*
!Funky!Stuff!
echo x - bin/reminder
cat >bin/reminder <<'!Funky!Stuff!'
#
set notetype=$0
set notetype=$notetype:t
set notefile=~/.$notetype
# if ($notetype == appt) then
#     set notetype=appointment
#     set notefile=~/calendar
# endif

if ($#argv == 0) then
    test -t 0 && echo Please enter your $notetype entry '(^D to end):'
    echo ' ' >> $notefile
    exec cat >> $notefile
endif

switch ($1)
    case -:
        exec vi $notefile
    case -rm:
        cat /dev/null > $notefile
        exec echo The ${notetype}s are removed.
    case -what:
        exec cat $notefile
    default:
        echo '' >> $notefile
        echo "$*" >> $notefile
endsw
!Funky!Stuff!
echo x - bin/reremind
cat >bin/reremind <<'!Funky!Stuff!'
#
set tty=`tty`
set tty=`expr $tty : '.*tty\(.*\)'`
set leaveproc=`ps gt$tty | awk '$5 ~ /^remind$/ { print $1 }'`
if ($#leaveproc > 1) echo $#leaveproc reminds were running
kill -9 $leaveproc
date
if ($#argv <= 1) then
    remind $*
else
    set time=$1
    shift
    remind $time "$*"
endif
!Funky!Stuff!
echo x - bin/restore
cat >bin/restore <<'!Funky!Stuff!'
# Truncate filename if necessary
set file=$1
if (`expr $file:t : '.*'` >= 11) then
    set savename=`expr $file : '\(.*\)'$file:t`
    set savename=$savename`expr $file:t : '\(...........\)'`
else
    set savename=$file
endif

switch ($#argv)
    case 1:
        set nonomatch
        set backup=(${savename}_[0-9][0-9])
        if ("$backup" == "${savename}_[0-9][0-9]") then
            echo Error: No backups found for $file
            exit
        endif
        set backup=$backup[$#backup]
        echo No backup number specified. Using latest: $backup
        breaksw
    case 2:
        set backup=${savename}_$2
        breaksw
    default:
        exec echo Usage: `basename $0` '<file>' '[<backup number>]'
endsw

if ( { cp $backup $file } ) then
    echo $file restored from $backup.
    echo -n Do you wish to keep "$backup? "
    set response=$<
    if ($response !~ y*) then
        rm $backup
    endif
endif
!Funky!Stuff!
echo x - bin/rot13
cat >bin/rot13 <<'!Funky!Stuff!'
tr "A-Za-z" "N-ZA-Mn-za-m"
!Funky!Stuff!
echo x - bin/shufcol
cat >bin/shufcol <<'!Funky!Stuff!'
trap 'rm /tmp/$$.*; exit' 0 2
cat > /tmp/$$.0
i=1
for cols
do
    cut -f$cols < /tmp/$$.0 > /tmp/$$.$i
    filelist="$filelist /tmp/$$.$i"
    i=`expr $i + 1`
done
paste $filelist
!Funky!Stuff!
echo x - bin/signature
cat >bin/signature <<'!Funky!Stuff!'
PATH=/bin:/usr/bin
cat
echo --
cat $HOME/.signature
!Funky!Stuff!
echo x - bin/swab
cat >bin/swab <<'!Funky!Stuff!'
#
if ($#argv == 0) then
    dd conv=swab
else
    onintr cleanup
    foreach file ($argv)
        cp $file /tmp/swab$$
        dd if=/tmp/swab$$ of=$file conv=swab
    end
    cleanup:
    rm /tmp/swab$$
endif
!Funky!Stuff!
echo x - bin/what
cat >bin/what <<'!Funky!Stuff!'
cat $HOME/.query
echo -n 'save? (n or d to delete, e to edit) '
read response
case $response in
    n | no | d | delete)
        rm $HOME/.query && echo The query is removed. ;;
    "" | y | yes | s | save)
        exit ;;
    e | edit)
        exec vi $HOME/.query < /dev/tty
        exit ;;
    *)
        echo Bad response: "$response"
        exec $0 ;;
esac
!Funky!Stuff!
echo x - bin/whereis
cat >bin/whereis <<'!Funky!Stuff!'
N=$#
command=echo
case "$1" in
    -*)
        command=`expr "$1" : '-\(.*\)'`
        shift
        N=`expr $N - 1` ;;
esac
case $N in
    0)
        exec echo Usage: `basename $0` [ -command ] pattern file ...  ;;
    1)
        files=`fgrep -l "$1" *` ;;
    *)
        files=`fgrep -l "$@"` ;;
esac
case $files in
        "")
            echo $1 not found in any files.
            exit ;;
esac
exec $command $files
!Funky!Stuff!
echo x - bin/wide
cat >bin/wide <<'!Funky!Stuff!'
echo \"
!Funky!Stuff!
echo x - bin/xprint
cat >bin/xprint <<'!Funky!Stuff!'
case $# in
    1)
        eval $1 | eval pr -f -h \"$1\" | vpr -l ;;
    *)
        command='cat $file'
        for file
        do
            case $file in
                -*)
                    command=`expr "$file" : '-\(.*\)'`
                    case $command in
                        *\$file*)
                            ;;
                        *)
                            command="$command \$file" ;;
                    esac ;;
                *)
                    eval $command | eval pr -f -h \"$command\" | vpr -l ;;
            esac
        done
esac
!Funky!Stuff!
echo x - bin/archives
mkdir bin/archives
echo x - bin/archives/newsweed
cat >bin/archives/newsweed <<'!Funky!Stuff!'
#
cd
if ($#argv == 0) then
    if (-e .newsweed) then
        set WEEDGROUPS=`cat .newsweed`
    else
        set WEEDGROUPS=
    endif
else
    set WEEDGROUPS=$*
endif
if ($#WEEDGROUPS == 0) then
    onintr
    echo Searching for articles in all newsgroups
    readnews -l | \
    grep Subject | \
    sed -e 's/Subject: *//' -e 's/^[rR][eE]:*  *//' | \
    sort -u > /tmp/weed$$a
    if (-z /tmp/weed$$a) then
        echo No news.
    else
        cp /tmp/weed$$a /tmp/weed$$b
        echo Please remove article titles which you do not wish to read
        sleep 1
        onintr -
        vi /tmp/weed$$b
        onintr cleanup
        comm -23 /tmp/weed$$a /tmp/weed$$b > /tmp/weed$$c
        echo Removing unwanted articles
        newsec -f /tmp/weed$$c
    endif
else
    foreach group ($WEEDGROUPS)
        echo Searching for articles in group\(s\):
        echo $group
        readnews -l -n $group | \
        grep Subject | \
        sed -e 's/Subject: *//' -e 's/^[rR]e:*  *//' | \
        sort -u > /tmp/weed$$a
        if (-z /tmp/weed$$a) then
            echo in newsgroups $group.
        else
            cp /tmp/weed$$a /tmp/weed$$b
            echo Please remove article titles which you do not wish to read
            sleep 1
            onintr -
            vi /tmp/weed$$b
            onintr cleanup
            comm -23 /tmp/weed$$a /tmp/weed$$b > /tmp/weed$$c
            echo Removing unwanted articles
            newsec -f /tmp/weed$$c
        endif
    end
endif

cleanup:
rm /tmp/weed$$?
!Funky!Stuff!
echo x - bin/archives/pk_01
cat >bin/archives/pk_01 <<'!Funky!Stuff!'
: Roff, nroff, or eqn input text
for file in `file $* | sed -n '/eqn input text$/s/:[^:]*$//p'`
do
    echo "echo x - $file"
    echo "sed 's/^x//' >$file <<'!Funky!Stuff!'"
    sed 's/^/x/' $file; echo "!Funky!Stuff!"
done
: Text files
for file in `file $* | sed -n -e '/commands text$/s/:[^:]*$//p' -e '/ascii text$/s/:[^:]*$//p'`
do
    echo "echo x - $file"
    echo "cat >$file <<'!Funky!Stuff!'"
    cat $file; echo "!Funky!Stuff!"
done
: Directories, recursively
for dir in `file $* | sed -n '/directory$/s/:.*//p'`
do
    echo "echo x - $dir"
    echo "mkdir $dir"
    file=`echo $dir/*`
    test "$file" != "$dir/*" && $0 $file
done
!Funky!Stuff!
echo x - bin/archives/pkf
cat >bin/archives/pkf <<'!Funky!Stuff!'

for dir
do
        echo "echo x - $dir"
        echo "mkdir $dir";
        for file in `file $dir/* | sed -n '/text$/s/:[^:]*$//p'`
        do
                echo "echo x - $file"
                echo "cat >$file <<'!Funky!Stuff!'"
                cat $file; echo "!Funky!Stuff!"
        done
        $0 `file $dir/* | sed -n '/directory$/s/:.*//p'`
done
!Funky!Stuff!
echo x - bin/archives/pkg
cat >bin/archives/pkg <<'!Funky!Stuff!'
for file
do
    echo "echo x - $file"
    echo "cat >$file <<'!Funky!Stuff!'"
    cat $file; echo "!Funky!Stuff!"
done
!Funky!Stuff!
echo x - bin/archives/pkn
cat >bin/archives/pkn <<'!Funky!Stuff!'

for dir
do
        echo "echo x - $dir"
        echo "mkdir $dir";
        for file in `file $dir/* | sed -n '/text$/s/:[^:]*$//p'`
        do
                echo "echo x - $file"
                echo "sed 's/^x//' >$file <<'!Funky!Stuff!'"
                sed 's/^/x/' $file; echo "!Funky!Stuff!"
        done
        $0 `file $dir/* | sed -n '/directory$/s/:.*//p'`
done
!Funky!Stuff!
echo x - bin/archives/prod
cat >bin/archives/prod <<'!Funky!Stuff!'
#
set flags=()
set syslist=()
foreach arg ($argv)
    switch ($arg)
        case -s*:
            if (`expr $arg : '.*'` > 9) then
                rm -f /usr/spool/uucp/STST.`expr $arg : '-s\(.......\)'`
            else
                rm -f /usr/spool/uucp/STST.`expr $arg : '-s\(.*\)'`
            endif
            set syslist=($syslist $arg)
            breaksw
        case -*:
            set flags=($flags $arg)
            breaksw
        default:
            if (`expr $arg : '.*'` > 7) then
                rm -f /usr/spool/uucp/STST.`expr $arg : '\(.......\)'`
            else
                rm -f /usr/spool/uucp/STST.$arg
            endif
            set syslist=($syslist -s$arg)
            breaksw
    endsw
end
foreach sys ($syslist)
    /usr/lib/uucp/uucico -r1 $flags $sys
end
!Funky!Stuff!
echo x - bin/bourne_scripts
mkdir bin/bourne_scripts
echo x - bin/bourne_scripts/lookdoc
sed 's/^x//' >bin/bourne_scripts/lookdoc <<'!Funky!Stuff!'
xtrap exit 2
xcase $# in
x    0)
x       ul | more
x       exit ;;
xesac
xfor names
xdo
x    case $names in
x       -n)
x           default=n ;;
x       -t)
x           default=t ;;
x       -m*)
x           macros="$macros $names" ;;
x       *.n | *.nr)
x           nroff $macros $names | ul | more ;;
x       *.t | *.tbl)
x           soelim $names | tbl | nroff $macros - | ul | more ;;
x       *)
x           case $default in
x               n)
x                   nroff $macros $names | ul | more ;;
x               t)
x                   soelim $names | tbl | nroff $macros - | ul | more ;;
x               "")
x                   ul $names | more ;;
x           esac
x    esac
xdone
!Funky!Stuff!
echo x - bin/bourne_scripts/CC
cat >bin/bourne_scripts/CC <<'!Funky!Stuff!'
outname=a.out
for argv
do
    case $argv in
        *.[cos])
            outname=`expr $argv : '\(.*\)\.'`
            break ;;
    esac
done
cc -o $outname $*
!Funky!Stuff!
echo x - bin/bourne_scripts/appt
cat >bin/bourne_scripts/appt <<'!Funky!Stuff!'
case $0 in
    appt)
        notetype=appointment
        notefile=$HOME/calendar ;;
    *)
        notetype=$0
        notefile=$HOME/.$0 ;;
esac

case $# in
    0)
        test -t 0 && echo Please enter your $notetype '(^D to end):'
        echo '' >> $notefile
        exec cat >> $notefile ;;
esac
case $1 in
    -)
        exec vi $notefile ;;
    -rm)
        cat /dev/null > $notefile
        exec echo The ${notetype}s are removed. ;;
    -what)
        exec cat $notefile ;;
    *)
        echo '' >> $notefile
        exec echo "$*" >> $notefile ;;
esac
!Funky!Stuff!
echo x - bin/bourne_scripts/beautify
cat >bin/bourne_scripts/beautify <<'!Funky!Stuff!'
for files
do
    echo $files:
    cb < $files > /tmp/cb$$
    cat /tmp/cb$$ > $files
done
rm /tmp/cb$$
!Funky!Stuff!
echo x - bin/bourne_scripts/format
cat >bin/bourne_scripts/format <<'!Funky!Stuff!'
case $# in
    0)
        echo "Usage: `basename $0` [-flags] <filename> [ <filename> ... ]"
        exit 1 ;;
esac
for names
do
    case $names in
        -*)
                flags="$flags $names" ;;
        *.t)
                outfile=`expr $names : '\(.*\)\.'`.d
                soelim $names | tbl | nroff $flags - > $outfile ;;
        *.tbl)
                outfile=`expr $names : '\(.*\)\.'`.doc
                soelim $names | tbl | nroff $flags - > $outfile ;;
        *.n)
                outfile=`expr $names : '\(.*\)\.'`.d
                nroff $flags $names > $outfile ;;
        *.nr)
                outfile=`expr $names : '\(.*\)\.'`.doc
                nroff $flags $names > $outfile ;;
        *)
                echo Don\'t know what to do with $names ;;
    esac
done
!Funky!Stuff!
echo x - bin/bourne_scripts/print
cat >bin/bourne_scripts/print <<'!Funky!Stuff!'
PATH=/avsd/ava/turk/bin:/usr/local/bin:/usr/bin
indent=0
for names
do
    case $names in
        -i)
            indent=1 ;;
        *)
            args="$args $names" ;;
    esac
done
case $indent in
    0)
        pr $args | lpr ;;
    *)
        pr $args | indent | lpr ;;
esac
!Funky!Stuff!
echo x - bin/bourne_scripts/repeat
cat >bin/bourne_scripts/repeat <<'!Funky!Stuff!'
case $1 in
    -[0-9]*)
        number=`expr $1 : '-\(.*\)'`
        shift
        while test $number -gt 0
        do
            eval $*
            number=`expr $number - 1`
        done
        exit ;;
    *)
        echo Executing forever: $* 1>&2
        number=0
        trap 'echo Executed $number times.; exit' 2
        while true
        do
            eval $*
            number=`expr $number + 1`
        done ;;
esac
!Funky!Stuff!
echo x - bin/bourne_scripts/restore
cat >bin/bourne_scripts/restore <<'!Funky!Stuff!'
case $# in
    2) ;;
    *)
        exec echo Usage: `basename $0` '<file>' '<version>' ;;
esac
: Truncate filename if necessary
if test `expr $1 : '.*'` -gt 11
then
    savename=`expr $1 : '\(...........\)'`
else
    savename=$1
fi
savename=${savename}_$2
cp $savename $1 && rm $savename && echo $1 restored from $savename
!Funky!Stuff!
echo x - bin/bourne_scripts/save
cat >bin/bourne_scripts/save <<'!Funky!Stuff!'
for file
do
    if test `expr $file : '.*'` -gt 11
    then
        savename=`expr $file : '\(...........\)'`
    else
        savename=$file
    fi
    for copy in ${savename}_??
    do
        latest=$copy
    done
    if test $latest = "${savename}_??"
    then
        latest=${savename}_01
    else
        latest=`expr $latest : '.*_\([0123456789]*\)$' + 1`
        case $latest in
            ?)
                latest=0$latest
                ;;
        esac
        latest=${savename}_$latest
    fi
    cp $file $latest && echo $file saved as $latest
done
!Funky!Stuff!
echo x - bin/csh_scripts
mkdir bin/csh_scripts
echo x - bin/csh_scripts/newsweed
cat >bin/csh_scripts/newsweed <<'!Funky!Stuff!'
#
set TEMP=/tmp/weed$$
set NEWSRC=~/.newsrc
set AWKFILE=/usr/ken/cmd/lib/newsweed.awk
onintr
echo Searching for articles in all newsgroups
readnews -l $* | sort -o ${TEMP}a
if (-z ${TEMP}a) then
    echo No news.
else
    cp ${TEMP}a ${TEMP}b
    echo Please remove article titles which you do not wish to read
    sleep 1
    onintr -
    vi ${TEMP}b
    onintr cleanup
    if ( { cmp -s ${TEMP}a ${TEMP}b } ) then
        echo No articles deleted.
    else
        comm -23 ${TEMP}a ${TEMP}b | sed 's/ .*//' > ${TEMP}c
        echo Removing unwanted articles
        cp $NEWSRC $NEWSRC.old
        awk -f $AWKFILE $NEWSRC.old ${TEMP}c > ${TEMP}d
        cp ${TEMP}d $NEWSRC
    endif
endif
cleanup:
rm ${TEMP}?
!Funky!Stuff!
echo x - bin/csh_scripts/pathname
cat >bin/csh_scripts/pathname <<'!Funky!Stuff!'
#
foreach cmddir ($path)
    if ( -e $cmddir/$1 ) echo " $cmddir/$1"
end
!Funky!Stuff!
echo x - bin/local
mkdir bin/local
echo x - bin/local/format
cat >bin/local/format <<'!Funky!Stuff!'
#
if ($#argv == 0) then
    set progname=$0
    set progname=$progname:t
    echo 'Usage:' $progname '[-v] [-n] [-print] [-troffflags] <filename> [ <filename> ... ]'
    exit (1)
endif
set flags
set formatter="vtroff -t"
set eqnsetter=eqn
set docsuf=v
set longdocsuf=vpr
set more=0
foreach name ($argv)
    if ($more > 0) then
        set flags="$flags $name"
        @ more--
        continue
    endif
    switch ($name)
        case -*:
            switch ($name)
                case -print:
                    set print
                    continue
                case -v:
                    set formatter="vtroff -t"
                    set eqnsetter=eqn
                    set docsuf=v
                    set longdocsuf=vpr
                    continue
                case -n:
                    set formatter=nroff
                    set eqnsetter=neqn
                    set docsuf=d
                    set longdocsuf=doc
                    continue
                case -[F123]:
                    set more=1
                default:
                    set flags="$flags $name"
            endsw
            continue
        case *.et:
            set outfile=$name:r.$docsuf
            eval soelim $name | tbl | $eqnsetter | $formatter $flags > $outfile
            breaksw
        case *.t:
            set outfile=$name:r.$docsuf
            eval soelim $name | tbl | $formatter $flags > $outfile
            breaksw
        case *.tbl:
            set outfile=$name:r.$longdocsuf
            eval soelim $name | tbl | $formatter $flags > $outfile
            breaksw
        case *.e:
            set outfile=$name:r.$docsuf
            eval $eqnsetter $name | $formatter $flags > $outfile
            breaksw
        case *.eqn:
            set outfile=$name:r.$longdocsuf
            eval $eqnsetter $name | $formatter $flags > $outfile
            breaksw
        case *.n:
            set outfile=$name:r.$docsuf
            eval $formatter $flags $name > $outfile
            breaksw
        case *.nr:
            set outfile=$name:r.$longdocsuf
            eval $formatter $flags $name > $outfile
            breaksw
        default:
            echo Don\'t know what to do with $name
            continue
    endsw
    if ($?print) then
        if ("$formatter" == nroff) then
            vpr $outfile
        else
            vpr -t $outfile
        endif
    endif
end
!Funky!Stuff!
echo x - bin/local/lntree
cat >bin/local/lntree <<'!Funky!Stuff!'
PATH=/usr/local/bin:/usr/ucb:/bin:/usr/bin
if test $1 = -v
then
    verbose=1
    shift
else
    verbose=0
fi
case $2 in
    /*)
        target=$2 ;;
    *)
        target=`pwd`/$2 ;;
esac
if test -f $2
then
    echo Error: $2 is not a directory
    exit 1
fi
cd $1
source=`pwd`
if test `expr $target : $source/` != 0
then
    echo Error: $2 may be a subdirectory of $1
    echo Try using the full path name of $2 \(no ..\'s\)
    exit 1
fi
if test $verbose = 1
then
    set -x
fi
files=`type -f`
case $files in
    "") ;;
    *)
        ln $files $target ;;
esac
for directory in `find '' -type d -a -print`
do
    mkdir $target$directory
    cd $source$directory
    files=`type -f`
    case $files in
        "") ;;
        *)
            ln $files $target$directory ;;
    esac
done
!Funky!Stuff!
echo x - bin/local/lookdoc
cat >bin/local/lookdoc <<'!Funky!Stuff!'
#
if ($#argv == 0) then
        more
        exit
endif
set macros pipespec args
foreach name ($argv)
    switch ($name)
        case -n:
            set pipespec=n
            breaksw
        case -t:
            set pipespec=t
            breaksw
        case -m*:
            set macros="$macros $name"
            breaksw
        case *.n:
        case *.nr:
            if ($pipespec != t) set pipespec=n
            set args="$args $name"
            breaksw
        case *.t:
        case *.tbl:
            set pipespec=t
            set args="$args $name"
            breaksw
        default:
            set args="$args $name"
    endsw
end

switch ($pipespec)
    case n:
        nroff $macros $args | more
        breaksw
    case t:
        soelim $args | tbl | nroff $macros - | col | more
        breaksw
    default:
        more $name
        breaksw
endsw
!Funky!Stuff!
echo x - bin/local/newsweed
cat >bin/local/newsweed <<'!Funky!Stuff!'
TEMP=/tmp/weed$$
NEWSRC=$HOME/.newsrc
AWKFILE=/usr/local/lib/newsweed.awk
trap 'rm ${TEMP}?; exit' 0 2
echo Making list of article titles
readnews -l $* | sort -o ${TEMP}a
if test -s ${TEMP}a
then
    cp ${TEMP}a ${TEMP}b
    echo Please remove article titles which you do not wish to read
    sleep 1
    reset       # So that vi's CRLF doesn't get trashed by another vi
    ${EDITOR-vi} ${TEMP}b
    if cmp -s ${TEMP}a ${TEMP}b
    then
        echo No articles deleted.
    else
        comm -23 ${TEMP}a ${TEMP}b | sed 's/ .*//' > ${TEMP}c
        echo Removing unwanted articles
        cp $NEWSRC $NEWSRC.old
        awk -f $AWKFILE $NEWSRC.old ${TEMP}c > ${TEMP}d
        cp ${TEMP}d $NEWSRC
    fi
else
    echo No news.
fi
!Funky!Stuff!
echo x - bin/local/nmail
cat >bin/local/nmail <<'!Funky!Stuff!'
#/bin/csh
set found = 0
set arg = 1
while($arg <= $#argv)
        if(`echo $argv[$arg] | grep \!` != "") then
                set tuple = `echo $argv[$arg] | sed s/\\!/\ /`
                set upath = `uupath $tuple[1]`
                set found = $status
                set argv[$arg] = "$upath\!$tuple[2]"
        else
                set found = 0
        endif
        if($found != 0) then
                set argv[$arg]
        endif
        @ arg = $arg + 1
end
echo "mail $argv"
mail $argv

!Funky!Stuff!
echo x - bin/local/peopledata
cat >bin/local/peopledata <<'!Funky!Stuff!'
peoplefile=$HOME/.peopledata

echo ' '

case $# in
    0)
        ed - $peoplefile << EOF
g/./s/$/\\
/
g/      /s//\\
/g
1,\$p
q
EOF
    exit ;;
esac

case $1 in
    -)
        chmod 600 $peoplefile
        vi $peoplefile
        chmod 400 $peoplefile
        exit ;;
esac
trap "rm /tmp/data$$; exit" 0 2
for name
do
    grep -y "$name" $peoplefile >> /tmp/data$$
done
ed - /tmp/data$$ << EOF
g/./s/$/\\
/
g/      /s//\\
/g
1,\$p
q
EOF
!Funky!Stuff!
echo x - bin/local/phone
cat >bin/local/phone <<'!Funky!Stuff!'
peoplefile=$HOME/.peopledata

case $# in
    0)
        ed - $peoplefile << EOF
        v/-/d
        g/./s/\([^      ]*\)[^-]*       \(.*-.*\)/\1    \2/
        1,\$p
EOF
        exit ;;
esac

case $1 in
    -)
        chmod 600 $peoplefile
        vi $peoplefile
        chmod 400 $peoplefile
        exit ;;
esac

trap "rm /tmp/data$$; exit" 0 2
for name
do
    grep -y "$name" $peoplefile >> /tmp/data$$
done
ed - /tmp/data$$ << EOF
g/./s/\([^      ]*\)[^-]*       \(.*-.*\)/\1    \2/
1,\$p
q
EOF
!Funky!Stuff!
echo x - bin/local/pk
cat >bin/local/pk <<'!Funky!Stuff!'
for dir
do echo "mkdir $dir";
        for file in `file $dir/* | sed -n '/text$/s/:[^:]*$//p'`
        do      echo "echo x - $file"
                echo "cat >$file <<'#EOF#'"
                cat $file; echo "#EOF#"
        done
        pk `file $dir/* | sed -n '/directory$/s/:.*//p'`
done
!Funky!Stuff!
echo x - bin/local/save
cat >bin/local/save <<'!Funky!Stuff!'
#
if ("$1" =~ -*) then
    set suffix=`expr $1 : '-\(.*\)'`
    shift
    foreach file ($argv)
        if (`expr $file:t : '.*'` >= 11) then
            set savename=`expr $file : '\(.*\)'$file:t`
            set savename=$savename`expr $file:t : '\(...........\)'`
        else
            set savename=$file
        endif
        cp $file ${savename}_$suffix && \
                echo $file saved as ${savename}_$suffix
    end
    exit
endif
foreach file ($argv)
    if (`expr $file:t : '.*'` >= 11) then
        set savename=`expr $file : '\(.*\)'$file:t`
        set savename=$savename`expr $file:t : '\(...........\)'`
    else
        set savename=$file
    endif

    set nonomatch
    set latest=(${savename}_[0-9][0-9])
    if ("$latest" == "${savename}_[0-9][0-9]") then
        set latest=${savename}_01
    else
        set latest=$latest[$#latest]
        set latest=`expr $latest : '.*_\([0123456789]*\)$' + 1`
        if ($latest < 10) set latest=0$latest
        set latest=${savename}_$latest
    endif
    cp $file $latest && echo $file saved as $latest
end
!Funky!Stuff!
echo x - bin/local/shar
cat >bin/local/shar <<'!Funky!Stuff!'
: Roff, nroff, or eqn input text
for file in `file $* | sed -n '/eqn input text$/s/:[^:]*$//p'`
do
    echo "echo x - $file"
    echo "sed 's/^x//' >$file <<'!Funky!Stuff!'"
    sed 's/^/x/' $file; echo "!Funky!Stuff!"
done
: Text files
for file in `file $* | sed -n -e '/eqn input text$/d' -e '/text$/s/:[^:]*$//p'`
do
    echo "echo x - $file"
    echo "cat >$file <<'!Funky!Stuff!'"
    cat $file; echo "!Funky!Stuff!"
done
: Directories, recursively
for dir in `file $* | sed -n '/directory$/s/:.*//p'`
do
    echo "echo x - $dir"
    echo "mkdir $dir"
    file=`echo $dir/*`
    test "$file" != "$dir/*" && $0 $file
done
!Funky!Stuff!
echo x - bin/local/uuhosts
cat >bin/local/uuhosts <<'!Funky!Stuff!'
#!/bin/sh
# '@(#) uuhosts.sh 1.22 84/08/07'

# PATH will have to be adjusted for non-BSD systems.
PATH=/usr/local/bin:/usr/ucb:/bin:/usr/bin
LIB=/usr/lib

# Routing information produced by pathalias.
paths=$LIB/nmail.paths

# The directory $NEWSMAP should contain the USENET news map information
# from newsgroup net.news.map that is posted about once a month from
# cbosgd!map, extracted by a line like this in $LIB/news/sys:
#
#       newsmap:net.news.map:B:/usr/local/uuhosts -x
#
# Locally-known information should go in $LIB/news/net.news.map/Local.
# The directory $MAILMAP is extracted by the same command from the
# UUCP mail information posted to the same newsgroup.
NEWSMAP=$LIB/news/net.news.map
MAILMAP=$LIB/news/net.mail.map
cd $NEWSMAP

case $1 in
        -x)
                # extract a new map piece into the map directory
                temphead=/tmp/maphead.$$
                temptext=/tmp/maptext.$$
                awk '
BEGIN   {
        temphead = "'$temphead'";
        isnewsmap = 0; ismailmap = 0;
        shead = 0; stext = 1; snews = 2; smail = 3; scat = 4; scatting = 5;
        state = shead;
        print "Reply-To: news" >> temphead;
}
state == shead && /^From: /     {
        print "Original-" $0 >> temphead;
}
state == shead && /^Subject: /  {
        if ($2 != "Re:")
        for (x = 2; x <= NF; x++) {
                if ($x == "UUCPmap" || $x == "uucpmap" || $x == "UUCPMAP") {
                        ismailmap = 1;
                        break;
                }
                if ($x == "map" || $x == "Map" || $x == "MAP") {
                        if (x <= 2)
                                continue;
                        x--;
                        if ($x == "USENET") {
                                isnewsmap = 1;
                                break;
                        }
                        if ($x == "UUCP") {
                                ismailmap = 1;
                                break;
                        }
                        x++;
                }
        }
        if (!isnewsmap && !ismailmap) {
                print "Subject:  not a map update" >> temphead;
                print "Original-" $0 >> temphead;
        } else
                print $0 >> temphead;
}
state == shead && /^$/  {
        if (isnewsmap != 0)
                state = snews;
        else if (ismailmap != 0) {
                state = scat;
        } else
                state = stext;
        next;
}
state == scat   {
        if ($1 != "cat")
                state = scatting;
        else
                state = smail;
}
state == scatting {
        if ($1 == ":")
                state = smail;
        else
                print;
}
state == smail  {
        print | "uuhosts -u";
}
state == snews  {
        print | "/bin/sh";
}
state == stext  {
        print;
}
' > $temptext 2>&1
                cat $temphead $temptext | /bin/mail news
                rm -f $temphead $temptext
                exit 0
        ;;

        -u)
                # extract a UUCP map piece
                cd $MAILMAP
                /bin/sh
                for f in *map*.a *map*.ar
                do
                        ar xv $f
                        rm $f
                done
        ;;

        -g)
                # by geographical region
                shift
                if test $# -eq 0
                then
                        exec ls
                        exit 1
                fi
                exec cat $*
                exit 1
        ;;

        -k)
                # by keyword
                shift
                exec awk '
BEGIN           { inside = 1; outside = 0; state = outside; }
/^Name:/        { state = inside; count = 0; useit = 0; }
state == inside { block[count++] = $0; }
/'"$*"'/        { useit = 1; }
/^$/ && state == inside {
        if (useit == 1) {
                for (i = 0; i < count; i++) {
                        print block[i];
                }
        }
        state = outside;
}
' *
                exit 1
        ;;

        -*)
                # unknown option
        ;;

        "")
                # no arguments
        ;;

        *)
                # by site name
                for arg in $*
                do
                        echo 'UUCP mail path:'
                        grep '^'${arg} $paths
                        echo '
UUCP mail host information:'
                        cat $MAILMAP/${arg}* | tr % '\012'
                        echo '
USENET news host information:'
                        sed -n -e "/^Name:[     ]*${arg}/,/^$/p" *
                done
                exit 0
        ;;
esac

echo 'Usage:    'uuhosts' hostname ...
for information about a particular UUCP or USENET host or hosts, or

        'uuhosts' -g geographical-region
for information about USENET news sites in a geographical region, or

        'uuhosts' -g
for a list of known USENET geographical-regions.
'
exit 1
!Funky!Stuff!

::::::::::::::
shells/4
::::::::::::::
Date: Fri, 14 Sep 84 15:06:07 pdt
From: hplabs!sdcrdcf!sdcsvax!celerity!barto (David Barto)
To: sdcsvax!sdcrdcf!hplabs!resonex!nancy
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

Hi Nancy,
        I too am a 'new' system admin, and belive me, it won't take
        you too long to get quite a bag of tricks put together.

        Most of mine relate to source programs put together in
        shell scripts to keep track of things.

        I have 1 for news (at the end of the article) which keeps
        the active list up to date.

        Another nice program is one I call '#'.  It is owned by root
        and setuid/setgid to root/daemon.  I use it to 'become' root
        while doing 1 command
                        # mv file1 file2
        which requires root permission.  It checks to see the normal
        userid is 'me' and then allows the command.  I will send it
        along if you want it.

        I have shell scripts for doing things such as 'rootedit'
        a file.  This is an alias for "alias re  '# vi -v \!*'"

        I too would love to see the things you get back from the
        net.  As well I have a sendmail config setup for making
        your configuration a breeze.  If you want it I can send
        it under seperate cover.


        barto (david barto)     Tele : (619) 271 9940
        uucp : {decvax || ucbvax || ihnp4}!sdcsvax!celerity!barto
        uucp : akgua!celerity!barto
        arpa : sdcsvax!celerity!barto@NOSC


: This is a shar archive.  Extract with sh, not csh.
echo x - Mkactive
cat > Mkactive << '!Funky!Stuff!'
#!/bin/sh
# see Update.active for this usage
#
sed -e '1,/---/d'\
        -e '1,/---/d'\
        -e 's/^[        ]//'\
        -e 's/  \(.*\)//'\
        active.current | sort | sed -e '1,/Newsgroup/d' > current
sed -e 's/ \(.*\)//' /usr/new/lib/news/active | sort > active
diff active current > /tmp/active.diff
echo "# active newsgroups not in local active file:"
fgrep ">" /tmp/active.diff
echo "# defunct newsgroups still in active file (also local groups):"
fgrep "<" /tmp/active.diff
/bin/rm current active /tmp/active.diff
!Funky!Stuff!
echo x - Mkdead
cat > Mkdead << '!Funky!Stuff!'
#!/bin/sh
# see Update.active for usage
# change all groups that we have (but shouldn't) to be removed,
# and change all groups that we dont have (but sould) to be a comment
sed     -e '/general/d'\
        -e '/control/d' \
        -e '/junk/d' \
        -e 's/</rmgroup/' \
        -e 's/>/#/'
!Funky!Stuff!
echo x - rmgroup
cat > rmgroup << '!Funky!Stuff!'
#! /bin/sh
# from : sdcsvax!sdcrdcf!hplabs!hao!seismo!rlgvax!cvl!umcp-cs!eneevax!chris
#
# @(#)rmgroup.sh        (U of Maryland) FLB 28-Jun-1983
#                       Bug fixes 5 June 1984 Chris Torek
#
# Delete a newsgroup

lib=/usr/new/lib/news
spool=/usr/spool/news

group=$*

for group
do
        qgrp="`echo $group | sed 's/\./\\\./g'`"
        if
                grep -s "^$qgrp [0-9][0-9][0-9][0-9][0-9]$" $lib/active
        then
                ed - $lib/active << xxxFOOxxx
/^$qgrp [0-9][0-9][0-9][0-9][0-9]$/d
w
q
xxxFOOxxx
        else
                echo "$0: $group: no such active line" 2>&1
        fi

        dir=$spool/"`echo $group | sed 's/\./\//g'`"
        if
                [ -d "$dir" ]
        then
                /bin/rm -fr "$dir"
        else
                echo "$0: $dir: no spool directory" 2>&1
        fi
done
exit 0
!Funky!Stuff!

::::::::::::::
shells/5
::::::::::::::
Date: Thu, 20 Sep 84 01:20:29 pdt
From: turtlevax!ken (Ken Turkowski)
To: resonex!nancy
Subject: Handy new uucp utility: uuque

cat << EOF
I just completed a new useful uucp utility which lets you know what kind
of uucp work is in progress.  While uusnap just tells you the number of
files to be processed, uuque tells you exactly what kind of work is to
be performed.  I've only tried it on three kinds of work, namely mail,
news, and standard uucp transfers.  Give it a try, and see if it breaks
on any new types of uucp work.
                                Ken
P.S. This really should be a C program.
EOF
echo x - uuque
cat >uuque <<'!Funky!Stuff!'
#! /bin/sh
# uusnap
cd /usr/spool/uucp
LUUNAME=`uuname -l`

# Check for outgoing work
for cmdfile in C./*
do
    test -f $cmdfile || continue
    othersys=`expr $cmdfile : 'C./C.\(.*\).....'`
    cmd=
    dfile=
    xfile=
    ufile=
    cat $cmdfile | {
        while read cmd arg1 arg2 arg3 extra
        do
            case $cmd in
                S) ;;
                *)  echo Bad cmd in $cmdfile: $cmd $arg1 $arg2 $arg3 $extra
                    exit ;;
            esac
            case $arg1 in
                D.${LUUNAME}X????)      # Remote execute file
                    xfile=$arg1
                    ;;
                D.${LUUNAME}?????)      # Data file ref'd by the execute file
                    dfile=$arg1
                    ;;
                *)                      # Just a uucp
                    dfile=$arg1
                    ufile=$arg2
                    from=$arg3
                    ;;
            esac
        done
        case $xfile in
            "")                 # uucp transfer
                echo `wc -c < $dfile`\   uucp $dfile $othersys!$ufile \($from\)
                ;;
            *)                  # complex transfer
                cat D.${LUUNAME}X/$xfile | {
                    while read xcmd arg1 arg2 extra
                    do
                        case $xcmd in
                            U)
                                from=$arg2!$arg1
                                ;;
                            F)
                                ;;
                            I)
                                ;;
                            C)
                                echo `wc -c < D.${LUUNAME}/$dfile`\      $arg1 $othersys!$arg2 \($from\)
                                ;;
                            *)
                                echo Unknown xcmd in $xfile: $xcmd $arg1 $arg2
                                exit
                                ;;
                        esac
                    done
                }
                ;;
        esac
    }
done

# Check for incoming work
for cmdfile in X./*
do
    test -f $cmdfile || continue
    othersys=`expr $cmdfile : 'X./X.\(.*\).....'`
    cat $cmdfile | {
        while read cmd arg1 arg2 extra
        do
            case $cmd in
                U)
                    from=$arg2!$arg1
                    ;;
                Z)
                    ;;
                F)
                    if test -f D./$arg1
                    then
                        dfile=D./$arg1
                    elif test -f D./$arg2
                    then
                        dfile=D./$arg2
                    else
                        continue 2
                    fi
                    ;;
                C)
                    xcmd=$arg1
                    ;;
                *)  echo Bad cmd in $cmdfile: $cmd $arg1 $arg2 $extra
                    exit ;;
            esac
        done
        echo `wc -c < $dfile`\   $xcmd $dfile \($from\)
    }
done
!Funky!Stuff!

::::::::::::::
shells/6
::::::::::::::
Date: Sat, 22 Sep 84 01:22:39 pdt
From: turtlevax!ken (Ken Turkowski)
To: resonex!nancy
Subject: Re:  uuque

I've updated uuque to the point where it should probably instead be called
uusnoop.  Of course, it's not that interesting unless there are others on
your system that use uucp and net mail.

                        Ken

echo x - uuque
cat >uuque <<'!Funky!Stuff!'
#! /bin/sh
# The user must have access to the /usr/spool/uucp/* directories and files.
# This can be easily done by making certain users members of the daemon
# and/or uucp groups, or by becoming super-user.
# uusnap
cd /usr/spool/uucp
LUUNAME=`uuname -l`

# Check for outgoing work
for cmdfile in C./*
do
    test -f $cmdfile || continue
    othersys=`expr $cmdfile : 'C./C.\(.*\).....'`
    cmd=
    dfile=
    xfile=
    ufile=
    cat $cmdfile | {
        while read cmd arg1 arg2 arg3 extra
        do
            case $cmd in
                S)                              # uucp send
                    case $arg1 in
                        D.${LUUNAME}X????)      # Remote execute file
                            xfile=$arg1
                            ;;
                        D.${LUUNAME}?????)      # Data file ref'd by xfile
                            dfile=D.${LUUNAME}/$arg1
                            ;;
                        *)              # Just a uucp -- no intertpretation
                            echo `wc -c < $arg1`\        uucp $arg1 $othersys!$arg2 \($arg3\)
                            ;;
                    esac
                    ;;
                R)              # uucp receive
                    echo '      ' uucp $othersys!$arg1 $arg2 \($arg3\)
                    ;;
                *)  echo Bad cmd in $cmdfile: $cmd $arg1 $arg2 $arg3 $extra
                    continue ;;
            esac
        done
        case $xfile in
            "")                 # uucp transfer
                continue
                ;;
        esac
        cat D.${LUUNAME}X/$xfile | {    # complex transfer -- interpret xfile
            while read xcmd arg1 arg2 extra
            do
                case $xcmd in
                    U)
                        from=$arg2!$arg1
                        ;;
                    F)
                        ;;
                    I)
                        ;;
                    Z)
                        ;;
                    C)
                        case $arg1 in
                            rmail)
                                from=`head -1 $dfile | ( read arg1 arg2 extra; echo $arg2 )`
                                echo `wc -c < $dfile`\   $arg1 $othersys!$arg2 \($from\)
                                echo -n '        '
                                grep '^Subject:' $dfile || echo ''
                                ;;
                            rnews)
                                echo `wc -c < $dfile`\   $arg1 $othersys  \($from\)
                                echo -n '        '
                                grep '^Newsgroups:' $dfile
                                echo -n '        '
                                grep '^Subject:' $dfile
                                ;;
                            *)
                                echo `wc -c < $dfile`\   $arg1 $arg2 $extra [$othersys $dfile] \($from\)
                                ;;
                        esac
                        ;;
                    *)
                        echo Unknown xcmd in $xfile: $xcmd $arg1 $arg2
                        exit
                        ;;
                esac
            done
        }
    }
done

# Check for incoming work
for cmdfile in X./*
do
    test -f $cmdfile || continue
    othersys=`expr $cmdfile : 'X./X.\(.*\).....'`
    comment=
    cat $cmdfile | {
        while read cmd arg1 arg2 extra
        do
            case $cmd in
                U)
                    from=$arg2!$arg1
                    ;;
                Z)
                    ;;
                I)
                    ;;
                F)
                    if test -f D./$arg1
                    then
                        dfile=D./$arg1
                    elif test -f XTMP/$arg2
                    then
                        dfile=XTMP/$arg2
                        comment="(EXECUTING)"
                    else
                        continue 2
                    fi
                    ;;
                C)
                    xcmd=$arg1
                    xargs="$arg2 $extra"
                    case $arg1 in
                        rmail)
                            from=$othersys!`head -1 $dfile | ( read arg1 arg2 extra; echo $arg2 )`
                            echo -n '    '
                            grep '^Subject:' $dfile || echo ''
                            ;;
                    esac
                    ;;
                *)  echo Bad cmd in $cmdfile: $cmd $arg1 $arg2 $extra
                    continue ;;
            esac
        done
        echo `wc -c < $dfile`\   $xcmd $xargs $comment \($from\)
    }
done
!Funky!Stuff!



From: Nancy Blachman <decvax!decwrl!sun!idi!resonex!nancy@Ucb-Vax.ARPA>
To: net.unix, net.unix-wizards, net.sources
Subject: Actual tricks, shells, csh aliases and the like, 3 of 3
Date: 16 Oct 84 21:24:32 GMT
Organization: Resonex Inc., Sunnyvale, CA

> [Know anybody with a GREAT .login or .cshrc?]

> I'm interested in collecting the little tricks, shell scripts, awk
> hacks, csh aliases, and such that people have built to make their daily
> life a little easier or more automatic.  Being a fairly new system
> administrator I don't have the big toolbox that years of messing around
> will leave you with.  If you have any hacks you're proud of (or that
> you aren't proud of, but which work anyway), and you're willing to make
> them public, mail them to me.  I'll collect, collate, shuffle, sort,
> munge, judge, select and discard them and then "summarize to the net".

This article centers on C programs and awk scripts I received in response to
my solicitation.  The first article concentrates on  aliases, and .cshrc and
.login files.  The second article in this series focuses shell scripts.

/\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\/
> Nancy Blachman {allegra,hplabs,ihnp4,sun}!resonex!nancy  (408)720 8600 x37 <
/\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\//\/

::::::::::::::
programs/1
::::::::::::::
Date: Sat, 15 Sep 84 02:45:08 pdt
From: <hplabs!intelca!t4test!chip>
To: intelca!hplabs!resonex!nancy
Subject: Re: Tricks, shell and awk scripts, csh aliases and the like

One thing I've put together is a bunch of scripts which give you a
status line on a DEC type terminal.  The thing is hardwired into VTxxx
type stuff rather than termcap for two reasons.  First, the cursor
save/restore function isn't part of termcap.  Secondly, the set
scrolling region is part of termcap, but it is for VT100 type
terminals.  Since we only have DEC terminals, it doesn't hurt us too
much.

Some history:  I used to like to display my current working directory
on my prompt line.  Later I wanted my terminal line there too.  (That
was in case a terminal I was on locked up, I could quickly tell what
terminal to kill.)  Later, when I had four accounts on the machine I
thought it would be nice to display my login name in my prompt.  The
straw which broke the camel's back was that we bought another VAX, and
I wanted to be able to see which machine I was logged on.  As you might
imagine, my prompt now extended about 60 columns across the screen.  My
answer was to take everything out of my prompt except the history
number and stick it at a status line at the bottom of my screen.

Below is a shar archive of the status line files.  You do a `source
stat.init' to get stuff initialized.  Then `son' and `soff' (which are
aliased to source the two other scripts) turn the status line on and
off.  These also define a bunch of aliases which help you work with
programs which don't like the status line.  So, I put a `source
/usr/public/stat.init' followed by a `son' in my `.login'.  (I don't
turn it on with my `.cshrc', my shell escapes would then get awfully
sloooooow.)

Also, you would need to add `vt100s' and `vt131s' to /etc/termcap.
This is to keep screen stuff (e.g. more, vi, etc.) happy if you run
them with the status line on.  This is what I use:

    ################      VT131 with 24th line reserved
    ################ d13s|vt131s|VT131S|vt-131s|pt131s|pt-131s|dec
    vt131s:\
            :li#23:tc=vt131

You will definately want to change the terminal identification stuff in
`stat.init'.  We run Eunice, so I use the `grep' to convert the Unix
style terminal line identification to a VMS terminal port.

You can redefine `statin' in the `stat.init' script to put whatever you
want on the status line.

Well...after all this, I hope you use VT1xx/VT2xx terminals.
Otherwise, this won't be real exciting.  (Unless you want to rewrite
`statterm.c')

---

Chip Rosenthal, Intel/Santa Clara
{ idi|intelca|icalqa|kremvax|qubix|ucscc } ! t4test ! { chip|news }

-----  cut here  -----------------------------------------------------------

: This is a shar archive.  Extract with sh, not csh.
: This archive contains the following files
:  Makefile stat.init stat.on stat.off statterm.c
: Total number of files: 5
echo x - Makefile [file 1 of 5]
sed 's/^|//' > Makefile << '!-FUNKY-STUFF-!'
|BIN=   /usr/public
|OBJS=  statterm
|
|IOBJS= $(BIN)/statterm \
|       $(BIN)/stat.init \
|       $(BIN)/stat.on \
|       $(BIN)/stat.off
|
|SOURCES=Makefile \
|       stat.init \
|       stat.on \
|       stat.off \
|       statterm.c
|
|all:           $(OBJS)
|install:       $(IOBJS)
|shar:          stat.shar
|
|statterm:              statterm.c
|                       cc -O statterm.c -o statterm
|
|$(BIN)/statterm:       statterm
|                       cp $? $@
|                       chmod 755 $@
|
|$(BIN)/stat.init:      stat.init
|                       cp $? $@
|                       chmod 755 $@
|
|$(BIN)/stat.on:                stat.on
|                       cp $? $@
|                       chmod 755 $@
|
|$(BIN)/stat.off:       stat.off
|                       cp $? $@
|                       chmod 755 $@
|
|stat.shar:             $(SOURCES)
|                       shar $(SOURCES) > $@
|
|
!-FUNKY-STUFF-!
echo x - stat.init [file 2 of 5]
sed 's/^|//' > stat.init << '!-FUNKY-STUFF-!'
|alias a 'alias'
|
|# run statterm to verify terminal can do status line
|statterm
|if $status then
|    # status line not available on this terminal -- see if a
|    # baseterm is defined.  if so, then maybe $TERM is just
|    # messed up from earlier invocation of stat.init.
|    if $?baseterm then
|       # baseterm has been defined -- see if it will work
|       set temp=$TERM
|       setenv TERM $baseterm
|       statterm
|       if $status then
|           # nope -- baseterm will not work either
|           setenv TERM $temp
|           unset temp
|           goto failed
|       else
|           # yes -- baseterm will work
|           echo "changing terminal type from $temp to $TERM"
|           unset temp
|       endif
|    else
|       # no baseterm defined
|       goto failed
|    endif
|endif
|
|# status line will work with this terminal
|set baseterm=$TERM
|set ignoreeof
|
|# find user's system (ick)
|set system=`tr '[A-Z]' '[a-z]' < /usr/include/whoami`
|
|# find user's tty (ick ick ick)
|set temp=`tty`'$'
|set tty=`grep "$temp" /etc/dev.com | sed -e 's/^.*_\(.*\):.*/\1/'`
|unset temp
|
|# setup terminal strings
|set statin="`statterm in '${system}\\!${user}' '(${tty})'`"
|set statout="`statterm out`"
|set statoff="`statterm off`"
|echo -n "$statoff"
|
|# setup status commands
|#   son - turn on status mode
|#   soff - turn off status mode
|#   stat - draw status line
|#   nostat - erase status line
|#   termstat - setenv the terminal with status line protected
|#   termnorm - setenv the terminal without a status line
|#   ns - execute a command without a status line
|a son          'source /usr/public/stat.on'
|a soff         'source /usr/public/stat.off'
|a stat         ';'
|a nostat       ';'
|a termstat     ';'
|a termnorm     ';'
|a ns           'nostat ; termnorm ; \!* ; termstat ; stat ; echo ""'
|
|# alias the commands which maintain the status line
|a cd           'chdir \!* ; stat'
|a popd         'popd ; stat'
|a pushd                'pushd \!* ; stat'
|
|# alias the commands which (might) munch the status line
|a clear                'clear \!* ; stat'
|a mail         'mail \!* ; stat'
|a more         'more \!* ; stat'
|
|# alias the commands which should be done with the status line off
|a lo           'ns logout \!*'
|a LO           'ns logout \!*'
|a rn           'ns /local/bin/rn \!*'
|a pn           'ns /local/bin/pn \!*'
|a reply                'ns /local/bin/reply \!*'
|a sus          'ns suspend \!*'
|a vi           'ns /usr/ucb/vi \!*'
|a view         'ns /usr/ucb/view \!*'
|
|# that is all folks.  the status stuff is initialized
|# now all you need is a 'son' to turn it on
|exit 0
|
|failed:
|set baseterm=$TERM
|set temp="status line is not available for terminal type $TERM"
|echo $temp
|set statin=";"
|set statout=";"
|if     $?statoff == 0 then
|    set statoff=";"
|endif
|alias son echo "$temp"
|alias off 'source /usr/public/stat.off'
|unset temp
|soff
|exit 1
|
!-FUNKY-STUFF-!
echo x - stat.on [file 3 of 5]
sed 's/^|//' > stat.on << '!-FUNKY-STUFF-!'
|a stat         'echo -n "${statin}${cwd}${statout}"'
|a nostat       'echo -n "$statoff"'
|a termstat     'setenv TERM ${baseterm}s'
|a termnorm     'setenv TERM $baseterm'
|termstat
|stat
|echo ""
|set statmode
!-FUNKY-STUFF-!
echo x - stat.off [file 4 of 5]
sed 's/^|//' > stat.off << '!-FUNKY-STUFF-!'
|setenv TERM $baseterm
|echo -n "$statoff"
|unset statmode
|a termstat     ';'
|a termnorm     ';'
|a stat ';'
|a nostat ';'
!-FUNKY-STUFF-!
echo x - statterm.c [file 5 of 5]
sed 's/^|//' > statterm.c << '!-FUNKY-STUFF-!'
|/*
| * FILE:       statterm
| * VERSION:    V0.01 [preliminary]
| * DATE:       Mon Aug 27 16:43:13 PDT 1984
| * AUTHOR:      Chip Rosenthal/Intel Corporation
| * ADDRESS:    t4test!chip
| * PACKAGE:     'stat' terminal status line package
| * DESCRIPTION:        produces terminal escape sequences to implement status line
| * COMPILATION: cc -C statterm.c -o statterm
| *
| * REVISION NOTES:
| *
| * V1.00  Original program.
| *
| *
| * USAGE:
| *
| *    statterm
| *        Verifies that the status line will work with current terminal.
| *        Returns a zero exit status if it will, nonzero if it won't.
| *
| *    statterm in [arg ...]
| *        Creates a string which opens up the status line.  Any
| *        arguments are placed at the beginning of the status
| *        line, and the cursor is left there.
| *
| *    statterm out
| *        Create string which closes the status line and returns
| *        cursor to position it was in prior to the last execution
| *        of a 'statterm in' string.
| *
| *    statterm off
| *        Creates a string which removes the status line.
| *
| *
| *    EXAMPLE:
| *        # this is a cshell script
| *        statterm
| *        if $status then
| *            echo "status line will not work on this terminal"
| *            exit
| *        endif
| *        echo -n `statterm in $user`
| *        echo -n `pwd`
| *        echo `statterm out`
| *
| *
| * BUGS:
| *
| *    This program is hardwired into the DEC VT100 terminal escape sequences.
| *    This is done because (unfortunately) 'termcap' doesn't offer a cursor
| *    position save/restore feature.
| *
| */
|
|#include <stdio.h>
|#define strmatch(A,B) (strcmp((A),(B))==0)
|
|/*
| * VT100 Terminal Escape Definitions -- all parameters are strings
| */
|#define ESC          putchar(27);              /* escape character          */
|#define CSI          ESC;putchar('[');         /* command string            */
|#define DECSC        ESC;putchar('7');         /* save cursor position      */
|#define DECRC        ESC;putchar('8');         /* restore cursor position   */
|#define CUP(L,C)      CSI;printf("%s;%sH",L,C); /* set cursor to line/col    */
|#define CUU1         CSI;printf("1A");        /* cursor up one line        */
|#define CUD1         CSI;printf("1B");        /* cursor down one line      */
|#define EL(MODE)      CSI;printf("%sK",MODE);   /* erase line                */
|#define ED(MODE)      CSI;printf("%sJ",MODE);   /* erase display             */
|#define DECSETBM(T,B) CSI;printf("%s;%sr",T,B); /* top/bot of scroll area    */
|/*
| * erasing modes:
| *   mode "0" - from cursor to end
| *   mode "1" - from beginning to cursor
| *   mode "2" - entire
| */
|
|
|main(argc,argv)
|int argc;
|char *argv[];
|{
|    char *term, *getenv();
|    int i;
|
|    if ( argc == 1 ) {
|       term=getenv("TERM");
|       if ( term == NULL )
|           exit(1);
|       if ( strmatch(term,"vt100") || strmatch(term,"vt131") )
|           exit(0);
|       else
|           exit(1);
|    }
|
|    if ( strmatch(argv[1],"in") ) {
|       /*
|        * Save cursor position, go to line 24, print out the arguments, and
|        * erase the rest of the status line.  Cursor remains in status line.
|        */
|       DECSC;
|       CUP("24","1");
|       for ( i=2 ; i<argc ; ++i )
|           printf("%s  ",argv[i]);
|       EL("0");
|    } else if ( strmatch(argv[1],"out") ) {
|       /*
|        * Protect status line from scrolling and restore cursor to location
|        * prior to the last 'in' call.  Move the cursor up and down one line.
|        * This will keep it out of the status line area if it was there when
|        * 'in' was called.
|        */
|       DECSETBM("1","23");
|       DECRC;
|       CUU1;
|       CUD1;
|    } else if ( strmatch(argv[1],"off") ) {
|       /*
|        * Save the current cursor position, unprotect the status line, erase
|        * the status line, and restore the cursor position.
|        */
|       DECSC;
|       DECSETBM("1","24");
|       CUP("24","1");
|       EL("2");
|       DECRC;
|    } else
|       exit(1);
|
|}
!-FUNKY-STUFF-!
exit



::::::::::::::
programs/2
::::::::::::::
From: ihnp4!mcnc!malloy@ittral
Date: Thu, 13 Sep 84 21:35:18 edt
To: ihnp4!resonex!nancy@mcnc
Subject: Tricks

Well it depends upon what you mean. The big problem with having lots of aliases
and such is they start taking up large amounts of memory.  Take it from someone
who knows.  But here's a few things.  Some you no doubt already have, and most
are trivial, but it's better to be complete then to leave anything out.  You
can always just delete this.    == William P. Malloy (ittral!malloy}
---------------------------------------------------------------------
In a .cshrc, a warning and a work around.  Apparently not known by most people
but obvious to people have who been around.  Our users keep bumping into it
about once a year like clock work.
# reason for setting variables only if a prompt already exists
# If it sets prompt in a non-interactive shell, for instance vi(1)
# firing up a sub-shell to expand shell meta-characters, the set prompt
# will stomp on alot of shell variables used for the expansion (like ~)
#
if ( $?prompt ) then
   set mail=/usr/spool/mail/malloy
   set prompt=\`
   set histchars=",;"
endif
Note the setting of histchars.  A little known, but for me much loved feature
of csh is the ability to change the history characters "!^" from their default
values.  The pair `,;' are easier to reach, don't require shifting, and don't
appear in mail paths.  Typing `mail mcnc\!ihnp4\!resonex\!nancy' gets to be
a pain every time you want to mail someone.

alias , 'redo \,* ~/.cmd ~/.cmd1 ; source ~/.cmd1 '

This little alias allows you to have command editing in the csh.  It's quite
useful, particularly when you've got a LONG painful command line.  The , is
just the history character and is ! for most people.  The command redo is a
simple C program.
--------------- redo.c  -------------------
#include <stdio.h>

/* redo -- outputs a command file (last arg )used to edit and
   re-ex a command.  Next to last arg is dest file of the command.

   NOTE: if you use a non-standard history character, i.e. not !
   then you must `setenv HISTCHARS $histchars' in your .login
   If you do not `set histchars=",;"' for instance then it will
   automagically default to !    -- 12/2/83 wpm

   First arg is the history ref . To use:
    alias , 'redo \,* ~/cmd ~/cmd1 ; source ~/cmd1 '
    , 25    to edit & re-execute ,25
    , , or ,  to edit & re-execute ,,
    , v     to edit & re-execute ,v ,etc.

*/

main(argc, argv)
   int argc;
   char *argv[];
{
   FILE *fp;
   char *t, *getenv();

   fp = fopen(argv[argc-1], "w");
   if ((t = getenv("HISTCHARS")) != NULL)
      t[1] = '\0';
   else
      t = "!";
   fprintf(fp, "echo \"%s", t);
   if ( (argc < 4) || (strcmp(argv[1], t) == 0) )
      fputs("-2", fp);
   else
      fputs(argv[1], fp);
   fputs(":q\" >! ", fp);
   fputs(argv[argc-2], fp);
   putc('\n', fp);
   fputs("ex +open ", fp);
   fputs(argv[argc-2], fp);
   putc('\n', fp);
   fputs("/usr/local/typein2 < ", fp);
   fputs(argv[argc-2], fp);
   putc('\n', fp);
   fclose(fp);
   exit(0);
}
------------------ (end of redo.c, begining of typein2.c) --------------------
#include <stdio.h>
#include <sgtty.h>

main(argc, argv)
        int argc;
        char **argv;
{
        register char *cp;
        struct sgttyb stb, stb2;
        int pendin = LPENDIN;
        int c,i,j;
        char buff[2];
        char buff2[256];

        i=0;
        while ((c=getchar()) != EOF) {
                        buff2[i++]=c;
        }
        ioctl(2, TIOCGETP, &stb);
        stb2 = stb;
        stb.sg_flags &= ~ECHO;
        ioctl(2, TIOCSETN, &stb);
        for (j=0; j<i; j++) {
                        ioctl(2, TIOCSTI, &buff2[j]);
                        putchar(buff2[j]);
        }
        ioctl(2, TIOCSETN, &stb2);
        ioctl(2, TIOCLBIS, &pendin);
        exit(0);
}
---------------------------- (end of typein2.c) ------------------------
A couple of oldies but still the simplest.  cd and back aliases.
alias back 'set back=$old; set old=$cwd; cd $back; unset back; dirs'
alias cd 'set old=$cwd; chdir \,*; set prompt = "< $cwd:t > "'

# this is a useful feature for vi
setenv EXINIT 'map #1 Gi/\<A\>"add@a|map #2 1G\!Gvispell|set ai sw=3'

You f2 key will run a file through the spell program, and put the words it
doesn't find in the dictionary at the bottom of the file.  Then typing f1 will
cause it to delete the last line in the file, and search for the string in
the rest of the file.
------------------------------ (source for vispell) -------------
#! /bin/sh
#
tee /tmp/vis$$
echo SpellingList
spell /tmp/vis$$
rm /tmp/vis$$
------------------------------- (end of vispell) ------------------
Stuff from our /.cshrc file.  psa lets you see what's going on in the system
and what people are doing.  Useful to see if people are hanging themselves.
alias psa 'ps axu | sed "/getty/d" | sort -f | more'

A simple alias to compile C programs (C adm.c expands to cc adm.c -o adm).
alias C 'cc \,:* -o \,^:r'

Useful to see what's going on in the system without those !@#$% bells.
alias moremsgs "tr -d '\07' </usr/adm/messages | more"

Like fg.
alias pj '%-'

A feature we use in our root .cshrc allowing indivual superusers to get their
own enviornment.  Useful if people want their own enviornment anywhere people
share an account.
if ( $user == "malloy" ) then
   source /t/malloy/.root
endif

--------------- (here's some things I picked up off the net) --------------
From: ittvax!decvax!harpo!utah-cs!seismo!hao!denelcor!udenva!koala!aburt
Date: Fri Aug 10 09:19:37 1984
Subject: Perversions of source -h and other csh aliases
Newsgroups: net.unix,net.unix-wizards,net.sources

For your enjoyment, here are some interesting lunch hour csh aliases that
I've created.
{this is to slow, my version is a little faster}
My personal favorite is the "history editor" -- allows you to edit
you csh history.  The alias:

        alias hed history -h !* > $hed; vi + $hed; source -h $hed

will allow you to invoke 'vi' on your current history.  (If, for
instance, you typed in a long, tedious line and put in an extra space,
among other things.  The ^...^...  mechanism to remove it can be quite
tedious; 'hed's is easy.)  Before anyone starts flaming that vi is too
slow, history can do it (even if it's tough to type and you're prone to
more typos doing the history), etc. -- if you don't like it, don't use it.

Hed works particularly well if you move the command in question to the
end of the file; then '!!' will execute it after you ZZ from vi.  The
only drawback to this is that it trashes your current event numbers
(they get incremented during the source -h).  By using 'hed 10' you
only edit the last 10 entries in your history.  A temp file, which I
keep in $hed (set to /tmp/hed.$$ from my .login), is used each time for
the history.  Obvious changes to this are to use /tmp/hed.$$ straight
out and add "rm /tmp/hed.$$" to the end of the list.  If you don't like
waiting for the rm, and your /tmp doesn't get cleared out periodically,
put a # in front of the name to make it a disposable file.

This may be slower than the vi/emacs mode in the ksh I keep hearing about, but
it does give the functionality.

A slight modification to 'hed'...

        alias hedf history -h !-0:1 > !-0:2; vi + !-0:2; source -h !-0:2

allows you to specify a file to place the history into instead of a temp
file.

Another modification yields:

        alias heh echo \!* > $hed; vi + $hed; source -h $hed

Which lets you edit then add to your history a specific history sequence.
'Heh' for History edit history.

By inserting a 'source \!-0:2' before the source -h in any of the
above has the effect of executing the commands AND placing them on the
history list (from which we may conclude that 'alias so source \!* ;
source -h \!*' is a useful item: it sources a file then places each line
into your history).

On rare occasions you'll have to put extra quotes/escapes around things
when editing the temp file so it gets sourced right.  Particularly around
aliases with raw history substitutions in them (the \!* type of thing).
The easiest is to try it first; if it fails, edit it again.  After all,
two 'hed's are better than one...

Regarding the use of !-0:1 instead of !:1 for the first argument to the
current command -- At least one csh is known to accept the former but not
the latter.  (The same csh dumps core (therefore logging you out) on receipt
of the !# history selector.  This is version 1.0 of 4.2BSD csh on a Sun-2.
The 1.1 csh exhibits this behavior:

        echo a !#
        a echo a echo

adding an extra arg 0 to the end.  Is this common to other cshs out there?)

So, for those whose csh's allow !:1, use that where I have !-0:1, etc.

Another interesting perversion is an alias'd whereis:

        alias wheres ls -l \{'`echo $path | sed "s/ /,/g"`'\}/'`echo \!-0:1 | sed "s/^./[&]/"`'

It does an ls -l on every file (passed as arg 1) in any directory on
your current path.  (No aliases, though adding an if at the front
should do the trick.)  The idea is to turn your $path list into a comma
separates list, stick that between {}, and append / and arg 1 to that.
Alas, if the file doesn't exist in one of the directories, you get
errors from ls saying it doesn't exist in a given directory.  So, arg 1
is turned into a pattern, which is allowed to fail; the pattern is,
e.g., foo --> [f]oo.  So the second arg to ls only expands to the
existing files.
---------------------------- (end of net article) ------------------------
--
Address: William P. Malloy, ITT Telecom, B & CC Engineering Group, Raleigh NC
         {ihnp4!mcnc, burl, ncsu, decvax!ittvax}!ittral!malloy


::::::::::::::
awk/1
::::::::::::::
Date:       Wed, 19 Sep 84 11:44:38 CST
From: David Chase <hplabs!ucbvax!rbbb@rice.ARPA>
Subject:    Re: Tricks, shell and awk scripts, csh aliases and the like
To: resonex!nancy@BERKELEY

Here is my favorite awk script.  It turns a list of csrc's from memory
errors on an 11/780 (with MS780C controller) into board and chip position
for certain Mostek memory boards.  This script saved me many headaches,
because the tables in the appendix of the technical manual were hard to read
and contained errors (errors that were noticed as deviations from a pattern
when entering this script).

#
# Incredible sleazy awk file to attack memory errors
# Included here is the local configuration, because some decoding
# is board specific
#
BEGIN   {
# Boards understood by this program

#       mk4118 = mostek mk8016 fully populated with mk4116 chips (512k)
        known["mk4118"] = 1

#       mk4116 = mostek mk8016 half populated with mk4116 chips (256k)
        known["mk4116"] = 1

#       mk8016 = mostek mk8016 fully populated with mk4108 chips (256k)
        known["mk4108"] = 1

#       m8210 = DEC 256k board; don't know how to decode this guy (256k)
        known["m8210"] = 0

# To add different boards, (i.e., not conforming to this system)
# append to the "pos" map, and make "keys[<array><bank><new board>]"
# reference the appended chip addresses.

# Local configuration
# boards is indexed by slot number
        boards["0"] = "m8210"
        boards["1"] = "m8210"
        boards["2"] = "m8210"
        boards["3"] = "m8210"
        boards["4"] = "m8210"
        boards["5"] = "m8210"
        boards["6"] = "mk4116"
        boards["7"] = "mk4116"
        boards["8"] = "mk4116"
        boards["9"] = "mk4116"
        boards["a"] = "mk4116"
        boards["b"] = "mk4116"
        boards["c"] = "mk4118"
        boards["d"] = "mk4118"
        boards["e"] = "mk4118"
        boards["f"] = "mk4118"

#       bit in error for a given CRC calculation
#       bits are identified by "u" (upper), "l" (lower), and "c" (check)
#       folowed by the bit number.

        bit["01"] = "c0"
        bit["02"] = "c1"
        bit["04"] = "c2"
        bit["08"] = "c3"
        bit["10"] = "c4"
        bit["19"] = "l01"
        bit["1a"] = "l02"
        bit["1c"] = "l04"
        bit["1f"] = "l07"
        bit["20"] = "c5"
        bit["38"] = "l00"
        bit["3b"] = "l03"
        bit["3d"] = "l05"
        bit["3e"] = "l06"
        bit["40"] = "c6"
        bit["49"] = "l09"
        bit["4a"] = "l10"
        bit["4c"] = "l12"
        bit["4f"] = "l15"
        bit["51"] = "l17"
        bit["52"] = "l18"
        bit["54"] = "l20"
        bit["57"] = "l23"
        bit["58"] = "l24"
        bit["5b"] = "l27"
        bit["5d"] = "l29"
        bit["5e"] = "l30"
        bit["68"] = "l08"
        bit["6b"] = "l11"
        bit["6d"] = "l13"
        bit["6e"] = "l14"
        bit["70"] = "l16"
        bit["73"] = "l19"
        bit["75"] = "l21"
        bit["76"] = "l22"
        bit["79"] = "l25"
        bit["7a"] = "l26"
        bit["7c"] = "l28"
        bit["7e"] = "l31"
        bit["80"] = "c7"
        bit["89"] = "u01"
        bit["8a"] = "u02"
        bit["8c"] = "u04"
        bit["8f"] = "u07"
        bit["91"] = "u09"
        bit["92"] = "u10"
        bit["94"] = "u12"
        bit["97"] = "u15"
        bit["98"] = "u16"
        bit["9b"] = "u19"
        bit["9d"] = "u21"
        bit["9e"] = "u22"
        bit["a8"] = "u00"
        bit["ab"] = "u03"
        bit["ad"] = "u05"
        bit["ae"] = "u06"
        bit["b0"] = "u08"
        bit["b3"] = "u11"
        bit["b5"] = "u13"
        bit["b6"] = "u14"
        bit["b9"] = "u17"
        bit["ba"] = "u18"
        bit["bc"] = "u20"
        bit["bf"] = "u23"
        bit["c1"] = "u25"
        bit["c2"] = "u26"
        bit["c4"] = "u28"
        bit["c7"] = "u31"
        bit["e0"] = "u24"
        bit["e3"] = "u27"
        bit["e5"] = "u29"
        bit["e6"] = "u30"

#       binary decoding of hex digits

        hex["0"]  = "0000"
        hex["1"]  = "0001"
        hex["2"]  = "0010"
        hex["3"]  = "0011"
        hex["4"]  = "0100"
        hex["5"]  = "0101"
        hex["6"]  = "0110"
        hex["7"]  = "0111"
        hex["8"]  = "1000"
        hex["9"]  = "1001"
        hex["a"]  = "1010"
        hex["b"]  = "1011"
        hex["c"]  = "1100"
        hex["d"]  = "1101"
        hex["e"]  = "1110"
        hex["f"]  = "1111"

#       chip positions for a given bit, collected across all possible
#       boards.  Each group of 3 letters represents a position.
#       See keys for a better description.

        pos["u31"] =  "i01h01g01f01"
        pos["u30"] =  "e01d01c01b01"
        pos["u29"] =  "i02h02g02f02"
        pos["u28"] =  "e02d02c02b02"
        pos["u27"] =  "i03h03g03f03"
        pos["u26"] =  "e03d03c03b03"
        pos["u25"] =  "i04h04g04f04"
        pos["u24"] =  "e04d04c04b04"
        pos["u23"] =  "a01a02a03a04"
        pos["u22"] =  "i05h05g05f05"
        pos["u21"] =  "e05d05c05b05"
        pos["u20"] =  "i06h06g06f06"
        pos["u19"] =  "e06d06c06b06"
        pos["u18"] =  "i07h07g07f07"
        pos["u17"] =  "e07d07c07b07"
        pos["u16"] =  "i08h08g08f08"
        pos["u15"] =  "e08d08c08b08"
        pos["u14"] =  "a05a06a07a08"
        pos["u13"] =  "i09h09g09f09"
        pos["u12"] =  "e09d09c09b09"
        pos["u11"] =  "i10h10g10f10"
        pos["u10"] =  "e10d10c10b10"
        pos["u09"] =  "i11h11g11f11"
        pos["u08"] =  "e11d11c11b11"
        pos["u07"] =  "i12h12g12f12"
        pos["u06"] =  "e12d12c12b12"
        pos["u05"] =  "a09a10a11a12"
        pos["u04"] =  "i13h13g13f13"
        pos["u03"] =  "e13d13c13b13"
        pos["u02"] =  "i14h14g14f14"
        pos["u01"] =  "e14d14c14b14"
        pos["u00"] =  "i15h15g15f15"
        pos["c7"] =   "e15d15c15b15"
        pos["c6"] =   "i16h16g16f16"
        pos["c5"] =   "e16d16c16b16"
        pos["c4"] =   "a13a14a15a16"
        pos["l31"] =  "i17h17g17f17"
        pos["l30"] =  "e17d17c17b17"
        pos["l29"] =  "i18h18g18f18"
        pos["l28"] =  "e18d18c18b18"
        pos["l27"] =  "i19h19g19f19"
        pos["l26"] =  "e19d19c19b19"
        pos["l25"] =  "i20h20g20f20"
        pos["l24"] =  "e20d20c20b20"
        pos["l23"] =  "a17a18a19a20"
        pos["l22"] =  "i21h21g21f21"
        pos["l21"] =  "e21d21c21b21"
        pos["l20"] =  "i22h22g22f22"
        pos["l19"] =  "e22d22c22b22"
        pos["l18"] =  "i23h23g23f23"
        pos["l17"] =  "e23d23c23b23"
        pos["l16"] =  "i24h24g24f24"
        pos["l15"] =  "e24d24c24b24"
        pos["l14"] =  "a21a22a23a24"
        pos["l13"] =  "i25h25g25f25"
        pos["l12"] =  "e25d25c25b25"
        pos["l11"] =  "i26h26g26f26"
        pos["l10"] =  "e26d26c26b26"
        pos["l09"] =  "i27h27g27f27"
        pos["l08"] =  "e27d27c27b27"
        pos["l07"] =  "i28h28g28f28"
        pos["l06"] =  "e28d28c28b28"
        pos["l05"] =  "a25a26a27a28"
        pos["l04"] =  "i29h29g29f29"
        pos["l03"] =  "e29d29c29b29"
        pos["l02"] =  "i30h30g30f30"
        pos["l01"] =  "e30d30c30b30"
        pos["l00"] =  "i31h31g31f31"
        pos["c3"] =   "e31d31c31b31"
        pos["c2"] =   "i32h32g32f32"
        pos["c1"] =   "e32d32c32b32"
        pos["c0"] =   "a29a30a31a32"

#       keys is indexed by <board #> <bank> <board type>
#       and yields an index into  a particular pos string
#       for example, board 0, bit 0 on an mk4118 board
#       gives a key of 4.  If the bit in error was c0, then
#       the chip in error is a32 (from the 4th group of 3
#       in pos["c0"].  To change this map, create new keys
#       and (if necessary) append to the pos entries.
#       If it could be more than one chip, then use a multiple
#       digit key (e.g, see the keys for the mk4108 board).

        keys["00mk4118"] = "4"
        keys["20mk4118"] = "4"
        keys["40mk4118"] = "4"
        keys["60mk4118"] = "4"
        keys["80mk4118"] = "4"
        keys["a0mk4118"] = "4"
        keys["c0mk4118"] = "4"
        keys["e0mk4118"] = "4"
        keys["01mk4118"] = "2"
        keys["21mk4118"] = "2"
        keys["41mk4118"] = "2"
        keys["61mk4118"] = "2"
        keys["81mk4118"] = "2"
        keys["a1mk4118"] = "2"
        keys["c1mk4118"] = "2"
        keys["e1mk4118"] = "2"
        keys["10mk4118"] = "3"
        keys["30mk4118"] = "3"
        keys["50mk4118"] = "3"
        keys["70mk4118"] = "3"
        keys["90mk4118"] = "3"
        keys["b0mk4118"] = "3"
        keys["d0mk4118"] = "3"
        keys["f0mk4118"] = "3"
        keys["11mk4118"] = "1"
        keys["31mk4118"] = "1"
        keys["51mk4118"] = "1"
        keys["71mk4118"] = "1"
        keys["91mk4118"] = "1"
        keys["b1mk4118"] = "1"
        keys["d1mk4118"] = "1"
        keys["f1mk4118"] = "1"

        keys["00mk4116"] = "4"
        keys["20mk4116"] = "4"
        keys["40mk4116"] = "4"
        keys["60mk4116"] = "4"
        keys["80mk4116"] = "4"
        keys["a0mk4116"] = "4"
        keys["c0mk4116"] = "4"
        keys["e0mk4116"] = "4"
        keys["01mk4116"] = "2"
        keys["21mk4116"] = "2"
        keys["41mk4116"] = "2"
        keys["61mk4116"] = "2"
        keys["81mk4116"] = "2"
        keys["a1mk4116"] = "2"
        keys["c1mk4116"] = "2"
        keys["e1mk4116"] = "2"
        keys["10mk4116"] = "4"
        keys["30mk4116"] = "4"
        keys["50mk4116"] = "4"
        keys["70mk4116"] = "4"
        keys["90mk4116"] = "4"
        keys["b0mk4116"] = "4"
        keys["d0mk4116"] = "4"
        keys["f0mk4116"] = "4"
        keys["11mk4116"] = "2"
        keys["31mk4116"] = "2"
        keys["51mk4116"] = "2"
        keys["71mk4116"] = "2"
        keys["91mk4116"] = "2"
        keys["b1mk4116"] = "2"
        keys["d1mk4116"] = "2"
        keys["f1mk4116"] = "2"

        keys["00mk4108"] = "34"
        keys["20mk4108"] = "34"
        keys["40mk4108"] = "34"
        keys["60mk4108"] = "34"
        keys["80mk4108"] = "34"
        keys["a0mk4108"] = "34"
        keys["c0mk4108"] = "34"
        keys["e0mk4108"] = "34"
        keys["01mk4108"] = "12"
        keys["21mk4108"] = "12"
        keys["41mk4108"] = "12"
        keys["61mk4108"] = "12"
        keys["81mk4108"] = "12"
        keys["a1mk4108"] = "12"
        keys["c1mk4108"] = "12"
        keys["e1mk4108"] = "12"
        keys["10mk4108"] = "34"
        keys["30mk4108"] = "34"
        keys["50mk4108"] = "34"
        keys["70mk4108"] = "34"
        keys["90mk4108"] = "34"
        keys["b0mk4108"] = "34"
        keys["d0mk4108"] = "34"
        keys["f0mk4108"] = "34"
        keys["11mk4108"] = "12"
        keys["31mk4108"] = "12"
        keys["51mk4108"] = "12"
        keys["71mk4108"] = "12"
        keys["91mk4108"] = "12"
        keys["b1mk4108"] = "12"
        keys["d1mk4108"] = "12"
        keys["f1mk4108"] = "12"
        }

        {csrc     = $1
        syndrome = substr (csrc,7,2)
        board    = substr (csrc,2,1)
        boardtype = boards[board]
        bank     = substr (hex [substr (csrc,3,1)],1,1)
        chips    = bit[syndrome]
        if (known[boardtype])
        {  where         = pos[chips]
           key   = keys[board bank boardtype]
           sbegin   = 3 * (substr(key,1,1) - 1) + 1
           thechip  = substr(where,sbegin,3)
           if (length(key) > 1)
           {   sbegin   = 3 * (substr(key,2,1) - 1) + 1
               thechip  = thechip " and/or " substr(where,sbegin,3)
           }
#          printf "\n"
#          print "csrc =      " csrc
#          print "syndrome =  " syndrome
#          print "board =     " board
#          print "bank =      " bank
#          print "chips =     " chips
#          print "locations = " where
#          print "boardtype = " boardtype
#          print "key =       " key
#          print "the chip is " thechip
           errors[board "-" thechip]++;
        }
        else
        {
#          printf "\n"
#          print "Board type " boardtype " is unknown"
           errors["unknown-unknown"]++;
        }
}

END { for (i in errors) {
        n = split(i,list,"-");
        printf "%d errors for board %s, chip %s\n",errors[i],list[1],list[2];
        }
}

