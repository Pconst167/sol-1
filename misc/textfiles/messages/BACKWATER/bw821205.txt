NUMBER OF LINES: 629 
1 If you are in need of help, you need but ask.
2 Welcome to BWMS (BackWater Message System)  Mike Day System operator
3 *********************** REMOVED: 5 DEC 82 ********************************
4 GENERAL DISCLAIMER: BWMS IS NOT RESPONSIBLE FOR ANY INFORMATION PLACED ON
5                     THIS SYSTEM.
6 BWMS was created as an electronic bill board. BWMS is a privatly owned
7 and operated system which is currently open for use by the general public.
8 No restrictions are placed on the use of the system.
9 It is intended that the system be normally used for messages and
10 advertisments by the users. As the system is privatly owned, I retain the
11 right to remove any and all messages from the system which are offensive
12 to me. Additionally because of the limited size of the system, it will be
13 periodically purged of older messages. (only 629 lines of data can be saved)
14 To leave a message, type 'ENTER' and use ctrl/C or break to get out
15 of the enter mode. The message is automaticly stored.
16 If after entering the message you find you made a mistake,
17 use the replace command to replace the line.
18 To exit from the system, type 'OFF' then hang up.
19 ********************************************************************
20  
21                ##########################################
22                ##                                      ##
23                ##   BE SURE TO BRING ALL OF YOUR       ##
24                ##    QUASI- OR SEMI-QUASI-JUNQUE       ##
25                ##    TO THE PORTLAND COMPUTER SOCIETY  ##
26                ##           S W A P  M E E T           ##
27                ##                                      ##
28                ##    NOVEMBER 20, 1982                 ##
29                ##                                      ##
30                ##    ROBERT MURPHY HALL                ##
31                ##    3736 SE 79TH AVE                  ##
32                ##    PORTLAND, OREGON                  ##
33                ##                                      ##
34                ##    THIS IS A LARGE HALL WITH PLENTY  ##
35                ##    OF TABLE SPACE AT $2 PER TABLE    ##
36                ##    FOR SELLERS AND NO ADMISSION FEE. ##
37                ##    SETUP TIME IS 11:00 AM WITH MEET  ##
38                ##    OPEN FROM 12:00 TO 4:00. PLENTY   ##
39                ##    OF FREE PARKING, TOO.  CALL NEAL  ##
40                ##    BONOME AT xxx-xxxx FOR DETAILS.   ##
41                ##                                      ##
42                ##########################################
43 
44 Just a note, in regard to the ability of the Atari to handle COBOL/FORTRAN.
45 with the Z80 card which allows the Atari to handle CP/M the afore mentioned
46 programs are available to run under CP/M. As such I fail to see the problem.
47 I know, they are not 'main frame' implimentations, but I have seen main frame
48 implimentations that stink far worst then the micro versions. As for the
49 other things on the Atari, I too find the membrane keyboard a piece of trash.
50 But if you don't like it you can always get the 800 which has a 'normal' type
51 keyboard. It always amazes me when someone says that a computer is a peice
52 of junk because it can't do such and such.
53 A computer performs the function that it was designed to perform. If it does
54 that task well it is a good computer. If it doesn't it is a poor computer.
55 As far as the task it performs being good or bad is a again a silly notion
56 that it has some relation to being required to run 'business' type programs.
57 The highest volume 8 bit micro is the 6502 (which the Atari uses), but the 
58 highest volume micro of all is the TMS1000 which is a 4 biter!!! (What do you
59 think TI uses in all those calculators it sells!) And it has found its
60 place in many things from coffee pots to microwave ovens to washing machines.
61 Yes,these are computers, they perform just as vital a function as the IBM 370's
62 Just because they aren't as flashy doesn't mean they are any less valuable.
63 From a performance standpoint, there are few computers around that can match
64 the graphics abilities of the Atrai at the price range. There is far more to 
65 a computer then the hardware it runs with, a far more important function is
66 the software that is available to use that hardware. and the IBM is currently
67 sorely lacking in that for graphics (compared to the Atari). Finally, you may
68 consider COBOL to be a more respectable langauge (I don't, but thats another
69 story) but I'll take $20-$50 for 100,000 games any day over $500-$1000 for
70 100 business programs. (If you don't think these numbers are representative
71 of the real life, you obviously aren't in the business.) Not only does it
72 pay more, but there is a whole bunch less headaches involving stupid idiots
73 who don't know which end of a floppy disk to put in the machine! As for the 
74 value of the game programing, I feel it is of extreme! importance. I have not
75 seen a single COBOL programer who really understood the problems of real time
76 interactive processing because the program isolates them from this very thing
77 by makeing it difficult to impossible to even do. On the other hand there 
78 are very few games programers that I know who are not fully aware of the 
79 problems in this. There will be far more small interactive machines sold
80 for various purposes then any other type of computer, and they most definatly
81 will not be written in COBOL!!!!! These programers will have to come from
82 someplace, and since the schools aren'T doing anything to provide them, the
83 same old thing will happen that happened to the micro to begin with, they 
84 will come from the garages of America. A bigger hammer aproach does not
85 solve the problem, it only pulverises it into meaningless little problems.
86 P.S. Just so you don't think I am some kid out of school who doesn't know
87 any better, I design computers for a living. I do not own an Atari, I use
88 to have a ZX80 which I gave to my father, I own several computers including
89 an heathkit H-8, and an IMSAI S-100 machine. My first langauge was Fortran
90 I do most of my work on a computer I designed and built myself (Z80 two 
91 5 inch floppies and 256K of RAM) I have written commercial software
92 and non-commercial (public-domain) software. I have written numerous 
93 articles on computers for various publications, and currently write
94 a telecommunications column for Compute! magazine, and last but not least
95 I own and run this message system. That's right, you guessed it, I am the 
96 one and only (Thank god!!!) 
97 ********* CISTOP MIKEY ******* 16 NOV 82 ******** 8:33 PM ************
98 P.S. I've even written a game or two. (Golly!)
99 That ought to keep 'em going for at least a week about how wrong I am.
100 ***********************************************************************
101 Dear Mikey;
102     You are talking raw sense.  I did not think that was permited on this
103 system!  But if the CISTOP likes it, swing with it!  I agree with your 
104 thought on cobal.  It's almost criminal to put a batch oriented language
105 on a perfectly good, interactive, microcomputer.  
106                                         the Phantom Glitch
107                                             11/16/82   22:20
108 
109 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
110 
111 Looking at the Want Ads in a recent sunday Oregonian,
112 I noticed that Cobol Programmers were most in demand -
113 but right on their heels was the demand for Assembly
114 Language programmers, and the Assembly Language applications
115 paid more! Most Commercial game software is written
116 in Assembly Language.
117 It would seem to me that Learning Assembly Language
118 would be potentially more beneficial to the majority of
119 Micro owners, while I have seen no programs advertised that
120 require Cobol.
121 **************************************************************
122 It is interesting that most, if not all of the ads for COBOL programmers
123 state the particular operating system and hardware that they want you to
124 have 2 to 3 years of experience using.  At that rate, all they are going
125 to get are a lot of recycled programmers.  I wonder how all of the new
126 blood gets into the seemingly closed loop.  Along these lines, there is
127 a good article in the South Metro section of the Oregonian this morning
128 relating the opinion that the jobs for programmers are drying up (from
129 the point of view of an educator at Clackamas CC).  Has the balloon
130 burst?
131 {}{}{}{}{}{}{}{} Analog Alan {}{}{}{}{}{}{}{} 1825 17 Nov 82 {}{}{}{}{}{}{}{}
132 HI THERE....THIS IS THE FIRST MESSAGE I HAVE FELT THE URGE TO LEAVE ON
133 A BULLETIN BOARD, BUT YOUR COMMENTS INSPIRED IT.....IF YOU REALLY WANT
134 TO WRITE GAMES, YOU SHOULD INVESTIGATE "C" FOR A LANGUAGE....I WORK WITH
135 A SOFTWARE COMPANY (EVRYWARE) WHICH WRITES ACTION GAMES FOR THE HEATH-
136 ZENITHLINE (IF YOU HAVE AN H-19 ON YOUR H8, LET ME KNOW), AND ALL OUR
137 STUFF IS DONE IN "C".....IT'S A MARVELOUS LANGUAGE, AS IT DOES A LOT OF THE
138 TEDIOUS REPETITIVE STUFF FOR YOU THAT YOU USUALLY HAVE TO DO IN ASSEMBLY
139 LANGUAGE, BUT STILL HAS ALL THE POWER AND STRUCTURE......MAUREEN HACKLEY
140 
141 #######################################################################
142 
143 Many of the idiots who blather about which language is better have
144 apparently not studied the history of computing. Way back when
145 Turing proved that any program could be expressed in a language
146 with only 5 (yes, five) instructions, but we all know that is a
147 lot easier to do it with a good rich language. The design of 
148 computer languages is changing because we are learning more about
149 how. COBOL was one of the first, and as such has certain 
150 caracteristics not too good for modern machines and programmers.
151 (It is oriented to cards and batch.) It of course does not have
152 any facilities for interactive or graphics use: these weren't
153 invented yet. Most ads for COBOL programmers are not for people
154 to write new programs, but rather to maintain old programs. This
155 is not an easy job, either; but not as "creative".
156    Then came BASIC, written for a specific purpose: to teach 
157 beginners to program. It was therefore VERY simple. Dijkstra
158 condemned it bitterly. However, it worked, for what it was designed
159 for. It was small, and could be put on the new microcomputers.
160 However, it was too simple-minded, so it was IMPROVED. It became
161 nonstandard. But it developed I/O handling, disc handling, graphics
162 commands, and it grew to be a business language. It also sprouted
163 such strays as compilers, double precsion, and preprocessors for
164 structured programs. However, it is still based on Dartmouth's
165 simple training aid, and isn't very good at anything, especially
166 in the common interpreted versions.
167    If that wasn't enough, along came another TEACHING language,
168 called Pascal. Again, it was intended as a teaching language, so
169 it did not need (or allow) fancy I/O, or high precision. What's
170 worse, as it was intended to teach a strict, precise programming
171 style, it demands a strict style, and this can really get in your
172 way. <Why is it necessary to insert semicolons at the end of line?
173 -Because Wirth thought this would better instill the idea of 'end
174 of statement'; but 'end' does the same, and both can not be 
175 together.> Again, not a general purpose language. SO, it is being
176 IMPROVED. (Better known as 'not compatible'.)
177    There is no general purpose language. All we have are written-
178 down dinosaurs like micro COBOL, or 'improved' teaching languages
179 like BASIC. I hope ADA flies, it is supposed to be all things for
180 all people. ( But so was PL-1.)
181    Of course, I also use C, but it isn't really for use part-time
182 hackers. It was written for, and by high level programmers. It is
183 about as cryptic as APL. It is a structured language, and supports
184 good data structures, but is close to assembly language in many 
185 ways. For you FORTH advocates, it is extensible. However, it is
186 very unlike Pascal in one important respect: it is NOT a complete
187 system, but much more like a macro assembler. You use your own
188 text editor, your own operating system, and then build your program
189 out of small bits, each of which can be used later. A program in C
190 can be nothing more than a series of function names, all of which
191 are simply separate files, but here seem to be powerful, 
192 individualized commands that act like say, extended BASIC 'print'
193 statements, with formating. It is very free-form, and rather
194 than having the syntax checker in the C compiler, it uses a separate
195 program called lint to remove them, or tell you about them.
196 Unfortunately, no small, easy to use interpreter is available for
197 micros.
198 
199 Bend your mind around a book called "The C Puzzle Book" by Alan 
200 Feuer. The puzzles look simple, and in start that way, but..
201 
202 ......................................B.A.D........2:20/11-20-82.......
203 I just looked at DB, and must say I'm not impressed. Atari vs IBM?
204 Who's kidding whom? $200 vs $2000? In any case, if you can talk to
205 BWMS, you are using either a 23 bit computer (with 37 bit 
206 instructions) or a 24 bit computer. The world is not wholly micros.
207    In case you were wondering what computer is a 23 bitter, pick up
208 the telephone and listen to that hum you here. It probably comes
209 from a computer called 'ESS', if you are served by Ma Bell, and
210 that uses 23 bits. It's main memory consists of up to 12 'stores' 
211 of 131,072 words (only 44 bits per word, though) each. It's slow,
212 running at about 5.5 micro seconds, but even so it handles something
213 like 30,000 time share terminals called telephones. Part of the
214 advantage it has is called pipelining, in that is has 3 instructions
215 running at the same time. I suppose I should add that it runs 24
216 hours a day. Yes, I said 44 bit memory- 37 for instruction, and
217 Hamming error correction if needed. This all in electrically 
218 alterable PROM.
219    As to the lead Apple and Radio Shack have in sales, both IBM and
220 Sinclair expect to sell more units next year than either of the 2
221 above have in all history. I don't know about Atari, but I expect
222 it too will be in the millions, soon. 
223 ************ Look out, here come the Japanese!!
224 ....................................B.A.D...(again).......
225 ______________________________________________________________
226 regarding FORTRAN & COBOL as opposed to a combination of BASIC
227 & Assembly level routines. The reason why FORTRAN is better is
228 that you can do high-level math without taking weeks to get
229 all those machine language routines figured out! I've never used
230 COBOL (and don't have any real interest in it) so I can't say
231 anything about it. 
232 	Getting back to FORTRAN vs BASIC, I would rather spend
233 my time on the PROGRAM logic than on re-inventing an ARCSIN
234 function. BASIC is great for string-handling, but FORTRAN is
235 better for math. They're about even as far as I/O is concerned.
236 When BASIC's based on the proposed ANSI standard start hitting
237 the market (in 2-3 years!) THEN BASIC will be preferrable to 
238 FORTRAN. Right now, there aren't that many BASICs that allow
239 TRUE sub-programs & sub-routines!
240 _____________________________________________________________
241 I think that all this goes to show that the advantage or
242 disadvantage of any particular computer language (PROGRAM!!!)
243 depends entirely on what your application is.
244 Incidently, the Atari has Layered Interrupts to the
245 point that it capable of Multi-processing!!
246 To my knowledge, these levels of interrupts are
247 not available to its nearest competiters-Apple, TRS, Commodore, etc.
248 -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
249 /////////////////////////////////////////////////////////////////
250 
251 Here's my beef about Basic:  Presumably a 'teaching language'
252 should NOT teach bad programming habits, such as writing throwaway
253 programs.  It should teach organized, structured programs whose
254 function is provable, easily modifiable, easily understandable by
255 someone else, easily maintainable, etc.  Basic does none of these
256 things.  
257 	The advantage of a 'standard' is that everyone can design
258 to that standard and everything will be compatible.  That's the
259 advantage.  The disadvantage of a 'standard' is that it inhibits
260 (to some extent) imagination and invention.
261 	In most cases, the advantages outweigh the disadvantages.
262 
263 But with Basic, it has all the disadvantages of a standard, but
264 none of the advantages.  It's the worst of both worlds.
265 
266 //////////////////////////////////////////////////////////////////
267 ??????????????????????????/////\\\\\?????????????????????????????
268 Ah, folks, you seem to be missing, or ignoring the point, with all 
269 this comparison of apples and oranges.  Someone a few lines up made
270 the point that the best language was application-dependent.  Too
271 true.  ALSO, the best programming style is RESULT-dependent.
272     
273 There are some folks who write clever, imaginative, poorly structured
274 and unmaintainable code, and once the result is achieved, there
275 are OTHER folks who come along a use the ideas of the "sloppy"
276 "wizard" to create a marketable and/or maintainable product.
277   
278 Rarely will you find the person who can do what the wizard does, and
279 also produce really clean code.  And all the error-checking compilers
280 in the world won't help, because that wizard will either find, or
281 invent, another language which won't burden him with constraints.
282  
283 Let me modify the "can do" above -- many "wizards" could produce
284 clean code, but for (often irrational, absurd, and ludicrous) reasons
285 of their own, WON'T!!
286 
287 But this world needs Ataris and IBMs and Apples and DECs and DGs
288 and even etceteras, and wizards and suits and beards and nerds,
289 and it isn't even reasonable to expect anyone to be happy about it,
290 but I don't think it's unreasonable to expect most folks to be
291 aware of it.
292 ???????????????????????????????////\\\\??????????????????????????
293 
294 I second the thought.  People who think they have the right to
295 tell me how to write programs forget that it's my machine and I will
296 
297 write the code the way I feel like it.  I don't like 'structured' pro-
298 graming shoved down my thrat and if I wan't to use GOSUB's, I will.
299                                             the Phantom Glitch.
300    //////////////////// 11/20/82 ///// 22:00 /////////////////////////
301 Here are a few more thoughts based on the above comments. 
302 I noticed that there appears to be a confusion as to what BASIC
303 and PASCAL teach. It is even more interesting that they would
304 be passed off as worthless simply because they originally were
305 designed as teaching langauges. The very act of using a langauge
306 to teach something insures it continuance as a use langauge. It
307 takes time to learn new things, and if you learn with BASIC you
308 will stick with it until the need for something else presses you
309 into learning a different langauge. This is not a bad thing either,
310 if you know something very well, you will operate with it much better
311 then something you only know slightly. No one can know more then
312 one or two langauges completly (most don't even know the full extent
313 of the langauge they are defending). I read the comment about 
314 FORTRAN being such a great number cruncher above, but please keep
315 in mind that the original version of FORTRAN was no better then 
316 any of the other langauges in that respect. (The original FORTRAN
317 ran on a 4K machine!) 
318 Pascal was created to teach structured programing, and it does that
319 very well, but please don't try to confuse or compare that to a
320 langauge that doesn't because it obviously won't. Basic on the other 
321 hand was created to teach people about computers not about a particular
322 programing style, and again it does this very well. The reason behind
323 this is motivation. To program in PASCAL you must have a clear
324 understanding of what you want to do before you even put down any
325 code. This is a bit difficult to do if you don't even know what a
326 computer is let alone what to do with it. With BASIC I can get 
327 people to understand what the computer is doing just by have them
328 write a quick little program right there at the terminal. It may not
329 seem like much to most programers, but to be able to tell the computer
330 to say "hi" and have it do it within a 15 second learning time is
331 very impressive to someone new to the game.
332 About writing sloppy code (I.E. non-structured) verses clean code.
333 If you know what you want to do, Structured is nice, but if you 
334 don't know, then it just gets in the way. There is a two step
335 process when creating something new (and I mean really new, not a
336 different way to calculate pi to n decimal places.)
337 The first step has nothing to do with how it should be implimented
338 or used, it is simply the creation of the idea into a usable form.
339 any attempt to strucure or standardize this will get in the way. The
340 continuous mutability of the whole concept is what allows the 
341 creative idea to be generated to begin with. What we are trying to
342 come up with here is something new and different, not the best or
343 cleanest way to do it. The two are incompatible in the thought 
344 process. The problem with the program industry is that it is so
345 new that the second portion of the equation never has time to 
346 come into effect before the whole idea is replaced with something
347 else. You must have a stable concept in existance in order for it
348 to be cleaned up and standardized.
349 *** ANOTHER LONG AND WINDY COMMENT FROM CISTOP MIKEY *** 21 NOV 82 ***
350 ***************************************************************
351 I was considering the sloppiness of microcomputing programming
352 yesterday.  Example:  It is silly to use the edit function of
353 these computer systems to enter messages.  You should first
354 use a text editor to make the message (assuming, of course, it
355 isn't a spur-of-the-moment thought) and after logging on,
356 send the message by computer.  Fine.  You don't waste 10 minutes
357 of the SINGLE-USER system while everyone else is getting busy-
358 signals on prime time.  Great.  Except for one thing.  In other
359 systems, (I don't know about this system, yet, haven't tried)
360 the system loses characters at the beginning of the line.  But
361 why should it?  Suppose it loses 5 characters.  At 300 baud,
362 this is effectively 0.166 seconds of dead time, during which
363 a reasonable microprocessor can execute 166,000 instructions.
364 But if only 5 of these instructions were inputting from the
365 serial port, no characters would be lost!  The fault is not
366 with the hardware at all, but with the idiot who wrote the
367 software.  HE JUST DIDN'T STOP TO CONSIDER THE POSSIBILITY....
368 What about those Apple BBS's that don't support lower case,
369 control-s and control-q, control-c, etc.  Same problem.  The
370 person who wrote it just DIDN'T THINK ......
371 Until people learn to program their hardware to its fullest
372 extent, it will be wasted.
373 ********************************************************
374 I think you have a point.
375 The thing that I have noticed is that each
376 Micro computer Programmer has to spend a lot
377 of time reinventing the wheel. After the very beginning
378 basic stuff on learning the language you're using,
379 there's not much in the way of texts that really teach
380 you the ins-and-outs of your computer.
381 For instance: Atari's Player/Missile graphics are
382 well known, but nowhere have I seen a well organized
383 chart or tutorial on how to set them up!
384 The poor programmer has to depend on magazine articles,
385 $50@hr classes (if he can find them), or expensive software tutorials.
386 Or manuals that are cryptic to the point of incomprhensibility!
387 The situation seems to be the same for all the other
388 micros. Anything beyond the basics is almost non-existant.
389 It would seem to me that there would be a good market
390 for subroutines that could be adapted to many different
391 programs (and well documented!!!) to reduce the reinvention
392 of the wheel presently necessary.
393 <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
394 Yes, the results are often not as good as could be desired, but why
395 spend the time and effort to make it "better" if it works? The lost
396 charaters at the beginning of the line may be fatal to you, with your
397 "better" way of doing things, but to most of us, who cares? Use the
398 machine the way it was designed, in this case direct entry.
399 There are other possible reasons for imperfect code: price, space in
400 memory, and some of the flaws are called 'features'. Anything can be 
401 made better, but to make it work in the first place is the real work.
402 Unfortunately it is true that the teaching language is the one you will
403 probably continue with, but to say this is good implies a lack of
404 understanding of the programming process, versus learning to program.
405 Have you heard of the advantages of assembly language? One of them
406 is it's totally unstructured nature. The assets of FORTRAN, such as
407 arcsin, are almost totally duplicated in BASIC, if they seemed to be 
408 needed (arcsin wasn't). Don't confuse FORTRAN's advantages with those
409 of a compiler, either. There are BASICS that will do anything that
410 FORTRAN will, and even a few BASICS that will run on small micro.
411 That 4k quoted for the original FORTRAN wasn't bytes, either. (I
412 also suspect hard disc.) In any case why kill yourself for super
413 fancy code when quick and dirty works? The program worth maintaining
414 is pretty rare, especially when BASIC allows a new one to be written
415 in less time than the old one could be converted to do what you want now.
416 ................................................B.A.D................
417 The dropped charaters at the beginning of the line are not simple to
418 eliminate, because the are usually caused by the machine doing something
419 out of reach of the programmer. The Apple BBS's may be running BASIC, and
420 the workings of this are not under control of the porgrammer because he
421 used BASIC to avoid the unimportant (to his use) details, and the huge
422 investment in time and effort needed to duplicate the things BASIC does.
423 On this system, I suspect it is because the processor is busy with a time
424 dependent job: running the disc drive. There is always a better way, if you
425 are willing to add that additional cost. 
426 By the way, Mike, what did this thing cost? Would a few extra $100 dollars
427 in cost have any effect on it's existance?
428 Anyone planning multiprogramming on a micro should look into the cost
429 of running another processor versus the cost in time. At less than $5 for
430 most 8 bit processors?? An operating system capable of alowwing real
431 multiprocessing is bigger than most micros will allow. Special purpose
432 jobs, that run a few more or less parallel processes, yes,, but a micro
433 is just to slow to run more. Except maybe keyboard input with a spooler
434 to the printer. The slow jobs like printing have their advantages, too;
435 just like the commercial on TV, it's time to go pee and have a beer.
436 .....................................BAD, again 11-22-82/ 0220 am.........
437 Let's hear it for the best, most efficient code known: self modifying.
438 It's also probably the most used code in the world, because the ESS in
439 most every city in the US uses it, the same 10 or so instructions repeated
440 over and over again, except it modifies itself every 5 ms or so. This was
441 a nightmare to get running in the first place, but it works! It doesn't
442 need maintaining. Good code doesn't need to be understood by anything but
443 the machine on which it runs. The best computers in the world are totally
444 incomprehensible, self modifying gadgets. (If you doubt this, tell me how
445 your brain works.)
446 ##############################################################################
447 If that's the case, then the Atari's really great --
448 It can (in BASIC) modify its own code and then
449 continue running it. The Terminal program that
450 I am using does exactly that! -- In this case
451 it just deletes a bunch of Data statements so
452 that there is more room for Upload/Download.
453 But about reinventing the wheel: Almost all micros offer
454 redefinable character sets, but how many of these
455 redefined sets (software) do you see kicking around?
456 If you want Script (for instance) where are you going
457 to get it besides doing it yourself?
458 /\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\
459 I have a request for the story  of this system, so here goes...
460 BWMS was put together initially over a weekend (accually a friday night
461 and saturday) The total cost was $0.00 (el zipo) The entire system was
462 put together from junk box parts. The software is from a text editor
463 used for store and forward communications. (Putting data on a disk for
464 latter transmission to a computer.) It was designed for PNB in fact for 
465 transmittal of service records to thier computers at the end of the day.
466 The disk drive was a dud that was resurected from the junk heap. It had
467 some worn out brushes which I modified the motor to allow them to run a
468 bit more (they are still in there!) The second drive came later also from
469 the junk heap, it had a seized motor which I took apart and cleaned up.
470 The CPU is an obsolete board that was thrown away and I pressed it into
471 service. The modem is one of the prototype PCS modems that wasn't much
472 good for anything else (it won't work accousticlly). The case for the modem
473 is a cardboard box. The auto answer consists of a capactitor that is charged
474 by the telephone ring signal and then maintained by the received carrier.
475 (That is why you have to hangup to get BWMS to hangup.) The case for BWMS
476 itself was also from the scrap heap, it was a prototype case for anouther 
477 store and forward device. Only got the chassis, not the cover. The total 
478 time spent on BWMS (not counting times like now, which is entertainment
479 to me, and therefor of its own value) is about 5 days. I have had to 
480 repair the system 3 times. since it was created 2 years ago. The first 
481 time was to replace a known defective regulator (I was waiting for a good
482 one to show up in the junk box) The second time was when I blew out the 
483 RS232 drivers by accidentally dumping 120volts AC into them (my terminal was
484 at the other end of the house which has a floating ground which I now
485 know about the hard way). The final repair was after the OMSI computer fair
486 I had to oil the disk drive bearings because they were getting very noisy.
487 Even the phone line does not cost really, since I use it for myself when
488 I need it (thats why BWMS is busy sometimes.) BWMS just uses it when I'm not
489 The only cost that is truly used by BWMS is the electricity, which at 30watts
490 isn't exactly a stagering amount. Thats about $2.00 a month or $24.00 a year.
491 I feel that I get far more then that in entertainment value out of it.
492 As you can see, cost is an extreme importance to BWMS. If it costs anything
493 I don't do it, it has to be free. 
494 As to why BWMS drops chars at the begining of the line. The CPU used in BWMS
495 is a very low cost aproach, that means that EVERYTHING is handled by the
496 CPU, even disk accesses. The disk service time is extremly tight, and in
497 fact there is absolutly no time available for the CPU to do anything else
498 but service the disk. The trade off here is that a DMA controler isn't needed
499 to do the servicing which saves some bucks. 
500 If you really do want to send data to BWMS via computer you can do it by
501 waiting for about  a second after sending a line to BWMS. The first
502 line may require upto 2 second delay if you are not at the bottom of the
503 disk before you ask for the enter. Anouther way is to wait for each character
504 you send to be echoed back by the system befor continuing.
505 When in command mode wait for the '>' prompt. Then give the command.
506 Another note is that While CBBS also drops the first few chars (it is much
507 better now that it has a Semidisk (TM) ) The software was written with
508 computer upload in mind. In case you haven't noticed, it always sends a
509 control G (bell) When it is ready for a new line of data. Yes, the programers
510 do think when they write programs, it is just that there is more to a
511 computer then software, and until you have spent a couple of years dealing
512 with real time communications you don't know what a mess it really is.
513 It is not a cut and dry process, but rather a lengthy series of compromisses.
514 ****** The great and all powerless CISTOP MIKEY *** 22 NOV 82 ***********
515 P.S. Even the disks I use on BWMS are rejects, they are disks that won't format
516 on the back side, so I can't use them on my double side drives that I use in
517 my real computer.
518 ***************************************************************************
519 )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
520 Actually, some cute programming would allow no lost characters even
521 during disk access.  An actual sector transfer can occur in about 10
522 milliseconds, assuming just the transfer.  This is only one-third of
523 a character at 300 baud.  So just check the serial input just before
524 and after any disk sector transfer, and voila', no lost characters.
525 (keep a queue for later input to the actual bbs software).
526 Notice that this requires no DMA, interrupts, or anything else
527 special: just programming.  Even the cheapest computer could do it.
528 (And from the description above, this system would be close to
529 the "cheapest").
530 	Anyway, I just wanted to point out that hardware limitations
531 aren't limiting in every case.  
532 
533 	Continuing, it seems that many languages are hiding behind
534 the excuse of "Every language is best for certain uses."  That may
535 be true, but so is a nutcracker best for cracking nuts, but not
536 much else.  Question:  Is there anyone out there that prefers Basic
537 who learned it after, say, learning more than one other language.
538 (example: PLI, APL, PASCAL, LISP, FORTRAN, ALGOL, etc)  It seems
539 to me this would be highly unusual.  People who like basic tend
540 to have learned it first, and thus don't miss nearly all of the
541 features it lacks but the other languages include.   If you've
542 never heard of a 'local variable' you program around this lack.
543 You don't miss what you've never had.
544 If you must learn basic, learn it after a couple other languages,
545 at least so you know there are alternatives.
546 
547 ****************************************************
548 A HAMMER WORKS GREAT FOR CRACKING NUTS TOO, AS WELL AS FINGERS.
549 YOU WILL SELDOM FIND A GOOD MECHANIC USING A CRESENT WRENCH TO
550 DO A JOB, YET IT IS A VERY VERSITAL TOOL, IT CAN BE ADJUSTED TO
551 FIT ANY NUT, BUT THIS VERSITILITY IS EXACTLY WHAT THE PROBLEM IS.
552 THE WRENCH MUST BE ADJUSTED TO EACH JOB, AND THEN IT IS ONLY FAIR
553 AT PERFORMING THAT JOB, WHILE THE BOX WRENCH OR OPEN END OR RATCHET
554 CAN DO THE JOB EXACTLY THE WAY THE MECHANIC WANTS, SO HE CARRIES A
555 FULL LINE OF TOOLS TO DO THE JOBS INSTEAD OF A FEW 'ALL PURPOSE TOOLS'.
556 ******************************************************
557 In regard to the disk access time. I can tell you have never written
558 any cheap disk software, because it ain't that easy. The actual
559 time to do the sector write is 11.111...ect. milliseconds. 200ms
560 divided by 18 (sectors per track). However, this is only a small
561 portion of the problem. The cheap disk interface uses a 1771 disk
562 controler (they don't come any cheaper). One of the aspects of the 
563 1771 is that to write a sector you tell it that you want to write
564 one, and then immediatly try to start writting it observing the 
565 write status in the 1771. Sometime later the 1771 will tell you
566 that it is done. This can occur anywhere from the 11ms time stated
567 to 200ms later. This is because the 1771 is searching for the
568 sector to write to, but the computer doesn't know when it will find
569 it so it has to be instantly ready to transfer the data when the time
570 comes. Since the status loop needed to do this disallows doing anything
571 else we are stuck in the loop for as long as 200ms (possibly longer 
572 if it gets an error on the first pass.) 
573 The problem was solved in the later equipment by changing the hardware
574 to do the status checking via interrupts. This gave us about 10micro
575 seconds out of every 64microseconds to play with so that we could do
576 the que thing as you mentioned above. Please note that the hardware
577 had to be modified to do this! Also it caused some rather extensive
578 software to be writtten to support all this. A version of the device
579 was accualy created that could communicate at 19200 baud while receiving
580 to disk, but it required a programer who was an expert in the field
581 over 6 man months to impliment it and the ques ate up enourmous amounts
582 of memory. 
583 It is nice to say that anything can be done, but realistically, there are
584 limitations. They may be hardware, they may be cost, or they may be time, 
585 but they are there just the same. If the time and money warent it they can
586 many times be overcome, but the desision must be first made that it is 
587 worth it.
588 They ain't worms in that there can, they's VIPER'S!!!!!
589 As for languages, I started with Fortran (actually machine langauge but
590 that is not really a high level langauge.). I moved to Basic because I
591 found Fortran to be horibally lacking in decent string handling. I also 
592 found the real world interface to be wierd at best. As far as doing
593 actual computation it is OK, but there is more to computers then just
594 computing!
595 I also have a copy of JRT Pascal, It is amazing how much nicer a language
596 can get once it recognizes that there is something else out there besides
597 the computer. I still am not in love with something that tells me how to
598 wrtie code, but at least JRT is passibly usable.
599 USCD Pascal is another mater .. Bleahhhhhh !!!!!!!!!
600 As for 'local vars', SO? I don't find them that hard to do with out
601 for the things I do. They are a nice touch yes, but SO? By the way ther
602 are a couple of Basic's out there that even support 'local vars'.
603 ******* The first and last CISTOP MIKEY **** 23 NOV 82 ************
604 wHAT Hte fu)6 HAPpEN TO drIve a  ?? ?  ss UHlk;scbjr:
605 HaLO SpACE cAdeTS !!! MY hatS Off to Yuou and EAchg o   f
606 u.   Ach spine deh ...............................................
607 ................excuse me this the curator of the Franklin
608 insane asylum. One of my patients got a hold of our computer.
609 excuse us for any harm we may have caused. Ted P. Skimmer.
610 =============================================
611 Here's another programer who came to BASIC after other languages.
612 I started with FORTRAN, then COBOL, then SAAL, and assembly (Univac,
613 not 8080). I will take BASIC over any of the above, for the simple
614 things it will do. For time dependent things I would use something
615 that is compiled, or if necessary, assembly. The teaching languages
616 are not for real programming: even N. Wirth, who invented Pascal,
617 reccommends a different language called Modula II for real programming.
618 It often makes sense to have more than 1 version of a language, for
619 instance BASIC as both an interpreter and a compiler. I have several
620 versions of BASIC, and several Pascals, for instance. Each has it's
621 advantages, as well as problems. If I had time and energy enough I
622 would write an extended BASIC that would do everything; but then
623 noone else could use it (totally non-compatible and absolutely
624 incomprehensible) It would have to have relocateable code, local
625 variables, every imaginable function, calls by name, line number,
626 implication; a full screen editor;automatic variable lists, a spelling
627 corrector.it would run as a full compiler, but would compile as text was
628 entered, so it could run like an interpreter. Etc, etc.
629 A minor problem: how big would it be?? 20 or 30 Megawords???....B.A.D....
                                                                                            