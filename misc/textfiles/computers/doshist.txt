THE DEVELOPMENT OF DOS

Personal computers began appearing in the mid 1970's, initially as
hobbyist toys that didn't even have keyboards or screens.  The first
real one, named Altair by a magazine editor's 12-year old daughter who
liked a Star Trek episode that took place in that solar system, was
built around a jazzed-up calculator chip, the Intel 8080.

Produced as a do-it-yourself kit by a company called MITS, it came with
256 bytes of memory. Since it lacked a keyboard, you entered data by
flipping switches on the front panel in binary sequence.  Because it had
no screen, you had to decode the patterns of blinking lights it
produced.  And it didn't let you store data permanently.

Two teenagers, Bill Gates and Paul Allen, who had started a company
called Traf-o-Data to make Intel-based computers to measure how many
cars ran across a rubber hose stretched across the road, saw a picture
of the Altos on the cover of an electronics magazine and developed a
version of BASIC for it.  Gates upgraded AltairBasic later to include
primitive file and disk-storage abilities.

The pair changed the comapny name to Microsoft; by 1976 the industry had
progressed to the point where Gates was railing against software pirates
(although back then pirates were making copies of punched paper tape
rather than floppies).  A few years later Gates became the worlds
youngest billionaire.

Soon after the Altair introduction, some hard-driving salespeople became
the market leaders with their Imsai 8080, another Intel-based machine,
and the first computer aimed squarely at small businesses.  To let users
store data efficiently, Imsai developed a floppy disk drive whose motors
and circuits were run by a program called CP/M (Control Program for
Microcomputers), which had been licensed from Intergalactic Digital
Research - later shortened to Digital Research.  DR's Gary Kildall had
created CP/M while working for Intel, to scale down the PL/1 programming
language into a version that would fit on a microcomputer.  Intel hadn't
seen much value in this brand new CP/M thingy and had given Kildall all
rights to it.

The early versions of DOS owe quite a bit to CP/M.  In fact, things like
the .COM formats of CP/M and DOS and the basic system calls were so
similar that programmers could easily switch up from CP/M.  CP/M uses a
command interpreter called CCP (or Console Command Processor) and two
fundamental system files called BDOS and BIOS to handle files and I/O.
This arrangement is nearly identical to the DOS COMMAND.COM, IBMDOS.COM
and IBMBIO.COM system trio.  What was especially remarkable about CP/M
was that it took up only 4k of space.  DOS 1.0 doubled that and it has
been mushrooming ever since.

Chain store magnate and leathercrafter Charles Tandy tried
unsuccessfully to buy computers from Imsai, then ended up creating his
own system, the TRS-80, which contained a Zilog Z-80 chip, 4096 bytes of
memory, and came fully assembled rather than in a kit.  To shave a few
dollars off the price he designed it to work entirely in upper case
letters.  Customers snapped them up as fast as Tandy could make them.

What really kicked the microcomputer business into high gear, however,
were a handful of visionary renegades from California and Florida.

In 1976 Steve Wozniak and Steve Jobs, whose early careers included a
stint peddling "black box" devices to circumvent telephone toll billing
computers, bought some 6502 chips and built a few hundred copies of a
computer they christened the Apple I.  It too worked only in upper case
letters.  Their second-generation Apple II offered an optional floppy
disk drive, and sold several orders of magnitude more.  On reason for
its success was a revolutionary program called Visicalc.  Visicalc
turned Apple's little computer into a powerful financial analysis and
planning machine.

But not all operating systems run on all chips.  CP/M worked on the 8080
and Z80 chips but not on Apples 6502.

Microsoft's Gates and Allen moved to Seattle to write programming
languages for computers built around Intel and Zilog processor chips and
running CP/M. Dismayed that their languages woudln't work on Apples,
they considered translating them all to run on Apples proprietary
operating system, an arduous job.  Instead they joined the crowd,
licensed CP/M, and sold it along with an add-in board that had a Zilog
chip on it.  Apple owners could stick the Microsoft boards in their
computers and run any CP/M program.

But Apple was an 8-bit machine and Gates and Allen felt Intel's new
16-bit processors were the wave of the future.  So did a local board
maker called Tim Patterson who worked for Seattle Computer Products.
All earlier processor chips managed data in 8-bit chunks.  Intel's new
8086/8088 chips finally doubled the processor power.

Patterson's board had an 8086, and he needed a new 16-bit operating
system to take advantage of it.  Digital Reserach had announced that it
was going to tweak CP/M into a 16-bit version, but Patterson couldn't
wait.  In early 1980 he started work on one of his own design called
QDOS (Quick & Dirty Operating System) that was to become 86-DOS (or
SCP-DOS) and eventually just plain DOS. To make it relatively easy for
programmers to translate CP/M softwrae to his system, he retained
fundamental CP/M file management structures and mimicked the way it
loaded and ran programs.  Patterson then added a device known as a File
Allocation Table (FAT) which Gates had used in Altair disk BASIC, and a
few other refinements.

--------------------------------------------------------------------
DOS 1.0

In late 1980, IBM approached Microsoft and revealed that it was
considering production of its own 8-bit computer.  Vast helpings of
money, ego, pride and general corporate paranoia have tempered details
of this exchange, but the popular version is that IBM wanted Microsoft
to design a version of BASIC for its new machine that would be delivered
on a ROM chip inside the IBM chassis. Gates was happy to oblige and
wanted to do a whole raft of languages, as the story goes, but argued
that IBM should consider a 16-bit computer instead. When IBM asked who
made a 16-bit operating system, Gates is said to have suggested that IBM
contact Gary Kildall - and supposedly even dialled the phone to Digital
Research himself.

Here the tale gets very fuzzy.  According to the one telling it, when
IBM trooped down to see Digital Research the next day, Kildall's wife
and lawyer were hesitant to sign IBM's strict non-disclosure agreements.
Other stories had Kildall out flying his plane while IBM executives
waited impatiently for him to land.  Microsoft's own publications admits
that Gates and Allen had heard rumours that Kildall was about to buy a
version of BASIC from one of Microsoft's competitors and give it away
free with every copy of CP/M-86, which didn't exactly endear him to
them.

In any event, Gates and Allen bought the rights to Patterson's 86-DOS
for around $50,000.00 and proposed to IBM that Microsoft provide BASIC,
FORTRAN, Pascal, COBOL, an 8086 Assembler, and the 86-DOS operating
system for the new computer.  IBM agreed in November 1980, and on August
12, 1981 introduced the world to its new PC and its main operating
system, Microsoft's DOS 1.0, which IBM called PC-DOS.  At the
announcement, IBM announced that users would someday be able to buy two
competing operating systems: CP/M-86 or the UCSD-p System. But IBM
priced these much higher than DOS, and since they were late reaching the
market and received little support from other software vendors, they
went nowhere.

Computer hardware isn't useful without software. And IBM initially
didn't offer much software - EasyWriter, a bug-filled version of a
mediocre word processor; Adventure, a mainframe text game adapted to run
on microcomputers, a DOS version of VisiCalc, some artless business
software, a few Microsoft languages and one or two other packages.

The most powerful and popular programs back then - dBase II and WordStar
- ran only on CP/M systems.  One of IBM's highest priorities was to make
it easy for software vendors to translate programs from CP/M to DOS, and
it was smart enough to know that making it easy meant making the two
operating systems similar.

Many of the DOS features that todays users truly hate - such as overly
brief eight-character filenames with three letter extensions, terse
prompts like A>, and unfriendly or missing messages (such as the stony
silence in response to file deletions) were directly swiped from CP/M.
So were underlying structures such as File Control Blocks (FCB's),
Program Segment Prefixes, and reliance on CP/M's memory loading
addresses.

DOS did change a few CP/M quirks.  File lengths that were rounded off in
CP/M were reported precisely in DOS.  Some commands were turned around
to be more logical.  Programmers could treat I/O to peripheral devices
like printers and screens the same way that they handled files.  DOS's
variable record lengths made disk storage and retrieval far more
efficient.  DOS could load and run larger .EXE format files in addition
to the smaller CP/M-standard COM-format files which were limited to 64k.
And it could keep a program loaded but inactive in memory, so that users
could pop it onto their screens whenever they needed it .  DOS relied on
a FAT, first used by Bill Gates and Tom Patterson, to keep track of
where all the various pieces of a file were stored, and could read and
write more than one piece of data at a time, which speeded up disk
activity significantly.

DOS at least theoretically made it easier for programmers to create
their own version of the COMMAND.COM user interface, although none has
ever caught on. But the ability to run scripts of commands called batch
files became very popular. When DOS reported inevitable errors, it did
so in a slightly friendlier way than CP/M, and it handled severe
hardware errors far better. DOS also sniffed out new disks automatically
while CP/M forced users to log such changes manually, and it kept track
of the date files were created or changed.

It also split the COMMAND.COM interface into several parts, a mixed
blessing. When the PC was new, and IBM offered it with a maximum of 64k
memory, this feature was welcome since it let other space-hungry
software temporarily steal a few thousand characters of memory from DOS.
When the user was finished with the software he'd have to insert his DOS
disk in drive A: so that the part of DOS that hadn't been stolen could
reload the part that had.  Trouble was that a short time later users
were buying systems with ten times that much memory, and the amount of
space freed up by this technique was relatively insignificant. But
floppy disk users still had to contend with keeping a DOS disk handy to
reload the "transient" stolen part.

One of the worst things about the first IBM PC and its operating system
was that it could store only 160k of data on floppy disks that were
clearly capable of storing twice as much.  A standard floppy has two
usable sides, but the first PC - and DOS - could only use one.

The initial DOS release contained several nasty bugs.  In mid-1982, IBM
began shipping PC's with double-sided drives, and released DOS version
1.1 to handle the new storage abilities and to fix several of the early
bugs.  Microsoft then released its own generic upgrade which it called
MS-DOS 1.25.

The initial release of DOS was tiny and relatively crude.  Version 1.0
TIME and DATE commands were separate short programs rather than part of
the main COMMAND.COM interface.  While the DOS 1.0 directory listing
noted the date a file was changed or created, it ignored the time.  The
MODE command couldn't set communications speeds or protocols, or let the
PC's parallel printer adaptor work with the many serial printers on the
market.  The COPY command wouldn't join or concatenate several small
files into a larger one.  The onscreen messages and prompts were
especially ugly and cryptic.

DOS 1.1 fixed all these problems, or at least made them less irritating.
The biggest problem of all was that DOS was still constrained by its
CP/M heritage and its clanky internal structure.  And although IBM
doubled the amount of disk storage space from 160k to 320k, users found
this was far from enough.  They demanded disks that were faster and more
efficient.

----------------------------------------------------------------------
DOS 2.0

In March 1983, IBM announced its PC-XT, a beefed-up version of the
standard PC that came with three addtional internal expansion slots (for
a total of eight), a ten-megabyte hard disk, and a new version of DOS -
2.0.

The new hard disk - which IBM referred to as a fixed disk - could hold
the equivalent of more than 31 double-sided floppies.  But all that
storage space introduced a new problem.  DOS 1.0 and 1.1 had crammed all
the file information for each floppy disk into a single directory.  A
single-sided floppy had room for a maximum of 64 directory entries, and
you could fit only 112 on a double-sided diskette.

Keeping track of all the files on a hard disk meant coming up with a new
DOS file management and directory system.  CP/M had dealt with large
disks by splitting them (or partitioning) them evenly into smaller ones,
an inelegant and inefficient solution.  But UNIX, an operating system
developed by the phone company, could handle vast volumes of files with
relative style and ease. Microsoft had licensed UNIX, and was offering a
version of it called XENIX.  At the heart of UNIX/XENIX was a
hierarchical or tree-structured directory system that gave users lots of
flexibility in dividing up the available storage space.


Microsoft adapted this tree-structured system as the core of a
significant new incarnation of DOS - version 2.0.  But it blundered
slightly.  UNIX used a slash (/) to identify the subdirectory levels
that acted as branches on the tree structure.  But earlier DOS versions
used slashes as switches (command suffixes such as the /s in FORMAT /s)
that turned optional features on and off. Microsoft substituted a
backslash (\) to identify subdirectory levels, which eneded up confusing
a whole generation of DOS and UNIX users, and caused much consternation
abroad where foreign keyboards often didn't come with backslash
characters.

IBM and Microsoft also had to find a way to deal with an explosion in
the number and type of devices that manufacturers were stamping out for
the PC. One of DOS's main roles was to manage the communication between
the PC and anything else you could hook up to it.  If DOS had to contain
explicit internal tables and instructions for every possible device it
would end up being absurdly large and cumbersome.

Microsoft designed a new version of DOS with hooks in it so that
manufacturers of peripheral equipment could supply installable device
driver programs to hook the new hardware effortlessly into the operating
system.  Users could load these specific additional sets of instructions
into DOS as needed, through a special CONFIG.SYS file.  This file also
let users customise their systems by telling DOS how much memory it
should devote to disk buffers, how many files could be opened
simultaneously, and how frequently DOS should check to see whether a
user was hitting the Ctrl-Break panic button.  It also made it easy for
users to load a replacement command processor if they weren't planning
on using the standard COMMAND.COM, or tell DOS if they were storing
COMMAND.COM in an unusual place.  And it gave users extended screen and
keyboard control with ANSI.SYS, a special device driver supplied by
Microsoft in an unsuccessful attempt to standardise certain parts of the
user interface across different computer systems.

Version 2.0 introduced several new commands most users can't live
without.  Its hard to believe, but versions 1.0 and 1.1 didn't have any
way to clear the screen.  CLS now does it.  This version was also the
first to offer batch file commands such as ECHO, IF, FOR, SHIFT and
GOTO.

DOS 2.0 also introduced a raft of commands and utilities to give users
cintrol of hard disks although some, like the pathetic TREE command -
designed to "display the entire directory structure" are a bad joke.

Perhaps to compensate, IBM threw in a gem that has become a power users
best friend - the mini-assembler in DEBUG.  You can become an absolute
computer whiz without ever having to learn a single thing about hex
codes or assembly language.  But if you want to climb inside your system
and stomp on the gas pedal, there's no better way.  Its a lot easier
than you think.

One of the most significant changes in DOS 2.0 was the way it dealt with
files internally.  To remain compatible with CP/M, DOS 1.0 and 1.1 kept
track of critical file information with a device called a File Control
Block (FCB).  But as programs became more sophisticated they were forced
to manipulate the data stored in FCB's directly, which was awkward and
potentially dangerous.  And FCB's had no provision for subdirectory
names.

DOS 2.0 introduced file handles as an optional way to streamline disk
management.  Once DOS knew about a particular file in a partcular
directory, it could act on that file simply by using a two-character
shorthand code called a handle.  In addition, DOS established five
special handles that made it a snap to switch inputs and outputs.
Normally the keyboard and screen (which DOS collectively refers to as
CON:) act as both the input and output.  But DOS 2.0 let users
"redirect" input or output to or from printers, files or other devices.
And it allowed users to "pipe" streams of data through filters to do
things like turn uppercase files into lowercase, strip out extraneous
characters, or sort records into alphabetical order.

The sample filters DOS 2.0 provided are actually pretty useful.  They'll
let you slog through files and skim out the text you want saved or
discarded. They'll sort your directories (or any list of names, numbers,
or items that have carriage returns at the end of each entry) lightning
fast.  And they'll paue your displays for you so you'll never again have
text scrolling off your screen too quickly to read.

To top it off, DOS 2.0 provided rundimentary background processing.  DOS
was originally designed as a sigle-tasking operating system that let
users do just one thing at a time.  But the designers of version 2.0
threw in a PRINT spooler command that could print out one file while a
user was actively working on another.

While spoolers are nothing new, this one was.  Spoolers normally lop off
a big chunk of RAM and trick DOS into sending files to memory that were
really destined for the printer.  Then they wait for a quiet moment and
re-route the files onto your printed page.  When they're done printing,
however, they still hold on to all the memory they've hogged - very
inefficient.  The DOS PRINT command reads files off your disks and uses
your precious memory much more sparingly.  It watches how you work, and
about 18 times each second, if you're not doing something at that
precise moment, it sneaks a few characters at a time to the printer.
Your computer is so fast that this "time slicing" technique makes it
appear that it's doing two things at once, when it really alternating so
quickly you don't notice it.  And the best part is that if you happen to
be working on something that tales more of your computer's constant
attention than usual, you can adjust how frequently the spooler tries to
intercede.

In addition, DOS increased the number of 512-byte sectors from eight to
nine. While DOS kept the number of tracks at 40, this upped the storage
capacity of each disk from 320k to 360k.  DOS 2.0 also let users add
electronic volume labels to their disks, gave them access to part of the
memory called the environment, in which critical system settings were
maintained, made memory allocation more efficient, and threw in more
than two dozen new commands.

With so many changes and features, you'd think a brand new version of
DOS would be filled with insidious bugs.  And you'd be right.  In March
1984, a year after the PC-XT introduction, IBM released DOS 2.1 to
excise these software errors - and to handle a hardware error it
produced called the PC-Jr.

The less said about the PC-Jr the better.  While it provided more
colours onscreen in graphics mode than IBM's real microcomputers, and
came with three-voice sound that could play chords, it was utterly
non-standard inside and out.  In fact, it used such a cheap, flimsy disk
drive that DOS 2.1 had to slow down the drive performance so the thing
wouldn't crash.

What's especially sad about all this is that lots of users still rely on
DOS 2.1, which means they have to put up with unacceptably slow disk
access times even though the're using machines that could handle much
higher speeds.  A pity, and another good reason to upgrade to a more
recent DOS version.

Microsoft ended up producing versions 2.05, 2.11, 2.2 and 2.25 with an
added modicum of international time, date, keyboard and currency
support.  These may come in handy if you need to work with Korean
Hangeul or Japanese Kanji characters; today Microsoft sells DOS in more
than 60 assorted languages.

-----------------------------------------------------------------------
DOS 3.0 and Beyond

IBM's PC and PC-XT brought microcomputing into the mainstream of
American business. But these machines were both relatively slow and
small. In fact, they weren't really even true 16-bit computers. While an
Intell 8088 CPU ticked away inside each one, their system bus - the
connecting pathway of wires that ties the CPU to all other parts of the
system - was a bottleneck that worked in eight-bit chunks only.

IBM introduced its first genuine 16-bit system, the PC-AT. Compared to
IBM's earlier releases, this was a real rocketship of a computer. Inside
was an 80286 CPU with a trick up its sleeve - it could run everything
IBM and Microsoft could throw at it and it could also accomodate
Microsoft's ne operating system, OS/2. And it needed a new version of
DOS - 3.0.

Engineers measure computer performance in many ways. Two prime
indicators are the clock speed of the CPU and the average access time of
the hard disk. The faster the clock, the faster a computer processes
instrauctions and the faster just about everything runs. The speedier
the hard disk access time, the sppedier it can read and write programs
and data. The higher the clock speed and the lower the average access
time, the faster the system.

Both the PC and the PC-XT run at 4.77 MHz. IBM sold many different
brands of hard disks for the XT, and the average access time was
somewhere between 80 and 115 milliseconds.

The official clock speed of IBM's first AT was 6MHz, but users quickly
found out that by replacing a socketed $4 quartz crystal on the main
system board they could boost performance to 8 or even 9 MHz without any
ill effects. (IBM is famous for publishing ultraconservative
specifications and holding down performance a bit on purpose.) When IBM
discovered that users were hot-rodding their systems, they wrote a
program that acted as a speed governor and put it on a system ROM chip
to stop tampering.

All of IBM's AT hard disks ran at 40ms or better. Unfortunately, the
first big batch of AT's came with CMI-brand drives that crashed in
shockingly high numbers. Hard disks - rapidly spinning precision-crafted
aluminium platters with magnetic coatings on both sides - need precise
feedback on where their magnetic read/write heads are located. If the
location mechanism is off by even a tiny bit the heads can write bad
data over good or wipe out important tables that tell the computer where
files are stored.

Hard disk heads actually "fly" on a cushion of air directly above the
surface of the platters themselves. All decent hard disks retract or
'park" the magnetic heads when the power goes off so they don't sink
down and plough furrows into your data. To save money, CMI disks used
what many believe was an unreliable implementation of "wedge servo"
technology. Most other hard disks used a dedicated positioning surface,
a whole side of a hard disk platter contained no data and instead acted
as a map to those that did. But not CMI's AT drives. And these drives
didn't park the heads when you turned the power off. The heads just
dropped down onto the data and scarped against it.

IBM never really admitted doing anything wrong, but tens of thousands of
users know different. If this black episode in computing history had a
silver lining, it was that it taught hard disk users how absolutley
imperative it is to make frequent and comprehensive backup copies of
their work.

In any event, a PC-AT running at 8MHz was 67 percent faster than a
standard PC or PC-XT. The PC-AT hard disk was twice as fast as the
speediest XT disk drive, which made everything seem a lot more
energetic, and ended up turbocharging disk-intensive applications such
as database searches. On top of all that, the PC-AT could deal with
memory in 16-bit chunks, while the PC and PC-XT had to lumber along with
half that amount. Clone makers soon started producing respectable AT
imitations that chugged along even faster. To avoid falling behind the
competition too much, IBM eventually had to nudge the performance upward
slightly each time it refined the AT design.

IBM's newest PS/2 line of hardware and many high-performance clones on
the market make even the fastest AT look like its standing still. With
CPU sppeds of up to 25MHz, hard disk access times in the high teens, and
a 32-bit bus that moves data four times as efficiently as the one in the
original PC, these hot new micros give refrigerator-sized minicomputers
a good run for their money.

The PC-AT was originally delivered with a 20-megabyte hard disk,
although subsequent versions have enhanced both the speed and capacity
of its hard disk. Still, 20Mb storage meant that backin it all up would
take 56 standard 360k floppies. The mind reels. Apparently, so did
IBM's. It dropped a quad-density floppy disk drive, with 1.2Mb capacity
into each AT. IBM refers to these as high-capacity drives. Unhappy users
have called them something else, unprintable here.

The PC-AT's new DOS, version 3.0, could handle the increased floppy disk
storage. But it also had to understand every other floppy format. In the
space of six years IBM had introduced single-sided and double-sided
drives, with eight or nine sectors, and in double or quad density, so
downward compatibility meant having to deal with:

         * 160k single-sided 5.25"
         * 180k    "         "
         * 320k double-sided "
         * 360k    "         "
         * 1.2M    "         "

Well, there's compatibility and there's compatibility. Out of the 25
different possible combinations of using the DISKCOPY command to move
information from one to the other, 16 won't work.

What's more, IBM's PS/2 hardware uses 3.5" diskettes, a whole new ball
game. These smaller diskettes are sturdier, easier to transport, and
vastly more efficient at storing information. IBM characteristically
complicated matters by producing two different and slightly incompatible
3.5" disk formats, one that holds 720k and one capable of storing 1.44Mb
of data.  The 5.25" 320/360k format won't go away very quickly, since so
many vendors have made it the standard for program distribution.  But
the PC-AT's 1.2Mb drive and the low-end PS/2 720k diskette are orphans.

         * note: This is US. 720k was very popular in NZ.

All IBM microcomputers gave users a clock and calendar that could stamp
DOS directory listings with the time and date files were created or most
recently updated.  But users had to set the clock each time they started
their systems, unless they had purchased an add-in board with a
battery-driven clock on it (and most did).  The PC-AT came with its own
internal battery run clock/calendar, but it wasn't until DOS 3.3 taht
users could reset it easily.

Program developers live by a rule: "The software is never finished."
Each release of DOS or any commercial application is quickly followed by
a version with bug fixes, sppedups, and forgotten utilities.  Market
considerations force manufacturers to ship everything at the earliest
possible date.  Microsoft officially admits that DOS 3.0 "wasn't quite
ready" at the introduction of the PC-AT.  But it went out the door
anyway.

Today, virtually every desk in America has a telephone in one corner.
IBM's vision of the future puts a computer terminal next to it, and
strings all the terminals together electronically.  Networking computers
this way has lots of advantages.  It lets users "mail" messages and
files to each other, and share centralised databases of information.
Networks can also let users share expensive peripherals like plotters or
laser printers, but it doesn't make much sense installing three $1500
network hookups to share one $1500 laser printer. Today networks are
interesting to a minority of users only - although the number grows as
the costs and headaches associated with using them are reduced. Networks
introduce their own special set of problems.  Two users may reach for
the same database records at the same time, and something has to mediate
the conflict.  Worse, giving users access to centralised information
means someone has to decide who gets access to what.  And then something
has to keep track of the authorisation levels and enforce it all, and
make sure the right data is routed to the right place.

Microsoft designed DOS version 3.0 to support the official IBM PC
network hardware.  Unfortunately, the AT was ready before the network
features of DOS were, and the Microsoft designers had to deactivate
these features in the final product.  They finally turned them back on
again in version 3.1, released in November 1984.  But DOS 3.1 was picky;
it would handle only certain well-behaved networks.

DOS 3.0 introduced a streamlined method for integrating FCB's and
handles. And while it provided a small handful of new features, none was
a radical departure from DOS 2.1. In fact, IBM stated in its
documentation that "DOS 3.0 does not replace DOS 2.1". But it did fix a
nasty 2.1 oversight, by making it harder for users to format their hard
disks if they weren't careful. (It wasn't until version 2.0 that DOS
even asked for confirmation if users tried to delete all the files on
their disk with a single ERASE *.* command.) Version 3.0 also let users
make files read-only to prevent any inadvertent changes or deletions.

Version 3.1 provided better "aliasing" features to combine drives and
directories and to trick DOS into treating a subdirectory like a disk
drive. DOS 3.2 introduced users to 3.5" diskettes (although the tools it
provided to do this were downright awful), made it easier for them to
upgrade DOS versions, and gave them one of the best but least-used new
commands, XCOPY.

DOS 3.3, tossed off by IBM pitchment at the introduction of the PS/2 as
an "interim solution" and the operating system for a string of dogs
including the PC Convertible, Portable PC, and PC-Jr, deftly excised a
heap of user headaches, and added a few sizzling new tricks.

As all seasoned hard disk users are aware, working efficiently on a hard
disk machine means pigeonholing related programs and data in electronic
file drawers called subdirectories. But users who are currently working
in one subdirectory often want to execute a program or look at data
stored in another.

Since version 2.0, users had been able to tell the PATH command to check
specified subdirectories for executable files (with filenames ending in
COM, EXE or BAT). This let users run programs in other subdirectories,
but it didn't let them get at distant data. Nonexecutable files remained
immune to even the most comprehensive search, forcing power users to
purchase commercial "path extender" programs, or struggle with the DOS
3.1 SUBST command.  The DOS 3.3 APPEND command made this process
relatively easy - and a lot cleaner.

Serial ports are your system's main gateway to the world.  Version 3.3
let MODE cruise along with four serial ports rather than two (OS/2 can
use 8) and cruise along at 19200 baud, double the previous limit.  And
IBM finally recognised that at least twice a year users need to reset
their internal IBM clocks and provided a way of doing this without
hunting down their Diagnostics disks, figure out which option adjusts
the time, and grind through all the irritating preliminary screens.  The
3.3 TIME and DATE commands automatically adjusted IBM CMOS memory to
reflect the change.

Another improvement was the newfound ability of the DOS 3.3 ATTRIB
command to gang-process all files within a directory and its related
subdirectories, which made it easier to create backups and prevent
inadvertent file deletions or changes.  Unfortunately, the same process
used by ATTRIB can also hide files from casual snooping, but IBM's
manual won't show you how.

The original DOS architects preferred working with 512-byte disk
sectors, and used a FAT to keep track of what data was in which sector.
When they designed the FAT they used 16-bit addresses, which allowed a
maximum of 65,536 (64k) table entries.  This clamped a firm 32Mb limit
on the size of any physical hard disk (512 x 65,536 = 33,554,432 bytes).
To get around this limit, manufacturers either had to increase the
sector size, which made their hardware non-standard and relatively
wasteful, or come up with an entirely new file management scheme, which
ended up being even more non-standard.

IBM tuned DOS 3.3 to divide physical hard disks into smaller "logical"
drives, and fixed the FDISK command to create extended DOS partitions in
addition to the primary ones they were able to carve out previously.
Each extended partition could be further subdivided into logical drives
32Mb or smaller, with their own drive letters.  Compaq quickly made it
even easier to use enormous hard disks, by introducing DOS 3.31 that
boasted 32-bit FAT addresses.

To expedite directory searches with the new generation of larger hard
disks, DOS 3.3 provided a filename cache utility called FASTOPEN.
Caches keep track of things in memory rather than on disk, which speeds
many processes up significantly.  FASTOPEN notes the location of files
and subdirectories (which are really just special classes of files) the
first time you hunt for them, and then directs DOS to the exact spot on
the disk the next time you have to deal with them.

The DOS BACKUP command had always been so pathetic that an entire
industry of third-party backup software has evolved to fill the gap.
While the version 3.3 enhancements aren't going to put those developers
out of business, they will bring some users back into the fold.  Under
previous DOS versions you had to format a tall stack of disks before
strating the backup process.  If you ran out of formatted disks halfway
through you had to abort and either find a way to catch up, or start the
whole elaborate, time-consuming procedure all over again.

In DOS 3.3 the BACKUP command can summon the FORMAT command and prepare
unformatted disks if necessary - with certain irritating restrictions.
And you have to limit the disks and drives you use; it still can't mix
and match.  The DOS 3.3 BACKUP works faster and more efficiently than
older versions, by copying all smaller files into a single enormous one,
and by creating a guide file that tells DOS how to take the big file
apart and restore it properly again later.  It also creates a log file
telling you what it did where.

The DOS 3.3 RESTORE gives you added flexibility in restoring backed-up
files by date and time, as well as those deleted or changed since you
last backed up, or files that are no longer on the target disk.  Better
yet, while older versions of RESTORE let you accidentally obliterate
your system files (IBMBIO.COM, IBMDOS.COM and COMMAND.COM or their
MS-DOS counterparts) with older backed-up versions, DOS 3.3 RESTORE
won't.  Inadvertently mixing versions of hard disk system files is like
replacing a heart surgeon in the middle of an operation, with a tree
surgeon.

Batch files can take the anguish out of tricky or repetitive tasks.  The
first thing most power users do when they create a batch file is turn
off the display by issuing an ECHO OFF command.  This stops DOS from
littering your screen with the frantic prompts, messages, and other
electronic graffiti a batch file generates.  But users had no authorised
way of preventing this ECHO OFF command from adding to the screen
clutter itself.  Version 3.3 users can prevent such clutter simply by
prefacing any command with an @ symbol.

in addition, DOS 3.3 could CALL one batch file from within another,
execute it, and then return to the original batch file and continue
executing it.  Doing this kind of "nesting" under previous versions of
DOS meant that each batch file had to load its own separate version of
COMMAND.COM to do its work, exit, and drop back to yet another version -
which was sort of like restarting a movie every time a latecomer walked
into the theatre.  DOS 3.3 also documented environment variables for the
first time, which let users pass information back and forth from
application to application.

DOS 3.0 to 3.2 came in five international flavours. By executing the
appropriate KEYBxx command, users could transform the keyboard into
British, German, French, Italian or Spanish modes.  With version 3.3,
IBM totally revamped the way DOS handled foreign alphabets.  IBM's
manuals have gotten a bit better over the years, but the three abtruse
and seemingly contradictory chunks on this international support
virtually defy comprehension.  IBM prefaced its long appendix-like
treatment of the topic with the caveat "You can use code page switching
without fully understanding everything about it." After poring over the
text, you'll know why this was included.  And if you live in the United
States, you'll take one look, put your hand over your heart, and say,
"Thank God we're Americans."

For the first time, DOS 3.3 set a default number of disk buffers based
on your system's configuration.  Under previous versions, it assumed
evert PC and XT user really wanted only two and every AT user only
three.  DOS will now sniff out what hardware you have available, and
allocate from two buffers (minimal RAM, no hi-density floppies, 3.5"
diskettes, or hard disks) to 15 (and machine with more than 512k of
RAM).  If you're using a big hard disk, you may want more than 15.
Better yet, try a commercial file cache program.

The Future

IBM and Microsoft continue to add and adapt messages and prompts; the
infamous and ubiquitous DOS error message "Abort, Retry, Ignore?" became
a more chilling "Abort, Retry, Ignore, Fail?" under DOS 3.3.  This isn't
exactly friedly.  When Microsoft originally designed DOS it published
all the specifications so that other manufacturers could replace the
COMMAND.COM user interface with something different, such as a visual
shell.  Several amateurs have tried, but nothing has come of it.
Microsoft itself tried an easier interface called WINDOWS, but users
have resisted, calling the interface overly large, ungainly, and slow.
Microsoft and IBM have adapted Windows as a graphic front-end called
Presentation Manager for OS/2.

DOS needs all sorts of help; way back when the EGA was first introduced,
for instance, users complained that the MODE command couldn't deal with
any of the new graphics settings, such as 43 or 50 lines of text, or the
far better colour selection.  Now that VGA is becoming the norm, DOS
still doesn't directly handle anything better than CGA.

(PC-DOS 4.0 and 4.01 have been released since this was written; MODE now
supports high resolution text displays and multiple serial ports.
However few users have switched to 4.0 or 4.01 in New Zealand,
particularly after the OS was slammed by the foreign press as being full
of bugs, inconsistent in its user interface, and a memory hog.  Some
Wellington BBS users have successfully changed to DOS 4.01, and have
experienced no real problems in their non-demanding environment.  Most
users with only 640k will probably prefer to stick with DOS 3.2 or 3.3,
and those with large disks to 3.31.)

[And since *that* was written, most new computers are sold with a 40MB
disk minimum and DOS 4.01. The product is now quite stable. DOS 5.0's
release is imminent.]

----------------------------------------------------------------------
Downloaded from The Cave III, where the SysOp had uploaded it.  Don't
know whether he wrote it, or found it somewhere, but it's not bad!
