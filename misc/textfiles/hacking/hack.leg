 NOVEMBER 7, 1990                                   C:\TEXT\NETWORK1.TXT

                    A PROPOSAL TO JOIN THE CORPORATE WORLD
                         AND THE COMPUTER UNDERGROUND
                       WITH A PEACEFUL, LEGAL SOLUTION

                                by FATAL ERROR

    I have conceived an idea that will change the way the world will view
computing. It's simple, middle of the road, inexpensive on an individual
basis, and best of all will provide:

    1) An alternative to _illegal_ hacking.
    2) A venting ground for authors of destructive viruses.
    3) A cyberspace home for cyberpunks.
    4) Pirates with a source of unlimited COOL warez.
    5) Shockwave riding phreaks something new to explore.

    Sounds too good to be true doesn't it?  Perhaps I may be wrong in
thinking that what I'm about to propose might divert the energies of
thousands of potential criminals. I'll let you be the judge.  Before I begin
I'll ask the audience not to heckle or laugh at my naivete or blatant
ignorance.  What I am attempting here is to offer _ANY_ solution.  Our
nation is wasting millions to find ways to prosecute our own finest minds.  I
don't know why they don't spend all _OUR_ money installing public mainframes
so us less-daring types have something to hack too.  But I guess politicians
have different priorities than I do.

    The public was introduced to the game called CORE WARS in the March, 1984
issue of Scientific American.  A.K. Dewdney, the author of the much-missed
Sci Am column Computer Recreations, has been accredited as being the
grandfather of the modern computer virus for describing this harmless game.
While it is true he heard rumors of actual core wars occurring and, assisted
by a student, created a harmless game called CORE WARS, he is NOT the
grandfather of the modern virus.  Again, the media in all their glory can't
even get this simple fact straight.

    CORE WARS is a game in which two gladiator programs are let loose in a
set block of memory to battle each other to the death.  The object for each
program is to either kill the other program or survive long enough for it's
opponent to commit accidental suicide.  In the pc-based public domain version
that I use, there are 4,000 memory locations allocated in a continuous loop.
Once you reach location 3,999 the next location is address 0, then 1, then
2 and so on.  There is an instruction set comprised of only nine commands.
This is all the CORE WAR programmer has to work with:

    1. MOV (Move)s the contents of one address to another.
    2. ADD (Add)s the contents of one address to another.
    3. SUB (Subtract)s the contents of one address from another.
    4. JMP (Jump) transfers control to a new address.
    5. JMZ (Jump if zero) transfers control to address A if contents of
           address B are zero.
    6. JMG (Jump if greater) transfers control to address A if contents of
           B are greater than zero.
    7. DJZ (Decrement, jump if zero) subtracts 1 from B and transfers control
           to address A if B is zero.
    8. CMP (Compare)s contents of A and B. If they are unequal, then skip
           the next instruction.
    9. DAT (Data) A nonexecutable statement, used to store values.

 Note: The preceding list was a close reproduction of one shown in Sci Am,
       March 1984.

One clever killer program, called IMP, requires only one instruction:

    MOV 0,1

All addressing is done relative to the instruction, so this simple program
copies what is 0 addresses away (itself) to the location 1 address ahead
making itself the next instruction to be executed:

    MOV 0,1    <-- first executed, copies itself to next address
    MOV 0,1    <-- next address, when executed it will copy itself again
    MOV 0,1    <-- You can see it never stops.

This program wins by simply running over competing programs!

    Needless to say the CORE WAR programs are useless if someone were to
attempt to run one outside the game arena. Only the CORE WAR supervising
program understands the code, your computers microprocessor WILL NOT!  Just
in case you do not understand how safe this is, I will create an analogy.

    Suppose I wanted to write a programming language for children that would
display geometric figures on the screen.  I would want to keep it simple so
they could understand it. Most helpful would be instructions that use plain
English, Ie.

       DRAW A BIG SQUARE IN THE TOP LEFT CORNER OF THE SCREEN
       DRAW A MEDIUM CIRCLE IN THE MIDDLE OF THE SCREEN
       DRAW A LITTLE TRIANGLE IN THE BOTTOM RIGHT CORNER OF THE SCREEN
                                   or even
       DRAW A CHARTREUSE DODECAHEDRON IN QUADRANT III WITH REFRACTIVITY EQUAL
        TO THE SPEED OF LIGHT DIVIDED BY ONE ASTRONOMICAL UNIT
       (yea, so what if the result is in time, not a refractive index,
        you have to remember these are children we're dealing with)

    The child would type these simple instructions into a text file.  The
child would then run my program that would interpret the instructions and do
as they commanded.  As you can see there are no instructions that would allow
a devious little first grader to format the hard drive or start a thermo-
nuclear war.

    The only way a program could be harmful is if there are instructions that
allow it to do harmful things.  If you write a language that does not allow
access to any sensitive areas of the computer, nothing can be directly
ruined. (I said 'directly' because I know one of you boneheads would prove me
wrong or die trying).

    Now I'd like to mention The Connection Machine, also fascinatingly
described in Scientific American (I can't remember which issue and it isn't
on my photocopy).  The Connection Machine is a parallel processing computer
that utilizes 65,536 microprocessors to execute several BILLION instructions
per second.  (Doesn't that make your jaw hit the floor)?  The Connection
Machine uses a Boolean n-cube pattern to connect its 4,096 switching devices
so any one processor of the 65,536 can communicate with ANY other using 12 or
less connections.  I am not a mathmatician by any stretch of the imagination
and I wouldn't even know where to begin mapping out this pattern, but I know
there's plenty of you out there that can.  My understanding of a Boolean n-
cube is as such: Take a line, it has one dimension, pull the line
perpendicular to itself and you have a square, with two dimensions.  Pull the
square perpendicular to itself and you have a cube.  A line is a Boolean 1-
cube, the square a 2-cube, a cube a 3-cube.  It is beyond this point I get
lost because I have trouble imagining any more than three dimensions.  But if
you pull that cube perpendicular to itself, you have a boolean 4-cube.  The
n-cube used in the Connection machine has 4,096 corners! I can't even begin
to fathom that.  All I am certain of is that it works.

    I'm going to borrow a few cups of CORE WARS and a tablespoon of Boolean
n-cube to begin rolling my own network of personal computers.  The operating
system would be a CORE WAR type supervisor, managing programs written with a
unique command set designed for this new environment.  Using the boolean n-
cube pattern to connect each pc in the network through the phone lines we
create an arena in which millions of programs can run wild and free.
(Imagine using Connection Machines to do this)!!!  The amount of coding
involved in developing a universe would be phenominal but you don't mind do
you?  It would probably start out a bit anarchic, certain individuals
spending all thier waking hours writing programs to kill other programs or
bringing pathways to a grinding halt.  But ingenious creative types would
develop antibody code that would drift around looking for and stopping such
devious programs.  Imagine if something like the IMP program mentioned
earlier were set loose.  All I would have to do, as a sysop of my node, is
write a subroutine to watch for that particular menace and stop it.  As cpu's
get faster, cheaper, better, we would spend an amazingly little amount of
time with such garbage collection.
     If we are successful, any one computer would be quickly accessible
through many possible routes from any other computer in the network.  If one
route is clogged by file transfers, another can be used.  Essentially what
would be created is the cyberspace everyone is dying to get into (sorry,
can't jack in yet).  Hackers would have the time of their lives writing
programs to do things smaller, better, faster, unheard of, etc.  Pirates
would be able to collect the clever hacks and trade with other pirates or
reveal new findings to hackers.  Phreaks would have the time of their lives
exploring the realm.  And for those shockwave riders out there, perhaps a
dial-up access where code can be written by punching in digits on a push-
button phone.  Completed programs or retrieved data could be read back to
push-button hackers via speech synthesizer.

    Programmers could create new commands or functions and make them
available on their node. Anyone wishing to use them could transfer their
program to that node to run. Let's say I create a function that calculates pi
to the tenth decimal place and you NEED to multiply some number by pi with
ten digit accuracy. You simply transfer your program to my node, multiply the
numbers, store the result in a data location within your program, then
transfer your program back to were you want it.  You could even make your
program spawn a small subroutine that would be transferred, perform the
function and return with the data WHILE YOUR PROGRAM CONTINUES RUNNING WHERE
IT IS!!!  Popular or widely used functions and commands could then be added
to nodes as the node owners wish.  If the owner deems a function or command
to be dangerous or not very useful it would be his right to not provide it.
Nobody would care, they can always use the function where it is provided, no
big deal.  Cyberspace realms such as this could be run separately until the
numbers work out right to connect the realms according to a larger Boolean n-
cube pattern.

     Each node would be privately owned.  I understand that having a computer
with twelve or more phone lines would cost a bundle, but it isn't beyond the
reach of dedicated hobbyists who could divide the cost among node users.

     It had entered my mind that the companies who own hacked mainframes
could provide nodes for public use to deter the curious from their business.
I'd be stupid to think that illegal hacking would end, but at least this
cyberspace realm would supply sufficient intellectual stimulation for the
extremely curious.

     Some companies may see this as extortion; "Put up a node or else", may
seem to be the message they receive.  But that simply is not what I'm
suggesting.  Companies donate services and property to communities all the
time.  Sometimes those services are oriented toward keeping kids off the
streets, away from crime and drugs.  Why not a cyberspace node?  Hell man,
it's a dirt cheap solution to a growing problem.  Like Wilfred Brimley would
say, "It just makes sense"!  A dozen dedicated lines and a fast pc wouldn't
even dent their data processing budget. Oh, and maybe hire some schmo to be
sysop of the node, but why bother when there are thousands of volunteers?

    Okay, so there's the idea.  I tossed the ball out for all to play.
Unless you are brain dead you can see there are limitless AI developments in
an environment like this, endless hacking to be done, infinite exploration
and discovery, and best of all it's all LEGAL!!!

                          YOUR ONLY ENEMY IS APATHY
                                                               -FE
????????????????????????????????