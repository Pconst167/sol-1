
		UNIX FOR BEGINNERS SECOND EDITION

                     Brian W. Kernighan


                     Bell Laboratories

               Murray Hill, New Jersey 07974



                          _A_B_S_T_R_A_C_T


       This paper  is  meant  to  help  new  users  get
     started  on  the  UNIX*  operating   system.    It
     includes:

      o+basics needed for day-to-day use of the system -
       typing  commands,  correcting  typing  mistakes,
       logging in and out, mail, inter-terminal commun-
       ication,   the   file  system,  printing  files,
       redirecting I/O, pipes, and the shell.

      o+document preparation - a brief discussion of the
       major  formatting  programs  and macro packages,
       hints  on  preparing  documents,   and   capsule
       descriptions of some supporting software.

      o+UNIX programming - using the editor, programming
       the shell, programming in C, other languages and
       tools.

      o+An annotated UNIX bibliography.



_I_N_T_R_O_D_U_C_T_I_O_N


  From the user's point of view, the UNIX  operating  system

is  easy  to  learn  and  use, and presents few of the usual

impediments to getting the job done.  It is  hard,  however,

__________________________
* UNIX is a Trademark of Bell Laboratories.



                     November 16, 1985






2                                         _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


for the beginner to know where to start, and how to make the

best  use  of the facilities available.  The purpose of this

introduction is to help new users get used to the main ideas

of  the  UNIX  system  and  start making effective use of it

quickly.


  You should have a couple of other documents with  you  for

easy  reference as you read this one.  The most important is

_T_h_e _U_N_I_X _P_r_o_g_r_a_m_m_e_r'_s _M_a_n_u_a_l; it's often easier to tell  you

to  read  about  something  in the manual than to repeat its

contents here.  The other  useful  document  is  _A  _T_u_t_o_r_i_a_l

_I_n_t_r_o_d_u_c_t_i_o_n  _t_o  _t_h_e  _U_N_I_X _T_e_x_t _E_d_i_t_o_r, which will tell you

how to use the editor to get text -  programs,  data,  docu-

ments - into the computer.


  A word of warning: the UNIX system has become quite  popu-

lar, and there are several major variants in widespread use.

Of course details also change with time.   So  although  the

basic  structure  of UNIX and how to use it is common to all

versions, there will certainly be a  few  things  which  are

different  on  your  system from what is described here.  We

have tried to minimize the problem, but be aware of it.   In

cases of doubt, this paper describes Version 7 UNIX.


  This paper has five sections:


  1.Getting Started: How to log in, how to type, what to  do

  about mistakes in typing, how to log out.  Some of this is

  dependent on which system you log into (phone numbers, for



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                         3


  example)  and  what terminal you use, so this section must

  necessarily be supplemented by local information.


  2.Day-to-day Use: Things you need every  day  to  use  the

  system  effectively:  generally  useful commands; the file

  system.


  3.Document Preparation: Preparing manuscripts  is  one  of

  the  most common uses for UNIX systems.  This section con-

  tains advice, but not extensive instructions on any of the

  formatting tools.


  4.Writing  Programs:  UNIX  is  an  excellent  system  for

  developing programs.  This section talks about some of the

  tools, but again is not a tutorial in any of the  program-

  ming languages provided by the system.


  5.A UNIX Reading List.  An annotated bibliography of docu-

  ments that new users should be aware of.


_I.  _G_E_T_T_I_N_G _S_T_A_R_T_E_D


_L_o_g_g_i_n_g _I_n


  You must have a UNIX login name, which you  can  get  from

whoever  administers your system.  You also need to know the

phone number, unless your system uses permanently  connected

terminals.   The  UNIX  system  is capable of dealing with a

wide variety of terminals: Terminet 300's; Execuport, TI and

similar  portables;  video  (CRT) terminals like the HP2640,

etc.; high-priced  graphics  terminals  like  the  Tektronix


                     November 16, 1985






4                                         _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


4014;  plotting  terminals like those from GSI and DASI; and

even the venerable Teletype in its various forms.  But note:

UNIX  is  strongly oriented towards devices with _l_o_w_e_r _c_a_s_e.

If your terminal produces only upper case  (e.g.,  model  33

Teletype,  some  video and portable terminals), life will be

so difficult that you should look for another terminal.


  Be sure to set the switches appropriately on your  device.

Switches  that  might need to be adjusted include the speed,

upper/lower case mode, full duplex,  even  parity,  and  any

others  that  local  wisdom advises.  Establish a connection

using whatever magic is needed for your terminal;  this  may

involve  dialing  a  telephone  call  or  merely  flipping a

switch.  In either case, UNIX should type ``llllooooggggiiiinnnn::::'' at you.

If  it  types  garbage, you may be at the wrong speed; check

the switches.  If that fails, push the ``break'' or ``inter-

rupt''  key a few times, slowly.  If that fails to produce a

login message, consult a guru.


  When you get a llllooooggggiiiinnnn:::: message, type  your  login  name  _i_n

_l_o_w_e_r  _c_a_s_e.   Follow it by a RETURN; the system will not do

anything  until  you  type  a  RETURN.   If  a  password  is

required, you will be asked for it, and (if possible) print-

ing will be turned off while  you  type  it.   Don't  forget

RETURN.


  The culmination of your login efforts is a ``prompt  char-

acter,''  a  single character that indicates that the system

is ready to accept commands from you.  The prompt  character


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                         5


is  usually  a  dollar sign $$$$ or a percent sign %%%%.  (You may

also get a message of the day just before the prompt charac-

ter, or a notification that you have mail.)


_T_y_p_i_n_g _C_o_m_m_a_n_d_s


  Once you've seen the prompt character, you can  type  com-

mands, which are requests that the system do something.  Try

typing


  ddddaaaatttteeee

followed by RETURN.  You should get back something like


  MMMMoooonnnn JJJJaaaannnn 11116666 11114444::::11117777::::11110000 EEEESSSSTTTT 1111999977778888

Don't forget the RETURN after the command, or  nothing  will

happen.   If  you think you're being ignored, type a RETURN;

something should happen.  RETURN won't be  mentioned  again,

but  don't forget it - it has to be there at the end of each

line.


  Another command you might try  is  wwwwhhhhoooo,  which  tells  you

everyone who is currently logged in:


  wwwwhhhhoooo

gives something like


  mmmmbbbb   ttttttttyyyy00001111JJJJaaaannnn 11116666    00009999::::11111111
  sssskkkkiiii  ttttttttyyyy00005555JJJJaaaannnn 11116666    00009999::::33333333
  ggggaaaammmm  ttttttttyyyy11111111JJJJaaaannnn 11116666    11113333::::00007777

The time is when  the  user  logged  in;  ``ttyxx''  is  the

system's idea of what terminal the user is on.




                     November 16, 1985






6                                         _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


  If you make a mistake typing the command name,  and  refer

to  a  non-existent command, you will be told.  For example,

if you type


  wwwwhhhhoooommmm

you will be told


  wwwwhhhhoooommmm:::: nnnnooootttt ffffoooouuuunnnndddd

Of course, if you inadvertently type the name of some  other

command, it will run, with more or less mysterious results.


_S_t_r_a_n_g_e _T_e_r_m_i_n_a_l _B_e_h_a_v_i_o_r


  Sometimes you can get into a  state  where  your  terminal

acts  strangely.   For  example,  each  letter  may be typed

twice, or the RETURN may not cause a line feed or  a  return

to  the  left margin.  You can often fix this by logging out

and logging back in.  Or you can read the description of the

command ssssttttttttyyyy in section I of the manual.  To get intelligent

treatment of tab characters (which are much used in UNIX) if

your terminal doesn't have tabs, type the command


  ssssttttttttyyyy ----ttttaaaabbbbssss

and the system will convert each tab into the  right  number

of  blanks  for  you.   If your terminal does have computer-

settable tabs, the command ttttaaaabbbbssss will set the stops correctly

for you.


_M_i_s_t_a_k_e_s _i_n _T_y_p_i_n_g


  If you make a typing mistake, and see it before RETURN has


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                         7


been  typed,  there  are  two  ways  to recover.  The sharp-

character #### erases the last character typed; in fact succes-

sive uses of #### erase characters back to the beginning of the

line (but not beyond).   So  if  you  type  badly,  you  can

correct as you go:


  dddddddd####aaaatttttttteeee########eeee

is the same as ddddaaaatttteeee.


  The at-sign @@@@ erases all of the characters typed so far on

the  current  input  line,  so  if the line is irretrievably

fouled up, type an @@@@ and start the line over.


  What if you must enter a sharp or at-sign as part  of  the

text?   If  you  precede  either #### or @@@@ by a backslash \\\\, it

loses its erase meaning.  So to enter a sharp or at-sign  in

something,  type  \\\\####  or  \\\\@@@@.  The system will always echo a

newline at you after your at-sign, even  if  preceded  by  a

backslash.  Don't worry - the at-sign has been recorded.


  To erase a backslash, you have to type two sharps  or  two

at-signs,  as  in \\\\########.  The backslash is used extensively in

UNIX to indicate that the following character is in some way

special.


_R_e_a_d-_a_h_e_a_d


  UNIX has full read-ahead, which means that you can type as

fast  as you want, whenever you want, even when some command

is typing at you.  If you type  during  output,  your  input



                     November 16, 1985






8                                         _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


characters  will  appear  intermixed with the output charac-

ters, but they will be stored away and  interpreted  in  the

correct  order.   So you can type several commands one after

another without waiting for the  first  to  finish  or  even

begin.


_S_t_o_p_p_i_n_g _a _P_r_o_g_r_a_m


  You can stop most programs by typing the character ``DEL''

(perhaps  called ``delete'' or ``rubout'' on your terminal).

The ``interrupt'' or ``break'' key found on  most  terminals

can  also be used.  In a few programs, like the text editor,

DEL stops whatever the program is doing but  leaves  you  in

that program.  Hanging up the phone will stop most programs.


_L_o_g_g_i_n_g _O_u_t


  The easiest way to log out is to hang up the  phone.   You

can also type


  llllooooggggiiiinnnn

and let someone else use the terminal you were  on.   It  is

usually  not sufficient just to turn off the terminal.  Most

UNIX systems do not use a time-out mechanism, so  you'll  be

there forever unless you hang up.


_M_a_i_l


  When you log in, you may sometimes get the message


  YYYYoooouuuu hhhhaaaavvvveeee mmmmaaaaiiiillll....



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                         9


UNIX provides a postal system so you  can  communicate  with

other users of the system.  To read your mail, type the com-

mand


  mmmmaaaaiiiillll

Your mail will be printed,  one  message  at  a  time,  most

recent  message  first.   After each message, mmmmaaaaiiiillll waits for

you to say what to do with it.  The two basic responses  are

dddd, which deletes the message, and RETURN, which does not (so

it will still be there the next time you read your mailbox).

Other  responses are described in the manual.  (Earlier ver-

sions of mmmmaaaaiiiillll do not process one message at a time, but  are

otherwise similar.)


  How do you send mail to someone else?  Suppose it is to go

to  ``joe'' (assuming ``joe'' is someone's login name).  The

easiest way is this:


  mmmmaaaaiiiillll jjjjooooeeee
  _n_o_w _t_y_p_e _i_n _t_h_e _t_e_x_t _o_f _t_h_e _l_e_t_t_e_r
  _o_n _a_s _m_a_n_y _l_i_n_e_s _a_s _y_o_u _l_i_k_e ...
  _A_f_t_e_r _t_h_e _l_a_s_t _l_i_n_e _o_f _t_h_e _l_e_t_t_e_r
  _t_y_p_e _t_h_e _c_h_a_r_a_c_t_e_r ``_c_o_n_t_r_o_l-_d'',
  _t_h_a_t _i_s, _h_o_l_d _d_o_w_n ``_c_o_n_t_r_o_l'' _a_n_d _t_y_p_e
  _a _l_e_t_t_e_r ``_d''.

And that's it.  The  ``control-d''  sequence,  often  called

``EOF''  for  end-of-file,  is used throughout the system to

mark the end of input from a terminal, so you might as  well

get used to it.


  For practice, send  mail  to  yourself.   (This  isn't  as

strange  as it might sound - mail to oneself is a handy rem-



                     November 16, 1985






10                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


inder mechanism.)


  There are other ways to send mail - you can send a  previ-

ously  prepared letter, and you can mail to a number of peo-

ple all at once.  For more details see mmmmaaaaiiiillll(1).  (The  nota-

tion mmmmaaaaiiiillll(1) means the command mmmmaaaaiiiillll in section 1 of the _U_N_I_X

_P_r_o_g_r_a_m_m_e_r'_s _M_a_n_u_a_l.)


_W_r_i_t_i_n_g _t_o _o_t_h_e_r _u_s_e_r_s


  At some point, out of the blue will come a message like


  MMMMeeeessssssssaaaaggggeeee ffffrrrroooommmm jjjjooooeeee ttttttttyyyy00007777............

accompanied by a startling beep.  It means that Joe wants to

talk  to  you, but unless you take explicit action you won't

be able to talk back.  To respond, type the command


  wwwwrrrriiiitttteeee jjjjooooeeee

This establishes a two-way communication path.  Now whatever

Joe  types  on  his  terminal  will appear on yours and vice

versa.  The path is slow, rather like talking to  the  moon.

(If you are in the middle of something, you have to get to a

state where you can type a command.  Normally, whatever pro-

gram  you are running has to terminate or be terminated.  If

you're editing, you can escape temporarily from the editor -

read the editor tutorial.)


  A protocol is needed to keep what you  type  from  getting

garbled up with what Joe types. Typically it's like this:





                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        11



  Joe types wwwwrrrriiiitttteeee ssssmmmmiiiitttthhhh and waits.
  Smith types wwwwrrrriiiitttteeee jjjjooooeeee and waits.
  Joe now types his message (as many  lines  as  he  likes).
  When  he's ready for a reply, he signals it by typing ((((oooo)))),
  which stands for ``over''.
  Now Smith types a reply, also terminated by ((((oooo)))).
  This cycle repeats  until  someone  gets  tired;  he  then
  signals  his  intent  to  quit  with  ((((oooooooo)))), for ``over and
  out''.
  To terminate the  conversation,  each  side  must  type  a
  ``control-d''  character alone on a line. (``Delete'' also
  works.) When the other person types his ``control-d'', you
  will get the message EEEEOOOOFFFF on your terminal.



  If you write to  someone  who  isn't  logged  in,  or  who

doesn't want to be disturbed, you'll be told.  If the target

is logged in but doesn't answer  after  a  decent  interval,

simply type ``control-d''.


_O_n-_l_i_n_e _M_a_n_u_a_l


  The _U_N_I_X _P_r_o_g_r_a_m_m_e_r'_s _M_a_n_u_a_l is  typically  kept  on-line.

If  you  get stuck on something, and can't find an expert to

assist you, you can print on your terminal some manual  sec-

tion  that  might help.  This is also useful for getting the

most up-to-date information on a command.  To print a manual

section,  type ``man command-name''.  Thus to read up on the

wwwwhhhhoooo command, type


  mmmmaaaannnn wwwwhhhhoooo

and, of course,


  mmmmaaaannnn mmmmaaaannnn

tells all about the mmmmaaaannnn command.




                     November 16, 1985






12                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


_C_o_m_p_u_t_e_r _A_i_d_e_d _I_n_s_t_r_u_c_t_i_o_n


  Your UNIX system  may  have  available  a  program  called

lllleeeeaaaarrrrnnnn, which provides computer aided instruction on the file

system and basic commands, the editor, document preparation,

and even C programming.  Try typing the command


  lllleeeeaaaarrrrnnnn

If lllleeeeaaaarrrrnnnn exists on your system, it will tell you what to  do

from there.


_I_I.  _D_A_Y-_T_O-_D_A_Y _U_S_E


_C_r_e_a_t_i_n_g _F_i_l_e_s - _T_h_e _E_d_i_t_o_r


  If you have to type a paper or a letter or a program,  how

do  you  get the information stored in the machine?  Most of

these tasks are done  with  the  UNIX  ``text  editor''  eeeedddd.

Since  eeeedddd is thoroughly documented in eeeedddd(1) and explained in

_A _T_u_t_o_r_i_a_l _I_n_t_r_o_d_u_c_t_i_o_n _t_o _t_h_e _U_N_I_X _T_e_x_t  _E_d_i_t_o_r,  we  won't

spend  any  time here describing how to use it.  All we want

it for right now is to make some _f_i_l_e_s.  (A file is  just  a

collection  of information stored in the machine, a simplis-

tic but adequate definition.)


  To create a file called jjjjuuuunnnnkkkk with some text in it, do  the

following:


  eeeedddd jjjjuuuunnnnkkkk(invokes the text editor)
  aaaa     (command to ``ed'', to add text)
  _n_o_w _t_y_p_e _i_n
  _w_h_a_t_e_v_e_r _t_e_x_t _y_o_u _w_a_n_t ...
  ....     (signals the end of adding text)


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        13


The ``....'' that signals the end of adding text must be at the

beginning  of  a line by itself.  Don't forget it, for until

it is typed, no other  eeeedddd  commands  will  be  recognized  -

everything you type will be treated as text to be added.


  At this point you can do various editing operations on the

text  you  typed  in,  such as correcting spelling mistakes,

rearranging paragraphs and  the  like.   Finally,  you  must

write  the  information  you have typed into a file with the

editor command wwww:


  wwww

eeeedddd will respond with the number of characters it wrote  into

the file jjjjuuuunnnnkkkk.


  Until the wwww command, nothing is stored permanently, so  if

you hang up and go home the information is lost.|- But  after

wwww the information is there permanently; you can re-access it

any time by typing


  eeeedddd jjjjuuuunnnnkkkk

Type a qqqq command to quit the editor.  (If you  try  to  quit

without  writing, eeeedddd will print a ???? to remind you.  A second

qqqq gets you out regardless.)


  Now create a second file called tttteeeemmmmpppp in the  same  manner.

You should now have two files, jjjjuuuunnnnkkkk and tttteeeemmmmpppp.
__________________________
|- This is not strictly true -  if  you  hang  up  while
editing,  the  data  you  were working on is saved in a
file called eeeedddd....hhhhuuuupppp, which you can continue with at your
next session.



                     November 16, 1985






14                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


_W_h_a_t _f_i_l_e_s _a_r_e _o_u_t _t_h_e_r_e?


  The llllssss (for ``list'') command lists the  names  (not  con-

tents)  of  any  of the files that UNIX knows about.  If you

type


  llllssss

the response will be


  jjjjuuuunnnnkkkk
  tttteeeemmmmpppp

which are indeed the two files just created.  The names  are

sorted  into  alphabetical  order  automatically,  but other

variations are possible.  For example, the command


  llllssss ----tttt

causes the files to be listed in the  order  in  which  they

were last changed, most recent first.  The ----llll option gives a

``long'' listing:


  llllssss ----llll

will produce something like


  ----rrrrwwww----rrrrwwww----rrrrwwww---- 1111 bbbbwwwwkkkk 44441111 JJJJuuuullll 22222222 2222::::55556666 jjjjuuuunnnnkkkk
  ----rrrrwwww----rrrrwwww----rrrrwwww---- 1111 bbbbwwwwkkkk 77778888 JJJJuuuullll 22222222 2222::::55557777 tttteeeemmmmpppp

The date and time are of the last change to the  file.   The

41  and  78 are the number of characters (which should agree

with the numbers you got from eeeedddd).  bbbbwwwwkkkk is the owner of  the

file,  that  is,  the person who created it.  The ----rrrrwwww----rrrrwwww----rrrrwwww----

tells who has permission to read and write the file, in this

case everyone.



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        15


  Options can be combined: llllssss ----lllltttt gives the  same  thing  as

llllssss ----llll,  but  sorted  into time order.  You can also name the

files you're interested in, and llllssss will list the information

about them only.  More details can be found in llllssss(1).


  The use of optional arguments  that  begin  with  a  minus

sign,  like ----tttt and ----lllltttt, is a common convention for UNIX pro-

grams.  In general, if a program accepts such optional argu-

ments,  they  precede  any  filename  arguments.  It is also

vital that you separate the various arguments  with  spaces:

llllssss----llll is not the same as llllssss  ----llll.


_P_r_i_n_t_i_n_g _F_i_l_e_s


  Now that you've got a file of text, how do you print it so

people can look at it?  There are a host of programs that do

that, probably more than are needed.


  One simple thing is to use the editor, since  printing  is

often done just before making changes anyway.  You can say


  eeeedddd jjjjuuuunnnnkkkk
  1111,,,,$$$$pppp

eeeedddd will reply with the count of the characters in  jjjjuuuunnnnkkkk  and

then  print  all the lines in the file.  After you learn how

to use the editor, you can be selective about the parts  you

print.


  There are times when it's not feasible to use  the  editor

for  printing.   For  example, there is a limit on how big a

file eeeedddd can handle (several thousand lines).   Secondly,  it


                     November 16, 1985






16                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


will  only  print one file at a time, and sometimes you want

to print several, one after another.  So here are  a  couple

of alternatives.


  First is ccccaaaatttt, the simplest of all the  printing  programs.

ccccaaaatttt  simply  prints  on the terminal the contents of all the

files named in a list.  Thus


  ccccaaaatttt jjjjuuuunnnnkkkk

prints one file, and


  ccccaaaatttt jjjjuuuunnnnkkkk tttteeeemmmmpppp

prints two.  The files are simply  concatenated  (hence  the

name ``ccccaaaatttt'') onto the terminal.


  pppprrrr produces formatted printouts of files.  As with ccccaaaatttt, pppprrrr

prints  all  the  files  named in a list.  The difference is

that it produces headings with date, time, page  number  and

file  name  at the top of each page, and extra lines to skip

over the fold in the paper.  Thus,


  pppprrrr jjjjuuuunnnnkkkk tttteeeemmmmpppp

will print jjjjuuuunnnnkkkk neatly, then skip to the top of a  new  page

and print tttteeeemmmmpppp neatly.


  pppprrrr can also produce multi-column output:


  pppprrrr ----3333 jjjjuuuunnnnkkkk

prints jjjjuuuunnnnkkkk in 3-column format.  You can use any  reasonable

number  in  place  of ``3'' and pppprrrr will do its best.  pppprrrr has

other capabilities as well; see pppprrrr(1).


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        17


  It should be noted that pppprrrr is _n_o_t a formatting program  in

the  sense of shuffling lines around and justifying margins.

The true formatters are nnnnrrrrooooffffffff and ttttrrrrooooffffffff, which we  will  get

to in the section on document preparation.


  There are also programs that print files on  a  high-speed

printer.   Look  in your manual under oooopppprrrr and llllpppprrrr.  Which to

use depends on what equipment is attached to your machine.


_S_h_u_f_f_l_i_n_g _F_i_l_e_s _A_b_o_u_t


  Now that you have some files in the file system  and  some

experience in printing them, you can try bigger things.  For

example, you can move a  file  from  one  place  to  another

(which amounts to giving it a new name), like this:


  mmmmvvvv jjjjuuuunnnnkkkk pppprrrreeeecccciiiioooouuuussss

This means that what used  to  be  ``junk''  is  now  ``pre-

cious''.  If you do an llllssss command now, you will get


  pppprrrreeeecccciiiioooouuuussss
  tttteeeemmmmpppp

Beware that if you move a file to another one  that  already

exists, the already existing contents are lost forever.


  If you want to make a _c_o_p_y of a file (that is, to have two

versions of something), you can use the ccccpppp command:


  ccccpppp pppprrrreeeecccciiiioooouuuussss tttteeeemmmmpppp1111

makes a duplicate copy of pppprrrreeeecccciiiioooouuuussss in tttteeeemmmmpppp1111.


  Finally, when you get tired of creating and moving  files,


                     November 16, 1985






18                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


there  is  a  command  to remove files from the file system,

called rrrrmmmm.


  rrrrmmmm tttteeeemmmmpppp tttteeeemmmmpppp1111

will remove both of the files named.


  You will get a warning message if one of the  named  files

wasn't  there,  but  otherwise  rrrrmmmm, like most UNIX commands,

does its work silently.  There is no prompting  or  chatter,

and error messages are occasionally curt.  This terseness is

sometimes disconcerting to newcomers, but experienced  users

find it desirable.


_W_h_a_t'_s _i_n _a _F_i_l_e_n_a_m_e


  So far we have used filenames without ever saying what's a

legal  name,  so  it's  time  for a couple of rules.  First,

filenames are limited to 14 characters, which is  enough  to

be  descriptive.   Second,  although  you can use almost any

character in a filename, common sense says you should  stick

to ones that are visible, and that you should probably avoid

characters that might be used with other meanings.  We  have

already  seen,  for  example,  that in the llllssss command, llllssss ----tttt

means to list in time order.  So if you  had  a  file  whose

name was ----tttt, you would have a tough time listing it by name.

Besides the minus sign, there  are  other  characters  which

have  special meaning.  To avoid pitfalls, you would do well

to use only letters, numbers and  the  period  until  you're

familiar with the situation.



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        19


  On to some more positive suggestions.  Suppose you're typ-

ing  a  large  document like a book.  Logically this divides

into many small pieces, like chapters and perhaps  sections.

Physically  it  must  be divided too, for eeeedddd will not handle

really big files.  Thus you should type the  document  as  a

number  of  files.   You might have a separate file for each

chapter, called


  cccchhhhaaaapppp1111
  cccchhhhaaaapppp2222
  etc...

Or, if each chapter were  broken  into  several  files,  you

might have


  cccchhhhaaaapppp1111....1111
  cccchhhhaaaapppp1111....2222
  cccchhhhaaaapppp1111....3333
  ............
  cccchhhhaaaapppp2222....1111
  cccchhhhaaaapppp2222....2222
  ............

You can now tell at a glance where a  particular  file  fits

into the whole.


  There are advantages to  a  systematic  naming  convention

which  are not obvious to the novice UNIX user.  What if you

wanted to print the whole book?  You could say


  pppprrrr cccchhhhaaaapppp1111....1111 cccchhhhaaaapppp1111....2222 cccchhhhaaaapppp1111....3333 ........................

but you would get tired pretty fast, and would probably even

make  mistakes.   Fortunately, there is a shortcut.  You can

say


  pppprrrr cccchhhhaaaapppp****


                     November 16, 1985






20                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


The **** means ``anything at all,''  so  this  translates  into

``print  all  files whose names begin with cccchhhhaaaapppp'', listed in

alphabetical order.


  This shorthand notation is not a property of the  pppprrrr  com-

mand,  by the way.  It is system-wide, a service of the pro-

gram that interprets commands (the ``shell,'' sssshhhh(1)).  Using

that fact, you can see how to list the names of the files in

the book:


  llllssss cccchhhhaaaapppp****

produces


  cccchhhhaaaapppp1111....1111
  cccchhhhaaaapppp1111....2222
  cccchhhhaaaapppp1111....3333
  ............

The **** is not limited to the last position in a filename - it

can be anywhere and can occur several times.  Thus


  rrrrmmmm ****jjjjuuuunnnnkkkk**** ****tttteeeemmmmpppp****

removes all files that contain jjjjuuuunnnnkkkk or tttteeeemmmmpppp as any  part  of

their  name.   As  a special case, **** by itself matches every

filename, so


  pppprrrr ****

prints all your files (alphabetical order), and


  rrrrmmmm ****

removes _a_l_l _f_i_l_e_s.  (You had better be _v_e_r_y sure that's what

you wanted to say!)




                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        21


  The **** is not the only pattern-matching feature  available.

Suppose  you  want to print only chapters 1 through 4 and 9.

Then you can say


  pppprrrr cccchhhhaaaapppp[[[[11112222333344449999]]]]****

The [[[[............]]]] means to match any of the  characters  inside  the

brackets.   A  range of consecutive letters or digits can be

abbreviated, so you can also do this with


  pppprrrr cccchhhhaaaapppp[[[[1111----44449999]]]]****

Letters can also be used within brackets: [[[[aaaa----zzzz]]]] matches  any

character in the range aaaa through zzzz.


  The ???? pattern matches any single character, so


  llllssss ????

lists all files which have single-character names, and


  llllssss ----llll cccchhhhaaaapppp????....1111

lists information about  the  first  file  of  each  chapter

(cccchhhhaaaapppp1111....1111, cccchhhhaaaapppp2222....1111, etc.).


  Of these niceties, **** is certainly the most useful, and you

should  get  used  to  it.  The others are frills, but worth

knowing.


  If you should ever have to turn off the special meaning of

****, ????, etc., enclose the entire argument in single quotes, as

in


  llllssss ''''????''''



                     November 16, 1985






22                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


We'll see some more examples of this shortly.


_W_h_a_t'_s _i_n _a _F_i_l_e_n_a_m_e, _C_o_n_t_i_n_u_e_d


  When you first made that file called  jjjjuuuunnnnkkkk,  how  did  the

system  know  that there wasn't another jjjjuuuunnnnkkkk somewhere else,

especially since the person in the next office is also read-

ing  this  tutorial?  The answer is that generally each user

has a private _d_i_r_e_c_t_o_r_y, which contains only the files  that

belong  to him.  When you log in, you are ``in'' your direc-

tory.  Unless you take special action, when you create a new

file, it is made in the directory that you are currently in;

this is most often your own directory, and thus the file  is

unrelated  to  any  other  file  of the same name that might

exist in someone else's directory.


  The set of all files is organized  into  a  (usually  big)

tree,  with  your  files  located  several branches into the

tree.  It is possible for you to ``walk'' around this  tree,

and  to find any file in the system, by starting at the root

of the tree and walking along the proper  set  of  branches.

Conversely,  you can start where you are and walk toward the

root.


  Let's try the latter first.  The basic tools is  the  com-

mand  ppppwwwwdddd  (``print  working  directory''), which prints the

name of the directory you are currently in.


  Although the details will vary according to the system you

are on, if you give the command ppppwwwwdddd, it will print something


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        23


like


  ////uuuussssrrrr////yyyyoooouuuurrrr----nnnnaaaammmmeeee

This says that you are currently in the directory yyyyoooouuuurrrr----nnnnaaaammmmeeee,

which  is in turn in the directory ////uuuussssrrrr, which is in turn in

the root directory called by convention just  ////.   (Even  if

it's  not called ////uuuussssrrrr on your system, you will get something

analogous.  Make the corresponding changes and read on.)


  If you now type


  llllssss ////uuuussssrrrr////yyyyoooouuuurrrr----nnnnaaaammmmeeee

you should get exactly the same list of file  names  as  you

get  from  a  plain llllssss: with no arguments, llllssss lists the con-

tents of the current directory; given the name of  a  direc-

tory, it lists the contents of that directory.


  Next, try


  llllssss ////uuuussssrrrr

This should print a long series of  names,  among  which  is

your  own  login  name yyyyoooouuuurrrr----nnnnaaaammmmeeee.  On many systems, uuuussssrrrr is a

directory that contains the directories of  all  the  normal

users of the system, like you.


  The next step is to try


  llllssss ////

You should get a  response  something  like  this  (although

again the details may be different):




                     November 16, 1985






24                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s



  bbbbiiiinnnn
  ddddeeeevvvv
  eeeettttcccc
  lllliiiibbbb
  ttttmmmmpppp
  uuuussssrrrr

This is a collection of the basic directories of files  that

the system knows about; we are at the root of the tree.


  Now try


  ccccaaaatttt ////uuuussssrrrr////yyyyoooouuuurrrr----nnnnaaaammmmeeee////jjjjuuuunnnnkkkk

(if jjjjuuuunnnnkkkk is still around in your directory).  The name


  ////uuuussssrrrr////yyyyoooouuuurrrr----nnnnaaaammmmeeee////jjjjuuuunnnnkkkk

is called the ppppaaaatttthhhhnnnnaaaammmmeeee of the file that you  normally  think

of  as  ``junk''.   ``Pathname''  has an obvious meaning: it

represents the full name of the path you have to follow from

the root through the tree of directories to get to a partic-

ular file.  It is a universal rule in the UNIX  system  that

anywhere  you  can  use  an ordinary filename, you can use a

pathname.


  Here is a picture which may make this clearer:


                            (root)
                            / | \
                           /  |  \
                          /   |   \
                bin    etc    usr    dev   tmp
            / | \   / | \   / | \   / | \   / | \
                           /  |  \
                          /   |   \
                       adam  eve   mary
                   /        /   \        \
                            /     \       junk
                          junk temp



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        25


Notice that Mary's jjjjuuuunnnnkkkk is unrelated to Eve's.


  This isn't too exciting if all the files of  interest  are

in  your own directory, but if you work with someone else or

on several projects concurrently, it becomes  handy  indeed.

For example, your friends can print your book by saying


  pppprrrr ////uuuussssrrrr////yyyyoooouuuurrrr----nnnnaaaammmmeeee////cccchhhhaaaapppp****

Similarly, you can find out what files your neighbor has  by

saying


  llllssss ////uuuussssrrrr////nnnneeeeiiiigggghhhhbbbboooorrrr----nnnnaaaammmmeeee

or make your own copy of one of his files by


  ccccpppp ////uuuussssrrrr////yyyyoooouuuurrrr----nnnneeeeiiiigggghhhhbbbboooorrrr////hhhhiiiissss----ffffiiiilllleeee yyyyoooouuuurrrrffffiiiil
llleeee


  If your neighbor doesn't want you  poking  around  in  his

files,  or  vice  versa, privacy can be arranged.  Each file

and directory has  read-write-execute  permissions  for  the

owner,  a group, and everyone else, which can be set to con-

trol access.  See llllssss(1) and  cccchhhhmmmmoooodddd(1)  for  details.   As  a

matter  of  observed  fact, most users most of the time find

openness of more benefit than privacy.


  As a final experiment with pathnames, try


  llllssss ////bbbbiiiinnnn ////uuuussssrrrr////bbbbiiiinnnn

Do some of the names look familiar?  When you run a program,

by  typing  its  name after the prompt character, the system

simply looks for a file of that  name.   It  normally  looks

first  in  your  directory  (where it typically doesn't find


                     November 16, 1985






26                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


it), then in ////bbbbiiiinnnn and finally in ////uuuussssrrrr////bbbbiiiinnnn.  There is nothing

magic  about  commands like ccccaaaatttt or llllssss, except that they have

been collected into a couple of places to be  easy  to  find

and administer.


  What if you work regularly with  someone  else  on  common

information in his directory?  You could just log in as your

friend each time you want to, but you can also say ``I  want

to  work  on his files instead of my own''.  This is done by

changing the directory that you are currently in:


  ccccdddd ////uuuussssrrrr////yyyyoooouuuurrrr----ffffrrrriiiieeeennnndddd

(On some systems, ccccdddd is spelled cccchhhhddddiiiirrrr.) Now when you  use  a

filename  in something like ccccaaaatttt or pppprrrr, it refers to the file

in your friend's directory.   Changing  directories  doesn't

affect  any  permissions  associated  with  a  file - if you

couldn't access a file from your own directory, changing  to

another  directory won't alter that fact.  Of course, if you

forget what directory you're in, type


  ppppwwwwdddd

to find out.


  It is usually convenient to arrange your own files so that

all  the  files  related  to  one  thing  are in a directory

separate from other projects.  For example, when  you  write

your  book,  you might want to keep all the text in a direc-

tory called bbbbooooooookkkk.  So make one with


  mmmmkkkkddddiiiirrrr bbbbooooooookkkk


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        27


then go to it with


  ccccdddd bbbbooooooookkkk

then start typing  chapters.   The  book  is  now  found  in

(presumably)


  ////uuuussssrrrr////yyyyoooouuuurrrr----nnnnaaaammmmeeee////bbbbooooooookkkk

To remove the directory bbbbooooooookkkk, type


  rrrrmmmm bbbbooooooookkkk////****
  rrrrmmmmddddiiiirrrr bbbbooooooookkkk

The first command removes all files from the directory;  the

second removes the empty directory.


  You can go up one level in the tree of files by saying


  ccccdddd ........

``........'' is the name of the parent of whatever  directory  you

are  currently  in.  For completeness, ``....'' is an alternate

name for the directory you are in.


_U_s_i_n_g _F_i_l_e_s _i_n_s_t_e_a_d _o_f _t_h_e _T_e_r_m_i_n_a_l


  Most of the commands we have seen so far produce output on

the  terminal;  some, like the editor, also take their input

from the terminal.  It is universal in UNIX systems that the

terminal  can  be  replaced  by a file for either or both of

input and output.  As one example,


  llllssss

makes a list of files on your terminal.  But if you say




                     November 16, 1985






28                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s



  llllssss >>>>ffffiiiilllleeeelllliiiisssstttt

a list of your files will be placed  in  the  file  ffffiiiilllleeeelllliiiisssstttt

(which  will  be  created  if  it  doesn't already exist, or

overwritten if it does).  The symbol >>>> means ``put the  out-

put  on  the  following file, rather than on the terminal.''

Nothing is produced on the terminal.   As  another  example,

you  could  combine  several files into one by capturing the

output of ccccaaaatttt in a file:


  ccccaaaatttt ffff1111 ffff2222 ffff3333 >>>>tttteeeemmmmpppp


  The symbol >>>>>>>> operates very much like >>>> does, except  that

it means ``add to the end of.'' That is,


  ccccaaaatttt ffff1111 ffff2222 ffff3333 >>>>>>>>tttteeeemmmmpppp

means to concatenate ffff1111, ffff2222 and ffff3333 to the end of whatever is

already  in  tttteeeemmmmpppp,  instead of overwriting the existing con-

tents.  As with >>>>, if tttteeeemmmmpppp doesn't exist, it will be created

for you.


  In a similar way, the symbol <<<< means to take the input for

a  program from the following file, instead of from the ter-

minal.  Thus, you could make up a script  of  commonly  used

editing  commands  and  put  them into a file called ssssccccrrrriiiipppptttt.

Then you can run the script on a file by saying


  eeeedddd ffffiiiilllleeee <<<<ssssccccrrrriiiipppptttt

As another example, you can use eeeedddd to prepare  a  letter  in

file lllleeeetttt, then send it to several people with



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        29



  mmmmaaaaiiiillll aaaaddddaaaammmm eeeevvvveeee mmmmaaaarrrryyyy jjjjooooeeee <<<<lllleeeetttt


_P_i_p_e_s


  One of the novel contributions of the UNIX system  is  the

idea  of a _p_i_p_e.  A pipe is simply a way to connect the out-

put of one program to the input of another program,  so  the

two run as a sequence of processes - a pipeline.


  For example,


  pppprrrr ffff gggg hhhh

will print the files ffff, gggg, and hhhh, beginning each  on  a  new

page.   Suppose  you  want  them  run together instead.  You

could say


  ccccaaaatttt ffff gggg hhhh >>>>tttteeeemmmmpppp
  pppprrrr <<<<tttteeeemmmmpppp
  rrrrmmmm tttteeeemmmmpppp

but this is more work than necessary.  Clearly what we  want

is  to take the output of ccccaaaatttt and connect it to the input of

pppprrrr.  So let us use a pipe:


  ccccaaaatttt ffff gggg hhhh |||| pppprrrr

The vertical bar |||| means to take the output from ccccaaaatttt,  which

would normally have gone to the terminal, and put it into pppprrrr

to be neatly formatted.


  There are many other examples of pipes.  For example,


  llllssss |||| pppprrrr ----3333

prints a list of your files in three columns.   The  program


                     November 16, 1985






30                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


wwwwcccc  counts  the number of lines, words and characters in its

input,  and  as  we  saw  earlier,  wwwwhhhhoooo  prints  a  list  of

currently-logged on people, one per line.  Thus


  wwwwhhhhoooo |||| wwwwcccc

tells how many people are logged on.  And of course


  llllssss |||| wwwwcccc

counts your files.


  Any program that reads from the terminal can read  from  a

pipe  instead;  any  program that writes on the terminal can

drive a pipe.  You can have as many elements in  a  pipeline

as you wish.


  Many UNIX programs are written  so  that  they  will  take

their  input  from  one  or more files if file arguments are

given; if no arguments are given they  will  read  from  the

terminal,  and  thus  can  be  used in pipelines.  pppprrrr is one

example:


  pppprrrr ----3333 aaaa bbbb cccc

prints files aaaa, bbbb and cccc in order in three columns.  But in


  ccccaaaatttt aaaa bbbb cccc |||| pppprrrr ----3333

pppprrrr prints the information coming down the pipeline, still in

three columns.


_T_h_e _S_h_e_l_l


  We have already mentioned once  or  twice  the  mysterious



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        31


``shell,'' which is in fact sssshhhh(1).  The shell is the program

that interprets what you type as commands and arguments.  It

also   looks  after  translating  ****,  etc.,  into  lists  of

filenames, and <<<<, >>>>, and |||| into changes of input and  output

streams.


  The shell has other capabilities too.   For  example,  you

can run two programs with one command line by separating the

commands with a semicolon; the shell  recognizes  the  semi-

colon and breaks the line into two commands.  Thus


  ddddaaaatttteeee;;;; wwwwhhhhoooo

does both commands before returning with a prompt character.


  You can also have more than one program running _s_i_m_u_l_t_a_n_e_-

_o_u_s_l_y  if you wish.  For example, if you are doing something

time-consuming, like the editor script of  an  earlier  sec-

tion,  and  you  don't  want  to wait around for the results

before starting something else, you can say


  eeeedddd ffffiiiilllleeee <<<<ssssccccrrrriiiipppptttt &&&&

The ampersand at the end of a command line says ``start this

command  running, then take further commands from the termi-

nal immediately,'' that is, don't wait for it  to  complete.

Thus the script will begin, but you can do something else at

the same time.  Of course, to keep the output from interfer-

ing  with  what  you're  doing  on the terminal, it would be

better to say


  eeeedddd ffffiiiilllleeee <<<<ssssccccrrrriiiipppptttt >>>>ssssccccrrrriiiipppptttt....oooouuuutttt &&&&


                     November 16, 1985






32                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


which saves the output lines in a file called ssssccccrrrriiiipppptttt....oooouuuutttt.


  When you initiate a command with  &&&&,  the  system  replies

with  a  number  called the process number, which identifies

the command in case you later want to stop it.  If  you  do,

you can say


  kkkkiiiillllllll pppprrrroooocccceeeessssssss----nnnnuuuummmmbbbbeeeerrrr

If you forget the process number, the command ppppssss  will  tell

you   about  everything  you  have  running.   (If  you  are

desperate, kkkkiiiillllllll 0000 will kill  all  your  processes.)  And  if

you're  curious about other people, ppppssss aaaa will tell you about

_a_l_l programs that are currently running.


  You can say


  ((((ccccoooommmmmmmmaaaannnndddd----1111;;;; ccccoooommmmmmmmaaaannnndddd----2222;;;; ccccoooommmmmmmmaaaannnndddd----3333)))) &&&&

to start three commands in the background, or you can  start

a background pipeline with


  ccccoooommmmmmmmaaaannnndddd----1111 |||| ccccoooommmmmmmmaaaannnndddd----2222 &&&&


  Just as you can tell the editor or some similar program to

take its input from a file instead of from the terminal, you

can tell the shell to read a file  to  get  commands.   (Why

not?  The  shell,  after  all,  is  just a program, albeit a

clever one.) For instance, suppose you want to set  tabs  on

your terminal, and find out the date and who's on the system

every time you log in.  Then you can put the three necessary

commands  (ttttaaaabbbbssss,  ddddaaaatttteeee,  wwwwhhhhoooo)  into  a  file,  let's call it



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        33


ssssttttaaaarrrrttttuuuupppp, and then run it with


  sssshhhh ssssttttaaaarrrrttttuuuupppp

This says to run the shell with the file ssssttttaaaarrrrttttuuuupppp  as  input.

The effect is as if you had typed the contents of ssssttttaaaarrrrttttuuuupppp on

the terminal.


  If this is to be a regular thing, you  can  eliminate  the

need to type sssshhhh: simply type, once only, the command


  cccchhhhmmmmoooodddd ++++xxxx ssssttttaaaarrrrttttuuuupppp

and thereafter you need only say


  ssssttttaaaarrrrttttuuuupppp

to run the sequence of commands.  The cccchhhhmmmmoooodddd(1) command marks

the  file  executable; the shell recognizes this and runs it

as a sequence of commands.


  If you want ssssttttaaaarrrrttttuuuupppp to run automatically  every  time  you

log  in,  create  a  file  in  your  login  directory called

....pppprrrrooooffffiiiilllleeee, and place in it the line ssssttttaaaarrrrttttuuuupppp.  When the  shell

first  gains  control  when  you  log  in,  it looks for the

....pppprrrrooooffffiiiilllleeee file and does whatever commands  it  finds  in  it.

We'll get back to the shell in the section on programming.



_I_I_I. _D_O_C_U_M_E_N_T _P_R_E_P_A_R_A_T_I_O_N


  UNIX systems are used extensively  for  document  prepara-

tion.   There  are  two  major formatting programs, that is,

programs that produce a text with justified  right  margins,



                     November 16, 1985






34                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


automatic page numbering and titling, automatic hyphenation,

and the like.  nnnnrrrrooooffffffff is designed to produce output on termi-

nals  and  line-printers.   ttttrrrrooooffffffff  (pronounced ``tee-roff'')

instead drives a phototypesetter, which produces  very  high

quality  output  on photographic paper.  This paper was for-

matted with ttttrrrrooooffffffff.


_F_o_r_m_a_t_t_i_n_g _P_a_c_k_a_g_e_s


  The basic idea of nnnnrrrrooooffffffff and ttttrrrrooooffffffff is that the text  to  be

formatted  contains  within  it ``formatting commands'' that

indicate in detail how the formatted text is to  look.   For

example, there might be commands that specify how long lines

are, whether to use single or double spacing, and what  run-

ning titles to use on each page.


  Because nnnnrrrrooooffffffff and ttttrrrrooooffffffff are relatively hard  to  learn  to

use  effectively,  several ``packages'' of canned formatting

requests are available to let you specify  paragraphs,  run-

ning titles, footnotes, multi-column output, and so on, with

little effort and without having to learn nnnnrrrrooooffffffff  and  ttttrrrrooooffffffff.

These  packages  take  a  modest  effort  to  learn, but the

rewards for using them are so great that  it  is  time  well

spent.


  In this section, we will  provide  a  hasty  look  at  the

``manuscript''  package  known  as ----mmmmssss.  Formatting requests

typically consist of a period and  two  upper-case  letters,

such  as  ....TTTTLLLL, which is used to introduce a title, or ....PPPPPPPP to



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        35


begin a new paragraph.


  A document is typed so it looks something like this:


  ....TTTTLLLL
  ttttiiiittttlllleeee ooooffff ddddooooccccuuuummmmeeeennnntttt
  ....AAAAUUUU
  aaaauuuutttthhhhoooorrrr nnnnaaaammmmeeee
  ....SSSSHHHH
  sssseeeeccccttttiiiioooonnnn hhhheeeeaaaaddddiiiinnnngggg
  ....PPPPPPPP
  ppppaaaarrrraaaaggggrrrraaaapppphhhh ............
  ....PPPPPPPP
  aaaannnnooootttthhhheeeerrrr ppppaaaarrrraaaaggggrrrraaaapppphhhh ............
  ....SSSSHHHH
  aaaannnnooootttthhhheeeerrrr sssseeeeccccttttiiiioooonnnn hhhheeeeaaaaddddiiiinnnngggg
  ....PPPPPPPP
  eeeettttcccc....

The lines that  begin  with  a  period  are  the  formatting

requests.   For  example, ....PPPPPPPP calls for starting a new para-

graph.  The precise meaning of ....PPPPPPPP depends  on  what  output

device is being used (typesetter or terminal, for instance),

and on what publication the document will  appear  in.   For

example,  ----mmmmssss  normally assumes that a paragraph is preceded

by a space (one line in nnnnrrrrooooffffffff, 1/2 line in ttttrrrrooooffffffff),  and  the

first  word  is indented.  These rules can be changed if you

like, but they are changed by changing the interpretation of

....PPPPPPPP, not by re-typing the document.


  To actually produce a document in  standard  format  using

----mmmmssss, use the command


  ttttrrrrooooffffffff ----mmmmssss ffffiiiilllleeeessss ............

for the typesetter, and


  nnnnrrrrooooffffffff ----mmmmssss ffffiiiilllleeeessss ............



                     November 16, 1985






36                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


for a terminal.  The ----mmmmssss argument tells ttttrrrrooooffffffff and  nnnnrrrrooooffffffff  to

use the manuscript package of formatting requests.


  There are several similar packages;  check  with  a  local

expert  to  determine  which  ones are in common use on your

machine.


_S_u_p_p_o_r_t_i_n_g _T_o_o_l_s


  In addition to the basic formatters, there is  a  host  of

supporting  programs  that  help  with document preparation.

The list in the next few paragraphs is far from complete, so

browse  through  the manual and check with people around you

for other possibilities.


  eeeeqqqqnnnn and nnnneeeeqqqqnnnn let you integrate mathematics into  the  text

of  a  document,  in  an easy-to-learn language that closely

resembles the way you would speak it  aloud.   For  example,

the eeeeqqqqnnnn input


  ssssuuuummmm ffffrrrroooommmm iiii====0000 ttttoooo nnnn xxxx ssssuuuubbbb iiii ~~~~====~~~~ ppppiiii oooovvvveeeerrrr 2222

produces the output



999                         _i_=078_R78_n999 _x_i _=99 278_J9__


9
  The program ttttbbbbllll provides an analogous service for  prepar-

ing tabular material; it does all the computations necessary

to  align  complicated  columns  with  elements  of  varying

widths.




                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        37


  rrrreeeeffffeeeerrrr prepares bibliographic citations from a  data  base,

in  whatever style is defined by the formatting package.  It

looks after all  the  details  of  numbering  references  in

sequence,  filling  in  page and volume numbers, getting the

author's initials and the journal name right, and so on.


  ssssppppeeeellllllll and ttttyyyyppppoooo detect  possible  spelling  mistakes  in  a

document.   ssssppppeeeellllllll works by comparing the words in your docu-

ment to a dictionary, printing those that  are  not  in  the

dictionary.   It  knows  enough  about  English  spelling to

detect plurals and the like, so it does  a  very  good  job.

ttttyyyyppppoooo  looks  for  words  which  are  ``unusual'', and prints

those.  Spelling mistakes tend to be more unusual, and  thus

show up early when the most unusual words are printed first.


  ggggrrrreeeepppp looks through a set of files for lines that contain a

particular  text  pattern  (rather like the editor's context

search does, but on a bunch of files).  For example,


  ggggrrrreeeepppp ''''iiiinnnngggg$$$$'''' cccchhhhaaaapppp****

will find all lines that end with the  letters  iiiinnnngggg  in  the

files  cccchhhhaaaapppp****.   (It  is almost always a good practice to put

single quotes around the pattern you're  searching  for,  in

case  it contains characters like **** or $$$$ that have a special

meaning to the shell.) ggggrrrreeeepppp is often useful for finding  out

in  which of a set of files the misspelled words detected by

ssssppppeeeellllllll are actually located.


  ddddiiiiffffffff prints a list of the differences between  two  files,



                     November 16, 1985






38                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


so  you  can compare two versions of something automatically

(which certainly beats proofreading by hand).


  wwwwcccc counts the words, lines and  characters  in  a  set  of

files.   ttttrrrr translates characters into other characters; for

example it will convert upper to lower case and vice  versa.

This translates upper into lower:


  ttttrrrr AAAA----ZZZZ aaaa----zzzz <<<<iiiinnnnppppuuuutttt >>>>oooouuuuttttppppuuuutttt


  ssssoooorrrrtttt sorts files in a variety of ways; ccccrrrreeeeffff  makes  cross-

references;  ppppttttxxxx  makes a permuted index (keyword-in-context

listing).  sssseeeedddd provides many of the  editing  facilities  of

eeeedddd, but can apply them to arbitrarily long inputs.  aaaawwwwkkkk pro-

vides the ability to do both pattern  matching  and  numeric

computations,  and  to  conveniently  process  fields within

lines.  These programs are for more advanced users, and they

are  not  limited to document preparation.  Put them on your

list of things to learn about.


  Most of these programs are either independently documented

(like  eeeeqqqqnnnn  and  ttttbbbbllll),  or  are sufficiently simple that the

description in the  _U_N_I_X  _P_r_o_g_r_a_m_m_e_r'_s  _M_a_n_u_a_l  is  adequate

explanation.


_H_i_n_t_s _f_o_r _P_r_e_p_a_r_i_n_g _D_o_c_u_m_e_n_t_s


  Most documents go through several  versions  (always  more

than   you  expected)  before  they  are  finally  finished.

Accordingly, you should do whatever possible to make the job



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        39


of changing them easy.


  First, when you do the  purely  mechanical  operations  of

typing, type so that subsequent editing will be easy.  Start

each sentence on a new line.  Make lines  short,  and  break

lines  at  natural  places,  such  as after commas and semi-

colons, rather than  randomly.   Since  most  people  change

documents  by  rewriting  phrases  and  adding, deleting and

rearranging sentences, these precautions simplify any  edit-

ing you have to do later.


  Keep the individual files of a  document  down  to  modest

size,  perhaps  ten  to fifteen thousand characters.  Larger

files edit more slowly, and of course if  you  make  a  dumb

mistake  it's  better  to have clobbered a small file than a

big one.  Split into files  at  natural  boundaries  in  the

document,  for the same reasons that you start each sentence

on a new line.


  The second aspect of making change easy is to  not  commit

yourself to formatting details too early.  One of the advan-

tages of formatting packages like ----mmmmssss is  that  they  permit

you to delay decisions to the last possible moment.  Indeed,

until a document is printed, it is not even decided  whether

it will be typeset or put on a line printer.


  As a rule of thumb, for all but the most trivial jobs, you

should  type  a  document in terms of a set of requests like

....PPPPPPPP, and then define them appropriately, either by using one



                     November 16, 1985






40                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


of  the canned packages (the better way) or by defining your

own nnnnrrrrooooffffffff and ttttrrrrooooffffffff commands.  As long as you  have  entered

the text in some systematic way, it can always be cleaned up

and re-formatted by a judicious combination of editing  com-

mands and request definitions.


_I_V.  _P_R_O_G_R_A_M_M_I_N_G


  There will be no attempt made to teach any of the program-

ming  languages  available  but a few words of advice are in

order.  One of the reasons why the UNIX system is a  produc-

tive programming environment is that there is already a rich

set of tools  available,  and  facilities  like  pipes,  I/O

redirection, and the capabilities of the shell often make it

possible to do a  job  by  pasting  together  programs  that

already exist instead of writing from scratch.


_T_h_e _S_h_e_l_l


  The pipe mechanism lets you  fabricate  quite  complicated

operations out of spare parts that already exist.  For exam-

ple, the first draft of the ssssppppeeeellllllll program was (roughly)


  ccccaaaatttt ............     _c_o_l_l_e_c_t _t_h_e _f_i_l_e_s
  |||| ttttrrrr ............    _p_u_t _e_a_c_h _w_o_r_d _o_n _a _n_e_w _l_i_n_e
  |||| ttttrrrr ............    _d_e_l_e_t_e _p_u_n_c_t_u_a_t_i_o_n, _e_t_c.
  |||| ssssoooorrrrtttt      _i_n_t_o _d_i_c_t_i_o_n_a_r_y _o_r_d_e_r
  |||| uuuunnnniiiiqqqq      _d_i_s_c_a_r_d _d_u_p_l_i_c_a_t_e_s
  |||| ccccoooommmmmmmm      _p_r_i_n_t _w_o_r_d_s _i_n _t_e_x_t
          _b_u_t _n_o_t _i_n _d_i_c_t_i_o_n_a_r_y

More pieces have been added subsequently, but  this  goes  a

long way for such a small effort.




                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        41


  The editor can be made to do things  that  would  normally

require  special programs on other systems.  For example, to

list the first and last lines of each of  a  set  of  files,

such as a book, you could laboriously type


  eeeedddd
  eeee cccchhhhaaaapppp1111....1111
  1111pppp
  $$$$pppp
  eeee cccchhhhaaaapppp1111....2222
  1111pppp
  $$$$pppp
  etc.

But you can do the job much more easily.  One way is to type


  llllssss cccchhhhaaaapppp**** >>>>tttteeeemmmmpppp

to get the list of filenames into a file.   Then  edit  this

file to make the necessary series of editing commands (using

the global commands of eeeedddd), and write it into  ssssccccrrrriiiipppptttt.   Now

the command


  eeeedddd <<<<ssssccccrrrriiiipppptttt

will produce the same output as the laborious  hand  typing.

Alternately (and more easily), you can use the fact that the

shell will perform loops, repeating a set of  commands  over

and over again for a set of arguments:


  ffffoooorrrr iiii iiiinnnn cccchhhhaaaapppp****
  ddddoooo
       eeeedddd $$$$iiii <<<<ssssccccrrrriiiipppptttt
  ddddoooonnnneeee

This sets the shell variable iiii to each file  name  in  turn,

then  does  the  command.   You can type this command at the

terminal, or put it in a file for later execution.



                     November 16, 1985






42                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


_P_r_o_g_r_a_m_m_i_n_g _t_h_e _S_h_e_l_l


  An option often overlooked by newcomers is that the  shell

is  itself  a  programming language, with variables, control

flow (iiiiffff----eeeellllsssseeee, wwwwhhhhiiiilllleeee, ffffoooorrrr, ccccaaaasssseeee), subroutines, and interrupt

handling.  Since there are many building-block programs, you

can sometimes avoid writing a new program merely by  piecing

together  some  of  the  building  blocks with shell command

files.


  We will not go into any details here; examples  and  rules

can  be found in _A_n _I_n_t_r_o_d_u_c_t_i_o_n _t_o _t_h_e _U_N_I_X _S_h_e_l_l, by S. R.

Bourne.


_P_r_o_g_r_a_m_m_i_n_g _i_n _C


  If you are undertaking anything substantial, C is the only

reasonable choice of programming language: everything in the

UNIX system is tuned to it.  The system itself is written in

C, as are most of the programs that run on it.  It is also a

easy language to use once you get started.  C is  introduced

and  fully  described in _T_h_e _C _P_r_o_g_r_a_m_m_i_n_g _L_a_n_g_u_a_g_e by B. W.

Kernighan and D. M. Ritchie (Prentice-Hall, 1978).   Several

sections  of the manual describe the system interfaces, that

is, how you do I/O and similar functions.   Read  _U_N_I_X  _P_r_o_-

_g_r_a_m_m_i_n_g for more complicated things.


  Most input and output in C is best handled with the  stan-

dard I/O library, which provides a set of I/O functions that

exist in compatible  form  on  most  machines  that  have  C


                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        43


compilers.   In  general,  it's wisest to confine the system

interactions in a program to the facilities provided by this

library.


  C programs that don't depend too much on special  features

of UNIX (such as pipes) can be moved to other computers that

have C compilers.  The list of such machines grows daily; in

addition  to  the  original PDP-11, it currently includes at

least Honeywell 6000, IBM 370, Interdata 8/32, Data  General

Nova  and  Eclipse,  HP 2100, Harris /7, VAX 11/780, SEL 86,

and Zilog Z80.  Calls to the standard I/O library will  work

on all of these machines.


  There are a number of supporting programs that go with  C.

lllliiiinnnntttt  checks  C programs for potential portability problems,

and detects errors such as  mismatched  argument  types  and

uninitialized variables.


  For larger programs (anything whose source is on more than

one  file) mmmmaaaakkkkeeee allows you to specify the dependencies among

the source files and the processing steps needed to  make  a

new  version;  it then checks the times that the pieces were

last changed and does the minimal amount of  recompiling  to

create a consistent updated version.


  The debugger aaaaddddbbbb is useful for digging  through  the  dead

bodies  of  C  programs,  but is rather hard to learn to use

effectively.  The most effective  debugging  tool  is  still

careful  thought,  coupled  with  judiciously  placed  print



                     November 16, 1985






44                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


statements.


  The C compiler provides a limited instrumentation service,

so you can find out where programs spend their time and what

parts are worth optimizing.  Compile the routines  with  the

----pppp  option;  after the test run, use pppprrrrooooffff to print an execu-

tion profile.  The command ttttiiiimmmmeeee  will  give  you  the  gross

run-time  statistics  of  a  program, but they are not super

accurate or reproducible.


_O_t_h_e_r _L_a_n_g_u_a_g_e_s


  If you _h_a_v_e to use Fortran, there are  two  possibilities.

You  might  consider Ratfor, which gives you the decent con-

trol structures and free-form input that characterize C, yet

lets you write code that is still portable to other environ-

ments.  Bear in mind that  UNIX  Fortran  tends  to  produce

large  and  relatively  slow-running programs.  Furthermore,

supporting software like aaaaddddbbbb, pppprrrrooooffff, etc., are all  virtually

useless  with Fortran programs.  There may also be a Fortran

77 compiler on your system.  If so, this is a viable  alter-

native  to Ratfor, and has the non-trivial advantage that it

is compatible with C and related programs.  (The Ratfor pro-

cessor and C tools can be used with Fortran 77 too.)


  If your application requires you to translate  a  language

into a set of actions or another language, you are in effect

building a compiler, though probably a small one.   In  that

case,  you should be using the yyyyaaaacccccccc compiler-compiler, which



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        45


helps you develop  a  compiler  quickly.   The  lllleeeexxxx  lexical

analyzer  generator  does  the  same  job  for  the  simpler

languages that can be expressed as regular expressions.   It

can be used by itself, or as a front end to recognize inputs

for a yyyyaaaacccccccc-based program.  Both yyyyaaaacccccccc and  lllleeeexxxx  require  some

sophistication  to  use,  but the initial effort of learning

them can be repaid many times over in programs that are easy

to change later on.


  Most UNIX systems also  make  available  other  languages,

such  as  Algol  68,  APL,  Basic, Lisp, Pascal, and Snobol.

Whether these  are  useful  depends  largely  on  the  local

environment:  if  someone  cares  about the language and has

worked on it, it may be in good shape.  If not, the odds are

strong that it will be more trouble than it's worth.


_V.  _U_N_I_X _R_E_A_D_I_N_G _L_I_S_T


_G_e_n_e_r_a_l:


K. L. Thompson and D.  M.  Ritchie,  _T_h_e  _U_N_I_X  _P_r_o_g_r_a_m_m_e_r'_s

_M_a_n_u_a_l,  Bell  Laboratories,  1978.   Lists commands, system

routines and interfaces,  file  formats,  and  some  of  the

maintenance   procedures.   You  can't  live  without  this,

although you will probably only need to read section 1.


_D_o_c_u_m_e_n_t_s _f_o_r _U_s_e _w_i_t_h _t_h_e _U_N_I_X _T_i_m_e-_s_h_a_r_i_n_g _S_y_s_t_e_m.  Volume

2  of the Programmer's Manual.  This contains more extensive

descriptions of major commands, and tutorials and  reference

manuals.   All  of the papers listed below are in it, as are


                     November 16, 1985






46                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


descriptions of most of the programs mentioned above.


D. M. Ritchie and K. L. Thompson,  ``The  UNIX  Time-sharing

System,''  CACM,  July 1974.  An overview of the system, for

people interested in operating systems.   Worth  reading  by

anyone  who  programs.  Contains a remarkable number of one-

sentence observations on how to do things right.


The Bell System Technical Journal (BSTJ)  Special  Issue  on

UNIX,  July/August,  1978,  contains  many papers describing

recent developments, and some retrospective material.


The 2nd International  Conference  on  Software  Engineering

(October,  1976)  contains several papers describing the use

of the Programmer's Workbench (PWB) version of UNIX.


_D_o_c_u_m_e_n_t _P_r_e_p_a_r_a_t_i_o_n:


B. W. Kernighan, ``A Tutorial Introduction to the UNIX  Text

Editor''  and  ``Advanced  Editing  on  UNIX,'' Bell Labora-

tories, 1978.  Beginners need the introduction; the advanced

material will help you get the most out of the editor.


M. E. Lesk, ``Typing Documents on UNIX,'' Bell Laboratories,

1978.   Describes  the ----mmmmssss macro package, which isolates the

novice from the vagaries of nnnnrrrrooooffffffff and ttttrrrrooooffffffff, and takes  care

of  most  formatting  situations.   If this specific package

isn't available on your system, something  similar  probably

is.  The most likely alternative is the PWB/UNIX macro pack-

age ----mmmmmmmm; see your local guru if you use PWB/UNIX.



                     November 16, 1985






_U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s                                        47


B. W. Kernighan and L. L. Cherry, ``A System for Typesetting

Mathematics,''  Bell  Laboratories  Computing  Science Tech.

Rep. 17.


M. E. Lesk, ``Tbl -  A  Program  to  Format  Tables,''  Bell

Laboratories CSTR 49, 1976.


J. F. Ossanna,  Jr.,  ``NROFF/TROFF  User's  Manual,''  Bell

Laboratories  CSTR  54,  1976.  ttttrrrrooooffffffff is the basic formatter

used  by  ----mmmmssss,  eeeeqqqqnnnn  and  ttttbbbbllll.   The  reference  manual   is

indispensable if you are going to write or maintain these or

similar programs.  But start with:


B. W. Kernighan, ``A TROFF  Tutorial,''  Bell  Laboratories,

1976.  An attempt to unravel the intricacies of ttttrrrrooooffffffff.


_P_r_o_g_r_a_m_m_i_n_g:


B. W.  Kernighan  and  D.  M.  Ritchie,  _T_h_e  _C  _P_r_o_g_r_a_m_m_i_n_g

_L_a_n_g_u_a_g_e,  Prentice-Hall,  1978.  Contains a tutorial intro-

duction, complete discussions of all language features,  and

the reference manual.


B. W. Kernighan and D.  M.  Ritchie,  ``UNIX  Programming,''

Bell  Laboratories,  1978.   Describes how to interface with

the system from C programs: I/O calls, signals, processes.


S. R. Bourne, ``An Introduction to the  UNIX  Shell,''  Bell

Laboratories,  1978.   An  introduction and reference manual

for the Version 7 shell.  Mandatory reading if you intend to

make effective use of the programming power of this shell.


                     November 16, 1985






48                                        _U_N_I_X _f_o_r _B_e_g_i_n_n_e_r_s


S. C. Johnson, ``Yacc  -  Yet  Another  Compiler-Compiler,''

Bell Laboratories CSTR 32, 1978.


M. E. Lesk, ``Lex - A  Lexical  Analyzer  Generator,''  Bell

Laboratories CSTR 39, 1975.


S. C. Johnson, ``Lint, a C Program Checker,''  Bell  Labora-

tories CSTR 65, 1977.


S. I. Feldman, ``MAKE - A Program for  Maintaining  Computer

Programs,'' Bell Laboratories CSTR 57, 1977.


J. F. Maranzano and S. R. Bourne, ``A Tutorial  Introduction

to  ADB,'' Bell Laboratories CSTR 62, 1977.  An introduction

to a powerful but complex debugging tool.


S. I. Feldman and P. J. Weinberger, ``A Portable Fortran  77

Compiler,''  Bell Laboratories, 1978.  A full Fortran 77 for

UNIX systems.


_M_a_y _1_9_7_9





















                     November 16, 1985





                   D O C U M E N T A T I O N   M E N U
                
This menu allows you to access documents about some of the
features of UNIX and this system in general.  Many of the
documents are very long. WARNING - Once the listing starts,
it will not STOP until the whole document has been listed. 
It is recommended that you 'download' the document entitled
BEGIN and study it for a general background of the system.

     Size in bytes      Name of Document
     -------------- -----------------
A    55330              ADVICE.doc 
B    81391              BEGIN.doc 
C   143449              CSH.doc 
D    13599              SECURITY.doc 
E    76644              SETUP.doc 
F    73228              SHELL.doc 
G    83376              SYNOPSIS.doc 
H    68271              UNIX.doc 
I    33799              UUCP_NET.doc 
J    40932              U_IMPL.doc 
K    ?????              List of Usenet Groups
L    88534              List of ARPANET Groups
